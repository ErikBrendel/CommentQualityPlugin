# id;timestamp;commentText;codeText;commentWords;codeWords
DocumentParser -> private static void parseCopyFields(ParseContext context, List<String> copyToFields) throws IOException;1524684173;Creates instances of the fields that the current field should be copied to;private static void parseCopyFields(ParseContext context, List<String> copyToFields) throws IOException {_        if (!context.isWithinCopyTo() && copyToFields.isEmpty() == false) {_            context = context.createCopyToContext()__            for (String field : copyToFields) {_                _                _                ParseContext.Document targetDoc = null__                for (ParseContext.Document doc = context.doc()_ doc != null_ doc = doc.getParent()) {_                    if (field.startsWith(doc.getPrefix())) {_                        targetDoc = doc__                        break__                    }_                }_                assert targetDoc != null__                final ParseContext copyToContext__                if (targetDoc == context.doc()) {_                    copyToContext = context__                } else {_                    copyToContext = context.switchDoc(targetDoc)__                }_                parseCopy(field, copyToContext)__            }_        }_    };creates,instances,of,the,fields,that,the,current,field,should,be,copied,to;private,static,void,parse,copy,fields,parse,context,context,list,string,copy,to,fields,throws,ioexception,if,context,is,within,copy,to,copy,to,fields,is,empty,false,context,context,create,copy,to,context,for,string,field,copy,to,fields,parse,context,document,target,doc,null,for,parse,context,document,doc,context,doc,doc,null,doc,doc,get,parent,if,field,starts,with,doc,get,prefix,target,doc,doc,break,assert,target,doc,null,final,parse,context,copy,to,context,if,target,doc,context,doc,copy,to,context,context,else,copy,to,context,context,switch,doc,target,doc,parse,copy,field,copy,to,context
DocumentParser -> private static void parseCopyFields(ParseContext context, List<String> copyToFields) throws IOException;1531937412;Creates instances of the fields that the current field should be copied to;private static void parseCopyFields(ParseContext context, List<String> copyToFields) throws IOException {_        if (!context.isWithinCopyTo() && copyToFields.isEmpty() == false) {_            context = context.createCopyToContext()__            for (String field : copyToFields) {_                _                _                ParseContext.Document targetDoc = null__                for (ParseContext.Document doc = context.doc()_ doc != null_ doc = doc.getParent()) {_                    if (field.startsWith(doc.getPrefix())) {_                        targetDoc = doc__                        break__                    }_                }_                assert targetDoc != null__                final ParseContext copyToContext__                if (targetDoc == context.doc()) {_                    copyToContext = context__                } else {_                    copyToContext = context.switchDoc(targetDoc)__                }_                parseCopy(field, copyToContext)__            }_        }_    };creates,instances,of,the,fields,that,the,current,field,should,be,copied,to;private,static,void,parse,copy,fields,parse,context,context,list,string,copy,to,fields,throws,ioexception,if,context,is,within,copy,to,copy,to,fields,is,empty,false,context,context,create,copy,to,context,for,string,field,copy,to,fields,parse,context,document,target,doc,null,for,parse,context,document,doc,context,doc,doc,null,doc,doc,get,parent,if,field,starts,with,doc,get,prefix,target,doc,doc,break,assert,target,doc,null,final,parse,context,copy,to,context,if,target,doc,context,doc,copy,to,context,context,else,copy,to,context,context,switch,doc,target,doc,parse,copy,field,copy,to,context
DocumentParser -> private static void parseCopyFields(ParseContext context, List<String> copyToFields) throws IOException;1535723122;Creates instances of the fields that the current field should be copied to;private static void parseCopyFields(ParseContext context, List<String> copyToFields) throws IOException {_        if (!context.isWithinCopyTo() && copyToFields.isEmpty() == false) {_            context = context.createCopyToContext()__            for (String field : copyToFields) {_                _                _                ParseContext.Document targetDoc = null__                for (ParseContext.Document doc = context.doc()_ doc != null_ doc = doc.getParent()) {_                    if (field.startsWith(doc.getPrefix())) {_                        targetDoc = doc__                        break__                    }_                }_                assert targetDoc != null__                final ParseContext copyToContext__                if (targetDoc == context.doc()) {_                    copyToContext = context__                } else {_                    copyToContext = context.switchDoc(targetDoc)__                }_                parseCopy(field, copyToContext)__            }_        }_    };creates,instances,of,the,fields,that,the,current,field,should,be,copied,to;private,static,void,parse,copy,fields,parse,context,context,list,string,copy,to,fields,throws,ioexception,if,context,is,within,copy,to,copy,to,fields,is,empty,false,context,context,create,copy,to,context,for,string,field,copy,to,fields,parse,context,document,target,doc,null,for,parse,context,document,doc,context,doc,doc,null,doc,doc,get,parent,if,field,starts,with,doc,get,prefix,target,doc,doc,break,assert,target,doc,null,final,parse,context,copy,to,context,if,target,doc,context,doc,copy,to,context,context,else,copy,to,context,context,switch,doc,target,doc,parse,copy,field,copy,to,context
DocumentParser -> private static void parseCopyFields(ParseContext context, List<String> copyToFields) throws IOException;1536137328;Creates instances of the fields that the current field should be copied to;private static void parseCopyFields(ParseContext context, List<String> copyToFields) throws IOException {_        if (!context.isWithinCopyTo() && copyToFields.isEmpty() == false) {_            context = context.createCopyToContext()__            for (String field : copyToFields) {_                _                _                ParseContext.Document targetDoc = null__                for (ParseContext.Document doc = context.doc()_ doc != null_ doc = doc.getParent()) {_                    if (field.startsWith(doc.getPrefix())) {_                        targetDoc = doc__                        break__                    }_                }_                assert targetDoc != null__                final ParseContext copyToContext__                if (targetDoc == context.doc()) {_                    copyToContext = context__                } else {_                    copyToContext = context.switchDoc(targetDoc)__                }_                parseCopy(field, copyToContext)__            }_        }_    };creates,instances,of,the,fields,that,the,current,field,should,be,copied,to;private,static,void,parse,copy,fields,parse,context,context,list,string,copy,to,fields,throws,ioexception,if,context,is,within,copy,to,copy,to,fields,is,empty,false,context,context,create,copy,to,context,for,string,field,copy,to,fields,parse,context,document,target,doc,null,for,parse,context,document,doc,context,doc,doc,null,doc,doc,get,parent,if,field,starts,with,doc,get,prefix,target,doc,doc,break,assert,target,doc,null,final,parse,context,copy,to,context,if,target,doc,context,doc,copy,to,context,context,else,copy,to,context,context,switch,doc,target,doc,parse,copy,field,copy,to,context
DocumentParser -> private static void parseCopyFields(ParseContext context, List<String> copyToFields) throws IOException;1537806831;Creates instances of the fields that the current field should be copied to;private static void parseCopyFields(ParseContext context, List<String> copyToFields) throws IOException {_        if (!context.isWithinCopyTo() && copyToFields.isEmpty() == false) {_            context = context.createCopyToContext()__            for (String field : copyToFields) {_                _                _                ParseContext.Document targetDoc = null__                for (ParseContext.Document doc = context.doc()_ doc != null_ doc = doc.getParent()) {_                    if (field.startsWith(doc.getPrefix())) {_                        targetDoc = doc__                        break__                    }_                }_                assert targetDoc != null__                final ParseContext copyToContext__                if (targetDoc == context.doc()) {_                    copyToContext = context__                } else {_                    copyToContext = context.switchDoc(targetDoc)__                }_                parseCopy(field, copyToContext)__            }_        }_    };creates,instances,of,the,fields,that,the,current,field,should,be,copied,to;private,static,void,parse,copy,fields,parse,context,context,list,string,copy,to,fields,throws,ioexception,if,context,is,within,copy,to,copy,to,fields,is,empty,false,context,context,create,copy,to,context,for,string,field,copy,to,fields,parse,context,document,target,doc,null,for,parse,context,document,doc,context,doc,doc,null,doc,doc,get,parent,if,field,starts,with,doc,get,prefix,target,doc,doc,break,assert,target,doc,null,final,parse,context,copy,to,context,if,target,doc,context,doc,copy,to,context,context,else,copy,to,context,context,switch,doc,target,doc,parse,copy,field,copy,to,context
DocumentParser -> private static void parseCopyFields(ParseContext context, List<String> copyToFields) throws IOException;1541008027;Creates instances of the fields that the current field should be copied to;private static void parseCopyFields(ParseContext context, List<String> copyToFields) throws IOException {_        if (!context.isWithinCopyTo() && copyToFields.isEmpty() == false) {_            context = context.createCopyToContext()__            for (String field : copyToFields) {_                _                _                ParseContext.Document targetDoc = null__                for (ParseContext.Document doc = context.doc()_ doc != null_ doc = doc.getParent()) {_                    if (field.startsWith(doc.getPrefix())) {_                        targetDoc = doc__                        break__                    }_                }_                assert targetDoc != null__                final ParseContext copyToContext__                if (targetDoc == context.doc()) {_                    copyToContext = context__                } else {_                    copyToContext = context.switchDoc(targetDoc)__                }_                parseCopy(field, copyToContext)__            }_        }_    };creates,instances,of,the,fields,that,the,current,field,should,be,copied,to;private,static,void,parse,copy,fields,parse,context,context,list,string,copy,to,fields,throws,ioexception,if,context,is,within,copy,to,copy,to,fields,is,empty,false,context,context,create,copy,to,context,for,string,field,copy,to,fields,parse,context,document,target,doc,null,for,parse,context,document,doc,context,doc,doc,null,doc,doc,get,parent,if,field,starts,with,doc,get,prefix,target,doc,doc,break,assert,target,doc,null,final,parse,context,copy,to,context,if,target,doc,context,doc,copy,to,context,context,else,copy,to,context,context,switch,doc,target,doc,parse,copy,field,copy,to,context
DocumentParser -> private static void parseCopyFields(ParseContext context, List<String> copyToFields) throws IOException;1542982526;Creates instances of the fields that the current field should be copied to;private static void parseCopyFields(ParseContext context, List<String> copyToFields) throws IOException {_        if (!context.isWithinCopyTo() && copyToFields.isEmpty() == false) {_            context = context.createCopyToContext()__            for (String field : copyToFields) {_                _                _                ParseContext.Document targetDoc = null__                for (ParseContext.Document doc = context.doc()_ doc != null_ doc = doc.getParent()) {_                    if (field.startsWith(doc.getPrefix())) {_                        targetDoc = doc__                        break__                    }_                }_                assert targetDoc != null__                final ParseContext copyToContext__                if (targetDoc == context.doc()) {_                    copyToContext = context__                } else {_                    copyToContext = context.switchDoc(targetDoc)__                }_                parseCopy(field, copyToContext)__            }_        }_    };creates,instances,of,the,fields,that,the,current,field,should,be,copied,to;private,static,void,parse,copy,fields,parse,context,context,list,string,copy,to,fields,throws,ioexception,if,context,is,within,copy,to,copy,to,fields,is,empty,false,context,context,create,copy,to,context,for,string,field,copy,to,fields,parse,context,document,target,doc,null,for,parse,context,document,doc,context,doc,doc,null,doc,doc,get,parent,if,field,starts,with,doc,get,prefix,target,doc,doc,break,assert,target,doc,null,final,parse,context,copy,to,context,if,target,doc,context,doc,copy,to,context,context,else,copy,to,context,context,switch,doc,target,doc,parse,copy,field,copy,to,context
DocumentParser -> private static void parseCopyFields(ParseContext context, List<String> copyToFields) throws IOException;1543947737;Creates instances of the fields that the current field should be copied to;private static void parseCopyFields(ParseContext context, List<String> copyToFields) throws IOException {_        if (!context.isWithinCopyTo() && copyToFields.isEmpty() == false) {_            context = context.createCopyToContext()__            for (String field : copyToFields) {_                _                _                ParseContext.Document targetDoc = null__                for (ParseContext.Document doc = context.doc()_ doc != null_ doc = doc.getParent()) {_                    if (field.startsWith(doc.getPrefix())) {_                        targetDoc = doc__                        break__                    }_                }_                assert targetDoc != null__                final ParseContext copyToContext__                if (targetDoc == context.doc()) {_                    copyToContext = context__                } else {_                    copyToContext = context.switchDoc(targetDoc)__                }_                parseCopy(field, copyToContext)__            }_        }_    };creates,instances,of,the,fields,that,the,current,field,should,be,copied,to;private,static,void,parse,copy,fields,parse,context,context,list,string,copy,to,fields,throws,ioexception,if,context,is,within,copy,to,copy,to,fields,is,empty,false,context,context,create,copy,to,context,for,string,field,copy,to,fields,parse,context,document,target,doc,null,for,parse,context,document,doc,context,doc,doc,null,doc,doc,get,parent,if,field,starts,with,doc,get,prefix,target,doc,doc,break,assert,target,doc,null,final,parse,context,copy,to,context,if,target,doc,context,doc,copy,to,context,context,else,copy,to,context,context,switch,doc,target,doc,parse,copy,field,copy,to,context
DocumentParser -> private static void parseCopyFields(ParseContext context, List<String> copyToFields) throws IOException;1544232221;Creates instances of the fields that the current field should be copied to;private static void parseCopyFields(ParseContext context, List<String> copyToFields) throws IOException {_        if (!context.isWithinCopyTo() && copyToFields.isEmpty() == false) {_            context = context.createCopyToContext()__            for (String field : copyToFields) {_                _                _                ParseContext.Document targetDoc = null__                for (ParseContext.Document doc = context.doc()_ doc != null_ doc = doc.getParent()) {_                    if (field.startsWith(doc.getPrefix())) {_                        targetDoc = doc__                        break__                    }_                }_                assert targetDoc != null__                final ParseContext copyToContext__                if (targetDoc == context.doc()) {_                    copyToContext = context__                } else {_                    copyToContext = context.switchDoc(targetDoc)__                }_                parseCopy(field, copyToContext)__            }_        }_    };creates,instances,of,the,fields,that,the,current,field,should,be,copied,to;private,static,void,parse,copy,fields,parse,context,context,list,string,copy,to,fields,throws,ioexception,if,context,is,within,copy,to,copy,to,fields,is,empty,false,context,context,create,copy,to,context,for,string,field,copy,to,fields,parse,context,document,target,doc,null,for,parse,context,document,doc,context,doc,doc,null,doc,doc,get,parent,if,field,starts,with,doc,get,prefix,target,doc,doc,break,assert,target,doc,null,final,parse,context,copy,to,context,if,target,doc,context,doc,copy,to,context,context,else,copy,to,context,context,switch,doc,target,doc,parse,copy,field,copy,to,context
DocumentParser -> private static void parseCopyFields(ParseContext context, List<String> copyToFields) throws IOException;1544458001;Creates instances of the fields that the current field should be copied to;private static void parseCopyFields(ParseContext context, List<String> copyToFields) throws IOException {_        if (!context.isWithinCopyTo() && copyToFields.isEmpty() == false) {_            context = context.createCopyToContext()__            for (String field : copyToFields) {_                _                _                ParseContext.Document targetDoc = null__                for (ParseContext.Document doc = context.doc()_ doc != null_ doc = doc.getParent()) {_                    if (field.startsWith(doc.getPrefix())) {_                        targetDoc = doc__                        break__                    }_                }_                assert targetDoc != null__                final ParseContext copyToContext__                if (targetDoc == context.doc()) {_                    copyToContext = context__                } else {_                    copyToContext = context.switchDoc(targetDoc)__                }_                parseCopy(field, copyToContext)__            }_        }_    };creates,instances,of,the,fields,that,the,current,field,should,be,copied,to;private,static,void,parse,copy,fields,parse,context,context,list,string,copy,to,fields,throws,ioexception,if,context,is,within,copy,to,copy,to,fields,is,empty,false,context,context,create,copy,to,context,for,string,field,copy,to,fields,parse,context,document,target,doc,null,for,parse,context,document,doc,context,doc,doc,null,doc,doc,get,parent,if,field,starts,with,doc,get,prefix,target,doc,doc,break,assert,target,doc,null,final,parse,context,copy,to,context,if,target,doc,context,doc,copy,to,context,context,else,copy,to,context,context,switch,doc,target,doc,parse,copy,field,copy,to,context
DocumentParser -> private static void parseCopyFields(ParseContext context, List<String> copyToFields) throws IOException;1548236405;Creates instances of the fields that the current field should be copied to;private static void parseCopyFields(ParseContext context, List<String> copyToFields) throws IOException {_        if (!context.isWithinCopyTo() && copyToFields.isEmpty() == false) {_            context = context.createCopyToContext()__            for (String field : copyToFields) {_                _                _                ParseContext.Document targetDoc = null__                for (ParseContext.Document doc = context.doc()_ doc != null_ doc = doc.getParent()) {_                    if (field.startsWith(doc.getPrefix())) {_                        targetDoc = doc__                        break__                    }_                }_                assert targetDoc != null__                final ParseContext copyToContext__                if (targetDoc == context.doc()) {_                    copyToContext = context__                } else {_                    copyToContext = context.switchDoc(targetDoc)__                }_                parseCopy(field, copyToContext)__            }_        }_    };creates,instances,of,the,fields,that,the,current,field,should,be,copied,to;private,static,void,parse,copy,fields,parse,context,context,list,string,copy,to,fields,throws,ioexception,if,context,is,within,copy,to,copy,to,fields,is,empty,false,context,context,create,copy,to,context,for,string,field,copy,to,fields,parse,context,document,target,doc,null,for,parse,context,document,doc,context,doc,doc,null,doc,doc,get,parent,if,field,starts,with,doc,get,prefix,target,doc,doc,break,assert,target,doc,null,final,parse,context,copy,to,context,if,target,doc,context,doc,copy,to,context,context,else,copy,to,context,context,switch,doc,target,doc,parse,copy,field,copy,to,context
DocumentParser -> private static ObjectMapper createUpdate(ObjectMapper parent, String[] nameParts, int i, Mapper mapper);1524684173;Build an update for the parent which will contain the given mapper and any intermediate fields.;private static ObjectMapper createUpdate(ObjectMapper parent, String[] nameParts, int i, Mapper mapper) {_        List<ObjectMapper> parentMappers = new ArrayList<>()__        ObjectMapper previousIntermediate = parent__        for (_ i < nameParts.length - 1_ ++i) {_            Mapper intermediate = previousIntermediate.getMapper(nameParts[i])__            assert intermediate != null : "Field " + previousIntermediate.name() + " does not have a subfield " + nameParts[i]__            assert intermediate instanceof ObjectMapper__            parentMappers.add((ObjectMapper)intermediate)__            previousIntermediate = (ObjectMapper)intermediate__        }_        if (parentMappers.isEmpty() == false) {_            _            addToLastMapper(parentMappers, mapper, false)__            popMappers(parentMappers, 1, false)__            mapper = parentMappers.get(0)__        }_        return parent.mappingUpdate(mapper)__    };build,an,update,for,the,parent,which,will,contain,the,given,mapper,and,any,intermediate,fields;private,static,object,mapper,create,update,object,mapper,parent,string,name,parts,int,i,mapper,mapper,list,object,mapper,parent,mappers,new,array,list,object,mapper,previous,intermediate,parent,for,i,name,parts,length,1,i,mapper,intermediate,previous,intermediate,get,mapper,name,parts,i,assert,intermediate,null,field,previous,intermediate,name,does,not,have,a,subfield,name,parts,i,assert,intermediate,instanceof,object,mapper,parent,mappers,add,object,mapper,intermediate,previous,intermediate,object,mapper,intermediate,if,parent,mappers,is,empty,false,add,to,last,mapper,parent,mappers,mapper,false,pop,mappers,parent,mappers,1,false,mapper,parent,mappers,get,0,return,parent,mapping,update,mapper
DocumentParser -> private static ObjectMapper createUpdate(ObjectMapper parent, String[] nameParts, int i, Mapper mapper);1531937412;Build an update for the parent which will contain the given mapper and any intermediate fields.;private static ObjectMapper createUpdate(ObjectMapper parent, String[] nameParts, int i, Mapper mapper) {_        List<ObjectMapper> parentMappers = new ArrayList<>()__        ObjectMapper previousIntermediate = parent__        for (_ i < nameParts.length - 1_ ++i) {_            Mapper intermediate = previousIntermediate.getMapper(nameParts[i])__            assert intermediate != null : "Field " + previousIntermediate.name() + " does not have a subfield " + nameParts[i]__            assert intermediate instanceof ObjectMapper__            parentMappers.add((ObjectMapper)intermediate)__            previousIntermediate = (ObjectMapper)intermediate__        }_        if (parentMappers.isEmpty() == false) {_            _            addToLastMapper(parentMappers, mapper, false)__            popMappers(parentMappers, 1, false)__            mapper = parentMappers.get(0)__        }_        return parent.mappingUpdate(mapper)__    };build,an,update,for,the,parent,which,will,contain,the,given,mapper,and,any,intermediate,fields;private,static,object,mapper,create,update,object,mapper,parent,string,name,parts,int,i,mapper,mapper,list,object,mapper,parent,mappers,new,array,list,object,mapper,previous,intermediate,parent,for,i,name,parts,length,1,i,mapper,intermediate,previous,intermediate,get,mapper,name,parts,i,assert,intermediate,null,field,previous,intermediate,name,does,not,have,a,subfield,name,parts,i,assert,intermediate,instanceof,object,mapper,parent,mappers,add,object,mapper,intermediate,previous,intermediate,object,mapper,intermediate,if,parent,mappers,is,empty,false,add,to,last,mapper,parent,mappers,mapper,false,pop,mappers,parent,mappers,1,false,mapper,parent,mappers,get,0,return,parent,mapping,update,mapper
DocumentParser -> private static ObjectMapper createUpdate(ObjectMapper parent, String[] nameParts, int i, Mapper mapper);1535723122;Build an update for the parent which will contain the given mapper and any intermediate fields.;private static ObjectMapper createUpdate(ObjectMapper parent, String[] nameParts, int i, Mapper mapper) {_        List<ObjectMapper> parentMappers = new ArrayList<>()__        ObjectMapper previousIntermediate = parent__        for (_ i < nameParts.length - 1_ ++i) {_            Mapper intermediate = previousIntermediate.getMapper(nameParts[i])__            assert intermediate != null : "Field " + previousIntermediate.name() + " does not have a subfield " + nameParts[i]__            assert intermediate instanceof ObjectMapper__            parentMappers.add((ObjectMapper)intermediate)__            previousIntermediate = (ObjectMapper)intermediate__        }_        if (parentMappers.isEmpty() == false) {_            _            addToLastMapper(parentMappers, mapper, false)__            popMappers(parentMappers, 1, false)__            mapper = parentMappers.get(0)__        }_        return parent.mappingUpdate(mapper)__    };build,an,update,for,the,parent,which,will,contain,the,given,mapper,and,any,intermediate,fields;private,static,object,mapper,create,update,object,mapper,parent,string,name,parts,int,i,mapper,mapper,list,object,mapper,parent,mappers,new,array,list,object,mapper,previous,intermediate,parent,for,i,name,parts,length,1,i,mapper,intermediate,previous,intermediate,get,mapper,name,parts,i,assert,intermediate,null,field,previous,intermediate,name,does,not,have,a,subfield,name,parts,i,assert,intermediate,instanceof,object,mapper,parent,mappers,add,object,mapper,intermediate,previous,intermediate,object,mapper,intermediate,if,parent,mappers,is,empty,false,add,to,last,mapper,parent,mappers,mapper,false,pop,mappers,parent,mappers,1,false,mapper,parent,mappers,get,0,return,parent,mapping,update,mapper
DocumentParser -> private static ObjectMapper createUpdate(ObjectMapper parent, String[] nameParts, int i, Mapper mapper);1536137328;Build an update for the parent which will contain the given mapper and any intermediate fields.;private static ObjectMapper createUpdate(ObjectMapper parent, String[] nameParts, int i, Mapper mapper) {_        List<ObjectMapper> parentMappers = new ArrayList<>()__        ObjectMapper previousIntermediate = parent__        for (_ i < nameParts.length - 1_ ++i) {_            Mapper intermediate = previousIntermediate.getMapper(nameParts[i])__            assert intermediate != null : "Field " + previousIntermediate.name() + " does not have a subfield " + nameParts[i]__            assert intermediate instanceof ObjectMapper__            parentMappers.add((ObjectMapper)intermediate)__            previousIntermediate = (ObjectMapper)intermediate__        }_        if (parentMappers.isEmpty() == false) {_            _            addToLastMapper(parentMappers, mapper, false)__            popMappers(parentMappers, 1, false)__            mapper = parentMappers.get(0)__        }_        return parent.mappingUpdate(mapper)__    };build,an,update,for,the,parent,which,will,contain,the,given,mapper,and,any,intermediate,fields;private,static,object,mapper,create,update,object,mapper,parent,string,name,parts,int,i,mapper,mapper,list,object,mapper,parent,mappers,new,array,list,object,mapper,previous,intermediate,parent,for,i,name,parts,length,1,i,mapper,intermediate,previous,intermediate,get,mapper,name,parts,i,assert,intermediate,null,field,previous,intermediate,name,does,not,have,a,subfield,name,parts,i,assert,intermediate,instanceof,object,mapper,parent,mappers,add,object,mapper,intermediate,previous,intermediate,object,mapper,intermediate,if,parent,mappers,is,empty,false,add,to,last,mapper,parent,mappers,mapper,false,pop,mappers,parent,mappers,1,false,mapper,parent,mappers,get,0,return,parent,mapping,update,mapper
DocumentParser -> private static ObjectMapper createUpdate(ObjectMapper parent, String[] nameParts, int i, Mapper mapper);1537806831;Build an update for the parent which will contain the given mapper and any intermediate fields.;private static ObjectMapper createUpdate(ObjectMapper parent, String[] nameParts, int i, Mapper mapper) {_        List<ObjectMapper> parentMappers = new ArrayList<>()__        ObjectMapper previousIntermediate = parent__        for (_ i < nameParts.length - 1_ ++i) {_            Mapper intermediate = previousIntermediate.getMapper(nameParts[i])__            assert intermediate != null : "Field " + previousIntermediate.name() + " does not have a subfield " + nameParts[i]__            assert intermediate instanceof ObjectMapper__            parentMappers.add((ObjectMapper)intermediate)__            previousIntermediate = (ObjectMapper)intermediate__        }_        if (parentMappers.isEmpty() == false) {_            _            addToLastMapper(parentMappers, mapper, false)__            popMappers(parentMappers, 1, false)__            mapper = parentMappers.get(0)__        }_        return parent.mappingUpdate(mapper)__    };build,an,update,for,the,parent,which,will,contain,the,given,mapper,and,any,intermediate,fields;private,static,object,mapper,create,update,object,mapper,parent,string,name,parts,int,i,mapper,mapper,list,object,mapper,parent,mappers,new,array,list,object,mapper,previous,intermediate,parent,for,i,name,parts,length,1,i,mapper,intermediate,previous,intermediate,get,mapper,name,parts,i,assert,intermediate,null,field,previous,intermediate,name,does,not,have,a,subfield,name,parts,i,assert,intermediate,instanceof,object,mapper,parent,mappers,add,object,mapper,intermediate,previous,intermediate,object,mapper,intermediate,if,parent,mappers,is,empty,false,add,to,last,mapper,parent,mappers,mapper,false,pop,mappers,parent,mappers,1,false,mapper,parent,mappers,get,0,return,parent,mapping,update,mapper
DocumentParser -> private static ObjectMapper createUpdate(ObjectMapper parent, String[] nameParts, int i, Mapper mapper);1541008027;Build an update for the parent which will contain the given mapper and any intermediate fields.;private static ObjectMapper createUpdate(ObjectMapper parent, String[] nameParts, int i, Mapper mapper) {_        List<ObjectMapper> parentMappers = new ArrayList<>()__        ObjectMapper previousIntermediate = parent__        for (_ i < nameParts.length - 1_ ++i) {_            Mapper intermediate = previousIntermediate.getMapper(nameParts[i])__            assert intermediate != null : "Field " + previousIntermediate.name() + " does not have a subfield " + nameParts[i]__            assert intermediate instanceof ObjectMapper__            parentMappers.add((ObjectMapper)intermediate)__            previousIntermediate = (ObjectMapper)intermediate__        }_        if (parentMappers.isEmpty() == false) {_            _            addToLastMapper(parentMappers, mapper, false)__            popMappers(parentMappers, 1, false)__            mapper = parentMappers.get(0)__        }_        return parent.mappingUpdate(mapper)__    };build,an,update,for,the,parent,which,will,contain,the,given,mapper,and,any,intermediate,fields;private,static,object,mapper,create,update,object,mapper,parent,string,name,parts,int,i,mapper,mapper,list,object,mapper,parent,mappers,new,array,list,object,mapper,previous,intermediate,parent,for,i,name,parts,length,1,i,mapper,intermediate,previous,intermediate,get,mapper,name,parts,i,assert,intermediate,null,field,previous,intermediate,name,does,not,have,a,subfield,name,parts,i,assert,intermediate,instanceof,object,mapper,parent,mappers,add,object,mapper,intermediate,previous,intermediate,object,mapper,intermediate,if,parent,mappers,is,empty,false,add,to,last,mapper,parent,mappers,mapper,false,pop,mappers,parent,mappers,1,false,mapper,parent,mappers,get,0,return,parent,mapping,update,mapper
DocumentParser -> private static ObjectMapper createUpdate(ObjectMapper parent, String[] nameParts, int i, Mapper mapper);1542982526;Build an update for the parent which will contain the given mapper and any intermediate fields.;private static ObjectMapper createUpdate(ObjectMapper parent, String[] nameParts, int i, Mapper mapper) {_        List<ObjectMapper> parentMappers = new ArrayList<>()__        ObjectMapper previousIntermediate = parent__        for (_ i < nameParts.length - 1_ ++i) {_            Mapper intermediate = previousIntermediate.getMapper(nameParts[i])__            assert intermediate != null : "Field " + previousIntermediate.name() + " does not have a subfield " + nameParts[i]__            assert intermediate instanceof ObjectMapper__            parentMappers.add((ObjectMapper)intermediate)__            previousIntermediate = (ObjectMapper)intermediate__        }_        if (parentMappers.isEmpty() == false) {_            _            addToLastMapper(parentMappers, mapper, false)__            popMappers(parentMappers, 1, false)__            mapper = parentMappers.get(0)__        }_        return parent.mappingUpdate(mapper)__    };build,an,update,for,the,parent,which,will,contain,the,given,mapper,and,any,intermediate,fields;private,static,object,mapper,create,update,object,mapper,parent,string,name,parts,int,i,mapper,mapper,list,object,mapper,parent,mappers,new,array,list,object,mapper,previous,intermediate,parent,for,i,name,parts,length,1,i,mapper,intermediate,previous,intermediate,get,mapper,name,parts,i,assert,intermediate,null,field,previous,intermediate,name,does,not,have,a,subfield,name,parts,i,assert,intermediate,instanceof,object,mapper,parent,mappers,add,object,mapper,intermediate,previous,intermediate,object,mapper,intermediate,if,parent,mappers,is,empty,false,add,to,last,mapper,parent,mappers,mapper,false,pop,mappers,parent,mappers,1,false,mapper,parent,mappers,get,0,return,parent,mapping,update,mapper
DocumentParser -> private static ObjectMapper createUpdate(ObjectMapper parent, String[] nameParts, int i, Mapper mapper);1543947737;Build an update for the parent which will contain the given mapper and any intermediate fields.;private static ObjectMapper createUpdate(ObjectMapper parent, String[] nameParts, int i, Mapper mapper) {_        List<ObjectMapper> parentMappers = new ArrayList<>()__        ObjectMapper previousIntermediate = parent__        for (_ i < nameParts.length - 1_ ++i) {_            Mapper intermediate = previousIntermediate.getMapper(nameParts[i])__            assert intermediate != null : "Field " + previousIntermediate.name() + " does not have a subfield " + nameParts[i]__            assert intermediate instanceof ObjectMapper__            parentMappers.add((ObjectMapper)intermediate)__            previousIntermediate = (ObjectMapper)intermediate__        }_        if (parentMappers.isEmpty() == false) {_            _            addToLastMapper(parentMappers, mapper, false)__            popMappers(parentMappers, 1, false)__            mapper = parentMappers.get(0)__        }_        return parent.mappingUpdate(mapper)__    };build,an,update,for,the,parent,which,will,contain,the,given,mapper,and,any,intermediate,fields;private,static,object,mapper,create,update,object,mapper,parent,string,name,parts,int,i,mapper,mapper,list,object,mapper,parent,mappers,new,array,list,object,mapper,previous,intermediate,parent,for,i,name,parts,length,1,i,mapper,intermediate,previous,intermediate,get,mapper,name,parts,i,assert,intermediate,null,field,previous,intermediate,name,does,not,have,a,subfield,name,parts,i,assert,intermediate,instanceof,object,mapper,parent,mappers,add,object,mapper,intermediate,previous,intermediate,object,mapper,intermediate,if,parent,mappers,is,empty,false,add,to,last,mapper,parent,mappers,mapper,false,pop,mappers,parent,mappers,1,false,mapper,parent,mappers,get,0,return,parent,mapping,update,mapper
DocumentParser -> private static ObjectMapper createUpdate(ObjectMapper parent, String[] nameParts, int i, Mapper mapper);1544232221;Build an update for the parent which will contain the given mapper and any intermediate fields.;private static ObjectMapper createUpdate(ObjectMapper parent, String[] nameParts, int i, Mapper mapper) {_        List<ObjectMapper> parentMappers = new ArrayList<>()__        ObjectMapper previousIntermediate = parent__        for (_ i < nameParts.length - 1_ ++i) {_            Mapper intermediate = previousIntermediate.getMapper(nameParts[i])__            assert intermediate != null : "Field " + previousIntermediate.name() + " does not have a subfield " + nameParts[i]__            assert intermediate instanceof ObjectMapper__            parentMappers.add((ObjectMapper)intermediate)__            previousIntermediate = (ObjectMapper)intermediate__        }_        if (parentMappers.isEmpty() == false) {_            _            addToLastMapper(parentMappers, mapper, false)__            popMappers(parentMappers, 1, false)__            mapper = parentMappers.get(0)__        }_        return parent.mappingUpdate(mapper)__    };build,an,update,for,the,parent,which,will,contain,the,given,mapper,and,any,intermediate,fields;private,static,object,mapper,create,update,object,mapper,parent,string,name,parts,int,i,mapper,mapper,list,object,mapper,parent,mappers,new,array,list,object,mapper,previous,intermediate,parent,for,i,name,parts,length,1,i,mapper,intermediate,previous,intermediate,get,mapper,name,parts,i,assert,intermediate,null,field,previous,intermediate,name,does,not,have,a,subfield,name,parts,i,assert,intermediate,instanceof,object,mapper,parent,mappers,add,object,mapper,intermediate,previous,intermediate,object,mapper,intermediate,if,parent,mappers,is,empty,false,add,to,last,mapper,parent,mappers,mapper,false,pop,mappers,parent,mappers,1,false,mapper,parent,mappers,get,0,return,parent,mapping,update,mapper
DocumentParser -> private static ObjectMapper createUpdate(ObjectMapper parent, String[] nameParts, int i, Mapper mapper);1544458001;Build an update for the parent which will contain the given mapper and any intermediate fields.;private static ObjectMapper createUpdate(ObjectMapper parent, String[] nameParts, int i, Mapper mapper) {_        List<ObjectMapper> parentMappers = new ArrayList<>()__        ObjectMapper previousIntermediate = parent__        for (_ i < nameParts.length - 1_ ++i) {_            Mapper intermediate = previousIntermediate.getMapper(nameParts[i])__            assert intermediate != null : "Field " + previousIntermediate.name() + " does not have a subfield " + nameParts[i]__            assert intermediate instanceof ObjectMapper__            parentMappers.add((ObjectMapper)intermediate)__            previousIntermediate = (ObjectMapper)intermediate__        }_        if (parentMappers.isEmpty() == false) {_            _            addToLastMapper(parentMappers, mapper, false)__            popMappers(parentMappers, 1, false)__            mapper = parentMappers.get(0)__        }_        return parent.mappingUpdate(mapper)__    };build,an,update,for,the,parent,which,will,contain,the,given,mapper,and,any,intermediate,fields;private,static,object,mapper,create,update,object,mapper,parent,string,name,parts,int,i,mapper,mapper,list,object,mapper,parent,mappers,new,array,list,object,mapper,previous,intermediate,parent,for,i,name,parts,length,1,i,mapper,intermediate,previous,intermediate,get,mapper,name,parts,i,assert,intermediate,null,field,previous,intermediate,name,does,not,have,a,subfield,name,parts,i,assert,intermediate,instanceof,object,mapper,parent,mappers,add,object,mapper,intermediate,previous,intermediate,object,mapper,intermediate,if,parent,mappers,is,empty,false,add,to,last,mapper,parent,mappers,mapper,false,pop,mappers,parent,mappers,1,false,mapper,parent,mappers,get,0,return,parent,mapping,update,mapper
DocumentParser -> private static ObjectMapper createUpdate(ObjectMapper parent, String[] nameParts, int i, Mapper mapper);1548236405;Build an update for the parent which will contain the given mapper and any intermediate fields.;private static ObjectMapper createUpdate(ObjectMapper parent, String[] nameParts, int i, Mapper mapper) {_        List<ObjectMapper> parentMappers = new ArrayList<>()__        ObjectMapper previousIntermediate = parent__        for (_ i < nameParts.length - 1_ ++i) {_            Mapper intermediate = previousIntermediate.getMapper(nameParts[i])__            assert intermediate != null : "Field " + previousIntermediate.name() + " does not have a subfield " + nameParts[i]__            assert intermediate instanceof ObjectMapper__            parentMappers.add((ObjectMapper)intermediate)__            previousIntermediate = (ObjectMapper)intermediate__        }_        if (parentMappers.isEmpty() == false) {_            _            addToLastMapper(parentMappers, mapper, false)__            popMappers(parentMappers, 1, false)__            mapper = parentMappers.get(0)__        }_        return parent.mappingUpdate(mapper)__    };build,an,update,for,the,parent,which,will,contain,the,given,mapper,and,any,intermediate,fields;private,static,object,mapper,create,update,object,mapper,parent,string,name,parts,int,i,mapper,mapper,list,object,mapper,parent,mappers,new,array,list,object,mapper,previous,intermediate,parent,for,i,name,parts,length,1,i,mapper,intermediate,previous,intermediate,get,mapper,name,parts,i,assert,intermediate,null,field,previous,intermediate,name,does,not,have,a,subfield,name,parts,i,assert,intermediate,instanceof,object,mapper,parent,mappers,add,object,mapper,intermediate,previous,intermediate,object,mapper,intermediate,if,parent,mappers,is,empty,false,add,to,last,mapper,parent,mappers,mapper,false,pop,mappers,parent,mappers,1,false,mapper,parent,mappers,get,0,return,parent,mapping,update,mapper
DocumentParser -> static Mapping createDynamicUpdate(Mapping mapping, DocumentMapper docMapper, List<Mapper> dynamicMappers);1524684173;Creates a Mapping containing any dynamically added fields, or returns null if there were no dynamic mappings.;static Mapping createDynamicUpdate(Mapping mapping, DocumentMapper docMapper, List<Mapper> dynamicMappers) {_        if (dynamicMappers.isEmpty()) {_            return null__        }_        _        _        _        Collections.sort(dynamicMappers, (Mapper o1, Mapper o2) -> o1.name().compareTo(o2.name()))__        Iterator<Mapper> dynamicMapperItr = dynamicMappers.iterator()__        List<ObjectMapper> parentMappers = new ArrayList<>()__        Mapper firstUpdate = dynamicMapperItr.next()__        parentMappers.add(createUpdate(mapping.root(), splitAndValidatePath(firstUpdate.name()), 0, firstUpdate))__        Mapper previousMapper = null__        while (dynamicMapperItr.hasNext()) {_            Mapper newMapper = dynamicMapperItr.next()__            if (previousMapper != null && newMapper.name().equals(previousMapper.name())) {_                _                _                _                newMapper.merge(previousMapper)__                continue__            }_            previousMapper = newMapper__            String[] nameParts = splitAndValidatePath(newMapper.name())___            _            _            _            int i = removeUncommonMappers(parentMappers, nameParts)___            _            _            _            _            i = expandCommonMappers(parentMappers, nameParts, i)___            _            _            _            _            _            _            if (i < nameParts.length - 1) {_                newMapper = createExistingMapperUpdate(parentMappers, nameParts, i, docMapper, newMapper)__            }__            if (newMapper instanceof ObjectMapper) {_                parentMappers.add((ObjectMapper)newMapper)__            } else {_                addToLastMapper(parentMappers, newMapper, true)__            }_        }_        popMappers(parentMappers, 1, true)__        assert parentMappers.size() == 1___        return mapping.mappingUpdate(parentMappers.get(0))__    };creates,a,mapping,containing,any,dynamically,added,fields,or,returns,null,if,there,were,no,dynamic,mappings;static,mapping,create,dynamic,update,mapping,mapping,document,mapper,doc,mapper,list,mapper,dynamic,mappers,if,dynamic,mappers,is,empty,return,null,collections,sort,dynamic,mappers,mapper,o1,mapper,o2,o1,name,compare,to,o2,name,iterator,mapper,dynamic,mapper,itr,dynamic,mappers,iterator,list,object,mapper,parent,mappers,new,array,list,mapper,first,update,dynamic,mapper,itr,next,parent,mappers,add,create,update,mapping,root,split,and,validate,path,first,update,name,0,first,update,mapper,previous,mapper,null,while,dynamic,mapper,itr,has,next,mapper,new,mapper,dynamic,mapper,itr,next,if,previous,mapper,null,new,mapper,name,equals,previous,mapper,name,new,mapper,merge,previous,mapper,continue,previous,mapper,new,mapper,string,name,parts,split,and,validate,path,new,mapper,name,int,i,remove,uncommon,mappers,parent,mappers,name,parts,i,expand,common,mappers,parent,mappers,name,parts,i,if,i,name,parts,length,1,new,mapper,create,existing,mapper,update,parent,mappers,name,parts,i,doc,mapper,new,mapper,if,new,mapper,instanceof,object,mapper,parent,mappers,add,object,mapper,new,mapper,else,add,to,last,mapper,parent,mappers,new,mapper,true,pop,mappers,parent,mappers,1,true,assert,parent,mappers,size,1,return,mapping,mapping,update,parent,mappers,get,0
DocumentParser -> static Mapping createDynamicUpdate(Mapping mapping, DocumentMapper docMapper, List<Mapper> dynamicMappers);1531937412;Creates a Mapping containing any dynamically added fields, or returns null if there were no dynamic mappings.;static Mapping createDynamicUpdate(Mapping mapping, DocumentMapper docMapper, List<Mapper> dynamicMappers) {_        if (dynamicMappers.isEmpty()) {_            return null__        }_        _        _        _        Collections.sort(dynamicMappers, (Mapper o1, Mapper o2) -> o1.name().compareTo(o2.name()))__        Iterator<Mapper> dynamicMapperItr = dynamicMappers.iterator()__        List<ObjectMapper> parentMappers = new ArrayList<>()__        Mapper firstUpdate = dynamicMapperItr.next()__        parentMappers.add(createUpdate(mapping.root(), splitAndValidatePath(firstUpdate.name()), 0, firstUpdate))__        Mapper previousMapper = null__        while (dynamicMapperItr.hasNext()) {_            Mapper newMapper = dynamicMapperItr.next()__            if (previousMapper != null && newMapper.name().equals(previousMapper.name())) {_                _                _                _                newMapper.merge(previousMapper)__                continue__            }_            previousMapper = newMapper__            String[] nameParts = splitAndValidatePath(newMapper.name())___            _            _            _            int i = removeUncommonMappers(parentMappers, nameParts)___            _            _            _            _            i = expandCommonMappers(parentMappers, nameParts, i)___            _            _            _            _            _            _            if (i < nameParts.length - 1) {_                newMapper = createExistingMapperUpdate(parentMappers, nameParts, i, docMapper, newMapper)__            }__            if (newMapper instanceof ObjectMapper) {_                parentMappers.add((ObjectMapper)newMapper)__            } else {_                addToLastMapper(parentMappers, newMapper, true)__            }_        }_        popMappers(parentMappers, 1, true)__        assert parentMappers.size() == 1___        return mapping.mappingUpdate(parentMappers.get(0))__    };creates,a,mapping,containing,any,dynamically,added,fields,or,returns,null,if,there,were,no,dynamic,mappings;static,mapping,create,dynamic,update,mapping,mapping,document,mapper,doc,mapper,list,mapper,dynamic,mappers,if,dynamic,mappers,is,empty,return,null,collections,sort,dynamic,mappers,mapper,o1,mapper,o2,o1,name,compare,to,o2,name,iterator,mapper,dynamic,mapper,itr,dynamic,mappers,iterator,list,object,mapper,parent,mappers,new,array,list,mapper,first,update,dynamic,mapper,itr,next,parent,mappers,add,create,update,mapping,root,split,and,validate,path,first,update,name,0,first,update,mapper,previous,mapper,null,while,dynamic,mapper,itr,has,next,mapper,new,mapper,dynamic,mapper,itr,next,if,previous,mapper,null,new,mapper,name,equals,previous,mapper,name,new,mapper,merge,previous,mapper,continue,previous,mapper,new,mapper,string,name,parts,split,and,validate,path,new,mapper,name,int,i,remove,uncommon,mappers,parent,mappers,name,parts,i,expand,common,mappers,parent,mappers,name,parts,i,if,i,name,parts,length,1,new,mapper,create,existing,mapper,update,parent,mappers,name,parts,i,doc,mapper,new,mapper,if,new,mapper,instanceof,object,mapper,parent,mappers,add,object,mapper,new,mapper,else,add,to,last,mapper,parent,mappers,new,mapper,true,pop,mappers,parent,mappers,1,true,assert,parent,mappers,size,1,return,mapping,mapping,update,parent,mappers,get,0
DocumentParser -> static Mapping createDynamicUpdate(Mapping mapping, DocumentMapper docMapper, List<Mapper> dynamicMappers);1535723122;Creates a Mapping containing any dynamically added fields, or returns null if there were no dynamic mappings.;static Mapping createDynamicUpdate(Mapping mapping, DocumentMapper docMapper, List<Mapper> dynamicMappers) {_        if (dynamicMappers.isEmpty()) {_            return null__        }_        _        _        _        Collections.sort(dynamicMappers, (Mapper o1, Mapper o2) -> o1.name().compareTo(o2.name()))__        Iterator<Mapper> dynamicMapperItr = dynamicMappers.iterator()__        List<ObjectMapper> parentMappers = new ArrayList<>()__        Mapper firstUpdate = dynamicMapperItr.next()__        parentMappers.add(createUpdate(mapping.root(), splitAndValidatePath(firstUpdate.name()), 0, firstUpdate))__        Mapper previousMapper = null__        while (dynamicMapperItr.hasNext()) {_            Mapper newMapper = dynamicMapperItr.next()__            if (previousMapper != null && newMapper.name().equals(previousMapper.name())) {_                _                _                _                newMapper.merge(previousMapper)__                continue__            }_            previousMapper = newMapper__            String[] nameParts = splitAndValidatePath(newMapper.name())___            _            _            _            int i = removeUncommonMappers(parentMappers, nameParts)___            _            _            _            _            i = expandCommonMappers(parentMappers, nameParts, i)___            _            _            _            _            _            _            if (i < nameParts.length - 1) {_                newMapper = createExistingMapperUpdate(parentMappers, nameParts, i, docMapper, newMapper)__            }__            if (newMapper instanceof ObjectMapper) {_                parentMappers.add((ObjectMapper)newMapper)__            } else {_                addToLastMapper(parentMappers, newMapper, true)__            }_        }_        popMappers(parentMappers, 1, true)__        assert parentMappers.size() == 1___        return mapping.mappingUpdate(parentMappers.get(0))__    };creates,a,mapping,containing,any,dynamically,added,fields,or,returns,null,if,there,were,no,dynamic,mappings;static,mapping,create,dynamic,update,mapping,mapping,document,mapper,doc,mapper,list,mapper,dynamic,mappers,if,dynamic,mappers,is,empty,return,null,collections,sort,dynamic,mappers,mapper,o1,mapper,o2,o1,name,compare,to,o2,name,iterator,mapper,dynamic,mapper,itr,dynamic,mappers,iterator,list,object,mapper,parent,mappers,new,array,list,mapper,first,update,dynamic,mapper,itr,next,parent,mappers,add,create,update,mapping,root,split,and,validate,path,first,update,name,0,first,update,mapper,previous,mapper,null,while,dynamic,mapper,itr,has,next,mapper,new,mapper,dynamic,mapper,itr,next,if,previous,mapper,null,new,mapper,name,equals,previous,mapper,name,new,mapper,merge,previous,mapper,continue,previous,mapper,new,mapper,string,name,parts,split,and,validate,path,new,mapper,name,int,i,remove,uncommon,mappers,parent,mappers,name,parts,i,expand,common,mappers,parent,mappers,name,parts,i,if,i,name,parts,length,1,new,mapper,create,existing,mapper,update,parent,mappers,name,parts,i,doc,mapper,new,mapper,if,new,mapper,instanceof,object,mapper,parent,mappers,add,object,mapper,new,mapper,else,add,to,last,mapper,parent,mappers,new,mapper,true,pop,mappers,parent,mappers,1,true,assert,parent,mappers,size,1,return,mapping,mapping,update,parent,mappers,get,0
DocumentParser -> static Mapping createDynamicUpdate(Mapping mapping, DocumentMapper docMapper, List<Mapper> dynamicMappers);1536137328;Creates a Mapping containing any dynamically added fields, or returns null if there were no dynamic mappings.;static Mapping createDynamicUpdate(Mapping mapping, DocumentMapper docMapper, List<Mapper> dynamicMappers) {_        if (dynamicMappers.isEmpty()) {_            return null__        }_        _        _        _        Collections.sort(dynamicMappers, (Mapper o1, Mapper o2) -> o1.name().compareTo(o2.name()))__        Iterator<Mapper> dynamicMapperItr = dynamicMappers.iterator()__        List<ObjectMapper> parentMappers = new ArrayList<>()__        Mapper firstUpdate = dynamicMapperItr.next()__        parentMappers.add(createUpdate(mapping.root(), splitAndValidatePath(firstUpdate.name()), 0, firstUpdate))__        Mapper previousMapper = null__        while (dynamicMapperItr.hasNext()) {_            Mapper newMapper = dynamicMapperItr.next()__            if (previousMapper != null && newMapper.name().equals(previousMapper.name())) {_                _                _                _                newMapper.merge(previousMapper)__                continue__            }_            previousMapper = newMapper__            String[] nameParts = splitAndValidatePath(newMapper.name())___            _            _            _            int i = removeUncommonMappers(parentMappers, nameParts)___            _            _            _            _            i = expandCommonMappers(parentMappers, nameParts, i)___            _            _            _            _            _            _            if (i < nameParts.length - 1) {_                newMapper = createExistingMapperUpdate(parentMappers, nameParts, i, docMapper, newMapper)__            }__            if (newMapper instanceof ObjectMapper) {_                parentMappers.add((ObjectMapper)newMapper)__            } else {_                addToLastMapper(parentMappers, newMapper, true)__            }_        }_        popMappers(parentMappers, 1, true)__        assert parentMappers.size() == 1___        return mapping.mappingUpdate(parentMappers.get(0))__    };creates,a,mapping,containing,any,dynamically,added,fields,or,returns,null,if,there,were,no,dynamic,mappings;static,mapping,create,dynamic,update,mapping,mapping,document,mapper,doc,mapper,list,mapper,dynamic,mappers,if,dynamic,mappers,is,empty,return,null,collections,sort,dynamic,mappers,mapper,o1,mapper,o2,o1,name,compare,to,o2,name,iterator,mapper,dynamic,mapper,itr,dynamic,mappers,iterator,list,object,mapper,parent,mappers,new,array,list,mapper,first,update,dynamic,mapper,itr,next,parent,mappers,add,create,update,mapping,root,split,and,validate,path,first,update,name,0,first,update,mapper,previous,mapper,null,while,dynamic,mapper,itr,has,next,mapper,new,mapper,dynamic,mapper,itr,next,if,previous,mapper,null,new,mapper,name,equals,previous,mapper,name,new,mapper,merge,previous,mapper,continue,previous,mapper,new,mapper,string,name,parts,split,and,validate,path,new,mapper,name,int,i,remove,uncommon,mappers,parent,mappers,name,parts,i,expand,common,mappers,parent,mappers,name,parts,i,if,i,name,parts,length,1,new,mapper,create,existing,mapper,update,parent,mappers,name,parts,i,doc,mapper,new,mapper,if,new,mapper,instanceof,object,mapper,parent,mappers,add,object,mapper,new,mapper,else,add,to,last,mapper,parent,mappers,new,mapper,true,pop,mappers,parent,mappers,1,true,assert,parent,mappers,size,1,return,mapping,mapping,update,parent,mappers,get,0
DocumentParser -> static Mapping createDynamicUpdate(Mapping mapping, DocumentMapper docMapper, List<Mapper> dynamicMappers);1537806831;Creates a Mapping containing any dynamically added fields, or returns null if there were no dynamic mappings.;static Mapping createDynamicUpdate(Mapping mapping, DocumentMapper docMapper, List<Mapper> dynamicMappers) {_        if (dynamicMappers.isEmpty()) {_            return null__        }_        _        _        _        Collections.sort(dynamicMappers, (Mapper o1, Mapper o2) -> o1.name().compareTo(o2.name()))__        Iterator<Mapper> dynamicMapperItr = dynamicMappers.iterator()__        List<ObjectMapper> parentMappers = new ArrayList<>()__        Mapper firstUpdate = dynamicMapperItr.next()__        parentMappers.add(createUpdate(mapping.root(), splitAndValidatePath(firstUpdate.name()), 0, firstUpdate))__        Mapper previousMapper = null__        while (dynamicMapperItr.hasNext()) {_            Mapper newMapper = dynamicMapperItr.next()__            if (previousMapper != null && newMapper.name().equals(previousMapper.name())) {_                _                _                _                newMapper.merge(previousMapper)__                continue__            }_            previousMapper = newMapper__            String[] nameParts = splitAndValidatePath(newMapper.name())___            _            _            _            int i = removeUncommonMappers(parentMappers, nameParts)___            _            _            _            _            i = expandCommonMappers(parentMappers, nameParts, i)___            _            _            _            _            _            _            if (i < nameParts.length - 1) {_                newMapper = createExistingMapperUpdate(parentMappers, nameParts, i, docMapper, newMapper)__            }__            if (newMapper instanceof ObjectMapper) {_                parentMappers.add((ObjectMapper)newMapper)__            } else {_                addToLastMapper(parentMappers, newMapper, true)__            }_        }_        popMappers(parentMappers, 1, true)__        assert parentMappers.size() == 1___        return mapping.mappingUpdate(parentMappers.get(0))__    };creates,a,mapping,containing,any,dynamically,added,fields,or,returns,null,if,there,were,no,dynamic,mappings;static,mapping,create,dynamic,update,mapping,mapping,document,mapper,doc,mapper,list,mapper,dynamic,mappers,if,dynamic,mappers,is,empty,return,null,collections,sort,dynamic,mappers,mapper,o1,mapper,o2,o1,name,compare,to,o2,name,iterator,mapper,dynamic,mapper,itr,dynamic,mappers,iterator,list,object,mapper,parent,mappers,new,array,list,mapper,first,update,dynamic,mapper,itr,next,parent,mappers,add,create,update,mapping,root,split,and,validate,path,first,update,name,0,first,update,mapper,previous,mapper,null,while,dynamic,mapper,itr,has,next,mapper,new,mapper,dynamic,mapper,itr,next,if,previous,mapper,null,new,mapper,name,equals,previous,mapper,name,new,mapper,merge,previous,mapper,continue,previous,mapper,new,mapper,string,name,parts,split,and,validate,path,new,mapper,name,int,i,remove,uncommon,mappers,parent,mappers,name,parts,i,expand,common,mappers,parent,mappers,name,parts,i,if,i,name,parts,length,1,new,mapper,create,existing,mapper,update,parent,mappers,name,parts,i,doc,mapper,new,mapper,if,new,mapper,instanceof,object,mapper,parent,mappers,add,object,mapper,new,mapper,else,add,to,last,mapper,parent,mappers,new,mapper,true,pop,mappers,parent,mappers,1,true,assert,parent,mappers,size,1,return,mapping,mapping,update,parent,mappers,get,0
DocumentParser -> static Mapping createDynamicUpdate(Mapping mapping, DocumentMapper docMapper, List<Mapper> dynamicMappers);1541008027;Creates a Mapping containing any dynamically added fields, or returns null if there were no dynamic mappings.;static Mapping createDynamicUpdate(Mapping mapping, DocumentMapper docMapper, List<Mapper> dynamicMappers) {_        if (dynamicMappers.isEmpty()) {_            return null__        }_        _        _        _        Collections.sort(dynamicMappers, (Mapper o1, Mapper o2) -> o1.name().compareTo(o2.name()))__        Iterator<Mapper> dynamicMapperItr = dynamicMappers.iterator()__        List<ObjectMapper> parentMappers = new ArrayList<>()__        Mapper firstUpdate = dynamicMapperItr.next()__        parentMappers.add(createUpdate(mapping.root(), splitAndValidatePath(firstUpdate.name()), 0, firstUpdate))__        Mapper previousMapper = null__        while (dynamicMapperItr.hasNext()) {_            Mapper newMapper = dynamicMapperItr.next()__            if (previousMapper != null && newMapper.name().equals(previousMapper.name())) {_                _                _                _                newMapper.merge(previousMapper)__                continue__            }_            previousMapper = newMapper__            String[] nameParts = splitAndValidatePath(newMapper.name())___            _            _            _            int i = removeUncommonMappers(parentMappers, nameParts)___            _            _            _            _            i = expandCommonMappers(parentMappers, nameParts, i)___            _            _            _            _            _            _            if (i < nameParts.length - 1) {_                newMapper = createExistingMapperUpdate(parentMappers, nameParts, i, docMapper, newMapper)__            }__            if (newMapper instanceof ObjectMapper) {_                parentMappers.add((ObjectMapper)newMapper)__            } else {_                addToLastMapper(parentMappers, newMapper, true)__            }_        }_        popMappers(parentMappers, 1, true)__        assert parentMappers.size() == 1___        return mapping.mappingUpdate(parentMappers.get(0))__    };creates,a,mapping,containing,any,dynamically,added,fields,or,returns,null,if,there,were,no,dynamic,mappings;static,mapping,create,dynamic,update,mapping,mapping,document,mapper,doc,mapper,list,mapper,dynamic,mappers,if,dynamic,mappers,is,empty,return,null,collections,sort,dynamic,mappers,mapper,o1,mapper,o2,o1,name,compare,to,o2,name,iterator,mapper,dynamic,mapper,itr,dynamic,mappers,iterator,list,object,mapper,parent,mappers,new,array,list,mapper,first,update,dynamic,mapper,itr,next,parent,mappers,add,create,update,mapping,root,split,and,validate,path,first,update,name,0,first,update,mapper,previous,mapper,null,while,dynamic,mapper,itr,has,next,mapper,new,mapper,dynamic,mapper,itr,next,if,previous,mapper,null,new,mapper,name,equals,previous,mapper,name,new,mapper,merge,previous,mapper,continue,previous,mapper,new,mapper,string,name,parts,split,and,validate,path,new,mapper,name,int,i,remove,uncommon,mappers,parent,mappers,name,parts,i,expand,common,mappers,parent,mappers,name,parts,i,if,i,name,parts,length,1,new,mapper,create,existing,mapper,update,parent,mappers,name,parts,i,doc,mapper,new,mapper,if,new,mapper,instanceof,object,mapper,parent,mappers,add,object,mapper,new,mapper,else,add,to,last,mapper,parent,mappers,new,mapper,true,pop,mappers,parent,mappers,1,true,assert,parent,mappers,size,1,return,mapping,mapping,update,parent,mappers,get,0
DocumentParser -> static Mapping createDynamicUpdate(Mapping mapping, DocumentMapper docMapper, List<Mapper> dynamicMappers);1542982526;Creates a Mapping containing any dynamically added fields, or returns null if there were no dynamic mappings.;static Mapping createDynamicUpdate(Mapping mapping, DocumentMapper docMapper, List<Mapper> dynamicMappers) {_        if (dynamicMappers.isEmpty()) {_            return null__        }_        _        _        _        Collections.sort(dynamicMappers, (Mapper o1, Mapper o2) -> o1.name().compareTo(o2.name()))__        Iterator<Mapper> dynamicMapperItr = dynamicMappers.iterator()__        List<ObjectMapper> parentMappers = new ArrayList<>()__        Mapper firstUpdate = dynamicMapperItr.next()__        parentMappers.add(createUpdate(mapping.root(), splitAndValidatePath(firstUpdate.name()), 0, firstUpdate))__        Mapper previousMapper = null__        while (dynamicMapperItr.hasNext()) {_            Mapper newMapper = dynamicMapperItr.next()__            if (previousMapper != null && newMapper.name().equals(previousMapper.name())) {_                _                _                _                newMapper.merge(previousMapper)__                continue__            }_            previousMapper = newMapper__            String[] nameParts = splitAndValidatePath(newMapper.name())___            _            _            _            int i = removeUncommonMappers(parentMappers, nameParts)___            _            _            _            _            i = expandCommonMappers(parentMappers, nameParts, i)___            _            _            _            _            _            _            if (i < nameParts.length - 1) {_                newMapper = createExistingMapperUpdate(parentMappers, nameParts, i, docMapper, newMapper)__            }__            if (newMapper instanceof ObjectMapper) {_                parentMappers.add((ObjectMapper)newMapper)__            } else {_                addToLastMapper(parentMappers, newMapper, true)__            }_        }_        popMappers(parentMappers, 1, true)__        assert parentMappers.size() == 1___        return mapping.mappingUpdate(parentMappers.get(0))__    };creates,a,mapping,containing,any,dynamically,added,fields,or,returns,null,if,there,were,no,dynamic,mappings;static,mapping,create,dynamic,update,mapping,mapping,document,mapper,doc,mapper,list,mapper,dynamic,mappers,if,dynamic,mappers,is,empty,return,null,collections,sort,dynamic,mappers,mapper,o1,mapper,o2,o1,name,compare,to,o2,name,iterator,mapper,dynamic,mapper,itr,dynamic,mappers,iterator,list,object,mapper,parent,mappers,new,array,list,mapper,first,update,dynamic,mapper,itr,next,parent,mappers,add,create,update,mapping,root,split,and,validate,path,first,update,name,0,first,update,mapper,previous,mapper,null,while,dynamic,mapper,itr,has,next,mapper,new,mapper,dynamic,mapper,itr,next,if,previous,mapper,null,new,mapper,name,equals,previous,mapper,name,new,mapper,merge,previous,mapper,continue,previous,mapper,new,mapper,string,name,parts,split,and,validate,path,new,mapper,name,int,i,remove,uncommon,mappers,parent,mappers,name,parts,i,expand,common,mappers,parent,mappers,name,parts,i,if,i,name,parts,length,1,new,mapper,create,existing,mapper,update,parent,mappers,name,parts,i,doc,mapper,new,mapper,if,new,mapper,instanceof,object,mapper,parent,mappers,add,object,mapper,new,mapper,else,add,to,last,mapper,parent,mappers,new,mapper,true,pop,mappers,parent,mappers,1,true,assert,parent,mappers,size,1,return,mapping,mapping,update,parent,mappers,get,0
DocumentParser -> static Mapping createDynamicUpdate(Mapping mapping, DocumentMapper docMapper, List<Mapper> dynamicMappers);1543947737;Creates a Mapping containing any dynamically added fields, or returns null if there were no dynamic mappings.;static Mapping createDynamicUpdate(Mapping mapping, DocumentMapper docMapper, List<Mapper> dynamicMappers) {_        if (dynamicMappers.isEmpty()) {_            return null__        }_        _        _        _        Collections.sort(dynamicMappers, (Mapper o1, Mapper o2) -> o1.name().compareTo(o2.name()))__        Iterator<Mapper> dynamicMapperItr = dynamicMappers.iterator()__        List<ObjectMapper> parentMappers = new ArrayList<>()__        Mapper firstUpdate = dynamicMapperItr.next()__        parentMappers.add(createUpdate(mapping.root(), splitAndValidatePath(firstUpdate.name()), 0, firstUpdate))__        Mapper previousMapper = null__        while (dynamicMapperItr.hasNext()) {_            Mapper newMapper = dynamicMapperItr.next()__            if (previousMapper != null && newMapper.name().equals(previousMapper.name())) {_                _                _                _                newMapper.merge(previousMapper)__                continue__            }_            previousMapper = newMapper__            String[] nameParts = splitAndValidatePath(newMapper.name())___            _            _            _            int i = removeUncommonMappers(parentMappers, nameParts)___            _            _            _            _            i = expandCommonMappers(parentMappers, nameParts, i)___            _            _            _            _            _            _            if (i < nameParts.length - 1) {_                newMapper = createExistingMapperUpdate(parentMappers, nameParts, i, docMapper, newMapper)__            }__            if (newMapper instanceof ObjectMapper) {_                parentMappers.add((ObjectMapper)newMapper)__            } else {_                addToLastMapper(parentMappers, newMapper, true)__            }_        }_        popMappers(parentMappers, 1, true)__        assert parentMappers.size() == 1___        return mapping.mappingUpdate(parentMappers.get(0))__    };creates,a,mapping,containing,any,dynamically,added,fields,or,returns,null,if,there,were,no,dynamic,mappings;static,mapping,create,dynamic,update,mapping,mapping,document,mapper,doc,mapper,list,mapper,dynamic,mappers,if,dynamic,mappers,is,empty,return,null,collections,sort,dynamic,mappers,mapper,o1,mapper,o2,o1,name,compare,to,o2,name,iterator,mapper,dynamic,mapper,itr,dynamic,mappers,iterator,list,object,mapper,parent,mappers,new,array,list,mapper,first,update,dynamic,mapper,itr,next,parent,mappers,add,create,update,mapping,root,split,and,validate,path,first,update,name,0,first,update,mapper,previous,mapper,null,while,dynamic,mapper,itr,has,next,mapper,new,mapper,dynamic,mapper,itr,next,if,previous,mapper,null,new,mapper,name,equals,previous,mapper,name,new,mapper,merge,previous,mapper,continue,previous,mapper,new,mapper,string,name,parts,split,and,validate,path,new,mapper,name,int,i,remove,uncommon,mappers,parent,mappers,name,parts,i,expand,common,mappers,parent,mappers,name,parts,i,if,i,name,parts,length,1,new,mapper,create,existing,mapper,update,parent,mappers,name,parts,i,doc,mapper,new,mapper,if,new,mapper,instanceof,object,mapper,parent,mappers,add,object,mapper,new,mapper,else,add,to,last,mapper,parent,mappers,new,mapper,true,pop,mappers,parent,mappers,1,true,assert,parent,mappers,size,1,return,mapping,mapping,update,parent,mappers,get,0
DocumentParser -> static Mapping createDynamicUpdate(Mapping mapping, DocumentMapper docMapper, List<Mapper> dynamicMappers);1544232221;Creates a Mapping containing any dynamically added fields, or returns null if there were no dynamic mappings.;static Mapping createDynamicUpdate(Mapping mapping, DocumentMapper docMapper, List<Mapper> dynamicMappers) {_        if (dynamicMappers.isEmpty()) {_            return null__        }_        _        _        _        Collections.sort(dynamicMappers, (Mapper o1, Mapper o2) -> o1.name().compareTo(o2.name()))__        Iterator<Mapper> dynamicMapperItr = dynamicMappers.iterator()__        List<ObjectMapper> parentMappers = new ArrayList<>()__        Mapper firstUpdate = dynamicMapperItr.next()__        parentMappers.add(createUpdate(mapping.root(), splitAndValidatePath(firstUpdate.name()), 0, firstUpdate))__        Mapper previousMapper = null__        while (dynamicMapperItr.hasNext()) {_            Mapper newMapper = dynamicMapperItr.next()__            if (previousMapper != null && newMapper.name().equals(previousMapper.name())) {_                _                _                _                newMapper.merge(previousMapper)__                continue__            }_            previousMapper = newMapper__            String[] nameParts = splitAndValidatePath(newMapper.name())___            _            _            _            int i = removeUncommonMappers(parentMappers, nameParts)___            _            _            _            _            i = expandCommonMappers(parentMappers, nameParts, i)___            _            _            _            _            _            _            if (i < nameParts.length - 1) {_                newMapper = createExistingMapperUpdate(parentMappers, nameParts, i, docMapper, newMapper)__            }__            if (newMapper instanceof ObjectMapper) {_                parentMappers.add((ObjectMapper)newMapper)__            } else {_                addToLastMapper(parentMappers, newMapper, true)__            }_        }_        popMappers(parentMappers, 1, true)__        assert parentMappers.size() == 1___        return mapping.mappingUpdate(parentMappers.get(0))__    };creates,a,mapping,containing,any,dynamically,added,fields,or,returns,null,if,there,were,no,dynamic,mappings;static,mapping,create,dynamic,update,mapping,mapping,document,mapper,doc,mapper,list,mapper,dynamic,mappers,if,dynamic,mappers,is,empty,return,null,collections,sort,dynamic,mappers,mapper,o1,mapper,o2,o1,name,compare,to,o2,name,iterator,mapper,dynamic,mapper,itr,dynamic,mappers,iterator,list,object,mapper,parent,mappers,new,array,list,mapper,first,update,dynamic,mapper,itr,next,parent,mappers,add,create,update,mapping,root,split,and,validate,path,first,update,name,0,first,update,mapper,previous,mapper,null,while,dynamic,mapper,itr,has,next,mapper,new,mapper,dynamic,mapper,itr,next,if,previous,mapper,null,new,mapper,name,equals,previous,mapper,name,new,mapper,merge,previous,mapper,continue,previous,mapper,new,mapper,string,name,parts,split,and,validate,path,new,mapper,name,int,i,remove,uncommon,mappers,parent,mappers,name,parts,i,expand,common,mappers,parent,mappers,name,parts,i,if,i,name,parts,length,1,new,mapper,create,existing,mapper,update,parent,mappers,name,parts,i,doc,mapper,new,mapper,if,new,mapper,instanceof,object,mapper,parent,mappers,add,object,mapper,new,mapper,else,add,to,last,mapper,parent,mappers,new,mapper,true,pop,mappers,parent,mappers,1,true,assert,parent,mappers,size,1,return,mapping,mapping,update,parent,mappers,get,0
DocumentParser -> static Mapping createDynamicUpdate(Mapping mapping, DocumentMapper docMapper, List<Mapper> dynamicMappers);1544458001;Creates a Mapping containing any dynamically added fields, or returns null if there were no dynamic mappings.;static Mapping createDynamicUpdate(Mapping mapping, DocumentMapper docMapper, List<Mapper> dynamicMappers) {_        if (dynamicMappers.isEmpty()) {_            return null__        }_        _        _        _        Collections.sort(dynamicMappers, (Mapper o1, Mapper o2) -> o1.name().compareTo(o2.name()))__        Iterator<Mapper> dynamicMapperItr = dynamicMappers.iterator()__        List<ObjectMapper> parentMappers = new ArrayList<>()__        Mapper firstUpdate = dynamicMapperItr.next()__        parentMappers.add(createUpdate(mapping.root(), splitAndValidatePath(firstUpdate.name()), 0, firstUpdate))__        Mapper previousMapper = null__        while (dynamicMapperItr.hasNext()) {_            Mapper newMapper = dynamicMapperItr.next()__            if (previousMapper != null && newMapper.name().equals(previousMapper.name())) {_                _                _                _                newMapper.merge(previousMapper)__                continue__            }_            previousMapper = newMapper__            String[] nameParts = splitAndValidatePath(newMapper.name())___            _            _            _            int i = removeUncommonMappers(parentMappers, nameParts)___            _            _            _            _            i = expandCommonMappers(parentMappers, nameParts, i)___            _            _            _            _            _            _            if (i < nameParts.length - 1) {_                newMapper = createExistingMapperUpdate(parentMappers, nameParts, i, docMapper, newMapper)__            }__            if (newMapper instanceof ObjectMapper) {_                parentMappers.add((ObjectMapper)newMapper)__            } else {_                addToLastMapper(parentMappers, newMapper, true)__            }_        }_        popMappers(parentMappers, 1, true)__        assert parentMappers.size() == 1___        return mapping.mappingUpdate(parentMappers.get(0))__    };creates,a,mapping,containing,any,dynamically,added,fields,or,returns,null,if,there,were,no,dynamic,mappings;static,mapping,create,dynamic,update,mapping,mapping,document,mapper,doc,mapper,list,mapper,dynamic,mappers,if,dynamic,mappers,is,empty,return,null,collections,sort,dynamic,mappers,mapper,o1,mapper,o2,o1,name,compare,to,o2,name,iterator,mapper,dynamic,mapper,itr,dynamic,mappers,iterator,list,object,mapper,parent,mappers,new,array,list,mapper,first,update,dynamic,mapper,itr,next,parent,mappers,add,create,update,mapping,root,split,and,validate,path,first,update,name,0,first,update,mapper,previous,mapper,null,while,dynamic,mapper,itr,has,next,mapper,new,mapper,dynamic,mapper,itr,next,if,previous,mapper,null,new,mapper,name,equals,previous,mapper,name,new,mapper,merge,previous,mapper,continue,previous,mapper,new,mapper,string,name,parts,split,and,validate,path,new,mapper,name,int,i,remove,uncommon,mappers,parent,mappers,name,parts,i,expand,common,mappers,parent,mappers,name,parts,i,if,i,name,parts,length,1,new,mapper,create,existing,mapper,update,parent,mappers,name,parts,i,doc,mapper,new,mapper,if,new,mapper,instanceof,object,mapper,parent,mappers,add,object,mapper,new,mapper,else,add,to,last,mapper,parent,mappers,new,mapper,true,pop,mappers,parent,mappers,1,true,assert,parent,mappers,size,1,return,mapping,mapping,update,parent,mappers,get,0
DocumentParser -> static Mapping createDynamicUpdate(Mapping mapping, DocumentMapper docMapper, List<Mapper> dynamicMappers);1548236405;Creates a Mapping containing any dynamically added fields, or returns null if there were no dynamic mappings.;static Mapping createDynamicUpdate(Mapping mapping, DocumentMapper docMapper, List<Mapper> dynamicMappers) {_        if (dynamicMappers.isEmpty()) {_            return null__        }_        _        _        _        Collections.sort(dynamicMappers, (Mapper o1, Mapper o2) -> o1.name().compareTo(o2.name()))__        Iterator<Mapper> dynamicMapperItr = dynamicMappers.iterator()__        List<ObjectMapper> parentMappers = new ArrayList<>()__        Mapper firstUpdate = dynamicMapperItr.next()__        parentMappers.add(createUpdate(mapping.root(), splitAndValidatePath(firstUpdate.name()), 0, firstUpdate))__        Mapper previousMapper = null__        while (dynamicMapperItr.hasNext()) {_            Mapper newMapper = dynamicMapperItr.next()__            if (previousMapper != null && newMapper.name().equals(previousMapper.name())) {_                _                _                _                newMapper.merge(previousMapper)__                continue__            }_            previousMapper = newMapper__            String[] nameParts = splitAndValidatePath(newMapper.name())___            _            _            _            int i = removeUncommonMappers(parentMappers, nameParts)___            _            _            _            _            i = expandCommonMappers(parentMappers, nameParts, i)___            _            _            _            _            _            _            if (i < nameParts.length - 1) {_                newMapper = createExistingMapperUpdate(parentMappers, nameParts, i, docMapper, newMapper)__            }__            if (newMapper instanceof ObjectMapper) {_                parentMappers.add((ObjectMapper)newMapper)__            } else {_                addToLastMapper(parentMappers, newMapper, true)__            }_        }_        popMappers(parentMappers, 1, true)__        assert parentMappers.size() == 1___        return mapping.mappingUpdate(parentMappers.get(0))__    };creates,a,mapping,containing,any,dynamically,added,fields,or,returns,null,if,there,were,no,dynamic,mappings;static,mapping,create,dynamic,update,mapping,mapping,document,mapper,doc,mapper,list,mapper,dynamic,mappers,if,dynamic,mappers,is,empty,return,null,collections,sort,dynamic,mappers,mapper,o1,mapper,o2,o1,name,compare,to,o2,name,iterator,mapper,dynamic,mapper,itr,dynamic,mappers,iterator,list,object,mapper,parent,mappers,new,array,list,mapper,first,update,dynamic,mapper,itr,next,parent,mappers,add,create,update,mapping,root,split,and,validate,path,first,update,name,0,first,update,mapper,previous,mapper,null,while,dynamic,mapper,itr,has,next,mapper,new,mapper,dynamic,mapper,itr,next,if,previous,mapper,null,new,mapper,name,equals,previous,mapper,name,new,mapper,merge,previous,mapper,continue,previous,mapper,new,mapper,string,name,parts,split,and,validate,path,new,mapper,name,int,i,remove,uncommon,mappers,parent,mappers,name,parts,i,expand,common,mappers,parent,mappers,name,parts,i,if,i,name,parts,length,1,new,mapper,create,existing,mapper,update,parent,mappers,name,parts,i,doc,mapper,new,mapper,if,new,mapper,instanceof,object,mapper,parent,mappers,add,object,mapper,new,mapper,else,add,to,last,mapper,parent,mappers,new,mapper,true,pop,mappers,parent,mappers,1,true,assert,parent,mappers,size,1,return,mapping,mapping,update,parent,mappers,get,0
DocumentParser -> private static void addToLastMapper(List<ObjectMapper> parentMappers, Mapper mapper, boolean merge);1524684173;Adds a mapper as an update into the last mapper. If merge is true, the new mapper_will be merged in with other child mappers of the last parent, otherwise it will be a new update.;private static void addToLastMapper(List<ObjectMapper> parentMappers, Mapper mapper, boolean merge) {_        assert parentMappers.size() >= 1__        int lastIndex = parentMappers.size() - 1__        ObjectMapper withNewMapper = parentMappers.get(lastIndex).mappingUpdate(mapper)__        if (merge) {_            withNewMapper = parentMappers.get(lastIndex).merge(withNewMapper)__        }_        parentMappers.set(lastIndex, withNewMapper)__    };adds,a,mapper,as,an,update,into,the,last,mapper,if,merge,is,true,the,new,mapper,will,be,merged,in,with,other,child,mappers,of,the,last,parent,otherwise,it,will,be,a,new,update;private,static,void,add,to,last,mapper,list,object,mapper,parent,mappers,mapper,mapper,boolean,merge,assert,parent,mappers,size,1,int,last,index,parent,mappers,size,1,object,mapper,with,new,mapper,parent,mappers,get,last,index,mapping,update,mapper,if,merge,with,new,mapper,parent,mappers,get,last,index,merge,with,new,mapper,parent,mappers,set,last,index,with,new,mapper
DocumentParser -> private static void addToLastMapper(List<ObjectMapper> parentMappers, Mapper mapper, boolean merge);1531937412;Adds a mapper as an update into the last mapper. If merge is true, the new mapper_will be merged in with other child mappers of the last parent, otherwise it will be a new update.;private static void addToLastMapper(List<ObjectMapper> parentMappers, Mapper mapper, boolean merge) {_        assert parentMappers.size() >= 1__        int lastIndex = parentMappers.size() - 1__        ObjectMapper withNewMapper = parentMappers.get(lastIndex).mappingUpdate(mapper)__        if (merge) {_            withNewMapper = parentMappers.get(lastIndex).merge(withNewMapper)__        }_        parentMappers.set(lastIndex, withNewMapper)__    };adds,a,mapper,as,an,update,into,the,last,mapper,if,merge,is,true,the,new,mapper,will,be,merged,in,with,other,child,mappers,of,the,last,parent,otherwise,it,will,be,a,new,update;private,static,void,add,to,last,mapper,list,object,mapper,parent,mappers,mapper,mapper,boolean,merge,assert,parent,mappers,size,1,int,last,index,parent,mappers,size,1,object,mapper,with,new,mapper,parent,mappers,get,last,index,mapping,update,mapper,if,merge,with,new,mapper,parent,mappers,get,last,index,merge,with,new,mapper,parent,mappers,set,last,index,with,new,mapper
DocumentParser -> private static void addToLastMapper(List<ObjectMapper> parentMappers, Mapper mapper, boolean merge);1535723122;Adds a mapper as an update into the last mapper. If merge is true, the new mapper_will be merged in with other child mappers of the last parent, otherwise it will be a new update.;private static void addToLastMapper(List<ObjectMapper> parentMappers, Mapper mapper, boolean merge) {_        assert parentMappers.size() >= 1__        int lastIndex = parentMappers.size() - 1__        ObjectMapper withNewMapper = parentMappers.get(lastIndex).mappingUpdate(mapper)__        if (merge) {_            withNewMapper = parentMappers.get(lastIndex).merge(withNewMapper)__        }_        parentMappers.set(lastIndex, withNewMapper)__    };adds,a,mapper,as,an,update,into,the,last,mapper,if,merge,is,true,the,new,mapper,will,be,merged,in,with,other,child,mappers,of,the,last,parent,otherwise,it,will,be,a,new,update;private,static,void,add,to,last,mapper,list,object,mapper,parent,mappers,mapper,mapper,boolean,merge,assert,parent,mappers,size,1,int,last,index,parent,mappers,size,1,object,mapper,with,new,mapper,parent,mappers,get,last,index,mapping,update,mapper,if,merge,with,new,mapper,parent,mappers,get,last,index,merge,with,new,mapper,parent,mappers,set,last,index,with,new,mapper
DocumentParser -> private static void addToLastMapper(List<ObjectMapper> parentMappers, Mapper mapper, boolean merge);1536137328;Adds a mapper as an update into the last mapper. If merge is true, the new mapper_will be merged in with other child mappers of the last parent, otherwise it will be a new update.;private static void addToLastMapper(List<ObjectMapper> parentMappers, Mapper mapper, boolean merge) {_        assert parentMappers.size() >= 1__        int lastIndex = parentMappers.size() - 1__        ObjectMapper withNewMapper = parentMappers.get(lastIndex).mappingUpdate(mapper)__        if (merge) {_            withNewMapper = parentMappers.get(lastIndex).merge(withNewMapper)__        }_        parentMappers.set(lastIndex, withNewMapper)__    };adds,a,mapper,as,an,update,into,the,last,mapper,if,merge,is,true,the,new,mapper,will,be,merged,in,with,other,child,mappers,of,the,last,parent,otherwise,it,will,be,a,new,update;private,static,void,add,to,last,mapper,list,object,mapper,parent,mappers,mapper,mapper,boolean,merge,assert,parent,mappers,size,1,int,last,index,parent,mappers,size,1,object,mapper,with,new,mapper,parent,mappers,get,last,index,mapping,update,mapper,if,merge,with,new,mapper,parent,mappers,get,last,index,merge,with,new,mapper,parent,mappers,set,last,index,with,new,mapper
DocumentParser -> private static void addToLastMapper(List<ObjectMapper> parentMappers, Mapper mapper, boolean merge);1537806831;Adds a mapper as an update into the last mapper. If merge is true, the new mapper_will be merged in with other child mappers of the last parent, otherwise it will be a new update.;private static void addToLastMapper(List<ObjectMapper> parentMappers, Mapper mapper, boolean merge) {_        assert parentMappers.size() >= 1__        int lastIndex = parentMappers.size() - 1__        ObjectMapper withNewMapper = parentMappers.get(lastIndex).mappingUpdate(mapper)__        if (merge) {_            withNewMapper = parentMappers.get(lastIndex).merge(withNewMapper)__        }_        parentMappers.set(lastIndex, withNewMapper)__    };adds,a,mapper,as,an,update,into,the,last,mapper,if,merge,is,true,the,new,mapper,will,be,merged,in,with,other,child,mappers,of,the,last,parent,otherwise,it,will,be,a,new,update;private,static,void,add,to,last,mapper,list,object,mapper,parent,mappers,mapper,mapper,boolean,merge,assert,parent,mappers,size,1,int,last,index,parent,mappers,size,1,object,mapper,with,new,mapper,parent,mappers,get,last,index,mapping,update,mapper,if,merge,with,new,mapper,parent,mappers,get,last,index,merge,with,new,mapper,parent,mappers,set,last,index,with,new,mapper
DocumentParser -> private static void addToLastMapper(List<ObjectMapper> parentMappers, Mapper mapper, boolean merge);1541008027;Adds a mapper as an update into the last mapper. If merge is true, the new mapper_will be merged in with other child mappers of the last parent, otherwise it will be a new update.;private static void addToLastMapper(List<ObjectMapper> parentMappers, Mapper mapper, boolean merge) {_        assert parentMappers.size() >= 1__        int lastIndex = parentMappers.size() - 1__        ObjectMapper withNewMapper = parentMappers.get(lastIndex).mappingUpdate(mapper)__        if (merge) {_            withNewMapper = parentMappers.get(lastIndex).merge(withNewMapper)__        }_        parentMappers.set(lastIndex, withNewMapper)__    };adds,a,mapper,as,an,update,into,the,last,mapper,if,merge,is,true,the,new,mapper,will,be,merged,in,with,other,child,mappers,of,the,last,parent,otherwise,it,will,be,a,new,update;private,static,void,add,to,last,mapper,list,object,mapper,parent,mappers,mapper,mapper,boolean,merge,assert,parent,mappers,size,1,int,last,index,parent,mappers,size,1,object,mapper,with,new,mapper,parent,mappers,get,last,index,mapping,update,mapper,if,merge,with,new,mapper,parent,mappers,get,last,index,merge,with,new,mapper,parent,mappers,set,last,index,with,new,mapper
DocumentParser -> private static void addToLastMapper(List<ObjectMapper> parentMappers, Mapper mapper, boolean merge);1542982526;Adds a mapper as an update into the last mapper. If merge is true, the new mapper_will be merged in with other child mappers of the last parent, otherwise it will be a new update.;private static void addToLastMapper(List<ObjectMapper> parentMappers, Mapper mapper, boolean merge) {_        assert parentMappers.size() >= 1__        int lastIndex = parentMappers.size() - 1__        ObjectMapper withNewMapper = parentMappers.get(lastIndex).mappingUpdate(mapper)__        if (merge) {_            withNewMapper = parentMappers.get(lastIndex).merge(withNewMapper)__        }_        parentMappers.set(lastIndex, withNewMapper)__    };adds,a,mapper,as,an,update,into,the,last,mapper,if,merge,is,true,the,new,mapper,will,be,merged,in,with,other,child,mappers,of,the,last,parent,otherwise,it,will,be,a,new,update;private,static,void,add,to,last,mapper,list,object,mapper,parent,mappers,mapper,mapper,boolean,merge,assert,parent,mappers,size,1,int,last,index,parent,mappers,size,1,object,mapper,with,new,mapper,parent,mappers,get,last,index,mapping,update,mapper,if,merge,with,new,mapper,parent,mappers,get,last,index,merge,with,new,mapper,parent,mappers,set,last,index,with,new,mapper
DocumentParser -> private static void addToLastMapper(List<ObjectMapper> parentMappers, Mapper mapper, boolean merge);1543947737;Adds a mapper as an update into the last mapper. If merge is true, the new mapper_will be merged in with other child mappers of the last parent, otherwise it will be a new update.;private static void addToLastMapper(List<ObjectMapper> parentMappers, Mapper mapper, boolean merge) {_        assert parentMappers.size() >= 1__        int lastIndex = parentMappers.size() - 1__        ObjectMapper withNewMapper = parentMappers.get(lastIndex).mappingUpdate(mapper)__        if (merge) {_            withNewMapper = parentMappers.get(lastIndex).merge(withNewMapper)__        }_        parentMappers.set(lastIndex, withNewMapper)__    };adds,a,mapper,as,an,update,into,the,last,mapper,if,merge,is,true,the,new,mapper,will,be,merged,in,with,other,child,mappers,of,the,last,parent,otherwise,it,will,be,a,new,update;private,static,void,add,to,last,mapper,list,object,mapper,parent,mappers,mapper,mapper,boolean,merge,assert,parent,mappers,size,1,int,last,index,parent,mappers,size,1,object,mapper,with,new,mapper,parent,mappers,get,last,index,mapping,update,mapper,if,merge,with,new,mapper,parent,mappers,get,last,index,merge,with,new,mapper,parent,mappers,set,last,index,with,new,mapper
DocumentParser -> private static void addToLastMapper(List<ObjectMapper> parentMappers, Mapper mapper, boolean merge);1544232221;Adds a mapper as an update into the last mapper. If merge is true, the new mapper_will be merged in with other child mappers of the last parent, otherwise it will be a new update.;private static void addToLastMapper(List<ObjectMapper> parentMappers, Mapper mapper, boolean merge) {_        assert parentMappers.size() >= 1__        int lastIndex = parentMappers.size() - 1__        ObjectMapper withNewMapper = parentMappers.get(lastIndex).mappingUpdate(mapper)__        if (merge) {_            withNewMapper = parentMappers.get(lastIndex).merge(withNewMapper)__        }_        parentMappers.set(lastIndex, withNewMapper)__    };adds,a,mapper,as,an,update,into,the,last,mapper,if,merge,is,true,the,new,mapper,will,be,merged,in,with,other,child,mappers,of,the,last,parent,otherwise,it,will,be,a,new,update;private,static,void,add,to,last,mapper,list,object,mapper,parent,mappers,mapper,mapper,boolean,merge,assert,parent,mappers,size,1,int,last,index,parent,mappers,size,1,object,mapper,with,new,mapper,parent,mappers,get,last,index,mapping,update,mapper,if,merge,with,new,mapper,parent,mappers,get,last,index,merge,with,new,mapper,parent,mappers,set,last,index,with,new,mapper
DocumentParser -> private static void addToLastMapper(List<ObjectMapper> parentMappers, Mapper mapper, boolean merge);1544458001;Adds a mapper as an update into the last mapper. If merge is true, the new mapper_will be merged in with other child mappers of the last parent, otherwise it will be a new update.;private static void addToLastMapper(List<ObjectMapper> parentMappers, Mapper mapper, boolean merge) {_        assert parentMappers.size() >= 1__        int lastIndex = parentMappers.size() - 1__        ObjectMapper withNewMapper = parentMappers.get(lastIndex).mappingUpdate(mapper)__        if (merge) {_            withNewMapper = parentMappers.get(lastIndex).merge(withNewMapper)__        }_        parentMappers.set(lastIndex, withNewMapper)__    };adds,a,mapper,as,an,update,into,the,last,mapper,if,merge,is,true,the,new,mapper,will,be,merged,in,with,other,child,mappers,of,the,last,parent,otherwise,it,will,be,a,new,update;private,static,void,add,to,last,mapper,list,object,mapper,parent,mappers,mapper,mapper,boolean,merge,assert,parent,mappers,size,1,int,last,index,parent,mappers,size,1,object,mapper,with,new,mapper,parent,mappers,get,last,index,mapping,update,mapper,if,merge,with,new,mapper,parent,mappers,get,last,index,merge,with,new,mapper,parent,mappers,set,last,index,with,new,mapper
DocumentParser -> private static void addToLastMapper(List<ObjectMapper> parentMappers, Mapper mapper, boolean merge);1548236405;Adds a mapper as an update into the last mapper. If merge is true, the new mapper_will be merged in with other child mappers of the last parent, otherwise it will be a new update.;private static void addToLastMapper(List<ObjectMapper> parentMappers, Mapper mapper, boolean merge) {_        assert parentMappers.size() >= 1__        int lastIndex = parentMappers.size() - 1__        ObjectMapper withNewMapper = parentMappers.get(lastIndex).mappingUpdate(mapper)__        if (merge) {_            withNewMapper = parentMappers.get(lastIndex).merge(withNewMapper)__        }_        parentMappers.set(lastIndex, withNewMapper)__    };adds,a,mapper,as,an,update,into,the,last,mapper,if,merge,is,true,the,new,mapper,will,be,merged,in,with,other,child,mappers,of,the,last,parent,otherwise,it,will,be,a,new,update;private,static,void,add,to,last,mapper,list,object,mapper,parent,mappers,mapper,mapper,boolean,merge,assert,parent,mappers,size,1,int,last,index,parent,mappers,size,1,object,mapper,with,new,mapper,parent,mappers,get,last,index,mapping,update,mapper,if,merge,with,new,mapper,parent,mappers,get,last,index,merge,with,new,mapper,parent,mappers,set,last,index,with,new,mapper
DocumentParser -> private static void parseCopy(String field, ParseContext context) throws IOException;1524684173;Creates an copy of the current field with given field name and boost;private static void parseCopy(String field, ParseContext context) throws IOException {_        FieldMapper fieldMapper = context.docMapper().mappers().getMapper(field)__        if (fieldMapper != null) {_            fieldMapper.parse(context)__        } else {_            _            context = context.overridePath(new ContentPath(0))___            final String[] paths = splitAndValidatePath(field)__            final String fieldName = paths[paths.length-1]__            Tuple<Integer, ObjectMapper> parentMapperTuple = getDynamicParentMapper(context, paths, null)__            ObjectMapper mapper = parentMapperTuple.v2()__            parseDynamicValue(context, mapper, fieldName, context.parser().currentToken())__            for (int i = 0_ i < parentMapperTuple.v1()_ i++) {_                context.path().remove()__            }_        }_    };creates,an,copy,of,the,current,field,with,given,field,name,and,boost;private,static,void,parse,copy,string,field,parse,context,context,throws,ioexception,field,mapper,field,mapper,context,doc,mapper,mappers,get,mapper,field,if,field,mapper,null,field,mapper,parse,context,else,context,context,override,path,new,content,path,0,final,string,paths,split,and,validate,path,field,final,string,field,name,paths,paths,length,1,tuple,integer,object,mapper,parent,mapper,tuple,get,dynamic,parent,mapper,context,paths,null,object,mapper,mapper,parent,mapper,tuple,v2,parse,dynamic,value,context,mapper,field,name,context,parser,current,token,for,int,i,0,i,parent,mapper,tuple,v1,i,context,path,remove
DocumentParser -> private static void parseCopy(String field, ParseContext context) throws IOException;1531937412;Creates an copy of the current field with given field name and boost;private static void parseCopy(String field, ParseContext context) throws IOException {_        Mapper mapper = context.docMapper().mappers().getMapper(field)__        if (mapper != null) {_            if (mapper instanceof FieldMapper) {_                ((FieldMapper) mapper).parse(context)__            } else if (mapper instanceof FieldAliasMapper) {_                throw new IllegalArgumentException("Cannot copy to a field alias [" + mapper.name() + "].")__            } else {_                throw new IllegalStateException("The provided mapper [" + mapper.name() +_                    "] has an unrecognized type [" + mapper.getClass().getSimpleName() + "].")__            }_        } else {_            _            context = context.overridePath(new ContentPath(0))___            final String[] paths = splitAndValidatePath(field)__            final String fieldName = paths[paths.length-1]__            Tuple<Integer, ObjectMapper> parentMapperTuple = getDynamicParentMapper(context, paths, null)__            ObjectMapper objectMapper = parentMapperTuple.v2()__            parseDynamicValue(context, objectMapper, fieldName, context.parser().currentToken())__            for (int i = 0_ i < parentMapperTuple.v1()_ i++) {_                context.path().remove()__            }_        }_    };creates,an,copy,of,the,current,field,with,given,field,name,and,boost;private,static,void,parse,copy,string,field,parse,context,context,throws,ioexception,mapper,mapper,context,doc,mapper,mappers,get,mapper,field,if,mapper,null,if,mapper,instanceof,field,mapper,field,mapper,mapper,parse,context,else,if,mapper,instanceof,field,alias,mapper,throw,new,illegal,argument,exception,cannot,copy,to,a,field,alias,mapper,name,else,throw,new,illegal,state,exception,the,provided,mapper,mapper,name,has,an,unrecognized,type,mapper,get,class,get,simple,name,else,context,context,override,path,new,content,path,0,final,string,paths,split,and,validate,path,field,final,string,field,name,paths,paths,length,1,tuple,integer,object,mapper,parent,mapper,tuple,get,dynamic,parent,mapper,context,paths,null,object,mapper,object,mapper,parent,mapper,tuple,v2,parse,dynamic,value,context,object,mapper,field,name,context,parser,current,token,for,int,i,0,i,parent,mapper,tuple,v1,i,context,path,remove
DocumentParser -> private static void parseCopy(String field, ParseContext context) throws IOException;1535723122;Creates an copy of the current field with given field name and boost;private static void parseCopy(String field, ParseContext context) throws IOException {_        Mapper mapper = context.docMapper().mappers().getMapper(field)__        if (mapper != null) {_            if (mapper instanceof FieldMapper) {_                ((FieldMapper) mapper).parse(context)__            } else if (mapper instanceof FieldAliasMapper) {_                throw new IllegalArgumentException("Cannot copy to a field alias [" + mapper.name() + "].")__            } else {_                throw new IllegalStateException("The provided mapper [" + mapper.name() +_                    "] has an unrecognized type [" + mapper.getClass().getSimpleName() + "].")__            }_        } else {_            _            context = context.overridePath(new ContentPath(0))___            final String[] paths = splitAndValidatePath(field)__            final String fieldName = paths[paths.length-1]__            Tuple<Integer, ObjectMapper> parentMapperTuple = getDynamicParentMapper(context, paths, null)__            ObjectMapper objectMapper = parentMapperTuple.v2()__            parseDynamicValue(context, objectMapper, fieldName, context.parser().currentToken())__            for (int i = 0_ i < parentMapperTuple.v1()_ i++) {_                context.path().remove()__            }_        }_    };creates,an,copy,of,the,current,field,with,given,field,name,and,boost;private,static,void,parse,copy,string,field,parse,context,context,throws,ioexception,mapper,mapper,context,doc,mapper,mappers,get,mapper,field,if,mapper,null,if,mapper,instanceof,field,mapper,field,mapper,mapper,parse,context,else,if,mapper,instanceof,field,alias,mapper,throw,new,illegal,argument,exception,cannot,copy,to,a,field,alias,mapper,name,else,throw,new,illegal,state,exception,the,provided,mapper,mapper,name,has,an,unrecognized,type,mapper,get,class,get,simple,name,else,context,context,override,path,new,content,path,0,final,string,paths,split,and,validate,path,field,final,string,field,name,paths,paths,length,1,tuple,integer,object,mapper,parent,mapper,tuple,get,dynamic,parent,mapper,context,paths,null,object,mapper,object,mapper,parent,mapper,tuple,v2,parse,dynamic,value,context,object,mapper,field,name,context,parser,current,token,for,int,i,0,i,parent,mapper,tuple,v1,i,context,path,remove
DocumentParser -> private static void parseCopy(String field, ParseContext context) throws IOException;1536137328;Creates an copy of the current field with given field name and boost;private static void parseCopy(String field, ParseContext context) throws IOException {_        Mapper mapper = context.docMapper().mappers().getMapper(field)__        if (mapper != null) {_            if (mapper instanceof FieldMapper) {_                ((FieldMapper) mapper).parse(context)__            } else if (mapper instanceof FieldAliasMapper) {_                throw new IllegalArgumentException("Cannot copy to a field alias [" + mapper.name() + "].")__            } else {_                throw new IllegalStateException("The provided mapper [" + mapper.name() +_                    "] has an unrecognized type [" + mapper.getClass().getSimpleName() + "].")__            }_        } else {_            _            context = context.overridePath(new ContentPath(0))___            final String[] paths = splitAndValidatePath(field)__            final String fieldName = paths[paths.length-1]__            Tuple<Integer, ObjectMapper> parentMapperTuple = getDynamicParentMapper(context, paths, null)__            ObjectMapper objectMapper = parentMapperTuple.v2()__            parseDynamicValue(context, objectMapper, fieldName, context.parser().currentToken())__            for (int i = 0_ i < parentMapperTuple.v1()_ i++) {_                context.path().remove()__            }_        }_    };creates,an,copy,of,the,current,field,with,given,field,name,and,boost;private,static,void,parse,copy,string,field,parse,context,context,throws,ioexception,mapper,mapper,context,doc,mapper,mappers,get,mapper,field,if,mapper,null,if,mapper,instanceof,field,mapper,field,mapper,mapper,parse,context,else,if,mapper,instanceof,field,alias,mapper,throw,new,illegal,argument,exception,cannot,copy,to,a,field,alias,mapper,name,else,throw,new,illegal,state,exception,the,provided,mapper,mapper,name,has,an,unrecognized,type,mapper,get,class,get,simple,name,else,context,context,override,path,new,content,path,0,final,string,paths,split,and,validate,path,field,final,string,field,name,paths,paths,length,1,tuple,integer,object,mapper,parent,mapper,tuple,get,dynamic,parent,mapper,context,paths,null,object,mapper,object,mapper,parent,mapper,tuple,v2,parse,dynamic,value,context,object,mapper,field,name,context,parser,current,token,for,int,i,0,i,parent,mapper,tuple,v1,i,context,path,remove
DocumentParser -> private static void parseCopy(String field, ParseContext context) throws IOException;1537806831;Creates an copy of the current field with given field name and boost;private static void parseCopy(String field, ParseContext context) throws IOException {_        Mapper mapper = context.docMapper().mappers().getMapper(field)__        if (mapper != null) {_            if (mapper instanceof FieldMapper) {_                ((FieldMapper) mapper).parse(context)__            } else if (mapper instanceof FieldAliasMapper) {_                throw new IllegalArgumentException("Cannot copy to a field alias [" + mapper.name() + "].")__            } else {_                throw new IllegalStateException("The provided mapper [" + mapper.name() +_                    "] has an unrecognized type [" + mapper.getClass().getSimpleName() + "].")__            }_        } else {_            _            context = context.overridePath(new ContentPath(0))___            final String[] paths = splitAndValidatePath(field)__            final String fieldName = paths[paths.length-1]__            Tuple<Integer, ObjectMapper> parentMapperTuple = getDynamicParentMapper(context, paths, null)__            ObjectMapper objectMapper = parentMapperTuple.v2()__            parseDynamicValue(context, objectMapper, fieldName, context.parser().currentToken())__            for (int i = 0_ i < parentMapperTuple.v1()_ i++) {_                context.path().remove()__            }_        }_    };creates,an,copy,of,the,current,field,with,given,field,name,and,boost;private,static,void,parse,copy,string,field,parse,context,context,throws,ioexception,mapper,mapper,context,doc,mapper,mappers,get,mapper,field,if,mapper,null,if,mapper,instanceof,field,mapper,field,mapper,mapper,parse,context,else,if,mapper,instanceof,field,alias,mapper,throw,new,illegal,argument,exception,cannot,copy,to,a,field,alias,mapper,name,else,throw,new,illegal,state,exception,the,provided,mapper,mapper,name,has,an,unrecognized,type,mapper,get,class,get,simple,name,else,context,context,override,path,new,content,path,0,final,string,paths,split,and,validate,path,field,final,string,field,name,paths,paths,length,1,tuple,integer,object,mapper,parent,mapper,tuple,get,dynamic,parent,mapper,context,paths,null,object,mapper,object,mapper,parent,mapper,tuple,v2,parse,dynamic,value,context,object,mapper,field,name,context,parser,current,token,for,int,i,0,i,parent,mapper,tuple,v1,i,context,path,remove
DocumentParser -> private static void parseCopy(String field, ParseContext context) throws IOException;1541008027;Creates an copy of the current field with given field name and boost;private static void parseCopy(String field, ParseContext context) throws IOException {_        Mapper mapper = context.docMapper().mappers().getMapper(field)__        if (mapper != null) {_            if (mapper instanceof FieldMapper) {_                ((FieldMapper) mapper).parse(context)__            } else if (mapper instanceof FieldAliasMapper) {_                throw new IllegalArgumentException("Cannot copy to a field alias [" + mapper.name() + "].")__            } else {_                throw new IllegalStateException("The provided mapper [" + mapper.name() +_                    "] has an unrecognized type [" + mapper.getClass().getSimpleName() + "].")__            }_        } else {_            _            context = context.overridePath(new ContentPath(0))___            final String[] paths = splitAndValidatePath(field)__            final String fieldName = paths[paths.length-1]__            Tuple<Integer, ObjectMapper> parentMapperTuple = getDynamicParentMapper(context, paths, null)__            ObjectMapper objectMapper = parentMapperTuple.v2()__            parseDynamicValue(context, objectMapper, fieldName, context.parser().currentToken())__            for (int i = 0_ i < parentMapperTuple.v1()_ i++) {_                context.path().remove()__            }_        }_    };creates,an,copy,of,the,current,field,with,given,field,name,and,boost;private,static,void,parse,copy,string,field,parse,context,context,throws,ioexception,mapper,mapper,context,doc,mapper,mappers,get,mapper,field,if,mapper,null,if,mapper,instanceof,field,mapper,field,mapper,mapper,parse,context,else,if,mapper,instanceof,field,alias,mapper,throw,new,illegal,argument,exception,cannot,copy,to,a,field,alias,mapper,name,else,throw,new,illegal,state,exception,the,provided,mapper,mapper,name,has,an,unrecognized,type,mapper,get,class,get,simple,name,else,context,context,override,path,new,content,path,0,final,string,paths,split,and,validate,path,field,final,string,field,name,paths,paths,length,1,tuple,integer,object,mapper,parent,mapper,tuple,get,dynamic,parent,mapper,context,paths,null,object,mapper,object,mapper,parent,mapper,tuple,v2,parse,dynamic,value,context,object,mapper,field,name,context,parser,current,token,for,int,i,0,i,parent,mapper,tuple,v1,i,context,path,remove
DocumentParser -> private static void parseCopy(String field, ParseContext context) throws IOException;1542982526;Creates an copy of the current field with given field name and boost;private static void parseCopy(String field, ParseContext context) throws IOException {_        Mapper mapper = context.docMapper().mappers().getMapper(field)__        if (mapper != null) {_            if (mapper instanceof FieldMapper) {_                ((FieldMapper) mapper).parse(context)__            } else if (mapper instanceof FieldAliasMapper) {_                throw new IllegalArgumentException("Cannot copy to a field alias [" + mapper.name() + "].")__            } else {_                throw new IllegalStateException("The provided mapper [" + mapper.name() +_                    "] has an unrecognized type [" + mapper.getClass().getSimpleName() + "].")__            }_        } else {_            _            context = context.overridePath(new ContentPath(0))___            final String[] paths = splitAndValidatePath(field)__            final String fieldName = paths[paths.length-1]__            Tuple<Integer, ObjectMapper> parentMapperTuple = getDynamicParentMapper(context, paths, null)__            ObjectMapper objectMapper = parentMapperTuple.v2()__            parseDynamicValue(context, objectMapper, fieldName, context.parser().currentToken())__            for (int i = 0_ i < parentMapperTuple.v1()_ i++) {_                context.path().remove()__            }_        }_    };creates,an,copy,of,the,current,field,with,given,field,name,and,boost;private,static,void,parse,copy,string,field,parse,context,context,throws,ioexception,mapper,mapper,context,doc,mapper,mappers,get,mapper,field,if,mapper,null,if,mapper,instanceof,field,mapper,field,mapper,mapper,parse,context,else,if,mapper,instanceof,field,alias,mapper,throw,new,illegal,argument,exception,cannot,copy,to,a,field,alias,mapper,name,else,throw,new,illegal,state,exception,the,provided,mapper,mapper,name,has,an,unrecognized,type,mapper,get,class,get,simple,name,else,context,context,override,path,new,content,path,0,final,string,paths,split,and,validate,path,field,final,string,field,name,paths,paths,length,1,tuple,integer,object,mapper,parent,mapper,tuple,get,dynamic,parent,mapper,context,paths,null,object,mapper,object,mapper,parent,mapper,tuple,v2,parse,dynamic,value,context,object,mapper,field,name,context,parser,current,token,for,int,i,0,i,parent,mapper,tuple,v1,i,context,path,remove
DocumentParser -> private static void parseCopy(String field, ParseContext context) throws IOException;1543947737;Creates an copy of the current field with given field name and boost;private static void parseCopy(String field, ParseContext context) throws IOException {_        Mapper mapper = context.docMapper().mappers().getMapper(field)__        if (mapper != null) {_            if (mapper instanceof FieldMapper) {_                ((FieldMapper) mapper).parse(context)__            } else if (mapper instanceof FieldAliasMapper) {_                throw new IllegalArgumentException("Cannot copy to a field alias [" + mapper.name() + "].")__            } else {_                throw new IllegalStateException("The provided mapper [" + mapper.name() +_                    "] has an unrecognized type [" + mapper.getClass().getSimpleName() + "].")__            }_        } else {_            _            context = context.overridePath(new ContentPath(0))___            final String[] paths = splitAndValidatePath(field)__            final String fieldName = paths[paths.length-1]__            Tuple<Integer, ObjectMapper> parentMapperTuple = getDynamicParentMapper(context, paths, null)__            ObjectMapper objectMapper = parentMapperTuple.v2()__            parseDynamicValue(context, objectMapper, fieldName, context.parser().currentToken())__            for (int i = 0_ i < parentMapperTuple.v1()_ i++) {_                context.path().remove()__            }_        }_    };creates,an,copy,of,the,current,field,with,given,field,name,and,boost;private,static,void,parse,copy,string,field,parse,context,context,throws,ioexception,mapper,mapper,context,doc,mapper,mappers,get,mapper,field,if,mapper,null,if,mapper,instanceof,field,mapper,field,mapper,mapper,parse,context,else,if,mapper,instanceof,field,alias,mapper,throw,new,illegal,argument,exception,cannot,copy,to,a,field,alias,mapper,name,else,throw,new,illegal,state,exception,the,provided,mapper,mapper,name,has,an,unrecognized,type,mapper,get,class,get,simple,name,else,context,context,override,path,new,content,path,0,final,string,paths,split,and,validate,path,field,final,string,field,name,paths,paths,length,1,tuple,integer,object,mapper,parent,mapper,tuple,get,dynamic,parent,mapper,context,paths,null,object,mapper,object,mapper,parent,mapper,tuple,v2,parse,dynamic,value,context,object,mapper,field,name,context,parser,current,token,for,int,i,0,i,parent,mapper,tuple,v1,i,context,path,remove
DocumentParser -> private static void parseCopy(String field, ParseContext context) throws IOException;1544232221;Creates an copy of the current field with given field name and boost;private static void parseCopy(String field, ParseContext context) throws IOException {_        Mapper mapper = context.docMapper().mappers().getMapper(field)__        if (mapper != null) {_            if (mapper instanceof FieldMapper) {_                ((FieldMapper) mapper).parse(context)__            } else if (mapper instanceof FieldAliasMapper) {_                throw new IllegalArgumentException("Cannot copy to a field alias [" + mapper.name() + "].")__            } else {_                throw new IllegalStateException("The provided mapper [" + mapper.name() +_                    "] has an unrecognized type [" + mapper.getClass().getSimpleName() + "].")__            }_        } else {_            _            context = context.overridePath(new ContentPath(0))___            final String[] paths = splitAndValidatePath(field)__            final String fieldName = paths[paths.length-1]__            Tuple<Integer, ObjectMapper> parentMapperTuple = getDynamicParentMapper(context, paths, null)__            ObjectMapper objectMapper = parentMapperTuple.v2()__            parseDynamicValue(context, objectMapper, fieldName, context.parser().currentToken())__            for (int i = 0_ i < parentMapperTuple.v1()_ i++) {_                context.path().remove()__            }_        }_    };creates,an,copy,of,the,current,field,with,given,field,name,and,boost;private,static,void,parse,copy,string,field,parse,context,context,throws,ioexception,mapper,mapper,context,doc,mapper,mappers,get,mapper,field,if,mapper,null,if,mapper,instanceof,field,mapper,field,mapper,mapper,parse,context,else,if,mapper,instanceof,field,alias,mapper,throw,new,illegal,argument,exception,cannot,copy,to,a,field,alias,mapper,name,else,throw,new,illegal,state,exception,the,provided,mapper,mapper,name,has,an,unrecognized,type,mapper,get,class,get,simple,name,else,context,context,override,path,new,content,path,0,final,string,paths,split,and,validate,path,field,final,string,field,name,paths,paths,length,1,tuple,integer,object,mapper,parent,mapper,tuple,get,dynamic,parent,mapper,context,paths,null,object,mapper,object,mapper,parent,mapper,tuple,v2,parse,dynamic,value,context,object,mapper,field,name,context,parser,current,token,for,int,i,0,i,parent,mapper,tuple,v1,i,context,path,remove
DocumentParser -> private static void parseCopy(String field, ParseContext context) throws IOException;1544458001;Creates an copy of the current field with given field name and boost;private static void parseCopy(String field, ParseContext context) throws IOException {_        Mapper mapper = context.docMapper().mappers().getMapper(field)__        if (mapper != null) {_            if (mapper instanceof FieldMapper) {_                ((FieldMapper) mapper).parse(context)__            } else if (mapper instanceof FieldAliasMapper) {_                throw new IllegalArgumentException("Cannot copy to a field alias [" + mapper.name() + "].")__            } else {_                throw new IllegalStateException("The provided mapper [" + mapper.name() +_                    "] has an unrecognized type [" + mapper.getClass().getSimpleName() + "].")__            }_        } else {_            _            context = context.overridePath(new ContentPath(0))___            final String[] paths = splitAndValidatePath(field)__            final String fieldName = paths[paths.length-1]__            Tuple<Integer, ObjectMapper> parentMapperTuple = getDynamicParentMapper(context, paths, null)__            ObjectMapper objectMapper = parentMapperTuple.v2()__            parseDynamicValue(context, objectMapper, fieldName, context.parser().currentToken())__            for (int i = 0_ i < parentMapperTuple.v1()_ i++) {_                context.path().remove()__            }_        }_    };creates,an,copy,of,the,current,field,with,given,field,name,and,boost;private,static,void,parse,copy,string,field,parse,context,context,throws,ioexception,mapper,mapper,context,doc,mapper,mappers,get,mapper,field,if,mapper,null,if,mapper,instanceof,field,mapper,field,mapper,mapper,parse,context,else,if,mapper,instanceof,field,alias,mapper,throw,new,illegal,argument,exception,cannot,copy,to,a,field,alias,mapper,name,else,throw,new,illegal,state,exception,the,provided,mapper,mapper,name,has,an,unrecognized,type,mapper,get,class,get,simple,name,else,context,context,override,path,new,content,path,0,final,string,paths,split,and,validate,path,field,final,string,field,name,paths,paths,length,1,tuple,integer,object,mapper,parent,mapper,tuple,get,dynamic,parent,mapper,context,paths,null,object,mapper,object,mapper,parent,mapper,tuple,v2,parse,dynamic,value,context,object,mapper,field,name,context,parser,current,token,for,int,i,0,i,parent,mapper,tuple,v1,i,context,path,remove
DocumentParser -> private static void parseCopy(String field, ParseContext context) throws IOException;1548236405;Creates an copy of the current field with given field name and boost;private static void parseCopy(String field, ParseContext context) throws IOException {_        Mapper mapper = context.docMapper().mappers().getMapper(field)__        if (mapper != null) {_            if (mapper instanceof FieldMapper) {_                ((FieldMapper) mapper).parse(context)__            } else if (mapper instanceof FieldAliasMapper) {_                throw new IllegalArgumentException("Cannot copy to a field alias [" + mapper.name() + "].")__            } else {_                throw new IllegalStateException("The provided mapper [" + mapper.name() +_                    "] has an unrecognized type [" + mapper.getClass().getSimpleName() + "].")__            }_        } else {_            _            context = context.overridePath(new ContentPath(0))___            final String[] paths = splitAndValidatePath(field)__            final String fieldName = paths[paths.length-1]__            Tuple<Integer, ObjectMapper> parentMapperTuple = getDynamicParentMapper(context, paths, null)__            ObjectMapper objectMapper = parentMapperTuple.v2()__            parseDynamicValue(context, objectMapper, fieldName, context.parser().currentToken())__            for (int i = 0_ i < parentMapperTuple.v1()_ i++) {_                context.path().remove()__            }_        }_    };creates,an,copy,of,the,current,field,with,given,field,name,and,boost;private,static,void,parse,copy,string,field,parse,context,context,throws,ioexception,mapper,mapper,context,doc,mapper,mappers,get,mapper,field,if,mapper,null,if,mapper,instanceof,field,mapper,field,mapper,mapper,parse,context,else,if,mapper,instanceof,field,alias,mapper,throw,new,illegal,argument,exception,cannot,copy,to,a,field,alias,mapper,name,else,throw,new,illegal,state,exception,the,provided,mapper,mapper,name,has,an,unrecognized,type,mapper,get,class,get,simple,name,else,context,context,override,path,new,content,path,0,final,string,paths,split,and,validate,path,field,final,string,field,name,paths,paths,length,1,tuple,integer,object,mapper,parent,mapper,tuple,get,dynamic,parent,mapper,context,paths,null,object,mapper,object,mapper,parent,mapper,tuple,v2,parse,dynamic,value,context,object,mapper,field,name,context,parser,current,token,for,int,i,0,i,parent,mapper,tuple,v1,i,context,path,remove
DocumentParser -> private static int expandCommonMappers(List<ObjectMapper> parentMappers, String[] nameParts, int i);1524684173;Adds mappers from the end of the stack that exist as updates within those mappers._Returns the next unprocessed index from nameParts.;private static int expandCommonMappers(List<ObjectMapper> parentMappers, String[] nameParts, int i) {_        ObjectMapper last = parentMappers.get(parentMappers.size() - 1)__        while (i < nameParts.length - 1 && last.getMapper(nameParts[i]) != null) {_            Mapper newLast = last.getMapper(nameParts[i])__            assert newLast instanceof ObjectMapper__            last = (ObjectMapper) newLast__            parentMappers.add(last)__            ++i__        }_        return i__    };adds,mappers,from,the,end,of,the,stack,that,exist,as,updates,within,those,mappers,returns,the,next,unprocessed,index,from,name,parts;private,static,int,expand,common,mappers,list,object,mapper,parent,mappers,string,name,parts,int,i,object,mapper,last,parent,mappers,get,parent,mappers,size,1,while,i,name,parts,length,1,last,get,mapper,name,parts,i,null,mapper,new,last,last,get,mapper,name,parts,i,assert,new,last,instanceof,object,mapper,last,object,mapper,new,last,parent,mappers,add,last,i,return,i
DocumentParser -> private static int expandCommonMappers(List<ObjectMapper> parentMappers, String[] nameParts, int i);1531937412;Adds mappers from the end of the stack that exist as updates within those mappers._Returns the next unprocessed index from nameParts.;private static int expandCommonMappers(List<ObjectMapper> parentMappers, String[] nameParts, int i) {_        ObjectMapper last = parentMappers.get(parentMappers.size() - 1)__        while (i < nameParts.length - 1 && last.getMapper(nameParts[i]) != null) {_            Mapper newLast = last.getMapper(nameParts[i])__            assert newLast instanceof ObjectMapper__            last = (ObjectMapper) newLast__            parentMappers.add(last)__            ++i__        }_        return i__    };adds,mappers,from,the,end,of,the,stack,that,exist,as,updates,within,those,mappers,returns,the,next,unprocessed,index,from,name,parts;private,static,int,expand,common,mappers,list,object,mapper,parent,mappers,string,name,parts,int,i,object,mapper,last,parent,mappers,get,parent,mappers,size,1,while,i,name,parts,length,1,last,get,mapper,name,parts,i,null,mapper,new,last,last,get,mapper,name,parts,i,assert,new,last,instanceof,object,mapper,last,object,mapper,new,last,parent,mappers,add,last,i,return,i
DocumentParser -> private static int expandCommonMappers(List<ObjectMapper> parentMappers, String[] nameParts, int i);1535723122;Adds mappers from the end of the stack that exist as updates within those mappers._Returns the next unprocessed index from nameParts.;private static int expandCommonMappers(List<ObjectMapper> parentMappers, String[] nameParts, int i) {_        ObjectMapper last = parentMappers.get(parentMappers.size() - 1)__        while (i < nameParts.length - 1 && last.getMapper(nameParts[i]) != null) {_            Mapper newLast = last.getMapper(nameParts[i])__            assert newLast instanceof ObjectMapper__            last = (ObjectMapper) newLast__            parentMappers.add(last)__            ++i__        }_        return i__    };adds,mappers,from,the,end,of,the,stack,that,exist,as,updates,within,those,mappers,returns,the,next,unprocessed,index,from,name,parts;private,static,int,expand,common,mappers,list,object,mapper,parent,mappers,string,name,parts,int,i,object,mapper,last,parent,mappers,get,parent,mappers,size,1,while,i,name,parts,length,1,last,get,mapper,name,parts,i,null,mapper,new,last,last,get,mapper,name,parts,i,assert,new,last,instanceof,object,mapper,last,object,mapper,new,last,parent,mappers,add,last,i,return,i
DocumentParser -> private static int expandCommonMappers(List<ObjectMapper> parentMappers, String[] nameParts, int i);1536137328;Adds mappers from the end of the stack that exist as updates within those mappers._Returns the next unprocessed index from nameParts.;private static int expandCommonMappers(List<ObjectMapper> parentMappers, String[] nameParts, int i) {_        ObjectMapper last = parentMappers.get(parentMappers.size() - 1)__        while (i < nameParts.length - 1 && last.getMapper(nameParts[i]) != null) {_            Mapper newLast = last.getMapper(nameParts[i])__            assert newLast instanceof ObjectMapper__            last = (ObjectMapper) newLast__            parentMappers.add(last)__            ++i__        }_        return i__    };adds,mappers,from,the,end,of,the,stack,that,exist,as,updates,within,those,mappers,returns,the,next,unprocessed,index,from,name,parts;private,static,int,expand,common,mappers,list,object,mapper,parent,mappers,string,name,parts,int,i,object,mapper,last,parent,mappers,get,parent,mappers,size,1,while,i,name,parts,length,1,last,get,mapper,name,parts,i,null,mapper,new,last,last,get,mapper,name,parts,i,assert,new,last,instanceof,object,mapper,last,object,mapper,new,last,parent,mappers,add,last,i,return,i
DocumentParser -> private static int expandCommonMappers(List<ObjectMapper> parentMappers, String[] nameParts, int i);1537806831;Adds mappers from the end of the stack that exist as updates within those mappers._Returns the next unprocessed index from nameParts.;private static int expandCommonMappers(List<ObjectMapper> parentMappers, String[] nameParts, int i) {_        ObjectMapper last = parentMappers.get(parentMappers.size() - 1)__        while (i < nameParts.length - 1 && last.getMapper(nameParts[i]) != null) {_            Mapper newLast = last.getMapper(nameParts[i])__            assert newLast instanceof ObjectMapper__            last = (ObjectMapper) newLast__            parentMappers.add(last)__            ++i__        }_        return i__    };adds,mappers,from,the,end,of,the,stack,that,exist,as,updates,within,those,mappers,returns,the,next,unprocessed,index,from,name,parts;private,static,int,expand,common,mappers,list,object,mapper,parent,mappers,string,name,parts,int,i,object,mapper,last,parent,mappers,get,parent,mappers,size,1,while,i,name,parts,length,1,last,get,mapper,name,parts,i,null,mapper,new,last,last,get,mapper,name,parts,i,assert,new,last,instanceof,object,mapper,last,object,mapper,new,last,parent,mappers,add,last,i,return,i
DocumentParser -> private static int expandCommonMappers(List<ObjectMapper> parentMappers, String[] nameParts, int i);1541008027;Adds mappers from the end of the stack that exist as updates within those mappers._Returns the next unprocessed index from nameParts.;private static int expandCommonMappers(List<ObjectMapper> parentMappers, String[] nameParts, int i) {_        ObjectMapper last = parentMappers.get(parentMappers.size() - 1)__        while (i < nameParts.length - 1 && last.getMapper(nameParts[i]) != null) {_            Mapper newLast = last.getMapper(nameParts[i])__            assert newLast instanceof ObjectMapper__            last = (ObjectMapper) newLast__            parentMappers.add(last)__            ++i__        }_        return i__    };adds,mappers,from,the,end,of,the,stack,that,exist,as,updates,within,those,mappers,returns,the,next,unprocessed,index,from,name,parts;private,static,int,expand,common,mappers,list,object,mapper,parent,mappers,string,name,parts,int,i,object,mapper,last,parent,mappers,get,parent,mappers,size,1,while,i,name,parts,length,1,last,get,mapper,name,parts,i,null,mapper,new,last,last,get,mapper,name,parts,i,assert,new,last,instanceof,object,mapper,last,object,mapper,new,last,parent,mappers,add,last,i,return,i
DocumentParser -> private static int expandCommonMappers(List<ObjectMapper> parentMappers, String[] nameParts, int i);1542982526;Adds mappers from the end of the stack that exist as updates within those mappers._Returns the next unprocessed index from nameParts.;private static int expandCommonMappers(List<ObjectMapper> parentMappers, String[] nameParts, int i) {_        ObjectMapper last = parentMappers.get(parentMappers.size() - 1)__        while (i < nameParts.length - 1 && last.getMapper(nameParts[i]) != null) {_            Mapper newLast = last.getMapper(nameParts[i])__            assert newLast instanceof ObjectMapper__            last = (ObjectMapper) newLast__            parentMappers.add(last)__            ++i__        }_        return i__    };adds,mappers,from,the,end,of,the,stack,that,exist,as,updates,within,those,mappers,returns,the,next,unprocessed,index,from,name,parts;private,static,int,expand,common,mappers,list,object,mapper,parent,mappers,string,name,parts,int,i,object,mapper,last,parent,mappers,get,parent,mappers,size,1,while,i,name,parts,length,1,last,get,mapper,name,parts,i,null,mapper,new,last,last,get,mapper,name,parts,i,assert,new,last,instanceof,object,mapper,last,object,mapper,new,last,parent,mappers,add,last,i,return,i
DocumentParser -> private static int expandCommonMappers(List<ObjectMapper> parentMappers, String[] nameParts, int i);1543947737;Adds mappers from the end of the stack that exist as updates within those mappers._Returns the next unprocessed index from nameParts.;private static int expandCommonMappers(List<ObjectMapper> parentMappers, String[] nameParts, int i) {_        ObjectMapper last = parentMappers.get(parentMappers.size() - 1)__        while (i < nameParts.length - 1 && last.getMapper(nameParts[i]) != null) {_            Mapper newLast = last.getMapper(nameParts[i])__            assert newLast instanceof ObjectMapper__            last = (ObjectMapper) newLast__            parentMappers.add(last)__            ++i__        }_        return i__    };adds,mappers,from,the,end,of,the,stack,that,exist,as,updates,within,those,mappers,returns,the,next,unprocessed,index,from,name,parts;private,static,int,expand,common,mappers,list,object,mapper,parent,mappers,string,name,parts,int,i,object,mapper,last,parent,mappers,get,parent,mappers,size,1,while,i,name,parts,length,1,last,get,mapper,name,parts,i,null,mapper,new,last,last,get,mapper,name,parts,i,assert,new,last,instanceof,object,mapper,last,object,mapper,new,last,parent,mappers,add,last,i,return,i
DocumentParser -> private static int expandCommonMappers(List<ObjectMapper> parentMappers, String[] nameParts, int i);1544232221;Adds mappers from the end of the stack that exist as updates within those mappers._Returns the next unprocessed index from nameParts.;private static int expandCommonMappers(List<ObjectMapper> parentMappers, String[] nameParts, int i) {_        ObjectMapper last = parentMappers.get(parentMappers.size() - 1)__        while (i < nameParts.length - 1 && last.getMapper(nameParts[i]) != null) {_            Mapper newLast = last.getMapper(nameParts[i])__            assert newLast instanceof ObjectMapper__            last = (ObjectMapper) newLast__            parentMappers.add(last)__            ++i__        }_        return i__    };adds,mappers,from,the,end,of,the,stack,that,exist,as,updates,within,those,mappers,returns,the,next,unprocessed,index,from,name,parts;private,static,int,expand,common,mappers,list,object,mapper,parent,mappers,string,name,parts,int,i,object,mapper,last,parent,mappers,get,parent,mappers,size,1,while,i,name,parts,length,1,last,get,mapper,name,parts,i,null,mapper,new,last,last,get,mapper,name,parts,i,assert,new,last,instanceof,object,mapper,last,object,mapper,new,last,parent,mappers,add,last,i,return,i
DocumentParser -> private static int expandCommonMappers(List<ObjectMapper> parentMappers, String[] nameParts, int i);1544458001;Adds mappers from the end of the stack that exist as updates within those mappers._Returns the next unprocessed index from nameParts.;private static int expandCommonMappers(List<ObjectMapper> parentMappers, String[] nameParts, int i) {_        ObjectMapper last = parentMappers.get(parentMappers.size() - 1)__        while (i < nameParts.length - 1 && last.getMapper(nameParts[i]) != null) {_            Mapper newLast = last.getMapper(nameParts[i])__            assert newLast instanceof ObjectMapper__            last = (ObjectMapper) newLast__            parentMappers.add(last)__            ++i__        }_        return i__    };adds,mappers,from,the,end,of,the,stack,that,exist,as,updates,within,those,mappers,returns,the,next,unprocessed,index,from,name,parts;private,static,int,expand,common,mappers,list,object,mapper,parent,mappers,string,name,parts,int,i,object,mapper,last,parent,mappers,get,parent,mappers,size,1,while,i,name,parts,length,1,last,get,mapper,name,parts,i,null,mapper,new,last,last,get,mapper,name,parts,i,assert,new,last,instanceof,object,mapper,last,object,mapper,new,last,parent,mappers,add,last,i,return,i
DocumentParser -> private static int expandCommonMappers(List<ObjectMapper> parentMappers, String[] nameParts, int i);1548236405;Adds mappers from the end of the stack that exist as updates within those mappers._Returns the next unprocessed index from nameParts.;private static int expandCommonMappers(List<ObjectMapper> parentMappers, String[] nameParts, int i) {_        ObjectMapper last = parentMappers.get(parentMappers.size() - 1)__        while (i < nameParts.length - 1 && last.getMapper(nameParts[i]) != null) {_            Mapper newLast = last.getMapper(nameParts[i])__            assert newLast instanceof ObjectMapper__            last = (ObjectMapper) newLast__            parentMappers.add(last)__            ++i__        }_        return i__    };adds,mappers,from,the,end,of,the,stack,that,exist,as,updates,within,those,mappers,returns,the,next,unprocessed,index,from,name,parts;private,static,int,expand,common,mappers,list,object,mapper,parent,mappers,string,name,parts,int,i,object,mapper,last,parent,mappers,get,parent,mappers,size,1,while,i,name,parts,length,1,last,get,mapper,name,parts,i,null,mapper,new,last,last,get,mapper,name,parts,i,assert,new,last,instanceof,object,mapper,last,object,mapper,new,last,parent,mappers,add,last,i,return,i
DocumentParser -> private static ObjectMapper createExistingMapperUpdate(List<ObjectMapper> parentMappers, String[] nameParts, int i,                                                            DocumentMapper docMapper, Mapper newMapper);1524684173;Creates an update for intermediate object mappers that are not on the stack, but parents of newMapper.;private static ObjectMapper createExistingMapperUpdate(List<ObjectMapper> parentMappers, String[] nameParts, int i,_                                                           DocumentMapper docMapper, Mapper newMapper) {_        String updateParentName = nameParts[i]__        final ObjectMapper lastParent = parentMappers.get(parentMappers.size() - 1)__        if (parentMappers.size() > 1) {_            _            updateParentName = lastParent.name() + '.' + nameParts[i]__        }_        ObjectMapper updateParent = docMapper.objectMappers().get(updateParentName)__        assert updateParent != null : updateParentName + " doesn't exist"__        return createUpdate(updateParent, nameParts, i + 1, newMapper)__    };creates,an,update,for,intermediate,object,mappers,that,are,not,on,the,stack,but,parents,of,new,mapper;private,static,object,mapper,create,existing,mapper,update,list,object,mapper,parent,mappers,string,name,parts,int,i,document,mapper,doc,mapper,mapper,new,mapper,string,update,parent,name,name,parts,i,final,object,mapper,last,parent,parent,mappers,get,parent,mappers,size,1,if,parent,mappers,size,1,update,parent,name,last,parent,name,name,parts,i,object,mapper,update,parent,doc,mapper,object,mappers,get,update,parent,name,assert,update,parent,null,update,parent,name,doesn,t,exist,return,create,update,update,parent,name,parts,i,1,new,mapper
DocumentParser -> private static ObjectMapper createExistingMapperUpdate(List<ObjectMapper> parentMappers, String[] nameParts, int i,                                                            DocumentMapper docMapper, Mapper newMapper);1531937412;Creates an update for intermediate object mappers that are not on the stack, but parents of newMapper.;private static ObjectMapper createExistingMapperUpdate(List<ObjectMapper> parentMappers, String[] nameParts, int i,_                                                           DocumentMapper docMapper, Mapper newMapper) {_        String updateParentName = nameParts[i]__        final ObjectMapper lastParent = parentMappers.get(parentMappers.size() - 1)__        if (parentMappers.size() > 1) {_            _            updateParentName = lastParent.name() + '.' + nameParts[i]__        }_        ObjectMapper updateParent = docMapper.objectMappers().get(updateParentName)__        assert updateParent != null : updateParentName + " doesn't exist"__        return createUpdate(updateParent, nameParts, i + 1, newMapper)__    };creates,an,update,for,intermediate,object,mappers,that,are,not,on,the,stack,but,parents,of,new,mapper;private,static,object,mapper,create,existing,mapper,update,list,object,mapper,parent,mappers,string,name,parts,int,i,document,mapper,doc,mapper,mapper,new,mapper,string,update,parent,name,name,parts,i,final,object,mapper,last,parent,parent,mappers,get,parent,mappers,size,1,if,parent,mappers,size,1,update,parent,name,last,parent,name,name,parts,i,object,mapper,update,parent,doc,mapper,object,mappers,get,update,parent,name,assert,update,parent,null,update,parent,name,doesn,t,exist,return,create,update,update,parent,name,parts,i,1,new,mapper
DocumentParser -> private static ObjectMapper createExistingMapperUpdate(List<ObjectMapper> parentMappers, String[] nameParts, int i,                                                            DocumentMapper docMapper, Mapper newMapper);1535723122;Creates an update for intermediate object mappers that are not on the stack, but parents of newMapper.;private static ObjectMapper createExistingMapperUpdate(List<ObjectMapper> parentMappers, String[] nameParts, int i,_                                                           DocumentMapper docMapper, Mapper newMapper) {_        String updateParentName = nameParts[i]__        final ObjectMapper lastParent = parentMappers.get(parentMappers.size() - 1)__        if (parentMappers.size() > 1) {_            _            updateParentName = lastParent.name() + '.' + nameParts[i]__        }_        ObjectMapper updateParent = docMapper.objectMappers().get(updateParentName)__        assert updateParent != null : updateParentName + " doesn't exist"__        return createUpdate(updateParent, nameParts, i + 1, newMapper)__    };creates,an,update,for,intermediate,object,mappers,that,are,not,on,the,stack,but,parents,of,new,mapper;private,static,object,mapper,create,existing,mapper,update,list,object,mapper,parent,mappers,string,name,parts,int,i,document,mapper,doc,mapper,mapper,new,mapper,string,update,parent,name,name,parts,i,final,object,mapper,last,parent,parent,mappers,get,parent,mappers,size,1,if,parent,mappers,size,1,update,parent,name,last,parent,name,name,parts,i,object,mapper,update,parent,doc,mapper,object,mappers,get,update,parent,name,assert,update,parent,null,update,parent,name,doesn,t,exist,return,create,update,update,parent,name,parts,i,1,new,mapper
DocumentParser -> private static ObjectMapper createExistingMapperUpdate(List<ObjectMapper> parentMappers, String[] nameParts, int i,                                                            DocumentMapper docMapper, Mapper newMapper);1536137328;Creates an update for intermediate object mappers that are not on the stack, but parents of newMapper.;private static ObjectMapper createExistingMapperUpdate(List<ObjectMapper> parentMappers, String[] nameParts, int i,_                                                           DocumentMapper docMapper, Mapper newMapper) {_        String updateParentName = nameParts[i]__        final ObjectMapper lastParent = parentMappers.get(parentMappers.size() - 1)__        if (parentMappers.size() > 1) {_            _            updateParentName = lastParent.name() + '.' + nameParts[i]__        }_        ObjectMapper updateParent = docMapper.objectMappers().get(updateParentName)__        assert updateParent != null : updateParentName + " doesn't exist"__        return createUpdate(updateParent, nameParts, i + 1, newMapper)__    };creates,an,update,for,intermediate,object,mappers,that,are,not,on,the,stack,but,parents,of,new,mapper;private,static,object,mapper,create,existing,mapper,update,list,object,mapper,parent,mappers,string,name,parts,int,i,document,mapper,doc,mapper,mapper,new,mapper,string,update,parent,name,name,parts,i,final,object,mapper,last,parent,parent,mappers,get,parent,mappers,size,1,if,parent,mappers,size,1,update,parent,name,last,parent,name,name,parts,i,object,mapper,update,parent,doc,mapper,object,mappers,get,update,parent,name,assert,update,parent,null,update,parent,name,doesn,t,exist,return,create,update,update,parent,name,parts,i,1,new,mapper
DocumentParser -> private static ObjectMapper createExistingMapperUpdate(List<ObjectMapper> parentMappers, String[] nameParts, int i,                                                            DocumentMapper docMapper, Mapper newMapper);1537806831;Creates an update for intermediate object mappers that are not on the stack, but parents of newMapper.;private static ObjectMapper createExistingMapperUpdate(List<ObjectMapper> parentMappers, String[] nameParts, int i,_                                                           DocumentMapper docMapper, Mapper newMapper) {_        String updateParentName = nameParts[i]__        final ObjectMapper lastParent = parentMappers.get(parentMappers.size() - 1)__        if (parentMappers.size() > 1) {_            _            updateParentName = lastParent.name() + '.' + nameParts[i]__        }_        ObjectMapper updateParent = docMapper.objectMappers().get(updateParentName)__        assert updateParent != null : updateParentName + " doesn't exist"__        return createUpdate(updateParent, nameParts, i + 1, newMapper)__    };creates,an,update,for,intermediate,object,mappers,that,are,not,on,the,stack,but,parents,of,new,mapper;private,static,object,mapper,create,existing,mapper,update,list,object,mapper,parent,mappers,string,name,parts,int,i,document,mapper,doc,mapper,mapper,new,mapper,string,update,parent,name,name,parts,i,final,object,mapper,last,parent,parent,mappers,get,parent,mappers,size,1,if,parent,mappers,size,1,update,parent,name,last,parent,name,name,parts,i,object,mapper,update,parent,doc,mapper,object,mappers,get,update,parent,name,assert,update,parent,null,update,parent,name,doesn,t,exist,return,create,update,update,parent,name,parts,i,1,new,mapper
DocumentParser -> private static ObjectMapper createExistingMapperUpdate(List<ObjectMapper> parentMappers, String[] nameParts, int i,                                                            DocumentMapper docMapper, Mapper newMapper);1541008027;Creates an update for intermediate object mappers that are not on the stack, but parents of newMapper.;private static ObjectMapper createExistingMapperUpdate(List<ObjectMapper> parentMappers, String[] nameParts, int i,_                                                           DocumentMapper docMapper, Mapper newMapper) {_        String updateParentName = nameParts[i]__        final ObjectMapper lastParent = parentMappers.get(parentMappers.size() - 1)__        if (parentMappers.size() > 1) {_            _            updateParentName = lastParent.name() + '.' + nameParts[i]__        }_        ObjectMapper updateParent = docMapper.objectMappers().get(updateParentName)__        assert updateParent != null : updateParentName + " doesn't exist"__        return createUpdate(updateParent, nameParts, i + 1, newMapper)__    };creates,an,update,for,intermediate,object,mappers,that,are,not,on,the,stack,but,parents,of,new,mapper;private,static,object,mapper,create,existing,mapper,update,list,object,mapper,parent,mappers,string,name,parts,int,i,document,mapper,doc,mapper,mapper,new,mapper,string,update,parent,name,name,parts,i,final,object,mapper,last,parent,parent,mappers,get,parent,mappers,size,1,if,parent,mappers,size,1,update,parent,name,last,parent,name,name,parts,i,object,mapper,update,parent,doc,mapper,object,mappers,get,update,parent,name,assert,update,parent,null,update,parent,name,doesn,t,exist,return,create,update,update,parent,name,parts,i,1,new,mapper
DocumentParser -> private static ObjectMapper createExistingMapperUpdate(List<ObjectMapper> parentMappers, String[] nameParts, int i,                                                            DocumentMapper docMapper, Mapper newMapper);1542982526;Creates an update for intermediate object mappers that are not on the stack, but parents of newMapper.;private static ObjectMapper createExistingMapperUpdate(List<ObjectMapper> parentMappers, String[] nameParts, int i,_                                                           DocumentMapper docMapper, Mapper newMapper) {_        String updateParentName = nameParts[i]__        final ObjectMapper lastParent = parentMappers.get(parentMappers.size() - 1)__        if (parentMappers.size() > 1) {_            _            updateParentName = lastParent.name() + '.' + nameParts[i]__        }_        ObjectMapper updateParent = docMapper.objectMappers().get(updateParentName)__        assert updateParent != null : updateParentName + " doesn't exist"__        return createUpdate(updateParent, nameParts, i + 1, newMapper)__    };creates,an,update,for,intermediate,object,mappers,that,are,not,on,the,stack,but,parents,of,new,mapper;private,static,object,mapper,create,existing,mapper,update,list,object,mapper,parent,mappers,string,name,parts,int,i,document,mapper,doc,mapper,mapper,new,mapper,string,update,parent,name,name,parts,i,final,object,mapper,last,parent,parent,mappers,get,parent,mappers,size,1,if,parent,mappers,size,1,update,parent,name,last,parent,name,name,parts,i,object,mapper,update,parent,doc,mapper,object,mappers,get,update,parent,name,assert,update,parent,null,update,parent,name,doesn,t,exist,return,create,update,update,parent,name,parts,i,1,new,mapper
DocumentParser -> private static ObjectMapper createExistingMapperUpdate(List<ObjectMapper> parentMappers, String[] nameParts, int i,                                                            DocumentMapper docMapper, Mapper newMapper);1543947737;Creates an update for intermediate object mappers that are not on the stack, but parents of newMapper.;private static ObjectMapper createExistingMapperUpdate(List<ObjectMapper> parentMappers, String[] nameParts, int i,_                                                           DocumentMapper docMapper, Mapper newMapper) {_        String updateParentName = nameParts[i]__        final ObjectMapper lastParent = parentMappers.get(parentMappers.size() - 1)__        if (parentMappers.size() > 1) {_            _            updateParentName = lastParent.name() + '.' + nameParts[i]__        }_        ObjectMapper updateParent = docMapper.objectMappers().get(updateParentName)__        assert updateParent != null : updateParentName + " doesn't exist"__        return createUpdate(updateParent, nameParts, i + 1, newMapper)__    };creates,an,update,for,intermediate,object,mappers,that,are,not,on,the,stack,but,parents,of,new,mapper;private,static,object,mapper,create,existing,mapper,update,list,object,mapper,parent,mappers,string,name,parts,int,i,document,mapper,doc,mapper,mapper,new,mapper,string,update,parent,name,name,parts,i,final,object,mapper,last,parent,parent,mappers,get,parent,mappers,size,1,if,parent,mappers,size,1,update,parent,name,last,parent,name,name,parts,i,object,mapper,update,parent,doc,mapper,object,mappers,get,update,parent,name,assert,update,parent,null,update,parent,name,doesn,t,exist,return,create,update,update,parent,name,parts,i,1,new,mapper
DocumentParser -> private static ObjectMapper createExistingMapperUpdate(List<ObjectMapper> parentMappers, String[] nameParts, int i,                                                            DocumentMapper docMapper, Mapper newMapper);1544232221;Creates an update for intermediate object mappers that are not on the stack, but parents of newMapper.;private static ObjectMapper createExistingMapperUpdate(List<ObjectMapper> parentMappers, String[] nameParts, int i,_                                                           DocumentMapper docMapper, Mapper newMapper) {_        String updateParentName = nameParts[i]__        final ObjectMapper lastParent = parentMappers.get(parentMappers.size() - 1)__        if (parentMappers.size() > 1) {_            _            updateParentName = lastParent.name() + '.' + nameParts[i]__        }_        ObjectMapper updateParent = docMapper.objectMappers().get(updateParentName)__        assert updateParent != null : updateParentName + " doesn't exist"__        return createUpdate(updateParent, nameParts, i + 1, newMapper)__    };creates,an,update,for,intermediate,object,mappers,that,are,not,on,the,stack,but,parents,of,new,mapper;private,static,object,mapper,create,existing,mapper,update,list,object,mapper,parent,mappers,string,name,parts,int,i,document,mapper,doc,mapper,mapper,new,mapper,string,update,parent,name,name,parts,i,final,object,mapper,last,parent,parent,mappers,get,parent,mappers,size,1,if,parent,mappers,size,1,update,parent,name,last,parent,name,name,parts,i,object,mapper,update,parent,doc,mapper,object,mappers,get,update,parent,name,assert,update,parent,null,update,parent,name,doesn,t,exist,return,create,update,update,parent,name,parts,i,1,new,mapper
DocumentParser -> private static ObjectMapper createExistingMapperUpdate(List<ObjectMapper> parentMappers, String[] nameParts, int i,                                                            DocumentMapper docMapper, Mapper newMapper);1544458001;Creates an update for intermediate object mappers that are not on the stack, but parents of newMapper.;private static ObjectMapper createExistingMapperUpdate(List<ObjectMapper> parentMappers, String[] nameParts, int i,_                                                           DocumentMapper docMapper, Mapper newMapper) {_        String updateParentName = nameParts[i]__        final ObjectMapper lastParent = parentMappers.get(parentMappers.size() - 1)__        if (parentMappers.size() > 1) {_            _            updateParentName = lastParent.name() + '.' + nameParts[i]__        }_        ObjectMapper updateParent = docMapper.objectMappers().get(updateParentName)__        assert updateParent != null : updateParentName + " doesn't exist"__        return createUpdate(updateParent, nameParts, i + 1, newMapper)__    };creates,an,update,for,intermediate,object,mappers,that,are,not,on,the,stack,but,parents,of,new,mapper;private,static,object,mapper,create,existing,mapper,update,list,object,mapper,parent,mappers,string,name,parts,int,i,document,mapper,doc,mapper,mapper,new,mapper,string,update,parent,name,name,parts,i,final,object,mapper,last,parent,parent,mappers,get,parent,mappers,size,1,if,parent,mappers,size,1,update,parent,name,last,parent,name,name,parts,i,object,mapper,update,parent,doc,mapper,object,mappers,get,update,parent,name,assert,update,parent,null,update,parent,name,doesn,t,exist,return,create,update,update,parent,name,parts,i,1,new,mapper
DocumentParser -> private static ObjectMapper createExistingMapperUpdate(List<ObjectMapper> parentMappers, String[] nameParts, int i,                                                            DocumentMapper docMapper, Mapper newMapper);1548236405;Creates an update for intermediate object mappers that are not on the stack, but parents of newMapper.;private static ObjectMapper createExistingMapperUpdate(List<ObjectMapper> parentMappers, String[] nameParts, int i,_                                                           DocumentMapper docMapper, Mapper newMapper) {_        String updateParentName = nameParts[i]__        final ObjectMapper lastParent = parentMappers.get(parentMappers.size() - 1)__        if (parentMappers.size() > 1) {_            _            updateParentName = lastParent.name() + '.' + nameParts[i]__        }_        ObjectMapper updateParent = docMapper.objectMappers().get(updateParentName)__        assert updateParent != null : updateParentName + " doesn't exist"__        return createUpdate(updateParent, nameParts, i + 1, newMapper)__    };creates,an,update,for,intermediate,object,mappers,that,are,not,on,the,stack,but,parents,of,new,mapper;private,static,object,mapper,create,existing,mapper,update,list,object,mapper,parent,mappers,string,name,parts,int,i,document,mapper,doc,mapper,mapper,new,mapper,string,update,parent,name,name,parts,i,final,object,mapper,last,parent,parent,mappers,get,parent,mappers,size,1,if,parent,mappers,size,1,update,parent,name,last,parent,name,name,parts,i,object,mapper,update,parent,doc,mapper,object,mappers,get,update,parent,name,assert,update,parent,null,update,parent,name,doesn,t,exist,return,create,update,update,parent,name,parts,i,1,new,mapper
DocumentParser -> private static int removeUncommonMappers(List<ObjectMapper> parentMappers, String[] nameParts);1524684173;Removes mappers that exist on the stack, but are not part of the path of the current nameParts,_Returns the next unprocessed index from nameParts.;private static int removeUncommonMappers(List<ObjectMapper> parentMappers, String[] nameParts) {_        int keepBefore = 1__        while (keepBefore < parentMappers.size() &&_            parentMappers.get(keepBefore).simpleName().equals(nameParts[keepBefore - 1])) {_            ++keepBefore__        }_        popMappers(parentMappers, keepBefore, true)__        return keepBefore - 1__    };removes,mappers,that,exist,on,the,stack,but,are,not,part,of,the,path,of,the,current,name,parts,returns,the,next,unprocessed,index,from,name,parts;private,static,int,remove,uncommon,mappers,list,object,mapper,parent,mappers,string,name,parts,int,keep,before,1,while,keep,before,parent,mappers,size,parent,mappers,get,keep,before,simple,name,equals,name,parts,keep,before,1,keep,before,pop,mappers,parent,mappers,keep,before,true,return,keep,before,1
DocumentParser -> private static int removeUncommonMappers(List<ObjectMapper> parentMappers, String[] nameParts);1531937412;Removes mappers that exist on the stack, but are not part of the path of the current nameParts,_Returns the next unprocessed index from nameParts.;private static int removeUncommonMappers(List<ObjectMapper> parentMappers, String[] nameParts) {_        int keepBefore = 1__        while (keepBefore < parentMappers.size() &&_            parentMappers.get(keepBefore).simpleName().equals(nameParts[keepBefore - 1])) {_            ++keepBefore__        }_        popMappers(parentMappers, keepBefore, true)__        return keepBefore - 1__    };removes,mappers,that,exist,on,the,stack,but,are,not,part,of,the,path,of,the,current,name,parts,returns,the,next,unprocessed,index,from,name,parts;private,static,int,remove,uncommon,mappers,list,object,mapper,parent,mappers,string,name,parts,int,keep,before,1,while,keep,before,parent,mappers,size,parent,mappers,get,keep,before,simple,name,equals,name,parts,keep,before,1,keep,before,pop,mappers,parent,mappers,keep,before,true,return,keep,before,1
DocumentParser -> private static int removeUncommonMappers(List<ObjectMapper> parentMappers, String[] nameParts);1535723122;Removes mappers that exist on the stack, but are not part of the path of the current nameParts,_Returns the next unprocessed index from nameParts.;private static int removeUncommonMappers(List<ObjectMapper> parentMappers, String[] nameParts) {_        int keepBefore = 1__        while (keepBefore < parentMappers.size() &&_            parentMappers.get(keepBefore).simpleName().equals(nameParts[keepBefore - 1])) {_            ++keepBefore__        }_        popMappers(parentMappers, keepBefore, true)__        return keepBefore - 1__    };removes,mappers,that,exist,on,the,stack,but,are,not,part,of,the,path,of,the,current,name,parts,returns,the,next,unprocessed,index,from,name,parts;private,static,int,remove,uncommon,mappers,list,object,mapper,parent,mappers,string,name,parts,int,keep,before,1,while,keep,before,parent,mappers,size,parent,mappers,get,keep,before,simple,name,equals,name,parts,keep,before,1,keep,before,pop,mappers,parent,mappers,keep,before,true,return,keep,before,1
DocumentParser -> private static int removeUncommonMappers(List<ObjectMapper> parentMappers, String[] nameParts);1536137328;Removes mappers that exist on the stack, but are not part of the path of the current nameParts,_Returns the next unprocessed index from nameParts.;private static int removeUncommonMappers(List<ObjectMapper> parentMappers, String[] nameParts) {_        int keepBefore = 1__        while (keepBefore < parentMappers.size() &&_            parentMappers.get(keepBefore).simpleName().equals(nameParts[keepBefore - 1])) {_            ++keepBefore__        }_        popMappers(parentMappers, keepBefore, true)__        return keepBefore - 1__    };removes,mappers,that,exist,on,the,stack,but,are,not,part,of,the,path,of,the,current,name,parts,returns,the,next,unprocessed,index,from,name,parts;private,static,int,remove,uncommon,mappers,list,object,mapper,parent,mappers,string,name,parts,int,keep,before,1,while,keep,before,parent,mappers,size,parent,mappers,get,keep,before,simple,name,equals,name,parts,keep,before,1,keep,before,pop,mappers,parent,mappers,keep,before,true,return,keep,before,1
DocumentParser -> private static int removeUncommonMappers(List<ObjectMapper> parentMappers, String[] nameParts);1537806831;Removes mappers that exist on the stack, but are not part of the path of the current nameParts,_Returns the next unprocessed index from nameParts.;private static int removeUncommonMappers(List<ObjectMapper> parentMappers, String[] nameParts) {_        int keepBefore = 1__        while (keepBefore < parentMappers.size() &&_            parentMappers.get(keepBefore).simpleName().equals(nameParts[keepBefore - 1])) {_            ++keepBefore__        }_        popMappers(parentMappers, keepBefore, true)__        return keepBefore - 1__    };removes,mappers,that,exist,on,the,stack,but,are,not,part,of,the,path,of,the,current,name,parts,returns,the,next,unprocessed,index,from,name,parts;private,static,int,remove,uncommon,mappers,list,object,mapper,parent,mappers,string,name,parts,int,keep,before,1,while,keep,before,parent,mappers,size,parent,mappers,get,keep,before,simple,name,equals,name,parts,keep,before,1,keep,before,pop,mappers,parent,mappers,keep,before,true,return,keep,before,1
DocumentParser -> private static int removeUncommonMappers(List<ObjectMapper> parentMappers, String[] nameParts);1541008027;Removes mappers that exist on the stack, but are not part of the path of the current nameParts,_Returns the next unprocessed index from nameParts.;private static int removeUncommonMappers(List<ObjectMapper> parentMappers, String[] nameParts) {_        int keepBefore = 1__        while (keepBefore < parentMappers.size() &&_            parentMappers.get(keepBefore).simpleName().equals(nameParts[keepBefore - 1])) {_            ++keepBefore__        }_        popMappers(parentMappers, keepBefore, true)__        return keepBefore - 1__    };removes,mappers,that,exist,on,the,stack,but,are,not,part,of,the,path,of,the,current,name,parts,returns,the,next,unprocessed,index,from,name,parts;private,static,int,remove,uncommon,mappers,list,object,mapper,parent,mappers,string,name,parts,int,keep,before,1,while,keep,before,parent,mappers,size,parent,mappers,get,keep,before,simple,name,equals,name,parts,keep,before,1,keep,before,pop,mappers,parent,mappers,keep,before,true,return,keep,before,1
DocumentParser -> private static int removeUncommonMappers(List<ObjectMapper> parentMappers, String[] nameParts);1542982526;Removes mappers that exist on the stack, but are not part of the path of the current nameParts,_Returns the next unprocessed index from nameParts.;private static int removeUncommonMappers(List<ObjectMapper> parentMappers, String[] nameParts) {_        int keepBefore = 1__        while (keepBefore < parentMappers.size() &&_            parentMappers.get(keepBefore).simpleName().equals(nameParts[keepBefore - 1])) {_            ++keepBefore__        }_        popMappers(parentMappers, keepBefore, true)__        return keepBefore - 1__    };removes,mappers,that,exist,on,the,stack,but,are,not,part,of,the,path,of,the,current,name,parts,returns,the,next,unprocessed,index,from,name,parts;private,static,int,remove,uncommon,mappers,list,object,mapper,parent,mappers,string,name,parts,int,keep,before,1,while,keep,before,parent,mappers,size,parent,mappers,get,keep,before,simple,name,equals,name,parts,keep,before,1,keep,before,pop,mappers,parent,mappers,keep,before,true,return,keep,before,1
DocumentParser -> private static int removeUncommonMappers(List<ObjectMapper> parentMappers, String[] nameParts);1543947737;Removes mappers that exist on the stack, but are not part of the path of the current nameParts,_Returns the next unprocessed index from nameParts.;private static int removeUncommonMappers(List<ObjectMapper> parentMappers, String[] nameParts) {_        int keepBefore = 1__        while (keepBefore < parentMappers.size() &&_            parentMappers.get(keepBefore).simpleName().equals(nameParts[keepBefore - 1])) {_            ++keepBefore__        }_        popMappers(parentMappers, keepBefore, true)__        return keepBefore - 1__    };removes,mappers,that,exist,on,the,stack,but,are,not,part,of,the,path,of,the,current,name,parts,returns,the,next,unprocessed,index,from,name,parts;private,static,int,remove,uncommon,mappers,list,object,mapper,parent,mappers,string,name,parts,int,keep,before,1,while,keep,before,parent,mappers,size,parent,mappers,get,keep,before,simple,name,equals,name,parts,keep,before,1,keep,before,pop,mappers,parent,mappers,keep,before,true,return,keep,before,1
DocumentParser -> private static int removeUncommonMappers(List<ObjectMapper> parentMappers, String[] nameParts);1544232221;Removes mappers that exist on the stack, but are not part of the path of the current nameParts,_Returns the next unprocessed index from nameParts.;private static int removeUncommonMappers(List<ObjectMapper> parentMappers, String[] nameParts) {_        int keepBefore = 1__        while (keepBefore < parentMappers.size() &&_            parentMappers.get(keepBefore).simpleName().equals(nameParts[keepBefore - 1])) {_            ++keepBefore__        }_        popMappers(parentMappers, keepBefore, true)__        return keepBefore - 1__    };removes,mappers,that,exist,on,the,stack,but,are,not,part,of,the,path,of,the,current,name,parts,returns,the,next,unprocessed,index,from,name,parts;private,static,int,remove,uncommon,mappers,list,object,mapper,parent,mappers,string,name,parts,int,keep,before,1,while,keep,before,parent,mappers,size,parent,mappers,get,keep,before,simple,name,equals,name,parts,keep,before,1,keep,before,pop,mappers,parent,mappers,keep,before,true,return,keep,before,1
DocumentParser -> private static int removeUncommonMappers(List<ObjectMapper> parentMappers, String[] nameParts);1544458001;Removes mappers that exist on the stack, but are not part of the path of the current nameParts,_Returns the next unprocessed index from nameParts.;private static int removeUncommonMappers(List<ObjectMapper> parentMappers, String[] nameParts) {_        int keepBefore = 1__        while (keepBefore < parentMappers.size() &&_            parentMappers.get(keepBefore).simpleName().equals(nameParts[keepBefore - 1])) {_            ++keepBefore__        }_        popMappers(parentMappers, keepBefore, true)__        return keepBefore - 1__    };removes,mappers,that,exist,on,the,stack,but,are,not,part,of,the,path,of,the,current,name,parts,returns,the,next,unprocessed,index,from,name,parts;private,static,int,remove,uncommon,mappers,list,object,mapper,parent,mappers,string,name,parts,int,keep,before,1,while,keep,before,parent,mappers,size,parent,mappers,get,keep,before,simple,name,equals,name,parts,keep,before,1,keep,before,pop,mappers,parent,mappers,keep,before,true,return,keep,before,1
DocumentParser -> private static int removeUncommonMappers(List<ObjectMapper> parentMappers, String[] nameParts);1548236405;Removes mappers that exist on the stack, but are not part of the path of the current nameParts,_Returns the next unprocessed index from nameParts.;private static int removeUncommonMappers(List<ObjectMapper> parentMappers, String[] nameParts) {_        int keepBefore = 1__        while (keepBefore < parentMappers.size() &&_            parentMappers.get(keepBefore).simpleName().equals(nameParts[keepBefore - 1])) {_            ++keepBefore__        }_        popMappers(parentMappers, keepBefore, true)__        return keepBefore - 1__    };removes,mappers,that,exist,on,the,stack,but,are,not,part,of,the,path,of,the,current,name,parts,returns,the,next,unprocessed,index,from,name,parts;private,static,int,remove,uncommon,mappers,list,object,mapper,parent,mappers,string,name,parts,int,keep,before,1,while,keep,before,parent,mappers,size,parent,mappers,get,keep,before,simple,name,equals,name,parts,keep,before,1,keep,before,pop,mappers,parent,mappers,keep,before,true,return,keep,before,1
