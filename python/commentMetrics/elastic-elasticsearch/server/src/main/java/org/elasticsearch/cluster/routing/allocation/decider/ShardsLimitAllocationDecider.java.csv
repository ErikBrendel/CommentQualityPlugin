commented;modifiers;parameterAmount;loc;comment;code
false;private;1;3;;private void setClusterShardLimit(int clusterShardLimit) {     this.clusterShardLimit = clusterShardLimit. }
false;public;3;4;;@Override public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {     return doDecide(shardRouting, node, allocation, (count, limit) -> count >= limit). }
false;public;3;5;;@Override public Decision canRemain(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {     return doDecide(shardRouting, node, allocation, (count, limit) -> count > limit). }
false;private;4;40;;private Decision doDecide(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation, BiPredicate<Integer, Integer> decider) {     IndexMetaData indexMd = allocation.metaData().getIndexSafe(shardRouting.index()).     final int indexShardLimit = INDEX_TOTAL_SHARDS_PER_NODE_SETTING.get(indexMd.getSettings(), settings).     // Capture the limit here in case it changes during this method's     // execution     final int clusterShardLimit = this.clusterShardLimit.     if (indexShardLimit <= 0 && clusterShardLimit <= 0) {         return allocation.decision(Decision.YES, NAME, "total shard limits are disabled: [index: %d, cluster: %d] <= 0", indexShardLimit, clusterShardLimit).     }     int indexShardCount = 0.     int nodeShardCount = 0.     for (ShardRouting nodeShard : node) {         // don't count relocating shards...         if (nodeShard.relocating()) {             continue.         }         nodeShardCount++.         if (nodeShard.index().equals(shardRouting.index())) {             indexShardCount++.         }     }     if (clusterShardLimit > 0 && decider.test(nodeShardCount, clusterShardLimit)) {         return allocation.decision(Decision.NO, NAME, "too many shards [%d] allocated to this node, cluster setting [%s=%d]", nodeShardCount, CLUSTER_TOTAL_SHARDS_PER_NODE_SETTING.getKey(), clusterShardLimit).     }     if (indexShardLimit > 0 && decider.test(indexShardCount, indexShardLimit)) {         return allocation.decision(Decision.NO, NAME, "too many shards [%d] allocated to this node for index [%s], index setting [%s=%d]", indexShardCount, shardRouting.getIndexName(), INDEX_TOTAL_SHARDS_PER_NODE_SETTING.getKey(), indexShardLimit).     }     return allocation.decision(Decision.YES, NAME, "the shard count [%d] for this node is under the index limit [%d] and cluster level node limit [%d]", nodeShardCount, indexShardLimit, clusterShardLimit). }
false;public;2;29;;@Override public Decision canAllocate(RoutingNode node, RoutingAllocation allocation) {     // Only checks the node-level limit, not the index-level     // Capture the limit here in case it changes during this method's     // execution     final int clusterShardLimit = this.clusterShardLimit.     if (clusterShardLimit <= 0) {         return allocation.decision(Decision.YES, NAME, "total shard limits are disabled: [cluster: %d] <= 0", clusterShardLimit).     }     int nodeShardCount = 0.     for (ShardRouting nodeShard : node) {         // don't count relocating shards...         if (nodeShard.relocating()) {             continue.         }         nodeShardCount++.     }     if (clusterShardLimit >= 0 && nodeShardCount >= clusterShardLimit) {         return allocation.decision(Decision.NO, NAME, "too many shards [%d] allocated to this node, cluster setting [%s=%d]", nodeShardCount, CLUSTER_TOTAL_SHARDS_PER_NODE_SETTING.getKey(), clusterShardLimit).     }     return allocation.decision(Decision.YES, NAME, "the shard count [%d] for this node is under the cluster level node limit [%d]", nodeShardCount, clusterShardLimit). }
