commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public List<SingleMemberInjector> getMemberInjectors() {     return memberInjectors. }
false;public;1;11;;@Override public void injectMembers(T instance) {     Errors errors = new Errors(typeLiteral).     try {         injectAndNotify(instance, errors).     } catch (ErrorsException e) {         errors.merge(e.getErrors()).     }     errors.throwProvisionExceptionIfErrorsExist(). }
false;public;1;5;;@Override public Void call(InternalContext context) throws ErrorsException {     injectMembers(instance, errors, context).     return null. }
false;;2;15;;void injectAndNotify(final T instance, final Errors errors) throws ErrorsException {     if (instance == null) {         return.     }     injector.callInContext(new ContextualCallable<Void>() {          @Override         public Void call(InternalContext context) throws ErrorsException {             injectMembers(instance, errors, context).             return null.         }     }).     notifyListeners(instance, errors). }
false;;2;11;;void notifyListeners(T instance, Errors errors) throws ErrorsException {     int numErrorsBefore = errors.size().     for (InjectionListener<? super T> injectionListener : injectionListeners) {         try {             injectionListener.afterInjection(instance).         } catch (RuntimeException e) {             errors.errorNotifyingInjectionListener(injectionListener, typeLiteral, e).         }     }     errors.throwIfNewErrors(numErrorsBefore). }
false;;3;16;;void injectMembers(T t, Errors errors, InternalContext context) {     // optimization: use manual for/each to save allocating an iterator here     for (int i = 0, size = memberInjectors.size(). i < size. i++) {         memberInjectors.get(i).inject(errors, context, t).     }     // optimization: use manual for/each to save allocating an iterator here     for (int i = 0, size = userMembersInjectors.size(). i < size. i++) {         MembersInjector<? super T> userMembersInjector = userMembersInjectors.get(i).         try {             userMembersInjector.injectMembers(t).         } catch (RuntimeException e) {             errors.errorInUserInjector(userMembersInjector, typeLiteral, e).         }     } }
false;public;0;4;;@Override public String toString() {     return "MembersInjector<" + typeLiteral + ">". }
false;public;0;5;;public Set<InjectionPoint> getInjectionPoints() {     return unmodifiableSet(memberInjectors.stream().map(SingleMemberInjector::getInjectionPoint).collect(toSet())). }
