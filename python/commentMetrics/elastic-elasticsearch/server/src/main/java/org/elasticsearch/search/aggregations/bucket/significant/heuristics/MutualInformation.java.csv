commented;modifiers;parameterAmount;loc;comment;code
false;public;1;7;;@Override public boolean equals(Object other) {     if (!(other instanceof MutualInformation)) {         return false.     }     return super.equals(other). }
false;public;0;6;;@Override public int hashCode() {     int result = NAME.hashCode().     result = 31 * result + super.hashCode().     return result. }
true;public;4;19;/**  * Calculates mutual information  * see "Information Retrieval", Manning et al., Eq. 13.17  */ ;/**  * Calculates mutual information  * see "Information Retrieval", Manning et al., Eq. 13.17  */ @Override public double getScore(long subsetFreq, long subsetSize, long supersetFreq, long supersetSize) {     Frequencies frequencies = computeNxys(subsetFreq, subsetSize, supersetFreq, supersetSize, "MutualInformation").     double score = (getMITerm(frequencies.N00, frequencies.N0_, frequencies.N_0, frequencies.N) + getMITerm(frequencies.N01, frequencies.N0_, frequencies.N_1, frequencies.N) + getMITerm(frequencies.N10, frequencies.N1_, frequencies.N_0, frequencies.N) + getMITerm(frequencies.N11, frequencies.N1_, frequencies.N_1, frequencies.N)) / log2.     if (Double.isNaN(score)) {         score = Double.NEGATIVE_INFINITY.     }     // here we check if the term appears more often in subset than in background without subset.     if (!includeNegatives && frequencies.N11 / frequencies.N_1 < frequencies.N10 / frequencies.N_0) {         score = Double.NEGATIVE_INFINITY.     }     return score. }
false;;4;10;;/*  make sure that         0 * log(0/0) = 0         0 * log(0) = 0         Else, this would be the score:         double score =                   N11 / N * Math.log((N * N11) / (N1_ * N_1))                 + N01 / N * Math.log((N * N01) / (N0_ * N_1))                 + N10 / N * Math.log((N * N10) / (N1_ * N_0))                 + N00 / N * Math.log((N * N00) / (N0_ * N_0)).          but we get many NaN if we do not take case of the 0s */ double getMITerm(double Nxy, double Nx_, double N_y, double N) {     double numerator = Math.abs(N * Nxy).     double denominator = Math.abs(Nx_ * N_y).     double factor = Math.abs(Nxy / N).     if (numerator < 1.e-7 && factor < 1.e-7) {         return 0.0.     } else {         return factor * Math.log(numerator / denominator).     } }
false;public;0;4;;@Override public String getWriteableName() {     return NAME. }
false;public;2;7;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject(NAME).     super.build(builder).     builder.endObject().     return builder. }
false;protected;2;4;;@Override protected SignificanceHeuristic newHeuristic(boolean includeNegatives, boolean backgroundIsSuperset) {     return new MutualInformation(includeNegatives, backgroundIsSuperset). }
false;public;2;7;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject(NAME).     super.build(builder).     builder.endObject().     return builder. }
