commented;modifiers;parameterAmount;loc;comment;code
true;public;2;3;/**  * Adds a new piece of metadata with the given key.  * If the provided key is already present, the corresponding metadata will be replaced  */ ;/**  * Adds a new piece of metadata with the given key.  * If the provided key is already present, the corresponding metadata will be replaced  */ public void addMetadata(String key, String... values) {     addMetadata(key, Arrays.asList(values)). }
true;public;2;7;/**  * Adds a new piece of metadata with the given key.  * If the provided key is already present, the corresponding metadata will be replaced  */ ;/**  * Adds a new piece of metadata with the given key.  * If the provided key is already present, the corresponding metadata will be replaced  */ public void addMetadata(String key, List<String> values) {     // we need to enforce this otherwise bw comp doesn't work properly, as "es." was the previous criteria to split headers in two sets     if (key.startsWith("es.") == false) {         throw new IllegalArgumentException("exception metadata must start with [es.], found [" + key + "] instead").     }     this.metadata.put(key, values). }
true;public;0;3;/**  * Returns a set of all metadata keys on this exception  */ ;/**  * Returns a set of all metadata keys on this exception  */ public Set<String> getMetadataKeys() {     return metadata.keySet(). }
true;public;1;3;/**  * Returns the list of metadata values for the given key or {@code null} if no metadata for the  * given key exists.  */ ;/**  * Returns the list of metadata values for the given key or {@code null} if no metadata for the  * given key exists.  */ public List<String> getMetadata(String key) {     return metadata.get(key). }
false;protected;0;3;;protected Map<String, List<String>> getMetadata() {     return metadata. }
true;public;2;7;/**  * Adds a new header with the given key.  * This method will replace existing header if a header with the same key already exists  */ ;/**  * Adds a new header with the given key.  * This method will replace existing header if a header with the same key already exists  */ public void addHeader(String key, List<String> value) {     // we need to enforce this otherwise bw comp doesn't work properly, as "es." was the previous criteria to split headers in two sets     if (key.startsWith("es.")) {         throw new IllegalArgumentException("exception headers must not start with [es.], found [" + key + "] instead").     }     this.headers.put(key, value). }
true;public;2;3;/**  * Adds a new header with the given key.  * This method will replace existing header if a header with the same key already exists  */ ;/**  * Adds a new header with the given key.  * This method will replace existing header if a header with the same key already exists  */ public void addHeader(String key, String... value) {     addHeader(key, Arrays.asList(value)). }
true;public;0;3;/**  * Returns a set of all header keys on this exception  */ ;/**  * Returns a set of all header keys on this exception  */ public Set<String> getHeaderKeys() {     return headers.keySet(). }
true;public;1;3;/**  * Returns the list of header values for the given key or {@code null} if no header for the  * given key exists.  */ ;/**  * Returns the list of header values for the given key or {@code null} if no header for the  * given key exists.  */ public List<String> getHeader(String key) {     return headers.get(key). }
false;protected;0;3;;protected Map<String, List<String>> getHeaders() {     return headers. }
true;public;0;8;/**  * Returns the rest status code associated with this exception.  */ ;/**  * Returns the rest status code associated with this exception.  */ public RestStatus status() {     Throwable cause = unwrapCause().     if (cause == this) {         return RestStatus.INTERNAL_SERVER_ERROR.     } else {         return ExceptionsHelper.status(cause).     } }
true;public;0;3;/**  * Unwraps the actual cause from the exception for cases when the exception is a  * {@link ElasticsearchWrapperException}.  *  * @see ExceptionsHelper#unwrapCause(Throwable)  */ ;/**  * Unwraps the actual cause from the exception for cases when the exception is a  * {@link ElasticsearchWrapperException}.  *  * @see ExceptionsHelper#unwrapCause(Throwable)  */ public Throwable unwrapCause() {     return ExceptionsHelper.unwrapCause(this). }
true;public;0;14;/**  * Return the detail message, including the message from the nested exception  * if there is one.  */ ;/**  * Return the detail message, including the message from the nested exception  * if there is one.  */ public String getDetailedMessage() {     if (getCause() != null) {         StringBuilder sb = new StringBuilder().         sb.append(toString()).append(". ").         if (getCause() instanceof ElasticsearchException) {             sb.append(((ElasticsearchException) getCause()).getDetailedMessage()).         } else {             sb.append(getCause()).         }         return sb.toString().     } else {         return super.toString().     } }
true;public;0;9;/**  * Retrieve the innermost cause of this exception, if none, returns the current exception.  */ ;/**  * Retrieve the innermost cause of this exception, if none, returns the current exception.  */ public Throwable getRootCause() {     Throwable rootCause = this.     Throwable cause = getCause().     while (cause != null && cause != rootCause) {         rootCause = cause.         cause = cause.getCause().     }     return rootCause. }
false;public;1;8;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeOptionalString(this.getMessage()).     out.writeException(this.getCause()).     writeStackTraces(this, out).     out.writeMapOfLists(headers, StreamOutput::writeString, StreamOutput::writeString).     out.writeMapOfLists(metadata, StreamOutput::writeString, StreamOutput::writeString). }
false;public,static;2;7;;public static ElasticsearchException readException(StreamInput input, int id) throws IOException {     CheckedFunction<StreamInput, ? extends ElasticsearchException, IOException> elasticsearchException = ID_TO_SUPPLIER.get(id).     if (elasticsearchException == null) {         throw new IllegalStateException("unknown exception for id: " + id).     }     return elasticsearchException.apply(input). }
true;public,static;2;7;/**  * Returns <code>true</code> iff the given class is a registered for an exception to be read.  */ ;/**  * Returns <code>true</code> iff the given class is a registered for an exception to be read.  */ public static boolean isRegistered(Class<? extends Throwable> exception, Version version) {     ElasticsearchExceptionHandle elasticsearchExceptionHandle = CLASS_TO_ELASTICSEARCH_EXCEPTION_HANDLE.get(exception).     if (elasticsearchExceptionHandle != null) {         return version.onOrAfter(elasticsearchExceptionHandle.versionAdded).     }     return false. }
false;static;0;3;;static Set<Class<? extends ElasticsearchException>> getRegisteredKeys() {     // for testing     return CLASS_TO_ELASTICSEARCH_EXCEPTION_HANDLE.keySet(). }
true;public,static;1;3;/**  * Returns the serialization id the given exception.  */ ;/**  * Returns the serialization id the given exception.  */ public static int getId(Class<? extends ElasticsearchException> exception) {     return CLASS_TO_ELASTICSEARCH_EXCEPTION_HANDLE.get(exception).id. }
false;public;2;10;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     Throwable ex = ExceptionsHelper.unwrapCause(this).     if (ex != this) {         generateThrowableXContent(builder, params, this).     } else {         innerToXContent(builder, params, this, getExceptionName(), getMessage(), headers, metadata, getCause()).     }     return builder. }
false;protected,static;8;47;;protected static void innerToXContent(XContentBuilder builder, Params params, Throwable throwable, String type, String message, Map<String, List<String>> headers, Map<String, List<String>> metadata, Throwable cause) throws IOException {     builder.field(TYPE, type).     builder.field(REASON, message).     for (Map.Entry<String, List<String>> entry : metadata.entrySet()) {         headerToXContent(builder, entry.getKey().substring("es.".length()), entry.getValue()).     }     if (throwable instanceof ElasticsearchException) {         ElasticsearchException exception = (ElasticsearchException) throwable.         exception.metadataToXContent(builder, params).     }     if (params.paramAsBoolean(REST_EXCEPTION_SKIP_CAUSE, REST_EXCEPTION_SKIP_CAUSE_DEFAULT) == false) {         if (cause != null) {             builder.field(CAUSED_BY).             builder.startObject().             generateThrowableXContent(builder, params, cause).             builder.endObject().         }     }     if (headers.isEmpty() == false) {         builder.startObject(HEADER).         for (Map.Entry<String, List<String>> entry : headers.entrySet()) {             headerToXContent(builder, entry.getKey(), entry.getValue()).         }         builder.endObject().     }     if (params.paramAsBoolean(REST_EXCEPTION_SKIP_STACK_TRACE, REST_EXCEPTION_SKIP_STACK_TRACE_DEFAULT) == false) {         builder.field(STACK_TRACE, ExceptionsHelper.stackTrace(throwable)).     }     Throwable[] allSuppressed = throwable.getSuppressed().     if (allSuppressed.length > 0) {         builder.startArray(SUPPRESSED.getPreferredName()).         for (Throwable suppressed : allSuppressed) {             builder.startObject().             generateThrowableXContent(builder, params, suppressed).             builder.endObject().         }         builder.endArray().     } }
false;private,static;3;13;;private static void headerToXContent(XContentBuilder builder, String key, List<String> values) throws IOException {     if (values != null && values.isEmpty() == false) {         if (values.size() == 1) {             builder.field(key, values.get(0)).         } else {             builder.startArray(key).             for (String value : values) {                 builder.value(value).             }             builder.endArray().         }     } }
true;protected;2;2;/**  * Renders additional per exception information into the XContent  */ ;/**  * Renders additional per exception information into the XContent  */ protected void metadataToXContent(XContentBuilder builder, Params params) throws IOException { }
true;public,static;1;5;/**  * Generate a {@link ElasticsearchException} from a {@link XContentParser}. This does not  * return the original exception type (ie NodeClosedException for example) but just wraps  * the type, the reason and the cause of the exception. It also recursively parses the  * tree structure of the cause, returning it as a tree structure of {@link ElasticsearchException}  * instances.  */ ;/**  * Generate a {@link ElasticsearchException} from a {@link XContentParser}. This does not  * return the original exception type (ie NodeClosedException for example) but just wraps  * the type, the reason and the cause of the exception. It also recursively parses the  * tree structure of the cause, returning it as a tree structure of {@link ElasticsearchException}  * instances.  */ public static ElasticsearchException fromXContent(XContentParser parser) throws IOException {     XContentParser.Token token = parser.nextToken().     ensureExpectedToken(XContentParser.Token.FIELD_NAME, token, parser::getTokenLocation).     return innerFromXContent(parser, false). }
false;public,static;2;110;;public static ElasticsearchException innerFromXContent(XContentParser parser, boolean parseRootCauses) throws IOException {     XContentParser.Token token = parser.currentToken().     ensureExpectedToken(XContentParser.Token.FIELD_NAME, token, parser::getTokenLocation).     String type = null, reason = null, stack = null.     ElasticsearchException cause = null.     Map<String, List<String>> metadata = new HashMap<>().     Map<String, List<String>> headers = new HashMap<>().     List<ElasticsearchException> rootCauses = new ArrayList<>().     List<ElasticsearchException> suppressed = new ArrayList<>().     for (. token == XContentParser.Token.FIELD_NAME. token = parser.nextToken()) {         String currentFieldName = parser.currentName().         token = parser.nextToken().         if (token.isValue()) {             if (TYPE.equals(currentFieldName)) {                 type = parser.text().             } else if (REASON.equals(currentFieldName)) {                 reason = parser.text().             } else if (STACK_TRACE.equals(currentFieldName)) {                 stack = parser.text().             } else if (token == XContentParser.Token.VALUE_STRING) {                 metadata.put(currentFieldName, Collections.singletonList(parser.text())).             }         } else if (token == XContentParser.Token.START_OBJECT) {             if (CAUSED_BY.equals(currentFieldName)) {                 cause = fromXContent(parser).             } else if (HEADER.equals(currentFieldName)) {                 while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {                     if (token == XContentParser.Token.FIELD_NAME) {                         currentFieldName = parser.currentName().                     } else {                         List<String> values = headers.getOrDefault(currentFieldName, new ArrayList<>()).                         if (token == XContentParser.Token.VALUE_STRING) {                             values.add(parser.text()).                         } else if (token == XContentParser.Token.START_ARRAY) {                             while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {                                 if (token == XContentParser.Token.VALUE_STRING) {                                     values.add(parser.text()).                                 } else {                                     parser.skipChildren().                                 }                             }                         } else if (token == XContentParser.Token.START_OBJECT) {                             parser.skipChildren().                         }                         headers.put(currentFieldName, values).                     }                 }             } else {                 // Any additional metadata object added by the metadataToXContent method is ignored                 // and skipped, so that the parser does not fail on unknown fields. The parser only                 // support metadata key-pairs and metadata arrays of values.                 parser.skipChildren().             }         } else if (token == XContentParser.Token.START_ARRAY) {             if (parseRootCauses && ROOT_CAUSE.equals(currentFieldName)) {                 while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {                     rootCauses.add(fromXContent(parser)).                 }             } else if (SUPPRESSED.match(currentFieldName, parser.getDeprecationHandler())) {                 while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {                     suppressed.add(fromXContent(parser)).                 }             } else {                 // Parse the array and add each item to the corresponding list of metadata.                 // Arrays of objects are not supported yet and just ignored and skipped.                 List<String> values = new ArrayList<>().                 while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {                     if (token == XContentParser.Token.VALUE_STRING) {                         values.add(parser.text()).                     } else {                         parser.skipChildren().                     }                 }                 if (values.size() > 0) {                     if (metadata.containsKey(currentFieldName)) {                         values.addAll(metadata.get(currentFieldName)).                     }                     metadata.put(currentFieldName, values).                 }             }         }     }     ElasticsearchException e = new ElasticsearchException(buildMessage(type, reason, stack), cause).     for (Map.Entry<String, List<String>> entry : metadata.entrySet()) {         // subclasses can print out additional metadata through the metadataToXContent method. Simple key-value pairs will be         // parsed back and become part of this metadata set, while objects and arrays are not supported when parsing back.         // Those key-value pairs become part of the metadata set and inherit the "es." prefix as that is currently required         // by addMetadata. The prefix will get stripped out when printing metadata out so it will be effectively invisible.         // TODO move subclasses that print out simple metadata to using addMetadata directly and support also numbers and booleans.         // TODO rename metadataToXContent and have only SearchPhaseExecutionException use it, which prints out complex objects         e.addMetadata("es." + entry.getKey(), entry.getValue()).     }     for (Map.Entry<String, List<String>> header : headers.entrySet()) {         e.addHeader(header.getKey(), header.getValue()).     }     // after parsing and can be retrieved using getSuppressed() method.     for (ElasticsearchException rootCause : rootCauses) {         e.addSuppressed(rootCause).     }     for (ElasticsearchException s : suppressed) {         e.addSuppressed(s).     }     return e. }
true;public,static;3;9;/**  * Static toXContent helper method that renders {@link org.elasticsearch.ElasticsearchException} or {@link Throwable} instances  * as XContent, delegating the rendering to {@link #toXContent(XContentBuilder, Params)}  * or {@link #innerToXContent(XContentBuilder, Params, Throwable, String, String, Map, Map, Throwable)}.  *  * This method is usually used when the {@link Throwable} is rendered as a part of another XContent object, and its result can  * be parsed back using the {@link #fromXContent(XContentParser)} method.  */ ;/**  * Static toXContent helper method that renders {@link org.elasticsearch.ElasticsearchException} or {@link Throwable} instances  * as XContent, delegating the rendering to {@link #toXContent(XContentBuilder, Params)}  * or {@link #innerToXContent(XContentBuilder, Params, Throwable, String, String, Map, Map, Throwable)}.  *  * This method is usually used when the {@link Throwable} is rendered as a part of another XContent object, and its result can  * be parsed back using the {@link #fromXContent(XContentParser)} method.  */ public static void generateThrowableXContent(XContentBuilder builder, Params params, Throwable t) throws IOException {     t = ExceptionsHelper.unwrapCause(t).     if (t instanceof ElasticsearchException) {         ((ElasticsearchException) t).toXContent(builder, params).     } else {         innerToXContent(builder, params, t, getExceptionName(t), t.getMessage(), emptyMap(), emptyMap(), t.getCause()).     } }
true;public,static;4;38;/**  * Render any exception as a xcontent, encapsulated within a field or object named "error". The level of details that are rendered  * depends on the value of the "detailed" parameter: when it's false only a simple message based on the type and message of the  * exception is rendered. When it's true all detail are provided including guesses root causes, cause and potentially stack  * trace.  *  * This method is usually used when the {@link Exception} is rendered as a full XContent object, and its output can be parsed  * by the {@link #failureFromXContent(XContentParser)} method.  */ ;/**  * Render any exception as a xcontent, encapsulated within a field or object named "error". The level of details that are rendered  * depends on the value of the "detailed" parameter: when it's false only a simple message based on the type and message of the  * exception is rendered. When it's true all detail are provided including guesses root causes, cause and potentially stack  * trace.  *  * This method is usually used when the {@link Exception} is rendered as a full XContent object, and its output can be parsed  * by the {@link #failureFromXContent(XContentParser)} method.  */ public static void generateFailureXContent(XContentBuilder builder, Params params, @Nullable Exception e, boolean detailed) throws IOException {     // No exception to render as an error     if (e == null) {         builder.field(ERROR, "unknown").         return.     }     // Render the exception with a simple message     if (detailed == false) {         String message = "No ElasticsearchException found".         Throwable t = e.         for (int counter = 0. counter < 10 && t != null. counter++) {             if (t instanceof ElasticsearchException) {                 message = t.getClass().getSimpleName() + "[" + t.getMessage() + "]".                 break.             }             t = t.getCause().         }         builder.field(ERROR, message).         return.     }     // Render the exception with all details     final ElasticsearchException[] rootCauses = ElasticsearchException.guessRootCauses(e).     builder.startObject(ERROR).     {         builder.startArray(ROOT_CAUSE).         for (ElasticsearchException rootCause : rootCauses) {             builder.startObject().             rootCause.toXContent(builder, new DelegatingMapParams(singletonMap(REST_EXCEPTION_SKIP_CAUSE, "true"), params)).             builder.endObject().         }         builder.endArray().     }     generateThrowableXContent(builder, params, e).     builder.endObject(). }
true;public,static;1;15;/**  * Parses the output of {@link #generateFailureXContent(XContentBuilder, Params, Exception, boolean)}  */ ;/**  * Parses the output of {@link #generateFailureXContent(XContentBuilder, Params, Exception, boolean)}  */ public static ElasticsearchException failureFromXContent(XContentParser parser) throws IOException {     XContentParser.Token token = parser.currentToken().     ensureFieldName(parser, token, ERROR).     token = parser.nextToken().     if (token.isValue()) {         return new ElasticsearchException(buildMessage("exception", parser.text(), null)).     }     ensureExpectedToken(XContentParser.Token.START_OBJECT, token, parser::getTokenLocation).     token = parser.nextToken().     // Root causes are parsed in the innerFromXContent() and are added as suppressed exceptions.     return innerFromXContent(parser, true). }
true;public;0;7;/**  * Returns the root cause of this exception or multiple if different shards caused different exceptions  */ ;/**  * Returns the root cause of this exception or multiple if different shards caused different exceptions  */ public ElasticsearchException[] guessRootCauses() {     final Throwable cause = getCause().     if (cause != null && cause instanceof ElasticsearchException) {         return ((ElasticsearchException) cause).guessRootCauses().     }     return new ElasticsearchException[] { this }. }
false;protected;0;4;;@Override protected String getExceptionName() {     return getExceptionName(getCause()). }
true;public,static;1;29;/**  * Returns the root cause of this exception or multiple if different shards caused different exceptions.  * If the given exception is not an instance of {@link org.elasticsearch.ElasticsearchException} an empty array  * is returned.  */ ;/**  * Returns the root cause of this exception or multiple if different shards caused different exceptions.  * If the given exception is not an instance of {@link org.elasticsearch.ElasticsearchException} an empty array  * is returned.  */ public static ElasticsearchException[] guessRootCauses(Throwable t) {     Throwable ex = ExceptionsHelper.unwrapCause(t).     if (ex instanceof ElasticsearchException) {         // ElasticsearchException knows how to guess its own root cause         return ((ElasticsearchException) ex).guessRootCauses().     }     if (ex instanceof XContentParseException) {         /*              * We'd like to unwrap parsing exceptions to the inner-most              * parsing exception because that is generally the most interesting              * exception to return to the user. If that exception is caused by              * an ElasticsearchException we'd like to keep unwrapping because              * ElasticserachExceptions tend to contain useful information for              * the user.              */         Throwable cause = ex.getCause().         if (cause != null) {             if (cause instanceof XContentParseException || cause instanceof ElasticsearchException) {                 return guessRootCauses(ex.getCause()).             }         }     }     return new ElasticsearchException[] { new ElasticsearchException(t.getMessage(), t) {          @Override         protected String getExceptionName() {             return getExceptionName(getCause()).         }     } }. }
false;protected;0;3;;protected String getExceptionName() {     return getExceptionName(this). }
true;public,static;1;8;/**  * Returns a underscore case name for the given exception. This method strips {@code Elasticsearch} prefixes from exception names.  */ ;/**  * Returns a underscore case name for the given exception. This method strips {@code Elasticsearch} prefixes from exception names.  */ public static String getExceptionName(Throwable ex) {     String simpleName = ex.getClass().getSimpleName().     if (simpleName.startsWith("Elasticsearch")) {         simpleName = simpleName.substring("Elasticsearch".length()).     }     // TODO: do we really need to make the exception name in underscore casing?     return toUnderscoreCase(simpleName). }
false;static;3;10;;static String buildMessage(String type, String reason, String stack) {     StringBuilder message = new StringBuilder("Elasticsearch exception [").     message.append(TYPE).append('=').append(type).append(", ").     message.append(REASON).append('=').append(reason).     if (stack != null) {         message.append(", ").append(STACK_TRACE).append('=').append(stack).     }     message.append(']').     return message.toString(). }
false;public;0;12;;@Override public String toString() {     StringBuilder builder = new StringBuilder().     if (metadata.containsKey(INDEX_METADATA_KEY)) {         builder.append(getIndex()).         if (metadata.containsKey(SHARD_METADATA_KEY)) {             builder.append('[').append(getShardId()).append(']').         }         builder.append(' ').     }     return builder.append(ExceptionsHelper.detailedMessage(this).trim()).toString(). }
true;public,static;2;18;/**  * Deserializes stacktrace elements as well as suppressed exceptions from the given output stream and  * adds it to the given exception.  */ ;/**  * Deserializes stacktrace elements as well as suppressed exceptions from the given output stream and  * adds it to the given exception.  */ public static <T extends Throwable> T readStackTrace(T throwable, StreamInput in) throws IOException {     final int stackTraceElements = in.readVInt().     StackTraceElement[] stackTrace = new StackTraceElement[stackTraceElements].     for (int i = 0. i < stackTraceElements. i++) {         final String declaringClasss = in.readString().         final String fileName = in.readOptionalString().         final String methodName = in.readString().         final int lineNumber = in.readVInt().         stackTrace[i] = new StackTraceElement(declaringClasss, methodName, fileName, lineNumber).     }     throwable.setStackTrace(stackTrace).     int numSuppressed = in.readVInt().     for (int i = 0. i < numSuppressed. i++) {         throwable.addSuppressed(in.readException()).     }     return throwable. }
true;public,static;2;16;/**  * Serializes the given exceptions stacktrace elements as well as it's suppressed exceptions to the given output stream.  */ ;/**  * Serializes the given exceptions stacktrace elements as well as it's suppressed exceptions to the given output stream.  */ public static <T extends Throwable> T writeStackTraces(T throwable, StreamOutput out) throws IOException {     StackTraceElement[] stackTrace = throwable.getStackTrace().     out.writeVInt(stackTrace.length).     for (StackTraceElement element : stackTrace) {         out.writeString(element.getClassName()).         out.writeOptionalString(element.getFileName()).         out.writeString(element.getMethodName()).         out.writeVInt(element.getLineNumber()).     }     Throwable[] suppressed = throwable.getSuppressed().     out.writeVInt(suppressed.length).     for (Throwable t : suppressed) {         out.writeException(t).     }     return throwable. }
true;static;0;3;/**  * Returns an array of all registered handle IDs. These are the IDs for every registered  * exception.  *  * @return an array of all registered handle IDs  */ ;/**  * Returns an array of all registered handle IDs. These are the IDs for every registered  * exception.  *  * @return an array of all registered handle IDs  */ static int[] ids() {     return Arrays.stream(ElasticsearchExceptionHandle.values()).mapToInt(h -> h.id).toArray(). }
true;static;0;7;/**  * Returns an array of all registered pairs of handle IDs and exception classes. These pairs are  * provided for every registered exception.  *  * @return an array of all registered pairs of handle IDs and exception classes  */ ;/**  * Returns an array of all registered pairs of handle IDs and exception classes. These pairs are  * provided for every registered exception.  *  * @return an array of all registered pairs of handle IDs and exception classes  */ static Tuple<Integer, Class<? extends ElasticsearchException>>[] classes() {     @SuppressWarnings("unchecked")     final Tuple<Integer, Class<? extends ElasticsearchException>>[] ts = Arrays.stream(ElasticsearchExceptionHandle.values()).map(h -> Tuple.tuple(h.id, h.exceptionClass)).toArray(Tuple[]::new).     return ts. }
false;public;0;9;;public Index getIndex() {     List<String> index = getMetadata(INDEX_METADATA_KEY).     if (index != null && index.isEmpty() == false) {         List<String> index_uuid = getMetadata(INDEX_METADATA_KEY_UUID).         return new Index(index.get(0), index_uuid.get(0)).     }     return null. }
false;public;0;7;;public ShardId getShardId() {     List<String> shard = getMetadata(SHARD_METADATA_KEY).     if (shard != null && shard.isEmpty() == false) {         return new ShardId(getIndex(), Integer.parseInt(shard.get(0))).     }     return null. }
false;public;1;6;;public void setIndex(Index index) {     if (index != null) {         addMetadata(INDEX_METADATA_KEY, index.getName()).         addMetadata(INDEX_METADATA_KEY_UUID, index.getUUID()).     } }
false;public;1;5;;public void setIndex(String index) {     if (index != null) {         setIndex(new Index(index, INDEX_UUID_NA_VALUE)).     } }
false;public;1;6;;public void setShard(ShardId shardId) {     if (shardId != null) {         setIndex(shardId.getIndex()).         addMetadata(SHARD_METADATA_KEY, Integer.toString(shardId.id())).     } }
false;public;2;5;;public void setResources(String type, String... id) {     assert type != null.     addMetadata(RESOURCE_METADATA_ID_KEY, id).     addMetadata(RESOURCE_METADATA_TYPE_KEY, type). }
false;public;0;3;;public List<String> getResourceId() {     return getMetadata(RESOURCE_METADATA_ID_KEY). }
false;public;0;8;;public String getResourceType() {     List<String> header = getMetadata(RESOURCE_METADATA_TYPE_KEY).     if (header != null && header.isEmpty() == false) {         assert header.size() == 1.         return header.get(0).     }     return null. }
true;private,static;1;33;// lower cases and adds underscores to transitions in a name ;// lower cases and adds underscores to transitions in a name private static String toUnderscoreCase(String value) {     StringBuilder sb = new StringBuilder().     boolean changed = false.     for (int i = 0. i < value.length(). i++) {         char c = value.charAt(i).         if (Character.isUpperCase(c)) {             if (!changed) {                 // copy it over here                 for (int j = 0. j < i. j++) {                     sb.append(value.charAt(j)).                 }                 changed = true.                 if (i == 0) {                     sb.append(Character.toLowerCase(c)).                 } else {                     sb.append('_').                     sb.append(Character.toLowerCase(c)).                 }             } else {                 sb.append('_').                 sb.append(Character.toLowerCase(c)).             }         } else {             if (changed) {                 sb.append(c).             }         }     }     if (!changed) {         return value.     }     return sb.toString(). }
