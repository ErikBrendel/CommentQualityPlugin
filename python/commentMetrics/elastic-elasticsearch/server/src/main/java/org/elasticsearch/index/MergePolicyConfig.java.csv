commented;modifiers;parameterAmount;loc;comment;code
false;;1;3;;void setSegmentsPerTier(Double segmentsPerTier) {     mergePolicy.setSegmentsPerTier(segmentsPerTier). }
false;;1;3;;void setMaxMergedSegment(ByteSizeValue maxMergedSegment) {     mergePolicy.setMaxMergedSegmentMB(maxMergedSegment.getMbFrac()). }
false;;1;3;;void setMaxMergesAtOnceExplicit(Integer maxMergeAtOnceExplicit) {     mergePolicy.setMaxMergeAtOnceExplicit(maxMergeAtOnceExplicit). }
false;;1;3;;void setMaxMergesAtOnce(Integer maxMergeAtOnce) {     mergePolicy.setMaxMergeAtOnce(maxMergeAtOnce). }
false;;1;3;;void setFloorSegmentSetting(ByteSizeValue floorSegementSetting) {     mergePolicy.setFloorSegmentMB(floorSegementSetting.getMbFrac()). }
false;;1;3;;void setExpungeDeletesAllowed(Double value) {     mergePolicy.setForceMergeDeletesPctAllowed(value). }
false;;1;3;;void setNoCFSRatio(Double noCFSRatio) {     mergePolicy.setNoCFSRatio(noCFSRatio). }
false;;1;3;;void setDeletesPctAllowed(Double deletesPctAllowed) {     mergePolicy.setDeletesPctAllowed(deletesPctAllowed). }
false;private;2;15;;private int adjustMaxMergeAtOnceIfNeeded(int maxMergeAtOnce, double segmentsPerTier) {     // fixing maxMergeAtOnce, see TieredMergePolicy#setMaxMergeAtOnce     if (!(segmentsPerTier >= maxMergeAtOnce)) {         int newMaxMergeAtOnce = (int) segmentsPerTier.         // max merge at once should be at least 2         if (newMaxMergeAtOnce <= 1) {             newMaxMergeAtOnce = 2.         }         logger.debug("changing max_merge_at_once from [{}] to [{}] because segments_per_tier [{}] has to be higher or " + "equal to it", maxMergeAtOnce, newMaxMergeAtOnce, segmentsPerTier).         maxMergeAtOnce = newMaxMergeAtOnce.     }     return maxMergeAtOnce. }
false;;0;3;;MergePolicy getMergePolicy() {     return mergesEnabled ? mergePolicy : NoMergePolicy.INSTANCE. }
false;private,static;1;19;;private static double parseNoCFSRatio(String noCFSRatio) {     noCFSRatio = noCFSRatio.trim().     if (noCFSRatio.equalsIgnoreCase("true")) {         return 1.0d.     } else if (noCFSRatio.equalsIgnoreCase("false")) {         return 0.0.     } else {         try {             double value = Double.parseDouble(noCFSRatio).             if (value < 0.0 || value > 1.0) {                 throw new IllegalArgumentException("NoCFSRatio must be in the interval [0..1] but was: [" + value + "]").             }             return value.         } catch (NumberFormatException ex) {             throw new IllegalArgumentException("Expected a boolean or a value in the interval [0..1] but was: " + "[" + noCFSRatio + "]", ex).         }     } }
