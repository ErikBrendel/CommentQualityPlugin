commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public IgnoredFieldMapper build(BuilderContext context) {     return new IgnoredFieldMapper(context.indexSettings()). }
false;public;3;5;;@Override public MetadataFieldMapper.Builder<?, ?> parse(String name, Map<String, Object> node, ParserContext parserContext) throws MapperParsingException {     return new Builder(parserContext.mapperService().fullName(NAME)). }
false;public;2;5;;@Override public MetadataFieldMapper getDefault(MappedFieldType fieldType, ParserContext context) {     final Settings indexSettings = context.mapperService().getIndexSettings().getSettings().     return new IgnoredFieldMapper(indexSettings). }
false;public;0;4;;@Override public IgnoredFieldType clone() {     return new IgnoredFieldType(this). }
false;public;0;4;;@Override public String typeName() {     return CONTENT_TYPE. }
false;public;1;8;;@Override public Query existsQuery(QueryShardContext context) {     // field is bounded by the number of fields in the mappings.     return new TermRangeQuery(name(), null, null, true, true). }
false;public;1;3;;@Override public void preParse(ParseContext context) throws IOException { }
false;public;1;4;;@Override public void postParse(ParseContext context) throws IOException {     super.parse(context). }
false;public;1;4;;@Override public void parse(ParseContext context) throws IOException { // done in post-parse }
false;protected;2;6;;@Override protected void parseCreateField(ParseContext context, List<IndexableField> fields) throws IOException {     for (String field : context.getIgnoredFields()) {         context.doc().add(new Field(NAME, field, fieldType())).     } }
false;protected;0;4;;@Override protected String contentType() {     return CONTENT_TYPE. }
false;public;2;4;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     return builder. }
