commented;modifiers;parameterAmount;loc;comment;code
true;public,abstract;1;1;/**  * Set the current doc ID.  */ ;/**  * Set the current doc ID.  */ public abstract void setNextDocId(int docId) throws IOException.
true;public,final;2;4;// Throw meaningful exceptions if someone tries to modify the ScriptDocValues. ;// Throw meaningful exceptions if someone tries to modify the ScriptDocValues. @Override public final void add(int index, T element) {     throw new UnsupportedOperationException("doc values are unmodifiable"). }
false;public,final;1;4;;@Override public final boolean remove(Object o) {     throw new UnsupportedOperationException("doc values are unmodifiable"). }
false;public,final;1;4;;@Override public final void replaceAll(UnaryOperator<T> operator) {     throw new UnsupportedOperationException("doc values are unmodifiable"). }
false;public,final;2;4;;@Override public final T set(int index, T element) {     throw new UnsupportedOperationException("doc values are unmodifiable"). }
false;public,final;1;4;;@Override public final void sort(Comparator<? super T> c) {     throw new UnsupportedOperationException("doc values are unmodifiable"). }
false;public;1;11;;@Override public void setNextDocId(int docId) throws IOException {     if (in.advanceExact(docId)) {         resize(in.docValueCount()).         for (int i = 0. i < count. i++) {             values[i] = in.nextValue().         }     } else {         resize(0).     } }
true;protected;1;4;/**  * Set the {@link #size()} and ensure that the {@link #values} array can  * store at least that many entries.  */ ;/**  * Set the {@link #size()} and ensure that the {@link #values} array can  * store at least that many entries.  */ protected void resize(int newSize) {     count = newSize.     values = ArrayUtil.grow(values, count). }
false;public;0;7;;public long getValue() {     if (count == 0) {         throw new IllegalStateException("A document doesn't have a value for a field! " + "Use doc[<field>].size()==0 to check if a document is missing a field!").     }     return values[0]. }
false;public;1;4;;@Override public Long get(int index) {     return values[index]. }
false;public;0;4;;@Override public int size() {     return count. }
true;public;0;7;/**  * Fetch the first field value or 0 millis after epoch if there are no  * in.  */ ;/**  * Fetch the first field value or 0 millis after epoch if there are no  * in.  */ public JodaCompatibleZonedDateTime getValue() {     if (count == 0) {         throw new IllegalStateException("A document doesn't have a value for a field! " + "Use doc[<field>].size()==0 to check if a document is missing a field!").     }     return get(0). }
false;public;1;9;;@Override public JodaCompatibleZonedDateTime get(int index) {     if (index >= count) {         throw new IndexOutOfBoundsException("attempted to fetch the [" + index + "] date when there are only [" + count + "] dates.").     }     return dates[index]. }
false;public;0;4;;@Override public int size() {     return count. }
false;public;1;9;;@Override public void setNextDocId(int docId) throws IOException {     if (in.advanceExact(docId)) {         count = in.docValueCount().     } else {         count = 0.     }     refreshArray(). }
true;;0;16;/**  * Refresh the backing array. Package private so it can be called when {@link Longs} loads dates.  */ ;/**  * Refresh the backing array. Package private so it can be called when {@link Longs} loads dates.  */ void refreshArray() throws IOException {     if (count == 0) {         return.     }     if (dates == null || count > dates.length) {         // Happens for the document. We delay allocating dates so we can allocate it with a reasonable size.         dates = new JodaCompatibleZonedDateTime[count].     }     for (int i = 0. i < count. ++i) {         if (isNanos) {             dates[i] = new JodaCompatibleZonedDateTime(DateUtils.toInstant(in.nextValue()), ZoneOffset.UTC).         } else {             dates[i] = new JodaCompatibleZonedDateTime(Instant.ofEpochMilli(in.nextValue()), ZoneOffset.UTC).         }     } }
false;public;1;11;;@Override public void setNextDocId(int docId) throws IOException {     if (in.advanceExact(docId)) {         resize(in.docValueCount()).         for (int i = 0. i < count. i++) {             values[i] = in.nextValue().         }     } else {         resize(0).     } }
true;protected;1;4;/**  * Set the {@link #size()} and ensure that the {@link #values} array can  * store at least that many entries.  */ ;/**  * Set the {@link #size()} and ensure that the {@link #values} array can  * store at least that many entries.  */ protected void resize(int newSize) {     count = newSize.     values = ArrayUtil.grow(values, count). }
false;public;0;3;;public SortedNumericDoubleValues getInternalValues() {     return this.in. }
false;public;0;7;;public double getValue() {     if (count == 0) {         throw new IllegalStateException("A document doesn't have a value for a field! " + "Use doc[<field>].size()==0 to check if a document is missing a field!").     }     return values[0]. }
false;public;1;4;;@Override public Double get(int index) {     return values[index]. }
false;public;0;4;;@Override public int size() {     return count. }
false;public;1;12;;@Override public void setNextDocId(int docId) throws IOException {     if (in.advanceExact(docId)) {         resize(in.docValueCount()).         for (int i = 0. i < count. i++) {             GeoPoint point = in.nextValue().             values[i] = new GeoPoint(point.lat(), point.lon()).         }     } else {         resize(0).     } }
true;protected;1;10;/**  * Set the {@link #size()} and ensure that the {@link #values} array can  * store at least that many entries.  */ ;/**  * Set the {@link #size()} and ensure that the {@link #values} array can  * store at least that many entries.  */ protected void resize(int newSize) {     count = newSize.     if (newSize > values.length) {         int oldLength = values.length.         values = ArrayUtil.grow(values, count).         for (int i = oldLength. i < values.length. ++i) {             values[i] = new GeoPoint().         }     } }
false;public;0;7;;public GeoPoint getValue() {     if (count == 0) {         throw new IllegalStateException("A document doesn't have a value for a field! " + "Use doc[<field>].size()==0 to check if a document is missing a field!").     }     return values[0]. }
false;public;0;3;;public double getLat() {     return getValue().lat(). }
false;public;0;7;;public double[] getLats() {     double[] lats = new double[size()].     for (int i = 0. i < size(). i++) {         lats[i] = get(i).lat().     }     return lats. }
false;public;0;7;;public double[] getLons() {     double[] lons = new double[size()].     for (int i = 0. i < size(). i++) {         lons[i] = get(i).lon().     }     return lons. }
false;public;0;3;;public double getLon() {     return getValue().lon(). }
false;public;1;5;;@Override public GeoPoint get(int index) {     final GeoPoint point = values[index].     return new GeoPoint(point.lat(), point.lon()). }
false;public;0;4;;@Override public int size() {     return count. }
false;public;2;4;;public double arcDistance(double lat, double lon) {     GeoPoint point = getValue().     return GeoUtils.arcDistance(point.lat(), point.lon(), lat, lon). }
false;public;3;6;;public double arcDistanceWithDefault(double lat, double lon, double defaultValue) {     if (isEmpty()) {         return defaultValue.     }     return arcDistance(lat, lon). }
false;public;2;4;;public double planeDistance(double lat, double lon) {     GeoPoint point = getValue().     return GeoUtils.planeDistance(point.lat(), point.lon(), lat, lon). }
false;public;3;6;;public double planeDistanceWithDefault(double lat, double lon, double defaultValue) {     if (isEmpty()) {         return defaultValue.     }     return planeDistance(lat, lon). }
false;public;1;5;;public double geohashDistance(String geohash) {     GeoPoint point = getValue().     return GeoUtils.arcDistance(point.lat(), point.lon(), GeoHashUtils.decodeLatitude(geohash), GeoHashUtils.decodeLongitude(geohash)). }
false;public;2;6;;public double geohashDistanceWithDefault(String geohash, double defaultValue) {     if (isEmpty()) {         return defaultValue.     }     return geohashDistance(geohash). }
false;public;1;11;;@Override public void setNextDocId(int docId) throws IOException {     if (in.advanceExact(docId)) {         resize(in.docValueCount()).         for (int i = 0. i < count. i++) {             values[i] = in.nextValue() == 1.         }     } else {         resize(0).     } }
true;protected;1;4;/**  * Set the {@link #size()} and ensure that the {@link #values} array can  * store at least that many entries.  */ ;/**  * Set the {@link #size()} and ensure that the {@link #values} array can  * store at least that many entries.  */ protected void resize(int newSize) {     count = newSize.     values = grow(values, count). }
false;public;0;7;;public boolean getValue() {     if (count == 0) {         throw new IllegalStateException("A document doesn't have a value for a field! " + "Use doc[<field>].size()==0 to check if a document is missing a field!").     }     return values[0]. }
false;public;1;4;;@Override public Boolean get(int index) {     return values[index]. }
false;public;0;4;;@Override public int size() {     return count. }
false;private,static;2;8;;private static boolean[] grow(boolean[] array, int minSize) {     assert minSize >= 0 : "size must be positive (got " + minSize + "): likely integer overflow?".     if (array.length < minSize) {         return Arrays.copyOf(array, ArrayUtil.oversize(minSize, 1)).     } else         return array. }
false;public;1;14;;@Override public void setNextDocId(int docId) throws IOException {     if (in.advanceExact(docId)) {         resize(in.docValueCount()).         for (int i = 0. i < count. i++) {             // We need to make a copy here, because BytesBinaryDVAtomicFieldData's SortedBinaryDocValues             // implementation reuses the returned BytesRef. Otherwise we would end up with the same BytesRef             // instance for all slots in the values array.             values[i].copyBytes(in.nextValue()).         }     } else {         resize(0).     } }
true;protected;1;10;/**  * Set the {@link #size()} and ensure that the {@link #values} array can  * store at least that many entries.  */ ;/**  * Set the {@link #size()} and ensure that the {@link #values} array can  * store at least that many entries.  */ protected void resize(int newSize) {     count = newSize.     if (newSize > values.length) {         final int oldLength = values.length.         values = ArrayUtil.grow(values, count).         for (int i = oldLength. i < values.length. ++i) {             values[i] = new BytesRefBuilder().         }     } }
false;public;0;4;;@Override public int size() {     return count. }
false;public;1;4;;@Override public String get(int index) {     return values[index].get().utf8ToString(). }
false;public;0;7;;public String getValue() {     if (count == 0) {         throw new IllegalStateException("A document doesn't have a value for a field! " + "Use doc[<field>].size()==0 to check if a document is missing a field!").     }     return get(0). }
false;public;1;9;;@Override public BytesRef get(int index) {     /**      * We need to make a copy here because {@link BinaryScriptDocValues} might reuse the      * returned value and the same instance might be used to      * return values from multiple documents.      */     return values[index].toBytesRef(). }
false;public;0;7;;public BytesRef getValue() {     if (count == 0) {         throw new IllegalStateException("A document doesn't have a value for a field! " + "Use doc[<field>].size()==0 to check if a document is missing a field!").     }     return get(0). }
