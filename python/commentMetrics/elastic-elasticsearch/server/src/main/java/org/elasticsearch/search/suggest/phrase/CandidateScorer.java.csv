commented;modifiers;parameterAmount;loc;comment;code
false;protected;2;4;;@Override protected boolean lessThan(Correction a, Correction b) {     return a.compareTo(b) < 0. }
false;public;3;25;;public Correction[] findBestCandiates(CandidateSet[] sets, float errorFraction, double cutoffScore) throws IOException {     if (sets.length == 0) {         return Correction.EMPTY.     }     PriorityQueue<Correction> corrections = new PriorityQueue<Correction>(maxNumCorrections) {          @Override         protected boolean lessThan(Correction a, Correction b) {             return a.compareTo(b) < 0.         }     }.     int numMissspellings = 1.     if (errorFraction >= 1.0) {         numMissspellings = (int) errorFraction.     } else {         numMissspellings = Math.round(errorFraction * sets.length).     }     findCandidates(sets, new Candidate[sets.length], 0, Math.max(1, numMissspellings), corrections, cutoffScore, 0.0).     Correction[] result = new Correction[corrections.size()].     for (int i = result.length - 1. i >= 0. i--) {         result[i] = corrections.pop().     }     assert corrections.size() == 0.     return result. }
false;public;7;30;;public void findCandidates(CandidateSet[] candidates, Candidate[] path, int ord, int numMissspellingsLeft, PriorityQueue<Correction> corrections, double cutoffScore, final double pathScore) throws IOException {     CandidateSet current = candidates[ord].     if (ord == candidates.length - 1) {         path[ord] = current.originalTerm.         updateTop(candidates, path, corrections, cutoffScore, pathScore + scorer.score(path, candidates, ord, gramSize)).         if (numMissspellingsLeft > 0) {             for (int i = 0. i < current.candidates.length. i++) {                 path[ord] = current.candidates[i].                 updateTop(candidates, path, corrections, cutoffScore, pathScore + scorer.score(path, candidates, ord, gramSize)).             }         }     } else {         if (numMissspellingsLeft > 0) {             path[ord] = current.originalTerm.             findCandidates(candidates, path, ord + 1, numMissspellingsLeft, corrections, cutoffScore, pathScore + scorer.score(path, candidates, ord, gramSize)).             for (int i = 0. i < current.candidates.length. i++) {                 path[ord] = current.candidates[i].                 findCandidates(candidates, path, ord + 1, numMissspellingsLeft - 1, corrections, cutoffScore, pathScore + scorer.score(path, candidates, ord, gramSize)).             }         } else {             path[ord] = current.originalTerm.             findCandidates(candidates, path, ord + 1, 0, corrections, cutoffScore, pathScore + scorer.score(path, candidates, ord, gramSize)).         }     } }
false;private;5;17;;private void updateTop(CandidateSet[] candidates, Candidate[] path, PriorityQueue<Correction> corrections, double cutoffScore, double score) throws IOException {     score = Math.exp(score).     assert Math.abs(score - score(path, candidates)) < 0.00001 : "cur_score=" + score + ", path_score=" + score(path, candidates).     if (score > cutoffScore) {         if (corrections.size() < maxNumCorrections) {             Candidate[] c = new Candidate[candidates.length].             System.arraycopy(path, 0, c, 0, path.length).             corrections.add(new Correction(score, c)).         } else if (corrections.top().compareTo(score, path) < 0) {             Correction top = corrections.top().             System.arraycopy(path, 0, top.candidates, 0, path.length).             top.score = score.             corrections.updateTop().         }     } }
false;public;2;7;;public double score(Candidate[] path, CandidateSet[] candidates) throws IOException {     double score = 0.0d.     for (int i = 0. i < candidates.length. i++) {         score += scorer.score(path, candidates, i, gramSize).     }     return Math.exp(score). }
