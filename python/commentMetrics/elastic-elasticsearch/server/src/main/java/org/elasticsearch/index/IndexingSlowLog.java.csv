commented;modifiers;parameterAmount;loc;comment;code
false;private;1;3;;private void setMaxSourceCharsToLog(int maxSourceCharsToLog) {     this.maxSourceCharsToLog = maxSourceCharsToLog. }
false;private;1;4;;private void setLevel(SlowLogLevel level) {     this.level = level.     Loggers.setLevel(this.indexLogger, level.name()). }
false;private;1;3;;private void setWarnThreshold(TimeValue warnThreshold) {     this.indexWarnThreshold = warnThreshold.nanos(). }
false;private;1;3;;private void setInfoThreshold(TimeValue infoThreshold) {     this.indexInfoThreshold = infoThreshold.nanos(). }
false;private;1;3;;private void setDebugThreshold(TimeValue debugThreshold) {     this.indexDebugThreshold = debugThreshold.nanos(). }
false;private;1;3;;private void setTraceThreshold(TimeValue traceThreshold) {     this.indexTraceThreshold = traceThreshold.nanos(). }
false;private;1;3;;private void setReformat(boolean reformat) {     this.reformat = reformat. }
false;public;3;16;;@Override public void postIndex(ShardId shardId, Engine.Index indexOperation, Engine.IndexResult result) {     if (result.getResultType() == Engine.Result.Type.SUCCESS) {         final ParsedDocument doc = indexOperation.parsedDoc().         final long tookInNanos = result.getTook().         if (indexWarnThreshold >= 0 && tookInNanos > indexWarnThreshold) {             indexLogger.warn("{}", new SlowLogParsedDocumentPrinter(index, doc, tookInNanos, reformat, maxSourceCharsToLog)).         } else if (indexInfoThreshold >= 0 && tookInNanos > indexInfoThreshold) {             indexLogger.info("{}", new SlowLogParsedDocumentPrinter(index, doc, tookInNanos, reformat, maxSourceCharsToLog)).         } else if (indexDebugThreshold >= 0 && tookInNanos > indexDebugThreshold) {             indexLogger.debug("{}", new SlowLogParsedDocumentPrinter(index, doc, tookInNanos, reformat, maxSourceCharsToLog)).         } else if (indexTraceThreshold >= 0 && tookInNanos > indexTraceThreshold) {             indexLogger.trace("{}", new SlowLogParsedDocumentPrinter(index, doc, tookInNanos, reformat, maxSourceCharsToLog)).         }     } }
false;public;0;31;;@Override public String toString() {     StringBuilder sb = new StringBuilder().     sb.append(index).append(" ").     sb.append("took[").append(TimeValue.timeValueNanos(tookInNanos)).append("], ").     sb.append("took_millis[").append(TimeUnit.NANOSECONDS.toMillis(tookInNanos)).append("], ").     sb.append("type[").append(doc.type()).append("], ").     sb.append("id[").append(doc.id()).append("], ").     if (doc.routing() == null) {         sb.append("routing[]").     } else {         sb.append("routing[").append(doc.routing()).append("]").     }     if (maxSourceCharsToLog == 0 || doc.source() == null || doc.source().length() == 0) {         return sb.toString().     }     try {         String source = XContentHelper.convertToJson(doc.source(), reformat, doc.getXContentType()).         sb.append(", source[").append(Strings.cleanTruncate(source, maxSourceCharsToLog).trim()).append("]").     } catch (IOException e) {         sb.append(", source[_failed_to_convert_[").append(e.getMessage()).append("]]").         /*                  * We choose to fail to write to the slow log and instead let this percolate up to the post index listener loop where this                  * will be logged at the warn level.                  */         final String message = String.format(Locale.ROOT, "failed to convert source for slow log entry [%s]", sb.toString()).         throw new UncheckedIOException(message, e).     }     return sb.toString(). }
false;;0;3;;boolean isReformat() {     return reformat. }
false;;0;3;;long getIndexWarnThreshold() {     return indexWarnThreshold. }
false;;0;3;;long getIndexInfoThreshold() {     return indexInfoThreshold. }
false;;0;3;;long getIndexTraceThreshold() {     return indexTraceThreshold. }
false;;0;3;;long getIndexDebugThreshold() {     return indexDebugThreshold. }
false;;0;3;;int getMaxSourceCharsToLog() {     return maxSourceCharsToLog. }
false;;0;3;;SlowLogLevel getLevel() {     return level. }
