commented;modifiers;parameterAmount;loc;comment;code
false;protected,abstract;0;1;;protected abstract String executor().
true;protected,abstract;0;2;/**  * @deprecated new implementors should override {@link #read(StreamInput)} and use the  *             {@link Writeable.Reader} interface.  * @return a new response instance. Typically this is used for serialization using the  *         {@link Streamable#readFrom(StreamInput)} method.  */ ;/**  * @deprecated new implementors should override {@link #read(StreamInput)} and use the  *             {@link Writeable.Reader} interface.  * @return a new response instance. Typically this is used for serialization using the  *         {@link Streamable#readFrom(StreamInput)} method.  */ @Deprecated protected abstract Response newResponse().
false;protected;1;5;;protected Response read(StreamInput in) throws IOException {     Response response = newResponse().     response.readFrom(in).     return response. }
false;protected,abstract;3;1;;protected abstract void masterOperation(Request request, ClusterState state, ActionListener<Response> listener) throws Exception.
true;protected;4;3;/**  * Override this operation if access to the task parameter is needed  */ ;/**  * Override this operation if access to the task parameter is needed  */ protected void masterOperation(Task task, Request request, ClusterState state, ActionListener<Response> listener) throws Exception {     masterOperation(request, state, listener). }
false;protected;1;3;;protected boolean localExecute(Request request) {     return false. }
false;protected,abstract;2;1;;protected abstract ClusterBlockException checkBlock(Request request, ClusterState state).
false;protected;3;4;;@Override protected void doExecute(Task task, final Request request, ActionListener<Response> listener) {     new AsyncSingleAction(task, request, listener).start(). }
false;public;0;6;;public void start() {     ClusterState state = clusterService.state().     this.observer = new ClusterStateObserver(state, clusterService, request.masterNodeTimeout(), logger, threadPool.getThreadContext()).     doStart(state). }
false;public;1;13;;@Override public void handleException(final TransportException exp) {     Throwable cause = exp.unwrapCause().     if (cause instanceof ConnectTransportException) {         // we want to retry here a bit to see if a new master is elected         logger.debug("connection exception while trying to forward request with action name [{}] to " + "master node [{}], scheduling a retry. Error: [{}]", actionName, nodes.getMasterNode(), exp.getDetailedMessage()).         retry(cause, masterChangePredicate).     } else {         listener.onFailure(exp).     } }
false;public;1;4;;@Override public void onResponse(Response response) {     listener.onResponse(response). }
false;public;1;10;;@Override public void onFailure(Exception t) {     if (t instanceof FailedToCommitClusterStateException || t instanceof NotMasterException) {         logger.debug(() -> new ParameterizedMessage("master could not publish cluster state or " + "stepped down before publishing action [{}], scheduling a retry", actionName), t).         retry(t, masterChangePredicate).     } else {         listener.onFailure(t).     } }
false;protected;0;4;;@Override protected void doRun() throws Exception {     masterOperation(task, request, clusterState, delegate). }
false;protected;1;77;;protected void doStart(ClusterState clusterState) {     try {         final Predicate<ClusterState> masterChangePredicate = MasterNodeChangePredicate.build(clusterState).         final DiscoveryNodes nodes = clusterState.nodes().         if (nodes.isLocalNodeElectedMaster() || localExecute(request)) {             // check for block, if blocked, retry, else, execute locally             final ClusterBlockException blockException = checkBlock(request, clusterState).             if (blockException != null) {                 if (!blockException.retryable()) {                     listener.onFailure(blockException).                 } else {                     logger.trace("can't execute due to a cluster block, retrying", blockException).                     retry(blockException, newState -> {                         try {                             ClusterBlockException newException = checkBlock(request, newState).                             return (newException == null || !newException.retryable()).                         } catch (Exception e) {                             // accept state as block will be rechecked by doStart() and listener.onFailure() then called                             logger.trace("exception occurred during cluster block checking, accepting state", e).                             return true.                         }                     }).                 }             } else {                 ActionListener<Response> delegate = new ActionListener<Response>() {                      @Override                     public void onResponse(Response response) {                         listener.onResponse(response).                     }                      @Override                     public void onFailure(Exception t) {                         if (t instanceof FailedToCommitClusterStateException || t instanceof NotMasterException) {                             logger.debug(() -> new ParameterizedMessage("master could not publish cluster state or " + "stepped down before publishing action [{}], scheduling a retry", actionName), t).                             retry(t, masterChangePredicate).                         } else {                             listener.onFailure(t).                         }                     }                 }.                 threadPool.executor(executor).execute(new ActionRunnable<Response>(delegate) {                      @Override                     protected void doRun() throws Exception {                         masterOperation(task, request, clusterState, delegate).                     }                 }).             }         } else {             if (nodes.getMasterNode() == null) {                 logger.debug("no known master node, scheduling a retry").                 retry(null, masterChangePredicate).             } else {                 DiscoveryNode masterNode = nodes.getMasterNode().                 final String actionName = getMasterActionName(masterNode).                 transportService.sendRequest(masterNode, actionName, request, new ActionListenerResponseHandler<Response>(listener, TransportMasterNodeAction.this::read) {                      @Override                     public void handleException(final TransportException exp) {                         Throwable cause = exp.unwrapCause().                         if (cause instanceof ConnectTransportException) {                             // we want to retry here a bit to see if a new master is elected                             logger.debug("connection exception while trying to forward request with action name [{}] to " + "master node [{}], scheduling a retry. Error: [{}]", actionName, nodes.getMasterNode(), exp.getDetailedMessage()).                             retry(cause, masterChangePredicate).                         } else {                             listener.onFailure(exp).                         }                     }                 }).             }         }     } catch (Exception e) {         listener.onFailure(e).     } }
false;public;1;4;;@Override public void onNewClusterState(ClusterState state) {     doStart(state). }
false;public;0;4;;@Override public void onClusterServiceClose() {     listener.onFailure(new NodeClosedException(clusterService.localNode())). }
false;public;1;6;;@Override public void onTimeout(TimeValue timeout) {     logger.debug(() -> new ParameterizedMessage("timed out while retrying [{}] after failure (timeout [{}])", actionName, timeout), failure).     listener.onFailure(new MasterNotDiscoveredException(failure)). }
false;private;2;22;;private void retry(final Throwable failure, final Predicate<ClusterState> statePredicate) {     observer.waitForNextChange(new ClusterStateObserver.Listener() {          @Override         public void onNewClusterState(ClusterState state) {             doStart(state).         }          @Override         public void onClusterServiceClose() {             listener.onFailure(new NodeClosedException(clusterService.localNode())).         }          @Override         public void onTimeout(TimeValue timeout) {             logger.debug(() -> new ParameterizedMessage("timed out while retrying [{}] after failure (timeout [{}])", actionName, timeout), failure).             listener.onFailure(new MasterNotDiscoveredException(failure)).         }     }, statePredicate). }
true;protected;1;3;/**  * Allows to conditionally return a different master node action name in the case an action gets renamed.  * This mainly for backwards compatibility should be used rarely  */ ;/**  * Allows to conditionally return a different master node action name in the case an action gets renamed.  * This mainly for backwards compatibility should be used rarely  */ protected String getMasterActionName(DiscoveryNode node) {     return actionName. }
