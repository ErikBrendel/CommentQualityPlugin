commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;10;;@Override protected void doWriteTo(StreamOutput out) throws IOException {     out.writeString(fieldName).     out.writeGenericValue(value).     out.writeVInt(slop).     if (out.getVersion().onOrAfter(Version.V_6_3_0)) {         zeroTermsQuery.writeTo(out).     }     out.writeOptionalString(analyzer). }
true;public;0;3;/**  * Returns the field name used in this query.  */ ;/**  * Returns the field name used in this query.  */ public String fieldName() {     return this.fieldName. }
true;public;0;3;/**  * Returns the value used in this query.  */ ;/**  * Returns the value used in this query.  */ public Object value() {     return this.value. }
true;public;1;4;/**  * Explicitly set the analyzer to use. Defaults to use explicit mapping  * config for the field, or, if not set, the default search analyzer.  */ ;/**  * Explicitly set the analyzer to use. Defaults to use explicit mapping  * config for the field, or, if not set, the default search analyzer.  */ public MatchPhraseQueryBuilder analyzer(String analyzer) {     this.analyzer = analyzer.     return this. }
true;public;0;3;/**  * Get the analyzer to use, if previously set, otherwise {@code null}  */ ;/**  * Get the analyzer to use, if previously set, otherwise {@code null}  */ public String analyzer() {     return this.analyzer. }
true;public;1;7;/**  * Sets a slop factor for phrase queries  */ ;/**  * Sets a slop factor for phrase queries  */ public MatchPhraseQueryBuilder slop(int slop) {     if (slop < 0) {         throw new IllegalArgumentException("No negative slop allowed.").     }     this.slop = slop.     return this. }
true;public;0;3;/**  * Get the slop factor for phrase queries.  */ ;/**  * Get the slop factor for phrase queries.  */ public int slop() {     return this.slop. }
true;public;1;7;/**  * Sets query to use in case no query terms are available, e.g. after analysis removed them.  * Defaults to {@link ZeroTermsQuery#NONE}, but can be set to  * {@link ZeroTermsQuery#ALL} instead.  */ ;/**  * Sets query to use in case no query terms are available, e.g. after analysis removed them.  * Defaults to {@link ZeroTermsQuery#NONE}, but can be set to  * {@link ZeroTermsQuery#ALL} instead.  */ public MatchPhraseQueryBuilder zeroTermsQuery(ZeroTermsQuery zeroTermsQuery) {     if (zeroTermsQuery == null) {         throw new IllegalArgumentException("[" + NAME + "] requires zeroTermsQuery to be non-null").     }     this.zeroTermsQuery = zeroTermsQuery.     return this. }
false;public;0;3;;public ZeroTermsQuery zeroTermsQuery() {     return this.zeroTermsQuery. }
false;public;0;4;;@Override public String getWriteableName() {     return NAME. }
false;protected;2;15;;@Override protected void doXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject(NAME).     builder.startObject(fieldName).     builder.field(MatchQueryBuilder.QUERY_FIELD.getPreferredName(), value).     if (analyzer != null) {         builder.field(MatchQueryBuilder.ANALYZER_FIELD.getPreferredName(), analyzer).     }     builder.field(SLOP_FIELD.getPreferredName(), slop).     builder.field(ZERO_TERMS_QUERY_FIELD.getPreferredName(), zeroTermsQuery.toString()).     printBoostAndQueryName(builder).     builder.endObject().     builder.endObject(). }
false;protected;1;16;;@Override protected Query doToQuery(QueryShardContext context) throws IOException {     // validate context specific fields     if (analyzer != null && context.getIndexAnalyzers().get(analyzer) == null) {         throw new QueryShardException(context, "[" + NAME + "] analyzer [" + analyzer + "] not found").     }     MatchQuery matchQuery = new MatchQuery(context).     if (analyzer != null) {         matchQuery.setAnalyzer(analyzer).     }     matchQuery.setPhraseSlop(slop).     matchQuery.setZeroTermsQuery(zeroTermsQuery).     return matchQuery.parse(MatchQuery.Type.PHRASE, fieldName, value). }
false;protected;1;8;;@Override protected boolean doEquals(MatchPhraseQueryBuilder other) {     return Objects.equals(fieldName, other.fieldName) && Objects.equals(value, other.value) && Objects.equals(analyzer, other.analyzer) && Objects.equals(slop, other.slop) && Objects.equals(zeroTermsQuery, other.zeroTermsQuery). }
false;protected;0;4;;@Override protected int doHashCode() {     return Objects.hash(fieldName, value, analyzer, slop). }
false;public,static;1;64;;public static MatchPhraseQueryBuilder fromXContent(XContentParser parser) throws IOException {     String fieldName = null.     Object value = null.     float boost = AbstractQueryBuilder.DEFAULT_BOOST.     String analyzer = null.     int slop = MatchQuery.DEFAULT_PHRASE_SLOP.     ZeroTermsQuery zeroTermsQuery = MatchQuery.DEFAULT_ZERO_TERMS_QUERY.     String queryName = null.     String currentFieldName = null.     XContentParser.Token token.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (token == XContentParser.Token.START_OBJECT) {             throwParsingExceptionOnMultipleFields(NAME, parser.getTokenLocation(), fieldName, currentFieldName).             fieldName = currentFieldName.             while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {                 if (token == XContentParser.Token.FIELD_NAME) {                     currentFieldName = parser.currentName().                 } else if (token.isValue()) {                     if (MatchQueryBuilder.QUERY_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                         value = parser.objectText().                     } else if (MatchQueryBuilder.ANALYZER_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                         analyzer = parser.text().                     } else if (AbstractQueryBuilder.BOOST_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                         boost = parser.floatValue().                     } else if (SLOP_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                         slop = parser.intValue().                     } else if (AbstractQueryBuilder.NAME_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                         queryName = parser.text().                     } else if (ZERO_TERMS_QUERY_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                         String zeroTermsValue = parser.text().                         if ("none".equalsIgnoreCase(zeroTermsValue)) {                             zeroTermsQuery = ZeroTermsQuery.NONE.                         } else if ("all".equalsIgnoreCase(zeroTermsValue)) {                             zeroTermsQuery = ZeroTermsQuery.ALL.                         } else {                             throw new ParsingException(parser.getTokenLocation(), "Unsupported zero_terms_query value [" + zeroTermsValue + "]").                         }                     } else {                         throw new ParsingException(parser.getTokenLocation(), "[" + NAME + "] query does not support [" + currentFieldName + "]").                     }                 } else {                     throw new ParsingException(parser.getTokenLocation(), "[" + NAME + "] unknown token [" + token + "] after [" + currentFieldName + "]").                 }             }         } else {             throwParsingExceptionOnMultipleFields(NAME, parser.getTokenLocation(), fieldName, parser.currentName()).             fieldName = parser.currentName().             value = parser.objectText().         }     }     MatchPhraseQueryBuilder matchQuery = new MatchPhraseQueryBuilder(fieldName, value).     matchQuery.analyzer(analyzer).     matchQuery.slop(slop).     matchQuery.zeroTermsQuery(zeroTermsQuery).     matchQuery.queryName(queryName).     matchQuery.boost(boost).     return matchQuery. }
