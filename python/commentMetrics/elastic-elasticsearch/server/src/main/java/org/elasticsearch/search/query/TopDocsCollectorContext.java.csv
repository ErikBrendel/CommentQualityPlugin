commented;modifiers;parameterAmount;loc;comment;code
true;final;0;3;/**  * Returns the number of top docs to retrieve  */ ;/**  * Returns the number of top docs to retrieve  */ final int numHits() {     return numHits. }
true;;0;3;/**  * Returns true if the top docs should be re-scored after initial search  */ ;/**  * Returns true if the top docs should be re-scored after initial search  */ boolean shouldRescore() {     return false. }
false;;1;4;;Collector create(Collector in) {     assert in == null.     return collector. }
false;;1;5;;@Override void postProcess(QuerySearchResult result) {     final TotalHits totalHitCount = hitCountSupplier.get().     result.topDocs(new TopDocsAndMaxScore(new TopDocs(totalHitCount, Lucene.EMPTY_SCORE_DOCS), Float.NaN), null). }
false;;1;5;;@Override Collector create(Collector in) throws IOException {     assert in == null.     return topDocsCollector. }
false;;1;5;;@Override void postProcess(QuerySearchResult result) throws IOException {     CollapseTopFieldDocs topDocs = topDocsCollector.getTopDocs().     result.topDocs(new TopDocsAndMaxScore(topDocs, maxScoreSupplier.get()), sortFmt). }
false;private,static;4;8;;private static TopDocsCollector<?> createCollector(@Nullable SortAndFormats sortAndFormats, int numHits, @Nullable ScoreDoc searchAfter, int hitCountThreshold) {     if (sortAndFormats == null) {         return TopScoreDocCollector.create(numHits, searchAfter, hitCountThreshold).     } else {         return TopFieldCollector.create(sortAndFormats.sort, numHits, (FieldDoc) searchAfter, hitCountThreshold).     } }
false;;1;5;;@Override Collector create(Collector in) {     assert in == null.     return collector. }
false;;0;12;;TopDocsAndMaxScore newTopDocs() {     TopDocs in = topDocsSupplier.get().     float maxScore = maxScoreSupplier.get().     final TopDocs newTopDocs.     if (in instanceof TopFieldDocs) {         TopFieldDocs fieldDocs = (TopFieldDocs) in.         newTopDocs = new TopFieldDocs(totalHitsSupplier.get(), fieldDocs.scoreDocs, fieldDocs.fields).     } else {         newTopDocs = new TopDocs(totalHitsSupplier.get(), in.scoreDocs).     }     return new TopDocsAndMaxScore(newTopDocs, maxScore). }
false;;1;5;;@Override void postProcess(QuerySearchResult result) throws IOException {     final TopDocsAndMaxScore topDocs = newTopDocs().     result.topDocs(topDocs, sortAndFormats == null ? null : sortAndFormats.formats). }
false;;1;22;;@Override void postProcess(QuerySearchResult result) throws IOException {     final TopDocsAndMaxScore topDocs = newTopDocs().     if (scrollContext.totalHits == null) {         // first round         scrollContext.totalHits = topDocs.topDocs.totalHits.         scrollContext.maxScore = topDocs.maxScore.     } else {         // subsequent round: the total number of hits and         // the maximum score were computed on the first round         topDocs.topDocs.totalHits = scrollContext.totalHits.         topDocs.maxScore = scrollContext.maxScore.     }     if (numberOfShards == 1) {         // if we fetch the document in the same roundtrip, we already know the last emitted doc         if (topDocs.topDocs.scoreDocs.length > 0) {             // set the last emitted doc             scrollContext.lastEmittedDoc = topDocs.topDocs.scoreDocs[topDocs.topDocs.scoreDocs.length - 1].         }     }     result.topDocs(topDocs, sortAndFormats == null ? null : sortAndFormats.formats). }
true;static;2;27;/**  * Returns query total hit count if the <code>query</code> is a {@link MatchAllDocsQuery}  * or a {@link TermQuery} and the <code>reader</code> has no deletions,  * -1 otherwise.  */ ;/**  * Returns query total hit count if the <code>query</code> is a {@link MatchAllDocsQuery}  * or a {@link TermQuery} and the <code>reader</code> has no deletions,  * -1 otherwise.  */ static int shortcutTotalHitCount(IndexReader reader, Query query) throws IOException {     while (true) {         // a constant_score query         if (query instanceof ConstantScoreQuery) {             query = ((ConstantScoreQuery) query).getQuery().         } else if (query instanceof BoostQuery) {             query = ((BoostQuery) query).getQuery().         } else {             break.         }     }     if (query.getClass() == MatchAllDocsQuery.class) {         return reader.numDocs().     } else if (query.getClass() == TermQuery.class && reader.hasDeletions() == false) {         final Term term = ((TermQuery) query).getTerm().         int count = 0.         for (LeafReaderContext context : reader.leaves()) {             count += context.reader().docFreq(term).         }         return count.     } else {         return -1.     } }
false;;0;4;;@Override boolean shouldRescore() {     return rescore. }
true;static;3;41;/**  * Creates a {@link TopDocsCollectorContext} from the provided <code>searchContext</code>.  * @param hasFilterCollector True if the collector chain contains at least one collector that can filters document.  */ ;/**  * Creates a {@link TopDocsCollectorContext} from the provided <code>searchContext</code>.  * @param hasFilterCollector True if the collector chain contains at least one collector that can filters document.  */ static TopDocsCollectorContext createTopDocsCollectorContext(SearchContext searchContext, IndexReader reader, boolean hasFilterCollector) throws IOException {     final Query query = searchContext.query().     // top collectors don't like a size of 0     final int totalNumDocs = Math.max(1, reader.numDocs()).     if (searchContext.size() == 0) {         // no matter what the value of from is         return new EmptyTopDocsCollectorContext(reader, query, searchContext.trackTotalHitsUpTo(), hasFilterCollector).     } else if (searchContext.scrollContext() != null) {         // we can disable the tracking of total hits after the initial scroll query         // since the total hits is preserved in the scroll context.         int trackTotalHitsUpTo = searchContext.scrollContext().totalHits != null ? SearchContext.TRACK_TOTAL_HITS_DISABLED : SearchContext.TRACK_TOTAL_HITS_ACCURATE.         // no matter what the value of from is         int numDocs = Math.min(searchContext.size(), totalNumDocs).         return new ScrollingTopDocsCollectorContext(reader, query, searchContext.scrollContext(), searchContext.sort(), numDocs, searchContext.trackScores(), searchContext.numberOfShards(), trackTotalHitsUpTo, hasFilterCollector).     } else if (searchContext.collapse() != null) {         boolean trackScores = searchContext.sort() == null ? true : searchContext.trackScores().         int numDocs = Math.min(searchContext.from() + searchContext.size(), totalNumDocs).         return new CollapsingTopDocsCollectorContext(searchContext.collapse(), searchContext.sort(), numDocs, trackScores).     } else {         int numDocs = Math.min(searchContext.from() + searchContext.size(), totalNumDocs).         final boolean rescore = searchContext.rescore().isEmpty() == false.         if (rescore) {             assert searchContext.sort() == null.             for (RescoreContext rescoreContext : searchContext.rescore()) {                 numDocs = Math.max(numDocs, rescoreContext.getWindowSize()).             }         }         return new SimpleTopDocsCollectorContext(reader, query, searchContext.sort(), searchContext.searchAfter(), numDocs, searchContext.trackScores(), searchContext.trackTotalHitsUpTo(), hasFilterCollector) {              @Override             boolean shouldRescore() {                 return rescore.             }         }.     } }
