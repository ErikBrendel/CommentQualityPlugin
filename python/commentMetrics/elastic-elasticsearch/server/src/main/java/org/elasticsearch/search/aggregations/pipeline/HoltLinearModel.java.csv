commented;modifiers;parameterAmount;loc;comment;code
false;public;1;5;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeDouble(alpha).     out.writeDouble(beta). }
false;public;0;4;;@Override public String getWriteableName() {     return NAME. }
false;public;0;4;;@Override public boolean canBeMinimized() {     return true. }
false;public;0;13;;@Override public MovAvgModel neighboringModel() {     double newValue = Math.random().     switch((int) (Math.random() * 2)) {         case 0:             return new HoltLinearModel(newValue, this.beta).         case 1:             return new HoltLinearModel(this.alpha, newValue).         default:             assert (false) : "Random value fell outside of range [0-1]".             // This should never technically happen...             return new HoltLinearModel(newValue, this.beta).     } }
false;public;0;4;;@Override public MovAvgModel clone() {     return new HoltLinearModel(this.alpha, this.beta). }
true;protected;2;4;/**  * Predicts the next `n` values in the series, using the smoothing model to generate new values.  * Unlike the other moving averages, Holt-Linear has forecasting/prediction built into the algorithm.  * Prediction is more than simply adding the next prediction to the window and repeating.  Holt-Linear  * will extrapolate into the future by applying the trend information to the smoothed data.  *  * @param values            Collection of numerics to movingAvg, usually windowed  * @param numPredictions    Number of newly generated predictions to return  * @return                  Returns an array of doubles, since most smoothing methods operate on floating points  */ ;/**  * Predicts the next `n` values in the series, using the smoothing model to generate new values.  * Unlike the other moving averages, Holt-Linear has forecasting/prediction built into the algorithm.  * Prediction is more than simply adding the next prediction to the window and repeating.  Holt-Linear  * will extrapolate into the future by applying the trend information to the smoothed data.  *  * @param values            Collection of numerics to movingAvg, usually windowed  * @param numPredictions    Number of newly generated predictions to return  * @return                  Returns an array of doubles, since most smoothing methods operate on floating points  */ @Override protected double[] doPredict(Collection<Double> values, int numPredictions) {     return next(values, numPredictions). }
false;public;1;4;;@Override public double next(Collection<Double> values) {     return next(values, 1)[0]. }
true;public;2;6;/**  * Calculate a Holt-Linear (doubly exponential weighted) moving average  *  * @param values Collection of values to calculate avg for  * @param numForecasts number of forecasts into the future to return  *  * @return       Returns a Double containing the moving avg for the window  */ ;/**  * Calculate a Holt-Linear (doubly exponential weighted) moving average  *  * @param values Collection of values to calculate avg for  * @param numForecasts number of forecasts into the future to return  *  * @return       Returns a Double containing the moving avg for the window  */ public double[] next(Collection<Double> values, int numForecasts) {     if (values.size() == 0) {         return emptyPredictions(numForecasts).     }     return MovingFunctions.holtForecast(values.stream().mapToDouble(Double::doubleValue).toArray(), alpha, beta, numForecasts). }
false;public;2;9;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.field(MovAvgPipelineAggregationBuilder.MODEL.getPreferredName(), NAME).     builder.startObject(MovAvgPipelineAggregationBuilder.SETTINGS.getPreferredName()).     builder.field("alpha", alpha).     builder.field("beta", beta).     builder.endObject().     return builder. }
false;public;3;8;;@Override public MovAvgModel parse(@Nullable Map<String, Object> settings, String pipelineName, int windowSize) throws ParseException {     double alpha = parseDoubleParam(settings, "alpha", DEFAULT_ALPHA).     double beta = parseDoubleParam(settings, "beta", DEFAULT_BETA).     checkUnrecognizedParams(settings).     return new HoltLinearModel(alpha, beta). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(alpha, beta). }
false;public;1;12;;@Override public boolean equals(Object obj) {     if (obj == null) {         return false.     }     if (getClass() != obj.getClass()) {         return false.     }     HoltLinearModel other = (HoltLinearModel) obj.     return Objects.equals(alpha, other.alpha) && Objects.equals(beta, other.beta). }
true;public;1;4;/**  * Alpha controls the smoothing of the data.  Alpha = 1 retains no memory of past values  * (e.g. a random walk), while alpha = 0 retains infinite memory of past values (e.g.  * the series mean).  Useful values are somewhere in between.  Defaults to 0.5.  *  * @param alpha A double between 0-1 inclusive, controls data smoothing  *  * @return The builder to continue chaining  */ ;/**  * Alpha controls the smoothing of the data.  Alpha = 1 retains no memory of past values  * (e.g. a random walk), while alpha = 0 retains infinite memory of past values (e.g.  * the series mean).  Useful values are somewhere in between.  Defaults to 0.5.  *  * @param alpha A double between 0-1 inclusive, controls data smoothing  *  * @return The builder to continue chaining  */ public HoltLinearModelBuilder alpha(double alpha) {     this.alpha = alpha.     return this. }
true;public;1;4;/**  * Equivalent to <code>alpha</code>, but controls the smoothing of the trend instead of the data  *  * @param beta a double between 0-1 inclusive, controls trend smoothing  *  * @return The builder to continue chaining  */ ;/**  * Equivalent to <code>alpha</code>, but controls the smoothing of the trend instead of the data  *  * @param beta a double between 0-1 inclusive, controls trend smoothing  *  * @return The builder to continue chaining  */ public HoltLinearModelBuilder beta(double beta) {     this.beta = beta.     return this. }
false;public;2;10;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.field(MovAvgPipelineAggregationBuilder.MODEL.getPreferredName(), NAME).     builder.startObject(MovAvgPipelineAggregationBuilder.SETTINGS.getPreferredName()).     builder.field("alpha", alpha).     builder.field("beta", beta).     builder.endObject().     return builder. }
false;public;0;4;;@Override public MovAvgModel build() {     return new HoltLinearModel(alpha, beta). }
