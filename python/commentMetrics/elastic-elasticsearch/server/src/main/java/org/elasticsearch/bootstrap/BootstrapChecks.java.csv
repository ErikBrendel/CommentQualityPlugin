# id;timestamp;commentText;codeText;commentWords;codeWords
BootstrapChecks -> static void check(             final BootstrapContext context,             final boolean enforceLimits,             final List<BootstrapCheck> checks,             final Logger logger) throws NodeValidationException;1524684173;Executes the provided checks and fails the node if {@code enforceLimits} is {@code true}, otherwise logs warnings. If the system_property {@code es.enforce.bootstrap.checks }is set to {@code true} then the bootstrap checks will be enforced regardless of whether_or not the transport protocol is bound to a non-loopback interface.__@param context the current node boostrap context_@param enforceLimits {@code true} if the checks should be enforced or otherwise warned_@param checks        the checks to execute_@param logger        the logger to;static void check(_            final BootstrapContext context,_            final boolean enforceLimits,_            final List<BootstrapCheck> checks,_            final Logger logger) throws NodeValidationException {_        final List<String> errors = new ArrayList<>()__        final List<String> ignoredErrors = new ArrayList<>()___        final String esEnforceBootstrapChecks = System.getProperty(ES_ENFORCE_BOOTSTRAP_CHECKS)__        final boolean enforceBootstrapChecks__        if (esEnforceBootstrapChecks == null) {_            enforceBootstrapChecks = false__        } else if (Boolean.TRUE.toString().equals(esEnforceBootstrapChecks)) {_            enforceBootstrapChecks = true__        } else {_            final String message =_                    String.format(_                            Locale.ROOT,_                            "[%s] must be [true] but was [%s]",_                            ES_ENFORCE_BOOTSTRAP_CHECKS,_                            esEnforceBootstrapChecks)__            throw new IllegalArgumentException(message)__        }__        if (enforceLimits) {_            logger.info("bound or publishing to a non-loopback address, enforcing bootstrap checks")__        } else if (enforceBootstrapChecks) {_            logger.info("explicitly enforcing bootstrap checks")__        }__        for (final BootstrapCheck check : checks) {_            final BootstrapCheck.BootstrapCheckResult result = check.check(context)__            if (result.isFailure()) {_                if (!(enforceLimits || enforceBootstrapChecks) && !check.alwaysEnforce()) {_                    ignoredErrors.add(result.getMessage())__                } else {_                    errors.add(result.getMessage())__                }_            }_        }__        if (!ignoredErrors.isEmpty()) {_            ignoredErrors.forEach(error -> log(logger, error))__        }__        if (!errors.isEmpty()) {_            final List<String> messages = new ArrayList<>(1 + errors.size())__            messages.add("[" + errors.size() + "] bootstrap checks failed")__            for (int i = 0_ i < errors.size()_ i++) {_                messages.add("[" + (i + 1) + "]: " + errors.get(i))__            }_            final NodeValidationException ne = new NodeValidationException(String.join("\n", messages))__            errors.stream().map(IllegalStateException::new).forEach(ne::addSuppressed)__            throw ne__        }_    };executes,the,provided,checks,and,fails,the,node,if,code,enforce,limits,is,code,true,otherwise,logs,warnings,if,the,system,property,code,es,enforce,bootstrap,checks,is,set,to,code,true,then,the,bootstrap,checks,will,be,enforced,regardless,of,whether,or,not,the,transport,protocol,is,bound,to,a,non,loopback,interface,param,context,the,current,node,boostrap,context,param,enforce,limits,code,true,if,the,checks,should,be,enforced,or,otherwise,warned,param,checks,the,checks,to,execute,param,logger,the,logger,to;static,void,check,final,bootstrap,context,context,final,boolean,enforce,limits,final,list,bootstrap,check,checks,final,logger,logger,throws,node,validation,exception,final,list,string,errors,new,array,list,final,list,string,ignored,errors,new,array,list,final,string,es,enforce,bootstrap,checks,system,get,property,final,boolean,enforce,bootstrap,checks,if,es,enforce,bootstrap,checks,null,enforce,bootstrap,checks,false,else,if,boolean,true,to,string,equals,es,enforce,bootstrap,checks,enforce,bootstrap,checks,true,else,final,string,message,string,format,locale,root,s,must,be,true,but,was,s,es,enforce,bootstrap,checks,throw,new,illegal,argument,exception,message,if,enforce,limits,logger,info,bound,or,publishing,to,a,non,loopback,address,enforcing,bootstrap,checks,else,if,enforce,bootstrap,checks,logger,info,explicitly,enforcing,bootstrap,checks,for,final,bootstrap,check,check,checks,final,bootstrap,check,bootstrap,check,result,result,check,check,context,if,result,is,failure,if,enforce,limits,enforce,bootstrap,checks,check,always,enforce,ignored,errors,add,result,get,message,else,errors,add,result,get,message,if,ignored,errors,is,empty,ignored,errors,for,each,error,log,logger,error,if,errors,is,empty,final,list,string,messages,new,array,list,1,errors,size,messages,add,errors,size,bootstrap,checks,failed,for,int,i,0,i,errors,size,i,messages,add,i,1,errors,get,i,final,node,validation,exception,ne,new,node,validation,exception,string,join,n,messages,errors,stream,map,illegal,state,exception,new,for,each,ne,add,suppressed,throw,ne
BootstrapChecks -> static void check(             final BootstrapContext context,             final boolean enforceLimits,             final List<BootstrapCheck> checks,             final Logger logger) throws NodeValidationException;1533063033;Executes the provided checks and fails the node if {@code enforceLimits} is {@code true}, otherwise logs warnings. If the system_property {@code es.enforce.bootstrap.checks }is set to {@code true} then the bootstrap checks will be enforced regardless of whether_or not the transport protocol is bound to a non-loopback interface.__@param context the current node boostrap context_@param enforceLimits {@code true} if the checks should be enforced or otherwise warned_@param checks        the checks to execute_@param logger        the logger to;static void check(_            final BootstrapContext context,_            final boolean enforceLimits,_            final List<BootstrapCheck> checks,_            final Logger logger) throws NodeValidationException {_        final List<String> errors = new ArrayList<>()__        final List<String> ignoredErrors = new ArrayList<>()___        final String esEnforceBootstrapChecks = System.getProperty(ES_ENFORCE_BOOTSTRAP_CHECKS)__        final boolean enforceBootstrapChecks__        if (esEnforceBootstrapChecks == null) {_            enforceBootstrapChecks = false__        } else if (Boolean.TRUE.toString().equals(esEnforceBootstrapChecks)) {_            enforceBootstrapChecks = true__        } else {_            final String message =_                    String.format(_                            Locale.ROOT,_                            "[%s] must be [true] but was [%s]",_                            ES_ENFORCE_BOOTSTRAP_CHECKS,_                            esEnforceBootstrapChecks)__            throw new IllegalArgumentException(message)__        }__        if (enforceLimits) {_            logger.info("bound or publishing to a non-loopback address, enforcing bootstrap checks")__        } else if (enforceBootstrapChecks) {_            logger.info("explicitly enforcing bootstrap checks")__        }__        for (final BootstrapCheck check : checks) {_            final BootstrapCheck.BootstrapCheckResult result = check.check(context)__            if (result.isFailure()) {_                if (!(enforceLimits || enforceBootstrapChecks) && !check.alwaysEnforce()) {_                    ignoredErrors.add(result.getMessage())__                } else {_                    errors.add(result.getMessage())__                }_            }_        }__        if (!ignoredErrors.isEmpty()) {_            ignoredErrors.forEach(error -> log(logger, error))__        }__        if (!errors.isEmpty()) {_            final List<String> messages = new ArrayList<>(1 + errors.size())__            messages.add("[" + errors.size() + "] bootstrap checks failed")__            for (int i = 0_ i < errors.size()_ i++) {_                messages.add("[" + (i + 1) + "]: " + errors.get(i))__            }_            final NodeValidationException ne = new NodeValidationException(String.join("\n", messages))__            errors.stream().map(IllegalStateException::new).forEach(ne::addSuppressed)__            throw ne__        }_    };executes,the,provided,checks,and,fails,the,node,if,code,enforce,limits,is,code,true,otherwise,logs,warnings,if,the,system,property,code,es,enforce,bootstrap,checks,is,set,to,code,true,then,the,bootstrap,checks,will,be,enforced,regardless,of,whether,or,not,the,transport,protocol,is,bound,to,a,non,loopback,interface,param,context,the,current,node,boostrap,context,param,enforce,limits,code,true,if,the,checks,should,be,enforced,or,otherwise,warned,param,checks,the,checks,to,execute,param,logger,the,logger,to;static,void,check,final,bootstrap,context,context,final,boolean,enforce,limits,final,list,bootstrap,check,checks,final,logger,logger,throws,node,validation,exception,final,list,string,errors,new,array,list,final,list,string,ignored,errors,new,array,list,final,string,es,enforce,bootstrap,checks,system,get,property,final,boolean,enforce,bootstrap,checks,if,es,enforce,bootstrap,checks,null,enforce,bootstrap,checks,false,else,if,boolean,true,to,string,equals,es,enforce,bootstrap,checks,enforce,bootstrap,checks,true,else,final,string,message,string,format,locale,root,s,must,be,true,but,was,s,es,enforce,bootstrap,checks,throw,new,illegal,argument,exception,message,if,enforce,limits,logger,info,bound,or,publishing,to,a,non,loopback,address,enforcing,bootstrap,checks,else,if,enforce,bootstrap,checks,logger,info,explicitly,enforcing,bootstrap,checks,for,final,bootstrap,check,check,checks,final,bootstrap,check,bootstrap,check,result,result,check,check,context,if,result,is,failure,if,enforce,limits,enforce,bootstrap,checks,check,always,enforce,ignored,errors,add,result,get,message,else,errors,add,result,get,message,if,ignored,errors,is,empty,ignored,errors,for,each,error,log,logger,error,if,errors,is,empty,final,list,string,messages,new,array,list,1,errors,size,messages,add,errors,size,bootstrap,checks,failed,for,int,i,0,i,errors,size,i,messages,add,i,1,errors,get,i,final,node,validation,exception,ne,new,node,validation,exception,string,join,n,messages,errors,stream,map,illegal,state,exception,new,for,each,ne,add,suppressed,throw,ne
BootstrapChecks -> static void check(             final BootstrapContext context,             final boolean enforceLimits,             final List<BootstrapCheck> checks,             final Logger logger) throws NodeValidationException;1535046779;Executes the provided checks and fails the node if {@code enforceLimits} is {@code true}, otherwise logs warnings. If the system_property {@code es.enforce.bootstrap.checks }is set to {@code true} then the bootstrap checks will be enforced regardless of whether_or not the transport protocol is bound to a non-loopback interface.__@param context the current node boostrap context_@param enforceLimits {@code true} if the checks should be enforced or otherwise warned_@param checks        the checks to execute_@param logger        the logger to;static void check(_            final BootstrapContext context,_            final boolean enforceLimits,_            final List<BootstrapCheck> checks,_            final Logger logger) throws NodeValidationException {_        final List<String> errors = new ArrayList<>()__        final List<String> ignoredErrors = new ArrayList<>()___        final String esEnforceBootstrapChecks = System.getProperty(ES_ENFORCE_BOOTSTRAP_CHECKS)__        final boolean enforceBootstrapChecks__        if (esEnforceBootstrapChecks == null) {_            enforceBootstrapChecks = false__        } else if (Boolean.TRUE.toString().equals(esEnforceBootstrapChecks)) {_            enforceBootstrapChecks = true__        } else {_            final String message =_                    String.format(_                            Locale.ROOT,_                            "[%s] must be [true] but was [%s]",_                            ES_ENFORCE_BOOTSTRAP_CHECKS,_                            esEnforceBootstrapChecks)__            throw new IllegalArgumentException(message)__        }__        if (enforceLimits) {_            logger.info("bound or publishing to a non-loopback address, enforcing bootstrap checks")__        } else if (enforceBootstrapChecks) {_            logger.info("explicitly enforcing bootstrap checks")__        }__        for (final BootstrapCheck check : checks) {_            final BootstrapCheck.BootstrapCheckResult result = check.check(context)__            if (result.isFailure()) {_                if (!(enforceLimits || enforceBootstrapChecks) && !check.alwaysEnforce()) {_                    ignoredErrors.add(result.getMessage())__                } else {_                    errors.add(result.getMessage())__                }_            }_        }__        if (!ignoredErrors.isEmpty()) {_            ignoredErrors.forEach(error -> log(logger, error))__        }__        if (!errors.isEmpty()) {_            final List<String> messages = new ArrayList<>(1 + errors.size())__            messages.add("[" + errors.size() + "] bootstrap checks failed")__            for (int i = 0_ i < errors.size()_ i++) {_                messages.add("[" + (i + 1) + "]: " + errors.get(i))__            }_            final NodeValidationException ne = new NodeValidationException(String.join("\n", messages))__            errors.stream().map(IllegalStateException::new).forEach(ne::addSuppressed)__            throw ne__        }_    };executes,the,provided,checks,and,fails,the,node,if,code,enforce,limits,is,code,true,otherwise,logs,warnings,if,the,system,property,code,es,enforce,bootstrap,checks,is,set,to,code,true,then,the,bootstrap,checks,will,be,enforced,regardless,of,whether,or,not,the,transport,protocol,is,bound,to,a,non,loopback,interface,param,context,the,current,node,boostrap,context,param,enforce,limits,code,true,if,the,checks,should,be,enforced,or,otherwise,warned,param,checks,the,checks,to,execute,param,logger,the,logger,to;static,void,check,final,bootstrap,context,context,final,boolean,enforce,limits,final,list,bootstrap,check,checks,final,logger,logger,throws,node,validation,exception,final,list,string,errors,new,array,list,final,list,string,ignored,errors,new,array,list,final,string,es,enforce,bootstrap,checks,system,get,property,final,boolean,enforce,bootstrap,checks,if,es,enforce,bootstrap,checks,null,enforce,bootstrap,checks,false,else,if,boolean,true,to,string,equals,es,enforce,bootstrap,checks,enforce,bootstrap,checks,true,else,final,string,message,string,format,locale,root,s,must,be,true,but,was,s,es,enforce,bootstrap,checks,throw,new,illegal,argument,exception,message,if,enforce,limits,logger,info,bound,or,publishing,to,a,non,loopback,address,enforcing,bootstrap,checks,else,if,enforce,bootstrap,checks,logger,info,explicitly,enforcing,bootstrap,checks,for,final,bootstrap,check,check,checks,final,bootstrap,check,bootstrap,check,result,result,check,check,context,if,result,is,failure,if,enforce,limits,enforce,bootstrap,checks,check,always,enforce,ignored,errors,add,result,get,message,else,errors,add,result,get,message,if,ignored,errors,is,empty,ignored,errors,for,each,error,log,logger,error,if,errors,is,empty,final,list,string,messages,new,array,list,1,errors,size,messages,add,errors,size,bootstrap,checks,failed,for,int,i,0,i,errors,size,i,messages,add,i,1,errors,get,i,final,node,validation,exception,ne,new,node,validation,exception,string,join,n,messages,errors,stream,map,illegal,state,exception,new,for,each,ne,add,suppressed,throw,ne
BootstrapChecks -> static void check(             final BootstrapContext context,             final boolean enforceLimits,             final List<BootstrapCheck> checks,             final Logger logger) throws NodeValidationException;1540486836;Executes the provided checks and fails the node if {@code enforceLimits} is {@code true}, otherwise logs warnings. If the system_property {@code es.enforce.bootstrap.checks }is set to {@code true} then the bootstrap checks will be enforced regardless of whether_or not the transport protocol is bound to a non-loopback interface.__@param context the current node boostrap context_@param enforceLimits {@code true} if the checks should be enforced or otherwise warned_@param checks        the checks to execute_@param logger        the logger to;static void check(_            final BootstrapContext context,_            final boolean enforceLimits,_            final List<BootstrapCheck> checks,_            final Logger logger) throws NodeValidationException {_        final List<String> errors = new ArrayList<>()__        final List<String> ignoredErrors = new ArrayList<>()___        final String esEnforceBootstrapChecks = System.getProperty(ES_ENFORCE_BOOTSTRAP_CHECKS)__        final boolean enforceBootstrapChecks__        if (esEnforceBootstrapChecks == null) {_            enforceBootstrapChecks = false__        } else if (Boolean.TRUE.toString().equals(esEnforceBootstrapChecks)) {_            enforceBootstrapChecks = true__        } else {_            final String message =_                    String.format(_                            Locale.ROOT,_                            "[%s] must be [true] but was [%s]",_                            ES_ENFORCE_BOOTSTRAP_CHECKS,_                            esEnforceBootstrapChecks)__            throw new IllegalArgumentException(message)__        }__        if (enforceLimits) {_            logger.info("bound or publishing to a non-loopback address, enforcing bootstrap checks")__        } else if (enforceBootstrapChecks) {_            logger.info("explicitly enforcing bootstrap checks")__        }__        for (final BootstrapCheck check : checks) {_            final BootstrapCheck.BootstrapCheckResult result = check.check(context)__            if (result.isFailure()) {_                if (!(enforceLimits || enforceBootstrapChecks) && !check.alwaysEnforce()) {_                    ignoredErrors.add(result.getMessage())__                } else {_                    errors.add(result.getMessage())__                }_            }_        }__        if (!ignoredErrors.isEmpty()) {_            ignoredErrors.forEach(error -> log(logger, error))__        }__        if (!errors.isEmpty()) {_            final List<String> messages = new ArrayList<>(1 + errors.size())__            messages.add("[" + errors.size() + "] bootstrap checks failed")__            for (int i = 0_ i < errors.size()_ i++) {_                messages.add("[" + (i + 1) + "]: " + errors.get(i))__            }_            final NodeValidationException ne = new NodeValidationException(String.join("\n", messages))__            errors.stream().map(IllegalStateException::new).forEach(ne::addSuppressed)__            throw ne__        }_    };executes,the,provided,checks,and,fails,the,node,if,code,enforce,limits,is,code,true,otherwise,logs,warnings,if,the,system,property,code,es,enforce,bootstrap,checks,is,set,to,code,true,then,the,bootstrap,checks,will,be,enforced,regardless,of,whether,or,not,the,transport,protocol,is,bound,to,a,non,loopback,interface,param,context,the,current,node,boostrap,context,param,enforce,limits,code,true,if,the,checks,should,be,enforced,or,otherwise,warned,param,checks,the,checks,to,execute,param,logger,the,logger,to;static,void,check,final,bootstrap,context,context,final,boolean,enforce,limits,final,list,bootstrap,check,checks,final,logger,logger,throws,node,validation,exception,final,list,string,errors,new,array,list,final,list,string,ignored,errors,new,array,list,final,string,es,enforce,bootstrap,checks,system,get,property,final,boolean,enforce,bootstrap,checks,if,es,enforce,bootstrap,checks,null,enforce,bootstrap,checks,false,else,if,boolean,true,to,string,equals,es,enforce,bootstrap,checks,enforce,bootstrap,checks,true,else,final,string,message,string,format,locale,root,s,must,be,true,but,was,s,es,enforce,bootstrap,checks,throw,new,illegal,argument,exception,message,if,enforce,limits,logger,info,bound,or,publishing,to,a,non,loopback,address,enforcing,bootstrap,checks,else,if,enforce,bootstrap,checks,logger,info,explicitly,enforcing,bootstrap,checks,for,final,bootstrap,check,check,checks,final,bootstrap,check,bootstrap,check,result,result,check,check,context,if,result,is,failure,if,enforce,limits,enforce,bootstrap,checks,check,always,enforce,ignored,errors,add,result,get,message,else,errors,add,result,get,message,if,ignored,errors,is,empty,ignored,errors,for,each,error,log,logger,error,if,errors,is,empty,final,list,string,messages,new,array,list,1,errors,size,messages,add,errors,size,bootstrap,checks,failed,for,int,i,0,i,errors,size,i,messages,add,i,1,errors,get,i,final,node,validation,exception,ne,new,node,validation,exception,string,join,n,messages,errors,stream,map,illegal,state,exception,new,for,each,ne,add,suppressed,throw,ne
BootstrapChecks -> static void check(             final BootstrapContext context,             final boolean enforceLimits,             final List<BootstrapCheck> checks,             final Logger logger) throws NodeValidationException;1544186829;Executes the provided checks and fails the node if {@code enforceLimits} is {@code true}, otherwise logs warnings. If the system_property {@code es.enforce.bootstrap.checks }is set to {@code true} then the bootstrap checks will be enforced regardless of whether_or not the transport protocol is bound to a non-loopback interface.__@param context the current node boostrap context_@param enforceLimits {@code true} if the checks should be enforced or otherwise warned_@param checks        the checks to execute_@param logger        the logger to;static void check(_            final BootstrapContext context,_            final boolean enforceLimits,_            final List<BootstrapCheck> checks,_            final Logger logger) throws NodeValidationException {_        final List<String> errors = new ArrayList<>()__        final List<String> ignoredErrors = new ArrayList<>()___        final String esEnforceBootstrapChecks = System.getProperty(ES_ENFORCE_BOOTSTRAP_CHECKS)__        final boolean enforceBootstrapChecks__        if (esEnforceBootstrapChecks == null) {_            enforceBootstrapChecks = false__        } else if (Boolean.TRUE.toString().equals(esEnforceBootstrapChecks)) {_            enforceBootstrapChecks = true__        } else {_            final String message =_                    String.format(_                            Locale.ROOT,_                            "[%s] must be [true] but was [%s]",_                            ES_ENFORCE_BOOTSTRAP_CHECKS,_                            esEnforceBootstrapChecks)__            throw new IllegalArgumentException(message)__        }__        if (enforceLimits) {_            logger.info("bound or publishing to a non-loopback address, enforcing bootstrap checks")__        } else if (enforceBootstrapChecks) {_            logger.info("explicitly enforcing bootstrap checks")__        }__        for (final BootstrapCheck check : checks) {_            final BootstrapCheck.BootstrapCheckResult result = check.check(context)__            if (result.isFailure()) {_                if (!(enforceLimits || enforceBootstrapChecks) && !check.alwaysEnforce()) {_                    ignoredErrors.add(result.getMessage())__                } else {_                    errors.add(result.getMessage())__                }_            }_        }__        if (!ignoredErrors.isEmpty()) {_            ignoredErrors.forEach(error -> log(logger, error))__        }__        if (!errors.isEmpty()) {_            final List<String> messages = new ArrayList<>(1 + errors.size())__            messages.add("[" + errors.size() + "] bootstrap checks failed")__            for (int i = 0_ i < errors.size()_ i++) {_                messages.add("[" + (i + 1) + "]: " + errors.get(i))__            }_            final NodeValidationException ne = new NodeValidationException(String.join("\n", messages))__            errors.stream().map(IllegalStateException::new).forEach(ne::addSuppressed)__            throw ne__        }_    };executes,the,provided,checks,and,fails,the,node,if,code,enforce,limits,is,code,true,otherwise,logs,warnings,if,the,system,property,code,es,enforce,bootstrap,checks,is,set,to,code,true,then,the,bootstrap,checks,will,be,enforced,regardless,of,whether,or,not,the,transport,protocol,is,bound,to,a,non,loopback,interface,param,context,the,current,node,boostrap,context,param,enforce,limits,code,true,if,the,checks,should,be,enforced,or,otherwise,warned,param,checks,the,checks,to,execute,param,logger,the,logger,to;static,void,check,final,bootstrap,context,context,final,boolean,enforce,limits,final,list,bootstrap,check,checks,final,logger,logger,throws,node,validation,exception,final,list,string,errors,new,array,list,final,list,string,ignored,errors,new,array,list,final,string,es,enforce,bootstrap,checks,system,get,property,final,boolean,enforce,bootstrap,checks,if,es,enforce,bootstrap,checks,null,enforce,bootstrap,checks,false,else,if,boolean,true,to,string,equals,es,enforce,bootstrap,checks,enforce,bootstrap,checks,true,else,final,string,message,string,format,locale,root,s,must,be,true,but,was,s,es,enforce,bootstrap,checks,throw,new,illegal,argument,exception,message,if,enforce,limits,logger,info,bound,or,publishing,to,a,non,loopback,address,enforcing,bootstrap,checks,else,if,enforce,bootstrap,checks,logger,info,explicitly,enforcing,bootstrap,checks,for,final,bootstrap,check,check,checks,final,bootstrap,check,bootstrap,check,result,result,check,check,context,if,result,is,failure,if,enforce,limits,enforce,bootstrap,checks,check,always,enforce,ignored,errors,add,result,get,message,else,errors,add,result,get,message,if,ignored,errors,is,empty,ignored,errors,for,each,error,log,logger,error,if,errors,is,empty,final,list,string,messages,new,array,list,1,errors,size,messages,add,errors,size,bootstrap,checks,failed,for,int,i,0,i,errors,size,i,messages,add,i,1,errors,get,i,final,node,validation,exception,ne,new,node,validation,exception,string,join,n,messages,errors,stream,map,illegal,state,exception,new,for,each,ne,add,suppressed,throw,ne
BootstrapChecks -> static void check(             final BootstrapContext context,             final boolean enforceLimits,             final List<BootstrapCheck> checks,             final Logger logger) throws NodeValidationException;1544677641;Executes the provided checks and fails the node if {@code enforceLimits} is {@code true}, otherwise logs warnings. If the system_property {@code es.enforce.bootstrap.checks }is set to {@code true} then the bootstrap checks will be enforced regardless of whether_or not the transport protocol is bound to a non-loopback interface.__@param context the current node boostrap context_@param enforceLimits {@code true} if the checks should be enforced or otherwise warned_@param checks        the checks to execute_@param logger        the logger to;static void check(_            final BootstrapContext context,_            final boolean enforceLimits,_            final List<BootstrapCheck> checks,_            final Logger logger) throws NodeValidationException {_        final List<String> errors = new ArrayList<>()__        final List<String> ignoredErrors = new ArrayList<>()___        final String esEnforceBootstrapChecks = System.getProperty(ES_ENFORCE_BOOTSTRAP_CHECKS)__        final boolean enforceBootstrapChecks__        if (esEnforceBootstrapChecks == null) {_            enforceBootstrapChecks = false__        } else if (Boolean.TRUE.toString().equals(esEnforceBootstrapChecks)) {_            enforceBootstrapChecks = true__        } else {_            final String message =_                    String.format(_                            Locale.ROOT,_                            "[%s] must be [true] but was [%s]",_                            ES_ENFORCE_BOOTSTRAP_CHECKS,_                            esEnforceBootstrapChecks)__            throw new IllegalArgumentException(message)__        }__        if (enforceLimits) {_            logger.info("bound or publishing to a non-loopback address, enforcing bootstrap checks")__        } else if (enforceBootstrapChecks) {_            logger.info("explicitly enforcing bootstrap checks")__        }__        for (final BootstrapCheck check : checks) {_            final BootstrapCheck.BootstrapCheckResult result = check.check(context)__            if (result.isFailure()) {_                if (!(enforceLimits || enforceBootstrapChecks) && !check.alwaysEnforce()) {_                    ignoredErrors.add(result.getMessage())__                } else {_                    errors.add(result.getMessage())__                }_            }_        }__        if (!ignoredErrors.isEmpty()) {_            ignoredErrors.forEach(error -> log(logger, error))__        }__        if (!errors.isEmpty()) {_            final List<String> messages = new ArrayList<>(1 + errors.size())__            messages.add("[" + errors.size() + "] bootstrap checks failed")__            for (int i = 0_ i < errors.size()_ i++) {_                messages.add("[" + (i + 1) + "]: " + errors.get(i))__            }_            final NodeValidationException ne = new NodeValidationException(String.join("\n", messages))__            errors.stream().map(IllegalStateException::new).forEach(ne::addSuppressed)__            throw ne__        }_    };executes,the,provided,checks,and,fails,the,node,if,code,enforce,limits,is,code,true,otherwise,logs,warnings,if,the,system,property,code,es,enforce,bootstrap,checks,is,set,to,code,true,then,the,bootstrap,checks,will,be,enforced,regardless,of,whether,or,not,the,transport,protocol,is,bound,to,a,non,loopback,interface,param,context,the,current,node,boostrap,context,param,enforce,limits,code,true,if,the,checks,should,be,enforced,or,otherwise,warned,param,checks,the,checks,to,execute,param,logger,the,logger,to;static,void,check,final,bootstrap,context,context,final,boolean,enforce,limits,final,list,bootstrap,check,checks,final,logger,logger,throws,node,validation,exception,final,list,string,errors,new,array,list,final,list,string,ignored,errors,new,array,list,final,string,es,enforce,bootstrap,checks,system,get,property,final,boolean,enforce,bootstrap,checks,if,es,enforce,bootstrap,checks,null,enforce,bootstrap,checks,false,else,if,boolean,true,to,string,equals,es,enforce,bootstrap,checks,enforce,bootstrap,checks,true,else,final,string,message,string,format,locale,root,s,must,be,true,but,was,s,es,enforce,bootstrap,checks,throw,new,illegal,argument,exception,message,if,enforce,limits,logger,info,bound,or,publishing,to,a,non,loopback,address,enforcing,bootstrap,checks,else,if,enforce,bootstrap,checks,logger,info,explicitly,enforcing,bootstrap,checks,for,final,bootstrap,check,check,checks,final,bootstrap,check,bootstrap,check,result,result,check,check,context,if,result,is,failure,if,enforce,limits,enforce,bootstrap,checks,check,always,enforce,ignored,errors,add,result,get,message,else,errors,add,result,get,message,if,ignored,errors,is,empty,ignored,errors,for,each,error,log,logger,error,if,errors,is,empty,final,list,string,messages,new,array,list,1,errors,size,messages,add,errors,size,bootstrap,checks,failed,for,int,i,0,i,errors,size,i,messages,add,i,1,errors,get,i,final,node,validation,exception,ne,new,node,validation,exception,string,join,n,messages,errors,stream,map,illegal,state,exception,new,for,each,ne,add,suppressed,throw,ne
BootstrapChecks -> static void check(             final BootstrapContext context,             final boolean enforceLimits,             final List<BootstrapCheck> checks,             final Logger logger) throws NodeValidationException;1546495834;Executes the provided checks and fails the node if {@code enforceLimits} is {@code true}, otherwise logs warnings. If the system_property {@code es.enforce.bootstrap.checks }is set to {@code true} then the bootstrap checks will be enforced regardless of whether_or not the transport protocol is bound to a non-loopback interface.__@param context the current node boostrap context_@param enforceLimits {@code true} if the checks should be enforced or otherwise warned_@param checks        the checks to execute_@param logger        the logger to;static void check(_            final BootstrapContext context,_            final boolean enforceLimits,_            final List<BootstrapCheck> checks,_            final Logger logger) throws NodeValidationException {_        final List<String> errors = new ArrayList<>()__        final List<String> ignoredErrors = new ArrayList<>()___        final String esEnforceBootstrapChecks = System.getProperty(ES_ENFORCE_BOOTSTRAP_CHECKS)__        final boolean enforceBootstrapChecks__        if (esEnforceBootstrapChecks == null) {_            enforceBootstrapChecks = false__        } else if (Boolean.TRUE.toString().equals(esEnforceBootstrapChecks)) {_            enforceBootstrapChecks = true__        } else {_            final String message =_                    String.format(_                            Locale.ROOT,_                            "[%s] must be [true] but was [%s]",_                            ES_ENFORCE_BOOTSTRAP_CHECKS,_                            esEnforceBootstrapChecks)__            throw new IllegalArgumentException(message)__        }__        if (enforceLimits) {_            logger.info("bound or publishing to a non-loopback address, enforcing bootstrap checks")__        } else if (enforceBootstrapChecks) {_            logger.info("explicitly enforcing bootstrap checks")__        }__        for (final BootstrapCheck check : checks) {_            final BootstrapCheck.BootstrapCheckResult result = check.check(context)__            if (result.isFailure()) {_                if (!(enforceLimits || enforceBootstrapChecks) && !check.alwaysEnforce()) {_                    ignoredErrors.add(result.getMessage())__                } else {_                    errors.add(result.getMessage())__                }_            }_        }__        if (!ignoredErrors.isEmpty()) {_            ignoredErrors.forEach(error -> log(logger, error))__        }__        if (!errors.isEmpty()) {_            final List<String> messages = new ArrayList<>(1 + errors.size())__            messages.add("[" + errors.size() + "] bootstrap checks failed")__            for (int i = 0_ i < errors.size()_ i++) {_                messages.add("[" + (i + 1) + "]: " + errors.get(i))__            }_            final NodeValidationException ne = new NodeValidationException(String.join("\n", messages))__            errors.stream().map(IllegalStateException::new).forEach(ne::addSuppressed)__            throw ne__        }_    };executes,the,provided,checks,and,fails,the,node,if,code,enforce,limits,is,code,true,otherwise,logs,warnings,if,the,system,property,code,es,enforce,bootstrap,checks,is,set,to,code,true,then,the,bootstrap,checks,will,be,enforced,regardless,of,whether,or,not,the,transport,protocol,is,bound,to,a,non,loopback,interface,param,context,the,current,node,boostrap,context,param,enforce,limits,code,true,if,the,checks,should,be,enforced,or,otherwise,warned,param,checks,the,checks,to,execute,param,logger,the,logger,to;static,void,check,final,bootstrap,context,context,final,boolean,enforce,limits,final,list,bootstrap,check,checks,final,logger,logger,throws,node,validation,exception,final,list,string,errors,new,array,list,final,list,string,ignored,errors,new,array,list,final,string,es,enforce,bootstrap,checks,system,get,property,final,boolean,enforce,bootstrap,checks,if,es,enforce,bootstrap,checks,null,enforce,bootstrap,checks,false,else,if,boolean,true,to,string,equals,es,enforce,bootstrap,checks,enforce,bootstrap,checks,true,else,final,string,message,string,format,locale,root,s,must,be,true,but,was,s,es,enforce,bootstrap,checks,throw,new,illegal,argument,exception,message,if,enforce,limits,logger,info,bound,or,publishing,to,a,non,loopback,address,enforcing,bootstrap,checks,else,if,enforce,bootstrap,checks,logger,info,explicitly,enforcing,bootstrap,checks,for,final,bootstrap,check,check,checks,final,bootstrap,check,bootstrap,check,result,result,check,check,context,if,result,is,failure,if,enforce,limits,enforce,bootstrap,checks,check,always,enforce,ignored,errors,add,result,get,message,else,errors,add,result,get,message,if,ignored,errors,is,empty,ignored,errors,for,each,error,log,logger,error,if,errors,is,empty,final,list,string,messages,new,array,list,1,errors,size,messages,add,errors,size,bootstrap,checks,failed,for,int,i,0,i,errors,size,i,messages,add,i,1,errors,get,i,final,node,validation,exception,ne,new,node,validation,exception,string,join,n,messages,errors,stream,map,illegal,state,exception,new,for,each,ne,add,suppressed,throw,ne
BootstrapChecks -> static void check(             final BootstrapContext context,             final boolean enforceLimits,             final List<BootstrapCheck> checks,             final Logger logger) throws NodeValidationException;1547677152;Executes the provided checks and fails the node if {@code enforceLimits} is {@code true}, otherwise logs warnings. If the system_property {@code es.enforce.bootstrap.checks }is set to {@code true} then the bootstrap checks will be enforced regardless of whether_or not the transport protocol is bound to a non-loopback interface.__@param context the current node boostrap context_@param enforceLimits {@code true} if the checks should be enforced or otherwise warned_@param checks        the checks to execute_@param logger        the logger to;static void check(_            final BootstrapContext context,_            final boolean enforceLimits,_            final List<BootstrapCheck> checks,_            final Logger logger) throws NodeValidationException {_        final List<String> errors = new ArrayList<>()__        final List<String> ignoredErrors = new ArrayList<>()___        final String esEnforceBootstrapChecks = System.getProperty(ES_ENFORCE_BOOTSTRAP_CHECKS)__        final boolean enforceBootstrapChecks__        if (esEnforceBootstrapChecks == null) {_            enforceBootstrapChecks = false__        } else if (Boolean.TRUE.toString().equals(esEnforceBootstrapChecks)) {_            enforceBootstrapChecks = true__        } else {_            final String message =_                    String.format(_                            Locale.ROOT,_                            "[%s] must be [true] but was [%s]",_                            ES_ENFORCE_BOOTSTRAP_CHECKS,_                            esEnforceBootstrapChecks)__            throw new IllegalArgumentException(message)__        }__        if (enforceLimits) {_            logger.info("bound or publishing to a non-loopback address, enforcing bootstrap checks")__        } else if (enforceBootstrapChecks) {_            logger.info("explicitly enforcing bootstrap checks")__        }__        for (final BootstrapCheck check : checks) {_            final BootstrapCheck.BootstrapCheckResult result = check.check(context)__            if (result.isFailure()) {_                if (!(enforceLimits || enforceBootstrapChecks) && !check.alwaysEnforce()) {_                    ignoredErrors.add(result.getMessage())__                } else {_                    errors.add(result.getMessage())__                }_            }_        }__        if (!ignoredErrors.isEmpty()) {_            ignoredErrors.forEach(error -> log(logger, error))__        }__        if (!errors.isEmpty()) {_            final List<String> messages = new ArrayList<>(1 + errors.size())__            messages.add("[" + errors.size() + "] bootstrap checks failed")__            for (int i = 0_ i < errors.size()_ i++) {_                messages.add("[" + (i + 1) + "]: " + errors.get(i))__            }_            final NodeValidationException ne = new NodeValidationException(String.join("\n", messages))__            errors.stream().map(IllegalStateException::new).forEach(ne::addSuppressed)__            throw ne__        }_    };executes,the,provided,checks,and,fails,the,node,if,code,enforce,limits,is,code,true,otherwise,logs,warnings,if,the,system,property,code,es,enforce,bootstrap,checks,is,set,to,code,true,then,the,bootstrap,checks,will,be,enforced,regardless,of,whether,or,not,the,transport,protocol,is,bound,to,a,non,loopback,interface,param,context,the,current,node,boostrap,context,param,enforce,limits,code,true,if,the,checks,should,be,enforced,or,otherwise,warned,param,checks,the,checks,to,execute,param,logger,the,logger,to;static,void,check,final,bootstrap,context,context,final,boolean,enforce,limits,final,list,bootstrap,check,checks,final,logger,logger,throws,node,validation,exception,final,list,string,errors,new,array,list,final,list,string,ignored,errors,new,array,list,final,string,es,enforce,bootstrap,checks,system,get,property,final,boolean,enforce,bootstrap,checks,if,es,enforce,bootstrap,checks,null,enforce,bootstrap,checks,false,else,if,boolean,true,to,string,equals,es,enforce,bootstrap,checks,enforce,bootstrap,checks,true,else,final,string,message,string,format,locale,root,s,must,be,true,but,was,s,es,enforce,bootstrap,checks,throw,new,illegal,argument,exception,message,if,enforce,limits,logger,info,bound,or,publishing,to,a,non,loopback,address,enforcing,bootstrap,checks,else,if,enforce,bootstrap,checks,logger,info,explicitly,enforcing,bootstrap,checks,for,final,bootstrap,check,check,checks,final,bootstrap,check,bootstrap,check,result,result,check,check,context,if,result,is,failure,if,enforce,limits,enforce,bootstrap,checks,check,always,enforce,ignored,errors,add,result,get,message,else,errors,add,result,get,message,if,ignored,errors,is,empty,ignored,errors,for,each,error,log,logger,error,if,errors,is,empty,final,list,string,messages,new,array,list,1,errors,size,messages,add,errors,size,bootstrap,checks,failed,for,int,i,0,i,errors,size,i,messages,add,i,1,errors,get,i,final,node,validation,exception,ne,new,node,validation,exception,string,join,n,messages,errors,stream,map,illegal,state,exception,new,for,each,ne,add,suppressed,throw,ne
BootstrapChecks -> static void check(             final BootstrapContext context,             final boolean enforceLimits,             final List<BootstrapCheck> checks,             final Logger logger) throws NodeValidationException;1549356412;Executes the provided checks and fails the node if {@code enforceLimits} is {@code true}, otherwise logs warnings. If the system_property {@code es.enforce.bootstrap.checks }is set to {@code true} then the bootstrap checks will be enforced regardless of whether_or not the transport protocol is bound to a non-loopback interface.__@param context the current node boostrap context_@param enforceLimits {@code true} if the checks should be enforced or otherwise warned_@param checks        the checks to execute_@param logger        the logger to;static void check(_            final BootstrapContext context,_            final boolean enforceLimits,_            final List<BootstrapCheck> checks,_            final Logger logger) throws NodeValidationException {_        final List<String> errors = new ArrayList<>()__        final List<String> ignoredErrors = new ArrayList<>()___        final String esEnforceBootstrapChecks = System.getProperty(ES_ENFORCE_BOOTSTRAP_CHECKS)__        final boolean enforceBootstrapChecks__        if (esEnforceBootstrapChecks == null) {_            enforceBootstrapChecks = false__        } else if (Boolean.TRUE.toString().equals(esEnforceBootstrapChecks)) {_            enforceBootstrapChecks = true__        } else {_            final String message =_                    String.format(_                            Locale.ROOT,_                            "[%s] must be [true] but was [%s]",_                            ES_ENFORCE_BOOTSTRAP_CHECKS,_                            esEnforceBootstrapChecks)__            throw new IllegalArgumentException(message)__        }__        if (enforceLimits) {_            logger.info("bound or publishing to a non-loopback address, enforcing bootstrap checks")__        } else if (enforceBootstrapChecks) {_            logger.info("explicitly enforcing bootstrap checks")__        }__        for (final BootstrapCheck check : checks) {_            final BootstrapCheck.BootstrapCheckResult result = check.check(context)__            if (result.isFailure()) {_                if (!(enforceLimits || enforceBootstrapChecks) && !check.alwaysEnforce()) {_                    ignoredErrors.add(result.getMessage())__                } else {_                    errors.add(result.getMessage())__                }_            }_        }__        if (!ignoredErrors.isEmpty()) {_            ignoredErrors.forEach(error -> log(logger, error))__        }__        if (!errors.isEmpty()) {_            final List<String> messages = new ArrayList<>(1 + errors.size())__            messages.add("[" + errors.size() + "] bootstrap checks failed")__            for (int i = 0_ i < errors.size()_ i++) {_                messages.add("[" + (i + 1) + "]: " + errors.get(i))__            }_            final NodeValidationException ne = new NodeValidationException(String.join("\n", messages))__            errors.stream().map(IllegalStateException::new).forEach(ne::addSuppressed)__            throw ne__        }_    };executes,the,provided,checks,and,fails,the,node,if,code,enforce,limits,is,code,true,otherwise,logs,warnings,if,the,system,property,code,es,enforce,bootstrap,checks,is,set,to,code,true,then,the,bootstrap,checks,will,be,enforced,regardless,of,whether,or,not,the,transport,protocol,is,bound,to,a,non,loopback,interface,param,context,the,current,node,boostrap,context,param,enforce,limits,code,true,if,the,checks,should,be,enforced,or,otherwise,warned,param,checks,the,checks,to,execute,param,logger,the,logger,to;static,void,check,final,bootstrap,context,context,final,boolean,enforce,limits,final,list,bootstrap,check,checks,final,logger,logger,throws,node,validation,exception,final,list,string,errors,new,array,list,final,list,string,ignored,errors,new,array,list,final,string,es,enforce,bootstrap,checks,system,get,property,final,boolean,enforce,bootstrap,checks,if,es,enforce,bootstrap,checks,null,enforce,bootstrap,checks,false,else,if,boolean,true,to,string,equals,es,enforce,bootstrap,checks,enforce,bootstrap,checks,true,else,final,string,message,string,format,locale,root,s,must,be,true,but,was,s,es,enforce,bootstrap,checks,throw,new,illegal,argument,exception,message,if,enforce,limits,logger,info,bound,or,publishing,to,a,non,loopback,address,enforcing,bootstrap,checks,else,if,enforce,bootstrap,checks,logger,info,explicitly,enforcing,bootstrap,checks,for,final,bootstrap,check,check,checks,final,bootstrap,check,bootstrap,check,result,result,check,check,context,if,result,is,failure,if,enforce,limits,enforce,bootstrap,checks,check,always,enforce,ignored,errors,add,result,get,message,else,errors,add,result,get,message,if,ignored,errors,is,empty,ignored,errors,for,each,error,log,logger,error,if,errors,is,empty,final,list,string,messages,new,array,list,1,errors,size,messages,add,errors,size,bootstrap,checks,failed,for,int,i,0,i,errors,size,i,messages,add,i,1,errors,get,i,final,node,validation,exception,ne,new,node,validation,exception,string,join,n,messages,errors,stream,map,illegal,state,exception,new,for,each,ne,add,suppressed,throw,ne
BootstrapChecks -> static void check(             final BootstrapContext context,             final boolean enforceLimits,             final List<BootstrapCheck> checks,             final Logger logger) throws NodeValidationException;1549452878;Executes the provided checks and fails the node if {@code enforceLimits} is {@code true}, otherwise logs warnings. If the system_property {@code es.enforce.bootstrap.checks }is set to {@code true} then the bootstrap checks will be enforced regardless of whether_or not the transport protocol is bound to a non-loopback interface.__@param context the current node boostrap context_@param enforceLimits {@code true} if the checks should be enforced or otherwise warned_@param checks        the checks to execute_@param logger        the logger to;static void check(_            final BootstrapContext context,_            final boolean enforceLimits,_            final List<BootstrapCheck> checks,_            final Logger logger) throws NodeValidationException {_        final List<String> errors = new ArrayList<>()__        final List<String> ignoredErrors = new ArrayList<>()___        final String esEnforceBootstrapChecks = System.getProperty(ES_ENFORCE_BOOTSTRAP_CHECKS)__        final boolean enforceBootstrapChecks__        if (esEnforceBootstrapChecks == null) {_            enforceBootstrapChecks = false__        } else if (Boolean.TRUE.toString().equals(esEnforceBootstrapChecks)) {_            enforceBootstrapChecks = true__        } else {_            final String message =_                    String.format(_                            Locale.ROOT,_                            "[%s] must be [true] but was [%s]",_                            ES_ENFORCE_BOOTSTRAP_CHECKS,_                            esEnforceBootstrapChecks)__            throw new IllegalArgumentException(message)__        }__        if (enforceLimits) {_            logger.info("bound or publishing to a non-loopback address, enforcing bootstrap checks")__        } else if (enforceBootstrapChecks) {_            logger.info("explicitly enforcing bootstrap checks")__        }__        for (final BootstrapCheck check : checks) {_            final BootstrapCheck.BootstrapCheckResult result = check.check(context)__            if (result.isFailure()) {_                if (!(enforceLimits || enforceBootstrapChecks) && !check.alwaysEnforce()) {_                    ignoredErrors.add(result.getMessage())__                } else {_                    errors.add(result.getMessage())__                }_            }_        }__        if (!ignoredErrors.isEmpty()) {_            ignoredErrors.forEach(error -> log(logger, error))__        }__        if (!errors.isEmpty()) {_            final List<String> messages = new ArrayList<>(1 + errors.size())__            messages.add("[" + errors.size() + "] bootstrap checks failed")__            for (int i = 0_ i < errors.size()_ i++) {_                messages.add("[" + (i + 1) + "]: " + errors.get(i))__            }_            final NodeValidationException ne = new NodeValidationException(String.join("\n", messages))__            errors.stream().map(IllegalStateException::new).forEach(ne::addSuppressed)__            throw ne__        }_    };executes,the,provided,checks,and,fails,the,node,if,code,enforce,limits,is,code,true,otherwise,logs,warnings,if,the,system,property,code,es,enforce,bootstrap,checks,is,set,to,code,true,then,the,bootstrap,checks,will,be,enforced,regardless,of,whether,or,not,the,transport,protocol,is,bound,to,a,non,loopback,interface,param,context,the,current,node,boostrap,context,param,enforce,limits,code,true,if,the,checks,should,be,enforced,or,otherwise,warned,param,checks,the,checks,to,execute,param,logger,the,logger,to;static,void,check,final,bootstrap,context,context,final,boolean,enforce,limits,final,list,bootstrap,check,checks,final,logger,logger,throws,node,validation,exception,final,list,string,errors,new,array,list,final,list,string,ignored,errors,new,array,list,final,string,es,enforce,bootstrap,checks,system,get,property,final,boolean,enforce,bootstrap,checks,if,es,enforce,bootstrap,checks,null,enforce,bootstrap,checks,false,else,if,boolean,true,to,string,equals,es,enforce,bootstrap,checks,enforce,bootstrap,checks,true,else,final,string,message,string,format,locale,root,s,must,be,true,but,was,s,es,enforce,bootstrap,checks,throw,new,illegal,argument,exception,message,if,enforce,limits,logger,info,bound,or,publishing,to,a,non,loopback,address,enforcing,bootstrap,checks,else,if,enforce,bootstrap,checks,logger,info,explicitly,enforcing,bootstrap,checks,for,final,bootstrap,check,check,checks,final,bootstrap,check,bootstrap,check,result,result,check,check,context,if,result,is,failure,if,enforce,limits,enforce,bootstrap,checks,check,always,enforce,ignored,errors,add,result,get,message,else,errors,add,result,get,message,if,ignored,errors,is,empty,ignored,errors,for,each,error,log,logger,error,if,errors,is,empty,final,list,string,messages,new,array,list,1,errors,size,messages,add,errors,size,bootstrap,checks,failed,for,int,i,0,i,errors,size,i,messages,add,i,1,errors,get,i,final,node,validation,exception,ne,new,node,validation,exception,string,join,n,messages,errors,stream,map,illegal,state,exception,new,for,each,ne,add,suppressed,throw,ne
BootstrapChecks -> static void check(final BootstrapContext context, final BoundTransportAddress boundTransportAddress,                       List<BootstrapCheck> additionalChecks) throws NodeValidationException;1524684173;Executes the bootstrap checks if the node has the transport protocol bound to a non-loopback interface. If the system property_{@code es.enforce.bootstrap.checks} is set to {@code true} then the bootstrap checks will be enforced regardless of whether or not_the transport protocol is bound to a non-loopback interface.__@param context              the current node bootstrap context_@param boundTransportAddress the node network bindings;static void check(final BootstrapContext context, final BoundTransportAddress boundTransportAddress,_                      List<BootstrapCheck> additionalChecks) throws NodeValidationException {_        final List<BootstrapCheck> builtInChecks = checks()__        final List<BootstrapCheck> combinedChecks = new ArrayList<>(builtInChecks)__        combinedChecks.addAll(additionalChecks)__        check(  context,_                enforceLimits(boundTransportAddress, DiscoveryModule.DISCOVERY_TYPE_SETTING.get(context.settings)),_                Collections.unmodifiableList(combinedChecks),_                Node.NODE_NAME_SETTING.get(context.settings))__    };executes,the,bootstrap,checks,if,the,node,has,the,transport,protocol,bound,to,a,non,loopback,interface,if,the,system,property,code,es,enforce,bootstrap,checks,is,set,to,code,true,then,the,bootstrap,checks,will,be,enforced,regardless,of,whether,or,not,the,transport,protocol,is,bound,to,a,non,loopback,interface,param,context,the,current,node,bootstrap,context,param,bound,transport,address,the,node,network,bindings;static,void,check,final,bootstrap,context,context,final,bound,transport,address,bound,transport,address,list,bootstrap,check,additional,checks,throws,node,validation,exception,final,list,bootstrap,check,built,in,checks,checks,final,list,bootstrap,check,combined,checks,new,array,list,built,in,checks,combined,checks,add,all,additional,checks,check,context,enforce,limits,bound,transport,address,discovery,module,get,context,settings,collections,unmodifiable,list,combined,checks,node,get,context,settings
BootstrapChecks -> static void check(final BootstrapContext context, final BoundTransportAddress boundTransportAddress,                       List<BootstrapCheck> additionalChecks) throws NodeValidationException;1533063033;Executes the bootstrap checks if the node has the transport protocol bound to a non-loopback interface. If the system property_{@code es.enforce.bootstrap.checks} is set to {@code true} then the bootstrap checks will be enforced regardless of whether or not_the transport protocol is bound to a non-loopback interface.__@param context              the current node bootstrap context_@param boundTransportAddress the node network bindings;static void check(final BootstrapContext context, final BoundTransportAddress boundTransportAddress,_                      List<BootstrapCheck> additionalChecks) throws NodeValidationException {_        final List<BootstrapCheck> builtInChecks = checks()__        final List<BootstrapCheck> combinedChecks = new ArrayList<>(builtInChecks)__        combinedChecks.addAll(additionalChecks)__        check(  context,_                enforceLimits(boundTransportAddress, DiscoveryModule.DISCOVERY_TYPE_SETTING.get(context.settings)),_                Collections.unmodifiableList(combinedChecks))__    };executes,the,bootstrap,checks,if,the,node,has,the,transport,protocol,bound,to,a,non,loopback,interface,if,the,system,property,code,es,enforce,bootstrap,checks,is,set,to,code,true,then,the,bootstrap,checks,will,be,enforced,regardless,of,whether,or,not,the,transport,protocol,is,bound,to,a,non,loopback,interface,param,context,the,current,node,bootstrap,context,param,bound,transport,address,the,node,network,bindings;static,void,check,final,bootstrap,context,context,final,bound,transport,address,bound,transport,address,list,bootstrap,check,additional,checks,throws,node,validation,exception,final,list,bootstrap,check,built,in,checks,checks,final,list,bootstrap,check,combined,checks,new,array,list,built,in,checks,combined,checks,add,all,additional,checks,check,context,enforce,limits,bound,transport,address,discovery,module,get,context,settings,collections,unmodifiable,list,combined,checks
BootstrapChecks -> static void check(final BootstrapContext context, final BoundTransportAddress boundTransportAddress,                       List<BootstrapCheck> additionalChecks) throws NodeValidationException;1535046779;Executes the bootstrap checks if the node has the transport protocol bound to a non-loopback interface. If the system property_{@code es.enforce.bootstrap.checks} is set to {@code true} then the bootstrap checks will be enforced regardless of whether or not_the transport protocol is bound to a non-loopback interface.__@param context              the current node bootstrap context_@param boundTransportAddress the node network bindings;static void check(final BootstrapContext context, final BoundTransportAddress boundTransportAddress,_                      List<BootstrapCheck> additionalChecks) throws NodeValidationException {_        final List<BootstrapCheck> builtInChecks = checks()__        final List<BootstrapCheck> combinedChecks = new ArrayList<>(builtInChecks)__        combinedChecks.addAll(additionalChecks)__        check(  context,_                enforceLimits(boundTransportAddress, DiscoveryModule.DISCOVERY_TYPE_SETTING.get(context.settings)),_                Collections.unmodifiableList(combinedChecks))__    };executes,the,bootstrap,checks,if,the,node,has,the,transport,protocol,bound,to,a,non,loopback,interface,if,the,system,property,code,es,enforce,bootstrap,checks,is,set,to,code,true,then,the,bootstrap,checks,will,be,enforced,regardless,of,whether,or,not,the,transport,protocol,is,bound,to,a,non,loopback,interface,param,context,the,current,node,bootstrap,context,param,bound,transport,address,the,node,network,bindings;static,void,check,final,bootstrap,context,context,final,bound,transport,address,bound,transport,address,list,bootstrap,check,additional,checks,throws,node,validation,exception,final,list,bootstrap,check,built,in,checks,checks,final,list,bootstrap,check,combined,checks,new,array,list,built,in,checks,combined,checks,add,all,additional,checks,check,context,enforce,limits,bound,transport,address,discovery,module,get,context,settings,collections,unmodifiable,list,combined,checks
BootstrapChecks -> static void check(final BootstrapContext context, final BoundTransportAddress boundTransportAddress,                       List<BootstrapCheck> additionalChecks) throws NodeValidationException;1540486836;Executes the bootstrap checks if the node has the transport protocol bound to a non-loopback interface. If the system property_{@code es.enforce.bootstrap.checks} is set to {@code true} then the bootstrap checks will be enforced regardless of whether or not_the transport protocol is bound to a non-loopback interface.__@param context              the current node bootstrap context_@param boundTransportAddress the node network bindings;static void check(final BootstrapContext context, final BoundTransportAddress boundTransportAddress,_                      List<BootstrapCheck> additionalChecks) throws NodeValidationException {_        final List<BootstrapCheck> builtInChecks = checks()__        final List<BootstrapCheck> combinedChecks = new ArrayList<>(builtInChecks)__        combinedChecks.addAll(additionalChecks)__        check(  context,_                enforceLimits(boundTransportAddress, DiscoveryModule.DISCOVERY_TYPE_SETTING.get(context.settings)),_                Collections.unmodifiableList(combinedChecks))__    };executes,the,bootstrap,checks,if,the,node,has,the,transport,protocol,bound,to,a,non,loopback,interface,if,the,system,property,code,es,enforce,bootstrap,checks,is,set,to,code,true,then,the,bootstrap,checks,will,be,enforced,regardless,of,whether,or,not,the,transport,protocol,is,bound,to,a,non,loopback,interface,param,context,the,current,node,bootstrap,context,param,bound,transport,address,the,node,network,bindings;static,void,check,final,bootstrap,context,context,final,bound,transport,address,bound,transport,address,list,bootstrap,check,additional,checks,throws,node,validation,exception,final,list,bootstrap,check,built,in,checks,checks,final,list,bootstrap,check,combined,checks,new,array,list,built,in,checks,combined,checks,add,all,additional,checks,check,context,enforce,limits,bound,transport,address,discovery,module,get,context,settings,collections,unmodifiable,list,combined,checks
BootstrapChecks -> static void check(final BootstrapContext context, final BoundTransportAddress boundTransportAddress,                       List<BootstrapCheck> additionalChecks) throws NodeValidationException;1544186829;Executes the bootstrap checks if the node has the transport protocol bound to a non-loopback interface. If the system property_{@code es.enforce.bootstrap.checks} is set to {@code true} then the bootstrap checks will be enforced regardless of whether or not_the transport protocol is bound to a non-loopback interface.__@param context              the current node bootstrap context_@param boundTransportAddress the node network bindings;static void check(final BootstrapContext context, final BoundTransportAddress boundTransportAddress,_                      List<BootstrapCheck> additionalChecks) throws NodeValidationException {_        final List<BootstrapCheck> builtInChecks = checks()__        final List<BootstrapCheck> combinedChecks = new ArrayList<>(builtInChecks)__        combinedChecks.addAll(additionalChecks)__        check(  context,_                enforceLimits(boundTransportAddress, DiscoveryModule.DISCOVERY_TYPE_SETTING.get(context.settings)),_                Collections.unmodifiableList(combinedChecks))__    };executes,the,bootstrap,checks,if,the,node,has,the,transport,protocol,bound,to,a,non,loopback,interface,if,the,system,property,code,es,enforce,bootstrap,checks,is,set,to,code,true,then,the,bootstrap,checks,will,be,enforced,regardless,of,whether,or,not,the,transport,protocol,is,bound,to,a,non,loopback,interface,param,context,the,current,node,bootstrap,context,param,bound,transport,address,the,node,network,bindings;static,void,check,final,bootstrap,context,context,final,bound,transport,address,bound,transport,address,list,bootstrap,check,additional,checks,throws,node,validation,exception,final,list,bootstrap,check,built,in,checks,checks,final,list,bootstrap,check,combined,checks,new,array,list,built,in,checks,combined,checks,add,all,additional,checks,check,context,enforce,limits,bound,transport,address,discovery,module,get,context,settings,collections,unmodifiable,list,combined,checks
BootstrapChecks -> static void check(final BootstrapContext context, final BoundTransportAddress boundTransportAddress,                       List<BootstrapCheck> additionalChecks) throws NodeValidationException;1544677641;Executes the bootstrap checks if the node has the transport protocol bound to a non-loopback interface. If the system property_{@code es.enforce.bootstrap.checks} is set to {@code true} then the bootstrap checks will be enforced regardless of whether or not_the transport protocol is bound to a non-loopback interface.__@param context              the current node bootstrap context_@param boundTransportAddress the node network bindings;static void check(final BootstrapContext context, final BoundTransportAddress boundTransportAddress,_                      List<BootstrapCheck> additionalChecks) throws NodeValidationException {_        final List<BootstrapCheck> builtInChecks = checks()__        final List<BootstrapCheck> combinedChecks = new ArrayList<>(builtInChecks)__        combinedChecks.addAll(additionalChecks)__        check(  context,_                enforceLimits(boundTransportAddress, DiscoveryModule.DISCOVERY_TYPE_SETTING.get(context.settings())),_                Collections.unmodifiableList(combinedChecks))__    };executes,the,bootstrap,checks,if,the,node,has,the,transport,protocol,bound,to,a,non,loopback,interface,if,the,system,property,code,es,enforce,bootstrap,checks,is,set,to,code,true,then,the,bootstrap,checks,will,be,enforced,regardless,of,whether,or,not,the,transport,protocol,is,bound,to,a,non,loopback,interface,param,context,the,current,node,bootstrap,context,param,bound,transport,address,the,node,network,bindings;static,void,check,final,bootstrap,context,context,final,bound,transport,address,bound,transport,address,list,bootstrap,check,additional,checks,throws,node,validation,exception,final,list,bootstrap,check,built,in,checks,checks,final,list,bootstrap,check,combined,checks,new,array,list,built,in,checks,combined,checks,add,all,additional,checks,check,context,enforce,limits,bound,transport,address,discovery,module,get,context,settings,collections,unmodifiable,list,combined,checks
BootstrapChecks -> static void check(final BootstrapContext context, final BoundTransportAddress boundTransportAddress,                       List<BootstrapCheck> additionalChecks) throws NodeValidationException;1546495834;Executes the bootstrap checks if the node has the transport protocol bound to a non-loopback interface. If the system property_{@code es.enforce.bootstrap.checks} is set to {@code true} then the bootstrap checks will be enforced regardless of whether or not_the transport protocol is bound to a non-loopback interface.__@param context              the current node bootstrap context_@param boundTransportAddress the node network bindings;static void check(final BootstrapContext context, final BoundTransportAddress boundTransportAddress,_                      List<BootstrapCheck> additionalChecks) throws NodeValidationException {_        final List<BootstrapCheck> builtInChecks = checks()__        final List<BootstrapCheck> combinedChecks = new ArrayList<>(builtInChecks)__        combinedChecks.addAll(additionalChecks)__        check(  context,_                enforceLimits(boundTransportAddress, DiscoveryModule.DISCOVERY_TYPE_SETTING.get(context.settings())),_                Collections.unmodifiableList(combinedChecks))__    };executes,the,bootstrap,checks,if,the,node,has,the,transport,protocol,bound,to,a,non,loopback,interface,if,the,system,property,code,es,enforce,bootstrap,checks,is,set,to,code,true,then,the,bootstrap,checks,will,be,enforced,regardless,of,whether,or,not,the,transport,protocol,is,bound,to,a,non,loopback,interface,param,context,the,current,node,bootstrap,context,param,bound,transport,address,the,node,network,bindings;static,void,check,final,bootstrap,context,context,final,bound,transport,address,bound,transport,address,list,bootstrap,check,additional,checks,throws,node,validation,exception,final,list,bootstrap,check,built,in,checks,checks,final,list,bootstrap,check,combined,checks,new,array,list,built,in,checks,combined,checks,add,all,additional,checks,check,context,enforce,limits,bound,transport,address,discovery,module,get,context,settings,collections,unmodifiable,list,combined,checks
BootstrapChecks -> static void check(final BootstrapContext context, final BoundTransportAddress boundTransportAddress,                       List<BootstrapCheck> additionalChecks) throws NodeValidationException;1547677152;Executes the bootstrap checks if the node has the transport protocol bound to a non-loopback interface. If the system property_{@code es.enforce.bootstrap.checks} is set to {@code true} then the bootstrap checks will be enforced regardless of whether or not_the transport protocol is bound to a non-loopback interface.__@param context              the current node bootstrap context_@param boundTransportAddress the node network bindings;static void check(final BootstrapContext context, final BoundTransportAddress boundTransportAddress,_                      List<BootstrapCheck> additionalChecks) throws NodeValidationException {_        final List<BootstrapCheck> builtInChecks = checks()__        final List<BootstrapCheck> combinedChecks = new ArrayList<>(builtInChecks)__        combinedChecks.addAll(additionalChecks)__        check(  context,_                enforceLimits(boundTransportAddress, DiscoveryModule.DISCOVERY_TYPE_SETTING.get(context.settings())),_                Collections.unmodifiableList(combinedChecks))__    };executes,the,bootstrap,checks,if,the,node,has,the,transport,protocol,bound,to,a,non,loopback,interface,if,the,system,property,code,es,enforce,bootstrap,checks,is,set,to,code,true,then,the,bootstrap,checks,will,be,enforced,regardless,of,whether,or,not,the,transport,protocol,is,bound,to,a,non,loopback,interface,param,context,the,current,node,bootstrap,context,param,bound,transport,address,the,node,network,bindings;static,void,check,final,bootstrap,context,context,final,bound,transport,address,bound,transport,address,list,bootstrap,check,additional,checks,throws,node,validation,exception,final,list,bootstrap,check,built,in,checks,checks,final,list,bootstrap,check,combined,checks,new,array,list,built,in,checks,combined,checks,add,all,additional,checks,check,context,enforce,limits,bound,transport,address,discovery,module,get,context,settings,collections,unmodifiable,list,combined,checks
BootstrapChecks -> static void check(final BootstrapContext context, final BoundTransportAddress boundTransportAddress,                       List<BootstrapCheck> additionalChecks) throws NodeValidationException;1549356412;Executes the bootstrap checks if the node has the transport protocol bound to a non-loopback interface. If the system property_{@code es.enforce.bootstrap.checks} is set to {@code true} then the bootstrap checks will be enforced regardless of whether or not_the transport protocol is bound to a non-loopback interface.__@param context              the current node bootstrap context_@param boundTransportAddress the node network bindings;static void check(final BootstrapContext context, final BoundTransportAddress boundTransportAddress,_                      List<BootstrapCheck> additionalChecks) throws NodeValidationException {_        final List<BootstrapCheck> builtInChecks = checks()__        final List<BootstrapCheck> combinedChecks = new ArrayList<>(builtInChecks)__        combinedChecks.addAll(additionalChecks)__        check(  context,_                enforceLimits(boundTransportAddress, DiscoveryModule.DISCOVERY_TYPE_SETTING.get(context.settings())),_                Collections.unmodifiableList(combinedChecks))__    };executes,the,bootstrap,checks,if,the,node,has,the,transport,protocol,bound,to,a,non,loopback,interface,if,the,system,property,code,es,enforce,bootstrap,checks,is,set,to,code,true,then,the,bootstrap,checks,will,be,enforced,regardless,of,whether,or,not,the,transport,protocol,is,bound,to,a,non,loopback,interface,param,context,the,current,node,bootstrap,context,param,bound,transport,address,the,node,network,bindings;static,void,check,final,bootstrap,context,context,final,bound,transport,address,bound,transport,address,list,bootstrap,check,additional,checks,throws,node,validation,exception,final,list,bootstrap,check,built,in,checks,checks,final,list,bootstrap,check,combined,checks,new,array,list,built,in,checks,combined,checks,add,all,additional,checks,check,context,enforce,limits,bound,transport,address,discovery,module,get,context,settings,collections,unmodifiable,list,combined,checks
BootstrapChecks -> static void check(final BootstrapContext context, final BoundTransportAddress boundTransportAddress,                       List<BootstrapCheck> additionalChecks) throws NodeValidationException;1549452878;Executes the bootstrap checks if the node has the transport protocol bound to a non-loopback interface. If the system property_{@code es.enforce.bootstrap.checks} is set to {@code true} then the bootstrap checks will be enforced regardless of whether or not_the transport protocol is bound to a non-loopback interface.__@param context              the current node bootstrap context_@param boundTransportAddress the node network bindings;static void check(final BootstrapContext context, final BoundTransportAddress boundTransportAddress,_                      List<BootstrapCheck> additionalChecks) throws NodeValidationException {_        final List<BootstrapCheck> builtInChecks = checks()__        final List<BootstrapCheck> combinedChecks = new ArrayList<>(builtInChecks)__        combinedChecks.addAll(additionalChecks)__        check(  context,_                enforceLimits(boundTransportAddress, DiscoveryModule.DISCOVERY_TYPE_SETTING.get(context.settings())),_                Collections.unmodifiableList(combinedChecks))__    };executes,the,bootstrap,checks,if,the,node,has,the,transport,protocol,bound,to,a,non,loopback,interface,if,the,system,property,code,es,enforce,bootstrap,checks,is,set,to,code,true,then,the,bootstrap,checks,will,be,enforced,regardless,of,whether,or,not,the,transport,protocol,is,bound,to,a,non,loopback,interface,param,context,the,current,node,bootstrap,context,param,bound,transport,address,the,node,network,bindings;static,void,check,final,bootstrap,context,context,final,bound,transport,address,bound,transport,address,list,bootstrap,check,additional,checks,throws,node,validation,exception,final,list,bootstrap,check,built,in,checks,checks,final,list,bootstrap,check,combined,checks,new,array,list,built,in,checks,combined,checks,add,all,additional,checks,check,context,enforce,limits,bound,transport,address,discovery,module,get,context,settings,collections,unmodifiable,list,combined,checks
BootstrapChecks -> static boolean enforceLimits(final BoundTransportAddress boundTransportAddress, final String discoveryType);1524684173;Tests if the checks should be enforced.__@param boundTransportAddress the node network bindings_@param discoveryType the discovery type_@return {@code true} if the checks should be enforced;static boolean enforceLimits(final BoundTransportAddress boundTransportAddress, final String discoveryType) {_        final Predicate<TransportAddress> isLoopbackAddress = t -> t.address().getAddress().isLoopbackAddress()__        final boolean bound =_                !(Arrays.stream(boundTransportAddress.boundAddresses()).allMatch(isLoopbackAddress) &&_                isLoopbackAddress.test(boundTransportAddress.publishAddress()))__        return bound && !"single-node".equals(discoveryType)__    };tests,if,the,checks,should,be,enforced,param,bound,transport,address,the,node,network,bindings,param,discovery,type,the,discovery,type,return,code,true,if,the,checks,should,be,enforced;static,boolean,enforce,limits,final,bound,transport,address,bound,transport,address,final,string,discovery,type,final,predicate,transport,address,is,loopback,address,t,t,address,get,address,is,loopback,address,final,boolean,bound,arrays,stream,bound,transport,address,bound,addresses,all,match,is,loopback,address,is,loopback,address,test,bound,transport,address,publish,address,return,bound,single,node,equals,discovery,type
BootstrapChecks -> static boolean enforceLimits(final BoundTransportAddress boundTransportAddress, final String discoveryType);1533063033;Tests if the checks should be enforced.__@param boundTransportAddress the node network bindings_@param discoveryType the discovery type_@return {@code true} if the checks should be enforced;static boolean enforceLimits(final BoundTransportAddress boundTransportAddress, final String discoveryType) {_        final Predicate<TransportAddress> isLoopbackAddress = t -> t.address().getAddress().isLoopbackAddress()__        final boolean bound =_                !(Arrays.stream(boundTransportAddress.boundAddresses()).allMatch(isLoopbackAddress) &&_                isLoopbackAddress.test(boundTransportAddress.publishAddress()))__        return bound && !"single-node".equals(discoveryType)__    };tests,if,the,checks,should,be,enforced,param,bound,transport,address,the,node,network,bindings,param,discovery,type,the,discovery,type,return,code,true,if,the,checks,should,be,enforced;static,boolean,enforce,limits,final,bound,transport,address,bound,transport,address,final,string,discovery,type,final,predicate,transport,address,is,loopback,address,t,t,address,get,address,is,loopback,address,final,boolean,bound,arrays,stream,bound,transport,address,bound,addresses,all,match,is,loopback,address,is,loopback,address,test,bound,transport,address,publish,address,return,bound,single,node,equals,discovery,type
BootstrapChecks -> static boolean enforceLimits(final BoundTransportAddress boundTransportAddress, final String discoveryType);1535046779;Tests if the checks should be enforced.__@param boundTransportAddress the node network bindings_@param discoveryType the discovery type_@return {@code true} if the checks should be enforced;static boolean enforceLimits(final BoundTransportAddress boundTransportAddress, final String discoveryType) {_        final Predicate<TransportAddress> isLoopbackAddress = t -> t.address().getAddress().isLoopbackAddress()__        final boolean bound =_                !(Arrays.stream(boundTransportAddress.boundAddresses()).allMatch(isLoopbackAddress) &&_                isLoopbackAddress.test(boundTransportAddress.publishAddress()))__        return bound && !"single-node".equals(discoveryType)__    };tests,if,the,checks,should,be,enforced,param,bound,transport,address,the,node,network,bindings,param,discovery,type,the,discovery,type,return,code,true,if,the,checks,should,be,enforced;static,boolean,enforce,limits,final,bound,transport,address,bound,transport,address,final,string,discovery,type,final,predicate,transport,address,is,loopback,address,t,t,address,get,address,is,loopback,address,final,boolean,bound,arrays,stream,bound,transport,address,bound,addresses,all,match,is,loopback,address,is,loopback,address,test,bound,transport,address,publish,address,return,bound,single,node,equals,discovery,type
BootstrapChecks -> static boolean enforceLimits(final BoundTransportAddress boundTransportAddress, final String discoveryType);1540486836;Tests if the checks should be enforced.__@param boundTransportAddress the node network bindings_@param discoveryType the discovery type_@return {@code true} if the checks should be enforced;static boolean enforceLimits(final BoundTransportAddress boundTransportAddress, final String discoveryType) {_        final Predicate<TransportAddress> isLoopbackAddress = t -> t.address().getAddress().isLoopbackAddress()__        final boolean bound =_                !(Arrays.stream(boundTransportAddress.boundAddresses()).allMatch(isLoopbackAddress) &&_                isLoopbackAddress.test(boundTransportAddress.publishAddress()))__        return bound && !"single-node".equals(discoveryType)__    };tests,if,the,checks,should,be,enforced,param,bound,transport,address,the,node,network,bindings,param,discovery,type,the,discovery,type,return,code,true,if,the,checks,should,be,enforced;static,boolean,enforce,limits,final,bound,transport,address,bound,transport,address,final,string,discovery,type,final,predicate,transport,address,is,loopback,address,t,t,address,get,address,is,loopback,address,final,boolean,bound,arrays,stream,bound,transport,address,bound,addresses,all,match,is,loopback,address,is,loopback,address,test,bound,transport,address,publish,address,return,bound,single,node,equals,discovery,type
BootstrapChecks -> static boolean enforceLimits(final BoundTransportAddress boundTransportAddress, final String discoveryType);1544186829;Tests if the checks should be enforced.__@param boundTransportAddress the node network bindings_@param discoveryType the discovery type_@return {@code true} if the checks should be enforced;static boolean enforceLimits(final BoundTransportAddress boundTransportAddress, final String discoveryType) {_        final Predicate<TransportAddress> isLoopbackAddress = t -> t.address().getAddress().isLoopbackAddress()__        final boolean bound =_                !(Arrays.stream(boundTransportAddress.boundAddresses()).allMatch(isLoopbackAddress) &&_                isLoopbackAddress.test(boundTransportAddress.publishAddress()))__        return bound && !"single-node".equals(discoveryType)__    };tests,if,the,checks,should,be,enforced,param,bound,transport,address,the,node,network,bindings,param,discovery,type,the,discovery,type,return,code,true,if,the,checks,should,be,enforced;static,boolean,enforce,limits,final,bound,transport,address,bound,transport,address,final,string,discovery,type,final,predicate,transport,address,is,loopback,address,t,t,address,get,address,is,loopback,address,final,boolean,bound,arrays,stream,bound,transport,address,bound,addresses,all,match,is,loopback,address,is,loopback,address,test,bound,transport,address,publish,address,return,bound,single,node,equals,discovery,type
BootstrapChecks -> static boolean enforceLimits(final BoundTransportAddress boundTransportAddress, final String discoveryType);1544677641;Tests if the checks should be enforced.__@param boundTransportAddress the node network bindings_@param discoveryType the discovery type_@return {@code true} if the checks should be enforced;static boolean enforceLimits(final BoundTransportAddress boundTransportAddress, final String discoveryType) {_        final Predicate<TransportAddress> isLoopbackAddress = t -> t.address().getAddress().isLoopbackAddress()__        final boolean bound =_                !(Arrays.stream(boundTransportAddress.boundAddresses()).allMatch(isLoopbackAddress) &&_                isLoopbackAddress.test(boundTransportAddress.publishAddress()))__        return bound && !"single-node".equals(discoveryType)__    };tests,if,the,checks,should,be,enforced,param,bound,transport,address,the,node,network,bindings,param,discovery,type,the,discovery,type,return,code,true,if,the,checks,should,be,enforced;static,boolean,enforce,limits,final,bound,transport,address,bound,transport,address,final,string,discovery,type,final,predicate,transport,address,is,loopback,address,t,t,address,get,address,is,loopback,address,final,boolean,bound,arrays,stream,bound,transport,address,bound,addresses,all,match,is,loopback,address,is,loopback,address,test,bound,transport,address,publish,address,return,bound,single,node,equals,discovery,type
BootstrapChecks -> static boolean enforceLimits(final BoundTransportAddress boundTransportAddress, final String discoveryType);1546495834;Tests if the checks should be enforced.__@param boundTransportAddress the node network bindings_@param discoveryType the discovery type_@return {@code true} if the checks should be enforced;static boolean enforceLimits(final BoundTransportAddress boundTransportAddress, final String discoveryType) {_        final Predicate<TransportAddress> isLoopbackAddress = t -> t.address().getAddress().isLoopbackAddress()__        final boolean bound =_                !(Arrays.stream(boundTransportAddress.boundAddresses()).allMatch(isLoopbackAddress) &&_                isLoopbackAddress.test(boundTransportAddress.publishAddress()))__        return bound && !"single-node".equals(discoveryType)__    };tests,if,the,checks,should,be,enforced,param,bound,transport,address,the,node,network,bindings,param,discovery,type,the,discovery,type,return,code,true,if,the,checks,should,be,enforced;static,boolean,enforce,limits,final,bound,transport,address,bound,transport,address,final,string,discovery,type,final,predicate,transport,address,is,loopback,address,t,t,address,get,address,is,loopback,address,final,boolean,bound,arrays,stream,bound,transport,address,bound,addresses,all,match,is,loopback,address,is,loopback,address,test,bound,transport,address,publish,address,return,bound,single,node,equals,discovery,type
BootstrapChecks -> static boolean enforceLimits(final BoundTransportAddress boundTransportAddress, final String discoveryType);1547677152;Tests if the checks should be enforced.__@param boundTransportAddress the node network bindings_@param discoveryType the discovery type_@return {@code true} if the checks should be enforced;static boolean enforceLimits(final BoundTransportAddress boundTransportAddress, final String discoveryType) {_        final Predicate<TransportAddress> isLoopbackAddress = t -> t.address().getAddress().isLoopbackAddress()__        final boolean bound =_                !(Arrays.stream(boundTransportAddress.boundAddresses()).allMatch(isLoopbackAddress) &&_                isLoopbackAddress.test(boundTransportAddress.publishAddress()))__        return bound && !"single-node".equals(discoveryType)__    };tests,if,the,checks,should,be,enforced,param,bound,transport,address,the,node,network,bindings,param,discovery,type,the,discovery,type,return,code,true,if,the,checks,should,be,enforced;static,boolean,enforce,limits,final,bound,transport,address,bound,transport,address,final,string,discovery,type,final,predicate,transport,address,is,loopback,address,t,t,address,get,address,is,loopback,address,final,boolean,bound,arrays,stream,bound,transport,address,bound,addresses,all,match,is,loopback,address,is,loopback,address,test,bound,transport,address,publish,address,return,bound,single,node,equals,discovery,type
BootstrapChecks -> static boolean enforceLimits(final BoundTransportAddress boundTransportAddress, final String discoveryType);1549356412;Tests if the checks should be enforced.__@param boundTransportAddress the node network bindings_@param discoveryType the discovery type_@return {@code true} if the checks should be enforced;static boolean enforceLimits(final BoundTransportAddress boundTransportAddress, final String discoveryType) {_        final Predicate<TransportAddress> isLoopbackAddress = t -> t.address().getAddress().isLoopbackAddress()__        final boolean bound =_                !(Arrays.stream(boundTransportAddress.boundAddresses()).allMatch(isLoopbackAddress) &&_                isLoopbackAddress.test(boundTransportAddress.publishAddress()))__        return bound && !"single-node".equals(discoveryType)__    };tests,if,the,checks,should,be,enforced,param,bound,transport,address,the,node,network,bindings,param,discovery,type,the,discovery,type,return,code,true,if,the,checks,should,be,enforced;static,boolean,enforce,limits,final,bound,transport,address,bound,transport,address,final,string,discovery,type,final,predicate,transport,address,is,loopback,address,t,t,address,get,address,is,loopback,address,final,boolean,bound,arrays,stream,bound,transport,address,bound,addresses,all,match,is,loopback,address,is,loopback,address,test,bound,transport,address,publish,address,return,bound,single,node,equals,discovery,type
BootstrapChecks -> static boolean enforceLimits(final BoundTransportAddress boundTransportAddress, final String discoveryType);1549452878;Tests if the checks should be enforced.__@param boundTransportAddress the node network bindings_@param discoveryType the discovery type_@return {@code true} if the checks should be enforced;static boolean enforceLimits(final BoundTransportAddress boundTransportAddress, final String discoveryType) {_        final Predicate<TransportAddress> isLoopbackAddress = t -> t.address().getAddress().isLoopbackAddress()__        final boolean bound =_                !(Arrays.stream(boundTransportAddress.boundAddresses()).allMatch(isLoopbackAddress) &&_                isLoopbackAddress.test(boundTransportAddress.publishAddress()))__        return bound && !"single-node".equals(discoveryType)__    };tests,if,the,checks,should,be,enforced,param,bound,transport,address,the,node,network,bindings,param,discovery,type,the,discovery,type,return,code,true,if,the,checks,should,be,enforced;static,boolean,enforce,limits,final,bound,transport,address,bound,transport,address,final,string,discovery,type,final,predicate,transport,address,is,loopback,address,t,t,address,get,address,is,loopback,address,final,boolean,bound,arrays,stream,bound,transport,address,bound,addresses,all,match,is,loopback,address,is,loopback,address,test,bound,transport,address,publish,address,return,bound,single,node,equals,discovery,type
BootstrapChecks -> static void check(         final BootstrapContext context,         final boolean enforceLimits,         final List<BootstrapCheck> checks) throws NodeValidationException;1533063033;Executes the provided checks and fails the node if {@code enforceLimits} is {@code true}, otherwise logs warnings. If the system_property {@code es.enforce.bootstrap.checks} is set to {@code true} then the bootstrap checks will be enforced regardless of whether_or not the transport protocol is bound to a non-loopback interface.__@param context        the current node boostrap context_@param enforceLimits {@code true} if the checks should be enforced or otherwise warned_@param checks        the checks to execute;static void check(_        final BootstrapContext context,_        final boolean enforceLimits,_        final List<BootstrapCheck> checks) throws NodeValidationException {_        check(context, enforceLimits, checks, Loggers.getLogger(BootstrapChecks.class))__    };executes,the,provided,checks,and,fails,the,node,if,code,enforce,limits,is,code,true,otherwise,logs,warnings,if,the,system,property,code,es,enforce,bootstrap,checks,is,set,to,code,true,then,the,bootstrap,checks,will,be,enforced,regardless,of,whether,or,not,the,transport,protocol,is,bound,to,a,non,loopback,interface,param,context,the,current,node,boostrap,context,param,enforce,limits,code,true,if,the,checks,should,be,enforced,or,otherwise,warned,param,checks,the,checks,to,execute;static,void,check,final,bootstrap,context,context,final,boolean,enforce,limits,final,list,bootstrap,check,checks,throws,node,validation,exception,check,context,enforce,limits,checks,loggers,get,logger,bootstrap,checks,class
BootstrapChecks -> static void check(         final BootstrapContext context,         final boolean enforceLimits,         final List<BootstrapCheck> checks) throws NodeValidationException;1535046779;Executes the provided checks and fails the node if {@code enforceLimits} is {@code true}, otherwise logs warnings. If the system_property {@code es.enforce.bootstrap.checks} is set to {@code true} then the bootstrap checks will be enforced regardless of whether_or not the transport protocol is bound to a non-loopback interface.__@param context        the current node boostrap context_@param enforceLimits {@code true} if the checks should be enforced or otherwise warned_@param checks        the checks to execute;static void check(_        final BootstrapContext context,_        final boolean enforceLimits,_        final List<BootstrapCheck> checks) throws NodeValidationException {_        check(context, enforceLimits, checks, Loggers.getLogger(BootstrapChecks.class))__    };executes,the,provided,checks,and,fails,the,node,if,code,enforce,limits,is,code,true,otherwise,logs,warnings,if,the,system,property,code,es,enforce,bootstrap,checks,is,set,to,code,true,then,the,bootstrap,checks,will,be,enforced,regardless,of,whether,or,not,the,transport,protocol,is,bound,to,a,non,loopback,interface,param,context,the,current,node,boostrap,context,param,enforce,limits,code,true,if,the,checks,should,be,enforced,or,otherwise,warned,param,checks,the,checks,to,execute;static,void,check,final,bootstrap,context,context,final,boolean,enforce,limits,final,list,bootstrap,check,checks,throws,node,validation,exception,check,context,enforce,limits,checks,loggers,get,logger,bootstrap,checks,class
BootstrapChecks -> static void check(         final BootstrapContext context,         final boolean enforceLimits,         final List<BootstrapCheck> checks) throws NodeValidationException;1540486836;Executes the provided checks and fails the node if {@code enforceLimits} is {@code true}, otherwise logs warnings. If the system_property {@code es.enforce.bootstrap.checks} is set to {@code true} then the bootstrap checks will be enforced regardless of whether_or not the transport protocol is bound to a non-loopback interface.__@param context        the current node boostrap context_@param enforceLimits {@code true} if the checks should be enforced or otherwise warned_@param checks        the checks to execute;static void check(_        final BootstrapContext context,_        final boolean enforceLimits,_        final List<BootstrapCheck> checks) throws NodeValidationException {_        check(context, enforceLimits, checks, LogManager.getLogger(BootstrapChecks.class))__    };executes,the,provided,checks,and,fails,the,node,if,code,enforce,limits,is,code,true,otherwise,logs,warnings,if,the,system,property,code,es,enforce,bootstrap,checks,is,set,to,code,true,then,the,bootstrap,checks,will,be,enforced,regardless,of,whether,or,not,the,transport,protocol,is,bound,to,a,non,loopback,interface,param,context,the,current,node,boostrap,context,param,enforce,limits,code,true,if,the,checks,should,be,enforced,or,otherwise,warned,param,checks,the,checks,to,execute;static,void,check,final,bootstrap,context,context,final,boolean,enforce,limits,final,list,bootstrap,check,checks,throws,node,validation,exception,check,context,enforce,limits,checks,log,manager,get,logger,bootstrap,checks,class
BootstrapChecks -> static void check(         final BootstrapContext context,         final boolean enforceLimits,         final List<BootstrapCheck> checks) throws NodeValidationException;1544186829;Executes the provided checks and fails the node if {@code enforceLimits} is {@code true}, otherwise logs warnings. If the system_property {@code es.enforce.bootstrap.checks} is set to {@code true} then the bootstrap checks will be enforced regardless of whether_or not the transport protocol is bound to a non-loopback interface.__@param context        the current node boostrap context_@param enforceLimits {@code true} if the checks should be enforced or otherwise warned_@param checks        the checks to execute;static void check(_        final BootstrapContext context,_        final boolean enforceLimits,_        final List<BootstrapCheck> checks) throws NodeValidationException {_        check(context, enforceLimits, checks, LogManager.getLogger(BootstrapChecks.class))__    };executes,the,provided,checks,and,fails,the,node,if,code,enforce,limits,is,code,true,otherwise,logs,warnings,if,the,system,property,code,es,enforce,bootstrap,checks,is,set,to,code,true,then,the,bootstrap,checks,will,be,enforced,regardless,of,whether,or,not,the,transport,protocol,is,bound,to,a,non,loopback,interface,param,context,the,current,node,boostrap,context,param,enforce,limits,code,true,if,the,checks,should,be,enforced,or,otherwise,warned,param,checks,the,checks,to,execute;static,void,check,final,bootstrap,context,context,final,boolean,enforce,limits,final,list,bootstrap,check,checks,throws,node,validation,exception,check,context,enforce,limits,checks,log,manager,get,logger,bootstrap,checks,class
BootstrapChecks -> static void check(         final BootstrapContext context,         final boolean enforceLimits,         final List<BootstrapCheck> checks) throws NodeValidationException;1544677641;Executes the provided checks and fails the node if {@code enforceLimits} is {@code true}, otherwise logs warnings. If the system_property {@code es.enforce.bootstrap.checks} is set to {@code true} then the bootstrap checks will be enforced regardless of whether_or not the transport protocol is bound to a non-loopback interface.__@param context        the current node boostrap context_@param enforceLimits {@code true} if the checks should be enforced or otherwise warned_@param checks        the checks to execute;static void check(_        final BootstrapContext context,_        final boolean enforceLimits,_        final List<BootstrapCheck> checks) throws NodeValidationException {_        check(context, enforceLimits, checks, LogManager.getLogger(BootstrapChecks.class))__    };executes,the,provided,checks,and,fails,the,node,if,code,enforce,limits,is,code,true,otherwise,logs,warnings,if,the,system,property,code,es,enforce,bootstrap,checks,is,set,to,code,true,then,the,bootstrap,checks,will,be,enforced,regardless,of,whether,or,not,the,transport,protocol,is,bound,to,a,non,loopback,interface,param,context,the,current,node,boostrap,context,param,enforce,limits,code,true,if,the,checks,should,be,enforced,or,otherwise,warned,param,checks,the,checks,to,execute;static,void,check,final,bootstrap,context,context,final,boolean,enforce,limits,final,list,bootstrap,check,checks,throws,node,validation,exception,check,context,enforce,limits,checks,log,manager,get,logger,bootstrap,checks,class
BootstrapChecks -> static void check(         final BootstrapContext context,         final boolean enforceLimits,         final List<BootstrapCheck> checks) throws NodeValidationException;1546495834;Executes the provided checks and fails the node if {@code enforceLimits} is {@code true}, otherwise logs warnings. If the system_property {@code es.enforce.bootstrap.checks} is set to {@code true} then the bootstrap checks will be enforced regardless of whether_or not the transport protocol is bound to a non-loopback interface.__@param context        the current node boostrap context_@param enforceLimits {@code true} if the checks should be enforced or otherwise warned_@param checks        the checks to execute;static void check(_        final BootstrapContext context,_        final boolean enforceLimits,_        final List<BootstrapCheck> checks) throws NodeValidationException {_        check(context, enforceLimits, checks, LogManager.getLogger(BootstrapChecks.class))__    };executes,the,provided,checks,and,fails,the,node,if,code,enforce,limits,is,code,true,otherwise,logs,warnings,if,the,system,property,code,es,enforce,bootstrap,checks,is,set,to,code,true,then,the,bootstrap,checks,will,be,enforced,regardless,of,whether,or,not,the,transport,protocol,is,bound,to,a,non,loopback,interface,param,context,the,current,node,boostrap,context,param,enforce,limits,code,true,if,the,checks,should,be,enforced,or,otherwise,warned,param,checks,the,checks,to,execute;static,void,check,final,bootstrap,context,context,final,boolean,enforce,limits,final,list,bootstrap,check,checks,throws,node,validation,exception,check,context,enforce,limits,checks,log,manager,get,logger,bootstrap,checks,class
BootstrapChecks -> static void check(         final BootstrapContext context,         final boolean enforceLimits,         final List<BootstrapCheck> checks) throws NodeValidationException;1547677152;Executes the provided checks and fails the node if {@code enforceLimits} is {@code true}, otherwise logs warnings. If the system_property {@code es.enforce.bootstrap.checks} is set to {@code true} then the bootstrap checks will be enforced regardless of whether_or not the transport protocol is bound to a non-loopback interface.__@param context        the current node boostrap context_@param enforceLimits {@code true} if the checks should be enforced or otherwise warned_@param checks        the checks to execute;static void check(_        final BootstrapContext context,_        final boolean enforceLimits,_        final List<BootstrapCheck> checks) throws NodeValidationException {_        check(context, enforceLimits, checks, LogManager.getLogger(BootstrapChecks.class))__    };executes,the,provided,checks,and,fails,the,node,if,code,enforce,limits,is,code,true,otherwise,logs,warnings,if,the,system,property,code,es,enforce,bootstrap,checks,is,set,to,code,true,then,the,bootstrap,checks,will,be,enforced,regardless,of,whether,or,not,the,transport,protocol,is,bound,to,a,non,loopback,interface,param,context,the,current,node,boostrap,context,param,enforce,limits,code,true,if,the,checks,should,be,enforced,or,otherwise,warned,param,checks,the,checks,to,execute;static,void,check,final,bootstrap,context,context,final,boolean,enforce,limits,final,list,bootstrap,check,checks,throws,node,validation,exception,check,context,enforce,limits,checks,log,manager,get,logger,bootstrap,checks,class
BootstrapChecks -> static void check(         final BootstrapContext context,         final boolean enforceLimits,         final List<BootstrapCheck> checks) throws NodeValidationException;1549356412;Executes the provided checks and fails the node if {@code enforceLimits} is {@code true}, otherwise logs warnings. If the system_property {@code es.enforce.bootstrap.checks} is set to {@code true} then the bootstrap checks will be enforced regardless of whether_or not the transport protocol is bound to a non-loopback interface.__@param context        the current node boostrap context_@param enforceLimits {@code true} if the checks should be enforced or otherwise warned_@param checks        the checks to execute;static void check(_        final BootstrapContext context,_        final boolean enforceLimits,_        final List<BootstrapCheck> checks) throws NodeValidationException {_        check(context, enforceLimits, checks, LogManager.getLogger(BootstrapChecks.class))__    };executes,the,provided,checks,and,fails,the,node,if,code,enforce,limits,is,code,true,otherwise,logs,warnings,if,the,system,property,code,es,enforce,bootstrap,checks,is,set,to,code,true,then,the,bootstrap,checks,will,be,enforced,regardless,of,whether,or,not,the,transport,protocol,is,bound,to,a,non,loopback,interface,param,context,the,current,node,boostrap,context,param,enforce,limits,code,true,if,the,checks,should,be,enforced,or,otherwise,warned,param,checks,the,checks,to,execute;static,void,check,final,bootstrap,context,context,final,boolean,enforce,limits,final,list,bootstrap,check,checks,throws,node,validation,exception,check,context,enforce,limits,checks,log,manager,get,logger,bootstrap,checks,class
BootstrapChecks -> static void check(         final BootstrapContext context,         final boolean enforceLimits,         final List<BootstrapCheck> checks) throws NodeValidationException;1549452878;Executes the provided checks and fails the node if {@code enforceLimits} is {@code true}, otherwise logs warnings. If the system_property {@code es.enforce.bootstrap.checks} is set to {@code true} then the bootstrap checks will be enforced regardless of whether_or not the transport protocol is bound to a non-loopback interface.__@param context        the current node boostrap context_@param enforceLimits {@code true} if the checks should be enforced or otherwise warned_@param checks        the checks to execute;static void check(_        final BootstrapContext context,_        final boolean enforceLimits,_        final List<BootstrapCheck> checks) throws NodeValidationException {_        check(context, enforceLimits, checks, LogManager.getLogger(BootstrapChecks.class))__    };executes,the,provided,checks,and,fails,the,node,if,code,enforce,limits,is,code,true,otherwise,logs,warnings,if,the,system,property,code,es,enforce,bootstrap,checks,is,set,to,code,true,then,the,bootstrap,checks,will,be,enforced,regardless,of,whether,or,not,the,transport,protocol,is,bound,to,a,non,loopback,interface,param,context,the,current,node,boostrap,context,param,enforce,limits,code,true,if,the,checks,should,be,enforced,or,otherwise,warned,param,checks,the,checks,to,execute;static,void,check,final,bootstrap,context,context,final,boolean,enforce,limits,final,list,bootstrap,check,checks,throws,node,validation,exception,check,context,enforce,limits,checks,log,manager,get,logger,bootstrap,checks,class
