commented;modifiers;parameterAmount;loc;comment;code
false;public;1;16;;@Override public Scorer scorer(LeafReaderContext context) throws IOException {     Sort segmentSort = context.reader().getMetaData().getSort().     if (segmentSort == null || Lucene.canEarlyTerminate(sort, segmentSort) == false) {         throw new IOException("search sort :[" + sort.getSort() + "] does not match the index sort:[" + segmentSort + "]").     }     final int afterDoc = after.doc - context.docBase.     TopComparator comparator = getTopComparator(fieldComparators, reverseMuls, context, afterDoc).     final int maxDoc = context.reader().maxDoc().     final int firstDoc = searchAfterDoc(comparator, 0, context.reader().maxDoc()).     if (firstDoc >= maxDoc) {         return null.     }     final DocIdSetIterator disi = new MinDocQuery.MinDocIterator(firstDoc, maxDoc).     return new ConstantScoreScorer(this, score(), scoreMode, disi). }
false;public;1;7;;@Override public boolean isCacheable(LeafReaderContext ctx) {     // candidate for caching     return false. }
false;public;3;29;;@Override public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {     return new ConstantScoreWeight(this, 1.0f) {          @Override         public Scorer scorer(LeafReaderContext context) throws IOException {             Sort segmentSort = context.reader().getMetaData().getSort().             if (segmentSort == null || Lucene.canEarlyTerminate(sort, segmentSort) == false) {                 throw new IOException("search sort :[" + sort.getSort() + "] does not match the index sort:[" + segmentSort + "]").             }             final int afterDoc = after.doc - context.docBase.             TopComparator comparator = getTopComparator(fieldComparators, reverseMuls, context, afterDoc).             final int maxDoc = context.reader().maxDoc().             final int firstDoc = searchAfterDoc(comparator, 0, context.reader().maxDoc()).             if (firstDoc >= maxDoc) {                 return null.             }             final DocIdSetIterator disi = new MinDocQuery.MinDocIterator(firstDoc, maxDoc).             return new ConstantScoreScorer(this, score(), scoreMode, disi).         }          @Override         public boolean isCacheable(LeafReaderContext ctx) {             // candidate for caching             return false.         }     }. }
false;public;1;4;;@Override public String toString(String field) {     return "SearchAfterSortedDocQuery(sort=" + sort + ", afterDoc=" + after.toString() + ")". }
false;public;1;5;;@Override public boolean equals(Object other) {     return sameClassAs(other) && equalsTo(getClass().cast(other)). }
false;private;1;6;;private boolean equalsTo(SearchAfterSortedDocQuery other) {     return sort.equals(other.sort) && after.doc == other.after.doc && Double.compare(after.score, other.after.score) == 0 && Arrays.equals(after.fields, other.after.fields). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(classHash(), sort, after.doc, after.score, Arrays.hashCode(after.fields)). }
false;;1;1;;boolean lessThanTop(int doc) throws IOException.
false;static;4;23;;static TopComparator getTopComparator(FieldComparator<?>[] fieldComparators, int[] reverseMuls, LeafReaderContext leafReaderContext, int topDoc) {     return doc -> {         // this should only be called a few time per segment (binary search).         for (int i = 0. i < fieldComparators.length. i++) {             LeafFieldComparator comparator = fieldComparators[i].getLeafComparator(leafReaderContext).             int value = reverseMuls[i] * comparator.compareTop(doc).             if (value != 0) {                 return value < 0.             }         }         if (doc <= topDoc) {             return false.         }         return true.     }. }
true;static;3;14;/**  * Returns the first doc id greater than the provided <code>after</code> doc.  */ ;/**  * Returns the first doc id greater than the provided <code>after</code> doc.  */ static int searchAfterDoc(TopComparator comparator, int from, int to) throws IOException {     int low = from.     int high = to - 1.     while (low <= high) {         int mid = (low + high) >>> 1.         if (comparator.lessThanTop(mid)) {             high = mid - 1.         } else {             low = mid + 1.         }     }     return low. }
