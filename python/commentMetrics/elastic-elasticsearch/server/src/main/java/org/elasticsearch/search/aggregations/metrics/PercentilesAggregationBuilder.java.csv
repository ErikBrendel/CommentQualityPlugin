commented;modifiers;parameterAmount;loc;comment;code
false;public,static;2;16;;public static AggregationBuilder parse(String aggregationName, XContentParser parser) throws IOException {     InternalBuilder internal = PARSER.parse(parser, new InternalBuilder(aggregationName), null).     // we need to return a PercentilesAggregationBuilder for equality checks to work     PercentilesAggregationBuilder returnedAgg = new PercentilesAggregationBuilder(internal.name).     setIfNotNull(returnedAgg::valueType, internal.valueType()).     setIfNotNull(returnedAgg::format, internal.format()).     setIfNotNull(returnedAgg::missing, internal.missing()).     setIfNotNull(returnedAgg::field, internal.field()).     setIfNotNull(returnedAgg::script, internal.script()).     setIfNotNull(returnedAgg::method, internal.method()).     setIfNotNull(returnedAgg::percentiles, internal.percentiles()).     returnedAgg.keyed(internal.keyed()).     returnedAgg.compression(internal.compression()).     returnedAgg.numberOfSignificantValueDigits(internal.numberOfSignificantValueDigits()).     return returnedAgg. }
false;private,static;2;5;;private static <T> void setIfNotNull(Consumer<T> consumer, T value) {     if (value != null) {         consumer.accept(value).     } }
false;protected;2;4;;@Override protected AggregationBuilder shallowCopy(Builder factoriesBuilder, Map<String, Object> metaData) {     return new PercentilesAggregationBuilder(this, factoriesBuilder, metaData). }
false;protected;1;8;;@Override protected void innerWriteTo(StreamOutput out) throws IOException {     out.writeDoubleArray(percents).     out.writeBoolean(keyed).     out.writeVInt(numberOfSignificantValueDigits).     out.writeDouble(compression).     method.writeTo(out). }
true;public;1;12;/**  * Set the values to compute percentiles from.  */ ;/**  * Set the values to compute percentiles from.  */ public PercentilesAggregationBuilder percentiles(double... percents) {     if (percents == null) {         throw new IllegalArgumentException("[percents] must not be null: [" + name + "]").     }     if (percents.length == 0) {         throw new IllegalArgumentException("[percents] must not be empty: [" + name + "]").     }     double[] sortedPercents = Arrays.copyOf(percents, percents.length).     Arrays.sort(sortedPercents).     this.percents = sortedPercents.     return this. }
true;public;0;3;/**  * Get the values to compute percentiles from.  */ ;/**  * Get the values to compute percentiles from.  */ public double[] percentiles() {     return percents. }
true;public;1;4;/**  * Set whether the XContent response should be keyed  */ ;/**  * Set whether the XContent response should be keyed  */ public PercentilesAggregationBuilder keyed(boolean keyed) {     this.keyed = keyed.     return this. }
true;public;0;3;/**  * Get whether the XContent response should be keyed  */ ;/**  * Get whether the XContent response should be keyed  */ public boolean keyed() {     return keyed. }
true;public;1;7;/**  * Expert: set the number of significant digits in the values. Only relevant  * when using {@link PercentilesMethod#HDR}.  */ ;/**  * Expert: set the number of significant digits in the values. Only relevant  * when using {@link PercentilesMethod#HDR}.  */ public PercentilesAggregationBuilder numberOfSignificantValueDigits(int numberOfSignificantValueDigits) {     if (numberOfSignificantValueDigits < 0 || numberOfSignificantValueDigits > 5) {         throw new IllegalArgumentException("[numberOfSignificantValueDigits] must be between 0 and 5: [" + name + "]").     }     this.numberOfSignificantValueDigits = numberOfSignificantValueDigits.     return this. }
true;public;0;3;/**  * Expert: get the number of significant digits in the values. Only relevant  * when using {@link PercentilesMethod#HDR}.  */ ;/**  * Expert: get the number of significant digits in the values. Only relevant  * when using {@link PercentilesMethod#HDR}.  */ public int numberOfSignificantValueDigits() {     return numberOfSignificantValueDigits. }
true;public;1;8;/**  * Expert: set the compression. Higher values improve accuracy but also  * memory usage. Only relevant when using {@link PercentilesMethod#TDIGEST}.  */ ;/**  * Expert: set the compression. Higher values improve accuracy but also  * memory usage. Only relevant when using {@link PercentilesMethod#TDIGEST}.  */ public PercentilesAggregationBuilder compression(double compression) {     if (compression < 0.0) {         throw new IllegalArgumentException("[compression] must be greater than or equal to 0. Found [" + compression + "] in [" + name + "]").     }     this.compression = compression.     return this. }
true;public;0;3;/**  * Expert: get the compression. Higher values improve accuracy but also  * memory usage. Only relevant when using {@link PercentilesMethod#TDIGEST}.  */ ;/**  * Expert: get the compression. Higher values improve accuracy but also  * memory usage. Only relevant when using {@link PercentilesMethod#TDIGEST}.  */ public double compression() {     return compression. }
false;public;1;7;;public PercentilesAggregationBuilder method(PercentilesMethod method) {     if (method == null) {         throw new IllegalArgumentException("[method] must not be null: [" + name + "]").     }     this.method = method.     return this. }
false;public;0;3;;public PercentilesMethod method() {     return method. }
false;protected;4;14;;@Override protected ValuesSourceAggregatorFactory<Numeric, ?> innerBuild(SearchContext context, ValuesSourceConfig<Numeric> config, AggregatorFactory<?> parent, Builder subFactoriesBuilder) throws IOException {     switch(method) {         case TDIGEST:             return new TDigestPercentilesAggregatorFactory(name, config, percents, compression, keyed, context, parent, subFactoriesBuilder, metaData).         case HDR:             return new HDRPercentilesAggregatorFactory(name, config, percents, numberOfSignificantValueDigits, keyed, context, parent, subFactoriesBuilder, metaData).         default:             throw new IllegalStateException("Illegal method [" + method + "]").     } }
false;protected;2;13;;@Override protected XContentBuilder doXContentBody(XContentBuilder builder, Params params) throws IOException {     builder.array(PERCENTS_FIELD.getPreferredName(), percents).     builder.field(KEYED_FIELD.getPreferredName(), keyed).     builder.startObject(method.toString()).     if (method == PercentilesMethod.TDIGEST) {         builder.field(COMPRESSION_FIELD.getPreferredName(), compression).     } else {         builder.field(NUMBER_SIGNIFICANT_DIGITS_FIELD.getPreferredName(), numberOfSignificantValueDigits).     }     builder.endObject().     return builder. }
false;protected;1;22;;@Override protected boolean innerEquals(Object obj) {     PercentilesAggregationBuilder other = (PercentilesAggregationBuilder) obj.     if (!Objects.equals(method, other.method)) {         return false.     }     boolean equalSettings = false.     switch(method) {         case HDR:             equalSettings = Objects.equals(numberOfSignificantValueDigits, other.numberOfSignificantValueDigits).             break.         case TDIGEST:             equalSettings = Objects.equals(compression, other.compression).             break.         default:             throw new IllegalStateException("Illegal method [" + method.toString() + "]").     }     return equalSettings && Objects.deepEquals(percents, other.percents) && Objects.equals(keyed, other.keyed) && Objects.equals(method, other.method). }
false;protected;0;11;;@Override protected int innerHashCode() {     switch(method) {         case HDR:             return Objects.hash(Arrays.hashCode(percents), keyed, numberOfSignificantValueDigits, method).         case TDIGEST:             return Objects.hash(Arrays.hashCode(percents), keyed, compression, method).         default:             throw new IllegalStateException("Illegal method [" + method.toString() + "]").     } }
false;public;0;4;;@Override public String getType() {     return NAME. }
false;public;1;10;;@Override public InternalBuilder method(PercentilesMethod method) {     if (setOnce == false) {         super.method(method).         setOnce = true.         return this.     } else {         throw new IllegalStateException("Only one percentiles method should be declared.").     } }
