commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(classHash(), minDoc, readerId). }
false;public;1;8;;@Override public boolean equals(Object obj) {     if (sameClassAs(obj) == false) {         return false.     }     MinDocQuery that = (MinDocQuery) obj.     return minDoc == that.minDoc && Objects.equals(readerId, that.readerId). }
false;public;1;7;;@Override public Query rewrite(IndexReader reader) throws IOException {     if (Objects.equals(reader.getContext().id(), readerId) == false) {         return new MinDocQuery(minDoc, reader.getContext().id()).     }     return this. }
false;public;1;10;;@Override public Scorer scorer(LeafReaderContext context) throws IOException {     final int maxDoc = context.reader().maxDoc().     if (context.docBase + maxDoc <= minDoc) {         return null.     }     final int segmentMinDoc = Math.max(0, minDoc - context.docBase).     final DocIdSetIterator disi = new MinDocIterator(segmentMinDoc, maxDoc).     return new ConstantScoreScorer(this, score(), scoreMode, disi). }
false;public;1;8;;@Override public boolean isCacheable(LeafReaderContext ctx) {     // makes it a bad candidate for per-segment caching.     return false. }
false;public;3;29;;@Override public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {     if (readerId == null) {         throw new IllegalStateException("Rewrite first").     } else if (Objects.equals(searcher.getIndexReader().getContext().id(), readerId) == false) {         throw new IllegalStateException("Executing against a different reader than the query has been rewritten against").     }     return new ConstantScoreWeight(this, boost) {          @Override         public Scorer scorer(LeafReaderContext context) throws IOException {             final int maxDoc = context.reader().maxDoc().             if (context.docBase + maxDoc <= minDoc) {                 return null.             }             final int segmentMinDoc = Math.max(0, minDoc - context.docBase).             final DocIdSetIterator disi = new MinDocIterator(segmentMinDoc, maxDoc).             return new ConstantScoreScorer(this, score(), scoreMode, disi).         }          @Override         public boolean isCacheable(LeafReaderContext ctx) {             // makes it a bad candidate for per-segment caching.             return false.         }     }. }
false;public;0;4;;@Override public int docID() {     return doc. }
false;public;0;4;;@Override public int nextDoc() throws IOException {     return advance(doc + 1). }
false;public;1;14;;@Override public int advance(int target) throws IOException {     assert target > doc.     if (doc == -1) {         // skip directly to minDoc         doc = Math.max(target, segmentMinDoc).     } else {         doc = target.     }     if (doc >= maxDoc) {         doc = NO_MORE_DOCS.     }     return doc. }
false;public;0;4;;@Override public long cost() {     return maxDoc - segmentMinDoc. }
false;public;1;4;;@Override public String toString(String field) {     return "MinDocQuery(minDoc=" + minDoc + ")". }
