# id;timestamp;commentText;codeText;commentWords;codeWords
MetaDataMappingService -> public void refreshMapping(final String index, final String indexUUID);1524684173;Refreshes mappings if they are not the same between original and parsed version;public void refreshMapping(final String index, final String indexUUID) {_        final RefreshTask refreshTask = new RefreshTask(index, indexUUID)__        clusterService.submitStateUpdateTask("refresh-mapping",_            refreshTask,_            ClusterStateTaskConfig.build(Priority.HIGH),_            refreshExecutor,_                (source, e) -> logger.warn(() -> new ParameterizedMessage("failure during [{}]", source), e)_        )__    };refreshes,mappings,if,they,are,not,the,same,between,original,and,parsed,version;public,void,refresh,mapping,final,string,index,final,string,index,uuid,final,refresh,task,refresh,task,new,refresh,task,index,index,uuid,cluster,service,submit,state,update,task,refresh,mapping,refresh,task,cluster,state,task,config,build,priority,high,refresh,executor,source,e,logger,warn,new,parameterized,message,failure,during,source,e
MetaDataMappingService -> public void refreshMapping(final String index, final String indexUUID);1527096592;Refreshes mappings if they are not the same between original and parsed version;public void refreshMapping(final String index, final String indexUUID) {_        final RefreshTask refreshTask = new RefreshTask(index, indexUUID)__        clusterService.submitStateUpdateTask("refresh-mapping",_            refreshTask,_            ClusterStateTaskConfig.build(Priority.HIGH),_            refreshExecutor,_                (source, e) -> logger.warn(() -> new ParameterizedMessage("failure during [{}]", source), e)_        )__    };refreshes,mappings,if,they,are,not,the,same,between,original,and,parsed,version;public,void,refresh,mapping,final,string,index,final,string,index,uuid,final,refresh,task,refresh,task,new,refresh,task,index,index,uuid,cluster,service,submit,state,update,task,refresh,mapping,refresh,task,cluster,state,task,config,build,priority,high,refresh,executor,source,e,logger,warn,new,parameterized,message,failure,during,source,e
MetaDataMappingService -> public void refreshMapping(final String index, final String indexUUID);1535405719;Refreshes mappings if they are not the same between original and parsed version;public void refreshMapping(final String index, final String indexUUID) {_        final RefreshTask refreshTask = new RefreshTask(index, indexUUID)__        clusterService.submitStateUpdateTask("refresh-mapping",_            refreshTask,_            ClusterStateTaskConfig.build(Priority.HIGH),_            refreshExecutor,_                (source, e) -> logger.warn(() -> new ParameterizedMessage("failure during [{}]", source), e)_        )__    };refreshes,mappings,if,they,are,not,the,same,between,original,and,parsed,version;public,void,refresh,mapping,final,string,index,final,string,index,uuid,final,refresh,task,refresh,task,new,refresh,task,index,index,uuid,cluster,service,submit,state,update,task,refresh,mapping,refresh,task,cluster,state,task,config,build,priority,high,refresh,executor,source,e,logger,warn,new,parameterized,message,failure,during,source,e
MetaDataMappingService -> public void refreshMapping(final String index, final String indexUUID);1540847035;Refreshes mappings if they are not the same between original and parsed version;public void refreshMapping(final String index, final String indexUUID) {_        final RefreshTask refreshTask = new RefreshTask(index, indexUUID)__        clusterService.submitStateUpdateTask("refresh-mapping",_            refreshTask,_            ClusterStateTaskConfig.build(Priority.HIGH),_            refreshExecutor,_                (source, e) -> logger.warn(() -> new ParameterizedMessage("failure during [{}]", source), e)_        )__    };refreshes,mappings,if,they,are,not,the,same,between,original,and,parsed,version;public,void,refresh,mapping,final,string,index,final,string,index,uuid,final,refresh,task,refresh,task,new,refresh,task,index,index,uuid,cluster,service,submit,state,update,task,refresh,mapping,refresh,task,cluster,state,task,config,build,priority,high,refresh,executor,source,e,logger,warn,new,parameterized,message,failure,during,source,e
MetaDataMappingService -> public void refreshMapping(final String index, final String indexUUID);1541092382;Refreshes mappings if they are not the same between original and parsed version;public void refreshMapping(final String index, final String indexUUID) {_        final RefreshTask refreshTask = new RefreshTask(index, indexUUID)__        clusterService.submitStateUpdateTask("refresh-mapping",_            refreshTask,_            ClusterStateTaskConfig.build(Priority.HIGH),_            refreshExecutor,_                (source, e) -> logger.warn(() -> new ParameterizedMessage("failure during [{}]", source), e)_        )__    };refreshes,mappings,if,they,are,not,the,same,between,original,and,parsed,version;public,void,refresh,mapping,final,string,index,final,string,index,uuid,final,refresh,task,refresh,task,new,refresh,task,index,index,uuid,cluster,service,submit,state,update,task,refresh,mapping,refresh,task,cluster,state,task,config,build,priority,high,refresh,executor,source,e,logger,warn,new,parameterized,message,failure,during,source,e
MetaDataMappingService -> public void refreshMapping(final String index, final String indexUUID);1542402632;Refreshes mappings if they are not the same between original and parsed version;public void refreshMapping(final String index, final String indexUUID) {_        final RefreshTask refreshTask = new RefreshTask(index, indexUUID)__        clusterService.submitStateUpdateTask("refresh-mapping",_            refreshTask,_            ClusterStateTaskConfig.build(Priority.HIGH),_            refreshExecutor,_                (source, e) -> logger.warn(() -> new ParameterizedMessage("failure during [{}]", source), e)_        )__    };refreshes,mappings,if,they,are,not,the,same,between,original,and,parsed,version;public,void,refresh,mapping,final,string,index,final,string,index,uuid,final,refresh,task,refresh,task,new,refresh,task,index,index,uuid,cluster,service,submit,state,update,task,refresh,mapping,refresh,task,cluster,state,task,config,build,priority,high,refresh,executor,source,e,logger,warn,new,parameterized,message,failure,during,source,e
MetaDataMappingService -> public void refreshMapping(final String index, final String indexUUID);1543947737;Refreshes mappings if they are not the same between original and parsed version;public void refreshMapping(final String index, final String indexUUID) {_        final RefreshTask refreshTask = new RefreshTask(index, indexUUID)__        clusterService.submitStateUpdateTask("refresh-mapping",_            refreshTask,_            ClusterStateTaskConfig.build(Priority.HIGH),_            refreshExecutor,_                (source, e) -> logger.warn(() -> new ParameterizedMessage("failure during [{}]", source), e)_        )__    };refreshes,mappings,if,they,are,not,the,same,between,original,and,parsed,version;public,void,refresh,mapping,final,string,index,final,string,index,uuid,final,refresh,task,refresh,task,new,refresh,task,index,index,uuid,cluster,service,submit,state,update,task,refresh,mapping,refresh,task,cluster,state,task,config,build,priority,high,refresh,executor,source,e,logger,warn,new,parameterized,message,failure,during,source,e
MetaDataMappingService -> public void refreshMapping(final String index, final String indexUUID);1547566367;Refreshes mappings if they are not the same between original and parsed version;public void refreshMapping(final String index, final String indexUUID) {_        final RefreshTask refreshTask = new RefreshTask(index, indexUUID)__        clusterService.submitStateUpdateTask("refresh-mapping",_            refreshTask,_            ClusterStateTaskConfig.build(Priority.HIGH),_            refreshExecutor,_                (source, e) -> logger.warn(() -> new ParameterizedMessage("failure during [{}]", source), e)_        )__    };refreshes,mappings,if,they,are,not,the,same,between,original,and,parsed,version;public,void,refresh,mapping,final,string,index,final,string,index,uuid,final,refresh,task,refresh,task,new,refresh,task,index,index,uuid,cluster,service,submit,state,update,task,refresh,mapping,refresh,task,cluster,state,task,config,build,priority,high,refresh,executor,source,e,logger,warn,new,parameterized,message,failure,during,source,e
MetaDataMappingService -> public void refreshMapping(final String index, final String indexUUID);1548939462;Refreshes mappings if they are not the same between original and parsed version;public void refreshMapping(final String index, final String indexUUID) {_        final RefreshTask refreshTask = new RefreshTask(index, indexUUID)__        clusterService.submitStateUpdateTask("refresh-mapping",_            refreshTask,_            ClusterStateTaskConfig.build(Priority.HIGH),_            refreshExecutor,_                (source, e) -> logger.warn(() -> new ParameterizedMessage("failure during [{}]", source), e)_        )__    };refreshes,mappings,if,they,are,not,the,same,between,original,and,parsed,version;public,void,refresh,mapping,final,string,index,final,string,index,uuid,final,refresh,task,refresh,task,new,refresh,task,index,index,uuid,cluster,service,submit,state,update,task,refresh,mapping,refresh,task,cluster,state,task,config,build,priority,high,refresh,executor,source,e,logger,warn,new,parameterized,message,failure,during,source,e
MetaDataMappingService -> public void refreshMapping(final String index, final String indexUUID);1549392752;Refreshes mappings if they are not the same between original and parsed version;public void refreshMapping(final String index, final String indexUUID) {_        final RefreshTask refreshTask = new RefreshTask(index, indexUUID)__        clusterService.submitStateUpdateTask("refresh-mapping",_            refreshTask,_            ClusterStateTaskConfig.build(Priority.HIGH),_            refreshExecutor,_                (source, e) -> logger.warn(() -> new ParameterizedMessage("failure during [{}]", source), e)_        )__    };refreshes,mappings,if,they,are,not,the,same,between,original,and,parsed,version;public,void,refresh,mapping,final,string,index,final,string,index,uuid,final,refresh,task,refresh,task,new,refresh,task,index,index,uuid,cluster,service,submit,state,update,task,refresh,mapping,refresh,task,cluster,state,task,config,build,priority,high,refresh,executor,source,e,logger,warn,new,parameterized,message,failure,during,source,e
MetaDataMappingService -> ClusterState executeRefresh(final ClusterState currentState, final List<RefreshTask> allTasks) throws Exception;1524684173;Batch method to apply all the queued refresh operations. The idea is to try and batch as much_as possible so we won't create the same index all the time for example for the updates on the same mapping_and generate a single cluster change event out of all of those.;ClusterState executeRefresh(final ClusterState currentState, final List<RefreshTask> allTasks) throws Exception {_        _        _        Map<String, List<RefreshTask>> tasksPerIndex = new HashMap<>()__        for (RefreshTask task : allTasks) {_            if (task.index == null) {_                logger.debug("ignoring a mapping task of type [{}] with a null index.", task)__            }_            tasksPerIndex.computeIfAbsent(task.index, k -> new ArrayList<>()).add(task)__        }__        boolean dirty = false__        MetaData.Builder mdBuilder = MetaData.builder(currentState.metaData())___        for (Map.Entry<String, List<RefreshTask>> entry : tasksPerIndex.entrySet()) {_            IndexMetaData indexMetaData = mdBuilder.get(entry.getKey())__            if (indexMetaData == null) {_                _                logger.debug("[{}] ignoring tasks - index meta data doesn't exist", entry.getKey())__                continue__            }_            final Index index = indexMetaData.getIndex()__            _            _            List<RefreshTask> allIndexTasks = entry.getValue()__            boolean hasTaskWithRightUUID = false__            for (RefreshTask task : allIndexTasks) {_                if (indexMetaData.isSameUUID(task.indexUUID)) {_                    hasTaskWithRightUUID = true__                } else {_                    logger.debug("{} ignoring task [{}] - index meta data doesn't match task uuid", index, task)__                }_            }_            if (hasTaskWithRightUUID == false) {_                continue__            }__            _            boolean removeIndex = false__            IndexService indexService = indicesService.indexService(indexMetaData.getIndex())__            if (indexService == null) {_                _                indexService = indicesService.createIndex(indexMetaData, Collections.emptyList())__                removeIndex = true__                indexService.mapperService().merge(indexMetaData, MergeReason.MAPPING_RECOVERY)__            }__            IndexMetaData.Builder builder = IndexMetaData.builder(indexMetaData)__            try {_                boolean indexDirty = refreshIndexMapping(indexService, builder)__                if (indexDirty) {_                    mdBuilder.put(builder)__                    dirty = true__                }_            } finally {_                if (removeIndex) {_                    indicesService.removeIndex(index, NO_LONGER_ASSIGNED, "created for mapping processing")__                }_            }_        }__        if (!dirty) {_            return currentState__        }_        return ClusterState.builder(currentState).metaData(mdBuilder).build()__    };batch,method,to,apply,all,the,queued,refresh,operations,the,idea,is,to,try,and,batch,as,much,as,possible,so,we,won,t,create,the,same,index,all,the,time,for,example,for,the,updates,on,the,same,mapping,and,generate,a,single,cluster,change,event,out,of,all,of,those;cluster,state,execute,refresh,final,cluster,state,current,state,final,list,refresh,task,all,tasks,throws,exception,map,string,list,refresh,task,tasks,per,index,new,hash,map,for,refresh,task,task,all,tasks,if,task,index,null,logger,debug,ignoring,a,mapping,task,of,type,with,a,null,index,task,tasks,per,index,compute,if,absent,task,index,k,new,array,list,add,task,boolean,dirty,false,meta,data,builder,md,builder,meta,data,builder,current,state,meta,data,for,map,entry,string,list,refresh,task,entry,tasks,per,index,entry,set,index,meta,data,index,meta,data,md,builder,get,entry,get,key,if,index,meta,data,null,logger,debug,ignoring,tasks,index,meta,data,doesn,t,exist,entry,get,key,continue,final,index,index,index,meta,data,get,index,list,refresh,task,all,index,tasks,entry,get,value,boolean,has,task,with,right,uuid,false,for,refresh,task,task,all,index,tasks,if,index,meta,data,is,same,uuid,task,index,uuid,has,task,with,right,uuid,true,else,logger,debug,ignoring,task,index,meta,data,doesn,t,match,task,uuid,index,task,if,has,task,with,right,uuid,false,continue,boolean,remove,index,false,index,service,index,service,indices,service,index,service,index,meta,data,get,index,if,index,service,null,index,service,indices,service,create,index,index,meta,data,collections,empty,list,remove,index,true,index,service,mapper,service,merge,index,meta,data,merge,reason,index,meta,data,builder,builder,index,meta,data,builder,index,meta,data,try,boolean,index,dirty,refresh,index,mapping,index,service,builder,if,index,dirty,md,builder,put,builder,dirty,true,finally,if,remove,index,indices,service,remove,index,index,created,for,mapping,processing,if,dirty,return,current,state,return,cluster,state,builder,current,state,meta,data,md,builder,build
MetaDataMappingService -> ClusterState executeRefresh(final ClusterState currentState, final List<RefreshTask> allTasks) throws Exception;1527096592;Batch method to apply all the queued refresh operations. The idea is to try and batch as much_as possible so we won't create the same index all the time for example for the updates on the same mapping_and generate a single cluster change event out of all of those.;ClusterState executeRefresh(final ClusterState currentState, final List<RefreshTask> allTasks) throws Exception {_        _        _        Map<String, List<RefreshTask>> tasksPerIndex = new HashMap<>()__        for (RefreshTask task : allTasks) {_            if (task.index == null) {_                logger.debug("ignoring a mapping task of type [{}] with a null index.", task)__            }_            tasksPerIndex.computeIfAbsent(task.index, k -> new ArrayList<>()).add(task)__        }__        boolean dirty = false__        MetaData.Builder mdBuilder = MetaData.builder(currentState.metaData())___        for (Map.Entry<String, List<RefreshTask>> entry : tasksPerIndex.entrySet()) {_            IndexMetaData indexMetaData = mdBuilder.get(entry.getKey())__            if (indexMetaData == null) {_                _                logger.debug("[{}] ignoring tasks - index meta data doesn't exist", entry.getKey())__                continue__            }_            final Index index = indexMetaData.getIndex()__            _            _            List<RefreshTask> allIndexTasks = entry.getValue()__            boolean hasTaskWithRightUUID = false__            for (RefreshTask task : allIndexTasks) {_                if (indexMetaData.isSameUUID(task.indexUUID)) {_                    hasTaskWithRightUUID = true__                } else {_                    logger.debug("{} ignoring task [{}] - index meta data doesn't match task uuid", index, task)__                }_            }_            if (hasTaskWithRightUUID == false) {_                continue__            }__            _            boolean removeIndex = false__            IndexService indexService = indicesService.indexService(indexMetaData.getIndex())__            if (indexService == null) {_                _                indexService = indicesService.createIndex(indexMetaData, Collections.emptyList())__                removeIndex = true__                indexService.mapperService().merge(indexMetaData, MergeReason.MAPPING_RECOVERY)__            }__            IndexMetaData.Builder builder = IndexMetaData.builder(indexMetaData)__            try {_                boolean indexDirty = refreshIndexMapping(indexService, builder)__                if (indexDirty) {_                    mdBuilder.put(builder)__                    dirty = true__                }_            } finally {_                if (removeIndex) {_                    indicesService.removeIndex(index, NO_LONGER_ASSIGNED, "created for mapping processing")__                }_            }_        }__        if (!dirty) {_            return currentState__        }_        return ClusterState.builder(currentState).metaData(mdBuilder).build()__    };batch,method,to,apply,all,the,queued,refresh,operations,the,idea,is,to,try,and,batch,as,much,as,possible,so,we,won,t,create,the,same,index,all,the,time,for,example,for,the,updates,on,the,same,mapping,and,generate,a,single,cluster,change,event,out,of,all,of,those;cluster,state,execute,refresh,final,cluster,state,current,state,final,list,refresh,task,all,tasks,throws,exception,map,string,list,refresh,task,tasks,per,index,new,hash,map,for,refresh,task,task,all,tasks,if,task,index,null,logger,debug,ignoring,a,mapping,task,of,type,with,a,null,index,task,tasks,per,index,compute,if,absent,task,index,k,new,array,list,add,task,boolean,dirty,false,meta,data,builder,md,builder,meta,data,builder,current,state,meta,data,for,map,entry,string,list,refresh,task,entry,tasks,per,index,entry,set,index,meta,data,index,meta,data,md,builder,get,entry,get,key,if,index,meta,data,null,logger,debug,ignoring,tasks,index,meta,data,doesn,t,exist,entry,get,key,continue,final,index,index,index,meta,data,get,index,list,refresh,task,all,index,tasks,entry,get,value,boolean,has,task,with,right,uuid,false,for,refresh,task,task,all,index,tasks,if,index,meta,data,is,same,uuid,task,index,uuid,has,task,with,right,uuid,true,else,logger,debug,ignoring,task,index,meta,data,doesn,t,match,task,uuid,index,task,if,has,task,with,right,uuid,false,continue,boolean,remove,index,false,index,service,index,service,indices,service,index,service,index,meta,data,get,index,if,index,service,null,index,service,indices,service,create,index,index,meta,data,collections,empty,list,remove,index,true,index,service,mapper,service,merge,index,meta,data,merge,reason,index,meta,data,builder,builder,index,meta,data,builder,index,meta,data,try,boolean,index,dirty,refresh,index,mapping,index,service,builder,if,index,dirty,md,builder,put,builder,dirty,true,finally,if,remove,index,indices,service,remove,index,index,created,for,mapping,processing,if,dirty,return,current,state,return,cluster,state,builder,current,state,meta,data,md,builder,build
MetaDataMappingService -> ClusterState executeRefresh(final ClusterState currentState, final List<RefreshTask> allTasks) throws Exception;1535405719;Batch method to apply all the queued refresh operations. The idea is to try and batch as much_as possible so we won't create the same index all the time for example for the updates on the same mapping_and generate a single cluster change event out of all of those.;ClusterState executeRefresh(final ClusterState currentState, final List<RefreshTask> allTasks) throws Exception {_        _        _        Map<String, List<RefreshTask>> tasksPerIndex = new HashMap<>()__        for (RefreshTask task : allTasks) {_            if (task.index == null) {_                logger.debug("ignoring a mapping task of type [{}] with a null index.", task)__            }_            tasksPerIndex.computeIfAbsent(task.index, k -> new ArrayList<>()).add(task)__        }__        boolean dirty = false__        MetaData.Builder mdBuilder = MetaData.builder(currentState.metaData())___        for (Map.Entry<String, List<RefreshTask>> entry : tasksPerIndex.entrySet()) {_            IndexMetaData indexMetaData = mdBuilder.get(entry.getKey())__            if (indexMetaData == null) {_                _                logger.debug("[{}] ignoring tasks - index meta data doesn't exist", entry.getKey())__                continue__            }_            final Index index = indexMetaData.getIndex()__            _            _            List<RefreshTask> allIndexTasks = entry.getValue()__            boolean hasTaskWithRightUUID = false__            for (RefreshTask task : allIndexTasks) {_                if (indexMetaData.isSameUUID(task.indexUUID)) {_                    hasTaskWithRightUUID = true__                } else {_                    logger.debug("{} ignoring task [{}] - index meta data doesn't match task uuid", index, task)__                }_            }_            if (hasTaskWithRightUUID == false) {_                continue__            }__            _            boolean removeIndex = false__            IndexService indexService = indicesService.indexService(indexMetaData.getIndex())__            if (indexService == null) {_                _                indexService = indicesService.createIndex(indexMetaData, Collections.emptyList())__                removeIndex = true__                indexService.mapperService().merge(indexMetaData, MergeReason.MAPPING_RECOVERY)__            }__            IndexMetaData.Builder builder = IndexMetaData.builder(indexMetaData)__            try {_                boolean indexDirty = refreshIndexMapping(indexService, builder)__                if (indexDirty) {_                    mdBuilder.put(builder)__                    dirty = true__                }_            } finally {_                if (removeIndex) {_                    indicesService.removeIndex(index, NO_LONGER_ASSIGNED, "created for mapping processing")__                }_            }_        }__        if (!dirty) {_            return currentState__        }_        return ClusterState.builder(currentState).metaData(mdBuilder).build()__    };batch,method,to,apply,all,the,queued,refresh,operations,the,idea,is,to,try,and,batch,as,much,as,possible,so,we,won,t,create,the,same,index,all,the,time,for,example,for,the,updates,on,the,same,mapping,and,generate,a,single,cluster,change,event,out,of,all,of,those;cluster,state,execute,refresh,final,cluster,state,current,state,final,list,refresh,task,all,tasks,throws,exception,map,string,list,refresh,task,tasks,per,index,new,hash,map,for,refresh,task,task,all,tasks,if,task,index,null,logger,debug,ignoring,a,mapping,task,of,type,with,a,null,index,task,tasks,per,index,compute,if,absent,task,index,k,new,array,list,add,task,boolean,dirty,false,meta,data,builder,md,builder,meta,data,builder,current,state,meta,data,for,map,entry,string,list,refresh,task,entry,tasks,per,index,entry,set,index,meta,data,index,meta,data,md,builder,get,entry,get,key,if,index,meta,data,null,logger,debug,ignoring,tasks,index,meta,data,doesn,t,exist,entry,get,key,continue,final,index,index,index,meta,data,get,index,list,refresh,task,all,index,tasks,entry,get,value,boolean,has,task,with,right,uuid,false,for,refresh,task,task,all,index,tasks,if,index,meta,data,is,same,uuid,task,index,uuid,has,task,with,right,uuid,true,else,logger,debug,ignoring,task,index,meta,data,doesn,t,match,task,uuid,index,task,if,has,task,with,right,uuid,false,continue,boolean,remove,index,false,index,service,index,service,indices,service,index,service,index,meta,data,get,index,if,index,service,null,index,service,indices,service,create,index,index,meta,data,collections,empty,list,remove,index,true,index,service,mapper,service,merge,index,meta,data,merge,reason,index,meta,data,builder,builder,index,meta,data,builder,index,meta,data,try,boolean,index,dirty,refresh,index,mapping,index,service,builder,if,index,dirty,md,builder,put,builder,dirty,true,finally,if,remove,index,indices,service,remove,index,index,created,for,mapping,processing,if,dirty,return,current,state,return,cluster,state,builder,current,state,meta,data,md,builder,build
MetaDataMappingService -> ClusterState executeRefresh(final ClusterState currentState, final List<RefreshTask> allTasks) throws Exception;1540847035;Batch method to apply all the queued refresh operations. The idea is to try and batch as much_as possible so we won't create the same index all the time for example for the updates on the same mapping_and generate a single cluster change event out of all of those.;ClusterState executeRefresh(final ClusterState currentState, final List<RefreshTask> allTasks) throws Exception {_        _        _        Map<String, List<RefreshTask>> tasksPerIndex = new HashMap<>()__        for (RefreshTask task : allTasks) {_            if (task.index == null) {_                logger.debug("ignoring a mapping task of type [{}] with a null index.", task)__            }_            tasksPerIndex.computeIfAbsent(task.index, k -> new ArrayList<>()).add(task)__        }__        boolean dirty = false__        MetaData.Builder mdBuilder = MetaData.builder(currentState.metaData())___        for (Map.Entry<String, List<RefreshTask>> entry : tasksPerIndex.entrySet()) {_            IndexMetaData indexMetaData = mdBuilder.get(entry.getKey())__            if (indexMetaData == null) {_                _                logger.debug("[{}] ignoring tasks - index meta data doesn't exist", entry.getKey())__                continue__            }_            final Index index = indexMetaData.getIndex()__            _            _            List<RefreshTask> allIndexTasks = entry.getValue()__            boolean hasTaskWithRightUUID = false__            for (RefreshTask task : allIndexTasks) {_                if (indexMetaData.isSameUUID(task.indexUUID)) {_                    hasTaskWithRightUUID = true__                } else {_                    logger.debug("{} ignoring task [{}] - index meta data doesn't match task uuid", index, task)__                }_            }_            if (hasTaskWithRightUUID == false) {_                continue__            }__            _            boolean removeIndex = false__            IndexService indexService = indicesService.indexService(indexMetaData.getIndex())__            if (indexService == null) {_                _                indexService = indicesService.createIndex(indexMetaData, Collections.emptyList())__                removeIndex = true__                indexService.mapperService().merge(indexMetaData, MergeReason.MAPPING_RECOVERY)__            }__            IndexMetaData.Builder builder = IndexMetaData.builder(indexMetaData)__            try {_                boolean indexDirty = refreshIndexMapping(indexService, builder)__                if (indexDirty) {_                    mdBuilder.put(builder)__                    dirty = true__                }_            } finally {_                if (removeIndex) {_                    indicesService.removeIndex(index, NO_LONGER_ASSIGNED, "created for mapping processing")__                }_            }_        }__        if (!dirty) {_            return currentState__        }_        return ClusterState.builder(currentState).metaData(mdBuilder).build()__    };batch,method,to,apply,all,the,queued,refresh,operations,the,idea,is,to,try,and,batch,as,much,as,possible,so,we,won,t,create,the,same,index,all,the,time,for,example,for,the,updates,on,the,same,mapping,and,generate,a,single,cluster,change,event,out,of,all,of,those;cluster,state,execute,refresh,final,cluster,state,current,state,final,list,refresh,task,all,tasks,throws,exception,map,string,list,refresh,task,tasks,per,index,new,hash,map,for,refresh,task,task,all,tasks,if,task,index,null,logger,debug,ignoring,a,mapping,task,of,type,with,a,null,index,task,tasks,per,index,compute,if,absent,task,index,k,new,array,list,add,task,boolean,dirty,false,meta,data,builder,md,builder,meta,data,builder,current,state,meta,data,for,map,entry,string,list,refresh,task,entry,tasks,per,index,entry,set,index,meta,data,index,meta,data,md,builder,get,entry,get,key,if,index,meta,data,null,logger,debug,ignoring,tasks,index,meta,data,doesn,t,exist,entry,get,key,continue,final,index,index,index,meta,data,get,index,list,refresh,task,all,index,tasks,entry,get,value,boolean,has,task,with,right,uuid,false,for,refresh,task,task,all,index,tasks,if,index,meta,data,is,same,uuid,task,index,uuid,has,task,with,right,uuid,true,else,logger,debug,ignoring,task,index,meta,data,doesn,t,match,task,uuid,index,task,if,has,task,with,right,uuid,false,continue,boolean,remove,index,false,index,service,index,service,indices,service,index,service,index,meta,data,get,index,if,index,service,null,index,service,indices,service,create,index,index,meta,data,collections,empty,list,remove,index,true,index,service,mapper,service,merge,index,meta,data,merge,reason,index,meta,data,builder,builder,index,meta,data,builder,index,meta,data,try,boolean,index,dirty,refresh,index,mapping,index,service,builder,if,index,dirty,md,builder,put,builder,dirty,true,finally,if,remove,index,indices,service,remove,index,index,created,for,mapping,processing,if,dirty,return,current,state,return,cluster,state,builder,current,state,meta,data,md,builder,build
MetaDataMappingService -> ClusterState executeRefresh(final ClusterState currentState, final List<RefreshTask> allTasks) throws Exception;1541092382;Batch method to apply all the queued refresh operations. The idea is to try and batch as much_as possible so we won't create the same index all the time for example for the updates on the same mapping_and generate a single cluster change event out of all of those.;ClusterState executeRefresh(final ClusterState currentState, final List<RefreshTask> allTasks) throws Exception {_        _        _        Map<String, List<RefreshTask>> tasksPerIndex = new HashMap<>()__        for (RefreshTask task : allTasks) {_            if (task.index == null) {_                logger.debug("ignoring a mapping task of type [{}] with a null index.", task)__            }_            tasksPerIndex.computeIfAbsent(task.index, k -> new ArrayList<>()).add(task)__        }__        boolean dirty = false__        MetaData.Builder mdBuilder = MetaData.builder(currentState.metaData())___        for (Map.Entry<String, List<RefreshTask>> entry : tasksPerIndex.entrySet()) {_            IndexMetaData indexMetaData = mdBuilder.get(entry.getKey())__            if (indexMetaData == null) {_                _                logger.debug("[{}] ignoring tasks - index meta data doesn't exist", entry.getKey())__                continue__            }_            final Index index = indexMetaData.getIndex()__            _            _            List<RefreshTask> allIndexTasks = entry.getValue()__            boolean hasTaskWithRightUUID = false__            for (RefreshTask task : allIndexTasks) {_                if (indexMetaData.isSameUUID(task.indexUUID)) {_                    hasTaskWithRightUUID = true__                } else {_                    logger.debug("{} ignoring task [{}] - index meta data doesn't match task uuid", index, task)__                }_            }_            if (hasTaskWithRightUUID == false) {_                continue__            }__            _            boolean removeIndex = false__            IndexService indexService = indicesService.indexService(indexMetaData.getIndex())__            if (indexService == null) {_                _                indexService = indicesService.createIndex(indexMetaData, Collections.emptyList())__                removeIndex = true__                indexService.mapperService().merge(indexMetaData, MergeReason.MAPPING_RECOVERY)__            }__            IndexMetaData.Builder builder = IndexMetaData.builder(indexMetaData)__            try {_                boolean indexDirty = refreshIndexMapping(indexService, builder)__                if (indexDirty) {_                    mdBuilder.put(builder)__                    dirty = true__                }_            } finally {_                if (removeIndex) {_                    indicesService.removeIndex(index, NO_LONGER_ASSIGNED, "created for mapping processing")__                }_            }_        }__        if (!dirty) {_            return currentState__        }_        return ClusterState.builder(currentState).metaData(mdBuilder).build()__    };batch,method,to,apply,all,the,queued,refresh,operations,the,idea,is,to,try,and,batch,as,much,as,possible,so,we,won,t,create,the,same,index,all,the,time,for,example,for,the,updates,on,the,same,mapping,and,generate,a,single,cluster,change,event,out,of,all,of,those;cluster,state,execute,refresh,final,cluster,state,current,state,final,list,refresh,task,all,tasks,throws,exception,map,string,list,refresh,task,tasks,per,index,new,hash,map,for,refresh,task,task,all,tasks,if,task,index,null,logger,debug,ignoring,a,mapping,task,of,type,with,a,null,index,task,tasks,per,index,compute,if,absent,task,index,k,new,array,list,add,task,boolean,dirty,false,meta,data,builder,md,builder,meta,data,builder,current,state,meta,data,for,map,entry,string,list,refresh,task,entry,tasks,per,index,entry,set,index,meta,data,index,meta,data,md,builder,get,entry,get,key,if,index,meta,data,null,logger,debug,ignoring,tasks,index,meta,data,doesn,t,exist,entry,get,key,continue,final,index,index,index,meta,data,get,index,list,refresh,task,all,index,tasks,entry,get,value,boolean,has,task,with,right,uuid,false,for,refresh,task,task,all,index,tasks,if,index,meta,data,is,same,uuid,task,index,uuid,has,task,with,right,uuid,true,else,logger,debug,ignoring,task,index,meta,data,doesn,t,match,task,uuid,index,task,if,has,task,with,right,uuid,false,continue,boolean,remove,index,false,index,service,index,service,indices,service,index,service,index,meta,data,get,index,if,index,service,null,index,service,indices,service,create,index,index,meta,data,collections,empty,list,remove,index,true,index,service,mapper,service,merge,index,meta,data,merge,reason,index,meta,data,builder,builder,index,meta,data,builder,index,meta,data,try,boolean,index,dirty,refresh,index,mapping,index,service,builder,if,index,dirty,md,builder,put,builder,dirty,true,finally,if,remove,index,indices,service,remove,index,index,created,for,mapping,processing,if,dirty,return,current,state,return,cluster,state,builder,current,state,meta,data,md,builder,build
MetaDataMappingService -> ClusterState executeRefresh(final ClusterState currentState, final List<RefreshTask> allTasks) throws Exception;1542402632;Batch method to apply all the queued refresh operations. The idea is to try and batch as much_as possible so we won't create the same index all the time for example for the updates on the same mapping_and generate a single cluster change event out of all of those.;ClusterState executeRefresh(final ClusterState currentState, final List<RefreshTask> allTasks) throws Exception {_        _        _        Map<String, List<RefreshTask>> tasksPerIndex = new HashMap<>()__        for (RefreshTask task : allTasks) {_            if (task.index == null) {_                logger.debug("ignoring a mapping task of type [{}] with a null index.", task)__            }_            tasksPerIndex.computeIfAbsent(task.index, k -> new ArrayList<>()).add(task)__        }__        boolean dirty = false__        MetaData.Builder mdBuilder = MetaData.builder(currentState.metaData())___        for (Map.Entry<String, List<RefreshTask>> entry : tasksPerIndex.entrySet()) {_            IndexMetaData indexMetaData = mdBuilder.get(entry.getKey())__            if (indexMetaData == null) {_                _                logger.debug("[{}] ignoring tasks - index meta data doesn't exist", entry.getKey())__                continue__            }_            final Index index = indexMetaData.getIndex()__            _            _            List<RefreshTask> allIndexTasks = entry.getValue()__            boolean hasTaskWithRightUUID = false__            for (RefreshTask task : allIndexTasks) {_                if (indexMetaData.isSameUUID(task.indexUUID)) {_                    hasTaskWithRightUUID = true__                } else {_                    logger.debug("{} ignoring task [{}] - index meta data doesn't match task uuid", index, task)__                }_            }_            if (hasTaskWithRightUUID == false) {_                continue__            }__            _            boolean removeIndex = false__            IndexService indexService = indicesService.indexService(indexMetaData.getIndex())__            if (indexService == null) {_                _                indexService = indicesService.createIndex(indexMetaData, Collections.emptyList())__                removeIndex = true__                indexService.mapperService().merge(indexMetaData, MergeReason.MAPPING_RECOVERY)__            }__            IndexMetaData.Builder builder = IndexMetaData.builder(indexMetaData)__            try {_                boolean indexDirty = refreshIndexMapping(indexService, builder)__                if (indexDirty) {_                    mdBuilder.put(builder)__                    dirty = true__                }_            } finally {_                if (removeIndex) {_                    indicesService.removeIndex(index, NO_LONGER_ASSIGNED, "created for mapping processing")__                }_            }_        }__        if (!dirty) {_            return currentState__        }_        return ClusterState.builder(currentState).metaData(mdBuilder).build()__    };batch,method,to,apply,all,the,queued,refresh,operations,the,idea,is,to,try,and,batch,as,much,as,possible,so,we,won,t,create,the,same,index,all,the,time,for,example,for,the,updates,on,the,same,mapping,and,generate,a,single,cluster,change,event,out,of,all,of,those;cluster,state,execute,refresh,final,cluster,state,current,state,final,list,refresh,task,all,tasks,throws,exception,map,string,list,refresh,task,tasks,per,index,new,hash,map,for,refresh,task,task,all,tasks,if,task,index,null,logger,debug,ignoring,a,mapping,task,of,type,with,a,null,index,task,tasks,per,index,compute,if,absent,task,index,k,new,array,list,add,task,boolean,dirty,false,meta,data,builder,md,builder,meta,data,builder,current,state,meta,data,for,map,entry,string,list,refresh,task,entry,tasks,per,index,entry,set,index,meta,data,index,meta,data,md,builder,get,entry,get,key,if,index,meta,data,null,logger,debug,ignoring,tasks,index,meta,data,doesn,t,exist,entry,get,key,continue,final,index,index,index,meta,data,get,index,list,refresh,task,all,index,tasks,entry,get,value,boolean,has,task,with,right,uuid,false,for,refresh,task,task,all,index,tasks,if,index,meta,data,is,same,uuid,task,index,uuid,has,task,with,right,uuid,true,else,logger,debug,ignoring,task,index,meta,data,doesn,t,match,task,uuid,index,task,if,has,task,with,right,uuid,false,continue,boolean,remove,index,false,index,service,index,service,indices,service,index,service,index,meta,data,get,index,if,index,service,null,index,service,indices,service,create,index,index,meta,data,collections,empty,list,remove,index,true,index,service,mapper,service,merge,index,meta,data,merge,reason,index,meta,data,builder,builder,index,meta,data,builder,index,meta,data,try,boolean,index,dirty,refresh,index,mapping,index,service,builder,if,index,dirty,md,builder,put,builder,dirty,true,finally,if,remove,index,indices,service,remove,index,index,created,for,mapping,processing,if,dirty,return,current,state,return,cluster,state,builder,current,state,meta,data,md,builder,build
MetaDataMappingService -> ClusterState executeRefresh(final ClusterState currentState, final List<RefreshTask> allTasks) throws Exception;1543947737;Batch method to apply all the queued refresh operations. The idea is to try and batch as much_as possible so we won't create the same index all the time for example for the updates on the same mapping_and generate a single cluster change event out of all of those.;ClusterState executeRefresh(final ClusterState currentState, final List<RefreshTask> allTasks) throws Exception {_        _        _        Map<String, List<RefreshTask>> tasksPerIndex = new HashMap<>()__        for (RefreshTask task : allTasks) {_            if (task.index == null) {_                logger.debug("ignoring a mapping task of type [{}] with a null index.", task)__            }_            tasksPerIndex.computeIfAbsent(task.index, k -> new ArrayList<>()).add(task)__        }__        boolean dirty = false__        MetaData.Builder mdBuilder = MetaData.builder(currentState.metaData())___        for (Map.Entry<String, List<RefreshTask>> entry : tasksPerIndex.entrySet()) {_            IndexMetaData indexMetaData = mdBuilder.get(entry.getKey())__            if (indexMetaData == null) {_                _                logger.debug("[{}] ignoring tasks - index meta data doesn't exist", entry.getKey())__                continue__            }_            final Index index = indexMetaData.getIndex()__            _            _            List<RefreshTask> allIndexTasks = entry.getValue()__            boolean hasTaskWithRightUUID = false__            for (RefreshTask task : allIndexTasks) {_                if (indexMetaData.isSameUUID(task.indexUUID)) {_                    hasTaskWithRightUUID = true__                } else {_                    logger.debug("{} ignoring task [{}] - index meta data doesn't match task uuid", index, task)__                }_            }_            if (hasTaskWithRightUUID == false) {_                continue__            }__            _            boolean removeIndex = false__            IndexService indexService = indicesService.indexService(indexMetaData.getIndex())__            if (indexService == null) {_                _                indexService = indicesService.createIndex(indexMetaData, Collections.emptyList())__                removeIndex = true__                indexService.mapperService().merge(indexMetaData, MergeReason.MAPPING_RECOVERY)__            }__            IndexMetaData.Builder builder = IndexMetaData.builder(indexMetaData)__            try {_                boolean indexDirty = refreshIndexMapping(indexService, builder)__                if (indexDirty) {_                    mdBuilder.put(builder)__                    dirty = true__                }_            } finally {_                if (removeIndex) {_                    indicesService.removeIndex(index, NO_LONGER_ASSIGNED, "created for mapping processing")__                }_            }_        }__        if (!dirty) {_            return currentState__        }_        return ClusterState.builder(currentState).metaData(mdBuilder).build()__    };batch,method,to,apply,all,the,queued,refresh,operations,the,idea,is,to,try,and,batch,as,much,as,possible,so,we,won,t,create,the,same,index,all,the,time,for,example,for,the,updates,on,the,same,mapping,and,generate,a,single,cluster,change,event,out,of,all,of,those;cluster,state,execute,refresh,final,cluster,state,current,state,final,list,refresh,task,all,tasks,throws,exception,map,string,list,refresh,task,tasks,per,index,new,hash,map,for,refresh,task,task,all,tasks,if,task,index,null,logger,debug,ignoring,a,mapping,task,of,type,with,a,null,index,task,tasks,per,index,compute,if,absent,task,index,k,new,array,list,add,task,boolean,dirty,false,meta,data,builder,md,builder,meta,data,builder,current,state,meta,data,for,map,entry,string,list,refresh,task,entry,tasks,per,index,entry,set,index,meta,data,index,meta,data,md,builder,get,entry,get,key,if,index,meta,data,null,logger,debug,ignoring,tasks,index,meta,data,doesn,t,exist,entry,get,key,continue,final,index,index,index,meta,data,get,index,list,refresh,task,all,index,tasks,entry,get,value,boolean,has,task,with,right,uuid,false,for,refresh,task,task,all,index,tasks,if,index,meta,data,is,same,uuid,task,index,uuid,has,task,with,right,uuid,true,else,logger,debug,ignoring,task,index,meta,data,doesn,t,match,task,uuid,index,task,if,has,task,with,right,uuid,false,continue,boolean,remove,index,false,index,service,index,service,indices,service,index,service,index,meta,data,get,index,if,index,service,null,index,service,indices,service,create,index,index,meta,data,collections,empty,list,remove,index,true,index,service,mapper,service,merge,index,meta,data,merge,reason,index,meta,data,builder,builder,index,meta,data,builder,index,meta,data,try,boolean,index,dirty,refresh,index,mapping,index,service,builder,if,index,dirty,md,builder,put,builder,dirty,true,finally,if,remove,index,indices,service,remove,index,index,created,for,mapping,processing,if,dirty,return,current,state,return,cluster,state,builder,current,state,meta,data,md,builder,build
MetaDataMappingService -> ClusterState executeRefresh(final ClusterState currentState, final List<RefreshTask> allTasks) throws Exception;1547566367;Batch method to apply all the queued refresh operations. The idea is to try and batch as much_as possible so we won't create the same index all the time for example for the updates on the same mapping_and generate a single cluster change event out of all of those.;ClusterState executeRefresh(final ClusterState currentState, final List<RefreshTask> allTasks) throws Exception {_        _        _        Map<String, List<RefreshTask>> tasksPerIndex = new HashMap<>()__        for (RefreshTask task : allTasks) {_            if (task.index == null) {_                logger.debug("ignoring a mapping task of type [{}] with a null index.", task)__            }_            tasksPerIndex.computeIfAbsent(task.index, k -> new ArrayList<>()).add(task)__        }__        boolean dirty = false__        MetaData.Builder mdBuilder = MetaData.builder(currentState.metaData())___        for (Map.Entry<String, List<RefreshTask>> entry : tasksPerIndex.entrySet()) {_            IndexMetaData indexMetaData = mdBuilder.get(entry.getKey())__            if (indexMetaData == null) {_                _                logger.debug("[{}] ignoring tasks - index meta data doesn't exist", entry.getKey())__                continue__            }_            final Index index = indexMetaData.getIndex()__            _            _            List<RefreshTask> allIndexTasks = entry.getValue()__            boolean hasTaskWithRightUUID = false__            for (RefreshTask task : allIndexTasks) {_                if (indexMetaData.isSameUUID(task.indexUUID)) {_                    hasTaskWithRightUUID = true__                } else {_                    logger.debug("{} ignoring task [{}] - index meta data doesn't match task uuid", index, task)__                }_            }_            if (hasTaskWithRightUUID == false) {_                continue__            }__            _            boolean removeIndex = false__            IndexService indexService = indicesService.indexService(indexMetaData.getIndex())__            if (indexService == null) {_                _                indexService = indicesService.createIndex(indexMetaData, Collections.emptyList())__                removeIndex = true__                indexService.mapperService().merge(indexMetaData, MergeReason.MAPPING_RECOVERY)__            }__            IndexMetaData.Builder builder = IndexMetaData.builder(indexMetaData)__            try {_                boolean indexDirty = refreshIndexMapping(indexService, builder)__                if (indexDirty) {_                    mdBuilder.put(builder)__                    dirty = true__                }_            } finally {_                if (removeIndex) {_                    indicesService.removeIndex(index, NO_LONGER_ASSIGNED, "created for mapping processing")__                }_            }_        }__        if (!dirty) {_            return currentState__        }_        return ClusterState.builder(currentState).metaData(mdBuilder).build()__    };batch,method,to,apply,all,the,queued,refresh,operations,the,idea,is,to,try,and,batch,as,much,as,possible,so,we,won,t,create,the,same,index,all,the,time,for,example,for,the,updates,on,the,same,mapping,and,generate,a,single,cluster,change,event,out,of,all,of,those;cluster,state,execute,refresh,final,cluster,state,current,state,final,list,refresh,task,all,tasks,throws,exception,map,string,list,refresh,task,tasks,per,index,new,hash,map,for,refresh,task,task,all,tasks,if,task,index,null,logger,debug,ignoring,a,mapping,task,of,type,with,a,null,index,task,tasks,per,index,compute,if,absent,task,index,k,new,array,list,add,task,boolean,dirty,false,meta,data,builder,md,builder,meta,data,builder,current,state,meta,data,for,map,entry,string,list,refresh,task,entry,tasks,per,index,entry,set,index,meta,data,index,meta,data,md,builder,get,entry,get,key,if,index,meta,data,null,logger,debug,ignoring,tasks,index,meta,data,doesn,t,exist,entry,get,key,continue,final,index,index,index,meta,data,get,index,list,refresh,task,all,index,tasks,entry,get,value,boolean,has,task,with,right,uuid,false,for,refresh,task,task,all,index,tasks,if,index,meta,data,is,same,uuid,task,index,uuid,has,task,with,right,uuid,true,else,logger,debug,ignoring,task,index,meta,data,doesn,t,match,task,uuid,index,task,if,has,task,with,right,uuid,false,continue,boolean,remove,index,false,index,service,index,service,indices,service,index,service,index,meta,data,get,index,if,index,service,null,index,service,indices,service,create,index,index,meta,data,collections,empty,list,remove,index,true,index,service,mapper,service,merge,index,meta,data,merge,reason,index,meta,data,builder,builder,index,meta,data,builder,index,meta,data,try,boolean,index,dirty,refresh,index,mapping,index,service,builder,if,index,dirty,md,builder,put,builder,dirty,true,finally,if,remove,index,indices,service,remove,index,index,created,for,mapping,processing,if,dirty,return,current,state,return,cluster,state,builder,current,state,meta,data,md,builder,build
MetaDataMappingService -> ClusterState executeRefresh(final ClusterState currentState, final List<RefreshTask> allTasks) throws Exception;1548939462;Batch method to apply all the queued refresh operations. The idea is to try and batch as much_as possible so we won't create the same index all the time for example for the updates on the same mapping_and generate a single cluster change event out of all of those.;ClusterState executeRefresh(final ClusterState currentState, final List<RefreshTask> allTasks) throws Exception {_        _        _        Map<String, List<RefreshTask>> tasksPerIndex = new HashMap<>()__        for (RefreshTask task : allTasks) {_            if (task.index == null) {_                logger.debug("ignoring a mapping task of type [{}] with a null index.", task)__            }_            tasksPerIndex.computeIfAbsent(task.index, k -> new ArrayList<>()).add(task)__        }__        boolean dirty = false__        MetaData.Builder mdBuilder = MetaData.builder(currentState.metaData())___        for (Map.Entry<String, List<RefreshTask>> entry : tasksPerIndex.entrySet()) {_            IndexMetaData indexMetaData = mdBuilder.get(entry.getKey())__            if (indexMetaData == null) {_                _                logger.debug("[{}] ignoring tasks - index meta data doesn't exist", entry.getKey())__                continue__            }_            final Index index = indexMetaData.getIndex()__            _            _            List<RefreshTask> allIndexTasks = entry.getValue()__            boolean hasTaskWithRightUUID = false__            for (RefreshTask task : allIndexTasks) {_                if (indexMetaData.isSameUUID(task.indexUUID)) {_                    hasTaskWithRightUUID = true__                } else {_                    logger.debug("{} ignoring task [{}] - index meta data doesn't match task uuid", index, task)__                }_            }_            if (hasTaskWithRightUUID == false) {_                continue__            }__            _            boolean removeIndex = false__            IndexService indexService = indicesService.indexService(indexMetaData.getIndex())__            if (indexService == null) {_                _                indexService = indicesService.createIndex(indexMetaData, Collections.emptyList())__                removeIndex = true__                indexService.mapperService().merge(indexMetaData, MergeReason.MAPPING_RECOVERY)__            }__            IndexMetaData.Builder builder = IndexMetaData.builder(indexMetaData)__            try {_                boolean indexDirty = refreshIndexMapping(indexService, builder)__                if (indexDirty) {_                    mdBuilder.put(builder)__                    dirty = true__                }_            } finally {_                if (removeIndex) {_                    indicesService.removeIndex(index, NO_LONGER_ASSIGNED, "created for mapping processing")__                }_            }_        }__        if (!dirty) {_            return currentState__        }_        return ClusterState.builder(currentState).metaData(mdBuilder).build()__    };batch,method,to,apply,all,the,queued,refresh,operations,the,idea,is,to,try,and,batch,as,much,as,possible,so,we,won,t,create,the,same,index,all,the,time,for,example,for,the,updates,on,the,same,mapping,and,generate,a,single,cluster,change,event,out,of,all,of,those;cluster,state,execute,refresh,final,cluster,state,current,state,final,list,refresh,task,all,tasks,throws,exception,map,string,list,refresh,task,tasks,per,index,new,hash,map,for,refresh,task,task,all,tasks,if,task,index,null,logger,debug,ignoring,a,mapping,task,of,type,with,a,null,index,task,tasks,per,index,compute,if,absent,task,index,k,new,array,list,add,task,boolean,dirty,false,meta,data,builder,md,builder,meta,data,builder,current,state,meta,data,for,map,entry,string,list,refresh,task,entry,tasks,per,index,entry,set,index,meta,data,index,meta,data,md,builder,get,entry,get,key,if,index,meta,data,null,logger,debug,ignoring,tasks,index,meta,data,doesn,t,exist,entry,get,key,continue,final,index,index,index,meta,data,get,index,list,refresh,task,all,index,tasks,entry,get,value,boolean,has,task,with,right,uuid,false,for,refresh,task,task,all,index,tasks,if,index,meta,data,is,same,uuid,task,index,uuid,has,task,with,right,uuid,true,else,logger,debug,ignoring,task,index,meta,data,doesn,t,match,task,uuid,index,task,if,has,task,with,right,uuid,false,continue,boolean,remove,index,false,index,service,index,service,indices,service,index,service,index,meta,data,get,index,if,index,service,null,index,service,indices,service,create,index,index,meta,data,collections,empty,list,remove,index,true,index,service,mapper,service,merge,index,meta,data,merge,reason,index,meta,data,builder,builder,index,meta,data,builder,index,meta,data,try,boolean,index,dirty,refresh,index,mapping,index,service,builder,if,index,dirty,md,builder,put,builder,dirty,true,finally,if,remove,index,indices,service,remove,index,index,created,for,mapping,processing,if,dirty,return,current,state,return,cluster,state,builder,current,state,meta,data,md,builder,build
MetaDataMappingService -> ClusterState executeRefresh(final ClusterState currentState, final List<RefreshTask> allTasks) throws Exception;1549392752;Batch method to apply all the queued refresh operations. The idea is to try and batch as much_as possible so we won't create the same index all the time for example for the updates on the same mapping_and generate a single cluster change event out of all of those.;ClusterState executeRefresh(final ClusterState currentState, final List<RefreshTask> allTasks) throws Exception {_        _        _        Map<String, List<RefreshTask>> tasksPerIndex = new HashMap<>()__        for (RefreshTask task : allTasks) {_            if (task.index == null) {_                logger.debug("ignoring a mapping task of type [{}] with a null index.", task)__            }_            tasksPerIndex.computeIfAbsent(task.index, k -> new ArrayList<>()).add(task)__        }__        boolean dirty = false__        MetaData.Builder mdBuilder = MetaData.builder(currentState.metaData())___        for (Map.Entry<String, List<RefreshTask>> entry : tasksPerIndex.entrySet()) {_            IndexMetaData indexMetaData = mdBuilder.get(entry.getKey())__            if (indexMetaData == null) {_                _                logger.debug("[{}] ignoring tasks - index meta data doesn't exist", entry.getKey())__                continue__            }_            final Index index = indexMetaData.getIndex()__            _            _            List<RefreshTask> allIndexTasks = entry.getValue()__            boolean hasTaskWithRightUUID = false__            for (RefreshTask task : allIndexTasks) {_                if (indexMetaData.isSameUUID(task.indexUUID)) {_                    hasTaskWithRightUUID = true__                } else {_                    logger.debug("{} ignoring task [{}] - index meta data doesn't match task uuid", index, task)__                }_            }_            if (hasTaskWithRightUUID == false) {_                continue__            }__            _            boolean removeIndex = false__            IndexService indexService = indicesService.indexService(indexMetaData.getIndex())__            if (indexService == null) {_                _                indexService = indicesService.createIndex(indexMetaData, Collections.emptyList())__                removeIndex = true__                indexService.mapperService().merge(indexMetaData, MergeReason.MAPPING_RECOVERY)__            }__            IndexMetaData.Builder builder = IndexMetaData.builder(indexMetaData)__            try {_                boolean indexDirty = refreshIndexMapping(indexService, builder)__                if (indexDirty) {_                    mdBuilder.put(builder)__                    dirty = true__                }_            } finally {_                if (removeIndex) {_                    indicesService.removeIndex(index, NO_LONGER_ASSIGNED, "created for mapping processing")__                }_            }_        }__        if (!dirty) {_            return currentState__        }_        return ClusterState.builder(currentState).metaData(mdBuilder).build()__    };batch,method,to,apply,all,the,queued,refresh,operations,the,idea,is,to,try,and,batch,as,much,as,possible,so,we,won,t,create,the,same,index,all,the,time,for,example,for,the,updates,on,the,same,mapping,and,generate,a,single,cluster,change,event,out,of,all,of,those;cluster,state,execute,refresh,final,cluster,state,current,state,final,list,refresh,task,all,tasks,throws,exception,map,string,list,refresh,task,tasks,per,index,new,hash,map,for,refresh,task,task,all,tasks,if,task,index,null,logger,debug,ignoring,a,mapping,task,of,type,with,a,null,index,task,tasks,per,index,compute,if,absent,task,index,k,new,array,list,add,task,boolean,dirty,false,meta,data,builder,md,builder,meta,data,builder,current,state,meta,data,for,map,entry,string,list,refresh,task,entry,tasks,per,index,entry,set,index,meta,data,index,meta,data,md,builder,get,entry,get,key,if,index,meta,data,null,logger,debug,ignoring,tasks,index,meta,data,doesn,t,exist,entry,get,key,continue,final,index,index,index,meta,data,get,index,list,refresh,task,all,index,tasks,entry,get,value,boolean,has,task,with,right,uuid,false,for,refresh,task,task,all,index,tasks,if,index,meta,data,is,same,uuid,task,index,uuid,has,task,with,right,uuid,true,else,logger,debug,ignoring,task,index,meta,data,doesn,t,match,task,uuid,index,task,if,has,task,with,right,uuid,false,continue,boolean,remove,index,false,index,service,index,service,indices,service,index,service,index,meta,data,get,index,if,index,service,null,index,service,indices,service,create,index,index,meta,data,collections,empty,list,remove,index,true,index,service,mapper,service,merge,index,meta,data,merge,reason,index,meta,data,builder,builder,index,meta,data,builder,index,meta,data,try,boolean,index,dirty,refresh,index,mapping,index,service,builder,if,index,dirty,md,builder,put,builder,dirty,true,finally,if,remove,index,indices,service,remove,index,index,created,for,mapping,processing,if,dirty,return,current,state,return,cluster,state,builder,current,state,meta,data,md,builder,build
