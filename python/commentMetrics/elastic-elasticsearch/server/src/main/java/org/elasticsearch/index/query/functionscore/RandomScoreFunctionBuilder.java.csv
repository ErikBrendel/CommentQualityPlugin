commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;12;;@Override protected void doWriteTo(StreamOutput out) throws IOException {     if (seed != null) {         out.writeBoolean(true).         out.writeInt(seed).     } else {         out.writeBoolean(false).     }     if (out.getVersion().onOrAfter(Version.V_6_0_0_beta1)) {         out.writeOptionalString(field).     } }
false;public;0;4;;@Override public String getName() {     return NAME. }
true;public;1;4;/**  * Sets the seed based on which the random number will be generated. Using the same seed is guaranteed to generate the same  * random number for a specific doc.  *  * @param seed The seed.  */ ;/**  * Sets the seed based on which the random number will be generated. Using the same seed is guaranteed to generate the same  * random number for a specific doc.  *  * @param seed The seed.  */ public RandomScoreFunctionBuilder seed(int seed) {     this.seed = seed.     return this. }
true;public;1;4;/**  * seed variant taking a long value.  * @see #seed(int)  */ ;/**  * seed variant taking a long value.  * @see #seed(int)  */ public RandomScoreFunctionBuilder seed(long seed) {     this.seed = hash(seed).     return this. }
true;public;1;7;/**  * seed variant taking a String value.  * @see #seed(int)  */ ;/**  * seed variant taking a String value.  * @see #seed(int)  */ public RandomScoreFunctionBuilder seed(String seed) {     if (seed == null) {         throw new IllegalArgumentException("random_score function: seed must not be null").     }     this.seed = seed.hashCode().     return this. }
false;public;0;3;;public Integer getSeed() {     return seed. }
true;public;1;4;/**  * Set the field to be used for random number generation. This parameter is compulsory  * when a {@link #seed(int) seed} is set and ignored otherwise. Note that documents that  * have the same value for a field will get the same score.  */ ;/**  * Set the field to be used for random number generation. This parameter is compulsory  * when a {@link #seed(int) seed} is set and ignored otherwise. Note that documents that  * have the same value for a field will get the same score.  */ public RandomScoreFunctionBuilder setField(String field) {     this.field = field.     return this. }
true;public;0;3;/**  * Get the field to use for random number generation.  * @see #setField(String)  */ ;/**  * Get the field to use for random number generation.  * @see #setField(String)  */ public String getField() {     return field. }
false;public;2;11;;@Override public void doXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject(getName()).     if (seed != null) {         builder.field("seed", seed).     }     if (field != null) {         builder.field("field", field).     }     builder.endObject(). }
false;protected;1;4;;@Override protected boolean doEquals(RandomScoreFunctionBuilder functionBuilder) {     return Objects.equals(this.seed, functionBuilder.seed). }
false;protected;0;4;;@Override protected int doHashCode() {     return Objects.hash(this.seed). }
false;protected;1;32;;@Override protected ScoreFunction doToFunction(QueryShardContext context) {     final int salt = (context.index().getName().hashCode() << 10) | context.getShardId().     if (seed == null) {         // DocID-based random score generation         return new RandomScoreFunction(hash(context.nowInMillis()), salt, null).     } else {         final MappedFieldType fieldType.         if (field != null) {             fieldType = context.getMapperService().fullName(field).         } else {             deprecationLogger.deprecated("As of version 7.0 Elasticsearch will require that a [field] parameter is provided when a [seed] is set").             fieldType = context.getMapperService().fullName(IdFieldMapper.NAME).         }         if (fieldType == null) {             if (context.getMapperService().documentMapper() == null) {                 // no mappings: the index is empty anyway                 return new RandomScoreFunction(hash(context.nowInMillis()), salt, null).             }             throw new IllegalArgumentException("Field [" + field + "] is not mapped on [" + context.index() + "] and cannot be used as a source of random numbers.").         }         int seed.         if (this.seed != null) {             seed = this.seed.         } else {             seed = hash(context.nowInMillis()).         }         return new RandomScoreFunction(seed, salt, context.getForField(fieldType)).     } }
false;private,static;1;3;;private static int hash(long value) {     return Long.hashCode(value). }
false;public,static;1;34;;public static RandomScoreFunctionBuilder fromXContent(XContentParser parser) throws IOException, ParsingException {     RandomScoreFunctionBuilder randomScoreFunctionBuilder = new RandomScoreFunctionBuilder().     String currentFieldName = null.     XContentParser.Token token.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (token.isValue()) {             if ("seed".equals(currentFieldName)) {                 if (token == XContentParser.Token.VALUE_NUMBER) {                     if (parser.numberType() == XContentParser.NumberType.INT) {                         randomScoreFunctionBuilder.seed(parser.intValue()).                     } else if (parser.numberType() == XContentParser.NumberType.LONG) {                         randomScoreFunctionBuilder.seed(parser.longValue()).                     } else {                         throw new ParsingException(parser.getTokenLocation(), "random_score seed must be an int, long or string, not '" + token.toString() + "'").                     }                 } else if (token == XContentParser.Token.VALUE_STRING) {                     randomScoreFunctionBuilder.seed(parser.text()).                 } else {                     throw new ParsingException(parser.getTokenLocation(), "random_score seed must be an int/long or string, not '" + token.toString() + "'").                 }             } else if ("field".equals(currentFieldName)) {                 randomScoreFunctionBuilder.setField(parser.text()).             } else {                 throw new ParsingException(parser.getTokenLocation(), NAME + " query does not support [" + currentFieldName + "]").             }         }     }     return randomScoreFunctionBuilder. }
