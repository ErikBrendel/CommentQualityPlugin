commented;modifiers;parameterAmount;loc;comment;code
true;public;0;11;/**  * Returns the {@link Weight} for this filter aggregation, creating it if  * necessary. This is done lazily so that the {@link Weight} is only created  * if the aggregation collects documents reducing the overhead of the  * aggregation in the case where no documents are collected.  *  * Note that as aggregations are initialsed and executed in a serial manner,  * no concurrency considerations are necessary here.  */ ;/**  * Returns the {@link Weight} for this filter aggregation, creating it if  * necessary. This is done lazily so that the {@link Weight} is only created  * if the aggregation collects documents reducing the overhead of the  * aggregation in the case where no documents are collected.  *  * Note that as aggregations are initialsed and executed in a serial manner,  * no concurrency considerations are necessary here.  */ public Weight getWeight() {     if (weight == null) {         IndexSearcher contextSearcher = context.searcher().         try {             weight = contextSearcher.createWeight(contextSearcher.rewrite(filter), ScoreMode.COMPLETE_NO_SCORES, 1f).         } catch (IOException e) {             throw new AggregationInitializationException("Failed to initialse filter", e).         }     }     return weight. }
false;public;4;5;;@Override public Aggregator createInternal(Aggregator parent, boolean collectsFromSingleBucket, List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData) throws IOException {     return new FilterAggregator(name, () -> this.getWeight(), factories, context, parent, pipelineAggregators, metaData). }
