commented;modifiers;parameterAmount;loc;comment;code
false;public;1;9;;@Override public void doWriteTo(StreamOutput out) throws IOException {     out.writeOptionalWriteable(fuzzyOptions).     out.writeOptionalWriteable(regexOptions).     out.writeOptionalBytesReference(contextBytes).     if (out.getVersion().onOrAfter(Version.V_6_1_0)) {         out.writeBoolean(skipDuplicates).     } }
true;public;1;5;/**  * Sets the prefix to provide completions for.  * The prefix gets analyzed by the suggest analyzer.  */ ;/**  * Sets the prefix to provide completions for.  * The prefix gets analyzed by the suggest analyzer.  */ @Override public CompletionSuggestionBuilder prefix(String prefix) {     super.prefix(prefix).     return this. }
true;public;2;5;/**  * Same as {@link #prefix(String)} with fuzziness of <code>fuzziness</code>  */ ;/**  * Same as {@link #prefix(String)} with fuzziness of <code>fuzziness</code>  */ public CompletionSuggestionBuilder prefix(String prefix, Fuzziness fuzziness) {     super.prefix(prefix).     this.fuzzyOptions = new FuzzyOptions.Builder().setFuzziness(fuzziness).build().     return this. }
true;public;2;5;/**  * Same as {@link #prefix(String)} with full fuzzy options  * see {@link FuzzyOptions.Builder}  */ ;/**  * Same as {@link #prefix(String)} with full fuzzy options  * see {@link FuzzyOptions.Builder}  */ public CompletionSuggestionBuilder prefix(String prefix, FuzzyOptions fuzzyOptions) {     super.prefix(prefix).     this.fuzzyOptions = fuzzyOptions.     return this. }
true;public;1;5;/**  * Sets a regular expression pattern for prefixes to provide completions for.  */ ;/**  * Sets a regular expression pattern for prefixes to provide completions for.  */ @Override public CompletionSuggestionBuilder regex(String regex) {     super.regex(regex).     return this. }
true;public;2;5;/**  * Same as {@link #regex(String)} with full regular expression options  * see {@link RegexOptions.Builder}  */ ;/**  * Same as {@link #regex(String)} with full regular expression options  * see {@link RegexOptions.Builder}  */ public CompletionSuggestionBuilder regex(String regex, RegexOptions regexOptions) {     this.regex(regex).     this.regexOptions = regexOptions.     return this. }
true;public;1;18;/**  * Sets query contexts for completion  * @param queryContexts named query contexts  *                      see {@link org.elasticsearch.search.suggest.completion.context.CategoryQueryContext}  *                      and {@link org.elasticsearch.search.suggest.completion.context.GeoQueryContext}  */ ;/**  * Sets query contexts for completion  * @param queryContexts named query contexts  *                      see {@link org.elasticsearch.search.suggest.completion.context.CategoryQueryContext}  *                      and {@link org.elasticsearch.search.suggest.completion.context.GeoQueryContext}  */ public CompletionSuggestionBuilder contexts(Map<String, List<? extends ToXContent>> queryContexts) {     Objects.requireNonNull(queryContexts, "contexts must not be null").     try {         XContentBuilder contentBuilder = XContentFactory.contentBuilder(CONTEXT_BYTES_XCONTENT_TYPE).         contentBuilder.startObject().         for (Map.Entry<String, List<? extends ToXContent>> contextEntry : queryContexts.entrySet()) {             contentBuilder.startArray(contextEntry.getKey()).             for (ToXContent queryContext : contextEntry.getValue()) {                 queryContext.toXContent(contentBuilder, EMPTY_PARAMS).             }             contentBuilder.endArray().         }         contentBuilder.endObject().         return contexts(contentBuilder).     } catch (IOException e) {         throw new IllegalArgumentException(e).     } }
false;private;1;4;;private CompletionSuggestionBuilder contexts(XContentBuilder contextBuilder) {     contextBytes = BytesReference.bytes(contextBuilder).     return this. }
true;public;0;3;/**  * Returns whether duplicate suggestions should be filtered out.  */ ;/**  * Returns whether duplicate suggestions should be filtered out.  */ public boolean skipDuplicates() {     return skipDuplicates. }
true;public;1;4;/**  * Should duplicates be filtered or not. Defaults to {@code false}.  */ ;/**  * Should duplicates be filtered or not. Defaults to {@code false}.  */ public CompletionSuggestionBuilder skipDuplicates(boolean skipDuplicates) {     this.skipDuplicates = skipDuplicates.     return this. }
false;private;1;4;;private InnerBuilder field(String field) {     this.field = field.     return this. }
false;protected;2;18;;@Override protected XContentBuilder innerToXContent(XContentBuilder builder, Params params) throws IOException {     if (fuzzyOptions != null) {         fuzzyOptions.toXContent(builder, params).     }     if (regexOptions != null) {         regexOptions.toXContent(builder, params).     }     if (skipDuplicates) {         builder.field(SKIP_DUPLICATES_FIELD.getPreferredName(), skipDuplicates).     }     if (contextBytes != null) {         try (InputStream stream = contextBytes.streamInput()) {             builder.rawField(CONTEXTS_FIELD.getPreferredName(), stream).         }     }     return builder. }
false;public,static;1;11;;public static CompletionSuggestionBuilder fromXContent(XContentParser parser) throws IOException {     CompletionSuggestionBuilder.InnerBuilder builder = new CompletionSuggestionBuilder.InnerBuilder().     PARSER.parse(parser, builder, null).     String field = builder.field.     // now we should have field name, check and copy fields over to the suggestion builder we return     if (field == null) {         throw new ElasticsearchParseException("the required field option [" + FIELDNAME_FIELD.getPreferredName() + "] is missing").     }     return new CompletionSuggestionBuilder(field, builder). }
false;public;1;30;;@Override public SuggestionContext build(QueryShardContext context) throws IOException {     CompletionSuggestionContext suggestionContext = new CompletionSuggestionContext(context).     // copy over common settings to each suggestion builder     final MapperService mapperService = context.getMapperService().     populateCommonFields(mapperService, suggestionContext).     suggestionContext.setSkipDuplicates(skipDuplicates).     suggestionContext.setFuzzyOptions(fuzzyOptions).     suggestionContext.setRegexOptions(regexOptions).     if (shardSize != null) {         suggestionContext.setShardSize(shardSize).     }     MappedFieldType mappedFieldType = mapperService.fullName(suggestionContext.getField()).     if (mappedFieldType == null || mappedFieldType instanceof CompletionFieldMapper.CompletionFieldType == false) {         throw new IllegalArgumentException("Field [" + suggestionContext.getField() + "] is not a completion suggest field").     }     if (mappedFieldType instanceof CompletionFieldMapper.CompletionFieldType) {         CompletionFieldMapper.CompletionFieldType type = (CompletionFieldMapper.CompletionFieldType) mappedFieldType.         suggestionContext.setFieldType(type).         if (type.hasContextMappings() && contextBytes != null) {             Map<String, List<ContextMapping.InternalQueryContext>> queryContexts = parseContextBytes(contextBytes, context.getXContentRegistry(), type.getContextMappings()).             suggestionContext.setQueryContexts(queryContexts).         } else if (contextBytes != null) {             throw new IllegalArgumentException("suggester [" + type.name() + "] doesn't expect any context").         }     }     assert suggestionContext.getFieldType() != null : "no completion field type set".     return suggestionContext. }
false;static;3;19;;static Map<String, List<ContextMapping.InternalQueryContext>> parseContextBytes(BytesReference contextBytes, NamedXContentRegistry xContentRegistry, ContextMappings contextMappings) throws IOException {     try (XContentParser contextParser = XContentHelper.createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, contextBytes, CONTEXT_BYTES_XCONTENT_TYPE)) {         contextParser.nextToken().         Map<String, List<ContextMapping.InternalQueryContext>> queryContexts = new HashMap<>(contextMappings.size()).         assert contextParser.currentToken() == XContentParser.Token.START_OBJECT.         XContentParser.Token currentToken.         String currentFieldName.         while ((currentToken = contextParser.nextToken()) != XContentParser.Token.END_OBJECT) {             if (currentToken == XContentParser.Token.FIELD_NAME) {                 currentFieldName = contextParser.currentName().                 final ContextMapping<?> mapping = contextMappings.get(currentFieldName).                 queryContexts.put(currentFieldName, mapping.parseQueryContext(contextParser)).             }         }         return queryContexts.     } }
false;public;0;4;;@Override public String getWriteableName() {     return SUGGESTION_NAME. }
false;protected;1;7;;@Override protected boolean doEquals(CompletionSuggestionBuilder other) {     return skipDuplicates == other.skipDuplicates && Objects.equals(fuzzyOptions, other.fuzzyOptions) && Objects.equals(regexOptions, other.regexOptions) && Objects.equals(contextBytes, other.contextBytes). }
false;protected;0;4;;@Override protected int doHashCode() {     return Objects.hash(fuzzyOptions, regexOptions, contextBytes, skipDuplicates). }
