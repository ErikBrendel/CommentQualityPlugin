commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected ReplicationResponse newResponseInstance() {     return new ReplicationResponse(). }
false;protected;3;6;;@Override protected void acquirePrimaryOperationPermit(final IndexShard primary, final ShardRequest request, final ActionListener<Releasable> onAcquired) {     primary.acquireAllPrimaryOperationsPermits(onAcquired, request.timeout()). }
false;protected;6;9;;@Override protected void acquireReplicaOperationPermit(final IndexShard replica, final ShardRequest request, final ActionListener<Releasable> onAcquired, final long primaryTerm, final long globalCheckpoint, final long maxSeqNoOfUpdateOrDeletes) {     replica.acquireAllReplicaOperationsPermits(primaryTerm, globalCheckpoint, maxSeqNoOfUpdateOrDeletes, onAcquired, request.timeout()). }
false;protected;2;6;;@Override protected PrimaryResult<ShardRequest, ReplicationResponse> shardOperationOnPrimary(final ShardRequest shardRequest, final IndexShard primary) throws Exception {     executeShardOperation(shardRequest, primary).     return new PrimaryResult<>(shardRequest, new ReplicationResponse()). }
false;protected;2;5;;@Override protected ReplicaResult shardOperationOnReplica(final ShardRequest shardRequest, final IndexShard replica) throws Exception {     executeShardOperation(shardRequest, replica).     return new ReplicaResult(). }
false;private;2;14;;private void executeShardOperation(final ShardRequest request, final IndexShard indexShard) {     final ShardId shardId = indexShard.shardId().     if (indexShard.getActiveOperationsCount() != 0) {         throw new IllegalStateException("On-going operations in progress while checking index shard " + shardId + " before closing").     }     final ClusterBlocks clusterBlocks = clusterService.state().blocks().     if (clusterBlocks.hasIndexBlock(shardId.getIndexName(), request.clusterBlock()) == false) {         throw new IllegalStateException("Index shard " + shardId + " must be blocked by " + request.clusterBlock() + " before closing").     }     indexShard.verifyShardBeforeIndexClosing().     indexShard.flush(new FlushRequest().force(true)).     logger.trace("{} shard is ready for closing", shardId). }
false;protected;1;4;;@Override protected ReplicationOperation.Replicas<ShardRequest> newReplicasProxy(final long primaryTerm) {     return new VerifyShardBeforeCloseActionReplicasProxy(primaryTerm). }
false;public;5;6;;@Override public void markShardCopyAsStaleIfNeeded(final ShardId shardId, final String allocationId, final Runnable onSuccess, final Consumer<Exception> onPrimaryDemoted, final Consumer<Exception> onIgnoredFailure) {     shardStateAction.remoteShardFailed(shardId, allocationId, primaryTerm, true, "mark copy as stale", null, createShardActionListener(onSuccess, onPrimaryDemoted, onIgnoredFailure)). }
false;public;0;4;;@Override public String toString() {     return "verify shard " + shardId + " before close with block " + clusterBlock. }
false;public;1;5;;@Override public void readFrom(final StreamInput in) throws IOException {     super.readFrom(in).     clusterBlock = new ClusterBlock(in). }
false;public;1;5;;@Override public void writeTo(final StreamOutput out) throws IOException {     super.writeTo(out).     clusterBlock.writeTo(out). }
false;public;0;3;;public ClusterBlock clusterBlock() {     return clusterBlock. }
