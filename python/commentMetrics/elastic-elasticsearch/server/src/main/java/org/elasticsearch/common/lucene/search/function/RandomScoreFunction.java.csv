commented;modifiers;parameterAmount;loc;comment;code
false;public;2;13;;@Override public double score(int docId, float subQueryScore) throws IOException {     int hash.     if (values == null) {         hash = BitMixer.mix(ctx.docBase + docId, saltedSeed).     } else if (values.advanceExact(docId)) {         hash = StringHelper.murmurhash3_x86_32(values.nextValue(), saltedSeed).     } else {         // field has no value         hash = saltedSeed.     }     // only use the lower 24 bits to construct a float from 0.0-1.0     return (hash & 0x00FFFFFF) / (float) (1 << 24). }
false;public;2;7;;@Override public Explanation explainScore(int docId, Explanation subQueryScore) throws IOException {     String field = fieldData == null ? null : fieldData.getFieldName().     return Explanation.match((float) score(docId, subQueryScore.getValue().floatValue()), "random score function (seed: " + originalSeed + ", field: " + field + ")"). }
false;public;1;36;;@Override public LeafScoreFunction getLeafScoreFunction(LeafReaderContext ctx) {     final SortedBinaryDocValues values.     if (fieldData != null) {         AtomicFieldData leafData = fieldData.load(ctx).         values = leafData.getBytesValues().         if (values == null)             throw new NullPointerException("failed to get fielddata").     } else {         values = null.     }     return new LeafScoreFunction() {          @Override         public double score(int docId, float subQueryScore) throws IOException {             int hash.             if (values == null) {                 hash = BitMixer.mix(ctx.docBase + docId, saltedSeed).             } else if (values.advanceExact(docId)) {                 hash = StringHelper.murmurhash3_x86_32(values.nextValue(), saltedSeed).             } else {                 // field has no value                 hash = saltedSeed.             }             // only use the lower 24 bits to construct a float from 0.0-1.0             return (hash & 0x00FFFFFF) / (float) (1 << 24).         }          @Override         public Explanation explainScore(int docId, Explanation subQueryScore) throws IOException {             String field = fieldData == null ? null : fieldData.getFieldName().             return Explanation.match((float) score(docId, subQueryScore.getValue().floatValue()), "random score function (seed: " + originalSeed + ", field: " + field + ")").         }     }. }
false;public;0;4;;@Override public boolean needsScores() {     return false. }
false;protected;1;6;;@Override protected boolean doEquals(ScoreFunction other) {     RandomScoreFunction randomScoreFunction = (RandomScoreFunction) other.     return this.originalSeed == randomScoreFunction.originalSeed && this.saltedSeed == randomScoreFunction.saltedSeed. }
false;protected;0;4;;@Override protected int doHashCode() {     return Objects.hash(originalSeed, saltedSeed). }
