commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;4;;@Override protected void doWriteTo(StreamOutput out) throws IOException {     writeQueries(out, clauses). }
true;public;1;7;/**  * Add a span clause to the current list of clauses  */ ;/**  * Add a span clause to the current list of clauses  */ public SpanOrQueryBuilder addClause(SpanQueryBuilder clause) {     if (clause == null) {         throw new IllegalArgumentException("[" + NAME + "] inner clause cannot be null").     }     clauses.add(clause).     return this. }
true;public;0;3;/**  * @return the {@link SpanQueryBuilder} clauses that were set for this query  */ ;/**  * @return the {@link SpanQueryBuilder} clauses that were set for this query  */ public List<SpanQueryBuilder> clauses() {     return Collections.unmodifiableList(this.clauses). }
false;protected;2;11;;@Override protected void doXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject(NAME).     builder.startArray(CLAUSES_FIELD.getPreferredName()).     for (SpanQueryBuilder clause : clauses) {         clause.toXContent(builder, params).     }     builder.endArray().     printBoostAndQueryName(builder).     builder.endObject(). }
false;public,static;1;48;;public static SpanOrQueryBuilder fromXContent(XContentParser parser) throws IOException {     float boost = AbstractQueryBuilder.DEFAULT_BOOST.     String queryName = null.     List<SpanQueryBuilder> clauses = new ArrayList<>().     String currentFieldName = null.     XContentParser.Token token.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (token == XContentParser.Token.START_ARRAY) {             if (CLAUSES_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {                     QueryBuilder query = parseInnerQueryBuilder(parser).                     if (query instanceof SpanQueryBuilder == false) {                         throw new ParsingException(parser.getTokenLocation(), "span_or [clauses] must be of type span query").                     }                     final SpanQueryBuilder clause = (SpanQueryBuilder) query.                     checkNoBoost(NAME, currentFieldName, parser, clause).                     clauses.add(clause).                 }             } else {                 throw new ParsingException(parser.getTokenLocation(), "[span_or] query does not support [" + currentFieldName + "]").             }         } else {             if (AbstractQueryBuilder.BOOST_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 boost = parser.floatValue().             } else if (AbstractQueryBuilder.NAME_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 queryName = parser.text().             } else {                 throw new ParsingException(parser.getTokenLocation(), "[span_or] query does not support [" + currentFieldName + "]").             }         }     }     if (clauses.isEmpty()) {         throw new ParsingException(parser.getTokenLocation(), "span_or must include [clauses]").     }     SpanOrQueryBuilder queryBuilder = new SpanOrQueryBuilder(clauses.get(0)).     for (int i = 1. i < clauses.size(). i++) {         queryBuilder.addClause(clauses.get(i)).     }     queryBuilder.boost(boost).     queryBuilder.queryName(queryName).     return queryBuilder. }
false;protected;1;10;;@Override protected Query doToQuery(QueryShardContext context) throws IOException {     SpanQuery[] spanQueries = new SpanQuery[clauses.size()].     for (int i = 0. i < clauses.size(). i++) {         Query query = clauses.get(i).toQuery(context).         assert query instanceof SpanQuery.         spanQueries[i] = (SpanQuery) query.     }     return new SpanOrQuery(spanQueries). }
false;protected;0;4;;@Override protected int doHashCode() {     return Objects.hash(clauses). }
false;protected;1;4;;@Override protected boolean doEquals(SpanOrQueryBuilder other) {     return Objects.equals(clauses, other.clauses). }
false;public;0;4;;@Override public String getWriteableName() {     return NAME. }
