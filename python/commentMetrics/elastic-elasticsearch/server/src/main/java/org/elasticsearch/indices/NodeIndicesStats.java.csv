commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Nullable public StoreStats getStore() {     return stats.getStore(). }
false;public;0;4;;@Nullable public DocsStats getDocs() {     return stats.getDocs(). }
false;public;0;4;;@Nullable public IndexingStats getIndexing() {     return stats.getIndexing(). }
false;public;0;4;;@Nullable public GetStats getGet() {     return stats.getGet(). }
false;public;0;4;;@Nullable public SearchStats getSearch() {     return stats.getSearch(). }
false;public;0;4;;@Nullable public MergeStats getMerge() {     return stats.getMerge(). }
false;public;0;4;;@Nullable public RefreshStats getRefresh() {     return stats.getRefresh(). }
false;public;0;4;;@Nullable public FlushStats getFlush() {     return stats.getFlush(). }
false;public;0;4;;@Nullable public WarmerStats getWarmer() {     return stats.getWarmer(). }
false;public;0;4;;@Nullable public FieldDataStats getFieldData() {     return stats.getFieldData(). }
false;public;0;4;;@Nullable public QueryCacheStats getQueryCache() {     return stats.getQueryCache(). }
false;public;0;4;;@Nullable public RequestCacheStats getRequestCache() {     return stats.getRequestCache(). }
false;public;0;4;;@Nullable public CompletionStats getCompletion() {     return stats.getCompletion(). }
false;public;0;4;;@Nullable public SegmentsStats getSegments() {     return stats.getSegments(). }
false;public;0;4;;@Nullable public TranslogStats getTranslog() {     return stats.getTranslog(). }
false;public;0;4;;@Nullable public RecoveryStats getRecoveryStats() {     return stats.getRecoveryStats(). }
false;public,static;1;5;;public static NodeIndicesStats readIndicesStats(StreamInput in) throws IOException {     NodeIndicesStats stats = new NodeIndicesStats().     stats.readFrom(in).     return stats. }
false;public;1;17;;@Override public void readFrom(StreamInput in) throws IOException {     stats = new CommonStats(in).     if (in.readBoolean()) {         int entries = in.readVInt().         statsByShard = new HashMap<>().         for (int i = 0. i < entries. i++) {             Index index = new Index(in).             int indexShardListSize = in.readVInt().             List<IndexShardStats> indexShardStats = new ArrayList<>(indexShardListSize).             for (int j = 0. j < indexShardListSize. j++) {                 indexShardStats.add(IndexShardStats.readIndexShardStats(in)).             }             statsByShard.put(index, indexShardStats).         }     } }
false;public;1;15;;@Override public void writeTo(StreamOutput out) throws IOException {     stats.writeTo(out).     out.writeBoolean(statsByShard != null).     if (statsByShard != null) {         out.writeVInt(statsByShard.size()).         for (Map.Entry<Index, List<IndexShardStats>> entry : statsByShard.entrySet()) {             entry.getKey().writeTo(out).             out.writeVInt(entry.getValue().size()).             for (IndexShardStats indexShardStats : entry.getValue()) {                 indexShardStats.writeTo(out).             }         }     } }
false;public;2;41;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     final String level = params.param("level", "node").     final boolean isLevelValid = "indices".equalsIgnoreCase(level) || "node".equalsIgnoreCase(level) || "shards".equalsIgnoreCase(level).     if (!isLevelValid) {         throw new IllegalArgumentException("level parameter must be one of [indices] or [node] or [shards] but was [" + level + "]").     }     // "node" level     builder.startObject(Fields.INDICES).     stats.toXContent(builder, params).     if ("indices".equals(level)) {         Map<Index, CommonStats> indexStats = createStatsByIndex().         builder.startObject(Fields.INDICES).         for (Map.Entry<Index, CommonStats> entry : indexStats.entrySet()) {             builder.startObject(entry.getKey().getName()).             entry.getValue().toXContent(builder, params).             builder.endObject().         }         builder.endObject().     } else if ("shards".equals(level)) {         builder.startObject("shards").         for (Map.Entry<Index, List<IndexShardStats>> entry : statsByShard.entrySet()) {             builder.startArray(entry.getKey().getName()).             for (IndexShardStats indexShardStats : entry.getValue()) {                 builder.startObject().startObject(String.valueOf(indexShardStats.getShardId().getId())).                 for (ShardStats shardStats : indexShardStats.getShards()) {                     shardStats.toXContent(builder, params).                 }                 builder.endObject().endObject().             }             builder.endArray().         }         builder.endObject().     }     builder.endObject().     return builder. }
false;private;0;16;;private Map<Index, CommonStats> createStatsByIndex() {     Map<Index, CommonStats> statsMap = new HashMap<>().     for (Map.Entry<Index, List<IndexShardStats>> entry : statsByShard.entrySet()) {         if (!statsMap.containsKey(entry.getKey())) {             statsMap.put(entry.getKey(), new CommonStats()).         }         for (IndexShardStats indexShardStats : entry.getValue()) {             for (ShardStats shardStats : indexShardStats.getShards()) {                 statsMap.get(entry.getKey()).add(shardStats.getStats()).             }         }     }     return statsMap. }
