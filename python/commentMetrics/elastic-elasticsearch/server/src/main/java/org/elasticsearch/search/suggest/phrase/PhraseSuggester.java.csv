commented;modifiers;parameterAmount;loc;comment;code
true;public;4;77;/*      * More Ideas:      *   - add ability to find whitespace problems -> we can build a poor mans decompounder with our index based on a automaton?      *   - add ability to build different error models maybe based on a confusion matrix?      *   - try to combine a token with its subsequent token to find / detect word splits (optional)      *      - for this to work we need some way to defined the position length of a candidate      *   - phonetic filters could be interesting here too for candidate selection      */ ;/*      * More Ideas:      *   - add ability to find whitespace problems -> we can build a poor mans decompounder with our index based on a automaton?      *   - add ability to build different error models maybe based on a confusion matrix?      *   - try to combine a token with its subsequent token to find / detect word splits (optional)      *      - for this to work we need some way to defined the position length of a candidate      *   - phonetic filters could be interesting here too for candidate selection      */ @Override public Suggestion<? extends Entry<? extends Option>> innerExecute(String name, PhraseSuggestionContext suggestion, IndexSearcher searcher, CharsRefBuilder spare) throws IOException {     double realWordErrorLikelihood = suggestion.realworldErrorLikelihood().     final PhraseSuggestion response = new PhraseSuggestion(name, suggestion.getSize()).     final IndexReader indexReader = searcher.getIndexReader().     List<PhraseSuggestionContext.DirectCandidateGenerator> generators = suggestion.generators().     final int numGenerators = generators.size().     final List<CandidateGenerator> gens = new ArrayList<>(generators.size()).     for (int i = 0. i < numGenerators. i++) {         PhraseSuggestionContext.DirectCandidateGenerator generator = generators.get(i).         DirectSpellChecker directSpellChecker = generator.createDirectSpellChecker().         Terms terms = MultiTerms.getTerms(indexReader, generator.field()).         if (terms != null) {             gens.add(new DirectCandidateGenerator(directSpellChecker, generator.field(), generator.suggestMode(), indexReader, realWordErrorLikelihood, generator.size(), generator.preFilter(), generator.postFilter(), terms)).         }     }     final String suggestField = suggestion.getField().     final Terms suggestTerms = MultiTerms.getTerms(indexReader, suggestField).     if (gens.size() > 0 && suggestTerms != null) {         final NoisyChannelSpellChecker checker = new NoisyChannelSpellChecker(realWordErrorLikelihood, suggestion.getRequireUnigram(), suggestion.getTokenLimit()).         final BytesRef separator = suggestion.separator().         WordScorer wordScorer = suggestion.model().newScorer(indexReader, suggestTerms, suggestField, realWordErrorLikelihood, separator).         Result checkerResult.         try (TokenStream stream = checker.tokenStream(suggestion.getAnalyzer(), suggestion.getText(), spare, suggestion.getField())) {             checkerResult = checker.getCorrections(stream, new MultiCandidateGeneratorWrapper(suggestion.getShardSize(), gens.toArray(new CandidateGenerator[gens.size()])), suggestion.maxErrors(), suggestion.getShardSize(), wordScorer, suggestion.confidence(), suggestion.gramSize()).         }         PhraseSuggestion.Entry resultEntry = buildResultEntry(suggestion, spare, checkerResult.cutoffScore).         response.addTerm(resultEntry).         final BytesRefBuilder byteSpare = new BytesRefBuilder().         final TemplateScript.Factory scriptFactory = suggestion.getCollateQueryScript().         final boolean collatePrune = (scriptFactory != null) && suggestion.collatePrune().         for (int i = 0. i < checkerResult.corrections.length. i++) {             Correction correction = checkerResult.corrections[i].             spare.copyUTF8Bytes(correction.join(SEPARATOR, byteSpare, null, null)).             boolean collateMatch = true.             if (scriptFactory != null) {                 // Checks if the template query collateScript yields any documents                 // from the index for a correction, collateMatch is updated                 final Map<String, Object> vars = suggestion.getCollateScriptParams().                 vars.put(SUGGESTION_TEMPLATE_VAR_NAME, spare.toString()).                 QueryShardContext shardContext = suggestion.getShardContext().                 final String querySource = scriptFactory.newInstance(vars).execute().                 try (XContentParser parser = XContentFactory.xContent(querySource).createParser(shardContext.getXContentRegistry(), LoggingDeprecationHandler.INSTANCE, querySource)) {                     QueryBuilder innerQueryBuilder = AbstractQueryBuilder.parseInnerQueryBuilder(parser).                     final ParsedQuery parsedQuery = shardContext.toQuery(innerQueryBuilder).                     collateMatch = Lucene.exists(searcher, parsedQuery.query()).                 }             }             if (!collateMatch && !collatePrune) {                 continue.             }             Text phrase = new Text(spare.toString()).             Text highlighted = null.             if (suggestion.getPreTag() != null) {                 spare.copyUTF8Bytes(correction.join(SEPARATOR, byteSpare, suggestion.getPreTag(), suggestion.getPostTag())).                 highlighted = new Text(spare.toString()).             }             if (collatePrune) {                 resultEntry.addOption(new PhraseSuggestion.Entry.Option(phrase, highlighted, (float) (correction.score), collateMatch)).             } else {                 resultEntry.addOption(new PhraseSuggestion.Entry.Option(phrase, highlighted, (float) (correction.score))).             }         }     } else {         response.addTerm(buildResultEntry(suggestion, spare, Double.MIN_VALUE)).     }     return response. }
false;private,static;3;4;;private static PhraseSuggestion.Entry buildResultEntry(SuggestionContext suggestion, CharsRefBuilder spare, double cutoffScore) {     spare.copyUTF8Bytes(suggestion.getText()).     return new PhraseSuggestion.Entry(new Text(spare.toString()), 0, spare.length(), cutoffScore). }
