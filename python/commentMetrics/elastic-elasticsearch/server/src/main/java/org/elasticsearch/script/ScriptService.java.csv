commented;modifiers;parameterAmount;loc;comment;code
false;;1;4;;void registerClusterSettingsListeners(ClusterSettings clusterSettings) {     clusterSettings.addSettingsUpdateConsumer(SCRIPT_MAX_SIZE_IN_BYTES, this::setMaxSizeInBytes).     clusterSettings.addSettingsUpdateConsumer(SCRIPT_MAX_COMPILATIONS_RATE, this::setMaxCompilationRate). }
false;public;0;4;;@Override public void close() throws IOException {     IOUtils.close(engines.values()). }
false;private;1;7;;private ScriptEngine getEngine(String lang) {     ScriptEngine scriptEngine = engines.get(lang).     if (scriptEngine == null) {         throw new IllegalArgumentException("script_lang not supported [" + lang + "]").     }     return scriptEngine. }
true;;1;11;/**  * Changes the maximum number of bytes a script's source is allowed to have.  * @param newMaxSizeInBytes The new maximum number of bytes.  */ ;/**  * Changes the maximum number of bytes a script's source is allowed to have.  * @param newMaxSizeInBytes The new maximum number of bytes.  */ void setMaxSizeInBytes(int newMaxSizeInBytes) {     for (Map.Entry<String, StoredScriptSource> source : getScriptsFromClusterState().entrySet()) {         if (source.getValue().getSource().getBytes(StandardCharsets.UTF_8).length > newMaxSizeInBytes) {             throw new IllegalArgumentException("script.max_size_in_bytes cannot be set to [" + newMaxSizeInBytes + "], " + "stored script [" + source.getKey() + "] exceeds the new value with a size of " + "[" + source.getValue().getSource().getBytes(StandardCharsets.UTF_8).length + "]").         }     }     maxSizeInBytes = newMaxSizeInBytes. }
true;;1;6;/**  * This configures the maximum script compilations per five minute window.  *  * @param newRate the new expected maximum number of compilations per five minute window  */ ;/**  * This configures the maximum script compilations per five minute window.  *  * @param newRate the new expected maximum number of compilations per five minute window  */ void setMaxCompilationRate(Tuple<Integer, TimeValue> newRate) {     this.rate = newRate.     // Reset the counter to allow new compilations     this.scriptsPerTimeWindow = rate.v1().     this.compilesAllowedPerNano = ((double) rate.v1()) / newRate.v2().nanos(). }
true;public;2;89;/**  * Compiles a script using the given context.  *  * @return a compiled script which may be used to construct instances of a script for the given context  */ ;/**  * Compiles a script using the given context.  *  * @return a compiled script which may be used to construct instances of a script for the given context  */ public <FactoryType> FactoryType compile(Script script, ScriptContext<FactoryType> context) {     Objects.requireNonNull(script).     Objects.requireNonNull(context).     ScriptType type = script.getType().     String lang = script.getLang().     String idOrCode = script.getIdOrCode().     Map<String, String> options = script.getOptions().     String id = idOrCode.     if (type == ScriptType.STORED) {         // * lang and options will both be null when looking up a stored script,         // so we must get the source to retrieve them before checking if the         // context is supported         // * a stored script must be pulled from the cluster state every time in case         // the script has been updated since the last compilation         StoredScriptSource source = getScriptFromClusterState(id).         lang = source.getLang().         idOrCode = source.getSource().         options = source.getOptions().     }     ScriptEngine scriptEngine = getEngine(lang).     if (isTypeEnabled(type) == false) {         throw new IllegalArgumentException("cannot execute [" + type + "] scripts").     }     if (contexts.containsKey(context.name) == false) {         throw new IllegalArgumentException("script context [" + context.name + "] not supported").     }     if (isContextEnabled(context) == false) {         throw new IllegalArgumentException("cannot execute scripts using [" + context.name + "] context").     }     if (type == ScriptType.INLINE) {         if (idOrCode.getBytes(StandardCharsets.UTF_8).length > maxSizeInBytes) {             throw new IllegalArgumentException("exceeded max allowed inline script size in bytes [" + maxSizeInBytes + "] " + "with size [" + idOrCode.getBytes(StandardCharsets.UTF_8).length + "] for script [" + idOrCode + "]").         }     }     if (logger.isTraceEnabled()) {         logger.trace("compiling lang: [{}] type: [{}] script: {}", lang, type, idOrCode).     }     CacheKey cacheKey = new CacheKey(lang, idOrCode, context.name, options).     Object compiledScript = cache.get(cacheKey).     if (compiledScript != null) {         return context.factoryClazz.cast(compiledScript).     }     // Synchronize so we don't compile scripts many times during multiple shards all compiling a script     synchronized (this) {         // Retrieve it again in case it has been put by a different thread         compiledScript = cache.get(cacheKey).         if (compiledScript == null) {             try {                 // for the inline case, then its anonymous: null.                 if (logger.isTraceEnabled()) {                     logger.trace("compiling script, type: [{}], lang: [{}], options: [{}]", type, lang, options).                 }                 // Check whether too many compilations have happened                 checkCompilationLimit().                 compiledScript = scriptEngine.compile(id, idOrCode, context, options).             } catch (ScriptException good) {                 // its already good                 throw good.             } catch (Exception exception) {                 throw new GeneralScriptException("Failed to compile " + type + " script [" + id + "] using lang [" + lang + "]", exception).             }             // Since the cache key is the script content itself we don't need to             // invalidate/check the cache if an indexed script changes.             scriptMetrics.onCompilation().             cache.put(cacheKey, compiledScript).         }         return context.factoryClazz.cast(compiledScript).     } }
true;;0;24;/**  * Check whether there have been too many compilations within the last minute, throwing a circuit breaking exception if so.  * This is a variant of the token bucket algorithm: https://en.wikipedia.org/wiki/Token_bucket  *  * It can be thought of as a bucket with water, every time the bucket is checked, water is added proportional to the amount of time that  * elapsed since the last time it was checked. If there is enough water, some is removed and the request is allowed. If there is not  * enough water the request is denied. Just like a normal bucket, if water is added that overflows the bucket, the extra water/capacity  * is discarded - there can never be more water in the bucket than the size of the bucket.  */ ;/**  * Check whether there have been too many compilations within the last minute, throwing a circuit breaking exception if so.  * This is a variant of the token bucket algorithm: https://en.wikipedia.org/wiki/Token_bucket  *  * It can be thought of as a bucket with water, every time the bucket is checked, water is added proportional to the amount of time that  * elapsed since the last time it was checked. If there is enough water, some is removed and the request is allowed. If there is not  * enough water the request is denied. Just like a normal bucket, if water is added that overflows the bucket, the extra water/capacity  * is discarded - there can never be more water in the bucket than the size of the bucket.  */ void checkCompilationLimit() {     long now = System.nanoTime().     long timePassed = now - lastInlineCompileTime.     lastInlineCompileTime = now.     scriptsPerTimeWindow += (timePassed) * compilesAllowedPerNano.     // It's been over the time limit anyway, readjust the bucket to be level     if (scriptsPerTimeWindow > rate.v1()) {         scriptsPerTimeWindow = rate.v1().     }     // If there is enough tokens in the bucket, allow the request and decrease the tokens by 1     if (scriptsPerTimeWindow >= 1) {         scriptsPerTimeWindow -= 1.0.     } else {         scriptMetrics.onCompilationLimit().         // Otherwise reject the request         throw new CircuitBreakingException("[script] Too many dynamic script compilations within, max: [" + rate.v1() + "/" + rate.v2() + "]. please use indexed, or scripts with parameters instead. " + "this limit can be changed by the [" + SCRIPT_MAX_COMPILATIONS_RATE.getKey() + "] setting", CircuitBreaker.Durability.TRANSIENT).     } }
false;public;1;4;;public boolean isLangSupported(String lang) {     Objects.requireNonNull(lang).     return engines.containsKey(lang). }
false;public;1;3;;public boolean isTypeEnabled(ScriptType scriptType) {     return typesAllowed == null || typesAllowed.contains(scriptType.getName()). }
false;public;1;3;;public boolean isContextEnabled(ScriptContext scriptContext) {     return contextsAllowed == null || contextsAllowed.contains(scriptContext.name). }
false;public;0;3;;public boolean isAnyContextEnabled() {     return contextsAllowed == null || contextsAllowed.isEmpty() == false. }
false;;0;13;;Map<String, StoredScriptSource> getScriptsFromClusterState() {     if (clusterState == null) {         return Collections.emptyMap().     }     ScriptMetaData scriptMetadata = clusterState.metaData().custom(ScriptMetaData.TYPE).     if (scriptMetadata == null) {         return Collections.emptyMap().     }     return scriptMetadata.getStoredScripts(). }
false;;1;15;;StoredScriptSource getScriptFromClusterState(String id) {     ScriptMetaData scriptMetadata = clusterState.metaData().custom(ScriptMetaData.TYPE).     if (scriptMetadata == null) {         throw new ResourceNotFoundException("unable to find script [" + id + "] in cluster state").     }     StoredScriptSource source = scriptMetadata.getStoredScript(id).     if (source == null) {         throw new ResourceNotFoundException("unable to find script [" + id + "] in cluster state").     }     return source. }
false;protected;1;4;;@Override protected AcknowledgedResponse newResponse(boolean acknowledged) {     return new AcknowledgedResponse(acknowledged). }
false;public;1;8;;@Override public ClusterState execute(ClusterState currentState) throws Exception {     ScriptMetaData smd = currentState.metaData().custom(ScriptMetaData.TYPE).     smd = ScriptMetaData.putStoredScript(smd, request.id(), source).     MetaData.Builder mdb = MetaData.builder(currentState.getMetaData()).putCustom(ScriptMetaData.TYPE, smd).     return ClusterState.builder(currentState).metaData(mdb).build(). }
false;public;3;53;;public void putStoredScript(ClusterService clusterService, PutStoredScriptRequest request, ActionListener<AcknowledgedResponse> listener) {     if (request.content().length() > maxSizeInBytes) {         throw new IllegalArgumentException("exceeded max allowed stored script size in bytes [" + maxSizeInBytes + "] with size [" + request.content().length() + "] for script [" + request.id() + "]").     }     StoredScriptSource source = request.source().     if (isLangSupported(source.getLang()) == false) {         throw new IllegalArgumentException("unable to put stored script with unsupported lang [" + source.getLang() + "]").     }     try {         ScriptEngine scriptEngine = getEngine(source.getLang()).         if (isTypeEnabled(ScriptType.STORED) == false) {             throw new IllegalArgumentException("cannot put [" + ScriptType.STORED + "] script, [" + ScriptType.STORED + "] scripts are not enabled").         } else if (isAnyContextEnabled() == false) {             throw new IllegalArgumentException("cannot put [" + ScriptType.STORED + "] script, no script contexts are enabled").         } else if (request.context() != null) {             ScriptContext<?> context = contexts.get(request.context()).             if (context == null) {                 throw new IllegalArgumentException("Unknown context [" + request.context() + "]").             }             scriptEngine.compile(request.id(), source.getSource(), context, Collections.emptyMap()).         }     } catch (ScriptException good) {         throw good.     } catch (Exception exception) {         throw new IllegalArgumentException("failed to parse/compile stored script [" + request.id() + "]", exception).     }     clusterService.submitStateUpdateTask("put-script-" + request.id(), new AckedClusterStateUpdateTask<AcknowledgedResponse>(request, listener) {          @Override         protected AcknowledgedResponse newResponse(boolean acknowledged) {             return new AcknowledgedResponse(acknowledged).         }          @Override         public ClusterState execute(ClusterState currentState) throws Exception {             ScriptMetaData smd = currentState.metaData().custom(ScriptMetaData.TYPE).             smd = ScriptMetaData.putStoredScript(smd, request.id(), source).             MetaData.Builder mdb = MetaData.builder(currentState.getMetaData()).putCustom(ScriptMetaData.TYPE, smd).             return ClusterState.builder(currentState).metaData(mdb).build().         }     }). }
false;protected;1;4;;@Override protected AcknowledgedResponse newResponse(boolean acknowledged) {     return new AcknowledgedResponse(acknowledged). }
false;public;1;8;;@Override public ClusterState execute(ClusterState currentState) throws Exception {     ScriptMetaData smd = currentState.metaData().custom(ScriptMetaData.TYPE).     smd = ScriptMetaData.deleteStoredScript(smd, request.id()).     MetaData.Builder mdb = MetaData.builder(currentState.getMetaData()).putCustom(ScriptMetaData.TYPE, smd).     return ClusterState.builder(currentState).metaData(mdb).build(). }
false;public;3;20;;public void deleteStoredScript(ClusterService clusterService, DeleteStoredScriptRequest request, ActionListener<AcknowledgedResponse> listener) {     clusterService.submitStateUpdateTask("delete-script-" + request.id(), new AckedClusterStateUpdateTask<AcknowledgedResponse>(request, listener) {          @Override         protected AcknowledgedResponse newResponse(boolean acknowledged) {             return new AcknowledgedResponse(acknowledged).         }          @Override         public ClusterState execute(ClusterState currentState) throws Exception {             ScriptMetaData smd = currentState.metaData().custom(ScriptMetaData.TYPE).             smd = ScriptMetaData.deleteStoredScript(smd, request.id()).             MetaData.Builder mdb = MetaData.builder(currentState.getMetaData()).putCustom(ScriptMetaData.TYPE, smd).             return ClusterState.builder(currentState).metaData(mdb).build().         }     }). }
false;public;2;9;;public StoredScriptSource getStoredScript(ClusterState state, GetStoredScriptRequest request) {     ScriptMetaData scriptMetadata = state.metaData().custom(ScriptMetaData.TYPE).     if (scriptMetadata != null) {         return scriptMetadata.getStoredScript(request.id()).     } else {         return null.     } }
false;public;0;3;;public ScriptStats stats() {     return scriptMetrics.stats(). }
false;public;1;4;;@Override public void applyClusterState(ClusterChangedEvent event) {     clusterState = event.state(). }
false;public;1;7;;@Override public void onRemoval(RemovalNotification<CacheKey, Object> notification) {     if (logger.isDebugEnabled()) {         logger.debug("removed {} from cache, reason: {}", notification.getValue(), notification.getRemovalReason()).     }     scriptMetrics.onCacheEviction(). }
false;public;1;10;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     CacheKey cacheKey = (CacheKey) o.     return Objects.equals(lang, cacheKey.lang) && Objects.equals(idOrCode, cacheKey.idOrCode) && Objects.equals(context, cacheKey.context) && Objects.equals(options, cacheKey.options). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(lang, idOrCode, context, options). }
