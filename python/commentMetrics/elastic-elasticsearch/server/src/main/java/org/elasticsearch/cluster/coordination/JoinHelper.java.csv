commented;modifiers;parameterAmount;loc;comment;code
false;public;2;18;;@Override public ClusterTasksResult<JoinTaskExecutor.Task> execute(ClusterState currentState, List<JoinTaskExecutor.Task> joiningTasks) throws Exception {     // This is called when preparing the next cluster state for publication. There is no guarantee that the term we see here is     // the term under which this state will eventually be published: the current term may be increased after this check due to     // some other activity. That the term is correct is, however, checked properly during publication, so it is sufficient to     // check it here on a best-effort basis. This is fine because a concurrent change indicates the existence of another leader     // in a higher term which will cause this node to stand down.     final long currentTerm = currentTermSupplier.getAsLong().     if (currentState.term() != currentTerm) {         final CoordinationMetaData coordinationMetaData = CoordinationMetaData.builder(currentState.coordinationMetaData()).term(currentTerm).build().         final MetaData metaData = MetaData.builder(currentState.metaData()).coordinationMetaData(coordinationMetaData).build().         currentState = ClusterState.builder(currentState).metaData(metaData).build().     }     return super.execute(currentState, joiningTasks). }
false;public;0;8;;@Override public void onSuccess() {     try {         channel.sendResponse(Empty.INSTANCE).     } catch (IOException e) {         onFailure(e).     } }
false;public;1;9;;@Override public void onFailure(Exception e) {     try {         channel.sendResponse(e).     } catch (Exception inner) {         inner.addSuppressed(e).         logger.warn("failed to send back failure on join request", inner).     } }
false;public;0;4;;@Override public String toString() {     return "JoinCallback{request=" + request + "}". }
false;private;2;28;;private JoinCallback transportJoinCallback(TransportRequest request, TransportChannel channel) {     return new JoinCallback() {          @Override         public void onSuccess() {             try {                 channel.sendResponse(Empty.INSTANCE).             } catch (IOException e) {                 onFailure(e).             }         }          @Override         public void onFailure(Exception e) {             try {                 channel.sendResponse(e).             } catch (Exception inner) {                 inner.addSuppressed(e).                 logger.warn("failed to send back failure on join request", inner).             }         }          @Override         public String toString() {             return "JoinCallback{request=" + request + "}".         }     }. }
false;public;2;4;;public void sendJoinRequest(DiscoveryNode destination, Optional<Join> optionalJoin) {     sendJoinRequest(destination, optionalJoin, () -> {     }). }
false;public;1;4;;@Override public Empty read(StreamInput in) {     return Empty.INSTANCE. }
false;public;1;6;;@Override public void handleResponse(Empty response) {     pendingOutgoingJoins.remove(dedupKey).     logger.debug("successfully joined {} with {}", destination, joinRequest).     onCompletion.run(). }
false;public;1;6;;@Override public void handleException(TransportException exp) {     pendingOutgoingJoins.remove(dedupKey).     logger.info(() -> new ParameterizedMessage("failed to join {} with {}", destination, joinRequest), exp).     onCompletion.run(). }
false;public;0;4;;@Override public String executor() {     return Names.SAME. }
false;public;3;46;;public void sendJoinRequest(DiscoveryNode destination, Optional<Join> optionalJoin, Runnable onCompletion) {     assert destination.isMasterNode() : "trying to join master-ineligible " + destination.     final JoinRequest joinRequest = new JoinRequest(transportService.getLocalNode(), optionalJoin).     final Tuple<DiscoveryNode, JoinRequest> dedupKey = Tuple.tuple(destination, joinRequest).     if (pendingOutgoingJoins.add(dedupKey)) {         logger.debug("attempting to join {} with {}", destination, joinRequest).         final String actionName.         final TransportRequest transportRequest.         if (Coordinator.isZen1Node(destination)) {             actionName = MembershipAction.DISCOVERY_JOIN_ACTION_NAME.             transportRequest = new MembershipAction.JoinRequest(transportService.getLocalNode()).         } else {             actionName = JOIN_ACTION_NAME.             transportRequest = joinRequest.         }         transportService.sendRequest(destination, actionName, transportRequest, TransportRequestOptions.builder().withTimeout(joinTimeout).build(), new TransportResponseHandler<Empty>() {              @Override             public Empty read(StreamInput in) {                 return Empty.INSTANCE.             }              @Override             public void handleResponse(Empty response) {                 pendingOutgoingJoins.remove(dedupKey).                 logger.debug("successfully joined {} with {}", destination, joinRequest).                 onCompletion.run().             }              @Override             public void handleException(TransportException exp) {                 pendingOutgoingJoins.remove(dedupKey).                 logger.info(() -> new ParameterizedMessage("failed to join {} with {}", destination, joinRequest), exp).                 onCompletion.run().             }              @Override             public String executor() {                 return Names.SAME.             }         }).     } else {         logger.debug("already attempting to join {} with request {}, not sending request", destination, joinRequest).     } }
false;public;1;4;;@Override public Empty read(StreamInput in) {     return Empty.INSTANCE. }
false;public;1;4;;@Override public void handleResponse(Empty response) {     logger.debug("successful response to {} from {}", startJoinRequest, destination). }
false;public;1;4;;@Override public void handleException(TransportException exp) {     logger.debug(new ParameterizedMessage("failure in response to {} from {}", startJoinRequest, destination), exp). }
false;public;0;4;;@Override public String executor() {     return ThreadPool.Names.SAME. }
false;public;2;26;;public void sendStartJoinRequest(final StartJoinRequest startJoinRequest, final DiscoveryNode destination) {     assert startJoinRequest.getSourceNode().isMasterNode() : "sending start-join request for master-ineligible " + startJoinRequest.getSourceNode().     transportService.sendRequest(destination, START_JOIN_ACTION_NAME, startJoinRequest, new TransportResponseHandler<Empty>() {          @Override         public Empty read(StreamInput in) {             return Empty.INSTANCE.         }          @Override         public void handleResponse(Empty response) {             logger.debug("successful response to {} from {}", startJoinRequest, destination).         }          @Override         public void handleException(TransportException exp) {             logger.debug(new ParameterizedMessage("failure in response to {} from {}", startJoinRequest, destination), exp).         }          @Override         public String executor() {             return ThreadPool.Names.SAME.         }     }). }
false;public;1;4;;@Override public void handleResponse(TransportResponse.Empty response) {     listener.onResponse(response). }
false;public;1;4;;@Override public void handleException(TransportException exp) {     listener.onFailure(exp). }
false;public;3;22;;public void sendValidateJoinRequest(DiscoveryNode node, ClusterState state, ActionListener<TransportResponse.Empty> listener) {     final String actionName.     if (Coordinator.isZen1Node(node)) {         actionName = MembershipAction.DISCOVERY_JOIN_VALIDATE_ACTION_NAME.     } else {         actionName = VALIDATE_JOIN_ACTION_NAME.     }     transportService.sendRequest(node, actionName, new MembershipAction.ValidateJoinRequest(state), TransportRequestOptions.builder().withTimeout(joinTimeout).build(), new EmptyTransportResponseHandler(ThreadPool.Names.GENERIC) {          @Override         public void handleResponse(TransportResponse.Empty response) {             listener.onResponse(response).         }          @Override         public void handleException(TransportException exp) {             listener.onFailure(exp).         }     }). }
false;;0;1;;void onSuccess().
false;;1;1;;void onFailure(Exception e).
false;public;2;4;;@Override public void onFailure(String source, Exception e) {     joinCallback.onFailure(e). }
false;public;3;4;;@Override public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {     joinCallback.onSuccess(). }
false;public;0;4;;@Override public String toString() {     return "JoinTaskListener{task=" + task + "}". }
false;;2;1;;void handleJoinRequest(DiscoveryNode sender, JoinCallback joinCallback).
false;default;1;2;;default void close(Mode newMode) { }
false;public;2;6;;@Override public void handleJoinRequest(DiscoveryNode sender, JoinCallback joinCallback) {     final JoinTaskExecutor.Task task = new JoinTaskExecutor.Task(sender, "join existing leader").     masterService.submitStateUpdateTask("node-join", task, ClusterStateTaskConfig.build(Priority.URGENT), joinTaskExecutor, new JoinTaskListener(task, joinCallback)). }
false;public;0;4;;@Override public String toString() {     return "LeaderJoinAccumulator". }
false;public;2;5;;@Override public void handleJoinRequest(DiscoveryNode sender, JoinCallback joinCallback) {     assert false : "unexpected join from " + sender + " during initialisation".     joinCallback.onFailure(new CoordinationStateRejectedException("join target is not initialised yet")). }
false;public;0;4;;@Override public String toString() {     return "InitialJoinAccumulator". }
false;public;2;4;;@Override public void handleJoinRequest(DiscoveryNode sender, JoinCallback joinCallback) {     joinCallback.onFailure(new CoordinationStateRejectedException("join target is a follower")). }
false;public;0;4;;@Override public String toString() {     return "FollowerJoinAccumulator". }
false;public;2;8;;@Override public void handleJoinRequest(DiscoveryNode sender, JoinCallback joinCallback) {     assert closed == false : "CandidateJoinAccumulator closed".     JoinCallback prev = joinRequestAccumulator.put(sender, joinCallback).     if (prev != null) {         prev.onFailure(new CoordinationStateRejectedException("received a newer join from " + sender)).     } }
false;public;1;28;;@Override public void close(Mode newMode) {     assert closed == false : "CandidateJoinAccumulator closed".     closed = true.     if (newMode == Mode.LEADER) {         final Map<JoinTaskExecutor.Task, ClusterStateTaskListener> pendingAsTasks = new LinkedHashMap<>().         joinRequestAccumulator.forEach((key, value) -> {             final JoinTaskExecutor.Task task = new JoinTaskExecutor.Task(key, "elect leader").             pendingAsTasks.put(task, new JoinTaskListener(task, value)).         }).         final String stateUpdateSource = "elected-as-master ([" + pendingAsTasks.size() + "] nodes joined)".         pendingAsTasks.put(JoinTaskExecutor.newBecomeMasterTask(), (source, e) -> {         }).         pendingAsTasks.put(JoinTaskExecutor.newFinishElectionTask(), (source, e) -> {         }).         masterService.submitStateUpdateTasks(stateUpdateSource, pendingAsTasks, ClusterStateTaskConfig.build(Priority.URGENT), joinTaskExecutor).     } else {         assert newMode == Mode.FOLLOWER : newMode.         joinRequestAccumulator.values().forEach(joinCallback -> joinCallback.onFailure(new CoordinationStateRejectedException("became follower"))).     } // CandidateJoinAccumulator is only closed when becoming leader or follower, otherwise it accumulates all joins received // regardless of term. }
false;public;0;5;;@Override public String toString() {     return "CandidateJoinAccumulator{" + joinRequestAccumulator.keySet() + ", closed=" + closed + '}'. }
