commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;4;;@Override protected void writeTermTo(StreamOutput out) throws IOException {     out.writeDouble(term). }
false;public;0;4;;@Override public String getKeyAsString() {     return format.format(term).toString(). }
false;public;0;4;;@Override public Object getKey() {     return term. }
false;public;0;4;;@Override public Number getKeyAsNumber() {     return term. }
false;public;1;4;;@Override public int compareKey(Bucket other) {     return Double.compare(term, other.term). }
false;;3;4;;@Override Bucket newBucket(long docCount, InternalAggregations aggs, long docCountError) {     return new Bucket(term, docCount, aggs, showDocCountError, docCountError, format). }
false;protected,final;1;8;;@Override protected final XContentBuilder keyToXContent(XContentBuilder builder) throws IOException {     builder.field(CommonFields.KEY.getPreferredName(), term).     if (format != DocValueFormat.RAW) {         builder.field(CommonFields.KEY_AS_STRING.getPreferredName(), format.format(term).toString()).     }     return builder. }
false;public;1;4;;@Override public boolean equals(Object obj) {     return super.equals(obj) && Objects.equals(term, ((Bucket) obj).term). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(super.hashCode(), term). }
false;public;0;4;;@Override public String getWriteableName() {     return NAME. }
false;public;1;5;;@Override public DoubleTerms create(List<Bucket> buckets) {     return new DoubleTerms(name, order, requiredSize, minDocCount, this.pipelineAggregators(), metaData, format, shardSize, showTermDocCountError, otherDocCount, buckets, docCountError). }
false;public;2;5;;@Override public Bucket createBucket(InternalAggregations aggregations, Bucket prototype) {     return new Bucket(prototype.term, prototype.docCount, aggregations, prototype.showDocCountError, prototype.docCountError, prototype.format). }
false;protected;4;5;;@Override protected DoubleTerms create(String name, List<Bucket> buckets, long docCountError, long otherDocCount) {     return new DoubleTerms(name, order, requiredSize, minDocCount, pipelineAggregators(), getMetaData(), format, shardSize, showTermDocCountError, otherDocCount, buckets, docCountError). }
false;protected;1;4;;@Override protected Bucket[] createBucketsArray(int size) {     return new Bucket[size]. }
false;public;2;27;;@Override public InternalAggregation doReduce(List<InternalAggregation> aggregations, ReduceContext reduceContext) {     boolean promoteToDouble = false.     for (InternalAggregation agg : aggregations) {         if (agg instanceof LongTerms && ((LongTerms) agg).format == DocValueFormat.RAW) {             /*                  * this terms agg mixes longs and doubles, we must promote longs to doubles to make the internal aggs                  * compatible                  */             promoteToDouble = true.             break.         }     }     if (promoteToDouble == false) {         return super.doReduce(aggregations, reduceContext).     }     List<InternalAggregation> newAggs = new ArrayList<>(aggregations.size()).     for (InternalAggregation agg : aggregations) {         if (agg instanceof LongTerms) {             DoubleTerms dTerms = LongTerms.convertLongTermsToDouble((LongTerms) agg, format).             newAggs.add(dTerms).         } else {             newAggs.add(agg).         }     }     return newAggs.get(0).doReduce(newAggs, reduceContext). }
