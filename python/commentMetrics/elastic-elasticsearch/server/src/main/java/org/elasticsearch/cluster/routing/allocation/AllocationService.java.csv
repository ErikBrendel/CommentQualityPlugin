# id;timestamp;commentText;codeText;commentWords;codeWords
AllocationService -> private void resetFailedAllocationCounter(RoutingAllocation allocation);1524684173;Reset failed allocation counter for unassigned shards;private void resetFailedAllocationCounter(RoutingAllocation allocation) {_        final RoutingNodes.UnassignedShards.UnassignedIterator unassignedIterator = allocation.routingNodes().unassigned().iterator()__        while (unassignedIterator.hasNext()) {_            ShardRouting shardRouting = unassignedIterator.next()__            UnassignedInfo unassignedInfo = shardRouting.unassignedInfo()__            unassignedIterator.updateUnassigned(new UnassignedInfo(unassignedInfo.getNumFailedAllocations() > 0 ?_                UnassignedInfo.Reason.MANUAL_ALLOCATION : unassignedInfo.getReason(), unassignedInfo.getMessage(),_                unassignedInfo.getFailure(), 0, unassignedInfo.getUnassignedTimeInNanos(),_                unassignedInfo.getUnassignedTimeInMillis(), unassignedInfo.isDelayed(),_                unassignedInfo.getLastAllocationStatus()), shardRouting.recoverySource(), allocation.changes())__        }_    };reset,failed,allocation,counter,for,unassigned,shards;private,void,reset,failed,allocation,counter,routing,allocation,allocation,final,routing,nodes,unassigned,shards,unassigned,iterator,unassigned,iterator,allocation,routing,nodes,unassigned,iterator,while,unassigned,iterator,has,next,shard,routing,shard,routing,unassigned,iterator,next,unassigned,info,unassigned,info,shard,routing,unassigned,info,unassigned,iterator,update,unassigned,new,unassigned,info,unassigned,info,get,num,failed,allocations,0,unassigned,info,reason,unassigned,info,get,reason,unassigned,info,get,message,unassigned,info,get,failure,0,unassigned,info,get,unassigned,time,in,nanos,unassigned,info,get,unassigned,time,in,millis,unassigned,info,is,delayed,unassigned,info,get,last,allocation,status,shard,routing,recovery,source,allocation,changes
AllocationService -> private void resetFailedAllocationCounter(RoutingAllocation allocation);1525798022;Reset failed allocation counter for unassigned shards;private void resetFailedAllocationCounter(RoutingAllocation allocation) {_        final RoutingNodes.UnassignedShards.UnassignedIterator unassignedIterator = allocation.routingNodes().unassigned().iterator()__        while (unassignedIterator.hasNext()) {_            ShardRouting shardRouting = unassignedIterator.next()__            UnassignedInfo unassignedInfo = shardRouting.unassignedInfo()__            unassignedIterator.updateUnassigned(new UnassignedInfo(unassignedInfo.getNumFailedAllocations() > 0 ?_                UnassignedInfo.Reason.MANUAL_ALLOCATION : unassignedInfo.getReason(), unassignedInfo.getMessage(),_                unassignedInfo.getFailure(), 0, unassignedInfo.getUnassignedTimeInNanos(),_                unassignedInfo.getUnassignedTimeInMillis(), unassignedInfo.isDelayed(),_                unassignedInfo.getLastAllocationStatus()), shardRouting.recoverySource(), allocation.changes())__        }_    };reset,failed,allocation,counter,for,unassigned,shards;private,void,reset,failed,allocation,counter,routing,allocation,allocation,final,routing,nodes,unassigned,shards,unassigned,iterator,unassigned,iterator,allocation,routing,nodes,unassigned,iterator,while,unassigned,iterator,has,next,shard,routing,shard,routing,unassigned,iterator,next,unassigned,info,unassigned,info,shard,routing,unassigned,info,unassigned,iterator,update,unassigned,new,unassigned,info,unassigned,info,get,num,failed,allocations,0,unassigned,info,reason,unassigned,info,get,reason,unassigned,info,get,message,unassigned,info,get,failure,0,unassigned,info,get,unassigned,time,in,nanos,unassigned,info,get,unassigned,time,in,millis,unassigned,info,is,delayed,unassigned,info,get,last,allocation,status,shard,routing,recovery,source,allocation,changes
AllocationService -> private void resetFailedAllocationCounter(RoutingAllocation allocation);1526374795;Reset failed allocation counter for unassigned shards;private void resetFailedAllocationCounter(RoutingAllocation allocation) {_        final RoutingNodes.UnassignedShards.UnassignedIterator unassignedIterator = allocation.routingNodes().unassigned().iterator()__        while (unassignedIterator.hasNext()) {_            ShardRouting shardRouting = unassignedIterator.next()__            UnassignedInfo unassignedInfo = shardRouting.unassignedInfo()__            unassignedIterator.updateUnassigned(new UnassignedInfo(unassignedInfo.getNumFailedAllocations() > 0 ?_                UnassignedInfo.Reason.MANUAL_ALLOCATION : unassignedInfo.getReason(), unassignedInfo.getMessage(),_                unassignedInfo.getFailure(), 0, unassignedInfo.getUnassignedTimeInNanos(),_                unassignedInfo.getUnassignedTimeInMillis(), unassignedInfo.isDelayed(),_                unassignedInfo.getLastAllocationStatus()), shardRouting.recoverySource(), allocation.changes())__        }_    };reset,failed,allocation,counter,for,unassigned,shards;private,void,reset,failed,allocation,counter,routing,allocation,allocation,final,routing,nodes,unassigned,shards,unassigned,iterator,unassigned,iterator,allocation,routing,nodes,unassigned,iterator,while,unassigned,iterator,has,next,shard,routing,shard,routing,unassigned,iterator,next,unassigned,info,unassigned,info,shard,routing,unassigned,info,unassigned,iterator,update,unassigned,new,unassigned,info,unassigned,info,get,num,failed,allocations,0,unassigned,info,reason,unassigned,info,get,reason,unassigned,info,get,message,unassigned,info,get,failure,0,unassigned,info,get,unassigned,time,in,nanos,unassigned,info,get,unassigned,time,in,millis,unassigned,info,is,delayed,unassigned,info,get,last,allocation,status,shard,routing,recovery,source,allocation,changes
AllocationService -> private void resetFailedAllocationCounter(RoutingAllocation allocation);1539723533;Reset failed allocation counter for unassigned shards;private void resetFailedAllocationCounter(RoutingAllocation allocation) {_        final RoutingNodes.UnassignedShards.UnassignedIterator unassignedIterator = allocation.routingNodes().unassigned().iterator()__        while (unassignedIterator.hasNext()) {_            ShardRouting shardRouting = unassignedIterator.next()__            UnassignedInfo unassignedInfo = shardRouting.unassignedInfo()__            unassignedIterator.updateUnassigned(new UnassignedInfo(unassignedInfo.getNumFailedAllocations() > 0 ?_                UnassignedInfo.Reason.MANUAL_ALLOCATION : unassignedInfo.getReason(), unassignedInfo.getMessage(),_                unassignedInfo.getFailure(), 0, unassignedInfo.getUnassignedTimeInNanos(),_                unassignedInfo.getUnassignedTimeInMillis(), unassignedInfo.isDelayed(),_                unassignedInfo.getLastAllocationStatus()), shardRouting.recoverySource(), allocation.changes())__        }_    };reset,failed,allocation,counter,for,unassigned,shards;private,void,reset,failed,allocation,counter,routing,allocation,allocation,final,routing,nodes,unassigned,shards,unassigned,iterator,unassigned,iterator,allocation,routing,nodes,unassigned,iterator,while,unassigned,iterator,has,next,shard,routing,shard,routing,unassigned,iterator,next,unassigned,info,unassigned,info,shard,routing,unassigned,info,unassigned,iterator,update,unassigned,new,unassigned,info,unassigned,info,get,num,failed,allocations,0,unassigned,info,reason,unassigned,info,get,reason,unassigned,info,get,message,unassigned,info,get,failure,0,unassigned,info,get,unassigned,time,in,nanos,unassigned,info,get,unassigned,time,in,millis,unassigned,info,is,delayed,unassigned,info,get,last,allocation,status,shard,routing,recovery,source,allocation,changes
AllocationService -> private void resetFailedAllocationCounter(RoutingAllocation allocation);1541092382;Reset failed allocation counter for unassigned shards;private void resetFailedAllocationCounter(RoutingAllocation allocation) {_        final RoutingNodes.UnassignedShards.UnassignedIterator unassignedIterator = allocation.routingNodes().unassigned().iterator()__        while (unassignedIterator.hasNext()) {_            ShardRouting shardRouting = unassignedIterator.next()__            UnassignedInfo unassignedInfo = shardRouting.unassignedInfo()__            unassignedIterator.updateUnassigned(new UnassignedInfo(unassignedInfo.getNumFailedAllocations() > 0 ?_                UnassignedInfo.Reason.MANUAL_ALLOCATION : unassignedInfo.getReason(), unassignedInfo.getMessage(),_                unassignedInfo.getFailure(), 0, unassignedInfo.getUnassignedTimeInNanos(),_                unassignedInfo.getUnassignedTimeInMillis(), unassignedInfo.isDelayed(),_                unassignedInfo.getLastAllocationStatus()), shardRouting.recoverySource(), allocation.changes())__        }_    };reset,failed,allocation,counter,for,unassigned,shards;private,void,reset,failed,allocation,counter,routing,allocation,allocation,final,routing,nodes,unassigned,shards,unassigned,iterator,unassigned,iterator,allocation,routing,nodes,unassigned,iterator,while,unassigned,iterator,has,next,shard,routing,shard,routing,unassigned,iterator,next,unassigned,info,unassigned,info,shard,routing,unassigned,info,unassigned,iterator,update,unassigned,new,unassigned,info,unassigned,info,get,num,failed,allocations,0,unassigned,info,reason,unassigned,info,get,reason,unassigned,info,get,message,unassigned,info,get,failure,0,unassigned,info,get,unassigned,time,in,nanos,unassigned,info,get,unassigned,time,in,millis,unassigned,info,is,delayed,unassigned,info,get,last,allocation,status,shard,routing,recovery,source,allocation,changes
AllocationService -> private void resetFailedAllocationCounter(RoutingAllocation allocation);1542402632;Reset failed allocation counter for unassigned shards;private void resetFailedAllocationCounter(RoutingAllocation allocation) {_        final RoutingNodes.UnassignedShards.UnassignedIterator unassignedIterator = allocation.routingNodes().unassigned().iterator()__        while (unassignedIterator.hasNext()) {_            ShardRouting shardRouting = unassignedIterator.next()__            UnassignedInfo unassignedInfo = shardRouting.unassignedInfo()__            unassignedIterator.updateUnassigned(new UnassignedInfo(unassignedInfo.getNumFailedAllocations() > 0 ?_                UnassignedInfo.Reason.MANUAL_ALLOCATION : unassignedInfo.getReason(), unassignedInfo.getMessage(),_                unassignedInfo.getFailure(), 0, unassignedInfo.getUnassignedTimeInNanos(),_                unassignedInfo.getUnassignedTimeInMillis(), unassignedInfo.isDelayed(),_                unassignedInfo.getLastAllocationStatus()), shardRouting.recoverySource(), allocation.changes())__        }_    };reset,failed,allocation,counter,for,unassigned,shards;private,void,reset,failed,allocation,counter,routing,allocation,allocation,final,routing,nodes,unassigned,shards,unassigned,iterator,unassigned,iterator,allocation,routing,nodes,unassigned,iterator,while,unassigned,iterator,has,next,shard,routing,shard,routing,unassigned,iterator,next,unassigned,info,unassigned,info,shard,routing,unassigned,info,unassigned,iterator,update,unassigned,new,unassigned,info,unassigned,info,get,num,failed,allocations,0,unassigned,info,reason,unassigned,info,get,reason,unassigned,info,get,message,unassigned,info,get,failure,0,unassigned,info,get,unassigned,time,in,nanos,unassigned,info,get,unassigned,time,in,millis,unassigned,info,is,delayed,unassigned,info,get,last,allocation,status,shard,routing,recovery,source,allocation,changes
AllocationService -> private void resetFailedAllocationCounter(RoutingAllocation allocation);1548161085;Reset failed allocation counter for unassigned shards;private void resetFailedAllocationCounter(RoutingAllocation allocation) {_        final RoutingNodes.UnassignedShards.UnassignedIterator unassignedIterator = allocation.routingNodes().unassigned().iterator()__        while (unassignedIterator.hasNext()) {_            ShardRouting shardRouting = unassignedIterator.next()__            UnassignedInfo unassignedInfo = shardRouting.unassignedInfo()__            unassignedIterator.updateUnassigned(new UnassignedInfo(unassignedInfo.getNumFailedAllocations() > 0 ?_                UnassignedInfo.Reason.MANUAL_ALLOCATION : unassignedInfo.getReason(), unassignedInfo.getMessage(),_                unassignedInfo.getFailure(), 0, unassignedInfo.getUnassignedTimeInNanos(),_                unassignedInfo.getUnassignedTimeInMillis(), unassignedInfo.isDelayed(),_                unassignedInfo.getLastAllocationStatus()), shardRouting.recoverySource(), allocation.changes())__        }_    };reset,failed,allocation,counter,for,unassigned,shards;private,void,reset,failed,allocation,counter,routing,allocation,allocation,final,routing,nodes,unassigned,shards,unassigned,iterator,unassigned,iterator,allocation,routing,nodes,unassigned,iterator,while,unassigned,iterator,has,next,shard,routing,shard,routing,unassigned,iterator,next,unassigned,info,unassigned,info,shard,routing,unassigned,info,unassigned,iterator,update,unassigned,new,unassigned,info,unassigned,info,get,num,failed,allocations,0,unassigned,info,reason,unassigned,info,get,reason,unassigned,info,get,message,unassigned,info,get,failure,0,unassigned,info,get,unassigned,time,in,nanos,unassigned,info,get,unassigned,time,in,millis,unassigned,info,is,delayed,unassigned,info,get,last,allocation,status,shard,routing,recovery,source,allocation,changes
AllocationService -> private void resetFailedAllocationCounter(RoutingAllocation allocation);1548259585;Reset failed allocation counter for unassigned shards;private void resetFailedAllocationCounter(RoutingAllocation allocation) {_        final RoutingNodes.UnassignedShards.UnassignedIterator unassignedIterator = allocation.routingNodes().unassigned().iterator()__        while (unassignedIterator.hasNext()) {_            ShardRouting shardRouting = unassignedIterator.next()__            UnassignedInfo unassignedInfo = shardRouting.unassignedInfo()__            unassignedIterator.updateUnassigned(new UnassignedInfo(unassignedInfo.getNumFailedAllocations() > 0 ?_                UnassignedInfo.Reason.MANUAL_ALLOCATION : unassignedInfo.getReason(), unassignedInfo.getMessage(),_                unassignedInfo.getFailure(), 0, unassignedInfo.getUnassignedTimeInNanos(),_                unassignedInfo.getUnassignedTimeInMillis(), unassignedInfo.isDelayed(),_                unassignedInfo.getLastAllocationStatus()), shardRouting.recoverySource(), allocation.changes())__        }_    };reset,failed,allocation,counter,for,unassigned,shards;private,void,reset,failed,allocation,counter,routing,allocation,allocation,final,routing,nodes,unassigned,shards,unassigned,iterator,unassigned,iterator,allocation,routing,nodes,unassigned,iterator,while,unassigned,iterator,has,next,shard,routing,shard,routing,unassigned,iterator,next,unassigned,info,unassigned,info,shard,routing,unassigned,info,unassigned,iterator,update,unassigned,new,unassigned,info,unassigned,info,get,num,failed,allocations,0,unassigned,info,reason,unassigned,info,get,reason,unassigned,info,get,message,unassigned,info,get,failure,0,unassigned,info,get,unassigned,time,in,nanos,unassigned,info,get,unassigned,time,in,millis,unassigned,info,is,delayed,unassigned,info,get,last,allocation,status,shard,routing,recovery,source,allocation,changes
AllocationService -> private void resetFailedAllocationCounter(RoutingAllocation allocation);1551086646;Reset failed allocation counter for unassigned shards;private void resetFailedAllocationCounter(RoutingAllocation allocation) {_        final RoutingNodes.UnassignedShards.UnassignedIterator unassignedIterator = allocation.routingNodes().unassigned().iterator()__        while (unassignedIterator.hasNext()) {_            ShardRouting shardRouting = unassignedIterator.next()__            UnassignedInfo unassignedInfo = shardRouting.unassignedInfo()__            unassignedIterator.updateUnassigned(new UnassignedInfo(unassignedInfo.getNumFailedAllocations() > 0 ?_                UnassignedInfo.Reason.MANUAL_ALLOCATION : unassignedInfo.getReason(), unassignedInfo.getMessage(),_                unassignedInfo.getFailure(), 0, unassignedInfo.getUnassignedTimeInNanos(),_                unassignedInfo.getUnassignedTimeInMillis(), unassignedInfo.isDelayed(),_                unassignedInfo.getLastAllocationStatus()), shardRouting.recoverySource(), allocation.changes())__        }_    };reset,failed,allocation,counter,for,unassigned,shards;private,void,reset,failed,allocation,counter,routing,allocation,allocation,final,routing,nodes,unassigned,shards,unassigned,iterator,unassigned,iterator,allocation,routing,nodes,unassigned,iterator,while,unassigned,iterator,has,next,shard,routing,shard,routing,unassigned,iterator,next,unassigned,info,unassigned,info,shard,routing,unassigned,info,unassigned,iterator,update,unassigned,new,unassigned,info,unassigned,info,get,num,failed,allocations,0,unassigned,info,reason,unassigned,info,get,reason,unassigned,info,get,message,unassigned,info,get,failure,0,unassigned,info,get,unassigned,time,in,nanos,unassigned,info,get,unassigned,time,in,millis,unassigned,info,is,delayed,unassigned,info,get,last,allocation,status,shard,routing,recovery,source,allocation,changes
AllocationService -> private <T> String firstListElementsToCommaDelimitedString(List<T> elements, Function<T, String> formatter);1524684173;Internal helper to cap the number of elements in a potentially long list for logging.__@param elements  The elements to log. May be any non-null list. Must not be null._@param formatter A function that can convert list elements to a String. Must not be null._@param <T>       The list element type._@return A comma-separated string of the first few elements.;private <T> String firstListElementsToCommaDelimitedString(List<T> elements, Function<T, String> formatter) {_        final int maxNumberOfElements = 10__        return elements_                .stream()_                .limit(maxNumberOfElements)_                .map(formatter)_                .collect(Collectors.joining(", "))__    };internal,helper,to,cap,the,number,of,elements,in,a,potentially,long,list,for,logging,param,elements,the,elements,to,log,may,be,any,non,null,list,must,not,be,null,param,formatter,a,function,that,can,convert,list,elements,to,a,string,must,not,be,null,param,t,the,list,element,type,return,a,comma,separated,string,of,the,first,few,elements;private,t,string,first,list,elements,to,comma,delimited,string,list,t,elements,function,t,string,formatter,final,int,max,number,of,elements,10,return,elements,stream,limit,max,number,of,elements,map,formatter,collect,collectors,joining
AllocationService -> private <T> String firstListElementsToCommaDelimitedString(List<T> elements, Function<T, String> formatter);1525798022;Internal helper to cap the number of elements in a potentially long list for logging.__@param elements  The elements to log. May be any non-null list. Must not be null._@param formatter A function that can convert list elements to a String. Must not be null._@param <T>       The list element type._@return A comma-separated string of the first few elements.;private <T> String firstListElementsToCommaDelimitedString(List<T> elements, Function<T, String> formatter) {_        final int maxNumberOfElements = 10__        return elements_                .stream()_                .limit(maxNumberOfElements)_                .map(formatter)_                .collect(Collectors.joining(", "))__    };internal,helper,to,cap,the,number,of,elements,in,a,potentially,long,list,for,logging,param,elements,the,elements,to,log,may,be,any,non,null,list,must,not,be,null,param,formatter,a,function,that,can,convert,list,elements,to,a,string,must,not,be,null,param,t,the,list,element,type,return,a,comma,separated,string,of,the,first,few,elements;private,t,string,first,list,elements,to,comma,delimited,string,list,t,elements,function,t,string,formatter,final,int,max,number,of,elements,10,return,elements,stream,limit,max,number,of,elements,map,formatter,collect,collectors,joining
AllocationService -> private <T> String firstListElementsToCommaDelimitedString(List<T> elements, Function<T, String> formatter);1526374795;Internal helper to cap the number of elements in a potentially long list for logging.__@param elements  The elements to log. May be any non-null list. Must not be null._@param formatter A function that can convert list elements to a String. Must not be null._@param <T>       The list element type._@return A comma-separated string of the first few elements.;private <T> String firstListElementsToCommaDelimitedString(List<T> elements, Function<T, String> formatter) {_        final int maxNumberOfElements = 10__        return elements_                .stream()_                .limit(maxNumberOfElements)_                .map(formatter)_                .collect(Collectors.joining(", "))__    };internal,helper,to,cap,the,number,of,elements,in,a,potentially,long,list,for,logging,param,elements,the,elements,to,log,may,be,any,non,null,list,must,not,be,null,param,formatter,a,function,that,can,convert,list,elements,to,a,string,must,not,be,null,param,t,the,list,element,type,return,a,comma,separated,string,of,the,first,few,elements;private,t,string,first,list,elements,to,comma,delimited,string,list,t,elements,function,t,string,formatter,final,int,max,number,of,elements,10,return,elements,stream,limit,max,number,of,elements,map,formatter,collect,collectors,joining
AllocationService -> private <T> String firstListElementsToCommaDelimitedString(List<T> elements, Function<T, String> formatter);1539723533;Internal helper to cap the number of elements in a potentially long list for logging.__@param elements  The elements to log. May be any non-null list. Must not be null._@param formatter A function that can convert list elements to a String. Must not be null._@param <T>       The list element type._@return A comma-separated string of the first few elements.;private <T> String firstListElementsToCommaDelimitedString(List<T> elements, Function<T, String> formatter) {_        final int maxNumberOfElements = 10__        return elements_                .stream()_                .limit(maxNumberOfElements)_                .map(formatter)_                .collect(Collectors.joining(", "))__    };internal,helper,to,cap,the,number,of,elements,in,a,potentially,long,list,for,logging,param,elements,the,elements,to,log,may,be,any,non,null,list,must,not,be,null,param,formatter,a,function,that,can,convert,list,elements,to,a,string,must,not,be,null,param,t,the,list,element,type,return,a,comma,separated,string,of,the,first,few,elements;private,t,string,first,list,elements,to,comma,delimited,string,list,t,elements,function,t,string,formatter,final,int,max,number,of,elements,10,return,elements,stream,limit,max,number,of,elements,map,formatter,collect,collectors,joining
AllocationService -> private <T> String firstListElementsToCommaDelimitedString(List<T> elements, Function<T, String> formatter);1541092382;Internal helper to cap the number of elements in a potentially long list for logging.__@param elements  The elements to log. May be any non-null list. Must not be null._@param formatter A function that can convert list elements to a String. Must not be null._@param <T>       The list element type._@return A comma-separated string of the first few elements.;private <T> String firstListElementsToCommaDelimitedString(List<T> elements, Function<T, String> formatter) {_        final int maxNumberOfElements = 10__        return elements_                .stream()_                .limit(maxNumberOfElements)_                .map(formatter)_                .collect(Collectors.joining(", "))__    };internal,helper,to,cap,the,number,of,elements,in,a,potentially,long,list,for,logging,param,elements,the,elements,to,log,may,be,any,non,null,list,must,not,be,null,param,formatter,a,function,that,can,convert,list,elements,to,a,string,must,not,be,null,param,t,the,list,element,type,return,a,comma,separated,string,of,the,first,few,elements;private,t,string,first,list,elements,to,comma,delimited,string,list,t,elements,function,t,string,formatter,final,int,max,number,of,elements,10,return,elements,stream,limit,max,number,of,elements,map,formatter,collect,collectors,joining
AllocationService -> private <T> String firstListElementsToCommaDelimitedString(List<T> elements, Function<T, String> formatter);1542402632;Internal helper to cap the number of elements in a potentially long list for logging.__@param elements  The elements to log. May be any non-null list. Must not be null._@param formatter A function that can convert list elements to a String. Must not be null._@param <T>       The list element type._@return A comma-separated string of the first few elements.;private <T> String firstListElementsToCommaDelimitedString(List<T> elements, Function<T, String> formatter) {_        final int maxNumberOfElements = 10__        return elements_                .stream()_                .limit(maxNumberOfElements)_                .map(formatter)_                .collect(Collectors.joining(", "))__    };internal,helper,to,cap,the,number,of,elements,in,a,potentially,long,list,for,logging,param,elements,the,elements,to,log,may,be,any,non,null,list,must,not,be,null,param,formatter,a,function,that,can,convert,list,elements,to,a,string,must,not,be,null,param,t,the,list,element,type,return,a,comma,separated,string,of,the,first,few,elements;private,t,string,first,list,elements,to,comma,delimited,string,list,t,elements,function,t,string,formatter,final,int,max,number,of,elements,10,return,elements,stream,limit,max,number,of,elements,map,formatter,collect,collectors,joining
AllocationService -> private <T> String firstListElementsToCommaDelimitedString(List<T> elements, Function<T, String> formatter);1548161085;Internal helper to cap the number of elements in a potentially long list for logging.__@param elements  The elements to log. May be any non-null list. Must not be null._@param formatter A function that can convert list elements to a String. Must not be null._@param <T>       The list element type._@return A comma-separated string of the first few elements.;private <T> String firstListElementsToCommaDelimitedString(List<T> elements, Function<T, String> formatter) {_        final int maxNumberOfElements = 10__        return elements_                .stream()_                .limit(maxNumberOfElements)_                .map(formatter)_                .collect(Collectors.joining(", "))__    };internal,helper,to,cap,the,number,of,elements,in,a,potentially,long,list,for,logging,param,elements,the,elements,to,log,may,be,any,non,null,list,must,not,be,null,param,formatter,a,function,that,can,convert,list,elements,to,a,string,must,not,be,null,param,t,the,list,element,type,return,a,comma,separated,string,of,the,first,few,elements;private,t,string,first,list,elements,to,comma,delimited,string,list,t,elements,function,t,string,formatter,final,int,max,number,of,elements,10,return,elements,stream,limit,max,number,of,elements,map,formatter,collect,collectors,joining
AllocationService -> private <T> String firstListElementsToCommaDelimitedString(List<T> elements, Function<T, String> formatter);1548259585;Internal helper to cap the number of elements in a potentially long list for logging.__@param elements  The elements to log. May be any non-null list. Must not be null._@param formatter A function that can convert list elements to a String. Must not be null._@param <T>       The list element type._@return A comma-separated string of the first few elements.;private <T> String firstListElementsToCommaDelimitedString(List<T> elements, Function<T, String> formatter) {_        final int maxNumberOfElements = 10__        return elements_                .stream()_                .limit(maxNumberOfElements)_                .map(formatter)_                .collect(Collectors.joining(", "))__    };internal,helper,to,cap,the,number,of,elements,in,a,potentially,long,list,for,logging,param,elements,the,elements,to,log,may,be,any,non,null,list,must,not,be,null,param,formatter,a,function,that,can,convert,list,elements,to,a,string,must,not,be,null,param,t,the,list,element,type,return,a,comma,separated,string,of,the,first,few,elements;private,t,string,first,list,elements,to,comma,delimited,string,list,t,elements,function,t,string,formatter,final,int,max,number,of,elements,10,return,elements,stream,limit,max,number,of,elements,map,formatter,collect,collectors,joining
AllocationService -> private <T> String firstListElementsToCommaDelimitedString(List<T> elements, Function<T, String> formatter);1551086646;Internal helper to cap the number of elements in a potentially long list for logging.__@param elements  The elements to log. May be any non-null list. Must not be null._@param formatter A function that can convert list elements to a String. Must not be null._@param <T>       The list element type._@return A comma-separated string of the first few elements.;private <T> String firstListElementsToCommaDelimitedString(List<T> elements, Function<T, String> formatter) {_        final int maxNumberOfElements = 10__        return elements_                .stream()_                .limit(maxNumberOfElements)_                .map(formatter)_                .collect(Collectors.joining(", "))__    };internal,helper,to,cap,the,number,of,elements,in,a,potentially,long,list,for,logging,param,elements,the,elements,to,log,may,be,any,non,null,list,must,not,be,null,param,formatter,a,function,that,can,convert,list,elements,to,a,string,must,not,be,null,param,t,the,list,element,type,return,a,comma,separated,string,of,the,first,few,elements;private,t,string,first,list,elements,to,comma,delimited,string,list,t,elements,function,t,string,formatter,final,int,max,number,of,elements,10,return,elements,stream,limit,max,number,of,elements,map,formatter,collect,collectors,joining
AllocationService -> protected ClusterState reroute(ClusterState clusterState, String reason, boolean debug);1525798022;Reroutes the routing table based on the live nodes._<p>_If the same instance of ClusterState is returned, then no change has been made.;protected ClusterState reroute(ClusterState clusterState, String reason, boolean debug) {_        ClusterState fixedClusterState = adaptAutoExpandReplicas(clusterState)___        RoutingNodes routingNodes = getMutableRoutingNodes(fixedClusterState)__        _        routingNodes.unassigned().shuffle()__        RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, routingNodes, fixedClusterState,_            clusterInfoService.getClusterInfo(), currentNanoTime())__        allocation.debugDecision(debug)__        reroute(allocation)__        if (fixedClusterState == clusterState && allocation.routingNodesChanged() == false) {_            return clusterState__        }_        return buildResultAndLogHealthChange(clusterState, allocation, reason)__    };reroutes,the,routing,table,based,on,the,live,nodes,p,if,the,same,instance,of,cluster,state,is,returned,then,no,change,has,been,made;protected,cluster,state,reroute,cluster,state,cluster,state,string,reason,boolean,debug,cluster,state,fixed,cluster,state,adapt,auto,expand,replicas,cluster,state,routing,nodes,routing,nodes,get,mutable,routing,nodes,fixed,cluster,state,routing,nodes,unassigned,shuffle,routing,allocation,allocation,new,routing,allocation,allocation,deciders,routing,nodes,fixed,cluster,state,cluster,info,service,get,cluster,info,current,nano,time,allocation,debug,decision,debug,reroute,allocation,if,fixed,cluster,state,cluster,state,allocation,routing,nodes,changed,false,return,cluster,state,return,build,result,and,log,health,change,cluster,state,allocation,reason
AllocationService -> protected ClusterState reroute(ClusterState clusterState, String reason, boolean debug);1526374795;Reroutes the routing table based on the live nodes._<p>_If the same instance of ClusterState is returned, then no change has been made.;protected ClusterState reroute(ClusterState clusterState, String reason, boolean debug) {_        ClusterState fixedClusterState = adaptAutoExpandReplicas(clusterState)___        RoutingNodes routingNodes = getMutableRoutingNodes(fixedClusterState)__        _        routingNodes.unassigned().shuffle()__        RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, routingNodes, fixedClusterState,_            clusterInfoService.getClusterInfo(), currentNanoTime())__        allocation.debugDecision(debug)__        reroute(allocation)__        if (fixedClusterState == clusterState && allocation.routingNodesChanged() == false) {_            return clusterState__        }_        return buildResultAndLogHealthChange(clusterState, allocation, reason)__    };reroutes,the,routing,table,based,on,the,live,nodes,p,if,the,same,instance,of,cluster,state,is,returned,then,no,change,has,been,made;protected,cluster,state,reroute,cluster,state,cluster,state,string,reason,boolean,debug,cluster,state,fixed,cluster,state,adapt,auto,expand,replicas,cluster,state,routing,nodes,routing,nodes,get,mutable,routing,nodes,fixed,cluster,state,routing,nodes,unassigned,shuffle,routing,allocation,allocation,new,routing,allocation,allocation,deciders,routing,nodes,fixed,cluster,state,cluster,info,service,get,cluster,info,current,nano,time,allocation,debug,decision,debug,reroute,allocation,if,fixed,cluster,state,cluster,state,allocation,routing,nodes,changed,false,return,cluster,state,return,build,result,and,log,health,change,cluster,state,allocation,reason
AllocationService -> protected ClusterState reroute(ClusterState clusterState, String reason, boolean debug);1539723533;Reroutes the routing table based on the live nodes._<p>_If the same instance of ClusterState is returned, then no change has been made.;protected ClusterState reroute(ClusterState clusterState, String reason, boolean debug) {_        ClusterState fixedClusterState = adaptAutoExpandReplicas(clusterState)___        RoutingNodes routingNodes = getMutableRoutingNodes(fixedClusterState)__        _        routingNodes.unassigned().shuffle()__        RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, routingNodes, fixedClusterState,_            clusterInfoService.getClusterInfo(), currentNanoTime())__        allocation.debugDecision(debug)__        reroute(allocation)__        if (fixedClusterState == clusterState && allocation.routingNodesChanged() == false) {_            return clusterState__        }_        return buildResultAndLogHealthChange(clusterState, allocation, reason)__    };reroutes,the,routing,table,based,on,the,live,nodes,p,if,the,same,instance,of,cluster,state,is,returned,then,no,change,has,been,made;protected,cluster,state,reroute,cluster,state,cluster,state,string,reason,boolean,debug,cluster,state,fixed,cluster,state,adapt,auto,expand,replicas,cluster,state,routing,nodes,routing,nodes,get,mutable,routing,nodes,fixed,cluster,state,routing,nodes,unassigned,shuffle,routing,allocation,allocation,new,routing,allocation,allocation,deciders,routing,nodes,fixed,cluster,state,cluster,info,service,get,cluster,info,current,nano,time,allocation,debug,decision,debug,reroute,allocation,if,fixed,cluster,state,cluster,state,allocation,routing,nodes,changed,false,return,cluster,state,return,build,result,and,log,health,change,cluster,state,allocation,reason
AllocationService -> protected ClusterState reroute(ClusterState clusterState, String reason, boolean debug);1541092382;Reroutes the routing table based on the live nodes._<p>_If the same instance of ClusterState is returned, then no change has been made.;protected ClusterState reroute(ClusterState clusterState, String reason, boolean debug) {_        ClusterState fixedClusterState = adaptAutoExpandReplicas(clusterState)___        RoutingNodes routingNodes = getMutableRoutingNodes(fixedClusterState)__        _        routingNodes.unassigned().shuffle()__        RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, routingNodes, fixedClusterState,_            clusterInfoService.getClusterInfo(), currentNanoTime())__        allocation.debugDecision(debug)__        reroute(allocation)__        if (fixedClusterState == clusterState && allocation.routingNodesChanged() == false) {_            return clusterState__        }_        return buildResultAndLogHealthChange(clusterState, allocation, reason)__    };reroutes,the,routing,table,based,on,the,live,nodes,p,if,the,same,instance,of,cluster,state,is,returned,then,no,change,has,been,made;protected,cluster,state,reroute,cluster,state,cluster,state,string,reason,boolean,debug,cluster,state,fixed,cluster,state,adapt,auto,expand,replicas,cluster,state,routing,nodes,routing,nodes,get,mutable,routing,nodes,fixed,cluster,state,routing,nodes,unassigned,shuffle,routing,allocation,allocation,new,routing,allocation,allocation,deciders,routing,nodes,fixed,cluster,state,cluster,info,service,get,cluster,info,current,nano,time,allocation,debug,decision,debug,reroute,allocation,if,fixed,cluster,state,cluster,state,allocation,routing,nodes,changed,false,return,cluster,state,return,build,result,and,log,health,change,cluster,state,allocation,reason
AllocationService -> protected ClusterState reroute(ClusterState clusterState, String reason, boolean debug);1542402632;Reroutes the routing table based on the live nodes._<p>_If the same instance of ClusterState is returned, then no change has been made.;protected ClusterState reroute(ClusterState clusterState, String reason, boolean debug) {_        ClusterState fixedClusterState = adaptAutoExpandReplicas(clusterState)___        RoutingNodes routingNodes = getMutableRoutingNodes(fixedClusterState)__        _        routingNodes.unassigned().shuffle()__        RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, routingNodes, fixedClusterState,_            clusterInfoService.getClusterInfo(), currentNanoTime())__        allocation.debugDecision(debug)__        reroute(allocation)__        if (fixedClusterState == clusterState && allocation.routingNodesChanged() == false) {_            return clusterState__        }_        return buildResultAndLogHealthChange(clusterState, allocation, reason)__    };reroutes,the,routing,table,based,on,the,live,nodes,p,if,the,same,instance,of,cluster,state,is,returned,then,no,change,has,been,made;protected,cluster,state,reroute,cluster,state,cluster,state,string,reason,boolean,debug,cluster,state,fixed,cluster,state,adapt,auto,expand,replicas,cluster,state,routing,nodes,routing,nodes,get,mutable,routing,nodes,fixed,cluster,state,routing,nodes,unassigned,shuffle,routing,allocation,allocation,new,routing,allocation,allocation,deciders,routing,nodes,fixed,cluster,state,cluster,info,service,get,cluster,info,current,nano,time,allocation,debug,decision,debug,reroute,allocation,if,fixed,cluster,state,cluster,state,allocation,routing,nodes,changed,false,return,cluster,state,return,build,result,and,log,health,change,cluster,state,allocation,reason
AllocationService -> protected ClusterState reroute(ClusterState clusterState, String reason, boolean debug);1548161085;Reroutes the routing table based on the live nodes._<p>_If the same instance of ClusterState is returned, then no change has been made.;protected ClusterState reroute(ClusterState clusterState, String reason, boolean debug) {_        ClusterState fixedClusterState = adaptAutoExpandReplicas(clusterState)___        RoutingNodes routingNodes = getMutableRoutingNodes(fixedClusterState)__        _        routingNodes.unassigned().shuffle()__        RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, routingNodes, fixedClusterState,_            clusterInfoService.getClusterInfo(), currentNanoTime())__        allocation.debugDecision(debug)__        reroute(allocation)__        if (fixedClusterState == clusterState && allocation.routingNodesChanged() == false) {_            return clusterState__        }_        return buildResultAndLogHealthChange(clusterState, allocation, reason)__    };reroutes,the,routing,table,based,on,the,live,nodes,p,if,the,same,instance,of,cluster,state,is,returned,then,no,change,has,been,made;protected,cluster,state,reroute,cluster,state,cluster,state,string,reason,boolean,debug,cluster,state,fixed,cluster,state,adapt,auto,expand,replicas,cluster,state,routing,nodes,routing,nodes,get,mutable,routing,nodes,fixed,cluster,state,routing,nodes,unassigned,shuffle,routing,allocation,allocation,new,routing,allocation,allocation,deciders,routing,nodes,fixed,cluster,state,cluster,info,service,get,cluster,info,current,nano,time,allocation,debug,decision,debug,reroute,allocation,if,fixed,cluster,state,cluster,state,allocation,routing,nodes,changed,false,return,cluster,state,return,build,result,and,log,health,change,cluster,state,allocation,reason
AllocationService -> protected ClusterState reroute(ClusterState clusterState, String reason, boolean debug);1548259585;Reroutes the routing table based on the live nodes._<p>_If the same instance of ClusterState is returned, then no change has been made.;protected ClusterState reroute(ClusterState clusterState, String reason, boolean debug) {_        ClusterState fixedClusterState = adaptAutoExpandReplicas(clusterState)___        RoutingNodes routingNodes = getMutableRoutingNodes(fixedClusterState)__        _        routingNodes.unassigned().shuffle()__        RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, routingNodes, fixedClusterState,_            clusterInfoService.getClusterInfo(), currentNanoTime())__        allocation.debugDecision(debug)__        reroute(allocation)__        if (fixedClusterState == clusterState && allocation.routingNodesChanged() == false) {_            return clusterState__        }_        return buildResultAndLogHealthChange(clusterState, allocation, reason)__    };reroutes,the,routing,table,based,on,the,live,nodes,p,if,the,same,instance,of,cluster,state,is,returned,then,no,change,has,been,made;protected,cluster,state,reroute,cluster,state,cluster,state,string,reason,boolean,debug,cluster,state,fixed,cluster,state,adapt,auto,expand,replicas,cluster,state,routing,nodes,routing,nodes,get,mutable,routing,nodes,fixed,cluster,state,routing,nodes,unassigned,shuffle,routing,allocation,allocation,new,routing,allocation,allocation,deciders,routing,nodes,fixed,cluster,state,cluster,info,service,get,cluster,info,current,nano,time,allocation,debug,decision,debug,reroute,allocation,if,fixed,cluster,state,cluster,state,allocation,routing,nodes,changed,false,return,cluster,state,return,build,result,and,log,health,change,cluster,state,allocation,reason
AllocationService -> protected ClusterState reroute(ClusterState clusterState, String reason, boolean debug);1551086646;Reroutes the routing table based on the live nodes._<p>_If the same instance of ClusterState is returned, then no change has been made.;protected ClusterState reroute(ClusterState clusterState, String reason, boolean debug) {_        ClusterState fixedClusterState = adaptAutoExpandReplicas(clusterState)___        RoutingNodes routingNodes = getMutableRoutingNodes(fixedClusterState)__        _        routingNodes.unassigned().shuffle()__        RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, routingNodes, fixedClusterState,_            clusterInfoService.getClusterInfo(), currentNanoTime())__        allocation.debugDecision(debug)__        reroute(allocation)__        if (fixedClusterState == clusterState && allocation.routingNodesChanged() == false) {_            return clusterState__        }_        return buildResultAndLogHealthChange(clusterState, allocation, reason)__    };reroutes,the,routing,table,based,on,the,live,nodes,p,if,the,same,instance,of,cluster,state,is,returned,then,no,change,has,been,made;protected,cluster,state,reroute,cluster,state,cluster,state,string,reason,boolean,debug,cluster,state,fixed,cluster,state,adapt,auto,expand,replicas,cluster,state,routing,nodes,routing,nodes,get,mutable,routing,nodes,fixed,cluster,state,routing,nodes,unassigned,shuffle,routing,allocation,allocation,new,routing,allocation,allocation,deciders,routing,nodes,fixed,cluster,state,cluster,info,service,get,cluster,info,current,nano,time,allocation,debug,decision,debug,reroute,allocation,if,fixed,cluster,state,cluster,state,allocation,routing,nodes,changed,false,return,cluster,state,return,build,result,and,log,health,change,cluster,state,allocation,reason
AllocationService -> public ClusterState disassociateDeadNodes(ClusterState clusterState, boolean reroute, String reason);1548259585;unassigned an shards that are associated with nodes that are no longer part of the cluster, potentially promoting replicas_if needed.;public ClusterState disassociateDeadNodes(ClusterState clusterState, boolean reroute, String reason) {_        RoutingNodes routingNodes = getMutableRoutingNodes(clusterState)__        _        routingNodes.unassigned().shuffle()__        RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, routingNodes, clusterState,_            clusterInfoService.getClusterInfo(), currentNanoTime())___        _        disassociateDeadNodes(allocation)___        if (allocation.routingNodesChanged()) {_            clusterState = buildResult(clusterState, allocation)__        }_        if (reroute) {_            return reroute(clusterState, reason)__        } else {_            return clusterState__        }_    };unassigned,an,shards,that,are,associated,with,nodes,that,are,no,longer,part,of,the,cluster,potentially,promoting,replicas,if,needed;public,cluster,state,disassociate,dead,nodes,cluster,state,cluster,state,boolean,reroute,string,reason,routing,nodes,routing,nodes,get,mutable,routing,nodes,cluster,state,routing,nodes,unassigned,shuffle,routing,allocation,allocation,new,routing,allocation,allocation,deciders,routing,nodes,cluster,state,cluster,info,service,get,cluster,info,current,nano,time,disassociate,dead,nodes,allocation,if,allocation,routing,nodes,changed,cluster,state,build,result,cluster,state,allocation,if,reroute,return,reroute,cluster,state,reason,else,return,cluster,state
AllocationService -> public ClusterState disassociateDeadNodes(ClusterState clusterState, boolean reroute, String reason);1551086646;unassigned an shards that are associated with nodes that are no longer part of the cluster, potentially promoting replicas_if needed.;public ClusterState disassociateDeadNodes(ClusterState clusterState, boolean reroute, String reason) {_        RoutingNodes routingNodes = getMutableRoutingNodes(clusterState)__        _        routingNodes.unassigned().shuffle()__        RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, routingNodes, clusterState,_            clusterInfoService.getClusterInfo(), currentNanoTime())___        _        disassociateDeadNodes(allocation)___        if (allocation.routingNodesChanged()) {_            clusterState = buildResult(clusterState, allocation)__        }_        if (reroute) {_            return reroute(clusterState, reason)__        } else {_            return clusterState__        }_    };unassigned,an,shards,that,are,associated,with,nodes,that,are,no,longer,part,of,the,cluster,potentially,promoting,replicas,if,needed;public,cluster,state,disassociate,dead,nodes,cluster,state,cluster,state,boolean,reroute,string,reason,routing,nodes,routing,nodes,get,mutable,routing,nodes,cluster,state,routing,nodes,unassigned,shuffle,routing,allocation,allocation,new,routing,allocation,allocation,deciders,routing,nodes,cluster,state,cluster,info,service,get,cluster,info,current,nano,time,disassociate,dead,nodes,allocation,if,allocation,routing,nodes,changed,cluster,state,build,result,cluster,state,allocation,if,reroute,return,reroute,cluster,state,reason,else,return,cluster,state
AllocationService -> public ClusterState applyFailedShards(final ClusterState clusterState, final List<FailedShard> failedShards,                                           final List<StaleShard> staleShards);1524684173;Applies the failed shards. Note, only assigned ShardRouting instances that exist in the routing table should be_provided as parameter. Also applies a list of allocation ids to remove from the in-sync set for shard copies for which there_are no routing entries in the routing table.__<p>_If the same instance of ClusterState is returned, then no change has been made.</p>;public ClusterState applyFailedShards(final ClusterState clusterState, final List<FailedShard> failedShards,_                                          final List<StaleShard> staleShards) {_        if (staleShards.isEmpty() && failedShards.isEmpty()) {_            return clusterState__        }_        ClusterState tmpState = IndexMetaDataUpdater.removeStaleIdsWithoutRoutings(clusterState, staleShards, logger)___        RoutingNodes routingNodes = getMutableRoutingNodes(tmpState)__        _        routingNodes.unassigned().shuffle()__        long currentNanoTime = currentNanoTime()__        RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, routingNodes, tmpState,_            clusterInfoService.getClusterInfo(), currentNanoTime)___        for (FailedShard failedShardEntry : failedShards) {_            ShardRouting shardToFail = failedShardEntry.getRoutingEntry()__            IndexMetaData indexMetaData = allocation.metaData().getIndexSafe(shardToFail.shardId().getIndex())__            allocation.addIgnoreShardForNode(shardToFail.shardId(), shardToFail.currentNodeId())__            _            ShardRouting failedShard = routingNodes.getByAllocationId(shardToFail.shardId(), shardToFail.allocationId().getId())__            if (failedShard != null) {_                if (failedShard != shardToFail) {_                    logger.trace("{} shard routing modified in an earlier iteration (previous: {}, current: {})",_                        shardToFail.shardId(), shardToFail, failedShard)__                }_                int failedAllocations = failedShard.unassignedInfo() != null ? failedShard.unassignedInfo().getNumFailedAllocations() : 0__                String message = "failed shard on node [" + shardToFail.currentNodeId() + "]: " + failedShardEntry.getMessage()__                UnassignedInfo unassignedInfo = new UnassignedInfo(UnassignedInfo.Reason.ALLOCATION_FAILED, message,_                    failedShardEntry.getFailure(), failedAllocations + 1, currentNanoTime, System.currentTimeMillis(), false,_                    AllocationStatus.NO_ATTEMPT)__                if (failedShardEntry.markAsStale()) {_                    allocation.removeAllocationId(failedShard)__                }_                logger.warn(new ParameterizedMessage("failing shard [{}]", failedShardEntry), failedShardEntry.getFailure())__                routingNodes.failShard(logger, failedShard, unassignedInfo, indexMetaData, allocation.changes())__            } else {_                logger.trace("{} shard routing failed in an earlier iteration (routing: {})", shardToFail.shardId(), shardToFail)__            }_        }_        gatewayAllocator.applyFailedShards(allocation, failedShards)___        reroute(allocation)__        String failedShardsAsString = firstListElementsToCommaDelimitedString(failedShards, s -> s.getRoutingEntry().shardId().toString())__        return buildResultAndLogHealthChange(clusterState, allocation, "shards failed [" + failedShardsAsString + "] ...")__    };applies,the,failed,shards,note,only,assigned,shard,routing,instances,that,exist,in,the,routing,table,should,be,provided,as,parameter,also,applies,a,list,of,allocation,ids,to,remove,from,the,in,sync,set,for,shard,copies,for,which,there,are,no,routing,entries,in,the,routing,table,p,if,the,same,instance,of,cluster,state,is,returned,then,no,change,has,been,made,p;public,cluster,state,apply,failed,shards,final,cluster,state,cluster,state,final,list,failed,shard,failed,shards,final,list,stale,shard,stale,shards,if,stale,shards,is,empty,failed,shards,is,empty,return,cluster,state,cluster,state,tmp,state,index,meta,data,updater,remove,stale,ids,without,routings,cluster,state,stale,shards,logger,routing,nodes,routing,nodes,get,mutable,routing,nodes,tmp,state,routing,nodes,unassigned,shuffle,long,current,nano,time,current,nano,time,routing,allocation,allocation,new,routing,allocation,allocation,deciders,routing,nodes,tmp,state,cluster,info,service,get,cluster,info,current,nano,time,for,failed,shard,failed,shard,entry,failed,shards,shard,routing,shard,to,fail,failed,shard,entry,get,routing,entry,index,meta,data,index,meta,data,allocation,meta,data,get,index,safe,shard,to,fail,shard,id,get,index,allocation,add,ignore,shard,for,node,shard,to,fail,shard,id,shard,to,fail,current,node,id,shard,routing,failed,shard,routing,nodes,get,by,allocation,id,shard,to,fail,shard,id,shard,to,fail,allocation,id,get,id,if,failed,shard,null,if,failed,shard,shard,to,fail,logger,trace,shard,routing,modified,in,an,earlier,iteration,previous,current,shard,to,fail,shard,id,shard,to,fail,failed,shard,int,failed,allocations,failed,shard,unassigned,info,null,failed,shard,unassigned,info,get,num,failed,allocations,0,string,message,failed,shard,on,node,shard,to,fail,current,node,id,failed,shard,entry,get,message,unassigned,info,unassigned,info,new,unassigned,info,unassigned,info,reason,message,failed,shard,entry,get,failure,failed,allocations,1,current,nano,time,system,current,time,millis,false,allocation,status,if,failed,shard,entry,mark,as,stale,allocation,remove,allocation,id,failed,shard,logger,warn,new,parameterized,message,failing,shard,failed,shard,entry,failed,shard,entry,get,failure,routing,nodes,fail,shard,logger,failed,shard,unassigned,info,index,meta,data,allocation,changes,else,logger,trace,shard,routing,failed,in,an,earlier,iteration,routing,shard,to,fail,shard,id,shard,to,fail,gateway,allocator,apply,failed,shards,allocation,failed,shards,reroute,allocation,string,failed,shards,as,string,first,list,elements,to,comma,delimited,string,failed,shards,s,s,get,routing,entry,shard,id,to,string,return,build,result,and,log,health,change,cluster,state,allocation,shards,failed,failed,shards,as,string
AllocationService -> public ClusterState applyFailedShards(final ClusterState clusterState, final List<FailedShard> failedShards,                                           final List<StaleShard> staleShards);1525798022;Applies the failed shards. Note, only assigned ShardRouting instances that exist in the routing table should be_provided as parameter. Also applies a list of allocation ids to remove from the in-sync set for shard copies for which there_are no routing entries in the routing table.__<p>_If the same instance of ClusterState is returned, then no change has been made.</p>;public ClusterState applyFailedShards(final ClusterState clusterState, final List<FailedShard> failedShards,_                                          final List<StaleShard> staleShards) {_        if (staleShards.isEmpty() && failedShards.isEmpty()) {_            return clusterState__        }_        ClusterState tmpState = IndexMetaDataUpdater.removeStaleIdsWithoutRoutings(clusterState, staleShards, logger)___        RoutingNodes routingNodes = getMutableRoutingNodes(tmpState)__        _        routingNodes.unassigned().shuffle()__        long currentNanoTime = currentNanoTime()__        RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, routingNodes, tmpState,_            clusterInfoService.getClusterInfo(), currentNanoTime)___        for (FailedShard failedShardEntry : failedShards) {_            ShardRouting shardToFail = failedShardEntry.getRoutingEntry()__            IndexMetaData indexMetaData = allocation.metaData().getIndexSafe(shardToFail.shardId().getIndex())__            allocation.addIgnoreShardForNode(shardToFail.shardId(), shardToFail.currentNodeId())__            _            ShardRouting failedShard = routingNodes.getByAllocationId(shardToFail.shardId(), shardToFail.allocationId().getId())__            if (failedShard != null) {_                if (failedShard != shardToFail) {_                    logger.trace("{} shard routing modified in an earlier iteration (previous: {}, current: {})",_                        shardToFail.shardId(), shardToFail, failedShard)__                }_                int failedAllocations = failedShard.unassignedInfo() != null ? failedShard.unassignedInfo().getNumFailedAllocations() : 0__                String message = "failed shard on node [" + shardToFail.currentNodeId() + "]: " + failedShardEntry.getMessage()__                UnassignedInfo unassignedInfo = new UnassignedInfo(UnassignedInfo.Reason.ALLOCATION_FAILED, message,_                    failedShardEntry.getFailure(), failedAllocations + 1, currentNanoTime, System.currentTimeMillis(), false,_                    AllocationStatus.NO_ATTEMPT)__                if (failedShardEntry.markAsStale()) {_                    allocation.removeAllocationId(failedShard)__                }_                logger.warn(new ParameterizedMessage("failing shard [{}]", failedShardEntry), failedShardEntry.getFailure())__                routingNodes.failShard(logger, failedShard, unassignedInfo, indexMetaData, allocation.changes())__            } else {_                logger.trace("{} shard routing failed in an earlier iteration (routing: {})", shardToFail.shardId(), shardToFail)__            }_        }_        gatewayAllocator.applyFailedShards(allocation, failedShards)___        reroute(allocation)__        String failedShardsAsString = firstListElementsToCommaDelimitedString(failedShards, s -> s.getRoutingEntry().shardId().toString())__        return buildResultAndLogHealthChange(clusterState, allocation, "shards failed [" + failedShardsAsString + "] ...")__    };applies,the,failed,shards,note,only,assigned,shard,routing,instances,that,exist,in,the,routing,table,should,be,provided,as,parameter,also,applies,a,list,of,allocation,ids,to,remove,from,the,in,sync,set,for,shard,copies,for,which,there,are,no,routing,entries,in,the,routing,table,p,if,the,same,instance,of,cluster,state,is,returned,then,no,change,has,been,made,p;public,cluster,state,apply,failed,shards,final,cluster,state,cluster,state,final,list,failed,shard,failed,shards,final,list,stale,shard,stale,shards,if,stale,shards,is,empty,failed,shards,is,empty,return,cluster,state,cluster,state,tmp,state,index,meta,data,updater,remove,stale,ids,without,routings,cluster,state,stale,shards,logger,routing,nodes,routing,nodes,get,mutable,routing,nodes,tmp,state,routing,nodes,unassigned,shuffle,long,current,nano,time,current,nano,time,routing,allocation,allocation,new,routing,allocation,allocation,deciders,routing,nodes,tmp,state,cluster,info,service,get,cluster,info,current,nano,time,for,failed,shard,failed,shard,entry,failed,shards,shard,routing,shard,to,fail,failed,shard,entry,get,routing,entry,index,meta,data,index,meta,data,allocation,meta,data,get,index,safe,shard,to,fail,shard,id,get,index,allocation,add,ignore,shard,for,node,shard,to,fail,shard,id,shard,to,fail,current,node,id,shard,routing,failed,shard,routing,nodes,get,by,allocation,id,shard,to,fail,shard,id,shard,to,fail,allocation,id,get,id,if,failed,shard,null,if,failed,shard,shard,to,fail,logger,trace,shard,routing,modified,in,an,earlier,iteration,previous,current,shard,to,fail,shard,id,shard,to,fail,failed,shard,int,failed,allocations,failed,shard,unassigned,info,null,failed,shard,unassigned,info,get,num,failed,allocations,0,string,message,failed,shard,on,node,shard,to,fail,current,node,id,failed,shard,entry,get,message,unassigned,info,unassigned,info,new,unassigned,info,unassigned,info,reason,message,failed,shard,entry,get,failure,failed,allocations,1,current,nano,time,system,current,time,millis,false,allocation,status,if,failed,shard,entry,mark,as,stale,allocation,remove,allocation,id,failed,shard,logger,warn,new,parameterized,message,failing,shard,failed,shard,entry,failed,shard,entry,get,failure,routing,nodes,fail,shard,logger,failed,shard,unassigned,info,index,meta,data,allocation,changes,else,logger,trace,shard,routing,failed,in,an,earlier,iteration,routing,shard,to,fail,shard,id,shard,to,fail,gateway,allocator,apply,failed,shards,allocation,failed,shards,reroute,allocation,string,failed,shards,as,string,first,list,elements,to,comma,delimited,string,failed,shards,s,s,get,routing,entry,shard,id,to,string,return,build,result,and,log,health,change,cluster,state,allocation,shards,failed,failed,shards,as,string
AllocationService -> public ClusterState applyFailedShards(final ClusterState clusterState, final List<FailedShard> failedShards,                                           final List<StaleShard> staleShards);1526374795;Applies the failed shards. Note, only assigned ShardRouting instances that exist in the routing table should be_provided as parameter. Also applies a list of allocation ids to remove from the in-sync set for shard copies for which there_are no routing entries in the routing table.__<p>_If the same instance of ClusterState is returned, then no change has been made.</p>;public ClusterState applyFailedShards(final ClusterState clusterState, final List<FailedShard> failedShards,_                                          final List<StaleShard> staleShards) {_        if (staleShards.isEmpty() && failedShards.isEmpty()) {_            return clusterState__        }_        ClusterState tmpState = IndexMetaDataUpdater.removeStaleIdsWithoutRoutings(clusterState, staleShards, logger)___        RoutingNodes routingNodes = getMutableRoutingNodes(tmpState)__        _        routingNodes.unassigned().shuffle()__        long currentNanoTime = currentNanoTime()__        RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, routingNodes, tmpState,_            clusterInfoService.getClusterInfo(), currentNanoTime)___        for (FailedShard failedShardEntry : failedShards) {_            ShardRouting shardToFail = failedShardEntry.getRoutingEntry()__            IndexMetaData indexMetaData = allocation.metaData().getIndexSafe(shardToFail.shardId().getIndex())__            allocation.addIgnoreShardForNode(shardToFail.shardId(), shardToFail.currentNodeId())__            _            ShardRouting failedShard = routingNodes.getByAllocationId(shardToFail.shardId(), shardToFail.allocationId().getId())__            if (failedShard != null) {_                if (failedShard != shardToFail) {_                    logger.trace("{} shard routing modified in an earlier iteration (previous: {}, current: {})",_                        shardToFail.shardId(), shardToFail, failedShard)__                }_                int failedAllocations = failedShard.unassignedInfo() != null ? failedShard.unassignedInfo().getNumFailedAllocations() : 0__                String message = "failed shard on node [" + shardToFail.currentNodeId() + "]: " + failedShardEntry.getMessage()__                UnassignedInfo unassignedInfo = new UnassignedInfo(UnassignedInfo.Reason.ALLOCATION_FAILED, message,_                    failedShardEntry.getFailure(), failedAllocations + 1, currentNanoTime, System.currentTimeMillis(), false,_                    AllocationStatus.NO_ATTEMPT)__                if (failedShardEntry.markAsStale()) {_                    allocation.removeAllocationId(failedShard)__                }_                logger.warn(new ParameterizedMessage("failing shard [{}]", failedShardEntry), failedShardEntry.getFailure())__                routingNodes.failShard(logger, failedShard, unassignedInfo, indexMetaData, allocation.changes())__            } else {_                logger.trace("{} shard routing failed in an earlier iteration (routing: {})", shardToFail.shardId(), shardToFail)__            }_        }_        gatewayAllocator.applyFailedShards(allocation, failedShards)___        reroute(allocation)__        String failedShardsAsString = firstListElementsToCommaDelimitedString(failedShards, s -> s.getRoutingEntry().shardId().toString())__        return buildResultAndLogHealthChange(clusterState, allocation, "shards failed [" + failedShardsAsString + "] ...")__    };applies,the,failed,shards,note,only,assigned,shard,routing,instances,that,exist,in,the,routing,table,should,be,provided,as,parameter,also,applies,a,list,of,allocation,ids,to,remove,from,the,in,sync,set,for,shard,copies,for,which,there,are,no,routing,entries,in,the,routing,table,p,if,the,same,instance,of,cluster,state,is,returned,then,no,change,has,been,made,p;public,cluster,state,apply,failed,shards,final,cluster,state,cluster,state,final,list,failed,shard,failed,shards,final,list,stale,shard,stale,shards,if,stale,shards,is,empty,failed,shards,is,empty,return,cluster,state,cluster,state,tmp,state,index,meta,data,updater,remove,stale,ids,without,routings,cluster,state,stale,shards,logger,routing,nodes,routing,nodes,get,mutable,routing,nodes,tmp,state,routing,nodes,unassigned,shuffle,long,current,nano,time,current,nano,time,routing,allocation,allocation,new,routing,allocation,allocation,deciders,routing,nodes,tmp,state,cluster,info,service,get,cluster,info,current,nano,time,for,failed,shard,failed,shard,entry,failed,shards,shard,routing,shard,to,fail,failed,shard,entry,get,routing,entry,index,meta,data,index,meta,data,allocation,meta,data,get,index,safe,shard,to,fail,shard,id,get,index,allocation,add,ignore,shard,for,node,shard,to,fail,shard,id,shard,to,fail,current,node,id,shard,routing,failed,shard,routing,nodes,get,by,allocation,id,shard,to,fail,shard,id,shard,to,fail,allocation,id,get,id,if,failed,shard,null,if,failed,shard,shard,to,fail,logger,trace,shard,routing,modified,in,an,earlier,iteration,previous,current,shard,to,fail,shard,id,shard,to,fail,failed,shard,int,failed,allocations,failed,shard,unassigned,info,null,failed,shard,unassigned,info,get,num,failed,allocations,0,string,message,failed,shard,on,node,shard,to,fail,current,node,id,failed,shard,entry,get,message,unassigned,info,unassigned,info,new,unassigned,info,unassigned,info,reason,message,failed,shard,entry,get,failure,failed,allocations,1,current,nano,time,system,current,time,millis,false,allocation,status,if,failed,shard,entry,mark,as,stale,allocation,remove,allocation,id,failed,shard,logger,warn,new,parameterized,message,failing,shard,failed,shard,entry,failed,shard,entry,get,failure,routing,nodes,fail,shard,logger,failed,shard,unassigned,info,index,meta,data,allocation,changes,else,logger,trace,shard,routing,failed,in,an,earlier,iteration,routing,shard,to,fail,shard,id,shard,to,fail,gateway,allocator,apply,failed,shards,allocation,failed,shards,reroute,allocation,string,failed,shards,as,string,first,list,elements,to,comma,delimited,string,failed,shards,s,s,get,routing,entry,shard,id,to,string,return,build,result,and,log,health,change,cluster,state,allocation,shards,failed,failed,shards,as,string
AllocationService -> public ClusterState applyFailedShards(final ClusterState clusterState, final List<FailedShard> failedShards,                                           final List<StaleShard> staleShards);1539723533;Applies the failed shards. Note, only assigned ShardRouting instances that exist in the routing table should be_provided as parameter. Also applies a list of allocation ids to remove from the in-sync set for shard copies for which there_are no routing entries in the routing table.__<p>_If the same instance of ClusterState is returned, then no change has been made.</p>;public ClusterState applyFailedShards(final ClusterState clusterState, final List<FailedShard> failedShards,_                                          final List<StaleShard> staleShards) {_        if (staleShards.isEmpty() && failedShards.isEmpty()) {_            return clusterState__        }_        ClusterState tmpState = IndexMetaDataUpdater.removeStaleIdsWithoutRoutings(clusterState, staleShards, logger)___        RoutingNodes routingNodes = getMutableRoutingNodes(tmpState)__        _        routingNodes.unassigned().shuffle()__        long currentNanoTime = currentNanoTime()__        RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, routingNodes, tmpState,_            clusterInfoService.getClusterInfo(), currentNanoTime)___        for (FailedShard failedShardEntry : failedShards) {_            ShardRouting shardToFail = failedShardEntry.getRoutingEntry()__            IndexMetaData indexMetaData = allocation.metaData().getIndexSafe(shardToFail.shardId().getIndex())__            allocation.addIgnoreShardForNode(shardToFail.shardId(), shardToFail.currentNodeId())__            _            ShardRouting failedShard = routingNodes.getByAllocationId(shardToFail.shardId(), shardToFail.allocationId().getId())__            if (failedShard != null) {_                if (failedShard != shardToFail) {_                    logger.trace("{} shard routing modified in an earlier iteration (previous: {}, current: {})",_                        shardToFail.shardId(), shardToFail, failedShard)__                }_                int failedAllocations = failedShard.unassignedInfo() != null ? failedShard.unassignedInfo().getNumFailedAllocations() : 0__                String message = "failed shard on node [" + shardToFail.currentNodeId() + "]: " + failedShardEntry.getMessage()__                UnassignedInfo unassignedInfo = new UnassignedInfo(UnassignedInfo.Reason.ALLOCATION_FAILED, message,_                    failedShardEntry.getFailure(), failedAllocations + 1, currentNanoTime, System.currentTimeMillis(), false,_                    AllocationStatus.NO_ATTEMPT)__                if (failedShardEntry.markAsStale()) {_                    allocation.removeAllocationId(failedShard)__                }_                logger.warn(new ParameterizedMessage("failing shard [{}]", failedShardEntry), failedShardEntry.getFailure())__                routingNodes.failShard(logger, failedShard, unassignedInfo, indexMetaData, allocation.changes())__            } else {_                logger.trace("{} shard routing failed in an earlier iteration (routing: {})", shardToFail.shardId(), shardToFail)__            }_        }_        gatewayAllocator.applyFailedShards(allocation, failedShards)___        reroute(allocation)__        String failedShardsAsString = firstListElementsToCommaDelimitedString(failedShards, s -> s.getRoutingEntry().shardId().toString())__        return buildResultAndLogHealthChange(clusterState, allocation, "shards failed [" + failedShardsAsString + "] ...")__    };applies,the,failed,shards,note,only,assigned,shard,routing,instances,that,exist,in,the,routing,table,should,be,provided,as,parameter,also,applies,a,list,of,allocation,ids,to,remove,from,the,in,sync,set,for,shard,copies,for,which,there,are,no,routing,entries,in,the,routing,table,p,if,the,same,instance,of,cluster,state,is,returned,then,no,change,has,been,made,p;public,cluster,state,apply,failed,shards,final,cluster,state,cluster,state,final,list,failed,shard,failed,shards,final,list,stale,shard,stale,shards,if,stale,shards,is,empty,failed,shards,is,empty,return,cluster,state,cluster,state,tmp,state,index,meta,data,updater,remove,stale,ids,without,routings,cluster,state,stale,shards,logger,routing,nodes,routing,nodes,get,mutable,routing,nodes,tmp,state,routing,nodes,unassigned,shuffle,long,current,nano,time,current,nano,time,routing,allocation,allocation,new,routing,allocation,allocation,deciders,routing,nodes,tmp,state,cluster,info,service,get,cluster,info,current,nano,time,for,failed,shard,failed,shard,entry,failed,shards,shard,routing,shard,to,fail,failed,shard,entry,get,routing,entry,index,meta,data,index,meta,data,allocation,meta,data,get,index,safe,shard,to,fail,shard,id,get,index,allocation,add,ignore,shard,for,node,shard,to,fail,shard,id,shard,to,fail,current,node,id,shard,routing,failed,shard,routing,nodes,get,by,allocation,id,shard,to,fail,shard,id,shard,to,fail,allocation,id,get,id,if,failed,shard,null,if,failed,shard,shard,to,fail,logger,trace,shard,routing,modified,in,an,earlier,iteration,previous,current,shard,to,fail,shard,id,shard,to,fail,failed,shard,int,failed,allocations,failed,shard,unassigned,info,null,failed,shard,unassigned,info,get,num,failed,allocations,0,string,message,failed,shard,on,node,shard,to,fail,current,node,id,failed,shard,entry,get,message,unassigned,info,unassigned,info,new,unassigned,info,unassigned,info,reason,message,failed,shard,entry,get,failure,failed,allocations,1,current,nano,time,system,current,time,millis,false,allocation,status,if,failed,shard,entry,mark,as,stale,allocation,remove,allocation,id,failed,shard,logger,warn,new,parameterized,message,failing,shard,failed,shard,entry,failed,shard,entry,get,failure,routing,nodes,fail,shard,logger,failed,shard,unassigned,info,index,meta,data,allocation,changes,else,logger,trace,shard,routing,failed,in,an,earlier,iteration,routing,shard,to,fail,shard,id,shard,to,fail,gateway,allocator,apply,failed,shards,allocation,failed,shards,reroute,allocation,string,failed,shards,as,string,first,list,elements,to,comma,delimited,string,failed,shards,s,s,get,routing,entry,shard,id,to,string,return,build,result,and,log,health,change,cluster,state,allocation,shards,failed,failed,shards,as,string
AllocationService -> public ClusterState applyFailedShards(final ClusterState clusterState, final List<FailedShard> failedShards,                                           final List<StaleShard> staleShards);1541092382;Applies the failed shards. Note, only assigned ShardRouting instances that exist in the routing table should be_provided as parameter. Also applies a list of allocation ids to remove from the in-sync set for shard copies for which there_are no routing entries in the routing table.__<p>_If the same instance of ClusterState is returned, then no change has been made.</p>;public ClusterState applyFailedShards(final ClusterState clusterState, final List<FailedShard> failedShards,_                                          final List<StaleShard> staleShards) {_        if (staleShards.isEmpty() && failedShards.isEmpty()) {_            return clusterState__        }_        ClusterState tmpState = IndexMetaDataUpdater.removeStaleIdsWithoutRoutings(clusterState, staleShards, logger)___        RoutingNodes routingNodes = getMutableRoutingNodes(tmpState)__        _        routingNodes.unassigned().shuffle()__        long currentNanoTime = currentNanoTime()__        RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, routingNodes, tmpState,_            clusterInfoService.getClusterInfo(), currentNanoTime)___        for (FailedShard failedShardEntry : failedShards) {_            ShardRouting shardToFail = failedShardEntry.getRoutingEntry()__            IndexMetaData indexMetaData = allocation.metaData().getIndexSafe(shardToFail.shardId().getIndex())__            allocation.addIgnoreShardForNode(shardToFail.shardId(), shardToFail.currentNodeId())__            _            ShardRouting failedShard = routingNodes.getByAllocationId(shardToFail.shardId(), shardToFail.allocationId().getId())__            if (failedShard != null) {_                if (failedShard != shardToFail) {_                    logger.trace("{} shard routing modified in an earlier iteration (previous: {}, current: {})",_                        shardToFail.shardId(), shardToFail, failedShard)__                }_                int failedAllocations = failedShard.unassignedInfo() != null ? failedShard.unassignedInfo().getNumFailedAllocations() : 0__                String message = "failed shard on node [" + shardToFail.currentNodeId() + "]: " + failedShardEntry.getMessage()__                UnassignedInfo unassignedInfo = new UnassignedInfo(UnassignedInfo.Reason.ALLOCATION_FAILED, message,_                    failedShardEntry.getFailure(), failedAllocations + 1, currentNanoTime, System.currentTimeMillis(), false,_                    AllocationStatus.NO_ATTEMPT)__                if (failedShardEntry.markAsStale()) {_                    allocation.removeAllocationId(failedShard)__                }_                logger.warn(new ParameterizedMessage("failing shard [{}]", failedShardEntry), failedShardEntry.getFailure())__                routingNodes.failShard(logger, failedShard, unassignedInfo, indexMetaData, allocation.changes())__            } else {_                logger.trace("{} shard routing failed in an earlier iteration (routing: {})", shardToFail.shardId(), shardToFail)__            }_        }_        gatewayAllocator.applyFailedShards(allocation, failedShards)___        reroute(allocation)__        String failedShardsAsString = firstListElementsToCommaDelimitedString(failedShards, s -> s.getRoutingEntry().shardId().toString())__        return buildResultAndLogHealthChange(clusterState, allocation, "shards failed [" + failedShardsAsString + "] ...")__    };applies,the,failed,shards,note,only,assigned,shard,routing,instances,that,exist,in,the,routing,table,should,be,provided,as,parameter,also,applies,a,list,of,allocation,ids,to,remove,from,the,in,sync,set,for,shard,copies,for,which,there,are,no,routing,entries,in,the,routing,table,p,if,the,same,instance,of,cluster,state,is,returned,then,no,change,has,been,made,p;public,cluster,state,apply,failed,shards,final,cluster,state,cluster,state,final,list,failed,shard,failed,shards,final,list,stale,shard,stale,shards,if,stale,shards,is,empty,failed,shards,is,empty,return,cluster,state,cluster,state,tmp,state,index,meta,data,updater,remove,stale,ids,without,routings,cluster,state,stale,shards,logger,routing,nodes,routing,nodes,get,mutable,routing,nodes,tmp,state,routing,nodes,unassigned,shuffle,long,current,nano,time,current,nano,time,routing,allocation,allocation,new,routing,allocation,allocation,deciders,routing,nodes,tmp,state,cluster,info,service,get,cluster,info,current,nano,time,for,failed,shard,failed,shard,entry,failed,shards,shard,routing,shard,to,fail,failed,shard,entry,get,routing,entry,index,meta,data,index,meta,data,allocation,meta,data,get,index,safe,shard,to,fail,shard,id,get,index,allocation,add,ignore,shard,for,node,shard,to,fail,shard,id,shard,to,fail,current,node,id,shard,routing,failed,shard,routing,nodes,get,by,allocation,id,shard,to,fail,shard,id,shard,to,fail,allocation,id,get,id,if,failed,shard,null,if,failed,shard,shard,to,fail,logger,trace,shard,routing,modified,in,an,earlier,iteration,previous,current,shard,to,fail,shard,id,shard,to,fail,failed,shard,int,failed,allocations,failed,shard,unassigned,info,null,failed,shard,unassigned,info,get,num,failed,allocations,0,string,message,failed,shard,on,node,shard,to,fail,current,node,id,failed,shard,entry,get,message,unassigned,info,unassigned,info,new,unassigned,info,unassigned,info,reason,message,failed,shard,entry,get,failure,failed,allocations,1,current,nano,time,system,current,time,millis,false,allocation,status,if,failed,shard,entry,mark,as,stale,allocation,remove,allocation,id,failed,shard,logger,warn,new,parameterized,message,failing,shard,failed,shard,entry,failed,shard,entry,get,failure,routing,nodes,fail,shard,logger,failed,shard,unassigned,info,index,meta,data,allocation,changes,else,logger,trace,shard,routing,failed,in,an,earlier,iteration,routing,shard,to,fail,shard,id,shard,to,fail,gateway,allocator,apply,failed,shards,allocation,failed,shards,reroute,allocation,string,failed,shards,as,string,first,list,elements,to,comma,delimited,string,failed,shards,s,s,get,routing,entry,shard,id,to,string,return,build,result,and,log,health,change,cluster,state,allocation,shards,failed,failed,shards,as,string
AllocationService -> public ClusterState applyFailedShards(final ClusterState clusterState, final List<FailedShard> failedShards,                                           final List<StaleShard> staleShards);1542402632;Applies the failed shards. Note, only assigned ShardRouting instances that exist in the routing table should be_provided as parameter. Also applies a list of allocation ids to remove from the in-sync set for shard copies for which there_are no routing entries in the routing table.__<p>_If the same instance of ClusterState is returned, then no change has been made.</p>;public ClusterState applyFailedShards(final ClusterState clusterState, final List<FailedShard> failedShards,_                                          final List<StaleShard> staleShards) {_        if (staleShards.isEmpty() && failedShards.isEmpty()) {_            return clusterState__        }_        ClusterState tmpState = IndexMetaDataUpdater.removeStaleIdsWithoutRoutings(clusterState, staleShards, logger)___        RoutingNodes routingNodes = getMutableRoutingNodes(tmpState)__        _        routingNodes.unassigned().shuffle()__        long currentNanoTime = currentNanoTime()__        RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, routingNodes, tmpState,_            clusterInfoService.getClusterInfo(), currentNanoTime)___        for (FailedShard failedShardEntry : failedShards) {_            ShardRouting shardToFail = failedShardEntry.getRoutingEntry()__            IndexMetaData indexMetaData = allocation.metaData().getIndexSafe(shardToFail.shardId().getIndex())__            allocation.addIgnoreShardForNode(shardToFail.shardId(), shardToFail.currentNodeId())__            _            ShardRouting failedShard = routingNodes.getByAllocationId(shardToFail.shardId(), shardToFail.allocationId().getId())__            if (failedShard != null) {_                if (failedShard != shardToFail) {_                    logger.trace("{} shard routing modified in an earlier iteration (previous: {}, current: {})",_                        shardToFail.shardId(), shardToFail, failedShard)__                }_                int failedAllocations = failedShard.unassignedInfo() != null ? failedShard.unassignedInfo().getNumFailedAllocations() : 0__                String message = "failed shard on node [" + shardToFail.currentNodeId() + "]: " + failedShardEntry.getMessage()__                UnassignedInfo unassignedInfo = new UnassignedInfo(UnassignedInfo.Reason.ALLOCATION_FAILED, message,_                    failedShardEntry.getFailure(), failedAllocations + 1, currentNanoTime, System.currentTimeMillis(), false,_                    AllocationStatus.NO_ATTEMPT)__                if (failedShardEntry.markAsStale()) {_                    allocation.removeAllocationId(failedShard)__                }_                logger.warn(new ParameterizedMessage("failing shard [{}]", failedShardEntry), failedShardEntry.getFailure())__                routingNodes.failShard(logger, failedShard, unassignedInfo, indexMetaData, allocation.changes())__            } else {_                logger.trace("{} shard routing failed in an earlier iteration (routing: {})", shardToFail.shardId(), shardToFail)__            }_        }_        gatewayAllocator.applyFailedShards(allocation, failedShards)___        reroute(allocation)__        String failedShardsAsString = firstListElementsToCommaDelimitedString(failedShards, s -> s.getRoutingEntry().shardId().toString())__        return buildResultAndLogHealthChange(clusterState, allocation, "shards failed [" + failedShardsAsString + "] ...")__    };applies,the,failed,shards,note,only,assigned,shard,routing,instances,that,exist,in,the,routing,table,should,be,provided,as,parameter,also,applies,a,list,of,allocation,ids,to,remove,from,the,in,sync,set,for,shard,copies,for,which,there,are,no,routing,entries,in,the,routing,table,p,if,the,same,instance,of,cluster,state,is,returned,then,no,change,has,been,made,p;public,cluster,state,apply,failed,shards,final,cluster,state,cluster,state,final,list,failed,shard,failed,shards,final,list,stale,shard,stale,shards,if,stale,shards,is,empty,failed,shards,is,empty,return,cluster,state,cluster,state,tmp,state,index,meta,data,updater,remove,stale,ids,without,routings,cluster,state,stale,shards,logger,routing,nodes,routing,nodes,get,mutable,routing,nodes,tmp,state,routing,nodes,unassigned,shuffle,long,current,nano,time,current,nano,time,routing,allocation,allocation,new,routing,allocation,allocation,deciders,routing,nodes,tmp,state,cluster,info,service,get,cluster,info,current,nano,time,for,failed,shard,failed,shard,entry,failed,shards,shard,routing,shard,to,fail,failed,shard,entry,get,routing,entry,index,meta,data,index,meta,data,allocation,meta,data,get,index,safe,shard,to,fail,shard,id,get,index,allocation,add,ignore,shard,for,node,shard,to,fail,shard,id,shard,to,fail,current,node,id,shard,routing,failed,shard,routing,nodes,get,by,allocation,id,shard,to,fail,shard,id,shard,to,fail,allocation,id,get,id,if,failed,shard,null,if,failed,shard,shard,to,fail,logger,trace,shard,routing,modified,in,an,earlier,iteration,previous,current,shard,to,fail,shard,id,shard,to,fail,failed,shard,int,failed,allocations,failed,shard,unassigned,info,null,failed,shard,unassigned,info,get,num,failed,allocations,0,string,message,failed,shard,on,node,shard,to,fail,current,node,id,failed,shard,entry,get,message,unassigned,info,unassigned,info,new,unassigned,info,unassigned,info,reason,message,failed,shard,entry,get,failure,failed,allocations,1,current,nano,time,system,current,time,millis,false,allocation,status,if,failed,shard,entry,mark,as,stale,allocation,remove,allocation,id,failed,shard,logger,warn,new,parameterized,message,failing,shard,failed,shard,entry,failed,shard,entry,get,failure,routing,nodes,fail,shard,logger,failed,shard,unassigned,info,index,meta,data,allocation,changes,else,logger,trace,shard,routing,failed,in,an,earlier,iteration,routing,shard,to,fail,shard,id,shard,to,fail,gateway,allocator,apply,failed,shards,allocation,failed,shards,reroute,allocation,string,failed,shards,as,string,first,list,elements,to,comma,delimited,string,failed,shards,s,s,get,routing,entry,shard,id,to,string,return,build,result,and,log,health,change,cluster,state,allocation,shards,failed,failed,shards,as,string
AllocationService -> public ClusterState applyFailedShards(final ClusterState clusterState, final List<FailedShard> failedShards,                                           final List<StaleShard> staleShards);1548161085;Applies the failed shards. Note, only assigned ShardRouting instances that exist in the routing table should be_provided as parameter. Also applies a list of allocation ids to remove from the in-sync set for shard copies for which there_are no routing entries in the routing table.__<p>_If the same instance of ClusterState is returned, then no change has been made.</p>;public ClusterState applyFailedShards(final ClusterState clusterState, final List<FailedShard> failedShards,_                                          final List<StaleShard> staleShards) {_        if (staleShards.isEmpty() && failedShards.isEmpty()) {_            return clusterState__        }_        ClusterState tmpState = IndexMetaDataUpdater.removeStaleIdsWithoutRoutings(clusterState, staleShards, logger)___        RoutingNodes routingNodes = getMutableRoutingNodes(tmpState)__        _        routingNodes.unassigned().shuffle()__        long currentNanoTime = currentNanoTime()__        RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, routingNodes, tmpState,_            clusterInfoService.getClusterInfo(), currentNanoTime)___        for (FailedShard failedShardEntry : failedShards) {_            ShardRouting shardToFail = failedShardEntry.getRoutingEntry()__            IndexMetaData indexMetaData = allocation.metaData().getIndexSafe(shardToFail.shardId().getIndex())__            allocation.addIgnoreShardForNode(shardToFail.shardId(), shardToFail.currentNodeId())__            _            ShardRouting failedShard = routingNodes.getByAllocationId(shardToFail.shardId(), shardToFail.allocationId().getId())__            if (failedShard != null) {_                if (failedShard != shardToFail) {_                    logger.trace("{} shard routing modified in an earlier iteration (previous: {}, current: {})",_                        shardToFail.shardId(), shardToFail, failedShard)__                }_                int failedAllocations = failedShard.unassignedInfo() != null ? failedShard.unassignedInfo().getNumFailedAllocations() : 0__                String message = "failed shard on node [" + shardToFail.currentNodeId() + "]: " + failedShardEntry.getMessage()__                UnassignedInfo unassignedInfo = new UnassignedInfo(UnassignedInfo.Reason.ALLOCATION_FAILED, message,_                    failedShardEntry.getFailure(), failedAllocations + 1, currentNanoTime, System.currentTimeMillis(), false,_                    AllocationStatus.NO_ATTEMPT)__                if (failedShardEntry.markAsStale()) {_                    allocation.removeAllocationId(failedShard)__                }_                logger.warn(new ParameterizedMessage("failing shard [{}]", failedShardEntry), failedShardEntry.getFailure())__                routingNodes.failShard(logger, failedShard, unassignedInfo, indexMetaData, allocation.changes())__            } else {_                logger.trace("{} shard routing failed in an earlier iteration (routing: {})", shardToFail.shardId(), shardToFail)__            }_        }_        gatewayAllocator.applyFailedShards(allocation, failedShards)___        reroute(allocation)__        String failedShardsAsString = firstListElementsToCommaDelimitedString(failedShards, s -> s.getRoutingEntry().shardId().toString())__        return buildResultAndLogHealthChange(clusterState, allocation, "shards failed [" + failedShardsAsString + "] ...")__    };applies,the,failed,shards,note,only,assigned,shard,routing,instances,that,exist,in,the,routing,table,should,be,provided,as,parameter,also,applies,a,list,of,allocation,ids,to,remove,from,the,in,sync,set,for,shard,copies,for,which,there,are,no,routing,entries,in,the,routing,table,p,if,the,same,instance,of,cluster,state,is,returned,then,no,change,has,been,made,p;public,cluster,state,apply,failed,shards,final,cluster,state,cluster,state,final,list,failed,shard,failed,shards,final,list,stale,shard,stale,shards,if,stale,shards,is,empty,failed,shards,is,empty,return,cluster,state,cluster,state,tmp,state,index,meta,data,updater,remove,stale,ids,without,routings,cluster,state,stale,shards,logger,routing,nodes,routing,nodes,get,mutable,routing,nodes,tmp,state,routing,nodes,unassigned,shuffle,long,current,nano,time,current,nano,time,routing,allocation,allocation,new,routing,allocation,allocation,deciders,routing,nodes,tmp,state,cluster,info,service,get,cluster,info,current,nano,time,for,failed,shard,failed,shard,entry,failed,shards,shard,routing,shard,to,fail,failed,shard,entry,get,routing,entry,index,meta,data,index,meta,data,allocation,meta,data,get,index,safe,shard,to,fail,shard,id,get,index,allocation,add,ignore,shard,for,node,shard,to,fail,shard,id,shard,to,fail,current,node,id,shard,routing,failed,shard,routing,nodes,get,by,allocation,id,shard,to,fail,shard,id,shard,to,fail,allocation,id,get,id,if,failed,shard,null,if,failed,shard,shard,to,fail,logger,trace,shard,routing,modified,in,an,earlier,iteration,previous,current,shard,to,fail,shard,id,shard,to,fail,failed,shard,int,failed,allocations,failed,shard,unassigned,info,null,failed,shard,unassigned,info,get,num,failed,allocations,0,string,message,failed,shard,on,node,shard,to,fail,current,node,id,failed,shard,entry,get,message,unassigned,info,unassigned,info,new,unassigned,info,unassigned,info,reason,message,failed,shard,entry,get,failure,failed,allocations,1,current,nano,time,system,current,time,millis,false,allocation,status,if,failed,shard,entry,mark,as,stale,allocation,remove,allocation,id,failed,shard,logger,warn,new,parameterized,message,failing,shard,failed,shard,entry,failed,shard,entry,get,failure,routing,nodes,fail,shard,logger,failed,shard,unassigned,info,index,meta,data,allocation,changes,else,logger,trace,shard,routing,failed,in,an,earlier,iteration,routing,shard,to,fail,shard,id,shard,to,fail,gateway,allocator,apply,failed,shards,allocation,failed,shards,reroute,allocation,string,failed,shards,as,string,first,list,elements,to,comma,delimited,string,failed,shards,s,s,get,routing,entry,shard,id,to,string,return,build,result,and,log,health,change,cluster,state,allocation,shards,failed,failed,shards,as,string
AllocationService -> public ClusterState applyFailedShards(final ClusterState clusterState, final List<FailedShard> failedShards,                                           final List<StaleShard> staleShards);1548259585;Applies the failed shards. Note, only assigned ShardRouting instances that exist in the routing table should be_provided as parameter. Also applies a list of allocation ids to remove from the in-sync set for shard copies for which there_are no routing entries in the routing table.__<p>_If the same instance of ClusterState is returned, then no change has been made.</p>;public ClusterState applyFailedShards(final ClusterState clusterState, final List<FailedShard> failedShards,_                                          final List<StaleShard> staleShards) {_        if (staleShards.isEmpty() && failedShards.isEmpty()) {_            return clusterState__        }_        ClusterState tmpState = IndexMetaDataUpdater.removeStaleIdsWithoutRoutings(clusterState, staleShards, logger)___        RoutingNodes routingNodes = getMutableRoutingNodes(tmpState)__        _        routingNodes.unassigned().shuffle()__        long currentNanoTime = currentNanoTime()__        RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, routingNodes, tmpState,_            clusterInfoService.getClusterInfo(), currentNanoTime)___        for (FailedShard failedShardEntry : failedShards) {_            ShardRouting shardToFail = failedShardEntry.getRoutingEntry()__            IndexMetaData indexMetaData = allocation.metaData().getIndexSafe(shardToFail.shardId().getIndex())__            allocation.addIgnoreShardForNode(shardToFail.shardId(), shardToFail.currentNodeId())__            _            ShardRouting failedShard = routingNodes.getByAllocationId(shardToFail.shardId(), shardToFail.allocationId().getId())__            if (failedShard != null) {_                if (failedShard != shardToFail) {_                    logger.trace("{} shard routing modified in an earlier iteration (previous: {}, current: {})",_                        shardToFail.shardId(), shardToFail, failedShard)__                }_                int failedAllocations = failedShard.unassignedInfo() != null ? failedShard.unassignedInfo().getNumFailedAllocations() : 0__                String message = "failed shard on node [" + shardToFail.currentNodeId() + "]: " + failedShardEntry.getMessage()__                UnassignedInfo unassignedInfo = new UnassignedInfo(UnassignedInfo.Reason.ALLOCATION_FAILED, message,_                    failedShardEntry.getFailure(), failedAllocations + 1, currentNanoTime, System.currentTimeMillis(), false,_                    AllocationStatus.NO_ATTEMPT)__                if (failedShardEntry.markAsStale()) {_                    allocation.removeAllocationId(failedShard)__                }_                logger.warn(new ParameterizedMessage("failing shard [{}]", failedShardEntry), failedShardEntry.getFailure())__                routingNodes.failShard(logger, failedShard, unassignedInfo, indexMetaData, allocation.changes())__            } else {_                logger.trace("{} shard routing failed in an earlier iteration (routing: {})", shardToFail.shardId(), shardToFail)__            }_        }_        gatewayAllocator.applyFailedShards(allocation, failedShards)___        reroute(allocation)__        String failedShardsAsString = firstListElementsToCommaDelimitedString(failedShards, s -> s.getRoutingEntry().shardId().toString())__        return buildResultAndLogHealthChange(clusterState, allocation, "shards failed [" + failedShardsAsString + "] ...")__    };applies,the,failed,shards,note,only,assigned,shard,routing,instances,that,exist,in,the,routing,table,should,be,provided,as,parameter,also,applies,a,list,of,allocation,ids,to,remove,from,the,in,sync,set,for,shard,copies,for,which,there,are,no,routing,entries,in,the,routing,table,p,if,the,same,instance,of,cluster,state,is,returned,then,no,change,has,been,made,p;public,cluster,state,apply,failed,shards,final,cluster,state,cluster,state,final,list,failed,shard,failed,shards,final,list,stale,shard,stale,shards,if,stale,shards,is,empty,failed,shards,is,empty,return,cluster,state,cluster,state,tmp,state,index,meta,data,updater,remove,stale,ids,without,routings,cluster,state,stale,shards,logger,routing,nodes,routing,nodes,get,mutable,routing,nodes,tmp,state,routing,nodes,unassigned,shuffle,long,current,nano,time,current,nano,time,routing,allocation,allocation,new,routing,allocation,allocation,deciders,routing,nodes,tmp,state,cluster,info,service,get,cluster,info,current,nano,time,for,failed,shard,failed,shard,entry,failed,shards,shard,routing,shard,to,fail,failed,shard,entry,get,routing,entry,index,meta,data,index,meta,data,allocation,meta,data,get,index,safe,shard,to,fail,shard,id,get,index,allocation,add,ignore,shard,for,node,shard,to,fail,shard,id,shard,to,fail,current,node,id,shard,routing,failed,shard,routing,nodes,get,by,allocation,id,shard,to,fail,shard,id,shard,to,fail,allocation,id,get,id,if,failed,shard,null,if,failed,shard,shard,to,fail,logger,trace,shard,routing,modified,in,an,earlier,iteration,previous,current,shard,to,fail,shard,id,shard,to,fail,failed,shard,int,failed,allocations,failed,shard,unassigned,info,null,failed,shard,unassigned,info,get,num,failed,allocations,0,string,message,failed,shard,on,node,shard,to,fail,current,node,id,failed,shard,entry,get,message,unassigned,info,unassigned,info,new,unassigned,info,unassigned,info,reason,message,failed,shard,entry,get,failure,failed,allocations,1,current,nano,time,system,current,time,millis,false,allocation,status,if,failed,shard,entry,mark,as,stale,allocation,remove,allocation,id,failed,shard,logger,warn,new,parameterized,message,failing,shard,failed,shard,entry,failed,shard,entry,get,failure,routing,nodes,fail,shard,logger,failed,shard,unassigned,info,index,meta,data,allocation,changes,else,logger,trace,shard,routing,failed,in,an,earlier,iteration,routing,shard,to,fail,shard,id,shard,to,fail,gateway,allocator,apply,failed,shards,allocation,failed,shards,reroute,allocation,string,failed,shards,as,string,first,list,elements,to,comma,delimited,string,failed,shards,s,s,get,routing,entry,shard,id,to,string,return,build,result,and,log,health,change,cluster,state,allocation,shards,failed,failed,shards,as,string
AllocationService -> public ClusterState applyFailedShards(final ClusterState clusterState, final List<FailedShard> failedShards,                                           final List<StaleShard> staleShards);1551086646;Applies the failed shards. Note, only assigned ShardRouting instances that exist in the routing table should be_provided as parameter. Also applies a list of allocation ids to remove from the in-sync set for shard copies for which there_are no routing entries in the routing table.__<p>_If the same instance of ClusterState is returned, then no change has been made.</p>;public ClusterState applyFailedShards(final ClusterState clusterState, final List<FailedShard> failedShards,_                                          final List<StaleShard> staleShards) {_        if (staleShards.isEmpty() && failedShards.isEmpty()) {_            return clusterState__        }_        ClusterState tmpState = IndexMetaDataUpdater.removeStaleIdsWithoutRoutings(clusterState, staleShards, logger)___        RoutingNodes routingNodes = getMutableRoutingNodes(tmpState)__        _        routingNodes.unassigned().shuffle()__        long currentNanoTime = currentNanoTime()__        RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, routingNodes, tmpState,_            clusterInfoService.getClusterInfo(), currentNanoTime)___        for (FailedShard failedShardEntry : failedShards) {_            ShardRouting shardToFail = failedShardEntry.getRoutingEntry()__            IndexMetaData indexMetaData = allocation.metaData().getIndexSafe(shardToFail.shardId().getIndex())__            allocation.addIgnoreShardForNode(shardToFail.shardId(), shardToFail.currentNodeId())__            _            ShardRouting failedShard = routingNodes.getByAllocationId(shardToFail.shardId(), shardToFail.allocationId().getId())__            if (failedShard != null) {_                if (failedShard != shardToFail) {_                    logger.trace("{} shard routing modified in an earlier iteration (previous: {}, current: {})",_                        shardToFail.shardId(), shardToFail, failedShard)__                }_                int failedAllocations = failedShard.unassignedInfo() != null ? failedShard.unassignedInfo().getNumFailedAllocations() : 0__                String message = "failed shard on node [" + shardToFail.currentNodeId() + "]: " + failedShardEntry.getMessage()__                UnassignedInfo unassignedInfo = new UnassignedInfo(UnassignedInfo.Reason.ALLOCATION_FAILED, message,_                    failedShardEntry.getFailure(), failedAllocations + 1, currentNanoTime, System.currentTimeMillis(), false,_                    AllocationStatus.NO_ATTEMPT)__                if (failedShardEntry.markAsStale()) {_                    allocation.removeAllocationId(failedShard)__                }_                logger.warn(new ParameterizedMessage("failing shard [{}]", failedShardEntry), failedShardEntry.getFailure())__                routingNodes.failShard(logger, failedShard, unassignedInfo, indexMetaData, allocation.changes())__            } else {_                logger.trace("{} shard routing failed in an earlier iteration (routing: {})", shardToFail.shardId(), shardToFail)__            }_        }_        gatewayAllocator.applyFailedShards(allocation, failedShards)___        reroute(allocation)__        String failedShardsAsString = firstListElementsToCommaDelimitedString(failedShards, s -> s.getRoutingEntry().shardId().toString())__        return buildResultAndLogHealthChange(clusterState, allocation, "shards failed [" + failedShardsAsString + "] ...")__    };applies,the,failed,shards,note,only,assigned,shard,routing,instances,that,exist,in,the,routing,table,should,be,provided,as,parameter,also,applies,a,list,of,allocation,ids,to,remove,from,the,in,sync,set,for,shard,copies,for,which,there,are,no,routing,entries,in,the,routing,table,p,if,the,same,instance,of,cluster,state,is,returned,then,no,change,has,been,made,p;public,cluster,state,apply,failed,shards,final,cluster,state,cluster,state,final,list,failed,shard,failed,shards,final,list,stale,shard,stale,shards,if,stale,shards,is,empty,failed,shards,is,empty,return,cluster,state,cluster,state,tmp,state,index,meta,data,updater,remove,stale,ids,without,routings,cluster,state,stale,shards,logger,routing,nodes,routing,nodes,get,mutable,routing,nodes,tmp,state,routing,nodes,unassigned,shuffle,long,current,nano,time,current,nano,time,routing,allocation,allocation,new,routing,allocation,allocation,deciders,routing,nodes,tmp,state,cluster,info,service,get,cluster,info,current,nano,time,for,failed,shard,failed,shard,entry,failed,shards,shard,routing,shard,to,fail,failed,shard,entry,get,routing,entry,index,meta,data,index,meta,data,allocation,meta,data,get,index,safe,shard,to,fail,shard,id,get,index,allocation,add,ignore,shard,for,node,shard,to,fail,shard,id,shard,to,fail,current,node,id,shard,routing,failed,shard,routing,nodes,get,by,allocation,id,shard,to,fail,shard,id,shard,to,fail,allocation,id,get,id,if,failed,shard,null,if,failed,shard,shard,to,fail,logger,trace,shard,routing,modified,in,an,earlier,iteration,previous,current,shard,to,fail,shard,id,shard,to,fail,failed,shard,int,failed,allocations,failed,shard,unassigned,info,null,failed,shard,unassigned,info,get,num,failed,allocations,0,string,message,failed,shard,on,node,shard,to,fail,current,node,id,failed,shard,entry,get,message,unassigned,info,unassigned,info,new,unassigned,info,unassigned,info,reason,message,failed,shard,entry,get,failure,failed,allocations,1,current,nano,time,system,current,time,millis,false,allocation,status,if,failed,shard,entry,mark,as,stale,allocation,remove,allocation,id,failed,shard,logger,warn,new,parameterized,message,failing,shard,failed,shard,entry,failed,shard,entry,get,failure,routing,nodes,fail,shard,logger,failed,shard,unassigned,info,index,meta,data,allocation,changes,else,logger,trace,shard,routing,failed,in,an,earlier,iteration,routing,shard,to,fail,shard,id,shard,to,fail,gateway,allocator,apply,failed,shards,allocation,failed,shards,reroute,allocation,string,failed,shards,as,string,first,list,elements,to,comma,delimited,string,failed,shards,s,s,get,routing,entry,shard,id,to,string,return,build,result,and,log,health,change,cluster,state,allocation,shards,failed,failed,shards,as,string
AllocationService -> private void removeDelayMarkers(RoutingAllocation allocation);1524684173;Removes delay markers from unassigned shards based on current time stamp.;private void removeDelayMarkers(RoutingAllocation allocation) {_        final RoutingNodes.UnassignedShards.UnassignedIterator unassignedIterator = allocation.routingNodes().unassigned().iterator()__        final MetaData metaData = allocation.metaData()__        while (unassignedIterator.hasNext()) {_            ShardRouting shardRouting = unassignedIterator.next()__            UnassignedInfo unassignedInfo = shardRouting.unassignedInfo()__            if (unassignedInfo.isDelayed()) {_                final long newComputedLeftDelayNanos = unassignedInfo.getRemainingDelay(allocation.getCurrentNanoTime(),_                    metaData.getIndexSafe(shardRouting.index()).getSettings())__                if (newComputedLeftDelayNanos == 0) {_                    unassignedIterator.updateUnassigned(new UnassignedInfo(unassignedInfo.getReason(), unassignedInfo.getMessage(),_                        unassignedInfo.getFailure(), unassignedInfo.getNumFailedAllocations(), unassignedInfo.getUnassignedTimeInNanos(),_                        unassignedInfo.getUnassignedTimeInMillis(), false, unassignedInfo.getLastAllocationStatus()),_                        shardRouting.recoverySource(), allocation.changes())__                }_            }_        }_    };removes,delay,markers,from,unassigned,shards,based,on,current,time,stamp;private,void,remove,delay,markers,routing,allocation,allocation,final,routing,nodes,unassigned,shards,unassigned,iterator,unassigned,iterator,allocation,routing,nodes,unassigned,iterator,final,meta,data,meta,data,allocation,meta,data,while,unassigned,iterator,has,next,shard,routing,shard,routing,unassigned,iterator,next,unassigned,info,unassigned,info,shard,routing,unassigned,info,if,unassigned,info,is,delayed,final,long,new,computed,left,delay,nanos,unassigned,info,get,remaining,delay,allocation,get,current,nano,time,meta,data,get,index,safe,shard,routing,index,get,settings,if,new,computed,left,delay,nanos,0,unassigned,iterator,update,unassigned,new,unassigned,info,unassigned,info,get,reason,unassigned,info,get,message,unassigned,info,get,failure,unassigned,info,get,num,failed,allocations,unassigned,info,get,unassigned,time,in,nanos,unassigned,info,get,unassigned,time,in,millis,false,unassigned,info,get,last,allocation,status,shard,routing,recovery,source,allocation,changes
AllocationService -> private void removeDelayMarkers(RoutingAllocation allocation);1525798022;Removes delay markers from unassigned shards based on current time stamp.;private void removeDelayMarkers(RoutingAllocation allocation) {_        final RoutingNodes.UnassignedShards.UnassignedIterator unassignedIterator = allocation.routingNodes().unassigned().iterator()__        final MetaData metaData = allocation.metaData()__        while (unassignedIterator.hasNext()) {_            ShardRouting shardRouting = unassignedIterator.next()__            UnassignedInfo unassignedInfo = shardRouting.unassignedInfo()__            if (unassignedInfo.isDelayed()) {_                final long newComputedLeftDelayNanos = unassignedInfo.getRemainingDelay(allocation.getCurrentNanoTime(),_                    metaData.getIndexSafe(shardRouting.index()).getSettings())__                if (newComputedLeftDelayNanos == 0) {_                    unassignedIterator.updateUnassigned(new UnassignedInfo(unassignedInfo.getReason(), unassignedInfo.getMessage(),_                        unassignedInfo.getFailure(), unassignedInfo.getNumFailedAllocations(), unassignedInfo.getUnassignedTimeInNanos(),_                        unassignedInfo.getUnassignedTimeInMillis(), false, unassignedInfo.getLastAllocationStatus()),_                        shardRouting.recoverySource(), allocation.changes())__                }_            }_        }_    };removes,delay,markers,from,unassigned,shards,based,on,current,time,stamp;private,void,remove,delay,markers,routing,allocation,allocation,final,routing,nodes,unassigned,shards,unassigned,iterator,unassigned,iterator,allocation,routing,nodes,unassigned,iterator,final,meta,data,meta,data,allocation,meta,data,while,unassigned,iterator,has,next,shard,routing,shard,routing,unassigned,iterator,next,unassigned,info,unassigned,info,shard,routing,unassigned,info,if,unassigned,info,is,delayed,final,long,new,computed,left,delay,nanos,unassigned,info,get,remaining,delay,allocation,get,current,nano,time,meta,data,get,index,safe,shard,routing,index,get,settings,if,new,computed,left,delay,nanos,0,unassigned,iterator,update,unassigned,new,unassigned,info,unassigned,info,get,reason,unassigned,info,get,message,unassigned,info,get,failure,unassigned,info,get,num,failed,allocations,unassigned,info,get,unassigned,time,in,nanos,unassigned,info,get,unassigned,time,in,millis,false,unassigned,info,get,last,allocation,status,shard,routing,recovery,source,allocation,changes
AllocationService -> private void removeDelayMarkers(RoutingAllocation allocation);1526374795;Removes delay markers from unassigned shards based on current time stamp.;private void removeDelayMarkers(RoutingAllocation allocation) {_        final RoutingNodes.UnassignedShards.UnassignedIterator unassignedIterator = allocation.routingNodes().unassigned().iterator()__        final MetaData metaData = allocation.metaData()__        while (unassignedIterator.hasNext()) {_            ShardRouting shardRouting = unassignedIterator.next()__            UnassignedInfo unassignedInfo = shardRouting.unassignedInfo()__            if (unassignedInfo.isDelayed()) {_                final long newComputedLeftDelayNanos = unassignedInfo.getRemainingDelay(allocation.getCurrentNanoTime(),_                    metaData.getIndexSafe(shardRouting.index()).getSettings())__                if (newComputedLeftDelayNanos == 0) {_                    unassignedIterator.updateUnassigned(new UnassignedInfo(unassignedInfo.getReason(), unassignedInfo.getMessage(),_                        unassignedInfo.getFailure(), unassignedInfo.getNumFailedAllocations(), unassignedInfo.getUnassignedTimeInNanos(),_                        unassignedInfo.getUnassignedTimeInMillis(), false, unassignedInfo.getLastAllocationStatus()),_                        shardRouting.recoverySource(), allocation.changes())__                }_            }_        }_    };removes,delay,markers,from,unassigned,shards,based,on,current,time,stamp;private,void,remove,delay,markers,routing,allocation,allocation,final,routing,nodes,unassigned,shards,unassigned,iterator,unassigned,iterator,allocation,routing,nodes,unassigned,iterator,final,meta,data,meta,data,allocation,meta,data,while,unassigned,iterator,has,next,shard,routing,shard,routing,unassigned,iterator,next,unassigned,info,unassigned,info,shard,routing,unassigned,info,if,unassigned,info,is,delayed,final,long,new,computed,left,delay,nanos,unassigned,info,get,remaining,delay,allocation,get,current,nano,time,meta,data,get,index,safe,shard,routing,index,get,settings,if,new,computed,left,delay,nanos,0,unassigned,iterator,update,unassigned,new,unassigned,info,unassigned,info,get,reason,unassigned,info,get,message,unassigned,info,get,failure,unassigned,info,get,num,failed,allocations,unassigned,info,get,unassigned,time,in,nanos,unassigned,info,get,unassigned,time,in,millis,false,unassigned,info,get,last,allocation,status,shard,routing,recovery,source,allocation,changes
AllocationService -> private void removeDelayMarkers(RoutingAllocation allocation);1539723533;Removes delay markers from unassigned shards based on current time stamp.;private void removeDelayMarkers(RoutingAllocation allocation) {_        final RoutingNodes.UnassignedShards.UnassignedIterator unassignedIterator = allocation.routingNodes().unassigned().iterator()__        final MetaData metaData = allocation.metaData()__        while (unassignedIterator.hasNext()) {_            ShardRouting shardRouting = unassignedIterator.next()__            UnassignedInfo unassignedInfo = shardRouting.unassignedInfo()__            if (unassignedInfo.isDelayed()) {_                final long newComputedLeftDelayNanos = unassignedInfo.getRemainingDelay(allocation.getCurrentNanoTime(),_                    metaData.getIndexSafe(shardRouting.index()).getSettings())__                if (newComputedLeftDelayNanos == 0) {_                    unassignedIterator.updateUnassigned(new UnassignedInfo(unassignedInfo.getReason(), unassignedInfo.getMessage(),_                        unassignedInfo.getFailure(), unassignedInfo.getNumFailedAllocations(), unassignedInfo.getUnassignedTimeInNanos(),_                        unassignedInfo.getUnassignedTimeInMillis(), false, unassignedInfo.getLastAllocationStatus()),_                        shardRouting.recoverySource(), allocation.changes())__                }_            }_        }_    };removes,delay,markers,from,unassigned,shards,based,on,current,time,stamp;private,void,remove,delay,markers,routing,allocation,allocation,final,routing,nodes,unassigned,shards,unassigned,iterator,unassigned,iterator,allocation,routing,nodes,unassigned,iterator,final,meta,data,meta,data,allocation,meta,data,while,unassigned,iterator,has,next,shard,routing,shard,routing,unassigned,iterator,next,unassigned,info,unassigned,info,shard,routing,unassigned,info,if,unassigned,info,is,delayed,final,long,new,computed,left,delay,nanos,unassigned,info,get,remaining,delay,allocation,get,current,nano,time,meta,data,get,index,safe,shard,routing,index,get,settings,if,new,computed,left,delay,nanos,0,unassigned,iterator,update,unassigned,new,unassigned,info,unassigned,info,get,reason,unassigned,info,get,message,unassigned,info,get,failure,unassigned,info,get,num,failed,allocations,unassigned,info,get,unassigned,time,in,nanos,unassigned,info,get,unassigned,time,in,millis,false,unassigned,info,get,last,allocation,status,shard,routing,recovery,source,allocation,changes
AllocationService -> private void removeDelayMarkers(RoutingAllocation allocation);1541092382;Removes delay markers from unassigned shards based on current time stamp.;private void removeDelayMarkers(RoutingAllocation allocation) {_        final RoutingNodes.UnassignedShards.UnassignedIterator unassignedIterator = allocation.routingNodes().unassigned().iterator()__        final MetaData metaData = allocation.metaData()__        while (unassignedIterator.hasNext()) {_            ShardRouting shardRouting = unassignedIterator.next()__            UnassignedInfo unassignedInfo = shardRouting.unassignedInfo()__            if (unassignedInfo.isDelayed()) {_                final long newComputedLeftDelayNanos = unassignedInfo.getRemainingDelay(allocation.getCurrentNanoTime(),_                    metaData.getIndexSafe(shardRouting.index()).getSettings())__                if (newComputedLeftDelayNanos == 0) {_                    unassignedIterator.updateUnassigned(new UnassignedInfo(unassignedInfo.getReason(), unassignedInfo.getMessage(),_                        unassignedInfo.getFailure(), unassignedInfo.getNumFailedAllocations(), unassignedInfo.getUnassignedTimeInNanos(),_                        unassignedInfo.getUnassignedTimeInMillis(), false, unassignedInfo.getLastAllocationStatus()),_                        shardRouting.recoverySource(), allocation.changes())__                }_            }_        }_    };removes,delay,markers,from,unassigned,shards,based,on,current,time,stamp;private,void,remove,delay,markers,routing,allocation,allocation,final,routing,nodes,unassigned,shards,unassigned,iterator,unassigned,iterator,allocation,routing,nodes,unassigned,iterator,final,meta,data,meta,data,allocation,meta,data,while,unassigned,iterator,has,next,shard,routing,shard,routing,unassigned,iterator,next,unassigned,info,unassigned,info,shard,routing,unassigned,info,if,unassigned,info,is,delayed,final,long,new,computed,left,delay,nanos,unassigned,info,get,remaining,delay,allocation,get,current,nano,time,meta,data,get,index,safe,shard,routing,index,get,settings,if,new,computed,left,delay,nanos,0,unassigned,iterator,update,unassigned,new,unassigned,info,unassigned,info,get,reason,unassigned,info,get,message,unassigned,info,get,failure,unassigned,info,get,num,failed,allocations,unassigned,info,get,unassigned,time,in,nanos,unassigned,info,get,unassigned,time,in,millis,false,unassigned,info,get,last,allocation,status,shard,routing,recovery,source,allocation,changes
AllocationService -> private void removeDelayMarkers(RoutingAllocation allocation);1542402632;Removes delay markers from unassigned shards based on current time stamp.;private void removeDelayMarkers(RoutingAllocation allocation) {_        final RoutingNodes.UnassignedShards.UnassignedIterator unassignedIterator = allocation.routingNodes().unassigned().iterator()__        final MetaData metaData = allocation.metaData()__        while (unassignedIterator.hasNext()) {_            ShardRouting shardRouting = unassignedIterator.next()__            UnassignedInfo unassignedInfo = shardRouting.unassignedInfo()__            if (unassignedInfo.isDelayed()) {_                final long newComputedLeftDelayNanos = unassignedInfo.getRemainingDelay(allocation.getCurrentNanoTime(),_                    metaData.getIndexSafe(shardRouting.index()).getSettings())__                if (newComputedLeftDelayNanos == 0) {_                    unassignedIterator.updateUnassigned(new UnassignedInfo(unassignedInfo.getReason(), unassignedInfo.getMessage(),_                        unassignedInfo.getFailure(), unassignedInfo.getNumFailedAllocations(), unassignedInfo.getUnassignedTimeInNanos(),_                        unassignedInfo.getUnassignedTimeInMillis(), false, unassignedInfo.getLastAllocationStatus()),_                        shardRouting.recoverySource(), allocation.changes())__                }_            }_        }_    };removes,delay,markers,from,unassigned,shards,based,on,current,time,stamp;private,void,remove,delay,markers,routing,allocation,allocation,final,routing,nodes,unassigned,shards,unassigned,iterator,unassigned,iterator,allocation,routing,nodes,unassigned,iterator,final,meta,data,meta,data,allocation,meta,data,while,unassigned,iterator,has,next,shard,routing,shard,routing,unassigned,iterator,next,unassigned,info,unassigned,info,shard,routing,unassigned,info,if,unassigned,info,is,delayed,final,long,new,computed,left,delay,nanos,unassigned,info,get,remaining,delay,allocation,get,current,nano,time,meta,data,get,index,safe,shard,routing,index,get,settings,if,new,computed,left,delay,nanos,0,unassigned,iterator,update,unassigned,new,unassigned,info,unassigned,info,get,reason,unassigned,info,get,message,unassigned,info,get,failure,unassigned,info,get,num,failed,allocations,unassigned,info,get,unassigned,time,in,nanos,unassigned,info,get,unassigned,time,in,millis,false,unassigned,info,get,last,allocation,status,shard,routing,recovery,source,allocation,changes
AllocationService -> private void removeDelayMarkers(RoutingAllocation allocation);1548161085;Removes delay markers from unassigned shards based on current time stamp.;private void removeDelayMarkers(RoutingAllocation allocation) {_        final RoutingNodes.UnassignedShards.UnassignedIterator unassignedIterator = allocation.routingNodes().unassigned().iterator()__        final MetaData metaData = allocation.metaData()__        while (unassignedIterator.hasNext()) {_            ShardRouting shardRouting = unassignedIterator.next()__            UnassignedInfo unassignedInfo = shardRouting.unassignedInfo()__            if (unassignedInfo.isDelayed()) {_                final long newComputedLeftDelayNanos = unassignedInfo.getRemainingDelay(allocation.getCurrentNanoTime(),_                    metaData.getIndexSafe(shardRouting.index()).getSettings())__                if (newComputedLeftDelayNanos == 0) {_                    unassignedIterator.updateUnassigned(new UnassignedInfo(unassignedInfo.getReason(), unassignedInfo.getMessage(),_                        unassignedInfo.getFailure(), unassignedInfo.getNumFailedAllocations(), unassignedInfo.getUnassignedTimeInNanos(),_                        unassignedInfo.getUnassignedTimeInMillis(), false, unassignedInfo.getLastAllocationStatus()),_                        shardRouting.recoverySource(), allocation.changes())__                }_            }_        }_    };removes,delay,markers,from,unassigned,shards,based,on,current,time,stamp;private,void,remove,delay,markers,routing,allocation,allocation,final,routing,nodes,unassigned,shards,unassigned,iterator,unassigned,iterator,allocation,routing,nodes,unassigned,iterator,final,meta,data,meta,data,allocation,meta,data,while,unassigned,iterator,has,next,shard,routing,shard,routing,unassigned,iterator,next,unassigned,info,unassigned,info,shard,routing,unassigned,info,if,unassigned,info,is,delayed,final,long,new,computed,left,delay,nanos,unassigned,info,get,remaining,delay,allocation,get,current,nano,time,meta,data,get,index,safe,shard,routing,index,get,settings,if,new,computed,left,delay,nanos,0,unassigned,iterator,update,unassigned,new,unassigned,info,unassigned,info,get,reason,unassigned,info,get,message,unassigned,info,get,failure,unassigned,info,get,num,failed,allocations,unassigned,info,get,unassigned,time,in,nanos,unassigned,info,get,unassigned,time,in,millis,false,unassigned,info,get,last,allocation,status,shard,routing,recovery,source,allocation,changes
AllocationService -> private void removeDelayMarkers(RoutingAllocation allocation);1548259585;Removes delay markers from unassigned shards based on current time stamp.;private void removeDelayMarkers(RoutingAllocation allocation) {_        final RoutingNodes.UnassignedShards.UnassignedIterator unassignedIterator = allocation.routingNodes().unassigned().iterator()__        final MetaData metaData = allocation.metaData()__        while (unassignedIterator.hasNext()) {_            ShardRouting shardRouting = unassignedIterator.next()__            UnassignedInfo unassignedInfo = shardRouting.unassignedInfo()__            if (unassignedInfo.isDelayed()) {_                final long newComputedLeftDelayNanos = unassignedInfo.getRemainingDelay(allocation.getCurrentNanoTime(),_                    metaData.getIndexSafe(shardRouting.index()).getSettings())__                if (newComputedLeftDelayNanos == 0) {_                    unassignedIterator.updateUnassigned(new UnassignedInfo(unassignedInfo.getReason(), unassignedInfo.getMessage(),_                        unassignedInfo.getFailure(), unassignedInfo.getNumFailedAllocations(), unassignedInfo.getUnassignedTimeInNanos(),_                        unassignedInfo.getUnassignedTimeInMillis(), false, unassignedInfo.getLastAllocationStatus()),_                        shardRouting.recoverySource(), allocation.changes())__                }_            }_        }_    };removes,delay,markers,from,unassigned,shards,based,on,current,time,stamp;private,void,remove,delay,markers,routing,allocation,allocation,final,routing,nodes,unassigned,shards,unassigned,iterator,unassigned,iterator,allocation,routing,nodes,unassigned,iterator,final,meta,data,meta,data,allocation,meta,data,while,unassigned,iterator,has,next,shard,routing,shard,routing,unassigned,iterator,next,unassigned,info,unassigned,info,shard,routing,unassigned,info,if,unassigned,info,is,delayed,final,long,new,computed,left,delay,nanos,unassigned,info,get,remaining,delay,allocation,get,current,nano,time,meta,data,get,index,safe,shard,routing,index,get,settings,if,new,computed,left,delay,nanos,0,unassigned,iterator,update,unassigned,new,unassigned,info,unassigned,info,get,reason,unassigned,info,get,message,unassigned,info,get,failure,unassigned,info,get,num,failed,allocations,unassigned,info,get,unassigned,time,in,nanos,unassigned,info,get,unassigned,time,in,millis,false,unassigned,info,get,last,allocation,status,shard,routing,recovery,source,allocation,changes
AllocationService -> private void removeDelayMarkers(RoutingAllocation allocation);1551086646;Removes delay markers from unassigned shards based on current time stamp.;private void removeDelayMarkers(RoutingAllocation allocation) {_        final RoutingNodes.UnassignedShards.UnassignedIterator unassignedIterator = allocation.routingNodes().unassigned().iterator()__        final MetaData metaData = allocation.metaData()__        while (unassignedIterator.hasNext()) {_            ShardRouting shardRouting = unassignedIterator.next()__            UnassignedInfo unassignedInfo = shardRouting.unassignedInfo()__            if (unassignedInfo.isDelayed()) {_                final long newComputedLeftDelayNanos = unassignedInfo.getRemainingDelay(allocation.getCurrentNanoTime(),_                    metaData.getIndexSafe(shardRouting.index()).getSettings())__                if (newComputedLeftDelayNanos == 0) {_                    unassignedIterator.updateUnassigned(new UnassignedInfo(unassignedInfo.getReason(), unassignedInfo.getMessage(),_                        unassignedInfo.getFailure(), unassignedInfo.getNumFailedAllocations(), unassignedInfo.getUnassignedTimeInNanos(),_                        unassignedInfo.getUnassignedTimeInMillis(), false, unassignedInfo.getLastAllocationStatus()),_                        shardRouting.recoverySource(), allocation.changes())__                }_            }_        }_    };removes,delay,markers,from,unassigned,shards,based,on,current,time,stamp;private,void,remove,delay,markers,routing,allocation,allocation,final,routing,nodes,unassigned,shards,unassigned,iterator,unassigned,iterator,allocation,routing,nodes,unassigned,iterator,final,meta,data,meta,data,allocation,meta,data,while,unassigned,iterator,has,next,shard,routing,shard,routing,unassigned,iterator,next,unassigned,info,unassigned,info,shard,routing,unassigned,info,if,unassigned,info,is,delayed,final,long,new,computed,left,delay,nanos,unassigned,info,get,remaining,delay,allocation,get,current,nano,time,meta,data,get,index,safe,shard,routing,index,get,settings,if,new,computed,left,delay,nanos,0,unassigned,iterator,update,unassigned,new,unassigned,info,unassigned,info,get,reason,unassigned,info,get,message,unassigned,info,get,failure,unassigned,info,get,num,failed,allocations,unassigned,info,get,unassigned,time,in,nanos,unassigned,info,get,unassigned,time,in,millis,false,unassigned,info,get,last,allocation,status,shard,routing,recovery,source,allocation,changes
AllocationService -> CommandsResult -> public ClusterState getClusterState();1524684173;the resulting cluster state, after the commands were applied;public ClusterState getClusterState() {_            return clusterState__        };the,resulting,cluster,state,after,the,commands,were,applied;public,cluster,state,get,cluster,state,return,cluster,state
AllocationService -> CommandsResult -> public ClusterState getClusterState();1525798022;the resulting cluster state, after the commands were applied;public ClusterState getClusterState() {_            return clusterState__        };the,resulting,cluster,state,after,the,commands,were,applied;public,cluster,state,get,cluster,state,return,cluster,state
AllocationService -> CommandsResult -> public ClusterState getClusterState();1526374795;the resulting cluster state, after the commands were applied;public ClusterState getClusterState() {_            return clusterState__        };the,resulting,cluster,state,after,the,commands,were,applied;public,cluster,state,get,cluster,state,return,cluster,state
AllocationService -> CommandsResult -> public ClusterState getClusterState();1539723533;the resulting cluster state, after the commands were applied;public ClusterState getClusterState() {_            return clusterState__        };the,resulting,cluster,state,after,the,commands,were,applied;public,cluster,state,get,cluster,state,return,cluster,state
AllocationService -> CommandsResult -> public ClusterState getClusterState();1541092382;the resulting cluster state, after the commands were applied;public ClusterState getClusterState() {_            return clusterState__        };the,resulting,cluster,state,after,the,commands,were,applied;public,cluster,state,get,cluster,state,return,cluster,state
AllocationService -> CommandsResult -> public ClusterState getClusterState();1542402632;the resulting cluster state, after the commands were applied;public ClusterState getClusterState() {_            return clusterState__        };the,resulting,cluster,state,after,the,commands,were,applied;public,cluster,state,get,cluster,state,return,cluster,state
AllocationService -> CommandsResult -> public ClusterState getClusterState();1548161085;the resulting cluster state, after the commands were applied;public ClusterState getClusterState() {_            return clusterState__        };the,resulting,cluster,state,after,the,commands,were,applied;public,cluster,state,get,cluster,state,return,cluster,state
AllocationService -> CommandsResult -> public ClusterState getClusterState();1548259585;the resulting cluster state, after the commands were applied;public ClusterState getClusterState() {_            return clusterState__        };the,resulting,cluster,state,after,the,commands,were,applied;public,cluster,state,get,cluster,state,return,cluster,state
AllocationService -> CommandsResult -> public ClusterState getClusterState();1551086646;the resulting cluster state, after the commands were applied;public ClusterState getClusterState() {_            return clusterState__        };the,resulting,cluster,state,after,the,commands,were,applied;public,cluster,state,get,cluster,state,return,cluster,state
AllocationService -> private ClusterState adaptAutoExpandReplicas(ClusterState clusterState);1525798022;Checks if the are replicas with the auto-expand feature that need to be adapted._Returns an updated cluster state if changes were necessary, or the identical cluster if no changes were required.;private ClusterState adaptAutoExpandReplicas(ClusterState clusterState) {_        final Map<Integer, List<String>> autoExpandReplicaChanges =_            AutoExpandReplicas.getAutoExpandReplicaChanges(clusterState.metaData(), clusterState.nodes())__        if (autoExpandReplicaChanges.isEmpty()) {_            return clusterState__        } else {_            final RoutingTable.Builder routingTableBuilder = RoutingTable.builder(clusterState.routingTable())__            final MetaData.Builder metaDataBuilder = MetaData.builder(clusterState.metaData())__            for (Map.Entry<Integer, List<String>> entry : autoExpandReplicaChanges.entrySet()) {_                final int numberOfReplicas = entry.getKey()__                final String[] indices = entry.getValue().toArray(new String[entry.getValue().size()])__                _                _                routingTableBuilder.updateNumberOfReplicas(numberOfReplicas, indices)__                metaDataBuilder.updateNumberOfReplicas(numberOfReplicas, indices)__                logger.info("updating number_of_replicas to [{}] for indices {}", numberOfReplicas, indices)__            }_            final ClusterState fixedState = ClusterState.builder(clusterState).routingTable(routingTableBuilder.build())_                .metaData(metaDataBuilder).build()__            assert AutoExpandReplicas.getAutoExpandReplicaChanges(fixedState.metaData(), fixedState.nodes()).isEmpty()__            return fixedState__        }_    };checks,if,the,are,replicas,with,the,auto,expand,feature,that,need,to,be,adapted,returns,an,updated,cluster,state,if,changes,were,necessary,or,the,identical,cluster,if,no,changes,were,required;private,cluster,state,adapt,auto,expand,replicas,cluster,state,cluster,state,final,map,integer,list,string,auto,expand,replica,changes,auto,expand,replicas,get,auto,expand,replica,changes,cluster,state,meta,data,cluster,state,nodes,if,auto,expand,replica,changes,is,empty,return,cluster,state,else,final,routing,table,builder,routing,table,builder,routing,table,builder,cluster,state,routing,table,final,meta,data,builder,meta,data,builder,meta,data,builder,cluster,state,meta,data,for,map,entry,integer,list,string,entry,auto,expand,replica,changes,entry,set,final,int,number,of,replicas,entry,get,key,final,string,indices,entry,get,value,to,array,new,string,entry,get,value,size,routing,table,builder,update,number,of,replicas,number,of,replicas,indices,meta,data,builder,update,number,of,replicas,number,of,replicas,indices,logger,info,updating,to,for,indices,number,of,replicas,indices,final,cluster,state,fixed,state,cluster,state,builder,cluster,state,routing,table,routing,table,builder,build,meta,data,meta,data,builder,build,assert,auto,expand,replicas,get,auto,expand,replica,changes,fixed,state,meta,data,fixed,state,nodes,is,empty,return,fixed,state
AllocationService -> private ClusterState adaptAutoExpandReplicas(ClusterState clusterState);1526374795;Checks if the are replicas with the auto-expand feature that need to be adapted._Returns an updated cluster state if changes were necessary, or the identical cluster if no changes were required.;private ClusterState adaptAutoExpandReplicas(ClusterState clusterState) {_        final Map<Integer, List<String>> autoExpandReplicaChanges =_            AutoExpandReplicas.getAutoExpandReplicaChanges(clusterState.metaData(), clusterState.nodes())__        if (autoExpandReplicaChanges.isEmpty()) {_            return clusterState__        } else {_            final RoutingTable.Builder routingTableBuilder = RoutingTable.builder(clusterState.routingTable())__            final MetaData.Builder metaDataBuilder = MetaData.builder(clusterState.metaData())__            for (Map.Entry<Integer, List<String>> entry : autoExpandReplicaChanges.entrySet()) {_                final int numberOfReplicas = entry.getKey()__                final String[] indices = entry.getValue().toArray(new String[entry.getValue().size()])__                _                _                routingTableBuilder.updateNumberOfReplicas(numberOfReplicas, indices)__                metaDataBuilder.updateNumberOfReplicas(numberOfReplicas, indices)__                logger.info("updating number_of_replicas to [{}] for indices {}", numberOfReplicas, indices)__            }_            final ClusterState fixedState = ClusterState.builder(clusterState).routingTable(routingTableBuilder.build())_                .metaData(metaDataBuilder).build()__            assert AutoExpandReplicas.getAutoExpandReplicaChanges(fixedState.metaData(), fixedState.nodes()).isEmpty()__            return fixedState__        }_    };checks,if,the,are,replicas,with,the,auto,expand,feature,that,need,to,be,adapted,returns,an,updated,cluster,state,if,changes,were,necessary,or,the,identical,cluster,if,no,changes,were,required;private,cluster,state,adapt,auto,expand,replicas,cluster,state,cluster,state,final,map,integer,list,string,auto,expand,replica,changes,auto,expand,replicas,get,auto,expand,replica,changes,cluster,state,meta,data,cluster,state,nodes,if,auto,expand,replica,changes,is,empty,return,cluster,state,else,final,routing,table,builder,routing,table,builder,routing,table,builder,cluster,state,routing,table,final,meta,data,builder,meta,data,builder,meta,data,builder,cluster,state,meta,data,for,map,entry,integer,list,string,entry,auto,expand,replica,changes,entry,set,final,int,number,of,replicas,entry,get,key,final,string,indices,entry,get,value,to,array,new,string,entry,get,value,size,routing,table,builder,update,number,of,replicas,number,of,replicas,indices,meta,data,builder,update,number,of,replicas,number,of,replicas,indices,logger,info,updating,to,for,indices,number,of,replicas,indices,final,cluster,state,fixed,state,cluster,state,builder,cluster,state,routing,table,routing,table,builder,build,meta,data,meta,data,builder,build,assert,auto,expand,replicas,get,auto,expand,replica,changes,fixed,state,meta,data,fixed,state,nodes,is,empty,return,fixed,state
AllocationService -> private ClusterState adaptAutoExpandReplicas(ClusterState clusterState);1539723533;Checks if the are replicas with the auto-expand feature that need to be adapted._Returns an updated cluster state if changes were necessary, or the identical cluster if no changes were required.;private ClusterState adaptAutoExpandReplicas(ClusterState clusterState) {_        final Map<Integer, List<String>> autoExpandReplicaChanges =_            AutoExpandReplicas.getAutoExpandReplicaChanges(clusterState.metaData(), clusterState.nodes())__        if (autoExpandReplicaChanges.isEmpty()) {_            return clusterState__        } else {_            final RoutingTable.Builder routingTableBuilder = RoutingTable.builder(clusterState.routingTable())__            final MetaData.Builder metaDataBuilder = MetaData.builder(clusterState.metaData())__            for (Map.Entry<Integer, List<String>> entry : autoExpandReplicaChanges.entrySet()) {_                final int numberOfReplicas = entry.getKey()__                final String[] indices = entry.getValue().toArray(new String[entry.getValue().size()])__                _                _                routingTableBuilder.updateNumberOfReplicas(numberOfReplicas, indices)__                metaDataBuilder.updateNumberOfReplicas(numberOfReplicas, indices)__                _                for (final String index : indices) {_                    final IndexMetaData indexMetaData = metaDataBuilder.get(index)__                    final IndexMetaData.Builder indexMetaDataBuilder =_                            new IndexMetaData.Builder(indexMetaData).settingsVersion(1 + indexMetaData.getSettingsVersion())__                    metaDataBuilder.put(indexMetaDataBuilder)__                }_                logger.info("updating number_of_replicas to [{}] for indices {}", numberOfReplicas, indices)__            }_            final ClusterState fixedState = ClusterState.builder(clusterState).routingTable(routingTableBuilder.build())_                .metaData(metaDataBuilder).build()__            assert AutoExpandReplicas.getAutoExpandReplicaChanges(fixedState.metaData(), fixedState.nodes()).isEmpty()__            return fixedState__        }_    };checks,if,the,are,replicas,with,the,auto,expand,feature,that,need,to,be,adapted,returns,an,updated,cluster,state,if,changes,were,necessary,or,the,identical,cluster,if,no,changes,were,required;private,cluster,state,adapt,auto,expand,replicas,cluster,state,cluster,state,final,map,integer,list,string,auto,expand,replica,changes,auto,expand,replicas,get,auto,expand,replica,changes,cluster,state,meta,data,cluster,state,nodes,if,auto,expand,replica,changes,is,empty,return,cluster,state,else,final,routing,table,builder,routing,table,builder,routing,table,builder,cluster,state,routing,table,final,meta,data,builder,meta,data,builder,meta,data,builder,cluster,state,meta,data,for,map,entry,integer,list,string,entry,auto,expand,replica,changes,entry,set,final,int,number,of,replicas,entry,get,key,final,string,indices,entry,get,value,to,array,new,string,entry,get,value,size,routing,table,builder,update,number,of,replicas,number,of,replicas,indices,meta,data,builder,update,number,of,replicas,number,of,replicas,indices,for,final,string,index,indices,final,index,meta,data,index,meta,data,meta,data,builder,get,index,final,index,meta,data,builder,index,meta,data,builder,new,index,meta,data,builder,index,meta,data,settings,version,1,index,meta,data,get,settings,version,meta,data,builder,put,index,meta,data,builder,logger,info,updating,to,for,indices,number,of,replicas,indices,final,cluster,state,fixed,state,cluster,state,builder,cluster,state,routing,table,routing,table,builder,build,meta,data,meta,data,builder,build,assert,auto,expand,replicas,get,auto,expand,replica,changes,fixed,state,meta,data,fixed,state,nodes,is,empty,return,fixed,state
AllocationService -> private ClusterState adaptAutoExpandReplicas(ClusterState clusterState);1541092382;Checks if the are replicas with the auto-expand feature that need to be adapted._Returns an updated cluster state if changes were necessary, or the identical cluster if no changes were required.;private ClusterState adaptAutoExpandReplicas(ClusterState clusterState) {_        final Map<Integer, List<String>> autoExpandReplicaChanges =_            AutoExpandReplicas.getAutoExpandReplicaChanges(clusterState.metaData(), clusterState.nodes())__        if (autoExpandReplicaChanges.isEmpty()) {_            return clusterState__        } else {_            final RoutingTable.Builder routingTableBuilder = RoutingTable.builder(clusterState.routingTable())__            final MetaData.Builder metaDataBuilder = MetaData.builder(clusterState.metaData())__            for (Map.Entry<Integer, List<String>> entry : autoExpandReplicaChanges.entrySet()) {_                final int numberOfReplicas = entry.getKey()__                final String[] indices = entry.getValue().toArray(new String[entry.getValue().size()])__                _                _                routingTableBuilder.updateNumberOfReplicas(numberOfReplicas, indices)__                metaDataBuilder.updateNumberOfReplicas(numberOfReplicas, indices)__                _                for (final String index : indices) {_                    final IndexMetaData indexMetaData = metaDataBuilder.get(index)__                    final IndexMetaData.Builder indexMetaDataBuilder =_                            new IndexMetaData.Builder(indexMetaData).settingsVersion(1 + indexMetaData.getSettingsVersion())__                    metaDataBuilder.put(indexMetaDataBuilder)__                }_                logger.info("updating number_of_replicas to [{}] for indices {}", numberOfReplicas, indices)__            }_            final ClusterState fixedState = ClusterState.builder(clusterState).routingTable(routingTableBuilder.build())_                .metaData(metaDataBuilder).build()__            assert AutoExpandReplicas.getAutoExpandReplicaChanges(fixedState.metaData(), fixedState.nodes()).isEmpty()__            return fixedState__        }_    };checks,if,the,are,replicas,with,the,auto,expand,feature,that,need,to,be,adapted,returns,an,updated,cluster,state,if,changes,were,necessary,or,the,identical,cluster,if,no,changes,were,required;private,cluster,state,adapt,auto,expand,replicas,cluster,state,cluster,state,final,map,integer,list,string,auto,expand,replica,changes,auto,expand,replicas,get,auto,expand,replica,changes,cluster,state,meta,data,cluster,state,nodes,if,auto,expand,replica,changes,is,empty,return,cluster,state,else,final,routing,table,builder,routing,table,builder,routing,table,builder,cluster,state,routing,table,final,meta,data,builder,meta,data,builder,meta,data,builder,cluster,state,meta,data,for,map,entry,integer,list,string,entry,auto,expand,replica,changes,entry,set,final,int,number,of,replicas,entry,get,key,final,string,indices,entry,get,value,to,array,new,string,entry,get,value,size,routing,table,builder,update,number,of,replicas,number,of,replicas,indices,meta,data,builder,update,number,of,replicas,number,of,replicas,indices,for,final,string,index,indices,final,index,meta,data,index,meta,data,meta,data,builder,get,index,final,index,meta,data,builder,index,meta,data,builder,new,index,meta,data,builder,index,meta,data,settings,version,1,index,meta,data,get,settings,version,meta,data,builder,put,index,meta,data,builder,logger,info,updating,to,for,indices,number,of,replicas,indices,final,cluster,state,fixed,state,cluster,state,builder,cluster,state,routing,table,routing,table,builder,build,meta,data,meta,data,builder,build,assert,auto,expand,replicas,get,auto,expand,replica,changes,fixed,state,meta,data,fixed,state,nodes,is,empty,return,fixed,state
AllocationService -> private ClusterState adaptAutoExpandReplicas(ClusterState clusterState);1542402632;Checks if the are replicas with the auto-expand feature that need to be adapted._Returns an updated cluster state if changes were necessary, or the identical cluster if no changes were required.;private ClusterState adaptAutoExpandReplicas(ClusterState clusterState) {_        final Map<Integer, List<String>> autoExpandReplicaChanges =_            AutoExpandReplicas.getAutoExpandReplicaChanges(clusterState.metaData(), clusterState.nodes())__        if (autoExpandReplicaChanges.isEmpty()) {_            return clusterState__        } else {_            final RoutingTable.Builder routingTableBuilder = RoutingTable.builder(clusterState.routingTable())__            final MetaData.Builder metaDataBuilder = MetaData.builder(clusterState.metaData())__            for (Map.Entry<Integer, List<String>> entry : autoExpandReplicaChanges.entrySet()) {_                final int numberOfReplicas = entry.getKey()__                final String[] indices = entry.getValue().toArray(new String[entry.getValue().size()])__                _                _                routingTableBuilder.updateNumberOfReplicas(numberOfReplicas, indices)__                metaDataBuilder.updateNumberOfReplicas(numberOfReplicas, indices)__                _                for (final String index : indices) {_                    final IndexMetaData indexMetaData = metaDataBuilder.get(index)__                    final IndexMetaData.Builder indexMetaDataBuilder =_                            new IndexMetaData.Builder(indexMetaData).settingsVersion(1 + indexMetaData.getSettingsVersion())__                    metaDataBuilder.put(indexMetaDataBuilder)__                }_                logger.info("updating number_of_replicas to [{}] for indices {}", numberOfReplicas, indices)__            }_            final ClusterState fixedState = ClusterState.builder(clusterState).routingTable(routingTableBuilder.build())_                .metaData(metaDataBuilder).build()__            assert AutoExpandReplicas.getAutoExpandReplicaChanges(fixedState.metaData(), fixedState.nodes()).isEmpty()__            return fixedState__        }_    };checks,if,the,are,replicas,with,the,auto,expand,feature,that,need,to,be,adapted,returns,an,updated,cluster,state,if,changes,were,necessary,or,the,identical,cluster,if,no,changes,were,required;private,cluster,state,adapt,auto,expand,replicas,cluster,state,cluster,state,final,map,integer,list,string,auto,expand,replica,changes,auto,expand,replicas,get,auto,expand,replica,changes,cluster,state,meta,data,cluster,state,nodes,if,auto,expand,replica,changes,is,empty,return,cluster,state,else,final,routing,table,builder,routing,table,builder,routing,table,builder,cluster,state,routing,table,final,meta,data,builder,meta,data,builder,meta,data,builder,cluster,state,meta,data,for,map,entry,integer,list,string,entry,auto,expand,replica,changes,entry,set,final,int,number,of,replicas,entry,get,key,final,string,indices,entry,get,value,to,array,new,string,entry,get,value,size,routing,table,builder,update,number,of,replicas,number,of,replicas,indices,meta,data,builder,update,number,of,replicas,number,of,replicas,indices,for,final,string,index,indices,final,index,meta,data,index,meta,data,meta,data,builder,get,index,final,index,meta,data,builder,index,meta,data,builder,new,index,meta,data,builder,index,meta,data,settings,version,1,index,meta,data,get,settings,version,meta,data,builder,put,index,meta,data,builder,logger,info,updating,to,for,indices,number,of,replicas,indices,final,cluster,state,fixed,state,cluster,state,builder,cluster,state,routing,table,routing,table,builder,build,meta,data,meta,data,builder,build,assert,auto,expand,replicas,get,auto,expand,replica,changes,fixed,state,meta,data,fixed,state,nodes,is,empty,return,fixed,state
AllocationService -> private ClusterState adaptAutoExpandReplicas(ClusterState clusterState);1548161085;Checks if the are replicas with the auto-expand feature that need to be adapted._Returns an updated cluster state if changes were necessary, or the identical cluster if no changes were required.;private ClusterState adaptAutoExpandReplicas(ClusterState clusterState) {_        final Map<Integer, List<String>> autoExpandReplicaChanges =_            AutoExpandReplicas.getAutoExpandReplicaChanges(clusterState.metaData(), clusterState.nodes())__        if (autoExpandReplicaChanges.isEmpty()) {_            return clusterState__        } else {_            final RoutingTable.Builder routingTableBuilder = RoutingTable.builder(clusterState.routingTable())__            final MetaData.Builder metaDataBuilder = MetaData.builder(clusterState.metaData())__            for (Map.Entry<Integer, List<String>> entry : autoExpandReplicaChanges.entrySet()) {_                final int numberOfReplicas = entry.getKey()__                final String[] indices = entry.getValue().toArray(new String[entry.getValue().size()])__                _                _                routingTableBuilder.updateNumberOfReplicas(numberOfReplicas, indices)__                metaDataBuilder.updateNumberOfReplicas(numberOfReplicas, indices)__                _                for (final String index : indices) {_                    final IndexMetaData indexMetaData = metaDataBuilder.get(index)__                    final IndexMetaData.Builder indexMetaDataBuilder =_                            new IndexMetaData.Builder(indexMetaData).settingsVersion(1 + indexMetaData.getSettingsVersion())__                    metaDataBuilder.put(indexMetaDataBuilder)__                }_                logger.info("updating number_of_replicas to [{}] for indices {}", numberOfReplicas, indices)__            }_            final ClusterState fixedState = ClusterState.builder(clusterState).routingTable(routingTableBuilder.build())_                .metaData(metaDataBuilder).build()__            assert AutoExpandReplicas.getAutoExpandReplicaChanges(fixedState.metaData(), fixedState.nodes()).isEmpty()__            return fixedState__        }_    };checks,if,the,are,replicas,with,the,auto,expand,feature,that,need,to,be,adapted,returns,an,updated,cluster,state,if,changes,were,necessary,or,the,identical,cluster,if,no,changes,were,required;private,cluster,state,adapt,auto,expand,replicas,cluster,state,cluster,state,final,map,integer,list,string,auto,expand,replica,changes,auto,expand,replicas,get,auto,expand,replica,changes,cluster,state,meta,data,cluster,state,nodes,if,auto,expand,replica,changes,is,empty,return,cluster,state,else,final,routing,table,builder,routing,table,builder,routing,table,builder,cluster,state,routing,table,final,meta,data,builder,meta,data,builder,meta,data,builder,cluster,state,meta,data,for,map,entry,integer,list,string,entry,auto,expand,replica,changes,entry,set,final,int,number,of,replicas,entry,get,key,final,string,indices,entry,get,value,to,array,new,string,entry,get,value,size,routing,table,builder,update,number,of,replicas,number,of,replicas,indices,meta,data,builder,update,number,of,replicas,number,of,replicas,indices,for,final,string,index,indices,final,index,meta,data,index,meta,data,meta,data,builder,get,index,final,index,meta,data,builder,index,meta,data,builder,new,index,meta,data,builder,index,meta,data,settings,version,1,index,meta,data,get,settings,version,meta,data,builder,put,index,meta,data,builder,logger,info,updating,to,for,indices,number,of,replicas,indices,final,cluster,state,fixed,state,cluster,state,builder,cluster,state,routing,table,routing,table,builder,build,meta,data,meta,data,builder,build,assert,auto,expand,replicas,get,auto,expand,replica,changes,fixed,state,meta,data,fixed,state,nodes,is,empty,return,fixed,state
AllocationService -> private ClusterState adaptAutoExpandReplicas(ClusterState clusterState);1548259585;Checks if the are replicas with the auto-expand feature that need to be adapted._Returns an updated cluster state if changes were necessary, or the identical cluster if no changes were required.;private ClusterState adaptAutoExpandReplicas(ClusterState clusterState) {_        final Map<Integer, List<String>> autoExpandReplicaChanges =_            AutoExpandReplicas.getAutoExpandReplicaChanges(clusterState.metaData(), clusterState.nodes())__        if (autoExpandReplicaChanges.isEmpty()) {_            return clusterState__        } else {_            final RoutingTable.Builder routingTableBuilder = RoutingTable.builder(clusterState.routingTable())__            final MetaData.Builder metaDataBuilder = MetaData.builder(clusterState.metaData())__            for (Map.Entry<Integer, List<String>> entry : autoExpandReplicaChanges.entrySet()) {_                final int numberOfReplicas = entry.getKey()__                final String[] indices = entry.getValue().toArray(new String[entry.getValue().size()])__                _                _                routingTableBuilder.updateNumberOfReplicas(numberOfReplicas, indices)__                metaDataBuilder.updateNumberOfReplicas(numberOfReplicas, indices)__                _                for (final String index : indices) {_                    final IndexMetaData indexMetaData = metaDataBuilder.get(index)__                    final IndexMetaData.Builder indexMetaDataBuilder =_                            new IndexMetaData.Builder(indexMetaData).settingsVersion(1 + indexMetaData.getSettingsVersion())__                    metaDataBuilder.put(indexMetaDataBuilder)__                }_                logger.info("updating number_of_replicas to [{}] for indices {}", numberOfReplicas, indices)__            }_            final ClusterState fixedState = ClusterState.builder(clusterState).routingTable(routingTableBuilder.build())_                .metaData(metaDataBuilder).build()__            assert AutoExpandReplicas.getAutoExpandReplicaChanges(fixedState.metaData(), fixedState.nodes()).isEmpty()__            return fixedState__        }_    };checks,if,the,are,replicas,with,the,auto,expand,feature,that,need,to,be,adapted,returns,an,updated,cluster,state,if,changes,were,necessary,or,the,identical,cluster,if,no,changes,were,required;private,cluster,state,adapt,auto,expand,replicas,cluster,state,cluster,state,final,map,integer,list,string,auto,expand,replica,changes,auto,expand,replicas,get,auto,expand,replica,changes,cluster,state,meta,data,cluster,state,nodes,if,auto,expand,replica,changes,is,empty,return,cluster,state,else,final,routing,table,builder,routing,table,builder,routing,table,builder,cluster,state,routing,table,final,meta,data,builder,meta,data,builder,meta,data,builder,cluster,state,meta,data,for,map,entry,integer,list,string,entry,auto,expand,replica,changes,entry,set,final,int,number,of,replicas,entry,get,key,final,string,indices,entry,get,value,to,array,new,string,entry,get,value,size,routing,table,builder,update,number,of,replicas,number,of,replicas,indices,meta,data,builder,update,number,of,replicas,number,of,replicas,indices,for,final,string,index,indices,final,index,meta,data,index,meta,data,meta,data,builder,get,index,final,index,meta,data,builder,index,meta,data,builder,new,index,meta,data,builder,index,meta,data,settings,version,1,index,meta,data,get,settings,version,meta,data,builder,put,index,meta,data,builder,logger,info,updating,to,for,indices,number,of,replicas,indices,final,cluster,state,fixed,state,cluster,state,builder,cluster,state,routing,table,routing,table,builder,build,meta,data,meta,data,builder,build,assert,auto,expand,replicas,get,auto,expand,replica,changes,fixed,state,meta,data,fixed,state,nodes,is,empty,return,fixed,state
AllocationService -> private ClusterState adaptAutoExpandReplicas(ClusterState clusterState);1551086646;Checks if the are replicas with the auto-expand feature that need to be adapted._Returns an updated cluster state if changes were necessary, or the identical cluster if no changes were required.;private ClusterState adaptAutoExpandReplicas(ClusterState clusterState) {_        final Map<Integer, List<String>> autoExpandReplicaChanges =_            AutoExpandReplicas.getAutoExpandReplicaChanges(clusterState.metaData(), clusterState.nodes())__        if (autoExpandReplicaChanges.isEmpty()) {_            return clusterState__        } else {_            final RoutingTable.Builder routingTableBuilder = RoutingTable.builder(clusterState.routingTable())__            final MetaData.Builder metaDataBuilder = MetaData.builder(clusterState.metaData())__            for (Map.Entry<Integer, List<String>> entry : autoExpandReplicaChanges.entrySet()) {_                final int numberOfReplicas = entry.getKey()__                final String[] indices = entry.getValue().toArray(new String[entry.getValue().size()])__                _                _                routingTableBuilder.updateNumberOfReplicas(numberOfReplicas, indices)__                metaDataBuilder.updateNumberOfReplicas(numberOfReplicas, indices)__                _                for (final String index : indices) {_                    final IndexMetaData indexMetaData = metaDataBuilder.get(index)__                    final IndexMetaData.Builder indexMetaDataBuilder =_                            new IndexMetaData.Builder(indexMetaData).settingsVersion(1 + indexMetaData.getSettingsVersion())__                    metaDataBuilder.put(indexMetaDataBuilder)__                }_                logger.info("updating number_of_replicas to [{}] for indices {}", numberOfReplicas, indices)__            }_            final ClusterState fixedState = ClusterState.builder(clusterState).routingTable(routingTableBuilder.build())_                .metaData(metaDataBuilder).build()__            assert AutoExpandReplicas.getAutoExpandReplicaChanges(fixedState.metaData(), fixedState.nodes()).isEmpty()__            return fixedState__        }_    };checks,if,the,are,replicas,with,the,auto,expand,feature,that,need,to,be,adapted,returns,an,updated,cluster,state,if,changes,were,necessary,or,the,identical,cluster,if,no,changes,were,required;private,cluster,state,adapt,auto,expand,replicas,cluster,state,cluster,state,final,map,integer,list,string,auto,expand,replica,changes,auto,expand,replicas,get,auto,expand,replica,changes,cluster,state,meta,data,cluster,state,nodes,if,auto,expand,replica,changes,is,empty,return,cluster,state,else,final,routing,table,builder,routing,table,builder,routing,table,builder,cluster,state,routing,table,final,meta,data,builder,meta,data,builder,meta,data,builder,cluster,state,meta,data,for,map,entry,integer,list,string,entry,auto,expand,replica,changes,entry,set,final,int,number,of,replicas,entry,get,key,final,string,indices,entry,get,value,to,array,new,string,entry,get,value,size,routing,table,builder,update,number,of,replicas,number,of,replicas,indices,meta,data,builder,update,number,of,replicas,number,of,replicas,indices,for,final,string,index,indices,final,index,meta,data,index,meta,data,meta,data,builder,get,index,final,index,meta,data,builder,index,meta,data,builder,new,index,meta,data,builder,index,meta,data,settings,version,1,index,meta,data,get,settings,version,meta,data,builder,put,index,meta,data,builder,logger,info,updating,to,for,indices,number,of,replicas,indices,final,cluster,state,fixed,state,cluster,state,builder,cluster,state,routing,table,routing,table,builder,build,meta,data,meta,data,builder,build,assert,auto,expand,replicas,get,auto,expand,replica,changes,fixed,state,meta,data,fixed,state,nodes,is,empty,return,fixed,state
AllocationService -> public ClusterState reroute(ClusterState clusterState, String reason);1524684173;Reroutes the routing table based on the live nodes._<p>_If the same instance of ClusterState is returned, then no change has been made.;public ClusterState reroute(ClusterState clusterState, String reason) {_        return reroute(clusterState, reason, false)__    };reroutes,the,routing,table,based,on,the,live,nodes,p,if,the,same,instance,of,cluster,state,is,returned,then,no,change,has,been,made;public,cluster,state,reroute,cluster,state,cluster,state,string,reason,return,reroute,cluster,state,reason,false
AllocationService -> public ClusterState reroute(ClusterState clusterState, String reason);1525798022;Reroutes the routing table based on the live nodes._<p>_If the same instance of ClusterState is returned, then no change has been made.;public ClusterState reroute(ClusterState clusterState, String reason) {_        return reroute(clusterState, reason, false)__    };reroutes,the,routing,table,based,on,the,live,nodes,p,if,the,same,instance,of,cluster,state,is,returned,then,no,change,has,been,made;public,cluster,state,reroute,cluster,state,cluster,state,string,reason,return,reroute,cluster,state,reason,false
AllocationService -> public ClusterState reroute(ClusterState clusterState, String reason);1526374795;Reroutes the routing table based on the live nodes._<p>_If the same instance of ClusterState is returned, then no change has been made.;public ClusterState reroute(ClusterState clusterState, String reason) {_        return reroute(clusterState, reason, false)__    };reroutes,the,routing,table,based,on,the,live,nodes,p,if,the,same,instance,of,cluster,state,is,returned,then,no,change,has,been,made;public,cluster,state,reroute,cluster,state,cluster,state,string,reason,return,reroute,cluster,state,reason,false
AllocationService -> public ClusterState reroute(ClusterState clusterState, String reason);1539723533;Reroutes the routing table based on the live nodes._<p>_If the same instance of ClusterState is returned, then no change has been made.;public ClusterState reroute(ClusterState clusterState, String reason) {_        return reroute(clusterState, reason, false)__    };reroutes,the,routing,table,based,on,the,live,nodes,p,if,the,same,instance,of,cluster,state,is,returned,then,no,change,has,been,made;public,cluster,state,reroute,cluster,state,cluster,state,string,reason,return,reroute,cluster,state,reason,false
AllocationService -> public ClusterState reroute(ClusterState clusterState, String reason);1541092382;Reroutes the routing table based on the live nodes._<p>_If the same instance of ClusterState is returned, then no change has been made.;public ClusterState reroute(ClusterState clusterState, String reason) {_        return reroute(clusterState, reason, false)__    };reroutes,the,routing,table,based,on,the,live,nodes,p,if,the,same,instance,of,cluster,state,is,returned,then,no,change,has,been,made;public,cluster,state,reroute,cluster,state,cluster,state,string,reason,return,reroute,cluster,state,reason,false
AllocationService -> public ClusterState reroute(ClusterState clusterState, String reason);1542402632;Reroutes the routing table based on the live nodes._<p>_If the same instance of ClusterState is returned, then no change has been made.;public ClusterState reroute(ClusterState clusterState, String reason) {_        return reroute(clusterState, reason, false)__    };reroutes,the,routing,table,based,on,the,live,nodes,p,if,the,same,instance,of,cluster,state,is,returned,then,no,change,has,been,made;public,cluster,state,reroute,cluster,state,cluster,state,string,reason,return,reroute,cluster,state,reason,false
AllocationService -> public ClusterState reroute(ClusterState clusterState, String reason);1548161085;Reroutes the routing table based on the live nodes._<p>_If the same instance of ClusterState is returned, then no change has been made.;public ClusterState reroute(ClusterState clusterState, String reason) {_        return reroute(clusterState, reason, false)__    };reroutes,the,routing,table,based,on,the,live,nodes,p,if,the,same,instance,of,cluster,state,is,returned,then,no,change,has,been,made;public,cluster,state,reroute,cluster,state,cluster,state,string,reason,return,reroute,cluster,state,reason,false
AllocationService -> public ClusterState reroute(ClusterState clusterState, String reason);1548259585;Reroutes the routing table based on the live nodes._<p>_If the same instance of ClusterState is returned, then no change has been made.;public ClusterState reroute(ClusterState clusterState, String reason) {_        return reroute(clusterState, reason, false)__    };reroutes,the,routing,table,based,on,the,live,nodes,p,if,the,same,instance,of,cluster,state,is,returned,then,no,change,has,been,made;public,cluster,state,reroute,cluster,state,cluster,state,string,reason,return,reroute,cluster,state,reason,false
AllocationService -> public ClusterState reroute(ClusterState clusterState, String reason);1551086646;Reroutes the routing table based on the live nodes._<p>_If the same instance of ClusterState is returned, then no change has been made.;public ClusterState reroute(ClusterState clusterState, String reason) {_        return reroute(clusterState, reason, false)__    };reroutes,the,routing,table,based,on,the,live,nodes,p,if,the,same,instance,of,cluster,state,is,returned,then,no,change,has,been,made;public,cluster,state,reroute,cluster,state,cluster,state,string,reason,return,reroute,cluster,state,reason,false
AllocationService -> CommandsResult -> private CommandsResult(RoutingExplanations explanations, ClusterState clusterState);1524684173;Creates a new {@link CommandsResult}_@param explanations Explanation for the reroute actions_@param clusterState Resulting cluster state;private CommandsResult(RoutingExplanations explanations, ClusterState clusterState) {_            this.clusterState = clusterState__            this.explanations = explanations__        };creates,a,new,link,commands,result,param,explanations,explanation,for,the,reroute,actions,param,cluster,state,resulting,cluster,state;private,commands,result,routing,explanations,explanations,cluster,state,cluster,state,this,cluster,state,cluster,state,this,explanations,explanations
AllocationService -> CommandsResult -> private CommandsResult(RoutingExplanations explanations, ClusterState clusterState);1525798022;Creates a new {@link CommandsResult}_@param explanations Explanation for the reroute actions_@param clusterState Resulting cluster state;private CommandsResult(RoutingExplanations explanations, ClusterState clusterState) {_            this.clusterState = clusterState__            this.explanations = explanations__        };creates,a,new,link,commands,result,param,explanations,explanation,for,the,reroute,actions,param,cluster,state,resulting,cluster,state;private,commands,result,routing,explanations,explanations,cluster,state,cluster,state,this,cluster,state,cluster,state,this,explanations,explanations
AllocationService -> CommandsResult -> private CommandsResult(RoutingExplanations explanations, ClusterState clusterState);1526374795;Creates a new {@link CommandsResult}_@param explanations Explanation for the reroute actions_@param clusterState Resulting cluster state;private CommandsResult(RoutingExplanations explanations, ClusterState clusterState) {_            this.clusterState = clusterState__            this.explanations = explanations__        };creates,a,new,link,commands,result,param,explanations,explanation,for,the,reroute,actions,param,cluster,state,resulting,cluster,state;private,commands,result,routing,explanations,explanations,cluster,state,cluster,state,this,cluster,state,cluster,state,this,explanations,explanations
AllocationService -> CommandsResult -> private CommandsResult(RoutingExplanations explanations, ClusterState clusterState);1539723533;Creates a new {@link CommandsResult}_@param explanations Explanation for the reroute actions_@param clusterState Resulting cluster state;private CommandsResult(RoutingExplanations explanations, ClusterState clusterState) {_            this.clusterState = clusterState__            this.explanations = explanations__        };creates,a,new,link,commands,result,param,explanations,explanation,for,the,reroute,actions,param,cluster,state,resulting,cluster,state;private,commands,result,routing,explanations,explanations,cluster,state,cluster,state,this,cluster,state,cluster,state,this,explanations,explanations
AllocationService -> CommandsResult -> private CommandsResult(RoutingExplanations explanations, ClusterState clusterState);1541092382;Creates a new {@link CommandsResult}_@param explanations Explanation for the reroute actions_@param clusterState Resulting cluster state;private CommandsResult(RoutingExplanations explanations, ClusterState clusterState) {_            this.clusterState = clusterState__            this.explanations = explanations__        };creates,a,new,link,commands,result,param,explanations,explanation,for,the,reroute,actions,param,cluster,state,resulting,cluster,state;private,commands,result,routing,explanations,explanations,cluster,state,cluster,state,this,cluster,state,cluster,state,this,explanations,explanations
AllocationService -> CommandsResult -> private CommandsResult(RoutingExplanations explanations, ClusterState clusterState);1542402632;Creates a new {@link CommandsResult}_@param explanations Explanation for the reroute actions_@param clusterState Resulting cluster state;private CommandsResult(RoutingExplanations explanations, ClusterState clusterState) {_            this.clusterState = clusterState__            this.explanations = explanations__        };creates,a,new,link,commands,result,param,explanations,explanation,for,the,reroute,actions,param,cluster,state,resulting,cluster,state;private,commands,result,routing,explanations,explanations,cluster,state,cluster,state,this,cluster,state,cluster,state,this,explanations,explanations
AllocationService -> CommandsResult -> private CommandsResult(RoutingExplanations explanations, ClusterState clusterState);1548161085;Creates a new {@link CommandsResult}_@param explanations Explanation for the reroute actions_@param clusterState Resulting cluster state;private CommandsResult(RoutingExplanations explanations, ClusterState clusterState) {_            this.clusterState = clusterState__            this.explanations = explanations__        };creates,a,new,link,commands,result,param,explanations,explanation,for,the,reroute,actions,param,cluster,state,resulting,cluster,state;private,commands,result,routing,explanations,explanations,cluster,state,cluster,state,this,cluster,state,cluster,state,this,explanations,explanations
AllocationService -> CommandsResult -> private CommandsResult(RoutingExplanations explanations, ClusterState clusterState);1548259585;Creates a new {@link CommandsResult}_@param explanations Explanation for the reroute actions_@param clusterState Resulting cluster state;private CommandsResult(RoutingExplanations explanations, ClusterState clusterState) {_            this.clusterState = clusterState__            this.explanations = explanations__        };creates,a,new,link,commands,result,param,explanations,explanation,for,the,reroute,actions,param,cluster,state,resulting,cluster,state;private,commands,result,routing,explanations,explanations,cluster,state,cluster,state,this,cluster,state,cluster,state,this,explanations,explanations
AllocationService -> CommandsResult -> private CommandsResult(RoutingExplanations explanations, ClusterState clusterState);1551086646;Creates a new {@link CommandsResult}_@param explanations Explanation for the reroute actions_@param clusterState Resulting cluster state;private CommandsResult(RoutingExplanations explanations, ClusterState clusterState) {_            this.clusterState = clusterState__            this.explanations = explanations__        };creates,a,new,link,commands,result,param,explanations,explanation,for,the,reroute,actions,param,cluster,state,resulting,cluster,state;private,commands,result,routing,explanations,explanations,cluster,state,cluster,state,this,cluster,state,cluster,state,this,explanations,explanations
AllocationService -> CommandsResult -> public RoutingExplanations explanations();1524684173;Get the explanation of this result;public RoutingExplanations explanations() {_            return explanations__        };get,the,explanation,of,this,result;public,routing,explanations,explanations,return,explanations
AllocationService -> CommandsResult -> public RoutingExplanations explanations();1525798022;Get the explanation of this result;public RoutingExplanations explanations() {_            return explanations__        };get,the,explanation,of,this,result;public,routing,explanations,explanations,return,explanations
AllocationService -> CommandsResult -> public RoutingExplanations explanations();1526374795;Get the explanation of this result;public RoutingExplanations explanations() {_            return explanations__        };get,the,explanation,of,this,result;public,routing,explanations,explanations,return,explanations
AllocationService -> CommandsResult -> public RoutingExplanations explanations();1539723533;Get the explanation of this result;public RoutingExplanations explanations() {_            return explanations__        };get,the,explanation,of,this,result;public,routing,explanations,explanations,return,explanations
AllocationService -> CommandsResult -> public RoutingExplanations explanations();1541092382;Get the explanation of this result;public RoutingExplanations explanations() {_            return explanations__        };get,the,explanation,of,this,result;public,routing,explanations,explanations,return,explanations
AllocationService -> CommandsResult -> public RoutingExplanations explanations();1542402632;Get the explanation of this result;public RoutingExplanations explanations() {_            return explanations__        };get,the,explanation,of,this,result;public,routing,explanations,explanations,return,explanations
AllocationService -> CommandsResult -> public RoutingExplanations explanations();1548161085;Get the explanation of this result;public RoutingExplanations explanations() {_            return explanations__        };get,the,explanation,of,this,result;public,routing,explanations,explanations,return,explanations
AllocationService -> CommandsResult -> public RoutingExplanations explanations();1548259585;Get the explanation of this result;public RoutingExplanations explanations() {_            return explanations__        };get,the,explanation,of,this,result;public,routing,explanations,explanations,return,explanations
AllocationService -> CommandsResult -> public RoutingExplanations explanations();1551086646;Get the explanation of this result;public RoutingExplanations explanations() {_            return explanations__        };get,the,explanation,of,this,result;public,routing,explanations,explanations,return,explanations
AllocationService -> public ClusterState applyStartedShards(ClusterState clusterState, List<ShardRouting> startedShards);1524684173;Applies the started shards. Note, only initializing ShardRouting instances that exist in the routing table should be_provided as parameter and no duplicates should be contained._<p>_If the same instance of the {@link ClusterState} is returned, then no change has been made.</p>;public ClusterState applyStartedShards(ClusterState clusterState, List<ShardRouting> startedShards) {_        if (startedShards.isEmpty()) {_            return clusterState__        }_        RoutingNodes routingNodes = getMutableRoutingNodes(clusterState)__        _        routingNodes.unassigned().shuffle()__        RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, routingNodes, clusterState,_            clusterInfoService.getClusterInfo(), currentNanoTime())__        _        startedShards = new ArrayList<>(startedShards)__        Collections.sort(startedShards, Comparator.comparing(ShardRouting::primary))__        applyStartedShards(allocation, startedShards)__        gatewayAllocator.applyStartedShards(allocation, startedShards)__        reroute(allocation)__        String startedShardsAsString = firstListElementsToCommaDelimitedString(startedShards, s -> s.shardId().toString())__        return buildResultAndLogHealthChange(clusterState, allocation, "shards started [" + startedShardsAsString + "] ...")__    };applies,the,started,shards,note,only,initializing,shard,routing,instances,that,exist,in,the,routing,table,should,be,provided,as,parameter,and,no,duplicates,should,be,contained,p,if,the,same,instance,of,the,link,cluster,state,is,returned,then,no,change,has,been,made,p;public,cluster,state,apply,started,shards,cluster,state,cluster,state,list,shard,routing,started,shards,if,started,shards,is,empty,return,cluster,state,routing,nodes,routing,nodes,get,mutable,routing,nodes,cluster,state,routing,nodes,unassigned,shuffle,routing,allocation,allocation,new,routing,allocation,allocation,deciders,routing,nodes,cluster,state,cluster,info,service,get,cluster,info,current,nano,time,started,shards,new,array,list,started,shards,collections,sort,started,shards,comparator,comparing,shard,routing,primary,apply,started,shards,allocation,started,shards,gateway,allocator,apply,started,shards,allocation,started,shards,reroute,allocation,string,started,shards,as,string,first,list,elements,to,comma,delimited,string,started,shards,s,s,shard,id,to,string,return,build,result,and,log,health,change,cluster,state,allocation,shards,started,started,shards,as,string
AllocationService -> public ClusterState applyStartedShards(ClusterState clusterState, List<ShardRouting> startedShards);1525798022;Applies the started shards. Note, only initializing ShardRouting instances that exist in the routing table should be_provided as parameter and no duplicates should be contained._<p>_If the same instance of the {@link ClusterState} is returned, then no change has been made.</p>;public ClusterState applyStartedShards(ClusterState clusterState, List<ShardRouting> startedShards) {_        if (startedShards.isEmpty()) {_            return clusterState__        }_        RoutingNodes routingNodes = getMutableRoutingNodes(clusterState)__        _        routingNodes.unassigned().shuffle()__        RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, routingNodes, clusterState,_            clusterInfoService.getClusterInfo(), currentNanoTime())__        _        startedShards = new ArrayList<>(startedShards)__        Collections.sort(startedShards, Comparator.comparing(ShardRouting::primary))__        applyStartedShards(allocation, startedShards)__        gatewayAllocator.applyStartedShards(allocation, startedShards)__        reroute(allocation)__        String startedShardsAsString = firstListElementsToCommaDelimitedString(startedShards, s -> s.shardId().toString())__        return buildResultAndLogHealthChange(clusterState, allocation, "shards started [" + startedShardsAsString + "] ...")__    };applies,the,started,shards,note,only,initializing,shard,routing,instances,that,exist,in,the,routing,table,should,be,provided,as,parameter,and,no,duplicates,should,be,contained,p,if,the,same,instance,of,the,link,cluster,state,is,returned,then,no,change,has,been,made,p;public,cluster,state,apply,started,shards,cluster,state,cluster,state,list,shard,routing,started,shards,if,started,shards,is,empty,return,cluster,state,routing,nodes,routing,nodes,get,mutable,routing,nodes,cluster,state,routing,nodes,unassigned,shuffle,routing,allocation,allocation,new,routing,allocation,allocation,deciders,routing,nodes,cluster,state,cluster,info,service,get,cluster,info,current,nano,time,started,shards,new,array,list,started,shards,collections,sort,started,shards,comparator,comparing,shard,routing,primary,apply,started,shards,allocation,started,shards,gateway,allocator,apply,started,shards,allocation,started,shards,reroute,allocation,string,started,shards,as,string,first,list,elements,to,comma,delimited,string,started,shards,s,s,shard,id,to,string,return,build,result,and,log,health,change,cluster,state,allocation,shards,started,started,shards,as,string
AllocationService -> public ClusterState applyStartedShards(ClusterState clusterState, List<ShardRouting> startedShards);1526374795;Applies the started shards. Note, only initializing ShardRouting instances that exist in the routing table should be_provided as parameter and no duplicates should be contained._<p>_If the same instance of the {@link ClusterState} is returned, then no change has been made.</p>;public ClusterState applyStartedShards(ClusterState clusterState, List<ShardRouting> startedShards) {_        if (startedShards.isEmpty()) {_            return clusterState__        }_        RoutingNodes routingNodes = getMutableRoutingNodes(clusterState)__        _        routingNodes.unassigned().shuffle()__        RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, routingNodes, clusterState,_            clusterInfoService.getClusterInfo(), currentNanoTime())__        _        startedShards = new ArrayList<>(startedShards)__        Collections.sort(startedShards, Comparator.comparing(ShardRouting::primary))__        applyStartedShards(allocation, startedShards)__        gatewayAllocator.applyStartedShards(allocation, startedShards)__        reroute(allocation)__        String startedShardsAsString = firstListElementsToCommaDelimitedString(startedShards, s -> s.shardId().toString())__        return buildResultAndLogHealthChange(clusterState, allocation, "shards started [" + startedShardsAsString + "] ...")__    };applies,the,started,shards,note,only,initializing,shard,routing,instances,that,exist,in,the,routing,table,should,be,provided,as,parameter,and,no,duplicates,should,be,contained,p,if,the,same,instance,of,the,link,cluster,state,is,returned,then,no,change,has,been,made,p;public,cluster,state,apply,started,shards,cluster,state,cluster,state,list,shard,routing,started,shards,if,started,shards,is,empty,return,cluster,state,routing,nodes,routing,nodes,get,mutable,routing,nodes,cluster,state,routing,nodes,unassigned,shuffle,routing,allocation,allocation,new,routing,allocation,allocation,deciders,routing,nodes,cluster,state,cluster,info,service,get,cluster,info,current,nano,time,started,shards,new,array,list,started,shards,collections,sort,started,shards,comparator,comparing,shard,routing,primary,apply,started,shards,allocation,started,shards,gateway,allocator,apply,started,shards,allocation,started,shards,reroute,allocation,string,started,shards,as,string,first,list,elements,to,comma,delimited,string,started,shards,s,s,shard,id,to,string,return,build,result,and,log,health,change,cluster,state,allocation,shards,started,started,shards,as,string
AllocationService -> public ClusterState applyStartedShards(ClusterState clusterState, List<ShardRouting> startedShards);1539723533;Applies the started shards. Note, only initializing ShardRouting instances that exist in the routing table should be_provided as parameter and no duplicates should be contained._<p>_If the same instance of the {@link ClusterState} is returned, then no change has been made.</p>;public ClusterState applyStartedShards(ClusterState clusterState, List<ShardRouting> startedShards) {_        if (startedShards.isEmpty()) {_            return clusterState__        }_        RoutingNodes routingNodes = getMutableRoutingNodes(clusterState)__        _        routingNodes.unassigned().shuffle()__        RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, routingNodes, clusterState,_            clusterInfoService.getClusterInfo(), currentNanoTime())__        _        startedShards = new ArrayList<>(startedShards)__        Collections.sort(startedShards, Comparator.comparing(ShardRouting::primary))__        applyStartedShards(allocation, startedShards)__        gatewayAllocator.applyStartedShards(allocation, startedShards)__        reroute(allocation)__        String startedShardsAsString = firstListElementsToCommaDelimitedString(startedShards, s -> s.shardId().toString())__        return buildResultAndLogHealthChange(clusterState, allocation, "shards started [" + startedShardsAsString + "] ...")__    };applies,the,started,shards,note,only,initializing,shard,routing,instances,that,exist,in,the,routing,table,should,be,provided,as,parameter,and,no,duplicates,should,be,contained,p,if,the,same,instance,of,the,link,cluster,state,is,returned,then,no,change,has,been,made,p;public,cluster,state,apply,started,shards,cluster,state,cluster,state,list,shard,routing,started,shards,if,started,shards,is,empty,return,cluster,state,routing,nodes,routing,nodes,get,mutable,routing,nodes,cluster,state,routing,nodes,unassigned,shuffle,routing,allocation,allocation,new,routing,allocation,allocation,deciders,routing,nodes,cluster,state,cluster,info,service,get,cluster,info,current,nano,time,started,shards,new,array,list,started,shards,collections,sort,started,shards,comparator,comparing,shard,routing,primary,apply,started,shards,allocation,started,shards,gateway,allocator,apply,started,shards,allocation,started,shards,reroute,allocation,string,started,shards,as,string,first,list,elements,to,comma,delimited,string,started,shards,s,s,shard,id,to,string,return,build,result,and,log,health,change,cluster,state,allocation,shards,started,started,shards,as,string
AllocationService -> public ClusterState applyStartedShards(ClusterState clusterState, List<ShardRouting> startedShards);1541092382;Applies the started shards. Note, only initializing ShardRouting instances that exist in the routing table should be_provided as parameter and no duplicates should be contained._<p>_If the same instance of the {@link ClusterState} is returned, then no change has been made.</p>;public ClusterState applyStartedShards(ClusterState clusterState, List<ShardRouting> startedShards) {_        if (startedShards.isEmpty()) {_            return clusterState__        }_        RoutingNodes routingNodes = getMutableRoutingNodes(clusterState)__        _        routingNodes.unassigned().shuffle()__        RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, routingNodes, clusterState,_            clusterInfoService.getClusterInfo(), currentNanoTime())__        _        startedShards = new ArrayList<>(startedShards)__        Collections.sort(startedShards, Comparator.comparing(ShardRouting::primary))__        applyStartedShards(allocation, startedShards)__        gatewayAllocator.applyStartedShards(allocation, startedShards)__        reroute(allocation)__        String startedShardsAsString = firstListElementsToCommaDelimitedString(startedShards, s -> s.shardId().toString())__        return buildResultAndLogHealthChange(clusterState, allocation, "shards started [" + startedShardsAsString + "] ...")__    };applies,the,started,shards,note,only,initializing,shard,routing,instances,that,exist,in,the,routing,table,should,be,provided,as,parameter,and,no,duplicates,should,be,contained,p,if,the,same,instance,of,the,link,cluster,state,is,returned,then,no,change,has,been,made,p;public,cluster,state,apply,started,shards,cluster,state,cluster,state,list,shard,routing,started,shards,if,started,shards,is,empty,return,cluster,state,routing,nodes,routing,nodes,get,mutable,routing,nodes,cluster,state,routing,nodes,unassigned,shuffle,routing,allocation,allocation,new,routing,allocation,allocation,deciders,routing,nodes,cluster,state,cluster,info,service,get,cluster,info,current,nano,time,started,shards,new,array,list,started,shards,collections,sort,started,shards,comparator,comparing,shard,routing,primary,apply,started,shards,allocation,started,shards,gateway,allocator,apply,started,shards,allocation,started,shards,reroute,allocation,string,started,shards,as,string,first,list,elements,to,comma,delimited,string,started,shards,s,s,shard,id,to,string,return,build,result,and,log,health,change,cluster,state,allocation,shards,started,started,shards,as,string
AllocationService -> public ClusterState applyStartedShards(ClusterState clusterState, List<ShardRouting> startedShards);1542402632;Applies the started shards. Note, only initializing ShardRouting instances that exist in the routing table should be_provided as parameter and no duplicates should be contained._<p>_If the same instance of the {@link ClusterState} is returned, then no change has been made.</p>;public ClusterState applyStartedShards(ClusterState clusterState, List<ShardRouting> startedShards) {_        if (startedShards.isEmpty()) {_            return clusterState__        }_        RoutingNodes routingNodes = getMutableRoutingNodes(clusterState)__        _        routingNodes.unassigned().shuffle()__        RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, routingNodes, clusterState,_            clusterInfoService.getClusterInfo(), currentNanoTime())__        _        startedShards = new ArrayList<>(startedShards)__        Collections.sort(startedShards, Comparator.comparing(ShardRouting::primary))__        applyStartedShards(allocation, startedShards)__        gatewayAllocator.applyStartedShards(allocation, startedShards)__        reroute(allocation)__        String startedShardsAsString = firstListElementsToCommaDelimitedString(startedShards, s -> s.shardId().toString())__        return buildResultAndLogHealthChange(clusterState, allocation, "shards started [" + startedShardsAsString + "] ...")__    };applies,the,started,shards,note,only,initializing,shard,routing,instances,that,exist,in,the,routing,table,should,be,provided,as,parameter,and,no,duplicates,should,be,contained,p,if,the,same,instance,of,the,link,cluster,state,is,returned,then,no,change,has,been,made,p;public,cluster,state,apply,started,shards,cluster,state,cluster,state,list,shard,routing,started,shards,if,started,shards,is,empty,return,cluster,state,routing,nodes,routing,nodes,get,mutable,routing,nodes,cluster,state,routing,nodes,unassigned,shuffle,routing,allocation,allocation,new,routing,allocation,allocation,deciders,routing,nodes,cluster,state,cluster,info,service,get,cluster,info,current,nano,time,started,shards,new,array,list,started,shards,collections,sort,started,shards,comparator,comparing,shard,routing,primary,apply,started,shards,allocation,started,shards,gateway,allocator,apply,started,shards,allocation,started,shards,reroute,allocation,string,started,shards,as,string,first,list,elements,to,comma,delimited,string,started,shards,s,s,shard,id,to,string,return,build,result,and,log,health,change,cluster,state,allocation,shards,started,started,shards,as,string
AllocationService -> public ClusterState applyStartedShards(ClusterState clusterState, List<ShardRouting> startedShards);1548161085;Applies the started shards. Note, only initializing ShardRouting instances that exist in the routing table should be_provided as parameter and no duplicates should be contained._<p>_If the same instance of the {@link ClusterState} is returned, then no change has been made.</p>;public ClusterState applyStartedShards(ClusterState clusterState, List<ShardRouting> startedShards) {_        if (startedShards.isEmpty()) {_            return clusterState__        }_        RoutingNodes routingNodes = getMutableRoutingNodes(clusterState)__        _        routingNodes.unassigned().shuffle()__        RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, routingNodes, clusterState,_            clusterInfoService.getClusterInfo(), currentNanoTime())__        _        startedShards = new ArrayList<>(startedShards)__        Collections.sort(startedShards, Comparator.comparing(ShardRouting::primary))__        applyStartedShards(allocation, startedShards)__        gatewayAllocator.applyStartedShards(allocation, startedShards)__        reroute(allocation)__        String startedShardsAsString = firstListElementsToCommaDelimitedString(startedShards, s -> s.shardId().toString())__        return buildResultAndLogHealthChange(clusterState, allocation, "shards started [" + startedShardsAsString + "] ...")__    };applies,the,started,shards,note,only,initializing,shard,routing,instances,that,exist,in,the,routing,table,should,be,provided,as,parameter,and,no,duplicates,should,be,contained,p,if,the,same,instance,of,the,link,cluster,state,is,returned,then,no,change,has,been,made,p;public,cluster,state,apply,started,shards,cluster,state,cluster,state,list,shard,routing,started,shards,if,started,shards,is,empty,return,cluster,state,routing,nodes,routing,nodes,get,mutable,routing,nodes,cluster,state,routing,nodes,unassigned,shuffle,routing,allocation,allocation,new,routing,allocation,allocation,deciders,routing,nodes,cluster,state,cluster,info,service,get,cluster,info,current,nano,time,started,shards,new,array,list,started,shards,collections,sort,started,shards,comparator,comparing,shard,routing,primary,apply,started,shards,allocation,started,shards,gateway,allocator,apply,started,shards,allocation,started,shards,reroute,allocation,string,started,shards,as,string,first,list,elements,to,comma,delimited,string,started,shards,s,s,shard,id,to,string,return,build,result,and,log,health,change,cluster,state,allocation,shards,started,started,shards,as,string
AllocationService -> public ClusterState applyStartedShards(ClusterState clusterState, List<ShardRouting> startedShards);1548259585;Applies the started shards. Note, only initializing ShardRouting instances that exist in the routing table should be_provided as parameter and no duplicates should be contained._<p>_If the same instance of the {@link ClusterState} is returned, then no change has been made.</p>;public ClusterState applyStartedShards(ClusterState clusterState, List<ShardRouting> startedShards) {_        if (startedShards.isEmpty()) {_            return clusterState__        }_        RoutingNodes routingNodes = getMutableRoutingNodes(clusterState)__        _        routingNodes.unassigned().shuffle()__        RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, routingNodes, clusterState,_            clusterInfoService.getClusterInfo(), currentNanoTime())__        _        startedShards = new ArrayList<>(startedShards)__        Collections.sort(startedShards, Comparator.comparing(ShardRouting::primary))__        applyStartedShards(allocation, startedShards)__        gatewayAllocator.applyStartedShards(allocation, startedShards)__        reroute(allocation)__        String startedShardsAsString = firstListElementsToCommaDelimitedString(startedShards, s -> s.shardId().toString())__        return buildResultAndLogHealthChange(clusterState, allocation, "shards started [" + startedShardsAsString + "] ...")__    };applies,the,started,shards,note,only,initializing,shard,routing,instances,that,exist,in,the,routing,table,should,be,provided,as,parameter,and,no,duplicates,should,be,contained,p,if,the,same,instance,of,the,link,cluster,state,is,returned,then,no,change,has,been,made,p;public,cluster,state,apply,started,shards,cluster,state,cluster,state,list,shard,routing,started,shards,if,started,shards,is,empty,return,cluster,state,routing,nodes,routing,nodes,get,mutable,routing,nodes,cluster,state,routing,nodes,unassigned,shuffle,routing,allocation,allocation,new,routing,allocation,allocation,deciders,routing,nodes,cluster,state,cluster,info,service,get,cluster,info,current,nano,time,started,shards,new,array,list,started,shards,collections,sort,started,shards,comparator,comparing,shard,routing,primary,apply,started,shards,allocation,started,shards,gateway,allocator,apply,started,shards,allocation,started,shards,reroute,allocation,string,started,shards,as,string,first,list,elements,to,comma,delimited,string,started,shards,s,s,shard,id,to,string,return,build,result,and,log,health,change,cluster,state,allocation,shards,started,started,shards,as,string
AllocationService -> public ClusterState applyStartedShards(ClusterState clusterState, List<ShardRouting> startedShards);1551086646;Applies the started shards. Note, only initializing ShardRouting instances that exist in the routing table should be_provided as parameter and no duplicates should be contained._<p>_If the same instance of the {@link ClusterState} is returned, then no change has been made.</p>;public ClusterState applyStartedShards(ClusterState clusterState, List<ShardRouting> startedShards) {_        if (startedShards.isEmpty()) {_            return clusterState__        }_        RoutingNodes routingNodes = getMutableRoutingNodes(clusterState)__        _        routingNodes.unassigned().shuffle()__        RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, routingNodes, clusterState,_            clusterInfoService.getClusterInfo(), currentNanoTime())__        _        startedShards = new ArrayList<>(startedShards)__        Collections.sort(startedShards, Comparator.comparing(ShardRouting::primary))__        applyStartedShards(allocation, startedShards)__        gatewayAllocator.applyStartedShards(allocation, startedShards)__        reroute(allocation)__        String startedShardsAsString = firstListElementsToCommaDelimitedString(startedShards, s -> s.shardId().toString())__        return buildResultAndLogHealthChange(clusterState, allocation, "shards started [" + startedShardsAsString + "] ...")__    };applies,the,started,shards,note,only,initializing,shard,routing,instances,that,exist,in,the,routing,table,should,be,provided,as,parameter,and,no,duplicates,should,be,contained,p,if,the,same,instance,of,the,link,cluster,state,is,returned,then,no,change,has,been,made,p;public,cluster,state,apply,started,shards,cluster,state,cluster,state,list,shard,routing,started,shards,if,started,shards,is,empty,return,cluster,state,routing,nodes,routing,nodes,get,mutable,routing,nodes,cluster,state,routing,nodes,unassigned,shuffle,routing,allocation,allocation,new,routing,allocation,allocation,deciders,routing,nodes,cluster,state,cluster,info,service,get,cluster,info,current,nano,time,started,shards,new,array,list,started,shards,collections,sort,started,shards,comparator,comparing,shard,routing,primary,apply,started,shards,allocation,started,shards,gateway,allocator,apply,started,shards,allocation,started,shards,reroute,allocation,string,started,shards,as,string,first,list,elements,to,comma,delimited,string,started,shards,s,s,shard,id,to,string,return,build,result,and,log,health,change,cluster,state,allocation,shards,started,started,shards,as,string
AllocationService -> protected long currentNanoTime();1524684173;override this to control time based decisions during allocation;protected long currentNanoTime() {_        return System.nanoTime()__    };override,this,to,control,time,based,decisions,during,allocation;protected,long,current,nano,time,return,system,nano,time
AllocationService -> protected long currentNanoTime();1525798022;override this to control time based decisions during allocation;protected long currentNanoTime() {_        return System.nanoTime()__    };override,this,to,control,time,based,decisions,during,allocation;protected,long,current,nano,time,return,system,nano,time
AllocationService -> protected long currentNanoTime();1526374795;override this to control time based decisions during allocation;protected long currentNanoTime() {_        return System.nanoTime()__    };override,this,to,control,time,based,decisions,during,allocation;protected,long,current,nano,time,return,system,nano,time
AllocationService -> protected long currentNanoTime();1539723533;override this to control time based decisions during allocation;protected long currentNanoTime() {_        return System.nanoTime()__    };override,this,to,control,time,based,decisions,during,allocation;protected,long,current,nano,time,return,system,nano,time
AllocationService -> protected long currentNanoTime();1541092382;override this to control time based decisions during allocation;protected long currentNanoTime() {_        return System.nanoTime()__    };override,this,to,control,time,based,decisions,during,allocation;protected,long,current,nano,time,return,system,nano,time
AllocationService -> protected long currentNanoTime();1542402632;override this to control time based decisions during allocation;protected long currentNanoTime() {_        return System.nanoTime()__    };override,this,to,control,time,based,decisions,during,allocation;protected,long,current,nano,time,return,system,nano,time
AllocationService -> protected long currentNanoTime();1548161085;override this to control time based decisions during allocation;protected long currentNanoTime() {_        return System.nanoTime()__    };override,this,to,control,time,based,decisions,during,allocation;protected,long,current,nano,time,return,system,nano,time
AllocationService -> protected long currentNanoTime();1548259585;override this to control time based decisions during allocation;protected long currentNanoTime() {_        return System.nanoTime()__    };override,this,to,control,time,based,decisions,during,allocation;protected,long,current,nano,time,return,system,nano,time
AllocationService -> protected long currentNanoTime();1551086646;override this to control time based decisions during allocation;protected long currentNanoTime() {_        return System.nanoTime()__    };override,this,to,control,time,based,decisions,during,allocation;protected,long,current,nano,time,return,system,nano,time
AllocationService -> public ClusterState deassociateDeadNodes(ClusterState clusterState, boolean reroute, String reason);1525798022;unassigned an shards that are associated with nodes that are no longer part of the cluster, potentially promoting replicas_if needed.;public ClusterState deassociateDeadNodes(ClusterState clusterState, boolean reroute, String reason) {_        ClusterState fixedClusterState = adaptAutoExpandReplicas(clusterState)__        RoutingNodes routingNodes = getMutableRoutingNodes(fixedClusterState)__        _        routingNodes.unassigned().shuffle()__        RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, routingNodes, fixedClusterState,_            clusterInfoService.getClusterInfo(), currentNanoTime())___        _        deassociateDeadNodes(allocation)___        if (reroute) {_            reroute(allocation)__        }__        if (fixedClusterState == clusterState && allocation.routingNodesChanged() == false) {_            return clusterState__        }_        return buildResultAndLogHealthChange(clusterState, allocation, reason)__    };unassigned,an,shards,that,are,associated,with,nodes,that,are,no,longer,part,of,the,cluster,potentially,promoting,replicas,if,needed;public,cluster,state,deassociate,dead,nodes,cluster,state,cluster,state,boolean,reroute,string,reason,cluster,state,fixed,cluster,state,adapt,auto,expand,replicas,cluster,state,routing,nodes,routing,nodes,get,mutable,routing,nodes,fixed,cluster,state,routing,nodes,unassigned,shuffle,routing,allocation,allocation,new,routing,allocation,allocation,deciders,routing,nodes,fixed,cluster,state,cluster,info,service,get,cluster,info,current,nano,time,deassociate,dead,nodes,allocation,if,reroute,reroute,allocation,if,fixed,cluster,state,cluster,state,allocation,routing,nodes,changed,false,return,cluster,state,return,build,result,and,log,health,change,cluster,state,allocation,reason
AllocationService -> public ClusterState deassociateDeadNodes(ClusterState clusterState, boolean reroute, String reason);1526374795;unassigned an shards that are associated with nodes that are no longer part of the cluster, potentially promoting replicas_if needed.;public ClusterState deassociateDeadNodes(ClusterState clusterState, boolean reroute, String reason) {_        RoutingNodes routingNodes = getMutableRoutingNodes(clusterState)__        _        routingNodes.unassigned().shuffle()__        RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, routingNodes, clusterState,_            clusterInfoService.getClusterInfo(), currentNanoTime())___        _        deassociateDeadNodes(allocation)___        if (allocation.routingNodesChanged()) {_            clusterState = buildResult(clusterState, allocation)__        }_        if (reroute) {_            return reroute(clusterState, reason)__        } else {_            return clusterState__        }_    };unassigned,an,shards,that,are,associated,with,nodes,that,are,no,longer,part,of,the,cluster,potentially,promoting,replicas,if,needed;public,cluster,state,deassociate,dead,nodes,cluster,state,cluster,state,boolean,reroute,string,reason,routing,nodes,routing,nodes,get,mutable,routing,nodes,cluster,state,routing,nodes,unassigned,shuffle,routing,allocation,allocation,new,routing,allocation,allocation,deciders,routing,nodes,cluster,state,cluster,info,service,get,cluster,info,current,nano,time,deassociate,dead,nodes,allocation,if,allocation,routing,nodes,changed,cluster,state,build,result,cluster,state,allocation,if,reroute,return,reroute,cluster,state,reason,else,return,cluster,state
AllocationService -> public ClusterState deassociateDeadNodes(ClusterState clusterState, boolean reroute, String reason);1539723533;unassigned an shards that are associated with nodes that are no longer part of the cluster, potentially promoting replicas_if needed.;public ClusterState deassociateDeadNodes(ClusterState clusterState, boolean reroute, String reason) {_        RoutingNodes routingNodes = getMutableRoutingNodes(clusterState)__        _        routingNodes.unassigned().shuffle()__        RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, routingNodes, clusterState,_            clusterInfoService.getClusterInfo(), currentNanoTime())___        _        deassociateDeadNodes(allocation)___        if (allocation.routingNodesChanged()) {_            clusterState = buildResult(clusterState, allocation)__        }_        if (reroute) {_            return reroute(clusterState, reason)__        } else {_            return clusterState__        }_    };unassigned,an,shards,that,are,associated,with,nodes,that,are,no,longer,part,of,the,cluster,potentially,promoting,replicas,if,needed;public,cluster,state,deassociate,dead,nodes,cluster,state,cluster,state,boolean,reroute,string,reason,routing,nodes,routing,nodes,get,mutable,routing,nodes,cluster,state,routing,nodes,unassigned,shuffle,routing,allocation,allocation,new,routing,allocation,allocation,deciders,routing,nodes,cluster,state,cluster,info,service,get,cluster,info,current,nano,time,deassociate,dead,nodes,allocation,if,allocation,routing,nodes,changed,cluster,state,build,result,cluster,state,allocation,if,reroute,return,reroute,cluster,state,reason,else,return,cluster,state
AllocationService -> public ClusterState deassociateDeadNodes(ClusterState clusterState, boolean reroute, String reason);1541092382;unassigned an shards that are associated with nodes that are no longer part of the cluster, potentially promoting replicas_if needed.;public ClusterState deassociateDeadNodes(ClusterState clusterState, boolean reroute, String reason) {_        RoutingNodes routingNodes = getMutableRoutingNodes(clusterState)__        _        routingNodes.unassigned().shuffle()__        RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, routingNodes, clusterState,_            clusterInfoService.getClusterInfo(), currentNanoTime())___        _        deassociateDeadNodes(allocation)___        if (allocation.routingNodesChanged()) {_            clusterState = buildResult(clusterState, allocation)__        }_        if (reroute) {_            return reroute(clusterState, reason)__        } else {_            return clusterState__        }_    };unassigned,an,shards,that,are,associated,with,nodes,that,are,no,longer,part,of,the,cluster,potentially,promoting,replicas,if,needed;public,cluster,state,deassociate,dead,nodes,cluster,state,cluster,state,boolean,reroute,string,reason,routing,nodes,routing,nodes,get,mutable,routing,nodes,cluster,state,routing,nodes,unassigned,shuffle,routing,allocation,allocation,new,routing,allocation,allocation,deciders,routing,nodes,cluster,state,cluster,info,service,get,cluster,info,current,nano,time,deassociate,dead,nodes,allocation,if,allocation,routing,nodes,changed,cluster,state,build,result,cluster,state,allocation,if,reroute,return,reroute,cluster,state,reason,else,return,cluster,state
AllocationService -> public ClusterState deassociateDeadNodes(ClusterState clusterState, boolean reroute, String reason);1542402632;unassigned an shards that are associated with nodes that are no longer part of the cluster, potentially promoting replicas_if needed.;public ClusterState deassociateDeadNodes(ClusterState clusterState, boolean reroute, String reason) {_        RoutingNodes routingNodes = getMutableRoutingNodes(clusterState)__        _        routingNodes.unassigned().shuffle()__        RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, routingNodes, clusterState,_            clusterInfoService.getClusterInfo(), currentNanoTime())___        _        deassociateDeadNodes(allocation)___        if (allocation.routingNodesChanged()) {_            clusterState = buildResult(clusterState, allocation)__        }_        if (reroute) {_            return reroute(clusterState, reason)__        } else {_            return clusterState__        }_    };unassigned,an,shards,that,are,associated,with,nodes,that,are,no,longer,part,of,the,cluster,potentially,promoting,replicas,if,needed;public,cluster,state,deassociate,dead,nodes,cluster,state,cluster,state,boolean,reroute,string,reason,routing,nodes,routing,nodes,get,mutable,routing,nodes,cluster,state,routing,nodes,unassigned,shuffle,routing,allocation,allocation,new,routing,allocation,allocation,deciders,routing,nodes,cluster,state,cluster,info,service,get,cluster,info,current,nano,time,deassociate,dead,nodes,allocation,if,allocation,routing,nodes,changed,cluster,state,build,result,cluster,state,allocation,if,reroute,return,reroute,cluster,state,reason,else,return,cluster,state
AllocationService -> public ClusterState deassociateDeadNodes(ClusterState clusterState, boolean reroute, String reason);1548161085;unassigned an shards that are associated with nodes that are no longer part of the cluster, potentially promoting replicas_if needed.;public ClusterState deassociateDeadNodes(ClusterState clusterState, boolean reroute, String reason) {_        RoutingNodes routingNodes = getMutableRoutingNodes(clusterState)__        _        routingNodes.unassigned().shuffle()__        RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, routingNodes, clusterState,_            clusterInfoService.getClusterInfo(), currentNanoTime())___        _        deassociateDeadNodes(allocation)___        if (allocation.routingNodesChanged()) {_            clusterState = buildResult(clusterState, allocation)__        }_        if (reroute) {_            return reroute(clusterState, reason)__        } else {_            return clusterState__        }_    };unassigned,an,shards,that,are,associated,with,nodes,that,are,no,longer,part,of,the,cluster,potentially,promoting,replicas,if,needed;public,cluster,state,deassociate,dead,nodes,cluster,state,cluster,state,boolean,reroute,string,reason,routing,nodes,routing,nodes,get,mutable,routing,nodes,cluster,state,routing,nodes,unassigned,shuffle,routing,allocation,allocation,new,routing,allocation,allocation,deciders,routing,nodes,cluster,state,cluster,info,service,get,cluster,info,current,nano,time,deassociate,dead,nodes,allocation,if,allocation,routing,nodes,changed,cluster,state,build,result,cluster,state,allocation,if,reroute,return,reroute,cluster,state,reason,else,return,cluster,state
