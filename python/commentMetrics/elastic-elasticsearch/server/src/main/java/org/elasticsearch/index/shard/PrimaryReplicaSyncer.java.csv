commented;modifiers;parameterAmount;loc;comment;code
false;;1;6;;void setChunkSize(ByteSizeValue chunkSize) {     // only settable for tests     if (chunkSize.bytesAsInt() <= 0) {         throw new IllegalArgumentException("chunkSize must be > 0").     }     this.chunkSize = chunkSize. }
false;public,synchronized;0;4;;@Override public synchronized void close() throws IOException {     originalSnapshot.close(). }
false;public,synchronized;0;4;;@Override public synchronized int totalOperations() {     return originalSnapshot.totalOperations(). }
false;public,synchronized;0;10;;@Override public synchronized Translog.Operation next() throws IOException {     IndexShardState state = indexShard.state().     if (state == IndexShardState.CLOSED) {         throw new IndexShardClosedException(shardId).     } else {         assert state == IndexShardState.STARTED : "resync should only happen on a started shard, but state was: " + state.     }     return originalSnapshot.next(). }
false;public;1;9;;@Override public void onResponse(final ResyncTask resyncTask) {     try {         wrappedSnapshot.close().         listener.onResponse(resyncTask).     } catch (final Exception e) {         onFailure(e).     } }
false;public;1;10;;@Override public void onFailure(final Exception e) {     try {         wrappedSnapshot.close().     } catch (final Exception inner) {         e.addSuppressed(inner).     } finally {         listener.onFailure(e).     } }
false;public;2;70;;public void resync(final IndexShard indexShard, final ActionListener<ResyncTask> listener) {     Translog.Snapshot snapshot = null.     try {         final long startingSeqNo = indexShard.getGlobalCheckpoint() + 1.         final long maxSeqNo = indexShard.seqNoStats().getMaxSeqNo().         final ShardId shardId = indexShard.shardId().         // Wrap translog snapshot to make it synchronized as it is accessed by different threads through SnapshotSender.         // Even though those calls are not concurrent, snapshot.next() uses non-synchronized state and is not multi-thread-compatible         // Also fail the resync early if the shard is shutting down         snapshot = indexShard.getHistoryOperations("resync", startingSeqNo).         final Translog.Snapshot originalSnapshot = snapshot.         final Translog.Snapshot wrappedSnapshot = new Translog.Snapshot() {              @Override             public synchronized void close() throws IOException {                 originalSnapshot.close().             }              @Override             public synchronized int totalOperations() {                 return originalSnapshot.totalOperations().             }              @Override             public synchronized Translog.Operation next() throws IOException {                 IndexShardState state = indexShard.state().                 if (state == IndexShardState.CLOSED) {                     throw new IndexShardClosedException(shardId).                 } else {                     assert state == IndexShardState.STARTED : "resync should only happen on a started shard, but state was: " + state.                 }                 return originalSnapshot.next().             }         }.         final ActionListener<ResyncTask> resyncListener = new ActionListener<ResyncTask>() {              @Override             public void onResponse(final ResyncTask resyncTask) {                 try {                     wrappedSnapshot.close().                     listener.onResponse(resyncTask).                 } catch (final Exception e) {                     onFailure(e).                 }             }              @Override             public void onFailure(final Exception e) {                 try {                     wrappedSnapshot.close().                 } catch (final Exception inner) {                     e.addSuppressed(inner).                 } finally {                     listener.onFailure(e).                 }             }         }.         // We must capture the timestamp after snapshotting a snapshot of operations to make sure         // that the auto_id_timestamp of every operation in the snapshot is at most this value.         final long maxSeenAutoIdTimestamp = indexShard.getMaxSeenAutoIdTimestamp().         resync(shardId, indexShard.routingEntry().allocationId().getId(), indexShard.getPendingPrimaryTerm(), wrappedSnapshot, startingSeqNo, maxSeqNo, maxSeenAutoIdTimestamp, resyncListener).     } catch (Exception e) {         try {             IOUtils.close(snapshot).         } catch (IOException inner) {             e.addSuppressed(inner).         } finally {             listener.onFailure(e).         }     } }
false;public;1;6;;@Override public void onResponse(Void ignore) {     resyncTask.setPhase("finished").     taskManager.unregister(resyncTask).     listener.onResponse(resyncTask). }
false;public;1;6;;@Override public void onFailure(Exception e) {     resyncTask.setPhase("finished").     taskManager.unregister(resyncTask).     listener.onFailure(e). }
false;private;8;26;;private void resync(final ShardId shardId, final String primaryAllocationId, final long primaryTerm, final Translog.Snapshot snapshot, long startingSeqNo, long maxSeqNo, long maxSeenAutoIdTimestamp, ActionListener<ResyncTask> listener) {     ResyncRequest request = new ResyncRequest(shardId, primaryAllocationId).     // it's not transport :-)     ResyncTask resyncTask = (ResyncTask) taskManager.register("transport", "resync", request).     ActionListener<Void> wrappedListener = new ActionListener<Void>() {          @Override         public void onResponse(Void ignore) {             resyncTask.setPhase("finished").             taskManager.unregister(resyncTask).             listener.onResponse(resyncTask).         }          @Override         public void onFailure(Exception e) {             resyncTask.setPhase("finished").             taskManager.unregister(resyncTask).             listener.onFailure(e).         }     }.     try {         new SnapshotSender(logger, syncAction, resyncTask, shardId, primaryAllocationId, primaryTerm, snapshot, chunkSize.bytesAsInt(), startingSeqNo, maxSeqNo, maxSeenAutoIdTimestamp, wrappedListener).run().     } catch (Exception e) {         wrappedListener.onFailure(e).     } }
false;;5;2;;void sync(ResyncReplicationRequest request, Task parentTask, String primaryAllocationId, long primaryTerm, ActionListener<ResyncReplicationResponse> listener).
false;public;1;4;;@Override public void onResponse(ResyncReplicationResponse response) {     run(). }
false;public;1;6;;@Override public void onFailure(Exception e) {     if (closed.compareAndSet(false, true)) {         listener.onFailure(e).     } }
false;protected;0;42;;@Override protected void doRun() throws Exception {     long size = 0.     final List<Translog.Operation> operations = new ArrayList<>().     task.setPhase("collecting_ops").     task.setResyncedOperations(totalSentOps.get()).     task.setSkippedOperations(totalSkippedOps.get()).     Translog.Operation operation.     while ((operation = snapshot.next()) != null) {         final long seqNo = operation.seqNo().         if (startingSeqNo >= 0 && (seqNo == SequenceNumbers.UNASSIGNED_SEQ_NO || seqNo < startingSeqNo)) {             totalSkippedOps.incrementAndGet().             continue.         }         operations.add(operation).         size += operation.estimateSize().         totalSentOps.incrementAndGet().         // check if this request is past bytes threshold, and if so, send it off         if (size >= chunkSizeInBytes) {             break.         }     }     final long trimmedAboveSeqNo = firstMessage.get() ? maxSeqNo : SequenceNumbers.UNASSIGNED_SEQ_NO.     // have to send sync request even in case of there are no operations to sync - have to sync trimmedAboveSeqNo at least     if (!operations.isEmpty() || trimmedAboveSeqNo != SequenceNumbers.UNASSIGNED_SEQ_NO) {         task.setPhase("sending_ops").         ResyncReplicationRequest request = new ResyncReplicationRequest(shardId, trimmedAboveSeqNo, maxSeenAutoIdTimestamp, operations.toArray(EMPTY_ARRAY)).         logger.trace("{} sending batch of [{}][{}] (total sent: [{}], skipped: [{}])", shardId, operations.size(), new ByteSizeValue(size), totalSentOps.get(), totalSkippedOps.get()).         firstMessage.set(false).         syncAction.sync(request, task, primaryAllocationId, primaryTerm, this).     } else if (closed.compareAndSet(false, true)) {         logger.trace("{} resync completed (total sent: [{}], skipped: [{}])", shardId, totalSentOps.get(), totalSkippedOps.get()).         listener.onResponse(null).     } }
false;public;5;4;;@Override public Task createTask(long id, String type, String action, TaskId parentTaskId, Map<String, String> headers) {     return new ResyncTask(id, type, action, getDescription(), parentTaskId, headers). }
false;public;0;4;;@Override public String getDescription() {     return toString(). }
false;public;0;4;;@Override public String toString() {     return "ResyncRequest{ " + shardId + ", " + allocationId + " }". }
false;public;0;4;;@Override public ActionRequestValidationException validate() {     return null. }
true;public;1;3;/**  * Set the current phase of the task.  */ ;/**  * Set the current phase of the task.  */ public void setPhase(String phase) {     this.phase = phase. }
true;public;0;3;/**  * Get the current phase of the task.  */ ;/**  * Get the current phase of the task.  */ public String getPhase() {     return phase. }
true;public;0;3;/**  * total number of translog operations that were captured by translog snapshot  */ ;/**  * total number of translog operations that were captured by translog snapshot  */ public int getTotalOperations() {     return totalOperations. }
false;public;1;3;;public void setTotalOperations(int totalOperations) {     this.totalOperations = totalOperations. }
true;public;0;3;/**  * number of operations that have been successfully replicated  */ ;/**  * number of operations that have been successfully replicated  */ public int getResyncedOperations() {     return resyncedOperations. }
false;public;1;3;;public void setResyncedOperations(int resyncedOperations) {     this.resyncedOperations = resyncedOperations. }
true;public;0;3;/**  * number of translog operations that have been skipped  */ ;/**  * number of translog operations that have been skipped  */ public int getSkippedOperations() {     return skippedOperations. }
false;public;1;3;;public void setSkippedOperations(int skippedOperations) {     this.skippedOperations = skippedOperations. }
false;public;0;4;;@Override public ResyncTask.Status getStatus() {     return new ResyncTask.Status(phase, totalOperations, resyncedOperations, skippedOperations). }
false;public;0;4;;@Override public String getWriteableName() {     return NAME. }
false;public;2;10;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     builder.field("phase", phase).     builder.field("totalOperations", totalOperations).     builder.field("resyncedOperations", resyncedOperations).     builder.field("skippedOperations", skippedOperations).     builder.endObject().     return builder. }
false;public;1;7;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeString(phase).     out.writeVLong(totalOperations).     out.writeVLong(resyncedOperations).     out.writeVLong(skippedOperations). }
false;public;0;4;;@Override public String toString() {     return Strings.toString(this). }
false;public;1;12;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     Status status = (Status) o.     if (totalOperations != status.totalOperations)         return false.     if (resyncedOperations != status.resyncedOperations)         return false.     if (skippedOperations != status.skippedOperations)         return false.     return phase.equals(status.phase). }
false;public;0;8;;@Override public int hashCode() {     int result = phase.hashCode().     result = 31 * result + totalOperations.     result = 31 * result + resyncedOperations.     result = 31 * result + skippedOperations.     return result. }
