commented;modifiers;parameterAmount;loc;comment;code
false;protected,abstract;0;1;;protected abstract Self self().
true;public;0;3;/**  * The search used to find documents to process.  */ ;/**  * The search used to find documents to process.  */ public SearchRequestBuilder source() {     return source. }
true;public;1;4;/**  * Set the source indices.  */ ;/**  * Set the source indices.  */ public Self source(String... indices) {     source.setIndices(indices).     return self(). }
true;public;1;4;/**  * Set the query that will filter the source. Just a convenience method for  * easy chaining.  */ ;/**  * Set the query that will filter the source. Just a convenience method for  * easy chaining.  */ public Self filter(QueryBuilder filter) {     source.setQuery(filter).     return self(). }
true;public;1;4;/**  * The maximum number of documents to attempt.  */ ;/**  * The maximum number of documents to attempt.  */ public Self size(int size) {     request.setSize(size).     return self(). }
true;public;1;4;/**  * Set whether or not version conflicts cause the action to abort.  */ ;/**  * Set whether or not version conflicts cause the action to abort.  */ public Self abortOnVersionConflict(boolean abortOnVersionConflict) {     request.setAbortOnVersionConflict(abortOnVersionConflict).     return self(). }
true;public;1;4;/**  * Call refresh on the indexes we've written to after the request ends?  */ ;/**  * Call refresh on the indexes we've written to after the request ends?  */ public Self refresh(boolean refresh) {     request.setRefresh(refresh).     return self(). }
true;public;1;4;/**  * Timeout to wait for the shards on to be available for each bulk request.  */ ;/**  * Timeout to wait for the shards on to be available for each bulk request.  */ public Self timeout(TimeValue timeout) {     request.setTimeout(timeout).     return self(). }
true;public;1;4;/**  * The number of shard copies that must be active before proceeding with the write.  * See {@link ReplicationRequest#waitForActiveShards(ActiveShardCount)} for details.  */ ;/**  * The number of shard copies that must be active before proceeding with the write.  * See {@link ReplicationRequest#waitForActiveShards(ActiveShardCount)} for details.  */ public Self waitForActiveShards(ActiveShardCount activeShardCount) {     request.setWaitForActiveShards(activeShardCount).     return self(). }
true;public;1;4;/**  * Initial delay after a rejection before retrying a bulk request. With the default maxRetries the total backoff for retrying rejections  * is about one minute per bulk request. Once the entire bulk request is successful the retry counter resets.  */ ;/**  * Initial delay after a rejection before retrying a bulk request. With the default maxRetries the total backoff for retrying rejections  * is about one minute per bulk request. Once the entire bulk request is successful the retry counter resets.  */ public Self setRetryBackoffInitialTime(TimeValue retryBackoffInitialTime) {     request.setRetryBackoffInitialTime(retryBackoffInitialTime).     return self(). }
true;public;1;4;/**  * Total number of retries attempted for rejections. There is no way to ask for unlimited retries.  */ ;/**  * Total number of retries attempted for rejections. There is no way to ask for unlimited retries.  */ public Self setMaxRetries(int maxRetries) {     request.setMaxRetries(maxRetries).     return self(). }
true;public;1;4;/**  * Set the throttle for this request in sub-requests per second. {@link Float#POSITIVE_INFINITY} means set no throttle and that is the  * default. Throttling is done between batches, as we start the next scroll requests. That way we can increase the scroll's timeout to  * make sure that it contains any time that we might wait.  */ ;/**  * Set the throttle for this request in sub-requests per second. {@link Float#POSITIVE_INFINITY} means set no throttle and that is the  * default. Throttling is done between batches, as we start the next scroll requests. That way we can increase the scroll's timeout to  * make sure that it contains any time that we might wait.  */ public Self setRequestsPerSecond(float requestsPerSecond) {     request.setRequestsPerSecond(requestsPerSecond).     return self(). }
true;public;1;4;/**  * Should this task store its result after it has finished?  */ ;/**  * Should this task store its result after it has finished?  */ public Self setShouldStoreResult(boolean shouldStoreResult) {     request.setShouldStoreResult(shouldStoreResult).     return self(). }
true;public;1;4;/**  * The number of slices this task should be divided into. Defaults to 1 meaning the task isn't sliced into subtasks.  */ ;/**  * The number of slices this task should be divided into. Defaults to 1 meaning the task isn't sliced into subtasks.  */ public Self setSlices(int slices) {     request.setSlices(slices).     return self(). }
