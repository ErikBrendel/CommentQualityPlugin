commented;modifiers;parameterAmount;loc;comment;code
true;public;4;14;/**  * Registers an instance for member injection when that step is performed.  *  * @param instance an instance that optionally has members to be injected (each annotated with  * @param source   the source location that this injection was requested  * @Inject).  */ ;/**  * Registers an instance for member injection when that step is performed.  *  * @param instance an instance that optionally has members to be injected (each annotated with  * @param source   the source location that this injection was requested  * @Inject).  */ public <T> Initializable<T> requestInjection(InjectorImpl injector, T instance, Object source, Set<InjectionPoint> injectionPoints) {     Objects.requireNonNull(source).     // short circuit if the object has no injections     if (instance == null || (injectionPoints.isEmpty() && !injector.membersInjectorStore.hasTypeListeners())) {         return Initializables.of(instance).     }     InjectableReference<T> initializable = new InjectableReference<>(injector, instance, source).     pendingInjection.put(instance, initializable).     return initializable. }
true;;1;9;/**  * Prepares member injectors for all injected instances. This prompts Guice to do static analysis  * on the injected instances.  */ ;/**  * Prepares member injectors for all injected instances. This prompts Guice to do static analysis  * on the injected instances.  */ void validateOustandingInjections(Errors errors) {     for (InjectableReference<?> reference : pendingInjection.values()) {         try {             reference.validate(errors).         } catch (ErrorsException e) {             errors.merge(e.getErrors()).         }     } }
true;;1;17;/**  * Performs creation-time injections on all objects that require it. Whenever fulfilling an  * injection depends on another object that requires injection, we inject it first. If the two  * instances are codependent (directly or transitively), ordering of injection is arbitrary.  */ ;/**  * Performs creation-time injections on all objects that require it. Whenever fulfilling an  * injection depends on another object that requires injection, we inject it first. If the two  * instances are codependent (directly or transitively), ordering of injection is arbitrary.  */ void injectAll(final Errors errors) {     // is made complicated by a bug in IBM's JDK, wherein entrySet().toArray(Object[]) doesn't work     for (InjectableReference<?> reference : new ArrayList<>(pendingInjection.values())) {         try {             reference.get(errors).         } catch (ErrorsException e) {             errors.merge(e.getErrors()).         }     }     if (!pendingInjection.isEmpty()) {         throw new AssertionError("Failed to satisfy " + pendingInjection).     }     ready.countDown(). }
false;public;1;5;;public void validate(Errors errors) throws ErrorsException {     // the type of 'T' is a TypeLiteral<T>     @SuppressWarnings("unchecked")     TypeLiteral<T> type = TypeLiteral.get((Class<T>) instance.getClass()).     membersInjector = injector.membersInjectorStore.get(type, errors.withSource(source)). }
true;public;1;24;/**  * Reentrant. If {@code instance} was registered for injection at injector-creation time, this  * method will ensure that all its members have been injected before returning.  */ ;/**  * Reentrant. If {@code instance} was registered for injection at injector-creation time, this  * method will ensure that all its members have been injected before returning.  */ @Override public T get(Errors errors) throws ErrorsException {     if (ready.getCount() == 0) {         return instance.     }     // just wait for everything to be injected by another thread     if (Thread.currentThread() != creatingThread) {         try {             ready.await().             return instance.         } catch (InterruptedException e) {             // Give up, since we don't know if our injection is ready             throw new RuntimeException(e).         }     }     // toInject needs injection, do it right away. we only do this once, even if it fails     if (pendingInjection.remove(instance) != null) {         membersInjector.injectAndNotify(instance, errors.withSource(source)).     }     return instance. }
false;public;0;4;;@Override public String toString() {     return instance.toString(). }
