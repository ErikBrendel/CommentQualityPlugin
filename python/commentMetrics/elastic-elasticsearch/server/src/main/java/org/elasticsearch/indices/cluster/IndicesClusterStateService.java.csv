# id;timestamp;commentText;codeText;commentWords;codeWords
IndicesClusterStateService -> private static DiscoveryNode findSourceNodeForPeerRecovery(Logger logger, RoutingTable routingTable, DiscoveryNodes nodes,                                                                ShardRouting shardRouting);1524684173;Finds the routing source node for peer recovery, return null if its not found. Note, this method expects the shard_routing to *require* peer recovery, use {@link ShardRouting#recoverySource()} to check if its needed or not.;private static DiscoveryNode findSourceNodeForPeerRecovery(Logger logger, RoutingTable routingTable, DiscoveryNodes nodes,_                                                               ShardRouting shardRouting) {_        DiscoveryNode sourceNode = null__        if (!shardRouting.primary()) {_            ShardRouting primary = routingTable.shardRoutingTable(shardRouting.shardId()).primaryShard()__            _            if (primary.active()) {_                sourceNode = nodes.get(primary.currentNodeId())__                if (sourceNode == null) {_                    logger.trace("can't find replica source node because primary shard {} is assigned to an unknown node.", primary)__                }_            } else {_                logger.trace("can't find replica source node because primary shard {} is not active.", primary)__            }_        } else if (shardRouting.relocatingNodeId() != null) {_            sourceNode = nodes.get(shardRouting.relocatingNodeId())__            if (sourceNode == null) {_                logger.trace("can't find relocation source node for shard {} because it is assigned to an unknown node [{}].",_                    shardRouting.shardId(), shardRouting.relocatingNodeId())__            }_        } else {_            throw new IllegalStateException("trying to find source node for peer recovery when routing state means no peer recovery: " +_                shardRouting)__        }_        return sourceNode__    };finds,the,routing,source,node,for,peer,recovery,return,null,if,its,not,found,note,this,method,expects,the,shard,routing,to,require,peer,recovery,use,link,shard,routing,recovery,source,to,check,if,its,needed,or,not;private,static,discovery,node,find,source,node,for,peer,recovery,logger,logger,routing,table,routing,table,discovery,nodes,nodes,shard,routing,shard,routing,discovery,node,source,node,null,if,shard,routing,primary,shard,routing,primary,routing,table,shard,routing,table,shard,routing,shard,id,primary,shard,if,primary,active,source,node,nodes,get,primary,current,node,id,if,source,node,null,logger,trace,can,t,find,replica,source,node,because,primary,shard,is,assigned,to,an,unknown,node,primary,else,logger,trace,can,t,find,replica,source,node,because,primary,shard,is,not,active,primary,else,if,shard,routing,relocating,node,id,null,source,node,nodes,get,shard,routing,relocating,node,id,if,source,node,null,logger,trace,can,t,find,relocation,source,node,for,shard,because,it,is,assigned,to,an,unknown,node,shard,routing,shard,id,shard,routing,relocating,node,id,else,throw,new,illegal,state,exception,trying,to,find,source,node,for,peer,recovery,when,routing,state,means,no,peer,recovery,shard,routing,return,source,node
IndicesClusterStateService -> private static DiscoveryNode findSourceNodeForPeerRecovery(Logger logger, RoutingTable routingTable, DiscoveryNodes nodes,                                                                ShardRouting shardRouting);1533063033;Finds the routing source node for peer recovery, return null if its not found. Note, this method expects the shard_routing to *require* peer recovery, use {@link ShardRouting#recoverySource()} to check if its needed or not.;private static DiscoveryNode findSourceNodeForPeerRecovery(Logger logger, RoutingTable routingTable, DiscoveryNodes nodes,_                                                               ShardRouting shardRouting) {_        DiscoveryNode sourceNode = null__        if (!shardRouting.primary()) {_            ShardRouting primary = routingTable.shardRoutingTable(shardRouting.shardId()).primaryShard()__            _            if (primary.active()) {_                sourceNode = nodes.get(primary.currentNodeId())__                if (sourceNode == null) {_                    logger.trace("can't find replica source node because primary shard {} is assigned to an unknown node.", primary)__                }_            } else {_                logger.trace("can't find replica source node because primary shard {} is not active.", primary)__            }_        } else if (shardRouting.relocatingNodeId() != null) {_            sourceNode = nodes.get(shardRouting.relocatingNodeId())__            if (sourceNode == null) {_                logger.trace("can't find relocation source node for shard {} because it is assigned to an unknown node [{}].",_                    shardRouting.shardId(), shardRouting.relocatingNodeId())__            }_        } else {_            throw new IllegalStateException("trying to find source node for peer recovery when routing state means no peer recovery: " +_                shardRouting)__        }_        return sourceNode__    };finds,the,routing,source,node,for,peer,recovery,return,null,if,its,not,found,note,this,method,expects,the,shard,routing,to,require,peer,recovery,use,link,shard,routing,recovery,source,to,check,if,its,needed,or,not;private,static,discovery,node,find,source,node,for,peer,recovery,logger,logger,routing,table,routing,table,discovery,nodes,nodes,shard,routing,shard,routing,discovery,node,source,node,null,if,shard,routing,primary,shard,routing,primary,routing,table,shard,routing,table,shard,routing,shard,id,primary,shard,if,primary,active,source,node,nodes,get,primary,current,node,id,if,source,node,null,logger,trace,can,t,find,replica,source,node,because,primary,shard,is,assigned,to,an,unknown,node,primary,else,logger,trace,can,t,find,replica,source,node,because,primary,shard,is,not,active,primary,else,if,shard,routing,relocating,node,id,null,source,node,nodes,get,shard,routing,relocating,node,id,if,source,node,null,logger,trace,can,t,find,relocation,source,node,for,shard,because,it,is,assigned,to,an,unknown,node,shard,routing,shard,id,shard,routing,relocating,node,id,else,throw,new,illegal,state,exception,trying,to,find,source,node,for,peer,recovery,when,routing,state,means,no,peer,recovery,shard,routing,return,source,node
IndicesClusterStateService -> private static DiscoveryNode findSourceNodeForPeerRecovery(Logger logger, RoutingTable routingTable, DiscoveryNodes nodes,                                                                ShardRouting shardRouting);1535405719;Finds the routing source node for peer recovery, return null if its not found. Note, this method expects the shard_routing to *require* peer recovery, use {@link ShardRouting#recoverySource()} to check if its needed or not.;private static DiscoveryNode findSourceNodeForPeerRecovery(Logger logger, RoutingTable routingTable, DiscoveryNodes nodes,_                                                               ShardRouting shardRouting) {_        DiscoveryNode sourceNode = null__        if (!shardRouting.primary()) {_            ShardRouting primary = routingTable.shardRoutingTable(shardRouting.shardId()).primaryShard()__            _            if (primary.active()) {_                sourceNode = nodes.get(primary.currentNodeId())__                if (sourceNode == null) {_                    logger.trace("can't find replica source node because primary shard {} is assigned to an unknown node.", primary)__                }_            } else {_                logger.trace("can't find replica source node because primary shard {} is not active.", primary)__            }_        } else if (shardRouting.relocatingNodeId() != null) {_            sourceNode = nodes.get(shardRouting.relocatingNodeId())__            if (sourceNode == null) {_                logger.trace("can't find relocation source node for shard {} because it is assigned to an unknown node [{}].",_                    shardRouting.shardId(), shardRouting.relocatingNodeId())__            }_        } else {_            throw new IllegalStateException("trying to find source node for peer recovery when routing state means no peer recovery: " +_                shardRouting)__        }_        return sourceNode__    };finds,the,routing,source,node,for,peer,recovery,return,null,if,its,not,found,note,this,method,expects,the,shard,routing,to,require,peer,recovery,use,link,shard,routing,recovery,source,to,check,if,its,needed,or,not;private,static,discovery,node,find,source,node,for,peer,recovery,logger,logger,routing,table,routing,table,discovery,nodes,nodes,shard,routing,shard,routing,discovery,node,source,node,null,if,shard,routing,primary,shard,routing,primary,routing,table,shard,routing,table,shard,routing,shard,id,primary,shard,if,primary,active,source,node,nodes,get,primary,current,node,id,if,source,node,null,logger,trace,can,t,find,replica,source,node,because,primary,shard,is,assigned,to,an,unknown,node,primary,else,logger,trace,can,t,find,replica,source,node,because,primary,shard,is,not,active,primary,else,if,shard,routing,relocating,node,id,null,source,node,nodes,get,shard,routing,relocating,node,id,if,source,node,null,logger,trace,can,t,find,relocation,source,node,for,shard,because,it,is,assigned,to,an,unknown,node,shard,routing,shard,id,shard,routing,relocating,node,id,else,throw,new,illegal,state,exception,trying,to,find,source,node,for,peer,recovery,when,routing,state,means,no,peer,recovery,shard,routing,return,source,node
IndicesClusterStateService -> private static DiscoveryNode findSourceNodeForPeerRecovery(Logger logger, RoutingTable routingTable, DiscoveryNodes nodes,                                                                ShardRouting shardRouting);1539723533;Finds the routing source node for peer recovery, return null if its not found. Note, this method expects the shard_routing to *require* peer recovery, use {@link ShardRouting#recoverySource()} to check if its needed or not.;private static DiscoveryNode findSourceNodeForPeerRecovery(Logger logger, RoutingTable routingTable, DiscoveryNodes nodes,_                                                               ShardRouting shardRouting) {_        DiscoveryNode sourceNode = null__        if (!shardRouting.primary()) {_            ShardRouting primary = routingTable.shardRoutingTable(shardRouting.shardId()).primaryShard()__            _            if (primary.active()) {_                sourceNode = nodes.get(primary.currentNodeId())__                if (sourceNode == null) {_                    logger.trace("can't find replica source node because primary shard {} is assigned to an unknown node.", primary)__                }_            } else {_                logger.trace("can't find replica source node because primary shard {} is not active.", primary)__            }_        } else if (shardRouting.relocatingNodeId() != null) {_            sourceNode = nodes.get(shardRouting.relocatingNodeId())__            if (sourceNode == null) {_                logger.trace("can't find relocation source node for shard {} because it is assigned to an unknown node [{}].",_                    shardRouting.shardId(), shardRouting.relocatingNodeId())__            }_        } else {_            throw new IllegalStateException("trying to find source node for peer recovery when routing state means no peer recovery: " +_                shardRouting)__        }_        return sourceNode__    };finds,the,routing,source,node,for,peer,recovery,return,null,if,its,not,found,note,this,method,expects,the,shard,routing,to,require,peer,recovery,use,link,shard,routing,recovery,source,to,check,if,its,needed,or,not;private,static,discovery,node,find,source,node,for,peer,recovery,logger,logger,routing,table,routing,table,discovery,nodes,nodes,shard,routing,shard,routing,discovery,node,source,node,null,if,shard,routing,primary,shard,routing,primary,routing,table,shard,routing,table,shard,routing,shard,id,primary,shard,if,primary,active,source,node,nodes,get,primary,current,node,id,if,source,node,null,logger,trace,can,t,find,replica,source,node,because,primary,shard,is,assigned,to,an,unknown,node,primary,else,logger,trace,can,t,find,replica,source,node,because,primary,shard,is,not,active,primary,else,if,shard,routing,relocating,node,id,null,source,node,nodes,get,shard,routing,relocating,node,id,if,source,node,null,logger,trace,can,t,find,relocation,source,node,for,shard,because,it,is,assigned,to,an,unknown,node,shard,routing,shard,id,shard,routing,relocating,node,id,else,throw,new,illegal,state,exception,trying,to,find,source,node,for,peer,recovery,when,routing,state,means,no,peer,recovery,shard,routing,return,source,node
IndicesClusterStateService -> private static DiscoveryNode findSourceNodeForPeerRecovery(Logger logger, RoutingTable routingTable, DiscoveryNodes nodes,                                                                ShardRouting shardRouting);1541008027;Finds the routing source node for peer recovery, return null if its not found. Note, this method expects the shard_routing to *require* peer recovery, use {@link ShardRouting#recoverySource()} to check if its needed or not.;private static DiscoveryNode findSourceNodeForPeerRecovery(Logger logger, RoutingTable routingTable, DiscoveryNodes nodes,_                                                               ShardRouting shardRouting) {_        DiscoveryNode sourceNode = null__        if (!shardRouting.primary()) {_            ShardRouting primary = routingTable.shardRoutingTable(shardRouting.shardId()).primaryShard()__            _            if (primary.active()) {_                sourceNode = nodes.get(primary.currentNodeId())__                if (sourceNode == null) {_                    logger.trace("can't find replica source node because primary shard {} is assigned to an unknown node.", primary)__                }_            } else {_                logger.trace("can't find replica source node because primary shard {} is not active.", primary)__            }_        } else if (shardRouting.relocatingNodeId() != null) {_            sourceNode = nodes.get(shardRouting.relocatingNodeId())__            if (sourceNode == null) {_                logger.trace("can't find relocation source node for shard {} because it is assigned to an unknown node [{}].",_                    shardRouting.shardId(), shardRouting.relocatingNodeId())__            }_        } else {_            throw new IllegalStateException("trying to find source node for peer recovery when routing state means no peer recovery: " +_                shardRouting)__        }_        return sourceNode__    };finds,the,routing,source,node,for,peer,recovery,return,null,if,its,not,found,note,this,method,expects,the,shard,routing,to,require,peer,recovery,use,link,shard,routing,recovery,source,to,check,if,its,needed,or,not;private,static,discovery,node,find,source,node,for,peer,recovery,logger,logger,routing,table,routing,table,discovery,nodes,nodes,shard,routing,shard,routing,discovery,node,source,node,null,if,shard,routing,primary,shard,routing,primary,routing,table,shard,routing,table,shard,routing,shard,id,primary,shard,if,primary,active,source,node,nodes,get,primary,current,node,id,if,source,node,null,logger,trace,can,t,find,replica,source,node,because,primary,shard,is,assigned,to,an,unknown,node,primary,else,logger,trace,can,t,find,replica,source,node,because,primary,shard,is,not,active,primary,else,if,shard,routing,relocating,node,id,null,source,node,nodes,get,shard,routing,relocating,node,id,if,source,node,null,logger,trace,can,t,find,relocation,source,node,for,shard,because,it,is,assigned,to,an,unknown,node,shard,routing,shard,id,shard,routing,relocating,node,id,else,throw,new,illegal,state,exception,trying,to,find,source,node,for,peer,recovery,when,routing,state,means,no,peer,recovery,shard,routing,return,source,node
IndicesClusterStateService -> private static DiscoveryNode findSourceNodeForPeerRecovery(Logger logger, RoutingTable routingTable, DiscoveryNodes nodes,                                                                ShardRouting shardRouting);1542646292;Finds the routing source node for peer recovery, return null if its not found. Note, this method expects the shard_routing to *require* peer recovery, use {@link ShardRouting#recoverySource()} to check if its needed or not.;private static DiscoveryNode findSourceNodeForPeerRecovery(Logger logger, RoutingTable routingTable, DiscoveryNodes nodes,_                                                               ShardRouting shardRouting) {_        DiscoveryNode sourceNode = null__        if (!shardRouting.primary()) {_            ShardRouting primary = routingTable.shardRoutingTable(shardRouting.shardId()).primaryShard()__            _            if (primary.active()) {_                sourceNode = nodes.get(primary.currentNodeId())__                if (sourceNode == null) {_                    logger.trace("can't find replica source node because primary shard {} is assigned to an unknown node.", primary)__                }_            } else {_                logger.trace("can't find replica source node because primary shard {} is not active.", primary)__            }_        } else if (shardRouting.relocatingNodeId() != null) {_            sourceNode = nodes.get(shardRouting.relocatingNodeId())__            if (sourceNode == null) {_                logger.trace("can't find relocation source node for shard {} because it is assigned to an unknown node [{}].",_                    shardRouting.shardId(), shardRouting.relocatingNodeId())__            }_        } else {_            throw new IllegalStateException("trying to find source node for peer recovery when routing state means no peer recovery: " +_                shardRouting)__        }_        return sourceNode__    };finds,the,routing,source,node,for,peer,recovery,return,null,if,its,not,found,note,this,method,expects,the,shard,routing,to,require,peer,recovery,use,link,shard,routing,recovery,source,to,check,if,its,needed,or,not;private,static,discovery,node,find,source,node,for,peer,recovery,logger,logger,routing,table,routing,table,discovery,nodes,nodes,shard,routing,shard,routing,discovery,node,source,node,null,if,shard,routing,primary,shard,routing,primary,routing,table,shard,routing,table,shard,routing,shard,id,primary,shard,if,primary,active,source,node,nodes,get,primary,current,node,id,if,source,node,null,logger,trace,can,t,find,replica,source,node,because,primary,shard,is,assigned,to,an,unknown,node,primary,else,logger,trace,can,t,find,replica,source,node,because,primary,shard,is,not,active,primary,else,if,shard,routing,relocating,node,id,null,source,node,nodes,get,shard,routing,relocating,node,id,if,source,node,null,logger,trace,can,t,find,relocation,source,node,for,shard,because,it,is,assigned,to,an,unknown,node,shard,routing,shard,id,shard,routing,relocating,node,id,else,throw,new,illegal,state,exception,trying,to,find,source,node,for,peer,recovery,when,routing,state,means,no,peer,recovery,shard,routing,return,source,node
IndicesClusterStateService -> private static DiscoveryNode findSourceNodeForPeerRecovery(Logger logger, RoutingTable routingTable, DiscoveryNodes nodes,                                                                ShardRouting shardRouting);1547520324;Finds the routing source node for peer recovery, return null if its not found. Note, this method expects the shard_routing to *require* peer recovery, use {@link ShardRouting#recoverySource()} to check if its needed or not.;private static DiscoveryNode findSourceNodeForPeerRecovery(Logger logger, RoutingTable routingTable, DiscoveryNodes nodes,_                                                               ShardRouting shardRouting) {_        DiscoveryNode sourceNode = null__        if (!shardRouting.primary()) {_            ShardRouting primary = routingTable.shardRoutingTable(shardRouting.shardId()).primaryShard()__            _            if (primary.active()) {_                sourceNode = nodes.get(primary.currentNodeId())__                if (sourceNode == null) {_                    logger.trace("can't find replica source node because primary shard {} is assigned to an unknown node.", primary)__                }_            } else {_                logger.trace("can't find replica source node because primary shard {} is not active.", primary)__            }_        } else if (shardRouting.relocatingNodeId() != null) {_            sourceNode = nodes.get(shardRouting.relocatingNodeId())__            if (sourceNode == null) {_                logger.trace("can't find relocation source node for shard {} because it is assigned to an unknown node [{}].",_                    shardRouting.shardId(), shardRouting.relocatingNodeId())__            }_        } else {_            throw new IllegalStateException("trying to find source node for peer recovery when routing state means no peer recovery: " +_                shardRouting)__        }_        return sourceNode__    };finds,the,routing,source,node,for,peer,recovery,return,null,if,its,not,found,note,this,method,expects,the,shard,routing,to,require,peer,recovery,use,link,shard,routing,recovery,source,to,check,if,its,needed,or,not;private,static,discovery,node,find,source,node,for,peer,recovery,logger,logger,routing,table,routing,table,discovery,nodes,nodes,shard,routing,shard,routing,discovery,node,source,node,null,if,shard,routing,primary,shard,routing,primary,routing,table,shard,routing,table,shard,routing,shard,id,primary,shard,if,primary,active,source,node,nodes,get,primary,current,node,id,if,source,node,null,logger,trace,can,t,find,replica,source,node,because,primary,shard,is,assigned,to,an,unknown,node,primary,else,logger,trace,can,t,find,replica,source,node,because,primary,shard,is,not,active,primary,else,if,shard,routing,relocating,node,id,null,source,node,nodes,get,shard,routing,relocating,node,id,if,source,node,null,logger,trace,can,t,find,relocation,source,node,for,shard,because,it,is,assigned,to,an,unknown,node,shard,routing,shard,id,shard,routing,relocating,node,id,else,throw,new,illegal,state,exception,trying,to,find,source,node,for,peer,recovery,when,routing,state,means,no,peer,recovery,shard,routing,return,source,node
IndicesClusterStateService -> private static DiscoveryNode findSourceNodeForPeerRecovery(Logger logger, RoutingTable routingTable, DiscoveryNodes nodes,                                                                ShardRouting shardRouting);1547536822;Finds the routing source node for peer recovery, return null if its not found. Note, this method expects the shard_routing to *require* peer recovery, use {@link ShardRouting#recoverySource()} to check if its needed or not.;private static DiscoveryNode findSourceNodeForPeerRecovery(Logger logger, RoutingTable routingTable, DiscoveryNodes nodes,_                                                               ShardRouting shardRouting) {_        DiscoveryNode sourceNode = null__        if (!shardRouting.primary()) {_            ShardRouting primary = routingTable.shardRoutingTable(shardRouting.shardId()).primaryShard()__            _            if (primary.active()) {_                sourceNode = nodes.get(primary.currentNodeId())__                if (sourceNode == null) {_                    logger.trace("can't find replica source node because primary shard {} is assigned to an unknown node.", primary)__                }_            } else {_                logger.trace("can't find replica source node because primary shard {} is not active.", primary)__            }_        } else if (shardRouting.relocatingNodeId() != null) {_            sourceNode = nodes.get(shardRouting.relocatingNodeId())__            if (sourceNode == null) {_                logger.trace("can't find relocation source node for shard {} because it is assigned to an unknown node [{}].",_                    shardRouting.shardId(), shardRouting.relocatingNodeId())__            }_        } else {_            throw new IllegalStateException("trying to find source node for peer recovery when routing state means no peer recovery: " +_                shardRouting)__        }_        return sourceNode__    };finds,the,routing,source,node,for,peer,recovery,return,null,if,its,not,found,note,this,method,expects,the,shard,routing,to,require,peer,recovery,use,link,shard,routing,recovery,source,to,check,if,its,needed,or,not;private,static,discovery,node,find,source,node,for,peer,recovery,logger,logger,routing,table,routing,table,discovery,nodes,nodes,shard,routing,shard,routing,discovery,node,source,node,null,if,shard,routing,primary,shard,routing,primary,routing,table,shard,routing,table,shard,routing,shard,id,primary,shard,if,primary,active,source,node,nodes,get,primary,current,node,id,if,source,node,null,logger,trace,can,t,find,replica,source,node,because,primary,shard,is,assigned,to,an,unknown,node,primary,else,logger,trace,can,t,find,replica,source,node,because,primary,shard,is,not,active,primary,else,if,shard,routing,relocating,node,id,null,source,node,nodes,get,shard,routing,relocating,node,id,if,source,node,null,logger,trace,can,t,find,relocation,source,node,for,shard,because,it,is,assigned,to,an,unknown,node,shard,routing,shard,id,shard,routing,relocating,node,id,else,throw,new,illegal,state,exception,trying,to,find,source,node,for,peer,recovery,when,routing,state,means,no,peer,recovery,shard,routing,return,source,node
IndicesClusterStateService -> private static DiscoveryNode findSourceNodeForPeerRecovery(Logger logger, RoutingTable routingTable, DiscoveryNodes nodes,                                                                ShardRouting shardRouting);1547625930;Finds the routing source node for peer recovery, return null if its not found. Note, this method expects the shard_routing to *require* peer recovery, use {@link ShardRouting#recoverySource()} to check if its needed or not.;private static DiscoveryNode findSourceNodeForPeerRecovery(Logger logger, RoutingTable routingTable, DiscoveryNodes nodes,_                                                               ShardRouting shardRouting) {_        DiscoveryNode sourceNode = null__        if (!shardRouting.primary()) {_            ShardRouting primary = routingTable.shardRoutingTable(shardRouting.shardId()).primaryShard()__            _            if (primary.active()) {_                sourceNode = nodes.get(primary.currentNodeId())__                if (sourceNode == null) {_                    logger.trace("can't find replica source node because primary shard {} is assigned to an unknown node.", primary)__                }_            } else {_                logger.trace("can't find replica source node because primary shard {} is not active.", primary)__            }_        } else if (shardRouting.relocatingNodeId() != null) {_            sourceNode = nodes.get(shardRouting.relocatingNodeId())__            if (sourceNode == null) {_                logger.trace("can't find relocation source node for shard {} because it is assigned to an unknown node [{}].",_                    shardRouting.shardId(), shardRouting.relocatingNodeId())__            }_        } else {_            throw new IllegalStateException("trying to find source node for peer recovery when routing state means no peer recovery: " +_                shardRouting)__        }_        return sourceNode__    };finds,the,routing,source,node,for,peer,recovery,return,null,if,its,not,found,note,this,method,expects,the,shard,routing,to,require,peer,recovery,use,link,shard,routing,recovery,source,to,check,if,its,needed,or,not;private,static,discovery,node,find,source,node,for,peer,recovery,logger,logger,routing,table,routing,table,discovery,nodes,nodes,shard,routing,shard,routing,discovery,node,source,node,null,if,shard,routing,primary,shard,routing,primary,routing,table,shard,routing,table,shard,routing,shard,id,primary,shard,if,primary,active,source,node,nodes,get,primary,current,node,id,if,source,node,null,logger,trace,can,t,find,replica,source,node,because,primary,shard,is,assigned,to,an,unknown,node,primary,else,logger,trace,can,t,find,replica,source,node,because,primary,shard,is,not,active,primary,else,if,shard,routing,relocating,node,id,null,source,node,nodes,get,shard,routing,relocating,node,id,if,source,node,null,logger,trace,can,t,find,relocation,source,node,for,shard,because,it,is,assigned,to,an,unknown,node,shard,routing,shard,id,shard,routing,relocating,node,id,else,throw,new,illegal,state,exception,trying,to,find,source,node,for,peer,recovery,when,routing,state,means,no,peer,recovery,shard,routing,return,source,node
IndicesClusterStateService -> private static DiscoveryNode findSourceNodeForPeerRecovery(Logger logger, RoutingTable routingTable, DiscoveryNodes nodes,                                                                ShardRouting shardRouting);1548593396;Finds the routing source node for peer recovery, return null if its not found. Note, this method expects the shard_routing to *require* peer recovery, use {@link ShardRouting#recoverySource()} to check if its needed or not.;private static DiscoveryNode findSourceNodeForPeerRecovery(Logger logger, RoutingTable routingTable, DiscoveryNodes nodes,_                                                               ShardRouting shardRouting) {_        DiscoveryNode sourceNode = null__        if (!shardRouting.primary()) {_            ShardRouting primary = routingTable.shardRoutingTable(shardRouting.shardId()).primaryShard()__            _            if (primary.active()) {_                sourceNode = nodes.get(primary.currentNodeId())__                if (sourceNode == null) {_                    logger.trace("can't find replica source node because primary shard {} is assigned to an unknown node.", primary)__                }_            } else {_                logger.trace("can't find replica source node because primary shard {} is not active.", primary)__            }_        } else if (shardRouting.relocatingNodeId() != null) {_            sourceNode = nodes.get(shardRouting.relocatingNodeId())__            if (sourceNode == null) {_                logger.trace("can't find relocation source node for shard {} because it is assigned to an unknown node [{}].",_                    shardRouting.shardId(), shardRouting.relocatingNodeId())__            }_        } else {_            throw new IllegalStateException("trying to find source node for peer recovery when routing state means no peer recovery: " +_                shardRouting)__        }_        return sourceNode__    };finds,the,routing,source,node,for,peer,recovery,return,null,if,its,not,found,note,this,method,expects,the,shard,routing,to,require,peer,recovery,use,link,shard,routing,recovery,source,to,check,if,its,needed,or,not;private,static,discovery,node,find,source,node,for,peer,recovery,logger,logger,routing,table,routing,table,discovery,nodes,nodes,shard,routing,shard,routing,discovery,node,source,node,null,if,shard,routing,primary,shard,routing,primary,routing,table,shard,routing,table,shard,routing,shard,id,primary,shard,if,primary,active,source,node,nodes,get,primary,current,node,id,if,source,node,null,logger,trace,can,t,find,replica,source,node,because,primary,shard,is,assigned,to,an,unknown,node,primary,else,logger,trace,can,t,find,replica,source,node,because,primary,shard,is,not,active,primary,else,if,shard,routing,relocating,node,id,null,source,node,nodes,get,shard,routing,relocating,node,id,if,source,node,null,logger,trace,can,t,find,relocation,source,node,for,shard,because,it,is,assigned,to,an,unknown,node,shard,routing,shard,id,shard,routing,relocating,node,id,else,throw,new,illegal,state,exception,trying,to,find,source,node,for,peer,recovery,when,routing,state,means,no,peer,recovery,shard,routing,return,source,node
IndicesClusterStateService -> private static DiscoveryNode findSourceNodeForPeerRecovery(Logger logger, RoutingTable routingTable, DiscoveryNodes nodes,                                                                ShardRouting shardRouting);1548770980;Finds the routing source node for peer recovery, return null if its not found. Note, this method expects the shard_routing to *require* peer recovery, use {@link ShardRouting#recoverySource()} to check if its needed or not.;private static DiscoveryNode findSourceNodeForPeerRecovery(Logger logger, RoutingTable routingTable, DiscoveryNodes nodes,_                                                               ShardRouting shardRouting) {_        DiscoveryNode sourceNode = null__        if (!shardRouting.primary()) {_            ShardRouting primary = routingTable.shardRoutingTable(shardRouting.shardId()).primaryShard()__            _            if (primary.active()) {_                sourceNode = nodes.get(primary.currentNodeId())__                if (sourceNode == null) {_                    logger.trace("can't find replica source node because primary shard {} is assigned to an unknown node.", primary)__                }_            } else {_                logger.trace("can't find replica source node because primary shard {} is not active.", primary)__            }_        } else if (shardRouting.relocatingNodeId() != null) {_            sourceNode = nodes.get(shardRouting.relocatingNodeId())__            if (sourceNode == null) {_                logger.trace("can't find relocation source node for shard {} because it is assigned to an unknown node [{}].",_                    shardRouting.shardId(), shardRouting.relocatingNodeId())__            }_        } else {_            throw new IllegalStateException("trying to find source node for peer recovery when routing state means no peer recovery: " +_                shardRouting)__        }_        return sourceNode__    };finds,the,routing,source,node,for,peer,recovery,return,null,if,its,not,found,note,this,method,expects,the,shard,routing,to,require,peer,recovery,use,link,shard,routing,recovery,source,to,check,if,its,needed,or,not;private,static,discovery,node,find,source,node,for,peer,recovery,logger,logger,routing,table,routing,table,discovery,nodes,nodes,shard,routing,shard,routing,discovery,node,source,node,null,if,shard,routing,primary,shard,routing,primary,routing,table,shard,routing,table,shard,routing,shard,id,primary,shard,if,primary,active,source,node,nodes,get,primary,current,node,id,if,source,node,null,logger,trace,can,t,find,replica,source,node,because,primary,shard,is,assigned,to,an,unknown,node,primary,else,logger,trace,can,t,find,replica,source,node,because,primary,shard,is,not,active,primary,else,if,shard,routing,relocating,node,id,null,source,node,nodes,get,shard,routing,relocating,node,id,if,source,node,null,logger,trace,can,t,find,relocation,source,node,for,shard,because,it,is,assigned,to,an,unknown,node,shard,routing,shard,id,shard,routing,relocating,node,id,else,throw,new,illegal,state,exception,trying,to,find,source,node,for,peer,recovery,when,routing,state,means,no,peer,recovery,shard,routing,return,source,node
IndicesClusterStateService -> private static DiscoveryNode findSourceNodeForPeerRecovery(Logger logger, RoutingTable routingTable, DiscoveryNodes nodes,                                                                ShardRouting shardRouting);1548872469;Finds the routing source node for peer recovery, return null if its not found. Note, this method expects the shard_routing to *require* peer recovery, use {@link ShardRouting#recoverySource()} to check if its needed or not.;private static DiscoveryNode findSourceNodeForPeerRecovery(Logger logger, RoutingTable routingTable, DiscoveryNodes nodes,_                                                               ShardRouting shardRouting) {_        DiscoveryNode sourceNode = null__        if (!shardRouting.primary()) {_            ShardRouting primary = routingTable.shardRoutingTable(shardRouting.shardId()).primaryShard()__            _            if (primary.active()) {_                sourceNode = nodes.get(primary.currentNodeId())__                if (sourceNode == null) {_                    logger.trace("can't find replica source node because primary shard {} is assigned to an unknown node.", primary)__                }_            } else {_                logger.trace("can't find replica source node because primary shard {} is not active.", primary)__            }_        } else if (shardRouting.relocatingNodeId() != null) {_            sourceNode = nodes.get(shardRouting.relocatingNodeId())__            if (sourceNode == null) {_                logger.trace("can't find relocation source node for shard {} because it is assigned to an unknown node [{}].",_                    shardRouting.shardId(), shardRouting.relocatingNodeId())__            }_        } else {_            throw new IllegalStateException("trying to find source node for peer recovery when routing state means no peer recovery: " +_                shardRouting)__        }_        return sourceNode__    };finds,the,routing,source,node,for,peer,recovery,return,null,if,its,not,found,note,this,method,expects,the,shard,routing,to,require,peer,recovery,use,link,shard,routing,recovery,source,to,check,if,its,needed,or,not;private,static,discovery,node,find,source,node,for,peer,recovery,logger,logger,routing,table,routing,table,discovery,nodes,nodes,shard,routing,shard,routing,discovery,node,source,node,null,if,shard,routing,primary,shard,routing,primary,routing,table,shard,routing,table,shard,routing,shard,id,primary,shard,if,primary,active,source,node,nodes,get,primary,current,node,id,if,source,node,null,logger,trace,can,t,find,replica,source,node,because,primary,shard,is,assigned,to,an,unknown,node,primary,else,logger,trace,can,t,find,replica,source,node,because,primary,shard,is,not,active,primary,else,if,shard,routing,relocating,node,id,null,source,node,nodes,get,shard,routing,relocating,node,id,if,source,node,null,logger,trace,can,t,find,relocation,source,node,for,shard,because,it,is,assigned,to,an,unknown,node,shard,routing,shard,id,shard,routing,relocating,node,id,else,throw,new,illegal,state,exception,trying,to,find,source,node,for,peer,recovery,when,routing,state,means,no,peer,recovery,shard,routing,return,source,node
IndicesClusterStateService -> private static DiscoveryNode findSourceNodeForPeerRecovery(Logger logger, RoutingTable routingTable, DiscoveryNodes nodes,                                                                ShardRouting shardRouting);1549294529;Finds the routing source node for peer recovery, return null if its not found. Note, this method expects the shard_routing to *require* peer recovery, use {@link ShardRouting#recoverySource()} to check if its needed or not.;private static DiscoveryNode findSourceNodeForPeerRecovery(Logger logger, RoutingTable routingTable, DiscoveryNodes nodes,_                                                               ShardRouting shardRouting) {_        DiscoveryNode sourceNode = null__        if (!shardRouting.primary()) {_            ShardRouting primary = routingTable.shardRoutingTable(shardRouting.shardId()).primaryShard()__            _            if (primary.active()) {_                sourceNode = nodes.get(primary.currentNodeId())__                if (sourceNode == null) {_                    logger.trace("can't find replica source node because primary shard {} is assigned to an unknown node.", primary)__                }_            } else {_                logger.trace("can't find replica source node because primary shard {} is not active.", primary)__            }_        } else if (shardRouting.relocatingNodeId() != null) {_            sourceNode = nodes.get(shardRouting.relocatingNodeId())__            if (sourceNode == null) {_                logger.trace("can't find relocation source node for shard {} because it is assigned to an unknown node [{}].",_                    shardRouting.shardId(), shardRouting.relocatingNodeId())__            }_        } else {_            throw new IllegalStateException("trying to find source node for peer recovery when routing state means no peer recovery: " +_                shardRouting)__        }_        return sourceNode__    };finds,the,routing,source,node,for,peer,recovery,return,null,if,its,not,found,note,this,method,expects,the,shard,routing,to,require,peer,recovery,use,link,shard,routing,recovery,source,to,check,if,its,needed,or,not;private,static,discovery,node,find,source,node,for,peer,recovery,logger,logger,routing,table,routing,table,discovery,nodes,nodes,shard,routing,shard,routing,discovery,node,source,node,null,if,shard,routing,primary,shard,routing,primary,routing,table,shard,routing,table,shard,routing,shard,id,primary,shard,if,primary,active,source,node,nodes,get,primary,current,node,id,if,source,node,null,logger,trace,can,t,find,replica,source,node,because,primary,shard,is,assigned,to,an,unknown,node,primary,else,logger,trace,can,t,find,replica,source,node,because,primary,shard,is,not,active,primary,else,if,shard,routing,relocating,node,id,null,source,node,nodes,get,shard,routing,relocating,node,id,if,source,node,null,logger,trace,can,t,find,relocation,source,node,for,shard,because,it,is,assigned,to,an,unknown,node,shard,routing,shard,id,shard,routing,relocating,node,id,else,throw,new,illegal,state,exception,trying,to,find,source,node,for,peer,recovery,when,routing,state,means,no,peer,recovery,shard,routing,return,source,node
IndicesClusterStateService -> private void failMissingShards(final ClusterState state);1524684173;Notifies master about shards that don't exist but are supposed to be active on this node.__@param state new cluster state;private void failMissingShards(final ClusterState state) {_        RoutingNode localRoutingNode = state.getRoutingNodes().node(state.nodes().getLocalNodeId())__        if (localRoutingNode == null) {_            return__        }_        for (final ShardRouting shardRouting : localRoutingNode) {_            ShardId shardId = shardRouting.shardId()__            if (shardRouting.initializing() == false &&_                failedShardsCache.containsKey(shardId) == false &&_                indicesService.getShardOrNull(shardId) == null) {_                _                sendFailShard(shardRouting, "master marked shard as active, but shard has not been created, mark shard as failed", null,_                    state)__            }_        }_    };notifies,master,about,shards,that,don,t,exist,but,are,supposed,to,be,active,on,this,node,param,state,new,cluster,state;private,void,fail,missing,shards,final,cluster,state,state,routing,node,local,routing,node,state,get,routing,nodes,node,state,nodes,get,local,node,id,if,local,routing,node,null,return,for,final,shard,routing,shard,routing,local,routing,node,shard,id,shard,id,shard,routing,shard,id,if,shard,routing,initializing,false,failed,shards,cache,contains,key,shard,id,false,indices,service,get,shard,or,null,shard,id,null,send,fail,shard,shard,routing,master,marked,shard,as,active,but,shard,has,not,been,created,mark,shard,as,failed,null,state
IndicesClusterStateService -> private void failMissingShards(final ClusterState state);1533063033;Notifies master about shards that don't exist but are supposed to be active on this node.__@param state new cluster state;private void failMissingShards(final ClusterState state) {_        RoutingNode localRoutingNode = state.getRoutingNodes().node(state.nodes().getLocalNodeId())__        if (localRoutingNode == null) {_            return__        }_        for (final ShardRouting shardRouting : localRoutingNode) {_            ShardId shardId = shardRouting.shardId()__            if (shardRouting.initializing() == false &&_                failedShardsCache.containsKey(shardId) == false &&_                indicesService.getShardOrNull(shardId) == null) {_                _                sendFailShard(shardRouting, "master marked shard as active, but shard has not been created, mark shard as failed", null,_                    state)__            }_        }_    };notifies,master,about,shards,that,don,t,exist,but,are,supposed,to,be,active,on,this,node,param,state,new,cluster,state;private,void,fail,missing,shards,final,cluster,state,state,routing,node,local,routing,node,state,get,routing,nodes,node,state,nodes,get,local,node,id,if,local,routing,node,null,return,for,final,shard,routing,shard,routing,local,routing,node,shard,id,shard,id,shard,routing,shard,id,if,shard,routing,initializing,false,failed,shards,cache,contains,key,shard,id,false,indices,service,get,shard,or,null,shard,id,null,send,fail,shard,shard,routing,master,marked,shard,as,active,but,shard,has,not,been,created,mark,shard,as,failed,null,state
IndicesClusterStateService -> private void failMissingShards(final ClusterState state);1535405719;Notifies master about shards that don't exist but are supposed to be active on this node.__@param state new cluster state;private void failMissingShards(final ClusterState state) {_        RoutingNode localRoutingNode = state.getRoutingNodes().node(state.nodes().getLocalNodeId())__        if (localRoutingNode == null) {_            return__        }_        for (final ShardRouting shardRouting : localRoutingNode) {_            ShardId shardId = shardRouting.shardId()__            if (shardRouting.initializing() == false &&_                failedShardsCache.containsKey(shardId) == false &&_                indicesService.getShardOrNull(shardId) == null) {_                _                sendFailShard(shardRouting, "master marked shard as active, but shard has not been created, mark shard as failed", null,_                    state)__            }_        }_    };notifies,master,about,shards,that,don,t,exist,but,are,supposed,to,be,active,on,this,node,param,state,new,cluster,state;private,void,fail,missing,shards,final,cluster,state,state,routing,node,local,routing,node,state,get,routing,nodes,node,state,nodes,get,local,node,id,if,local,routing,node,null,return,for,final,shard,routing,shard,routing,local,routing,node,shard,id,shard,id,shard,routing,shard,id,if,shard,routing,initializing,false,failed,shards,cache,contains,key,shard,id,false,indices,service,get,shard,or,null,shard,id,null,send,fail,shard,shard,routing,master,marked,shard,as,active,but,shard,has,not,been,created,mark,shard,as,failed,null,state
IndicesClusterStateService -> private void failMissingShards(final ClusterState state);1539723533;Notifies master about shards that don't exist but are supposed to be active on this node.__@param state new cluster state;private void failMissingShards(final ClusterState state) {_        RoutingNode localRoutingNode = state.getRoutingNodes().node(state.nodes().getLocalNodeId())__        if (localRoutingNode == null) {_            return__        }_        for (final ShardRouting shardRouting : localRoutingNode) {_            ShardId shardId = shardRouting.shardId()__            if (shardRouting.initializing() == false &&_                failedShardsCache.containsKey(shardId) == false &&_                indicesService.getShardOrNull(shardId) == null) {_                _                sendFailShard(shardRouting, "master marked shard as active, but shard has not been created, mark shard as failed", null,_                    state)__            }_        }_    };notifies,master,about,shards,that,don,t,exist,but,are,supposed,to,be,active,on,this,node,param,state,new,cluster,state;private,void,fail,missing,shards,final,cluster,state,state,routing,node,local,routing,node,state,get,routing,nodes,node,state,nodes,get,local,node,id,if,local,routing,node,null,return,for,final,shard,routing,shard,routing,local,routing,node,shard,id,shard,id,shard,routing,shard,id,if,shard,routing,initializing,false,failed,shards,cache,contains,key,shard,id,false,indices,service,get,shard,or,null,shard,id,null,send,fail,shard,shard,routing,master,marked,shard,as,active,but,shard,has,not,been,created,mark,shard,as,failed,null,state
IndicesClusterStateService -> private void failMissingShards(final ClusterState state);1541008027;Notifies master about shards that don't exist but are supposed to be active on this node.__@param state new cluster state;private void failMissingShards(final ClusterState state) {_        RoutingNode localRoutingNode = state.getRoutingNodes().node(state.nodes().getLocalNodeId())__        if (localRoutingNode == null) {_            return__        }_        for (final ShardRouting shardRouting : localRoutingNode) {_            ShardId shardId = shardRouting.shardId()__            if (shardRouting.initializing() == false &&_                failedShardsCache.containsKey(shardId) == false &&_                indicesService.getShardOrNull(shardId) == null) {_                _                sendFailShard(shardRouting, "master marked shard as active, but shard has not been created, mark shard as failed", null,_                    state)__            }_        }_    };notifies,master,about,shards,that,don,t,exist,but,are,supposed,to,be,active,on,this,node,param,state,new,cluster,state;private,void,fail,missing,shards,final,cluster,state,state,routing,node,local,routing,node,state,get,routing,nodes,node,state,nodes,get,local,node,id,if,local,routing,node,null,return,for,final,shard,routing,shard,routing,local,routing,node,shard,id,shard,id,shard,routing,shard,id,if,shard,routing,initializing,false,failed,shards,cache,contains,key,shard,id,false,indices,service,get,shard,or,null,shard,id,null,send,fail,shard,shard,routing,master,marked,shard,as,active,but,shard,has,not,been,created,mark,shard,as,failed,null,state
IndicesClusterStateService -> private void failMissingShards(final ClusterState state);1542646292;Notifies master about shards that don't exist but are supposed to be active on this node.__@param state new cluster state;private void failMissingShards(final ClusterState state) {_        RoutingNode localRoutingNode = state.getRoutingNodes().node(state.nodes().getLocalNodeId())__        if (localRoutingNode == null) {_            return__        }_        for (final ShardRouting shardRouting : localRoutingNode) {_            ShardId shardId = shardRouting.shardId()__            if (shardRouting.initializing() == false &&_                failedShardsCache.containsKey(shardId) == false &&_                indicesService.getShardOrNull(shardId) == null) {_                _                sendFailShard(shardRouting, "master marked shard as active, but shard has not been created, mark shard as failed", null,_                    state)__            }_        }_    };notifies,master,about,shards,that,don,t,exist,but,are,supposed,to,be,active,on,this,node,param,state,new,cluster,state;private,void,fail,missing,shards,final,cluster,state,state,routing,node,local,routing,node,state,get,routing,nodes,node,state,nodes,get,local,node,id,if,local,routing,node,null,return,for,final,shard,routing,shard,routing,local,routing,node,shard,id,shard,id,shard,routing,shard,id,if,shard,routing,initializing,false,failed,shards,cache,contains,key,shard,id,false,indices,service,get,shard,or,null,shard,id,null,send,fail,shard,shard,routing,master,marked,shard,as,active,but,shard,has,not,been,created,mark,shard,as,failed,null,state
IndicesClusterStateService -> private void failMissingShards(final ClusterState state);1547520324;Notifies master about shards that don't exist but are supposed to be active on this node.__@param state new cluster state;private void failMissingShards(final ClusterState state) {_        RoutingNode localRoutingNode = state.getRoutingNodes().node(state.nodes().getLocalNodeId())__        if (localRoutingNode == null) {_            return__        }_        for (final ShardRouting shardRouting : localRoutingNode) {_            ShardId shardId = shardRouting.shardId()__            if (shardRouting.initializing() == false &&_                failedShardsCache.containsKey(shardId) == false &&_                indicesService.getShardOrNull(shardId) == null) {_                _                sendFailShard(shardRouting, "master marked shard as active, but shard has not been created, mark shard as failed", null,_                    state)__            }_        }_    };notifies,master,about,shards,that,don,t,exist,but,are,supposed,to,be,active,on,this,node,param,state,new,cluster,state;private,void,fail,missing,shards,final,cluster,state,state,routing,node,local,routing,node,state,get,routing,nodes,node,state,nodes,get,local,node,id,if,local,routing,node,null,return,for,final,shard,routing,shard,routing,local,routing,node,shard,id,shard,id,shard,routing,shard,id,if,shard,routing,initializing,false,failed,shards,cache,contains,key,shard,id,false,indices,service,get,shard,or,null,shard,id,null,send,fail,shard,shard,routing,master,marked,shard,as,active,but,shard,has,not,been,created,mark,shard,as,failed,null,state
IndicesClusterStateService -> private void failMissingShards(final ClusterState state);1547536822;Notifies master about shards that don't exist but are supposed to be active on this node.__@param state new cluster state;private void failMissingShards(final ClusterState state) {_        RoutingNode localRoutingNode = state.getRoutingNodes().node(state.nodes().getLocalNodeId())__        if (localRoutingNode == null) {_            return__        }_        for (final ShardRouting shardRouting : localRoutingNode) {_            ShardId shardId = shardRouting.shardId()__            if (shardRouting.initializing() == false &&_                failedShardsCache.containsKey(shardId) == false &&_                indicesService.getShardOrNull(shardId) == null) {_                _                sendFailShard(shardRouting, "master marked shard as active, but shard has not been created, mark shard as failed", null,_                    state)__            }_        }_    };notifies,master,about,shards,that,don,t,exist,but,are,supposed,to,be,active,on,this,node,param,state,new,cluster,state;private,void,fail,missing,shards,final,cluster,state,state,routing,node,local,routing,node,state,get,routing,nodes,node,state,nodes,get,local,node,id,if,local,routing,node,null,return,for,final,shard,routing,shard,routing,local,routing,node,shard,id,shard,id,shard,routing,shard,id,if,shard,routing,initializing,false,failed,shards,cache,contains,key,shard,id,false,indices,service,get,shard,or,null,shard,id,null,send,fail,shard,shard,routing,master,marked,shard,as,active,but,shard,has,not,been,created,mark,shard,as,failed,null,state
IndicesClusterStateService -> private void failMissingShards(final ClusterState state);1547625930;Notifies master about shards that don't exist but are supposed to be active on this node.__@param state new cluster state;private void failMissingShards(final ClusterState state) {_        RoutingNode localRoutingNode = state.getRoutingNodes().node(state.nodes().getLocalNodeId())__        if (localRoutingNode == null) {_            return__        }_        for (final ShardRouting shardRouting : localRoutingNode) {_            ShardId shardId = shardRouting.shardId()__            if (shardRouting.initializing() == false &&_                failedShardsCache.containsKey(shardId) == false &&_                indicesService.getShardOrNull(shardId) == null) {_                _                sendFailShard(shardRouting, "master marked shard as active, but shard has not been created, mark shard as failed", null,_                    state)__            }_        }_    };notifies,master,about,shards,that,don,t,exist,but,are,supposed,to,be,active,on,this,node,param,state,new,cluster,state;private,void,fail,missing,shards,final,cluster,state,state,routing,node,local,routing,node,state,get,routing,nodes,node,state,nodes,get,local,node,id,if,local,routing,node,null,return,for,final,shard,routing,shard,routing,local,routing,node,shard,id,shard,id,shard,routing,shard,id,if,shard,routing,initializing,false,failed,shards,cache,contains,key,shard,id,false,indices,service,get,shard,or,null,shard,id,null,send,fail,shard,shard,routing,master,marked,shard,as,active,but,shard,has,not,been,created,mark,shard,as,failed,null,state
IndicesClusterStateService -> private void failMissingShards(final ClusterState state);1548593396;Notifies master about shards that don't exist but are supposed to be active on this node.__@param state new cluster state;private void failMissingShards(final ClusterState state) {_        RoutingNode localRoutingNode = state.getRoutingNodes().node(state.nodes().getLocalNodeId())__        if (localRoutingNode == null) {_            return__        }_        for (final ShardRouting shardRouting : localRoutingNode) {_            ShardId shardId = shardRouting.shardId()__            if (shardRouting.initializing() == false &&_                failedShardsCache.containsKey(shardId) == false &&_                indicesService.getShardOrNull(shardId) == null) {_                _                sendFailShard(shardRouting, "master marked shard as active, but shard has not been created, mark shard as failed", null,_                    state)__            }_        }_    };notifies,master,about,shards,that,don,t,exist,but,are,supposed,to,be,active,on,this,node,param,state,new,cluster,state;private,void,fail,missing,shards,final,cluster,state,state,routing,node,local,routing,node,state,get,routing,nodes,node,state,nodes,get,local,node,id,if,local,routing,node,null,return,for,final,shard,routing,shard,routing,local,routing,node,shard,id,shard,id,shard,routing,shard,id,if,shard,routing,initializing,false,failed,shards,cache,contains,key,shard,id,false,indices,service,get,shard,or,null,shard,id,null,send,fail,shard,shard,routing,master,marked,shard,as,active,but,shard,has,not,been,created,mark,shard,as,failed,null,state
IndicesClusterStateService -> private void failMissingShards(final ClusterState state);1548770980;Notifies master about shards that don't exist but are supposed to be active on this node.__@param state new cluster state;private void failMissingShards(final ClusterState state) {_        RoutingNode localRoutingNode = state.getRoutingNodes().node(state.nodes().getLocalNodeId())__        if (localRoutingNode == null) {_            return__        }_        for (final ShardRouting shardRouting : localRoutingNode) {_            ShardId shardId = shardRouting.shardId()__            if (shardRouting.initializing() == false &&_                failedShardsCache.containsKey(shardId) == false &&_                indicesService.getShardOrNull(shardId) == null) {_                _                sendFailShard(shardRouting, "master marked shard as active, but shard has not been created, mark shard as failed", null,_                    state)__            }_        }_    };notifies,master,about,shards,that,don,t,exist,but,are,supposed,to,be,active,on,this,node,param,state,new,cluster,state;private,void,fail,missing,shards,final,cluster,state,state,routing,node,local,routing,node,state,get,routing,nodes,node,state,nodes,get,local,node,id,if,local,routing,node,null,return,for,final,shard,routing,shard,routing,local,routing,node,shard,id,shard,id,shard,routing,shard,id,if,shard,routing,initializing,false,failed,shards,cache,contains,key,shard,id,false,indices,service,get,shard,or,null,shard,id,null,send,fail,shard,shard,routing,master,marked,shard,as,active,but,shard,has,not,been,created,mark,shard,as,failed,null,state
IndicesClusterStateService -> private void failMissingShards(final ClusterState state);1548872469;Notifies master about shards that don't exist but are supposed to be active on this node.__@param state new cluster state;private void failMissingShards(final ClusterState state) {_        RoutingNode localRoutingNode = state.getRoutingNodes().node(state.nodes().getLocalNodeId())__        if (localRoutingNode == null) {_            return__        }_        for (final ShardRouting shardRouting : localRoutingNode) {_            ShardId shardId = shardRouting.shardId()__            if (shardRouting.initializing() == false &&_                failedShardsCache.containsKey(shardId) == false &&_                indicesService.getShardOrNull(shardId) == null) {_                _                sendFailShard(shardRouting, "master marked shard as active, but shard has not been created, mark shard as failed", null,_                    state)__            }_        }_    };notifies,master,about,shards,that,don,t,exist,but,are,supposed,to,be,active,on,this,node,param,state,new,cluster,state;private,void,fail,missing,shards,final,cluster,state,state,routing,node,local,routing,node,state,get,routing,nodes,node,state,nodes,get,local,node,id,if,local,routing,node,null,return,for,final,shard,routing,shard,routing,local,routing,node,shard,id,shard,id,shard,routing,shard,id,if,shard,routing,initializing,false,failed,shards,cache,contains,key,shard,id,false,indices,service,get,shard,or,null,shard,id,null,send,fail,shard,shard,routing,master,marked,shard,as,active,but,shard,has,not,been,created,mark,shard,as,failed,null,state
IndicesClusterStateService -> private void failMissingShards(final ClusterState state);1549294529;Notifies master about shards that don't exist but are supposed to be active on this node.__@param state new cluster state;private void failMissingShards(final ClusterState state) {_        RoutingNode localRoutingNode = state.getRoutingNodes().node(state.nodes().getLocalNodeId())__        if (localRoutingNode == null) {_            return__        }_        for (final ShardRouting shardRouting : localRoutingNode) {_            ShardId shardId = shardRouting.shardId()__            if (shardRouting.initializing() == false &&_                failedShardsCache.containsKey(shardId) == false &&_                indicesService.getShardOrNull(shardId) == null) {_                _                sendFailShard(shardRouting, "master marked shard as active, but shard has not been created, mark shard as failed", null,_                    state)__            }_        }_    };notifies,master,about,shards,that,don,t,exist,but,are,supposed,to,be,active,on,this,node,param,state,new,cluster,state;private,void,fail,missing,shards,final,cluster,state,state,routing,node,local,routing,node,state,get,routing,nodes,node,state,nodes,get,local,node,id,if,local,routing,node,null,return,for,final,shard,routing,shard,routing,local,routing,node,shard,id,shard,id,shard,routing,shard,id,if,shard,routing,initializing,false,failed,shards,cache,contains,key,shard,id,false,indices,service,get,shard,or,null,shard,id,null,send,fail,shard,shard,routing,master,marked,shard,as,active,but,shard,has,not,been,created,mark,shard,as,failed,null,state
IndicesClusterStateService -> AllocatedIndex -> @Nullable T getShardOrNull(int shardId)_;1524684173;Returns shard with given id.;@Nullable T getShardOrNull(int shardId)_;returns,shard,with,given,id;nullable,t,get,shard,or,null,int,shard,id
IndicesClusterStateService -> AllocatedIndex -> @Nullable T getShardOrNull(int shardId)_;1533063033;Returns shard with given id.;@Nullable T getShardOrNull(int shardId)_;returns,shard,with,given,id;nullable,t,get,shard,or,null,int,shard,id
IndicesClusterStateService -> AllocatedIndex -> @Nullable T getShardOrNull(int shardId)_;1535405719;Returns shard with given id.;@Nullable T getShardOrNull(int shardId)_;returns,shard,with,given,id;nullable,t,get,shard,or,null,int,shard,id
IndicesClusterStateService -> AllocatedIndex -> @Nullable T getShardOrNull(int shardId)_;1539723533;Returns shard with given id.;@Nullable T getShardOrNull(int shardId)_;returns,shard,with,given,id;nullable,t,get,shard,or,null,int,shard,id
IndicesClusterStateService -> AllocatedIndex -> @Nullable T getShardOrNull(int shardId)_;1541008027;Returns shard with given id.;@Nullable T getShardOrNull(int shardId)_;returns,shard,with,given,id;nullable,t,get,shard,or,null,int,shard,id
IndicesClusterStateService -> AllocatedIndex -> @Nullable T getShardOrNull(int shardId)_;1542646292;Returns shard with given id.;@Nullable T getShardOrNull(int shardId)_;returns,shard,with,given,id;nullable,t,get,shard,or,null,int,shard,id
IndicesClusterStateService -> AllocatedIndex -> @Nullable T getShardOrNull(int shardId)_;1547520324;Returns shard with given id.;@Nullable T getShardOrNull(int shardId)_;returns,shard,with,given,id;nullable,t,get,shard,or,null,int,shard,id
IndicesClusterStateService -> AllocatedIndex -> @Nullable T getShardOrNull(int shardId)_;1547536822;Returns shard with given id.;@Nullable T getShardOrNull(int shardId)_;returns,shard,with,given,id;nullable,t,get,shard,or,null,int,shard,id
IndicesClusterStateService -> AllocatedIndex -> @Nullable T getShardOrNull(int shardId)_;1547625930;Returns shard with given id.;@Nullable T getShardOrNull(int shardId)_;returns,shard,with,given,id;nullable,t,get,shard,or,null,int,shard,id
IndicesClusterStateService -> AllocatedIndex -> @Nullable T getShardOrNull(int shardId)_;1548593396;Returns shard with given id.;@Nullable T getShardOrNull(int shardId)_;returns,shard,with,given,id;nullable,t,get,shard,or,null,int,shard,id
IndicesClusterStateService -> AllocatedIndex -> @Nullable T getShardOrNull(int shardId)_;1548770980;Returns shard with given id.;@Nullable T getShardOrNull(int shardId)_;returns,shard,with,given,id;nullable,t,get,shard,or,null,int,shard,id
IndicesClusterStateService -> AllocatedIndex -> @Nullable T getShardOrNull(int shardId)_;1548872469;Returns shard with given id.;@Nullable T getShardOrNull(int shardId)_;returns,shard,with,given,id;nullable,t,get,shard,or,null,int,shard,id
IndicesClusterStateService -> AllocatedIndex -> @Nullable T getShardOrNull(int shardId)_;1549294529;Returns shard with given id.;@Nullable T getShardOrNull(int shardId)_;returns,shard,with,given,id;nullable,t,get,shard,or,null,int,shard,id
IndicesClusterStateService -> AllocatedIndices -> IndexMetaData verifyIndexIsDeleted(Index index, ClusterState clusterState)_;1524684173;Verify that the contents on disk for the given index is deleted_ if not, delete the contents._This method assumes that an index is already deleted in the cluster state and/or explicitly_through index tombstones._@param index {@code Index} to make sure its deleted from disk_@param clusterState {@code ClusterState} to ensure the index is not part of it_@return IndexMetaData for the index loaded from disk;IndexMetaData verifyIndexIsDeleted(Index index, ClusterState clusterState)_;verify,that,the,contents,on,disk,for,the,given,index,is,deleted,if,not,delete,the,contents,this,method,assumes,that,an,index,is,already,deleted,in,the,cluster,state,and,or,explicitly,through,index,tombstones,param,index,code,index,to,make,sure,its,deleted,from,disk,param,cluster,state,code,cluster,state,to,ensure,the,index,is,not,part,of,it,return,index,meta,data,for,the,index,loaded,from,disk;index,meta,data,verify,index,is,deleted,index,index,cluster,state,cluster,state
IndicesClusterStateService -> AllocatedIndices -> IndexMetaData verifyIndexIsDeleted(Index index, ClusterState clusterState)_;1533063033;Verify that the contents on disk for the given index is deleted_ if not, delete the contents._This method assumes that an index is already deleted in the cluster state and/or explicitly_through index tombstones._@param index {@code Index} to make sure its deleted from disk_@param clusterState {@code ClusterState} to ensure the index is not part of it_@return IndexMetaData for the index loaded from disk;IndexMetaData verifyIndexIsDeleted(Index index, ClusterState clusterState)_;verify,that,the,contents,on,disk,for,the,given,index,is,deleted,if,not,delete,the,contents,this,method,assumes,that,an,index,is,already,deleted,in,the,cluster,state,and,or,explicitly,through,index,tombstones,param,index,code,index,to,make,sure,its,deleted,from,disk,param,cluster,state,code,cluster,state,to,ensure,the,index,is,not,part,of,it,return,index,meta,data,for,the,index,loaded,from,disk;index,meta,data,verify,index,is,deleted,index,index,cluster,state,cluster,state
IndicesClusterStateService -> AllocatedIndices -> IndexMetaData verifyIndexIsDeleted(Index index, ClusterState clusterState)_;1535405719;Verify that the contents on disk for the given index is deleted_ if not, delete the contents._This method assumes that an index is already deleted in the cluster state and/or explicitly_through index tombstones._@param index {@code Index} to make sure its deleted from disk_@param clusterState {@code ClusterState} to ensure the index is not part of it_@return IndexMetaData for the index loaded from disk;IndexMetaData verifyIndexIsDeleted(Index index, ClusterState clusterState)_;verify,that,the,contents,on,disk,for,the,given,index,is,deleted,if,not,delete,the,contents,this,method,assumes,that,an,index,is,already,deleted,in,the,cluster,state,and,or,explicitly,through,index,tombstones,param,index,code,index,to,make,sure,its,deleted,from,disk,param,cluster,state,code,cluster,state,to,ensure,the,index,is,not,part,of,it,return,index,meta,data,for,the,index,loaded,from,disk;index,meta,data,verify,index,is,deleted,index,index,cluster,state,cluster,state
IndicesClusterStateService -> AllocatedIndices -> IndexMetaData verifyIndexIsDeleted(Index index, ClusterState clusterState)_;1539723533;Verify that the contents on disk for the given index is deleted_ if not, delete the contents._This method assumes that an index is already deleted in the cluster state and/or explicitly_through index tombstones._@param index {@code Index} to make sure its deleted from disk_@param clusterState {@code ClusterState} to ensure the index is not part of it_@return IndexMetaData for the index loaded from disk;IndexMetaData verifyIndexIsDeleted(Index index, ClusterState clusterState)_;verify,that,the,contents,on,disk,for,the,given,index,is,deleted,if,not,delete,the,contents,this,method,assumes,that,an,index,is,already,deleted,in,the,cluster,state,and,or,explicitly,through,index,tombstones,param,index,code,index,to,make,sure,its,deleted,from,disk,param,cluster,state,code,cluster,state,to,ensure,the,index,is,not,part,of,it,return,index,meta,data,for,the,index,loaded,from,disk;index,meta,data,verify,index,is,deleted,index,index,cluster,state,cluster,state
IndicesClusterStateService -> AllocatedIndices -> IndexMetaData verifyIndexIsDeleted(Index index, ClusterState clusterState)_;1541008027;Verify that the contents on disk for the given index is deleted_ if not, delete the contents._This method assumes that an index is already deleted in the cluster state and/or explicitly_through index tombstones._@param index {@code Index} to make sure its deleted from disk_@param clusterState {@code ClusterState} to ensure the index is not part of it_@return IndexMetaData for the index loaded from disk;IndexMetaData verifyIndexIsDeleted(Index index, ClusterState clusterState)_;verify,that,the,contents,on,disk,for,the,given,index,is,deleted,if,not,delete,the,contents,this,method,assumes,that,an,index,is,already,deleted,in,the,cluster,state,and,or,explicitly,through,index,tombstones,param,index,code,index,to,make,sure,its,deleted,from,disk,param,cluster,state,code,cluster,state,to,ensure,the,index,is,not,part,of,it,return,index,meta,data,for,the,index,loaded,from,disk;index,meta,data,verify,index,is,deleted,index,index,cluster,state,cluster,state
IndicesClusterStateService -> AllocatedIndices -> IndexMetaData verifyIndexIsDeleted(Index index, ClusterState clusterState)_;1542646292;Verify that the contents on disk for the given index is deleted_ if not, delete the contents._This method assumes that an index is already deleted in the cluster state and/or explicitly_through index tombstones._@param index {@code Index} to make sure its deleted from disk_@param clusterState {@code ClusterState} to ensure the index is not part of it_@return IndexMetaData for the index loaded from disk;IndexMetaData verifyIndexIsDeleted(Index index, ClusterState clusterState)_;verify,that,the,contents,on,disk,for,the,given,index,is,deleted,if,not,delete,the,contents,this,method,assumes,that,an,index,is,already,deleted,in,the,cluster,state,and,or,explicitly,through,index,tombstones,param,index,code,index,to,make,sure,its,deleted,from,disk,param,cluster,state,code,cluster,state,to,ensure,the,index,is,not,part,of,it,return,index,meta,data,for,the,index,loaded,from,disk;index,meta,data,verify,index,is,deleted,index,index,cluster,state,cluster,state
IndicesClusterStateService -> AllocatedIndices -> IndexMetaData verifyIndexIsDeleted(Index index, ClusterState clusterState)_;1547520324;Verify that the contents on disk for the given index is deleted_ if not, delete the contents._This method assumes that an index is already deleted in the cluster state and/or explicitly_through index tombstones._@param index {@code Index} to make sure its deleted from disk_@param clusterState {@code ClusterState} to ensure the index is not part of it_@return IndexMetaData for the index loaded from disk;IndexMetaData verifyIndexIsDeleted(Index index, ClusterState clusterState)_;verify,that,the,contents,on,disk,for,the,given,index,is,deleted,if,not,delete,the,contents,this,method,assumes,that,an,index,is,already,deleted,in,the,cluster,state,and,or,explicitly,through,index,tombstones,param,index,code,index,to,make,sure,its,deleted,from,disk,param,cluster,state,code,cluster,state,to,ensure,the,index,is,not,part,of,it,return,index,meta,data,for,the,index,loaded,from,disk;index,meta,data,verify,index,is,deleted,index,index,cluster,state,cluster,state
IndicesClusterStateService -> AllocatedIndices -> IndexMetaData verifyIndexIsDeleted(Index index, ClusterState clusterState)_;1547536822;Verify that the contents on disk for the given index is deleted_ if not, delete the contents._This method assumes that an index is already deleted in the cluster state and/or explicitly_through index tombstones._@param index {@code Index} to make sure its deleted from disk_@param clusterState {@code ClusterState} to ensure the index is not part of it_@return IndexMetaData for the index loaded from disk;IndexMetaData verifyIndexIsDeleted(Index index, ClusterState clusterState)_;verify,that,the,contents,on,disk,for,the,given,index,is,deleted,if,not,delete,the,contents,this,method,assumes,that,an,index,is,already,deleted,in,the,cluster,state,and,or,explicitly,through,index,tombstones,param,index,code,index,to,make,sure,its,deleted,from,disk,param,cluster,state,code,cluster,state,to,ensure,the,index,is,not,part,of,it,return,index,meta,data,for,the,index,loaded,from,disk;index,meta,data,verify,index,is,deleted,index,index,cluster,state,cluster,state
IndicesClusterStateService -> AllocatedIndices -> IndexMetaData verifyIndexIsDeleted(Index index, ClusterState clusterState)_;1547625930;Verify that the contents on disk for the given index is deleted_ if not, delete the contents._This method assumes that an index is already deleted in the cluster state and/or explicitly_through index tombstones._@param index {@code Index} to make sure its deleted from disk_@param clusterState {@code ClusterState} to ensure the index is not part of it_@return IndexMetaData for the index loaded from disk;IndexMetaData verifyIndexIsDeleted(Index index, ClusterState clusterState)_;verify,that,the,contents,on,disk,for,the,given,index,is,deleted,if,not,delete,the,contents,this,method,assumes,that,an,index,is,already,deleted,in,the,cluster,state,and,or,explicitly,through,index,tombstones,param,index,code,index,to,make,sure,its,deleted,from,disk,param,cluster,state,code,cluster,state,to,ensure,the,index,is,not,part,of,it,return,index,meta,data,for,the,index,loaded,from,disk;index,meta,data,verify,index,is,deleted,index,index,cluster,state,cluster,state
IndicesClusterStateService -> AllocatedIndices -> IndexMetaData verifyIndexIsDeleted(Index index, ClusterState clusterState)_;1548593396;Verify that the contents on disk for the given index is deleted_ if not, delete the contents._This method assumes that an index is already deleted in the cluster state and/or explicitly_through index tombstones._@param index {@code Index} to make sure its deleted from disk_@param clusterState {@code ClusterState} to ensure the index is not part of it_@return IndexMetaData for the index loaded from disk;IndexMetaData verifyIndexIsDeleted(Index index, ClusterState clusterState)_;verify,that,the,contents,on,disk,for,the,given,index,is,deleted,if,not,delete,the,contents,this,method,assumes,that,an,index,is,already,deleted,in,the,cluster,state,and,or,explicitly,through,index,tombstones,param,index,code,index,to,make,sure,its,deleted,from,disk,param,cluster,state,code,cluster,state,to,ensure,the,index,is,not,part,of,it,return,index,meta,data,for,the,index,loaded,from,disk;index,meta,data,verify,index,is,deleted,index,index,cluster,state,cluster,state
IndicesClusterStateService -> AllocatedIndices -> IndexMetaData verifyIndexIsDeleted(Index index, ClusterState clusterState)_;1548770980;Verify that the contents on disk for the given index is deleted_ if not, delete the contents._This method assumes that an index is already deleted in the cluster state and/or explicitly_through index tombstones._@param index {@code Index} to make sure its deleted from disk_@param clusterState {@code ClusterState} to ensure the index is not part of it_@return IndexMetaData for the index loaded from disk;IndexMetaData verifyIndexIsDeleted(Index index, ClusterState clusterState)_;verify,that,the,contents,on,disk,for,the,given,index,is,deleted,if,not,delete,the,contents,this,method,assumes,that,an,index,is,already,deleted,in,the,cluster,state,and,or,explicitly,through,index,tombstones,param,index,code,index,to,make,sure,its,deleted,from,disk,param,cluster,state,code,cluster,state,to,ensure,the,index,is,not,part,of,it,return,index,meta,data,for,the,index,loaded,from,disk;index,meta,data,verify,index,is,deleted,index,index,cluster,state,cluster,state
IndicesClusterStateService -> AllocatedIndices -> IndexMetaData verifyIndexIsDeleted(Index index, ClusterState clusterState)_;1548872469;Verify that the contents on disk for the given index is deleted_ if not, delete the contents._This method assumes that an index is already deleted in the cluster state and/or explicitly_through index tombstones._@param index {@code Index} to make sure its deleted from disk_@param clusterState {@code ClusterState} to ensure the index is not part of it_@return IndexMetaData for the index loaded from disk;IndexMetaData verifyIndexIsDeleted(Index index, ClusterState clusterState)_;verify,that,the,contents,on,disk,for,the,given,index,is,deleted,if,not,delete,the,contents,this,method,assumes,that,an,index,is,already,deleted,in,the,cluster,state,and,or,explicitly,through,index,tombstones,param,index,code,index,to,make,sure,its,deleted,from,disk,param,cluster,state,code,cluster,state,to,ensure,the,index,is,not,part,of,it,return,index,meta,data,for,the,index,loaded,from,disk;index,meta,data,verify,index,is,deleted,index,index,cluster,state,cluster,state
IndicesClusterStateService -> AllocatedIndices -> IndexMetaData verifyIndexIsDeleted(Index index, ClusterState clusterState)_;1549294529;Verify that the contents on disk for the given index is deleted_ if not, delete the contents._This method assumes that an index is already deleted in the cluster state and/or explicitly_through index tombstones._@param index {@code Index} to make sure its deleted from disk_@param clusterState {@code ClusterState} to ensure the index is not part of it_@return IndexMetaData for the index loaded from disk;IndexMetaData verifyIndexIsDeleted(Index index, ClusterState clusterState)_;verify,that,the,contents,on,disk,for,the,given,index,is,deleted,if,not,delete,the,contents,this,method,assumes,that,an,index,is,already,deleted,in,the,cluster,state,and,or,explicitly,through,index,tombstones,param,index,code,index,to,make,sure,its,deleted,from,disk,param,cluster,state,code,cluster,state,to,ensure,the,index,is,not,part,of,it,return,index,meta,data,for,the,index,loaded,from,disk;index,meta,data,verify,index,is,deleted,index,index,cluster,state,cluster,state
IndicesClusterStateService -> AllocatedIndex -> void updateMetaData(IndexMetaData currentIndexMetaData, IndexMetaData newIndexMetaData)_;1539723533;Updates the metadata of this index. Changes become visible through {@link #getIndexSettings()}.__@param currentIndexMetaData the current index metadata_@param newIndexMetaData the new index metadata;void updateMetaData(IndexMetaData currentIndexMetaData, IndexMetaData newIndexMetaData)_;updates,the,metadata,of,this,index,changes,become,visible,through,link,get,index,settings,param,current,index,meta,data,the,current,index,metadata,param,new,index,meta,data,the,new,index,metadata;void,update,meta,data,index,meta,data,current,index,meta,data,index,meta,data,new,index,meta,data
IndicesClusterStateService -> AllocatedIndex -> void updateMetaData(IndexMetaData currentIndexMetaData, IndexMetaData newIndexMetaData)_;1541008027;Updates the metadata of this index. Changes become visible through {@link #getIndexSettings()}.__@param currentIndexMetaData the current index metadata_@param newIndexMetaData the new index metadata;void updateMetaData(IndexMetaData currentIndexMetaData, IndexMetaData newIndexMetaData)_;updates,the,metadata,of,this,index,changes,become,visible,through,link,get,index,settings,param,current,index,meta,data,the,current,index,metadata,param,new,index,meta,data,the,new,index,metadata;void,update,meta,data,index,meta,data,current,index,meta,data,index,meta,data,new,index,meta,data
IndicesClusterStateService -> AllocatedIndex -> void updateMetaData(IndexMetaData currentIndexMetaData, IndexMetaData newIndexMetaData)_;1542646292;Updates the metadata of this index. Changes become visible through {@link #getIndexSettings()}.__@param currentIndexMetaData the current index metadata_@param newIndexMetaData the new index metadata;void updateMetaData(IndexMetaData currentIndexMetaData, IndexMetaData newIndexMetaData)_;updates,the,metadata,of,this,index,changes,become,visible,through,link,get,index,settings,param,current,index,meta,data,the,current,index,metadata,param,new,index,meta,data,the,new,index,metadata;void,update,meta,data,index,meta,data,current,index,meta,data,index,meta,data,new,index,meta,data
IndicesClusterStateService -> AllocatedIndex -> void updateMetaData(IndexMetaData currentIndexMetaData, IndexMetaData newIndexMetaData)_;1547520324;Updates the metadata of this index. Changes become visible through {@link #getIndexSettings()}.__@param currentIndexMetaData the current index metadata_@param newIndexMetaData the new index metadata;void updateMetaData(IndexMetaData currentIndexMetaData, IndexMetaData newIndexMetaData)_;updates,the,metadata,of,this,index,changes,become,visible,through,link,get,index,settings,param,current,index,meta,data,the,current,index,metadata,param,new,index,meta,data,the,new,index,metadata;void,update,meta,data,index,meta,data,current,index,meta,data,index,meta,data,new,index,meta,data
IndicesClusterStateService -> AllocatedIndex -> void updateMetaData(IndexMetaData currentIndexMetaData, IndexMetaData newIndexMetaData)_;1547536822;Updates the metadata of this index. Changes become visible through {@link #getIndexSettings()}.__@param currentIndexMetaData the current index metadata_@param newIndexMetaData the new index metadata;void updateMetaData(IndexMetaData currentIndexMetaData, IndexMetaData newIndexMetaData)_;updates,the,metadata,of,this,index,changes,become,visible,through,link,get,index,settings,param,current,index,meta,data,the,current,index,metadata,param,new,index,meta,data,the,new,index,metadata;void,update,meta,data,index,meta,data,current,index,meta,data,index,meta,data,new,index,meta,data
IndicesClusterStateService -> AllocatedIndex -> void updateMetaData(IndexMetaData currentIndexMetaData, IndexMetaData newIndexMetaData)_;1547625930;Updates the metadata of this index. Changes become visible through {@link #getIndexSettings()}.__@param currentIndexMetaData the current index metadata_@param newIndexMetaData the new index metadata;void updateMetaData(IndexMetaData currentIndexMetaData, IndexMetaData newIndexMetaData)_;updates,the,metadata,of,this,index,changes,become,visible,through,link,get,index,settings,param,current,index,meta,data,the,current,index,metadata,param,new,index,meta,data,the,new,index,metadata;void,update,meta,data,index,meta,data,current,index,meta,data,index,meta,data,new,index,meta,data
IndicesClusterStateService -> AllocatedIndex -> void updateMetaData(IndexMetaData currentIndexMetaData, IndexMetaData newIndexMetaData)_;1548593396;Updates the metadata of this index. Changes become visible through {@link #getIndexSettings()}.__@param currentIndexMetaData the current index metadata_@param newIndexMetaData the new index metadata;void updateMetaData(IndexMetaData currentIndexMetaData, IndexMetaData newIndexMetaData)_;updates,the,metadata,of,this,index,changes,become,visible,through,link,get,index,settings,param,current,index,meta,data,the,current,index,metadata,param,new,index,meta,data,the,new,index,metadata;void,update,meta,data,index,meta,data,current,index,meta,data,index,meta,data,new,index,meta,data
IndicesClusterStateService -> AllocatedIndex -> void updateMetaData(IndexMetaData currentIndexMetaData, IndexMetaData newIndexMetaData)_;1548770980;Updates the metadata of this index. Changes become visible through {@link #getIndexSettings()}.__@param currentIndexMetaData the current index metadata_@param newIndexMetaData the new index metadata;void updateMetaData(IndexMetaData currentIndexMetaData, IndexMetaData newIndexMetaData)_;updates,the,metadata,of,this,index,changes,become,visible,through,link,get,index,settings,param,current,index,meta,data,the,current,index,metadata,param,new,index,meta,data,the,new,index,metadata;void,update,meta,data,index,meta,data,current,index,meta,data,index,meta,data,new,index,meta,data
IndicesClusterStateService -> AllocatedIndex -> void updateMetaData(IndexMetaData currentIndexMetaData, IndexMetaData newIndexMetaData)_;1548872469;Updates the metadata of this index. Changes become visible through {@link #getIndexSettings()}.__@param currentIndexMetaData the current index metadata_@param newIndexMetaData the new index metadata;void updateMetaData(IndexMetaData currentIndexMetaData, IndexMetaData newIndexMetaData)_;updates,the,metadata,of,this,index,changes,become,visible,through,link,get,index,settings,param,current,index,meta,data,the,current,index,metadata,param,new,index,meta,data,the,new,index,metadata;void,update,meta,data,index,meta,data,current,index,meta,data,index,meta,data,new,index,meta,data
IndicesClusterStateService -> AllocatedIndex -> void updateMetaData(IndexMetaData currentIndexMetaData, IndexMetaData newIndexMetaData)_;1549294529;Updates the metadata of this index. Changes become visible through {@link #getIndexSettings()}.__@param currentIndexMetaData the current index metadata_@param newIndexMetaData the new index metadata;void updateMetaData(IndexMetaData currentIndexMetaData, IndexMetaData newIndexMetaData)_;updates,the,metadata,of,this,index,changes,become,visible,through,link,get,index,settings,param,current,index,meta,data,the,current,index,metadata,param,new,index,meta,data,the,new,index,metadata;void,update,meta,data,index,meta,data,current,index,meta,data,index,meta,data,new,index,meta,data
IndicesClusterStateService -> AllocatedIndex -> boolean updateMapping(IndexMetaData indexMetaData) throws IOException_;1524684173;Checks if index requires refresh from master.;boolean updateMapping(IndexMetaData indexMetaData) throws IOException_;checks,if,index,requires,refresh,from,master;boolean,update,mapping,index,meta,data,index,meta,data,throws,ioexception
IndicesClusterStateService -> AllocatedIndex -> boolean updateMapping(IndexMetaData indexMetaData) throws IOException_;1533063033;Checks if index requires refresh from master.;boolean updateMapping(IndexMetaData indexMetaData) throws IOException_;checks,if,index,requires,refresh,from,master;boolean,update,mapping,index,meta,data,index,meta,data,throws,ioexception
IndicesClusterStateService -> AllocatedIndices -> T createShard(ShardRouting shardRouting, RecoveryState recoveryState, PeerRecoveryTargetService recoveryTargetService,                       PeerRecoveryTargetService.RecoveryListener recoveryListener, RepositoriesService repositoriesService,                       Consumer<IndexShard.ShardFailure> onShardFailure,                       Consumer<ShardId> globalCheckpointSyncer) throws IOException_;1524684173;Creates shard for the specified shard routing and starts recovery,;T createShard(ShardRouting shardRouting, RecoveryState recoveryState, PeerRecoveryTargetService recoveryTargetService,_                      PeerRecoveryTargetService.RecoveryListener recoveryListener, RepositoriesService repositoriesService,_                      Consumer<IndexShard.ShardFailure> onShardFailure,_                      Consumer<ShardId> globalCheckpointSyncer) throws IOException_;creates,shard,for,the,specified,shard,routing,and,starts,recovery;t,create,shard,shard,routing,shard,routing,recovery,state,recovery,state,peer,recovery,target,service,recovery,target,service,peer,recovery,target,service,recovery,listener,recovery,listener,repositories,service,repositories,service,consumer,index,shard,shard,failure,on,shard,failure,consumer,shard,id,global,checkpoint,syncer,throws,ioexception
IndicesClusterStateService -> AllocatedIndices -> T createShard(ShardRouting shardRouting, RecoveryState recoveryState, PeerRecoveryTargetService recoveryTargetService,                       PeerRecoveryTargetService.RecoveryListener recoveryListener, RepositoriesService repositoriesService,                       Consumer<IndexShard.ShardFailure> onShardFailure,                       Consumer<ShardId> globalCheckpointSyncer) throws IOException_;1533063033;Creates shard for the specified shard routing and starts recovery,;T createShard(ShardRouting shardRouting, RecoveryState recoveryState, PeerRecoveryTargetService recoveryTargetService,_                      PeerRecoveryTargetService.RecoveryListener recoveryListener, RepositoriesService repositoriesService,_                      Consumer<IndexShard.ShardFailure> onShardFailure,_                      Consumer<ShardId> globalCheckpointSyncer) throws IOException_;creates,shard,for,the,specified,shard,routing,and,starts,recovery;t,create,shard,shard,routing,shard,routing,recovery,state,recovery,state,peer,recovery,target,service,recovery,target,service,peer,recovery,target,service,recovery,listener,recovery,listener,repositories,service,repositories,service,consumer,index,shard,shard,failure,on,shard,failure,consumer,shard,id,global,checkpoint,syncer,throws,ioexception
IndicesClusterStateService -> AllocatedIndices -> T createShard(ShardRouting shardRouting, RecoveryState recoveryState, PeerRecoveryTargetService recoveryTargetService,                       PeerRecoveryTargetService.RecoveryListener recoveryListener, RepositoriesService repositoriesService,                       Consumer<IndexShard.ShardFailure> onShardFailure,                       Consumer<ShardId> globalCheckpointSyncer) throws IOException_;1535405719;Creates shard for the specified shard routing and starts recovery,;T createShard(ShardRouting shardRouting, RecoveryState recoveryState, PeerRecoveryTargetService recoveryTargetService,_                      PeerRecoveryTargetService.RecoveryListener recoveryListener, RepositoriesService repositoriesService,_                      Consumer<IndexShard.ShardFailure> onShardFailure,_                      Consumer<ShardId> globalCheckpointSyncer) throws IOException_;creates,shard,for,the,specified,shard,routing,and,starts,recovery;t,create,shard,shard,routing,shard,routing,recovery,state,recovery,state,peer,recovery,target,service,recovery,target,service,peer,recovery,target,service,recovery,listener,recovery,listener,repositories,service,repositories,service,consumer,index,shard,shard,failure,on,shard,failure,consumer,shard,id,global,checkpoint,syncer,throws,ioexception
IndicesClusterStateService -> AllocatedIndices -> T createShard(ShardRouting shardRouting, RecoveryState recoveryState, PeerRecoveryTargetService recoveryTargetService,                       PeerRecoveryTargetService.RecoveryListener recoveryListener, RepositoriesService repositoriesService,                       Consumer<IndexShard.ShardFailure> onShardFailure,                       Consumer<ShardId> globalCheckpointSyncer) throws IOException_;1539723533;Creates shard for the specified shard routing and starts recovery,;T createShard(ShardRouting shardRouting, RecoveryState recoveryState, PeerRecoveryTargetService recoveryTargetService,_                      PeerRecoveryTargetService.RecoveryListener recoveryListener, RepositoriesService repositoriesService,_                      Consumer<IndexShard.ShardFailure> onShardFailure,_                      Consumer<ShardId> globalCheckpointSyncer) throws IOException_;creates,shard,for,the,specified,shard,routing,and,starts,recovery;t,create,shard,shard,routing,shard,routing,recovery,state,recovery,state,peer,recovery,target,service,recovery,target,service,peer,recovery,target,service,recovery,listener,recovery,listener,repositories,service,repositories,service,consumer,index,shard,shard,failure,on,shard,failure,consumer,shard,id,global,checkpoint,syncer,throws,ioexception
IndicesClusterStateService -> AllocatedIndices -> T createShard(ShardRouting shardRouting, RecoveryState recoveryState, PeerRecoveryTargetService recoveryTargetService,                       PeerRecoveryTargetService.RecoveryListener recoveryListener, RepositoriesService repositoriesService,                       Consumer<IndexShard.ShardFailure> onShardFailure,                       Consumer<ShardId> globalCheckpointSyncer) throws IOException_;1541008027;Creates shard for the specified shard routing and starts recovery,;T createShard(ShardRouting shardRouting, RecoveryState recoveryState, PeerRecoveryTargetService recoveryTargetService,_                      PeerRecoveryTargetService.RecoveryListener recoveryListener, RepositoriesService repositoriesService,_                      Consumer<IndexShard.ShardFailure> onShardFailure,_                      Consumer<ShardId> globalCheckpointSyncer) throws IOException_;creates,shard,for,the,specified,shard,routing,and,starts,recovery;t,create,shard,shard,routing,shard,routing,recovery,state,recovery,state,peer,recovery,target,service,recovery,target,service,peer,recovery,target,service,recovery,listener,recovery,listener,repositories,service,repositories,service,consumer,index,shard,shard,failure,on,shard,failure,consumer,shard,id,global,checkpoint,syncer,throws,ioexception
IndicesClusterStateService -> AllocatedIndices -> T createShard(ShardRouting shardRouting, RecoveryState recoveryState, PeerRecoveryTargetService recoveryTargetService,                       PeerRecoveryTargetService.RecoveryListener recoveryListener, RepositoriesService repositoriesService,                       Consumer<IndexShard.ShardFailure> onShardFailure,                       Consumer<ShardId> globalCheckpointSyncer) throws IOException_;1542646292;Creates shard for the specified shard routing and starts recovery,;T createShard(ShardRouting shardRouting, RecoveryState recoveryState, PeerRecoveryTargetService recoveryTargetService,_                      PeerRecoveryTargetService.RecoveryListener recoveryListener, RepositoriesService repositoriesService,_                      Consumer<IndexShard.ShardFailure> onShardFailure,_                      Consumer<ShardId> globalCheckpointSyncer) throws IOException_;creates,shard,for,the,specified,shard,routing,and,starts,recovery;t,create,shard,shard,routing,shard,routing,recovery,state,recovery,state,peer,recovery,target,service,recovery,target,service,peer,recovery,target,service,recovery,listener,recovery,listener,repositories,service,repositories,service,consumer,index,shard,shard,failure,on,shard,failure,consumer,shard,id,global,checkpoint,syncer,throws,ioexception
IndicesClusterStateService -> private void removeUnallocatedIndices(final ClusterChangedEvent event);1524684173;Removes indices that have no shards allocated to this node. This does not delete the shard data as we wait for enough_shard copies to exist in the cluster before deleting shard data (triggered by {@link org.elasticsearch.indices.store.IndicesStore}).__@param event the cluster changed event;private void removeUnallocatedIndices(final ClusterChangedEvent event) {_        final ClusterState state = event.state()__        final String localNodeId = state.nodes().getLocalNodeId()__        assert localNodeId != null___        Set<Index> indicesWithShards = new HashSet<>()__        RoutingNode localRoutingNode = state.getRoutingNodes().node(localNodeId)__        if (localRoutingNode != null) { _            for (ShardRouting shardRouting : localRoutingNode) {_                indicesWithShards.add(shardRouting.index())__            }_        }__        for (AllocatedIndex<? extends Shard> indexService : indicesService) {_            Index index = indexService.index()__            if (indicesWithShards.contains(index) == false) {_                _                _                _                _                final IndexMetaData indexMetaData = state.metaData().index(index)__                assert indexMetaData != null || event.isNewCluster() :_                    "index " + index + " does not exist in the cluster state, it should either " +_                        "have been deleted or the cluster must be new"__                final AllocatedIndices.IndexRemovalReason reason =_                    indexMetaData != null && indexMetaData.getState() == IndexMetaData.State.CLOSE ? CLOSED : NO_LONGER_ASSIGNED__                logger.debug("{} removing index, [{}]", index, reason)__                indicesService.removeIndex(index, reason, "removing index (no shards allocated)")__            }_        }_    };removes,indices,that,have,no,shards,allocated,to,this,node,this,does,not,delete,the,shard,data,as,we,wait,for,enough,shard,copies,to,exist,in,the,cluster,before,deleting,shard,data,triggered,by,link,org,elasticsearch,indices,store,indices,store,param,event,the,cluster,changed,event;private,void,remove,unallocated,indices,final,cluster,changed,event,event,final,cluster,state,state,event,state,final,string,local,node,id,state,nodes,get,local,node,id,assert,local,node,id,null,set,index,indices,with,shards,new,hash,set,routing,node,local,routing,node,state,get,routing,nodes,node,local,node,id,if,local,routing,node,null,for,shard,routing,shard,routing,local,routing,node,indices,with,shards,add,shard,routing,index,for,allocated,index,extends,shard,index,service,indices,service,index,index,index,service,index,if,indices,with,shards,contains,index,false,final,index,meta,data,index,meta,data,state,meta,data,index,index,assert,index,meta,data,null,event,is,new,cluster,index,index,does,not,exist,in,the,cluster,state,it,should,either,have,been,deleted,or,the,cluster,must,be,new,final,allocated,indices,index,removal,reason,reason,index,meta,data,null,index,meta,data,get,state,index,meta,data,state,close,closed,logger,debug,removing,index,index,reason,indices,service,remove,index,index,reason,removing,index,no,shards,allocated
IndicesClusterStateService -> private void removeUnallocatedIndices(final ClusterChangedEvent event);1533063033;Removes indices that have no shards allocated to this node. This does not delete the shard data as we wait for enough_shard copies to exist in the cluster before deleting shard data (triggered by {@link org.elasticsearch.indices.store.IndicesStore}).__@param event the cluster changed event;private void removeUnallocatedIndices(final ClusterChangedEvent event) {_        final ClusterState state = event.state()__        final String localNodeId = state.nodes().getLocalNodeId()__        assert localNodeId != null___        Set<Index> indicesWithShards = new HashSet<>()__        RoutingNode localRoutingNode = state.getRoutingNodes().node(localNodeId)__        if (localRoutingNode != null) { _            for (ShardRouting shardRouting : localRoutingNode) {_                indicesWithShards.add(shardRouting.index())__            }_        }__        for (AllocatedIndex<? extends Shard> indexService : indicesService) {_            Index index = indexService.index()__            if (indicesWithShards.contains(index) == false) {_                _                _                _                _                final IndexMetaData indexMetaData = state.metaData().index(index)__                assert indexMetaData != null || event.isNewCluster() :_                    "index " + index + " does not exist in the cluster state, it should either " +_                        "have been deleted or the cluster must be new"__                final AllocatedIndices.IndexRemovalReason reason =_                    indexMetaData != null && indexMetaData.getState() == IndexMetaData.State.CLOSE ? CLOSED : NO_LONGER_ASSIGNED__                logger.debug("{} removing index, [{}]", index, reason)__                indicesService.removeIndex(index, reason, "removing index (no shards allocated)")__            }_        }_    };removes,indices,that,have,no,shards,allocated,to,this,node,this,does,not,delete,the,shard,data,as,we,wait,for,enough,shard,copies,to,exist,in,the,cluster,before,deleting,shard,data,triggered,by,link,org,elasticsearch,indices,store,indices,store,param,event,the,cluster,changed,event;private,void,remove,unallocated,indices,final,cluster,changed,event,event,final,cluster,state,state,event,state,final,string,local,node,id,state,nodes,get,local,node,id,assert,local,node,id,null,set,index,indices,with,shards,new,hash,set,routing,node,local,routing,node,state,get,routing,nodes,node,local,node,id,if,local,routing,node,null,for,shard,routing,shard,routing,local,routing,node,indices,with,shards,add,shard,routing,index,for,allocated,index,extends,shard,index,service,indices,service,index,index,index,service,index,if,indices,with,shards,contains,index,false,final,index,meta,data,index,meta,data,state,meta,data,index,index,assert,index,meta,data,null,event,is,new,cluster,index,index,does,not,exist,in,the,cluster,state,it,should,either,have,been,deleted,or,the,cluster,must,be,new,final,allocated,indices,index,removal,reason,reason,index,meta,data,null,index,meta,data,get,state,index,meta,data,state,close,closed,logger,debug,removing,index,index,reason,indices,service,remove,index,index,reason,removing,index,no,shards,allocated
IndicesClusterStateService -> private void removeUnallocatedIndices(final ClusterChangedEvent event);1535405719;Removes indices that have no shards allocated to this node. This does not delete the shard data as we wait for enough_shard copies to exist in the cluster before deleting shard data (triggered by {@link org.elasticsearch.indices.store.IndicesStore}).__@param event the cluster changed event;private void removeUnallocatedIndices(final ClusterChangedEvent event) {_        final ClusterState state = event.state()__        final String localNodeId = state.nodes().getLocalNodeId()__        assert localNodeId != null___        Set<Index> indicesWithShards = new HashSet<>()__        RoutingNode localRoutingNode = state.getRoutingNodes().node(localNodeId)__        if (localRoutingNode != null) { _            for (ShardRouting shardRouting : localRoutingNode) {_                indicesWithShards.add(shardRouting.index())__            }_        }__        for (AllocatedIndex<? extends Shard> indexService : indicesService) {_            Index index = indexService.index()__            if (indicesWithShards.contains(index) == false) {_                _                _                _                _                final IndexMetaData indexMetaData = state.metaData().index(index)__                assert indexMetaData != null || event.isNewCluster() :_                    "index " + index + " does not exist in the cluster state, it should either " +_                        "have been deleted or the cluster must be new"__                final AllocatedIndices.IndexRemovalReason reason =_                    indexMetaData != null && indexMetaData.getState() == IndexMetaData.State.CLOSE ? CLOSED : NO_LONGER_ASSIGNED__                logger.debug("{} removing index, [{}]", index, reason)__                indicesService.removeIndex(index, reason, "removing index (no shards allocated)")__            }_        }_    };removes,indices,that,have,no,shards,allocated,to,this,node,this,does,not,delete,the,shard,data,as,we,wait,for,enough,shard,copies,to,exist,in,the,cluster,before,deleting,shard,data,triggered,by,link,org,elasticsearch,indices,store,indices,store,param,event,the,cluster,changed,event;private,void,remove,unallocated,indices,final,cluster,changed,event,event,final,cluster,state,state,event,state,final,string,local,node,id,state,nodes,get,local,node,id,assert,local,node,id,null,set,index,indices,with,shards,new,hash,set,routing,node,local,routing,node,state,get,routing,nodes,node,local,node,id,if,local,routing,node,null,for,shard,routing,shard,routing,local,routing,node,indices,with,shards,add,shard,routing,index,for,allocated,index,extends,shard,index,service,indices,service,index,index,index,service,index,if,indices,with,shards,contains,index,false,final,index,meta,data,index,meta,data,state,meta,data,index,index,assert,index,meta,data,null,event,is,new,cluster,index,index,does,not,exist,in,the,cluster,state,it,should,either,have,been,deleted,or,the,cluster,must,be,new,final,allocated,indices,index,removal,reason,reason,index,meta,data,null,index,meta,data,get,state,index,meta,data,state,close,closed,logger,debug,removing,index,index,reason,indices,service,remove,index,index,reason,removing,index,no,shards,allocated
IndicesClusterStateService -> private void removeUnallocatedIndices(final ClusterChangedEvent event);1539723533;Removes indices that have no shards allocated to this node. This does not delete the shard data as we wait for enough_shard copies to exist in the cluster before deleting shard data (triggered by {@link org.elasticsearch.indices.store.IndicesStore}).__@param event the cluster changed event;private void removeUnallocatedIndices(final ClusterChangedEvent event) {_        final ClusterState state = event.state()__        final String localNodeId = state.nodes().getLocalNodeId()__        assert localNodeId != null___        Set<Index> indicesWithShards = new HashSet<>()__        RoutingNode localRoutingNode = state.getRoutingNodes().node(localNodeId)__        if (localRoutingNode != null) { _            for (ShardRouting shardRouting : localRoutingNode) {_                indicesWithShards.add(shardRouting.index())__            }_        }__        for (AllocatedIndex<? extends Shard> indexService : indicesService) {_            Index index = indexService.index()__            if (indicesWithShards.contains(index) == false) {_                _                _                _                _                final IndexMetaData indexMetaData = state.metaData().index(index)__                assert indexMetaData != null || event.isNewCluster() :_                    "index " + index + " does not exist in the cluster state, it should either " +_                        "have been deleted or the cluster must be new"__                final AllocatedIndices.IndexRemovalReason reason =_                    indexMetaData != null && indexMetaData.getState() == IndexMetaData.State.CLOSE ? CLOSED : NO_LONGER_ASSIGNED__                logger.debug("{} removing index, [{}]", index, reason)__                indicesService.removeIndex(index, reason, "removing index (no shards allocated)")__            }_        }_    };removes,indices,that,have,no,shards,allocated,to,this,node,this,does,not,delete,the,shard,data,as,we,wait,for,enough,shard,copies,to,exist,in,the,cluster,before,deleting,shard,data,triggered,by,link,org,elasticsearch,indices,store,indices,store,param,event,the,cluster,changed,event;private,void,remove,unallocated,indices,final,cluster,changed,event,event,final,cluster,state,state,event,state,final,string,local,node,id,state,nodes,get,local,node,id,assert,local,node,id,null,set,index,indices,with,shards,new,hash,set,routing,node,local,routing,node,state,get,routing,nodes,node,local,node,id,if,local,routing,node,null,for,shard,routing,shard,routing,local,routing,node,indices,with,shards,add,shard,routing,index,for,allocated,index,extends,shard,index,service,indices,service,index,index,index,service,index,if,indices,with,shards,contains,index,false,final,index,meta,data,index,meta,data,state,meta,data,index,index,assert,index,meta,data,null,event,is,new,cluster,index,index,does,not,exist,in,the,cluster,state,it,should,either,have,been,deleted,or,the,cluster,must,be,new,final,allocated,indices,index,removal,reason,reason,index,meta,data,null,index,meta,data,get,state,index,meta,data,state,close,closed,logger,debug,removing,index,index,reason,indices,service,remove,index,index,reason,removing,index,no,shards,allocated
IndicesClusterStateService -> private void removeUnallocatedIndices(final ClusterChangedEvent event);1541008027;Removes indices that have no shards allocated to this node. This does not delete the shard data as we wait for enough_shard copies to exist in the cluster before deleting shard data (triggered by {@link org.elasticsearch.indices.store.IndicesStore}).__@param event the cluster changed event;private void removeUnallocatedIndices(final ClusterChangedEvent event) {_        final ClusterState state = event.state()__        final String localNodeId = state.nodes().getLocalNodeId()__        assert localNodeId != null___        Set<Index> indicesWithShards = new HashSet<>()__        RoutingNode localRoutingNode = state.getRoutingNodes().node(localNodeId)__        if (localRoutingNode != null) { _            for (ShardRouting shardRouting : localRoutingNode) {_                indicesWithShards.add(shardRouting.index())__            }_        }__        for (AllocatedIndex<? extends Shard> indexService : indicesService) {_            Index index = indexService.index()__            if (indicesWithShards.contains(index) == false) {_                _                _                _                _                final IndexMetaData indexMetaData = state.metaData().index(index)__                assert indexMetaData != null || event.isNewCluster() :_                    "index " + index + " does not exist in the cluster state, it should either " +_                        "have been deleted or the cluster must be new"__                final AllocatedIndices.IndexRemovalReason reason =_                    indexMetaData != null && indexMetaData.getState() == IndexMetaData.State.CLOSE ? CLOSED : NO_LONGER_ASSIGNED__                logger.debug("{} removing index, [{}]", index, reason)__                indicesService.removeIndex(index, reason, "removing index (no shards allocated)")__            }_        }_    };removes,indices,that,have,no,shards,allocated,to,this,node,this,does,not,delete,the,shard,data,as,we,wait,for,enough,shard,copies,to,exist,in,the,cluster,before,deleting,shard,data,triggered,by,link,org,elasticsearch,indices,store,indices,store,param,event,the,cluster,changed,event;private,void,remove,unallocated,indices,final,cluster,changed,event,event,final,cluster,state,state,event,state,final,string,local,node,id,state,nodes,get,local,node,id,assert,local,node,id,null,set,index,indices,with,shards,new,hash,set,routing,node,local,routing,node,state,get,routing,nodes,node,local,node,id,if,local,routing,node,null,for,shard,routing,shard,routing,local,routing,node,indices,with,shards,add,shard,routing,index,for,allocated,index,extends,shard,index,service,indices,service,index,index,index,service,index,if,indices,with,shards,contains,index,false,final,index,meta,data,index,meta,data,state,meta,data,index,index,assert,index,meta,data,null,event,is,new,cluster,index,index,does,not,exist,in,the,cluster,state,it,should,either,have,been,deleted,or,the,cluster,must,be,new,final,allocated,indices,index,removal,reason,reason,index,meta,data,null,index,meta,data,get,state,index,meta,data,state,close,closed,logger,debug,removing,index,index,reason,indices,service,remove,index,index,reason,removing,index,no,shards,allocated
IndicesClusterStateService -> private void removeUnallocatedIndices(final ClusterChangedEvent event);1542646292;Removes indices that have no shards allocated to this node. This does not delete the shard data as we wait for enough_shard copies to exist in the cluster before deleting shard data (triggered by {@link org.elasticsearch.indices.store.IndicesStore}).__@param event the cluster changed event;private void removeUnallocatedIndices(final ClusterChangedEvent event) {_        final ClusterState state = event.state()__        final String localNodeId = state.nodes().getLocalNodeId()__        assert localNodeId != null___        Set<Index> indicesWithShards = new HashSet<>()__        RoutingNode localRoutingNode = state.getRoutingNodes().node(localNodeId)__        if (localRoutingNode != null) { _            for (ShardRouting shardRouting : localRoutingNode) {_                indicesWithShards.add(shardRouting.index())__            }_        }__        for (AllocatedIndex<? extends Shard> indexService : indicesService) {_            Index index = indexService.index()__            if (indicesWithShards.contains(index) == false) {_                _                _                _                _                final IndexMetaData indexMetaData = state.metaData().index(index)__                assert indexMetaData != null || event.isNewCluster() :_                    "index " + index + " does not exist in the cluster state, it should either " +_                        "have been deleted or the cluster must be new"__                final AllocatedIndices.IndexRemovalReason reason =_                    indexMetaData != null && indexMetaData.getState() == IndexMetaData.State.CLOSE ? CLOSED : NO_LONGER_ASSIGNED__                logger.debug("{} removing index, [{}]", index, reason)__                indicesService.removeIndex(index, reason, "removing index (no shards allocated)")__            }_        }_    };removes,indices,that,have,no,shards,allocated,to,this,node,this,does,not,delete,the,shard,data,as,we,wait,for,enough,shard,copies,to,exist,in,the,cluster,before,deleting,shard,data,triggered,by,link,org,elasticsearch,indices,store,indices,store,param,event,the,cluster,changed,event;private,void,remove,unallocated,indices,final,cluster,changed,event,event,final,cluster,state,state,event,state,final,string,local,node,id,state,nodes,get,local,node,id,assert,local,node,id,null,set,index,indices,with,shards,new,hash,set,routing,node,local,routing,node,state,get,routing,nodes,node,local,node,id,if,local,routing,node,null,for,shard,routing,shard,routing,local,routing,node,indices,with,shards,add,shard,routing,index,for,allocated,index,extends,shard,index,service,indices,service,index,index,index,service,index,if,indices,with,shards,contains,index,false,final,index,meta,data,index,meta,data,state,meta,data,index,index,assert,index,meta,data,null,event,is,new,cluster,index,index,does,not,exist,in,the,cluster,state,it,should,either,have,been,deleted,or,the,cluster,must,be,new,final,allocated,indices,index,removal,reason,reason,index,meta,data,null,index,meta,data,get,state,index,meta,data,state,close,closed,logger,debug,removing,index,index,reason,indices,service,remove,index,index,reason,removing,index,no,shards,allocated
IndicesClusterStateService -> private void removeUnallocatedIndices(final ClusterChangedEvent event);1547520324;Removes indices that have no shards allocated to this node. This does not delete the shard data as we wait for enough_shard copies to exist in the cluster before deleting shard data (triggered by {@link org.elasticsearch.indices.store.IndicesStore}).__@param event the cluster changed event;private void removeUnallocatedIndices(final ClusterChangedEvent event) {_        final ClusterState state = event.state()__        final String localNodeId = state.nodes().getLocalNodeId()__        assert localNodeId != null___        Set<Index> indicesWithShards = new HashSet<>()__        RoutingNode localRoutingNode = state.getRoutingNodes().node(localNodeId)__        if (localRoutingNode != null) { _            for (ShardRouting shardRouting : localRoutingNode) {_                indicesWithShards.add(shardRouting.index())__            }_        }__        for (AllocatedIndex<? extends Shard> indexService : indicesService) {_            Index index = indexService.index()__            if (indicesWithShards.contains(index) == false) {_                _                _                _                _                final IndexMetaData indexMetaData = state.metaData().index(index)__                assert indexMetaData != null || event.isNewCluster() :_                    "index " + index + " does not exist in the cluster state, it should either " +_                        "have been deleted or the cluster must be new"__                final AllocatedIndices.IndexRemovalReason reason =_                    indexMetaData != null && indexMetaData.getState() == IndexMetaData.State.CLOSE ? CLOSED : NO_LONGER_ASSIGNED__                logger.debug("{} removing index, [{}]", index, reason)__                indicesService.removeIndex(index, reason, "removing index (no shards allocated)")__            }_        }_    };removes,indices,that,have,no,shards,allocated,to,this,node,this,does,not,delete,the,shard,data,as,we,wait,for,enough,shard,copies,to,exist,in,the,cluster,before,deleting,shard,data,triggered,by,link,org,elasticsearch,indices,store,indices,store,param,event,the,cluster,changed,event;private,void,remove,unallocated,indices,final,cluster,changed,event,event,final,cluster,state,state,event,state,final,string,local,node,id,state,nodes,get,local,node,id,assert,local,node,id,null,set,index,indices,with,shards,new,hash,set,routing,node,local,routing,node,state,get,routing,nodes,node,local,node,id,if,local,routing,node,null,for,shard,routing,shard,routing,local,routing,node,indices,with,shards,add,shard,routing,index,for,allocated,index,extends,shard,index,service,indices,service,index,index,index,service,index,if,indices,with,shards,contains,index,false,final,index,meta,data,index,meta,data,state,meta,data,index,index,assert,index,meta,data,null,event,is,new,cluster,index,index,does,not,exist,in,the,cluster,state,it,should,either,have,been,deleted,or,the,cluster,must,be,new,final,allocated,indices,index,removal,reason,reason,index,meta,data,null,index,meta,data,get,state,index,meta,data,state,close,closed,logger,debug,removing,index,index,reason,indices,service,remove,index,index,reason,removing,index,no,shards,allocated
IndicesClusterStateService -> private void removeUnallocatedIndices(final ClusterChangedEvent event);1547536822;Removes indices that have no shards allocated to this node. This does not delete the shard data as we wait for enough_shard copies to exist in the cluster before deleting shard data (triggered by {@link org.elasticsearch.indices.store.IndicesStore}).__@param event the cluster changed event;private void removeUnallocatedIndices(final ClusterChangedEvent event) {_        final ClusterState state = event.state()__        final String localNodeId = state.nodes().getLocalNodeId()__        assert localNodeId != null___        Set<Index> indicesWithShards = new HashSet<>()__        RoutingNode localRoutingNode = state.getRoutingNodes().node(localNodeId)__        if (localRoutingNode != null) { _            for (ShardRouting shardRouting : localRoutingNode) {_                indicesWithShards.add(shardRouting.index())__            }_        }__        for (AllocatedIndex<? extends Shard> indexService : indicesService) {_            Index index = indexService.index()__            if (indicesWithShards.contains(index) == false) {_                _                _                _                _                final IndexMetaData indexMetaData = state.metaData().index(index)__                assert indexMetaData != null || event.isNewCluster() :_                    "index " + index + " does not exist in the cluster state, it should either " +_                        "have been deleted or the cluster must be new"__                final AllocatedIndices.IndexRemovalReason reason =_                    indexMetaData != null && indexMetaData.getState() == IndexMetaData.State.CLOSE ? CLOSED : NO_LONGER_ASSIGNED__                logger.debug("{} removing index, [{}]", index, reason)__                indicesService.removeIndex(index, reason, "removing index (no shards allocated)")__            }_        }_    };removes,indices,that,have,no,shards,allocated,to,this,node,this,does,not,delete,the,shard,data,as,we,wait,for,enough,shard,copies,to,exist,in,the,cluster,before,deleting,shard,data,triggered,by,link,org,elasticsearch,indices,store,indices,store,param,event,the,cluster,changed,event;private,void,remove,unallocated,indices,final,cluster,changed,event,event,final,cluster,state,state,event,state,final,string,local,node,id,state,nodes,get,local,node,id,assert,local,node,id,null,set,index,indices,with,shards,new,hash,set,routing,node,local,routing,node,state,get,routing,nodes,node,local,node,id,if,local,routing,node,null,for,shard,routing,shard,routing,local,routing,node,indices,with,shards,add,shard,routing,index,for,allocated,index,extends,shard,index,service,indices,service,index,index,index,service,index,if,indices,with,shards,contains,index,false,final,index,meta,data,index,meta,data,state,meta,data,index,index,assert,index,meta,data,null,event,is,new,cluster,index,index,does,not,exist,in,the,cluster,state,it,should,either,have,been,deleted,or,the,cluster,must,be,new,final,allocated,indices,index,removal,reason,reason,index,meta,data,null,index,meta,data,get,state,index,meta,data,state,close,closed,logger,debug,removing,index,index,reason,indices,service,remove,index,index,reason,removing,index,no,shards,allocated
IndicesClusterStateService -> private void removeUnallocatedIndices(final ClusterChangedEvent event);1547625930;Removes indices that have no shards allocated to this node. This does not delete the shard data as we wait for enough_shard copies to exist in the cluster before deleting shard data (triggered by {@link org.elasticsearch.indices.store.IndicesStore}).__@param event the cluster changed event;private void removeUnallocatedIndices(final ClusterChangedEvent event) {_        final ClusterState state = event.state()__        final String localNodeId = state.nodes().getLocalNodeId()__        assert localNodeId != null___        Set<Index> indicesWithShards = new HashSet<>()__        RoutingNode localRoutingNode = state.getRoutingNodes().node(localNodeId)__        if (localRoutingNode != null) { _            for (ShardRouting shardRouting : localRoutingNode) {_                indicesWithShards.add(shardRouting.index())__            }_        }__        for (AllocatedIndex<? extends Shard> indexService : indicesService) {_            Index index = indexService.index()__            if (indicesWithShards.contains(index) == false) {_                _                _                _                _                final IndexMetaData indexMetaData = state.metaData().index(index)__                assert indexMetaData != null || event.isNewCluster() :_                    "index " + index + " does not exist in the cluster state, it should either " +_                        "have been deleted or the cluster must be new"__                final AllocatedIndices.IndexRemovalReason reason =_                    indexMetaData != null && indexMetaData.getState() == IndexMetaData.State.CLOSE ? CLOSED : NO_LONGER_ASSIGNED__                logger.debug("{} removing index, [{}]", index, reason)__                indicesService.removeIndex(index, reason, "removing index (no shards allocated)")__            }_        }_    };removes,indices,that,have,no,shards,allocated,to,this,node,this,does,not,delete,the,shard,data,as,we,wait,for,enough,shard,copies,to,exist,in,the,cluster,before,deleting,shard,data,triggered,by,link,org,elasticsearch,indices,store,indices,store,param,event,the,cluster,changed,event;private,void,remove,unallocated,indices,final,cluster,changed,event,event,final,cluster,state,state,event,state,final,string,local,node,id,state,nodes,get,local,node,id,assert,local,node,id,null,set,index,indices,with,shards,new,hash,set,routing,node,local,routing,node,state,get,routing,nodes,node,local,node,id,if,local,routing,node,null,for,shard,routing,shard,routing,local,routing,node,indices,with,shards,add,shard,routing,index,for,allocated,index,extends,shard,index,service,indices,service,index,index,index,service,index,if,indices,with,shards,contains,index,false,final,index,meta,data,index,meta,data,state,meta,data,index,index,assert,index,meta,data,null,event,is,new,cluster,index,index,does,not,exist,in,the,cluster,state,it,should,either,have,been,deleted,or,the,cluster,must,be,new,final,allocated,indices,index,removal,reason,reason,index,meta,data,null,index,meta,data,get,state,index,meta,data,state,close,closed,logger,debug,removing,index,index,reason,indices,service,remove,index,index,reason,removing,index,no,shards,allocated
IndicesClusterStateService -> private void removeUnallocatedIndices(final ClusterChangedEvent event);1548593396;Removes indices that have no shards allocated to this node. This does not delete the shard data as we wait for enough_shard copies to exist in the cluster before deleting shard data (triggered by {@link org.elasticsearch.indices.store.IndicesStore}).__@param event the cluster changed event;private void removeUnallocatedIndices(final ClusterChangedEvent event) {_        final ClusterState state = event.state()__        final String localNodeId = state.nodes().getLocalNodeId()__        assert localNodeId != null___        Set<Index> indicesWithShards = new HashSet<>()__        RoutingNode localRoutingNode = state.getRoutingNodes().node(localNodeId)__        if (localRoutingNode != null) { _            for (ShardRouting shardRouting : localRoutingNode) {_                indicesWithShards.add(shardRouting.index())__            }_        }__        for (AllocatedIndex<? extends Shard> indexService : indicesService) {_            Index index = indexService.index()__            if (indicesWithShards.contains(index) == false) {_                _                _                _                _                final IndexMetaData indexMetaData = state.metaData().index(index)__                assert indexMetaData != null || event.isNewCluster() :_                    "index " + index + " does not exist in the cluster state, it should either " +_                        "have been deleted or the cluster must be new"__                final AllocatedIndices.IndexRemovalReason reason =_                    indexMetaData != null && indexMetaData.getState() == IndexMetaData.State.CLOSE ? CLOSED : NO_LONGER_ASSIGNED__                logger.debug("{} removing index, [{}]", index, reason)__                indicesService.removeIndex(index, reason, "removing index (no shards allocated)")__            }_        }_    };removes,indices,that,have,no,shards,allocated,to,this,node,this,does,not,delete,the,shard,data,as,we,wait,for,enough,shard,copies,to,exist,in,the,cluster,before,deleting,shard,data,triggered,by,link,org,elasticsearch,indices,store,indices,store,param,event,the,cluster,changed,event;private,void,remove,unallocated,indices,final,cluster,changed,event,event,final,cluster,state,state,event,state,final,string,local,node,id,state,nodes,get,local,node,id,assert,local,node,id,null,set,index,indices,with,shards,new,hash,set,routing,node,local,routing,node,state,get,routing,nodes,node,local,node,id,if,local,routing,node,null,for,shard,routing,shard,routing,local,routing,node,indices,with,shards,add,shard,routing,index,for,allocated,index,extends,shard,index,service,indices,service,index,index,index,service,index,if,indices,with,shards,contains,index,false,final,index,meta,data,index,meta,data,state,meta,data,index,index,assert,index,meta,data,null,event,is,new,cluster,index,index,does,not,exist,in,the,cluster,state,it,should,either,have,been,deleted,or,the,cluster,must,be,new,final,allocated,indices,index,removal,reason,reason,index,meta,data,null,index,meta,data,get,state,index,meta,data,state,close,closed,logger,debug,removing,index,index,reason,indices,service,remove,index,index,reason,removing,index,no,shards,allocated
IndicesClusterStateService -> private void removeUnallocatedIndices(final ClusterChangedEvent event);1548770980;Removes indices that have no shards allocated to this node. This does not delete the shard data as we wait for enough_shard copies to exist in the cluster before deleting shard data (triggered by {@link org.elasticsearch.indices.store.IndicesStore}).__@param event the cluster changed event;private void removeUnallocatedIndices(final ClusterChangedEvent event) {_        final ClusterState state = event.state()__        final String localNodeId = state.nodes().getLocalNodeId()__        assert localNodeId != null___        Set<Index> indicesWithShards = new HashSet<>()__        RoutingNode localRoutingNode = state.getRoutingNodes().node(localNodeId)__        if (localRoutingNode != null) { _            for (ShardRouting shardRouting : localRoutingNode) {_                indicesWithShards.add(shardRouting.index())__            }_        }__        for (AllocatedIndex<? extends Shard> indexService : indicesService) {_            Index index = indexService.index()__            if (indicesWithShards.contains(index) == false) {_                _                _                _                _                final IndexMetaData indexMetaData = state.metaData().index(index)__                assert indexMetaData != null || event.isNewCluster() :_                    "index " + index + " does not exist in the cluster state, it should either " +_                        "have been deleted or the cluster must be new"__                final AllocatedIndices.IndexRemovalReason reason =_                    indexMetaData != null && indexMetaData.getState() == IndexMetaData.State.CLOSE ? CLOSED : NO_LONGER_ASSIGNED__                logger.debug("{} removing index, [{}]", index, reason)__                indicesService.removeIndex(index, reason, "removing index (no shards allocated)")__            }_        }_    };removes,indices,that,have,no,shards,allocated,to,this,node,this,does,not,delete,the,shard,data,as,we,wait,for,enough,shard,copies,to,exist,in,the,cluster,before,deleting,shard,data,triggered,by,link,org,elasticsearch,indices,store,indices,store,param,event,the,cluster,changed,event;private,void,remove,unallocated,indices,final,cluster,changed,event,event,final,cluster,state,state,event,state,final,string,local,node,id,state,nodes,get,local,node,id,assert,local,node,id,null,set,index,indices,with,shards,new,hash,set,routing,node,local,routing,node,state,get,routing,nodes,node,local,node,id,if,local,routing,node,null,for,shard,routing,shard,routing,local,routing,node,indices,with,shards,add,shard,routing,index,for,allocated,index,extends,shard,index,service,indices,service,index,index,index,service,index,if,indices,with,shards,contains,index,false,final,index,meta,data,index,meta,data,state,meta,data,index,index,assert,index,meta,data,null,event,is,new,cluster,index,index,does,not,exist,in,the,cluster,state,it,should,either,have,been,deleted,or,the,cluster,must,be,new,final,allocated,indices,index,removal,reason,reason,index,meta,data,null,index,meta,data,get,state,index,meta,data,state,close,closed,logger,debug,removing,index,index,reason,indices,service,remove,index,index,reason,removing,index,no,shards,allocated
IndicesClusterStateService -> private void removeUnallocatedIndices(final ClusterChangedEvent event);1548872469;Removes indices that have no shards allocated to this node. This does not delete the shard data as we wait for enough_shard copies to exist in the cluster before deleting shard data (triggered by {@link org.elasticsearch.indices.store.IndicesStore}).__@param event the cluster changed event;private void removeUnallocatedIndices(final ClusterChangedEvent event) {_        final ClusterState state = event.state()__        final String localNodeId = state.nodes().getLocalNodeId()__        assert localNodeId != null___        Set<Index> indicesWithShards = new HashSet<>()__        RoutingNode localRoutingNode = state.getRoutingNodes().node(localNodeId)__        if (localRoutingNode != null) { _            for (ShardRouting shardRouting : localRoutingNode) {_                indicesWithShards.add(shardRouting.index())__            }_        }__        for (AllocatedIndex<? extends Shard> indexService : indicesService) {_            Index index = indexService.index()__            if (indicesWithShards.contains(index) == false) {_                _                _                _                _                final IndexMetaData indexMetaData = state.metaData().index(index)__                assert indexMetaData != null || event.isNewCluster() :_                    "index " + index + " does not exist in the cluster state, it should either " +_                        "have been deleted or the cluster must be new"__                final AllocatedIndices.IndexRemovalReason reason =_                    indexMetaData != null && indexMetaData.getState() == IndexMetaData.State.CLOSE ? CLOSED : NO_LONGER_ASSIGNED__                logger.debug("{} removing index, [{}]", index, reason)__                indicesService.removeIndex(index, reason, "removing index (no shards allocated)")__            }_        }_    };removes,indices,that,have,no,shards,allocated,to,this,node,this,does,not,delete,the,shard,data,as,we,wait,for,enough,shard,copies,to,exist,in,the,cluster,before,deleting,shard,data,triggered,by,link,org,elasticsearch,indices,store,indices,store,param,event,the,cluster,changed,event;private,void,remove,unallocated,indices,final,cluster,changed,event,event,final,cluster,state,state,event,state,final,string,local,node,id,state,nodes,get,local,node,id,assert,local,node,id,null,set,index,indices,with,shards,new,hash,set,routing,node,local,routing,node,state,get,routing,nodes,node,local,node,id,if,local,routing,node,null,for,shard,routing,shard,routing,local,routing,node,indices,with,shards,add,shard,routing,index,for,allocated,index,extends,shard,index,service,indices,service,index,index,index,service,index,if,indices,with,shards,contains,index,false,final,index,meta,data,index,meta,data,state,meta,data,index,index,assert,index,meta,data,null,event,is,new,cluster,index,index,does,not,exist,in,the,cluster,state,it,should,either,have,been,deleted,or,the,cluster,must,be,new,final,allocated,indices,index,removal,reason,reason,index,meta,data,null,index,meta,data,get,state,index,meta,data,state,close,closed,logger,debug,removing,index,index,reason,indices,service,remove,index,index,reason,removing,index,no,shards,allocated
IndicesClusterStateService -> private void removeUnallocatedIndices(final ClusterChangedEvent event);1549294529;Removes indices that have no shards allocated to this node. This does not delete the shard data as we wait for enough_shard copies to exist in the cluster before deleting shard data (triggered by {@link org.elasticsearch.indices.store.IndicesStore}).__@param event the cluster changed event;private void removeUnallocatedIndices(final ClusterChangedEvent event) {_        final ClusterState state = event.state()__        final String localNodeId = state.nodes().getLocalNodeId()__        assert localNodeId != null___        Set<Index> indicesWithShards = new HashSet<>()__        RoutingNode localRoutingNode = state.getRoutingNodes().node(localNodeId)__        if (localRoutingNode != null) { _            for (ShardRouting shardRouting : localRoutingNode) {_                indicesWithShards.add(shardRouting.index())__            }_        }__        for (AllocatedIndex<? extends Shard> indexService : indicesService) {_            Index index = indexService.index()__            if (indicesWithShards.contains(index) == false) {_                _                _                _                _                final IndexMetaData indexMetaData = state.metaData().index(index)__                assert indexMetaData != null || event.isNewCluster() :_                    "index " + index + " does not exist in the cluster state, it should either " +_                        "have been deleted or the cluster must be new"__                final AllocatedIndices.IndexRemovalReason reason =_                    indexMetaData != null && indexMetaData.getState() == IndexMetaData.State.CLOSE ? CLOSED : NO_LONGER_ASSIGNED__                logger.debug("{} removing index, [{}]", index, reason)__                indicesService.removeIndex(index, reason, "removing index (no shards allocated)")__            }_        }_    };removes,indices,that,have,no,shards,allocated,to,this,node,this,does,not,delete,the,shard,data,as,we,wait,for,enough,shard,copies,to,exist,in,the,cluster,before,deleting,shard,data,triggered,by,link,org,elasticsearch,indices,store,indices,store,param,event,the,cluster,changed,event;private,void,remove,unallocated,indices,final,cluster,changed,event,event,final,cluster,state,state,event,state,final,string,local,node,id,state,nodes,get,local,node,id,assert,local,node,id,null,set,index,indices,with,shards,new,hash,set,routing,node,local,routing,node,state,get,routing,nodes,node,local,node,id,if,local,routing,node,null,for,shard,routing,shard,routing,local,routing,node,indices,with,shards,add,shard,routing,index,for,allocated,index,extends,shard,index,service,indices,service,index,index,index,service,index,if,indices,with,shards,contains,index,false,final,index,meta,data,index,meta,data,state,meta,data,index,index,assert,index,meta,data,null,event,is,new,cluster,index,index,does,not,exist,in,the,cluster,state,it,should,either,have,been,deleted,or,the,cluster,must,be,new,final,allocated,indices,index,removal,reason,reason,index,meta,data,null,index,meta,data,get,state,index,meta,data,state,close,closed,logger,debug,removing,index,index,reason,indices,service,remove,index,index,reason,removing,index,no,shards,allocated
IndicesClusterStateService -> Shard -> ShardId shardId()_;1524684173;Returns the shard id of this shard.;ShardId shardId()_;returns,the,shard,id,of,this,shard;shard,id,shard,id
IndicesClusterStateService -> Shard -> ShardId shardId()_;1533063033;Returns the shard id of this shard.;ShardId shardId()_;returns,the,shard,id,of,this,shard;shard,id,shard,id
IndicesClusterStateService -> Shard -> ShardId shardId()_;1535405719;Returns the shard id of this shard.;ShardId shardId()_;returns,the,shard,id,of,this,shard;shard,id,shard,id
IndicesClusterStateService -> Shard -> ShardId shardId()_;1539723533;Returns the shard id of this shard.;ShardId shardId()_;returns,the,shard,id,of,this,shard;shard,id,shard,id
IndicesClusterStateService -> Shard -> ShardId shardId()_;1541008027;Returns the shard id of this shard.;ShardId shardId()_;returns,the,shard,id,of,this,shard;shard,id,shard,id
IndicesClusterStateService -> Shard -> ShardId shardId()_;1542646292;Returns the shard id of this shard.;ShardId shardId()_;returns,the,shard,id,of,this,shard;shard,id,shard,id
IndicesClusterStateService -> Shard -> ShardId shardId()_;1547520324;Returns the shard id of this shard.;ShardId shardId()_;returns,the,shard,id,of,this,shard;shard,id,shard,id
IndicesClusterStateService -> Shard -> ShardId shardId()_;1547536822;Returns the shard id of this shard.;ShardId shardId()_;returns,the,shard,id,of,this,shard;shard,id,shard,id
IndicesClusterStateService -> Shard -> ShardId shardId()_;1547625930;Returns the shard id of this shard.;ShardId shardId()_;returns,the,shard,id,of,this,shard;shard,id,shard,id
IndicesClusterStateService -> Shard -> ShardId shardId()_;1548593396;Returns the shard id of this shard.;ShardId shardId()_;returns,the,shard,id,of,this,shard;shard,id,shard,id
IndicesClusterStateService -> Shard -> ShardId shardId()_;1548770980;Returns the shard id of this shard.;ShardId shardId()_;returns,the,shard,id,of,this,shard;shard,id,shard,id
IndicesClusterStateService -> Shard -> ShardId shardId()_;1548872469;Returns the shard id of this shard.;ShardId shardId()_;returns,the,shard,id,of,this,shard;shard,id,shard,id
IndicesClusterStateService -> Shard -> ShardId shardId()_;1549294529;Returns the shard id of this shard.;ShardId shardId()_;returns,the,shard,id,of,this,shard;shard,id,shard,id
IndicesClusterStateService -> Shard -> IndexShardState state()_;1524684173;Returns the latest internal shard state.;IndexShardState state()_;returns,the,latest,internal,shard,state;index,shard,state,state
IndicesClusterStateService -> Shard -> IndexShardState state()_;1533063033;Returns the latest internal shard state.;IndexShardState state()_;returns,the,latest,internal,shard,state;index,shard,state,state
IndicesClusterStateService -> Shard -> IndexShardState state()_;1535405719;Returns the latest internal shard state.;IndexShardState state()_;returns,the,latest,internal,shard,state;index,shard,state,state
IndicesClusterStateService -> Shard -> IndexShardState state()_;1539723533;Returns the latest internal shard state.;IndexShardState state()_;returns,the,latest,internal,shard,state;index,shard,state,state
IndicesClusterStateService -> Shard -> IndexShardState state()_;1541008027;Returns the latest internal shard state.;IndexShardState state()_;returns,the,latest,internal,shard,state;index,shard,state,state
IndicesClusterStateService -> Shard -> IndexShardState state()_;1542646292;Returns the latest internal shard state.;IndexShardState state()_;returns,the,latest,internal,shard,state;index,shard,state,state
IndicesClusterStateService -> Shard -> IndexShardState state()_;1547520324;Returns the latest internal shard state.;IndexShardState state()_;returns,the,latest,internal,shard,state;index,shard,state,state
IndicesClusterStateService -> Shard -> IndexShardState state()_;1547536822;Returns the latest internal shard state.;IndexShardState state()_;returns,the,latest,internal,shard,state;index,shard,state,state
IndicesClusterStateService -> Shard -> IndexShardState state()_;1547625930;Returns the latest internal shard state.;IndexShardState state()_;returns,the,latest,internal,shard,state;index,shard,state,state
IndicesClusterStateService -> Shard -> IndexShardState state()_;1548593396;Returns the latest internal shard state.;IndexShardState state()_;returns,the,latest,internal,shard,state;index,shard,state,state
IndicesClusterStateService -> Shard -> IndexShardState state()_;1548770980;Returns the latest internal shard state.;IndexShardState state()_;returns,the,latest,internal,shard,state;index,shard,state,state
IndicesClusterStateService -> Shard -> IndexShardState state()_;1548872469;Returns the latest internal shard state.;IndexShardState state()_;returns,the,latest,internal,shard,state;index,shard,state,state
IndicesClusterStateService -> Shard -> IndexShardState state()_;1549294529;Returns the latest internal shard state.;IndexShardState state()_;returns,the,latest,internal,shard,state;index,shard,state,state
IndicesClusterStateService -> private void removeShards(final ClusterState state);1524684173;Removes shards that are currently loaded by indicesService but have disappeared from the routing table of the current node._This method does not delete the shard data.__@param state new cluster state;private void removeShards(final ClusterState state) {_        final String localNodeId = state.nodes().getLocalNodeId()__        assert localNodeId != null___        _        RoutingNode localRoutingNode = state.getRoutingNodes().node(localNodeId)__        for (AllocatedIndex<? extends Shard> indexService : indicesService) {_            for (Shard shard : indexService) {_                ShardRouting currentRoutingEntry = shard.routingEntry()__                ShardId shardId = currentRoutingEntry.shardId()__                ShardRouting newShardRouting = localRoutingNode == null ? null : localRoutingNode.getByShardId(shardId)__                if (newShardRouting == null) {_                    _                    _                    logger.debug("{} removing shard (not allocated)", shardId)__                    indexService.removeShard(shardId.id(), "removing shard (not allocated)")__                } else if (newShardRouting.isSameAllocation(currentRoutingEntry) == false) {_                    logger.debug("{} removing shard (stale allocation id, stale {}, new {})", shardId,_                        currentRoutingEntry, newShardRouting)__                    indexService.removeShard(shardId.id(), "removing shard (stale copy)")__                } else if (newShardRouting.initializing() && currentRoutingEntry.active()) {_                    _                    _                    _                    logger.debug("{} removing shard (not active, current {}, new {})", shardId, currentRoutingEntry, newShardRouting)__                    indexService.removeShard(shardId.id(), "removing shard (stale copy)")__                }_            }_        }_    };removes,shards,that,are,currently,loaded,by,indices,service,but,have,disappeared,from,the,routing,table,of,the,current,node,this,method,does,not,delete,the,shard,data,param,state,new,cluster,state;private,void,remove,shards,final,cluster,state,state,final,string,local,node,id,state,nodes,get,local,node,id,assert,local,node,id,null,routing,node,local,routing,node,state,get,routing,nodes,node,local,node,id,for,allocated,index,extends,shard,index,service,indices,service,for,shard,shard,index,service,shard,routing,current,routing,entry,shard,routing,entry,shard,id,shard,id,current,routing,entry,shard,id,shard,routing,new,shard,routing,local,routing,node,null,null,local,routing,node,get,by,shard,id,shard,id,if,new,shard,routing,null,logger,debug,removing,shard,not,allocated,shard,id,index,service,remove,shard,shard,id,id,removing,shard,not,allocated,else,if,new,shard,routing,is,same,allocation,current,routing,entry,false,logger,debug,removing,shard,stale,allocation,id,stale,new,shard,id,current,routing,entry,new,shard,routing,index,service,remove,shard,shard,id,id,removing,shard,stale,copy,else,if,new,shard,routing,initializing,current,routing,entry,active,logger,debug,removing,shard,not,active,current,new,shard,id,current,routing,entry,new,shard,routing,index,service,remove,shard,shard,id,id,removing,shard,stale,copy
IndicesClusterStateService -> private void removeShards(final ClusterState state);1533063033;Removes shards that are currently loaded by indicesService but have disappeared from the routing table of the current node._This method does not delete the shard data.__@param state new cluster state;private void removeShards(final ClusterState state) {_        final String localNodeId = state.nodes().getLocalNodeId()__        assert localNodeId != null___        _        RoutingNode localRoutingNode = state.getRoutingNodes().node(localNodeId)__        for (AllocatedIndex<? extends Shard> indexService : indicesService) {_            for (Shard shard : indexService) {_                ShardRouting currentRoutingEntry = shard.routingEntry()__                ShardId shardId = currentRoutingEntry.shardId()__                ShardRouting newShardRouting = localRoutingNode == null ? null : localRoutingNode.getByShardId(shardId)__                if (newShardRouting == null) {_                    _                    _                    logger.debug("{} removing shard (not allocated)", shardId)__                    indexService.removeShard(shardId.id(), "removing shard (not allocated)")__                } else if (newShardRouting.isSameAllocation(currentRoutingEntry) == false) {_                    logger.debug("{} removing shard (stale allocation id, stale {}, new {})", shardId,_                        currentRoutingEntry, newShardRouting)__                    indexService.removeShard(shardId.id(), "removing shard (stale copy)")__                } else if (newShardRouting.initializing() && currentRoutingEntry.active()) {_                    _                    _                    _                    logger.debug("{} removing shard (not active, current {}, new {})", shardId, currentRoutingEntry, newShardRouting)__                    indexService.removeShard(shardId.id(), "removing shard (stale copy)")__                } else if (newShardRouting.primary() && currentRoutingEntry.primary() == false && newShardRouting.initializing()) {_                    assert currentRoutingEntry.initializing() : currentRoutingEntry_ _                    _                    _                    logger.debug("{} removing shard (not active, current {}, new {})", shardId, currentRoutingEntry, newShardRouting)__                    indexService.removeShard(shardId.id(), "removing shard (stale copy)")__                }_            }_        }_    };removes,shards,that,are,currently,loaded,by,indices,service,but,have,disappeared,from,the,routing,table,of,the,current,node,this,method,does,not,delete,the,shard,data,param,state,new,cluster,state;private,void,remove,shards,final,cluster,state,state,final,string,local,node,id,state,nodes,get,local,node,id,assert,local,node,id,null,routing,node,local,routing,node,state,get,routing,nodes,node,local,node,id,for,allocated,index,extends,shard,index,service,indices,service,for,shard,shard,index,service,shard,routing,current,routing,entry,shard,routing,entry,shard,id,shard,id,current,routing,entry,shard,id,shard,routing,new,shard,routing,local,routing,node,null,null,local,routing,node,get,by,shard,id,shard,id,if,new,shard,routing,null,logger,debug,removing,shard,not,allocated,shard,id,index,service,remove,shard,shard,id,id,removing,shard,not,allocated,else,if,new,shard,routing,is,same,allocation,current,routing,entry,false,logger,debug,removing,shard,stale,allocation,id,stale,new,shard,id,current,routing,entry,new,shard,routing,index,service,remove,shard,shard,id,id,removing,shard,stale,copy,else,if,new,shard,routing,initializing,current,routing,entry,active,logger,debug,removing,shard,not,active,current,new,shard,id,current,routing,entry,new,shard,routing,index,service,remove,shard,shard,id,id,removing,shard,stale,copy,else,if,new,shard,routing,primary,current,routing,entry,primary,false,new,shard,routing,initializing,assert,current,routing,entry,initializing,current,routing,entry,logger,debug,removing,shard,not,active,current,new,shard,id,current,routing,entry,new,shard,routing,index,service,remove,shard,shard,id,id,removing,shard,stale,copy
IndicesClusterStateService -> private void removeShards(final ClusterState state);1535405719;Removes shards that are currently loaded by indicesService but have disappeared from the routing table of the current node._This method does not delete the shard data.__@param state new cluster state;private void removeShards(final ClusterState state) {_        final String localNodeId = state.nodes().getLocalNodeId()__        assert localNodeId != null___        _        RoutingNode localRoutingNode = state.getRoutingNodes().node(localNodeId)__        for (AllocatedIndex<? extends Shard> indexService : indicesService) {_            for (Shard shard : indexService) {_                ShardRouting currentRoutingEntry = shard.routingEntry()__                ShardId shardId = currentRoutingEntry.shardId()__                ShardRouting newShardRouting = localRoutingNode == null ? null : localRoutingNode.getByShardId(shardId)__                if (newShardRouting == null) {_                    _                    _                    logger.debug("{} removing shard (not allocated)", shardId)__                    indexService.removeShard(shardId.id(), "removing shard (not allocated)")__                } else if (newShardRouting.isSameAllocation(currentRoutingEntry) == false) {_                    logger.debug("{} removing shard (stale allocation id, stale {}, new {})", shardId,_                        currentRoutingEntry, newShardRouting)__                    indexService.removeShard(shardId.id(), "removing shard (stale copy)")__                } else if (newShardRouting.initializing() && currentRoutingEntry.active()) {_                    _                    _                    _                    logger.debug("{} removing shard (not active, current {}, new {})", shardId, currentRoutingEntry, newShardRouting)__                    indexService.removeShard(shardId.id(), "removing shard (stale copy)")__                } else if (newShardRouting.primary() && currentRoutingEntry.primary() == false && newShardRouting.initializing()) {_                    assert currentRoutingEntry.initializing() : currentRoutingEntry_ _                    _                    _                    logger.debug("{} removing shard (not active, current {}, new {})", shardId, currentRoutingEntry, newShardRouting)__                    indexService.removeShard(shardId.id(), "removing shard (stale copy)")__                }_            }_        }_    };removes,shards,that,are,currently,loaded,by,indices,service,but,have,disappeared,from,the,routing,table,of,the,current,node,this,method,does,not,delete,the,shard,data,param,state,new,cluster,state;private,void,remove,shards,final,cluster,state,state,final,string,local,node,id,state,nodes,get,local,node,id,assert,local,node,id,null,routing,node,local,routing,node,state,get,routing,nodes,node,local,node,id,for,allocated,index,extends,shard,index,service,indices,service,for,shard,shard,index,service,shard,routing,current,routing,entry,shard,routing,entry,shard,id,shard,id,current,routing,entry,shard,id,shard,routing,new,shard,routing,local,routing,node,null,null,local,routing,node,get,by,shard,id,shard,id,if,new,shard,routing,null,logger,debug,removing,shard,not,allocated,shard,id,index,service,remove,shard,shard,id,id,removing,shard,not,allocated,else,if,new,shard,routing,is,same,allocation,current,routing,entry,false,logger,debug,removing,shard,stale,allocation,id,stale,new,shard,id,current,routing,entry,new,shard,routing,index,service,remove,shard,shard,id,id,removing,shard,stale,copy,else,if,new,shard,routing,initializing,current,routing,entry,active,logger,debug,removing,shard,not,active,current,new,shard,id,current,routing,entry,new,shard,routing,index,service,remove,shard,shard,id,id,removing,shard,stale,copy,else,if,new,shard,routing,primary,current,routing,entry,primary,false,new,shard,routing,initializing,assert,current,routing,entry,initializing,current,routing,entry,logger,debug,removing,shard,not,active,current,new,shard,id,current,routing,entry,new,shard,routing,index,service,remove,shard,shard,id,id,removing,shard,stale,copy
IndicesClusterStateService -> private void removeShards(final ClusterState state);1539723533;Removes shards that are currently loaded by indicesService but have disappeared from the routing table of the current node._This method does not delete the shard data.__@param state new cluster state;private void removeShards(final ClusterState state) {_        final String localNodeId = state.nodes().getLocalNodeId()__        assert localNodeId != null___        _        RoutingNode localRoutingNode = state.getRoutingNodes().node(localNodeId)__        for (AllocatedIndex<? extends Shard> indexService : indicesService) {_            for (Shard shard : indexService) {_                ShardRouting currentRoutingEntry = shard.routingEntry()__                ShardId shardId = currentRoutingEntry.shardId()__                ShardRouting newShardRouting = localRoutingNode == null ? null : localRoutingNode.getByShardId(shardId)__                if (newShardRouting == null) {_                    _                    _                    logger.debug("{} removing shard (not allocated)", shardId)__                    indexService.removeShard(shardId.id(), "removing shard (not allocated)")__                } else if (newShardRouting.isSameAllocation(currentRoutingEntry) == false) {_                    logger.debug("{} removing shard (stale allocation id, stale {}, new {})", shardId,_                        currentRoutingEntry, newShardRouting)__                    indexService.removeShard(shardId.id(), "removing shard (stale copy)")__                } else if (newShardRouting.initializing() && currentRoutingEntry.active()) {_                    _                    _                    _                    logger.debug("{} removing shard (not active, current {}, new {})", shardId, currentRoutingEntry, newShardRouting)__                    indexService.removeShard(shardId.id(), "removing shard (stale copy)")__                } else if (newShardRouting.primary() && currentRoutingEntry.primary() == false && newShardRouting.initializing()) {_                    assert currentRoutingEntry.initializing() : currentRoutingEntry_ _                    _                    _                    logger.debug("{} removing shard (not active, current {}, new {})", shardId, currentRoutingEntry, newShardRouting)__                    indexService.removeShard(shardId.id(), "removing shard (stale copy)")__                }_            }_        }_    };removes,shards,that,are,currently,loaded,by,indices,service,but,have,disappeared,from,the,routing,table,of,the,current,node,this,method,does,not,delete,the,shard,data,param,state,new,cluster,state;private,void,remove,shards,final,cluster,state,state,final,string,local,node,id,state,nodes,get,local,node,id,assert,local,node,id,null,routing,node,local,routing,node,state,get,routing,nodes,node,local,node,id,for,allocated,index,extends,shard,index,service,indices,service,for,shard,shard,index,service,shard,routing,current,routing,entry,shard,routing,entry,shard,id,shard,id,current,routing,entry,shard,id,shard,routing,new,shard,routing,local,routing,node,null,null,local,routing,node,get,by,shard,id,shard,id,if,new,shard,routing,null,logger,debug,removing,shard,not,allocated,shard,id,index,service,remove,shard,shard,id,id,removing,shard,not,allocated,else,if,new,shard,routing,is,same,allocation,current,routing,entry,false,logger,debug,removing,shard,stale,allocation,id,stale,new,shard,id,current,routing,entry,new,shard,routing,index,service,remove,shard,shard,id,id,removing,shard,stale,copy,else,if,new,shard,routing,initializing,current,routing,entry,active,logger,debug,removing,shard,not,active,current,new,shard,id,current,routing,entry,new,shard,routing,index,service,remove,shard,shard,id,id,removing,shard,stale,copy,else,if,new,shard,routing,primary,current,routing,entry,primary,false,new,shard,routing,initializing,assert,current,routing,entry,initializing,current,routing,entry,logger,debug,removing,shard,not,active,current,new,shard,id,current,routing,entry,new,shard,routing,index,service,remove,shard,shard,id,id,removing,shard,stale,copy
IndicesClusterStateService -> private void removeShards(final ClusterState state);1541008027;Removes shards that are currently loaded by indicesService but have disappeared from the routing table of the current node._This method does not delete the shard data.__@param state new cluster state;private void removeShards(final ClusterState state) {_        final String localNodeId = state.nodes().getLocalNodeId()__        assert localNodeId != null___        _        RoutingNode localRoutingNode = state.getRoutingNodes().node(localNodeId)__        for (AllocatedIndex<? extends Shard> indexService : indicesService) {_            for (Shard shard : indexService) {_                ShardRouting currentRoutingEntry = shard.routingEntry()__                ShardId shardId = currentRoutingEntry.shardId()__                ShardRouting newShardRouting = localRoutingNode == null ? null : localRoutingNode.getByShardId(shardId)__                if (newShardRouting == null) {_                    _                    _                    logger.debug("{} removing shard (not allocated)", shardId)__                    indexService.removeShard(shardId.id(), "removing shard (not allocated)")__                } else if (newShardRouting.isSameAllocation(currentRoutingEntry) == false) {_                    logger.debug("{} removing shard (stale allocation id, stale {}, new {})", shardId,_                        currentRoutingEntry, newShardRouting)__                    indexService.removeShard(shardId.id(), "removing shard (stale copy)")__                } else if (newShardRouting.initializing() && currentRoutingEntry.active()) {_                    _                    _                    _                    logger.debug("{} removing shard (not active, current {}, new {})", shardId, currentRoutingEntry, newShardRouting)__                    indexService.removeShard(shardId.id(), "removing shard (stale copy)")__                } else if (newShardRouting.primary() && currentRoutingEntry.primary() == false && newShardRouting.initializing()) {_                    assert currentRoutingEntry.initializing() : currentRoutingEntry_ _                    _                    _                    logger.debug("{} removing shard (not active, current {}, new {})", shardId, currentRoutingEntry, newShardRouting)__                    indexService.removeShard(shardId.id(), "removing shard (stale copy)")__                }_            }_        }_    };removes,shards,that,are,currently,loaded,by,indices,service,but,have,disappeared,from,the,routing,table,of,the,current,node,this,method,does,not,delete,the,shard,data,param,state,new,cluster,state;private,void,remove,shards,final,cluster,state,state,final,string,local,node,id,state,nodes,get,local,node,id,assert,local,node,id,null,routing,node,local,routing,node,state,get,routing,nodes,node,local,node,id,for,allocated,index,extends,shard,index,service,indices,service,for,shard,shard,index,service,shard,routing,current,routing,entry,shard,routing,entry,shard,id,shard,id,current,routing,entry,shard,id,shard,routing,new,shard,routing,local,routing,node,null,null,local,routing,node,get,by,shard,id,shard,id,if,new,shard,routing,null,logger,debug,removing,shard,not,allocated,shard,id,index,service,remove,shard,shard,id,id,removing,shard,not,allocated,else,if,new,shard,routing,is,same,allocation,current,routing,entry,false,logger,debug,removing,shard,stale,allocation,id,stale,new,shard,id,current,routing,entry,new,shard,routing,index,service,remove,shard,shard,id,id,removing,shard,stale,copy,else,if,new,shard,routing,initializing,current,routing,entry,active,logger,debug,removing,shard,not,active,current,new,shard,id,current,routing,entry,new,shard,routing,index,service,remove,shard,shard,id,id,removing,shard,stale,copy,else,if,new,shard,routing,primary,current,routing,entry,primary,false,new,shard,routing,initializing,assert,current,routing,entry,initializing,current,routing,entry,logger,debug,removing,shard,not,active,current,new,shard,id,current,routing,entry,new,shard,routing,index,service,remove,shard,shard,id,id,removing,shard,stale,copy
IndicesClusterStateService -> private void removeShards(final ClusterState state);1542646292;Removes shards that are currently loaded by indicesService but have disappeared from the routing table of the current node._This method does not delete the shard data.__@param state new cluster state;private void removeShards(final ClusterState state) {_        final String localNodeId = state.nodes().getLocalNodeId()__        assert localNodeId != null___        _        RoutingNode localRoutingNode = state.getRoutingNodes().node(localNodeId)__        for (AllocatedIndex<? extends Shard> indexService : indicesService) {_            for (Shard shard : indexService) {_                ShardRouting currentRoutingEntry = shard.routingEntry()__                ShardId shardId = currentRoutingEntry.shardId()__                ShardRouting newShardRouting = localRoutingNode == null ? null : localRoutingNode.getByShardId(shardId)__                if (newShardRouting == null) {_                    _                    _                    logger.debug("{} removing shard (not allocated)", shardId)__                    indexService.removeShard(shardId.id(), "removing shard (not allocated)")__                } else if (newShardRouting.isSameAllocation(currentRoutingEntry) == false) {_                    logger.debug("{} removing shard (stale allocation id, stale {}, new {})", shardId,_                        currentRoutingEntry, newShardRouting)__                    indexService.removeShard(shardId.id(), "removing shard (stale copy)")__                } else if (newShardRouting.initializing() && currentRoutingEntry.active()) {_                    _                    _                    _                    logger.debug("{} removing shard (not active, current {}, new {})", shardId, currentRoutingEntry, newShardRouting)__                    indexService.removeShard(shardId.id(), "removing shard (stale copy)")__                } else if (newShardRouting.primary() && currentRoutingEntry.primary() == false && newShardRouting.initializing()) {_                    assert currentRoutingEntry.initializing() : currentRoutingEntry_ _                    _                    _                    logger.debug("{} removing shard (not active, current {}, new {})", shardId, currentRoutingEntry, newShardRouting)__                    indexService.removeShard(shardId.id(), "removing shard (stale copy)")__                }_            }_        }_    };removes,shards,that,are,currently,loaded,by,indices,service,but,have,disappeared,from,the,routing,table,of,the,current,node,this,method,does,not,delete,the,shard,data,param,state,new,cluster,state;private,void,remove,shards,final,cluster,state,state,final,string,local,node,id,state,nodes,get,local,node,id,assert,local,node,id,null,routing,node,local,routing,node,state,get,routing,nodes,node,local,node,id,for,allocated,index,extends,shard,index,service,indices,service,for,shard,shard,index,service,shard,routing,current,routing,entry,shard,routing,entry,shard,id,shard,id,current,routing,entry,shard,id,shard,routing,new,shard,routing,local,routing,node,null,null,local,routing,node,get,by,shard,id,shard,id,if,new,shard,routing,null,logger,debug,removing,shard,not,allocated,shard,id,index,service,remove,shard,shard,id,id,removing,shard,not,allocated,else,if,new,shard,routing,is,same,allocation,current,routing,entry,false,logger,debug,removing,shard,stale,allocation,id,stale,new,shard,id,current,routing,entry,new,shard,routing,index,service,remove,shard,shard,id,id,removing,shard,stale,copy,else,if,new,shard,routing,initializing,current,routing,entry,active,logger,debug,removing,shard,not,active,current,new,shard,id,current,routing,entry,new,shard,routing,index,service,remove,shard,shard,id,id,removing,shard,stale,copy,else,if,new,shard,routing,primary,current,routing,entry,primary,false,new,shard,routing,initializing,assert,current,routing,entry,initializing,current,routing,entry,logger,debug,removing,shard,not,active,current,new,shard,id,current,routing,entry,new,shard,routing,index,service,remove,shard,shard,id,id,removing,shard,stale,copy
IndicesClusterStateService -> private void removeShards(final ClusterState state);1547520324;Removes shards that are currently loaded by indicesService but have disappeared from the routing table of the current node._This method does not delete the shard data.__@param state new cluster state;private void removeShards(final ClusterState state) {_        final String localNodeId = state.nodes().getLocalNodeId()__        assert localNodeId != null___        _        RoutingNode localRoutingNode = state.getRoutingNodes().node(localNodeId)__        for (AllocatedIndex<? extends Shard> indexService : indicesService) {_            for (Shard shard : indexService) {_                ShardRouting currentRoutingEntry = shard.routingEntry()__                ShardId shardId = currentRoutingEntry.shardId()__                ShardRouting newShardRouting = localRoutingNode == null ? null : localRoutingNode.getByShardId(shardId)__                if (newShardRouting == null) {_                    _                    _                    logger.debug("{} removing shard (not allocated)", shardId)__                    indexService.removeShard(shardId.id(), "removing shard (not allocated)")__                } else if (newShardRouting.isSameAllocation(currentRoutingEntry) == false) {_                    logger.debug("{} removing shard (stale allocation id, stale {}, new {})", shardId,_                        currentRoutingEntry, newShardRouting)__                    indexService.removeShard(shardId.id(), "removing shard (stale copy)")__                } else if (newShardRouting.initializing() && currentRoutingEntry.active()) {_                    _                    _                    _                    logger.debug("{} removing shard (not active, current {}, new {})", shardId, currentRoutingEntry, newShardRouting)__                    indexService.removeShard(shardId.id(), "removing shard (stale copy)")__                } else if (newShardRouting.primary() && currentRoutingEntry.primary() == false && newShardRouting.initializing()) {_                    assert currentRoutingEntry.initializing() : currentRoutingEntry_ _                    _                    _                    logger.debug("{} removing shard (not active, current {}, new {})", shardId, currentRoutingEntry, newShardRouting)__                    indexService.removeShard(shardId.id(), "removing shard (stale copy)")__                }_            }_        }_    };removes,shards,that,are,currently,loaded,by,indices,service,but,have,disappeared,from,the,routing,table,of,the,current,node,this,method,does,not,delete,the,shard,data,param,state,new,cluster,state;private,void,remove,shards,final,cluster,state,state,final,string,local,node,id,state,nodes,get,local,node,id,assert,local,node,id,null,routing,node,local,routing,node,state,get,routing,nodes,node,local,node,id,for,allocated,index,extends,shard,index,service,indices,service,for,shard,shard,index,service,shard,routing,current,routing,entry,shard,routing,entry,shard,id,shard,id,current,routing,entry,shard,id,shard,routing,new,shard,routing,local,routing,node,null,null,local,routing,node,get,by,shard,id,shard,id,if,new,shard,routing,null,logger,debug,removing,shard,not,allocated,shard,id,index,service,remove,shard,shard,id,id,removing,shard,not,allocated,else,if,new,shard,routing,is,same,allocation,current,routing,entry,false,logger,debug,removing,shard,stale,allocation,id,stale,new,shard,id,current,routing,entry,new,shard,routing,index,service,remove,shard,shard,id,id,removing,shard,stale,copy,else,if,new,shard,routing,initializing,current,routing,entry,active,logger,debug,removing,shard,not,active,current,new,shard,id,current,routing,entry,new,shard,routing,index,service,remove,shard,shard,id,id,removing,shard,stale,copy,else,if,new,shard,routing,primary,current,routing,entry,primary,false,new,shard,routing,initializing,assert,current,routing,entry,initializing,current,routing,entry,logger,debug,removing,shard,not,active,current,new,shard,id,current,routing,entry,new,shard,routing,index,service,remove,shard,shard,id,id,removing,shard,stale,copy
IndicesClusterStateService -> private void removeShards(final ClusterState state);1547536822;Removes shards that are currently loaded by indicesService but have disappeared from the routing table of the current node._This method does not delete the shard data.__@param state new cluster state;private void removeShards(final ClusterState state) {_        final String localNodeId = state.nodes().getLocalNodeId()__        assert localNodeId != null___        _        RoutingNode localRoutingNode = state.getRoutingNodes().node(localNodeId)__        for (AllocatedIndex<? extends Shard> indexService : indicesService) {_            for (Shard shard : indexService) {_                ShardRouting currentRoutingEntry = shard.routingEntry()__                ShardId shardId = currentRoutingEntry.shardId()__                ShardRouting newShardRouting = localRoutingNode == null ? null : localRoutingNode.getByShardId(shardId)__                if (newShardRouting == null) {_                    _                    _                    logger.debug("{} removing shard (not allocated)", shardId)__                    indexService.removeShard(shardId.id(), "removing shard (not allocated)")__                } else if (newShardRouting.isSameAllocation(currentRoutingEntry) == false) {_                    logger.debug("{} removing shard (stale allocation id, stale {}, new {})", shardId,_                        currentRoutingEntry, newShardRouting)__                    indexService.removeShard(shardId.id(), "removing shard (stale copy)")__                } else if (newShardRouting.initializing() && currentRoutingEntry.active()) {_                    _                    _                    _                    logger.debug("{} removing shard (not active, current {}, new {})", shardId, currentRoutingEntry, newShardRouting)__                    indexService.removeShard(shardId.id(), "removing shard (stale copy)")__                } else if (newShardRouting.primary() && currentRoutingEntry.primary() == false && newShardRouting.initializing()) {_                    assert currentRoutingEntry.initializing() : currentRoutingEntry_ _                    _                    _                    logger.debug("{} removing shard (not active, current {}, new {})", shardId, currentRoutingEntry, newShardRouting)__                    indexService.removeShard(shardId.id(), "removing shard (stale copy)")__                }_            }_        }_    };removes,shards,that,are,currently,loaded,by,indices,service,but,have,disappeared,from,the,routing,table,of,the,current,node,this,method,does,not,delete,the,shard,data,param,state,new,cluster,state;private,void,remove,shards,final,cluster,state,state,final,string,local,node,id,state,nodes,get,local,node,id,assert,local,node,id,null,routing,node,local,routing,node,state,get,routing,nodes,node,local,node,id,for,allocated,index,extends,shard,index,service,indices,service,for,shard,shard,index,service,shard,routing,current,routing,entry,shard,routing,entry,shard,id,shard,id,current,routing,entry,shard,id,shard,routing,new,shard,routing,local,routing,node,null,null,local,routing,node,get,by,shard,id,shard,id,if,new,shard,routing,null,logger,debug,removing,shard,not,allocated,shard,id,index,service,remove,shard,shard,id,id,removing,shard,not,allocated,else,if,new,shard,routing,is,same,allocation,current,routing,entry,false,logger,debug,removing,shard,stale,allocation,id,stale,new,shard,id,current,routing,entry,new,shard,routing,index,service,remove,shard,shard,id,id,removing,shard,stale,copy,else,if,new,shard,routing,initializing,current,routing,entry,active,logger,debug,removing,shard,not,active,current,new,shard,id,current,routing,entry,new,shard,routing,index,service,remove,shard,shard,id,id,removing,shard,stale,copy,else,if,new,shard,routing,primary,current,routing,entry,primary,false,new,shard,routing,initializing,assert,current,routing,entry,initializing,current,routing,entry,logger,debug,removing,shard,not,active,current,new,shard,id,current,routing,entry,new,shard,routing,index,service,remove,shard,shard,id,id,removing,shard,stale,copy
IndicesClusterStateService -> private void removeShards(final ClusterState state);1547625930;Removes shards that are currently loaded by indicesService but have disappeared from the routing table of the current node._This method does not delete the shard data.__@param state new cluster state;private void removeShards(final ClusterState state) {_        final String localNodeId = state.nodes().getLocalNodeId()__        assert localNodeId != null___        _        RoutingNode localRoutingNode = state.getRoutingNodes().node(localNodeId)__        for (AllocatedIndex<? extends Shard> indexService : indicesService) {_            for (Shard shard : indexService) {_                ShardRouting currentRoutingEntry = shard.routingEntry()__                ShardId shardId = currentRoutingEntry.shardId()__                ShardRouting newShardRouting = localRoutingNode == null ? null : localRoutingNode.getByShardId(shardId)__                if (newShardRouting == null) {_                    _                    _                    logger.debug("{} removing shard (not allocated)", shardId)__                    indexService.removeShard(shardId.id(), "removing shard (not allocated)")__                } else if (newShardRouting.isSameAllocation(currentRoutingEntry) == false) {_                    logger.debug("{} removing shard (stale allocation id, stale {}, new {})", shardId,_                        currentRoutingEntry, newShardRouting)__                    indexService.removeShard(shardId.id(), "removing shard (stale copy)")__                } else if (newShardRouting.initializing() && currentRoutingEntry.active()) {_                    _                    _                    _                    logger.debug("{} removing shard (not active, current {}, new {})", shardId, currentRoutingEntry, newShardRouting)__                    indexService.removeShard(shardId.id(), "removing shard (stale copy)")__                } else if (newShardRouting.primary() && currentRoutingEntry.primary() == false && newShardRouting.initializing()) {_                    assert currentRoutingEntry.initializing() : currentRoutingEntry_ _                    _                    _                    logger.debug("{} removing shard (not active, current {}, new {})", shardId, currentRoutingEntry, newShardRouting)__                    indexService.removeShard(shardId.id(), "removing shard (stale copy)")__                }_            }_        }_    };removes,shards,that,are,currently,loaded,by,indices,service,but,have,disappeared,from,the,routing,table,of,the,current,node,this,method,does,not,delete,the,shard,data,param,state,new,cluster,state;private,void,remove,shards,final,cluster,state,state,final,string,local,node,id,state,nodes,get,local,node,id,assert,local,node,id,null,routing,node,local,routing,node,state,get,routing,nodes,node,local,node,id,for,allocated,index,extends,shard,index,service,indices,service,for,shard,shard,index,service,shard,routing,current,routing,entry,shard,routing,entry,shard,id,shard,id,current,routing,entry,shard,id,shard,routing,new,shard,routing,local,routing,node,null,null,local,routing,node,get,by,shard,id,shard,id,if,new,shard,routing,null,logger,debug,removing,shard,not,allocated,shard,id,index,service,remove,shard,shard,id,id,removing,shard,not,allocated,else,if,new,shard,routing,is,same,allocation,current,routing,entry,false,logger,debug,removing,shard,stale,allocation,id,stale,new,shard,id,current,routing,entry,new,shard,routing,index,service,remove,shard,shard,id,id,removing,shard,stale,copy,else,if,new,shard,routing,initializing,current,routing,entry,active,logger,debug,removing,shard,not,active,current,new,shard,id,current,routing,entry,new,shard,routing,index,service,remove,shard,shard,id,id,removing,shard,stale,copy,else,if,new,shard,routing,primary,current,routing,entry,primary,false,new,shard,routing,initializing,assert,current,routing,entry,initializing,current,routing,entry,logger,debug,removing,shard,not,active,current,new,shard,id,current,routing,entry,new,shard,routing,index,service,remove,shard,shard,id,id,removing,shard,stale,copy
IndicesClusterStateService -> private void removeShards(final ClusterState state);1548593396;Removes shards that are currently loaded by indicesService but have disappeared from the routing table of the current node._This method does not delete the shard data.__@param state new cluster state;private void removeShards(final ClusterState state) {_        final String localNodeId = state.nodes().getLocalNodeId()__        assert localNodeId != null___        _        RoutingNode localRoutingNode = state.getRoutingNodes().node(localNodeId)__        for (AllocatedIndex<? extends Shard> indexService : indicesService) {_            for (Shard shard : indexService) {_                ShardRouting currentRoutingEntry = shard.routingEntry()__                ShardId shardId = currentRoutingEntry.shardId()__                ShardRouting newShardRouting = localRoutingNode == null ? null : localRoutingNode.getByShardId(shardId)__                if (newShardRouting == null) {_                    _                    _                    logger.debug("{} removing shard (not allocated)", shardId)__                    indexService.removeShard(shardId.id(), "removing shard (not allocated)")__                } else if (newShardRouting.isSameAllocation(currentRoutingEntry) == false) {_                    logger.debug("{} removing shard (stale allocation id, stale {}, new {})", shardId,_                        currentRoutingEntry, newShardRouting)__                    indexService.removeShard(shardId.id(), "removing shard (stale copy)")__                } else if (newShardRouting.initializing() && currentRoutingEntry.active()) {_                    _                    _                    _                    logger.debug("{} removing shard (not active, current {}, new {})", shardId, currentRoutingEntry, newShardRouting)__                    indexService.removeShard(shardId.id(), "removing shard (stale copy)")__                } else if (newShardRouting.primary() && currentRoutingEntry.primary() == false && newShardRouting.initializing()) {_                    assert currentRoutingEntry.initializing() : currentRoutingEntry_ _                    _                    _                    logger.debug("{} removing shard (not active, current {}, new {})", shardId, currentRoutingEntry, newShardRouting)__                    indexService.removeShard(shardId.id(), "removing shard (stale copy)")__                }_            }_        }_    };removes,shards,that,are,currently,loaded,by,indices,service,but,have,disappeared,from,the,routing,table,of,the,current,node,this,method,does,not,delete,the,shard,data,param,state,new,cluster,state;private,void,remove,shards,final,cluster,state,state,final,string,local,node,id,state,nodes,get,local,node,id,assert,local,node,id,null,routing,node,local,routing,node,state,get,routing,nodes,node,local,node,id,for,allocated,index,extends,shard,index,service,indices,service,for,shard,shard,index,service,shard,routing,current,routing,entry,shard,routing,entry,shard,id,shard,id,current,routing,entry,shard,id,shard,routing,new,shard,routing,local,routing,node,null,null,local,routing,node,get,by,shard,id,shard,id,if,new,shard,routing,null,logger,debug,removing,shard,not,allocated,shard,id,index,service,remove,shard,shard,id,id,removing,shard,not,allocated,else,if,new,shard,routing,is,same,allocation,current,routing,entry,false,logger,debug,removing,shard,stale,allocation,id,stale,new,shard,id,current,routing,entry,new,shard,routing,index,service,remove,shard,shard,id,id,removing,shard,stale,copy,else,if,new,shard,routing,initializing,current,routing,entry,active,logger,debug,removing,shard,not,active,current,new,shard,id,current,routing,entry,new,shard,routing,index,service,remove,shard,shard,id,id,removing,shard,stale,copy,else,if,new,shard,routing,primary,current,routing,entry,primary,false,new,shard,routing,initializing,assert,current,routing,entry,initializing,current,routing,entry,logger,debug,removing,shard,not,active,current,new,shard,id,current,routing,entry,new,shard,routing,index,service,remove,shard,shard,id,id,removing,shard,stale,copy
IndicesClusterStateService -> private void removeShards(final ClusterState state);1548770980;Removes shards that are currently loaded by indicesService but have disappeared from the routing table of the current node._This method does not delete the shard data.__@param state new cluster state;private void removeShards(final ClusterState state) {_        final String localNodeId = state.nodes().getLocalNodeId()__        assert localNodeId != null___        _        RoutingNode localRoutingNode = state.getRoutingNodes().node(localNodeId)__        for (AllocatedIndex<? extends Shard> indexService : indicesService) {_            for (Shard shard : indexService) {_                ShardRouting currentRoutingEntry = shard.routingEntry()__                ShardId shardId = currentRoutingEntry.shardId()__                ShardRouting newShardRouting = localRoutingNode == null ? null : localRoutingNode.getByShardId(shardId)__                if (newShardRouting == null) {_                    _                    _                    logger.debug("{} removing shard (not allocated)", shardId)__                    indexService.removeShard(shardId.id(), "removing shard (not allocated)")__                } else if (newShardRouting.isSameAllocation(currentRoutingEntry) == false) {_                    logger.debug("{} removing shard (stale allocation id, stale {}, new {})", shardId,_                        currentRoutingEntry, newShardRouting)__                    indexService.removeShard(shardId.id(), "removing shard (stale copy)")__                } else if (newShardRouting.initializing() && currentRoutingEntry.active()) {_                    _                    _                    _                    logger.debug("{} removing shard (not active, current {}, new {})", shardId, currentRoutingEntry, newShardRouting)__                    indexService.removeShard(shardId.id(), "removing shard (stale copy)")__                } else if (newShardRouting.primary() && currentRoutingEntry.primary() == false && newShardRouting.initializing()) {_                    assert currentRoutingEntry.initializing() : currentRoutingEntry_ _                    _                    _                    logger.debug("{} removing shard (not active, current {}, new {})", shardId, currentRoutingEntry, newShardRouting)__                    indexService.removeShard(shardId.id(), "removing shard (stale copy)")__                }_            }_        }_    };removes,shards,that,are,currently,loaded,by,indices,service,but,have,disappeared,from,the,routing,table,of,the,current,node,this,method,does,not,delete,the,shard,data,param,state,new,cluster,state;private,void,remove,shards,final,cluster,state,state,final,string,local,node,id,state,nodes,get,local,node,id,assert,local,node,id,null,routing,node,local,routing,node,state,get,routing,nodes,node,local,node,id,for,allocated,index,extends,shard,index,service,indices,service,for,shard,shard,index,service,shard,routing,current,routing,entry,shard,routing,entry,shard,id,shard,id,current,routing,entry,shard,id,shard,routing,new,shard,routing,local,routing,node,null,null,local,routing,node,get,by,shard,id,shard,id,if,new,shard,routing,null,logger,debug,removing,shard,not,allocated,shard,id,index,service,remove,shard,shard,id,id,removing,shard,not,allocated,else,if,new,shard,routing,is,same,allocation,current,routing,entry,false,logger,debug,removing,shard,stale,allocation,id,stale,new,shard,id,current,routing,entry,new,shard,routing,index,service,remove,shard,shard,id,id,removing,shard,stale,copy,else,if,new,shard,routing,initializing,current,routing,entry,active,logger,debug,removing,shard,not,active,current,new,shard,id,current,routing,entry,new,shard,routing,index,service,remove,shard,shard,id,id,removing,shard,stale,copy,else,if,new,shard,routing,primary,current,routing,entry,primary,false,new,shard,routing,initializing,assert,current,routing,entry,initializing,current,routing,entry,logger,debug,removing,shard,not,active,current,new,shard,id,current,routing,entry,new,shard,routing,index,service,remove,shard,shard,id,id,removing,shard,stale,copy
IndicesClusterStateService -> private void removeShards(final ClusterState state);1548872469;Removes shards that are currently loaded by indicesService but have disappeared from the routing table of the current node._This method does not delete the shard data.__@param state new cluster state;private void removeShards(final ClusterState state) {_        final String localNodeId = state.nodes().getLocalNodeId()__        assert localNodeId != null___        _        RoutingNode localRoutingNode = state.getRoutingNodes().node(localNodeId)__        for (AllocatedIndex<? extends Shard> indexService : indicesService) {_            for (Shard shard : indexService) {_                ShardRouting currentRoutingEntry = shard.routingEntry()__                ShardId shardId = currentRoutingEntry.shardId()__                ShardRouting newShardRouting = localRoutingNode == null ? null : localRoutingNode.getByShardId(shardId)__                if (newShardRouting == null) {_                    _                    _                    logger.debug("{} removing shard (not allocated)", shardId)__                    indexService.removeShard(shardId.id(), "removing shard (not allocated)")__                } else if (newShardRouting.isSameAllocation(currentRoutingEntry) == false) {_                    logger.debug("{} removing shard (stale allocation id, stale {}, new {})", shardId,_                        currentRoutingEntry, newShardRouting)__                    indexService.removeShard(shardId.id(), "removing shard (stale copy)")__                } else if (newShardRouting.initializing() && currentRoutingEntry.active()) {_                    _                    _                    _                    logger.debug("{} removing shard (not active, current {}, new {})", shardId, currentRoutingEntry, newShardRouting)__                    indexService.removeShard(shardId.id(), "removing shard (stale copy)")__                } else if (newShardRouting.primary() && currentRoutingEntry.primary() == false && newShardRouting.initializing()) {_                    assert currentRoutingEntry.initializing() : currentRoutingEntry_ _                    _                    _                    logger.debug("{} removing shard (not active, current {}, new {})", shardId, currentRoutingEntry, newShardRouting)__                    indexService.removeShard(shardId.id(), "removing shard (stale copy)")__                }_            }_        }_    };removes,shards,that,are,currently,loaded,by,indices,service,but,have,disappeared,from,the,routing,table,of,the,current,node,this,method,does,not,delete,the,shard,data,param,state,new,cluster,state;private,void,remove,shards,final,cluster,state,state,final,string,local,node,id,state,nodes,get,local,node,id,assert,local,node,id,null,routing,node,local,routing,node,state,get,routing,nodes,node,local,node,id,for,allocated,index,extends,shard,index,service,indices,service,for,shard,shard,index,service,shard,routing,current,routing,entry,shard,routing,entry,shard,id,shard,id,current,routing,entry,shard,id,shard,routing,new,shard,routing,local,routing,node,null,null,local,routing,node,get,by,shard,id,shard,id,if,new,shard,routing,null,logger,debug,removing,shard,not,allocated,shard,id,index,service,remove,shard,shard,id,id,removing,shard,not,allocated,else,if,new,shard,routing,is,same,allocation,current,routing,entry,false,logger,debug,removing,shard,stale,allocation,id,stale,new,shard,id,current,routing,entry,new,shard,routing,index,service,remove,shard,shard,id,id,removing,shard,stale,copy,else,if,new,shard,routing,initializing,current,routing,entry,active,logger,debug,removing,shard,not,active,current,new,shard,id,current,routing,entry,new,shard,routing,index,service,remove,shard,shard,id,id,removing,shard,stale,copy,else,if,new,shard,routing,primary,current,routing,entry,primary,false,new,shard,routing,initializing,assert,current,routing,entry,initializing,current,routing,entry,logger,debug,removing,shard,not,active,current,new,shard,id,current,routing,entry,new,shard,routing,index,service,remove,shard,shard,id,id,removing,shard,stale,copy
IndicesClusterStateService -> private void removeShards(final ClusterState state);1549294529;Removes shards that are currently loaded by indicesService but have disappeared from the routing table of the current node._This method does not delete the shard data.__@param state new cluster state;private void removeShards(final ClusterState state) {_        final String localNodeId = state.nodes().getLocalNodeId()__        assert localNodeId != null___        _        RoutingNode localRoutingNode = state.getRoutingNodes().node(localNodeId)__        for (AllocatedIndex<? extends Shard> indexService : indicesService) {_            for (Shard shard : indexService) {_                ShardRouting currentRoutingEntry = shard.routingEntry()__                ShardId shardId = currentRoutingEntry.shardId()__                ShardRouting newShardRouting = localRoutingNode == null ? null : localRoutingNode.getByShardId(shardId)__                if (newShardRouting == null) {_                    _                    _                    logger.debug("{} removing shard (not allocated)", shardId)__                    indexService.removeShard(shardId.id(), "removing shard (not allocated)")__                } else if (newShardRouting.isSameAllocation(currentRoutingEntry) == false) {_                    logger.debug("{} removing shard (stale allocation id, stale {}, new {})", shardId,_                        currentRoutingEntry, newShardRouting)__                    indexService.removeShard(shardId.id(), "removing shard (stale copy)")__                } else if (newShardRouting.initializing() && currentRoutingEntry.active()) {_                    _                    _                    _                    logger.debug("{} removing shard (not active, current {}, new {})", shardId, currentRoutingEntry, newShardRouting)__                    indexService.removeShard(shardId.id(), "removing shard (stale copy)")__                } else if (newShardRouting.primary() && currentRoutingEntry.primary() == false && newShardRouting.initializing()) {_                    assert currentRoutingEntry.initializing() : currentRoutingEntry_ _                    _                    _                    logger.debug("{} removing shard (not active, current {}, new {})", shardId, currentRoutingEntry, newShardRouting)__                    indexService.removeShard(shardId.id(), "removing shard (stale copy)")__                }_            }_        }_    };removes,shards,that,are,currently,loaded,by,indices,service,but,have,disappeared,from,the,routing,table,of,the,current,node,this,method,does,not,delete,the,shard,data,param,state,new,cluster,state;private,void,remove,shards,final,cluster,state,state,final,string,local,node,id,state,nodes,get,local,node,id,assert,local,node,id,null,routing,node,local,routing,node,state,get,routing,nodes,node,local,node,id,for,allocated,index,extends,shard,index,service,indices,service,for,shard,shard,index,service,shard,routing,current,routing,entry,shard,routing,entry,shard,id,shard,id,current,routing,entry,shard,id,shard,routing,new,shard,routing,local,routing,node,null,null,local,routing,node,get,by,shard,id,shard,id,if,new,shard,routing,null,logger,debug,removing,shard,not,allocated,shard,id,index,service,remove,shard,shard,id,id,removing,shard,not,allocated,else,if,new,shard,routing,is,same,allocation,current,routing,entry,false,logger,debug,removing,shard,stale,allocation,id,stale,new,shard,id,current,routing,entry,new,shard,routing,index,service,remove,shard,shard,id,id,removing,shard,stale,copy,else,if,new,shard,routing,initializing,current,routing,entry,active,logger,debug,removing,shard,not,active,current,new,shard,id,current,routing,entry,new,shard,routing,index,service,remove,shard,shard,id,id,removing,shard,stale,copy,else,if,new,shard,routing,primary,current,routing,entry,primary,false,new,shard,routing,initializing,assert,current,routing,entry,initializing,current,routing,entry,logger,debug,removing,shard,not,active,current,new,shard,id,current,routing,entry,new,shard,routing,index,service,remove,shard,shard,id,id,removing,shard,stale,copy
IndicesClusterStateService -> Shard -> RecoveryState recoveryState()_;1524684173;Returns the recovery state associated with this shard.;RecoveryState recoveryState()_;returns,the,recovery,state,associated,with,this,shard;recovery,state,recovery,state
IndicesClusterStateService -> Shard -> RecoveryState recoveryState()_;1533063033;Returns the recovery state associated with this shard.;RecoveryState recoveryState()_;returns,the,recovery,state,associated,with,this,shard;recovery,state,recovery,state
IndicesClusterStateService -> Shard -> RecoveryState recoveryState()_;1535405719;Returns the recovery state associated with this shard.;RecoveryState recoveryState()_;returns,the,recovery,state,associated,with,this,shard;recovery,state,recovery,state
IndicesClusterStateService -> Shard -> RecoveryState recoveryState()_;1539723533;Returns the recovery state associated with this shard.;RecoveryState recoveryState()_;returns,the,recovery,state,associated,with,this,shard;recovery,state,recovery,state
IndicesClusterStateService -> Shard -> RecoveryState recoveryState()_;1541008027;Returns the recovery state associated with this shard.;RecoveryState recoveryState()_;returns,the,recovery,state,associated,with,this,shard;recovery,state,recovery,state
IndicesClusterStateService -> Shard -> RecoveryState recoveryState()_;1542646292;Returns the recovery state associated with this shard.;RecoveryState recoveryState()_;returns,the,recovery,state,associated,with,this,shard;recovery,state,recovery,state
IndicesClusterStateService -> Shard -> RecoveryState recoveryState()_;1547520324;Returns the recovery state associated with this shard.;RecoveryState recoveryState()_;returns,the,recovery,state,associated,with,this,shard;recovery,state,recovery,state
IndicesClusterStateService -> Shard -> RecoveryState recoveryState()_;1547536822;Returns the recovery state associated with this shard.;RecoveryState recoveryState()_;returns,the,recovery,state,associated,with,this,shard;recovery,state,recovery,state
IndicesClusterStateService -> Shard -> RecoveryState recoveryState()_;1547625930;Returns the recovery state associated with this shard.;RecoveryState recoveryState()_;returns,the,recovery,state,associated,with,this,shard;recovery,state,recovery,state
IndicesClusterStateService -> Shard -> RecoveryState recoveryState()_;1548593396;Returns the recovery state associated with this shard.;RecoveryState recoveryState()_;returns,the,recovery,state,associated,with,this,shard;recovery,state,recovery,state
IndicesClusterStateService -> Shard -> RecoveryState recoveryState()_;1548770980;Returns the recovery state associated with this shard.;RecoveryState recoveryState()_;returns,the,recovery,state,associated,with,this,shard;recovery,state,recovery,state
IndicesClusterStateService -> Shard -> RecoveryState recoveryState()_;1548872469;Returns the recovery state associated with this shard.;RecoveryState recoveryState()_;returns,the,recovery,state,associated,with,this,shard;recovery,state,recovery,state
IndicesClusterStateService -> Shard -> RecoveryState recoveryState()_;1549294529;Returns the recovery state associated with this shard.;RecoveryState recoveryState()_;returns,the,recovery,state,associated,with,this,shard;recovery,state,recovery,state
IndicesClusterStateService -> AllocatedIndex -> boolean updateMapping(IndexMetaData currentIndexMetaData, IndexMetaData newIndexMetaData) throws IOException_;1535405719;Checks if index requires refresh from master.;boolean updateMapping(IndexMetaData currentIndexMetaData, IndexMetaData newIndexMetaData) throws IOException_;checks,if,index,requires,refresh,from,master;boolean,update,mapping,index,meta,data,current,index,meta,data,index,meta,data,new,index,meta,data,throws,ioexception
IndicesClusterStateService -> AllocatedIndex -> boolean updateMapping(IndexMetaData currentIndexMetaData, IndexMetaData newIndexMetaData) throws IOException_;1539723533;Checks if index requires refresh from master.;boolean updateMapping(IndexMetaData currentIndexMetaData, IndexMetaData newIndexMetaData) throws IOException_;checks,if,index,requires,refresh,from,master;boolean,update,mapping,index,meta,data,current,index,meta,data,index,meta,data,new,index,meta,data,throws,ioexception
IndicesClusterStateService -> AllocatedIndex -> boolean updateMapping(IndexMetaData currentIndexMetaData, IndexMetaData newIndexMetaData) throws IOException_;1541008027;Checks if index requires refresh from master.;boolean updateMapping(IndexMetaData currentIndexMetaData, IndexMetaData newIndexMetaData) throws IOException_;checks,if,index,requires,refresh,from,master;boolean,update,mapping,index,meta,data,current,index,meta,data,index,meta,data,new,index,meta,data,throws,ioexception
IndicesClusterStateService -> AllocatedIndex -> boolean updateMapping(IndexMetaData currentIndexMetaData, IndexMetaData newIndexMetaData) throws IOException_;1542646292;Checks if index requires refresh from master.;boolean updateMapping(IndexMetaData currentIndexMetaData, IndexMetaData newIndexMetaData) throws IOException_;checks,if,index,requires,refresh,from,master;boolean,update,mapping,index,meta,data,current,index,meta,data,index,meta,data,new,index,meta,data,throws,ioexception
IndicesClusterStateService -> AllocatedIndex -> boolean updateMapping(IndexMetaData currentIndexMetaData, IndexMetaData newIndexMetaData) throws IOException_;1547520324;Checks if index requires refresh from master.;boolean updateMapping(IndexMetaData currentIndexMetaData, IndexMetaData newIndexMetaData) throws IOException_;checks,if,index,requires,refresh,from,master;boolean,update,mapping,index,meta,data,current,index,meta,data,index,meta,data,new,index,meta,data,throws,ioexception
IndicesClusterStateService -> AllocatedIndex -> boolean updateMapping(IndexMetaData currentIndexMetaData, IndexMetaData newIndexMetaData) throws IOException_;1547536822;Checks if index requires refresh from master.;boolean updateMapping(IndexMetaData currentIndexMetaData, IndexMetaData newIndexMetaData) throws IOException_;checks,if,index,requires,refresh,from,master;boolean,update,mapping,index,meta,data,current,index,meta,data,index,meta,data,new,index,meta,data,throws,ioexception
IndicesClusterStateService -> AllocatedIndex -> boolean updateMapping(IndexMetaData currentIndexMetaData, IndexMetaData newIndexMetaData) throws IOException_;1547625930;Checks if index requires refresh from master.;boolean updateMapping(IndexMetaData currentIndexMetaData, IndexMetaData newIndexMetaData) throws IOException_;checks,if,index,requires,refresh,from,master;boolean,update,mapping,index,meta,data,current,index,meta,data,index,meta,data,new,index,meta,data,throws,ioexception
IndicesClusterStateService -> AllocatedIndex -> boolean updateMapping(IndexMetaData currentIndexMetaData, IndexMetaData newIndexMetaData) throws IOException_;1548593396;Checks if index requires refresh from master.;boolean updateMapping(IndexMetaData currentIndexMetaData, IndexMetaData newIndexMetaData) throws IOException_;checks,if,index,requires,refresh,from,master;boolean,update,mapping,index,meta,data,current,index,meta,data,index,meta,data,new,index,meta,data,throws,ioexception
IndicesClusterStateService -> AllocatedIndex -> boolean updateMapping(IndexMetaData currentIndexMetaData, IndexMetaData newIndexMetaData) throws IOException_;1548770980;Checks if index requires refresh from master.;boolean updateMapping(IndexMetaData currentIndexMetaData, IndexMetaData newIndexMetaData) throws IOException_;checks,if,index,requires,refresh,from,master;boolean,update,mapping,index,meta,data,current,index,meta,data,index,meta,data,new,index,meta,data,throws,ioexception
IndicesClusterStateService -> AllocatedIndex -> boolean updateMapping(IndexMetaData currentIndexMetaData, IndexMetaData newIndexMetaData) throws IOException_;1548872469;Checks if index requires refresh from master.;boolean updateMapping(IndexMetaData currentIndexMetaData, IndexMetaData newIndexMetaData) throws IOException_;checks,if,index,requires,refresh,from,master;boolean,update,mapping,index,meta,data,current,index,meta,data,index,meta,data,new,index,meta,data,throws,ioexception
IndicesClusterStateService -> AllocatedIndex -> boolean updateMapping(IndexMetaData currentIndexMetaData, IndexMetaData newIndexMetaData) throws IOException_;1549294529;Checks if index requires refresh from master.;boolean updateMapping(IndexMetaData currentIndexMetaData, IndexMetaData newIndexMetaData) throws IOException_;checks,if,index,requires,refresh,from,master;boolean,update,mapping,index,meta,data,current,index,meta,data,index,meta,data,new,index,meta,data,throws,ioexception
IndicesClusterStateService -> Shard -> void updateShardState(ShardRouting shardRouting,                               long primaryTerm,                               BiConsumer<IndexShard, ActionListener<ResyncTask>> primaryReplicaSyncer,                               long applyingClusterStateVersion,                               Set<String> inSyncAllocationIds,                               IndexShardRoutingTable routingTable,                               Set<String> pre60AllocationIds) throws IOException_;1524684173;Updates the shard state based on an incoming cluster state:_- Updates and persists the new routing value._- Updates the primary term if this shard is a primary._- Updates the allocation ids that are tracked by the shard if it is a primary._See {@link ReplicationTracker#updateFromMaster(long, Set, IndexShardRoutingTable, Set)} for details.__@param shardRouting                the new routing entry_@param primaryTerm                 the new primary term_@param primaryReplicaSyncer        the primary-replica resync action to trigger when a term is increased on a primary_@param applyingClusterStateVersion the cluster state version being applied when updating the allocation IDs from the master_@param inSyncAllocationIds         the allocation ids of the currently in-sync shard copies_@param routingTable                the shard routing table_@throws IndexShardRelocatedException if shard is marked as relocated and relocation aborted_@throws IOException                  if shard state could not be persisted;void updateShardState(ShardRouting shardRouting,_                              long primaryTerm,_                              BiConsumer<IndexShard, ActionListener<ResyncTask>> primaryReplicaSyncer,_                              long applyingClusterStateVersion,_                              Set<String> inSyncAllocationIds,_                              IndexShardRoutingTable routingTable,_                              Set<String> pre60AllocationIds) throws IOException_;updates,the,shard,state,based,on,an,incoming,cluster,state,updates,and,persists,the,new,routing,value,updates,the,primary,term,if,this,shard,is,a,primary,updates,the,allocation,ids,that,are,tracked,by,the,shard,if,it,is,a,primary,see,link,replication,tracker,update,from,master,long,set,index,shard,routing,table,set,for,details,param,shard,routing,the,new,routing,entry,param,primary,term,the,new,primary,term,param,primary,replica,syncer,the,primary,replica,resync,action,to,trigger,when,a,term,is,increased,on,a,primary,param,applying,cluster,state,version,the,cluster,state,version,being,applied,when,updating,the,allocation,ids,from,the,master,param,in,sync,allocation,ids,the,allocation,ids,of,the,currently,in,sync,shard,copies,param,routing,table,the,shard,routing,table,throws,index,shard,relocated,exception,if,shard,is,marked,as,relocated,and,relocation,aborted,throws,ioexception,if,shard,state,could,not,be,persisted;void,update,shard,state,shard,routing,shard,routing,long,primary,term,bi,consumer,index,shard,action,listener,resync,task,primary,replica,syncer,long,applying,cluster,state,version,set,string,in,sync,allocation,ids,index,shard,routing,table,routing,table,set,string,pre60allocation,ids,throws,ioexception
IndicesClusterStateService -> Shard -> void updateShardState(ShardRouting shardRouting,                               long primaryTerm,                               BiConsumer<IndexShard, ActionListener<ResyncTask>> primaryReplicaSyncer,                               long applyingClusterStateVersion,                               Set<String> inSyncAllocationIds,                               IndexShardRoutingTable routingTable,                               Set<String> pre60AllocationIds) throws IOException_;1533063033;Updates the shard state based on an incoming cluster state:_- Updates and persists the new routing value._- Updates the primary term if this shard is a primary._- Updates the allocation ids that are tracked by the shard if it is a primary._See {@link ReplicationTracker#updateFromMaster(long, Set, IndexShardRoutingTable, Set)} for details.__@param shardRouting                the new routing entry_@param primaryTerm                 the new primary term_@param primaryReplicaSyncer        the primary-replica resync action to trigger when a term is increased on a primary_@param applyingClusterStateVersion the cluster state version being applied when updating the allocation IDs from the master_@param inSyncAllocationIds         the allocation ids of the currently in-sync shard copies_@param routingTable                the shard routing table_@throws IndexShardRelocatedException if shard is marked as relocated and relocation aborted_@throws IOException                  if shard state could not be persisted;void updateShardState(ShardRouting shardRouting,_                              long primaryTerm,_                              BiConsumer<IndexShard, ActionListener<ResyncTask>> primaryReplicaSyncer,_                              long applyingClusterStateVersion,_                              Set<String> inSyncAllocationIds,_                              IndexShardRoutingTable routingTable,_                              Set<String> pre60AllocationIds) throws IOException_;updates,the,shard,state,based,on,an,incoming,cluster,state,updates,and,persists,the,new,routing,value,updates,the,primary,term,if,this,shard,is,a,primary,updates,the,allocation,ids,that,are,tracked,by,the,shard,if,it,is,a,primary,see,link,replication,tracker,update,from,master,long,set,index,shard,routing,table,set,for,details,param,shard,routing,the,new,routing,entry,param,primary,term,the,new,primary,term,param,primary,replica,syncer,the,primary,replica,resync,action,to,trigger,when,a,term,is,increased,on,a,primary,param,applying,cluster,state,version,the,cluster,state,version,being,applied,when,updating,the,allocation,ids,from,the,master,param,in,sync,allocation,ids,the,allocation,ids,of,the,currently,in,sync,shard,copies,param,routing,table,the,shard,routing,table,throws,index,shard,relocated,exception,if,shard,is,marked,as,relocated,and,relocation,aborted,throws,ioexception,if,shard,state,could,not,be,persisted;void,update,shard,state,shard,routing,shard,routing,long,primary,term,bi,consumer,index,shard,action,listener,resync,task,primary,replica,syncer,long,applying,cluster,state,version,set,string,in,sync,allocation,ids,index,shard,routing,table,routing,table,set,string,pre60allocation,ids,throws,ioexception
IndicesClusterStateService -> Shard -> void updateShardState(ShardRouting shardRouting,                               long primaryTerm,                               BiConsumer<IndexShard, ActionListener<ResyncTask>> primaryReplicaSyncer,                               long applyingClusterStateVersion,                               Set<String> inSyncAllocationIds,                               IndexShardRoutingTable routingTable,                               Set<String> pre60AllocationIds) throws IOException_;1535405719;Updates the shard state based on an incoming cluster state:_- Updates and persists the new routing value._- Updates the primary term if this shard is a primary._- Updates the allocation ids that are tracked by the shard if it is a primary._See {@link ReplicationTracker#updateFromMaster(long, Set, IndexShardRoutingTable, Set)} for details.__@param shardRouting                the new routing entry_@param primaryTerm                 the new primary term_@param primaryReplicaSyncer        the primary-replica resync action to trigger when a term is increased on a primary_@param applyingClusterStateVersion the cluster state version being applied when updating the allocation IDs from the master_@param inSyncAllocationIds         the allocation ids of the currently in-sync shard copies_@param routingTable                the shard routing table_@throws IndexShardRelocatedException if shard is marked as relocated and relocation aborted_@throws IOException                  if shard state could not be persisted;void updateShardState(ShardRouting shardRouting,_                              long primaryTerm,_                              BiConsumer<IndexShard, ActionListener<ResyncTask>> primaryReplicaSyncer,_                              long applyingClusterStateVersion,_                              Set<String> inSyncAllocationIds,_                              IndexShardRoutingTable routingTable,_                              Set<String> pre60AllocationIds) throws IOException_;updates,the,shard,state,based,on,an,incoming,cluster,state,updates,and,persists,the,new,routing,value,updates,the,primary,term,if,this,shard,is,a,primary,updates,the,allocation,ids,that,are,tracked,by,the,shard,if,it,is,a,primary,see,link,replication,tracker,update,from,master,long,set,index,shard,routing,table,set,for,details,param,shard,routing,the,new,routing,entry,param,primary,term,the,new,primary,term,param,primary,replica,syncer,the,primary,replica,resync,action,to,trigger,when,a,term,is,increased,on,a,primary,param,applying,cluster,state,version,the,cluster,state,version,being,applied,when,updating,the,allocation,ids,from,the,master,param,in,sync,allocation,ids,the,allocation,ids,of,the,currently,in,sync,shard,copies,param,routing,table,the,shard,routing,table,throws,index,shard,relocated,exception,if,shard,is,marked,as,relocated,and,relocation,aborted,throws,ioexception,if,shard,state,could,not,be,persisted;void,update,shard,state,shard,routing,shard,routing,long,primary,term,bi,consumer,index,shard,action,listener,resync,task,primary,replica,syncer,long,applying,cluster,state,version,set,string,in,sync,allocation,ids,index,shard,routing,table,routing,table,set,string,pre60allocation,ids,throws,ioexception
IndicesClusterStateService -> Shard -> void updateShardState(ShardRouting shardRouting,                               long primaryTerm,                               BiConsumer<IndexShard, ActionListener<ResyncTask>> primaryReplicaSyncer,                               long applyingClusterStateVersion,                               Set<String> inSyncAllocationIds,                               IndexShardRoutingTable routingTable,                               Set<String> pre60AllocationIds) throws IOException_;1539723533;Updates the shard state based on an incoming cluster state:_- Updates and persists the new routing value._- Updates the primary term if this shard is a primary._- Updates the allocation ids that are tracked by the shard if it is a primary._See {@link ReplicationTracker#updateFromMaster(long, Set, IndexShardRoutingTable, Set)} for details.__@param shardRouting                the new routing entry_@param primaryTerm                 the new primary term_@param primaryReplicaSyncer        the primary-replica resync action to trigger when a term is increased on a primary_@param applyingClusterStateVersion the cluster state version being applied when updating the allocation IDs from the master_@param inSyncAllocationIds         the allocation ids of the currently in-sync shard copies_@param routingTable                the shard routing table_@throws IndexShardRelocatedException if shard is marked as relocated and relocation aborted_@throws IOException                  if shard state could not be persisted;void updateShardState(ShardRouting shardRouting,_                              long primaryTerm,_                              BiConsumer<IndexShard, ActionListener<ResyncTask>> primaryReplicaSyncer,_                              long applyingClusterStateVersion,_                              Set<String> inSyncAllocationIds,_                              IndexShardRoutingTable routingTable,_                              Set<String> pre60AllocationIds) throws IOException_;updates,the,shard,state,based,on,an,incoming,cluster,state,updates,and,persists,the,new,routing,value,updates,the,primary,term,if,this,shard,is,a,primary,updates,the,allocation,ids,that,are,tracked,by,the,shard,if,it,is,a,primary,see,link,replication,tracker,update,from,master,long,set,index,shard,routing,table,set,for,details,param,shard,routing,the,new,routing,entry,param,primary,term,the,new,primary,term,param,primary,replica,syncer,the,primary,replica,resync,action,to,trigger,when,a,term,is,increased,on,a,primary,param,applying,cluster,state,version,the,cluster,state,version,being,applied,when,updating,the,allocation,ids,from,the,master,param,in,sync,allocation,ids,the,allocation,ids,of,the,currently,in,sync,shard,copies,param,routing,table,the,shard,routing,table,throws,index,shard,relocated,exception,if,shard,is,marked,as,relocated,and,relocation,aborted,throws,ioexception,if,shard,state,could,not,be,persisted;void,update,shard,state,shard,routing,shard,routing,long,primary,term,bi,consumer,index,shard,action,listener,resync,task,primary,replica,syncer,long,applying,cluster,state,version,set,string,in,sync,allocation,ids,index,shard,routing,table,routing,table,set,string,pre60allocation,ids,throws,ioexception
IndicesClusterStateService -> Shard -> void updateShardState(ShardRouting shardRouting,                               long primaryTerm,                               BiConsumer<IndexShard, ActionListener<ResyncTask>> primaryReplicaSyncer,                               long applyingClusterStateVersion,                               Set<String> inSyncAllocationIds,                               IndexShardRoutingTable routingTable,                               Set<String> pre60AllocationIds) throws IOException_;1541008027;Updates the shard state based on an incoming cluster state:_- Updates and persists the new routing value._- Updates the primary term if this shard is a primary._- Updates the allocation ids that are tracked by the shard if it is a primary._See {@link ReplicationTracker#updateFromMaster(long, Set, IndexShardRoutingTable, Set)} for details.__@param shardRouting                the new routing entry_@param primaryTerm                 the new primary term_@param primaryReplicaSyncer        the primary-replica resync action to trigger when a term is increased on a primary_@param applyingClusterStateVersion the cluster state version being applied when updating the allocation IDs from the master_@param inSyncAllocationIds         the allocation ids of the currently in-sync shard copies_@param routingTable                the shard routing table_@throws IndexShardRelocatedException if shard is marked as relocated and relocation aborted_@throws IOException                  if shard state could not be persisted;void updateShardState(ShardRouting shardRouting,_                              long primaryTerm,_                              BiConsumer<IndexShard, ActionListener<ResyncTask>> primaryReplicaSyncer,_                              long applyingClusterStateVersion,_                              Set<String> inSyncAllocationIds,_                              IndexShardRoutingTable routingTable,_                              Set<String> pre60AllocationIds) throws IOException_;updates,the,shard,state,based,on,an,incoming,cluster,state,updates,and,persists,the,new,routing,value,updates,the,primary,term,if,this,shard,is,a,primary,updates,the,allocation,ids,that,are,tracked,by,the,shard,if,it,is,a,primary,see,link,replication,tracker,update,from,master,long,set,index,shard,routing,table,set,for,details,param,shard,routing,the,new,routing,entry,param,primary,term,the,new,primary,term,param,primary,replica,syncer,the,primary,replica,resync,action,to,trigger,when,a,term,is,increased,on,a,primary,param,applying,cluster,state,version,the,cluster,state,version,being,applied,when,updating,the,allocation,ids,from,the,master,param,in,sync,allocation,ids,the,allocation,ids,of,the,currently,in,sync,shard,copies,param,routing,table,the,shard,routing,table,throws,index,shard,relocated,exception,if,shard,is,marked,as,relocated,and,relocation,aborted,throws,ioexception,if,shard,state,could,not,be,persisted;void,update,shard,state,shard,routing,shard,routing,long,primary,term,bi,consumer,index,shard,action,listener,resync,task,primary,replica,syncer,long,applying,cluster,state,version,set,string,in,sync,allocation,ids,index,shard,routing,table,routing,table,set,string,pre60allocation,ids,throws,ioexception
IndicesClusterStateService -> Shard -> void updateShardState(ShardRouting shardRouting,                               long primaryTerm,                               BiConsumer<IndexShard, ActionListener<ResyncTask>> primaryReplicaSyncer,                               long applyingClusterStateVersion,                               Set<String> inSyncAllocationIds,                               IndexShardRoutingTable routingTable,                               Set<String> pre60AllocationIds) throws IOException_;1542646292;Updates the shard state based on an incoming cluster state:_- Updates and persists the new routing value._- Updates the primary term if this shard is a primary._- Updates the allocation ids that are tracked by the shard if it is a primary._See {@link ReplicationTracker#updateFromMaster(long, Set, IndexShardRoutingTable, Set)} for details.__@param shardRouting                the new routing entry_@param primaryTerm                 the new primary term_@param primaryReplicaSyncer        the primary-replica resync action to trigger when a term is increased on a primary_@param applyingClusterStateVersion the cluster state version being applied when updating the allocation IDs from the master_@param inSyncAllocationIds         the allocation ids of the currently in-sync shard copies_@param routingTable                the shard routing table_@throws IndexShardRelocatedException if shard is marked as relocated and relocation aborted_@throws IOException                  if shard state could not be persisted;void updateShardState(ShardRouting shardRouting,_                              long primaryTerm,_                              BiConsumer<IndexShard, ActionListener<ResyncTask>> primaryReplicaSyncer,_                              long applyingClusterStateVersion,_                              Set<String> inSyncAllocationIds,_                              IndexShardRoutingTable routingTable,_                              Set<String> pre60AllocationIds) throws IOException_;updates,the,shard,state,based,on,an,incoming,cluster,state,updates,and,persists,the,new,routing,value,updates,the,primary,term,if,this,shard,is,a,primary,updates,the,allocation,ids,that,are,tracked,by,the,shard,if,it,is,a,primary,see,link,replication,tracker,update,from,master,long,set,index,shard,routing,table,set,for,details,param,shard,routing,the,new,routing,entry,param,primary,term,the,new,primary,term,param,primary,replica,syncer,the,primary,replica,resync,action,to,trigger,when,a,term,is,increased,on,a,primary,param,applying,cluster,state,version,the,cluster,state,version,being,applied,when,updating,the,allocation,ids,from,the,master,param,in,sync,allocation,ids,the,allocation,ids,of,the,currently,in,sync,shard,copies,param,routing,table,the,shard,routing,table,throws,index,shard,relocated,exception,if,shard,is,marked,as,relocated,and,relocation,aborted,throws,ioexception,if,shard,state,could,not,be,persisted;void,update,shard,state,shard,routing,shard,routing,long,primary,term,bi,consumer,index,shard,action,listener,resync,task,primary,replica,syncer,long,applying,cluster,state,version,set,string,in,sync,allocation,ids,index,shard,routing,table,routing,table,set,string,pre60allocation,ids,throws,ioexception
IndicesClusterStateService -> Shard -> void updateShardState(ShardRouting shardRouting,                               long primaryTerm,                               BiConsumer<IndexShard, ActionListener<ResyncTask>> primaryReplicaSyncer,                               long applyingClusterStateVersion,                               Set<String> inSyncAllocationIds,                               IndexShardRoutingTable routingTable,                               Set<String> pre60AllocationIds) throws IOException_;1547520324;Updates the shard state based on an incoming cluster state:_- Updates and persists the new routing value._- Updates the primary term if this shard is a primary._- Updates the allocation ids that are tracked by the shard if it is a primary._See {@link ReplicationTracker#updateFromMaster(long, Set, IndexShardRoutingTable, Set)} for details.__@param shardRouting                the new routing entry_@param primaryTerm                 the new primary term_@param primaryReplicaSyncer        the primary-replica resync action to trigger when a term is increased on a primary_@param applyingClusterStateVersion the cluster state version being applied when updating the allocation IDs from the master_@param inSyncAllocationIds         the allocation ids of the currently in-sync shard copies_@param routingTable                the shard routing table_@throws IndexShardRelocatedException if shard is marked as relocated and relocation aborted_@throws IOException                  if shard state could not be persisted;void updateShardState(ShardRouting shardRouting,_                              long primaryTerm,_                              BiConsumer<IndexShard, ActionListener<ResyncTask>> primaryReplicaSyncer,_                              long applyingClusterStateVersion,_                              Set<String> inSyncAllocationIds,_                              IndexShardRoutingTable routingTable,_                              Set<String> pre60AllocationIds) throws IOException_;updates,the,shard,state,based,on,an,incoming,cluster,state,updates,and,persists,the,new,routing,value,updates,the,primary,term,if,this,shard,is,a,primary,updates,the,allocation,ids,that,are,tracked,by,the,shard,if,it,is,a,primary,see,link,replication,tracker,update,from,master,long,set,index,shard,routing,table,set,for,details,param,shard,routing,the,new,routing,entry,param,primary,term,the,new,primary,term,param,primary,replica,syncer,the,primary,replica,resync,action,to,trigger,when,a,term,is,increased,on,a,primary,param,applying,cluster,state,version,the,cluster,state,version,being,applied,when,updating,the,allocation,ids,from,the,master,param,in,sync,allocation,ids,the,allocation,ids,of,the,currently,in,sync,shard,copies,param,routing,table,the,shard,routing,table,throws,index,shard,relocated,exception,if,shard,is,marked,as,relocated,and,relocation,aborted,throws,ioexception,if,shard,state,could,not,be,persisted;void,update,shard,state,shard,routing,shard,routing,long,primary,term,bi,consumer,index,shard,action,listener,resync,task,primary,replica,syncer,long,applying,cluster,state,version,set,string,in,sync,allocation,ids,index,shard,routing,table,routing,table,set,string,pre60allocation,ids,throws,ioexception
IndicesClusterStateService -> Shard -> void updateShardState(ShardRouting shardRouting,                               long primaryTerm,                               BiConsumer<IndexShard, ActionListener<ResyncTask>> primaryReplicaSyncer,                               long applyingClusterStateVersion,                               Set<String> inSyncAllocationIds,                               IndexShardRoutingTable routingTable,                               Set<String> pre60AllocationIds) throws IOException_;1547536822;Updates the shard state based on an incoming cluster state:_- Updates and persists the new routing value._- Updates the primary term if this shard is a primary._- Updates the allocation ids that are tracked by the shard if it is a primary._See {@link ReplicationTracker#updateFromMaster(long, Set, IndexShardRoutingTable, Set)} for details.__@param shardRouting                the new routing entry_@param primaryTerm                 the new primary term_@param primaryReplicaSyncer        the primary-replica resync action to trigger when a term is increased on a primary_@param applyingClusterStateVersion the cluster state version being applied when updating the allocation IDs from the master_@param inSyncAllocationIds         the allocation ids of the currently in-sync shard copies_@param routingTable                the shard routing table_@throws IndexShardRelocatedException if shard is marked as relocated and relocation aborted_@throws IOException                  if shard state could not be persisted;void updateShardState(ShardRouting shardRouting,_                              long primaryTerm,_                              BiConsumer<IndexShard, ActionListener<ResyncTask>> primaryReplicaSyncer,_                              long applyingClusterStateVersion,_                              Set<String> inSyncAllocationIds,_                              IndexShardRoutingTable routingTable,_                              Set<String> pre60AllocationIds) throws IOException_;updates,the,shard,state,based,on,an,incoming,cluster,state,updates,and,persists,the,new,routing,value,updates,the,primary,term,if,this,shard,is,a,primary,updates,the,allocation,ids,that,are,tracked,by,the,shard,if,it,is,a,primary,see,link,replication,tracker,update,from,master,long,set,index,shard,routing,table,set,for,details,param,shard,routing,the,new,routing,entry,param,primary,term,the,new,primary,term,param,primary,replica,syncer,the,primary,replica,resync,action,to,trigger,when,a,term,is,increased,on,a,primary,param,applying,cluster,state,version,the,cluster,state,version,being,applied,when,updating,the,allocation,ids,from,the,master,param,in,sync,allocation,ids,the,allocation,ids,of,the,currently,in,sync,shard,copies,param,routing,table,the,shard,routing,table,throws,index,shard,relocated,exception,if,shard,is,marked,as,relocated,and,relocation,aborted,throws,ioexception,if,shard,state,could,not,be,persisted;void,update,shard,state,shard,routing,shard,routing,long,primary,term,bi,consumer,index,shard,action,listener,resync,task,primary,replica,syncer,long,applying,cluster,state,version,set,string,in,sync,allocation,ids,index,shard,routing,table,routing,table,set,string,pre60allocation,ids,throws,ioexception
IndicesClusterStateService -> Shard -> void updateShardState(ShardRouting shardRouting,                               long primaryTerm,                               BiConsumer<IndexShard, ActionListener<ResyncTask>> primaryReplicaSyncer,                               long applyingClusterStateVersion,                               Set<String> inSyncAllocationIds,                               IndexShardRoutingTable routingTable,                               Set<String> pre60AllocationIds) throws IOException_;1547625930;Updates the shard state based on an incoming cluster state:_- Updates and persists the new routing value._- Updates the primary term if this shard is a primary._- Updates the allocation ids that are tracked by the shard if it is a primary._See {@link ReplicationTracker#updateFromMaster(long, Set, IndexShardRoutingTable, Set)} for details.__@param shardRouting                the new routing entry_@param primaryTerm                 the new primary term_@param primaryReplicaSyncer        the primary-replica resync action to trigger when a term is increased on a primary_@param applyingClusterStateVersion the cluster state version being applied when updating the allocation IDs from the master_@param inSyncAllocationIds         the allocation ids of the currently in-sync shard copies_@param routingTable                the shard routing table_@throws IndexShardRelocatedException if shard is marked as relocated and relocation aborted_@throws IOException                  if shard state could not be persisted;void updateShardState(ShardRouting shardRouting,_                              long primaryTerm,_                              BiConsumer<IndexShard, ActionListener<ResyncTask>> primaryReplicaSyncer,_                              long applyingClusterStateVersion,_                              Set<String> inSyncAllocationIds,_                              IndexShardRoutingTable routingTable,_                              Set<String> pre60AllocationIds) throws IOException_;updates,the,shard,state,based,on,an,incoming,cluster,state,updates,and,persists,the,new,routing,value,updates,the,primary,term,if,this,shard,is,a,primary,updates,the,allocation,ids,that,are,tracked,by,the,shard,if,it,is,a,primary,see,link,replication,tracker,update,from,master,long,set,index,shard,routing,table,set,for,details,param,shard,routing,the,new,routing,entry,param,primary,term,the,new,primary,term,param,primary,replica,syncer,the,primary,replica,resync,action,to,trigger,when,a,term,is,increased,on,a,primary,param,applying,cluster,state,version,the,cluster,state,version,being,applied,when,updating,the,allocation,ids,from,the,master,param,in,sync,allocation,ids,the,allocation,ids,of,the,currently,in,sync,shard,copies,param,routing,table,the,shard,routing,table,throws,index,shard,relocated,exception,if,shard,is,marked,as,relocated,and,relocation,aborted,throws,ioexception,if,shard,state,could,not,be,persisted;void,update,shard,state,shard,routing,shard,routing,long,primary,term,bi,consumer,index,shard,action,listener,resync,task,primary,replica,syncer,long,applying,cluster,state,version,set,string,in,sync,allocation,ids,index,shard,routing,table,routing,table,set,string,pre60allocation,ids,throws,ioexception
IndicesClusterStateService -> Shard -> void updateShardState(ShardRouting shardRouting,                               long primaryTerm,                               BiConsumer<IndexShard, ActionListener<ResyncTask>> primaryReplicaSyncer,                               long applyingClusterStateVersion,                               Set<String> inSyncAllocationIds,                               IndexShardRoutingTable routingTable,                               Set<String> pre60AllocationIds) throws IOException_;1548593396;Updates the shard state based on an incoming cluster state:_- Updates and persists the new routing value._- Updates the primary term if this shard is a primary._- Updates the allocation ids that are tracked by the shard if it is a primary._See {@link ReplicationTracker#updateFromMaster(long, Set, IndexShardRoutingTable, Set)} for details.__@param shardRouting                the new routing entry_@param primaryTerm                 the new primary term_@param primaryReplicaSyncer        the primary-replica resync action to trigger when a term is increased on a primary_@param applyingClusterStateVersion the cluster state version being applied when updating the allocation IDs from the master_@param inSyncAllocationIds         the allocation ids of the currently in-sync shard copies_@param routingTable                the shard routing table_@throws IndexShardRelocatedException if shard is marked as relocated and relocation aborted_@throws IOException                  if shard state could not be persisted;void updateShardState(ShardRouting shardRouting,_                              long primaryTerm,_                              BiConsumer<IndexShard, ActionListener<ResyncTask>> primaryReplicaSyncer,_                              long applyingClusterStateVersion,_                              Set<String> inSyncAllocationIds,_                              IndexShardRoutingTable routingTable,_                              Set<String> pre60AllocationIds) throws IOException_;updates,the,shard,state,based,on,an,incoming,cluster,state,updates,and,persists,the,new,routing,value,updates,the,primary,term,if,this,shard,is,a,primary,updates,the,allocation,ids,that,are,tracked,by,the,shard,if,it,is,a,primary,see,link,replication,tracker,update,from,master,long,set,index,shard,routing,table,set,for,details,param,shard,routing,the,new,routing,entry,param,primary,term,the,new,primary,term,param,primary,replica,syncer,the,primary,replica,resync,action,to,trigger,when,a,term,is,increased,on,a,primary,param,applying,cluster,state,version,the,cluster,state,version,being,applied,when,updating,the,allocation,ids,from,the,master,param,in,sync,allocation,ids,the,allocation,ids,of,the,currently,in,sync,shard,copies,param,routing,table,the,shard,routing,table,throws,index,shard,relocated,exception,if,shard,is,marked,as,relocated,and,relocation,aborted,throws,ioexception,if,shard,state,could,not,be,persisted;void,update,shard,state,shard,routing,shard,routing,long,primary,term,bi,consumer,index,shard,action,listener,resync,task,primary,replica,syncer,long,applying,cluster,state,version,set,string,in,sync,allocation,ids,index,shard,routing,table,routing,table,set,string,pre60allocation,ids,throws,ioexception
IndicesClusterStateService -> Shard -> void updateShardState(ShardRouting shardRouting,                               long primaryTerm,                               BiConsumer<IndexShard, ActionListener<ResyncTask>> primaryReplicaSyncer,                               long applyingClusterStateVersion,                               Set<String> inSyncAllocationIds,                               IndexShardRoutingTable routingTable,                               Set<String> pre60AllocationIds) throws IOException_;1548770980;Updates the shard state based on an incoming cluster state:_- Updates and persists the new routing value._- Updates the primary term if this shard is a primary._- Updates the allocation ids that are tracked by the shard if it is a primary._See {@link ReplicationTracker#updateFromMaster(long, Set, IndexShardRoutingTable, Set)} for details.__@param shardRouting                the new routing entry_@param primaryTerm                 the new primary term_@param primaryReplicaSyncer        the primary-replica resync action to trigger when a term is increased on a primary_@param applyingClusterStateVersion the cluster state version being applied when updating the allocation IDs from the master_@param inSyncAllocationIds         the allocation ids of the currently in-sync shard copies_@param routingTable                the shard routing table_@throws IndexShardRelocatedException if shard is marked as relocated and relocation aborted_@throws IOException                  if shard state could not be persisted;void updateShardState(ShardRouting shardRouting,_                              long primaryTerm,_                              BiConsumer<IndexShard, ActionListener<ResyncTask>> primaryReplicaSyncer,_                              long applyingClusterStateVersion,_                              Set<String> inSyncAllocationIds,_                              IndexShardRoutingTable routingTable,_                              Set<String> pre60AllocationIds) throws IOException_;updates,the,shard,state,based,on,an,incoming,cluster,state,updates,and,persists,the,new,routing,value,updates,the,primary,term,if,this,shard,is,a,primary,updates,the,allocation,ids,that,are,tracked,by,the,shard,if,it,is,a,primary,see,link,replication,tracker,update,from,master,long,set,index,shard,routing,table,set,for,details,param,shard,routing,the,new,routing,entry,param,primary,term,the,new,primary,term,param,primary,replica,syncer,the,primary,replica,resync,action,to,trigger,when,a,term,is,increased,on,a,primary,param,applying,cluster,state,version,the,cluster,state,version,being,applied,when,updating,the,allocation,ids,from,the,master,param,in,sync,allocation,ids,the,allocation,ids,of,the,currently,in,sync,shard,copies,param,routing,table,the,shard,routing,table,throws,index,shard,relocated,exception,if,shard,is,marked,as,relocated,and,relocation,aborted,throws,ioexception,if,shard,state,could,not,be,persisted;void,update,shard,state,shard,routing,shard,routing,long,primary,term,bi,consumer,index,shard,action,listener,resync,task,primary,replica,syncer,long,applying,cluster,state,version,set,string,in,sync,allocation,ids,index,shard,routing,table,routing,table,set,string,pre60allocation,ids,throws,ioexception
IndicesClusterStateService -> Shard -> void updateShardState(ShardRouting shardRouting,                               long primaryTerm,                               BiConsumer<IndexShard, ActionListener<ResyncTask>> primaryReplicaSyncer,                               long applyingClusterStateVersion,                               Set<String> inSyncAllocationIds,                               IndexShardRoutingTable routingTable,                               Set<String> pre60AllocationIds) throws IOException_;1548872469;Updates the shard state based on an incoming cluster state:_- Updates and persists the new routing value._- Updates the primary term if this shard is a primary._- Updates the allocation ids that are tracked by the shard if it is a primary._See {@link ReplicationTracker#updateFromMaster(long, Set, IndexShardRoutingTable, Set)} for details.__@param shardRouting                the new routing entry_@param primaryTerm                 the new primary term_@param primaryReplicaSyncer        the primary-replica resync action to trigger when a term is increased on a primary_@param applyingClusterStateVersion the cluster state version being applied when updating the allocation IDs from the master_@param inSyncAllocationIds         the allocation ids of the currently in-sync shard copies_@param routingTable                the shard routing table_@throws IndexShardRelocatedException if shard is marked as relocated and relocation aborted_@throws IOException                  if shard state could not be persisted;void updateShardState(ShardRouting shardRouting,_                              long primaryTerm,_                              BiConsumer<IndexShard, ActionListener<ResyncTask>> primaryReplicaSyncer,_                              long applyingClusterStateVersion,_                              Set<String> inSyncAllocationIds,_                              IndexShardRoutingTable routingTable,_                              Set<String> pre60AllocationIds) throws IOException_;updates,the,shard,state,based,on,an,incoming,cluster,state,updates,and,persists,the,new,routing,value,updates,the,primary,term,if,this,shard,is,a,primary,updates,the,allocation,ids,that,are,tracked,by,the,shard,if,it,is,a,primary,see,link,replication,tracker,update,from,master,long,set,index,shard,routing,table,set,for,details,param,shard,routing,the,new,routing,entry,param,primary,term,the,new,primary,term,param,primary,replica,syncer,the,primary,replica,resync,action,to,trigger,when,a,term,is,increased,on,a,primary,param,applying,cluster,state,version,the,cluster,state,version,being,applied,when,updating,the,allocation,ids,from,the,master,param,in,sync,allocation,ids,the,allocation,ids,of,the,currently,in,sync,shard,copies,param,routing,table,the,shard,routing,table,throws,index,shard,relocated,exception,if,shard,is,marked,as,relocated,and,relocation,aborted,throws,ioexception,if,shard,state,could,not,be,persisted;void,update,shard,state,shard,routing,shard,routing,long,primary,term,bi,consumer,index,shard,action,listener,resync,task,primary,replica,syncer,long,applying,cluster,state,version,set,string,in,sync,allocation,ids,index,shard,routing,table,routing,table,set,string,pre60allocation,ids,throws,ioexception
IndicesClusterStateService -> Shard -> void updateShardState(ShardRouting shardRouting,                               long primaryTerm,                               BiConsumer<IndexShard, ActionListener<ResyncTask>> primaryReplicaSyncer,                               long applyingClusterStateVersion,                               Set<String> inSyncAllocationIds,                               IndexShardRoutingTable routingTable,                               Set<String> pre60AllocationIds) throws IOException_;1549294529;Updates the shard state based on an incoming cluster state:_- Updates and persists the new routing value._- Updates the primary term if this shard is a primary._- Updates the allocation ids that are tracked by the shard if it is a primary._See {@link ReplicationTracker#updateFromMaster(long, Set, IndexShardRoutingTable, Set)} for details.__@param shardRouting                the new routing entry_@param primaryTerm                 the new primary term_@param primaryReplicaSyncer        the primary-replica resync action to trigger when a term is increased on a primary_@param applyingClusterStateVersion the cluster state version being applied when updating the allocation IDs from the master_@param inSyncAllocationIds         the allocation ids of the currently in-sync shard copies_@param routingTable                the shard routing table_@throws IndexShardRelocatedException if shard is marked as relocated and relocation aborted_@throws IOException                  if shard state could not be persisted;void updateShardState(ShardRouting shardRouting,_                              long primaryTerm,_                              BiConsumer<IndexShard, ActionListener<ResyncTask>> primaryReplicaSyncer,_                              long applyingClusterStateVersion,_                              Set<String> inSyncAllocationIds,_                              IndexShardRoutingTable routingTable,_                              Set<String> pre60AllocationIds) throws IOException_;updates,the,shard,state,based,on,an,incoming,cluster,state,updates,and,persists,the,new,routing,value,updates,the,primary,term,if,this,shard,is,a,primary,updates,the,allocation,ids,that,are,tracked,by,the,shard,if,it,is,a,primary,see,link,replication,tracker,update,from,master,long,set,index,shard,routing,table,set,for,details,param,shard,routing,the,new,routing,entry,param,primary,term,the,new,primary,term,param,primary,replica,syncer,the,primary,replica,resync,action,to,trigger,when,a,term,is,increased,on,a,primary,param,applying,cluster,state,version,the,cluster,state,version,being,applied,when,updating,the,allocation,ids,from,the,master,param,in,sync,allocation,ids,the,allocation,ids,of,the,currently,in,sync,shard,copies,param,routing,table,the,shard,routing,table,throws,index,shard,relocated,exception,if,shard,is,marked,as,relocated,and,relocation,aborted,throws,ioexception,if,shard,state,could,not,be,persisted;void,update,shard,state,shard,routing,shard,routing,long,primary,term,bi,consumer,index,shard,action,listener,resync,task,primary,replica,syncer,long,applying,cluster,state,version,set,string,in,sync,allocation,ids,index,shard,routing,table,routing,table,set,string,pre60allocation,ids,throws,ioexception
IndicesClusterStateService -> AllocatedIndices -> void removeIndex(Index index, IndexRemovalReason reason, String extraInfo)_;1524684173;Removes the given index from this service and releases all associated resources. Persistent parts of the index_like the shards files, state and transaction logs are kept around in the case of a disaster recovery._@param index the index to remove_@param reason the reason to remove the index_@param extraInfo extra information that will be used for logging and reporting;void removeIndex(Index index, IndexRemovalReason reason, String extraInfo)_;removes,the,given,index,from,this,service,and,releases,all,associated,resources,persistent,parts,of,the,index,like,the,shards,files,state,and,transaction,logs,are,kept,around,in,the,case,of,a,disaster,recovery,param,index,the,index,to,remove,param,reason,the,reason,to,remove,the,index,param,extra,info,extra,information,that,will,be,used,for,logging,and,reporting;void,remove,index,index,index,index,removal,reason,reason,string,extra,info
IndicesClusterStateService -> AllocatedIndices -> void removeIndex(Index index, IndexRemovalReason reason, String extraInfo)_;1533063033;Removes the given index from this service and releases all associated resources. Persistent parts of the index_like the shards files, state and transaction logs are kept around in the case of a disaster recovery._@param index the index to remove_@param reason the reason to remove the index_@param extraInfo extra information that will be used for logging and reporting;void removeIndex(Index index, IndexRemovalReason reason, String extraInfo)_;removes,the,given,index,from,this,service,and,releases,all,associated,resources,persistent,parts,of,the,index,like,the,shards,files,state,and,transaction,logs,are,kept,around,in,the,case,of,a,disaster,recovery,param,index,the,index,to,remove,param,reason,the,reason,to,remove,the,index,param,extra,info,extra,information,that,will,be,used,for,logging,and,reporting;void,remove,index,index,index,index,removal,reason,reason,string,extra,info
IndicesClusterStateService -> AllocatedIndices -> void removeIndex(Index index, IndexRemovalReason reason, String extraInfo)_;1535405719;Removes the given index from this service and releases all associated resources. Persistent parts of the index_like the shards files, state and transaction logs are kept around in the case of a disaster recovery._@param index the index to remove_@param reason the reason to remove the index_@param extraInfo extra information that will be used for logging and reporting;void removeIndex(Index index, IndexRemovalReason reason, String extraInfo)_;removes,the,given,index,from,this,service,and,releases,all,associated,resources,persistent,parts,of,the,index,like,the,shards,files,state,and,transaction,logs,are,kept,around,in,the,case,of,a,disaster,recovery,param,index,the,index,to,remove,param,reason,the,reason,to,remove,the,index,param,extra,info,extra,information,that,will,be,used,for,logging,and,reporting;void,remove,index,index,index,index,removal,reason,reason,string,extra,info
IndicesClusterStateService -> AllocatedIndices -> void removeIndex(Index index, IndexRemovalReason reason, String extraInfo)_;1539723533;Removes the given index from this service and releases all associated resources. Persistent parts of the index_like the shards files, state and transaction logs are kept around in the case of a disaster recovery._@param index the index to remove_@param reason the reason to remove the index_@param extraInfo extra information that will be used for logging and reporting;void removeIndex(Index index, IndexRemovalReason reason, String extraInfo)_;removes,the,given,index,from,this,service,and,releases,all,associated,resources,persistent,parts,of,the,index,like,the,shards,files,state,and,transaction,logs,are,kept,around,in,the,case,of,a,disaster,recovery,param,index,the,index,to,remove,param,reason,the,reason,to,remove,the,index,param,extra,info,extra,information,that,will,be,used,for,logging,and,reporting;void,remove,index,index,index,index,removal,reason,reason,string,extra,info
IndicesClusterStateService -> AllocatedIndices -> void removeIndex(Index index, IndexRemovalReason reason, String extraInfo)_;1541008027;Removes the given index from this service and releases all associated resources. Persistent parts of the index_like the shards files, state and transaction logs are kept around in the case of a disaster recovery._@param index the index to remove_@param reason the reason to remove the index_@param extraInfo extra information that will be used for logging and reporting;void removeIndex(Index index, IndexRemovalReason reason, String extraInfo)_;removes,the,given,index,from,this,service,and,releases,all,associated,resources,persistent,parts,of,the,index,like,the,shards,files,state,and,transaction,logs,are,kept,around,in,the,case,of,a,disaster,recovery,param,index,the,index,to,remove,param,reason,the,reason,to,remove,the,index,param,extra,info,extra,information,that,will,be,used,for,logging,and,reporting;void,remove,index,index,index,index,removal,reason,reason,string,extra,info
IndicesClusterStateService -> AllocatedIndices -> void removeIndex(Index index, IndexRemovalReason reason, String extraInfo)_;1542646292;Removes the given index from this service and releases all associated resources. Persistent parts of the index_like the shards files, state and transaction logs are kept around in the case of a disaster recovery._@param index the index to remove_@param reason the reason to remove the index_@param extraInfo extra information that will be used for logging and reporting;void removeIndex(Index index, IndexRemovalReason reason, String extraInfo)_;removes,the,given,index,from,this,service,and,releases,all,associated,resources,persistent,parts,of,the,index,like,the,shards,files,state,and,transaction,logs,are,kept,around,in,the,case,of,a,disaster,recovery,param,index,the,index,to,remove,param,reason,the,reason,to,remove,the,index,param,extra,info,extra,information,that,will,be,used,for,logging,and,reporting;void,remove,index,index,index,index,removal,reason,reason,string,extra,info
IndicesClusterStateService -> AllocatedIndices -> void removeIndex(Index index, IndexRemovalReason reason, String extraInfo)_;1547520324;Removes the given index from this service and releases all associated resources. Persistent parts of the index_like the shards files, state and transaction logs are kept around in the case of a disaster recovery._@param index the index to remove_@param reason the reason to remove the index_@param extraInfo extra information that will be used for logging and reporting;void removeIndex(Index index, IndexRemovalReason reason, String extraInfo)_;removes,the,given,index,from,this,service,and,releases,all,associated,resources,persistent,parts,of,the,index,like,the,shards,files,state,and,transaction,logs,are,kept,around,in,the,case,of,a,disaster,recovery,param,index,the,index,to,remove,param,reason,the,reason,to,remove,the,index,param,extra,info,extra,information,that,will,be,used,for,logging,and,reporting;void,remove,index,index,index,index,removal,reason,reason,string,extra,info
IndicesClusterStateService -> AllocatedIndices -> void removeIndex(Index index, IndexRemovalReason reason, String extraInfo)_;1547536822;Removes the given index from this service and releases all associated resources. Persistent parts of the index_like the shards files, state and transaction logs are kept around in the case of a disaster recovery._@param index the index to remove_@param reason the reason to remove the index_@param extraInfo extra information that will be used for logging and reporting;void removeIndex(Index index, IndexRemovalReason reason, String extraInfo)_;removes,the,given,index,from,this,service,and,releases,all,associated,resources,persistent,parts,of,the,index,like,the,shards,files,state,and,transaction,logs,are,kept,around,in,the,case,of,a,disaster,recovery,param,index,the,index,to,remove,param,reason,the,reason,to,remove,the,index,param,extra,info,extra,information,that,will,be,used,for,logging,and,reporting;void,remove,index,index,index,index,removal,reason,reason,string,extra,info
IndicesClusterStateService -> AllocatedIndices -> void removeIndex(Index index, IndexRemovalReason reason, String extraInfo)_;1547625930;Removes the given index from this service and releases all associated resources. Persistent parts of the index_like the shards files, state and transaction logs are kept around in the case of a disaster recovery._@param index the index to remove_@param reason the reason to remove the index_@param extraInfo extra information that will be used for logging and reporting;void removeIndex(Index index, IndexRemovalReason reason, String extraInfo)_;removes,the,given,index,from,this,service,and,releases,all,associated,resources,persistent,parts,of,the,index,like,the,shards,files,state,and,transaction,logs,are,kept,around,in,the,case,of,a,disaster,recovery,param,index,the,index,to,remove,param,reason,the,reason,to,remove,the,index,param,extra,info,extra,information,that,will,be,used,for,logging,and,reporting;void,remove,index,index,index,index,removal,reason,reason,string,extra,info
IndicesClusterStateService -> AllocatedIndices -> void removeIndex(Index index, IndexRemovalReason reason, String extraInfo)_;1548593396;Removes the given index from this service and releases all associated resources. Persistent parts of the index_like the shards files, state and transaction logs are kept around in the case of a disaster recovery._@param index the index to remove_@param reason the reason to remove the index_@param extraInfo extra information that will be used for logging and reporting;void removeIndex(Index index, IndexRemovalReason reason, String extraInfo)_;removes,the,given,index,from,this,service,and,releases,all,associated,resources,persistent,parts,of,the,index,like,the,shards,files,state,and,transaction,logs,are,kept,around,in,the,case,of,a,disaster,recovery,param,index,the,index,to,remove,param,reason,the,reason,to,remove,the,index,param,extra,info,extra,information,that,will,be,used,for,logging,and,reporting;void,remove,index,index,index,index,removal,reason,reason,string,extra,info
IndicesClusterStateService -> AllocatedIndices -> void removeIndex(Index index, IndexRemovalReason reason, String extraInfo)_;1548770980;Removes the given index from this service and releases all associated resources. Persistent parts of the index_like the shards files, state and transaction logs are kept around in the case of a disaster recovery._@param index the index to remove_@param reason the reason to remove the index_@param extraInfo extra information that will be used for logging and reporting;void removeIndex(Index index, IndexRemovalReason reason, String extraInfo)_;removes,the,given,index,from,this,service,and,releases,all,associated,resources,persistent,parts,of,the,index,like,the,shards,files,state,and,transaction,logs,are,kept,around,in,the,case,of,a,disaster,recovery,param,index,the,index,to,remove,param,reason,the,reason,to,remove,the,index,param,extra,info,extra,information,that,will,be,used,for,logging,and,reporting;void,remove,index,index,index,index,removal,reason,reason,string,extra,info
IndicesClusterStateService -> AllocatedIndices -> void removeIndex(Index index, IndexRemovalReason reason, String extraInfo)_;1548872469;Removes the given index from this service and releases all associated resources. Persistent parts of the index_like the shards files, state and transaction logs are kept around in the case of a disaster recovery._@param index the index to remove_@param reason the reason to remove the index_@param extraInfo extra information that will be used for logging and reporting;void removeIndex(Index index, IndexRemovalReason reason, String extraInfo)_;removes,the,given,index,from,this,service,and,releases,all,associated,resources,persistent,parts,of,the,index,like,the,shards,files,state,and,transaction,logs,are,kept,around,in,the,case,of,a,disaster,recovery,param,index,the,index,to,remove,param,reason,the,reason,to,remove,the,index,param,extra,info,extra,information,that,will,be,used,for,logging,and,reporting;void,remove,index,index,index,index,removal,reason,reason,string,extra,info
IndicesClusterStateService -> AllocatedIndices -> void removeIndex(Index index, IndexRemovalReason reason, String extraInfo)_;1549294529;Removes the given index from this service and releases all associated resources. Persistent parts of the index_like the shards files, state and transaction logs are kept around in the case of a disaster recovery._@param index the index to remove_@param reason the reason to remove the index_@param extraInfo extra information that will be used for logging and reporting;void removeIndex(Index index, IndexRemovalReason reason, String extraInfo)_;removes,the,given,index,from,this,service,and,releases,all,associated,resources,persistent,parts,of,the,index,like,the,shards,files,state,and,transaction,logs,are,kept,around,in,the,case,of,a,disaster,recovery,param,index,the,index,to,remove,param,reason,the,reason,to,remove,the,index,param,extra,info,extra,information,that,will,be,used,for,logging,and,reporting;void,remove,index,index,index,index,removal,reason,reason,string,extra,info
IndicesClusterStateService -> AllocatedIndices -> U createIndex(IndexMetaData indexMetaData,                       List<IndexEventListener> builtInIndexListener) throws IOException_;1524684173;Creates a new {@link IndexService} for the given metadata.__@param indexMetaData          the index metadata to create the index for_@param builtInIndexListener   a list of built-in lifecycle {@link IndexEventListener} that should should be used along side with_the per-index listeners_@throws ResourceAlreadyExistsException if the index already exists.;U createIndex(IndexMetaData indexMetaData,_                      List<IndexEventListener> builtInIndexListener) throws IOException_;creates,a,new,link,index,service,for,the,given,metadata,param,index,meta,data,the,index,metadata,to,create,the,index,for,param,built,in,index,listener,a,list,of,built,in,lifecycle,link,index,event,listener,that,should,should,be,used,along,side,with,the,per,index,listeners,throws,resource,already,exists,exception,if,the,index,already,exists;u,create,index,index,meta,data,index,meta,data,list,index,event,listener,built,in,index,listener,throws,ioexception
IndicesClusterStateService -> AllocatedIndices -> U createIndex(IndexMetaData indexMetaData,                       List<IndexEventListener> builtInIndexListener) throws IOException_;1533063033;Creates a new {@link IndexService} for the given metadata.__@param indexMetaData          the index metadata to create the index for_@param builtInIndexListener   a list of built-in lifecycle {@link IndexEventListener} that should should be used along side with_the per-index listeners_@throws ResourceAlreadyExistsException if the index already exists.;U createIndex(IndexMetaData indexMetaData,_                      List<IndexEventListener> builtInIndexListener) throws IOException_;creates,a,new,link,index,service,for,the,given,metadata,param,index,meta,data,the,index,metadata,to,create,the,index,for,param,built,in,index,listener,a,list,of,built,in,lifecycle,link,index,event,listener,that,should,should,be,used,along,side,with,the,per,index,listeners,throws,resource,already,exists,exception,if,the,index,already,exists;u,create,index,index,meta,data,index,meta,data,list,index,event,listener,built,in,index,listener,throws,ioexception
IndicesClusterStateService -> AllocatedIndices -> U createIndex(IndexMetaData indexMetaData,                       List<IndexEventListener> builtInIndexListener) throws IOException_;1535405719;Creates a new {@link IndexService} for the given metadata.__@param indexMetaData          the index metadata to create the index for_@param builtInIndexListener   a list of built-in lifecycle {@link IndexEventListener} that should should be used along side with_the per-index listeners_@throws ResourceAlreadyExistsException if the index already exists.;U createIndex(IndexMetaData indexMetaData,_                      List<IndexEventListener> builtInIndexListener) throws IOException_;creates,a,new,link,index,service,for,the,given,metadata,param,index,meta,data,the,index,metadata,to,create,the,index,for,param,built,in,index,listener,a,list,of,built,in,lifecycle,link,index,event,listener,that,should,should,be,used,along,side,with,the,per,index,listeners,throws,resource,already,exists,exception,if,the,index,already,exists;u,create,index,index,meta,data,index,meta,data,list,index,event,listener,built,in,index,listener,throws,ioexception
IndicesClusterStateService -> AllocatedIndices -> U createIndex(IndexMetaData indexMetaData,                       List<IndexEventListener> builtInIndexListener) throws IOException_;1539723533;Creates a new {@link IndexService} for the given metadata.__@param indexMetaData          the index metadata to create the index for_@param builtInIndexListener   a list of built-in lifecycle {@link IndexEventListener} that should should be used along side with_the per-index listeners_@throws ResourceAlreadyExistsException if the index already exists.;U createIndex(IndexMetaData indexMetaData,_                      List<IndexEventListener> builtInIndexListener) throws IOException_;creates,a,new,link,index,service,for,the,given,metadata,param,index,meta,data,the,index,metadata,to,create,the,index,for,param,built,in,index,listener,a,list,of,built,in,lifecycle,link,index,event,listener,that,should,should,be,used,along,side,with,the,per,index,listeners,throws,resource,already,exists,exception,if,the,index,already,exists;u,create,index,index,meta,data,index,meta,data,list,index,event,listener,built,in,index,listener,throws,ioexception
IndicesClusterStateService -> AllocatedIndices -> U createIndex(IndexMetaData indexMetaData,                       List<IndexEventListener> builtInIndexListener) throws IOException_;1541008027;Creates a new {@link IndexService} for the given metadata.__@param indexMetaData          the index metadata to create the index for_@param builtInIndexListener   a list of built-in lifecycle {@link IndexEventListener} that should should be used along side with_the per-index listeners_@throws ResourceAlreadyExistsException if the index already exists.;U createIndex(IndexMetaData indexMetaData,_                      List<IndexEventListener> builtInIndexListener) throws IOException_;creates,a,new,link,index,service,for,the,given,metadata,param,index,meta,data,the,index,metadata,to,create,the,index,for,param,built,in,index,listener,a,list,of,built,in,lifecycle,link,index,event,listener,that,should,should,be,used,along,side,with,the,per,index,listeners,throws,resource,already,exists,exception,if,the,index,already,exists;u,create,index,index,meta,data,index,meta,data,list,index,event,listener,built,in,index,listener,throws,ioexception
IndicesClusterStateService -> AllocatedIndices -> U createIndex(IndexMetaData indexMetaData,                       List<IndexEventListener> builtInIndexListener) throws IOException_;1542646292;Creates a new {@link IndexService} for the given metadata.__@param indexMetaData          the index metadata to create the index for_@param builtInIndexListener   a list of built-in lifecycle {@link IndexEventListener} that should should be used along side with_the per-index listeners_@throws ResourceAlreadyExistsException if the index already exists.;U createIndex(IndexMetaData indexMetaData,_                      List<IndexEventListener> builtInIndexListener) throws IOException_;creates,a,new,link,index,service,for,the,given,metadata,param,index,meta,data,the,index,metadata,to,create,the,index,for,param,built,in,index,listener,a,list,of,built,in,lifecycle,link,index,event,listener,that,should,should,be,used,along,side,with,the,per,index,listeners,throws,resource,already,exists,exception,if,the,index,already,exists;u,create,index,index,meta,data,index,meta,data,list,index,event,listener,built,in,index,listener,throws,ioexception
IndicesClusterStateService -> AllocatedIndices -> U createIndex(IndexMetaData indexMetaData,                       List<IndexEventListener> builtInIndexListener) throws IOException_;1547520324;Creates a new {@link IndexService} for the given metadata.__@param indexMetaData          the index metadata to create the index for_@param builtInIndexListener   a list of built-in lifecycle {@link IndexEventListener} that should should be used along side with_the per-index listeners_@throws ResourceAlreadyExistsException if the index already exists.;U createIndex(IndexMetaData indexMetaData,_                      List<IndexEventListener> builtInIndexListener) throws IOException_;creates,a,new,link,index,service,for,the,given,metadata,param,index,meta,data,the,index,metadata,to,create,the,index,for,param,built,in,index,listener,a,list,of,built,in,lifecycle,link,index,event,listener,that,should,should,be,used,along,side,with,the,per,index,listeners,throws,resource,already,exists,exception,if,the,index,already,exists;u,create,index,index,meta,data,index,meta,data,list,index,event,listener,built,in,index,listener,throws,ioexception
IndicesClusterStateService -> AllocatedIndices -> U createIndex(IndexMetaData indexMetaData,                       List<IndexEventListener> builtInIndexListener) throws IOException_;1547536822;Creates a new {@link IndexService} for the given metadata.__@param indexMetaData          the index metadata to create the index for_@param builtInIndexListener   a list of built-in lifecycle {@link IndexEventListener} that should should be used along side with_the per-index listeners_@throws ResourceAlreadyExistsException if the index already exists.;U createIndex(IndexMetaData indexMetaData,_                      List<IndexEventListener> builtInIndexListener) throws IOException_;creates,a,new,link,index,service,for,the,given,metadata,param,index,meta,data,the,index,metadata,to,create,the,index,for,param,built,in,index,listener,a,list,of,built,in,lifecycle,link,index,event,listener,that,should,should,be,used,along,side,with,the,per,index,listeners,throws,resource,already,exists,exception,if,the,index,already,exists;u,create,index,index,meta,data,index,meta,data,list,index,event,listener,built,in,index,listener,throws,ioexception
IndicesClusterStateService -> AllocatedIndices -> U createIndex(IndexMetaData indexMetaData,                       List<IndexEventListener> builtInIndexListener) throws IOException_;1547625930;Creates a new {@link IndexService} for the given metadata.__@param indexMetaData          the index metadata to create the index for_@param builtInIndexListener   a list of built-in lifecycle {@link IndexEventListener} that should should be used along side with_the per-index listeners_@throws ResourceAlreadyExistsException if the index already exists.;U createIndex(IndexMetaData indexMetaData,_                      List<IndexEventListener> builtInIndexListener) throws IOException_;creates,a,new,link,index,service,for,the,given,metadata,param,index,meta,data,the,index,metadata,to,create,the,index,for,param,built,in,index,listener,a,list,of,built,in,lifecycle,link,index,event,listener,that,should,should,be,used,along,side,with,the,per,index,listeners,throws,resource,already,exists,exception,if,the,index,already,exists;u,create,index,index,meta,data,index,meta,data,list,index,event,listener,built,in,index,listener,throws,ioexception
IndicesClusterStateService -> AllocatedIndices -> U createIndex(IndexMetaData indexMetaData,                       List<IndexEventListener> builtInIndexListener) throws IOException_;1548593396;Creates a new {@link IndexService} for the given metadata.__@param indexMetaData          the index metadata to create the index for_@param builtInIndexListener   a list of built-in lifecycle {@link IndexEventListener} that should should be used along side with_the per-index listeners_@throws ResourceAlreadyExistsException if the index already exists.;U createIndex(IndexMetaData indexMetaData,_                      List<IndexEventListener> builtInIndexListener) throws IOException_;creates,a,new,link,index,service,for,the,given,metadata,param,index,meta,data,the,index,metadata,to,create,the,index,for,param,built,in,index,listener,a,list,of,built,in,lifecycle,link,index,event,listener,that,should,should,be,used,along,side,with,the,per,index,listeners,throws,resource,already,exists,exception,if,the,index,already,exists;u,create,index,index,meta,data,index,meta,data,list,index,event,listener,built,in,index,listener,throws,ioexception
IndicesClusterStateService -> AllocatedIndices -> U createIndex(IndexMetaData indexMetaData,                       List<IndexEventListener> builtInIndexListener) throws IOException_;1548770980;Creates a new {@link IndexService} for the given metadata.__@param indexMetaData          the index metadata to create the index for_@param builtInIndexListener   a list of built-in lifecycle {@link IndexEventListener} that should should be used along side with_the per-index listeners_@throws ResourceAlreadyExistsException if the index already exists.;U createIndex(IndexMetaData indexMetaData,_                      List<IndexEventListener> builtInIndexListener) throws IOException_;creates,a,new,link,index,service,for,the,given,metadata,param,index,meta,data,the,index,metadata,to,create,the,index,for,param,built,in,index,listener,a,list,of,built,in,lifecycle,link,index,event,listener,that,should,should,be,used,along,side,with,the,per,index,listeners,throws,resource,already,exists,exception,if,the,index,already,exists;u,create,index,index,meta,data,index,meta,data,list,index,event,listener,built,in,index,listener,throws,ioexception
IndicesClusterStateService -> AllocatedIndices -> U createIndex(IndexMetaData indexMetaData,                       List<IndexEventListener> builtInIndexListener) throws IOException_;1548872469;Creates a new {@link IndexService} for the given metadata.__@param indexMetaData          the index metadata to create the index for_@param builtInIndexListener   a list of built-in lifecycle {@link IndexEventListener} that should should be used along side with_the per-index listeners_@throws ResourceAlreadyExistsException if the index already exists.;U createIndex(IndexMetaData indexMetaData,_                      List<IndexEventListener> builtInIndexListener) throws IOException_;creates,a,new,link,index,service,for,the,given,metadata,param,index,meta,data,the,index,metadata,to,create,the,index,for,param,built,in,index,listener,a,list,of,built,in,lifecycle,link,index,event,listener,that,should,should,be,used,along,side,with,the,per,index,listeners,throws,resource,already,exists,exception,if,the,index,already,exists;u,create,index,index,meta,data,index,meta,data,list,index,event,listener,built,in,index,listener,throws,ioexception
IndicesClusterStateService -> AllocatedIndices -> U createIndex(IndexMetaData indexMetaData,                       List<IndexEventListener> builtInIndexListener) throws IOException_;1549294529;Creates a new {@link IndexService} for the given metadata.__@param indexMetaData          the index metadata to create the index for_@param builtInIndexListener   a list of built-in lifecycle {@link IndexEventListener} that should should be used along side with_the per-index listeners_@throws ResourceAlreadyExistsException if the index already exists.;U createIndex(IndexMetaData indexMetaData,_                      List<IndexEventListener> builtInIndexListener) throws IOException_;creates,a,new,link,index,service,for,the,given,metadata,param,index,meta,data,the,index,metadata,to,create,the,index,for,param,built,in,index,listener,a,list,of,built,in,lifecycle,link,index,event,listener,that,should,should,be,used,along,side,with,the,per,index,listeners,throws,resource,already,exists,exception,if,the,index,already,exists;u,create,index,index,meta,data,index,meta,data,list,index,event,listener,built,in,index,listener,throws,ioexception
IndicesClusterStateService -> private void updateFailedShardsCache(final ClusterState state);1524684173;Removes shard entries from the failed shards cache that are no longer allocated to this node by the master._Sends shard failures for shards that are marked as actively allocated to this node but don't actually exist on the node._Resends shard failures for shards that are still marked as allocated to this node but previously failed.__@param state new cluster state;private void updateFailedShardsCache(final ClusterState state) {_        RoutingNode localRoutingNode = state.getRoutingNodes().node(state.nodes().getLocalNodeId())__        if (localRoutingNode == null) {_            failedShardsCache.clear()__            return__        }__        DiscoveryNode masterNode = state.nodes().getMasterNode()___        _        for (Iterator<Map.Entry<ShardId, ShardRouting>> iterator = failedShardsCache.entrySet().iterator()_ iterator.hasNext()_ ) {_            ShardRouting failedShardRouting = iterator.next().getValue()__            ShardRouting matchedRouting = localRoutingNode.getByShardId(failedShardRouting.shardId())__            if (matchedRouting == null || matchedRouting.isSameAllocation(failedShardRouting) == false) {_                iterator.remove()__            } else {_                if (masterNode != null) { _                    String message = "master " + masterNode + " has not removed previously failed shard. resending shard failure"__                    logger.trace("[{}] re-sending failed shard [{}], reason [{}]", matchedRouting.shardId(), matchedRouting, message)__                    shardStateAction.localShardFailed(matchedRouting, message, null, SHARD_STATE_ACTION_LISTENER, state)__                }_            }_        }_    };removes,shard,entries,from,the,failed,shards,cache,that,are,no,longer,allocated,to,this,node,by,the,master,sends,shard,failures,for,shards,that,are,marked,as,actively,allocated,to,this,node,but,don,t,actually,exist,on,the,node,resends,shard,failures,for,shards,that,are,still,marked,as,allocated,to,this,node,but,previously,failed,param,state,new,cluster,state;private,void,update,failed,shards,cache,final,cluster,state,state,routing,node,local,routing,node,state,get,routing,nodes,node,state,nodes,get,local,node,id,if,local,routing,node,null,failed,shards,cache,clear,return,discovery,node,master,node,state,nodes,get,master,node,for,iterator,map,entry,shard,id,shard,routing,iterator,failed,shards,cache,entry,set,iterator,iterator,has,next,shard,routing,failed,shard,routing,iterator,next,get,value,shard,routing,matched,routing,local,routing,node,get,by,shard,id,failed,shard,routing,shard,id,if,matched,routing,null,matched,routing,is,same,allocation,failed,shard,routing,false,iterator,remove,else,if,master,node,null,string,message,master,master,node,has,not,removed,previously,failed,shard,resending,shard,failure,logger,trace,re,sending,failed,shard,reason,matched,routing,shard,id,matched,routing,message,shard,state,action,local,shard,failed,matched,routing,message,null,state
IndicesClusterStateService -> private void updateFailedShardsCache(final ClusterState state);1533063033;Removes shard entries from the failed shards cache that are no longer allocated to this node by the master._Sends shard failures for shards that are marked as actively allocated to this node but don't actually exist on the node._Resends shard failures for shards that are still marked as allocated to this node but previously failed.__@param state new cluster state;private void updateFailedShardsCache(final ClusterState state) {_        RoutingNode localRoutingNode = state.getRoutingNodes().node(state.nodes().getLocalNodeId())__        if (localRoutingNode == null) {_            failedShardsCache.clear()__            return__        }__        DiscoveryNode masterNode = state.nodes().getMasterNode()___        _        for (Iterator<Map.Entry<ShardId, ShardRouting>> iterator = failedShardsCache.entrySet().iterator()_ iterator.hasNext()_ ) {_            ShardRouting failedShardRouting = iterator.next().getValue()__            ShardRouting matchedRouting = localRoutingNode.getByShardId(failedShardRouting.shardId())__            if (matchedRouting == null || matchedRouting.isSameAllocation(failedShardRouting) == false) {_                iterator.remove()__            } else {_                if (masterNode != null) { _                    String message = "master " + masterNode + " has not removed previously failed shard. resending shard failure"__                    logger.trace("[{}] re-sending failed shard [{}], reason [{}]", matchedRouting.shardId(), matchedRouting, message)__                    shardStateAction.localShardFailed(matchedRouting, message, null, SHARD_STATE_ACTION_LISTENER, state)__                }_            }_        }_    };removes,shard,entries,from,the,failed,shards,cache,that,are,no,longer,allocated,to,this,node,by,the,master,sends,shard,failures,for,shards,that,are,marked,as,actively,allocated,to,this,node,but,don,t,actually,exist,on,the,node,resends,shard,failures,for,shards,that,are,still,marked,as,allocated,to,this,node,but,previously,failed,param,state,new,cluster,state;private,void,update,failed,shards,cache,final,cluster,state,state,routing,node,local,routing,node,state,get,routing,nodes,node,state,nodes,get,local,node,id,if,local,routing,node,null,failed,shards,cache,clear,return,discovery,node,master,node,state,nodes,get,master,node,for,iterator,map,entry,shard,id,shard,routing,iterator,failed,shards,cache,entry,set,iterator,iterator,has,next,shard,routing,failed,shard,routing,iterator,next,get,value,shard,routing,matched,routing,local,routing,node,get,by,shard,id,failed,shard,routing,shard,id,if,matched,routing,null,matched,routing,is,same,allocation,failed,shard,routing,false,iterator,remove,else,if,master,node,null,string,message,master,master,node,has,not,removed,previously,failed,shard,resending,shard,failure,logger,trace,re,sending,failed,shard,reason,matched,routing,shard,id,matched,routing,message,shard,state,action,local,shard,failed,matched,routing,message,null,state
IndicesClusterStateService -> private void updateFailedShardsCache(final ClusterState state);1535405719;Removes shard entries from the failed shards cache that are no longer allocated to this node by the master._Sends shard failures for shards that are marked as actively allocated to this node but don't actually exist on the node._Resends shard failures for shards that are still marked as allocated to this node but previously failed.__@param state new cluster state;private void updateFailedShardsCache(final ClusterState state) {_        RoutingNode localRoutingNode = state.getRoutingNodes().node(state.nodes().getLocalNodeId())__        if (localRoutingNode == null) {_            failedShardsCache.clear()__            return__        }__        DiscoveryNode masterNode = state.nodes().getMasterNode()___        _        for (Iterator<Map.Entry<ShardId, ShardRouting>> iterator = failedShardsCache.entrySet().iterator()_ iterator.hasNext()_ ) {_            ShardRouting failedShardRouting = iterator.next().getValue()__            ShardRouting matchedRouting = localRoutingNode.getByShardId(failedShardRouting.shardId())__            if (matchedRouting == null || matchedRouting.isSameAllocation(failedShardRouting) == false) {_                iterator.remove()__            } else {_                if (masterNode != null) { _                    String message = "master " + masterNode + " has not removed previously failed shard. resending shard failure"__                    logger.trace("[{}] re-sending failed shard [{}], reason [{}]", matchedRouting.shardId(), matchedRouting, message)__                    shardStateAction.localShardFailed(matchedRouting, message, null, SHARD_STATE_ACTION_LISTENER, state)__                }_            }_        }_    };removes,shard,entries,from,the,failed,shards,cache,that,are,no,longer,allocated,to,this,node,by,the,master,sends,shard,failures,for,shards,that,are,marked,as,actively,allocated,to,this,node,but,don,t,actually,exist,on,the,node,resends,shard,failures,for,shards,that,are,still,marked,as,allocated,to,this,node,but,previously,failed,param,state,new,cluster,state;private,void,update,failed,shards,cache,final,cluster,state,state,routing,node,local,routing,node,state,get,routing,nodes,node,state,nodes,get,local,node,id,if,local,routing,node,null,failed,shards,cache,clear,return,discovery,node,master,node,state,nodes,get,master,node,for,iterator,map,entry,shard,id,shard,routing,iterator,failed,shards,cache,entry,set,iterator,iterator,has,next,shard,routing,failed,shard,routing,iterator,next,get,value,shard,routing,matched,routing,local,routing,node,get,by,shard,id,failed,shard,routing,shard,id,if,matched,routing,null,matched,routing,is,same,allocation,failed,shard,routing,false,iterator,remove,else,if,master,node,null,string,message,master,master,node,has,not,removed,previously,failed,shard,resending,shard,failure,logger,trace,re,sending,failed,shard,reason,matched,routing,shard,id,matched,routing,message,shard,state,action,local,shard,failed,matched,routing,message,null,state
IndicesClusterStateService -> private void updateFailedShardsCache(final ClusterState state);1539723533;Removes shard entries from the failed shards cache that are no longer allocated to this node by the master._Sends shard failures for shards that are marked as actively allocated to this node but don't actually exist on the node._Resends shard failures for shards that are still marked as allocated to this node but previously failed.__@param state new cluster state;private void updateFailedShardsCache(final ClusterState state) {_        RoutingNode localRoutingNode = state.getRoutingNodes().node(state.nodes().getLocalNodeId())__        if (localRoutingNode == null) {_            failedShardsCache.clear()__            return__        }__        DiscoveryNode masterNode = state.nodes().getMasterNode()___        _        for (Iterator<Map.Entry<ShardId, ShardRouting>> iterator = failedShardsCache.entrySet().iterator()_ iterator.hasNext()_ ) {_            ShardRouting failedShardRouting = iterator.next().getValue()__            ShardRouting matchedRouting = localRoutingNode.getByShardId(failedShardRouting.shardId())__            if (matchedRouting == null || matchedRouting.isSameAllocation(failedShardRouting) == false) {_                iterator.remove()__            } else {_                if (masterNode != null) { _                    String message = "master " + masterNode + " has not removed previously failed shard. resending shard failure"__                    logger.trace("[{}] re-sending failed shard [{}], reason [{}]", matchedRouting.shardId(), matchedRouting, message)__                    shardStateAction.localShardFailed(matchedRouting, message, null, SHARD_STATE_ACTION_LISTENER, state)__                }_            }_        }_    };removes,shard,entries,from,the,failed,shards,cache,that,are,no,longer,allocated,to,this,node,by,the,master,sends,shard,failures,for,shards,that,are,marked,as,actively,allocated,to,this,node,but,don,t,actually,exist,on,the,node,resends,shard,failures,for,shards,that,are,still,marked,as,allocated,to,this,node,but,previously,failed,param,state,new,cluster,state;private,void,update,failed,shards,cache,final,cluster,state,state,routing,node,local,routing,node,state,get,routing,nodes,node,state,nodes,get,local,node,id,if,local,routing,node,null,failed,shards,cache,clear,return,discovery,node,master,node,state,nodes,get,master,node,for,iterator,map,entry,shard,id,shard,routing,iterator,failed,shards,cache,entry,set,iterator,iterator,has,next,shard,routing,failed,shard,routing,iterator,next,get,value,shard,routing,matched,routing,local,routing,node,get,by,shard,id,failed,shard,routing,shard,id,if,matched,routing,null,matched,routing,is,same,allocation,failed,shard,routing,false,iterator,remove,else,if,master,node,null,string,message,master,master,node,has,not,removed,previously,failed,shard,resending,shard,failure,logger,trace,re,sending,failed,shard,reason,matched,routing,shard,id,matched,routing,message,shard,state,action,local,shard,failed,matched,routing,message,null,state
IndicesClusterStateService -> private void updateFailedShardsCache(final ClusterState state);1541008027;Removes shard entries from the failed shards cache that are no longer allocated to this node by the master._Sends shard failures for shards that are marked as actively allocated to this node but don't actually exist on the node._Resends shard failures for shards that are still marked as allocated to this node but previously failed.__@param state new cluster state;private void updateFailedShardsCache(final ClusterState state) {_        RoutingNode localRoutingNode = state.getRoutingNodes().node(state.nodes().getLocalNodeId())__        if (localRoutingNode == null) {_            failedShardsCache.clear()__            return__        }__        DiscoveryNode masterNode = state.nodes().getMasterNode()___        _        for (Iterator<Map.Entry<ShardId, ShardRouting>> iterator = failedShardsCache.entrySet().iterator()_ iterator.hasNext()_ ) {_            ShardRouting failedShardRouting = iterator.next().getValue()__            ShardRouting matchedRouting = localRoutingNode.getByShardId(failedShardRouting.shardId())__            if (matchedRouting == null || matchedRouting.isSameAllocation(failedShardRouting) == false) {_                iterator.remove()__            } else {_                if (masterNode != null) { _                    String message = "master " + masterNode + " has not removed previously failed shard. resending shard failure"__                    logger.trace("[{}] re-sending failed shard [{}], reason [{}]", matchedRouting.shardId(), matchedRouting, message)__                    shardStateAction.localShardFailed(matchedRouting, message, null, SHARD_STATE_ACTION_LISTENER, state)__                }_            }_        }_    };removes,shard,entries,from,the,failed,shards,cache,that,are,no,longer,allocated,to,this,node,by,the,master,sends,shard,failures,for,shards,that,are,marked,as,actively,allocated,to,this,node,but,don,t,actually,exist,on,the,node,resends,shard,failures,for,shards,that,are,still,marked,as,allocated,to,this,node,but,previously,failed,param,state,new,cluster,state;private,void,update,failed,shards,cache,final,cluster,state,state,routing,node,local,routing,node,state,get,routing,nodes,node,state,nodes,get,local,node,id,if,local,routing,node,null,failed,shards,cache,clear,return,discovery,node,master,node,state,nodes,get,master,node,for,iterator,map,entry,shard,id,shard,routing,iterator,failed,shards,cache,entry,set,iterator,iterator,has,next,shard,routing,failed,shard,routing,iterator,next,get,value,shard,routing,matched,routing,local,routing,node,get,by,shard,id,failed,shard,routing,shard,id,if,matched,routing,null,matched,routing,is,same,allocation,failed,shard,routing,false,iterator,remove,else,if,master,node,null,string,message,master,master,node,has,not,removed,previously,failed,shard,resending,shard,failure,logger,trace,re,sending,failed,shard,reason,matched,routing,shard,id,matched,routing,message,shard,state,action,local,shard,failed,matched,routing,message,null,state
IndicesClusterStateService -> private void updateFailedShardsCache(final ClusterState state);1542646292;Removes shard entries from the failed shards cache that are no longer allocated to this node by the master._Sends shard failures for shards that are marked as actively allocated to this node but don't actually exist on the node._Resends shard failures for shards that are still marked as allocated to this node but previously failed.__@param state new cluster state;private void updateFailedShardsCache(final ClusterState state) {_        RoutingNode localRoutingNode = state.getRoutingNodes().node(state.nodes().getLocalNodeId())__        if (localRoutingNode == null) {_            failedShardsCache.clear()__            return__        }__        DiscoveryNode masterNode = state.nodes().getMasterNode()___        _        for (Iterator<Map.Entry<ShardId, ShardRouting>> iterator = failedShardsCache.entrySet().iterator()_ iterator.hasNext()_ ) {_            ShardRouting failedShardRouting = iterator.next().getValue()__            ShardRouting matchedRouting = localRoutingNode.getByShardId(failedShardRouting.shardId())__            if (matchedRouting == null || matchedRouting.isSameAllocation(failedShardRouting) == false) {_                iterator.remove()__            } else {_                if (masterNode != null) { _                    String message = "master " + masterNode + " has not removed previously failed shard. resending shard failure"__                    logger.trace("[{}] re-sending failed shard [{}], reason [{}]", matchedRouting.shardId(), matchedRouting, message)__                    shardStateAction.localShardFailed(matchedRouting, message, null, SHARD_STATE_ACTION_LISTENER, state)__                }_            }_        }_    };removes,shard,entries,from,the,failed,shards,cache,that,are,no,longer,allocated,to,this,node,by,the,master,sends,shard,failures,for,shards,that,are,marked,as,actively,allocated,to,this,node,but,don,t,actually,exist,on,the,node,resends,shard,failures,for,shards,that,are,still,marked,as,allocated,to,this,node,but,previously,failed,param,state,new,cluster,state;private,void,update,failed,shards,cache,final,cluster,state,state,routing,node,local,routing,node,state,get,routing,nodes,node,state,nodes,get,local,node,id,if,local,routing,node,null,failed,shards,cache,clear,return,discovery,node,master,node,state,nodes,get,master,node,for,iterator,map,entry,shard,id,shard,routing,iterator,failed,shards,cache,entry,set,iterator,iterator,has,next,shard,routing,failed,shard,routing,iterator,next,get,value,shard,routing,matched,routing,local,routing,node,get,by,shard,id,failed,shard,routing,shard,id,if,matched,routing,null,matched,routing,is,same,allocation,failed,shard,routing,false,iterator,remove,else,if,master,node,null,string,message,master,master,node,has,not,removed,previously,failed,shard,resending,shard,failure,logger,trace,re,sending,failed,shard,reason,matched,routing,shard,id,matched,routing,message,shard,state,action,local,shard,failed,matched,routing,message,null,state
IndicesClusterStateService -> private void updateFailedShardsCache(final ClusterState state);1547520324;Removes shard entries from the failed shards cache that are no longer allocated to this node by the master._Sends shard failures for shards that are marked as actively allocated to this node but don't actually exist on the node._Resends shard failures for shards that are still marked as allocated to this node but previously failed.__@param state new cluster state;private void updateFailedShardsCache(final ClusterState state) {_        RoutingNode localRoutingNode = state.getRoutingNodes().node(state.nodes().getLocalNodeId())__        if (localRoutingNode == null) {_            failedShardsCache.clear()__            return__        }__        DiscoveryNode masterNode = state.nodes().getMasterNode()___        _        for (Iterator<Map.Entry<ShardId, ShardRouting>> iterator = failedShardsCache.entrySet().iterator()_ iterator.hasNext()_ ) {_            ShardRouting failedShardRouting = iterator.next().getValue()__            ShardRouting matchedRouting = localRoutingNode.getByShardId(failedShardRouting.shardId())__            if (matchedRouting == null || matchedRouting.isSameAllocation(failedShardRouting) == false) {_                iterator.remove()__            } else {_                if (masterNode != null) { _                    String message = "master " + masterNode + " has not removed previously failed shard. resending shard failure"__                    logger.trace("[{}] re-sending failed shard [{}], reason [{}]", matchedRouting.shardId(), matchedRouting, message)__                    shardStateAction.localShardFailed(matchedRouting, message, null, SHARD_STATE_ACTION_LISTENER, state)__                }_            }_        }_    };removes,shard,entries,from,the,failed,shards,cache,that,are,no,longer,allocated,to,this,node,by,the,master,sends,shard,failures,for,shards,that,are,marked,as,actively,allocated,to,this,node,but,don,t,actually,exist,on,the,node,resends,shard,failures,for,shards,that,are,still,marked,as,allocated,to,this,node,but,previously,failed,param,state,new,cluster,state;private,void,update,failed,shards,cache,final,cluster,state,state,routing,node,local,routing,node,state,get,routing,nodes,node,state,nodes,get,local,node,id,if,local,routing,node,null,failed,shards,cache,clear,return,discovery,node,master,node,state,nodes,get,master,node,for,iterator,map,entry,shard,id,shard,routing,iterator,failed,shards,cache,entry,set,iterator,iterator,has,next,shard,routing,failed,shard,routing,iterator,next,get,value,shard,routing,matched,routing,local,routing,node,get,by,shard,id,failed,shard,routing,shard,id,if,matched,routing,null,matched,routing,is,same,allocation,failed,shard,routing,false,iterator,remove,else,if,master,node,null,string,message,master,master,node,has,not,removed,previously,failed,shard,resending,shard,failure,logger,trace,re,sending,failed,shard,reason,matched,routing,shard,id,matched,routing,message,shard,state,action,local,shard,failed,matched,routing,message,null,state
IndicesClusterStateService -> private void updateFailedShardsCache(final ClusterState state);1547536822;Removes shard entries from the failed shards cache that are no longer allocated to this node by the master._Sends shard failures for shards that are marked as actively allocated to this node but don't actually exist on the node._Resends shard failures for shards that are still marked as allocated to this node but previously failed.__@param state new cluster state;private void updateFailedShardsCache(final ClusterState state) {_        RoutingNode localRoutingNode = state.getRoutingNodes().node(state.nodes().getLocalNodeId())__        if (localRoutingNode == null) {_            failedShardsCache.clear()__            return__        }__        DiscoveryNode masterNode = state.nodes().getMasterNode()___        _        for (Iterator<Map.Entry<ShardId, ShardRouting>> iterator = failedShardsCache.entrySet().iterator()_ iterator.hasNext()_ ) {_            ShardRouting failedShardRouting = iterator.next().getValue()__            ShardRouting matchedRouting = localRoutingNode.getByShardId(failedShardRouting.shardId())__            if (matchedRouting == null || matchedRouting.isSameAllocation(failedShardRouting) == false) {_                iterator.remove()__            } else {_                if (masterNode != null) { _                    String message = "master " + masterNode + " has not removed previously failed shard. resending shard failure"__                    logger.trace("[{}] re-sending failed shard [{}], reason [{}]", matchedRouting.shardId(), matchedRouting, message)__                    shardStateAction.localShardFailed(matchedRouting, message, null, SHARD_STATE_ACTION_LISTENER, state)__                }_            }_        }_    };removes,shard,entries,from,the,failed,shards,cache,that,are,no,longer,allocated,to,this,node,by,the,master,sends,shard,failures,for,shards,that,are,marked,as,actively,allocated,to,this,node,but,don,t,actually,exist,on,the,node,resends,shard,failures,for,shards,that,are,still,marked,as,allocated,to,this,node,but,previously,failed,param,state,new,cluster,state;private,void,update,failed,shards,cache,final,cluster,state,state,routing,node,local,routing,node,state,get,routing,nodes,node,state,nodes,get,local,node,id,if,local,routing,node,null,failed,shards,cache,clear,return,discovery,node,master,node,state,nodes,get,master,node,for,iterator,map,entry,shard,id,shard,routing,iterator,failed,shards,cache,entry,set,iterator,iterator,has,next,shard,routing,failed,shard,routing,iterator,next,get,value,shard,routing,matched,routing,local,routing,node,get,by,shard,id,failed,shard,routing,shard,id,if,matched,routing,null,matched,routing,is,same,allocation,failed,shard,routing,false,iterator,remove,else,if,master,node,null,string,message,master,master,node,has,not,removed,previously,failed,shard,resending,shard,failure,logger,trace,re,sending,failed,shard,reason,matched,routing,shard,id,matched,routing,message,shard,state,action,local,shard,failed,matched,routing,message,null,state
IndicesClusterStateService -> private void updateFailedShardsCache(final ClusterState state);1547625930;Removes shard entries from the failed shards cache that are no longer allocated to this node by the master._Sends shard failures for shards that are marked as actively allocated to this node but don't actually exist on the node._Resends shard failures for shards that are still marked as allocated to this node but previously failed.__@param state new cluster state;private void updateFailedShardsCache(final ClusterState state) {_        RoutingNode localRoutingNode = state.getRoutingNodes().node(state.nodes().getLocalNodeId())__        if (localRoutingNode == null) {_            failedShardsCache.clear()__            return__        }__        DiscoveryNode masterNode = state.nodes().getMasterNode()___        _        for (Iterator<Map.Entry<ShardId, ShardRouting>> iterator = failedShardsCache.entrySet().iterator()_ iterator.hasNext()_ ) {_            ShardRouting failedShardRouting = iterator.next().getValue()__            ShardRouting matchedRouting = localRoutingNode.getByShardId(failedShardRouting.shardId())__            if (matchedRouting == null || matchedRouting.isSameAllocation(failedShardRouting) == false) {_                iterator.remove()__            } else {_                if (masterNode != null) { _                    String message = "master " + masterNode + " has not removed previously failed shard. resending shard failure"__                    logger.trace("[{}] re-sending failed shard [{}], reason [{}]", matchedRouting.shardId(), matchedRouting, message)__                    shardStateAction.localShardFailed(matchedRouting, message, null, SHARD_STATE_ACTION_LISTENER, state)__                }_            }_        }_    };removes,shard,entries,from,the,failed,shards,cache,that,are,no,longer,allocated,to,this,node,by,the,master,sends,shard,failures,for,shards,that,are,marked,as,actively,allocated,to,this,node,but,don,t,actually,exist,on,the,node,resends,shard,failures,for,shards,that,are,still,marked,as,allocated,to,this,node,but,previously,failed,param,state,new,cluster,state;private,void,update,failed,shards,cache,final,cluster,state,state,routing,node,local,routing,node,state,get,routing,nodes,node,state,nodes,get,local,node,id,if,local,routing,node,null,failed,shards,cache,clear,return,discovery,node,master,node,state,nodes,get,master,node,for,iterator,map,entry,shard,id,shard,routing,iterator,failed,shards,cache,entry,set,iterator,iterator,has,next,shard,routing,failed,shard,routing,iterator,next,get,value,shard,routing,matched,routing,local,routing,node,get,by,shard,id,failed,shard,routing,shard,id,if,matched,routing,null,matched,routing,is,same,allocation,failed,shard,routing,false,iterator,remove,else,if,master,node,null,string,message,master,master,node,has,not,removed,previously,failed,shard,resending,shard,failure,logger,trace,re,sending,failed,shard,reason,matched,routing,shard,id,matched,routing,message,shard,state,action,local,shard,failed,matched,routing,message,null,state
IndicesClusterStateService -> private void updateFailedShardsCache(final ClusterState state);1548593396;Removes shard entries from the failed shards cache that are no longer allocated to this node by the master._Sends shard failures for shards that are marked as actively allocated to this node but don't actually exist on the node._Resends shard failures for shards that are still marked as allocated to this node but previously failed.__@param state new cluster state;private void updateFailedShardsCache(final ClusterState state) {_        RoutingNode localRoutingNode = state.getRoutingNodes().node(state.nodes().getLocalNodeId())__        if (localRoutingNode == null) {_            failedShardsCache.clear()__            return__        }__        DiscoveryNode masterNode = state.nodes().getMasterNode()___        _        for (Iterator<Map.Entry<ShardId, ShardRouting>> iterator = failedShardsCache.entrySet().iterator()_ iterator.hasNext()_ ) {_            ShardRouting failedShardRouting = iterator.next().getValue()__            ShardRouting matchedRouting = localRoutingNode.getByShardId(failedShardRouting.shardId())__            if (matchedRouting == null || matchedRouting.isSameAllocation(failedShardRouting) == false) {_                iterator.remove()__            } else {_                if (masterNode != null) { _                    String message = "master " + masterNode + " has not removed previously failed shard. resending shard failure"__                    logger.trace("[{}] re-sending failed shard [{}], reason [{}]", matchedRouting.shardId(), matchedRouting, message)__                    shardStateAction.localShardFailed(matchedRouting, message, null, SHARD_STATE_ACTION_LISTENER, state)__                }_            }_        }_    };removes,shard,entries,from,the,failed,shards,cache,that,are,no,longer,allocated,to,this,node,by,the,master,sends,shard,failures,for,shards,that,are,marked,as,actively,allocated,to,this,node,but,don,t,actually,exist,on,the,node,resends,shard,failures,for,shards,that,are,still,marked,as,allocated,to,this,node,but,previously,failed,param,state,new,cluster,state;private,void,update,failed,shards,cache,final,cluster,state,state,routing,node,local,routing,node,state,get,routing,nodes,node,state,nodes,get,local,node,id,if,local,routing,node,null,failed,shards,cache,clear,return,discovery,node,master,node,state,nodes,get,master,node,for,iterator,map,entry,shard,id,shard,routing,iterator,failed,shards,cache,entry,set,iterator,iterator,has,next,shard,routing,failed,shard,routing,iterator,next,get,value,shard,routing,matched,routing,local,routing,node,get,by,shard,id,failed,shard,routing,shard,id,if,matched,routing,null,matched,routing,is,same,allocation,failed,shard,routing,false,iterator,remove,else,if,master,node,null,string,message,master,master,node,has,not,removed,previously,failed,shard,resending,shard,failure,logger,trace,re,sending,failed,shard,reason,matched,routing,shard,id,matched,routing,message,shard,state,action,local,shard,failed,matched,routing,message,null,state
IndicesClusterStateService -> private void updateFailedShardsCache(final ClusterState state);1548770980;Removes shard entries from the failed shards cache that are no longer allocated to this node by the master._Sends shard failures for shards that are marked as actively allocated to this node but don't actually exist on the node._Resends shard failures for shards that are still marked as allocated to this node but previously failed.__@param state new cluster state;private void updateFailedShardsCache(final ClusterState state) {_        RoutingNode localRoutingNode = state.getRoutingNodes().node(state.nodes().getLocalNodeId())__        if (localRoutingNode == null) {_            failedShardsCache.clear()__            return__        }__        DiscoveryNode masterNode = state.nodes().getMasterNode()___        _        for (Iterator<Map.Entry<ShardId, ShardRouting>> iterator = failedShardsCache.entrySet().iterator()_ iterator.hasNext()_ ) {_            ShardRouting failedShardRouting = iterator.next().getValue()__            ShardRouting matchedRouting = localRoutingNode.getByShardId(failedShardRouting.shardId())__            if (matchedRouting == null || matchedRouting.isSameAllocation(failedShardRouting) == false) {_                iterator.remove()__            } else {_                if (masterNode != null) { _                    String message = "master " + masterNode + " has not removed previously failed shard. resending shard failure"__                    logger.trace("[{}] re-sending failed shard [{}], reason [{}]", matchedRouting.shardId(), matchedRouting, message)__                    shardStateAction.localShardFailed(matchedRouting, message, null, SHARD_STATE_ACTION_LISTENER, state)__                }_            }_        }_    };removes,shard,entries,from,the,failed,shards,cache,that,are,no,longer,allocated,to,this,node,by,the,master,sends,shard,failures,for,shards,that,are,marked,as,actively,allocated,to,this,node,but,don,t,actually,exist,on,the,node,resends,shard,failures,for,shards,that,are,still,marked,as,allocated,to,this,node,but,previously,failed,param,state,new,cluster,state;private,void,update,failed,shards,cache,final,cluster,state,state,routing,node,local,routing,node,state,get,routing,nodes,node,state,nodes,get,local,node,id,if,local,routing,node,null,failed,shards,cache,clear,return,discovery,node,master,node,state,nodes,get,master,node,for,iterator,map,entry,shard,id,shard,routing,iterator,failed,shards,cache,entry,set,iterator,iterator,has,next,shard,routing,failed,shard,routing,iterator,next,get,value,shard,routing,matched,routing,local,routing,node,get,by,shard,id,failed,shard,routing,shard,id,if,matched,routing,null,matched,routing,is,same,allocation,failed,shard,routing,false,iterator,remove,else,if,master,node,null,string,message,master,master,node,has,not,removed,previously,failed,shard,resending,shard,failure,logger,trace,re,sending,failed,shard,reason,matched,routing,shard,id,matched,routing,message,shard,state,action,local,shard,failed,matched,routing,message,null,state
IndicesClusterStateService -> private void updateFailedShardsCache(final ClusterState state);1548872469;Removes shard entries from the failed shards cache that are no longer allocated to this node by the master._Sends shard failures for shards that are marked as actively allocated to this node but don't actually exist on the node._Resends shard failures for shards that are still marked as allocated to this node but previously failed.__@param state new cluster state;private void updateFailedShardsCache(final ClusterState state) {_        RoutingNode localRoutingNode = state.getRoutingNodes().node(state.nodes().getLocalNodeId())__        if (localRoutingNode == null) {_            failedShardsCache.clear()__            return__        }__        DiscoveryNode masterNode = state.nodes().getMasterNode()___        _        for (Iterator<Map.Entry<ShardId, ShardRouting>> iterator = failedShardsCache.entrySet().iterator()_ iterator.hasNext()_ ) {_            ShardRouting failedShardRouting = iterator.next().getValue()__            ShardRouting matchedRouting = localRoutingNode.getByShardId(failedShardRouting.shardId())__            if (matchedRouting == null || matchedRouting.isSameAllocation(failedShardRouting) == false) {_                iterator.remove()__            } else {_                if (masterNode != null) { _                    String message = "master " + masterNode + " has not removed previously failed shard. resending shard failure"__                    logger.trace("[{}] re-sending failed shard [{}], reason [{}]", matchedRouting.shardId(), matchedRouting, message)__                    shardStateAction.localShardFailed(matchedRouting, message, null, SHARD_STATE_ACTION_LISTENER, state)__                }_            }_        }_    };removes,shard,entries,from,the,failed,shards,cache,that,are,no,longer,allocated,to,this,node,by,the,master,sends,shard,failures,for,shards,that,are,marked,as,actively,allocated,to,this,node,but,don,t,actually,exist,on,the,node,resends,shard,failures,for,shards,that,are,still,marked,as,allocated,to,this,node,but,previously,failed,param,state,new,cluster,state;private,void,update,failed,shards,cache,final,cluster,state,state,routing,node,local,routing,node,state,get,routing,nodes,node,state,nodes,get,local,node,id,if,local,routing,node,null,failed,shards,cache,clear,return,discovery,node,master,node,state,nodes,get,master,node,for,iterator,map,entry,shard,id,shard,routing,iterator,failed,shards,cache,entry,set,iterator,iterator,has,next,shard,routing,failed,shard,routing,iterator,next,get,value,shard,routing,matched,routing,local,routing,node,get,by,shard,id,failed,shard,routing,shard,id,if,matched,routing,null,matched,routing,is,same,allocation,failed,shard,routing,false,iterator,remove,else,if,master,node,null,string,message,master,master,node,has,not,removed,previously,failed,shard,resending,shard,failure,logger,trace,re,sending,failed,shard,reason,matched,routing,shard,id,matched,routing,message,shard,state,action,local,shard,failed,matched,routing,message,null,state
IndicesClusterStateService -> private void updateFailedShardsCache(final ClusterState state);1549294529;Removes shard entries from the failed shards cache that are no longer allocated to this node by the master._Sends shard failures for shards that are marked as actively allocated to this node but don't actually exist on the node._Resends shard failures for shards that are still marked as allocated to this node but previously failed.__@param state new cluster state;private void updateFailedShardsCache(final ClusterState state) {_        RoutingNode localRoutingNode = state.getRoutingNodes().node(state.nodes().getLocalNodeId())__        if (localRoutingNode == null) {_            failedShardsCache.clear()__            return__        }__        DiscoveryNode masterNode = state.nodes().getMasterNode()___        _        for (Iterator<Map.Entry<ShardId, ShardRouting>> iterator = failedShardsCache.entrySet().iterator()_ iterator.hasNext()_ ) {_            ShardRouting failedShardRouting = iterator.next().getValue()__            ShardRouting matchedRouting = localRoutingNode.getByShardId(failedShardRouting.shardId())__            if (matchedRouting == null || matchedRouting.isSameAllocation(failedShardRouting) == false) {_                iterator.remove()__            } else {_                if (masterNode != null) { _                    String message = "master " + masterNode + " has not removed previously failed shard. resending shard failure"__                    logger.trace("[{}] re-sending failed shard [{}], reason [{}]", matchedRouting.shardId(), matchedRouting, message)__                    shardStateAction.localShardFailed(matchedRouting, message, null, SHARD_STATE_ACTION_LISTENER, state)__                }_            }_        }_    };removes,shard,entries,from,the,failed,shards,cache,that,are,no,longer,allocated,to,this,node,by,the,master,sends,shard,failures,for,shards,that,are,marked,as,actively,allocated,to,this,node,but,don,t,actually,exist,on,the,node,resends,shard,failures,for,shards,that,are,still,marked,as,allocated,to,this,node,but,previously,failed,param,state,new,cluster,state;private,void,update,failed,shards,cache,final,cluster,state,state,routing,node,local,routing,node,state,get,routing,nodes,node,state,nodes,get,local,node,id,if,local,routing,node,null,failed,shards,cache,clear,return,discovery,node,master,node,state,nodes,get,master,node,for,iterator,map,entry,shard,id,shard,routing,iterator,failed,shards,cache,entry,set,iterator,iterator,has,next,shard,routing,failed,shard,routing,iterator,next,get,value,shard,routing,matched,routing,local,routing,node,get,by,shard,id,failed,shard,routing,shard,id,if,matched,routing,null,matched,routing,is,same,allocation,failed,shard,routing,false,iterator,remove,else,if,master,node,null,string,message,master,master,node,has,not,removed,previously,failed,shard,resending,shard,failure,logger,trace,re,sending,failed,shard,reason,matched,routing,shard,id,matched,routing,message,shard,state,action,local,shard,failed,matched,routing,message,null,state
IndicesClusterStateService -> private void deleteIndices(final ClusterChangedEvent event);1524684173;Deletes indices (with shard data).__@param event cluster change event;private void deleteIndices(final ClusterChangedEvent event) {_        final ClusterState previousState = event.previousState()__        final ClusterState state = event.state()__        final String localNodeId = state.nodes().getLocalNodeId()__        assert localNodeId != null___        for (Index index : event.indicesDeleted()) {_            if (logger.isDebugEnabled()) {_                logger.debug("[{}] cleaning index, no longer part of the metadata", index)__            }_            AllocatedIndex<? extends Shard> indexService = indicesService.indexService(index)__            final IndexSettings indexSettings__            if (indexService != null) {_                indexSettings = indexService.getIndexSettings()__                indicesService.removeIndex(index, DELETED, "index no longer part of the metadata")__            } else if (previousState.metaData().hasIndex(index.getName())) {_                _                final IndexMetaData metaData = previousState.metaData().index(index)__                indexSettings = new IndexSettings(metaData, settings)__                indicesService.deleteUnassignedIndex("deleted index was not assigned to local node", metaData, state)__            } else {_                _                _                _                _                _                _                assert previousState.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)__                final IndexMetaData metaData = indicesService.verifyIndexIsDeleted(index, event.state())__                if (metaData != null) {_                    indexSettings = new IndexSettings(metaData, settings)__                } else {_                    indexSettings = null__                }_            }_            if (indexSettings != null) {_                threadPool.generic().execute(new AbstractRunnable() {_                    @Override_                    public void onFailure(Exception e) {_                        logger.warn(() -> new ParameterizedMessage("[{}] failed to complete pending deletion for index", index), e)__                    }__                    @Override_                    protected void doRun() throws Exception {_                        try {_                            _                            _                            _                            _                            indicesService.processPendingDeletes(index, indexSettings, new TimeValue(30, TimeUnit.MINUTES))__                        } catch (LockObtainFailedException exc) {_                            logger.warn("[{}] failed to lock all shards for index - timed out after 30 seconds", index)__                        } catch (InterruptedException e) {_                            logger.warn("[{}] failed to lock all shards for index - interrupted", index)__                        }_                    }_                })__            }_        }_    };deletes,indices,with,shard,data,param,event,cluster,change,event;private,void,delete,indices,final,cluster,changed,event,event,final,cluster,state,previous,state,event,previous,state,final,cluster,state,state,event,state,final,string,local,node,id,state,nodes,get,local,node,id,assert,local,node,id,null,for,index,index,event,indices,deleted,if,logger,is,debug,enabled,logger,debug,cleaning,index,no,longer,part,of,the,metadata,index,allocated,index,extends,shard,index,service,indices,service,index,service,index,final,index,settings,index,settings,if,index,service,null,index,settings,index,service,get,index,settings,indices,service,remove,index,index,deleted,index,no,longer,part,of,the,metadata,else,if,previous,state,meta,data,has,index,index,get,name,final,index,meta,data,meta,data,previous,state,meta,data,index,index,index,settings,new,index,settings,meta,data,settings,indices,service,delete,unassigned,index,deleted,index,was,not,assigned,to,local,node,meta,data,state,else,assert,previous,state,blocks,has,global,block,gateway,service,final,index,meta,data,meta,data,indices,service,verify,index,is,deleted,index,event,state,if,meta,data,null,index,settings,new,index,settings,meta,data,settings,else,index,settings,null,if,index,settings,null,thread,pool,generic,execute,new,abstract,runnable,override,public,void,on,failure,exception,e,logger,warn,new,parameterized,message,failed,to,complete,pending,deletion,for,index,index,e,override,protected,void,do,run,throws,exception,try,indices,service,process,pending,deletes,index,index,settings,new,time,value,30,time,unit,minutes,catch,lock,obtain,failed,exception,exc,logger,warn,failed,to,lock,all,shards,for,index,timed,out,after,30,seconds,index,catch,interrupted,exception,e,logger,warn,failed,to,lock,all,shards,for,index,interrupted,index
IndicesClusterStateService -> private void deleteIndices(final ClusterChangedEvent event);1533063033;Deletes indices (with shard data).__@param event cluster change event;private void deleteIndices(final ClusterChangedEvent event) {_        final ClusterState previousState = event.previousState()__        final ClusterState state = event.state()__        final String localNodeId = state.nodes().getLocalNodeId()__        assert localNodeId != null___        for (Index index : event.indicesDeleted()) {_            if (logger.isDebugEnabled()) {_                logger.debug("[{}] cleaning index, no longer part of the metadata", index)__            }_            AllocatedIndex<? extends Shard> indexService = indicesService.indexService(index)__            final IndexSettings indexSettings__            if (indexService != null) {_                indexSettings = indexService.getIndexSettings()__                indicesService.removeIndex(index, DELETED, "index no longer part of the metadata")__            } else if (previousState.metaData().hasIndex(index.getName())) {_                _                final IndexMetaData metaData = previousState.metaData().index(index)__                indexSettings = new IndexSettings(metaData, settings)__                indicesService.deleteUnassignedIndex("deleted index was not assigned to local node", metaData, state)__            } else {_                _                _                _                _                _                _                assert previousState.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)__                final IndexMetaData metaData = indicesService.verifyIndexIsDeleted(index, event.state())__                if (metaData != null) {_                    indexSettings = new IndexSettings(metaData, settings)__                } else {_                    indexSettings = null__                }_            }_            if (indexSettings != null) {_                threadPool.generic().execute(new AbstractRunnable() {_                    @Override_                    public void onFailure(Exception e) {_                        logger.warn(() -> new ParameterizedMessage("[{}] failed to complete pending deletion for index", index), e)__                    }__                    @Override_                    protected void doRun() throws Exception {_                        try {_                            _                            _                            _                            _                            indicesService.processPendingDeletes(index, indexSettings, new TimeValue(30, TimeUnit.MINUTES))__                        } catch (LockObtainFailedException exc) {_                            logger.warn("[{}] failed to lock all shards for index - timed out after 30 seconds", index)__                        } catch (InterruptedException e) {_                            logger.warn("[{}] failed to lock all shards for index - interrupted", index)__                        }_                    }_                })__            }_        }_    };deletes,indices,with,shard,data,param,event,cluster,change,event;private,void,delete,indices,final,cluster,changed,event,event,final,cluster,state,previous,state,event,previous,state,final,cluster,state,state,event,state,final,string,local,node,id,state,nodes,get,local,node,id,assert,local,node,id,null,for,index,index,event,indices,deleted,if,logger,is,debug,enabled,logger,debug,cleaning,index,no,longer,part,of,the,metadata,index,allocated,index,extends,shard,index,service,indices,service,index,service,index,final,index,settings,index,settings,if,index,service,null,index,settings,index,service,get,index,settings,indices,service,remove,index,index,deleted,index,no,longer,part,of,the,metadata,else,if,previous,state,meta,data,has,index,index,get,name,final,index,meta,data,meta,data,previous,state,meta,data,index,index,index,settings,new,index,settings,meta,data,settings,indices,service,delete,unassigned,index,deleted,index,was,not,assigned,to,local,node,meta,data,state,else,assert,previous,state,blocks,has,global,block,gateway,service,final,index,meta,data,meta,data,indices,service,verify,index,is,deleted,index,event,state,if,meta,data,null,index,settings,new,index,settings,meta,data,settings,else,index,settings,null,if,index,settings,null,thread,pool,generic,execute,new,abstract,runnable,override,public,void,on,failure,exception,e,logger,warn,new,parameterized,message,failed,to,complete,pending,deletion,for,index,index,e,override,protected,void,do,run,throws,exception,try,indices,service,process,pending,deletes,index,index,settings,new,time,value,30,time,unit,minutes,catch,lock,obtain,failed,exception,exc,logger,warn,failed,to,lock,all,shards,for,index,timed,out,after,30,seconds,index,catch,interrupted,exception,e,logger,warn,failed,to,lock,all,shards,for,index,interrupted,index
IndicesClusterStateService -> private void deleteIndices(final ClusterChangedEvent event);1535405719;Deletes indices (with shard data).__@param event cluster change event;private void deleteIndices(final ClusterChangedEvent event) {_        final ClusterState previousState = event.previousState()__        final ClusterState state = event.state()__        final String localNodeId = state.nodes().getLocalNodeId()__        assert localNodeId != null___        for (Index index : event.indicesDeleted()) {_            if (logger.isDebugEnabled()) {_                logger.debug("[{}] cleaning index, no longer part of the metadata", index)__            }_            AllocatedIndex<? extends Shard> indexService = indicesService.indexService(index)__            final IndexSettings indexSettings__            if (indexService != null) {_                indexSettings = indexService.getIndexSettings()__                indicesService.removeIndex(index, DELETED, "index no longer part of the metadata")__            } else if (previousState.metaData().hasIndex(index.getName())) {_                _                final IndexMetaData metaData = previousState.metaData().index(index)__                indexSettings = new IndexSettings(metaData, settings)__                indicesService.deleteUnassignedIndex("deleted index was not assigned to local node", metaData, state)__            } else {_                _                _                _                _                _                _                assert previousState.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)__                final IndexMetaData metaData = indicesService.verifyIndexIsDeleted(index, event.state())__                if (metaData != null) {_                    indexSettings = new IndexSettings(metaData, settings)__                } else {_                    indexSettings = null__                }_            }_            if (indexSettings != null) {_                threadPool.generic().execute(new AbstractRunnable() {_                    @Override_                    public void onFailure(Exception e) {_                        logger.warn(() -> new ParameterizedMessage("[{}] failed to complete pending deletion for index", index), e)__                    }__                    @Override_                    protected void doRun() throws Exception {_                        try {_                            _                            _                            _                            _                            indicesService.processPendingDeletes(index, indexSettings, new TimeValue(30, TimeUnit.MINUTES))__                        } catch (LockObtainFailedException exc) {_                            logger.warn("[{}] failed to lock all shards for index - timed out after 30 seconds", index)__                        } catch (InterruptedException e) {_                            logger.warn("[{}] failed to lock all shards for index - interrupted", index)__                        }_                    }_                })__            }_        }_    };deletes,indices,with,shard,data,param,event,cluster,change,event;private,void,delete,indices,final,cluster,changed,event,event,final,cluster,state,previous,state,event,previous,state,final,cluster,state,state,event,state,final,string,local,node,id,state,nodes,get,local,node,id,assert,local,node,id,null,for,index,index,event,indices,deleted,if,logger,is,debug,enabled,logger,debug,cleaning,index,no,longer,part,of,the,metadata,index,allocated,index,extends,shard,index,service,indices,service,index,service,index,final,index,settings,index,settings,if,index,service,null,index,settings,index,service,get,index,settings,indices,service,remove,index,index,deleted,index,no,longer,part,of,the,metadata,else,if,previous,state,meta,data,has,index,index,get,name,final,index,meta,data,meta,data,previous,state,meta,data,index,index,index,settings,new,index,settings,meta,data,settings,indices,service,delete,unassigned,index,deleted,index,was,not,assigned,to,local,node,meta,data,state,else,assert,previous,state,blocks,has,global,block,gateway,service,final,index,meta,data,meta,data,indices,service,verify,index,is,deleted,index,event,state,if,meta,data,null,index,settings,new,index,settings,meta,data,settings,else,index,settings,null,if,index,settings,null,thread,pool,generic,execute,new,abstract,runnable,override,public,void,on,failure,exception,e,logger,warn,new,parameterized,message,failed,to,complete,pending,deletion,for,index,index,e,override,protected,void,do,run,throws,exception,try,indices,service,process,pending,deletes,index,index,settings,new,time,value,30,time,unit,minutes,catch,lock,obtain,failed,exception,exc,logger,warn,failed,to,lock,all,shards,for,index,timed,out,after,30,seconds,index,catch,interrupted,exception,e,logger,warn,failed,to,lock,all,shards,for,index,interrupted,index
IndicesClusterStateService -> private void deleteIndices(final ClusterChangedEvent event);1539723533;Deletes indices (with shard data).__@param event cluster change event;private void deleteIndices(final ClusterChangedEvent event) {_        final ClusterState previousState = event.previousState()__        final ClusterState state = event.state()__        final String localNodeId = state.nodes().getLocalNodeId()__        assert localNodeId != null___        for (Index index : event.indicesDeleted()) {_            if (logger.isDebugEnabled()) {_                logger.debug("[{}] cleaning index, no longer part of the metadata", index)__            }_            AllocatedIndex<? extends Shard> indexService = indicesService.indexService(index)__            final IndexSettings indexSettings__            if (indexService != null) {_                indexSettings = indexService.getIndexSettings()__                indicesService.removeIndex(index, DELETED, "index no longer part of the metadata")__            } else if (previousState.metaData().hasIndex(index.getName())) {_                _                final IndexMetaData metaData = previousState.metaData().index(index)__                indexSettings = new IndexSettings(metaData, settings)__                indicesService.deleteUnassignedIndex("deleted index was not assigned to local node", metaData, state)__            } else {_                _                _                _                _                _                _                assert previousState.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)__                final IndexMetaData metaData = indicesService.verifyIndexIsDeleted(index, event.state())__                if (metaData != null) {_                    indexSettings = new IndexSettings(metaData, settings)__                } else {_                    indexSettings = null__                }_            }_            if (indexSettings != null) {_                threadPool.generic().execute(new AbstractRunnable() {_                    @Override_                    public void onFailure(Exception e) {_                        logger.warn(() -> new ParameterizedMessage("[{}] failed to complete pending deletion for index", index), e)__                    }__                    @Override_                    protected void doRun() throws Exception {_                        try {_                            _                            _                            _                            _                            indicesService.processPendingDeletes(index, indexSettings, new TimeValue(30, TimeUnit.MINUTES))__                        } catch (LockObtainFailedException exc) {_                            logger.warn("[{}] failed to lock all shards for index - timed out after 30 seconds", index)__                        } catch (InterruptedException e) {_                            logger.warn("[{}] failed to lock all shards for index - interrupted", index)__                        }_                    }_                })__            }_        }_    };deletes,indices,with,shard,data,param,event,cluster,change,event;private,void,delete,indices,final,cluster,changed,event,event,final,cluster,state,previous,state,event,previous,state,final,cluster,state,state,event,state,final,string,local,node,id,state,nodes,get,local,node,id,assert,local,node,id,null,for,index,index,event,indices,deleted,if,logger,is,debug,enabled,logger,debug,cleaning,index,no,longer,part,of,the,metadata,index,allocated,index,extends,shard,index,service,indices,service,index,service,index,final,index,settings,index,settings,if,index,service,null,index,settings,index,service,get,index,settings,indices,service,remove,index,index,deleted,index,no,longer,part,of,the,metadata,else,if,previous,state,meta,data,has,index,index,get,name,final,index,meta,data,meta,data,previous,state,meta,data,index,index,index,settings,new,index,settings,meta,data,settings,indices,service,delete,unassigned,index,deleted,index,was,not,assigned,to,local,node,meta,data,state,else,assert,previous,state,blocks,has,global,block,gateway,service,final,index,meta,data,meta,data,indices,service,verify,index,is,deleted,index,event,state,if,meta,data,null,index,settings,new,index,settings,meta,data,settings,else,index,settings,null,if,index,settings,null,thread,pool,generic,execute,new,abstract,runnable,override,public,void,on,failure,exception,e,logger,warn,new,parameterized,message,failed,to,complete,pending,deletion,for,index,index,e,override,protected,void,do,run,throws,exception,try,indices,service,process,pending,deletes,index,index,settings,new,time,value,30,time,unit,minutes,catch,lock,obtain,failed,exception,exc,logger,warn,failed,to,lock,all,shards,for,index,timed,out,after,30,seconds,index,catch,interrupted,exception,e,logger,warn,failed,to,lock,all,shards,for,index,interrupted,index
IndicesClusterStateService -> private void deleteIndices(final ClusterChangedEvent event);1541008027;Deletes indices (with shard data).__@param event cluster change event;private void deleteIndices(final ClusterChangedEvent event) {_        final ClusterState previousState = event.previousState()__        final ClusterState state = event.state()__        final String localNodeId = state.nodes().getLocalNodeId()__        assert localNodeId != null___        for (Index index : event.indicesDeleted()) {_            if (logger.isDebugEnabled()) {_                logger.debug("[{}] cleaning index, no longer part of the metadata", index)__            }_            AllocatedIndex<? extends Shard> indexService = indicesService.indexService(index)__            final IndexSettings indexSettings__            if (indexService != null) {_                indexSettings = indexService.getIndexSettings()__                indicesService.removeIndex(index, DELETED, "index no longer part of the metadata")__            } else if (previousState.metaData().hasIndex(index.getName())) {_                _                final IndexMetaData metaData = previousState.metaData().index(index)__                indexSettings = new IndexSettings(metaData, settings)__                indicesService.deleteUnassignedIndex("deleted index was not assigned to local node", metaData, state)__            } else {_                _                _                _                _                _                _                assert previousState.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)__                final IndexMetaData metaData = indicesService.verifyIndexIsDeleted(index, event.state())__                if (metaData != null) {_                    indexSettings = new IndexSettings(metaData, settings)__                } else {_                    indexSettings = null__                }_            }_            if (indexSettings != null) {_                threadPool.generic().execute(new AbstractRunnable() {_                    @Override_                    public void onFailure(Exception e) {_                        logger.warn(() -> new ParameterizedMessage("[{}] failed to complete pending deletion for index", index), e)__                    }__                    @Override_                    protected void doRun() throws Exception {_                        try {_                            _                            _                            _                            _                            indicesService.processPendingDeletes(index, indexSettings, new TimeValue(30, TimeUnit.MINUTES))__                        } catch (LockObtainFailedException exc) {_                            logger.warn("[{}] failed to lock all shards for index - timed out after 30 seconds", index)__                        } catch (InterruptedException e) {_                            logger.warn("[{}] failed to lock all shards for index - interrupted", index)__                        }_                    }_                })__            }_        }_    };deletes,indices,with,shard,data,param,event,cluster,change,event;private,void,delete,indices,final,cluster,changed,event,event,final,cluster,state,previous,state,event,previous,state,final,cluster,state,state,event,state,final,string,local,node,id,state,nodes,get,local,node,id,assert,local,node,id,null,for,index,index,event,indices,deleted,if,logger,is,debug,enabled,logger,debug,cleaning,index,no,longer,part,of,the,metadata,index,allocated,index,extends,shard,index,service,indices,service,index,service,index,final,index,settings,index,settings,if,index,service,null,index,settings,index,service,get,index,settings,indices,service,remove,index,index,deleted,index,no,longer,part,of,the,metadata,else,if,previous,state,meta,data,has,index,index,get,name,final,index,meta,data,meta,data,previous,state,meta,data,index,index,index,settings,new,index,settings,meta,data,settings,indices,service,delete,unassigned,index,deleted,index,was,not,assigned,to,local,node,meta,data,state,else,assert,previous,state,blocks,has,global,block,gateway,service,final,index,meta,data,meta,data,indices,service,verify,index,is,deleted,index,event,state,if,meta,data,null,index,settings,new,index,settings,meta,data,settings,else,index,settings,null,if,index,settings,null,thread,pool,generic,execute,new,abstract,runnable,override,public,void,on,failure,exception,e,logger,warn,new,parameterized,message,failed,to,complete,pending,deletion,for,index,index,e,override,protected,void,do,run,throws,exception,try,indices,service,process,pending,deletes,index,index,settings,new,time,value,30,time,unit,minutes,catch,lock,obtain,failed,exception,exc,logger,warn,failed,to,lock,all,shards,for,index,timed,out,after,30,seconds,index,catch,interrupted,exception,e,logger,warn,failed,to,lock,all,shards,for,index,interrupted,index
IndicesClusterStateService -> private void deleteIndices(final ClusterChangedEvent event);1542646292;Deletes indices (with shard data).__@param event cluster change event;private void deleteIndices(final ClusterChangedEvent event) {_        final ClusterState previousState = event.previousState()__        final ClusterState state = event.state()__        final String localNodeId = state.nodes().getLocalNodeId()__        assert localNodeId != null___        for (Index index : event.indicesDeleted()) {_            if (logger.isDebugEnabled()) {_                logger.debug("[{}] cleaning index, no longer part of the metadata", index)__            }_            AllocatedIndex<? extends Shard> indexService = indicesService.indexService(index)__            final IndexSettings indexSettings__            if (indexService != null) {_                indexSettings = indexService.getIndexSettings()__                indicesService.removeIndex(index, DELETED, "index no longer part of the metadata")__            } else if (previousState.metaData().hasIndex(index.getName())) {_                _                final IndexMetaData metaData = previousState.metaData().index(index)__                indexSettings = new IndexSettings(metaData, settings)__                indicesService.deleteUnassignedIndex("deleted index was not assigned to local node", metaData, state)__            } else {_                _                _                _                _                _                _                assert previousState.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)__                final IndexMetaData metaData = indicesService.verifyIndexIsDeleted(index, event.state())__                if (metaData != null) {_                    indexSettings = new IndexSettings(metaData, settings)__                } else {_                    indexSettings = null__                }_            }_            if (indexSettings != null) {_                threadPool.generic().execute(new AbstractRunnable() {_                    @Override_                    public void onFailure(Exception e) {_                        logger.warn(() -> new ParameterizedMessage("[{}] failed to complete pending deletion for index", index), e)__                    }__                    @Override_                    protected void doRun() throws Exception {_                        try {_                            _                            _                            _                            _                            indicesService.processPendingDeletes(index, indexSettings, new TimeValue(30, TimeUnit.MINUTES))__                        } catch (LockObtainFailedException exc) {_                            logger.warn("[{}] failed to lock all shards for index - timed out after 30 seconds", index)__                        } catch (InterruptedException e) {_                            logger.warn("[{}] failed to lock all shards for index - interrupted", index)__                        }_                    }_                })__            }_        }_    };deletes,indices,with,shard,data,param,event,cluster,change,event;private,void,delete,indices,final,cluster,changed,event,event,final,cluster,state,previous,state,event,previous,state,final,cluster,state,state,event,state,final,string,local,node,id,state,nodes,get,local,node,id,assert,local,node,id,null,for,index,index,event,indices,deleted,if,logger,is,debug,enabled,logger,debug,cleaning,index,no,longer,part,of,the,metadata,index,allocated,index,extends,shard,index,service,indices,service,index,service,index,final,index,settings,index,settings,if,index,service,null,index,settings,index,service,get,index,settings,indices,service,remove,index,index,deleted,index,no,longer,part,of,the,metadata,else,if,previous,state,meta,data,has,index,index,get,name,final,index,meta,data,meta,data,previous,state,meta,data,index,index,index,settings,new,index,settings,meta,data,settings,indices,service,delete,unassigned,index,deleted,index,was,not,assigned,to,local,node,meta,data,state,else,assert,previous,state,blocks,has,global,block,gateway,service,final,index,meta,data,meta,data,indices,service,verify,index,is,deleted,index,event,state,if,meta,data,null,index,settings,new,index,settings,meta,data,settings,else,index,settings,null,if,index,settings,null,thread,pool,generic,execute,new,abstract,runnable,override,public,void,on,failure,exception,e,logger,warn,new,parameterized,message,failed,to,complete,pending,deletion,for,index,index,e,override,protected,void,do,run,throws,exception,try,indices,service,process,pending,deletes,index,index,settings,new,time,value,30,time,unit,minutes,catch,lock,obtain,failed,exception,exc,logger,warn,failed,to,lock,all,shards,for,index,timed,out,after,30,seconds,index,catch,interrupted,exception,e,logger,warn,failed,to,lock,all,shards,for,index,interrupted,index
IndicesClusterStateService -> private void deleteIndices(final ClusterChangedEvent event);1547520324;Deletes indices (with shard data).__@param event cluster change event;private void deleteIndices(final ClusterChangedEvent event) {_        final ClusterState previousState = event.previousState()__        final ClusterState state = event.state()__        final String localNodeId = state.nodes().getLocalNodeId()__        assert localNodeId != null___        for (Index index : event.indicesDeleted()) {_            if (logger.isDebugEnabled()) {_                logger.debug("[{}] cleaning index, no longer part of the metadata", index)__            }_            AllocatedIndex<? extends Shard> indexService = indicesService.indexService(index)__            final IndexSettings indexSettings__            if (indexService != null) {_                indexSettings = indexService.getIndexSettings()__                indicesService.removeIndex(index, DELETED, "index no longer part of the metadata")__            } else if (previousState.metaData().hasIndex(index.getName())) {_                _                final IndexMetaData metaData = previousState.metaData().index(index)__                indexSettings = new IndexSettings(metaData, settings)__                indicesService.deleteUnassignedIndex("deleted index was not assigned to local node", metaData, state)__            } else {_                _                _                _                _                _                _                assert previousState.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)__                final IndexMetaData metaData = indicesService.verifyIndexIsDeleted(index, event.state())__                if (metaData != null) {_                    indexSettings = new IndexSettings(metaData, settings)__                } else {_                    indexSettings = null__                }_            }_            if (indexSettings != null) {_                threadPool.generic().execute(new AbstractRunnable() {_                    @Override_                    public void onFailure(Exception e) {_                        logger.warn(() -> new ParameterizedMessage("[{}] failed to complete pending deletion for index", index), e)__                    }__                    @Override_                    protected void doRun() throws Exception {_                        try {_                            _                            _                            _                            _                            indicesService.processPendingDeletes(index, indexSettings, new TimeValue(30, TimeUnit.MINUTES))__                        } catch (LockObtainFailedException exc) {_                            logger.warn("[{}] failed to lock all shards for index - timed out after 30 seconds", index)__                        } catch (InterruptedException e) {_                            logger.warn("[{}] failed to lock all shards for index - interrupted", index)__                        }_                    }_                })__            }_        }_    };deletes,indices,with,shard,data,param,event,cluster,change,event;private,void,delete,indices,final,cluster,changed,event,event,final,cluster,state,previous,state,event,previous,state,final,cluster,state,state,event,state,final,string,local,node,id,state,nodes,get,local,node,id,assert,local,node,id,null,for,index,index,event,indices,deleted,if,logger,is,debug,enabled,logger,debug,cleaning,index,no,longer,part,of,the,metadata,index,allocated,index,extends,shard,index,service,indices,service,index,service,index,final,index,settings,index,settings,if,index,service,null,index,settings,index,service,get,index,settings,indices,service,remove,index,index,deleted,index,no,longer,part,of,the,metadata,else,if,previous,state,meta,data,has,index,index,get,name,final,index,meta,data,meta,data,previous,state,meta,data,index,index,index,settings,new,index,settings,meta,data,settings,indices,service,delete,unassigned,index,deleted,index,was,not,assigned,to,local,node,meta,data,state,else,assert,previous,state,blocks,has,global,block,gateway,service,final,index,meta,data,meta,data,indices,service,verify,index,is,deleted,index,event,state,if,meta,data,null,index,settings,new,index,settings,meta,data,settings,else,index,settings,null,if,index,settings,null,thread,pool,generic,execute,new,abstract,runnable,override,public,void,on,failure,exception,e,logger,warn,new,parameterized,message,failed,to,complete,pending,deletion,for,index,index,e,override,protected,void,do,run,throws,exception,try,indices,service,process,pending,deletes,index,index,settings,new,time,value,30,time,unit,minutes,catch,lock,obtain,failed,exception,exc,logger,warn,failed,to,lock,all,shards,for,index,timed,out,after,30,seconds,index,catch,interrupted,exception,e,logger,warn,failed,to,lock,all,shards,for,index,interrupted,index
IndicesClusterStateService -> private void deleteIndices(final ClusterChangedEvent event);1547536822;Deletes indices (with shard data).__@param event cluster change event;private void deleteIndices(final ClusterChangedEvent event) {_        final ClusterState previousState = event.previousState()__        final ClusterState state = event.state()__        final String localNodeId = state.nodes().getLocalNodeId()__        assert localNodeId != null___        for (Index index : event.indicesDeleted()) {_            if (logger.isDebugEnabled()) {_                logger.debug("[{}] cleaning index, no longer part of the metadata", index)__            }_            AllocatedIndex<? extends Shard> indexService = indicesService.indexService(index)__            final IndexSettings indexSettings__            if (indexService != null) {_                indexSettings = indexService.getIndexSettings()__                indicesService.removeIndex(index, DELETED, "index no longer part of the metadata")__            } else if (previousState.metaData().hasIndex(index.getName())) {_                _                final IndexMetaData metaData = previousState.metaData().index(index)__                indexSettings = new IndexSettings(metaData, settings)__                indicesService.deleteUnassignedIndex("deleted index was not assigned to local node", metaData, state)__            } else {_                _                _                _                _                _                _                assert previousState.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)__                final IndexMetaData metaData = indicesService.verifyIndexIsDeleted(index, event.state())__                if (metaData != null) {_                    indexSettings = new IndexSettings(metaData, settings)__                } else {_                    indexSettings = null__                }_            }_            if (indexSettings != null) {_                threadPool.generic().execute(new AbstractRunnable() {_                    @Override_                    public void onFailure(Exception e) {_                        logger.warn(() -> new ParameterizedMessage("[{}] failed to complete pending deletion for index", index), e)__                    }__                    @Override_                    protected void doRun() throws Exception {_                        try {_                            _                            _                            _                            _                            indicesService.processPendingDeletes(index, indexSettings, new TimeValue(30, TimeUnit.MINUTES))__                        } catch (LockObtainFailedException exc) {_                            logger.warn("[{}] failed to lock all shards for index - timed out after 30 seconds", index)__                        } catch (InterruptedException e) {_                            logger.warn("[{}] failed to lock all shards for index - interrupted", index)__                        }_                    }_                })__            }_        }_    };deletes,indices,with,shard,data,param,event,cluster,change,event;private,void,delete,indices,final,cluster,changed,event,event,final,cluster,state,previous,state,event,previous,state,final,cluster,state,state,event,state,final,string,local,node,id,state,nodes,get,local,node,id,assert,local,node,id,null,for,index,index,event,indices,deleted,if,logger,is,debug,enabled,logger,debug,cleaning,index,no,longer,part,of,the,metadata,index,allocated,index,extends,shard,index,service,indices,service,index,service,index,final,index,settings,index,settings,if,index,service,null,index,settings,index,service,get,index,settings,indices,service,remove,index,index,deleted,index,no,longer,part,of,the,metadata,else,if,previous,state,meta,data,has,index,index,get,name,final,index,meta,data,meta,data,previous,state,meta,data,index,index,index,settings,new,index,settings,meta,data,settings,indices,service,delete,unassigned,index,deleted,index,was,not,assigned,to,local,node,meta,data,state,else,assert,previous,state,blocks,has,global,block,gateway,service,final,index,meta,data,meta,data,indices,service,verify,index,is,deleted,index,event,state,if,meta,data,null,index,settings,new,index,settings,meta,data,settings,else,index,settings,null,if,index,settings,null,thread,pool,generic,execute,new,abstract,runnable,override,public,void,on,failure,exception,e,logger,warn,new,parameterized,message,failed,to,complete,pending,deletion,for,index,index,e,override,protected,void,do,run,throws,exception,try,indices,service,process,pending,deletes,index,index,settings,new,time,value,30,time,unit,minutes,catch,lock,obtain,failed,exception,exc,logger,warn,failed,to,lock,all,shards,for,index,timed,out,after,30,seconds,index,catch,interrupted,exception,e,logger,warn,failed,to,lock,all,shards,for,index,interrupted,index
IndicesClusterStateService -> private void deleteIndices(final ClusterChangedEvent event);1547625930;Deletes indices (with shard data).__@param event cluster change event;private void deleteIndices(final ClusterChangedEvent event) {_        final ClusterState previousState = event.previousState()__        final ClusterState state = event.state()__        final String localNodeId = state.nodes().getLocalNodeId()__        assert localNodeId != null___        for (Index index : event.indicesDeleted()) {_            if (logger.isDebugEnabled()) {_                logger.debug("[{}] cleaning index, no longer part of the metadata", index)__            }_            AllocatedIndex<? extends Shard> indexService = indicesService.indexService(index)__            final IndexSettings indexSettings__            if (indexService != null) {_                indexSettings = indexService.getIndexSettings()__                indicesService.removeIndex(index, DELETED, "index no longer part of the metadata")__            } else if (previousState.metaData().hasIndex(index.getName())) {_                _                final IndexMetaData metaData = previousState.metaData().index(index)__                indexSettings = new IndexSettings(metaData, settings)__                indicesService.deleteUnassignedIndex("deleted index was not assigned to local node", metaData, state)__            } else {_                _                _                _                _                _                _                assert previousState.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)__                final IndexMetaData metaData = indicesService.verifyIndexIsDeleted(index, event.state())__                if (metaData != null) {_                    indexSettings = new IndexSettings(metaData, settings)__                } else {_                    indexSettings = null__                }_            }_            if (indexSettings != null) {_                threadPool.generic().execute(new AbstractRunnable() {_                    @Override_                    public void onFailure(Exception e) {_                        logger.warn(() -> new ParameterizedMessage("[{}] failed to complete pending deletion for index", index), e)__                    }__                    @Override_                    protected void doRun() throws Exception {_                        try {_                            _                            _                            _                            _                            indicesService.processPendingDeletes(index, indexSettings, new TimeValue(30, TimeUnit.MINUTES))__                        } catch (LockObtainFailedException exc) {_                            logger.warn("[{}] failed to lock all shards for index - timed out after 30 seconds", index)__                        } catch (InterruptedException e) {_                            logger.warn("[{}] failed to lock all shards for index - interrupted", index)__                        }_                    }_                })__            }_        }_    };deletes,indices,with,shard,data,param,event,cluster,change,event;private,void,delete,indices,final,cluster,changed,event,event,final,cluster,state,previous,state,event,previous,state,final,cluster,state,state,event,state,final,string,local,node,id,state,nodes,get,local,node,id,assert,local,node,id,null,for,index,index,event,indices,deleted,if,logger,is,debug,enabled,logger,debug,cleaning,index,no,longer,part,of,the,metadata,index,allocated,index,extends,shard,index,service,indices,service,index,service,index,final,index,settings,index,settings,if,index,service,null,index,settings,index,service,get,index,settings,indices,service,remove,index,index,deleted,index,no,longer,part,of,the,metadata,else,if,previous,state,meta,data,has,index,index,get,name,final,index,meta,data,meta,data,previous,state,meta,data,index,index,index,settings,new,index,settings,meta,data,settings,indices,service,delete,unassigned,index,deleted,index,was,not,assigned,to,local,node,meta,data,state,else,assert,previous,state,blocks,has,global,block,gateway,service,final,index,meta,data,meta,data,indices,service,verify,index,is,deleted,index,event,state,if,meta,data,null,index,settings,new,index,settings,meta,data,settings,else,index,settings,null,if,index,settings,null,thread,pool,generic,execute,new,abstract,runnable,override,public,void,on,failure,exception,e,logger,warn,new,parameterized,message,failed,to,complete,pending,deletion,for,index,index,e,override,protected,void,do,run,throws,exception,try,indices,service,process,pending,deletes,index,index,settings,new,time,value,30,time,unit,minutes,catch,lock,obtain,failed,exception,exc,logger,warn,failed,to,lock,all,shards,for,index,timed,out,after,30,seconds,index,catch,interrupted,exception,e,logger,warn,failed,to,lock,all,shards,for,index,interrupted,index
IndicesClusterStateService -> private void deleteIndices(final ClusterChangedEvent event);1548593396;Deletes indices (with shard data).__@param event cluster change event;private void deleteIndices(final ClusterChangedEvent event) {_        final ClusterState previousState = event.previousState()__        final ClusterState state = event.state()__        final String localNodeId = state.nodes().getLocalNodeId()__        assert localNodeId != null___        for (Index index : event.indicesDeleted()) {_            if (logger.isDebugEnabled()) {_                logger.debug("[{}] cleaning index, no longer part of the metadata", index)__            }_            AllocatedIndex<? extends Shard> indexService = indicesService.indexService(index)__            final IndexSettings indexSettings__            if (indexService != null) {_                indexSettings = indexService.getIndexSettings()__                indicesService.removeIndex(index, DELETED, "index no longer part of the metadata")__            } else if (previousState.metaData().hasIndex(index.getName())) {_                _                final IndexMetaData metaData = previousState.metaData().index(index)__                indexSettings = new IndexSettings(metaData, settings)__                indicesService.deleteUnassignedIndex("deleted index was not assigned to local node", metaData, state)__            } else {_                _                _                _                _                _                _                assert previousState.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)__                final IndexMetaData metaData = indicesService.verifyIndexIsDeleted(index, event.state())__                if (metaData != null) {_                    indexSettings = new IndexSettings(metaData, settings)__                } else {_                    indexSettings = null__                }_            }_            if (indexSettings != null) {_                threadPool.generic().execute(new AbstractRunnable() {_                    @Override_                    public void onFailure(Exception e) {_                        logger.warn(() -> new ParameterizedMessage("[{}] failed to complete pending deletion for index", index), e)__                    }__                    @Override_                    protected void doRun() throws Exception {_                        try {_                            _                            _                            _                            _                            indicesService.processPendingDeletes(index, indexSettings, new TimeValue(30, TimeUnit.MINUTES))__                        } catch (LockObtainFailedException exc) {_                            logger.warn("[{}] failed to lock all shards for index - timed out after 30 seconds", index)__                        } catch (InterruptedException e) {_                            logger.warn("[{}] failed to lock all shards for index - interrupted", index)__                        }_                    }_                })__            }_        }_    };deletes,indices,with,shard,data,param,event,cluster,change,event;private,void,delete,indices,final,cluster,changed,event,event,final,cluster,state,previous,state,event,previous,state,final,cluster,state,state,event,state,final,string,local,node,id,state,nodes,get,local,node,id,assert,local,node,id,null,for,index,index,event,indices,deleted,if,logger,is,debug,enabled,logger,debug,cleaning,index,no,longer,part,of,the,metadata,index,allocated,index,extends,shard,index,service,indices,service,index,service,index,final,index,settings,index,settings,if,index,service,null,index,settings,index,service,get,index,settings,indices,service,remove,index,index,deleted,index,no,longer,part,of,the,metadata,else,if,previous,state,meta,data,has,index,index,get,name,final,index,meta,data,meta,data,previous,state,meta,data,index,index,index,settings,new,index,settings,meta,data,settings,indices,service,delete,unassigned,index,deleted,index,was,not,assigned,to,local,node,meta,data,state,else,assert,previous,state,blocks,has,global,block,gateway,service,final,index,meta,data,meta,data,indices,service,verify,index,is,deleted,index,event,state,if,meta,data,null,index,settings,new,index,settings,meta,data,settings,else,index,settings,null,if,index,settings,null,thread,pool,generic,execute,new,abstract,runnable,override,public,void,on,failure,exception,e,logger,warn,new,parameterized,message,failed,to,complete,pending,deletion,for,index,index,e,override,protected,void,do,run,throws,exception,try,indices,service,process,pending,deletes,index,index,settings,new,time,value,30,time,unit,minutes,catch,lock,obtain,failed,exception,exc,logger,warn,failed,to,lock,all,shards,for,index,timed,out,after,30,seconds,index,catch,interrupted,exception,e,logger,warn,failed,to,lock,all,shards,for,index,interrupted,index
IndicesClusterStateService -> private void deleteIndices(final ClusterChangedEvent event);1548770980;Deletes indices (with shard data).__@param event cluster change event;private void deleteIndices(final ClusterChangedEvent event) {_        final ClusterState previousState = event.previousState()__        final ClusterState state = event.state()__        final String localNodeId = state.nodes().getLocalNodeId()__        assert localNodeId != null___        for (Index index : event.indicesDeleted()) {_            if (logger.isDebugEnabled()) {_                logger.debug("[{}] cleaning index, no longer part of the metadata", index)__            }_            AllocatedIndex<? extends Shard> indexService = indicesService.indexService(index)__            final IndexSettings indexSettings__            if (indexService != null) {_                indexSettings = indexService.getIndexSettings()__                indicesService.removeIndex(index, DELETED, "index no longer part of the metadata")__            } else if (previousState.metaData().hasIndex(index.getName())) {_                _                final IndexMetaData metaData = previousState.metaData().index(index)__                indexSettings = new IndexSettings(metaData, settings)__                indicesService.deleteUnassignedIndex("deleted index was not assigned to local node", metaData, state)__            } else {_                _                _                _                _                _                _                assert previousState.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)__                final IndexMetaData metaData = indicesService.verifyIndexIsDeleted(index, event.state())__                if (metaData != null) {_                    indexSettings = new IndexSettings(metaData, settings)__                } else {_                    indexSettings = null__                }_            }_            if (indexSettings != null) {_                threadPool.generic().execute(new AbstractRunnable() {_                    @Override_                    public void onFailure(Exception e) {_                        logger.warn(() -> new ParameterizedMessage("[{}] failed to complete pending deletion for index", index), e)__                    }__                    @Override_                    protected void doRun() throws Exception {_                        try {_                            _                            _                            _                            _                            indicesService.processPendingDeletes(index, indexSettings, new TimeValue(30, TimeUnit.MINUTES))__                        } catch (LockObtainFailedException exc) {_                            logger.warn("[{}] failed to lock all shards for index - timed out after 30 seconds", index)__                        } catch (InterruptedException e) {_                            logger.warn("[{}] failed to lock all shards for index - interrupted", index)__                        }_                    }_                })__            }_        }_    };deletes,indices,with,shard,data,param,event,cluster,change,event;private,void,delete,indices,final,cluster,changed,event,event,final,cluster,state,previous,state,event,previous,state,final,cluster,state,state,event,state,final,string,local,node,id,state,nodes,get,local,node,id,assert,local,node,id,null,for,index,index,event,indices,deleted,if,logger,is,debug,enabled,logger,debug,cleaning,index,no,longer,part,of,the,metadata,index,allocated,index,extends,shard,index,service,indices,service,index,service,index,final,index,settings,index,settings,if,index,service,null,index,settings,index,service,get,index,settings,indices,service,remove,index,index,deleted,index,no,longer,part,of,the,metadata,else,if,previous,state,meta,data,has,index,index,get,name,final,index,meta,data,meta,data,previous,state,meta,data,index,index,index,settings,new,index,settings,meta,data,settings,indices,service,delete,unassigned,index,deleted,index,was,not,assigned,to,local,node,meta,data,state,else,assert,previous,state,blocks,has,global,block,gateway,service,final,index,meta,data,meta,data,indices,service,verify,index,is,deleted,index,event,state,if,meta,data,null,index,settings,new,index,settings,meta,data,settings,else,index,settings,null,if,index,settings,null,thread,pool,generic,execute,new,abstract,runnable,override,public,void,on,failure,exception,e,logger,warn,new,parameterized,message,failed,to,complete,pending,deletion,for,index,index,e,override,protected,void,do,run,throws,exception,try,indices,service,process,pending,deletes,index,index,settings,new,time,value,30,time,unit,minutes,catch,lock,obtain,failed,exception,exc,logger,warn,failed,to,lock,all,shards,for,index,timed,out,after,30,seconds,index,catch,interrupted,exception,e,logger,warn,failed,to,lock,all,shards,for,index,interrupted,index
IndicesClusterStateService -> private void deleteIndices(final ClusterChangedEvent event);1548872469;Deletes indices (with shard data).__@param event cluster change event;private void deleteIndices(final ClusterChangedEvent event) {_        final ClusterState previousState = event.previousState()__        final ClusterState state = event.state()__        final String localNodeId = state.nodes().getLocalNodeId()__        assert localNodeId != null___        for (Index index : event.indicesDeleted()) {_            if (logger.isDebugEnabled()) {_                logger.debug("[{}] cleaning index, no longer part of the metadata", index)__            }_            AllocatedIndex<? extends Shard> indexService = indicesService.indexService(index)__            final IndexSettings indexSettings__            if (indexService != null) {_                indexSettings = indexService.getIndexSettings()__                indicesService.removeIndex(index, DELETED, "index no longer part of the metadata")__            } else if (previousState.metaData().hasIndex(index.getName())) {_                _                final IndexMetaData metaData = previousState.metaData().index(index)__                indexSettings = new IndexSettings(metaData, settings)__                indicesService.deleteUnassignedIndex("deleted index was not assigned to local node", metaData, state)__            } else {_                _                _                _                _                _                _                assert previousState.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)__                final IndexMetaData metaData = indicesService.verifyIndexIsDeleted(index, event.state())__                if (metaData != null) {_                    indexSettings = new IndexSettings(metaData, settings)__                } else {_                    indexSettings = null__                }_            }_            if (indexSettings != null) {_                threadPool.generic().execute(new AbstractRunnable() {_                    @Override_                    public void onFailure(Exception e) {_                        logger.warn(() -> new ParameterizedMessage("[{}] failed to complete pending deletion for index", index), e)__                    }__                    @Override_                    protected void doRun() throws Exception {_                        try {_                            _                            _                            _                            _                            indicesService.processPendingDeletes(index, indexSettings, new TimeValue(30, TimeUnit.MINUTES))__                        } catch (LockObtainFailedException exc) {_                            logger.warn("[{}] failed to lock all shards for index - timed out after 30 seconds", index)__                        } catch (InterruptedException e) {_                            logger.warn("[{}] failed to lock all shards for index - interrupted", index)__                        }_                    }_                })__            }_        }_    };deletes,indices,with,shard,data,param,event,cluster,change,event;private,void,delete,indices,final,cluster,changed,event,event,final,cluster,state,previous,state,event,previous,state,final,cluster,state,state,event,state,final,string,local,node,id,state,nodes,get,local,node,id,assert,local,node,id,null,for,index,index,event,indices,deleted,if,logger,is,debug,enabled,logger,debug,cleaning,index,no,longer,part,of,the,metadata,index,allocated,index,extends,shard,index,service,indices,service,index,service,index,final,index,settings,index,settings,if,index,service,null,index,settings,index,service,get,index,settings,indices,service,remove,index,index,deleted,index,no,longer,part,of,the,metadata,else,if,previous,state,meta,data,has,index,index,get,name,final,index,meta,data,meta,data,previous,state,meta,data,index,index,index,settings,new,index,settings,meta,data,settings,indices,service,delete,unassigned,index,deleted,index,was,not,assigned,to,local,node,meta,data,state,else,assert,previous,state,blocks,has,global,block,gateway,service,final,index,meta,data,meta,data,indices,service,verify,index,is,deleted,index,event,state,if,meta,data,null,index,settings,new,index,settings,meta,data,settings,else,index,settings,null,if,index,settings,null,thread,pool,generic,execute,new,abstract,runnable,override,public,void,on,failure,exception,e,logger,warn,new,parameterized,message,failed,to,complete,pending,deletion,for,index,index,e,override,protected,void,do,run,throws,exception,try,indices,service,process,pending,deletes,index,index,settings,new,time,value,30,time,unit,minutes,catch,lock,obtain,failed,exception,exc,logger,warn,failed,to,lock,all,shards,for,index,timed,out,after,30,seconds,index,catch,interrupted,exception,e,logger,warn,failed,to,lock,all,shards,for,index,interrupted,index
IndicesClusterStateService -> private void deleteIndices(final ClusterChangedEvent event);1549294529;Deletes indices (with shard data).__@param event cluster change event;private void deleteIndices(final ClusterChangedEvent event) {_        final ClusterState previousState = event.previousState()__        final ClusterState state = event.state()__        final String localNodeId = state.nodes().getLocalNodeId()__        assert localNodeId != null___        for (Index index : event.indicesDeleted()) {_            if (logger.isDebugEnabled()) {_                logger.debug("[{}] cleaning index, no longer part of the metadata", index)__            }_            AllocatedIndex<? extends Shard> indexService = indicesService.indexService(index)__            final IndexSettings indexSettings__            if (indexService != null) {_                indexSettings = indexService.getIndexSettings()__                indicesService.removeIndex(index, DELETED, "index no longer part of the metadata")__            } else if (previousState.metaData().hasIndex(index.getName())) {_                _                final IndexMetaData metaData = previousState.metaData().index(index)__                indexSettings = new IndexSettings(metaData, settings)__                indicesService.deleteUnassignedIndex("deleted index was not assigned to local node", metaData, state)__            } else {_                _                _                _                _                _                _                assert previousState.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)__                final IndexMetaData metaData = indicesService.verifyIndexIsDeleted(index, event.state())__                if (metaData != null) {_                    indexSettings = new IndexSettings(metaData, settings)__                } else {_                    indexSettings = null__                }_            }_            if (indexSettings != null) {_                threadPool.generic().execute(new AbstractRunnable() {_                    @Override_                    public void onFailure(Exception e) {_                        logger.warn(() -> new ParameterizedMessage("[{}] failed to complete pending deletion for index", index), e)__                    }__                    @Override_                    protected void doRun() throws Exception {_                        try {_                            _                            _                            _                            _                            indicesService.processPendingDeletes(index, indexSettings, new TimeValue(30, TimeUnit.MINUTES))__                        } catch (LockObtainFailedException exc) {_                            logger.warn("[{}] failed to lock all shards for index - timed out after 30 seconds", index)__                        } catch (InterruptedException e) {_                            logger.warn("[{}] failed to lock all shards for index - interrupted", index)__                        }_                    }_                })__            }_        }_    };deletes,indices,with,shard,data,param,event,cluster,change,event;private,void,delete,indices,final,cluster,changed,event,event,final,cluster,state,previous,state,event,previous,state,final,cluster,state,state,event,state,final,string,local,node,id,state,nodes,get,local,node,id,assert,local,node,id,null,for,index,index,event,indices,deleted,if,logger,is,debug,enabled,logger,debug,cleaning,index,no,longer,part,of,the,metadata,index,allocated,index,extends,shard,index,service,indices,service,index,service,index,final,index,settings,index,settings,if,index,service,null,index,settings,index,service,get,index,settings,indices,service,remove,index,index,deleted,index,no,longer,part,of,the,metadata,else,if,previous,state,meta,data,has,index,index,get,name,final,index,meta,data,meta,data,previous,state,meta,data,index,index,index,settings,new,index,settings,meta,data,settings,indices,service,delete,unassigned,index,deleted,index,was,not,assigned,to,local,node,meta,data,state,else,assert,previous,state,blocks,has,global,block,gateway,service,final,index,meta,data,meta,data,indices,service,verify,index,is,deleted,index,event,state,if,meta,data,null,index,settings,new,index,settings,meta,data,settings,else,index,settings,null,if,index,settings,null,thread,pool,generic,execute,new,abstract,runnable,override,public,void,on,failure,exception,e,logger,warn,new,parameterized,message,failed,to,complete,pending,deletion,for,index,index,e,override,protected,void,do,run,throws,exception,try,indices,service,process,pending,deletes,index,index,settings,new,time,value,30,time,unit,minutes,catch,lock,obtain,failed,exception,exc,logger,warn,failed,to,lock,all,shards,for,index,timed,out,after,30,seconds,index,catch,interrupted,exception,e,logger,warn,failed,to,lock,all,shards,for,index,interrupted,index
IndicesClusterStateService -> AllocatedIndex -> IndexSettings getIndexSettings()_;1524684173;Returns the index settings of this index.;IndexSettings getIndexSettings()_;returns,the,index,settings,of,this,index;index,settings,get,index,settings
IndicesClusterStateService -> AllocatedIndex -> IndexSettings getIndexSettings()_;1533063033;Returns the index settings of this index.;IndexSettings getIndexSettings()_;returns,the,index,settings,of,this,index;index,settings,get,index,settings
IndicesClusterStateService -> AllocatedIndex -> IndexSettings getIndexSettings()_;1535405719;Returns the index settings of this index.;IndexSettings getIndexSettings()_;returns,the,index,settings,of,this,index;index,settings,get,index,settings
IndicesClusterStateService -> AllocatedIndex -> IndexSettings getIndexSettings()_;1539723533;Returns the index settings of this index.;IndexSettings getIndexSettings()_;returns,the,index,settings,of,this,index;index,settings,get,index,settings
IndicesClusterStateService -> AllocatedIndex -> IndexSettings getIndexSettings()_;1541008027;Returns the index settings of this index.;IndexSettings getIndexSettings()_;returns,the,index,settings,of,this,index;index,settings,get,index,settings
IndicesClusterStateService -> AllocatedIndex -> IndexSettings getIndexSettings()_;1542646292;Returns the index settings of this index.;IndexSettings getIndexSettings()_;returns,the,index,settings,of,this,index;index,settings,get,index,settings
IndicesClusterStateService -> AllocatedIndex -> IndexSettings getIndexSettings()_;1547520324;Returns the index settings of this index.;IndexSettings getIndexSettings()_;returns,the,index,settings,of,this,index;index,settings,get,index,settings
IndicesClusterStateService -> AllocatedIndex -> IndexSettings getIndexSettings()_;1547536822;Returns the index settings of this index.;IndexSettings getIndexSettings()_;returns,the,index,settings,of,this,index;index,settings,get,index,settings
IndicesClusterStateService -> AllocatedIndex -> IndexSettings getIndexSettings()_;1547625930;Returns the index settings of this index.;IndexSettings getIndexSettings()_;returns,the,index,settings,of,this,index;index,settings,get,index,settings
IndicesClusterStateService -> AllocatedIndex -> IndexSettings getIndexSettings()_;1548593396;Returns the index settings of this index.;IndexSettings getIndexSettings()_;returns,the,index,settings,of,this,index;index,settings,get,index,settings
IndicesClusterStateService -> AllocatedIndex -> IndexSettings getIndexSettings()_;1548770980;Returns the index settings of this index.;IndexSettings getIndexSettings()_;returns,the,index,settings,of,this,index;index,settings,get,index,settings
IndicesClusterStateService -> AllocatedIndex -> IndexSettings getIndexSettings()_;1548872469;Returns the index settings of this index.;IndexSettings getIndexSettings()_;returns,the,index,settings,of,this,index;index,settings,get,index,settings
IndicesClusterStateService -> AllocatedIndex -> IndexSettings getIndexSettings()_;1549294529;Returns the index settings of this index.;IndexSettings getIndexSettings()_;returns,the,index,settings,of,this,index;index,settings,get,index,settings
IndicesClusterStateService -> AllocatedIndex -> void updateMetaData(IndexMetaData indexMetaData)_;1524684173;Updates the meta data of this index. Changes become visible through {@link #getIndexSettings()};void updateMetaData(IndexMetaData indexMetaData)_;updates,the,meta,data,of,this,index,changes,become,visible,through,link,get,index,settings;void,update,meta,data,index,meta,data,index,meta,data
IndicesClusterStateService -> AllocatedIndex -> void updateMetaData(IndexMetaData indexMetaData)_;1533063033;Updates the meta data of this index. Changes become visible through {@link #getIndexSettings()};void updateMetaData(IndexMetaData indexMetaData)_;updates,the,meta,data,of,this,index,changes,become,visible,through,link,get,index,settings;void,update,meta,data,index,meta,data,index,meta,data
IndicesClusterStateService -> AllocatedIndex -> void updateMetaData(IndexMetaData indexMetaData)_;1535405719;Updates the meta data of this index. Changes become visible through {@link #getIndexSettings()};void updateMetaData(IndexMetaData indexMetaData)_;updates,the,meta,data,of,this,index,changes,become,visible,through,link,get,index,settings;void,update,meta,data,index,meta,data,index,meta,data
IndicesClusterStateService -> Shard -> ShardRouting routingEntry()_;1524684173;Returns the latest cluster routing entry received with this shard.;ShardRouting routingEntry()_;returns,the,latest,cluster,routing,entry,received,with,this,shard;shard,routing,routing,entry
IndicesClusterStateService -> Shard -> ShardRouting routingEntry()_;1533063033;Returns the latest cluster routing entry received with this shard.;ShardRouting routingEntry()_;returns,the,latest,cluster,routing,entry,received,with,this,shard;shard,routing,routing,entry
IndicesClusterStateService -> Shard -> ShardRouting routingEntry()_;1535405719;Returns the latest cluster routing entry received with this shard.;ShardRouting routingEntry()_;returns,the,latest,cluster,routing,entry,received,with,this,shard;shard,routing,routing,entry
IndicesClusterStateService -> Shard -> ShardRouting routingEntry()_;1539723533;Returns the latest cluster routing entry received with this shard.;ShardRouting routingEntry()_;returns,the,latest,cluster,routing,entry,received,with,this,shard;shard,routing,routing,entry
IndicesClusterStateService -> Shard -> ShardRouting routingEntry()_;1541008027;Returns the latest cluster routing entry received with this shard.;ShardRouting routingEntry()_;returns,the,latest,cluster,routing,entry,received,with,this,shard;shard,routing,routing,entry
IndicesClusterStateService -> Shard -> ShardRouting routingEntry()_;1542646292;Returns the latest cluster routing entry received with this shard.;ShardRouting routingEntry()_;returns,the,latest,cluster,routing,entry,received,with,this,shard;shard,routing,routing,entry
IndicesClusterStateService -> Shard -> ShardRouting routingEntry()_;1547520324;Returns the latest cluster routing entry received with this shard.;ShardRouting routingEntry()_;returns,the,latest,cluster,routing,entry,received,with,this,shard;shard,routing,routing,entry
IndicesClusterStateService -> Shard -> ShardRouting routingEntry()_;1547536822;Returns the latest cluster routing entry received with this shard.;ShardRouting routingEntry()_;returns,the,latest,cluster,routing,entry,received,with,this,shard;shard,routing,routing,entry
IndicesClusterStateService -> Shard -> ShardRouting routingEntry()_;1547625930;Returns the latest cluster routing entry received with this shard.;ShardRouting routingEntry()_;returns,the,latest,cluster,routing,entry,received,with,this,shard;shard,routing,routing,entry
IndicesClusterStateService -> Shard -> ShardRouting routingEntry()_;1548593396;Returns the latest cluster routing entry received with this shard.;ShardRouting routingEntry()_;returns,the,latest,cluster,routing,entry,received,with,this,shard;shard,routing,routing,entry
IndicesClusterStateService -> Shard -> ShardRouting routingEntry()_;1548770980;Returns the latest cluster routing entry received with this shard.;ShardRouting routingEntry()_;returns,the,latest,cluster,routing,entry,received,with,this,shard;shard,routing,routing,entry
IndicesClusterStateService -> Shard -> ShardRouting routingEntry()_;1548872469;Returns the latest cluster routing entry received with this shard.;ShardRouting routingEntry()_;returns,the,latest,cluster,routing,entry,received,with,this,shard;shard,routing,routing,entry
IndicesClusterStateService -> Shard -> ShardRouting routingEntry()_;1549294529;Returns the latest cluster routing entry received with this shard.;ShardRouting routingEntry()_;returns,the,latest,cluster,routing,entry,received,with,this,shard;shard,routing,routing,entry
IndicesClusterStateService -> AllocatedIndices -> T createShard(                 ShardRouting shardRouting,                 RecoveryState recoveryState,                 PeerRecoveryTargetService recoveryTargetService,                 PeerRecoveryTargetService.RecoveryListener recoveryListener,                 RepositoriesService repositoriesService,                 Consumer<IndexShard.ShardFailure> onShardFailure,                 Consumer<ShardId> globalCheckpointSyncer,                 RetentionLeaseSyncer retentionLeaseSyncer) throws IOException_;1548593396;Creates a shard for the specified shard routing and starts recovery.__@param shardRouting           the shard routing_@param recoveryState          the recovery state_@param recoveryTargetService  recovery service for the target_@param recoveryListener       a callback when recovery changes state (finishes or fails)_@param repositoriesService    service responsible for snapshot/restore_@param onShardFailure         a callback when this shard fails_@param globalCheckpointSyncer a callback when this shard syncs the global checkpoint_@param retentionLeaseSyncer   a callback when this shard syncs retention leases_@return a new shard_@throws IOException if an I/O exception occurs when creating the shard;T createShard(_                ShardRouting shardRouting,_                RecoveryState recoveryState,_                PeerRecoveryTargetService recoveryTargetService,_                PeerRecoveryTargetService.RecoveryListener recoveryListener,_                RepositoriesService repositoriesService,_                Consumer<IndexShard.ShardFailure> onShardFailure,_                Consumer<ShardId> globalCheckpointSyncer,_                RetentionLeaseSyncer retentionLeaseSyncer) throws IOException_;creates,a,shard,for,the,specified,shard,routing,and,starts,recovery,param,shard,routing,the,shard,routing,param,recovery,state,the,recovery,state,param,recovery,target,service,recovery,service,for,the,target,param,recovery,listener,a,callback,when,recovery,changes,state,finishes,or,fails,param,repositories,service,service,responsible,for,snapshot,restore,param,on,shard,failure,a,callback,when,this,shard,fails,param,global,checkpoint,syncer,a,callback,when,this,shard,syncs,the,global,checkpoint,param,retention,lease,syncer,a,callback,when,this,shard,syncs,retention,leases,return,a,new,shard,throws,ioexception,if,an,i,o,exception,occurs,when,creating,the,shard;t,create,shard,shard,routing,shard,routing,recovery,state,recovery,state,peer,recovery,target,service,recovery,target,service,peer,recovery,target,service,recovery,listener,recovery,listener,repositories,service,repositories,service,consumer,index,shard,shard,failure,on,shard,failure,consumer,shard,id,global,checkpoint,syncer,retention,lease,syncer,retention,lease,syncer,throws,ioexception
IndicesClusterStateService -> AllocatedIndices -> T createShard(                 ShardRouting shardRouting,                 RecoveryState recoveryState,                 PeerRecoveryTargetService recoveryTargetService,                 PeerRecoveryTargetService.RecoveryListener recoveryListener,                 RepositoriesService repositoriesService,                 Consumer<IndexShard.ShardFailure> onShardFailure,                 Consumer<ShardId> globalCheckpointSyncer,                 RetentionLeaseSyncer retentionLeaseSyncer) throws IOException_;1548770980;Creates a shard for the specified shard routing and starts recovery.__@param shardRouting           the shard routing_@param recoveryState          the recovery state_@param recoveryTargetService  recovery service for the target_@param recoveryListener       a callback when recovery changes state (finishes or fails)_@param repositoriesService    service responsible for snapshot/restore_@param onShardFailure         a callback when this shard fails_@param globalCheckpointSyncer a callback when this shard syncs the global checkpoint_@param retentionLeaseSyncer   a callback when this shard syncs retention leases_@return a new shard_@throws IOException if an I/O exception occurs when creating the shard;T createShard(_                ShardRouting shardRouting,_                RecoveryState recoveryState,_                PeerRecoveryTargetService recoveryTargetService,_                PeerRecoveryTargetService.RecoveryListener recoveryListener,_                RepositoriesService repositoriesService,_                Consumer<IndexShard.ShardFailure> onShardFailure,_                Consumer<ShardId> globalCheckpointSyncer,_                RetentionLeaseSyncer retentionLeaseSyncer) throws IOException_;creates,a,shard,for,the,specified,shard,routing,and,starts,recovery,param,shard,routing,the,shard,routing,param,recovery,state,the,recovery,state,param,recovery,target,service,recovery,service,for,the,target,param,recovery,listener,a,callback,when,recovery,changes,state,finishes,or,fails,param,repositories,service,service,responsible,for,snapshot,restore,param,on,shard,failure,a,callback,when,this,shard,fails,param,global,checkpoint,syncer,a,callback,when,this,shard,syncs,the,global,checkpoint,param,retention,lease,syncer,a,callback,when,this,shard,syncs,retention,leases,return,a,new,shard,throws,ioexception,if,an,i,o,exception,occurs,when,creating,the,shard;t,create,shard,shard,routing,shard,routing,recovery,state,recovery,state,peer,recovery,target,service,recovery,target,service,peer,recovery,target,service,recovery,listener,recovery,listener,repositories,service,repositories,service,consumer,index,shard,shard,failure,on,shard,failure,consumer,shard,id,global,checkpoint,syncer,retention,lease,syncer,retention,lease,syncer,throws,ioexception
IndicesClusterStateService -> AllocatedIndices -> T createShard(                 ShardRouting shardRouting,                 RecoveryState recoveryState,                 PeerRecoveryTargetService recoveryTargetService,                 PeerRecoveryTargetService.RecoveryListener recoveryListener,                 RepositoriesService repositoriesService,                 Consumer<IndexShard.ShardFailure> onShardFailure,                 Consumer<ShardId> globalCheckpointSyncer,                 RetentionLeaseSyncer retentionLeaseSyncer) throws IOException_;1548872469;Creates a shard for the specified shard routing and starts recovery.__@param shardRouting           the shard routing_@param recoveryState          the recovery state_@param recoveryTargetService  recovery service for the target_@param recoveryListener       a callback when recovery changes state (finishes or fails)_@param repositoriesService    service responsible for snapshot/restore_@param onShardFailure         a callback when this shard fails_@param globalCheckpointSyncer a callback when this shard syncs the global checkpoint_@param retentionLeaseSyncer   a callback when this shard syncs retention leases_@return a new shard_@throws IOException if an I/O exception occurs when creating the shard;T createShard(_                ShardRouting shardRouting,_                RecoveryState recoveryState,_                PeerRecoveryTargetService recoveryTargetService,_                PeerRecoveryTargetService.RecoveryListener recoveryListener,_                RepositoriesService repositoriesService,_                Consumer<IndexShard.ShardFailure> onShardFailure,_                Consumer<ShardId> globalCheckpointSyncer,_                RetentionLeaseSyncer retentionLeaseSyncer) throws IOException_;creates,a,shard,for,the,specified,shard,routing,and,starts,recovery,param,shard,routing,the,shard,routing,param,recovery,state,the,recovery,state,param,recovery,target,service,recovery,service,for,the,target,param,recovery,listener,a,callback,when,recovery,changes,state,finishes,or,fails,param,repositories,service,service,responsible,for,snapshot,restore,param,on,shard,failure,a,callback,when,this,shard,fails,param,global,checkpoint,syncer,a,callback,when,this,shard,syncs,the,global,checkpoint,param,retention,lease,syncer,a,callback,when,this,shard,syncs,retention,leases,return,a,new,shard,throws,ioexception,if,an,i,o,exception,occurs,when,creating,the,shard;t,create,shard,shard,routing,shard,routing,recovery,state,recovery,state,peer,recovery,target,service,recovery,target,service,peer,recovery,target,service,recovery,listener,recovery,listener,repositories,service,repositories,service,consumer,index,shard,shard,failure,on,shard,failure,consumer,shard,id,global,checkpoint,syncer,retention,lease,syncer,retention,lease,syncer,throws,ioexception
IndicesClusterStateService -> AllocatedIndices -> T createShard(                 ShardRouting shardRouting,                 RecoveryState recoveryState,                 PeerRecoveryTargetService recoveryTargetService,                 PeerRecoveryTargetService.RecoveryListener recoveryListener,                 RepositoriesService repositoriesService,                 Consumer<IndexShard.ShardFailure> onShardFailure,                 Consumer<ShardId> globalCheckpointSyncer,                 RetentionLeaseSyncer retentionLeaseSyncer) throws IOException_;1549294529;Creates a shard for the specified shard routing and starts recovery.__@param shardRouting           the shard routing_@param recoveryState          the recovery state_@param recoveryTargetService  recovery service for the target_@param recoveryListener       a callback when recovery changes state (finishes or fails)_@param repositoriesService    service responsible for snapshot/restore_@param onShardFailure         a callback when this shard fails_@param globalCheckpointSyncer a callback when this shard syncs the global checkpoint_@param retentionLeaseSyncer   a callback when this shard syncs retention leases_@return a new shard_@throws IOException if an I/O exception occurs when creating the shard;T createShard(_                ShardRouting shardRouting,_                RecoveryState recoveryState,_                PeerRecoveryTargetService recoveryTargetService,_                PeerRecoveryTargetService.RecoveryListener recoveryListener,_                RepositoriesService repositoriesService,_                Consumer<IndexShard.ShardFailure> onShardFailure,_                Consumer<ShardId> globalCheckpointSyncer,_                RetentionLeaseSyncer retentionLeaseSyncer) throws IOException_;creates,a,shard,for,the,specified,shard,routing,and,starts,recovery,param,shard,routing,the,shard,routing,param,recovery,state,the,recovery,state,param,recovery,target,service,recovery,service,for,the,target,param,recovery,listener,a,callback,when,recovery,changes,state,finishes,or,fails,param,repositories,service,service,responsible,for,snapshot,restore,param,on,shard,failure,a,callback,when,this,shard,fails,param,global,checkpoint,syncer,a,callback,when,this,shard,syncs,the,global,checkpoint,param,retention,lease,syncer,a,callback,when,this,shard,syncs,retention,leases,return,a,new,shard,throws,ioexception,if,an,i,o,exception,occurs,when,creating,the,shard;t,create,shard,shard,routing,shard,routing,recovery,state,recovery,state,peer,recovery,target,service,recovery,target,service,peer,recovery,target,service,recovery,listener,recovery,listener,repositories,service,repositories,service,consumer,index,shard,shard,failure,on,shard,failure,consumer,shard,id,global,checkpoint,syncer,retention,lease,syncer,retention,lease,syncer,throws,ioexception
IndicesClusterStateService -> AllocatedIndices -> @Nullable U indexService(Index index)_;1524684173;Returns an IndexService for the specified index if exists otherwise returns <code>null</code>.;@Nullable U indexService(Index index)_;returns,an,index,service,for,the,specified,index,if,exists,otherwise,returns,code,null,code;nullable,u,index,service,index,index
IndicesClusterStateService -> AllocatedIndices -> @Nullable U indexService(Index index)_;1533063033;Returns an IndexService for the specified index if exists otherwise returns <code>null</code>.;@Nullable U indexService(Index index)_;returns,an,index,service,for,the,specified,index,if,exists,otherwise,returns,code,null,code;nullable,u,index,service,index,index
IndicesClusterStateService -> AllocatedIndices -> @Nullable U indexService(Index index)_;1535405719;Returns an IndexService for the specified index if exists otherwise returns <code>null</code>.;@Nullable U indexService(Index index)_;returns,an,index,service,for,the,specified,index,if,exists,otherwise,returns,code,null,code;nullable,u,index,service,index,index
IndicesClusterStateService -> AllocatedIndices -> @Nullable U indexService(Index index)_;1539723533;Returns an IndexService for the specified index if exists otherwise returns <code>null</code>.;@Nullable U indexService(Index index)_;returns,an,index,service,for,the,specified,index,if,exists,otherwise,returns,code,null,code;nullable,u,index,service,index,index
IndicesClusterStateService -> AllocatedIndices -> @Nullable U indexService(Index index)_;1541008027;Returns an IndexService for the specified index if exists otherwise returns <code>null</code>.;@Nullable U indexService(Index index)_;returns,an,index,service,for,the,specified,index,if,exists,otherwise,returns,code,null,code;nullable,u,index,service,index,index
IndicesClusterStateService -> AllocatedIndices -> @Nullable U indexService(Index index)_;1542646292;Returns an IndexService for the specified index if exists otherwise returns <code>null</code>.;@Nullable U indexService(Index index)_;returns,an,index,service,for,the,specified,index,if,exists,otherwise,returns,code,null,code;nullable,u,index,service,index,index
IndicesClusterStateService -> AllocatedIndices -> @Nullable U indexService(Index index)_;1547520324;Returns an IndexService for the specified index if exists otherwise returns <code>null</code>.;@Nullable U indexService(Index index)_;returns,an,index,service,for,the,specified,index,if,exists,otherwise,returns,code,null,code;nullable,u,index,service,index,index
IndicesClusterStateService -> AllocatedIndices -> @Nullable U indexService(Index index)_;1547536822;Returns an IndexService for the specified index if exists otherwise returns <code>null</code>.;@Nullable U indexService(Index index)_;returns,an,index,service,for,the,specified,index,if,exists,otherwise,returns,code,null,code;nullable,u,index,service,index,index
IndicesClusterStateService -> AllocatedIndices -> @Nullable U indexService(Index index)_;1547625930;Returns an IndexService for the specified index if exists otherwise returns <code>null</code>.;@Nullable U indexService(Index index)_;returns,an,index,service,for,the,specified,index,if,exists,otherwise,returns,code,null,code;nullable,u,index,service,index,index
IndicesClusterStateService -> AllocatedIndices -> @Nullable U indexService(Index index)_;1548593396;Returns an IndexService for the specified index if exists otherwise returns <code>null</code>.;@Nullable U indexService(Index index)_;returns,an,index,service,for,the,specified,index,if,exists,otherwise,returns,code,null,code;nullable,u,index,service,index,index
IndicesClusterStateService -> AllocatedIndices -> @Nullable U indexService(Index index)_;1548770980;Returns an IndexService for the specified index if exists otherwise returns <code>null</code>.;@Nullable U indexService(Index index)_;returns,an,index,service,for,the,specified,index,if,exists,otherwise,returns,code,null,code;nullable,u,index,service,index,index
IndicesClusterStateService -> AllocatedIndices -> @Nullable U indexService(Index index)_;1548872469;Returns an IndexService for the specified index if exists otherwise returns <code>null</code>.;@Nullable U indexService(Index index)_;returns,an,index,service,for,the,specified,index,if,exists,otherwise,returns,code,null,code;nullable,u,index,service,index,index
IndicesClusterStateService -> AllocatedIndices -> @Nullable U indexService(Index index)_;1549294529;Returns an IndexService for the specified index if exists otherwise returns <code>null</code>.;@Nullable U indexService(Index index)_;returns,an,index,service,for,the,specified,index,if,exists,otherwise,returns,code,null,code;nullable,u,index,service,index,index
IndicesClusterStateService -> AllocatedIndices -> T createShard(                 ShardRouting shardRouting,                 RecoveryState recoveryState,                 PeerRecoveryTargetService recoveryTargetService,                 PeerRecoveryTargetService.RecoveryListener recoveryListener,                 RepositoriesService repositoriesService,                 Consumer<IndexShard.ShardFailure> onShardFailure,                 Consumer<ShardId> globalCheckpointSyncer) throws IOException_;1547520324;Creates a shard for the specified shard routing and starts recovery.__@param shardRouting           the shard routing_@param recoveryState          the recovery state_@param recoveryTargetService  recovery service for the target_@param recoveryListener       a callback when recovery changes state (finishes or fails)_@param repositoriesService    service responsible for snapshot/restore_@param onShardFailure         a callback when this shard fails_@param globalCheckpointSyncer a callback when this shard syncs the global checkpoint_@return a new shard_@throws IOException if an I/O exception occurs when creating the shard;T createShard(_                ShardRouting shardRouting,_                RecoveryState recoveryState,_                PeerRecoveryTargetService recoveryTargetService,_                PeerRecoveryTargetService.RecoveryListener recoveryListener,_                RepositoriesService repositoriesService,_                Consumer<IndexShard.ShardFailure> onShardFailure,_                Consumer<ShardId> globalCheckpointSyncer) throws IOException_;creates,a,shard,for,the,specified,shard,routing,and,starts,recovery,param,shard,routing,the,shard,routing,param,recovery,state,the,recovery,state,param,recovery,target,service,recovery,service,for,the,target,param,recovery,listener,a,callback,when,recovery,changes,state,finishes,or,fails,param,repositories,service,service,responsible,for,snapshot,restore,param,on,shard,failure,a,callback,when,this,shard,fails,param,global,checkpoint,syncer,a,callback,when,this,shard,syncs,the,global,checkpoint,return,a,new,shard,throws,ioexception,if,an,i,o,exception,occurs,when,creating,the,shard;t,create,shard,shard,routing,shard,routing,recovery,state,recovery,state,peer,recovery,target,service,recovery,target,service,peer,recovery,target,service,recovery,listener,recovery,listener,repositories,service,repositories,service,consumer,index,shard,shard,failure,on,shard,failure,consumer,shard,id,global,checkpoint,syncer,throws,ioexception
IndicesClusterStateService -> AllocatedIndices -> T createShard(                 ShardRouting shardRouting,                 RecoveryState recoveryState,                 PeerRecoveryTargetService recoveryTargetService,                 PeerRecoveryTargetService.RecoveryListener recoveryListener,                 RepositoriesService repositoriesService,                 Consumer<IndexShard.ShardFailure> onShardFailure,                 Consumer<ShardId> globalCheckpointSyncer) throws IOException_;1547536822;Creates a shard for the specified shard routing and starts recovery.__@param shardRouting           the shard routing_@param recoveryState          the recovery state_@param recoveryTargetService  recovery service for the target_@param recoveryListener       a callback when recovery changes state (finishes or fails)_@param repositoriesService    service responsible for snapshot/restore_@param onShardFailure         a callback when this shard fails_@param globalCheckpointSyncer a callback when this shard syncs the global checkpoint_@return a new shard_@throws IOException if an I/O exception occurs when creating the shard;T createShard(_                ShardRouting shardRouting,_                RecoveryState recoveryState,_                PeerRecoveryTargetService recoveryTargetService,_                PeerRecoveryTargetService.RecoveryListener recoveryListener,_                RepositoriesService repositoriesService,_                Consumer<IndexShard.ShardFailure> onShardFailure,_                Consumer<ShardId> globalCheckpointSyncer) throws IOException_;creates,a,shard,for,the,specified,shard,routing,and,starts,recovery,param,shard,routing,the,shard,routing,param,recovery,state,the,recovery,state,param,recovery,target,service,recovery,service,for,the,target,param,recovery,listener,a,callback,when,recovery,changes,state,finishes,or,fails,param,repositories,service,service,responsible,for,snapshot,restore,param,on,shard,failure,a,callback,when,this,shard,fails,param,global,checkpoint,syncer,a,callback,when,this,shard,syncs,the,global,checkpoint,return,a,new,shard,throws,ioexception,if,an,i,o,exception,occurs,when,creating,the,shard;t,create,shard,shard,routing,shard,routing,recovery,state,recovery,state,peer,recovery,target,service,recovery,target,service,peer,recovery,target,service,recovery,listener,recovery,listener,repositories,service,repositories,service,consumer,index,shard,shard,failure,on,shard,failure,consumer,shard,id,global,checkpoint,syncer,throws,ioexception
IndicesClusterStateService -> AllocatedIndices -> T createShard(                 ShardRouting shardRouting,                 RecoveryState recoveryState,                 PeerRecoveryTargetService recoveryTargetService,                 PeerRecoveryTargetService.RecoveryListener recoveryListener,                 RepositoriesService repositoriesService,                 Consumer<IndexShard.ShardFailure> onShardFailure,                 Consumer<ShardId> globalCheckpointSyncer) throws IOException_;1547625930;Creates a shard for the specified shard routing and starts recovery.__@param shardRouting           the shard routing_@param recoveryState          the recovery state_@param recoveryTargetService  recovery service for the target_@param recoveryListener       a callback when recovery changes state (finishes or fails)_@param repositoriesService    service responsible for snapshot/restore_@param onShardFailure         a callback when this shard fails_@param globalCheckpointSyncer a callback when this shard syncs the global checkpoint_@return a new shard_@throws IOException if an I/O exception occurs when creating the shard;T createShard(_                ShardRouting shardRouting,_                RecoveryState recoveryState,_                PeerRecoveryTargetService recoveryTargetService,_                PeerRecoveryTargetService.RecoveryListener recoveryListener,_                RepositoriesService repositoriesService,_                Consumer<IndexShard.ShardFailure> onShardFailure,_                Consumer<ShardId> globalCheckpointSyncer) throws IOException_;creates,a,shard,for,the,specified,shard,routing,and,starts,recovery,param,shard,routing,the,shard,routing,param,recovery,state,the,recovery,state,param,recovery,target,service,recovery,service,for,the,target,param,recovery,listener,a,callback,when,recovery,changes,state,finishes,or,fails,param,repositories,service,service,responsible,for,snapshot,restore,param,on,shard,failure,a,callback,when,this,shard,fails,param,global,checkpoint,syncer,a,callback,when,this,shard,syncs,the,global,checkpoint,return,a,new,shard,throws,ioexception,if,an,i,o,exception,occurs,when,creating,the,shard;t,create,shard,shard,routing,shard,routing,recovery,state,recovery,state,peer,recovery,target,service,recovery,target,service,peer,recovery,target,service,recovery,listener,recovery,listener,repositories,service,repositories,service,consumer,index,shard,shard,failure,on,shard,failure,consumer,shard,id,global,checkpoint,syncer,throws,ioexception
IndicesClusterStateService -> AllocatedIndex -> void removeShard(int shardId, String message)_;1524684173;Removes shard with given id.;void removeShard(int shardId, String message)_;removes,shard,with,given,id;void,remove,shard,int,shard,id,string,message
IndicesClusterStateService -> AllocatedIndex -> void removeShard(int shardId, String message)_;1533063033;Removes shard with given id.;void removeShard(int shardId, String message)_;removes,shard,with,given,id;void,remove,shard,int,shard,id,string,message
IndicesClusterStateService -> AllocatedIndex -> void removeShard(int shardId, String message)_;1535405719;Removes shard with given id.;void removeShard(int shardId, String message)_;removes,shard,with,given,id;void,remove,shard,int,shard,id,string,message
IndicesClusterStateService -> AllocatedIndex -> void removeShard(int shardId, String message)_;1539723533;Removes shard with given id.;void removeShard(int shardId, String message)_;removes,shard,with,given,id;void,remove,shard,int,shard,id,string,message
IndicesClusterStateService -> AllocatedIndex -> void removeShard(int shardId, String message)_;1541008027;Removes shard with given id.;void removeShard(int shardId, String message)_;removes,shard,with,given,id;void,remove,shard,int,shard,id,string,message
IndicesClusterStateService -> AllocatedIndex -> void removeShard(int shardId, String message)_;1542646292;Removes shard with given id.;void removeShard(int shardId, String message)_;removes,shard,with,given,id;void,remove,shard,int,shard,id,string,message
IndicesClusterStateService -> AllocatedIndex -> void removeShard(int shardId, String message)_;1547520324;Removes shard with given id.;void removeShard(int shardId, String message)_;removes,shard,with,given,id;void,remove,shard,int,shard,id,string,message
IndicesClusterStateService -> AllocatedIndex -> void removeShard(int shardId, String message)_;1547536822;Removes shard with given id.;void removeShard(int shardId, String message)_;removes,shard,with,given,id;void,remove,shard,int,shard,id,string,message
IndicesClusterStateService -> AllocatedIndex -> void removeShard(int shardId, String message)_;1547625930;Removes shard with given id.;void removeShard(int shardId, String message)_;removes,shard,with,given,id;void,remove,shard,int,shard,id,string,message
IndicesClusterStateService -> AllocatedIndex -> void removeShard(int shardId, String message)_;1548593396;Removes shard with given id.;void removeShard(int shardId, String message)_;removes,shard,with,given,id;void,remove,shard,int,shard,id,string,message
IndicesClusterStateService -> AllocatedIndex -> void removeShard(int shardId, String message)_;1548770980;Removes shard with given id.;void removeShard(int shardId, String message)_;removes,shard,with,given,id;void,remove,shard,int,shard,id,string,message
IndicesClusterStateService -> AllocatedIndex -> void removeShard(int shardId, String message)_;1548872469;Removes shard with given id.;void removeShard(int shardId, String message)_;removes,shard,with,given,id;void,remove,shard,int,shard,id,string,message
IndicesClusterStateService -> AllocatedIndex -> void removeShard(int shardId, String message)_;1549294529;Removes shard with given id.;void removeShard(int shardId, String message)_;removes,shard,with,given,id;void,remove,shard,int,shard,id,string,message
IndicesClusterStateService -> AllocatedIndices -> default T getShardOrNull(ShardId shardId);1524684173;Returns shard for the specified id if it exists otherwise returns <code>null</code>.;default T getShardOrNull(ShardId shardId) {_            U indexRef = indexService(shardId.getIndex())__            if (indexRef != null) {_                return indexRef.getShardOrNull(shardId.id())__            }_            return null__        };returns,shard,for,the,specified,id,if,it,exists,otherwise,returns,code,null,code;default,t,get,shard,or,null,shard,id,shard,id,u,index,ref,index,service,shard,id,get,index,if,index,ref,null,return,index,ref,get,shard,or,null,shard,id,id,return,null
IndicesClusterStateService -> AllocatedIndices -> default T getShardOrNull(ShardId shardId);1533063033;Returns shard for the specified id if it exists otherwise returns <code>null</code>.;default T getShardOrNull(ShardId shardId) {_            U indexRef = indexService(shardId.getIndex())__            if (indexRef != null) {_                return indexRef.getShardOrNull(shardId.id())__            }_            return null__        };returns,shard,for,the,specified,id,if,it,exists,otherwise,returns,code,null,code;default,t,get,shard,or,null,shard,id,shard,id,u,index,ref,index,service,shard,id,get,index,if,index,ref,null,return,index,ref,get,shard,or,null,shard,id,id,return,null
IndicesClusterStateService -> AllocatedIndices -> default T getShardOrNull(ShardId shardId);1535405719;Returns shard for the specified id if it exists otherwise returns <code>null</code>.;default T getShardOrNull(ShardId shardId) {_            U indexRef = indexService(shardId.getIndex())__            if (indexRef != null) {_                return indexRef.getShardOrNull(shardId.id())__            }_            return null__        };returns,shard,for,the,specified,id,if,it,exists,otherwise,returns,code,null,code;default,t,get,shard,or,null,shard,id,shard,id,u,index,ref,index,service,shard,id,get,index,if,index,ref,null,return,index,ref,get,shard,or,null,shard,id,id,return,null
IndicesClusterStateService -> AllocatedIndices -> default T getShardOrNull(ShardId shardId);1539723533;Returns shard for the specified id if it exists otherwise returns <code>null</code>.;default T getShardOrNull(ShardId shardId) {_            U indexRef = indexService(shardId.getIndex())__            if (indexRef != null) {_                return indexRef.getShardOrNull(shardId.id())__            }_            return null__        };returns,shard,for,the,specified,id,if,it,exists,otherwise,returns,code,null,code;default,t,get,shard,or,null,shard,id,shard,id,u,index,ref,index,service,shard,id,get,index,if,index,ref,null,return,index,ref,get,shard,or,null,shard,id,id,return,null
IndicesClusterStateService -> AllocatedIndices -> default T getShardOrNull(ShardId shardId);1541008027;Returns shard for the specified id if it exists otherwise returns <code>null</code>.;default T getShardOrNull(ShardId shardId) {_            U indexRef = indexService(shardId.getIndex())__            if (indexRef != null) {_                return indexRef.getShardOrNull(shardId.id())__            }_            return null__        };returns,shard,for,the,specified,id,if,it,exists,otherwise,returns,code,null,code;default,t,get,shard,or,null,shard,id,shard,id,u,index,ref,index,service,shard,id,get,index,if,index,ref,null,return,index,ref,get,shard,or,null,shard,id,id,return,null
IndicesClusterStateService -> AllocatedIndices -> default T getShardOrNull(ShardId shardId);1542646292;Returns shard for the specified id if it exists otherwise returns <code>null</code>.;default T getShardOrNull(ShardId shardId) {_            U indexRef = indexService(shardId.getIndex())__            if (indexRef != null) {_                return indexRef.getShardOrNull(shardId.id())__            }_            return null__        };returns,shard,for,the,specified,id,if,it,exists,otherwise,returns,code,null,code;default,t,get,shard,or,null,shard,id,shard,id,u,index,ref,index,service,shard,id,get,index,if,index,ref,null,return,index,ref,get,shard,or,null,shard,id,id,return,null
IndicesClusterStateService -> AllocatedIndices -> default T getShardOrNull(ShardId shardId);1547520324;Returns shard for the specified id if it exists otherwise returns <code>null</code>.;default T getShardOrNull(ShardId shardId) {_            U indexRef = indexService(shardId.getIndex())__            if (indexRef != null) {_                return indexRef.getShardOrNull(shardId.id())__            }_            return null__        };returns,shard,for,the,specified,id,if,it,exists,otherwise,returns,code,null,code;default,t,get,shard,or,null,shard,id,shard,id,u,index,ref,index,service,shard,id,get,index,if,index,ref,null,return,index,ref,get,shard,or,null,shard,id,id,return,null
IndicesClusterStateService -> AllocatedIndices -> default T getShardOrNull(ShardId shardId);1547536822;Returns shard for the specified id if it exists otherwise returns <code>null</code>.;default T getShardOrNull(ShardId shardId) {_            U indexRef = indexService(shardId.getIndex())__            if (indexRef != null) {_                return indexRef.getShardOrNull(shardId.id())__            }_            return null__        };returns,shard,for,the,specified,id,if,it,exists,otherwise,returns,code,null,code;default,t,get,shard,or,null,shard,id,shard,id,u,index,ref,index,service,shard,id,get,index,if,index,ref,null,return,index,ref,get,shard,or,null,shard,id,id,return,null
IndicesClusterStateService -> AllocatedIndices -> default T getShardOrNull(ShardId shardId);1547625930;Returns shard for the specified id if it exists otherwise returns <code>null</code>.;default T getShardOrNull(ShardId shardId) {_            U indexRef = indexService(shardId.getIndex())__            if (indexRef != null) {_                return indexRef.getShardOrNull(shardId.id())__            }_            return null__        };returns,shard,for,the,specified,id,if,it,exists,otherwise,returns,code,null,code;default,t,get,shard,or,null,shard,id,shard,id,u,index,ref,index,service,shard,id,get,index,if,index,ref,null,return,index,ref,get,shard,or,null,shard,id,id,return,null
IndicesClusterStateService -> AllocatedIndices -> default T getShardOrNull(ShardId shardId);1548593396;Returns shard for the specified id if it exists otherwise returns <code>null</code>.;default T getShardOrNull(ShardId shardId) {_            U indexRef = indexService(shardId.getIndex())__            if (indexRef != null) {_                return indexRef.getShardOrNull(shardId.id())__            }_            return null__        };returns,shard,for,the,specified,id,if,it,exists,otherwise,returns,code,null,code;default,t,get,shard,or,null,shard,id,shard,id,u,index,ref,index,service,shard,id,get,index,if,index,ref,null,return,index,ref,get,shard,or,null,shard,id,id,return,null
IndicesClusterStateService -> AllocatedIndices -> default T getShardOrNull(ShardId shardId);1548770980;Returns shard for the specified id if it exists otherwise returns <code>null</code>.;default T getShardOrNull(ShardId shardId) {_            U indexRef = indexService(shardId.getIndex())__            if (indexRef != null) {_                return indexRef.getShardOrNull(shardId.id())__            }_            return null__        };returns,shard,for,the,specified,id,if,it,exists,otherwise,returns,code,null,code;default,t,get,shard,or,null,shard,id,shard,id,u,index,ref,index,service,shard,id,get,index,if,index,ref,null,return,index,ref,get,shard,or,null,shard,id,id,return,null
IndicesClusterStateService -> AllocatedIndices -> default T getShardOrNull(ShardId shardId);1548872469;Returns shard for the specified id if it exists otherwise returns <code>null</code>.;default T getShardOrNull(ShardId shardId) {_            U indexRef = indexService(shardId.getIndex())__            if (indexRef != null) {_                return indexRef.getShardOrNull(shardId.id())__            }_            return null__        };returns,shard,for,the,specified,id,if,it,exists,otherwise,returns,code,null,code;default,t,get,shard,or,null,shard,id,shard,id,u,index,ref,index,service,shard,id,get,index,if,index,ref,null,return,index,ref,get,shard,or,null,shard,id,id,return,null
IndicesClusterStateService -> AllocatedIndices -> default T getShardOrNull(ShardId shardId);1549294529;Returns shard for the specified id if it exists otherwise returns <code>null</code>.;default T getShardOrNull(ShardId shardId) {_            U indexRef = indexService(shardId.getIndex())__            if (indexRef != null) {_                return indexRef.getShardOrNull(shardId.id())__            }_            return null__        };returns,shard,for,the,specified,id,if,it,exists,otherwise,returns,code,null,code;default,t,get,shard,or,null,shard,id,shard,id,u,index,ref,index,service,shard,id,get,index,if,index,ref,null,return,index,ref,get,shard,or,null,shard,id,id,return,null
IndicesClusterStateService -> AllocatedIndices -> void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState)_;1524684173;Deletes an index that is not assigned to this node. This method cleans up all disk folders relating to the index_but does not deal with in-memory structures. For those call {@link #removeIndex(Index, IndexRemovalReason, String)};void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState)_;deletes,an,index,that,is,not,assigned,to,this,node,this,method,cleans,up,all,disk,folders,relating,to,the,index,but,does,not,deal,with,in,memory,structures,for,those,call,link,remove,index,index,index,removal,reason,string;void,delete,unassigned,index,string,reason,index,meta,data,meta,data,cluster,state,cluster,state
IndicesClusterStateService -> AllocatedIndices -> void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState)_;1533063033;Deletes an index that is not assigned to this node. This method cleans up all disk folders relating to the index_but does not deal with in-memory structures. For those call {@link #removeIndex(Index, IndexRemovalReason, String)};void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState)_;deletes,an,index,that,is,not,assigned,to,this,node,this,method,cleans,up,all,disk,folders,relating,to,the,index,but,does,not,deal,with,in,memory,structures,for,those,call,link,remove,index,index,index,removal,reason,string;void,delete,unassigned,index,string,reason,index,meta,data,meta,data,cluster,state,cluster,state
IndicesClusterStateService -> AllocatedIndices -> void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState)_;1535405719;Deletes an index that is not assigned to this node. This method cleans up all disk folders relating to the index_but does not deal with in-memory structures. For those call {@link #removeIndex(Index, IndexRemovalReason, String)};void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState)_;deletes,an,index,that,is,not,assigned,to,this,node,this,method,cleans,up,all,disk,folders,relating,to,the,index,but,does,not,deal,with,in,memory,structures,for,those,call,link,remove,index,index,index,removal,reason,string;void,delete,unassigned,index,string,reason,index,meta,data,meta,data,cluster,state,cluster,state
IndicesClusterStateService -> AllocatedIndices -> void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState)_;1539723533;Deletes an index that is not assigned to this node. This method cleans up all disk folders relating to the index_but does not deal with in-memory structures. For those call {@link #removeIndex(Index, IndexRemovalReason, String)};void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState)_;deletes,an,index,that,is,not,assigned,to,this,node,this,method,cleans,up,all,disk,folders,relating,to,the,index,but,does,not,deal,with,in,memory,structures,for,those,call,link,remove,index,index,index,removal,reason,string;void,delete,unassigned,index,string,reason,index,meta,data,meta,data,cluster,state,cluster,state
IndicesClusterStateService -> AllocatedIndices -> void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState)_;1541008027;Deletes an index that is not assigned to this node. This method cleans up all disk folders relating to the index_but does not deal with in-memory structures. For those call {@link #removeIndex(Index, IndexRemovalReason, String)};void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState)_;deletes,an,index,that,is,not,assigned,to,this,node,this,method,cleans,up,all,disk,folders,relating,to,the,index,but,does,not,deal,with,in,memory,structures,for,those,call,link,remove,index,index,index,removal,reason,string;void,delete,unassigned,index,string,reason,index,meta,data,meta,data,cluster,state,cluster,state
IndicesClusterStateService -> AllocatedIndices -> void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState)_;1542646292;Deletes an index that is not assigned to this node. This method cleans up all disk folders relating to the index_but does not deal with in-memory structures. For those call {@link #removeIndex(Index, IndexRemovalReason, String)};void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState)_;deletes,an,index,that,is,not,assigned,to,this,node,this,method,cleans,up,all,disk,folders,relating,to,the,index,but,does,not,deal,with,in,memory,structures,for,those,call,link,remove,index,index,index,removal,reason,string;void,delete,unassigned,index,string,reason,index,meta,data,meta,data,cluster,state,cluster,state
IndicesClusterStateService -> AllocatedIndices -> void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState)_;1547520324;Deletes an index that is not assigned to this node. This method cleans up all disk folders relating to the index_but does not deal with in-memory structures. For those call {@link #removeIndex(Index, IndexRemovalReason, String)};void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState)_;deletes,an,index,that,is,not,assigned,to,this,node,this,method,cleans,up,all,disk,folders,relating,to,the,index,but,does,not,deal,with,in,memory,structures,for,those,call,link,remove,index,index,index,removal,reason,string;void,delete,unassigned,index,string,reason,index,meta,data,meta,data,cluster,state,cluster,state
IndicesClusterStateService -> AllocatedIndices -> void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState)_;1547536822;Deletes an index that is not assigned to this node. This method cleans up all disk folders relating to the index_but does not deal with in-memory structures. For those call {@link #removeIndex(Index, IndexRemovalReason, String)};void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState)_;deletes,an,index,that,is,not,assigned,to,this,node,this,method,cleans,up,all,disk,folders,relating,to,the,index,but,does,not,deal,with,in,memory,structures,for,those,call,link,remove,index,index,index,removal,reason,string;void,delete,unassigned,index,string,reason,index,meta,data,meta,data,cluster,state,cluster,state
IndicesClusterStateService -> AllocatedIndices -> void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState)_;1547625930;Deletes an index that is not assigned to this node. This method cleans up all disk folders relating to the index_but does not deal with in-memory structures. For those call {@link #removeIndex(Index, IndexRemovalReason, String)};void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState)_;deletes,an,index,that,is,not,assigned,to,this,node,this,method,cleans,up,all,disk,folders,relating,to,the,index,but,does,not,deal,with,in,memory,structures,for,those,call,link,remove,index,index,index,removal,reason,string;void,delete,unassigned,index,string,reason,index,meta,data,meta,data,cluster,state,cluster,state
IndicesClusterStateService -> AllocatedIndices -> void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState)_;1548593396;Deletes an index that is not assigned to this node. This method cleans up all disk folders relating to the index_but does not deal with in-memory structures. For those call {@link #removeIndex(Index, IndexRemovalReason, String)};void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState)_;deletes,an,index,that,is,not,assigned,to,this,node,this,method,cleans,up,all,disk,folders,relating,to,the,index,but,does,not,deal,with,in,memory,structures,for,those,call,link,remove,index,index,index,removal,reason,string;void,delete,unassigned,index,string,reason,index,meta,data,meta,data,cluster,state,cluster,state
IndicesClusterStateService -> AllocatedIndices -> void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState)_;1548770980;Deletes an index that is not assigned to this node. This method cleans up all disk folders relating to the index_but does not deal with in-memory structures. For those call {@link #removeIndex(Index, IndexRemovalReason, String)};void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState)_;deletes,an,index,that,is,not,assigned,to,this,node,this,method,cleans,up,all,disk,folders,relating,to,the,index,but,does,not,deal,with,in,memory,structures,for,those,call,link,remove,index,index,index,removal,reason,string;void,delete,unassigned,index,string,reason,index,meta,data,meta,data,cluster,state,cluster,state
IndicesClusterStateService -> AllocatedIndices -> void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState)_;1548872469;Deletes an index that is not assigned to this node. This method cleans up all disk folders relating to the index_but does not deal with in-memory structures. For those call {@link #removeIndex(Index, IndexRemovalReason, String)};void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState)_;deletes,an,index,that,is,not,assigned,to,this,node,this,method,cleans,up,all,disk,folders,relating,to,the,index,but,does,not,deal,with,in,memory,structures,for,those,call,link,remove,index,index,index,removal,reason,string;void,delete,unassigned,index,string,reason,index,meta,data,meta,data,cluster,state,cluster,state
IndicesClusterStateService -> AllocatedIndices -> void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState)_;1549294529;Deletes an index that is not assigned to this node. This method cleans up all disk folders relating to the index_but does not deal with in-memory structures. For those call {@link #removeIndex(Index, IndexRemovalReason, String)};void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState)_;deletes,an,index,that,is,not,assigned,to,this,node,this,method,cleans,up,all,disk,folders,relating,to,the,index,but,does,not,deal,with,in,memory,structures,for,those,call,link,remove,index,index,index,removal,reason,string;void,delete,unassigned,index,string,reason,index,meta,data,meta,data,cluster,state,cluster,state
