commented;modifiers;parameterAmount;loc;comment;code
false;public;3;7;;@Override public void sync(final ShardId shardId, final RetentionLeases retentionLeases, final ActionListener<ReplicationResponse> listener) {     Objects.requireNonNull(retentionLeaseSyncAction).sync(shardId, retentionLeases, listener). }
false;public;2;4;;@Override public void backgroundSync(final ShardId shardId, final RetentionLeases retentionLeases) {     Objects.requireNonNull(retentionLeaseBackgroundSyncAction).backgroundSync(shardId, retentionLeases). }
false;protected;0;7;;@Override protected void doStart() {     // Doesn't make sense to manage shards on non-master and non-data nodes     if (DiscoveryNode.isDataNode(settings) || DiscoveryNode.isMasterNode(settings)) {         clusterService.addHighPriorityApplier(this).     } }
false;protected;0;6;;@Override protected void doStop() {     if (DiscoveryNode.isDataNode(settings) || DiscoveryNode.isMasterNode(settings)) {         clusterService.removeApplier(this).     } }
false;protected;0;3;;@Override protected void doClose() { }
false;public,synchronized;1;35;;@Override public synchronized void applyClusterState(final ClusterChangedEvent event) {     if (!lifecycle.started()) {         return.     }     final ClusterState state = event.state().     // TODO: feels hacky, a block disables state persistence, and then we clean the allocated shards, maybe another flag in blocks?     if (state.blocks().disableStatePersistence()) {         for (AllocatedIndex<? extends Shard> indexService : indicesService) {             indicesService.removeIndex(indexService.index(), NO_LONGER_ASSIGNED, // also cleans shards             "cleaning index (disabled block persistence)").         }         return.     }     updateFailedShardsCache(state).     // also deletes shards of deleted indices     deleteIndices(event).     // also removes shards of removed indices     removeIndices(event).     failMissingShards(state).     // removes any local shards that doesn't match what the master expects     removeShards(state).     // can also fail shards, but these are then guaranteed to be in failedShardsCache     updateIndices(event).     createIndices(state).     createOrUpdateShards(state). }
true;private;1;24;/**  * Removes shard entries from the failed shards cache that are no longer allocated to this node by the master.  * Sends shard failures for shards that are marked as actively allocated to this node but don't actually exist on the node.  * Resends shard failures for shards that are still marked as allocated to this node but previously failed.  *  * @param state new cluster state  */ ;/**  * Removes shard entries from the failed shards cache that are no longer allocated to this node by the master.  * Sends shard failures for shards that are marked as actively allocated to this node but don't actually exist on the node.  * Resends shard failures for shards that are still marked as allocated to this node but previously failed.  *  * @param state new cluster state  */ private void updateFailedShardsCache(final ClusterState state) {     RoutingNode localRoutingNode = state.getRoutingNodes().node(state.nodes().getLocalNodeId()).     if (localRoutingNode == null) {         failedShardsCache.clear().         return.     }     DiscoveryNode masterNode = state.nodes().getMasterNode().     // remove items from cache which are not in our routing table anymore and resend failures that have not executed on master yet     for (Iterator<Map.Entry<ShardId, ShardRouting>> iterator = failedShardsCache.entrySet().iterator(). iterator.hasNext(). ) {         ShardRouting failedShardRouting = iterator.next().getValue().         ShardRouting matchedRouting = localRoutingNode.getByShardId(failedShardRouting.shardId()).         if (matchedRouting == null || matchedRouting.isSameAllocation(failedShardRouting) == false) {             iterator.remove().         } else {             if (masterNode != null) {                 // TODO: can we remove this? Is resending shard failures the responsibility of shardStateAction?                 String message = "master " + masterNode + " has not removed previously failed shard. resending shard failure".                 logger.trace("[{}] re-sending failed shard [{}], reason [{}]", matchedRouting.shardId(), matchedRouting, message).                 shardStateAction.localShardFailed(matchedRouting, message, null, SHARD_STATE_ACTION_LISTENER, state).             }         }     } }
false;public;1;4;;@Override public void onFailure(Exception e) {     logger.warn(() -> new ParameterizedMessage("[{}] failed to complete pending deletion for index", index), e). }
false;protected;0;14;;@Override protected void doRun() throws Exception {     try {         // we are waiting until we can lock the index / all shards on the node and then we ack the delete of the store         // to the master. If we can't acquire the locks here immediately there might be a shard of this index still         // holding on to the lock due to a "currently canceled recovery" or so. The shard will delete itself BEFORE the         // lock is released so it's guaranteed to be deleted by the time we get the lock         indicesService.processPendingDeletes(index, indexSettings, new TimeValue(30, TimeUnit.MINUTES)).     } catch (LockObtainFailedException exc) {         logger.warn("[{}] failed to lock all shards for index - timed out after 30 seconds", index).     } catch (InterruptedException e) {         logger.warn("[{}] failed to lock all shards for index - interrupted", index).     } }
true;private;1;60;/**  * Deletes indices (with shard data).  *  * @param event cluster change event  */ ;/**  * Deletes indices (with shard data).  *  * @param event cluster change event  */ private void deleteIndices(final ClusterChangedEvent event) {     final ClusterState previousState = event.previousState().     final ClusterState state = event.state().     final String localNodeId = state.nodes().getLocalNodeId().     assert localNodeId != null.     for (Index index : event.indicesDeleted()) {         if (logger.isDebugEnabled()) {             logger.debug("[{}] cleaning index, no longer part of the metadata", index).         }         AllocatedIndex<? extends Shard> indexService = indicesService.indexService(index).         final IndexSettings indexSettings.         if (indexService != null) {             indexSettings = indexService.getIndexSettings().             indicesService.removeIndex(index, DELETED, "index no longer part of the metadata").         } else if (previousState.metaData().hasIndex(index.getName())) {             // The deleted index was part of the previous cluster state, but not loaded on the local node             final IndexMetaData metaData = previousState.metaData().index(index).             indexSettings = new IndexSettings(metaData, settings).             indicesService.deleteUnassignedIndex("deleted index was not assigned to local node", metaData, state).         } else {             // asserting that the previous cluster state is not initialized/recovered.             assert previousState.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK).             final IndexMetaData metaData = indicesService.verifyIndexIsDeleted(index, event.state()).             if (metaData != null) {                 indexSettings = new IndexSettings(metaData, settings).             } else {                 indexSettings = null.             }         }         if (indexSettings != null) {             threadPool.generic().execute(new AbstractRunnable() {                  @Override                 public void onFailure(Exception e) {                     logger.warn(() -> new ParameterizedMessage("[{}] failed to complete pending deletion for index", index), e).                 }                  @Override                 protected void doRun() throws Exception {                     try {                         // we are waiting until we can lock the index / all shards on the node and then we ack the delete of the store                         // to the master. If we can't acquire the locks here immediately there might be a shard of this index still                         // holding on to the lock due to a "currently canceled recovery" or so. The shard will delete itself BEFORE the                         // lock is released so it's guaranteed to be deleted by the time we get the lock                         indicesService.processPendingDeletes(index, indexSettings, new TimeValue(30, TimeUnit.MINUTES)).                     } catch (LockObtainFailedException exc) {                         logger.warn("[{}] failed to lock all shards for index - timed out after 30 seconds", index).                     } catch (InterruptedException e) {                         logger.warn("[{}] failed to lock all shards for index - interrupted", index).                     }                 }             }).         }     } }
true;private;1;38;/**  * Removes indices that have no shards allocated to this node or indices whose state has changed. This does not delete the shard data  * as we wait for enough shard copies to exist in the cluster before deleting shard data (triggered by  * {@link org.elasticsearch.indices.store.IndicesStore}).  *  * @param event the cluster changed event  */ ;/**  * Removes indices that have no shards allocated to this node or indices whose state has changed. This does not delete the shard data  * as we wait for enough shard copies to exist in the cluster before deleting shard data (triggered by  * {@link org.elasticsearch.indices.store.IndicesStore}).  *  * @param event the cluster changed event  */ private void removeIndices(final ClusterChangedEvent event) {     final ClusterState state = event.state().     final String localNodeId = state.nodes().getLocalNodeId().     assert localNodeId != null.     final Set<Index> indicesWithShards = new HashSet<>().     RoutingNode localRoutingNode = state.getRoutingNodes().node(localNodeId).     if (localRoutingNode != null) {         // null e.g. if we are not a data node         for (ShardRouting shardRouting : localRoutingNode) {             indicesWithShards.add(shardRouting.index()).         }     }     for (AllocatedIndex<? extends Shard> indexService : indicesService) {         final Index index = indexService.index().         final IndexMetaData indexMetaData = state.metaData().index(index).         final IndexMetaData existingMetaData = indexService.getIndexSettings().getIndexMetaData().         AllocatedIndices.IndexRemovalReason reason = null.         if (indexMetaData != null && indexMetaData.getState() != existingMetaData.getState()) {             reason = indexMetaData.getState() == IndexMetaData.State.CLOSE ? CLOSED : REOPENED.         } else if (indicesWithShards.contains(index) == false) {             // dangling index             assert indexMetaData != null || event.isNewCluster() : "index " + index + " does not exist in the cluster state, it should either " + "have been deleted or the cluster must be new".             reason = indexMetaData != null && indexMetaData.getState() == IndexMetaData.State.CLOSE ? CLOSED : NO_LONGER_ASSIGNED.         }         if (reason != null) {             logger.debug("{} removing index ({})", index, reason).             indicesService.removeIndex(index, reason, "removing index (" + reason + ")").         }     } }
true;private;1;16;/**  * Notifies master about shards that don't exist but are supposed to be active on this node.  *  * @param state new cluster state  */ ;/**  * Notifies master about shards that don't exist but are supposed to be active on this node.  *  * @param state new cluster state  */ private void failMissingShards(final ClusterState state) {     RoutingNode localRoutingNode = state.getRoutingNodes().node(state.nodes().getLocalNodeId()).     if (localRoutingNode == null) {         return.     }     for (final ShardRouting shardRouting : localRoutingNode) {         ShardId shardId = shardRouting.shardId().         if (shardRouting.initializing() == false && failedShardsCache.containsKey(shardId) == false && indicesService.getShardOrNull(shardId) == null) {             // the master thinks we are active, but we don't have this shard at all, mark it as failed             sendFailShard(shardRouting, "master marked shard as active, but shard has not been created, mark shard as failed", null, state).         }     } }
true;private;1;36;/**  * Removes shards that are currently loaded by indicesService but have disappeared from the routing table of the current node.  * This method does not delete the shard data.  *  * @param state new cluster state  */ ;/**  * Removes shards that are currently loaded by indicesService but have disappeared from the routing table of the current node.  * This method does not delete the shard data.  *  * @param state new cluster state  */ private void removeShards(final ClusterState state) {     final String localNodeId = state.nodes().getLocalNodeId().     assert localNodeId != null.     // remove shards based on routing nodes (no deletion of data)     RoutingNode localRoutingNode = state.getRoutingNodes().node(localNodeId).     for (AllocatedIndex<? extends Shard> indexService : indicesService) {         for (Shard shard : indexService) {             ShardRouting currentRoutingEntry = shard.routingEntry().             ShardId shardId = currentRoutingEntry.shardId().             ShardRouting newShardRouting = localRoutingNode == null ? null : localRoutingNode.getByShardId(shardId).             if (newShardRouting == null) {                 // we can just remove the shard without cleaning it locally, since we will clean it in IndicesStore                 // once all shards are allocated                 logger.debug("{} removing shard (not allocated)", shardId).                 indexService.removeShard(shardId.id(), "removing shard (not allocated)").             } else if (newShardRouting.isSameAllocation(currentRoutingEntry) == false) {                 logger.debug("{} removing shard (stale allocation id, stale {}, new {})", shardId, currentRoutingEntry, newShardRouting).                 indexService.removeShard(shardId.id(), "removing shard (stale copy)").             } else if (newShardRouting.initializing() && currentRoutingEntry.active()) {                 // this can happen if the node was isolated/gc-ed, rejoins the cluster and a new shard with the same allocation id                 // is assigned to it. Batch cluster state processing or if shard fetching completes before the node gets a new cluster                 // state may result in a new shard being initialized while having the same allocation id as the currently started shard.                 logger.debug("{} removing shard (not active, current {}, new {})", shardId, currentRoutingEntry, newShardRouting).                 indexService.removeShard(shardId.id(), "removing shard (stale copy)").             } else if (newShardRouting.primary() && currentRoutingEntry.primary() == false && newShardRouting.initializing()) {                 // see above if clause                 assert currentRoutingEntry.initializing() : currentRoutingEntry.                 // this can happen when cluster state batching batches activation of the shard, closing an index, reopening it                 // and assigning an initializing primary to this node                 logger.debug("{} removing shard (not active, current {}, new {})", shardId, currentRoutingEntry, newShardRouting).                 indexService.removeShard(shardId.id(), "removing shard (stale copy)").             }         }     } }
false;private;1;45;;private void createIndices(final ClusterState state) {     // we only create indices for shards that are allocated     RoutingNode localRoutingNode = state.getRoutingNodes().node(state.nodes().getLocalNodeId()).     if (localRoutingNode == null) {         return.     }     // create map of indices to create with shards to fail if index creation fails     final Map<Index, List<ShardRouting>> indicesToCreate = new HashMap<>().     for (ShardRouting shardRouting : localRoutingNode) {         if (failedShardsCache.containsKey(shardRouting.shardId()) == false) {             final Index index = shardRouting.index().             if (indicesService.indexService(index) == null) {                 indicesToCreate.computeIfAbsent(index, k -> new ArrayList<>()).add(shardRouting).             }         }     }     for (Map.Entry<Index, List<ShardRouting>> entry : indicesToCreate.entrySet()) {         final Index index = entry.getKey().         final IndexMetaData indexMetaData = state.metaData().index(index).         logger.debug("[{}] creating index", index).         AllocatedIndex<? extends Shard> indexService = null.         try {             indexService = indicesService.createIndex(indexMetaData, buildInIndexListener).             if (indexService.updateMapping(null, indexMetaData) && sendRefreshMapping) {                 nodeMappingRefreshAction.nodeMappingRefresh(state.nodes().getMasterNode(), new NodeMappingRefreshAction.NodeMappingRefreshRequest(indexMetaData.getIndex().getName(), indexMetaData.getIndexUUID(), state.nodes().getLocalNodeId())).             }         } catch (Exception e) {             final String failShardReason.             if (indexService == null) {                 failShardReason = "failed to create index".             } else {                 failShardReason = "failed to update mapping for index".                 indicesService.removeIndex(index, FAILURE, "removing index (mapping update failed)").             }             for (ShardRouting shardRouting : entry.getValue()) {                 sendFailShard(shardRouting, failShardReason, e, state).             }         }     } }
false;private;1;35;;private void updateIndices(ClusterChangedEvent event) {     if (!event.metaDataChanged()) {         return.     }     final ClusterState state = event.state().     for (AllocatedIndex<? extends Shard> indexService : indicesService) {         final Index index = indexService.index().         final IndexMetaData currentIndexMetaData = indexService.getIndexSettings().getIndexMetaData().         final IndexMetaData newIndexMetaData = state.metaData().index(index).         assert newIndexMetaData != null : "index " + index + " should have been removed by deleteIndices".         if (ClusterChangedEvent.indexMetaDataChanged(currentIndexMetaData, newIndexMetaData)) {             indexService.updateMetaData(currentIndexMetaData, newIndexMetaData).             try {                 if (indexService.updateMapping(currentIndexMetaData, newIndexMetaData) && sendRefreshMapping) {                     nodeMappingRefreshAction.nodeMappingRefresh(state.nodes().getMasterNode(), new NodeMappingRefreshAction.NodeMappingRefreshRequest(newIndexMetaData.getIndex().getName(), newIndexMetaData.getIndexUUID(), state.nodes().getLocalNodeId())).                 }             } catch (Exception e) {                 indicesService.removeIndex(indexService.index(), FAILURE, "removing index (mapping update failed)").                 // fail shards that would be created or updated by createOrUpdateShards                 RoutingNode localRoutingNode = state.getRoutingNodes().node(state.nodes().getLocalNodeId()).                 if (localRoutingNode != null) {                     for (final ShardRouting shardRouting : localRoutingNode) {                         if (shardRouting.index().equals(index) && failedShardsCache.containsKey(shardRouting.shardId()) == false) {                             sendFailShard(shardRouting, "failed to update mapping for index", e, state).                         }                     }                 }             }         }     } }
false;private;1;24;;private void createOrUpdateShards(final ClusterState state) {     RoutingNode localRoutingNode = state.getRoutingNodes().node(state.nodes().getLocalNodeId()).     if (localRoutingNode == null) {         return.     }     DiscoveryNodes nodes = state.nodes().     RoutingTable routingTable = state.routingTable().     for (final ShardRouting shardRouting : localRoutingNode) {         ShardId shardId = shardRouting.shardId().         if (failedShardsCache.containsKey(shardId) == false) {             AllocatedIndex<? extends Shard> indexService = indicesService.indexService(shardId.getIndex()).             assert indexService != null : "index " + shardId.getIndex() + " should have been created by createIndices".             Shard shard = indexService.getShardOrNull(shardId.id()).             if (shard == null) {                 assert shardRouting.initializing() : shardRouting + " should have been removed by failMissingShards".                 createShard(nodes, routingTable, shardRouting, state).             } else {                 updateShard(nodes, shardRouting, shard, routingTable, state).             }         }     } }
false;private;4;29;;private void createShard(DiscoveryNodes nodes, RoutingTable routingTable, ShardRouting shardRouting, ClusterState state) {     assert shardRouting.initializing() : "only allow shard creation for initializing shard but was " + shardRouting.     DiscoveryNode sourceNode = null.     if (shardRouting.recoverySource().getType() == Type.PEER) {         sourceNode = findSourceNodeForPeerRecovery(logger, routingTable, nodes, shardRouting).         if (sourceNode == null) {             logger.trace("ignoring initializing shard {} - no source node can be found.", shardRouting.shardId()).             return.         }     }     try {         final long primaryTerm = state.metaData().index(shardRouting.index()).primaryTerm(shardRouting.id()).         logger.debug("{} creating shard with primary term [{}]", shardRouting.shardId(), primaryTerm).         RecoveryState recoveryState = new RecoveryState(shardRouting, nodes.getLocalNode(), sourceNode).         indicesService.createShard(shardRouting, recoveryState, recoveryTargetService, new RecoveryListener(shardRouting, primaryTerm), repositoriesService, failedShardHandler, globalCheckpointSyncer, retentionLeaseSyncer).     } catch (Exception e) {         failAndRemoveShard(shardRouting, true, "failed to create shard", e, state).     } }
false;private;5;49;;private void updateShard(DiscoveryNodes nodes, ShardRouting shardRouting, Shard shard, RoutingTable routingTable, ClusterState clusterState) {     final ShardRouting currentRoutingEntry = shard.routingEntry().     assert currentRoutingEntry.isSameAllocation(shardRouting) : "local shard has a different allocation id but wasn't cleaned by removeShards. " + "cluster state: " + shardRouting + " local: " + currentRoutingEntry.     final long primaryTerm.     try {         final IndexMetaData indexMetaData = clusterState.metaData().index(shard.shardId().getIndex()).         primaryTerm = indexMetaData.primaryTerm(shard.shardId().id()).         final Set<String> inSyncIds = indexMetaData.inSyncAllocationIds(shard.shardId().id()).         final IndexShardRoutingTable indexShardRoutingTable = routingTable.shardRoutingTable(shardRouting.shardId()).         final Set<String> pre60AllocationIds = indexShardRoutingTable.assignedShards().stream().flatMap(shr -> {             if (shr.relocating()) {                 return Stream.of(shr, shr.getTargetRelocatingShard()).             } else {                 return Stream.of(shr).             }         }).filter(shr -> nodes.get(shr.currentNodeId()).getVersion().before(Version.V_6_0_0_alpha1)).map(ShardRouting::allocationId).map(AllocationId::getId).collect(Collectors.toSet()).         shard.updateShardState(shardRouting, primaryTerm, primaryReplicaSyncer::resync, clusterState.version(), inSyncIds, indexShardRoutingTable, pre60AllocationIds).     } catch (Exception e) {         failAndRemoveShard(shardRouting, true, "failed updating shard routing entry", e, clusterState).         return.     }     final IndexShardState state = shard.state().     if (shardRouting.initializing() && (state == IndexShardState.STARTED || state == IndexShardState.POST_RECOVERY)) {         // we managed to tell the master we started), mark us as started         if (logger.isTraceEnabled()) {             logger.trace("{} master marked shard as initializing, but shard has state [{}], resending shard started to {}", shardRouting.shardId(), state, nodes.getMasterNode()).         }         if (nodes.getMasterNode() != null) {             shardStateAction.shardStarted(shardRouting, primaryTerm, "master " + nodes.getMasterNode() + " marked shard as initializing, but shard state is [" + state + "], mark shard as started", SHARD_STATE_ACTION_LISTENER, clusterState).         }     } }
true;private,static;4;26;/**  * Finds the routing source node for peer recovery, return null if its not found. Note, this method expects the shard  * routing to *require* peer recovery, use {@link ShardRouting#recoverySource()} to check if its needed or not.  */ ;/**  * Finds the routing source node for peer recovery, return null if its not found. Note, this method expects the shard  * routing to *require* peer recovery, use {@link ShardRouting#recoverySource()} to check if its needed or not.  */ private static DiscoveryNode findSourceNodeForPeerRecovery(Logger logger, RoutingTable routingTable, DiscoveryNodes nodes, ShardRouting shardRouting) {     DiscoveryNode sourceNode = null.     if (!shardRouting.primary()) {         ShardRouting primary = routingTable.shardRoutingTable(shardRouting.shardId()).primaryShard().         // only recover from started primary, if we can't find one, we will do it next round         if (primary.active()) {             sourceNode = nodes.get(primary.currentNodeId()).             if (sourceNode == null) {                 logger.trace("can't find replica source node because primary shard {} is assigned to an unknown node.", primary).             }         } else {             logger.trace("can't find replica source node because primary shard {} is not active.", primary).         }     } else if (shardRouting.relocatingNodeId() != null) {         sourceNode = nodes.get(shardRouting.relocatingNodeId()).         if (sourceNode == null) {             logger.trace("can't find relocation source node for shard {} because it is assigned to an unknown node [{}].", shardRouting.shardId(), shardRouting.relocatingNodeId()).         }     } else {         throw new IllegalStateException("trying to find source node for peer recovery when routing state means no peer recovery: " + shardRouting).     }     return sourceNode. }
false;public;1;4;;@Override public void onRecoveryDone(final RecoveryState state) {     shardStateAction.shardStarted(shardRouting, primaryTerm, "after " + state.getRecoverySource(), SHARD_STATE_ACTION_LISTENER). }
false;public;3;4;;@Override public void onRecoveryFailure(RecoveryState state, RecoveryFailedException e, boolean sendShardFailure) {     handleRecoveryFailure(shardRouting, sendShardFailure, e). }
false;private,synchronized;3;3;;private synchronized void handleRecoveryFailure(ShardRouting shardRouting, boolean sendShardFailure, Exception failure) {     failAndRemoveShard(shardRouting, sendShardFailure, "failed recovery", failure, clusterService.state()). }
false;private;5;22;;private void failAndRemoveShard(ShardRouting shardRouting, boolean sendShardFailure, String message, @Nullable Exception failure, ClusterState state) {     try {         AllocatedIndex<? extends Shard> indexService = indicesService.indexService(shardRouting.shardId().getIndex()).         if (indexService != null) {             indexService.removeShard(shardRouting.shardId().id(), message).         }     } catch (ShardNotFoundException e) {     // the node got closed on us, ignore it     } catch (Exception inner) {         inner.addSuppressed(failure).         logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to remove shard after failure ([{}])", shardRouting.getIndexName(), shardRouting.getId(), message), inner).     }     if (sendShardFailure) {         sendFailShard(shardRouting, message, failure, state).     } }
false;private;4;16;;private void sendFailShard(ShardRouting shardRouting, String message, @Nullable Exception failure, ClusterState state) {     try {         logger.warn(() -> new ParameterizedMessage("{} marking and sending shard failed due to [{}]", shardRouting.shardId(), message), failure).         failedShardsCache.put(shardRouting.shardId(), shardRouting).         shardStateAction.localShardFailed(shardRouting, message, failure, SHARD_STATE_ACTION_LISTENER, state).     } catch (Exception inner) {         if (failure != null)             inner.addSuppressed(failure).         logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to mark shard as failed (because of [{}])", shardRouting.getIndexName(), shardRouting.getId(), message), inner).     } }
false;public;1;10;;@Override public void accept(final IndexShard.ShardFailure shardFailure) {     final ShardRouting shardRouting = shardFailure.routing.     threadPool.generic().execute(() -> {         synchronized (IndicesClusterStateService.this) {             failAndRemoveShard(shardRouting, true, "shard failure, reason [" + shardFailure.reason + "]", shardFailure.cause, clusterService.state()).         }     }). }
true;;0;1;/**  * Returns the shard id of this shard.  */ ;/**  * Returns the shard id of this shard.  */ ShardId shardId().
true;;0;1;/**  * Returns the latest cluster routing entry received with this shard.  */ ;/**  * Returns the latest cluster routing entry received with this shard.  */ ShardRouting routingEntry().
true;;0;1;/**  * Returns the latest internal shard state.  */ ;/**  * Returns the latest internal shard state.  */ IndexShardState state().
true;;0;1;/**  * Returns the recovery state associated with this shard.  */ ;/**  * Returns the recovery state associated with this shard.  */ RecoveryState recoveryState().
true;;7;7;/**  * Updates the shard state based on an incoming cluster state:  * - Updates and persists the new routing value.  * - Updates the primary term if this shard is a primary.  * - Updates the allocation ids that are tracked by the shard if it is a primary.  *   See {@link ReplicationTracker#updateFromMaster(long, Set, IndexShardRoutingTable, Set)} for details.  *  * @param shardRouting                the new routing entry  * @param primaryTerm                 the new primary term  * @param primaryReplicaSyncer        the primary-replica resync action to trigger when a term is increased on a primary  * @param applyingClusterStateVersion the cluster state version being applied when updating the allocation IDs from the master  * @param inSyncAllocationIds         the allocation ids of the currently in-sync shard copies  * @param routingTable                the shard routing table  * @throws IndexShardRelocatedException if shard is marked as relocated and relocation aborted  * @throws IOException                  if shard state could not be persisted  */ ;/**  * Updates the shard state based on an incoming cluster state:  * - Updates and persists the new routing value.  * - Updates the primary term if this shard is a primary.  * - Updates the allocation ids that are tracked by the shard if it is a primary.  *   See {@link ReplicationTracker#updateFromMaster(long, Set, IndexShardRoutingTable, Set)} for details.  *  * @param shardRouting                the new routing entry  * @param primaryTerm                 the new primary term  * @param primaryReplicaSyncer        the primary-replica resync action to trigger when a term is increased on a primary  * @param applyingClusterStateVersion the cluster state version being applied when updating the allocation IDs from the master  * @param inSyncAllocationIds         the allocation ids of the currently in-sync shard copies  * @param routingTable                the shard routing table  * @throws IndexShardRelocatedException if shard is marked as relocated and relocation aborted  * @throws IOException                  if shard state could not be persisted  */ void updateShardState(ShardRouting shardRouting, long primaryTerm, BiConsumer<IndexShard, ActionListener<ResyncTask>> primaryReplicaSyncer, long applyingClusterStateVersion, Set<String> inSyncAllocationIds, IndexShardRoutingTable routingTable, Set<String> pre60AllocationIds) throws IOException.
true;;0;1;/**  * Returns the index settings of this index.  */ ;/**  * Returns the index settings of this index.  */ IndexSettings getIndexSettings().
true;;2;1;/**  * Updates the metadata of this index. Changes become visible through {@link #getIndexSettings()}.  *  * @param currentIndexMetaData the current index metadata  * @param newIndexMetaData the new index metadata  */ ;/**  * Updates the metadata of this index. Changes become visible through {@link #getIndexSettings()}.  *  * @param currentIndexMetaData the current index metadata  * @param newIndexMetaData the new index metadata  */ void updateMetaData(IndexMetaData currentIndexMetaData, IndexMetaData newIndexMetaData).
true;;2;1;/**  * Checks if index requires refresh from master.  */ ;/**  * Checks if index requires refresh from master.  */ boolean updateMapping(IndexMetaData currentIndexMetaData, IndexMetaData newIndexMetaData) throws IOException.
true;;1;1;/**  * Returns shard with given id.  */ ;/**  * Returns shard with given id.  */ @Nullable T getShardOrNull(int shardId).
true;;2;1;/**  * Removes shard with given id.  */ ;/**  * Removes shard with given id.  */ void removeShard(int shardId, String message).
true;;2;2;/**  * Creates a new {@link IndexService} for the given metadata.  *  * @param indexMetaData          the index metadata to create the index for  * @param builtInIndexListener   a list of built-in lifecycle {@link IndexEventListener} that should should be used along side with  *                               the per-index listeners  * @throws ResourceAlreadyExistsException if the index already exists.  */ ;/**  * Creates a new {@link IndexService} for the given metadata.  *  * @param indexMetaData          the index metadata to create the index for  * @param builtInIndexListener   a list of built-in lifecycle {@link IndexEventListener} that should should be used along side with  *                               the per-index listeners  * @throws ResourceAlreadyExistsException if the index already exists.  */ U createIndex(IndexMetaData indexMetaData, List<IndexEventListener> builtInIndexListener) throws IOException.
true;;2;1;/**  * Verify that the contents on disk for the given index is deleted. if not, delete the contents.  * This method assumes that an index is already deleted in the cluster state and/or explicitly  * through index tombstones.  * @param index {@code Index} to make sure its deleted from disk  * @param clusterState {@code ClusterState} to ensure the index is not part of it  * @return IndexMetaData for the index loaded from disk  */ ;/**  * Verify that the contents on disk for the given index is deleted. if not, delete the contents.  * This method assumes that an index is already deleted in the cluster state and/or explicitly  * through index tombstones.  * @param index {@code Index} to make sure its deleted from disk  * @param clusterState {@code ClusterState} to ensure the index is not part of it  * @return IndexMetaData for the index loaded from disk  */ IndexMetaData verifyIndexIsDeleted(Index index, ClusterState clusterState).
true;;3;1;/**  * Deletes an index that is not assigned to this node. This method cleans up all disk folders relating to the index  * but does not deal with in-memory structures. For those call {@link #removeIndex(Index, IndexRemovalReason, String)}  */ ;/**  * Deletes an index that is not assigned to this node. This method cleans up all disk folders relating to the index  * but does not deal with in-memory structures. For those call {@link #removeIndex(Index, IndexRemovalReason, String)}  */ void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState).
true;;3;1;/**  * Removes the given index from this service and releases all associated resources. Persistent parts of the index  * like the shards files, state and transaction logs are kept around in the case of a disaster recovery.  * @param index the index to remove  * @param reason the reason to remove the index  * @param extraInfo extra information that will be used for logging and reporting  */ ;/**  * Removes the given index from this service and releases all associated resources. Persistent parts of the index  * like the shards files, state and transaction logs are kept around in the case of a disaster recovery.  * @param index the index to remove  * @param reason the reason to remove the index  * @param extraInfo extra information that will be used for logging and reporting  */ void removeIndex(Index index, IndexRemovalReason reason, String extraInfo).
true;;1;1;/**  * Returns an IndexService for the specified index if exists otherwise returns <code>null</code>.  */ ;/**  * Returns an IndexService for the specified index if exists otherwise returns <code>null</code>.  */ @Nullable U indexService(Index index).
true;;8;9;/**  * Creates a shard for the specified shard routing and starts recovery.  *  * @param shardRouting           the shard routing  * @param recoveryState          the recovery state  * @param recoveryTargetService  recovery service for the target  * @param recoveryListener       a callback when recovery changes state (finishes or fails)  * @param repositoriesService    service responsible for snapshot/restore  * @param onShardFailure         a callback when this shard fails  * @param globalCheckpointSyncer a callback when this shard syncs the global checkpoint  * @param retentionLeaseSyncer   a callback when this shard syncs retention leases  * @return a new shard  * @throws IOException if an I/O exception occurs when creating the shard  */ ;/**  * Creates a shard for the specified shard routing and starts recovery.  *  * @param shardRouting           the shard routing  * @param recoveryState          the recovery state  * @param recoveryTargetService  recovery service for the target  * @param recoveryListener       a callback when recovery changes state (finishes or fails)  * @param repositoriesService    service responsible for snapshot/restore  * @param onShardFailure         a callback when this shard fails  * @param globalCheckpointSyncer a callback when this shard syncs the global checkpoint  * @param retentionLeaseSyncer   a callback when this shard syncs retention leases  * @return a new shard  * @throws IOException if an I/O exception occurs when creating the shard  */ T createShard(ShardRouting shardRouting, RecoveryState recoveryState, PeerRecoveryTargetService recoveryTargetService, PeerRecoveryTargetService.RecoveryListener recoveryListener, RepositoriesService repositoriesService, Consumer<IndexShard.ShardFailure> onShardFailure, Consumer<ShardId> globalCheckpointSyncer, RetentionLeaseSyncer retentionLeaseSyncer) throws IOException.
true;default;1;7;/**  * Returns shard for the specified id if it exists otherwise returns <code>null</code>.  */ ;/**  * Returns shard for the specified id if it exists otherwise returns <code>null</code>.  */ default T getShardOrNull(ShardId shardId) {     U indexRef = indexService(shardId.getIndex()).     if (indexRef != null) {         return indexRef.getShardOrNull(shardId.id()).     }     return null. }
false;;3;2;;void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeValue) throws IOException, InterruptedException, ShardLockObtainFailedException.
