commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public DiscoveryNode getNode() {     return node. }
false;public;0;3;;public long getClusterStateVersion() {     return clusterStateVersion. }
false;public;0;7;;@Override public String toString() {     return "Candidate{" + "node=" + node + ", clusterStateVersion=" + clusterStateVersion + '}'. }
true;public,static;2;9;/**  * compares two candidates to indicate which the a better master.  * A higher cluster state version is better  *  * @return -1 if c1 is a batter candidate, 1 if c2.  */ ;/**  * compares two candidates to indicate which the a better master.  * A higher cluster state version is better  *  * @return -1 if c1 is a batter candidate, 1 if c2.  */ public static int compare(MasterCandidate c1, MasterCandidate c2) {     // we explicitly swap c1 and c2 here. the code expects "better" is lower in a sorted     // list, so if c2 has a higher cluster state version, it needs to come first.     int ret = Long.compare(c2.clusterStateVersion, c1.clusterStateVersion).     if (ret == 0) {         ret = compareNodes(c1.getNode(), c2.getNode()).     }     return ret. }
false;public;1;3;;public void minimumMasterNodes(int minimumMasterNodes) {     this.minimumMasterNodes = minimumMasterNodes. }
false;public;0;3;;public int minimumMasterNodes() {     return minimumMasterNodes. }
false;public;1;9;;public int countMasterNodes(Iterable<DiscoveryNode> nodes) {     int count = 0.     for (DiscoveryNode node : nodes) {         if (node.isMasterNode()) {             count++.         }     }     return count. }
false;public;1;11;;public boolean hasEnoughCandidates(Collection<MasterCandidate> candidates) {     if (candidates.isEmpty()) {         return false.     }     if (minimumMasterNodes < 1) {         return true.     }     assert candidates.stream().map(MasterCandidate::getNode).collect(Collectors.toSet()).size() == candidates.size() : "duplicates ahead: " + candidates.     return candidates.size() >= minimumMasterNodes. }
true;public;1;6;/**  * Elects a new master out of the possible nodes, returning it. Returns {@code null}  * if no master has been elected.  */ ;/**  * Elects a new master out of the possible nodes, returning it. Returns {@code null}  * if no master has been elected.  */ public MasterCandidate electMaster(Collection<MasterCandidate> candidates) {     assert hasEnoughCandidates(candidates).     List<MasterCandidate> sortedCandidates = new ArrayList<>(candidates).     sortedCandidates.sort(MasterCandidate::compare).     return sortedCandidates.get(0). }
true;public;1;3;/**  * selects the best active master to join, where multiple are discovered  */ ;/**  * selects the best active master to join, where multiple are discovered  */ public DiscoveryNode tieBreakActiveMasters(Collection<DiscoveryNode> activeMasters) {     return activeMasters.stream().min(ElectMasterService::compareNodes).get(). }
false;public;1;4;;public boolean hasEnoughMasterNodes(Iterable<DiscoveryNode> nodes) {     final int count = countMasterNodes(nodes).     return count > 0 && (minimumMasterNodes < 0 || count >= minimumMasterNodes). }
false;public;1;4;;public boolean hasTooManyMasterNodes(Iterable<DiscoveryNode> nodes) {     final int count = countMasterNodes(nodes).     return count > 1 && minimumMasterNodes <= count / 2. }
false;public;2;9;;public void logMinimumMasterNodesWarningIfNecessary(ClusterState oldState, ClusterState newState) {     // check if min_master_nodes setting is too low and log warning     if (hasTooManyMasterNodes(oldState.nodes()) == false && hasTooManyMasterNodes(newState.nodes())) {         logger.warn("value for setting \"{}\" is too low. This can result in data loss! Please set it to at least a quorum of master-" + "eligible nodes (current value: [{}], total number of master-eligible nodes used for publishing in this round: [{}])", ElectMasterService.DISCOVERY_ZEN_MINIMUM_MASTER_NODES_SETTING.getKey(), minimumMasterNodes(), newState.getNodes().getMasterNodes().size()).     } }
true;static;1;5;/**  * Returns the given nodes sorted by likelihood of being elected as master, most likely first.  * Non-master nodes are not removed but are rather put in the end  */ ;/**  * Returns the given nodes sorted by likelihood of being elected as master, most likely first.  * Non-master nodes are not removed but are rather put in the end  */ static List<DiscoveryNode> sortByMasterLikelihood(Iterable<DiscoveryNode> nodes) {     ArrayList<DiscoveryNode> sortedNodes = CollectionUtils.iterableAsArrayList(nodes).     CollectionUtil.introSort(sortedNodes, ElectMasterService::compareNodes).     return sortedNodes. }
true;public;2;15;/**  * Returns a list of the next possible masters.  */ ;/**  * Returns a list of the next possible masters.  */ public DiscoveryNode[] nextPossibleMasters(ObjectContainer<DiscoveryNode> nodes, int numberOfPossibleMasters) {     List<DiscoveryNode> sortedNodes = sortedMasterNodes(Arrays.asList(nodes.toArray(DiscoveryNode.class))).     if (sortedNodes == null) {         return new DiscoveryNode[0].     }     List<DiscoveryNode> nextPossibleMasters = new ArrayList<>(numberOfPossibleMasters).     int counter = 0.     for (DiscoveryNode nextPossibleMaster : sortedNodes) {         if (++counter >= numberOfPossibleMasters) {             break.         }         nextPossibleMasters.add(nextPossibleMaster).     }     return nextPossibleMasters.toArray(new DiscoveryNode[nextPossibleMasters.size()]). }
false;private;1;10;;private List<DiscoveryNode> sortedMasterNodes(Iterable<DiscoveryNode> nodes) {     List<DiscoveryNode> possibleNodes = CollectionUtils.iterableAsArrayList(nodes).     if (possibleNodes.isEmpty()) {         return null.     }     // clean non master nodes     possibleNodes.removeIf(node -> !node.isMasterNode()).     CollectionUtil.introSort(possibleNodes, ElectMasterService::compareNodes).     return possibleNodes. }
true;private,static;2;9;/**  * master nodes go before other nodes, with a secondary sort by id *  */ ;/**  * master nodes go before other nodes, with a secondary sort by id *  */ private static int compareNodes(DiscoveryNode o1, DiscoveryNode o2) {     if (o1.isMasterNode() && !o2.isMasterNode()) {         return -1.     }     if (!o1.isMasterNode() && o2.isMasterNode()) {         return 1.     }     return o1.getId().compareTo(o2.getId()). }
