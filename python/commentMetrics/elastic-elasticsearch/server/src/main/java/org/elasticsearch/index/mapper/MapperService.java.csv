# id;timestamp;commentText;codeText;commentWords;codeWords
MapperService -> public Collection<String> simpleMatchToIndexNames(String pattern);1524684173;Returns all the fields that match the given pattern. If the pattern is prefixed with a type_then the fields will be returned with a type prefix.;public Collection<String> simpleMatchToIndexNames(String pattern) {_        if (Regex.isSimpleMatchPattern(pattern) == false) {_            _            return Collections.singletonList(pattern)__        }_        return fieldTypes.simpleMatchToFullName(pattern)__    };returns,all,the,fields,that,match,the,given,pattern,if,the,pattern,is,prefixed,with,a,type,then,the,fields,will,be,returned,with,a,type,prefix;public,collection,string,simple,match,to,index,names,string,pattern,if,regex,is,simple,match,pattern,pattern,false,return,collections,singleton,list,pattern,return,field,types,simple,match,to,full,name,pattern
MapperService -> public Collection<String> simpleMatchToIndexNames(String pattern);1525334055;Returns all the fields that match the given pattern. If the pattern is prefixed with a type_then the fields will be returned with a type prefix.;public Collection<String> simpleMatchToIndexNames(String pattern) {_        if (Regex.isSimpleMatchPattern(pattern) == false) {_            _            return Collections.singletonList(pattern)__        }_        return fieldTypes.simpleMatchToFullName(pattern)__    };returns,all,the,fields,that,match,the,given,pattern,if,the,pattern,is,prefixed,with,a,type,then,the,fields,will,be,returned,with,a,type,prefix;public,collection,string,simple,match,to,index,names,string,pattern,if,regex,is,simple,match,pattern,pattern,false,return,collections,singleton,list,pattern,return,field,types,simple,match,to,full,name,pattern
MapperService -> public MappedFieldType unmappedFieldType(String type);1524684173;Given a type (eg. long, string, ...), return an anonymous field mapper that can be used for search operations.;public MappedFieldType unmappedFieldType(String type) {_        if (type.equals("string")) {_            deprecationLogger.deprecated("[unmapped_type:string] should be replaced with [unmapped_type:keyword]")__            type = "keyword"__        }_        MappedFieldType fieldType = unmappedFieldTypes.get(type)__        if (fieldType == null) {_            final Mapper.TypeParser.ParserContext parserContext = documentMapperParser().parserContext(type)__            Mapper.TypeParser typeParser = parserContext.typeParser(type)__            if (typeParser == null) {_                throw new IllegalArgumentException("No mapper found for type [" + type + "]")__            }_            final Mapper.Builder<?, ?> builder = typeParser.parse("__anonymous_" + type, emptyMap(), parserContext)__            final BuilderContext builderContext = new BuilderContext(indexSettings.getSettings(), new ContentPath(1))__            fieldType = ((FieldMapper)builder.build(builderContext)).fieldType()___            _            _            Map<String, MappedFieldType> newUnmappedFieldTypes = new HashMap<>(unmappedFieldTypes)__            newUnmappedFieldTypes.put(type, fieldType)__            unmappedFieldTypes = unmodifiableMap(newUnmappedFieldTypes)__        }_        return fieldType__    };given,a,type,eg,long,string,return,an,anonymous,field,mapper,that,can,be,used,for,search,operations;public,mapped,field,type,unmapped,field,type,string,type,if,type,equals,string,deprecation,logger,deprecated,string,should,be,replaced,with,keyword,type,keyword,mapped,field,type,field,type,unmapped,field,types,get,type,if,field,type,null,final,mapper,type,parser,parser,context,parser,context,document,mapper,parser,parser,context,type,mapper,type,parser,type,parser,parser,context,type,parser,type,if,type,parser,null,throw,new,illegal,argument,exception,no,mapper,found,for,type,type,final,mapper,builder,builder,type,parser,parse,type,empty,map,parser,context,final,builder,context,builder,context,new,builder,context,index,settings,get,settings,new,content,path,1,field,type,field,mapper,builder,build,builder,context,field,type,map,string,mapped,field,type,new,unmapped,field,types,new,hash,map,unmapped,field,types,new,unmapped,field,types,put,type,field,type,unmapped,field,types,unmodifiable,map,new,unmapped,field,types,return,field,type
MapperService -> public MappedFieldType unmappedFieldType(String type);1525334055;Given a type (eg. long, string, ...), return an anonymous field mapper that can be used for search operations.;public MappedFieldType unmappedFieldType(String type) {_        if (type.equals("string")) {_            deprecationLogger.deprecated("[unmapped_type:string] should be replaced with [unmapped_type:keyword]")__            type = "keyword"__        }_        MappedFieldType fieldType = unmappedFieldTypes.get(type)__        if (fieldType == null) {_            final Mapper.TypeParser.ParserContext parserContext = documentMapperParser().parserContext(type)__            Mapper.TypeParser typeParser = parserContext.typeParser(type)__            if (typeParser == null) {_                throw new IllegalArgumentException("No mapper found for type [" + type + "]")__            }_            final Mapper.Builder<?, ?> builder = typeParser.parse("__anonymous_" + type, emptyMap(), parserContext)__            final BuilderContext builderContext = new BuilderContext(indexSettings.getSettings(), new ContentPath(1))__            fieldType = ((FieldMapper)builder.build(builderContext)).fieldType()___            _            _            Map<String, MappedFieldType> newUnmappedFieldTypes = new HashMap<>(unmappedFieldTypes)__            newUnmappedFieldTypes.put(type, fieldType)__            unmappedFieldTypes = unmodifiableMap(newUnmappedFieldTypes)__        }_        return fieldType__    };given,a,type,eg,long,string,return,an,anonymous,field,mapper,that,can,be,used,for,search,operations;public,mapped,field,type,unmapped,field,type,string,type,if,type,equals,string,deprecation,logger,deprecated,string,should,be,replaced,with,keyword,type,keyword,mapped,field,type,field,type,unmapped,field,types,get,type,if,field,type,null,final,mapper,type,parser,parser,context,parser,context,document,mapper,parser,parser,context,type,mapper,type,parser,type,parser,parser,context,type,parser,type,if,type,parser,null,throw,new,illegal,argument,exception,no,mapper,found,for,type,type,final,mapper,builder,builder,type,parser,parse,type,empty,map,parser,context,final,builder,context,builder,context,new,builder,context,index,settings,get,settings,new,content,path,1,field,type,field,mapper,builder,build,builder,context,field,type,map,string,mapped,field,type,new,unmapped,field,types,new,hash,map,unmapped,field,types,new,unmapped,field,types,put,type,field,type,unmapped,field,types,unmodifiable,map,new,unmapped,field,types,return,field,type
MapperService -> public MappedFieldType unmappedFieldType(String type);1528706846;Given a type (eg. long, string, ...), return an anonymous field mapper that can be used for search operations.;public MappedFieldType unmappedFieldType(String type) {_        if (type.equals("string")) {_            deprecationLogger.deprecated("[unmapped_type:string] should be replaced with [unmapped_type:keyword]")__            type = "keyword"__        }_        MappedFieldType fieldType = unmappedFieldTypes.get(type)__        if (fieldType == null) {_            final Mapper.TypeParser.ParserContext parserContext = documentMapperParser().parserContext(type)__            Mapper.TypeParser typeParser = parserContext.typeParser(type)__            if (typeParser == null) {_                throw new IllegalArgumentException("No mapper found for type [" + type + "]")__            }_            final Mapper.Builder<?, ?> builder = typeParser.parse("__anonymous_" + type, emptyMap(), parserContext)__            final BuilderContext builderContext = new BuilderContext(indexSettings.getSettings(), new ContentPath(1))__            fieldType = ((FieldMapper)builder.build(builderContext)).fieldType()___            _            _            Map<String, MappedFieldType> newUnmappedFieldTypes = new HashMap<>(unmappedFieldTypes)__            newUnmappedFieldTypes.put(type, fieldType)__            unmappedFieldTypes = unmodifiableMap(newUnmappedFieldTypes)__        }_        return fieldType__    };given,a,type,eg,long,string,return,an,anonymous,field,mapper,that,can,be,used,for,search,operations;public,mapped,field,type,unmapped,field,type,string,type,if,type,equals,string,deprecation,logger,deprecated,string,should,be,replaced,with,keyword,type,keyword,mapped,field,type,field,type,unmapped,field,types,get,type,if,field,type,null,final,mapper,type,parser,parser,context,parser,context,document,mapper,parser,parser,context,type,mapper,type,parser,type,parser,parser,context,type,parser,type,if,type,parser,null,throw,new,illegal,argument,exception,no,mapper,found,for,type,type,final,mapper,builder,builder,type,parser,parse,type,empty,map,parser,context,final,builder,context,builder,context,new,builder,context,index,settings,get,settings,new,content,path,1,field,type,field,mapper,builder,build,builder,context,field,type,map,string,mapped,field,type,new,unmapped,field,types,new,hash,map,unmapped,field,types,new,unmapped,field,types,put,type,field,type,unmapped,field,types,unmodifiable,map,new,unmapped,field,types,return,field,type
MapperService -> public MappedFieldType unmappedFieldType(String type);1531937412;Given a type (eg. long, string, ...), return an anonymous field mapper that can be used for search operations.;public MappedFieldType unmappedFieldType(String type) {_        if (type.equals("string")) {_            deprecationLogger.deprecated("[unmapped_type:string] should be replaced with [unmapped_type:keyword]")__            type = "keyword"__        }_        MappedFieldType fieldType = unmappedFieldTypes.get(type)__        if (fieldType == null) {_            final Mapper.TypeParser.ParserContext parserContext = documentMapperParser().parserContext(type)__            Mapper.TypeParser typeParser = parserContext.typeParser(type)__            if (typeParser == null) {_                throw new IllegalArgumentException("No mapper found for type [" + type + "]")__            }_            final Mapper.Builder<?, ?> builder = typeParser.parse("__anonymous_" + type, emptyMap(), parserContext)__            final BuilderContext builderContext = new BuilderContext(indexSettings.getSettings(), new ContentPath(1))__            fieldType = ((FieldMapper)builder.build(builderContext)).fieldType()___            _            _            Map<String, MappedFieldType> newUnmappedFieldTypes = new HashMap<>(unmappedFieldTypes)__            newUnmappedFieldTypes.put(type, fieldType)__            unmappedFieldTypes = unmodifiableMap(newUnmappedFieldTypes)__        }_        return fieldType__    };given,a,type,eg,long,string,return,an,anonymous,field,mapper,that,can,be,used,for,search,operations;public,mapped,field,type,unmapped,field,type,string,type,if,type,equals,string,deprecation,logger,deprecated,string,should,be,replaced,with,keyword,type,keyword,mapped,field,type,field,type,unmapped,field,types,get,type,if,field,type,null,final,mapper,type,parser,parser,context,parser,context,document,mapper,parser,parser,context,type,mapper,type,parser,type,parser,parser,context,type,parser,type,if,type,parser,null,throw,new,illegal,argument,exception,no,mapper,found,for,type,type,final,mapper,builder,builder,type,parser,parse,type,empty,map,parser,context,final,builder,context,builder,context,new,builder,context,index,settings,get,settings,new,content,path,1,field,type,field,mapper,builder,build,builder,context,field,type,map,string,mapped,field,type,new,unmapped,field,types,new,hash,map,unmapped,field,types,new,unmapped,field,types,put,type,field,type,unmapped,field,types,unmodifiable,map,new,unmapped,field,types,return,field,type
MapperService -> public MappedFieldType unmappedFieldType(String type);1532353780;Given a type (eg. long, string, ...), return an anonymous field mapper that can be used for search operations.;public MappedFieldType unmappedFieldType(String type) {_        if (type.equals("string")) {_            deprecationLogger.deprecated("[unmapped_type:string] should be replaced with [unmapped_type:keyword]")__            type = "keyword"__        }_        MappedFieldType fieldType = unmappedFieldTypes.get(type)__        if (fieldType == null) {_            final Mapper.TypeParser.ParserContext parserContext = documentMapperParser().parserContext(type)__            Mapper.TypeParser typeParser = parserContext.typeParser(type)__            if (typeParser == null) {_                throw new IllegalArgumentException("No mapper found for type [" + type + "]")__            }_            final Mapper.Builder<?, ?> builder = typeParser.parse("__anonymous_" + type, emptyMap(), parserContext)__            final BuilderContext builderContext = new BuilderContext(indexSettings.getSettings(), new ContentPath(1))__            fieldType = ((FieldMapper)builder.build(builderContext)).fieldType()___            _            _            Map<String, MappedFieldType> newUnmappedFieldTypes = new HashMap<>(unmappedFieldTypes)__            newUnmappedFieldTypes.put(type, fieldType)__            unmappedFieldTypes = unmodifiableMap(newUnmappedFieldTypes)__        }_        return fieldType__    };given,a,type,eg,long,string,return,an,anonymous,field,mapper,that,can,be,used,for,search,operations;public,mapped,field,type,unmapped,field,type,string,type,if,type,equals,string,deprecation,logger,deprecated,string,should,be,replaced,with,keyword,type,keyword,mapped,field,type,field,type,unmapped,field,types,get,type,if,field,type,null,final,mapper,type,parser,parser,context,parser,context,document,mapper,parser,parser,context,type,mapper,type,parser,type,parser,parser,context,type,parser,type,if,type,parser,null,throw,new,illegal,argument,exception,no,mapper,found,for,type,type,final,mapper,builder,builder,type,parser,parse,type,empty,map,parser,context,final,builder,context,builder,context,new,builder,context,index,settings,get,settings,new,content,path,1,field,type,field,mapper,builder,build,builder,context,field,type,map,string,mapped,field,type,new,unmapped,field,types,new,hash,map,unmapped,field,types,new,unmapped,field,types,put,type,field,type,unmapped,field,types,unmodifiable,map,new,unmapped,field,types,return,field,type
MapperService -> public MappedFieldType unmappedFieldType(String type);1534539448;Given a type (eg. long, string, ...), return an anonymous field mapper that can be used for search operations.;public MappedFieldType unmappedFieldType(String type) {_        if (type.equals("string")) {_            deprecationLogger.deprecated("[unmapped_type:string] should be replaced with [unmapped_type:keyword]")__            type = "keyword"__        }_        MappedFieldType fieldType = unmappedFieldTypes.get(type)__        if (fieldType == null) {_            final Mapper.TypeParser.ParserContext parserContext = documentMapperParser().parserContext(type)__            Mapper.TypeParser typeParser = parserContext.typeParser(type)__            if (typeParser == null) {_                throw new IllegalArgumentException("No mapper found for type [" + type + "]")__            }_            final Mapper.Builder<?, ?> builder = typeParser.parse("__anonymous_" + type, emptyMap(), parserContext)__            final BuilderContext builderContext = new BuilderContext(indexSettings.getSettings(), new ContentPath(1))__            fieldType = ((FieldMapper)builder.build(builderContext)).fieldType()___            _            _            Map<String, MappedFieldType> newUnmappedFieldTypes = new HashMap<>(unmappedFieldTypes)__            newUnmappedFieldTypes.put(type, fieldType)__            unmappedFieldTypes = unmodifiableMap(newUnmappedFieldTypes)__        }_        return fieldType__    };given,a,type,eg,long,string,return,an,anonymous,field,mapper,that,can,be,used,for,search,operations;public,mapped,field,type,unmapped,field,type,string,type,if,type,equals,string,deprecation,logger,deprecated,string,should,be,replaced,with,keyword,type,keyword,mapped,field,type,field,type,unmapped,field,types,get,type,if,field,type,null,final,mapper,type,parser,parser,context,parser,context,document,mapper,parser,parser,context,type,mapper,type,parser,type,parser,parser,context,type,parser,type,if,type,parser,null,throw,new,illegal,argument,exception,no,mapper,found,for,type,type,final,mapper,builder,builder,type,parser,parse,type,empty,map,parser,context,final,builder,context,builder,context,new,builder,context,index,settings,get,settings,new,content,path,1,field,type,field,mapper,builder,build,builder,context,field,type,map,string,mapped,field,type,new,unmapped,field,types,new,hash,map,unmapped,field,types,new,unmapped,field,types,put,type,field,type,unmapped,field,types,unmodifiable,map,new,unmapped,field,types,return,field,type
MapperService -> public MappedFieldType unmappedFieldType(String type);1535383145;Given a type (eg. long, string, ...), return an anonymous field mapper that can be used for search operations.;public MappedFieldType unmappedFieldType(String type) {_        if (type.equals("string")) {_            deprecationLogger.deprecated("[unmapped_type:string] should be replaced with [unmapped_type:keyword]")__            type = "keyword"__        }_        MappedFieldType fieldType = unmappedFieldTypes.get(type)__        if (fieldType == null) {_            final Mapper.TypeParser.ParserContext parserContext = documentMapperParser().parserContext(type)__            Mapper.TypeParser typeParser = parserContext.typeParser(type)__            if (typeParser == null) {_                throw new IllegalArgumentException("No mapper found for type [" + type + "]")__            }_            final Mapper.Builder<?, ?> builder = typeParser.parse("__anonymous_" + type, emptyMap(), parserContext)__            final BuilderContext builderContext = new BuilderContext(indexSettings.getSettings(), new ContentPath(1))__            fieldType = ((FieldMapper)builder.build(builderContext)).fieldType()___            _            _            Map<String, MappedFieldType> newUnmappedFieldTypes = new HashMap<>(unmappedFieldTypes)__            newUnmappedFieldTypes.put(type, fieldType)__            unmappedFieldTypes = unmodifiableMap(newUnmappedFieldTypes)__        }_        return fieldType__    };given,a,type,eg,long,string,return,an,anonymous,field,mapper,that,can,be,used,for,search,operations;public,mapped,field,type,unmapped,field,type,string,type,if,type,equals,string,deprecation,logger,deprecated,string,should,be,replaced,with,keyword,type,keyword,mapped,field,type,field,type,unmapped,field,types,get,type,if,field,type,null,final,mapper,type,parser,parser,context,parser,context,document,mapper,parser,parser,context,type,mapper,type,parser,type,parser,parser,context,type,parser,type,if,type,parser,null,throw,new,illegal,argument,exception,no,mapper,found,for,type,type,final,mapper,builder,builder,type,parser,parse,type,empty,map,parser,context,final,builder,context,builder,context,new,builder,context,index,settings,get,settings,new,content,path,1,field,type,field,mapper,builder,build,builder,context,field,type,map,string,mapped,field,type,new,unmapped,field,types,new,hash,map,unmapped,field,types,new,unmapped,field,types,put,type,field,type,unmapped,field,types,unmodifiable,map,new,unmapped,field,types,return,field,type
MapperService -> public MappedFieldType unmappedFieldType(String type);1535405719;Given a type (eg. long, string, ...), return an anonymous field mapper that can be used for search operations.;public MappedFieldType unmappedFieldType(String type) {_        if (type.equals("string")) {_            deprecationLogger.deprecated("[unmapped_type:string] should be replaced with [unmapped_type:keyword]")__            type = "keyword"__        }_        MappedFieldType fieldType = unmappedFieldTypes.get(type)__        if (fieldType == null) {_            final Mapper.TypeParser.ParserContext parserContext = documentMapperParser().parserContext(type)__            Mapper.TypeParser typeParser = parserContext.typeParser(type)__            if (typeParser == null) {_                throw new IllegalArgumentException("No mapper found for type [" + type + "]")__            }_            final Mapper.Builder<?, ?> builder = typeParser.parse("__anonymous_" + type, emptyMap(), parserContext)__            final BuilderContext builderContext = new BuilderContext(indexSettings.getSettings(), new ContentPath(1))__            fieldType = ((FieldMapper)builder.build(builderContext)).fieldType()___            _            _            Map<String, MappedFieldType> newUnmappedFieldTypes = new HashMap<>(unmappedFieldTypes)__            newUnmappedFieldTypes.put(type, fieldType)__            unmappedFieldTypes = unmodifiableMap(newUnmappedFieldTypes)__        }_        return fieldType__    };given,a,type,eg,long,string,return,an,anonymous,field,mapper,that,can,be,used,for,search,operations;public,mapped,field,type,unmapped,field,type,string,type,if,type,equals,string,deprecation,logger,deprecated,string,should,be,replaced,with,keyword,type,keyword,mapped,field,type,field,type,unmapped,field,types,get,type,if,field,type,null,final,mapper,type,parser,parser,context,parser,context,document,mapper,parser,parser,context,type,mapper,type,parser,type,parser,parser,context,type,parser,type,if,type,parser,null,throw,new,illegal,argument,exception,no,mapper,found,for,type,type,final,mapper,builder,builder,type,parser,parse,type,empty,map,parser,context,final,builder,context,builder,context,new,builder,context,index,settings,get,settings,new,content,path,1,field,type,field,mapper,builder,build,builder,context,field,type,map,string,mapped,field,type,new,unmapped,field,types,new,hash,map,unmapped,field,types,new,unmapped,field,types,put,type,field,type,unmapped,field,types,unmodifiable,map,new,unmapped,field,types,return,field,type
MapperService -> public MappedFieldType unmappedFieldType(String type);1536177418;Given a type (eg. long, string, ...), return an anonymous field mapper that can be used for search operations.;public MappedFieldType unmappedFieldType(String type) {_        if (type.equals("string")) {_            deprecationLogger.deprecated("[unmapped_type:string] should be replaced with [unmapped_type:keyword]")__            type = "keyword"__        }_        MappedFieldType fieldType = unmappedFieldTypes.get(type)__        if (fieldType == null) {_            final Mapper.TypeParser.ParserContext parserContext = documentMapperParser().parserContext(type)__            Mapper.TypeParser typeParser = parserContext.typeParser(type)__            if (typeParser == null) {_                throw new IllegalArgumentException("No mapper found for type [" + type + "]")__            }_            final Mapper.Builder<?, ?> builder = typeParser.parse("__anonymous_" + type, emptyMap(), parserContext)__            final BuilderContext builderContext = new BuilderContext(indexSettings.getSettings(), new ContentPath(1))__            fieldType = ((FieldMapper)builder.build(builderContext)).fieldType()___            _            _            Map<String, MappedFieldType> newUnmappedFieldTypes = new HashMap<>(unmappedFieldTypes)__            newUnmappedFieldTypes.put(type, fieldType)__            unmappedFieldTypes = unmodifiableMap(newUnmappedFieldTypes)__        }_        return fieldType__    };given,a,type,eg,long,string,return,an,anonymous,field,mapper,that,can,be,used,for,search,operations;public,mapped,field,type,unmapped,field,type,string,type,if,type,equals,string,deprecation,logger,deprecated,string,should,be,replaced,with,keyword,type,keyword,mapped,field,type,field,type,unmapped,field,types,get,type,if,field,type,null,final,mapper,type,parser,parser,context,parser,context,document,mapper,parser,parser,context,type,mapper,type,parser,type,parser,parser,context,type,parser,type,if,type,parser,null,throw,new,illegal,argument,exception,no,mapper,found,for,type,type,final,mapper,builder,builder,type,parser,parse,type,empty,map,parser,context,final,builder,context,builder,context,new,builder,context,index,settings,get,settings,new,content,path,1,field,type,field,mapper,builder,build,builder,context,field,type,map,string,mapped,field,type,new,unmapped,field,types,new,hash,map,unmapped,field,types,new,unmapped,field,types,put,type,field,type,unmapped,field,types,unmodifiable,map,new,unmapped,field,types,return,field,type
MapperService -> public MappedFieldType unmappedFieldType(String type);1540486836;Given a type (eg. long, string, ...), return an anonymous field mapper that can be used for search operations.;public MappedFieldType unmappedFieldType(String type) {_        if (type.equals("string")) {_            deprecationLogger.deprecated("[unmapped_type:string] should be replaced with [unmapped_type:keyword]")__            type = "keyword"__        }_        MappedFieldType fieldType = unmappedFieldTypes.get(type)__        if (fieldType == null) {_            final Mapper.TypeParser.ParserContext parserContext = documentMapperParser().parserContext(type)__            Mapper.TypeParser typeParser = parserContext.typeParser(type)__            if (typeParser == null) {_                throw new IllegalArgumentException("No mapper found for type [" + type + "]")__            }_            final Mapper.Builder<?, ?> builder = typeParser.parse("__anonymous_" + type, emptyMap(), parserContext)__            final BuilderContext builderContext = new BuilderContext(indexSettings.getSettings(), new ContentPath(1))__            fieldType = ((FieldMapper)builder.build(builderContext)).fieldType()___            _            _            Map<String, MappedFieldType> newUnmappedFieldTypes = new HashMap<>(unmappedFieldTypes)__            newUnmappedFieldTypes.put(type, fieldType)__            unmappedFieldTypes = unmodifiableMap(newUnmappedFieldTypes)__        }_        return fieldType__    };given,a,type,eg,long,string,return,an,anonymous,field,mapper,that,can,be,used,for,search,operations;public,mapped,field,type,unmapped,field,type,string,type,if,type,equals,string,deprecation,logger,deprecated,string,should,be,replaced,with,keyword,type,keyword,mapped,field,type,field,type,unmapped,field,types,get,type,if,field,type,null,final,mapper,type,parser,parser,context,parser,context,document,mapper,parser,parser,context,type,mapper,type,parser,type,parser,parser,context,type,parser,type,if,type,parser,null,throw,new,illegal,argument,exception,no,mapper,found,for,type,type,final,mapper,builder,builder,type,parser,parse,type,empty,map,parser,context,final,builder,context,builder,context,new,builder,context,index,settings,get,settings,new,content,path,1,field,type,field,mapper,builder,build,builder,context,field,type,map,string,mapped,field,type,new,unmapped,field,types,new,hash,map,unmapped,field,types,new,unmapped,field,types,put,type,field,type,unmapped,field,types,unmodifiable,map,new,unmapped,field,types,return,field,type
MapperService -> public MappedFieldType unmappedFieldType(String type);1540583181;Given a type (eg. long, string, ...), return an anonymous field mapper that can be used for search operations.;public MappedFieldType unmappedFieldType(String type) {_        if (type.equals("string")) {_            deprecationLogger.deprecated("[unmapped_type:string] should be replaced with [unmapped_type:keyword]")__            type = "keyword"__        }_        MappedFieldType fieldType = unmappedFieldTypes.get(type)__        if (fieldType == null) {_            final Mapper.TypeParser.ParserContext parserContext = documentMapperParser().parserContext(type)__            Mapper.TypeParser typeParser = parserContext.typeParser(type)__            if (typeParser == null) {_                throw new IllegalArgumentException("No mapper found for type [" + type + "]")__            }_            final Mapper.Builder<?, ?> builder = typeParser.parse("__anonymous_" + type, emptyMap(), parserContext)__            final BuilderContext builderContext = new BuilderContext(indexSettings.getSettings(), new ContentPath(1))__            fieldType = ((FieldMapper)builder.build(builderContext)).fieldType()___            _            _            Map<String, MappedFieldType> newUnmappedFieldTypes = new HashMap<>(unmappedFieldTypes)__            newUnmappedFieldTypes.put(type, fieldType)__            unmappedFieldTypes = unmodifiableMap(newUnmappedFieldTypes)__        }_        return fieldType__    };given,a,type,eg,long,string,return,an,anonymous,field,mapper,that,can,be,used,for,search,operations;public,mapped,field,type,unmapped,field,type,string,type,if,type,equals,string,deprecation,logger,deprecated,string,should,be,replaced,with,keyword,type,keyword,mapped,field,type,field,type,unmapped,field,types,get,type,if,field,type,null,final,mapper,type,parser,parser,context,parser,context,document,mapper,parser,parser,context,type,mapper,type,parser,type,parser,parser,context,type,parser,type,if,type,parser,null,throw,new,illegal,argument,exception,no,mapper,found,for,type,type,final,mapper,builder,builder,type,parser,parse,type,empty,map,parser,context,final,builder,context,builder,context,new,builder,context,index,settings,get,settings,new,content,path,1,field,type,field,mapper,builder,build,builder,context,field,type,map,string,mapped,field,type,new,unmapped,field,types,new,hash,map,unmapped,field,types,new,unmapped,field,types,put,type,field,type,unmapped,field,types,unmodifiable,map,new,unmapped,field,types,return,field,type
MapperService -> public MappedFieldType unmappedFieldType(String type);1541008027;Given a type (eg. long, string, ...), return an anonymous field mapper that can be used for search operations.;public MappedFieldType unmappedFieldType(String type) {_        if (type.equals("string")) {_            deprecationLogger.deprecated("[unmapped_type:string] should be replaced with [unmapped_type:keyword]")__            type = "keyword"__        }_        MappedFieldType fieldType = unmappedFieldTypes.get(type)__        if (fieldType == null) {_            final Mapper.TypeParser.ParserContext parserContext = documentMapperParser().parserContext(type)__            Mapper.TypeParser typeParser = parserContext.typeParser(type)__            if (typeParser == null) {_                throw new IllegalArgumentException("No mapper found for type [" + type + "]")__            }_            final Mapper.Builder<?, ?> builder = typeParser.parse("__anonymous_" + type, emptyMap(), parserContext)__            final BuilderContext builderContext = new BuilderContext(indexSettings.getSettings(), new ContentPath(1))__            fieldType = ((FieldMapper)builder.build(builderContext)).fieldType()___            _            _            Map<String, MappedFieldType> newUnmappedFieldTypes = new HashMap<>(unmappedFieldTypes)__            newUnmappedFieldTypes.put(type, fieldType)__            unmappedFieldTypes = unmodifiableMap(newUnmappedFieldTypes)__        }_        return fieldType__    };given,a,type,eg,long,string,return,an,anonymous,field,mapper,that,can,be,used,for,search,operations;public,mapped,field,type,unmapped,field,type,string,type,if,type,equals,string,deprecation,logger,deprecated,string,should,be,replaced,with,keyword,type,keyword,mapped,field,type,field,type,unmapped,field,types,get,type,if,field,type,null,final,mapper,type,parser,parser,context,parser,context,document,mapper,parser,parser,context,type,mapper,type,parser,type,parser,parser,context,type,parser,type,if,type,parser,null,throw,new,illegal,argument,exception,no,mapper,found,for,type,type,final,mapper,builder,builder,type,parser,parse,type,empty,map,parser,context,final,builder,context,builder,context,new,builder,context,index,settings,get,settings,new,content,path,1,field,type,field,mapper,builder,build,builder,context,field,type,map,string,mapped,field,type,new,unmapped,field,types,new,hash,map,unmapped,field,types,new,unmapped,field,types,put,type,field,type,unmapped,field,types,unmodifiable,map,new,unmapped,field,types,return,field,type
MapperService -> public MappedFieldType unmappedFieldType(String type);1541592065;Given a type (eg. long, string, ...), return an anonymous field mapper that can be used for search operations.;public MappedFieldType unmappedFieldType(String type) {_        if (type.equals("string")) {_            deprecationLogger.deprecated("[unmapped_type:string] should be replaced with [unmapped_type:keyword]")__            type = "keyword"__        }_        MappedFieldType fieldType = unmappedFieldTypes.get(type)__        if (fieldType == null) {_            final Mapper.TypeParser.ParserContext parserContext = documentMapperParser().parserContext(type)__            Mapper.TypeParser typeParser = parserContext.typeParser(type)__            if (typeParser == null) {_                throw new IllegalArgumentException("No mapper found for type [" + type + "]")__            }_            final Mapper.Builder<?, ?> builder = typeParser.parse("__anonymous_" + type, emptyMap(), parserContext)__            final BuilderContext builderContext = new BuilderContext(indexSettings.getSettings(), new ContentPath(1))__            fieldType = ((FieldMapper)builder.build(builderContext)).fieldType()___            _            _            Map<String, MappedFieldType> newUnmappedFieldTypes = new HashMap<>(unmappedFieldTypes)__            newUnmappedFieldTypes.put(type, fieldType)__            unmappedFieldTypes = unmodifiableMap(newUnmappedFieldTypes)__        }_        return fieldType__    };given,a,type,eg,long,string,return,an,anonymous,field,mapper,that,can,be,used,for,search,operations;public,mapped,field,type,unmapped,field,type,string,type,if,type,equals,string,deprecation,logger,deprecated,string,should,be,replaced,with,keyword,type,keyword,mapped,field,type,field,type,unmapped,field,types,get,type,if,field,type,null,final,mapper,type,parser,parser,context,parser,context,document,mapper,parser,parser,context,type,mapper,type,parser,type,parser,parser,context,type,parser,type,if,type,parser,null,throw,new,illegal,argument,exception,no,mapper,found,for,type,type,final,mapper,builder,builder,type,parser,parse,type,empty,map,parser,context,final,builder,context,builder,context,new,builder,context,index,settings,get,settings,new,content,path,1,field,type,field,mapper,builder,build,builder,context,field,type,map,string,mapped,field,type,new,unmapped,field,types,new,hash,map,unmapped,field,types,new,unmapped,field,types,put,type,field,type,unmapped,field,types,unmodifiable,map,new,unmapped,field,types,return,field,type
MapperService -> public MappedFieldType unmappedFieldType(String type);1542899326;Given a type (eg. long, string, ...), return an anonymous field mapper that can be used for search operations.;public MappedFieldType unmappedFieldType(String type) {_        if (type.equals("string")) {_            deprecationLogger.deprecated("[unmapped_type:string] should be replaced with [unmapped_type:keyword]")__            type = "keyword"__        }_        MappedFieldType fieldType = unmappedFieldTypes.get(type)__        if (fieldType == null) {_            final Mapper.TypeParser.ParserContext parserContext = documentMapperParser().parserContext(type)__            Mapper.TypeParser typeParser = parserContext.typeParser(type)__            if (typeParser == null) {_                throw new IllegalArgumentException("No mapper found for type [" + type + "]")__            }_            final Mapper.Builder<?, ?> builder = typeParser.parse("__anonymous_" + type, emptyMap(), parserContext)__            final BuilderContext builderContext = new BuilderContext(indexSettings.getSettings(), new ContentPath(1))__            fieldType = ((FieldMapper)builder.build(builderContext)).fieldType()___            _            _            Map<String, MappedFieldType> newUnmappedFieldTypes = new HashMap<>(unmappedFieldTypes)__            newUnmappedFieldTypes.put(type, fieldType)__            unmappedFieldTypes = unmodifiableMap(newUnmappedFieldTypes)__        }_        return fieldType__    };given,a,type,eg,long,string,return,an,anonymous,field,mapper,that,can,be,used,for,search,operations;public,mapped,field,type,unmapped,field,type,string,type,if,type,equals,string,deprecation,logger,deprecated,string,should,be,replaced,with,keyword,type,keyword,mapped,field,type,field,type,unmapped,field,types,get,type,if,field,type,null,final,mapper,type,parser,parser,context,parser,context,document,mapper,parser,parser,context,type,mapper,type,parser,type,parser,parser,context,type,parser,type,if,type,parser,null,throw,new,illegal,argument,exception,no,mapper,found,for,type,type,final,mapper,builder,builder,type,parser,parse,type,empty,map,parser,context,final,builder,context,builder,context,new,builder,context,index,settings,get,settings,new,content,path,1,field,type,field,mapper,builder,build,builder,context,field,type,map,string,mapped,field,type,new,unmapped,field,types,new,hash,map,unmapped,field,types,new,unmapped,field,types,put,type,field,type,unmapped,field,types,unmodifiable,map,new,unmapped,field,types,return,field,type
MapperService -> public MappedFieldType unmappedFieldType(String type);1543947737;Given a type (eg. long, string, ...), return an anonymous field mapper that can be used for search operations.;public MappedFieldType unmappedFieldType(String type) {_        if (type.equals("string")) {_            deprecationLogger.deprecated("[unmapped_type:string] should be replaced with [unmapped_type:keyword]")__            type = "keyword"__        }_        MappedFieldType fieldType = unmappedFieldTypes.get(type)__        if (fieldType == null) {_            final Mapper.TypeParser.ParserContext parserContext = documentMapperParser().parserContext(type)__            Mapper.TypeParser typeParser = parserContext.typeParser(type)__            if (typeParser == null) {_                throw new IllegalArgumentException("No mapper found for type [" + type + "]")__            }_            final Mapper.Builder<?, ?> builder = typeParser.parse("__anonymous_" + type, emptyMap(), parserContext)__            final BuilderContext builderContext = new BuilderContext(indexSettings.getSettings(), new ContentPath(1))__            fieldType = ((FieldMapper)builder.build(builderContext)).fieldType()___            _            _            Map<String, MappedFieldType> newUnmappedFieldTypes = new HashMap<>(unmappedFieldTypes)__            newUnmappedFieldTypes.put(type, fieldType)__            unmappedFieldTypes = unmodifiableMap(newUnmappedFieldTypes)__        }_        return fieldType__    };given,a,type,eg,long,string,return,an,anonymous,field,mapper,that,can,be,used,for,search,operations;public,mapped,field,type,unmapped,field,type,string,type,if,type,equals,string,deprecation,logger,deprecated,string,should,be,replaced,with,keyword,type,keyword,mapped,field,type,field,type,unmapped,field,types,get,type,if,field,type,null,final,mapper,type,parser,parser,context,parser,context,document,mapper,parser,parser,context,type,mapper,type,parser,type,parser,parser,context,type,parser,type,if,type,parser,null,throw,new,illegal,argument,exception,no,mapper,found,for,type,type,final,mapper,builder,builder,type,parser,parse,type,empty,map,parser,context,final,builder,context,builder,context,new,builder,context,index,settings,get,settings,new,content,path,1,field,type,field,mapper,builder,build,builder,context,field,type,map,string,mapped,field,type,new,unmapped,field,types,new,hash,map,unmapped,field,types,new,unmapped,field,types,put,type,field,type,unmapped,field,types,unmodifiable,map,new,unmapped,field,types,return,field,type
MapperService -> public MappedFieldType unmappedFieldType(String type);1545126194;Given a type (eg. long, string, ...), return an anonymous field mapper that can be used for search operations.;public MappedFieldType unmappedFieldType(String type) {_        if (type.equals("string")) {_            deprecationLogger.deprecated("[unmapped_type:string] should be replaced with [unmapped_type:keyword]")__            type = "keyword"__        }_        MappedFieldType fieldType = unmappedFieldTypes.get(type)__        if (fieldType == null) {_            final Mapper.TypeParser.ParserContext parserContext = documentMapperParser().parserContext(type)__            Mapper.TypeParser typeParser = parserContext.typeParser(type)__            if (typeParser == null) {_                throw new IllegalArgumentException("No mapper found for type [" + type + "]")__            }_            final Mapper.Builder<?, ?> builder = typeParser.parse("__anonymous_" + type, emptyMap(), parserContext)__            final BuilderContext builderContext = new BuilderContext(indexSettings.getSettings(), new ContentPath(1))__            fieldType = ((FieldMapper)builder.build(builderContext)).fieldType()___            _            _            Map<String, MappedFieldType> newUnmappedFieldTypes = new HashMap<>(unmappedFieldTypes)__            newUnmappedFieldTypes.put(type, fieldType)__            unmappedFieldTypes = unmodifiableMap(newUnmappedFieldTypes)__        }_        return fieldType__    };given,a,type,eg,long,string,return,an,anonymous,field,mapper,that,can,be,used,for,search,operations;public,mapped,field,type,unmapped,field,type,string,type,if,type,equals,string,deprecation,logger,deprecated,string,should,be,replaced,with,keyword,type,keyword,mapped,field,type,field,type,unmapped,field,types,get,type,if,field,type,null,final,mapper,type,parser,parser,context,parser,context,document,mapper,parser,parser,context,type,mapper,type,parser,type,parser,parser,context,type,parser,type,if,type,parser,null,throw,new,illegal,argument,exception,no,mapper,found,for,type,type,final,mapper,builder,builder,type,parser,parse,type,empty,map,parser,context,final,builder,context,builder,context,new,builder,context,index,settings,get,settings,new,content,path,1,field,type,field,mapper,builder,build,builder,context,field,type,map,string,mapped,field,type,new,unmapped,field,types,new,hash,map,unmapped,field,types,new,unmapped,field,types,put,type,field,type,unmapped,field,types,unmodifiable,map,new,unmapped,field,types,return,field,type
MapperService -> public MappedFieldType unmappedFieldType(String type);1547566367;Given a type (eg. long, string, ...), return an anonymous field mapper that can be used for search operations.;public MappedFieldType unmappedFieldType(String type) {_        if (type.equals("string")) {_            deprecationLogger.deprecated("[unmapped_type:string] should be replaced with [unmapped_type:keyword]")__            type = "keyword"__        }_        MappedFieldType fieldType = unmappedFieldTypes.get(type)__        if (fieldType == null) {_            final Mapper.TypeParser.ParserContext parserContext = documentMapperParser().parserContext(type)__            Mapper.TypeParser typeParser = parserContext.typeParser(type)__            if (typeParser == null) {_                throw new IllegalArgumentException("No mapper found for type [" + type + "]")__            }_            final Mapper.Builder<?, ?> builder = typeParser.parse("__anonymous_" + type, emptyMap(), parserContext)__            final BuilderContext builderContext = new BuilderContext(indexSettings.getSettings(), new ContentPath(1))__            fieldType = ((FieldMapper)builder.build(builderContext)).fieldType()___            _            _            Map<String, MappedFieldType> newUnmappedFieldTypes = new HashMap<>(unmappedFieldTypes)__            newUnmappedFieldTypes.put(type, fieldType)__            unmappedFieldTypes = unmodifiableMap(newUnmappedFieldTypes)__        }_        return fieldType__    };given,a,type,eg,long,string,return,an,anonymous,field,mapper,that,can,be,used,for,search,operations;public,mapped,field,type,unmapped,field,type,string,type,if,type,equals,string,deprecation,logger,deprecated,string,should,be,replaced,with,keyword,type,keyword,mapped,field,type,field,type,unmapped,field,types,get,type,if,field,type,null,final,mapper,type,parser,parser,context,parser,context,document,mapper,parser,parser,context,type,mapper,type,parser,type,parser,parser,context,type,parser,type,if,type,parser,null,throw,new,illegal,argument,exception,no,mapper,found,for,type,type,final,mapper,builder,builder,type,parser,parse,type,empty,map,parser,context,final,builder,context,builder,context,new,builder,context,index,settings,get,settings,new,content,path,1,field,type,field,mapper,builder,build,builder,context,field,type,map,string,mapped,field,type,new,unmapped,field,types,new,hash,map,unmapped,field,types,new,unmapped,field,types,put,type,field,type,unmapped,field,types,unmodifiable,map,new,unmapped,field,types,return,field,type
MapperService -> public MappedFieldType unmappedFieldType(String type);1549392752;Given a type (eg. long, string, ...), return an anonymous field mapper that can be used for search operations.;public MappedFieldType unmappedFieldType(String type) {_        if (type.equals("string")) {_            deprecationLogger.deprecated("[unmapped_type:string] should be replaced with [unmapped_type:keyword]")__            type = "keyword"__        }_        MappedFieldType fieldType = unmappedFieldTypes.get(type)__        if (fieldType == null) {_            final Mapper.TypeParser.ParserContext parserContext = documentMapperParser().parserContext(type)__            Mapper.TypeParser typeParser = parserContext.typeParser(type)__            if (typeParser == null) {_                throw new IllegalArgumentException("No mapper found for type [" + type + "]")__            }_            final Mapper.Builder<?, ?> builder = typeParser.parse("__anonymous_" + type, emptyMap(), parserContext)__            final BuilderContext builderContext = new BuilderContext(indexSettings.getSettings(), new ContentPath(1))__            fieldType = ((FieldMapper)builder.build(builderContext)).fieldType()___            _            _            Map<String, MappedFieldType> newUnmappedFieldTypes = new HashMap<>(unmappedFieldTypes)__            newUnmappedFieldTypes.put(type, fieldType)__            unmappedFieldTypes = unmodifiableMap(newUnmappedFieldTypes)__        }_        return fieldType__    };given,a,type,eg,long,string,return,an,anonymous,field,mapper,that,can,be,used,for,search,operations;public,mapped,field,type,unmapped,field,type,string,type,if,type,equals,string,deprecation,logger,deprecated,string,should,be,replaced,with,keyword,type,keyword,mapped,field,type,field,type,unmapped,field,types,get,type,if,field,type,null,final,mapper,type,parser,parser,context,parser,context,document,mapper,parser,parser,context,type,mapper,type,parser,type,parser,parser,context,type,parser,type,if,type,parser,null,throw,new,illegal,argument,exception,no,mapper,found,for,type,type,final,mapper,builder,builder,type,parser,parse,type,empty,map,parser,context,final,builder,context,builder,context,new,builder,context,index,settings,get,settings,new,content,path,1,field,type,field,mapper,builder,build,builder,context,field,type,map,string,mapped,field,type,new,unmapped,field,types,new,hash,map,unmapped,field,types,new,unmapped,field,types,put,type,field,type,unmapped,field,types,unmodifiable,map,new,unmapped,field,types,return,field,type
MapperService -> public Iterable<MappedFieldType> fieldTypes();1531937412;Returns all mapped field types.;public Iterable<MappedFieldType> fieldTypes() {_        return fieldTypes__    };returns,all,mapped,field,types;public,iterable,mapped,field,type,field,types,return,field,types
MapperService -> public Iterable<MappedFieldType> fieldTypes();1532353780;Returns all mapped field types.;public Iterable<MappedFieldType> fieldTypes() {_        return fieldTypes__    };returns,all,mapped,field,types;public,iterable,mapped,field,type,field,types,return,field,types
MapperService -> public Iterable<MappedFieldType> fieldTypes();1534539448;Returns all mapped field types.;public Iterable<MappedFieldType> fieldTypes() {_        return fieldTypes__    };returns,all,mapped,field,types;public,iterable,mapped,field,type,field,types,return,field,types
MapperService -> public Iterable<MappedFieldType> fieldTypes();1535383145;Returns all mapped field types.;public Iterable<MappedFieldType> fieldTypes() {_        return fieldTypes__    };returns,all,mapped,field,types;public,iterable,mapped,field,type,field,types,return,field,types
MapperService -> public Iterable<MappedFieldType> fieldTypes();1535405719;Returns all mapped field types.;public Iterable<MappedFieldType> fieldTypes() {_        return fieldTypes__    };returns,all,mapped,field,types;public,iterable,mapped,field,type,field,types,return,field,types
MapperService -> public Iterable<MappedFieldType> fieldTypes();1536177418;Returns all mapped field types.;public Iterable<MappedFieldType> fieldTypes() {_        return fieldTypes__    };returns,all,mapped,field,types;public,iterable,mapped,field,type,field,types,return,field,types
MapperService -> public Iterable<MappedFieldType> fieldTypes();1540486836;Returns all mapped field types.;public Iterable<MappedFieldType> fieldTypes() {_        return fieldTypes__    };returns,all,mapped,field,types;public,iterable,mapped,field,type,field,types,return,field,types
MapperService -> public Iterable<MappedFieldType> fieldTypes();1540583181;Returns all mapped field types.;public Iterable<MappedFieldType> fieldTypes() {_        return fieldTypes__    };returns,all,mapped,field,types;public,iterable,mapped,field,type,field,types,return,field,types
MapperService -> public Iterable<MappedFieldType> fieldTypes();1541008027;Returns all mapped field types.;public Iterable<MappedFieldType> fieldTypes() {_        return fieldTypes__    };returns,all,mapped,field,types;public,iterable,mapped,field,type,field,types,return,field,types
MapperService -> public Iterable<MappedFieldType> fieldTypes();1541592065;Returns all mapped field types.;public Iterable<MappedFieldType> fieldTypes() {_        return fieldTypes__    };returns,all,mapped,field,types;public,iterable,mapped,field,type,field,types,return,field,types
MapperService -> public Iterable<MappedFieldType> fieldTypes();1542899326;Returns all mapped field types.;public Iterable<MappedFieldType> fieldTypes() {_        return fieldTypes__    };returns,all,mapped,field,types;public,iterable,mapped,field,type,field,types,return,field,types
MapperService -> public Iterable<MappedFieldType> fieldTypes();1543947737;Returns all mapped field types.;public Iterable<MappedFieldType> fieldTypes() {_        return fieldTypes__    };returns,all,mapped,field,types;public,iterable,mapped,field,type,field,types,return,field,types
MapperService -> public Iterable<MappedFieldType> fieldTypes();1545126194;Returns all mapped field types.;public Iterable<MappedFieldType> fieldTypes() {_        return fieldTypes__    };returns,all,mapped,field,types;public,iterable,mapped,field,type,field,types,return,field,types
MapperService -> public Iterable<MappedFieldType> fieldTypes();1547566367;Returns all mapped field types.;public Iterable<MappedFieldType> fieldTypes() {_        return fieldTypes__    };returns,all,mapped,field,types;public,iterable,mapped,field,type,field,types,return,field,types
MapperService -> public Iterable<MappedFieldType> fieldTypes();1549392752;Returns all mapped field types.;public Iterable<MappedFieldType> fieldTypes() {_        return fieldTypes__    };returns,all,mapped,field,types;public,iterable,mapped,field,type,field,types,return,field,types
MapperService -> public boolean updateMapping(IndexMetaData indexMetaData) throws IOException;1524684173;Update mapping by only merging the metadata that is different between received and stored entries;public boolean updateMapping(IndexMetaData indexMetaData) throws IOException {_        assert indexMetaData.getIndex().equals(index()) : "index mismatch: expected " + index() + " but was " + indexMetaData.getIndex()__        _        Set<String> existingMappers = new HashSet<>()__        if (mapper != null) {_            existingMappers.add(mapper.type())__        }_        if (defaultMapper != null) {_            existingMappers.add(DEFAULT_MAPPING)__        }_        final Map<String, DocumentMapper> updatedEntries__        try {_            _            updatedEntries = internalMerge(indexMetaData, MergeReason.MAPPING_RECOVERY, true)__        } catch (Exception e) {_            logger.warn(() -> new ParameterizedMessage("[{}] failed to apply mappings", index()), e)__            throw e__        }__        boolean requireRefresh = false___        for (DocumentMapper documentMapper : updatedEntries.values()) {_            String mappingType = documentMapper.type()__            CompressedXContent incomingMappingSource = indexMetaData.mapping(mappingType).source()___            String op = existingMappers.contains(mappingType) ? "updated" : "added"__            if (logger.isDebugEnabled() && incomingMappingSource.compressed().length < 512) {_                logger.debug("[{}] {} mapping [{}], source [{}]", index(), op, mappingType, incomingMappingSource.string())__            } else if (logger.isTraceEnabled()) {_                logger.trace("[{}] {} mapping [{}], source [{}]", index(), op, mappingType, incomingMappingSource.string())__            } else {_                logger.debug("[{}] {} mapping [{}] (source suppressed due to length, use TRACE level if needed)", index(), op, mappingType)__            }__            _            _            _            if (documentMapper(mappingType).mappingSource().equals(incomingMappingSource) == false) {_                logger.debug("[{}] parsed mapping [{}], and got different sources\noriginal:\n{}\nparsed:\n{}", index(), mappingType,_                    incomingMappingSource, documentMapper(mappingType).mappingSource())___                requireRefresh = true__            }_        }__        return requireRefresh__    };update,mapping,by,only,merging,the,metadata,that,is,different,between,received,and,stored,entries;public,boolean,update,mapping,index,meta,data,index,meta,data,throws,ioexception,assert,index,meta,data,get,index,equals,index,index,mismatch,expected,index,but,was,index,meta,data,get,index,set,string,existing,mappers,new,hash,set,if,mapper,null,existing,mappers,add,mapper,type,if,default,mapper,null,existing,mappers,add,final,map,string,document,mapper,updated,entries,try,updated,entries,internal,merge,index,meta,data,merge,reason,true,catch,exception,e,logger,warn,new,parameterized,message,failed,to,apply,mappings,index,e,throw,e,boolean,require,refresh,false,for,document,mapper,document,mapper,updated,entries,values,string,mapping,type,document,mapper,type,compressed,xcontent,incoming,mapping,source,index,meta,data,mapping,mapping,type,source,string,op,existing,mappers,contains,mapping,type,updated,added,if,logger,is,debug,enabled,incoming,mapping,source,compressed,length,512,logger,debug,mapping,source,index,op,mapping,type,incoming,mapping,source,string,else,if,logger,is,trace,enabled,logger,trace,mapping,source,index,op,mapping,type,incoming,mapping,source,string,else,logger,debug,mapping,source,suppressed,due,to,length,use,trace,level,if,needed,index,op,mapping,type,if,document,mapper,mapping,type,mapping,source,equals,incoming,mapping,source,false,logger,debug,parsed,mapping,and,got,different,sources,noriginal,n,nparsed,n,index,mapping,type,incoming,mapping,source,document,mapper,mapping,type,mapping,source,require,refresh,true,return,require,refresh
MapperService -> public boolean updateMapping(IndexMetaData indexMetaData) throws IOException;1525334055;Update mapping by only merging the metadata that is different between received and stored entries;public boolean updateMapping(IndexMetaData indexMetaData) throws IOException {_        assert indexMetaData.getIndex().equals(index()) : "index mismatch: expected " + index() + " but was " + indexMetaData.getIndex()__        _        Set<String> existingMappers = new HashSet<>()__        if (mapper != null) {_            existingMappers.add(mapper.type())__        }_        if (defaultMapper != null) {_            existingMappers.add(DEFAULT_MAPPING)__        }_        final Map<String, DocumentMapper> updatedEntries__        try {_            _            updatedEntries = internalMerge(indexMetaData, MergeReason.MAPPING_RECOVERY, true)__        } catch (Exception e) {_            logger.warn(() -> new ParameterizedMessage("[{}] failed to apply mappings", index()), e)__            throw e__        }__        boolean requireRefresh = false___        for (DocumentMapper documentMapper : updatedEntries.values()) {_            String mappingType = documentMapper.type()__            CompressedXContent incomingMappingSource = indexMetaData.mapping(mappingType).source()___            String op = existingMappers.contains(mappingType) ? "updated" : "added"__            if (logger.isDebugEnabled() && incomingMappingSource.compressed().length < 512) {_                logger.debug("[{}] {} mapping [{}], source [{}]", index(), op, mappingType, incomingMappingSource.string())__            } else if (logger.isTraceEnabled()) {_                logger.trace("[{}] {} mapping [{}], source [{}]", index(), op, mappingType, incomingMappingSource.string())__            } else {_                logger.debug("[{}] {} mapping [{}] (source suppressed due to length, use TRACE level if needed)", index(), op, mappingType)__            }__            _            _            _            if (documentMapper(mappingType).mappingSource().equals(incomingMappingSource) == false) {_                logger.debug("[{}] parsed mapping [{}], and got different sources\noriginal:\n{}\nparsed:\n{}", index(), mappingType,_                    incomingMappingSource, documentMapper(mappingType).mappingSource())___                requireRefresh = true__            }_        }__        return requireRefresh__    };update,mapping,by,only,merging,the,metadata,that,is,different,between,received,and,stored,entries;public,boolean,update,mapping,index,meta,data,index,meta,data,throws,ioexception,assert,index,meta,data,get,index,equals,index,index,mismatch,expected,index,but,was,index,meta,data,get,index,set,string,existing,mappers,new,hash,set,if,mapper,null,existing,mappers,add,mapper,type,if,default,mapper,null,existing,mappers,add,final,map,string,document,mapper,updated,entries,try,updated,entries,internal,merge,index,meta,data,merge,reason,true,catch,exception,e,logger,warn,new,parameterized,message,failed,to,apply,mappings,index,e,throw,e,boolean,require,refresh,false,for,document,mapper,document,mapper,updated,entries,values,string,mapping,type,document,mapper,type,compressed,xcontent,incoming,mapping,source,index,meta,data,mapping,mapping,type,source,string,op,existing,mappers,contains,mapping,type,updated,added,if,logger,is,debug,enabled,incoming,mapping,source,compressed,length,512,logger,debug,mapping,source,index,op,mapping,type,incoming,mapping,source,string,else,if,logger,is,trace,enabled,logger,trace,mapping,source,index,op,mapping,type,incoming,mapping,source,string,else,logger,debug,mapping,source,suppressed,due,to,length,use,trace,level,if,needed,index,op,mapping,type,if,document,mapper,mapping,type,mapping,source,equals,incoming,mapping,source,false,logger,debug,parsed,mapping,and,got,different,sources,noriginal,n,nparsed,n,index,mapping,type,incoming,mapping,source,document,mapper,mapping,type,mapping,source,require,refresh,true,return,require,refresh
MapperService -> public boolean updateMapping(IndexMetaData indexMetaData) throws IOException;1528706846;Update mapping by only merging the metadata that is different between received and stored entries;public boolean updateMapping(IndexMetaData indexMetaData) throws IOException {_        assert indexMetaData.getIndex().equals(index()) : "index mismatch: expected " + index() + " but was " + indexMetaData.getIndex()__        _        Set<String> existingMappers = new HashSet<>()__        if (mapper != null) {_            existingMappers.add(mapper.type())__        }_        if (defaultMapper != null) {_            existingMappers.add(DEFAULT_MAPPING)__        }_        final Map<String, DocumentMapper> updatedEntries__        try {_            _            updatedEntries = internalMerge(indexMetaData, MergeReason.MAPPING_RECOVERY, true)__        } catch (Exception e) {_            logger.warn(() -> new ParameterizedMessage("[{}] failed to apply mappings", index()), e)__            throw e__        }__        boolean requireRefresh = false___        for (DocumentMapper documentMapper : updatedEntries.values()) {_            String mappingType = documentMapper.type()__            CompressedXContent incomingMappingSource = indexMetaData.mapping(mappingType).source()___            String op = existingMappers.contains(mappingType) ? "updated" : "added"__            if (logger.isDebugEnabled() && incomingMappingSource.compressed().length < 512) {_                logger.debug("[{}] {} mapping [{}], source [{}]", index(), op, mappingType, incomingMappingSource.string())__            } else if (logger.isTraceEnabled()) {_                logger.trace("[{}] {} mapping [{}], source [{}]", index(), op, mappingType, incomingMappingSource.string())__            } else {_                logger.debug("[{}] {} mapping [{}] (source suppressed due to length, use TRACE level if needed)", index(), op, mappingType)__            }__            _            _            _            if (documentMapper(mappingType).mappingSource().equals(incomingMappingSource) == false) {_                logger.debug("[{}] parsed mapping [{}], and got different sources\noriginal:\n{}\nparsed:\n{}", index(), mappingType,_                    incomingMappingSource, documentMapper(mappingType).mappingSource())___                requireRefresh = true__            }_        }__        return requireRefresh__    };update,mapping,by,only,merging,the,metadata,that,is,different,between,received,and,stored,entries;public,boolean,update,mapping,index,meta,data,index,meta,data,throws,ioexception,assert,index,meta,data,get,index,equals,index,index,mismatch,expected,index,but,was,index,meta,data,get,index,set,string,existing,mappers,new,hash,set,if,mapper,null,existing,mappers,add,mapper,type,if,default,mapper,null,existing,mappers,add,final,map,string,document,mapper,updated,entries,try,updated,entries,internal,merge,index,meta,data,merge,reason,true,catch,exception,e,logger,warn,new,parameterized,message,failed,to,apply,mappings,index,e,throw,e,boolean,require,refresh,false,for,document,mapper,document,mapper,updated,entries,values,string,mapping,type,document,mapper,type,compressed,xcontent,incoming,mapping,source,index,meta,data,mapping,mapping,type,source,string,op,existing,mappers,contains,mapping,type,updated,added,if,logger,is,debug,enabled,incoming,mapping,source,compressed,length,512,logger,debug,mapping,source,index,op,mapping,type,incoming,mapping,source,string,else,if,logger,is,trace,enabled,logger,trace,mapping,source,index,op,mapping,type,incoming,mapping,source,string,else,logger,debug,mapping,source,suppressed,due,to,length,use,trace,level,if,needed,index,op,mapping,type,if,document,mapper,mapping,type,mapping,source,equals,incoming,mapping,source,false,logger,debug,parsed,mapping,and,got,different,sources,noriginal,n,nparsed,n,index,mapping,type,incoming,mapping,source,document,mapper,mapping,type,mapping,source,require,refresh,true,return,require,refresh
MapperService -> public boolean updateMapping(IndexMetaData indexMetaData) throws IOException;1531937412;Update mapping by only merging the metadata that is different between received and stored entries;public boolean updateMapping(IndexMetaData indexMetaData) throws IOException {_        assert indexMetaData.getIndex().equals(index()) : "index mismatch: expected " + index() + " but was " + indexMetaData.getIndex()__        _        Set<String> existingMappers = new HashSet<>()__        if (mapper != null) {_            existingMappers.add(mapper.type())__        }_        if (defaultMapper != null) {_            existingMappers.add(DEFAULT_MAPPING)__        }_        final Map<String, DocumentMapper> updatedEntries__        try {_            _            updatedEntries = internalMerge(indexMetaData, MergeReason.MAPPING_RECOVERY, true)__        } catch (Exception e) {_            logger.warn(() -> new ParameterizedMessage("[{}] failed to apply mappings", index()), e)__            throw e__        }__        boolean requireRefresh = false___        for (DocumentMapper documentMapper : updatedEntries.values()) {_            String mappingType = documentMapper.type()__            CompressedXContent incomingMappingSource = indexMetaData.mapping(mappingType).source()___            String op = existingMappers.contains(mappingType) ? "updated" : "added"__            if (logger.isDebugEnabled() && incomingMappingSource.compressed().length < 512) {_                logger.debug("[{}] {} mapping [{}], source [{}]", index(), op, mappingType, incomingMappingSource.string())__            } else if (logger.isTraceEnabled()) {_                logger.trace("[{}] {} mapping [{}], source [{}]", index(), op, mappingType, incomingMappingSource.string())__            } else {_                logger.debug("[{}] {} mapping [{}] (source suppressed due to length, use TRACE level if needed)", index(), op, mappingType)__            }__            _            _            _            if (documentMapper(mappingType).mappingSource().equals(incomingMappingSource) == false) {_                logger.debug("[{}] parsed mapping [{}], and got different sources\noriginal:\n{}\nparsed:\n{}", index(), mappingType,_                    incomingMappingSource, documentMapper(mappingType).mappingSource())___                requireRefresh = true__            }_        }__        return requireRefresh__    };update,mapping,by,only,merging,the,metadata,that,is,different,between,received,and,stored,entries;public,boolean,update,mapping,index,meta,data,index,meta,data,throws,ioexception,assert,index,meta,data,get,index,equals,index,index,mismatch,expected,index,but,was,index,meta,data,get,index,set,string,existing,mappers,new,hash,set,if,mapper,null,existing,mappers,add,mapper,type,if,default,mapper,null,existing,mappers,add,final,map,string,document,mapper,updated,entries,try,updated,entries,internal,merge,index,meta,data,merge,reason,true,catch,exception,e,logger,warn,new,parameterized,message,failed,to,apply,mappings,index,e,throw,e,boolean,require,refresh,false,for,document,mapper,document,mapper,updated,entries,values,string,mapping,type,document,mapper,type,compressed,xcontent,incoming,mapping,source,index,meta,data,mapping,mapping,type,source,string,op,existing,mappers,contains,mapping,type,updated,added,if,logger,is,debug,enabled,incoming,mapping,source,compressed,length,512,logger,debug,mapping,source,index,op,mapping,type,incoming,mapping,source,string,else,if,logger,is,trace,enabled,logger,trace,mapping,source,index,op,mapping,type,incoming,mapping,source,string,else,logger,debug,mapping,source,suppressed,due,to,length,use,trace,level,if,needed,index,op,mapping,type,if,document,mapper,mapping,type,mapping,source,equals,incoming,mapping,source,false,logger,debug,parsed,mapping,and,got,different,sources,noriginal,n,nparsed,n,index,mapping,type,incoming,mapping,source,document,mapper,mapping,type,mapping,source,require,refresh,true,return,require,refresh
MapperService -> public boolean updateMapping(IndexMetaData indexMetaData) throws IOException;1532353780;Update mapping by only merging the metadata that is different between received and stored entries;public boolean updateMapping(IndexMetaData indexMetaData) throws IOException {_        assert indexMetaData.getIndex().equals(index()) : "index mismatch: expected " + index() + " but was " + indexMetaData.getIndex()__        _        Set<String> existingMappers = new HashSet<>()__        if (mapper != null) {_            existingMappers.add(mapper.type())__        }_        if (defaultMapper != null) {_            existingMappers.add(DEFAULT_MAPPING)__        }_        final Map<String, DocumentMapper> updatedEntries__        try {_            _            updatedEntries = internalMerge(indexMetaData, MergeReason.MAPPING_RECOVERY, true)__        } catch (Exception e) {_            logger.warn(() -> new ParameterizedMessage("[{}] failed to apply mappings", index()), e)__            throw e__        }__        boolean requireRefresh = false___        for (DocumentMapper documentMapper : updatedEntries.values()) {_            String mappingType = documentMapper.type()__            CompressedXContent incomingMappingSource = indexMetaData.mapping(mappingType).source()___            String op = existingMappers.contains(mappingType) ? "updated" : "added"__            if (logger.isDebugEnabled() && incomingMappingSource.compressed().length < 512) {_                logger.debug("[{}] {} mapping [{}], source [{}]", index(), op, mappingType, incomingMappingSource.string())__            } else if (logger.isTraceEnabled()) {_                logger.trace("[{}] {} mapping [{}], source [{}]", index(), op, mappingType, incomingMappingSource.string())__            } else {_                logger.debug("[{}] {} mapping [{}] (source suppressed due to length, use TRACE level if needed)", index(), op, mappingType)__            }__            _            _            _            if (documentMapper(mappingType).mappingSource().equals(incomingMappingSource) == false) {_                logger.debug("[{}] parsed mapping [{}], and got different sources\noriginal:\n{}\nparsed:\n{}", index(), mappingType,_                    incomingMappingSource, documentMapper(mappingType).mappingSource())___                requireRefresh = true__            }_        }__        return requireRefresh__    };update,mapping,by,only,merging,the,metadata,that,is,different,between,received,and,stored,entries;public,boolean,update,mapping,index,meta,data,index,meta,data,throws,ioexception,assert,index,meta,data,get,index,equals,index,index,mismatch,expected,index,but,was,index,meta,data,get,index,set,string,existing,mappers,new,hash,set,if,mapper,null,existing,mappers,add,mapper,type,if,default,mapper,null,existing,mappers,add,final,map,string,document,mapper,updated,entries,try,updated,entries,internal,merge,index,meta,data,merge,reason,true,catch,exception,e,logger,warn,new,parameterized,message,failed,to,apply,mappings,index,e,throw,e,boolean,require,refresh,false,for,document,mapper,document,mapper,updated,entries,values,string,mapping,type,document,mapper,type,compressed,xcontent,incoming,mapping,source,index,meta,data,mapping,mapping,type,source,string,op,existing,mappers,contains,mapping,type,updated,added,if,logger,is,debug,enabled,incoming,mapping,source,compressed,length,512,logger,debug,mapping,source,index,op,mapping,type,incoming,mapping,source,string,else,if,logger,is,trace,enabled,logger,trace,mapping,source,index,op,mapping,type,incoming,mapping,source,string,else,logger,debug,mapping,source,suppressed,due,to,length,use,trace,level,if,needed,index,op,mapping,type,if,document,mapper,mapping,type,mapping,source,equals,incoming,mapping,source,false,logger,debug,parsed,mapping,and,got,different,sources,noriginal,n,nparsed,n,index,mapping,type,incoming,mapping,source,document,mapper,mapping,type,mapping,source,require,refresh,true,return,require,refresh
MapperService -> public boolean updateMapping(IndexMetaData indexMetaData) throws IOException;1534539448;Update mapping by only merging the metadata that is different between received and stored entries;public boolean updateMapping(IndexMetaData indexMetaData) throws IOException {_        assert indexMetaData.getIndex().equals(index()) : "index mismatch: expected " + index() + " but was " + indexMetaData.getIndex()__        _        Set<String> existingMappers = new HashSet<>()__        if (mapper != null) {_            existingMappers.add(mapper.type())__        }_        if (defaultMapper != null) {_            existingMappers.add(DEFAULT_MAPPING)__        }_        final Map<String, DocumentMapper> updatedEntries__        try {_            _            updatedEntries = internalMerge(indexMetaData, MergeReason.MAPPING_RECOVERY, true)__        } catch (Exception e) {_            logger.warn(() -> new ParameterizedMessage("[{}] failed to apply mappings", index()), e)__            throw e__        }__        boolean requireRefresh = false___        for (DocumentMapper documentMapper : updatedEntries.values()) {_            String mappingType = documentMapper.type()__            CompressedXContent incomingMappingSource = indexMetaData.mapping(mappingType).source()___            String op = existingMappers.contains(mappingType) ? "updated" : "added"__            if (logger.isDebugEnabled() && incomingMappingSource.compressed().length < 512) {_                logger.debug("[{}] {} mapping [{}], source [{}]", index(), op, mappingType, incomingMappingSource.string())__            } else if (logger.isTraceEnabled()) {_                logger.trace("[{}] {} mapping [{}], source [{}]", index(), op, mappingType, incomingMappingSource.string())__            } else {_                logger.debug("[{}] {} mapping [{}] (source suppressed due to length, use TRACE level if needed)", index(), op, mappingType)__            }__            _            _            _            if (documentMapper(mappingType).mappingSource().equals(incomingMappingSource) == false) {_                logger.debug("[{}] parsed mapping [{}], and got different sources\noriginal:\n{}\nparsed:\n{}", index(), mappingType,_                    incomingMappingSource, documentMapper(mappingType).mappingSource())___                requireRefresh = true__            }_        }__        return requireRefresh__    };update,mapping,by,only,merging,the,metadata,that,is,different,between,received,and,stored,entries;public,boolean,update,mapping,index,meta,data,index,meta,data,throws,ioexception,assert,index,meta,data,get,index,equals,index,index,mismatch,expected,index,but,was,index,meta,data,get,index,set,string,existing,mappers,new,hash,set,if,mapper,null,existing,mappers,add,mapper,type,if,default,mapper,null,existing,mappers,add,final,map,string,document,mapper,updated,entries,try,updated,entries,internal,merge,index,meta,data,merge,reason,true,catch,exception,e,logger,warn,new,parameterized,message,failed,to,apply,mappings,index,e,throw,e,boolean,require,refresh,false,for,document,mapper,document,mapper,updated,entries,values,string,mapping,type,document,mapper,type,compressed,xcontent,incoming,mapping,source,index,meta,data,mapping,mapping,type,source,string,op,existing,mappers,contains,mapping,type,updated,added,if,logger,is,debug,enabled,incoming,mapping,source,compressed,length,512,logger,debug,mapping,source,index,op,mapping,type,incoming,mapping,source,string,else,if,logger,is,trace,enabled,logger,trace,mapping,source,index,op,mapping,type,incoming,mapping,source,string,else,logger,debug,mapping,source,suppressed,due,to,length,use,trace,level,if,needed,index,op,mapping,type,if,document,mapper,mapping,type,mapping,source,equals,incoming,mapping,source,false,logger,debug,parsed,mapping,and,got,different,sources,noriginal,n,nparsed,n,index,mapping,type,incoming,mapping,source,document,mapper,mapping,type,mapping,source,require,refresh,true,return,require,refresh
MapperService -> public boolean updateMapping(IndexMetaData indexMetaData) throws IOException;1535383145;Update mapping by only merging the metadata that is different between received and stored entries;public boolean updateMapping(IndexMetaData indexMetaData) throws IOException {_        assert indexMetaData.getIndex().equals(index()) : "index mismatch: expected " + index() + " but was " + indexMetaData.getIndex()__        _        Set<String> existingMappers = new HashSet<>()__        if (mapper != null) {_            existingMappers.add(mapper.type())__        }_        if (defaultMapper != null) {_            existingMappers.add(DEFAULT_MAPPING)__        }_        final Map<String, DocumentMapper> updatedEntries__        try {_            _            updatedEntries = internalMerge(indexMetaData, MergeReason.MAPPING_RECOVERY, true)__        } catch (Exception e) {_            logger.warn(() -> new ParameterizedMessage("[{}] failed to apply mappings", index()), e)__            throw e__        }__        boolean requireRefresh = false___        for (DocumentMapper documentMapper : updatedEntries.values()) {_            String mappingType = documentMapper.type()__            CompressedXContent incomingMappingSource = indexMetaData.mapping(mappingType).source()___            String op = existingMappers.contains(mappingType) ? "updated" : "added"__            if (logger.isDebugEnabled() && incomingMappingSource.compressed().length < 512) {_                logger.debug("[{}] {} mapping [{}], source [{}]", index(), op, mappingType, incomingMappingSource.string())__            } else if (logger.isTraceEnabled()) {_                logger.trace("[{}] {} mapping [{}], source [{}]", index(), op, mappingType, incomingMappingSource.string())__            } else {_                logger.debug("[{}] {} mapping [{}] (source suppressed due to length, use TRACE level if needed)", index(), op, mappingType)__            }__            _            _            _            if (documentMapper(mappingType).mappingSource().equals(incomingMappingSource) == false) {_                logger.debug("[{}] parsed mapping [{}], and got different sources\noriginal:\n{}\nparsed:\n{}", index(), mappingType,_                    incomingMappingSource, documentMapper(mappingType).mappingSource())___                requireRefresh = true__            }_        }__        return requireRefresh__    };update,mapping,by,only,merging,the,metadata,that,is,different,between,received,and,stored,entries;public,boolean,update,mapping,index,meta,data,index,meta,data,throws,ioexception,assert,index,meta,data,get,index,equals,index,index,mismatch,expected,index,but,was,index,meta,data,get,index,set,string,existing,mappers,new,hash,set,if,mapper,null,existing,mappers,add,mapper,type,if,default,mapper,null,existing,mappers,add,final,map,string,document,mapper,updated,entries,try,updated,entries,internal,merge,index,meta,data,merge,reason,true,catch,exception,e,logger,warn,new,parameterized,message,failed,to,apply,mappings,index,e,throw,e,boolean,require,refresh,false,for,document,mapper,document,mapper,updated,entries,values,string,mapping,type,document,mapper,type,compressed,xcontent,incoming,mapping,source,index,meta,data,mapping,mapping,type,source,string,op,existing,mappers,contains,mapping,type,updated,added,if,logger,is,debug,enabled,incoming,mapping,source,compressed,length,512,logger,debug,mapping,source,index,op,mapping,type,incoming,mapping,source,string,else,if,logger,is,trace,enabled,logger,trace,mapping,source,index,op,mapping,type,incoming,mapping,source,string,else,logger,debug,mapping,source,suppressed,due,to,length,use,trace,level,if,needed,index,op,mapping,type,if,document,mapper,mapping,type,mapping,source,equals,incoming,mapping,source,false,logger,debug,parsed,mapping,and,got,different,sources,noriginal,n,nparsed,n,index,mapping,type,incoming,mapping,source,document,mapper,mapping,type,mapping,source,require,refresh,true,return,require,refresh
MapperService -> public DocumentMapperForType documentMapperWithAutoCreate(String type);1524684173;Returns the document mapper created, including a mapping update if the_type has been dynamically created.;public DocumentMapperForType documentMapperWithAutoCreate(String type) {_        DocumentMapper mapper = documentMapper(type)__        if (mapper != null) {_            return new DocumentMapperForType(mapper, null)__        }_        mapper = parse(type, null, true)__        return new DocumentMapperForType(mapper, mapper.mapping())__    };returns,the,document,mapper,created,including,a,mapping,update,if,the,type,has,been,dynamically,created;public,document,mapper,for,type,document,mapper,with,auto,create,string,type,document,mapper,mapper,document,mapper,type,if,mapper,null,return,new,document,mapper,for,type,mapper,null,mapper,parse,type,null,true,return,new,document,mapper,for,type,mapper,mapper,mapping
MapperService -> public DocumentMapperForType documentMapperWithAutoCreate(String type);1525334055;Returns the document mapper created, including a mapping update if the_type has been dynamically created.;public DocumentMapperForType documentMapperWithAutoCreate(String type) {_        DocumentMapper mapper = documentMapper(type)__        if (mapper != null) {_            return new DocumentMapperForType(mapper, null)__        }_        mapper = parse(type, null, true)__        return new DocumentMapperForType(mapper, mapper.mapping())__    };returns,the,document,mapper,created,including,a,mapping,update,if,the,type,has,been,dynamically,created;public,document,mapper,for,type,document,mapper,with,auto,create,string,type,document,mapper,mapper,document,mapper,type,if,mapper,null,return,new,document,mapper,for,type,mapper,null,mapper,parse,type,null,true,return,new,document,mapper,for,type,mapper,mapper,mapping
MapperService -> public DocumentMapperForType documentMapperWithAutoCreate(String type);1528706846;Returns the document mapper created, including a mapping update if the_type has been dynamically created.;public DocumentMapperForType documentMapperWithAutoCreate(String type) {_        DocumentMapper mapper = documentMapper(type)__        if (mapper != null) {_            return new DocumentMapperForType(mapper, null)__        }_        mapper = parse(type, null, true)__        return new DocumentMapperForType(mapper, mapper.mapping())__    };returns,the,document,mapper,created,including,a,mapping,update,if,the,type,has,been,dynamically,created;public,document,mapper,for,type,document,mapper,with,auto,create,string,type,document,mapper,mapper,document,mapper,type,if,mapper,null,return,new,document,mapper,for,type,mapper,null,mapper,parse,type,null,true,return,new,document,mapper,for,type,mapper,mapper,mapping
MapperService -> public DocumentMapperForType documentMapperWithAutoCreate(String type);1531937412;Returns the document mapper created, including a mapping update if the_type has been dynamically created.;public DocumentMapperForType documentMapperWithAutoCreate(String type) {_        DocumentMapper mapper = documentMapper(type)__        if (mapper != null) {_            return new DocumentMapperForType(mapper, null)__        }_        mapper = parse(type, null, true)__        return new DocumentMapperForType(mapper, mapper.mapping())__    };returns,the,document,mapper,created,including,a,mapping,update,if,the,type,has,been,dynamically,created;public,document,mapper,for,type,document,mapper,with,auto,create,string,type,document,mapper,mapper,document,mapper,type,if,mapper,null,return,new,document,mapper,for,type,mapper,null,mapper,parse,type,null,true,return,new,document,mapper,for,type,mapper,mapper,mapping
MapperService -> public DocumentMapperForType documentMapperWithAutoCreate(String type);1532353780;Returns the document mapper created, including a mapping update if the_type has been dynamically created.;public DocumentMapperForType documentMapperWithAutoCreate(String type) {_        DocumentMapper mapper = documentMapper(type)__        if (mapper != null) {_            return new DocumentMapperForType(mapper, null)__        }_        mapper = parse(type, null, true)__        return new DocumentMapperForType(mapper, mapper.mapping())__    };returns,the,document,mapper,created,including,a,mapping,update,if,the,type,has,been,dynamically,created;public,document,mapper,for,type,document,mapper,with,auto,create,string,type,document,mapper,mapper,document,mapper,type,if,mapper,null,return,new,document,mapper,for,type,mapper,null,mapper,parse,type,null,true,return,new,document,mapper,for,type,mapper,mapper,mapping
MapperService -> public DocumentMapperForType documentMapperWithAutoCreate(String type);1534539448;Returns the document mapper created, including a mapping update if the_type has been dynamically created.;public DocumentMapperForType documentMapperWithAutoCreate(String type) {_        DocumentMapper mapper = documentMapper(type)__        if (mapper != null) {_            return new DocumentMapperForType(mapper, null)__        }_        mapper = parse(type, null, true)__        return new DocumentMapperForType(mapper, mapper.mapping())__    };returns,the,document,mapper,created,including,a,mapping,update,if,the,type,has,been,dynamically,created;public,document,mapper,for,type,document,mapper,with,auto,create,string,type,document,mapper,mapper,document,mapper,type,if,mapper,null,return,new,document,mapper,for,type,mapper,null,mapper,parse,type,null,true,return,new,document,mapper,for,type,mapper,mapper,mapping
MapperService -> public DocumentMapperForType documentMapperWithAutoCreate(String type);1535383145;Returns the document mapper created, including a mapping update if the_type has been dynamically created.;public DocumentMapperForType documentMapperWithAutoCreate(String type) {_        DocumentMapper mapper = documentMapper(type)__        if (mapper != null) {_            return new DocumentMapperForType(mapper, null)__        }_        mapper = parse(type, null, true)__        return new DocumentMapperForType(mapper, mapper.mapping())__    };returns,the,document,mapper,created,including,a,mapping,update,if,the,type,has,been,dynamically,created;public,document,mapper,for,type,document,mapper,with,auto,create,string,type,document,mapper,mapper,document,mapper,type,if,mapper,null,return,new,document,mapper,for,type,mapper,null,mapper,parse,type,null,true,return,new,document,mapper,for,type,mapper,mapper,mapping
MapperService -> public DocumentMapperForType documentMapperWithAutoCreate(String type);1535405719;Returns the document mapper created, including a mapping update if the_type has been dynamically created.;public DocumentMapperForType documentMapperWithAutoCreate(String type) {_        DocumentMapper mapper = documentMapper(type)__        if (mapper != null) {_            return new DocumentMapperForType(mapper, null)__        }_        mapper = parse(type, null, true)__        return new DocumentMapperForType(mapper, mapper.mapping())__    };returns,the,document,mapper,created,including,a,mapping,update,if,the,type,has,been,dynamically,created;public,document,mapper,for,type,document,mapper,with,auto,create,string,type,document,mapper,mapper,document,mapper,type,if,mapper,null,return,new,document,mapper,for,type,mapper,null,mapper,parse,type,null,true,return,new,document,mapper,for,type,mapper,mapper,mapping
MapperService -> public DocumentMapperForType documentMapperWithAutoCreate(String type);1536177418;Returns the document mapper created, including a mapping update if the_type has been dynamically created.;public DocumentMapperForType documentMapperWithAutoCreate(String type) {_        DocumentMapper mapper = documentMapper(type)__        if (mapper != null) {_            return new DocumentMapperForType(mapper, null)__        }_        mapper = parse(type, null, true)__        return new DocumentMapperForType(mapper, mapper.mapping())__    };returns,the,document,mapper,created,including,a,mapping,update,if,the,type,has,been,dynamically,created;public,document,mapper,for,type,document,mapper,with,auto,create,string,type,document,mapper,mapper,document,mapper,type,if,mapper,null,return,new,document,mapper,for,type,mapper,null,mapper,parse,type,null,true,return,new,document,mapper,for,type,mapper,mapper,mapping
MapperService -> public DocumentMapperForType documentMapperWithAutoCreate(String type);1540486836;Returns the document mapper created, including a mapping update if the_type has been dynamically created.;public DocumentMapperForType documentMapperWithAutoCreate(String type) {_        DocumentMapper mapper = documentMapper(type)__        if (mapper != null) {_            return new DocumentMapperForType(mapper, null)__        }_        mapper = parse(type, null, true)__        return new DocumentMapperForType(mapper, mapper.mapping())__    };returns,the,document,mapper,created,including,a,mapping,update,if,the,type,has,been,dynamically,created;public,document,mapper,for,type,document,mapper,with,auto,create,string,type,document,mapper,mapper,document,mapper,type,if,mapper,null,return,new,document,mapper,for,type,mapper,null,mapper,parse,type,null,true,return,new,document,mapper,for,type,mapper,mapper,mapping
MapperService -> public DocumentMapperForType documentMapperWithAutoCreate(String type);1540583181;Returns the document mapper created, including a mapping update if the_type has been dynamically created.;public DocumentMapperForType documentMapperWithAutoCreate(String type) {_        DocumentMapper mapper = documentMapper(type)__        if (mapper != null) {_            return new DocumentMapperForType(mapper, null)__        }_        mapper = parse(type, null, true)__        return new DocumentMapperForType(mapper, mapper.mapping())__    };returns,the,document,mapper,created,including,a,mapping,update,if,the,type,has,been,dynamically,created;public,document,mapper,for,type,document,mapper,with,auto,create,string,type,document,mapper,mapper,document,mapper,type,if,mapper,null,return,new,document,mapper,for,type,mapper,null,mapper,parse,type,null,true,return,new,document,mapper,for,type,mapper,mapper,mapping
MapperService -> public DocumentMapperForType documentMapperWithAutoCreate(String type);1541008027;Returns the document mapper created, including a mapping update if the_type has been dynamically created.;public DocumentMapperForType documentMapperWithAutoCreate(String type) {_        DocumentMapper mapper = documentMapper(type)__        if (mapper != null) {_            return new DocumentMapperForType(mapper, null)__        }_        mapper = parse(type, null, true)__        return new DocumentMapperForType(mapper, mapper.mapping())__    };returns,the,document,mapper,created,including,a,mapping,update,if,the,type,has,been,dynamically,created;public,document,mapper,for,type,document,mapper,with,auto,create,string,type,document,mapper,mapper,document,mapper,type,if,mapper,null,return,new,document,mapper,for,type,mapper,null,mapper,parse,type,null,true,return,new,document,mapper,for,type,mapper,mapper,mapping
MapperService -> public DocumentMapperForType documentMapperWithAutoCreate(String type);1541592065;Returns the document mapper created, including a mapping update if the_type has been dynamically created.;public DocumentMapperForType documentMapperWithAutoCreate(String type) {_        DocumentMapper mapper = documentMapper(type)__        if (mapper != null) {_            return new DocumentMapperForType(mapper, null)__        }_        mapper = parse(type, null, true)__        return new DocumentMapperForType(mapper, mapper.mapping())__    };returns,the,document,mapper,created,including,a,mapping,update,if,the,type,has,been,dynamically,created;public,document,mapper,for,type,document,mapper,with,auto,create,string,type,document,mapper,mapper,document,mapper,type,if,mapper,null,return,new,document,mapper,for,type,mapper,null,mapper,parse,type,null,true,return,new,document,mapper,for,type,mapper,mapper,mapping
MapperService -> public DocumentMapperForType documentMapperWithAutoCreate(String type);1542899326;Returns the document mapper created, including a mapping update if the_type has been dynamically created.;public DocumentMapperForType documentMapperWithAutoCreate(String type) {_        DocumentMapper mapper = documentMapper(type)__        if (mapper != null) {_            return new DocumentMapperForType(mapper, null)__        }_        mapper = parse(type, null, true)__        return new DocumentMapperForType(mapper, mapper.mapping())__    };returns,the,document,mapper,created,including,a,mapping,update,if,the,type,has,been,dynamically,created;public,document,mapper,for,type,document,mapper,with,auto,create,string,type,document,mapper,mapper,document,mapper,type,if,mapper,null,return,new,document,mapper,for,type,mapper,null,mapper,parse,type,null,true,return,new,document,mapper,for,type,mapper,mapper,mapping
MapperService -> public DocumentMapperForType documentMapperWithAutoCreate(String type);1543947737;Returns the document mapper created, including a mapping update if the_type has been dynamically created.;public DocumentMapperForType documentMapperWithAutoCreate(String type) {_        DocumentMapper mapper = documentMapper(type)__        if (mapper != null) {_            return new DocumentMapperForType(mapper, null)__        }_        mapper = parse(type, null, true)__        return new DocumentMapperForType(mapper, mapper.mapping())__    };returns,the,document,mapper,created,including,a,mapping,update,if,the,type,has,been,dynamically,created;public,document,mapper,for,type,document,mapper,with,auto,create,string,type,document,mapper,mapper,document,mapper,type,if,mapper,null,return,new,document,mapper,for,type,mapper,null,mapper,parse,type,null,true,return,new,document,mapper,for,type,mapper,mapper,mapping
MapperService -> public DocumentMapperForType documentMapperWithAutoCreate(String type);1545126194;Returns the document mapper created, including a mapping update if the_type has been dynamically created.;public DocumentMapperForType documentMapperWithAutoCreate(String type) {_        DocumentMapper mapper = documentMapper(type)__        if (mapper != null) {_            return new DocumentMapperForType(mapper, null)__        }_        mapper = parse(type, null, true)__        return new DocumentMapperForType(mapper, mapper.mapping())__    };returns,the,document,mapper,created,including,a,mapping,update,if,the,type,has,been,dynamically,created;public,document,mapper,for,type,document,mapper,with,auto,create,string,type,document,mapper,mapper,document,mapper,type,if,mapper,null,return,new,document,mapper,for,type,mapper,null,mapper,parse,type,null,true,return,new,document,mapper,for,type,mapper,mapper,mapping
MapperService -> public DocumentMapperForType documentMapperWithAutoCreate(String type);1547566367;Returns the document mapper created, including a mapping update if the_type has been dynamically created.;public DocumentMapperForType documentMapperWithAutoCreate(String type) {_        DocumentMapper mapper = documentMapper(type)__        if (mapper != null) {_            return new DocumentMapperForType(mapper, null)__        }_        mapper = parse(type, null, true)__        return new DocumentMapperForType(mapper, mapper.mapping())__    };returns,the,document,mapper,created,including,a,mapping,update,if,the,type,has,been,dynamically,created;public,document,mapper,for,type,document,mapper,with,auto,create,string,type,document,mapper,mapper,document,mapper,type,if,mapper,null,return,new,document,mapper,for,type,mapper,null,mapper,parse,type,null,true,return,new,document,mapper,for,type,mapper,mapper,mapping
MapperService -> public DocumentMapperForType documentMapperWithAutoCreate(String type);1549392752;Returns the document mapper created, including a mapping update if the_type has been dynamically created.;public DocumentMapperForType documentMapperWithAutoCreate(String type) {_        DocumentMapper mapper = documentMapper(type)__        if (mapper != null) {_            return new DocumentMapperForType(mapper, null)__        }_        mapper = parse(type, null, true)__        return new DocumentMapperForType(mapper, mapper.mapping())__    };returns,the,document,mapper,created,including,a,mapping,update,if,the,type,has,been,dynamically,created;public,document,mapper,for,type,document,mapper,with,auto,create,string,type,document,mapper,mapper,document,mapper,type,if,mapper,null,return,new,document,mapper,for,type,mapper,null,mapper,parse,type,null,true,return,new,document,mapper,for,type,mapper,mapper,mapping
MapperService -> public MappedFieldType fullName(String fullName);1524684173;Returns the {@link MappedFieldType} for the give fullName.__If multiple types have fields with the same full name, the first is returned.;public MappedFieldType fullName(String fullName) {_        return fieldTypes.get(fullName)__    };returns,the,link,mapped,field,type,for,the,give,full,name,if,multiple,types,have,fields,with,the,same,full,name,the,first,is,returned;public,mapped,field,type,full,name,string,full,name,return,field,types,get,full,name
MapperService -> public MappedFieldType fullName(String fullName);1525334055;Returns the {@link MappedFieldType} for the give fullName.__If multiple types have fields with the same full name, the first is returned.;public MappedFieldType fullName(String fullName) {_        return fieldTypes.get(fullName)__    };returns,the,link,mapped,field,type,for,the,give,full,name,if,multiple,types,have,fields,with,the,same,full,name,the,first,is,returned;public,mapped,field,type,full,name,string,full,name,return,field,types,get,full,name
MapperService -> public MappedFieldType fullName(String fullName);1528706846;Returns the {@link MappedFieldType} for the give fullName.__If multiple types have fields with the same full name, the first is returned.;public MappedFieldType fullName(String fullName) {_        return fieldTypes.get(fullName)__    };returns,the,link,mapped,field,type,for,the,give,full,name,if,multiple,types,have,fields,with,the,same,full,name,the,first,is,returned;public,mapped,field,type,full,name,string,full,name,return,field,types,get,full,name
MapperService -> public MappedFieldType fullName(String fullName);1531937412;Returns the {@link MappedFieldType} for the give fullName.__If multiple types have fields with the same full name, the first is returned.;public MappedFieldType fullName(String fullName) {_        return fieldTypes.get(fullName)__    };returns,the,link,mapped,field,type,for,the,give,full,name,if,multiple,types,have,fields,with,the,same,full,name,the,first,is,returned;public,mapped,field,type,full,name,string,full,name,return,field,types,get,full,name
MapperService -> public MappedFieldType fullName(String fullName);1532353780;Returns the {@link MappedFieldType} for the give fullName.__If multiple types have fields with the same full name, the first is returned.;public MappedFieldType fullName(String fullName) {_        return fieldTypes.get(fullName)__    };returns,the,link,mapped,field,type,for,the,give,full,name,if,multiple,types,have,fields,with,the,same,full,name,the,first,is,returned;public,mapped,field,type,full,name,string,full,name,return,field,types,get,full,name
MapperService -> public MappedFieldType fullName(String fullName);1534539448;Returns the {@link MappedFieldType} for the give fullName.__If multiple types have fields with the same full name, the first is returned.;public MappedFieldType fullName(String fullName) {_        return fieldTypes.get(fullName)__    };returns,the,link,mapped,field,type,for,the,give,full,name,if,multiple,types,have,fields,with,the,same,full,name,the,first,is,returned;public,mapped,field,type,full,name,string,full,name,return,field,types,get,full,name
MapperService -> public MappedFieldType fullName(String fullName);1535383145;Returns the {@link MappedFieldType} for the give fullName.__If multiple types have fields with the same full name, the first is returned.;public MappedFieldType fullName(String fullName) {_        return fieldTypes.get(fullName)__    };returns,the,link,mapped,field,type,for,the,give,full,name,if,multiple,types,have,fields,with,the,same,full,name,the,first,is,returned;public,mapped,field,type,full,name,string,full,name,return,field,types,get,full,name
MapperService -> public MappedFieldType fullName(String fullName);1535405719;Returns the {@link MappedFieldType} for the give fullName.__If multiple types have fields with the same full name, the first is returned.;public MappedFieldType fullName(String fullName) {_        return fieldTypes.get(fullName)__    };returns,the,link,mapped,field,type,for,the,give,full,name,if,multiple,types,have,fields,with,the,same,full,name,the,first,is,returned;public,mapped,field,type,full,name,string,full,name,return,field,types,get,full,name
MapperService -> public MappedFieldType fullName(String fullName);1536177418;Returns the {@link MappedFieldType} for the give fullName.__If multiple types have fields with the same full name, the first is returned.;public MappedFieldType fullName(String fullName) {_        return fieldTypes.get(fullName)__    };returns,the,link,mapped,field,type,for,the,give,full,name,if,multiple,types,have,fields,with,the,same,full,name,the,first,is,returned;public,mapped,field,type,full,name,string,full,name,return,field,types,get,full,name
MapperService -> public MappedFieldType fullName(String fullName);1540486836;Returns the {@link MappedFieldType} for the give fullName.__If multiple types have fields with the same full name, the first is returned.;public MappedFieldType fullName(String fullName) {_        return fieldTypes.get(fullName)__    };returns,the,link,mapped,field,type,for,the,give,full,name,if,multiple,types,have,fields,with,the,same,full,name,the,first,is,returned;public,mapped,field,type,full,name,string,full,name,return,field,types,get,full,name
MapperService -> public MappedFieldType fullName(String fullName);1540583181;Returns the {@link MappedFieldType} for the give fullName.__If multiple types have fields with the same full name, the first is returned.;public MappedFieldType fullName(String fullName) {_        return fieldTypes.get(fullName)__    };returns,the,link,mapped,field,type,for,the,give,full,name,if,multiple,types,have,fields,with,the,same,full,name,the,first,is,returned;public,mapped,field,type,full,name,string,full,name,return,field,types,get,full,name
MapperService -> public MappedFieldType fullName(String fullName);1541008027;Returns the {@link MappedFieldType} for the give fullName.__If multiple types have fields with the same full name, the first is returned.;public MappedFieldType fullName(String fullName) {_        return fieldTypes.get(fullName)__    };returns,the,link,mapped,field,type,for,the,give,full,name,if,multiple,types,have,fields,with,the,same,full,name,the,first,is,returned;public,mapped,field,type,full,name,string,full,name,return,field,types,get,full,name
MapperService -> public MappedFieldType fullName(String fullName);1541592065;Returns the {@link MappedFieldType} for the give fullName.__If multiple types have fields with the same full name, the first is returned.;public MappedFieldType fullName(String fullName) {_        return fieldTypes.get(fullName)__    };returns,the,link,mapped,field,type,for,the,give,full,name,if,multiple,types,have,fields,with,the,same,full,name,the,first,is,returned;public,mapped,field,type,full,name,string,full,name,return,field,types,get,full,name
MapperService -> public MappedFieldType fullName(String fullName);1542899326;Returns the {@link MappedFieldType} for the give fullName.__If multiple types have fields with the same full name, the first is returned.;public MappedFieldType fullName(String fullName) {_        return fieldTypes.get(fullName)__    };returns,the,link,mapped,field,type,for,the,give,full,name,if,multiple,types,have,fields,with,the,same,full,name,the,first,is,returned;public,mapped,field,type,full,name,string,full,name,return,field,types,get,full,name
MapperService -> public MappedFieldType fullName(String fullName);1543947737;Returns the {@link MappedFieldType} for the give fullName.__If multiple types have fields with the same full name, the first is returned.;public MappedFieldType fullName(String fullName) {_        return fieldTypes.get(fullName)__    };returns,the,link,mapped,field,type,for,the,give,full,name,if,multiple,types,have,fields,with,the,same,full,name,the,first,is,returned;public,mapped,field,type,full,name,string,full,name,return,field,types,get,full,name
MapperService -> public MappedFieldType fullName(String fullName);1545126194;Returns the {@link MappedFieldType} for the give fullName.__If multiple types have fields with the same full name, the first is returned.;public MappedFieldType fullName(String fullName) {_        return fieldTypes.get(fullName)__    };returns,the,link,mapped,field,type,for,the,give,full,name,if,multiple,types,have,fields,with,the,same,full,name,the,first,is,returned;public,mapped,field,type,full,name,string,full,name,return,field,types,get,full,name
MapperService -> public MappedFieldType fullName(String fullName);1547566367;Returns the {@link MappedFieldType} for the give fullName.__If multiple types have fields with the same full name, the first is returned.;public MappedFieldType fullName(String fullName) {_        return fieldTypes.get(fullName)__    };returns,the,link,mapped,field,type,for,the,give,full,name,if,multiple,types,have,fields,with,the,same,full,name,the,first,is,returned;public,mapped,field,type,full,name,string,full,name,return,field,types,get,full,name
MapperService -> public MappedFieldType fullName(String fullName);1549392752;Returns the {@link MappedFieldType} for the give fullName.__If multiple types have fields with the same full name, the first is returned.;public MappedFieldType fullName(String fullName) {_        return fieldTypes.get(fullName)__    };returns,the,link,mapped,field,type,for,the,give,full,name,if,multiple,types,have,fields,with,the,same,full,name,the,first,is,returned;public,mapped,field,type,full,name,string,full,name,return,field,types,get,full,name
MapperService -> public String resolveDocumentType(String type);1547566367;Resolves a type from a mapping-related request into the type that should be used when_merging and updating mappings.__If the special `_doc` type is provided, then we replace it with the actual type that is_being used in the mappings. This allows typeless APIs such as 'index' or 'put mappings'_to work against indices with a custom type name.;public String resolveDocumentType(String type) {_        if (MapperService.SINGLE_MAPPING_NAME.equals(type)) {_            if (mapper != null) {_                return mapper.type()__            }_        }_        return type__    };resolves,a,type,from,a,mapping,related,request,into,the,type,that,should,be,used,when,merging,and,updating,mappings,if,the,special,type,is,provided,then,we,replace,it,with,the,actual,type,that,is,being,used,in,the,mappings,this,allows,typeless,apis,such,as,index,or,put,mappings,to,work,against,indices,with,a,custom,type,name;public,string,resolve,document,type,string,type,if,mapper,service,equals,type,if,mapper,null,return,mapper,type,return,type
MapperService -> public String resolveDocumentType(String type);1549392752;Resolves a type from a mapping-related request into the type that should be used when_merging and updating mappings.__If the special `_doc` type is provided, then we replace it with the actual type that is_being used in the mappings. This allows typeless APIs such as 'index' or 'put mappings'_to work against indices with a custom type name.;public String resolveDocumentType(String type) {_        if (MapperService.SINGLE_MAPPING_NAME.equals(type)) {_            if (mapper != null) {_                return mapper.type()__            }_        }_        return type__    };resolves,a,type,from,a,mapping,related,request,into,the,type,that,should,be,used,when,merging,and,updating,mappings,if,the,special,type,is,provided,then,we,replace,it,with,the,actual,type,that,is,being,used,in,the,mappings,this,allows,typeless,apis,such,as,index,or,put,mappings,to,work,against,indices,with,a,custom,type,name;public,string,resolve,document,type,string,type,if,mapper,service,equals,type,if,mapper,null,return,mapper,type,return,type
MapperService -> public DocumentMapper documentMapper(String type);1524684173;Return the {@link DocumentMapper} for the given type. By using the special_{@value #DEFAULT_MAPPING} type, you can get a {@link DocumentMapper} for_the default mapping.;public DocumentMapper documentMapper(String type) {_        if (mapper != null && type.equals(mapper.type())) {_            return mapper__        }_        if (DEFAULT_MAPPING.equals(type)) {_            return defaultMapper__        }_        return null__    };return,the,link,document,mapper,for,the,given,type,by,using,the,special,value,type,you,can,get,a,link,document,mapper,for,the,default,mapping;public,document,mapper,document,mapper,string,type,if,mapper,null,type,equals,mapper,type,return,mapper,if,equals,type,return,default,mapper,return,null
MapperService -> public DocumentMapper documentMapper(String type);1525334055;Return the {@link DocumentMapper} for the given type. By using the special_{@value #DEFAULT_MAPPING} type, you can get a {@link DocumentMapper} for_the default mapping.;public DocumentMapper documentMapper(String type) {_        if (mapper != null && type.equals(mapper.type())) {_            return mapper__        }_        if (DEFAULT_MAPPING.equals(type)) {_            return defaultMapper__        }_        return null__    };return,the,link,document,mapper,for,the,given,type,by,using,the,special,value,type,you,can,get,a,link,document,mapper,for,the,default,mapping;public,document,mapper,document,mapper,string,type,if,mapper,null,type,equals,mapper,type,return,mapper,if,equals,type,return,default,mapper,return,null
MapperService -> public DocumentMapper documentMapper(String type);1528706846;Return the {@link DocumentMapper} for the given type. By using the special_{@value #DEFAULT_MAPPING} type, you can get a {@link DocumentMapper} for_the default mapping.;public DocumentMapper documentMapper(String type) {_        if (mapper != null && type.equals(mapper.type())) {_            return mapper__        }_        if (DEFAULT_MAPPING.equals(type)) {_            return defaultMapper__        }_        return null__    };return,the,link,document,mapper,for,the,given,type,by,using,the,special,value,type,you,can,get,a,link,document,mapper,for,the,default,mapping;public,document,mapper,document,mapper,string,type,if,mapper,null,type,equals,mapper,type,return,mapper,if,equals,type,return,default,mapper,return,null
MapperService -> public DocumentMapper documentMapper(String type);1531937412;Return the {@link DocumentMapper} for the given type. By using the special_{@value #DEFAULT_MAPPING} type, you can get a {@link DocumentMapper} for_the default mapping.;public DocumentMapper documentMapper(String type) {_        if (mapper != null && type.equals(mapper.type())) {_            return mapper__        }_        if (DEFAULT_MAPPING.equals(type)) {_            return defaultMapper__        }_        return null__    };return,the,link,document,mapper,for,the,given,type,by,using,the,special,value,type,you,can,get,a,link,document,mapper,for,the,default,mapping;public,document,mapper,document,mapper,string,type,if,mapper,null,type,equals,mapper,type,return,mapper,if,equals,type,return,default,mapper,return,null
MapperService -> public DocumentMapper documentMapper(String type);1532353780;Return the {@link DocumentMapper} for the given type. By using the special_{@value #DEFAULT_MAPPING} type, you can get a {@link DocumentMapper} for_the default mapping.;public DocumentMapper documentMapper(String type) {_        if (mapper != null && type.equals(mapper.type())) {_            return mapper__        }_        if (DEFAULT_MAPPING.equals(type)) {_            return defaultMapper__        }_        return null__    };return,the,link,document,mapper,for,the,given,type,by,using,the,special,value,type,you,can,get,a,link,document,mapper,for,the,default,mapping;public,document,mapper,document,mapper,string,type,if,mapper,null,type,equals,mapper,type,return,mapper,if,equals,type,return,default,mapper,return,null
MapperService -> public DocumentMapper documentMapper(String type);1534539448;Return the {@link DocumentMapper} for the given type. By using the special_{@value #DEFAULT_MAPPING} type, you can get a {@link DocumentMapper} for_the default mapping.;public DocumentMapper documentMapper(String type) {_        if (mapper != null && type.equals(mapper.type())) {_            return mapper__        }_        if (DEFAULT_MAPPING.equals(type)) {_            return defaultMapper__        }_        return null__    };return,the,link,document,mapper,for,the,given,type,by,using,the,special,value,type,you,can,get,a,link,document,mapper,for,the,default,mapping;public,document,mapper,document,mapper,string,type,if,mapper,null,type,equals,mapper,type,return,mapper,if,equals,type,return,default,mapper,return,null
MapperService -> public DocumentMapper documentMapper(String type);1535383145;Return the {@link DocumentMapper} for the given type. By using the special_{@value #DEFAULT_MAPPING} type, you can get a {@link DocumentMapper} for_the default mapping.;public DocumentMapper documentMapper(String type) {_        if (mapper != null && type.equals(mapper.type())) {_            return mapper__        }_        if (DEFAULT_MAPPING.equals(type)) {_            return defaultMapper__        }_        return null__    };return,the,link,document,mapper,for,the,given,type,by,using,the,special,value,type,you,can,get,a,link,document,mapper,for,the,default,mapping;public,document,mapper,document,mapper,string,type,if,mapper,null,type,equals,mapper,type,return,mapper,if,equals,type,return,default,mapper,return,null
MapperService -> public DocumentMapper documentMapper(String type);1535405719;Return the {@link DocumentMapper} for the given type. By using the special_{@value #DEFAULT_MAPPING} type, you can get a {@link DocumentMapper} for_the default mapping.;public DocumentMapper documentMapper(String type) {_        if (mapper != null && type.equals(mapper.type())) {_            return mapper__        }_        if (DEFAULT_MAPPING.equals(type)) {_            return defaultMapper__        }_        return null__    };return,the,link,document,mapper,for,the,given,type,by,using,the,special,value,type,you,can,get,a,link,document,mapper,for,the,default,mapping;public,document,mapper,document,mapper,string,type,if,mapper,null,type,equals,mapper,type,return,mapper,if,equals,type,return,default,mapper,return,null
MapperService -> public DocumentMapper documentMapper(String type);1536177418;Return the {@link DocumentMapper} for the given type. By using the special_{@value #DEFAULT_MAPPING} type, you can get a {@link DocumentMapper} for_the default mapping.;public DocumentMapper documentMapper(String type) {_        if (mapper != null && type.equals(mapper.type())) {_            return mapper__        }_        if (DEFAULT_MAPPING.equals(type)) {_            return defaultMapper__        }_        return null__    };return,the,link,document,mapper,for,the,given,type,by,using,the,special,value,type,you,can,get,a,link,document,mapper,for,the,default,mapping;public,document,mapper,document,mapper,string,type,if,mapper,null,type,equals,mapper,type,return,mapper,if,equals,type,return,default,mapper,return,null
MapperService -> public DocumentMapper documentMapper(String type);1540486836;Return the {@link DocumentMapper} for the given type. By using the special_{@value #DEFAULT_MAPPING} type, you can get a {@link DocumentMapper} for_the default mapping.;public DocumentMapper documentMapper(String type) {_        if (mapper != null && type.equals(mapper.type())) {_            return mapper__        }_        if (DEFAULT_MAPPING.equals(type)) {_            return defaultMapper__        }_        return null__    };return,the,link,document,mapper,for,the,given,type,by,using,the,special,value,type,you,can,get,a,link,document,mapper,for,the,default,mapping;public,document,mapper,document,mapper,string,type,if,mapper,null,type,equals,mapper,type,return,mapper,if,equals,type,return,default,mapper,return,null
MapperService -> public DocumentMapper documentMapper(String type);1540583181;Return the {@link DocumentMapper} for the given type. By using the special_{@value #DEFAULT_MAPPING} type, you can get a {@link DocumentMapper} for_the default mapping.;public DocumentMapper documentMapper(String type) {_        if (mapper != null && type.equals(mapper.type())) {_            return mapper__        }_        if (DEFAULT_MAPPING.equals(type)) {_            return defaultMapper__        }_        return null__    };return,the,link,document,mapper,for,the,given,type,by,using,the,special,value,type,you,can,get,a,link,document,mapper,for,the,default,mapping;public,document,mapper,document,mapper,string,type,if,mapper,null,type,equals,mapper,type,return,mapper,if,equals,type,return,default,mapper,return,null
MapperService -> public DocumentMapper documentMapper(String type);1541008027;Return the {@link DocumentMapper} for the given type. By using the special_{@value #DEFAULT_MAPPING} type, you can get a {@link DocumentMapper} for_the default mapping.;public DocumentMapper documentMapper(String type) {_        if (mapper != null && type.equals(mapper.type())) {_            return mapper__        }_        if (DEFAULT_MAPPING.equals(type)) {_            return defaultMapper__        }_        return null__    };return,the,link,document,mapper,for,the,given,type,by,using,the,special,value,type,you,can,get,a,link,document,mapper,for,the,default,mapping;public,document,mapper,document,mapper,string,type,if,mapper,null,type,equals,mapper,type,return,mapper,if,equals,type,return,default,mapper,return,null
MapperService -> public DocumentMapper documentMapper(String type);1541592065;Return the {@link DocumentMapper} for the given type. By using the special_{@value #DEFAULT_MAPPING} type, you can get a {@link DocumentMapper} for_the default mapping.;public DocumentMapper documentMapper(String type) {_        if (mapper != null && type.equals(mapper.type())) {_            return mapper__        }_        if (DEFAULT_MAPPING.equals(type)) {_            return defaultMapper__        }_        return null__    };return,the,link,document,mapper,for,the,given,type,by,using,the,special,value,type,you,can,get,a,link,document,mapper,for,the,default,mapping;public,document,mapper,document,mapper,string,type,if,mapper,null,type,equals,mapper,type,return,mapper,if,equals,type,return,default,mapper,return,null
MapperService -> public DocumentMapper documentMapper(String type);1542899326;Return the {@link DocumentMapper} for the given type. By using the special_{@value #DEFAULT_MAPPING} type, you can get a {@link DocumentMapper} for_the default mapping.;public DocumentMapper documentMapper(String type) {_        if (mapper != null && type.equals(mapper.type())) {_            return mapper__        }_        if (DEFAULT_MAPPING.equals(type)) {_            return defaultMapper__        }_        return null__    };return,the,link,document,mapper,for,the,given,type,by,using,the,special,value,type,you,can,get,a,link,document,mapper,for,the,default,mapping;public,document,mapper,document,mapper,string,type,if,mapper,null,type,equals,mapper,type,return,mapper,if,equals,type,return,default,mapper,return,null
MapperService -> public DocumentMapper documentMapper(String type);1543947737;Return the {@link DocumentMapper} for the given type. By using the special_{@value #DEFAULT_MAPPING} type, you can get a {@link DocumentMapper} for_the default mapping.;public DocumentMapper documentMapper(String type) {_        if (mapper != null && type.equals(mapper.type())) {_            return mapper__        }_        if (DEFAULT_MAPPING.equals(type)) {_            return defaultMapper__        }_        return null__    };return,the,link,document,mapper,for,the,given,type,by,using,the,special,value,type,you,can,get,a,link,document,mapper,for,the,default,mapping;public,document,mapper,document,mapper,string,type,if,mapper,null,type,equals,mapper,type,return,mapper,if,equals,type,return,default,mapper,return,null
MapperService -> public DocumentMapper documentMapper(String type);1545126194;Return the {@link DocumentMapper} for the given type. By using the special_{@value #DEFAULT_MAPPING} type, you can get a {@link DocumentMapper} for_the default mapping.;public DocumentMapper documentMapper(String type) {_        if (mapper != null && type.equals(mapper.type())) {_            return mapper__        }_        if (DEFAULT_MAPPING.equals(type)) {_            return defaultMapper__        }_        return null__    };return,the,link,document,mapper,for,the,given,type,by,using,the,special,value,type,you,can,get,a,link,document,mapper,for,the,default,mapping;public,document,mapper,document,mapper,string,type,if,mapper,null,type,equals,mapper,type,return,mapper,if,equals,type,return,default,mapper,return,null
MapperService -> public DocumentMapper documentMapper(String type);1547566367;Return the {@link DocumentMapper} for the given type. By using the special_{@value #DEFAULT_MAPPING} type, you can get a {@link DocumentMapper} for_the default mapping.;public DocumentMapper documentMapper(String type) {_        if (mapper != null && type.equals(mapper.type())) {_            return mapper__        }_        if (DEFAULT_MAPPING.equals(type)) {_            return defaultMapper__        }_        return null__    };return,the,link,document,mapper,for,the,given,type,by,using,the,special,value,type,you,can,get,a,link,document,mapper,for,the,default,mapping;public,document,mapper,document,mapper,string,type,if,mapper,null,type,equals,mapper,type,return,mapper,if,equals,type,return,default,mapper,return,null
MapperService -> public DocumentMapper documentMapper(String type);1549392752;Return the {@link DocumentMapper} for the given type. By using the special_{@value #DEFAULT_MAPPING} type, you can get a {@link DocumentMapper} for_the default mapping.;public DocumentMapper documentMapper(String type) {_        if (mapper != null && type.equals(mapper.type())) {_            return mapper__        }_        if (DEFAULT_MAPPING.equals(type)) {_            return defaultMapper__        }_        return null__    };return,the,link,document,mapper,for,the,given,type,by,using,the,special,value,type,you,can,get,a,link,document,mapper,for,the,default,mapping;public,document,mapper,document,mapper,string,type,if,mapper,null,type,equals,mapper,type,return,mapper,if,equals,type,return,default,mapper,return,null
MapperService -> public DocumentMapper documentMapper();1524684173;Return the document mapper, or {@code null} if no mapping has been put yet.;public DocumentMapper documentMapper() {_        return mapper__    };return,the,document,mapper,or,code,null,if,no,mapping,has,been,put,yet;public,document,mapper,document,mapper,return,mapper
MapperService -> public DocumentMapper documentMapper();1525334055;Return the document mapper, or {@code null} if no mapping has been put yet.;public DocumentMapper documentMapper() {_        return mapper__    };return,the,document,mapper,or,code,null,if,no,mapping,has,been,put,yet;public,document,mapper,document,mapper,return,mapper
MapperService -> public DocumentMapper documentMapper();1528706846;Return the document mapper, or {@code null} if no mapping has been put yet.;public DocumentMapper documentMapper() {_        return mapper__    };return,the,document,mapper,or,code,null,if,no,mapping,has,been,put,yet;public,document,mapper,document,mapper,return,mapper
MapperService -> public DocumentMapper documentMapper();1531937412;Return the document mapper, or {@code null} if no mapping has been put yet.;public DocumentMapper documentMapper() {_        return mapper__    };return,the,document,mapper,or,code,null,if,no,mapping,has,been,put,yet;public,document,mapper,document,mapper,return,mapper
MapperService -> public DocumentMapper documentMapper();1532353780;Return the document mapper, or {@code null} if no mapping has been put yet.;public DocumentMapper documentMapper() {_        return mapper__    };return,the,document,mapper,or,code,null,if,no,mapping,has,been,put,yet;public,document,mapper,document,mapper,return,mapper
MapperService -> public DocumentMapper documentMapper();1534539448;Return the document mapper, or {@code null} if no mapping has been put yet.;public DocumentMapper documentMapper() {_        return mapper__    };return,the,document,mapper,or,code,null,if,no,mapping,has,been,put,yet;public,document,mapper,document,mapper,return,mapper
MapperService -> public DocumentMapper documentMapper();1535383145;Return the document mapper, or {@code null} if no mapping has been put yet.;public DocumentMapper documentMapper() {_        return mapper__    };return,the,document,mapper,or,code,null,if,no,mapping,has,been,put,yet;public,document,mapper,document,mapper,return,mapper
MapperService -> public DocumentMapper documentMapper();1535405719;Return the document mapper, or {@code null} if no mapping has been put yet.;public DocumentMapper documentMapper() {_        return mapper__    };return,the,document,mapper,or,code,null,if,no,mapping,has,been,put,yet;public,document,mapper,document,mapper,return,mapper
MapperService -> public DocumentMapper documentMapper();1536177418;Return the document mapper, or {@code null} if no mapping has been put yet.;public DocumentMapper documentMapper() {_        return mapper__    };return,the,document,mapper,or,code,null,if,no,mapping,has,been,put,yet;public,document,mapper,document,mapper,return,mapper
MapperService -> public DocumentMapper documentMapper();1540486836;Return the document mapper, or {@code null} if no mapping has been put yet.;public DocumentMapper documentMapper() {_        return mapper__    };return,the,document,mapper,or,code,null,if,no,mapping,has,been,put,yet;public,document,mapper,document,mapper,return,mapper
MapperService -> public DocumentMapper documentMapper();1540583181;Return the document mapper, or {@code null} if no mapping has been put yet.;public DocumentMapper documentMapper() {_        return mapper__    };return,the,document,mapper,or,code,null,if,no,mapping,has,been,put,yet;public,document,mapper,document,mapper,return,mapper
MapperService -> public DocumentMapper documentMapper();1541008027;Return the document mapper, or {@code null} if no mapping has been put yet.;public DocumentMapper documentMapper() {_        return mapper__    };return,the,document,mapper,or,code,null,if,no,mapping,has,been,put,yet;public,document,mapper,document,mapper,return,mapper
MapperService -> public DocumentMapper documentMapper();1541592065;Return the document mapper, or {@code null} if no mapping has been put yet.;public DocumentMapper documentMapper() {_        return mapper__    };return,the,document,mapper,or,code,null,if,no,mapping,has,been,put,yet;public,document,mapper,document,mapper,return,mapper
MapperService -> public DocumentMapper documentMapper();1542899326;Return the document mapper, or {@code null} if no mapping has been put yet.;public DocumentMapper documentMapper() {_        return mapper__    };return,the,document,mapper,or,code,null,if,no,mapping,has,been,put,yet;public,document,mapper,document,mapper,return,mapper
MapperService -> public DocumentMapper documentMapper();1543947737;Return the document mapper, or {@code null} if no mapping has been put yet.;public DocumentMapper documentMapper() {_        return mapper__    };return,the,document,mapper,or,code,null,if,no,mapping,has,been,put,yet;public,document,mapper,document,mapper,return,mapper
MapperService -> public DocumentMapper documentMapper();1545126194;Return the document mapper, or {@code null} if no mapping has been put yet.;public DocumentMapper documentMapper() {_        return mapper__    };return,the,document,mapper,or,code,null,if,no,mapping,has,been,put,yet;public,document,mapper,document,mapper,return,mapper
MapperService -> public DocumentMapper documentMapper();1547566367;Return the document mapper, or {@code null} if no mapping has been put yet.;public DocumentMapper documentMapper() {_        return mapper__    };return,the,document,mapper,or,code,null,if,no,mapping,has,been,put,yet;public,document,mapper,document,mapper,return,mapper
MapperService -> public DocumentMapper documentMapper();1549392752;Return the document mapper, or {@code null} if no mapping has been put yet.;public DocumentMapper documentMapper() {_        return mapper__    };return,the,document,mapper,or,code,null,if,no,mapping,has,been,put,yet;public,document,mapper,document,mapper,return,mapper
MapperService -> public Term createUidTerm(String type, String id);1524684173;Return a term that uniquely identifies the document, or {@code null} if the type is not allowed.;public Term createUidTerm(String type, String id) {_        if (mapper == null || mapper.type().equals(type) == false) {_            return null__        }_        return new Term(IdFieldMapper.NAME, Uid.encodeId(id))__    };return,a,term,that,uniquely,identifies,the,document,or,code,null,if,the,type,is,not,allowed;public,term,create,uid,term,string,type,string,id,if,mapper,null,mapper,type,equals,type,false,return,null,return,new,term,id,field,mapper,name,uid,encode,id,id
MapperService -> public Term createUidTerm(String type, String id);1525334055;Return a term that uniquely identifies the document, or {@code null} if the type is not allowed.;public Term createUidTerm(String type, String id) {_        if (mapper == null || mapper.type().equals(type) == false) {_            return null__        }_        return new Term(IdFieldMapper.NAME, Uid.encodeId(id))__    };return,a,term,that,uniquely,identifies,the,document,or,code,null,if,the,type,is,not,allowed;public,term,create,uid,term,string,type,string,id,if,mapper,null,mapper,type,equals,type,false,return,null,return,new,term,id,field,mapper,name,uid,encode,id,id
MapperService -> public Term createUidTerm(String type, String id);1528706846;Return a term that uniquely identifies the document, or {@code null} if the type is not allowed.;public Term createUidTerm(String type, String id) {_        if (mapper == null || mapper.type().equals(type) == false) {_            return null__        }_        return new Term(IdFieldMapper.NAME, Uid.encodeId(id))__    };return,a,term,that,uniquely,identifies,the,document,or,code,null,if,the,type,is,not,allowed;public,term,create,uid,term,string,type,string,id,if,mapper,null,mapper,type,equals,type,false,return,null,return,new,term,id,field,mapper,name,uid,encode,id,id
MapperService -> public Term createUidTerm(String type, String id);1531937412;Return a term that uniquely identifies the document, or {@code null} if the type is not allowed.;public Term createUidTerm(String type, String id) {_        if (mapper == null || mapper.type().equals(type) == false) {_            return null__        }_        return new Term(IdFieldMapper.NAME, Uid.encodeId(id))__    };return,a,term,that,uniquely,identifies,the,document,or,code,null,if,the,type,is,not,allowed;public,term,create,uid,term,string,type,string,id,if,mapper,null,mapper,type,equals,type,false,return,null,return,new,term,id,field,mapper,name,uid,encode,id,id
MapperService -> public Term createUidTerm(String type, String id);1532353780;Return a term that uniquely identifies the document, or {@code null} if the type is not allowed.;public Term createUidTerm(String type, String id) {_        if (mapper == null || mapper.type().equals(type) == false) {_            return null__        }_        return new Term(IdFieldMapper.NAME, Uid.encodeId(id))__    };return,a,term,that,uniquely,identifies,the,document,or,code,null,if,the,type,is,not,allowed;public,term,create,uid,term,string,type,string,id,if,mapper,null,mapper,type,equals,type,false,return,null,return,new,term,id,field,mapper,name,uid,encode,id,id
MapperService -> public Term createUidTerm(String type, String id);1534539448;Return a term that uniquely identifies the document, or {@code null} if the type is not allowed.;public Term createUidTerm(String type, String id) {_        if (mapper == null || mapper.type().equals(type) == false) {_            return null__        }_        return new Term(IdFieldMapper.NAME, Uid.encodeId(id))__    };return,a,term,that,uniquely,identifies,the,document,or,code,null,if,the,type,is,not,allowed;public,term,create,uid,term,string,type,string,id,if,mapper,null,mapper,type,equals,type,false,return,null,return,new,term,id,field,mapper,name,uid,encode,id,id
MapperService -> public Term createUidTerm(String type, String id);1535383145;Return a term that uniquely identifies the document, or {@code null} if the type is not allowed.;public Term createUidTerm(String type, String id) {_        if (mapper == null || mapper.type().equals(type) == false) {_            return null__        }_        return new Term(IdFieldMapper.NAME, Uid.encodeId(id))__    };return,a,term,that,uniquely,identifies,the,document,or,code,null,if,the,type,is,not,allowed;public,term,create,uid,term,string,type,string,id,if,mapper,null,mapper,type,equals,type,false,return,null,return,new,term,id,field,mapper,name,uid,encode,id,id
MapperService -> public Term createUidTerm(String type, String id);1535405719;Return a term that uniquely identifies the document, or {@code null} if the type is not allowed.;public Term createUidTerm(String type, String id) {_        if (mapper == null || mapper.type().equals(type) == false) {_            return null__        }_        return new Term(IdFieldMapper.NAME, Uid.encodeId(id))__    };return,a,term,that,uniquely,identifies,the,document,or,code,null,if,the,type,is,not,allowed;public,term,create,uid,term,string,type,string,id,if,mapper,null,mapper,type,equals,type,false,return,null,return,new,term,id,field,mapper,name,uid,encode,id,id
MapperService -> public Term createUidTerm(String type, String id);1536177418;Return a term that uniquely identifies the document, or {@code null} if the type is not allowed.;public Term createUidTerm(String type, String id) {_        if (mapper == null || mapper.type().equals(type) == false) {_            return null__        }_        return new Term(IdFieldMapper.NAME, Uid.encodeId(id))__    };return,a,term,that,uniquely,identifies,the,document,or,code,null,if,the,type,is,not,allowed;public,term,create,uid,term,string,type,string,id,if,mapper,null,mapper,type,equals,type,false,return,null,return,new,term,id,field,mapper,name,uid,encode,id,id
MapperService -> public Term createUidTerm(String type, String id);1540486836;Return a term that uniquely identifies the document, or {@code null} if the type is not allowed.;public Term createUidTerm(String type, String id) {_        if (mapper == null || mapper.type().equals(type) == false) {_            return null__        }_        return new Term(IdFieldMapper.NAME, Uid.encodeId(id))__    };return,a,term,that,uniquely,identifies,the,document,or,code,null,if,the,type,is,not,allowed;public,term,create,uid,term,string,type,string,id,if,mapper,null,mapper,type,equals,type,false,return,null,return,new,term,id,field,mapper,name,uid,encode,id,id
MapperService -> public Term createUidTerm(String type, String id);1540583181;Return a term that uniquely identifies the document, or {@code null} if the type is not allowed.;public Term createUidTerm(String type, String id) {_        if (mapper == null || mapper.type().equals(type) == false) {_            return null__        }_        return new Term(IdFieldMapper.NAME, Uid.encodeId(id))__    };return,a,term,that,uniquely,identifies,the,document,or,code,null,if,the,type,is,not,allowed;public,term,create,uid,term,string,type,string,id,if,mapper,null,mapper,type,equals,type,false,return,null,return,new,term,id,field,mapper,name,uid,encode,id,id
MapperService -> public Term createUidTerm(String type, String id);1541008027;Return a term that uniquely identifies the document, or {@code null} if the type is not allowed.;public Term createUidTerm(String type, String id) {_        if (mapper == null || mapper.type().equals(type) == false) {_            return null__        }_        return new Term(IdFieldMapper.NAME, Uid.encodeId(id))__    };return,a,term,that,uniquely,identifies,the,document,or,code,null,if,the,type,is,not,allowed;public,term,create,uid,term,string,type,string,id,if,mapper,null,mapper,type,equals,type,false,return,null,return,new,term,id,field,mapper,name,uid,encode,id,id
MapperService -> public Term createUidTerm(String type, String id);1541592065;Return a term that uniquely identifies the document, or {@code null} if the type is not allowed.;public Term createUidTerm(String type, String id) {_        if (mapper == null || mapper.type().equals(type) == false) {_            return null__        }_        return new Term(IdFieldMapper.NAME, Uid.encodeId(id))__    };return,a,term,that,uniquely,identifies,the,document,or,code,null,if,the,type,is,not,allowed;public,term,create,uid,term,string,type,string,id,if,mapper,null,mapper,type,equals,type,false,return,null,return,new,term,id,field,mapper,name,uid,encode,id,id
MapperService -> public Term createUidTerm(String type, String id);1542899326;Return a term that uniquely identifies the document, or {@code null} if the type is not allowed.;public Term createUidTerm(String type, String id) {_        if (mapper == null || mapper.type().equals(type) == false) {_            return null__        }_        return new Term(IdFieldMapper.NAME, Uid.encodeId(id))__    };return,a,term,that,uniquely,identifies,the,document,or,code,null,if,the,type,is,not,allowed;public,term,create,uid,term,string,type,string,id,if,mapper,null,mapper,type,equals,type,false,return,null,return,new,term,id,field,mapper,name,uid,encode,id,id
MapperService -> public static boolean isMetadataField(String fieldName);1524684173;@return Whether a field is a metadata field.;public static boolean isMetadataField(String fieldName) {_        return META_FIELDS.contains(fieldName)__    };return,whether,a,field,is,a,metadata,field;public,static,boolean,is,metadata,field,string,field,name,return,contains,field,name
MapperService -> public static boolean isMetadataField(String fieldName);1525334055;@return Whether a field is a metadata field.;public static boolean isMetadataField(String fieldName) {_        return META_FIELDS.contains(fieldName)__    };return,whether,a,field,is,a,metadata,field;public,static,boolean,is,metadata,field,string,field,name,return,contains,field,name
MapperService -> public static boolean isMetadataField(String fieldName);1528706846;@return Whether a field is a metadata field.;public static boolean isMetadataField(String fieldName) {_        return META_FIELDS.contains(fieldName)__    };return,whether,a,field,is,a,metadata,field;public,static,boolean,is,metadata,field,string,field,name,return,contains,field,name
MapperService -> public static boolean isMetadataField(String fieldName);1531937412;@return Whether a field is a metadata field.;public static boolean isMetadataField(String fieldName) {_        return META_FIELDS.contains(fieldName)__    };return,whether,a,field,is,a,metadata,field;public,static,boolean,is,metadata,field,string,field,name,return,contains,field,name
MapperService -> public static boolean isMetadataField(String fieldName);1532353780;@return Whether a field is a metadata field.;public static boolean isMetadataField(String fieldName) {_        return META_FIELDS.contains(fieldName)__    };return,whether,a,field,is,a,metadata,field;public,static,boolean,is,metadata,field,string,field,name,return,contains,field,name
MapperService -> public static boolean isMetadataField(String fieldName);1534539448;@return Whether a field is a metadata field.;public static boolean isMetadataField(String fieldName) {_        return META_FIELDS.contains(fieldName)__    };return,whether,a,field,is,a,metadata,field;public,static,boolean,is,metadata,field,string,field,name,return,contains,field,name
MapperService -> public static boolean isMetadataField(String fieldName);1535383145;@return Whether a field is a metadata field.;public static boolean isMetadataField(String fieldName) {_        return META_FIELDS.contains(fieldName)__    };return,whether,a,field,is,a,metadata,field;public,static,boolean,is,metadata,field,string,field,name,return,contains,field,name
MapperService -> public static boolean isMetadataField(String fieldName);1535405719;@return Whether a field is a metadata field.;public static boolean isMetadataField(String fieldName) {_        return META_FIELDS.contains(fieldName)__    };return,whether,a,field,is,a,metadata,field;public,static,boolean,is,metadata,field,string,field,name,return,contains,field,name
MapperService -> public static boolean isMetadataField(String fieldName);1536177418;@return Whether a field is a metadata field.;public static boolean isMetadataField(String fieldName) {_        return META_FIELDS.contains(fieldName)__    };return,whether,a,field,is,a,metadata,field;public,static,boolean,is,metadata,field,string,field,name,return,contains,field,name
MapperService -> public static boolean isMetadataField(String fieldName);1540486836;@return Whether a field is a metadata field.;public static boolean isMetadataField(String fieldName) {_        return META_FIELDS.contains(fieldName)__    };return,whether,a,field,is,a,metadata,field;public,static,boolean,is,metadata,field,string,field,name,return,contains,field,name
MapperService -> public static boolean isMetadataField(String fieldName);1540583181;@return Whether a field is a metadata field.;public static boolean isMetadataField(String fieldName) {_        return META_FIELDS.contains(fieldName)__    };return,whether,a,field,is,a,metadata,field;public,static,boolean,is,metadata,field,string,field,name,return,contains,field,name
MapperService -> public static boolean isMetadataField(String fieldName);1541008027;@return Whether a field is a metadata field.;public static boolean isMetadataField(String fieldName) {_        return META_FIELDS.contains(fieldName)__    };return,whether,a,field,is,a,metadata,field;public,static,boolean,is,metadata,field,string,field,name,return,contains,field,name
MapperService -> public static boolean isMetadataField(String fieldName);1541592065;@return Whether a field is a metadata field.;public static boolean isMetadataField(String fieldName) {_        return META_FIELDS.contains(fieldName)__    };return,whether,a,field,is,a,metadata,field;public,static,boolean,is,metadata,field,string,field,name,return,contains,field,name
MapperService -> public static boolean isMetadataField(String fieldName);1542899326;@return Whether a field is a metadata field.;public static boolean isMetadataField(String fieldName) {_        return META_FIELDS.contains(fieldName)__    };return,whether,a,field,is,a,metadata,field;public,static,boolean,is,metadata,field,string,field,name,return,contains,field,name
MapperService -> public static boolean isMetadataField(String fieldName);1543947737;@return Whether a field is a metadata field.;public static boolean isMetadataField(String fieldName) {_        return META_FIELDS.contains(fieldName)__    };return,whether,a,field,is,a,metadata,field;public,static,boolean,is,metadata,field,string,field,name,return,contains,field,name
MapperService -> public static boolean isMetadataField(String fieldName);1545126194;@return Whether a field is a metadata field.;public static boolean isMetadataField(String fieldName) {_        return META_FIELDS.contains(fieldName)__    };return,whether,a,field,is,a,metadata,field;public,static,boolean,is,metadata,field,string,field,name,return,contains,field,name
MapperService -> public static boolean isMetadataField(String fieldName);1547566367;@return Whether a field is a metadata field.;public static boolean isMetadataField(String fieldName) {_        return META_FIELDS.contains(fieldName)__    };return,whether,a,field,is,a,metadata,field;public,static,boolean,is,metadata,field,string,field,name,return,contains,field,name
MapperService -> public static boolean isMetadataField(String fieldName);1549392752;@return Whether a field is a metadata field.;public static boolean isMetadataField(String fieldName) {_        return META_FIELDS.contains(fieldName)__    };return,whether,a,field,is,a,metadata,field;public,static,boolean,is,metadata,field,string,field,name,return,contains,field,name
MapperService -> public static Map<String, Object> parseMapping(NamedXContentRegistry xContentRegistry, String mappingSource) throws Exception;1524684173;Parses the mappings (formatted as JSON) into a map;public static Map<String, Object> parseMapping(NamedXContentRegistry xContentRegistry, String mappingSource) throws Exception {_        try (XContentParser parser = XContentType.JSON.xContent()_                .createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, mappingSource)) {_            return parser.map()__        }_    };parses,the,mappings,formatted,as,json,into,a,map;public,static,map,string,object,parse,mapping,named,xcontent,registry,x,content,registry,string,mapping,source,throws,exception,try,xcontent,parser,parser,xcontent,type,json,x,content,create,parser,x,content,registry,logging,deprecation,handler,instance,mapping,source,return,parser,map
MapperService -> public static Map<String, Object> parseMapping(NamedXContentRegistry xContentRegistry, String mappingSource) throws Exception;1525334055;Parses the mappings (formatted as JSON) into a map;public static Map<String, Object> parseMapping(NamedXContentRegistry xContentRegistry, String mappingSource) throws Exception {_        try (XContentParser parser = XContentType.JSON.xContent()_                .createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, mappingSource)) {_            return parser.map()__        }_    };parses,the,mappings,formatted,as,json,into,a,map;public,static,map,string,object,parse,mapping,named,xcontent,registry,x,content,registry,string,mapping,source,throws,exception,try,xcontent,parser,parser,xcontent,type,json,x,content,create,parser,x,content,registry,logging,deprecation,handler,instance,mapping,source,return,parser,map
MapperService -> public static Map<String, Object> parseMapping(NamedXContentRegistry xContentRegistry, String mappingSource) throws Exception;1528706846;Parses the mappings (formatted as JSON) into a map;public static Map<String, Object> parseMapping(NamedXContentRegistry xContentRegistry, String mappingSource) throws Exception {_        try (XContentParser parser = XContentType.JSON.xContent()_                .createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, mappingSource)) {_            return parser.map()__        }_    };parses,the,mappings,formatted,as,json,into,a,map;public,static,map,string,object,parse,mapping,named,xcontent,registry,x,content,registry,string,mapping,source,throws,exception,try,xcontent,parser,parser,xcontent,type,json,x,content,create,parser,x,content,registry,logging,deprecation,handler,instance,mapping,source,return,parser,map
MapperService -> public static Map<String, Object> parseMapping(NamedXContentRegistry xContentRegistry, String mappingSource) throws Exception;1531937412;Parses the mappings (formatted as JSON) into a map;public static Map<String, Object> parseMapping(NamedXContentRegistry xContentRegistry, String mappingSource) throws Exception {_        try (XContentParser parser = XContentType.JSON.xContent()_                .createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, mappingSource)) {_            return parser.map()__        }_    };parses,the,mappings,formatted,as,json,into,a,map;public,static,map,string,object,parse,mapping,named,xcontent,registry,x,content,registry,string,mapping,source,throws,exception,try,xcontent,parser,parser,xcontent,type,json,x,content,create,parser,x,content,registry,logging,deprecation,handler,instance,mapping,source,return,parser,map
MapperService -> public static Map<String, Object> parseMapping(NamedXContentRegistry xContentRegistry, String mappingSource) throws Exception;1532353780;Parses the mappings (formatted as JSON) into a map;public static Map<String, Object> parseMapping(NamedXContentRegistry xContentRegistry, String mappingSource) throws Exception {_        try (XContentParser parser = XContentType.JSON.xContent()_                .createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, mappingSource)) {_            return parser.map()__        }_    };parses,the,mappings,formatted,as,json,into,a,map;public,static,map,string,object,parse,mapping,named,xcontent,registry,x,content,registry,string,mapping,source,throws,exception,try,xcontent,parser,parser,xcontent,type,json,x,content,create,parser,x,content,registry,logging,deprecation,handler,instance,mapping,source,return,parser,map
MapperService -> public static Map<String, Object> parseMapping(NamedXContentRegistry xContentRegistry, String mappingSource) throws Exception;1534539448;Parses the mappings (formatted as JSON) into a map;public static Map<String, Object> parseMapping(NamedXContentRegistry xContentRegistry, String mappingSource) throws Exception {_        try (XContentParser parser = XContentType.JSON.xContent()_                .createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, mappingSource)) {_            return parser.map()__        }_    };parses,the,mappings,formatted,as,json,into,a,map;public,static,map,string,object,parse,mapping,named,xcontent,registry,x,content,registry,string,mapping,source,throws,exception,try,xcontent,parser,parser,xcontent,type,json,x,content,create,parser,x,content,registry,logging,deprecation,handler,instance,mapping,source,return,parser,map
MapperService -> public static Map<String, Object> parseMapping(NamedXContentRegistry xContentRegistry, String mappingSource) throws Exception;1535383145;Parses the mappings (formatted as JSON) into a map;public static Map<String, Object> parseMapping(NamedXContentRegistry xContentRegistry, String mappingSource) throws Exception {_        try (XContentParser parser = XContentType.JSON.xContent()_                .createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, mappingSource)) {_            return parser.map()__        }_    };parses,the,mappings,formatted,as,json,into,a,map;public,static,map,string,object,parse,mapping,named,xcontent,registry,x,content,registry,string,mapping,source,throws,exception,try,xcontent,parser,parser,xcontent,type,json,x,content,create,parser,x,content,registry,logging,deprecation,handler,instance,mapping,source,return,parser,map
MapperService -> public static Map<String, Object> parseMapping(NamedXContentRegistry xContentRegistry, String mappingSource) throws Exception;1535405719;Parses the mappings (formatted as JSON) into a map;public static Map<String, Object> parseMapping(NamedXContentRegistry xContentRegistry, String mappingSource) throws Exception {_        try (XContentParser parser = XContentType.JSON.xContent()_                .createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, mappingSource)) {_            return parser.map()__        }_    };parses,the,mappings,formatted,as,json,into,a,map;public,static,map,string,object,parse,mapping,named,xcontent,registry,x,content,registry,string,mapping,source,throws,exception,try,xcontent,parser,parser,xcontent,type,json,x,content,create,parser,x,content,registry,logging,deprecation,handler,instance,mapping,source,return,parser,map
MapperService -> public static Map<String, Object> parseMapping(NamedXContentRegistry xContentRegistry, String mappingSource) throws Exception;1536177418;Parses the mappings (formatted as JSON) into a map;public static Map<String, Object> parseMapping(NamedXContentRegistry xContentRegistry, String mappingSource) throws Exception {_        try (XContentParser parser = XContentType.JSON.xContent()_                .createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, mappingSource)) {_            return parser.map()__        }_    };parses,the,mappings,formatted,as,json,into,a,map;public,static,map,string,object,parse,mapping,named,xcontent,registry,x,content,registry,string,mapping,source,throws,exception,try,xcontent,parser,parser,xcontent,type,json,x,content,create,parser,x,content,registry,logging,deprecation,handler,instance,mapping,source,return,parser,map
MapperService -> public static Map<String, Object> parseMapping(NamedXContentRegistry xContentRegistry, String mappingSource) throws Exception;1540486836;Parses the mappings (formatted as JSON) into a map;public static Map<String, Object> parseMapping(NamedXContentRegistry xContentRegistry, String mappingSource) throws Exception {_        try (XContentParser parser = XContentType.JSON.xContent()_                .createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, mappingSource)) {_            return parser.map()__        }_    };parses,the,mappings,formatted,as,json,into,a,map;public,static,map,string,object,parse,mapping,named,xcontent,registry,x,content,registry,string,mapping,source,throws,exception,try,xcontent,parser,parser,xcontent,type,json,x,content,create,parser,x,content,registry,logging,deprecation,handler,instance,mapping,source,return,parser,map
MapperService -> public static Map<String, Object> parseMapping(NamedXContentRegistry xContentRegistry, String mappingSource) throws Exception;1540583181;Parses the mappings (formatted as JSON) into a map;public static Map<String, Object> parseMapping(NamedXContentRegistry xContentRegistry, String mappingSource) throws Exception {_        try (XContentParser parser = XContentType.JSON.xContent()_                .createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, mappingSource)) {_            return parser.map()__        }_    };parses,the,mappings,formatted,as,json,into,a,map;public,static,map,string,object,parse,mapping,named,xcontent,registry,x,content,registry,string,mapping,source,throws,exception,try,xcontent,parser,parser,xcontent,type,json,x,content,create,parser,x,content,registry,logging,deprecation,handler,instance,mapping,source,return,parser,map
MapperService -> public static Map<String, Object> parseMapping(NamedXContentRegistry xContentRegistry, String mappingSource) throws Exception;1541008027;Parses the mappings (formatted as JSON) into a map;public static Map<String, Object> parseMapping(NamedXContentRegistry xContentRegistry, String mappingSource) throws Exception {_        try (XContentParser parser = XContentType.JSON.xContent()_                .createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, mappingSource)) {_            return parser.map()__        }_    };parses,the,mappings,formatted,as,json,into,a,map;public,static,map,string,object,parse,mapping,named,xcontent,registry,x,content,registry,string,mapping,source,throws,exception,try,xcontent,parser,parser,xcontent,type,json,x,content,create,parser,x,content,registry,logging,deprecation,handler,instance,mapping,source,return,parser,map
MapperService -> public static Map<String, Object> parseMapping(NamedXContentRegistry xContentRegistry, String mappingSource) throws Exception;1541592065;Parses the mappings (formatted as JSON) into a map;public static Map<String, Object> parseMapping(NamedXContentRegistry xContentRegistry, String mappingSource) throws Exception {_        try (XContentParser parser = XContentType.JSON.xContent()_                .createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, mappingSource)) {_            return parser.map()__        }_    };parses,the,mappings,formatted,as,json,into,a,map;public,static,map,string,object,parse,mapping,named,xcontent,registry,x,content,registry,string,mapping,source,throws,exception,try,xcontent,parser,parser,xcontent,type,json,x,content,create,parser,x,content,registry,logging,deprecation,handler,instance,mapping,source,return,parser,map
MapperService -> public static Map<String, Object> parseMapping(NamedXContentRegistry xContentRegistry, String mappingSource) throws Exception;1542899326;Parses the mappings (formatted as JSON) into a map;public static Map<String, Object> parseMapping(NamedXContentRegistry xContentRegistry, String mappingSource) throws Exception {_        try (XContentParser parser = XContentType.JSON.xContent()_                .createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, mappingSource)) {_            return parser.map()__        }_    };parses,the,mappings,formatted,as,json,into,a,map;public,static,map,string,object,parse,mapping,named,xcontent,registry,x,content,registry,string,mapping,source,throws,exception,try,xcontent,parser,parser,xcontent,type,json,x,content,create,parser,x,content,registry,logging,deprecation,handler,instance,mapping,source,return,parser,map
MapperService -> public static Map<String, Object> parseMapping(NamedXContentRegistry xContentRegistry, String mappingSource) throws Exception;1543947737;Parses the mappings (formatted as JSON) into a map;public static Map<String, Object> parseMapping(NamedXContentRegistry xContentRegistry, String mappingSource) throws Exception {_        try (XContentParser parser = XContentType.JSON.xContent()_                .createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, mappingSource)) {_            return parser.map()__        }_    };parses,the,mappings,formatted,as,json,into,a,map;public,static,map,string,object,parse,mapping,named,xcontent,registry,x,content,registry,string,mapping,source,throws,exception,try,xcontent,parser,parser,xcontent,type,json,x,content,create,parser,x,content,registry,logging,deprecation,handler,instance,mapping,source,return,parser,map
MapperService -> public static Map<String, Object> parseMapping(NamedXContentRegistry xContentRegistry, String mappingSource) throws Exception;1545126194;Parses the mappings (formatted as JSON) into a map;public static Map<String, Object> parseMapping(NamedXContentRegistry xContentRegistry, String mappingSource) throws Exception {_        try (XContentParser parser = XContentType.JSON.xContent()_                .createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, mappingSource)) {_            return parser.map()__        }_    };parses,the,mappings,formatted,as,json,into,a,map;public,static,map,string,object,parse,mapping,named,xcontent,registry,x,content,registry,string,mapping,source,throws,exception,try,xcontent,parser,parser,xcontent,type,json,x,content,create,parser,x,content,registry,logging,deprecation,handler,instance,mapping,source,return,parser,map
MapperService -> public static Map<String, Object> parseMapping(NamedXContentRegistry xContentRegistry, String mappingSource) throws Exception;1547566367;Parses the mappings (formatted as JSON) into a map;public static Map<String, Object> parseMapping(NamedXContentRegistry xContentRegistry, String mappingSource) throws Exception {_        try (XContentParser parser = XContentType.JSON.xContent()_                .createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, mappingSource)) {_            return parser.map()__        }_    };parses,the,mappings,formatted,as,json,into,a,map;public,static,map,string,object,parse,mapping,named,xcontent,registry,x,content,registry,string,mapping,source,throws,exception,try,xcontent,parser,parser,xcontent,type,json,x,content,create,parser,x,content,registry,logging,deprecation,handler,instance,mapping,source,return,parser,map
MapperService -> public static Map<String, Object> parseMapping(NamedXContentRegistry xContentRegistry, String mappingSource) throws Exception;1549392752;Parses the mappings (formatted as JSON) into a map;public static Map<String, Object> parseMapping(NamedXContentRegistry xContentRegistry, String mappingSource) throws Exception {_        try (XContentParser parser = XContentType.JSON.xContent()_                .createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, mappingSource)) {_            return parser.map()__        }_    };parses,the,mappings,formatted,as,json,into,a,map;public,static,map,string,object,parse,mapping,named,xcontent,registry,x,content,registry,string,mapping,source,throws,exception,try,xcontent,parser,parser,xcontent,type,json,x,content,create,parser,x,content,registry,logging,deprecation,handler,instance,mapping,source,return,parser,map
MapperService -> public boolean updateMapping(final IndexMetaData currentIndexMetaData, final IndexMetaData newIndexMetaData) throws IOException;1535405719;Update mapping by only merging the metadata that is different between received and stored entries;public boolean updateMapping(final IndexMetaData currentIndexMetaData, final IndexMetaData newIndexMetaData) throws IOException {_        assert newIndexMetaData.getIndex().equals(index()) : "index mismatch: expected " + index() + " but was " + newIndexMetaData.getIndex()__        _        Set<String> existingMappers = new HashSet<>()__        if (mapper != null) {_            existingMappers.add(mapper.type())__        }_        if (defaultMapper != null) {_            existingMappers.add(DEFAULT_MAPPING)__        }_        final Map<String, DocumentMapper> updatedEntries__        try {_            _            updatedEntries = internalMerge(newIndexMetaData, MergeReason.MAPPING_RECOVERY, true)__        } catch (Exception e) {_            logger.warn(() -> new ParameterizedMessage("[{}] failed to apply mappings", index()), e)__            throw e__        }__        boolean requireRefresh = false___        assertMappingVersion(currentIndexMetaData, newIndexMetaData, updatedEntries)___        for (DocumentMapper documentMapper : updatedEntries.values()) {_            String mappingType = documentMapper.type()__            CompressedXContent incomingMappingSource = newIndexMetaData.mapping(mappingType).source()___            String op = existingMappers.contains(mappingType) ? "updated" : "added"__            if (logger.isDebugEnabled() && incomingMappingSource.compressed().length < 512) {_                logger.debug("[{}] {} mapping [{}], source [{}]", index(), op, mappingType, incomingMappingSource.string())__            } else if (logger.isTraceEnabled()) {_                logger.trace("[{}] {} mapping [{}], source [{}]", index(), op, mappingType, incomingMappingSource.string())__            } else {_                logger.debug("[{}] {} mapping [{}] (source suppressed due to length, use TRACE level if needed)", index(), op, mappingType)__            }__            _            _            _            if (documentMapper(mappingType).mappingSource().equals(incomingMappingSource) == false) {_                logger.debug("[{}] parsed mapping [{}], and got different sources\noriginal:\n{}\nparsed:\n{}", index(), mappingType,_                    incomingMappingSource, documentMapper(mappingType).mappingSource())___                requireRefresh = true__            }_        }__        return requireRefresh__    };update,mapping,by,only,merging,the,metadata,that,is,different,between,received,and,stored,entries;public,boolean,update,mapping,final,index,meta,data,current,index,meta,data,final,index,meta,data,new,index,meta,data,throws,ioexception,assert,new,index,meta,data,get,index,equals,index,index,mismatch,expected,index,but,was,new,index,meta,data,get,index,set,string,existing,mappers,new,hash,set,if,mapper,null,existing,mappers,add,mapper,type,if,default,mapper,null,existing,mappers,add,final,map,string,document,mapper,updated,entries,try,updated,entries,internal,merge,new,index,meta,data,merge,reason,true,catch,exception,e,logger,warn,new,parameterized,message,failed,to,apply,mappings,index,e,throw,e,boolean,require,refresh,false,assert,mapping,version,current,index,meta,data,new,index,meta,data,updated,entries,for,document,mapper,document,mapper,updated,entries,values,string,mapping,type,document,mapper,type,compressed,xcontent,incoming,mapping,source,new,index,meta,data,mapping,mapping,type,source,string,op,existing,mappers,contains,mapping,type,updated,added,if,logger,is,debug,enabled,incoming,mapping,source,compressed,length,512,logger,debug,mapping,source,index,op,mapping,type,incoming,mapping,source,string,else,if,logger,is,trace,enabled,logger,trace,mapping,source,index,op,mapping,type,incoming,mapping,source,string,else,logger,debug,mapping,source,suppressed,due,to,length,use,trace,level,if,needed,index,op,mapping,type,if,document,mapper,mapping,type,mapping,source,equals,incoming,mapping,source,false,logger,debug,parsed,mapping,and,got,different,sources,noriginal,n,nparsed,n,index,mapping,type,incoming,mapping,source,document,mapper,mapping,type,mapping,source,require,refresh,true,return,require,refresh
MapperService -> public boolean updateMapping(final IndexMetaData currentIndexMetaData, final IndexMetaData newIndexMetaData) throws IOException;1536177418;Update mapping by only merging the metadata that is different between received and stored entries;public boolean updateMapping(final IndexMetaData currentIndexMetaData, final IndexMetaData newIndexMetaData) throws IOException {_        assert newIndexMetaData.getIndex().equals(index()) : "index mismatch: expected " + index() + " but was " + newIndexMetaData.getIndex()__        _        Set<String> existingMappers = new HashSet<>()__        if (mapper != null) {_            existingMappers.add(mapper.type())__        }_        if (defaultMapper != null) {_            existingMappers.add(DEFAULT_MAPPING)__        }_        final Map<String, DocumentMapper> updatedEntries__        try {_            _            updatedEntries = internalMerge(newIndexMetaData, MergeReason.MAPPING_RECOVERY, true)__        } catch (Exception e) {_            logger.warn(() -> new ParameterizedMessage("[{}] failed to apply mappings", index()), e)__            throw e__        }__        boolean requireRefresh = false___        assertMappingVersion(currentIndexMetaData, newIndexMetaData, updatedEntries)___        for (DocumentMapper documentMapper : updatedEntries.values()) {_            String mappingType = documentMapper.type()__            CompressedXContent incomingMappingSource = newIndexMetaData.mapping(mappingType).source()___            String op = existingMappers.contains(mappingType) ? "updated" : "added"__            if (logger.isDebugEnabled() && incomingMappingSource.compressed().length < 512) {_                logger.debug("[{}] {} mapping [{}], source [{}]", index(), op, mappingType, incomingMappingSource.string())__            } else if (logger.isTraceEnabled()) {_                logger.trace("[{}] {} mapping [{}], source [{}]", index(), op, mappingType, incomingMappingSource.string())__            } else {_                logger.debug("[{}] {} mapping [{}] (source suppressed due to length, use TRACE level if needed)", index(), op, mappingType)__            }__            _            _            _            if (documentMapper(mappingType).mappingSource().equals(incomingMappingSource) == false) {_                logger.debug("[{}] parsed mapping [{}], and got different sources\noriginal:\n{}\nparsed:\n{}", index(), mappingType,_                    incomingMappingSource, documentMapper(mappingType).mappingSource())___                requireRefresh = true__            }_        }__        return requireRefresh__    };update,mapping,by,only,merging,the,metadata,that,is,different,between,received,and,stored,entries;public,boolean,update,mapping,final,index,meta,data,current,index,meta,data,final,index,meta,data,new,index,meta,data,throws,ioexception,assert,new,index,meta,data,get,index,equals,index,index,mismatch,expected,index,but,was,new,index,meta,data,get,index,set,string,existing,mappers,new,hash,set,if,mapper,null,existing,mappers,add,mapper,type,if,default,mapper,null,existing,mappers,add,final,map,string,document,mapper,updated,entries,try,updated,entries,internal,merge,new,index,meta,data,merge,reason,true,catch,exception,e,logger,warn,new,parameterized,message,failed,to,apply,mappings,index,e,throw,e,boolean,require,refresh,false,assert,mapping,version,current,index,meta,data,new,index,meta,data,updated,entries,for,document,mapper,document,mapper,updated,entries,values,string,mapping,type,document,mapper,type,compressed,xcontent,incoming,mapping,source,new,index,meta,data,mapping,mapping,type,source,string,op,existing,mappers,contains,mapping,type,updated,added,if,logger,is,debug,enabled,incoming,mapping,source,compressed,length,512,logger,debug,mapping,source,index,op,mapping,type,incoming,mapping,source,string,else,if,logger,is,trace,enabled,logger,trace,mapping,source,index,op,mapping,type,incoming,mapping,source,string,else,logger,debug,mapping,source,suppressed,due,to,length,use,trace,level,if,needed,index,op,mapping,type,if,document,mapper,mapping,type,mapping,source,equals,incoming,mapping,source,false,logger,debug,parsed,mapping,and,got,different,sources,noriginal,n,nparsed,n,index,mapping,type,incoming,mapping,source,document,mapper,mapping,type,mapping,source,require,refresh,true,return,require,refresh
MapperService -> public boolean updateMapping(final IndexMetaData currentIndexMetaData, final IndexMetaData newIndexMetaData) throws IOException;1540486836;Update mapping by only merging the metadata that is different between received and stored entries;public boolean updateMapping(final IndexMetaData currentIndexMetaData, final IndexMetaData newIndexMetaData) throws IOException {_        assert newIndexMetaData.getIndex().equals(index()) : "index mismatch: expected " + index() + " but was " + newIndexMetaData.getIndex()__        _        Set<String> existingMappers = new HashSet<>()__        if (mapper != null) {_            existingMappers.add(mapper.type())__        }_        if (defaultMapper != null) {_            existingMappers.add(DEFAULT_MAPPING)__        }_        final Map<String, DocumentMapper> updatedEntries__        try {_            _            updatedEntries = internalMerge(newIndexMetaData, MergeReason.MAPPING_RECOVERY, true)__        } catch (Exception e) {_            logger.warn(() -> new ParameterizedMessage("[{}] failed to apply mappings", index()), e)__            throw e__        }__        boolean requireRefresh = false___        assertMappingVersion(currentIndexMetaData, newIndexMetaData, updatedEntries)___        for (DocumentMapper documentMapper : updatedEntries.values()) {_            String mappingType = documentMapper.type()__            CompressedXContent incomingMappingSource = newIndexMetaData.mapping(mappingType).source()___            String op = existingMappers.contains(mappingType) ? "updated" : "added"__            if (logger.isDebugEnabled() && incomingMappingSource.compressed().length < 512) {_                logger.debug("[{}] {} mapping [{}], source [{}]", index(), op, mappingType, incomingMappingSource.string())__            } else if (logger.isTraceEnabled()) {_                logger.trace("[{}] {} mapping [{}], source [{}]", index(), op, mappingType, incomingMappingSource.string())__            } else {_                logger.debug("[{}] {} mapping [{}] (source suppressed due to length, use TRACE level if needed)", index(), op, mappingType)__            }__            _            _            _            if (documentMapper(mappingType).mappingSource().equals(incomingMappingSource) == false) {_                logger.debug("[{}] parsed mapping [{}], and got different sources\noriginal:\n{}\nparsed:\n{}", index(), mappingType,_                    incomingMappingSource, documentMapper(mappingType).mappingSource())___                requireRefresh = true__            }_        }__        return requireRefresh__    };update,mapping,by,only,merging,the,metadata,that,is,different,between,received,and,stored,entries;public,boolean,update,mapping,final,index,meta,data,current,index,meta,data,final,index,meta,data,new,index,meta,data,throws,ioexception,assert,new,index,meta,data,get,index,equals,index,index,mismatch,expected,index,but,was,new,index,meta,data,get,index,set,string,existing,mappers,new,hash,set,if,mapper,null,existing,mappers,add,mapper,type,if,default,mapper,null,existing,mappers,add,final,map,string,document,mapper,updated,entries,try,updated,entries,internal,merge,new,index,meta,data,merge,reason,true,catch,exception,e,logger,warn,new,parameterized,message,failed,to,apply,mappings,index,e,throw,e,boolean,require,refresh,false,assert,mapping,version,current,index,meta,data,new,index,meta,data,updated,entries,for,document,mapper,document,mapper,updated,entries,values,string,mapping,type,document,mapper,type,compressed,xcontent,incoming,mapping,source,new,index,meta,data,mapping,mapping,type,source,string,op,existing,mappers,contains,mapping,type,updated,added,if,logger,is,debug,enabled,incoming,mapping,source,compressed,length,512,logger,debug,mapping,source,index,op,mapping,type,incoming,mapping,source,string,else,if,logger,is,trace,enabled,logger,trace,mapping,source,index,op,mapping,type,incoming,mapping,source,string,else,logger,debug,mapping,source,suppressed,due,to,length,use,trace,level,if,needed,index,op,mapping,type,if,document,mapper,mapping,type,mapping,source,equals,incoming,mapping,source,false,logger,debug,parsed,mapping,and,got,different,sources,noriginal,n,nparsed,n,index,mapping,type,incoming,mapping,source,document,mapper,mapping,type,mapping,source,require,refresh,true,return,require,refresh
MapperService -> public boolean updateMapping(final IndexMetaData currentIndexMetaData, final IndexMetaData newIndexMetaData) throws IOException;1540583181;Update mapping by only merging the metadata that is different between received and stored entries;public boolean updateMapping(final IndexMetaData currentIndexMetaData, final IndexMetaData newIndexMetaData) throws IOException {_        assert newIndexMetaData.getIndex().equals(index()) : "index mismatch: expected " + index() + " but was " + newIndexMetaData.getIndex()__        _        Set<String> existingMappers = new HashSet<>()__        if (mapper != null) {_            existingMappers.add(mapper.type())__        }_        if (defaultMapper != null) {_            existingMappers.add(DEFAULT_MAPPING)__        }_        final Map<String, DocumentMapper> updatedEntries__        try {_            _            updatedEntries = internalMerge(newIndexMetaData, MergeReason.MAPPING_RECOVERY, true)__        } catch (Exception e) {_            logger.warn(() -> new ParameterizedMessage("[{}] failed to apply mappings", index()), e)__            throw e__        }__        boolean requireRefresh = false___        assertMappingVersion(currentIndexMetaData, newIndexMetaData, updatedEntries)___        for (DocumentMapper documentMapper : updatedEntries.values()) {_            String mappingType = documentMapper.type()__            CompressedXContent incomingMappingSource = newIndexMetaData.mapping(mappingType).source()___            String op = existingMappers.contains(mappingType) ? "updated" : "added"__            if (logger.isDebugEnabled() && incomingMappingSource.compressed().length < 512) {_                logger.debug("[{}] {} mapping [{}], source [{}]", index(), op, mappingType, incomingMappingSource.string())__            } else if (logger.isTraceEnabled()) {_                logger.trace("[{}] {} mapping [{}], source [{}]", index(), op, mappingType, incomingMappingSource.string())__            } else {_                logger.debug("[{}] {} mapping [{}] (source suppressed due to length, use TRACE level if needed)", index(), op, mappingType)__            }__            _            _            _            if (documentMapper(mappingType).mappingSource().equals(incomingMappingSource) == false) {_                logger.debug("[{}] parsed mapping [{}], and got different sources\noriginal:\n{}\nparsed:\n{}", index(), mappingType,_                    incomingMappingSource, documentMapper(mappingType).mappingSource())___                requireRefresh = true__            }_        }__        return requireRefresh__    };update,mapping,by,only,merging,the,metadata,that,is,different,between,received,and,stored,entries;public,boolean,update,mapping,final,index,meta,data,current,index,meta,data,final,index,meta,data,new,index,meta,data,throws,ioexception,assert,new,index,meta,data,get,index,equals,index,index,mismatch,expected,index,but,was,new,index,meta,data,get,index,set,string,existing,mappers,new,hash,set,if,mapper,null,existing,mappers,add,mapper,type,if,default,mapper,null,existing,mappers,add,final,map,string,document,mapper,updated,entries,try,updated,entries,internal,merge,new,index,meta,data,merge,reason,true,catch,exception,e,logger,warn,new,parameterized,message,failed,to,apply,mappings,index,e,throw,e,boolean,require,refresh,false,assert,mapping,version,current,index,meta,data,new,index,meta,data,updated,entries,for,document,mapper,document,mapper,updated,entries,values,string,mapping,type,document,mapper,type,compressed,xcontent,incoming,mapping,source,new,index,meta,data,mapping,mapping,type,source,string,op,existing,mappers,contains,mapping,type,updated,added,if,logger,is,debug,enabled,incoming,mapping,source,compressed,length,512,logger,debug,mapping,source,index,op,mapping,type,incoming,mapping,source,string,else,if,logger,is,trace,enabled,logger,trace,mapping,source,index,op,mapping,type,incoming,mapping,source,string,else,logger,debug,mapping,source,suppressed,due,to,length,use,trace,level,if,needed,index,op,mapping,type,if,document,mapper,mapping,type,mapping,source,equals,incoming,mapping,source,false,logger,debug,parsed,mapping,and,got,different,sources,noriginal,n,nparsed,n,index,mapping,type,incoming,mapping,source,document,mapper,mapping,type,mapping,source,require,refresh,true,return,require,refresh
MapperService -> public boolean updateMapping(final IndexMetaData currentIndexMetaData, final IndexMetaData newIndexMetaData) throws IOException;1541008027;Update mapping by only merging the metadata that is different between received and stored entries;public boolean updateMapping(final IndexMetaData currentIndexMetaData, final IndexMetaData newIndexMetaData) throws IOException {_        assert newIndexMetaData.getIndex().equals(index()) : "index mismatch: expected " + index()_            + " but was " + newIndexMetaData.getIndex()__        _        Set<String> existingMappers = new HashSet<>()__        if (mapper != null) {_            existingMappers.add(mapper.type())__        }_        if (defaultMapper != null) {_            existingMappers.add(DEFAULT_MAPPING)__        }_        final Map<String, DocumentMapper> updatedEntries__        try {_            _            updatedEntries = internalMerge(newIndexMetaData, MergeReason.MAPPING_RECOVERY, true)__        } catch (Exception e) {_            logger.warn(() -> new ParameterizedMessage("[{}] failed to apply mappings", index()), e)__            throw e__        }__        boolean requireRefresh = false___        assertMappingVersion(currentIndexMetaData, newIndexMetaData, updatedEntries)___        for (DocumentMapper documentMapper : updatedEntries.values()) {_            String mappingType = documentMapper.type()__            CompressedXContent incomingMappingSource = newIndexMetaData.mapping(mappingType).source()___            String op = existingMappers.contains(mappingType) ? "updated" : "added"__            if (logger.isDebugEnabled() && incomingMappingSource.compressed().length < 512) {_                logger.debug("[{}] {} mapping [{}], source [{}]", index(), op, mappingType, incomingMappingSource.string())__            } else if (logger.isTraceEnabled()) {_                logger.trace("[{}] {} mapping [{}], source [{}]", index(), op, mappingType, incomingMappingSource.string())__            } else {_                logger.debug("[{}] {} mapping [{}] (source suppressed due to length, use TRACE level if needed)",_                    index(), op, mappingType)__            }__            _            _            _            if (documentMapper(mappingType).mappingSource().equals(incomingMappingSource) == false) {_                logger.debug("[{}] parsed mapping [{}], and got different sources\noriginal:\n{}\nparsed:\n{}",_                    index(), mappingType, incomingMappingSource, documentMapper(mappingType).mappingSource())___                requireRefresh = true__            }_        }__        return requireRefresh__    };update,mapping,by,only,merging,the,metadata,that,is,different,between,received,and,stored,entries;public,boolean,update,mapping,final,index,meta,data,current,index,meta,data,final,index,meta,data,new,index,meta,data,throws,ioexception,assert,new,index,meta,data,get,index,equals,index,index,mismatch,expected,index,but,was,new,index,meta,data,get,index,set,string,existing,mappers,new,hash,set,if,mapper,null,existing,mappers,add,mapper,type,if,default,mapper,null,existing,mappers,add,final,map,string,document,mapper,updated,entries,try,updated,entries,internal,merge,new,index,meta,data,merge,reason,true,catch,exception,e,logger,warn,new,parameterized,message,failed,to,apply,mappings,index,e,throw,e,boolean,require,refresh,false,assert,mapping,version,current,index,meta,data,new,index,meta,data,updated,entries,for,document,mapper,document,mapper,updated,entries,values,string,mapping,type,document,mapper,type,compressed,xcontent,incoming,mapping,source,new,index,meta,data,mapping,mapping,type,source,string,op,existing,mappers,contains,mapping,type,updated,added,if,logger,is,debug,enabled,incoming,mapping,source,compressed,length,512,logger,debug,mapping,source,index,op,mapping,type,incoming,mapping,source,string,else,if,logger,is,trace,enabled,logger,trace,mapping,source,index,op,mapping,type,incoming,mapping,source,string,else,logger,debug,mapping,source,suppressed,due,to,length,use,trace,level,if,needed,index,op,mapping,type,if,document,mapper,mapping,type,mapping,source,equals,incoming,mapping,source,false,logger,debug,parsed,mapping,and,got,different,sources,noriginal,n,nparsed,n,index,mapping,type,incoming,mapping,source,document,mapper,mapping,type,mapping,source,require,refresh,true,return,require,refresh
MapperService -> public boolean updateMapping(final IndexMetaData currentIndexMetaData, final IndexMetaData newIndexMetaData) throws IOException;1541592065;Update mapping by only merging the metadata that is different between received and stored entries;public boolean updateMapping(final IndexMetaData currentIndexMetaData, final IndexMetaData newIndexMetaData) throws IOException {_        assert newIndexMetaData.getIndex().equals(index()) : "index mismatch: expected " + index()_            + " but was " + newIndexMetaData.getIndex()__        _        Set<String> existingMappers = new HashSet<>()__        if (mapper != null) {_            existingMappers.add(mapper.type())__        }_        if (defaultMapper != null) {_            existingMappers.add(DEFAULT_MAPPING)__        }_        final Map<String, DocumentMapper> updatedEntries__        try {_            _            updatedEntries = internalMerge(newIndexMetaData, MergeReason.MAPPING_RECOVERY, true)__        } catch (Exception e) {_            logger.warn(() -> new ParameterizedMessage("[{}] failed to apply mappings", index()), e)__            throw e__        }__        boolean requireRefresh = false___        assertMappingVersion(currentIndexMetaData, newIndexMetaData, updatedEntries)___        for (DocumentMapper documentMapper : updatedEntries.values()) {_            String mappingType = documentMapper.type()__            CompressedXContent incomingMappingSource = newIndexMetaData.mapping(mappingType).source()___            String op = existingMappers.contains(mappingType) ? "updated" : "added"__            if (logger.isDebugEnabled() && incomingMappingSource.compressed().length < 512) {_                logger.debug("[{}] {} mapping [{}], source [{}]", index(), op, mappingType, incomingMappingSource.string())__            } else if (logger.isTraceEnabled()) {_                logger.trace("[{}] {} mapping [{}], source [{}]", index(), op, mappingType, incomingMappingSource.string())__            } else {_                logger.debug("[{}] {} mapping [{}] (source suppressed due to length, use TRACE level if needed)",_                    index(), op, mappingType)__            }__            _            _            _            if (documentMapper(mappingType).mappingSource().equals(incomingMappingSource) == false) {_                logger.debug("[{}] parsed mapping [{}], and got different sources\noriginal:\n{}\nparsed:\n{}",_                    index(), mappingType, incomingMappingSource, documentMapper(mappingType).mappingSource())___                requireRefresh = true__            }_        }__        return requireRefresh__    };update,mapping,by,only,merging,the,metadata,that,is,different,between,received,and,stored,entries;public,boolean,update,mapping,final,index,meta,data,current,index,meta,data,final,index,meta,data,new,index,meta,data,throws,ioexception,assert,new,index,meta,data,get,index,equals,index,index,mismatch,expected,index,but,was,new,index,meta,data,get,index,set,string,existing,mappers,new,hash,set,if,mapper,null,existing,mappers,add,mapper,type,if,default,mapper,null,existing,mappers,add,final,map,string,document,mapper,updated,entries,try,updated,entries,internal,merge,new,index,meta,data,merge,reason,true,catch,exception,e,logger,warn,new,parameterized,message,failed,to,apply,mappings,index,e,throw,e,boolean,require,refresh,false,assert,mapping,version,current,index,meta,data,new,index,meta,data,updated,entries,for,document,mapper,document,mapper,updated,entries,values,string,mapping,type,document,mapper,type,compressed,xcontent,incoming,mapping,source,new,index,meta,data,mapping,mapping,type,source,string,op,existing,mappers,contains,mapping,type,updated,added,if,logger,is,debug,enabled,incoming,mapping,source,compressed,length,512,logger,debug,mapping,source,index,op,mapping,type,incoming,mapping,source,string,else,if,logger,is,trace,enabled,logger,trace,mapping,source,index,op,mapping,type,incoming,mapping,source,string,else,logger,debug,mapping,source,suppressed,due,to,length,use,trace,level,if,needed,index,op,mapping,type,if,document,mapper,mapping,type,mapping,source,equals,incoming,mapping,source,false,logger,debug,parsed,mapping,and,got,different,sources,noriginal,n,nparsed,n,index,mapping,type,incoming,mapping,source,document,mapper,mapping,type,mapping,source,require,refresh,true,return,require,refresh
MapperService -> public boolean updateMapping(final IndexMetaData currentIndexMetaData, final IndexMetaData newIndexMetaData) throws IOException;1542899326;Update mapping by only merging the metadata that is different between received and stored entries;public boolean updateMapping(final IndexMetaData currentIndexMetaData, final IndexMetaData newIndexMetaData) throws IOException {_        assert newIndexMetaData.getIndex().equals(index()) : "index mismatch: expected " + index()_            + " but was " + newIndexMetaData.getIndex()__        _        Set<String> existingMappers = new HashSet<>()__        if (mapper != null) {_            existingMappers.add(mapper.type())__        }_        if (defaultMapper != null) {_            existingMappers.add(DEFAULT_MAPPING)__        }_        final Map<String, DocumentMapper> updatedEntries__        try {_            _            updatedEntries = internalMerge(newIndexMetaData, MergeReason.MAPPING_RECOVERY, true)__        } catch (Exception e) {_            logger.warn(() -> new ParameterizedMessage("[{}] failed to apply mappings", index()), e)__            throw e__        }__        boolean requireRefresh = false___        assertMappingVersion(currentIndexMetaData, newIndexMetaData, updatedEntries)___        for (DocumentMapper documentMapper : updatedEntries.values()) {_            String mappingType = documentMapper.type()__            CompressedXContent incomingMappingSource = newIndexMetaData.mapping(mappingType).source()___            String op = existingMappers.contains(mappingType) ? "updated" : "added"__            if (logger.isDebugEnabled() && incomingMappingSource.compressed().length < 512) {_                logger.debug("[{}] {} mapping [{}], source [{}]", index(), op, mappingType, incomingMappingSource.string())__            } else if (logger.isTraceEnabled()) {_                logger.trace("[{}] {} mapping [{}], source [{}]", index(), op, mappingType, incomingMappingSource.string())__            } else {_                logger.debug("[{}] {} mapping [{}] (source suppressed due to length, use TRACE level if needed)",_                    index(), op, mappingType)__            }__            _            _            _            if (documentMapper(mappingType).mappingSource().equals(incomingMappingSource) == false) {_                logger.debug("[{}] parsed mapping [{}], and got different sources\noriginal:\n{}\nparsed:\n{}",_                    index(), mappingType, incomingMappingSource, documentMapper(mappingType).mappingSource())___                requireRefresh = true__            }_        }__        return requireRefresh__    };update,mapping,by,only,merging,the,metadata,that,is,different,between,received,and,stored,entries;public,boolean,update,mapping,final,index,meta,data,current,index,meta,data,final,index,meta,data,new,index,meta,data,throws,ioexception,assert,new,index,meta,data,get,index,equals,index,index,mismatch,expected,index,but,was,new,index,meta,data,get,index,set,string,existing,mappers,new,hash,set,if,mapper,null,existing,mappers,add,mapper,type,if,default,mapper,null,existing,mappers,add,final,map,string,document,mapper,updated,entries,try,updated,entries,internal,merge,new,index,meta,data,merge,reason,true,catch,exception,e,logger,warn,new,parameterized,message,failed,to,apply,mappings,index,e,throw,e,boolean,require,refresh,false,assert,mapping,version,current,index,meta,data,new,index,meta,data,updated,entries,for,document,mapper,document,mapper,updated,entries,values,string,mapping,type,document,mapper,type,compressed,xcontent,incoming,mapping,source,new,index,meta,data,mapping,mapping,type,source,string,op,existing,mappers,contains,mapping,type,updated,added,if,logger,is,debug,enabled,incoming,mapping,source,compressed,length,512,logger,debug,mapping,source,index,op,mapping,type,incoming,mapping,source,string,else,if,logger,is,trace,enabled,logger,trace,mapping,source,index,op,mapping,type,incoming,mapping,source,string,else,logger,debug,mapping,source,suppressed,due,to,length,use,trace,level,if,needed,index,op,mapping,type,if,document,mapper,mapping,type,mapping,source,equals,incoming,mapping,source,false,logger,debug,parsed,mapping,and,got,different,sources,noriginal,n,nparsed,n,index,mapping,type,incoming,mapping,source,document,mapper,mapping,type,mapping,source,require,refresh,true,return,require,refresh
MapperService -> public boolean updateMapping(final IndexMetaData currentIndexMetaData, final IndexMetaData newIndexMetaData) throws IOException;1543947737;Update mapping by only merging the metadata that is different between received and stored entries;public boolean updateMapping(final IndexMetaData currentIndexMetaData, final IndexMetaData newIndexMetaData) throws IOException {_        assert newIndexMetaData.getIndex().equals(index()) : "index mismatch: expected " + index()_            + " but was " + newIndexMetaData.getIndex()__        _        Set<String> existingMappers = new HashSet<>()__        if (mapper != null) {_            existingMappers.add(mapper.type())__        }_        if (defaultMapper != null) {_            existingMappers.add(DEFAULT_MAPPING)__        }_        final Map<String, DocumentMapper> updatedEntries__        try {_            _            updatedEntries = internalMerge(newIndexMetaData, MergeReason.MAPPING_RECOVERY, true)__        } catch (Exception e) {_            logger.warn(() -> new ParameterizedMessage("[{}] failed to apply mappings", index()), e)__            throw e__        }__        boolean requireRefresh = false___        assertMappingVersion(currentIndexMetaData, newIndexMetaData, updatedEntries)___        for (DocumentMapper documentMapper : updatedEntries.values()) {_            String mappingType = documentMapper.type()__            MappingMetaData mappingMetaData__            if (mappingType.equals(MapperService.DEFAULT_MAPPING)) {_                mappingMetaData = newIndexMetaData.defaultMapping()__            } else {_                mappingMetaData = newIndexMetaData.mapping()__                assert mappingType.equals(mappingMetaData.type())__            }_            CompressedXContent incomingMappingSource = mappingMetaData.source()___            String op = existingMappers.contains(mappingType) ? "updated" : "added"__            if (logger.isDebugEnabled() && incomingMappingSource.compressed().length < 512) {_                logger.debug("[{}] {} mapping [{}], source [{}]", index(), op, mappingType, incomingMappingSource.string())__            } else if (logger.isTraceEnabled()) {_                logger.trace("[{}] {} mapping [{}], source [{}]", index(), op, mappingType, incomingMappingSource.string())__            } else {_                logger.debug("[{}] {} mapping [{}] (source suppressed due to length, use TRACE level if needed)",_                    index(), op, mappingType)__            }__            _            _            _            if (documentMapper(mappingType).mappingSource().equals(incomingMappingSource) == false) {_                logger.debug("[{}] parsed mapping [{}], and got different sources\noriginal:\n{}\nparsed:\n{}",_                    index(), mappingType, incomingMappingSource, documentMapper(mappingType).mappingSource())___                requireRefresh = true__            }_        }__        return requireRefresh__    };update,mapping,by,only,merging,the,metadata,that,is,different,between,received,and,stored,entries;public,boolean,update,mapping,final,index,meta,data,current,index,meta,data,final,index,meta,data,new,index,meta,data,throws,ioexception,assert,new,index,meta,data,get,index,equals,index,index,mismatch,expected,index,but,was,new,index,meta,data,get,index,set,string,existing,mappers,new,hash,set,if,mapper,null,existing,mappers,add,mapper,type,if,default,mapper,null,existing,mappers,add,final,map,string,document,mapper,updated,entries,try,updated,entries,internal,merge,new,index,meta,data,merge,reason,true,catch,exception,e,logger,warn,new,parameterized,message,failed,to,apply,mappings,index,e,throw,e,boolean,require,refresh,false,assert,mapping,version,current,index,meta,data,new,index,meta,data,updated,entries,for,document,mapper,document,mapper,updated,entries,values,string,mapping,type,document,mapper,type,mapping,meta,data,mapping,meta,data,if,mapping,type,equals,mapper,service,mapping,meta,data,new,index,meta,data,default,mapping,else,mapping,meta,data,new,index,meta,data,mapping,assert,mapping,type,equals,mapping,meta,data,type,compressed,xcontent,incoming,mapping,source,mapping,meta,data,source,string,op,existing,mappers,contains,mapping,type,updated,added,if,logger,is,debug,enabled,incoming,mapping,source,compressed,length,512,logger,debug,mapping,source,index,op,mapping,type,incoming,mapping,source,string,else,if,logger,is,trace,enabled,logger,trace,mapping,source,index,op,mapping,type,incoming,mapping,source,string,else,logger,debug,mapping,source,suppressed,due,to,length,use,trace,level,if,needed,index,op,mapping,type,if,document,mapper,mapping,type,mapping,source,equals,incoming,mapping,source,false,logger,debug,parsed,mapping,and,got,different,sources,noriginal,n,nparsed,n,index,mapping,type,incoming,mapping,source,document,mapper,mapping,type,mapping,source,require,refresh,true,return,require,refresh
MapperService -> public boolean updateMapping(final IndexMetaData currentIndexMetaData, final IndexMetaData newIndexMetaData) throws IOException;1545126194;Update mapping by only merging the metadata that is different between received and stored entries;public boolean updateMapping(final IndexMetaData currentIndexMetaData, final IndexMetaData newIndexMetaData) throws IOException {_        assert newIndexMetaData.getIndex().equals(index()) : "index mismatch: expected " + index()_            + " but was " + newIndexMetaData.getIndex()__        _        Set<String> existingMappers = new HashSet<>()__        if (mapper != null) {_            existingMappers.add(mapper.type())__        }_        if (defaultMapper != null) {_            existingMappers.add(DEFAULT_MAPPING)__        }_        final Map<String, DocumentMapper> updatedEntries__        try {_            _            updatedEntries = internalMerge(newIndexMetaData, MergeReason.MAPPING_RECOVERY, true)__        } catch (Exception e) {_            logger.warn(() -> new ParameterizedMessage("[{}] failed to apply mappings", index()), e)__            throw e__        }__        boolean requireRefresh = false___        assertMappingVersion(currentIndexMetaData, newIndexMetaData, updatedEntries)___        for (DocumentMapper documentMapper : updatedEntries.values()) {_            String mappingType = documentMapper.type()__            MappingMetaData mappingMetaData__            if (mappingType.equals(MapperService.DEFAULT_MAPPING)) {_                mappingMetaData = newIndexMetaData.defaultMapping()__            } else {_                mappingMetaData = newIndexMetaData.mapping()__                assert mappingType.equals(mappingMetaData.type())__            }_            CompressedXContent incomingMappingSource = mappingMetaData.source()___            String op = existingMappers.contains(mappingType) ? "updated" : "added"__            if (logger.isDebugEnabled() && incomingMappingSource.compressed().length < 512) {_                logger.debug("[{}] {} mapping [{}], source [{}]", index(), op, mappingType, incomingMappingSource.string())__            } else if (logger.isTraceEnabled()) {_                logger.trace("[{}] {} mapping [{}], source [{}]", index(), op, mappingType, incomingMappingSource.string())__            } else {_                logger.debug("[{}] {} mapping [{}] (source suppressed due to length, use TRACE level if needed)",_                    index(), op, mappingType)__            }__            _            _            _            if (documentMapper(mappingType).mappingSource().equals(incomingMappingSource) == false) {_                logger.debug("[{}] parsed mapping [{}], and got different sources\noriginal:\n{}\nparsed:\n{}",_                    index(), mappingType, incomingMappingSource, documentMapper(mappingType).mappingSource())___                requireRefresh = true__            }_        }__        return requireRefresh__    };update,mapping,by,only,merging,the,metadata,that,is,different,between,received,and,stored,entries;public,boolean,update,mapping,final,index,meta,data,current,index,meta,data,final,index,meta,data,new,index,meta,data,throws,ioexception,assert,new,index,meta,data,get,index,equals,index,index,mismatch,expected,index,but,was,new,index,meta,data,get,index,set,string,existing,mappers,new,hash,set,if,mapper,null,existing,mappers,add,mapper,type,if,default,mapper,null,existing,mappers,add,final,map,string,document,mapper,updated,entries,try,updated,entries,internal,merge,new,index,meta,data,merge,reason,true,catch,exception,e,logger,warn,new,parameterized,message,failed,to,apply,mappings,index,e,throw,e,boolean,require,refresh,false,assert,mapping,version,current,index,meta,data,new,index,meta,data,updated,entries,for,document,mapper,document,mapper,updated,entries,values,string,mapping,type,document,mapper,type,mapping,meta,data,mapping,meta,data,if,mapping,type,equals,mapper,service,mapping,meta,data,new,index,meta,data,default,mapping,else,mapping,meta,data,new,index,meta,data,mapping,assert,mapping,type,equals,mapping,meta,data,type,compressed,xcontent,incoming,mapping,source,mapping,meta,data,source,string,op,existing,mappers,contains,mapping,type,updated,added,if,logger,is,debug,enabled,incoming,mapping,source,compressed,length,512,logger,debug,mapping,source,index,op,mapping,type,incoming,mapping,source,string,else,if,logger,is,trace,enabled,logger,trace,mapping,source,index,op,mapping,type,incoming,mapping,source,string,else,logger,debug,mapping,source,suppressed,due,to,length,use,trace,level,if,needed,index,op,mapping,type,if,document,mapper,mapping,type,mapping,source,equals,incoming,mapping,source,false,logger,debug,parsed,mapping,and,got,different,sources,noriginal,n,nparsed,n,index,mapping,type,incoming,mapping,source,document,mapper,mapping,type,mapping,source,require,refresh,true,return,require,refresh
MapperService -> public boolean updateMapping(final IndexMetaData currentIndexMetaData, final IndexMetaData newIndexMetaData) throws IOException;1547566367;Update mapping by only merging the metadata that is different between received and stored entries;public boolean updateMapping(final IndexMetaData currentIndexMetaData, final IndexMetaData newIndexMetaData) throws IOException {_        assert newIndexMetaData.getIndex().equals(index()) : "index mismatch: expected " + index()_            + " but was " + newIndexMetaData.getIndex()__        _        Set<String> existingMappers = new HashSet<>()__        if (mapper != null) {_            existingMappers.add(mapper.type())__        }_        if (defaultMapper != null) {_            existingMappers.add(DEFAULT_MAPPING)__        }_        final Map<String, DocumentMapper> updatedEntries__        try {_            _            updatedEntries = internalMerge(newIndexMetaData, MergeReason.MAPPING_RECOVERY, true)__        } catch (Exception e) {_            logger.warn(() -> new ParameterizedMessage("[{}] failed to apply mappings", index()), e)__            throw e__        }__        boolean requireRefresh = false___        assertMappingVersion(currentIndexMetaData, newIndexMetaData, updatedEntries)___        for (DocumentMapper documentMapper : updatedEntries.values()) {_            String mappingType = documentMapper.type()__            MappingMetaData mappingMetaData__            if (mappingType.equals(MapperService.DEFAULT_MAPPING)) {_                mappingMetaData = newIndexMetaData.defaultMapping()__            } else {_                mappingMetaData = newIndexMetaData.mapping()__                assert mappingType.equals(mappingMetaData.type())__            }_            CompressedXContent incomingMappingSource = mappingMetaData.source()___            String op = existingMappers.contains(mappingType) ? "updated" : "added"__            if (logger.isDebugEnabled() && incomingMappingSource.compressed().length < 512) {_                logger.debug("[{}] {} mapping [{}], source [{}]", index(), op, mappingType, incomingMappingSource.string())__            } else if (logger.isTraceEnabled()) {_                logger.trace("[{}] {} mapping [{}], source [{}]", index(), op, mappingType, incomingMappingSource.string())__            } else {_                logger.debug("[{}] {} mapping [{}] (source suppressed due to length, use TRACE level if needed)",_                    index(), op, mappingType)__            }__            _            _            _            if (documentMapper(mappingType).mappingSource().equals(incomingMappingSource) == false) {_                logger.debug("[{}] parsed mapping [{}], and got different sources\noriginal:\n{}\nparsed:\n{}",_                    index(), mappingType, incomingMappingSource, documentMapper(mappingType).mappingSource())___                requireRefresh = true__            }_        }__        return requireRefresh__    };update,mapping,by,only,merging,the,metadata,that,is,different,between,received,and,stored,entries;public,boolean,update,mapping,final,index,meta,data,current,index,meta,data,final,index,meta,data,new,index,meta,data,throws,ioexception,assert,new,index,meta,data,get,index,equals,index,index,mismatch,expected,index,but,was,new,index,meta,data,get,index,set,string,existing,mappers,new,hash,set,if,mapper,null,existing,mappers,add,mapper,type,if,default,mapper,null,existing,mappers,add,final,map,string,document,mapper,updated,entries,try,updated,entries,internal,merge,new,index,meta,data,merge,reason,true,catch,exception,e,logger,warn,new,parameterized,message,failed,to,apply,mappings,index,e,throw,e,boolean,require,refresh,false,assert,mapping,version,current,index,meta,data,new,index,meta,data,updated,entries,for,document,mapper,document,mapper,updated,entries,values,string,mapping,type,document,mapper,type,mapping,meta,data,mapping,meta,data,if,mapping,type,equals,mapper,service,mapping,meta,data,new,index,meta,data,default,mapping,else,mapping,meta,data,new,index,meta,data,mapping,assert,mapping,type,equals,mapping,meta,data,type,compressed,xcontent,incoming,mapping,source,mapping,meta,data,source,string,op,existing,mappers,contains,mapping,type,updated,added,if,logger,is,debug,enabled,incoming,mapping,source,compressed,length,512,logger,debug,mapping,source,index,op,mapping,type,incoming,mapping,source,string,else,if,logger,is,trace,enabled,logger,trace,mapping,source,index,op,mapping,type,incoming,mapping,source,string,else,logger,debug,mapping,source,suppressed,due,to,length,use,trace,level,if,needed,index,op,mapping,type,if,document,mapper,mapping,type,mapping,source,equals,incoming,mapping,source,false,logger,debug,parsed,mapping,and,got,different,sources,noriginal,n,nparsed,n,index,mapping,type,incoming,mapping,source,document,mapper,mapping,type,mapping,source,require,refresh,true,return,require,refresh
MapperService -> public boolean updateMapping(final IndexMetaData currentIndexMetaData, final IndexMetaData newIndexMetaData) throws IOException;1549392752;Update mapping by only merging the metadata that is different between received and stored entries;public boolean updateMapping(final IndexMetaData currentIndexMetaData, final IndexMetaData newIndexMetaData) throws IOException {_        assert newIndexMetaData.getIndex().equals(index()) : "index mismatch: expected " + index()_            + " but was " + newIndexMetaData.getIndex()__        _        Set<String> existingMappers = new HashSet<>()__        if (mapper != null) {_            existingMappers.add(mapper.type())__        }_        if (defaultMapper != null) {_            existingMappers.add(DEFAULT_MAPPING)__        }_        final Map<String, DocumentMapper> updatedEntries__        try {_            _            updatedEntries = internalMerge(newIndexMetaData, MergeReason.MAPPING_RECOVERY, true)__        } catch (Exception e) {_            logger.warn(() -> new ParameterizedMessage("[{}] failed to apply mappings", index()), e)__            throw e__        }__        boolean requireRefresh = false___        assertMappingVersion(currentIndexMetaData, newIndexMetaData, updatedEntries)___        for (DocumentMapper documentMapper : updatedEntries.values()) {_            String mappingType = documentMapper.type()__            MappingMetaData mappingMetaData__            if (mappingType.equals(MapperService.DEFAULT_MAPPING)) {_                mappingMetaData = newIndexMetaData.defaultMapping()__            } else {_                mappingMetaData = newIndexMetaData.mapping()__                assert mappingType.equals(mappingMetaData.type())__            }_            CompressedXContent incomingMappingSource = mappingMetaData.source()___            String op = existingMappers.contains(mappingType) ? "updated" : "added"__            if (logger.isDebugEnabled() && incomingMappingSource.compressed().length < 512) {_                logger.debug("[{}] {} mapping [{}], source [{}]", index(), op, mappingType, incomingMappingSource.string())__            } else if (logger.isTraceEnabled()) {_                logger.trace("[{}] {} mapping [{}], source [{}]", index(), op, mappingType, incomingMappingSource.string())__            } else {_                logger.debug("[{}] {} mapping [{}] (source suppressed due to length, use TRACE level if needed)",_                    index(), op, mappingType)__            }__            _            _            _            if (documentMapper(mappingType).mappingSource().equals(incomingMappingSource) == false) {_                logger.debug("[{}] parsed mapping [{}], and got different sources\noriginal:\n{}\nparsed:\n{}",_                    index(), mappingType, incomingMappingSource, documentMapper(mappingType).mappingSource())___                requireRefresh = true__            }_        }__        return requireRefresh__    };update,mapping,by,only,merging,the,metadata,that,is,different,between,received,and,stored,entries;public,boolean,update,mapping,final,index,meta,data,current,index,meta,data,final,index,meta,data,new,index,meta,data,throws,ioexception,assert,new,index,meta,data,get,index,equals,index,index,mismatch,expected,index,but,was,new,index,meta,data,get,index,set,string,existing,mappers,new,hash,set,if,mapper,null,existing,mappers,add,mapper,type,if,default,mapper,null,existing,mappers,add,final,map,string,document,mapper,updated,entries,try,updated,entries,internal,merge,new,index,meta,data,merge,reason,true,catch,exception,e,logger,warn,new,parameterized,message,failed,to,apply,mappings,index,e,throw,e,boolean,require,refresh,false,assert,mapping,version,current,index,meta,data,new,index,meta,data,updated,entries,for,document,mapper,document,mapper,updated,entries,values,string,mapping,type,document,mapper,type,mapping,meta,data,mapping,meta,data,if,mapping,type,equals,mapper,service,mapping,meta,data,new,index,meta,data,default,mapping,else,mapping,meta,data,new,index,meta,data,mapping,assert,mapping,type,equals,mapping,meta,data,type,compressed,xcontent,incoming,mapping,source,mapping,meta,data,source,string,op,existing,mappers,contains,mapping,type,updated,added,if,logger,is,debug,enabled,incoming,mapping,source,compressed,length,512,logger,debug,mapping,source,index,op,mapping,type,incoming,mapping,source,string,else,if,logger,is,trace,enabled,logger,trace,mapping,source,index,op,mapping,type,incoming,mapping,source,string,else,logger,debug,mapping,source,suppressed,due,to,length,use,trace,level,if,needed,index,op,mapping,type,if,document,mapper,mapping,type,mapping,source,equals,incoming,mapping,source,false,logger,debug,parsed,mapping,and,got,different,sources,noriginal,n,nparsed,n,index,mapping,type,incoming,mapping,source,document,mapper,mapping,type,mapping,source,require,refresh,true,return,require,refresh
MapperService -> public Collection<String> simpleMatchToFullName(String pattern);1528706846;Returns all the fields that match the given pattern. If the pattern is prefixed with a type_then the fields will be returned with a type prefix.;public Collection<String> simpleMatchToFullName(String pattern) {_        if (Regex.isSimpleMatchPattern(pattern) == false) {_            _            return Collections.singletonList(pattern)__        }_        return fieldTypes.simpleMatchToFullName(pattern)__    };returns,all,the,fields,that,match,the,given,pattern,if,the,pattern,is,prefixed,with,a,type,then,the,fields,will,be,returned,with,a,type,prefix;public,collection,string,simple,match,to,full,name,string,pattern,if,regex,is,simple,match,pattern,pattern,false,return,collections,singleton,list,pattern,return,field,types,simple,match,to,full,name,pattern
MapperService -> public Collection<String> simpleMatchToFullName(String pattern);1531937412;Returns all the fields that match the given pattern. If the pattern is prefixed with a type_then the fields will be returned with a type prefix.;public Collection<String> simpleMatchToFullName(String pattern) {_        if (Regex.isSimpleMatchPattern(pattern) == false) {_            _            return Collections.singletonList(pattern)__        }_        return fieldTypes.simpleMatchToFullName(pattern)__    };returns,all,the,fields,that,match,the,given,pattern,if,the,pattern,is,prefixed,with,a,type,then,the,fields,will,be,returned,with,a,type,prefix;public,collection,string,simple,match,to,full,name,string,pattern,if,regex,is,simple,match,pattern,pattern,false,return,collections,singleton,list,pattern,return,field,types,simple,match,to,full,name,pattern
MapperService -> public Collection<String> simpleMatchToFullName(String pattern);1532353780;Returns all the fields that match the given pattern. If the pattern is prefixed with a type_then the fields will be returned with a type prefix.;public Collection<String> simpleMatchToFullName(String pattern) {_        if (Regex.isSimpleMatchPattern(pattern) == false) {_            _            return Collections.singletonList(pattern)__        }_        return fieldTypes.simpleMatchToFullName(pattern)__    };returns,all,the,fields,that,match,the,given,pattern,if,the,pattern,is,prefixed,with,a,type,then,the,fields,will,be,returned,with,a,type,prefix;public,collection,string,simple,match,to,full,name,string,pattern,if,regex,is,simple,match,pattern,pattern,false,return,collections,singleton,list,pattern,return,field,types,simple,match,to,full,name,pattern
MapperService -> public Collection<String> simpleMatchToFullName(String pattern);1534539448;Returns all the fields that match the given pattern. If the pattern is prefixed with a type_then the fields will be returned with a type prefix.;public Collection<String> simpleMatchToFullName(String pattern) {_        if (Regex.isSimpleMatchPattern(pattern) == false) {_            _            return Collections.singletonList(pattern)__        }_        return fieldTypes.simpleMatchToFullName(pattern)__    };returns,all,the,fields,that,match,the,given,pattern,if,the,pattern,is,prefixed,with,a,type,then,the,fields,will,be,returned,with,a,type,prefix;public,collection,string,simple,match,to,full,name,string,pattern,if,regex,is,simple,match,pattern,pattern,false,return,collections,singleton,list,pattern,return,field,types,simple,match,to,full,name,pattern
MapperService -> public Collection<String> simpleMatchToFullName(String pattern);1535383145;Returns all the fields that match the given pattern. If the pattern is prefixed with a type_then the fields will be returned with a type prefix.;public Collection<String> simpleMatchToFullName(String pattern) {_        if (Regex.isSimpleMatchPattern(pattern) == false) {_            _            return Collections.singletonList(pattern)__        }_        return fieldTypes.simpleMatchToFullName(pattern)__    };returns,all,the,fields,that,match,the,given,pattern,if,the,pattern,is,prefixed,with,a,type,then,the,fields,will,be,returned,with,a,type,prefix;public,collection,string,simple,match,to,full,name,string,pattern,if,regex,is,simple,match,pattern,pattern,false,return,collections,singleton,list,pattern,return,field,types,simple,match,to,full,name,pattern
MapperService -> public Collection<String> simpleMatchToFullName(String pattern);1535405719;Returns all the fields that match the given pattern. If the pattern is prefixed with a type_then the fields will be returned with a type prefix.;public Collection<String> simpleMatchToFullName(String pattern) {_        if (Regex.isSimpleMatchPattern(pattern) == false) {_            _            return Collections.singletonList(pattern)__        }_        return fieldTypes.simpleMatchToFullName(pattern)__    };returns,all,the,fields,that,match,the,given,pattern,if,the,pattern,is,prefixed,with,a,type,then,the,fields,will,be,returned,with,a,type,prefix;public,collection,string,simple,match,to,full,name,string,pattern,if,regex,is,simple,match,pattern,pattern,false,return,collections,singleton,list,pattern,return,field,types,simple,match,to,full,name,pattern
MapperService -> public Collection<String> simpleMatchToFullName(String pattern);1536177418;Returns all the fields that match the given pattern. If the pattern is prefixed with a type_then the fields will be returned with a type prefix.;public Collection<String> simpleMatchToFullName(String pattern) {_        if (Regex.isSimpleMatchPattern(pattern) == false) {_            _            return Collections.singletonList(pattern)__        }_        return fieldTypes.simpleMatchToFullName(pattern)__    };returns,all,the,fields,that,match,the,given,pattern,if,the,pattern,is,prefixed,with,a,type,then,the,fields,will,be,returned,with,a,type,prefix;public,collection,string,simple,match,to,full,name,string,pattern,if,regex,is,simple,match,pattern,pattern,false,return,collections,singleton,list,pattern,return,field,types,simple,match,to,full,name,pattern
MapperService -> public Collection<String> simpleMatchToFullName(String pattern);1540486836;Returns all the fields that match the given pattern. If the pattern is prefixed with a type_then the fields will be returned with a type prefix.;public Collection<String> simpleMatchToFullName(String pattern) {_        if (Regex.isSimpleMatchPattern(pattern) == false) {_            _            return Collections.singletonList(pattern)__        }_        return fieldTypes.simpleMatchToFullName(pattern)__    };returns,all,the,fields,that,match,the,given,pattern,if,the,pattern,is,prefixed,with,a,type,then,the,fields,will,be,returned,with,a,type,prefix;public,collection,string,simple,match,to,full,name,string,pattern,if,regex,is,simple,match,pattern,pattern,false,return,collections,singleton,list,pattern,return,field,types,simple,match,to,full,name,pattern
MapperService -> public Collection<String> simpleMatchToFullName(String pattern);1540583181;Returns all the fields that match the given pattern. If the pattern is prefixed with a type_then the fields will be returned with a type prefix.;public Collection<String> simpleMatchToFullName(String pattern) {_        if (Regex.isSimpleMatchPattern(pattern) == false) {_            _            return Collections.singletonList(pattern)__        }_        return fieldTypes.simpleMatchToFullName(pattern)__    };returns,all,the,fields,that,match,the,given,pattern,if,the,pattern,is,prefixed,with,a,type,then,the,fields,will,be,returned,with,a,type,prefix;public,collection,string,simple,match,to,full,name,string,pattern,if,regex,is,simple,match,pattern,pattern,false,return,collections,singleton,list,pattern,return,field,types,simple,match,to,full,name,pattern
MapperService -> public Collection<String> simpleMatchToFullName(String pattern);1541008027;Returns all the fields that match the given pattern. If the pattern is prefixed with a type_then the fields will be returned with a type prefix.;public Collection<String> simpleMatchToFullName(String pattern) {_        if (Regex.isSimpleMatchPattern(pattern) == false) {_            _            return Collections.singletonList(pattern)__        }_        return fieldTypes.simpleMatchToFullName(pattern)__    };returns,all,the,fields,that,match,the,given,pattern,if,the,pattern,is,prefixed,with,a,type,then,the,fields,will,be,returned,with,a,type,prefix;public,collection,string,simple,match,to,full,name,string,pattern,if,regex,is,simple,match,pattern,pattern,false,return,collections,singleton,list,pattern,return,field,types,simple,match,to,full,name,pattern
MapperService -> public Collection<String> simpleMatchToFullName(String pattern);1541592065;Returns all the fields that match the given pattern. If the pattern is prefixed with a type_then the fields will be returned with a type prefix.;public Collection<String> simpleMatchToFullName(String pattern) {_        if (Regex.isSimpleMatchPattern(pattern) == false) {_            _            return Collections.singletonList(pattern)__        }_        return fieldTypes.simpleMatchToFullName(pattern)__    };returns,all,the,fields,that,match,the,given,pattern,if,the,pattern,is,prefixed,with,a,type,then,the,fields,will,be,returned,with,a,type,prefix;public,collection,string,simple,match,to,full,name,string,pattern,if,regex,is,simple,match,pattern,pattern,false,return,collections,singleton,list,pattern,return,field,types,simple,match,to,full,name,pattern
MapperService -> public Collection<String> simpleMatchToFullName(String pattern);1542899326;Returns all the fields that match the given pattern. If the pattern is prefixed with a type_then the fields will be returned with a type prefix.;public Collection<String> simpleMatchToFullName(String pattern) {_        if (Regex.isSimpleMatchPattern(pattern) == false) {_            _            return Collections.singletonList(pattern)__        }_        return fieldTypes.simpleMatchToFullName(pattern)__    };returns,all,the,fields,that,match,the,given,pattern,if,the,pattern,is,prefixed,with,a,type,then,the,fields,will,be,returned,with,a,type,prefix;public,collection,string,simple,match,to,full,name,string,pattern,if,regex,is,simple,match,pattern,pattern,false,return,collections,singleton,list,pattern,return,field,types,simple,match,to,full,name,pattern
MapperService -> public Collection<String> simpleMatchToFullName(String pattern);1543947737;Returns all the fields that match the given pattern. If the pattern is prefixed with a type_then the fields will be returned with a type prefix.;public Collection<String> simpleMatchToFullName(String pattern) {_        if (Regex.isSimpleMatchPattern(pattern) == false) {_            _            return Collections.singletonList(pattern)__        }_        return fieldTypes.simpleMatchToFullName(pattern)__    };returns,all,the,fields,that,match,the,given,pattern,if,the,pattern,is,prefixed,with,a,type,then,the,fields,will,be,returned,with,a,type,prefix;public,collection,string,simple,match,to,full,name,string,pattern,if,regex,is,simple,match,pattern,pattern,false,return,collections,singleton,list,pattern,return,field,types,simple,match,to,full,name,pattern
MapperService -> public Collection<String> simpleMatchToFullName(String pattern);1545126194;Returns all the fields that match the given pattern. If the pattern is prefixed with a type_then the fields will be returned with a type prefix.;public Collection<String> simpleMatchToFullName(String pattern) {_        if (Regex.isSimpleMatchPattern(pattern) == false) {_            _            return Collections.singletonList(pattern)__        }_        return fieldTypes.simpleMatchToFullName(pattern)__    };returns,all,the,fields,that,match,the,given,pattern,if,the,pattern,is,prefixed,with,a,type,then,the,fields,will,be,returned,with,a,type,prefix;public,collection,string,simple,match,to,full,name,string,pattern,if,regex,is,simple,match,pattern,pattern,false,return,collections,singleton,list,pattern,return,field,types,simple,match,to,full,name,pattern
MapperService -> public Collection<String> simpleMatchToFullName(String pattern);1547566367;Returns all the fields that match the given pattern. If the pattern is prefixed with a type_then the fields will be returned with a type prefix.;public Collection<String> simpleMatchToFullName(String pattern) {_        if (Regex.isSimpleMatchPattern(pattern) == false) {_            _            return Collections.singletonList(pattern)__        }_        return fieldTypes.simpleMatchToFullName(pattern)__    };returns,all,the,fields,that,match,the,given,pattern,if,the,pattern,is,prefixed,with,a,type,then,the,fields,will,be,returned,with,a,type,prefix;public,collection,string,simple,match,to,full,name,string,pattern,if,regex,is,simple,match,pattern,pattern,false,return,collections,singleton,list,pattern,return,field,types,simple,match,to,full,name,pattern
MapperService -> public Collection<String> simpleMatchToFullName(String pattern);1549392752;Returns all the fields that match the given pattern. If the pattern is prefixed with a type_then the fields will be returned with a type prefix.;public Collection<String> simpleMatchToFullName(String pattern) {_        if (Regex.isSimpleMatchPattern(pattern) == false) {_            _            return Collections.singletonList(pattern)__        }_        return fieldTypes.simpleMatchToFullName(pattern)__    };returns,all,the,fields,that,match,the,given,pattern,if,the,pattern,is,prefixed,with,a,type,then,the,fields,will,be,returned,with,a,type,prefix;public,collection,string,simple,match,to,full,name,string,pattern,if,regex,is,simple,match,pattern,pattern,false,return,collections,singleton,list,pattern,return,field,types,simple,match,to,full,name,pattern
