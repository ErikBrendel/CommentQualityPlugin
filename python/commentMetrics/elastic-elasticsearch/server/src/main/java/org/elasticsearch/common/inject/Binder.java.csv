commented;modifiers;parameterAmount;loc;comment;code
true;;2;1;/**  * Binds a scope to an annotation.  */ ;/**  * Binds a scope to an annotation.  */ void bindScope(Class<? extends Annotation> annotationType, Scope scope).
true;;1;1;/**  * See the EDSL examples at {@link Binder}.  */ ;/**  * See the EDSL examples at {@link Binder}.  */ <T> LinkedBindingBuilder<T> bind(Key<T> key).
true;;1;1;/**  * See the EDSL examples at {@link Binder}.  */ ;/**  * See the EDSL examples at {@link Binder}.  */ <T> AnnotatedBindingBuilder<T> bind(TypeLiteral<T> typeLiteral).
true;;1;1;/**  * See the EDSL examples at {@link Binder}.  */ ;/**  * See the EDSL examples at {@link Binder}.  */ <T> AnnotatedBindingBuilder<T> bind(Class<T> type).
true;;0;1;/**  * See the EDSL examples at {@link Binder}.  */ ;/**  * See the EDSL examples at {@link Binder}.  */ AnnotatedConstantBindingBuilder bindConstant().
true;;2;1;/**  * Upon successful creation, the {@link Injector} will inject instance fields  * and methods of the given object.  *  * @param type     of instance  * @param instance for which members will be injected  * @since 2.0  */ ;/**  * Upon successful creation, the {@link Injector} will inject instance fields  * and methods of the given object.  *  * @param type     of instance  * @param instance for which members will be injected  * @since 2.0  */ <T> void requestInjection(TypeLiteral<T> type, T instance).
true;;1;1;/**  * Upon successful creation, the {@link Injector} will inject instance fields  * and methods of the given object.  *  * @param instance for which members will be injected  * @since 2.0  */ ;/**  * Upon successful creation, the {@link Injector} will inject instance fields  * and methods of the given object.  *  * @param instance for which members will be injected  * @since 2.0  */ void requestInjection(Object instance).
true;;1;1;/**  * Upon successful creation, the {@link Injector} will inject static fields  * and methods in the given classes.  *  * @param types for which static members will be injected  */ ;/**  * Upon successful creation, the {@link Injector} will inject static fields  * and methods in the given classes.  *  * @param types for which static members will be injected  */ void requestStaticInjection(Class<?>... types).
true;;1;1;/**  * Uses the given module to configure more bindings.  */ ;/**  * Uses the given module to configure more bindings.  */ void install(Module module).
true;;0;1;/**  * Gets the current stage.  */ ;/**  * Gets the current stage.  */ Stage currentStage().
true;;2;1;/**  * Records an error message which will be presented to the user at a later  * time. Unlike throwing an exception, this enable us to continue  * configuring the Injector and discover more errors. Uses {@link  * String#format(String, Object[])} to insert the arguments into the  * message.  */ ;/**  * Records an error message which will be presented to the user at a later  * time. Unlike throwing an exception, this enable us to continue  * configuring the Injector and discover more errors. Uses {@link  * String#format(String, Object[])} to insert the arguments into the  * message.  */ void addError(String message, Object... arguments).
true;;1;1;/**  * Records an exception, the full details of which will be logged, and the  * message of which will be presented to the user at a later  * time. If your Module calls something that you worry may fail, you should  * catch the exception and pass it into this.  */ ;/**  * Records an exception, the full details of which will be logged, and the  * message of which will be presented to the user at a later  * time. If your Module calls something that you worry may fail, you should  * catch the exception and pass it into this.  */ void addError(Throwable t).
true;;1;1;/**  * Records an error message to be presented to the user at a later time.  *  * @since 2.0  */ ;/**  * Records an error message to be presented to the user at a later time.  *  * @since 2.0  */ void addError(Message message).
true;;1;1;/**  * Returns the provider used to obtain instances for the given injection key.  * The returned will not be valid until the {@link Injector} has been  * created. The provider will throw an {@code IllegalStateException} if you  * try to use it beforehand.  *  * @since 2.0  */ ;/**  * Returns the provider used to obtain instances for the given injection key.  * The returned will not be valid until the {@link Injector} has been  * created. The provider will throw an {@code IllegalStateException} if you  * try to use it beforehand.  *  * @since 2.0  */ <T> Provider<T> getProvider(Key<T> key).
true;;1;1;/**  * Returns the provider used to obtain instances for the given injection type.  * The returned provider will not be valid until the {@link Injector} has been  * created. The provider will throw an {@code IllegalStateException} if you  * try to use it beforehand.  *  * @since 2.0  */ ;/**  * Returns the provider used to obtain instances for the given injection type.  * The returned provider will not be valid until the {@link Injector} has been  * created. The provider will throw an {@code IllegalStateException} if you  * try to use it beforehand.  *  * @since 2.0  */ <T> Provider<T> getProvider(Class<T> type).
true;;1;1;/**  * Returns the members injector used to inject dependencies into methods and fields on instances  * of the given type {@code T}. The returned members injector will not be valid until the main  * {@link Injector} has been created. The members injector will throw an {@code  * IllegalStateException} if you try to use it beforehand.  *  * @param typeLiteral type to get members injector for  * @since 2.0  */ ;/**  * Returns the members injector used to inject dependencies into methods and fields on instances  * of the given type {@code T}. The returned members injector will not be valid until the main  * {@link Injector} has been created. The members injector will throw an {@code  * IllegalStateException} if you try to use it beforehand.  *  * @param typeLiteral type to get members injector for  * @since 2.0  */ <T> MembersInjector<T> getMembersInjector(TypeLiteral<T> typeLiteral).
true;;1;1;/**  * Returns the members injector used to inject dependencies into methods and fields on instances  * of the given type {@code T}. The returned members injector will not be valid until the main  * {@link Injector} has been created. The members injector will throw an {@code  * IllegalStateException} if you try to use it beforehand.  *  * @param type type to get members injector for  * @since 2.0  */ ;/**  * Returns the members injector used to inject dependencies into methods and fields on instances  * of the given type {@code T}. The returned members injector will not be valid until the main  * {@link Injector} has been created. The members injector will throw an {@code  * IllegalStateException} if you try to use it beforehand.  *  * @param type type to get members injector for  * @since 2.0  */ <T> MembersInjector<T> getMembersInjector(Class<T> type).
true;;2;2;/**  * Binds a type converter. The injector will use the given converter to  * convert string constants to matching types as needed.  *  * @param typeMatcher matches types the converter can handle  * @param converter   converts values  * @since 2.0  */ ;/**  * Binds a type converter. The injector will use the given converter to  * convert string constants to matching types as needed.  *  * @param typeMatcher matches types the converter can handle  * @param converter   converts values  * @since 2.0  */ void convertToTypes(Matcher<? super TypeLiteral<?>> typeMatcher, TypeConverter converter).
true;;2;2;/**  * Registers a listener for injectable types. Guice will notify the listener when it encounters  * injectable types matched by the given type matcher.  *  * @param typeMatcher that matches injectable types the listener should be notified of  * @param listener    for injectable types matched by typeMatcher  * @since 2.0  */ ;/**  * Registers a listener for injectable types. Guice will notify the listener when it encounters  * injectable types matched by the given type matcher.  *  * @param typeMatcher that matches injectable types the listener should be notified of  * @param listener    for injectable types matched by typeMatcher  * @since 2.0  */ void bindListener(Matcher<? super TypeLiteral<?>> typeMatcher, TypeListener listener).
true;;1;1;/**  * Returns a binder that uses {@code source} as the reference location for  * configuration errors. This is typically a {@link StackTraceElement}  * for {@code .java} source but it could any binding source, such as the  * path to a {@code .properties} file.  *  * @param source any object representing the source location and has a  *               concise {@link Object#toString() toString()} value  * @return a binder that shares its configuration with this binder  * @since 2.0  */ ;/**  * Returns a binder that uses {@code source} as the reference location for  * configuration errors. This is typically a {@link StackTraceElement}  * for {@code .java} source but it could any binding source, such as the  * path to a {@code .properties} file.  *  * @param source any object representing the source location and has a  *               concise {@link Object#toString() toString()} value  * @return a binder that shares its configuration with this binder  * @since 2.0  */ Binder withSource(Object source).
true;;1;1;/**  * Returns a binder that skips {@code classesToSkip} when identify the  * calling code. The caller's {@link StackTraceElement} is used to locate  * the source of configuration errors.  *  * @param classesToSkip library classes that create bindings on behalf of  *                      their clients.  * @return a binder that shares its configuration with this binder.  * @since 2.0  */ ;/**  * Returns a binder that skips {@code classesToSkip} when identify the  * calling code. The caller's {@link StackTraceElement} is used to locate  * the source of configuration errors.  *  * @param classesToSkip library classes that create bindings on behalf of  *                      their clients.  * @return a binder that shares its configuration with this binder.  * @since 2.0  */ Binder skipSources(Class<?>... classesToSkip).
true;;0;1;/**  * Creates a new private child environment for bindings and other configuration. The returned  * binder can be used to add and configuration information in this environment. See {@link  * PrivateModule} for details.  *  * @return a binder that inherits configuration from this binder. Only exposed configuration on  *         the returned binder will be visible to this binder.  * @since 2.0  */ ;/**  * Creates a new private child environment for bindings and other configuration. The returned  * binder can be used to add and configuration information in this environment. See {@link  * PrivateModule} for details.  *  * @return a binder that inherits configuration from this binder. Only exposed configuration on  *         the returned binder will be visible to this binder.  * @since 2.0  */ PrivateBinder newPrivateBinder().
