commented;modifiers;parameterAmount;loc;comment;code
true;protected,static;2;13;/**  * Syncs operation result to the translog or throws a shard not available failure  */ ;/**  * Syncs operation result to the translog or throws a shard not available failure  */ protected static Location syncOperationResultOrThrow(final Engine.Result operationResult, final Location currentLocation) throws Exception {     final Location location.     if (operationResult.getFailure() != null) {         // check if any transient write operation failures should be bubbled up         Exception failure = operationResult.getFailure().         assert failure instanceof MapperParsingException : "expected mapper parsing failures. got " + failure.         throw failure.     } else {         location = locationToSync(currentLocation, operationResult.getTranslogLocation()).     }     return location. }
false;public,static;2;11;;public static Location locationToSync(Location current, Location next) {     /* here we are moving forward in the translog with each operation. Under the hood this might          * cross translog files which is ok since from the user perspective the translog is like a          * tape where only the highest location needs to be fsynced in order to sync all previous          * locations even though they are not in the same file. When the translog rolls over files          * the previous file is fsynced on after closing if needed.*/     assert next != null : "next operation can't be null".     assert current == null || current.compareTo(next) < 0 : "translog locations are not increasing".     return next. }
false;protected;1;4;;@Override protected ReplicationOperation.Replicas newReplicasProxy(long primaryTerm) {     return new WriteActionReplicasProxy(primaryTerm). }
true;protected,abstract;2;3;/**  * Called on the primary with a reference to the primary {@linkplain IndexShard} to modify.  *  * @return the result of the operation on primary, including current translog location and operation response and failure  * async refresh is performed on the <code>primary</code> shard according to the <code>Request</code> refresh policy  */ ;/**  * Called on the primary with a reference to the primary {@linkplain IndexShard} to modify.  *  * @return the result of the operation on primary, including current translog location and operation response and failure  * async refresh is performed on the <code>primary</code> shard according to the <code>Request</code> refresh policy  */ @Override protected abstract WritePrimaryResult<ReplicaRequest, Response> shardOperationOnPrimary(Request request, IndexShard primary) throws Exception.
true;protected,abstract;2;3;/**  * Called once per replica with a reference to the replica {@linkplain IndexShard} to modify.  *  * @return the result of the operation on replica, including current translog location and operation response and failure  * async refresh is performed on the <code>replica</code> shard according to the <code>ReplicaRequest</code> refresh policy  */ ;/**  * Called once per replica with a reference to the replica {@linkplain IndexShard} to modify.  *  * @return the result of the operation on replica, including current translog location and operation response and failure  * async refresh is performed on the <code>replica</code> shard according to the <code>ReplicaRequest</code> refresh policy  */ @Override protected abstract WriteReplicaResult<ReplicaRequest> shardOperationOnReplica(ReplicaRequest request, IndexShard replica) throws Exception.
false;public,synchronized;1;5;;@Override public synchronized void respond(ActionListener<Response> listener) {     this.listener = listener.     respondIfPossible(null). }
true;protected;1;10;/**  * Respond if the refresh has occurred and the listener is ready. Always called while synchronized on {@code this}.  */ ;/**  * Respond if the refresh has occurred and the listener is ready. Always called while synchronized on {@code this}.  */ protected void respondIfPossible(Exception ex) {     assert Thread.holdsLock(this).     if (finishedAsyncActions && listener != null) {         if (ex == null) {             super.respond(listener).         } else {             listener.onFailure(ex).         }     } }
false;public,synchronized;1;4;;public synchronized void onFailure(Exception exception) {     finishedAsyncActions = true.     respondIfPossible(exception). }
false;public,synchronized;1;6;;@Override public synchronized void onSuccess(boolean forcedRefresh) {     finalResponseIfSuccessful.setForcedRefresh(forcedRefresh).     finishedAsyncActions = true.     respondIfPossible(null). }
false;public,synchronized;1;5;;@Override public synchronized void respond(ActionListener<TransportResponse.Empty> listener) {     this.listener = listener.     respondIfPossible(null). }
true;protected;1;10;/**  * Respond if the refresh has occurred and the listener is ready. Always called while synchronized on {@code this}.  */ ;/**  * Respond if the refresh has occurred and the listener is ready. Always called while synchronized on {@code this}.  */ protected void respondIfPossible(Exception ex) {     assert Thread.holdsLock(this).     if (finishedAsyncActions && listener != null) {         if (ex == null) {             super.respond(listener).         } else {             listener.onFailure(ex).         }     } }
false;public,synchronized;1;5;;@Override public synchronized void onFailure(Exception ex) {     finishedAsyncActions = true.     respondIfPossible(ex). }
false;public,synchronized;1;5;;@Override public synchronized void onSuccess(boolean forcedRefresh) {     finishedAsyncActions = true.     respondIfPossible(null). }
false;protected;0;4;;@Override protected ClusterBlockLevel globalBlockLevel() {     return ClusterBlockLevel.WRITE. }
false;public;0;4;;@Override public ClusterBlockLevel indexBlockLevel() {     return ClusterBlockLevel.WRITE. }
true;;1;1;/**  * Called on successful processing of all post write actions  * @param forcedRefresh <code>true</code> iff this write has caused a refresh  */ ;/**  * Called on successful processing of all post write actions  * @param forcedRefresh <code>true</code> iff this write has caused a refresh  */ void onSuccess(boolean forcedRefresh).
true;;1;1;/**  * Called on failure if a post action failed.  */ ;/**  * Called on failure if a post action failed.  */ void onFailure(Exception ex).
true;private;0;11;/**  * calls the response listener if all pending operations have returned otherwise it just decrements the pending opts counter.  */ ;/**  * calls the response listener if all pending operations have returned otherwise it just decrements the pending opts counter.  */ private void maybeFinish() {     final int numPending = pendingOps.decrementAndGet().     if (numPending == 0) {         if (syncFailure.get() != null) {             respond.onFailure(syncFailure.get()).         } else {             respond.onSuccess(refreshed.get()).         }     }     assert numPending >= 0 && numPending <= 2 : "numPending must either 2, 1 or 0 but was " + numPending. }
false;;0;29;;void run() {     /*              * We either respond immediately (i.e., if we do not fsync per request or wait for              * refresh), or we there are past async operations and we wait for them to return to              * respond.              */     indexShard.afterWriteOperation().     // decrement pending by one, if there is nothing else to do we just respond with success     maybeFinish().     if (waitUntilRefresh) {         assert pendingOps.get() > 0.         indexShard.addRefreshListener(location, forcedRefresh -> {             if (forcedRefresh) {                 logger.warn("block until refresh ran out of slots and forced a refresh: [{}]", request).             }             refreshed.set(forcedRefresh).             maybeFinish().         }).     }     if (sync) {         assert pendingOps.get() > 0.         indexShard.sync(location, (ex) -> {             syncFailure.set(ex).             maybeFinish().         }).     } }
false;public;6;9;;@Override public void failShardIfNeeded(ShardRouting replica, String message, Exception exception, Runnable onSuccess, Consumer<Exception> onPrimaryDemoted, Consumer<Exception> onIgnoredFailure) {     if (TransportActions.isShardNotAvailableException(exception) == false) {         logger.warn(new ParameterizedMessage("[{}] {}", replica.shardId(), message), exception).     }     shardStateAction.remoteShardFailed(replica.shardId(), replica.allocationId().getId(), primaryTerm, true, message, exception, createShardActionListener(onSuccess, onPrimaryDemoted, onIgnoredFailure)). }
false;public;5;6;;@Override public void markShardCopyAsStaleIfNeeded(ShardId shardId, String allocationId, Runnable onSuccess, Consumer<Exception> onPrimaryDemoted, Consumer<Exception> onIgnoredFailure) {     shardStateAction.remoteShardFailed(shardId, allocationId, primaryTerm, true, "mark copy as stale", null, createShardActionListener(onSuccess, onPrimaryDemoted, onIgnoredFailure)). }
