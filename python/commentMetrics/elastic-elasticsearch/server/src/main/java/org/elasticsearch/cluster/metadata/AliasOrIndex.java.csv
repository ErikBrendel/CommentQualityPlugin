commented;modifiers;parameterAmount;loc;comment;code
true;;0;1;/**  * @return whether this an alias or concrete index  */ ;/**  * @return whether this an alias or concrete index  */ boolean isAlias().
true;;0;1;/**  * @return All {@link IndexMetaData} of all concrete indices this alias is referring to  * or if this is a concrete index its {@link IndexMetaData}  */ ;/**  * @return All {@link IndexMetaData} of all concrete indices this alias is referring to  * or if this is a concrete index its {@link IndexMetaData}  */ List<IndexMetaData> getIndices().
false;public;0;4;;@Override public boolean isAlias() {     return false. }
false;public;0;4;;@Override public List<IndexMetaData> getIndices() {     return Collections.singletonList(concreteIndex). }
false;public;0;4;;@Override public boolean isAlias() {     return true. }
false;public;0;3;;public String getAliasName() {     return aliasName. }
false;public;0;4;;@Override public List<IndexMetaData> getIndices() {     return referenceIndexMetaDatas. }
false;public;0;4;;@Nullable public IndexMetaData getWriteIndex() {     return writeIndex.get(). }
false;public;0;4;;@Override public boolean hasNext() {     return index < referenceIndexMetaDatas.size(). }
false;public;0;5;;@Override public Tuple<String, AliasMetaData> next() {     IndexMetaData indexMetaData = referenceIndexMetaDatas.get(index++).     return new Tuple<>(indexMetaData.getIndex().getName(), indexMetaData.getAliases().get(aliasName)). }
true;public;0;17;/**  * Returns the unique alias metadata per concrete index.  *  * (note that although alias can point to the same concrete indices, each alias reference may have its own routing  * and filters)  */ ;/**  * Returns the unique alias metadata per concrete index.  *  * (note that although alias can point to the same concrete indices, each alias reference may have its own routing  * and filters)  */ public Iterable<Tuple<String, AliasMetaData>> getConcreteIndexAndAliasMetaDatas() {     return () -> new Iterator<Tuple<String, AliasMetaData>>() {          int index = 0.          @Override         public boolean hasNext() {             return index < referenceIndexMetaDatas.size().         }          @Override         public Tuple<String, AliasMetaData> next() {             IndexMetaData indexMetaData = referenceIndexMetaDatas.get(index++).             return new Tuple<>(indexMetaData.getIndex().getName(), indexMetaData.getAliases().get(aliasName)).         }     }. }
false;public;0;3;;public AliasMetaData getFirstAliasMetaData() {     return referenceIndexMetaDatas.get(0).getAliases().get(aliasName). }
false;;1;3;;void addIndex(IndexMetaData indexMetaData) {     this.referenceIndexMetaDatas.add(indexMetaData). }
false;public;0;19;;public void computeAndValidateWriteIndex() {     List<IndexMetaData> writeIndices = referenceIndexMetaDatas.stream().filter(idxMeta -> Boolean.TRUE.equals(idxMeta.getAliases().get(aliasName).writeIndex())).collect(Collectors.toList()).     if (writeIndices.isEmpty() && referenceIndexMetaDatas.size() == 1 && referenceIndexMetaDatas.get(0).getAliases().get(aliasName).writeIndex() == null) {         writeIndices.add(referenceIndexMetaDatas.get(0)).     }     if (writeIndices.size() == 1) {         writeIndex.set(writeIndices.get(0)).     } else if (writeIndices.size() > 1) {         List<String> writeIndicesStrings = writeIndices.stream().map(i -> i.getIndex().getName()).collect(Collectors.toList()).         throw new IllegalStateException("alias [" + aliasName + "] has more than one write index [" + Strings.collectionToCommaDelimitedString(writeIndicesStrings) + "]").     } }
