commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;8;;@Override protected void doWriteTo(StreamOutput out) throws IOException {     if (out.getVersion().onOrAfter(Version.V_6_3_0)) {         out.writeString(type).     } else {         out.writeBytesRef(new BytesRef(type)).     } }
false;public;0;3;;public String type() {     return type. }
false;protected;2;7;;@Override protected void doXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject(NAME).     builder.field(VALUE_FIELD.getPreferredName(), type).     printBoostAndQueryName(builder).     builder.endObject(). }
false;public,static;1;34;;public static TypeQueryBuilder fromXContent(XContentParser parser) throws IOException {     String type = null.     String queryName = null.     float boost = AbstractQueryBuilder.DEFAULT_BOOST.     String currentFieldName = null.     XContentParser.Token token.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (token.isValue()) {             if (AbstractQueryBuilder.NAME_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 queryName = parser.text().             } else if (AbstractQueryBuilder.BOOST_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 boost = parser.floatValue().             } else if (VALUE_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 type = parser.text().             } else {                 throw new ParsingException(parser.getTokenLocation(), "[" + TypeQueryBuilder.NAME + "] filter doesn't support [" + currentFieldName + "]").             }         } else {             throw new ParsingException(parser.getTokenLocation(), "[" + TypeQueryBuilder.NAME + "] filter doesn't support [" + currentFieldName + "]").         }     }     if (type == null) {         throw new ParsingException(parser.getTokenLocation(), "[" + TypeQueryBuilder.NAME + "] filter needs to be provided with a value for the type").     }     return new TypeQueryBuilder(type).boost(boost).queryName(queryName). }
false;public;0;4;;@Override public String getWriteableName() {     return NAME. }
false;protected;1;12;;@Override protected Query doToQuery(QueryShardContext context) throws IOException {     deprecationLogger.deprecatedAndMaybeLog("type_query", TYPES_DEPRECATION_MESSAGE).     // LUCENE 4 UPGRADE document mapper should use bytesref as well?     DocumentMapper documentMapper = context.getMapperService().documentMapper(type).     if (documentMapper == null) {         // no type means no documents         return new MatchNoDocsQuery().     } else {         return documentMapper.typeFilter(context).     } }
false;protected;0;4;;@Override protected int doHashCode() {     return Objects.hash(type). }
false;protected;1;4;;@Override protected boolean doEquals(TypeQueryBuilder other) {     return Objects.equals(type, other.type). }
