commented;modifiers;parameterAmount;loc;comment;code
false;protected;3;4;;@Override protected void doExecute(Task task, Request request, ActionListener<Response> listener) {     new AsyncBroadcastAction(task, request, listener).start(). }
false;protected,abstract;3;1;;protected abstract Response newResponse(Request request, AtomicReferenceArray shardsResponses, ClusterState clusterState).
false;protected,abstract;3;1;;protected abstract ShardRequest newShardRequest(int numShards, ShardRouting shard, Request request).
false;protected,abstract;0;1;;protected abstract ShardResponse newShardResponse().
false;protected,abstract;2;1;;protected abstract ShardResponse shardOperation(ShardRequest request, Task task) throws IOException.
true;protected,abstract;3;1;/**  * Determines the shards this operation will be executed on. The operation is executed once per shard iterator, typically  * on the first shard in it. If the operation fails, it will be retried on the next shard in the iterator.  */ ;/**  * Determines the shards this operation will be executed on. The operation is executed once per shard iterator, typically  * on the first shard in it. If the operation fails, it will be retried on the next shard in the iterator.  */ protected abstract GroupShardsIterator<ShardIterator> shards(ClusterState clusterState, Request request, String[] concreteIndices).
false;protected,abstract;2;1;;protected abstract ClusterBlockException checkGlobalBlock(ClusterState state, Request request).
false;protected,abstract;3;1;;protected abstract ClusterBlockException checkRequestBlock(ClusterState state, Request request, String[] concreteIndices).
false;public;0;23;;public void start() {     if (shardsIts.size() == 0) {         // no shards         try {             listener.onResponse(newResponse(request, new AtomicReferenceArray(0), clusterState)).         } catch (Exception e) {             listener.onFailure(e).         }         return.     }     // count the local operations, and perform the non local ones     int shardIndex = -1.     for (final ShardIterator shardIt : shardsIts) {         shardIndex++.         final ShardRouting shard = shardIt.nextOrNull().         if (shard != null) {             performOperation(shardIt, shard, shardIndex).         } else {             // really, no shards active in this group             onOperation(null, shardIt, shardIndex, new NoShardAvailableActionException(shardIt.shardId())).         }     } }
false;public;1;6;;@Override public ShardResponse read(StreamInput in) throws IOException {     ShardResponse response = newShardResponse().     response.readFrom(in).     return response. }
false;public;0;4;;@Override public String executor() {     return ThreadPool.Names.SAME. }
false;public;1;4;;@Override public void handleResponse(ShardResponse response) {     onOperation(shard, shardIndex, response). }
false;public;1;4;;@Override public void handleException(TransportException e) {     onOperation(shard, shardIt, shardIndex, e). }
false;protected;3;43;;protected void performOperation(final ShardIterator shardIt, final ShardRouting shard, final int shardIndex) {     if (shard == null) {         // no more active shards... (we should not really get here, just safety)         onOperation(null, shardIt, shardIndex, new NoShardAvailableActionException(shardIt.shardId())).     } else {         try {             final ShardRequest shardRequest = newShardRequest(shardIt.size(), shard, request).             shardRequest.setParentTask(clusterService.localNode().getId(), task.getId()).             DiscoveryNode node = nodes.get(shard.currentNodeId()).             if (node == null) {                 // no node connected, act as failure                 onOperation(shard, shardIt, shardIndex, new NoShardAvailableActionException(shardIt.shardId())).             } else {                 transportService.sendRequest(node, transportShardAction, shardRequest, new TransportResponseHandler<ShardResponse>() {                      @Override                     public ShardResponse read(StreamInput in) throws IOException {                         ShardResponse response = newShardResponse().                         response.readFrom(in).                         return response.                     }                      @Override                     public String executor() {                         return ThreadPool.Names.SAME.                     }                      @Override                     public void handleResponse(ShardResponse response) {                         onOperation(shard, shardIndex, response).                     }                      @Override                     public void handleException(TransportException e) {                         onOperation(shard, shardIt, shardIndex, e).                     }                 }).             }         } catch (Exception e) {             onOperation(shard, shardIt, shardIndex, e).         }     } }
false;protected;3;8;;@SuppressWarnings({ "unchecked" }) protected void onOperation(ShardRouting shard, int shardIndex, ShardResponse response) {     logger.trace("received response for {}", shard).     shardsResponses.set(shardIndex, response).     if (expectedOps == counterOps.incrementAndGet()) {         finishHim().     } }
false;;4;29;;void onOperation(@Nullable ShardRouting shard, final ShardIterator shardIt, int shardIndex, Exception e) {     // we set the shard failure always, even if its the first in the replication group, and the next one     // will work (it will just override it...)     setFailure(shardIt, shardIndex, e).     ShardRouting nextShard = shardIt.nextOrNull().     if (nextShard != null) {         if (e != null) {             if (logger.isTraceEnabled()) {                 if (!TransportActions.isShardNotAvailableException(e)) {                     logger.trace(new ParameterizedMessage("{}: failed to execute [{}]", shard != null ? shard.shortSummary() : shardIt.shardId(), request), e).                 }             }         }         performOperation(shardIt, nextShard, shardIndex).     } else {         if (logger.isDebugEnabled()) {             if (e != null) {                 if (!TransportActions.isShardNotAvailableException(e)) {                     logger.debug(new ParameterizedMessage("{}: failed to execute [{}]", shard != null ? shard.shortSummary() : shardIt.shardId(), request), e).                 }             }         }         if (expectedOps == counterOps.incrementAndGet()) {             finishHim().         }     } }
false;protected;0;7;;protected void finishHim() {     try {         listener.onResponse(newResponse(request, shardsResponses, clusterState)).     } catch (Exception e) {         listener.onFailure(e).     } }
false;;3;27;;void setFailure(ShardIterator shardIt, int shardIndex, Exception e) {     // we don't aggregate shard failures on non active shards (but do keep the header counts right)     if (TransportActions.isShardNotAvailableException(e)) {         return.     }     if (!(e instanceof BroadcastShardOperationFailedException)) {         e = new BroadcastShardOperationFailedException(shardIt.shardId(), e).     }     Object response = shardsResponses.get(shardIndex).     if (response == null) {         // just override it and return         shardsResponses.set(shardIndex, e).     }     if (!(response instanceof Throwable)) {         // we should never really get here...         return.     }     // for example, getting illegal shard state     if (TransportActions.isReadOverrideException(e)) {         shardsResponses.set(shardIndex, e).     } }
false;public;1;8;;@Override public void onResponse(ShardResponse response) {     try {         channel.sendResponse(response).     } catch (Exception e) {         onFailure(e).     } }
false;public;1;9;;@Override public void onFailure(Exception e) {     try {         channel.sendResponse(e).     } catch (Exception e1) {         logger.warn(() -> new ParameterizedMessage("Failed to send error response for action [{}] and request [{}]", actionName, request), e1).     } }
false;public;3;23;;@Override public void messageReceived(ShardRequest request, TransportChannel channel, Task task) throws Exception {     asyncShardOperation(request, task, new ActionListener<ShardResponse>() {          @Override         public void onResponse(ShardResponse response) {             try {                 channel.sendResponse(response).             } catch (Exception e) {                 onFailure(e).             }         }          @Override         public void onFailure(Exception e) {             try {                 channel.sendResponse(e).             } catch (Exception e1) {                 logger.warn(() -> new ParameterizedMessage("Failed to send error response for action [{}] and request [{}]", actionName, request), e1).             }         }     }). }
false;public;1;4;;@Override public void onFailure(Exception e) {     listener.onFailure(e). }
false;protected;0;4;;@Override protected void doRun() throws Exception {     listener.onResponse(shardOperation(request, task)). }
false;protected;3;13;;protected void asyncShardOperation(ShardRequest request, Task task, ActionListener<ShardResponse> listener) {     transportService.getThreadPool().executor(getExecutor(request)).execute(new AbstractRunnable() {          @Override         public void onFailure(Exception e) {             listener.onFailure(e).         }          @Override         protected void doRun() throws Exception {             listener.onResponse(shardOperation(request, task)).         }     }). }
false;protected;1;3;;protected String getExecutor(ShardRequest request) {     return shardExecutor. }
