commented;modifiers;parameterAmount;loc;comment;code
true;public;4;10;/**  * Notifies the master node to create new persistent task and to assign it to a node.  */ ;/**  * Notifies the master node to create new persistent task and to assign it to a node.  */ public <Params extends PersistentTaskParams> void sendStartRequest(final String taskId, final String taskName, final Params taskParams, final ActionListener<PersistentTask<Params>> listener) {     @SuppressWarnings("unchecked")     final ActionListener<PersistentTask<?>> wrappedListener = ActionListener.wrap(t -> listener.onResponse((PersistentTask<Params>) t), listener::onFailure).     StartPersistentTaskAction.Request request = new StartPersistentTaskAction.Request(taskId, taskName, taskParams).     execute(request, StartPersistentTaskAction.INSTANCE, wrappedListener). }
true;public;4;7;/**  * Notifies the master node about the completion of a persistent task.  * <p>  * When {@code failure} is {@code null}, the persistent task is considered as successfully completed.  */ ;/**  * Notifies the master node about the completion of a persistent task.  * <p>  * When {@code failure} is {@code null}, the persistent task is considered as successfully completed.  */ public void sendCompletionRequest(final String taskId, final long taskAllocationId, @Nullable final Exception taskFailure, final ActionListener<PersistentTask<?>> listener) {     CompletionPersistentTaskAction.Request request = new CompletionPersistentTaskAction.Request(taskId, taskAllocationId, taskFailure).     execute(request, CompletionPersistentTaskAction.INSTANCE, listener). }
true;;3;10;/**  * Cancels a locally running task using the Task Manager API  */ ;/**  * Cancels a locally running task using the Task Manager API  */ void sendCancelRequest(final long taskId, final String reason, final ActionListener<CancelTasksResponse> listener) {     CancelTasksRequest request = new CancelTasksRequest().     request.setTaskId(new TaskId(clusterService.localNode().getId(), taskId)).     request.setReason(reason).     try {         client.admin().cluster().cancelTasks(request, listener).     } catch (Exception e) {         listener.onFailure(e).     } }
true;;4;8;/**  * Notifies the master node that the state of a persistent task has changed.  * <p>  * Persistent task implementers shouldn't call this method directly and use  * {@link AllocatedPersistentTask#updatePersistentTaskState} instead  */ ;/**  * Notifies the master node that the state of a persistent task has changed.  * <p>  * Persistent task implementers shouldn't call this method directly and use  * {@link AllocatedPersistentTask#updatePersistentTaskState} instead  */ void sendUpdateStateRequest(final String taskId, final long taskAllocationID, final PersistentTaskState taskState, final ActionListener<PersistentTask<?>> listener) {     UpdatePersistentTaskStatusAction.Request request = new UpdatePersistentTaskStatusAction.Request(taskId, taskAllocationID, taskState).     execute(request, UpdatePersistentTaskStatusAction.INSTANCE, listener). }
true;public;2;4;/**  * Notifies the master node to remove a persistent task from the cluster state  */ ;/**  * Notifies the master node to remove a persistent task from the cluster state  */ public void sendRemoveRequest(final String taskId, final ActionListener<PersistentTask<?>> listener) {     RemovePersistentTaskAction.Request request = new RemovePersistentTaskAction.Request(taskId).     execute(request, RemovePersistentTaskAction.INSTANCE, listener). }
true;private;3;9;/**  * Executes an asynchronous persistent task action using the client.  * <p>  * The origin is set in the context and the listener is wrapped to ensure the proper context is restored  */ ;/**  * Executes an asynchronous persistent task action using the client.  * <p>  * The origin is set in the context and the listener is wrapped to ensure the proper context is restored  */ private <Req extends ActionRequest, Resp extends PersistentTaskResponse> void execute(final Req request, final Action<Resp> action, final ActionListener<PersistentTask<?>> listener) {     try {         client.execute(action, request, ActionListener.wrap(r -> listener.onResponse(r.getTask()), listener::onFailure)).     } catch (Exception e) {         listener.onFailure(e).     } }
false;public;1;4;;@Override public void onNewClusterState(ClusterState state) {     listener.onResponse(PersistentTasksCustomMetaData.getTaskWithId(state, taskId)). }
false;public;0;4;;@Override public void onClusterServiceClose() {     listener.onFailure(new NodeClosedException(clusterService.localNode())). }
false;public;1;4;;@Override public void onTimeout(TimeValue timeout) {     listener.onTimeout(timeout). }
true;public;4;30;/**  * Waits for a given persistent task to comply with a given predicate, then call back the listener accordingly.  *  * @param taskId the persistent task id  * @param predicate the persistent task predicate to evaluate  * @param timeout a timeout for waiting  * @param listener the callback listener  */ ;/**  * Waits for a given persistent task to comply with a given predicate, then call back the listener accordingly.  *  * @param taskId the persistent task id  * @param predicate the persistent task predicate to evaluate  * @param timeout a timeout for waiting  * @param listener the callback listener  */ public void waitForPersistentTaskCondition(final String taskId, final Predicate<PersistentTask<?>> predicate, @Nullable final TimeValue timeout, final WaitForPersistentTaskListener<?> listener) {     final Predicate<ClusterState> clusterStatePredicate = clusterState -> predicate.test(PersistentTasksCustomMetaData.getTaskWithId(clusterState, taskId)).     final ClusterStateObserver observer = new ClusterStateObserver(clusterService, timeout, logger, threadPool.getThreadContext()).     final ClusterState clusterState = observer.setAndGetObservedState().     if (clusterStatePredicate.test(clusterState)) {         listener.onResponse(PersistentTasksCustomMetaData.getTaskWithId(clusterState, taskId)).     } else {         observer.waitForNextChange(new ClusterStateObserver.Listener() {              @Override             public void onNewClusterState(ClusterState state) {                 listener.onResponse(PersistentTasksCustomMetaData.getTaskWithId(state, taskId)).             }              @Override             public void onClusterServiceClose() {                 listener.onFailure(new NodeClosedException(clusterService.localNode())).             }              @Override             public void onTimeout(TimeValue timeout) {                 listener.onTimeout(timeout).             }         }, clusterStatePredicate).     } }
false;public;1;4;;@Override public void onNewClusterState(ClusterState state) {     listener.onResponse(true). }
false;public;0;4;;@Override public void onClusterServiceClose() {     listener.onFailure(new NodeClosedException(clusterService.localNode())). }
false;public;1;4;;@Override public void onTimeout(TimeValue timeout) {     listener.onFailure(new IllegalStateException("Timed out when waiting for persistent tasks after " + timeout)). }
true;public;3;28;/**  * Waits for persistent tasks to comply with a given predicate, then call back the listener accordingly.  *  * @param predicate the predicate to evaluate  * @param timeout a timeout for waiting  * @param listener the callback listener  */ ;/**  * Waits for persistent tasks to comply with a given predicate, then call back the listener accordingly.  *  * @param predicate the predicate to evaluate  * @param timeout a timeout for waiting  * @param listener the callback listener  */ public void waitForPersistentTasksCondition(final Predicate<PersistentTasksCustomMetaData> predicate, @Nullable final TimeValue timeout, final ActionListener<Boolean> listener) {     final Predicate<ClusterState> clusterStatePredicate = clusterState -> predicate.test(clusterState.metaData().custom(PersistentTasksCustomMetaData.TYPE)).     final ClusterStateObserver observer = new ClusterStateObserver(clusterService, timeout, logger, threadPool.getThreadContext()).     if (clusterStatePredicate.test(observer.setAndGetObservedState())) {         listener.onResponse(true).     } else {         observer.waitForNextChange(new ClusterStateObserver.Listener() {              @Override             public void onNewClusterState(ClusterState state) {                 listener.onResponse(true).             }              @Override             public void onClusterServiceClose() {                 listener.onFailure(new NodeClosedException(clusterService.localNode())).             }              @Override             public void onTimeout(TimeValue timeout) {                 listener.onFailure(new IllegalStateException("Timed out when waiting for persistent tasks after " + timeout)).             }         }, clusterStatePredicate, timeout).     } }
false;default;1;3;;default void onTimeout(TimeValue timeout) {     onFailure(new IllegalStateException("Timed out when waiting for persistent task after " + timeout)). }
