commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String getName() {     return "cluster_state_action". }
false;public;2;13;;@Override public RestResponse buildResponse(ClusterStateResponse response, XContentBuilder builder) throws Exception {     builder.startObject().     if (clusterStateRequest.waitForMetaDataVersion() != null) {         builder.field(Fields.WAIT_FOR_TIMED_OUT, response.isWaitForTimedOut()).     }     builder.field(Fields.CLUSTER_NAME, response.getClusterName().value()).     builder.humanReadableField(Fields.CLUSTER_STATE_SIZE_IN_BYTES, Fields.CLUSTER_STATE_SIZE, response.getTotalCompressedSize()).     response.getState().toXContent(builder, request).     builder.endObject().     return new BytesRestResponse(RestStatus.OK, builder). }
false;public;2;49;;@Override public RestChannelConsumer prepareRequest(final RestRequest request, final NodeClient client) throws IOException {     final ClusterStateRequest clusterStateRequest = Requests.clusterStateRequest().     clusterStateRequest.indicesOptions(IndicesOptions.fromRequest(request, clusterStateRequest.indicesOptions())).     clusterStateRequest.local(request.paramAsBoolean("local", clusterStateRequest.local())).     clusterStateRequest.masterNodeTimeout(request.paramAsTime("master_timeout", clusterStateRequest.masterNodeTimeout())).     if (request.hasParam("wait_for_metadata_version")) {         clusterStateRequest.waitForMetaDataVersion(request.paramAsLong("wait_for_metadata_version", 0)).     }     clusterStateRequest.waitForTimeout(request.paramAsTime("wait_for_timeout", ClusterStateRequest.DEFAULT_WAIT_FOR_NODE_TIMEOUT)).     final String[] indices = Strings.splitStringByCommaToArray(request.param("indices", "_all")).     boolean isAllIndicesOnly = indices.length == 1 && "_all".equals(indices[0]).     if (!isAllIndicesOnly) {         clusterStateRequest.indices(indices).     }     if (request.hasParam("metric")) {         EnumSet<ClusterState.Metric> metrics = ClusterState.Metric.parseString(request.param("metric"), true).         // do not ask for what we do not need.         clusterStateRequest.nodes(metrics.contains(ClusterState.Metric.NODES) || metrics.contains(ClusterState.Metric.MASTER_NODE)).         /*              * there is no distinction in Java api between routing_table and routing_nodes, it's the same info set over the wire, one single              * flag to ask for it              */         clusterStateRequest.routingTable(metrics.contains(ClusterState.Metric.ROUTING_TABLE) || metrics.contains(ClusterState.Metric.ROUTING_NODES)).         clusterStateRequest.metaData(metrics.contains(ClusterState.Metric.METADATA)).         clusterStateRequest.blocks(metrics.contains(ClusterState.Metric.BLOCKS)).         clusterStateRequest.customs(metrics.contains(ClusterState.Metric.CUSTOMS)).     }     settingsFilter.addFilterSettingParams(request).     return channel -> client.admin().cluster().state(clusterStateRequest, new RestBuilderListener<ClusterStateResponse>(channel) {          @Override         public RestResponse buildResponse(ClusterStateResponse response, XContentBuilder builder) throws Exception {             builder.startObject().             if (clusterStateRequest.waitForMetaDataVersion() != null) {                 builder.field(Fields.WAIT_FOR_TIMED_OUT, response.isWaitForTimedOut()).             }             builder.field(Fields.CLUSTER_NAME, response.getClusterName().value()).             builder.humanReadableField(Fields.CLUSTER_STATE_SIZE_IN_BYTES, Fields.CLUSTER_STATE_SIZE, response.getTotalCompressedSize()).             response.getState().toXContent(builder, request).             builder.endObject().             return new BytesRestResponse(RestStatus.OK, builder).         }     }). }
false;protected;0;4;;@Override protected Set<String> responseParams() {     return RESPONSE_PARAMS. }
false;public;0;4;;@Override public boolean canTripCircuitBreaker() {     return false. }
