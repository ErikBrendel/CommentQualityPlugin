commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;8;;@Override protected void doWriteTo(StreamOutput out) throws IOException {     script.writeTo(out).     out.writeNamedWriteable(formatter).     gapPolicy.writeTo(out).     out.writeString(bucketsPath).     out.writeInt(window). }
false;public;0;4;;@Override public String getWriteableName() {     return MovFnPipelineAggregationBuilder.NAME. }
false;public;2;46;;@Override public InternalAggregation reduce(InternalAggregation aggregation, InternalAggregation.ReduceContext reduceContext) {     InternalMultiBucketAggregation<? extends InternalMultiBucketAggregation, ? extends InternalMultiBucketAggregation.InternalBucket> histo = (InternalMultiBucketAggregation<? extends InternalMultiBucketAggregation, ? extends InternalMultiBucketAggregation.InternalBucket>) aggregation.     List<? extends InternalMultiBucketAggregation.InternalBucket> buckets = histo.getBuckets().     HistogramFactory factory = (HistogramFactory) histo.     List<MultiBucketsAggregation.Bucket> newBuckets = new ArrayList<>().     EvictingQueue<Double> values = new EvictingQueue<>(this.window).     // Initialize the script     MovingFunctionScript.Factory scriptFactory = reduceContext.scriptService().compile(script, MovingFunctionScript.CONTEXT).     Map<String, Object> vars = new HashMap<>().     if (script.getParams() != null) {         vars.putAll(script.getParams()).     }     MovingFunctionScript executableScript = scriptFactory.newInstance().     for (InternalMultiBucketAggregation.InternalBucket bucket : buckets) {         Double thisBucketValue = resolveBucketValue(histo, bucket, bucketsPaths()[0], gapPolicy).         // Default is to reuse existing bucket.  Simplifies the rest of the logic,         // since we only change newBucket if we can add to it         MultiBucketsAggregation.Bucket newBucket = bucket.         if (thisBucketValue != null && thisBucketValue.equals(Double.NaN) == false) {             // The custom context mandates that the script returns a double (not Double) so we             // don't need null checks, etc.             double movavg = executableScript.execute(vars, values.stream().mapToDouble(Double::doubleValue).toArray()).             List<InternalAggregation> aggs = StreamSupport.stream(bucket.getAggregations().spliterator(), false).map(InternalAggregation.class::cast).collect(Collectors.toList()).             aggs.add(new InternalSimpleValue(name(), movavg, formatter, new ArrayList<>(), metaData())).             newBucket = factory.createBucket(factory.getKey(bucket), bucket.getDocCount(), new InternalAggregations(aggs)).             values.offer(thisBucketValue).         }         newBuckets.add(newBucket).     }     return factory.createAggregation(newBuckets). }
