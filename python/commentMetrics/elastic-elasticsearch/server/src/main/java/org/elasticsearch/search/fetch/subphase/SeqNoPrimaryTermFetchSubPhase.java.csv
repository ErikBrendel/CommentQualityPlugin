commented;modifiers;parameterAmount;loc;comment;code
false;public;2;34;;@Override public void hitsExecute(SearchContext context, SearchHit[] hits) throws IOException {     if (context.seqNoAndPrimaryTerm() == false) {         return.     }     // don't modify the incoming hits     hits = hits.clone().     Arrays.sort(hits, Comparator.comparingInt(SearchHit::docId)).     int lastReaderId = -1.     NumericDocValues seqNoField = null.     NumericDocValues primaryTermField = null.     for (SearchHit hit : hits) {         int readerId = ReaderUtil.subIndex(hit.docId(), context.searcher().getIndexReader().leaves()).         LeafReaderContext subReaderContext = context.searcher().getIndexReader().leaves().get(readerId).         if (lastReaderId != readerId) {             seqNoField = subReaderContext.reader().getNumericDocValues(SeqNoFieldMapper.NAME).             primaryTermField = subReaderContext.reader().getNumericDocValues(SeqNoFieldMapper.PRIMARY_TERM_NAME).             lastReaderId = readerId.         }         int docId = hit.docId() - subReaderContext.docBase.         long seqNo = SequenceNumbers.UNASSIGNED_SEQ_NO.         long primaryTerm = SequenceNumbers.UNASSIGNED_PRIMARY_TERM.         // we have to check the primary term field as it is only assigned for non-nested documents         if (primaryTermField != null && primaryTermField.advanceExact(docId)) {             boolean found = seqNoField.advanceExact(docId).             assert found : "found seq no for " + docId + " but not a primary term".             seqNo = seqNoField.longValue().             primaryTerm = primaryTermField.longValue().         }         hit.setSeqNo(seqNo).         hit.setPrimaryTerm(primaryTerm).     } }
