# id;timestamp;commentText;codeText;commentWords;codeWords
PrimaryShardAllocator -> protected static NodeShardsResult buildNodeShardsResult(ShardRouting shard, boolean matchAnyShard,                                                             Set<String> ignoreNodes, Set<String> inSyncAllocationIds,                                                             FetchResult<NodeGatewayStartedShards> shardState,                                                             Logger logger);1524684173;Builds a list of nodes. If matchAnyShard is set to false, only nodes that have an allocation id matching_inSyncAllocationIds are added to the list. Otherwise, any node that has a shard is added to the list, but_entries with matching allocation id are always at the front of the list.;protected static NodeShardsResult buildNodeShardsResult(ShardRouting shard, boolean matchAnyShard,_                                                            Set<String> ignoreNodes, Set<String> inSyncAllocationIds,_                                                            FetchResult<NodeGatewayStartedShards> shardState,_                                                            Logger logger) {_        List<NodeGatewayStartedShards> nodeShardStates = new ArrayList<>()__        int numberOfAllocationsFound = 0__        for (NodeGatewayStartedShards nodeShardState : shardState.getData().values()) {_            DiscoveryNode node = nodeShardState.getNode()__            String allocationId = nodeShardState.allocationId()___            if (ignoreNodes.contains(node.getId())) {_                continue__            }__            if (nodeShardState.storeException() == null) {_                if (allocationId == null) {_                    logger.trace("[{}] on node [{}] has no shard state information", shard, nodeShardState.getNode())__                } else {_                    logger.trace("[{}] on node [{}] has allocation id [{}]", shard, nodeShardState.getNode(), allocationId)__                }_            } else {_                final String finalAllocationId = allocationId__                if (nodeShardState.storeException() instanceof ShardLockObtainFailedException) {_                    logger.trace(() -> new ParameterizedMessage("[{}] on node [{}] has allocation id [{}] but the store can not be opened as it's locked, treating as valid shard", shard, nodeShardState.getNode(), finalAllocationId), nodeShardState.storeException())__                } else {_                    logger.trace(() -> new ParameterizedMessage("[{}] on node [{}] has allocation id [{}] but the store can not be opened, treating as no allocation id", shard, nodeShardState.getNode(), finalAllocationId), nodeShardState.storeException())__                    allocationId = null__                }_            }__            if (allocationId != null) {_                assert nodeShardState.storeException() == null ||_                    nodeShardState.storeException() instanceof ShardLockObtainFailedException :_                    "only allow store that can be opened or that throws a ShardLockObtainFailedException while being opened but got a store throwing " + nodeShardState.storeException()__                numberOfAllocationsFound++__                if (matchAnyShard || inSyncAllocationIds.contains(nodeShardState.allocationId())) {_                    nodeShardStates.add(nodeShardState)__                }_            }_        }__        final Comparator<NodeGatewayStartedShards> comparator_ _        if (matchAnyShard) {_            _            Comparator<NodeGatewayStartedShards> matchingAllocationsFirst = Comparator.comparing(_                (NodeGatewayStartedShards state) -> inSyncAllocationIds.contains(state.allocationId())).reversed()__            comparator = matchingAllocationsFirst.thenComparing(NO_STORE_EXCEPTION_FIRST_COMPARATOR).thenComparing(PRIMARY_FIRST_COMPARATOR)__        } else {_            comparator = NO_STORE_EXCEPTION_FIRST_COMPARATOR.thenComparing(PRIMARY_FIRST_COMPARATOR)__        }__        nodeShardStates.sort(comparator)___        if (logger.isTraceEnabled()) {_            logger.trace("{} candidates for allocation: {}", shard, nodeShardStates.stream().map(s -> s.getNode().getName()).collect(Collectors.joining(", ")))__        }_        return new NodeShardsResult(nodeShardStates, numberOfAllocationsFound)__    };builds,a,list,of,nodes,if,match,any,shard,is,set,to,false,only,nodes,that,have,an,allocation,id,matching,in,sync,allocation,ids,are,added,to,the,list,otherwise,any,node,that,has,a,shard,is,added,to,the,list,but,entries,with,matching,allocation,id,are,always,at,the,front,of,the,list;protected,static,node,shards,result,build,node,shards,result,shard,routing,shard,boolean,match,any,shard,set,string,ignore,nodes,set,string,in,sync,allocation,ids,fetch,result,node,gateway,started,shards,shard,state,logger,logger,list,node,gateway,started,shards,node,shard,states,new,array,list,int,number,of,allocations,found,0,for,node,gateway,started,shards,node,shard,state,shard,state,get,data,values,discovery,node,node,node,shard,state,get,node,string,allocation,id,node,shard,state,allocation,id,if,ignore,nodes,contains,node,get,id,continue,if,node,shard,state,store,exception,null,if,allocation,id,null,logger,trace,on,node,has,no,shard,state,information,shard,node,shard,state,get,node,else,logger,trace,on,node,has,allocation,id,shard,node,shard,state,get,node,allocation,id,else,final,string,final,allocation,id,allocation,id,if,node,shard,state,store,exception,instanceof,shard,lock,obtain,failed,exception,logger,trace,new,parameterized,message,on,node,has,allocation,id,but,the,store,can,not,be,opened,as,it,s,locked,treating,as,valid,shard,shard,node,shard,state,get,node,final,allocation,id,node,shard,state,store,exception,else,logger,trace,new,parameterized,message,on,node,has,allocation,id,but,the,store,can,not,be,opened,treating,as,no,allocation,id,shard,node,shard,state,get,node,final,allocation,id,node,shard,state,store,exception,allocation,id,null,if,allocation,id,null,assert,node,shard,state,store,exception,null,node,shard,state,store,exception,instanceof,shard,lock,obtain,failed,exception,only,allow,store,that,can,be,opened,or,that,throws,a,shard,lock,obtain,failed,exception,while,being,opened,but,got,a,store,throwing,node,shard,state,store,exception,number,of,allocations,found,if,match,any,shard,in,sync,allocation,ids,contains,node,shard,state,allocation,id,node,shard,states,add,node,shard,state,final,comparator,node,gateway,started,shards,comparator,if,match,any,shard,comparator,node,gateway,started,shards,matching,allocations,first,comparator,comparing,node,gateway,started,shards,state,in,sync,allocation,ids,contains,state,allocation,id,reversed,comparator,matching,allocations,first,then,comparing,then,comparing,else,comparator,then,comparing,node,shard,states,sort,comparator,if,logger,is,trace,enabled,logger,trace,candidates,for,allocation,shard,node,shard,states,stream,map,s,s,get,node,get,name,collect,collectors,joining,return,new,node,shards,result,node,shard,states,number,of,allocations,found
PrimaryShardAllocator -> protected static NodeShardsResult buildNodeShardsResult(ShardRouting shard, boolean matchAnyShard,                                                             Set<String> ignoreNodes, Set<String> inSyncAllocationIds,                                                             FetchResult<NodeGatewayStartedShards> shardState,                                                             Logger logger);1528762805;Builds a list of nodes. If matchAnyShard is set to false, only nodes that have an allocation id matching_inSyncAllocationIds are added to the list. Otherwise, any node that has a shard is added to the list, but_entries with matching allocation id are always at the front of the list.;protected static NodeShardsResult buildNodeShardsResult(ShardRouting shard, boolean matchAnyShard,_                                                            Set<String> ignoreNodes, Set<String> inSyncAllocationIds,_                                                            FetchResult<NodeGatewayStartedShards> shardState,_                                                            Logger logger) {_        List<NodeGatewayStartedShards> nodeShardStates = new ArrayList<>()__        int numberOfAllocationsFound = 0__        for (NodeGatewayStartedShards nodeShardState : shardState.getData().values()) {_            DiscoveryNode node = nodeShardState.getNode()__            String allocationId = nodeShardState.allocationId()___            if (ignoreNodes.contains(node.getId())) {_                continue__            }__            if (nodeShardState.storeException() == null) {_                if (allocationId == null) {_                    logger.trace("[{}] on node [{}] has no shard state information", shard, nodeShardState.getNode())__                } else {_                    logger.trace("[{}] on node [{}] has allocation id [{}]", shard, nodeShardState.getNode(), allocationId)__                }_            } else {_                final String finalAllocationId = allocationId__                if (nodeShardState.storeException() instanceof ShardLockObtainFailedException) {_                    logger.trace(() -> new ParameterizedMessage("[{}] on node [{}] has allocation id [{}] but the store can not be opened as it's locked, treating as valid shard", shard, nodeShardState.getNode(), finalAllocationId), nodeShardState.storeException())__                } else {_                    logger.trace(() -> new ParameterizedMessage("[{}] on node [{}] has allocation id [{}] but the store can not be opened, treating as no allocation id", shard, nodeShardState.getNode(), finalAllocationId), nodeShardState.storeException())__                    allocationId = null__                }_            }__            if (allocationId != null) {_                assert nodeShardState.storeException() == null ||_                    nodeShardState.storeException() instanceof ShardLockObtainFailedException :_                    "only allow store that can be opened or that throws a ShardLockObtainFailedException while being opened but got a store throwing " + nodeShardState.storeException()__                numberOfAllocationsFound++__                if (matchAnyShard || inSyncAllocationIds.contains(nodeShardState.allocationId())) {_                    nodeShardStates.add(nodeShardState)__                }_            }_        }__        final Comparator<NodeGatewayStartedShards> comparator_ _        if (matchAnyShard) {_            _            Comparator<NodeGatewayStartedShards> matchingAllocationsFirst = Comparator.comparing(_                (NodeGatewayStartedShards state) -> inSyncAllocationIds.contains(state.allocationId())).reversed()__            comparator = matchingAllocationsFirst.thenComparing(NO_STORE_EXCEPTION_FIRST_COMPARATOR).thenComparing(PRIMARY_FIRST_COMPARATOR)__        } else {_            comparator = NO_STORE_EXCEPTION_FIRST_COMPARATOR.thenComparing(PRIMARY_FIRST_COMPARATOR)__        }__        nodeShardStates.sort(comparator)___        if (logger.isTraceEnabled()) {_            logger.trace("{} candidates for allocation: {}", shard, nodeShardStates.stream().map(s -> s.getNode().getName()).collect(Collectors.joining(", ")))__        }_        return new NodeShardsResult(nodeShardStates, numberOfAllocationsFound)__    };builds,a,list,of,nodes,if,match,any,shard,is,set,to,false,only,nodes,that,have,an,allocation,id,matching,in,sync,allocation,ids,are,added,to,the,list,otherwise,any,node,that,has,a,shard,is,added,to,the,list,but,entries,with,matching,allocation,id,are,always,at,the,front,of,the,list;protected,static,node,shards,result,build,node,shards,result,shard,routing,shard,boolean,match,any,shard,set,string,ignore,nodes,set,string,in,sync,allocation,ids,fetch,result,node,gateway,started,shards,shard,state,logger,logger,list,node,gateway,started,shards,node,shard,states,new,array,list,int,number,of,allocations,found,0,for,node,gateway,started,shards,node,shard,state,shard,state,get,data,values,discovery,node,node,node,shard,state,get,node,string,allocation,id,node,shard,state,allocation,id,if,ignore,nodes,contains,node,get,id,continue,if,node,shard,state,store,exception,null,if,allocation,id,null,logger,trace,on,node,has,no,shard,state,information,shard,node,shard,state,get,node,else,logger,trace,on,node,has,allocation,id,shard,node,shard,state,get,node,allocation,id,else,final,string,final,allocation,id,allocation,id,if,node,shard,state,store,exception,instanceof,shard,lock,obtain,failed,exception,logger,trace,new,parameterized,message,on,node,has,allocation,id,but,the,store,can,not,be,opened,as,it,s,locked,treating,as,valid,shard,shard,node,shard,state,get,node,final,allocation,id,node,shard,state,store,exception,else,logger,trace,new,parameterized,message,on,node,has,allocation,id,but,the,store,can,not,be,opened,treating,as,no,allocation,id,shard,node,shard,state,get,node,final,allocation,id,node,shard,state,store,exception,allocation,id,null,if,allocation,id,null,assert,node,shard,state,store,exception,null,node,shard,state,store,exception,instanceof,shard,lock,obtain,failed,exception,only,allow,store,that,can,be,opened,or,that,throws,a,shard,lock,obtain,failed,exception,while,being,opened,but,got,a,store,throwing,node,shard,state,store,exception,number,of,allocations,found,if,match,any,shard,in,sync,allocation,ids,contains,node,shard,state,allocation,id,node,shard,states,add,node,shard,state,final,comparator,node,gateway,started,shards,comparator,if,match,any,shard,comparator,node,gateway,started,shards,matching,allocations,first,comparator,comparing,node,gateway,started,shards,state,in,sync,allocation,ids,contains,state,allocation,id,reversed,comparator,matching,allocations,first,then,comparing,then,comparing,else,comparator,then,comparing,node,shard,states,sort,comparator,if,logger,is,trace,enabled,logger,trace,candidates,for,allocation,shard,node,shard,states,stream,map,s,s,get,node,get,name,collect,collectors,joining,return,new,node,shards,result,node,shard,states,number,of,allocations,found
PrimaryShardAllocator -> protected static NodeShardsResult buildNodeShardsResult(ShardRouting shard, boolean matchAnyShard,                                                             Set<String> ignoreNodes, Set<String> inSyncAllocationIds,                                                             FetchResult<NodeGatewayStartedShards> shardState,                                                             Logger logger);1540847035;Builds a list of nodes. If matchAnyShard is set to false, only nodes that have an allocation id matching_inSyncAllocationIds are added to the list. Otherwise, any node that has a shard is added to the list, but_entries with matching allocation id are always at the front of the list.;protected static NodeShardsResult buildNodeShardsResult(ShardRouting shard, boolean matchAnyShard,_                                                            Set<String> ignoreNodes, Set<String> inSyncAllocationIds,_                                                            FetchResult<NodeGatewayStartedShards> shardState,_                                                            Logger logger) {_        List<NodeGatewayStartedShards> nodeShardStates = new ArrayList<>()__        int numberOfAllocationsFound = 0__        for (NodeGatewayStartedShards nodeShardState : shardState.getData().values()) {_            DiscoveryNode node = nodeShardState.getNode()__            String allocationId = nodeShardState.allocationId()___            if (ignoreNodes.contains(node.getId())) {_                continue__            }__            if (nodeShardState.storeException() == null) {_                if (allocationId == null) {_                    logger.trace("[{}] on node [{}] has no shard state information", shard, nodeShardState.getNode())__                } else {_                    logger.trace("[{}] on node [{}] has allocation id [{}]", shard, nodeShardState.getNode(), allocationId)__                }_            } else {_                final String finalAllocationId = allocationId__                if (nodeShardState.storeException() instanceof ShardLockObtainFailedException) {_                    logger.trace(() -> new ParameterizedMessage("[{}] on node [{}] has allocation id [{}] but the store can not be " +_                        "opened as it's locked, treating as valid shard", shard, nodeShardState.getNode(), finalAllocationId),_                        nodeShardState.storeException())__                } else {_                    logger.trace(() -> new ParameterizedMessage("[{}] on node [{}] has allocation id [{}] but the store can not be " +_                        "opened, treating as no allocation id", shard, nodeShardState.getNode(), finalAllocationId),_                        nodeShardState.storeException())__                    allocationId = null__                }_            }__            if (allocationId != null) {_                assert nodeShardState.storeException() == null ||_                    nodeShardState.storeException() instanceof ShardLockObtainFailedException :_                    "only allow store that can be opened or that throws a ShardLockObtainFailedException while being opened but got a " +_                        "store throwing " + nodeShardState.storeException()__                numberOfAllocationsFound++__                if (matchAnyShard || inSyncAllocationIds.contains(nodeShardState.allocationId())) {_                    nodeShardStates.add(nodeShardState)__                }_            }_        }__        final Comparator<NodeGatewayStartedShards> comparator_ _        if (matchAnyShard) {_            _            Comparator<NodeGatewayStartedShards> matchingAllocationsFirst = Comparator.comparing(_                (NodeGatewayStartedShards state) -> inSyncAllocationIds.contains(state.allocationId())).reversed()__            comparator = matchingAllocationsFirst.thenComparing(NO_STORE_EXCEPTION_FIRST_COMPARATOR)_                .thenComparing(PRIMARY_FIRST_COMPARATOR)__        } else {_            comparator = NO_STORE_EXCEPTION_FIRST_COMPARATOR.thenComparing(PRIMARY_FIRST_COMPARATOR)__        }__        nodeShardStates.sort(comparator)___        if (logger.isTraceEnabled()) {_            logger.trace("{} candidates for allocation: {}", shard, nodeShardStates.stream().map(s -> s.getNode().getName())_                .collect(Collectors.joining(", ")))__        }_        return new NodeShardsResult(nodeShardStates, numberOfAllocationsFound)__    };builds,a,list,of,nodes,if,match,any,shard,is,set,to,false,only,nodes,that,have,an,allocation,id,matching,in,sync,allocation,ids,are,added,to,the,list,otherwise,any,node,that,has,a,shard,is,added,to,the,list,but,entries,with,matching,allocation,id,are,always,at,the,front,of,the,list;protected,static,node,shards,result,build,node,shards,result,shard,routing,shard,boolean,match,any,shard,set,string,ignore,nodes,set,string,in,sync,allocation,ids,fetch,result,node,gateway,started,shards,shard,state,logger,logger,list,node,gateway,started,shards,node,shard,states,new,array,list,int,number,of,allocations,found,0,for,node,gateway,started,shards,node,shard,state,shard,state,get,data,values,discovery,node,node,node,shard,state,get,node,string,allocation,id,node,shard,state,allocation,id,if,ignore,nodes,contains,node,get,id,continue,if,node,shard,state,store,exception,null,if,allocation,id,null,logger,trace,on,node,has,no,shard,state,information,shard,node,shard,state,get,node,else,logger,trace,on,node,has,allocation,id,shard,node,shard,state,get,node,allocation,id,else,final,string,final,allocation,id,allocation,id,if,node,shard,state,store,exception,instanceof,shard,lock,obtain,failed,exception,logger,trace,new,parameterized,message,on,node,has,allocation,id,but,the,store,can,not,be,opened,as,it,s,locked,treating,as,valid,shard,shard,node,shard,state,get,node,final,allocation,id,node,shard,state,store,exception,else,logger,trace,new,parameterized,message,on,node,has,allocation,id,but,the,store,can,not,be,opened,treating,as,no,allocation,id,shard,node,shard,state,get,node,final,allocation,id,node,shard,state,store,exception,allocation,id,null,if,allocation,id,null,assert,node,shard,state,store,exception,null,node,shard,state,store,exception,instanceof,shard,lock,obtain,failed,exception,only,allow,store,that,can,be,opened,or,that,throws,a,shard,lock,obtain,failed,exception,while,being,opened,but,got,a,store,throwing,node,shard,state,store,exception,number,of,allocations,found,if,match,any,shard,in,sync,allocation,ids,contains,node,shard,state,allocation,id,node,shard,states,add,node,shard,state,final,comparator,node,gateway,started,shards,comparator,if,match,any,shard,comparator,node,gateway,started,shards,matching,allocations,first,comparator,comparing,node,gateway,started,shards,state,in,sync,allocation,ids,contains,state,allocation,id,reversed,comparator,matching,allocations,first,then,comparing,then,comparing,else,comparator,then,comparing,node,shard,states,sort,comparator,if,logger,is,trace,enabled,logger,trace,candidates,for,allocation,shard,node,shard,states,stream,map,s,s,get,node,get,name,collect,collectors,joining,return,new,node,shards,result,node,shard,states,number,of,allocations,found
PrimaryShardAllocator -> protected static NodeShardsResult buildNodeShardsResult(ShardRouting shard, boolean matchAnyShard,                                                             Set<String> ignoreNodes, Set<String> inSyncAllocationIds,                                                             FetchResult<NodeGatewayStartedShards> shardState,                                                             Logger logger);1541092382;Builds a list of nodes. If matchAnyShard is set to false, only nodes that have an allocation id matching_inSyncAllocationIds are added to the list. Otherwise, any node that has a shard is added to the list, but_entries with matching allocation id are always at the front of the list.;protected static NodeShardsResult buildNodeShardsResult(ShardRouting shard, boolean matchAnyShard,_                                                            Set<String> ignoreNodes, Set<String> inSyncAllocationIds,_                                                            FetchResult<NodeGatewayStartedShards> shardState,_                                                            Logger logger) {_        List<NodeGatewayStartedShards> nodeShardStates = new ArrayList<>()__        int numberOfAllocationsFound = 0__        for (NodeGatewayStartedShards nodeShardState : shardState.getData().values()) {_            DiscoveryNode node = nodeShardState.getNode()__            String allocationId = nodeShardState.allocationId()___            if (ignoreNodes.contains(node.getId())) {_                continue__            }__            if (nodeShardState.storeException() == null) {_                if (allocationId == null) {_                    logger.trace("[{}] on node [{}] has no shard state information", shard, nodeShardState.getNode())__                } else {_                    logger.trace("[{}] on node [{}] has allocation id [{}]", shard, nodeShardState.getNode(), allocationId)__                }_            } else {_                final String finalAllocationId = allocationId__                if (nodeShardState.storeException() instanceof ShardLockObtainFailedException) {_                    logger.trace(() -> new ParameterizedMessage("[{}] on node [{}] has allocation id [{}] but the store can not be " +_                        "opened as it's locked, treating as valid shard", shard, nodeShardState.getNode(), finalAllocationId),_                        nodeShardState.storeException())__                } else {_                    logger.trace(() -> new ParameterizedMessage("[{}] on node [{}] has allocation id [{}] but the store can not be " +_                        "opened, treating as no allocation id", shard, nodeShardState.getNode(), finalAllocationId),_                        nodeShardState.storeException())__                    allocationId = null__                }_            }__            if (allocationId != null) {_                assert nodeShardState.storeException() == null ||_                    nodeShardState.storeException() instanceof ShardLockObtainFailedException :_                    "only allow store that can be opened or that throws a ShardLockObtainFailedException while being opened but got a " +_                        "store throwing " + nodeShardState.storeException()__                numberOfAllocationsFound++__                if (matchAnyShard || inSyncAllocationIds.contains(nodeShardState.allocationId())) {_                    nodeShardStates.add(nodeShardState)__                }_            }_        }__        final Comparator<NodeGatewayStartedShards> comparator_ _        if (matchAnyShard) {_            _            Comparator<NodeGatewayStartedShards> matchingAllocationsFirst = Comparator.comparing(_                (NodeGatewayStartedShards state) -> inSyncAllocationIds.contains(state.allocationId())).reversed()__            comparator = matchingAllocationsFirst.thenComparing(NO_STORE_EXCEPTION_FIRST_COMPARATOR)_                .thenComparing(PRIMARY_FIRST_COMPARATOR)__        } else {_            comparator = NO_STORE_EXCEPTION_FIRST_COMPARATOR.thenComparing(PRIMARY_FIRST_COMPARATOR)__        }__        nodeShardStates.sort(comparator)___        if (logger.isTraceEnabled()) {_            logger.trace("{} candidates for allocation: {}", shard, nodeShardStates.stream().map(s -> s.getNode().getName())_                .collect(Collectors.joining(", ")))__        }_        return new NodeShardsResult(nodeShardStates, numberOfAllocationsFound)__    };builds,a,list,of,nodes,if,match,any,shard,is,set,to,false,only,nodes,that,have,an,allocation,id,matching,in,sync,allocation,ids,are,added,to,the,list,otherwise,any,node,that,has,a,shard,is,added,to,the,list,but,entries,with,matching,allocation,id,are,always,at,the,front,of,the,list;protected,static,node,shards,result,build,node,shards,result,shard,routing,shard,boolean,match,any,shard,set,string,ignore,nodes,set,string,in,sync,allocation,ids,fetch,result,node,gateway,started,shards,shard,state,logger,logger,list,node,gateway,started,shards,node,shard,states,new,array,list,int,number,of,allocations,found,0,for,node,gateway,started,shards,node,shard,state,shard,state,get,data,values,discovery,node,node,node,shard,state,get,node,string,allocation,id,node,shard,state,allocation,id,if,ignore,nodes,contains,node,get,id,continue,if,node,shard,state,store,exception,null,if,allocation,id,null,logger,trace,on,node,has,no,shard,state,information,shard,node,shard,state,get,node,else,logger,trace,on,node,has,allocation,id,shard,node,shard,state,get,node,allocation,id,else,final,string,final,allocation,id,allocation,id,if,node,shard,state,store,exception,instanceof,shard,lock,obtain,failed,exception,logger,trace,new,parameterized,message,on,node,has,allocation,id,but,the,store,can,not,be,opened,as,it,s,locked,treating,as,valid,shard,shard,node,shard,state,get,node,final,allocation,id,node,shard,state,store,exception,else,logger,trace,new,parameterized,message,on,node,has,allocation,id,but,the,store,can,not,be,opened,treating,as,no,allocation,id,shard,node,shard,state,get,node,final,allocation,id,node,shard,state,store,exception,allocation,id,null,if,allocation,id,null,assert,node,shard,state,store,exception,null,node,shard,state,store,exception,instanceof,shard,lock,obtain,failed,exception,only,allow,store,that,can,be,opened,or,that,throws,a,shard,lock,obtain,failed,exception,while,being,opened,but,got,a,store,throwing,node,shard,state,store,exception,number,of,allocations,found,if,match,any,shard,in,sync,allocation,ids,contains,node,shard,state,allocation,id,node,shard,states,add,node,shard,state,final,comparator,node,gateway,started,shards,comparator,if,match,any,shard,comparator,node,gateway,started,shards,matching,allocations,first,comparator,comparing,node,gateway,started,shards,state,in,sync,allocation,ids,contains,state,allocation,id,reversed,comparator,matching,allocations,first,then,comparing,then,comparing,else,comparator,then,comparing,node,shard,states,sort,comparator,if,logger,is,trace,enabled,logger,trace,candidates,for,allocation,shard,node,shard,states,stream,map,s,s,get,node,get,name,collect,collectors,joining,return,new,node,shards,result,node,shard,states,number,of,allocations,found
PrimaryShardAllocator -> private NodesToAllocate buildNodesToAllocate(RoutingAllocation allocation,                                                  List<NodeGatewayStartedShards> nodeShardStates,                                                  ShardRouting shardRouting,                                                  boolean forceAllocate);1524684173;Split the list of node shard states into groups yes/no/throttle based on allocation deciders;private NodesToAllocate buildNodesToAllocate(RoutingAllocation allocation,_                                                 List<NodeGatewayStartedShards> nodeShardStates,_                                                 ShardRouting shardRouting,_                                                 boolean forceAllocate) {_        List<DecidedNode> yesNodeShards = new ArrayList<>()__        List<DecidedNode> throttledNodeShards = new ArrayList<>()__        List<DecidedNode> noNodeShards = new ArrayList<>()__        for (NodeGatewayStartedShards nodeShardState : nodeShardStates) {_            RoutingNode node = allocation.routingNodes().node(nodeShardState.getNode().getId())__            if (node == null) {_                continue__            }__            Decision decision = forceAllocate ? allocation.deciders().canForceAllocatePrimary(shardRouting, node, allocation) :_                                                allocation.deciders().canAllocate(shardRouting, node, allocation)__            DecidedNode decidedNode = new DecidedNode(nodeShardState, decision)__            if (decision.type() == Type.THROTTLE) {_                throttledNodeShards.add(decidedNode)__            } else if (decision.type() == Type.NO) {_                noNodeShards.add(decidedNode)__            } else {_                yesNodeShards.add(decidedNode)__            }_        }_        return new NodesToAllocate(Collections.unmodifiableList(yesNodeShards), Collections.unmodifiableList(throttledNodeShards),_                                      Collections.unmodifiableList(noNodeShards))__    };split,the,list,of,node,shard,states,into,groups,yes,no,throttle,based,on,allocation,deciders;private,nodes,to,allocate,build,nodes,to,allocate,routing,allocation,allocation,list,node,gateway,started,shards,node,shard,states,shard,routing,shard,routing,boolean,force,allocate,list,decided,node,yes,node,shards,new,array,list,list,decided,node,throttled,node,shards,new,array,list,list,decided,node,no,node,shards,new,array,list,for,node,gateway,started,shards,node,shard,state,node,shard,states,routing,node,node,allocation,routing,nodes,node,node,shard,state,get,node,get,id,if,node,null,continue,decision,decision,force,allocate,allocation,deciders,can,force,allocate,primary,shard,routing,node,allocation,allocation,deciders,can,allocate,shard,routing,node,allocation,decided,node,decided,node,new,decided,node,node,shard,state,decision,if,decision,type,type,throttle,throttled,node,shards,add,decided,node,else,if,decision,type,type,no,no,node,shards,add,decided,node,else,yes,node,shards,add,decided,node,return,new,nodes,to,allocate,collections,unmodifiable,list,yes,node,shards,collections,unmodifiable,list,throttled,node,shards,collections,unmodifiable,list,no,node,shards
PrimaryShardAllocator -> private NodesToAllocate buildNodesToAllocate(RoutingAllocation allocation,                                                  List<NodeGatewayStartedShards> nodeShardStates,                                                  ShardRouting shardRouting,                                                  boolean forceAllocate);1528762805;Split the list of node shard states into groups yes/no/throttle based on allocation deciders;private NodesToAllocate buildNodesToAllocate(RoutingAllocation allocation,_                                                 List<NodeGatewayStartedShards> nodeShardStates,_                                                 ShardRouting shardRouting,_                                                 boolean forceAllocate) {_        List<DecidedNode> yesNodeShards = new ArrayList<>()__        List<DecidedNode> throttledNodeShards = new ArrayList<>()__        List<DecidedNode> noNodeShards = new ArrayList<>()__        for (NodeGatewayStartedShards nodeShardState : nodeShardStates) {_            RoutingNode node = allocation.routingNodes().node(nodeShardState.getNode().getId())__            if (node == null) {_                continue__            }__            Decision decision = forceAllocate ? allocation.deciders().canForceAllocatePrimary(shardRouting, node, allocation) :_                                                allocation.deciders().canAllocate(shardRouting, node, allocation)__            DecidedNode decidedNode = new DecidedNode(nodeShardState, decision)__            if (decision.type() == Type.THROTTLE) {_                throttledNodeShards.add(decidedNode)__            } else if (decision.type() == Type.NO) {_                noNodeShards.add(decidedNode)__            } else {_                yesNodeShards.add(decidedNode)__            }_        }_        return new NodesToAllocate(Collections.unmodifiableList(yesNodeShards), Collections.unmodifiableList(throttledNodeShards),_                                      Collections.unmodifiableList(noNodeShards))__    };split,the,list,of,node,shard,states,into,groups,yes,no,throttle,based,on,allocation,deciders;private,nodes,to,allocate,build,nodes,to,allocate,routing,allocation,allocation,list,node,gateway,started,shards,node,shard,states,shard,routing,shard,routing,boolean,force,allocate,list,decided,node,yes,node,shards,new,array,list,list,decided,node,throttled,node,shards,new,array,list,list,decided,node,no,node,shards,new,array,list,for,node,gateway,started,shards,node,shard,state,node,shard,states,routing,node,node,allocation,routing,nodes,node,node,shard,state,get,node,get,id,if,node,null,continue,decision,decision,force,allocate,allocation,deciders,can,force,allocate,primary,shard,routing,node,allocation,allocation,deciders,can,allocate,shard,routing,node,allocation,decided,node,decided,node,new,decided,node,node,shard,state,decision,if,decision,type,type,throttle,throttled,node,shards,add,decided,node,else,if,decision,type,type,no,no,node,shards,add,decided,node,else,yes,node,shards,add,decided,node,return,new,nodes,to,allocate,collections,unmodifiable,list,yes,node,shards,collections,unmodifiable,list,throttled,node,shards,collections,unmodifiable,list,no,node,shards
PrimaryShardAllocator -> private NodesToAllocate buildNodesToAllocate(RoutingAllocation allocation,                                                  List<NodeGatewayStartedShards> nodeShardStates,                                                  ShardRouting shardRouting,                                                  boolean forceAllocate);1540847035;Split the list of node shard states into groups yes/no/throttle based on allocation deciders;private NodesToAllocate buildNodesToAllocate(RoutingAllocation allocation,_                                                 List<NodeGatewayStartedShards> nodeShardStates,_                                                 ShardRouting shardRouting,_                                                 boolean forceAllocate) {_        List<DecidedNode> yesNodeShards = new ArrayList<>()__        List<DecidedNode> throttledNodeShards = new ArrayList<>()__        List<DecidedNode> noNodeShards = new ArrayList<>()__        for (NodeGatewayStartedShards nodeShardState : nodeShardStates) {_            RoutingNode node = allocation.routingNodes().node(nodeShardState.getNode().getId())__            if (node == null) {_                continue__            }__            Decision decision = forceAllocate ? allocation.deciders().canForceAllocatePrimary(shardRouting, node, allocation) :_                                                allocation.deciders().canAllocate(shardRouting, node, allocation)__            DecidedNode decidedNode = new DecidedNode(nodeShardState, decision)__            if (decision.type() == Type.THROTTLE) {_                throttledNodeShards.add(decidedNode)__            } else if (decision.type() == Type.NO) {_                noNodeShards.add(decidedNode)__            } else {_                yesNodeShards.add(decidedNode)__            }_        }_        return new NodesToAllocate(Collections.unmodifiableList(yesNodeShards), Collections.unmodifiableList(throttledNodeShards),_                                      Collections.unmodifiableList(noNodeShards))__    };split,the,list,of,node,shard,states,into,groups,yes,no,throttle,based,on,allocation,deciders;private,nodes,to,allocate,build,nodes,to,allocate,routing,allocation,allocation,list,node,gateway,started,shards,node,shard,states,shard,routing,shard,routing,boolean,force,allocate,list,decided,node,yes,node,shards,new,array,list,list,decided,node,throttled,node,shards,new,array,list,list,decided,node,no,node,shards,new,array,list,for,node,gateway,started,shards,node,shard,state,node,shard,states,routing,node,node,allocation,routing,nodes,node,node,shard,state,get,node,get,id,if,node,null,continue,decision,decision,force,allocate,allocation,deciders,can,force,allocate,primary,shard,routing,node,allocation,allocation,deciders,can,allocate,shard,routing,node,allocation,decided,node,decided,node,new,decided,node,node,shard,state,decision,if,decision,type,type,throttle,throttled,node,shards,add,decided,node,else,if,decision,type,type,no,no,node,shards,add,decided,node,else,yes,node,shards,add,decided,node,return,new,nodes,to,allocate,collections,unmodifiable,list,yes,node,shards,collections,unmodifiable,list,throttled,node,shards,collections,unmodifiable,list,no,node,shards
PrimaryShardAllocator -> private NodesToAllocate buildNodesToAllocate(RoutingAllocation allocation,                                                  List<NodeGatewayStartedShards> nodeShardStates,                                                  ShardRouting shardRouting,                                                  boolean forceAllocate);1541092382;Split the list of node shard states into groups yes/no/throttle based on allocation deciders;private NodesToAllocate buildNodesToAllocate(RoutingAllocation allocation,_                                                 List<NodeGatewayStartedShards> nodeShardStates,_                                                 ShardRouting shardRouting,_                                                 boolean forceAllocate) {_        List<DecidedNode> yesNodeShards = new ArrayList<>()__        List<DecidedNode> throttledNodeShards = new ArrayList<>()__        List<DecidedNode> noNodeShards = new ArrayList<>()__        for (NodeGatewayStartedShards nodeShardState : nodeShardStates) {_            RoutingNode node = allocation.routingNodes().node(nodeShardState.getNode().getId())__            if (node == null) {_                continue__            }__            Decision decision = forceAllocate ? allocation.deciders().canForceAllocatePrimary(shardRouting, node, allocation) :_                                                allocation.deciders().canAllocate(shardRouting, node, allocation)__            DecidedNode decidedNode = new DecidedNode(nodeShardState, decision)__            if (decision.type() == Type.THROTTLE) {_                throttledNodeShards.add(decidedNode)__            } else if (decision.type() == Type.NO) {_                noNodeShards.add(decidedNode)__            } else {_                yesNodeShards.add(decidedNode)__            }_        }_        return new NodesToAllocate(Collections.unmodifiableList(yesNodeShards), Collections.unmodifiableList(throttledNodeShards),_                                      Collections.unmodifiableList(noNodeShards))__    };split,the,list,of,node,shard,states,into,groups,yes,no,throttle,based,on,allocation,deciders;private,nodes,to,allocate,build,nodes,to,allocate,routing,allocation,allocation,list,node,gateway,started,shards,node,shard,states,shard,routing,shard,routing,boolean,force,allocate,list,decided,node,yes,node,shards,new,array,list,list,decided,node,throttled,node,shards,new,array,list,list,decided,node,no,node,shards,new,array,list,for,node,gateway,started,shards,node,shard,state,node,shard,states,routing,node,node,allocation,routing,nodes,node,node,shard,state,get,node,get,id,if,node,null,continue,decision,decision,force,allocate,allocation,deciders,can,force,allocate,primary,shard,routing,node,allocation,allocation,deciders,can,allocate,shard,routing,node,allocation,decided,node,decided,node,new,decided,node,node,shard,state,decision,if,decision,type,type,throttle,throttled,node,shards,add,decided,node,else,if,decision,type,type,no,no,node,shards,add,decided,node,else,yes,node,shards,add,decided,node,return,new,nodes,to,allocate,collections,unmodifiable,list,yes,node,shards,collections,unmodifiable,list,throttled,node,shards,collections,unmodifiable,list,no,node,shards
PrimaryShardAllocator -> private static boolean isResponsibleFor(final ShardRouting shard);1524684173;Is the allocator responsible for allocating the given {@link ShardRouting}?;private static boolean isResponsibleFor(final ShardRouting shard) {_        return shard.primary() _                && shard.unassigned() _                _                && (shard.recoverySource().getType() == RecoverySource.Type.EXISTING_STORE_                    || shard.recoverySource().getType() == RecoverySource.Type.SNAPSHOT)__    };is,the,allocator,responsible,for,allocating,the,given,link,shard,routing;private,static,boolean,is,responsible,for,final,shard,routing,shard,return,shard,primary,shard,unassigned,shard,recovery,source,get,type,recovery,source,type,shard,recovery,source,get,type,recovery,source,type,snapshot
PrimaryShardAllocator -> private static boolean isResponsibleFor(final ShardRouting shard);1528762805;Is the allocator responsible for allocating the given {@link ShardRouting}?;private static boolean isResponsibleFor(final ShardRouting shard) {_        return shard.primary() _                && shard.unassigned() _                _                && (shard.recoverySource().getType() == RecoverySource.Type.EXISTING_STORE_                    || shard.recoverySource().getType() == RecoverySource.Type.SNAPSHOT)__    };is,the,allocator,responsible,for,allocating,the,given,link,shard,routing;private,static,boolean,is,responsible,for,final,shard,routing,shard,return,shard,primary,shard,unassigned,shard,recovery,source,get,type,recovery,source,type,shard,recovery,source,get,type,recovery,source,type,snapshot
PrimaryShardAllocator -> private static boolean isResponsibleFor(final ShardRouting shard);1540847035;Is the allocator responsible for allocating the given {@link ShardRouting}?;private static boolean isResponsibleFor(final ShardRouting shard) {_        return shard.primary() _                && shard.unassigned() _                _                && (shard.recoverySource().getType() == RecoverySource.Type.EXISTING_STORE_                    || shard.recoverySource().getType() == RecoverySource.Type.SNAPSHOT)__    };is,the,allocator,responsible,for,allocating,the,given,link,shard,routing;private,static,boolean,is,responsible,for,final,shard,routing,shard,return,shard,primary,shard,unassigned,shard,recovery,source,get,type,recovery,source,type,shard,recovery,source,get,type,recovery,source,type,snapshot
PrimaryShardAllocator -> private static boolean isResponsibleFor(final ShardRouting shard);1541092382;Is the allocator responsible for allocating the given {@link ShardRouting}?;private static boolean isResponsibleFor(final ShardRouting shard) {_        return shard.primary() _                && shard.unassigned() _                _                && (shard.recoverySource().getType() == RecoverySource.Type.EXISTING_STORE_                    || shard.recoverySource().getType() == RecoverySource.Type.SNAPSHOT)__    };is,the,allocator,responsible,for,allocating,the,given,link,shard,routing;private,static,boolean,is,responsible,for,final,shard,routing,shard,return,shard,primary,shard,unassigned,shard,recovery,source,get,type,recovery,source,type,shard,recovery,source,get,type,recovery,source,type,snapshot
PrimaryShardAllocator -> private static List<NodeAllocationResult> buildNodeDecisions(NodesToAllocate nodesToAllocate,                                                                  FetchResult<NodeGatewayStartedShards> fetchedShardData,                                                                  Set<String> inSyncAllocationIds);1524684173;Builds a map of nodes to the corresponding allocation decisions for those nodes.;private static List<NodeAllocationResult> buildNodeDecisions(NodesToAllocate nodesToAllocate,_                                                                 FetchResult<NodeGatewayStartedShards> fetchedShardData,_                                                                 Set<String> inSyncAllocationIds) {_        List<NodeAllocationResult> nodeResults = new ArrayList<>()__        Collection<NodeGatewayStartedShards> ineligibleShards__        if (nodesToAllocate != null) {_            final Set<DiscoveryNode> discoNodes = new HashSet<>()__            nodeResults.addAll(Stream.of(nodesToAllocate.yesNodeShards, nodesToAllocate.throttleNodeShards, nodesToAllocate.noNodeShards)_                                .flatMap(Collection::stream)_                                .map(dnode -> {_                                    discoNodes.add(dnode.nodeShardState.getNode())__                                    return new NodeAllocationResult(dnode.nodeShardState.getNode(),_                                                                       shardStoreInfo(dnode.nodeShardState, inSyncAllocationIds),_                                                                       dnode.decision)__                                }).collect(Collectors.toList()))__            ineligibleShards = fetchedShardData.getData().values().stream().filter(shardData ->_                discoNodes.contains(shardData.getNode()) == false_            ).collect(Collectors.toList())__        } else {_            _            _            ineligibleShards = fetchedShardData.getData().values()__        }__        nodeResults.addAll(ineligibleShards.stream().map(shardData ->_            new NodeAllocationResult(shardData.getNode(), shardStoreInfo(shardData, inSyncAllocationIds), null)_        ).collect(Collectors.toList()))___        return nodeResults__    };builds,a,map,of,nodes,to,the,corresponding,allocation,decisions,for,those,nodes;private,static,list,node,allocation,result,build,node,decisions,nodes,to,allocate,nodes,to,allocate,fetch,result,node,gateway,started,shards,fetched,shard,data,set,string,in,sync,allocation,ids,list,node,allocation,result,node,results,new,array,list,collection,node,gateway,started,shards,ineligible,shards,if,nodes,to,allocate,null,final,set,discovery,node,disco,nodes,new,hash,set,node,results,add,all,stream,of,nodes,to,allocate,yes,node,shards,nodes,to,allocate,throttle,node,shards,nodes,to,allocate,no,node,shards,flat,map,collection,stream,map,dnode,disco,nodes,add,dnode,node,shard,state,get,node,return,new,node,allocation,result,dnode,node,shard,state,get,node,shard,store,info,dnode,node,shard,state,in,sync,allocation,ids,dnode,decision,collect,collectors,to,list,ineligible,shards,fetched,shard,data,get,data,values,stream,filter,shard,data,disco,nodes,contains,shard,data,get,node,false,collect,collectors,to,list,else,ineligible,shards,fetched,shard,data,get,data,values,node,results,add,all,ineligible,shards,stream,map,shard,data,new,node,allocation,result,shard,data,get,node,shard,store,info,shard,data,in,sync,allocation,ids,null,collect,collectors,to,list,return,node,results
PrimaryShardAllocator -> private static List<NodeAllocationResult> buildNodeDecisions(NodesToAllocate nodesToAllocate,                                                                  FetchResult<NodeGatewayStartedShards> fetchedShardData,                                                                  Set<String> inSyncAllocationIds);1528762805;Builds a map of nodes to the corresponding allocation decisions for those nodes.;private static List<NodeAllocationResult> buildNodeDecisions(NodesToAllocate nodesToAllocate,_                                                                 FetchResult<NodeGatewayStartedShards> fetchedShardData,_                                                                 Set<String> inSyncAllocationIds) {_        List<NodeAllocationResult> nodeResults = new ArrayList<>()__        Collection<NodeGatewayStartedShards> ineligibleShards__        if (nodesToAllocate != null) {_            final Set<DiscoveryNode> discoNodes = new HashSet<>()__            nodeResults.addAll(Stream.of(nodesToAllocate.yesNodeShards, nodesToAllocate.throttleNodeShards, nodesToAllocate.noNodeShards)_                                .flatMap(Collection::stream)_                                .map(dnode -> {_                                    discoNodes.add(dnode.nodeShardState.getNode())__                                    return new NodeAllocationResult(dnode.nodeShardState.getNode(),_                                                                       shardStoreInfo(dnode.nodeShardState, inSyncAllocationIds),_                                                                       dnode.decision)__                                }).collect(Collectors.toList()))__            ineligibleShards = fetchedShardData.getData().values().stream().filter(shardData ->_                discoNodes.contains(shardData.getNode()) == false_            ).collect(Collectors.toList())__        } else {_            _            _            ineligibleShards = fetchedShardData.getData().values()__        }__        nodeResults.addAll(ineligibleShards.stream().map(shardData ->_            new NodeAllocationResult(shardData.getNode(), shardStoreInfo(shardData, inSyncAllocationIds), null)_        ).collect(Collectors.toList()))___        return nodeResults__    };builds,a,map,of,nodes,to,the,corresponding,allocation,decisions,for,those,nodes;private,static,list,node,allocation,result,build,node,decisions,nodes,to,allocate,nodes,to,allocate,fetch,result,node,gateway,started,shards,fetched,shard,data,set,string,in,sync,allocation,ids,list,node,allocation,result,node,results,new,array,list,collection,node,gateway,started,shards,ineligible,shards,if,nodes,to,allocate,null,final,set,discovery,node,disco,nodes,new,hash,set,node,results,add,all,stream,of,nodes,to,allocate,yes,node,shards,nodes,to,allocate,throttle,node,shards,nodes,to,allocate,no,node,shards,flat,map,collection,stream,map,dnode,disco,nodes,add,dnode,node,shard,state,get,node,return,new,node,allocation,result,dnode,node,shard,state,get,node,shard,store,info,dnode,node,shard,state,in,sync,allocation,ids,dnode,decision,collect,collectors,to,list,ineligible,shards,fetched,shard,data,get,data,values,stream,filter,shard,data,disco,nodes,contains,shard,data,get,node,false,collect,collectors,to,list,else,ineligible,shards,fetched,shard,data,get,data,values,node,results,add,all,ineligible,shards,stream,map,shard,data,new,node,allocation,result,shard,data,get,node,shard,store,info,shard,data,in,sync,allocation,ids,null,collect,collectors,to,list,return,node,results
PrimaryShardAllocator -> private static List<NodeAllocationResult> buildNodeDecisions(NodesToAllocate nodesToAllocate,                                                                  FetchResult<NodeGatewayStartedShards> fetchedShardData,                                                                  Set<String> inSyncAllocationIds);1540847035;Builds a map of nodes to the corresponding allocation decisions for those nodes.;private static List<NodeAllocationResult> buildNodeDecisions(NodesToAllocate nodesToAllocate,_                                                                 FetchResult<NodeGatewayStartedShards> fetchedShardData,_                                                                 Set<String> inSyncAllocationIds) {_        List<NodeAllocationResult> nodeResults = new ArrayList<>()__        Collection<NodeGatewayStartedShards> ineligibleShards__        if (nodesToAllocate != null) {_            final Set<DiscoveryNode> discoNodes = new HashSet<>()__            nodeResults.addAll(Stream.of(nodesToAllocate.yesNodeShards, nodesToAllocate.throttleNodeShards, nodesToAllocate.noNodeShards)_                                .flatMap(Collection::stream)_                                .map(dnode -> {_                                    discoNodes.add(dnode.nodeShardState.getNode())__                                    return new NodeAllocationResult(dnode.nodeShardState.getNode(),_                                                                       shardStoreInfo(dnode.nodeShardState, inSyncAllocationIds),_                                                                       dnode.decision)__                                }).collect(Collectors.toList()))__            ineligibleShards = fetchedShardData.getData().values().stream().filter(shardData ->_                discoNodes.contains(shardData.getNode()) == false_            ).collect(Collectors.toList())__        } else {_            _            _            ineligibleShards = fetchedShardData.getData().values()__        }__        nodeResults.addAll(ineligibleShards.stream().map(shardData ->_            new NodeAllocationResult(shardData.getNode(), shardStoreInfo(shardData, inSyncAllocationIds), null)_        ).collect(Collectors.toList()))___        return nodeResults__    };builds,a,map,of,nodes,to,the,corresponding,allocation,decisions,for,those,nodes;private,static,list,node,allocation,result,build,node,decisions,nodes,to,allocate,nodes,to,allocate,fetch,result,node,gateway,started,shards,fetched,shard,data,set,string,in,sync,allocation,ids,list,node,allocation,result,node,results,new,array,list,collection,node,gateway,started,shards,ineligible,shards,if,nodes,to,allocate,null,final,set,discovery,node,disco,nodes,new,hash,set,node,results,add,all,stream,of,nodes,to,allocate,yes,node,shards,nodes,to,allocate,throttle,node,shards,nodes,to,allocate,no,node,shards,flat,map,collection,stream,map,dnode,disco,nodes,add,dnode,node,shard,state,get,node,return,new,node,allocation,result,dnode,node,shard,state,get,node,shard,store,info,dnode,node,shard,state,in,sync,allocation,ids,dnode,decision,collect,collectors,to,list,ineligible,shards,fetched,shard,data,get,data,values,stream,filter,shard,data,disco,nodes,contains,shard,data,get,node,false,collect,collectors,to,list,else,ineligible,shards,fetched,shard,data,get,data,values,node,results,add,all,ineligible,shards,stream,map,shard,data,new,node,allocation,result,shard,data,get,node,shard,store,info,shard,data,in,sync,allocation,ids,null,collect,collectors,to,list,return,node,results
PrimaryShardAllocator -> private static List<NodeAllocationResult> buildNodeDecisions(NodesToAllocate nodesToAllocate,                                                                  FetchResult<NodeGatewayStartedShards> fetchedShardData,                                                                  Set<String> inSyncAllocationIds);1541092382;Builds a map of nodes to the corresponding allocation decisions for those nodes.;private static List<NodeAllocationResult> buildNodeDecisions(NodesToAllocate nodesToAllocate,_                                                                 FetchResult<NodeGatewayStartedShards> fetchedShardData,_                                                                 Set<String> inSyncAllocationIds) {_        List<NodeAllocationResult> nodeResults = new ArrayList<>()__        Collection<NodeGatewayStartedShards> ineligibleShards__        if (nodesToAllocate != null) {_            final Set<DiscoveryNode> discoNodes = new HashSet<>()__            nodeResults.addAll(Stream.of(nodesToAllocate.yesNodeShards, nodesToAllocate.throttleNodeShards, nodesToAllocate.noNodeShards)_                                .flatMap(Collection::stream)_                                .map(dnode -> {_                                    discoNodes.add(dnode.nodeShardState.getNode())__                                    return new NodeAllocationResult(dnode.nodeShardState.getNode(),_                                                                       shardStoreInfo(dnode.nodeShardState, inSyncAllocationIds),_                                                                       dnode.decision)__                                }).collect(Collectors.toList()))__            ineligibleShards = fetchedShardData.getData().values().stream().filter(shardData ->_                discoNodes.contains(shardData.getNode()) == false_            ).collect(Collectors.toList())__        } else {_            _            _            ineligibleShards = fetchedShardData.getData().values()__        }__        nodeResults.addAll(ineligibleShards.stream().map(shardData ->_            new NodeAllocationResult(shardData.getNode(), shardStoreInfo(shardData, inSyncAllocationIds), null)_        ).collect(Collectors.toList()))___        return nodeResults__    };builds,a,map,of,nodes,to,the,corresponding,allocation,decisions,for,those,nodes;private,static,list,node,allocation,result,build,node,decisions,nodes,to,allocate,nodes,to,allocate,fetch,result,node,gateway,started,shards,fetched,shard,data,set,string,in,sync,allocation,ids,list,node,allocation,result,node,results,new,array,list,collection,node,gateway,started,shards,ineligible,shards,if,nodes,to,allocate,null,final,set,discovery,node,disco,nodes,new,hash,set,node,results,add,all,stream,of,nodes,to,allocate,yes,node,shards,nodes,to,allocate,throttle,node,shards,nodes,to,allocate,no,node,shards,flat,map,collection,stream,map,dnode,disco,nodes,add,dnode,node,shard,state,get,node,return,new,node,allocation,result,dnode,node,shard,state,get,node,shard,store,info,dnode,node,shard,state,in,sync,allocation,ids,dnode,decision,collect,collectors,to,list,ineligible,shards,fetched,shard,data,get,data,values,stream,filter,shard,data,disco,nodes,contains,shard,data,get,node,false,collect,collectors,to,list,else,ineligible,shards,fetched,shard,data,get,data,values,node,results,add,all,ineligible,shards,stream,map,shard,data,new,node,allocation,result,shard,data,get,node,shard,store,info,shard,data,in,sync,allocation,ids,null,collect,collectors,to,list,return,node,results
