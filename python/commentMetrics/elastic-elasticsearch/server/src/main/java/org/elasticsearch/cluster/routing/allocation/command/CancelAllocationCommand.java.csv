commented;modifiers;parameterAmount;loc;comment;code
false;public;1;7;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeString(index).     out.writeVInt(shardId).     out.writeString(node).     out.writeBoolean(allowPrimary). }
false;public;0;4;;@Override public String name() {     return NAME. }
true;public;0;3;/**  * Get the index of the shard which allocation should be canceled  * @return index of the shard which allocation should be canceled  */ ;/**  * Get the index of the shard which allocation should be canceled  * @return index of the shard which allocation should be canceled  */ public String index() {     return this.index. }
true;public;0;3;/**  * Get the id of the shard which allocation should be canceled  * @return id of the shard which allocation should be canceled  */ ;/**  * Get the id of the shard which allocation should be canceled  * @return id of the shard which allocation should be canceled  */ public int shardId() {     return this.shardId. }
true;public;0;3;/**  * Get the id of the node that manages the shard which allocation should be canceled  * @return id of the node that manages the shard which allocation should be canceled  */ ;/**  * Get the id of the node that manages the shard which allocation should be canceled  * @return id of the node that manages the shard which allocation should be canceled  */ public String node() {     return this.node. }
false;public;0;3;;public boolean allowPrimary() {     return this.allowPrimary. }
false;public;2;41;;@Override public RerouteExplanation execute(RoutingAllocation allocation, boolean explain) {     DiscoveryNode discoNode = allocation.nodes().resolveNode(node).     ShardRouting shardRouting = null.     RoutingNodes routingNodes = allocation.routingNodes().     RoutingNode routingNode = routingNodes.node(discoNode.getId()).     IndexMetaData indexMetaData = null.     if (routingNode != null) {         indexMetaData = allocation.metaData().index(index()).         if (indexMetaData == null) {             throw new IndexNotFoundException(index()).         }         ShardId shardId = new ShardId(indexMetaData.getIndex(), shardId()).         shardRouting = routingNode.getByShardId(shardId).     }     if (shardRouting == null) {         if (explain) {             return new RerouteExplanation(this, allocation.decision(Decision.NO, "cancel_allocation_command", "can't cancel " + shardId + ", failed to find it on node " + discoNode)).         }         throw new IllegalArgumentException("[cancel_allocation] can't cancel " + shardId + ", failed to find it on node " + discoNode).     }     if (shardRouting.primary() && allowPrimary == false) {         if ((shardRouting.initializing() && shardRouting.relocatingNodeId() != null) == false) {             // only allow cancelling initializing shard of primary relocation without allowPrimary flag             if (explain) {                 return new RerouteExplanation(this, allocation.decision(Decision.NO, "cancel_allocation_command", "can't cancel " + shardId + " on node " + discoNode + ", shard is primary and " + shardRouting.state().name().toLowerCase(Locale.ROOT))).             }             throw new IllegalArgumentException("[cancel_allocation] can't cancel " + shardId + " on node " + discoNode + ", shard is primary and " + shardRouting.state().name().toLowerCase(Locale.ROOT)).         }     }     routingNodes.failShard(LogManager.getLogger(CancelAllocationCommand.class), shardRouting, new UnassignedInfo(UnassignedInfo.Reason.REROUTE_CANCELLED, null), indexMetaData, allocation.changes()).     // TODO: We don't have to remove a cancelled shard from in-sync set once we have a strict resync implementation.     allocation.removeAllocationId(shardRouting).     return new RerouteExplanation(this, allocation.decision(Decision.YES, "cancel_allocation_command", "shard " + shardId + " on node " + discoNode + " can be cancelled")). }
false;public;2;9;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     builder.field("index", index()).     builder.field("shard", shardId()).     builder.field("node", node()).     builder.field("allow_primary", allowPrimary()).     return builder.endObject(). }
false;public,static;1;38;;public static CancelAllocationCommand fromXContent(XContentParser parser) throws IOException {     String index = null.     int shardId = -1.     String nodeId = null.     boolean allowPrimary = false.     String currentFieldName = null.     XContentParser.Token token.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (token.isValue()) {             if ("index".equals(currentFieldName)) {                 index = parser.text().             } else if ("shard".equals(currentFieldName)) {                 shardId = parser.intValue().             } else if ("node".equals(currentFieldName)) {                 nodeId = parser.text().             } else if ("allow_primary".equals(currentFieldName) || "allowPrimary".equals(currentFieldName)) {                 allowPrimary = parser.booleanValue().             } else {                 throw new ElasticsearchParseException("[{}] command does not support field [{}]", NAME, currentFieldName).             }         } else {             throw new ElasticsearchParseException("[{}] command does not support complex json tokens [{}]", NAME, token).         }     }     if (index == null) {         throw new ElasticsearchParseException("[{}] command missing the index parameter", NAME).     }     if (shardId == -1) {         throw new ElasticsearchParseException("[{}] command missing the shard parameter", NAME).     }     if (nodeId == null) {         throw new ElasticsearchParseException("[{}] command missing the node parameter", NAME).     }     return new CancelAllocationCommand(index, shardId, nodeId, allowPrimary). }
false;public;1;12;;@Override public boolean equals(Object obj) {     if (obj == null || getClass() != obj.getClass()) {         return false.     }     CancelAllocationCommand other = (CancelAllocationCommand) obj.     // Override equals and hashCode for testing     return Objects.equals(index, other.index) && Objects.equals(shardId, other.shardId) && Objects.equals(node, other.node) && Objects.equals(allowPrimary, other.allowPrimary). }
false;public;0;5;;@Override public int hashCode() {     // Override equals and hashCode for testing     return Objects.hash(index, shardId, node, allowPrimary). }
