commented;modifiers;parameterAmount;loc;comment;code
false;protected;3;4;;@Override protected void doExecute(Task task, TasksRequest request, ActionListener<TasksResponse> listener) {     new AsyncAction(task, request, listener).start(). }
false;public;1;5;;@Override public void onResponse(TaskResponse response) {     responses.setOnce(taskIndex, response == null ? null : new Tuple<>(response, null)).     respondIfFinished(). }
false;public;1;5;;@Override public void onFailure(Exception e) {     responses.setOnce(taskIndex, new Tuple<>(null, e)).     respondIfFinished(). }
false;private;0;18;;private void respondIfFinished() {     if (counter.decrementAndGet() != 0) {         return.     }     List<TaskResponse> results = new ArrayList<>().     List<TaskOperationFailure> exceptions = new ArrayList<>().     for (Tuple<TaskResponse, Exception> response : responses.asList()) {         if (response.v1() == null) {             assert response.v2() != null.             exceptions.add(new TaskOperationFailure(clusterService.localNode().getId(), tasks.get(taskIndex).getId(), response.v2())).         } else {             assert response.v2() == null.             results.add(response.v1()).         }     }     listener.onResponse(new NodeTasksResponse(clusterService.localNode().getId(), results, exceptions)). }
false;private;2;51;;private void nodeOperation(NodeTaskRequest nodeTaskRequest, ActionListener<NodeTasksResponse> listener) {     TasksRequest request = nodeTaskRequest.tasksRequest.     List<OperationTask> tasks = new ArrayList<>().     processTasks(request, tasks::add).     if (tasks.isEmpty()) {         listener.onResponse(new NodeTasksResponse(clusterService.localNode().getId(), emptyList(), emptyList())).         return.     }     AtomicArray<Tuple<TaskResponse, Exception>> responses = new AtomicArray<>(tasks.size()).     final AtomicInteger counter = new AtomicInteger(tasks.size()).     for (int i = 0. i < tasks.size(). i++) {         final int taskIndex = i.         ActionListener<TaskResponse> taskListener = new ActionListener<TaskResponse>() {              @Override             public void onResponse(TaskResponse response) {                 responses.setOnce(taskIndex, response == null ? null : new Tuple<>(response, null)).                 respondIfFinished().             }              @Override             public void onFailure(Exception e) {                 responses.setOnce(taskIndex, new Tuple<>(null, e)).                 respondIfFinished().             }              private void respondIfFinished() {                 if (counter.decrementAndGet() != 0) {                     return.                 }                 List<TaskResponse> results = new ArrayList<>().                 List<TaskOperationFailure> exceptions = new ArrayList<>().                 for (Tuple<TaskResponse, Exception> response : responses.asList()) {                     if (response.v1() == null) {                         assert response.v2() != null.                         exceptions.add(new TaskOperationFailure(clusterService.localNode().getId(), tasks.get(taskIndex).getId(), response.v2())).                     } else {                         assert response.v2() == null.                         results.add(response.v1()).                     }                 }                 listener.onResponse(new NodeTasksResponse(clusterService.localNode().getId(), results, exceptions)).             }         }.         try {             taskOperation(request, tasks.get(taskIndex), taskListener).         } catch (Exception e) {             taskListener.onFailure(e).         }     } }
false;protected;2;3;;protected String[] filterNodeIds(DiscoveryNodes nodes, String[] nodesIds) {     return nodesIds. }
false;protected;2;7;;protected String[] resolveNodes(TasksRequest request, ClusterState clusterState) {     if (request.getTaskId().isSet()) {         return new String[] { request.getTaskId().getNodeId() }.     } else {         return clusterState.nodes().resolveNodes(request.getNodes()).     } }
false;protected;2;21;;protected void processTasks(TasksRequest request, Consumer<OperationTask> operation) {     if (request.getTaskId().isSet()) {         // we are only checking one task, we can optimize it         Task task = taskManager.getTask(request.getTaskId().getId()).         if (task != null) {             if (request.match(task)) {                 operation.accept((OperationTask) task).             } else {                 throw new ResourceNotFoundException("task [{}] doesn't support this operation", request.getTaskId()).             }         } else {             throw new ResourceNotFoundException("task [{}] is missing", request.getTaskId()).         }     } else {         for (Task task : taskManager.getTasks().values()) {             if (request.match(task)) {                 operation.accept((OperationTask) task).             }         }     } }
false;protected,abstract;4;2;;protected abstract TasksResponse newResponse(TasksRequest request, List<TaskResponse> tasks, List<TaskOperationFailure> taskOperationFailures, List<FailedNodeException> failedNodeExceptions).
false;protected;2;21;;@SuppressWarnings("unchecked") protected TasksResponse newResponse(TasksRequest request, AtomicReferenceArray responses) {     List<TaskResponse> tasks = new ArrayList<>().     List<FailedNodeException> failedNodeExceptions = new ArrayList<>().     List<TaskOperationFailure> taskOperationFailures = new ArrayList<>().     for (int i = 0. i < responses.length(). i++) {         Object response = responses.get(i).         if (response instanceof FailedNodeException) {             failedNodeExceptions.add((FailedNodeException) response).         } else {             NodeTasksResponse tasksResponse = (NodeTasksResponse) response.             if (tasksResponse.results != null) {                 tasks.addAll(tasksResponse.results).             }             if (tasksResponse.exceptions != null) {                 taskOperationFailures.addAll(tasksResponse.exceptions).             }         }     }     return newResponse(request, tasks, taskOperationFailures, failedNodeExceptions). }
true;protected,abstract;3;1;/**  * Perform the required operation on the task. It is OK start an asynchronous operation or to throw an exception but not both.  */ ;/**  * Perform the required operation on the task. It is OK start an asynchronous operation or to throw an exception but not both.  */ protected abstract void taskOperation(TasksRequest request, OperationTask task, ActionListener<TaskResponse> listener).
false;public;1;6;;@Override public NodeTasksResponse read(StreamInput in) throws IOException {     NodeTasksResponse response = new NodeTasksResponse().     response.readFrom(in).     return response. }
false;public;1;4;;@Override public void handleResponse(NodeTasksResponse response) {     onOperation(idx, response). }
false;public;1;4;;@Override public void handleException(TransportException exp) {     onFailure(idx, node.getId(), exp). }
false;public;0;4;;@Override public String executor() {     return ThreadPool.Names.SAME. }
false;private;0;55;;private void start() {     if (nodesIds.length == 0) {         // nothing to do         try {             listener.onResponse(newResponse(request, responses)).         } catch (Exception e) {             logger.debug("failed to generate empty response", e).             listener.onFailure(e).         }     } else {         TransportRequestOptions.Builder builder = TransportRequestOptions.builder().         if (request.getTimeout() != null) {             builder.withTimeout(request.getTimeout()).         }         for (int i = 0. i < nodesIds.length. i++) {             final String nodeId = nodesIds[i].             final int idx = i.             final DiscoveryNode node = nodes[i].             try {                 if (node == null) {                     onFailure(idx, nodeId, new NoSuchNodeException(nodeId)).                 } else {                     NodeTaskRequest nodeRequest = new NodeTaskRequest(request).                     nodeRequest.setParentTask(clusterService.localNode().getId(), task.getId()).                     transportService.sendRequest(node, transportNodeAction, nodeRequest, builder.build(), new TransportResponseHandler<NodeTasksResponse>() {                          @Override                         public NodeTasksResponse read(StreamInput in) throws IOException {                             NodeTasksResponse response = new NodeTasksResponse().                             response.readFrom(in).                             return response.                         }                          @Override                         public void handleResponse(NodeTasksResponse response) {                             onOperation(idx, response).                         }                          @Override                         public void handleException(TransportException exp) {                             onFailure(idx, node.getId(), exp).                         }                          @Override                         public String executor() {                             return ThreadPool.Names.SAME.                         }                     }).                 }             } catch (Exception e) {                 onFailure(idx, nodeId, e).             }         }     } }
false;private;2;6;;private void onOperation(int idx, NodeTasksResponse nodeResponse) {     responses.set(idx, nodeResponse).     if (counter.incrementAndGet() == responses.length()) {         finishHim().     } }
false;private;3;11;;private void onFailure(int idx, String nodeId, Throwable t) {     if (logger.isDebugEnabled() && !(t instanceof NodeShouldNotConnectException)) {         logger.debug(new ParameterizedMessage("failed to execute on node [{}]", nodeId), t).     }     responses.set(idx, new FailedNodeException(nodeId, "Failed node [" + nodeId + "]", t)).     if (counter.incrementAndGet() == responses.length()) {         finishHim().     } }
false;private;0;11;;private void finishHim() {     TasksResponse finalResponse.     try {         finalResponse = newResponse(request, responses).     } catch (Exception e) {         logger.debug("failed to combine responses from nodes", e).         listener.onFailure(e).         return.     }     listener.onResponse(finalResponse). }
false;public;1;9;;@Override public void onResponse(TransportTasksAction<OperationTask, TasksRequest, TasksResponse, TaskResponse>.NodeTasksResponse response) {     try {         channel.sendResponse(response).     } catch (Exception e) {         onFailure(e).     } }
false;public;1;9;;@Override public void onFailure(Exception e) {     try {         channel.sendResponse(e).     } catch (IOException e1) {         e1.addSuppressed(e).         logger.warn("Failed to send failure", e1).     } }
false;public;3;24;;@Override public void messageReceived(final NodeTaskRequest request, final TransportChannel channel, Task task) throws Exception {     nodeOperation(request, new ActionListener<NodeTasksResponse>() {          @Override         public void onResponse(TransportTasksAction<OperationTask, TasksRequest, TasksResponse, TaskResponse>.NodeTasksResponse response) {             try {                 channel.sendResponse(response).             } catch (Exception e) {                 onFailure(e).             }         }          @Override         public void onFailure(Exception e) {             try {                 channel.sendResponse(e).             } catch (IOException e1) {                 e1.addSuppressed(e).                 logger.warn("Failed to send failure", e1).             }         }     }). }
false;public;1;5;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     tasksRequest.writeTo(out). }
false;public;0;3;;public String getNodeId() {     return nodeId. }
false;public;0;3;;public List<TaskOperationFailure> getExceptions() {     return exceptions. }
false;public;1;20;;@Override public void readFrom(StreamInput in) throws IOException {     super.readFrom(in).     nodeId = in.readString().     int resultsSize = in.readVInt().     results = new ArrayList<>(resultsSize).     for (. resultsSize > 0. resultsSize--) {         final TaskResponse result = in.readBoolean() ? responseReader.read(in) : null.         results.add(result).     }     if (in.readBoolean()) {         int taskFailures = in.readVInt().         exceptions = new ArrayList<>(taskFailures).         for (int i = 0. i < taskFailures. i++) {             exceptions.add(new TaskOperationFailure(in)).         }     } else {         exceptions = null.     } }
false;public;1;22;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeString(nodeId).     out.writeVInt(results.size()).     for (TaskResponse result : results) {         if (result != null) {             out.writeBoolean(true).             result.writeTo(out).         } else {             out.writeBoolean(false).         }     }     out.writeBoolean(exceptions != null).     if (exceptions != null) {         int taskFailures = exceptions.size().         out.writeVInt(taskFailures).         for (TaskOperationFailure exception : exceptions) {             exception.writeTo(out).         }     } }
