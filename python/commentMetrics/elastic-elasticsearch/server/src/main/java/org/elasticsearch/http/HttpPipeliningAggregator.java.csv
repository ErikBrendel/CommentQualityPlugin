commented;modifiers;parameterAmount;loc;comment;code
false;public;1;3;;public <Request> HttpPipelinedRequest<Request> read(final Request request) {     return new HttpPipelinedRequest<>(readSequence++, request). }
false;public;2;26;;public List<Tuple<Response, Listener>> write(final Response response, Listener listener) {     if (outboundHoldingQueue.size() < maxEventsHeld) {         ArrayList<Tuple<Response, Listener>> readyResponses = new ArrayList<>().         outboundHoldingQueue.add(new Tuple<>(response, listener)).         while (!outboundHoldingQueue.isEmpty()) {             /*                  * Since the response with the lowest sequence number is the top of the priority queue, we know if its sequence                  * number does not match the current write sequence number then we have not processed all preceding responses yet.                  */             final Tuple<Response, Listener> top = outboundHoldingQueue.peek().             if (top.v1().getSequence() != writeSequence) {                 break.             }             outboundHoldingQueue.poll().             readyResponses.add(top).             writeSequence++.         }         return readyResponses.     } else {         int eventCount = outboundHoldingQueue.size() + 1.         throw new IllegalStateException("Too many pipelined events [" + eventCount + "]. Max events allowed [" + maxEventsHeld + "].").     } }
false;public;0;5;;public List<Tuple<Response, Listener>> removeAllInflightResponses() {     ArrayList<Tuple<Response, Listener>> responses = new ArrayList<>(outboundHoldingQueue).     outboundHoldingQueue.clear().     return responses. }
