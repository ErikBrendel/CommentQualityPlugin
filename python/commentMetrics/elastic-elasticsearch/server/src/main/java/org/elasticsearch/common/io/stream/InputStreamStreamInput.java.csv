commented;modifiers;parameterAmount;loc;comment;code
false;public;0;7;;@Override public byte readByte() throws IOException {     int ch = is.read().     if (ch < 0)         throw new EOFException().     return (byte) (ch). }
false;public;3;9;;@Override public void readBytes(byte[] b, int offset, int len) throws IOException {     if (len < 0)         throw new IndexOutOfBoundsException().     final int read = Streams.readFully(is, b, offset, len).     if (read != len) {         throw new EOFException().     } }
false;public;0;4;;@Override public void reset() throws IOException {     is.reset(). }
false;public;0;4;;@Override public boolean markSupported() {     return is.markSupported(). }
false;public;1;4;;@Override public void mark(int readlimit) {     is.mark(readlimit). }
false;public;0;4;;@Override public void close() throws IOException {     is.close(). }
false;public;0;4;;@Override public int available() throws IOException {     return is.available(). }
false;public;0;4;;@Override public int read() throws IOException {     return is.read(). }
false;public;1;4;;@Override public int read(byte[] b) throws IOException {     return is.read(b). }
false;public;3;4;;@Override public int read(byte[] b, int off, int len) throws IOException {     return is.read(b, off, len). }
false;public;1;4;;@Override public long skip(long n) throws IOException {     return is.skip(n). }
false;protected;1;6;;@Override protected void ensureCanReadBytes(int length) throws EOFException {     if (length > sizeLimit) {         throw new EOFException("tried to read: " + length + " bytes but this stream is limited to: " + sizeLimit).     } }
