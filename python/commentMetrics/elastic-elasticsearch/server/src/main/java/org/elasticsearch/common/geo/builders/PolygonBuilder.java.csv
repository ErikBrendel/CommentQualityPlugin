commented;modifiers;parameterAmount;loc;comment;code
false;public;1;9;;@Override public void writeTo(StreamOutput out) throws IOException {     shell.writeTo(out).     orientation.writeTo(out).     out.writeVInt(holes.size()).     for (LineStringBuilder hole : holes) {         hole.writeTo(out).     } }
false;public;0;3;;public Orientation orientation() {     return this.orientation. }
true;public;1;3;/**  * Add a new hole to the polygon  * @param hole linear ring defining the hole  * @return this  */ ;/**  * Add a new hole to the polygon  * @param hole linear ring defining the hole  * @return this  */ public PolygonBuilder hole(LineStringBuilder hole) {     return this.hole(hole, false). }
true;public;2;8;/**  * Add a new hole to the polygon  * @param hole linear ring defining the hole  * @param coerce if set to true, it will try to close the hole by adding starting point as end point  * @return this  */ ;/**  * Add a new hole to the polygon  * @param hole linear ring defining the hole  * @param coerce if set to true, it will try to close the hole by adding starting point as end point  * @return this  */ public PolygonBuilder hole(LineStringBuilder hole, boolean coerce) {     if (coerce) {         hole.close().     }     validateLinearRing(hole).     holes.add(hole).     return this. }
true;public;0;3;/**  * @return the list of holes defined for this polygon  */ ;/**  * @return the list of holes defined for this polygon  */ public List<LineStringBuilder> holes() {     return this.holes. }
true;public;0;3;/**  * @return the list of points of the shell for this polygon  */ ;/**  * @return the list of points of the shell for this polygon  */ public LineStringBuilder shell() {     return this.shell. }
true;public;0;4;/**  * Close the shell of the polygon  */ ;/**  * Close the shell of the polygon  */ public PolygonBuilder close() {     shell.close().     return this. }
false;private,static;1;17;;private static void validateLinearRing(LineStringBuilder lineString) {     /**      * Per GeoJSON spec (http://geojson.org/geojson-spec.html#linestring)      * A LinearRing is closed LineString with 4 or more positions. The first and last positions      * are equivalent (they represent equivalent points). Though a LinearRing is not explicitly      * represented as a GeoJSON geometry type, it is referred to in the Polygon geometry type definition.      */     List<Coordinate> points = lineString.coordinates.     if (points.size() < 4) {         throw new IllegalArgumentException("invalid number of points in LinearRing (found [" + points.size() + "] - must be >= 4)").     }     if (!points.get(0).equals(points.get(points.size() - 1))) {         throw new IllegalArgumentException("invalid LinearRing found (coordinates are not closed)").     } }
true;protected;2;8;/**  * Validates only 1 vertex is tangential (shared) between the interior and exterior of a polygon  */ ;/**  * Validates only 1 vertex is tangential (shared) between the interior and exterior of a polygon  */ protected void validateHole(LineStringBuilder shell, LineStringBuilder hole) {     HashSet<Coordinate> exterior = Sets.newHashSet(shell.coordinates).     HashSet<Coordinate> interior = Sets.newHashSet(hole.coordinates).     exterior.retainAll(interior).     if (exterior.size() >= 2) {         throw new InvalidShapeException("Invalid polygon, interior cannot share more than one point with the exterior").     } }
true;public;0;24;/**  * The coordinates setup by the builder will be assembled to a polygon. The result will consist of  * a set of polygons. Each of these components holds a list of linestrings defining the polygon: the  * first set of coordinates will be used as the shell of the polygon. The others are defined to holes  * within the polygon.  * This Method also wraps the polygons at the dateline. In order to this fact the result may  * contains more polygons and less holes than defined in the builder it self.  *  * @return coordinates of the polygon  */ ;/**  * The coordinates setup by the builder will be assembled to a polygon. The result will consist of  * a set of polygons. Each of these components holds a list of linestrings defining the polygon: the  * first set of coordinates will be used as the shell of the polygon. The others are defined to holes  * within the polygon.  * This Method also wraps the polygons at the dateline. In order to this fact the result may  * contains more polygons and less holes than defined in the builder it self.  *  * @return coordinates of the polygon  */ public Coordinate[][][] coordinates() {     // Last point is repeated     int numEdges = shell.coordinates.size() - 1.     for (int i = 0. i < holes.size(). i++) {         numEdges += holes.get(i).coordinates.size() - 1.         validateHole(shell, this.holes.get(i)).     }     Edge[] edges = new Edge[numEdges].     Edge[] holeComponents = new Edge[holes.size()].     final AtomicBoolean translated = new AtomicBoolean(false).     int offset = createEdges(0, orientation, shell, null, edges, 0, translated).     for (int i = 0. i < holes.size(). i++) {         int length = createEdges(i + 1, orientation, shell, this.holes.get(i), edges, offset, translated).         holeComponents[i] = edges[offset].         offset += length.     }     int numHoles = holeComponents.length.     numHoles = merge(edges, 0, intersections(+DATELINE, edges), holeComponents, numHoles).     numHoles = merge(edges, 0, intersections(-DATELINE, edges), holeComponents, numHoles).     return compose(edges, holeComponents, numHoles). }
false;public;0;4;;@Override public JtsGeometry buildS4J() {     return jtsGeometry(buildS4JGeometry(FACTORY, wrapdateline)). }
false;public;0;10;;@Override public org.elasticsearch.geo.geometry.Geometry buildGeometry() {     if (wrapdateline) {         Coordinate[][][] polygons = coordinates().         return polygons.length == 1 ? polygonGeometry(polygons[0]) : multipolygon(polygons).     }     return toPolygonGeometry(). }
false;protected;2;7;;protected XContentBuilder coordinatesArray(XContentBuilder builder, Params params) throws IOException {     shell.coordinatesToXcontent(builder, true).     for (LineStringBuilder hole : holes) {         hole.coordinatesToXcontent(builder, true).     }     return builder. }
false;public;2;11;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     builder.field(ShapeParser.FIELD_TYPE.getPreferredName(), TYPE.shapeName()).     builder.field(ShapeParser.FIELD_ORIENTATION.getPreferredName(), orientation.name().toLowerCase(Locale.ROOT)).     builder.startArray(ShapeParser.FIELD_COORDINATES.getPreferredName()).     coordinatesArray(builder, params).     builder.endArray().     builder.endObject().     return builder. }
false;public;2;10;;public Geometry buildS4JGeometry(GeometryFactory factory, boolean fixDateline) {     if (fixDateline) {         Coordinate[][][] polygons = coordinates().         return polygons.length == 1 ? polygonS4J(factory, polygons[0]) : multipolygonS4J(factory, polygons).     } else {         return toPolygonS4J(factory).     } }
false;public;0;3;;public Polygon toPolygonS4J() {     return toPolygonS4J(FACTORY). }
false;protected;1;9;;protected Polygon toPolygonS4J(GeometryFactory factory) {     final LinearRing shell = linearRingS4J(factory, this.shell.coordinates).     final LinearRing[] holes = new LinearRing[this.holes.size()].     Iterator<LineStringBuilder> iterator = this.holes.iterator().     for (int i = 0. iterator.hasNext(). i++) {         holes[i] = linearRingS4J(factory, iterator.next().coordinates).     }     return factory.createPolygon(shell, holes). }
false;public;0;10;;public org.elasticsearch.geo.geometry.Polygon toPolygonGeometry() {     final List<org.elasticsearch.geo.geometry.LinearRing> holes = new ArrayList<>(this.holes.size()).     for (int i = 0. i < this.holes.size(). ++i) {         holes.add(linearRing(this.holes.get(i).coordinates)).     }     return new org.elasticsearch.geo.geometry.Polygon(new org.elasticsearch.geo.geometry.LinearRing(this.shell.coordinates.stream().mapToDouble(i -> normalizeLat(i.y)).toArray(), this.shell.coordinates.stream().mapToDouble(i -> normalizeLon(i.x)).toArray()), holes). }
false;protected,static;1;4;;protected static org.elasticsearch.geo.geometry.LinearRing linearRing(List<Coordinate> coordinates) {     return new org.elasticsearch.geo.geometry.LinearRing(coordinates.stream().mapToDouble(i -> normalizeLat(i.y)).toArray(), coordinates.stream().mapToDouble(i -> normalizeLon(i.x)).toArray()). }
false;protected,static;2;3;;protected static LinearRing linearRingS4J(GeometryFactory factory, List<Coordinate> coordinates) {     return factory.createLinearRing(coordinates.toArray(new Coordinate[coordinates.size()])). }
false;public;0;4;;@Override public GeoShapeType type() {     return TYPE. }
false;public;0;8;;@Override public int numDimensions() {     if (shell == null) {         throw new IllegalStateException("unable to get number of dimensions, " + "Polygon has not yet been initialized").     }     return shell.numDimensions(). }
false;protected,static;2;14;;protected static Polygon polygonS4J(GeometryFactory factory, Coordinate[][] polygon) {     LinearRing shell = factory.createLinearRing(polygon[0]).     LinearRing[] holes.     if (polygon.length > 1) {         holes = new LinearRing[polygon.length - 1].         for (int i = 0. i < holes.length. i++) {             holes[i] = factory.createLinearRing(polygon[i + 1]).         }     } else {         holes = null.     }     return factory.createPolygon(shell, holes). }
false;protected,static;1;32;;protected static org.elasticsearch.geo.geometry.Polygon polygonGeometry(Coordinate[][] polygon) {     List<org.elasticsearch.geo.geometry.LinearRing> holes.     Coordinate[] shell = polygon[0].     if (polygon.length > 1) {         holes = new ArrayList<>(polygon.length - 1).         for (int i = 1. i < polygon.length. ++i) {             Coordinate[] coords = polygon[i].             // We do not have holes on the dateline as they get eliminated             // when breaking the polygon around it.             double[] x = new double[coords.length].             double[] y = new double[coords.length].             for (int c = 0. c < coords.length. ++c) {                 x[c] = normalizeLon(coords[c].x).                 y[c] = normalizeLat(coords[c].y).             }             holes.add(new org.elasticsearch.geo.geometry.LinearRing(y, x)).         }     } else {         holes = Collections.emptyList().     }     double[] x = new double[shell.length].     double[] y = new double[shell.length].     for (int i = 0. i < shell.length. ++i) {         // Lucene Tessellator treats different +180 and -180 and we should keep the sign.         // normalizeLon method excludes -180.         x[i] = Math.abs(shell[i].x) > 180 ? normalizeLon(shell[i].x) : shell[i].x.         y[i] = normalizeLat(shell[i].y).     }     return new org.elasticsearch.geo.geometry.Polygon(new org.elasticsearch.geo.geometry.LinearRing(y, x), holes). }
true;protected,static;2;7;/**  * Create a Multipolygon from a set of coordinates. Each primary array contains a polygon which  * in turn contains an array of linestrings. These line Strings are represented as an array of  * coordinates. The first linestring will be the shell of the polygon the others define holes  * within the polygon.  *  * @param factory {@link GeometryFactory} to use  * @param polygons definition of polygons  * @return a new Multipolygon  */ ;/**  * Create a Multipolygon from a set of coordinates. Each primary array contains a polygon which  * in turn contains an array of linestrings. These line Strings are represented as an array of  * coordinates. The first linestring will be the shell of the polygon the others define holes  * within the polygon.  *  * @param factory {@link GeometryFactory} to use  * @param polygons definition of polygons  * @return a new Multipolygon  */ protected static MultiPolygon multipolygonS4J(GeometryFactory factory, Coordinate[][][] polygons) {     Polygon[] polygonSet = new Polygon[polygons.length].     for (int i = 0. i < polygonSet.length. i++) {         polygonSet[i] = polygonS4J(factory, polygons[i]).     }     return factory.createMultiPolygon(polygonSet). }
false;protected,static;1;7;;protected static org.elasticsearch.geo.geometry.MultiPolygon multipolygon(Coordinate[][][] polygons) {     List<org.elasticsearch.geo.geometry.Polygon> polygonSet = new ArrayList<>(polygons.length).     for (int i = 0. i < polygons.length. ++i) {         polygonSet.add(polygonGeometry(polygons[i])).     }     return new org.elasticsearch.geo.geometry.MultiPolygon(polygonSet). }
true;private,static;3;66;/**  * This method sets the component id of all edges in a ring to a given id and shifts the  * coordinates of this component according to the dateline  *  * @param edge An arbitrary edge of the component  * @param id id to apply to the component  * @param edges a list of edges to which all edges of the component will be added (could be <code>null</code>)  * @return number of edges that belong to this component  */ ;/**  * This method sets the component id of all edges in a ring to a given id and shifts the  * coordinates of this component according to the dateline  *  * @param edge An arbitrary edge of the component  * @param id id to apply to the component  * @param edges a list of edges to which all edges of the component will be added (could be <code>null</code>)  * @return number of edges that belong to this component  */ private static int component(final Edge edge, final int id, final ArrayList<Edge> edges) {     // find a coordinate that is not part of the dateline     Edge any = edge.     while (any.coordinate.x == +DATELINE || any.coordinate.x == -DATELINE) {         if ((any = any.next) == edge) {             break.         }     }     double shiftOffset = any.coordinate.x > DATELINE ? DATELINE : (any.coordinate.x < -DATELINE ? -DATELINE : 0).     if (debugEnabled()) {         LOGGER.debug("shift: [{}]", shiftOffset).     }     // run along the border of the component, collect the     // edges, shift them according to the dateline and     // update the component id     int length = 0, connectedComponents = 0.     // if there are two connected components, splitIndex keeps track of where to split the edge array     // start at 1 since the source coordinate is shared     int splitIndex = 1.     Edge current = edge.     Edge prev = edge.     // bookkeep the source and sink of each visited coordinate     HashMap<Coordinate, Tuple<Edge, Edge>> visitedEdge = new HashMap<>().     do {         current.coordinate = shift(current.coordinate, shiftOffset).         current.component = id.         if (edges != null) {             // found a closed loop - we have two connected components so we need to slice into two distinct components             if (visitedEdge.containsKey(current.coordinate)) {                 if (connectedComponents > 0 && current.next != edge) {                     throw new InvalidShapeException("Shape contains more than one shared point").                 }                 // a negative id flags the edge as visited for the edges(...) method.                 // since we're splitting connected components, we want the edges method to visit                 // the newly separated component                 final int visitID = -id.                 Edge firstAppearance = visitedEdge.get(current.coordinate).v2().                 // correct the graph pointers by correcting the 'next' pointer for both the                 // first appearance and this appearance of the edge                 Edge temp = firstAppearance.next.                 firstAppearance.next = current.next.                 current.next = temp.                 current.component = visitID.                 // a non-visited value (anything positive)                 do {                     prev.component = visitID.                     prev = visitedEdge.get(prev.coordinate).v1().                     ++splitIndex.                 } while (!current.coordinate.equals(prev.coordinate)).                 ++connectedComponents.             } else {                 visitedEdge.put(current.coordinate, new Tuple<Edge, Edge>(prev, current)).             }             edges.add(current).             prev = current.         }         length++.     } while (connectedComponents == 0 && (current = current.next) != edge).     return (splitIndex != 1) ? length - splitIndex : length. }
true;private,static;2;6;/**  * Compute all coordinates of a component  * @param component an arbitrary edge of the component  * @param coordinates Array of coordinates to write the result to  * @return the coordinates parameter  */ ;/**  * Compute all coordinates of a component  * @param component an arbitrary edge of the component  * @param coordinates Array of coordinates to write the result to  * @return the coordinates parameter  */ private static Coordinate[] coordinates(Edge component, Coordinate[] coordinates) {     for (int i = 0. i < coordinates.length. i++) {         coordinates[i] = (component = component.next).coordinate.     }     return coordinates. }
false;private,static;1;18;;private static Coordinate[][][] buildCoordinates(List<List<Coordinate[]>> components) {     Coordinate[][][] result = new Coordinate[components.size()][][].     for (int i = 0. i < result.length. i++) {         List<Coordinate[]> component = components.get(i).         result[i] = component.toArray(new Coordinate[component.size()][]).     }     if (debugEnabled()) {         for (int i = 0. i < result.length. i++) {             LOGGER.debug("Component [{}]:", i).             for (int j = 0. j < result[i].length. j++) {                 LOGGER.debug("\t{}", Arrays.toString(result[i][j])).             }         }     }     return result. }
false;private,static;2;13;;private static Coordinate[][] holes(Edge[] holes, int numHoles) {     if (numHoles == 0) {         return EMPTY.     }     final Coordinate[][] points = new Coordinate[numHoles][].     for (int i = 0. i < numHoles. i++) {         // mark as visited by inverting the sign         int length = component(holes[i], -(i + 1), null).         points[i] = coordinates(holes[i], new Coordinate[length + 1]).     }     return points. }
false;private,static;3;14;;private static Edge[] edges(Edge[] edges, int numHoles, List<List<Coordinate[]>> components) {     ArrayList<Edge> mainEdges = new ArrayList<>(edges.length).     for (int i = 0. i < edges.length. i++) {         if (edges[i].component >= 0) {             int length = component(edges[i], -(components.size() + numHoles + 1), mainEdges).             List<Coordinate[]> component = new ArrayList<>().             component.add(coordinates(edges[i], new Coordinate[length + 1])).             components.add(component).         }     }     return mainEdges.toArray(new Edge[mainEdges.size()]). }
false;private,static;3;5;;private static Coordinate[][][] compose(Edge[] edges, Edge[] holes, int numHoles) {     final List<List<Coordinate[]>> components = new ArrayList<>().     assign(holes, holes(holes, numHoles), numHoles, edges(edges, numHoles, components), components).     return buildCoordinates(components). }
false;private,static;5;71;;private static void assign(Edge[] holes, Coordinate[][] points, int numHoles, Edge[] edges, List<List<Coordinate[]>> components) {     // is part of the polygon the hole belongs to.     if (debugEnabled()) {         LOGGER.debug("Holes: {}", Arrays.toString(holes)).     }     for (int i = 0. i < numHoles. i++) {         // To do the assignment we assume (and later, elsewhere, check) that each hole is within         // a single component, and the components do not overlap. Based on this assumption, it's         // enough to find a component that contains some vertex of the hole, and         // holes[i].coordinate is such a vertex, so we use that one.         // First, we sort all the edges according to their order of intersection with the line         // of longitude through holes[i].coordinate, in order from south to north. Edges that do         // not intersect this line are sorted to the end of the array and of no further interest         // here.         final Edge current = new Edge(holes[i].coordinate, holes[i].next).         current.intersect = current.coordinate.         final int intersections = intersections(current.coordinate.x, edges).         if (intersections == 0) {             // holes[i].coordinate, so there's no way this hole is within the polygon.             throw new InvalidShapeException("Invalid shape: Hole is not within polygon").         }         // Next we do a binary search to find the position of holes[i].coordinate in the array.         // The binary search returns the index of an exact match, or (-insertionPoint - 1) if         // the vertex lies between the intersections of edges[insertionPoint] and         // edges[insertionPoint+1]. The latter case is vastly more common.         final int pos.         boolean sharedVertex = false.         if (((pos = Arrays.binarySearch(edges, 0, intersections, current, INTERSECTION_ORDER)) >= 0) && !(sharedVertex = (edges[pos].intersect.compareTo(current.coordinate) == 0))) {             // TODO Can this actually happen? Needs a test to exercise it, or else needs to be removed.             throw new InvalidShapeException("Invalid shape: Hole is not within polygon").         }         final int index.         if (sharedVertex) {             // holes[i].coordinate lies exactly on an edge.             // TODO Should this be pos instead of 0? This assigns exact matches to the southernmost component.             index = 0.         } else if (pos == -1) {             // holes[i].coordinate is strictly south of all intersections. Assign it to the             // southernmost component, and allow later validation to spot that it is not             // entirely within the chosen component.             index = 0.         } else {             // holes[i].coordinate is strictly north of at least one intersection. Assign it to             // the component immediately to its south.             index = -(pos + 2).         }         final int component = -edges[index].component - numHoles - 1.         if (debugEnabled()) {             LOGGER.debug("\tposition ({}) of edge {}: {}", index, current, edges[index]).             LOGGER.debug("\tComponent: {}", component).             LOGGER.debug("\tHole intersections ({}): {}", current.coordinate.x, Arrays.toString(edges)).         }         components.get(component).add(points[i]).     } }
false;private,static;5;41;;private static int merge(Edge[] intersections, int offset, int length, Edge[] holes, int numHoles) {     for (int i = 0. i < length. i += 2) {         Edge e1 = intersections[offset + i + 0].         Edge e2 = intersections[offset + i + 1].         // already handled)         if (e2.component > 0) {             // TODO: Check if we could save the set null step             numHoles--.             holes[e2.component - 1] = holes[numHoles].             holes[numHoles] = null.         }         // in support of OGC standards         if (e1.intersect != Edge.MAX_COORDINATE && e2.intersect != Edge.MAX_COORDINATE && !(e1.next.next.coordinate.equals3D(e2.coordinate) && Math.abs(e1.next.coordinate.x) == DATELINE && Math.abs(e2.coordinate.x) == DATELINE)) {             connect(e1, e2).         }     }     return numHoles. }
false;private,static;2;36;;private static void connect(Edge in, Edge out) {     assert in != null && out != null.     assert in != out.     // two edges between this points. One per direction     if (in.intersect != in.next.coordinate) {         // NOTE: the order of the object creation is crucial here! Don't change it!         // first edge has no point on dateline         Edge e1 = new Edge(in.intersect, in.next).         if (out.intersect != out.next.coordinate) {             // second edge has no point on dateline             Edge e2 = new Edge(out.intersect, out.next).             in.next = new Edge(in.intersect, e2, in.intersect).         } else {             // second edge intersects with dateline             in.next = new Edge(in.intersect, out.next, in.intersect).         }         out.next = new Edge(out.intersect, e1, out.intersect).     } else if (in.next != out && in.coordinate != out.intersect) {         // first edge intersects with dateline         Edge e2 = new Edge(out.intersect, in.next, out.intersect).         if (out.intersect != out.next.coordinate) {             // second edge has no point on dateline             Edge e1 = new Edge(out.intersect, out.next).             in.next = new Edge(in.intersect, e1, in.intersect).         } else {             // second edge intersects with dateline             in.next = new Edge(in.intersect, out.next, in.intersect).         }         out.next = e2.     } }
false;private,static;7;10;;private static int createEdges(int component, Orientation orientation, LineStringBuilder shell, LineStringBuilder hole, Edge[] edges, int offset, final AtomicBoolean translated) {     // inner rings (holes) have an opposite direction than the outer rings     // XOR will invert the orientation for outer ring cases (Truth Table:, T/T = F, T/F = T, F/T = T, F/F = F)     boolean direction = (component == 0 ^ orientation == Orientation.RIGHT).     // set the points array accordingly (shell or hole)     Coordinate[] points = (hole != null) ? hole.coordinates(false) : shell.coordinates(false).     ring(component, direction, orientation == Orientation.LEFT, points, 0, edges, offset, points.length - 1, translated).     return points.length - 1. }
true;private,static;9;31;/**  * Create a connected list of a list of coordinates  *  * @param points  *            array of point  * @param offset  *            index of the first point  * @param length  *            number of points  * @return Array of edges  */ ;/**  * Create a connected list of a list of coordinates  *  * @param points  *            array of point  * @param offset  *            index of the first point  * @param length  *            number of points  * @return Array of edges  */ private static Edge[] ring(int component, boolean direction, boolean handedness, Coordinate[] points, int offset, Edge[] edges, int toffset, int length, final AtomicBoolean translated) {     boolean orientation = getOrientation(points, offset, length).     // OGC requires shell as ccw (Right-Handedness) and holes as cw (Left-Handedness)     // since GeoJSON doesn't specify (and doesn't need to) GEO core will assume OGC standards     // thus if orientation is computed as cw, the logic will translate points across dateline     // and convert to a right handed system     // compute the bounding box and calculate range     double[] range = range(points, offset, length).     final double rng = range[1] - range[0].     // translate the points if the following is true     // 1.  shell orientation is cw and range is greater than a hemisphere (180 degrees) but not spanning 2 hemispheres     // (translation would result in a collapsed poly)     // 2.  the shell of the candidate hole has been translated (to preserve the coordinate system)     boolean incorrectOrientation = component == 0 && handedness != orientation.     if ((incorrectOrientation && (rng > DATELINE && rng != 2 * DATELINE)) || (translated.get() && component != 0)) {         translate(points).         // flip the translation bit if the shell is being translated         if (component == 0) {             translated.set(true).         }         // correct the orientation post translation (ccw for shell, cw for holes)         if (component == 0 || (component != 0 && handedness == orientation)) {             orientation = !orientation.         }     }     return concat(component, direction ^ orientation, points, offset, edges, toffset, length). }
true;private,static;3;21;/**  * @return whether the points are clockwise (true) or anticlockwise (false)  */ ;/**  * @return whether the points are clockwise (true) or anticlockwise (false)  */ private static boolean getOrientation(Coordinate[] points, int offset, int length) {     // calculate the direction of the points: find the southernmost point     // and check its neighbors orientation.     final int top = top(points, offset, length).     final int prev = (top + length - 1) % length.     final int next = (top + 1) % length.     final int determinantSign = orient(points[offset + prev].x, points[offset + prev].y, points[offset + top].x, points[offset + top].y, points[offset + next].x, points[offset + next].y).     if (determinantSign == 0) {         // Points are collinear, but `top` is not in the middle if so, so the edges either side of `top` are intersecting.         throw new InvalidShapeException("Cannot determine orientation: edges adjacent to (" + points[offset + top].x + "," + points[offset + top].y + ") coincide").     }     return determinantSign < 0. }
true;private,static;3;13;/**  * @return the (offset) index of the point that is furthest west amongst  * those points that are the furthest south in the set.  */ ;/**  * @return the (offset) index of the point that is furthest west amongst  * those points that are the furthest south in the set.  */ private static int top(Coordinate[] points, int offset, int length) {     // we start at 1 here since top points to 0     int top = 0.     for (int i = 1. i < length. i++) {         if (points[offset + i].y < points[offset + top].y) {             top = i.         } else if (points[offset + i].y == points[offset + top].y) {             if (points[offset + i].x < points[offset + top].x) {                 top = i.             }         }     }     return top. }
false;private,static;3;22;;private static double[] range(Coordinate[] points, int offset, int length) {     double minX = points[0].x.     double maxX = points[0].x.     double minY = points[0].y.     double maxY = points[0].y.     // compute the bounding coordinates (@todo: cleanup brute force)     for (int i = 1. i < length. ++i) {         if (points[offset + i].x < minX) {             minX = points[offset + i].x.         }         if (points[offset + i].x > maxX) {             maxX = points[offset + i].x.         }         if (points[offset + i].y < minY) {             minY = points[offset + i].y.         }         if (points[offset + i].y > maxY) {             maxY = points[offset + i].y.         }     }     return new double[] { minX, maxX, minY, maxY }. }
true;private,static;7;27;/**  * Concatenate a set of points to a polygon  *  * @param component  *            component id of the polygon  * @param direction  *            direction of the ring  * @param points  *            list of points to concatenate  * @param pointOffset  *            index of the first point  * @param edges  *            Array of edges to write the result to  * @param edgeOffset  *            index of the first edge in the result  * @param length  *            number of points to use  * @return the edges creates  */ ;/**  * Concatenate a set of points to a polygon  *  * @param component  *            component id of the polygon  * @param direction  *            direction of the ring  * @param points  *            list of points to concatenate  * @param pointOffset  *            index of the first point  * @param edges  *            Array of edges to write the result to  * @param edgeOffset  *            index of the first edge in the result  * @param length  *            number of points to use  * @return the edges creates  */ private static Edge[] concat(int component, boolean direction, Coordinate[] points, final int pointOffset, Edge[] edges, final int edgeOffset, int length) {     assert edges.length >= length + edgeOffset.     assert points.length >= length + pointOffset.     edges[edgeOffset] = new Edge(points[pointOffset], null).     for (int i = 1. i < length. i++) {         if (direction) {             edges[edgeOffset + i] = new Edge(points[pointOffset + i], edges[edgeOffset + i - 1]).             edges[edgeOffset + i].component = component.         } else if (!edges[edgeOffset + i - 1].coordinate.equals(points[pointOffset + i])) {             edges[edgeOffset + i - 1].next = edges[edgeOffset + i] = new Edge(points[pointOffset + i], null).             edges[edgeOffset + i - 1].component = component.         } else {             throw new InvalidShapeException("Provided shape has duplicate consecutive coordinates at: " + points[pointOffset + i]).         }     }     if (direction) {         edges[edgeOffset].setNext(edges[edgeOffset + length - 1]).         edges[edgeOffset].component = component.     } else {         edges[edgeOffset + length - 1].setNext(edges[edgeOffset]).         edges[edgeOffset + length - 1].component = component.     }     return edges. }
true;private,static;1;7;/**  * Transforms coordinates in the eastern hemisphere (-180:0) to a (180:360) range  */ ;/**  * Transforms coordinates in the eastern hemisphere (-180:0) to a (180:360) range  */ private static void translate(Coordinate[] points) {     for (Coordinate c : points) {         if (c.x < 0) {             c.x += 2 * DATELINE.         }     } }
false;protected;0;12;;@Override protected StringBuilder contentToWKT() {     StringBuilder sb = new StringBuilder().     sb.append('(').     sb.append(ShapeBuilder.coordinateListToWKT(shell.coordinates)).     for (LineStringBuilder hole : holes) {         sb.append(", ").         sb.append(ShapeBuilder.coordinateListToWKT(hole.coordinates)).     }     sb.append(')').     return sb. }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(shell, holes, orientation). }
false;public;1;13;;@Override public boolean equals(Object obj) {     if (this == obj) {         return true.     }     if (obj == null || getClass() != obj.getClass()) {         return false.     }     PolygonBuilder other = (PolygonBuilder) obj.     return Objects.equals(shell, other.shell) && Objects.equals(holes, other.holes) && Objects.equals(orientation, other.orientation). }
