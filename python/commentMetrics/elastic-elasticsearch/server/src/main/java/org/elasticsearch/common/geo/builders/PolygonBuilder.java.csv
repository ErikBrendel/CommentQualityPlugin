# id;timestamp;commentText;codeText;commentWords;codeWords
PolygonBuilder -> public Coordinate[][][] coordinates();1524684173;The coordinates setup by the builder will be assembled to a polygon. The result will consist of_a set of polygons. Each of these components holds a list of linestrings defining the polygon: the_first set of coordinates will be used as the shell of the polygon. The others are defined to holes_within the polygon._This Method also wraps the polygons at the dateline. In order to this fact the result may_contains more polygons and less holes than defined in the builder it self.__@return coordinates of the polygon;public Coordinate[][][] coordinates() {_        int numEdges = shell.coordinates.size()-1_ _        for (int i = 0_ i < holes.size()_ i++) {_            numEdges += holes.get(i).coordinates.size()-1__            validateHole(shell, this.holes.get(i))__        }__        Edge[] edges = new Edge[numEdges]__        Edge[] holeComponents = new Edge[holes.size()]__        final AtomicBoolean translated = new AtomicBoolean(false)__        int offset = createEdges(0, orientation, shell, null, edges, 0, translated)__        for (int i = 0_ i < holes.size()_ i++) {_            int length = createEdges(i+1, orientation, shell, this.holes.get(i), edges, offset, translated)__            holeComponents[i] = edges[offset]__            offset += length__        }__        int numHoles = holeComponents.length___        numHoles = merge(edges, 0, intersections(+DATELINE, edges), holeComponents, numHoles)__        numHoles = merge(edges, 0, intersections(-DATELINE, edges), holeComponents, numHoles)___        return compose(edges, holeComponents, numHoles)__    };the,coordinates,setup,by,the,builder,will,be,assembled,to,a,polygon,the,result,will,consist,of,a,set,of,polygons,each,of,these,components,holds,a,list,of,linestrings,defining,the,polygon,the,first,set,of,coordinates,will,be,used,as,the,shell,of,the,polygon,the,others,are,defined,to,holes,within,the,polygon,this,method,also,wraps,the,polygons,at,the,dateline,in,order,to,this,fact,the,result,may,contains,more,polygons,and,less,holes,than,defined,in,the,builder,it,self,return,coordinates,of,the,polygon;public,coordinate,coordinates,int,num,edges,shell,coordinates,size,1,for,int,i,0,i,holes,size,i,num,edges,holes,get,i,coordinates,size,1,validate,hole,shell,this,holes,get,i,edge,edges,new,edge,num,edges,edge,hole,components,new,edge,holes,size,final,atomic,boolean,translated,new,atomic,boolean,false,int,offset,create,edges,0,orientation,shell,null,edges,0,translated,for,int,i,0,i,holes,size,i,int,length,create,edges,i,1,orientation,shell,this,holes,get,i,edges,offset,translated,hole,components,i,edges,offset,offset,length,int,num,holes,hole,components,length,num,holes,merge,edges,0,intersections,dateline,edges,hole,components,num,holes,num,holes,merge,edges,0,intersections,dateline,edges,hole,components,num,holes,return,compose,edges,hole,components,num,holes
PolygonBuilder -> public Coordinate[][][] coordinates();1528762805;The coordinates setup by the builder will be assembled to a polygon. The result will consist of_a set of polygons. Each of these components holds a list of linestrings defining the polygon: the_first set of coordinates will be used as the shell of the polygon. The others are defined to holes_within the polygon._This Method also wraps the polygons at the dateline. In order to this fact the result may_contains more polygons and less holes than defined in the builder it self.__@return coordinates of the polygon;public Coordinate[][][] coordinates() {_        int numEdges = shell.coordinates.size()-1_ _        for (int i = 0_ i < holes.size()_ i++) {_            numEdges += holes.get(i).coordinates.size()-1__            validateHole(shell, this.holes.get(i))__        }__        Edge[] edges = new Edge[numEdges]__        Edge[] holeComponents = new Edge[holes.size()]__        final AtomicBoolean translated = new AtomicBoolean(false)__        int offset = createEdges(0, orientation, shell, null, edges, 0, translated)__        for (int i = 0_ i < holes.size()_ i++) {_            int length = createEdges(i+1, orientation, shell, this.holes.get(i), edges, offset, translated)__            holeComponents[i] = edges[offset]__            offset += length__        }__        int numHoles = holeComponents.length___        numHoles = merge(edges, 0, intersections(+DATELINE, edges), holeComponents, numHoles)__        numHoles = merge(edges, 0, intersections(-DATELINE, edges), holeComponents, numHoles)___        return compose(edges, holeComponents, numHoles)__    };the,coordinates,setup,by,the,builder,will,be,assembled,to,a,polygon,the,result,will,consist,of,a,set,of,polygons,each,of,these,components,holds,a,list,of,linestrings,defining,the,polygon,the,first,set,of,coordinates,will,be,used,as,the,shell,of,the,polygon,the,others,are,defined,to,holes,within,the,polygon,this,method,also,wraps,the,polygons,at,the,dateline,in,order,to,this,fact,the,result,may,contains,more,polygons,and,less,holes,than,defined,in,the,builder,it,self,return,coordinates,of,the,polygon;public,coordinate,coordinates,int,num,edges,shell,coordinates,size,1,for,int,i,0,i,holes,size,i,num,edges,holes,get,i,coordinates,size,1,validate,hole,shell,this,holes,get,i,edge,edges,new,edge,num,edges,edge,hole,components,new,edge,holes,size,final,atomic,boolean,translated,new,atomic,boolean,false,int,offset,create,edges,0,orientation,shell,null,edges,0,translated,for,int,i,0,i,holes,size,i,int,length,create,edges,i,1,orientation,shell,this,holes,get,i,edges,offset,translated,hole,components,i,edges,offset,offset,length,int,num,holes,hole,components,length,num,holes,merge,edges,0,intersections,dateline,edges,hole,components,num,holes,num,holes,merge,edges,0,intersections,dateline,edges,hole,components,num,holes,return,compose,edges,hole,components,num,holes
PolygonBuilder -> public Coordinate[][][] coordinates();1533063033;The coordinates setup by the builder will be assembled to a polygon. The result will consist of_a set of polygons. Each of these components holds a list of linestrings defining the polygon: the_first set of coordinates will be used as the shell of the polygon. The others are defined to holes_within the polygon._This Method also wraps the polygons at the dateline. In order to this fact the result may_contains more polygons and less holes than defined in the builder it self.__@return coordinates of the polygon;public Coordinate[][][] coordinates() {_        int numEdges = shell.coordinates.size()-1_ _        for (int i = 0_ i < holes.size()_ i++) {_            numEdges += holes.get(i).coordinates.size()-1__            validateHole(shell, this.holes.get(i))__        }__        Edge[] edges = new Edge[numEdges]__        Edge[] holeComponents = new Edge[holes.size()]__        final AtomicBoolean translated = new AtomicBoolean(false)__        int offset = createEdges(0, orientation, shell, null, edges, 0, translated)__        for (int i = 0_ i < holes.size()_ i++) {_            int length = createEdges(i+1, orientation, shell, this.holes.get(i), edges, offset, translated)__            holeComponents[i] = edges[offset]__            offset += length__        }__        int numHoles = holeComponents.length___        numHoles = merge(edges, 0, intersections(+DATELINE, edges), holeComponents, numHoles)__        numHoles = merge(edges, 0, intersections(-DATELINE, edges), holeComponents, numHoles)___        return compose(edges, holeComponents, numHoles)__    };the,coordinates,setup,by,the,builder,will,be,assembled,to,a,polygon,the,result,will,consist,of,a,set,of,polygons,each,of,these,components,holds,a,list,of,linestrings,defining,the,polygon,the,first,set,of,coordinates,will,be,used,as,the,shell,of,the,polygon,the,others,are,defined,to,holes,within,the,polygon,this,method,also,wraps,the,polygons,at,the,dateline,in,order,to,this,fact,the,result,may,contains,more,polygons,and,less,holes,than,defined,in,the,builder,it,self,return,coordinates,of,the,polygon;public,coordinate,coordinates,int,num,edges,shell,coordinates,size,1,for,int,i,0,i,holes,size,i,num,edges,holes,get,i,coordinates,size,1,validate,hole,shell,this,holes,get,i,edge,edges,new,edge,num,edges,edge,hole,components,new,edge,holes,size,final,atomic,boolean,translated,new,atomic,boolean,false,int,offset,create,edges,0,orientation,shell,null,edges,0,translated,for,int,i,0,i,holes,size,i,int,length,create,edges,i,1,orientation,shell,this,holes,get,i,edges,offset,translated,hole,components,i,edges,offset,offset,length,int,num,holes,hole,components,length,num,holes,merge,edges,0,intersections,dateline,edges,hole,components,num,holes,num,holes,merge,edges,0,intersections,dateline,edges,hole,components,num,holes,return,compose,edges,hole,components,num,holes
PolygonBuilder -> public Coordinate[][][] coordinates();1542820501;The coordinates setup by the builder will be assembled to a polygon. The result will consist of_a set of polygons. Each of these components holds a list of linestrings defining the polygon: the_first set of coordinates will be used as the shell of the polygon. The others are defined to holes_within the polygon._This Method also wraps the polygons at the dateline. In order to this fact the result may_contains more polygons and less holes than defined in the builder it self.__@return coordinates of the polygon;public Coordinate[][][] coordinates() {_        int numEdges = shell.coordinates.size()-1_ _        for (int i = 0_ i < holes.size()_ i++) {_            numEdges += holes.get(i).coordinates.size()-1__            validateHole(shell, this.holes.get(i))__        }__        Edge[] edges = new Edge[numEdges]__        Edge[] holeComponents = new Edge[holes.size()]__        final AtomicBoolean translated = new AtomicBoolean(false)__        int offset = createEdges(0, orientation, shell, null, edges, 0, translated)__        for (int i = 0_ i < holes.size()_ i++) {_            int length = createEdges(i+1, orientation, shell, this.holes.get(i), edges, offset, translated)__            holeComponents[i] = edges[offset]__            offset += length__        }__        int numHoles = holeComponents.length___        numHoles = merge(edges, 0, intersections(+DATELINE, edges), holeComponents, numHoles)__        numHoles = merge(edges, 0, intersections(-DATELINE, edges), holeComponents, numHoles)___        return compose(edges, holeComponents, numHoles)__    };the,coordinates,setup,by,the,builder,will,be,assembled,to,a,polygon,the,result,will,consist,of,a,set,of,polygons,each,of,these,components,holds,a,list,of,linestrings,defining,the,polygon,the,first,set,of,coordinates,will,be,used,as,the,shell,of,the,polygon,the,others,are,defined,to,holes,within,the,polygon,this,method,also,wraps,the,polygons,at,the,dateline,in,order,to,this,fact,the,result,may,contains,more,polygons,and,less,holes,than,defined,in,the,builder,it,self,return,coordinates,of,the,polygon;public,coordinate,coordinates,int,num,edges,shell,coordinates,size,1,for,int,i,0,i,holes,size,i,num,edges,holes,get,i,coordinates,size,1,validate,hole,shell,this,holes,get,i,edge,edges,new,edge,num,edges,edge,hole,components,new,edge,holes,size,final,atomic,boolean,translated,new,atomic,boolean,false,int,offset,create,edges,0,orientation,shell,null,edges,0,translated,for,int,i,0,i,holes,size,i,int,length,create,edges,i,1,orientation,shell,this,holes,get,i,edges,offset,translated,hole,components,i,edges,offset,offset,length,int,num,holes,hole,components,length,num,holes,merge,edges,0,intersections,dateline,edges,hole,components,num,holes,num,holes,merge,edges,0,intersections,dateline,edges,hole,components,num,holes,return,compose,edges,hole,components,num,holes
PolygonBuilder -> public Coordinate[][][] coordinates();1547195838;The coordinates setup by the builder will be assembled to a polygon. The result will consist of_a set of polygons. Each of these components holds a list of linestrings defining the polygon: the_first set of coordinates will be used as the shell of the polygon. The others are defined to holes_within the polygon._This Method also wraps the polygons at the dateline. In order to this fact the result may_contains more polygons and less holes than defined in the builder it self.__@return coordinates of the polygon;public Coordinate[][][] coordinates() {_        int numEdges = shell.coordinates.size()-1_ _        for (int i = 0_ i < holes.size()_ i++) {_            numEdges += holes.get(i).coordinates.size()-1__            validateHole(shell, this.holes.get(i))__        }__        Edge[] edges = new Edge[numEdges]__        Edge[] holeComponents = new Edge[holes.size()]__        final AtomicBoolean translated = new AtomicBoolean(false)__        int offset = createEdges(0, orientation, shell, null, edges, 0, translated)__        for (int i = 0_ i < holes.size()_ i++) {_            int length = createEdges(i+1, orientation, shell, this.holes.get(i), edges, offset, translated)__            holeComponents[i] = edges[offset]__            offset += length__        }__        int numHoles = holeComponents.length___        numHoles = merge(edges, 0, intersections(+DATELINE, edges), holeComponents, numHoles)__        numHoles = merge(edges, 0, intersections(-DATELINE, edges), holeComponents, numHoles)___        return compose(edges, holeComponents, numHoles)__    };the,coordinates,setup,by,the,builder,will,be,assembled,to,a,polygon,the,result,will,consist,of,a,set,of,polygons,each,of,these,components,holds,a,list,of,linestrings,defining,the,polygon,the,first,set,of,coordinates,will,be,used,as,the,shell,of,the,polygon,the,others,are,defined,to,holes,within,the,polygon,this,method,also,wraps,the,polygons,at,the,dateline,in,order,to,this,fact,the,result,may,contains,more,polygons,and,less,holes,than,defined,in,the,builder,it,self,return,coordinates,of,the,polygon;public,coordinate,coordinates,int,num,edges,shell,coordinates,size,1,for,int,i,0,i,holes,size,i,num,edges,holes,get,i,coordinates,size,1,validate,hole,shell,this,holes,get,i,edge,edges,new,edge,num,edges,edge,hole,components,new,edge,holes,size,final,atomic,boolean,translated,new,atomic,boolean,false,int,offset,create,edges,0,orientation,shell,null,edges,0,translated,for,int,i,0,i,holes,size,i,int,length,create,edges,i,1,orientation,shell,this,holes,get,i,edges,offset,translated,hole,components,i,edges,offset,offset,length,int,num,holes,hole,components,length,num,holes,merge,edges,0,intersections,dateline,edges,hole,components,num,holes,num,holes,merge,edges,0,intersections,dateline,edges,hole,components,num,holes,return,compose,edges,hole,components,num,holes
PolygonBuilder -> public Coordinate[][][] coordinates();1548434247;The coordinates setup by the builder will be assembled to a polygon. The result will consist of_a set of polygons. Each of these components holds a list of linestrings defining the polygon: the_first set of coordinates will be used as the shell of the polygon. The others are defined to holes_within the polygon._This Method also wraps the polygons at the dateline. In order to this fact the result may_contains more polygons and less holes than defined in the builder it self.__@return coordinates of the polygon;public Coordinate[][][] coordinates() {_        int numEdges = shell.coordinates.size()-1_ _        for (int i = 0_ i < holes.size()_ i++) {_            numEdges += holes.get(i).coordinates.size()-1__            validateHole(shell, this.holes.get(i))__        }__        Edge[] edges = new Edge[numEdges]__        Edge[] holeComponents = new Edge[holes.size()]__        final AtomicBoolean translated = new AtomicBoolean(false)__        int offset = createEdges(0, orientation, shell, null, edges, 0, translated)__        for (int i = 0_ i < holes.size()_ i++) {_            int length = createEdges(i+1, orientation, shell, this.holes.get(i), edges, offset, translated)__            holeComponents[i] = edges[offset]__            offset += length__        }__        int numHoles = holeComponents.length___        numHoles = merge(edges, 0, intersections(+DATELINE, edges), holeComponents, numHoles)__        numHoles = merge(edges, 0, intersections(-DATELINE, edges), holeComponents, numHoles)___        return compose(edges, holeComponents, numHoles)__    };the,coordinates,setup,by,the,builder,will,be,assembled,to,a,polygon,the,result,will,consist,of,a,set,of,polygons,each,of,these,components,holds,a,list,of,linestrings,defining,the,polygon,the,first,set,of,coordinates,will,be,used,as,the,shell,of,the,polygon,the,others,are,defined,to,holes,within,the,polygon,this,method,also,wraps,the,polygons,at,the,dateline,in,order,to,this,fact,the,result,may,contains,more,polygons,and,less,holes,than,defined,in,the,builder,it,self,return,coordinates,of,the,polygon;public,coordinate,coordinates,int,num,edges,shell,coordinates,size,1,for,int,i,0,i,holes,size,i,num,edges,holes,get,i,coordinates,size,1,validate,hole,shell,this,holes,get,i,edge,edges,new,edge,num,edges,edge,hole,components,new,edge,holes,size,final,atomic,boolean,translated,new,atomic,boolean,false,int,offset,create,edges,0,orientation,shell,null,edges,0,translated,for,int,i,0,i,holes,size,i,int,length,create,edges,i,1,orientation,shell,this,holes,get,i,edges,offset,translated,hole,components,i,edges,offset,offset,length,int,num,holes,hole,components,length,num,holes,merge,edges,0,intersections,dateline,edges,hole,components,num,holes,num,holes,merge,edges,0,intersections,dateline,edges,hole,components,num,holes,return,compose,edges,hole,components,num,holes
PolygonBuilder -> protected static MultiPolygon multipolygon(GeometryFactory factory, Coordinate[][][] polygons);1524684173;Create a Multipolygon from a set of coordinates. Each primary array contains a polygon which_in turn contains an array of linestrings. These line Strings are represented as an array of_coordinates. The first linestring will be the shell of the polygon the others define holes_within the polygon.__@param factory {@link GeometryFactory} to use_@param polygons definition of polygons_@return a new Multipolygon;protected static MultiPolygon multipolygon(GeometryFactory factory, Coordinate[][][] polygons) {_        Polygon[] polygonSet = new Polygon[polygons.length]__        for (int i = 0_ i < polygonSet.length_ i++) {_            polygonSet[i] = polygon(factory, polygons[i])__        }_        return factory.createMultiPolygon(polygonSet)__    };create,a,multipolygon,from,a,set,of,coordinates,each,primary,array,contains,a,polygon,which,in,turn,contains,an,array,of,linestrings,these,line,strings,are,represented,as,an,array,of,coordinates,the,first,linestring,will,be,the,shell,of,the,polygon,the,others,define,holes,within,the,polygon,param,factory,link,geometry,factory,to,use,param,polygons,definition,of,polygons,return,a,new,multipolygon;protected,static,multi,polygon,multipolygon,geometry,factory,factory,coordinate,polygons,polygon,polygon,set,new,polygon,polygons,length,for,int,i,0,i,polygon,set,length,i,polygon,set,i,polygon,factory,polygons,i,return,factory,create,multi,polygon,polygon,set
PolygonBuilder -> protected static MultiPolygon multipolygon(GeometryFactory factory, Coordinate[][][] polygons);1528762805;Create a Multipolygon from a set of coordinates. Each primary array contains a polygon which_in turn contains an array of linestrings. These line Strings are represented as an array of_coordinates. The first linestring will be the shell of the polygon the others define holes_within the polygon.__@param factory {@link GeometryFactory} to use_@param polygons definition of polygons_@return a new Multipolygon;protected static MultiPolygon multipolygon(GeometryFactory factory, Coordinate[][][] polygons) {_        Polygon[] polygonSet = new Polygon[polygons.length]__        for (int i = 0_ i < polygonSet.length_ i++) {_            polygonSet[i] = polygon(factory, polygons[i])__        }_        return factory.createMultiPolygon(polygonSet)__    };create,a,multipolygon,from,a,set,of,coordinates,each,primary,array,contains,a,polygon,which,in,turn,contains,an,array,of,linestrings,these,line,strings,are,represented,as,an,array,of,coordinates,the,first,linestring,will,be,the,shell,of,the,polygon,the,others,define,holes,within,the,polygon,param,factory,link,geometry,factory,to,use,param,polygons,definition,of,polygons,return,a,new,multipolygon;protected,static,multi,polygon,multipolygon,geometry,factory,factory,coordinate,polygons,polygon,polygon,set,new,polygon,polygons,length,for,int,i,0,i,polygon,set,length,i,polygon,set,i,polygon,factory,polygons,i,return,factory,create,multi,polygon,polygon,set
PolygonBuilder -> protected static MultiPolygon multipolygon(GeometryFactory factory, Coordinate[][][] polygons);1533063033;Create a Multipolygon from a set of coordinates. Each primary array contains a polygon which_in turn contains an array of linestrings. These line Strings are represented as an array of_coordinates. The first linestring will be the shell of the polygon the others define holes_within the polygon.__@param factory {@link GeometryFactory} to use_@param polygons definition of polygons_@return a new Multipolygon;protected static MultiPolygon multipolygon(GeometryFactory factory, Coordinate[][][] polygons) {_        Polygon[] polygonSet = new Polygon[polygons.length]__        for (int i = 0_ i < polygonSet.length_ i++) {_            polygonSet[i] = polygon(factory, polygons[i])__        }_        return factory.createMultiPolygon(polygonSet)__    };create,a,multipolygon,from,a,set,of,coordinates,each,primary,array,contains,a,polygon,which,in,turn,contains,an,array,of,linestrings,these,line,strings,are,represented,as,an,array,of,coordinates,the,first,linestring,will,be,the,shell,of,the,polygon,the,others,define,holes,within,the,polygon,param,factory,link,geometry,factory,to,use,param,polygons,definition,of,polygons,return,a,new,multipolygon;protected,static,multi,polygon,multipolygon,geometry,factory,factory,coordinate,polygons,polygon,polygon,set,new,polygon,polygons,length,for,int,i,0,i,polygon,set,length,i,polygon,set,i,polygon,factory,polygons,i,return,factory,create,multi,polygon,polygon,set
PolygonBuilder -> private static Edge[] concat(int component, boolean direction, Coordinate[] points, final int pointOffset, Edge[] edges,             final int edgeOffset, int length);1524684173;Concatenate a set of points to a polygon__@param component_component id of the polygon_@param direction_direction of the ring_@param points_list of points to concatenate_@param pointOffset_index of the first point_@param edges_Array of edges to write the result to_@param edgeOffset_index of the first edge in the result_@param length_number of points to use_@return the edges creates;private static Edge[] concat(int component, boolean direction, Coordinate[] points, final int pointOffset, Edge[] edges,_            final int edgeOffset, int length) {_        assert edges.length >= length+edgeOffset__        assert points.length >= length+pointOffset__        edges[edgeOffset] = new Edge(points[pointOffset], null)__        for (int i = 1_ i < length_ i++) {_            if (direction) {_                edges[edgeOffset + i] = new Edge(points[pointOffset + i], edges[edgeOffset + i - 1])__                edges[edgeOffset + i].component = component__            } else if(!edges[edgeOffset + i - 1].coordinate.equals(points[pointOffset + i])) {_                edges[edgeOffset + i - 1].next = edges[edgeOffset + i] = new Edge(points[pointOffset + i], null)__                edges[edgeOffset + i - 1].component = component__            } else {_                throw new InvalidShapeException("Provided shape has duplicate consecutive coordinates at: " + points[pointOffset + i])__            }_        }__        if (direction) {_            edges[edgeOffset].setNext(edges[edgeOffset + length - 1])__            edges[edgeOffset].component = component__        } else {_            edges[edgeOffset + length - 1].setNext(edges[edgeOffset])__            edges[edgeOffset + length - 1].component = component__        }__        return edges__    };concatenate,a,set,of,points,to,a,polygon,param,component,component,id,of,the,polygon,param,direction,direction,of,the,ring,param,points,list,of,points,to,concatenate,param,point,offset,index,of,the,first,point,param,edges,array,of,edges,to,write,the,result,to,param,edge,offset,index,of,the,first,edge,in,the,result,param,length,number,of,points,to,use,return,the,edges,creates;private,static,edge,concat,int,component,boolean,direction,coordinate,points,final,int,point,offset,edge,edges,final,int,edge,offset,int,length,assert,edges,length,length,edge,offset,assert,points,length,length,point,offset,edges,edge,offset,new,edge,points,point,offset,null,for,int,i,1,i,length,i,if,direction,edges,edge,offset,i,new,edge,points,point,offset,i,edges,edge,offset,i,1,edges,edge,offset,i,component,component,else,if,edges,edge,offset,i,1,coordinate,equals,points,point,offset,i,edges,edge,offset,i,1,next,edges,edge,offset,i,new,edge,points,point,offset,i,null,edges,edge,offset,i,1,component,component,else,throw,new,invalid,shape,exception,provided,shape,has,duplicate,consecutive,coordinates,at,points,point,offset,i,if,direction,edges,edge,offset,set,next,edges,edge,offset,length,1,edges,edge,offset,component,component,else,edges,edge,offset,length,1,set,next,edges,edge,offset,edges,edge,offset,length,1,component,component,return,edges
PolygonBuilder -> private static Edge[] concat(int component, boolean direction, Coordinate[] points, final int pointOffset, Edge[] edges,             final int edgeOffset, int length);1528762805;Concatenate a set of points to a polygon__@param component_component id of the polygon_@param direction_direction of the ring_@param points_list of points to concatenate_@param pointOffset_index of the first point_@param edges_Array of edges to write the result to_@param edgeOffset_index of the first edge in the result_@param length_number of points to use_@return the edges creates;private static Edge[] concat(int component, boolean direction, Coordinate[] points, final int pointOffset, Edge[] edges,_            final int edgeOffset, int length) {_        assert edges.length >= length+edgeOffset__        assert points.length >= length+pointOffset__        edges[edgeOffset] = new Edge(points[pointOffset], null)__        for (int i = 1_ i < length_ i++) {_            if (direction) {_                edges[edgeOffset + i] = new Edge(points[pointOffset + i], edges[edgeOffset + i - 1])__                edges[edgeOffset + i].component = component__            } else if(!edges[edgeOffset + i - 1].coordinate.equals(points[pointOffset + i])) {_                edges[edgeOffset + i - 1].next = edges[edgeOffset + i] = new Edge(points[pointOffset + i], null)__                edges[edgeOffset + i - 1].component = component__            } else {_                throw new InvalidShapeException("Provided shape has duplicate consecutive coordinates at: " + points[pointOffset + i])__            }_        }__        if (direction) {_            edges[edgeOffset].setNext(edges[edgeOffset + length - 1])__            edges[edgeOffset].component = component__        } else {_            edges[edgeOffset + length - 1].setNext(edges[edgeOffset])__            edges[edgeOffset + length - 1].component = component__        }__        return edges__    };concatenate,a,set,of,points,to,a,polygon,param,component,component,id,of,the,polygon,param,direction,direction,of,the,ring,param,points,list,of,points,to,concatenate,param,point,offset,index,of,the,first,point,param,edges,array,of,edges,to,write,the,result,to,param,edge,offset,index,of,the,first,edge,in,the,result,param,length,number,of,points,to,use,return,the,edges,creates;private,static,edge,concat,int,component,boolean,direction,coordinate,points,final,int,point,offset,edge,edges,final,int,edge,offset,int,length,assert,edges,length,length,edge,offset,assert,points,length,length,point,offset,edges,edge,offset,new,edge,points,point,offset,null,for,int,i,1,i,length,i,if,direction,edges,edge,offset,i,new,edge,points,point,offset,i,edges,edge,offset,i,1,edges,edge,offset,i,component,component,else,if,edges,edge,offset,i,1,coordinate,equals,points,point,offset,i,edges,edge,offset,i,1,next,edges,edge,offset,i,new,edge,points,point,offset,i,null,edges,edge,offset,i,1,component,component,else,throw,new,invalid,shape,exception,provided,shape,has,duplicate,consecutive,coordinates,at,points,point,offset,i,if,direction,edges,edge,offset,set,next,edges,edge,offset,length,1,edges,edge,offset,component,component,else,edges,edge,offset,length,1,set,next,edges,edge,offset,edges,edge,offset,length,1,component,component,return,edges
PolygonBuilder -> private static Edge[] concat(int component, boolean direction, Coordinate[] points, final int pointOffset, Edge[] edges,             final int edgeOffset, int length);1533063033;Concatenate a set of points to a polygon__@param component_component id of the polygon_@param direction_direction of the ring_@param points_list of points to concatenate_@param pointOffset_index of the first point_@param edges_Array of edges to write the result to_@param edgeOffset_index of the first edge in the result_@param length_number of points to use_@return the edges creates;private static Edge[] concat(int component, boolean direction, Coordinate[] points, final int pointOffset, Edge[] edges,_            final int edgeOffset, int length) {_        assert edges.length >= length+edgeOffset__        assert points.length >= length+pointOffset__        edges[edgeOffset] = new Edge(points[pointOffset], null)__        for (int i = 1_ i < length_ i++) {_            if (direction) {_                edges[edgeOffset + i] = new Edge(points[pointOffset + i], edges[edgeOffset + i - 1])__                edges[edgeOffset + i].component = component__            } else if(!edges[edgeOffset + i - 1].coordinate.equals(points[pointOffset + i])) {_                edges[edgeOffset + i - 1].next = edges[edgeOffset + i] = new Edge(points[pointOffset + i], null)__                edges[edgeOffset + i - 1].component = component__            } else {_                throw new InvalidShapeException("Provided shape has duplicate consecutive coordinates at: " + points[pointOffset + i])__            }_        }__        if (direction) {_            edges[edgeOffset].setNext(edges[edgeOffset + length - 1])__            edges[edgeOffset].component = component__        } else {_            edges[edgeOffset + length - 1].setNext(edges[edgeOffset])__            edges[edgeOffset + length - 1].component = component__        }__        return edges__    };concatenate,a,set,of,points,to,a,polygon,param,component,component,id,of,the,polygon,param,direction,direction,of,the,ring,param,points,list,of,points,to,concatenate,param,point,offset,index,of,the,first,point,param,edges,array,of,edges,to,write,the,result,to,param,edge,offset,index,of,the,first,edge,in,the,result,param,length,number,of,points,to,use,return,the,edges,creates;private,static,edge,concat,int,component,boolean,direction,coordinate,points,final,int,point,offset,edge,edges,final,int,edge,offset,int,length,assert,edges,length,length,edge,offset,assert,points,length,length,point,offset,edges,edge,offset,new,edge,points,point,offset,null,for,int,i,1,i,length,i,if,direction,edges,edge,offset,i,new,edge,points,point,offset,i,edges,edge,offset,i,1,edges,edge,offset,i,component,component,else,if,edges,edge,offset,i,1,coordinate,equals,points,point,offset,i,edges,edge,offset,i,1,next,edges,edge,offset,i,new,edge,points,point,offset,i,null,edges,edge,offset,i,1,component,component,else,throw,new,invalid,shape,exception,provided,shape,has,duplicate,consecutive,coordinates,at,points,point,offset,i,if,direction,edges,edge,offset,set,next,edges,edge,offset,length,1,edges,edge,offset,component,component,else,edges,edge,offset,length,1,set,next,edges,edge,offset,edges,edge,offset,length,1,component,component,return,edges
PolygonBuilder -> private static Edge[] concat(int component, boolean direction, Coordinate[] points, final int pointOffset, Edge[] edges,             final int edgeOffset, int length);1542820501;Concatenate a set of points to a polygon__@param component_component id of the polygon_@param direction_direction of the ring_@param points_list of points to concatenate_@param pointOffset_index of the first point_@param edges_Array of edges to write the result to_@param edgeOffset_index of the first edge in the result_@param length_number of points to use_@return the edges creates;private static Edge[] concat(int component, boolean direction, Coordinate[] points, final int pointOffset, Edge[] edges,_            final int edgeOffset, int length) {_        assert edges.length >= length+edgeOffset__        assert points.length >= length+pointOffset__        edges[edgeOffset] = new Edge(points[pointOffset], null)__        for (int i = 1_ i < length_ i++) {_            if (direction) {_                edges[edgeOffset + i] = new Edge(points[pointOffset + i], edges[edgeOffset + i - 1])__                edges[edgeOffset + i].component = component__            } else if(!edges[edgeOffset + i - 1].coordinate.equals(points[pointOffset + i])) {_                edges[edgeOffset + i - 1].next = edges[edgeOffset + i] = new Edge(points[pointOffset + i], null)__                edges[edgeOffset + i - 1].component = component__            } else {_                throw new InvalidShapeException("Provided shape has duplicate consecutive coordinates at: " + points[pointOffset + i])__            }_        }__        if (direction) {_            edges[edgeOffset].setNext(edges[edgeOffset + length - 1])__            edges[edgeOffset].component = component__        } else {_            edges[edgeOffset + length - 1].setNext(edges[edgeOffset])__            edges[edgeOffset + length - 1].component = component__        }__        return edges__    };concatenate,a,set,of,points,to,a,polygon,param,component,component,id,of,the,polygon,param,direction,direction,of,the,ring,param,points,list,of,points,to,concatenate,param,point,offset,index,of,the,first,point,param,edges,array,of,edges,to,write,the,result,to,param,edge,offset,index,of,the,first,edge,in,the,result,param,length,number,of,points,to,use,return,the,edges,creates;private,static,edge,concat,int,component,boolean,direction,coordinate,points,final,int,point,offset,edge,edges,final,int,edge,offset,int,length,assert,edges,length,length,edge,offset,assert,points,length,length,point,offset,edges,edge,offset,new,edge,points,point,offset,null,for,int,i,1,i,length,i,if,direction,edges,edge,offset,i,new,edge,points,point,offset,i,edges,edge,offset,i,1,edges,edge,offset,i,component,component,else,if,edges,edge,offset,i,1,coordinate,equals,points,point,offset,i,edges,edge,offset,i,1,next,edges,edge,offset,i,new,edge,points,point,offset,i,null,edges,edge,offset,i,1,component,component,else,throw,new,invalid,shape,exception,provided,shape,has,duplicate,consecutive,coordinates,at,points,point,offset,i,if,direction,edges,edge,offset,set,next,edges,edge,offset,length,1,edges,edge,offset,component,component,else,edges,edge,offset,length,1,set,next,edges,edge,offset,edges,edge,offset,length,1,component,component,return,edges
PolygonBuilder -> private static Edge[] concat(int component, boolean direction, Coordinate[] points, final int pointOffset, Edge[] edges,             final int edgeOffset, int length);1547195838;Concatenate a set of points to a polygon__@param component_component id of the polygon_@param direction_direction of the ring_@param points_list of points to concatenate_@param pointOffset_index of the first point_@param edges_Array of edges to write the result to_@param edgeOffset_index of the first edge in the result_@param length_number of points to use_@return the edges creates;private static Edge[] concat(int component, boolean direction, Coordinate[] points, final int pointOffset, Edge[] edges,_            final int edgeOffset, int length) {_        assert edges.length >= length+edgeOffset__        assert points.length >= length+pointOffset__        edges[edgeOffset] = new Edge(points[pointOffset], null)__        for (int i = 1_ i < length_ i++) {_            if (direction) {_                edges[edgeOffset + i] = new Edge(points[pointOffset + i], edges[edgeOffset + i - 1])__                edges[edgeOffset + i].component = component__            } else if(!edges[edgeOffset + i - 1].coordinate.equals(points[pointOffset + i])) {_                edges[edgeOffset + i - 1].next = edges[edgeOffset + i] = new Edge(points[pointOffset + i], null)__                edges[edgeOffset + i - 1].component = component__            } else {_                throw new InvalidShapeException("Provided shape has duplicate consecutive coordinates at: " + points[pointOffset + i])__            }_        }__        if (direction) {_            edges[edgeOffset].setNext(edges[edgeOffset + length - 1])__            edges[edgeOffset].component = component__        } else {_            edges[edgeOffset + length - 1].setNext(edges[edgeOffset])__            edges[edgeOffset + length - 1].component = component__        }__        return edges__    };concatenate,a,set,of,points,to,a,polygon,param,component,component,id,of,the,polygon,param,direction,direction,of,the,ring,param,points,list,of,points,to,concatenate,param,point,offset,index,of,the,first,point,param,edges,array,of,edges,to,write,the,result,to,param,edge,offset,index,of,the,first,edge,in,the,result,param,length,number,of,points,to,use,return,the,edges,creates;private,static,edge,concat,int,component,boolean,direction,coordinate,points,final,int,point,offset,edge,edges,final,int,edge,offset,int,length,assert,edges,length,length,edge,offset,assert,points,length,length,point,offset,edges,edge,offset,new,edge,points,point,offset,null,for,int,i,1,i,length,i,if,direction,edges,edge,offset,i,new,edge,points,point,offset,i,edges,edge,offset,i,1,edges,edge,offset,i,component,component,else,if,edges,edge,offset,i,1,coordinate,equals,points,point,offset,i,edges,edge,offset,i,1,next,edges,edge,offset,i,new,edge,points,point,offset,i,null,edges,edge,offset,i,1,component,component,else,throw,new,invalid,shape,exception,provided,shape,has,duplicate,consecutive,coordinates,at,points,point,offset,i,if,direction,edges,edge,offset,set,next,edges,edge,offset,length,1,edges,edge,offset,component,component,else,edges,edge,offset,length,1,set,next,edges,edge,offset,edges,edge,offset,length,1,component,component,return,edges
PolygonBuilder -> private static Edge[] concat(int component, boolean direction, Coordinate[] points, final int pointOffset, Edge[] edges,             final int edgeOffset, int length);1548434247;Concatenate a set of points to a polygon__@param component_component id of the polygon_@param direction_direction of the ring_@param points_list of points to concatenate_@param pointOffset_index of the first point_@param edges_Array of edges to write the result to_@param edgeOffset_index of the first edge in the result_@param length_number of points to use_@return the edges creates;private static Edge[] concat(int component, boolean direction, Coordinate[] points, final int pointOffset, Edge[] edges,_            final int edgeOffset, int length) {_        assert edges.length >= length+edgeOffset__        assert points.length >= length+pointOffset__        edges[edgeOffset] = new Edge(points[pointOffset], null)__        for (int i = 1_ i < length_ i++) {_            if (direction) {_                edges[edgeOffset + i] = new Edge(points[pointOffset + i], edges[edgeOffset + i - 1])__                edges[edgeOffset + i].component = component__            } else if(!edges[edgeOffset + i - 1].coordinate.equals(points[pointOffset + i])) {_                edges[edgeOffset + i - 1].next = edges[edgeOffset + i] = new Edge(points[pointOffset + i], null)__                edges[edgeOffset + i - 1].component = component__            } else {_                throw new InvalidShapeException("Provided shape has duplicate consecutive coordinates at: " + points[pointOffset + i])__            }_        }__        if (direction) {_            edges[edgeOffset].setNext(edges[edgeOffset + length - 1])__            edges[edgeOffset].component = component__        } else {_            edges[edgeOffset + length - 1].setNext(edges[edgeOffset])__            edges[edgeOffset + length - 1].component = component__        }__        return edges__    };concatenate,a,set,of,points,to,a,polygon,param,component,component,id,of,the,polygon,param,direction,direction,of,the,ring,param,points,list,of,points,to,concatenate,param,point,offset,index,of,the,first,point,param,edges,array,of,edges,to,write,the,result,to,param,edge,offset,index,of,the,first,edge,in,the,result,param,length,number,of,points,to,use,return,the,edges,creates;private,static,edge,concat,int,component,boolean,direction,coordinate,points,final,int,point,offset,edge,edges,final,int,edge,offset,int,length,assert,edges,length,length,edge,offset,assert,points,length,length,point,offset,edges,edge,offset,new,edge,points,point,offset,null,for,int,i,1,i,length,i,if,direction,edges,edge,offset,i,new,edge,points,point,offset,i,edges,edge,offset,i,1,edges,edge,offset,i,component,component,else,if,edges,edge,offset,i,1,coordinate,equals,points,point,offset,i,edges,edge,offset,i,1,next,edges,edge,offset,i,new,edge,points,point,offset,i,null,edges,edge,offset,i,1,component,component,else,throw,new,invalid,shape,exception,provided,shape,has,duplicate,consecutive,coordinates,at,points,point,offset,i,if,direction,edges,edge,offset,set,next,edges,edge,offset,length,1,edges,edge,offset,component,component,else,edges,edge,offset,length,1,set,next,edges,edge,offset,edges,edge,offset,length,1,component,component,return,edges
PolygonBuilder -> public List<LineStringBuilder> holes();1524684173;@return the list of holes defined for this polygon;public List<LineStringBuilder> holes() {_        return this.holes__    };return,the,list,of,holes,defined,for,this,polygon;public,list,line,string,builder,holes,return,this,holes
PolygonBuilder -> public List<LineStringBuilder> holes();1528762805;@return the list of holes defined for this polygon;public List<LineStringBuilder> holes() {_        return this.holes__    };return,the,list,of,holes,defined,for,this,polygon;public,list,line,string,builder,holes,return,this,holes
PolygonBuilder -> public List<LineStringBuilder> holes();1533063033;@return the list of holes defined for this polygon;public List<LineStringBuilder> holes() {_        return this.holes__    };return,the,list,of,holes,defined,for,this,polygon;public,list,line,string,builder,holes,return,this,holes
PolygonBuilder -> public List<LineStringBuilder> holes();1542820501;@return the list of holes defined for this polygon;public List<LineStringBuilder> holes() {_        return this.holes__    };return,the,list,of,holes,defined,for,this,polygon;public,list,line,string,builder,holes,return,this,holes
PolygonBuilder -> public List<LineStringBuilder> holes();1547195838;@return the list of holes defined for this polygon;public List<LineStringBuilder> holes() {_        return this.holes__    };return,the,list,of,holes,defined,for,this,polygon;public,list,line,string,builder,holes,return,this,holes
PolygonBuilder -> public List<LineStringBuilder> holes();1548434247;@return the list of holes defined for this polygon;public List<LineStringBuilder> holes() {_        return this.holes__    };return,the,list,of,holes,defined,for,this,polygon;public,list,line,string,builder,holes,return,this,holes
PolygonBuilder -> private static int component(final Edge edge, final int id, final ArrayList<Edge> edges);1524684173;This method sets the component id of all edges in a ring to a given id and shifts the_coordinates of this component according to the dateline__@param edge An arbitrary edge of the component_@param id id to apply to the component_@param edges a list of edges to which all edges of the component will be added (could be <code>null</code>)_@return number of edges that belong to this component;private static int component(final Edge edge, final int id, final ArrayList<Edge> edges) {_        _        Edge any = edge__        while(any.coordinate.x == +DATELINE || any.coordinate.x == -DATELINE) {_            if((any = any.next) == edge) {_                break__            }_        }__        double shiftOffset = any.coordinate.x > DATELINE ? DATELINE : (any.coordinate.x < -DATELINE ? -DATELINE : 0)__        if (debugEnabled()) {_            LOGGER.debug("shift: [{}]", shiftOffset)__        }__        _        _        _        int length = 0, connectedComponents = 0__        _        _        int splitIndex = 1__        Edge current = edge__        Edge prev = edge__        _        HashMap<Coordinate, Tuple<Edge, Edge>> visitedEdge = new HashMap<>()__        do {_            current.coordinate = shift(current.coordinate, shiftOffset)__            current.component = id___            if (edges != null) {_                _                if (visitedEdge.containsKey(current.coordinate)) {_                    if (connectedComponents > 0 && current.next != edge) {_                        throw new InvalidShapeException("Shape contains more than one shared point")__                    }__                    _                    _                    _                    final int visitID = -id__                    Edge firstAppearance = visitedEdge.get(current.coordinate).v2()__                    _                    _                    Edge temp = firstAppearance.next__                    firstAppearance.next = current.next__                    current.next = temp__                    current.component = visitID__                    _                    _                    do {_                        prev.component = visitID__                        prev = visitedEdge.get(prev.coordinate).v1()__                        ++splitIndex__                    } while (!current.coordinate.equals(prev.coordinate))__                    ++connectedComponents__                } else {_                    visitedEdge.put(current.coordinate, new Tuple<Edge, Edge>(prev, current))__                }_                edges.add(current)__                prev = current__            }_            length++__        } while(connectedComponents == 0 && (current = current.next) != edge)___        return (splitIndex != 1) ? length-splitIndex: length__    };this,method,sets,the,component,id,of,all,edges,in,a,ring,to,a,given,id,and,shifts,the,coordinates,of,this,component,according,to,the,dateline,param,edge,an,arbitrary,edge,of,the,component,param,id,id,to,apply,to,the,component,param,edges,a,list,of,edges,to,which,all,edges,of,the,component,will,be,added,could,be,code,null,code,return,number,of,edges,that,belong,to,this,component;private,static,int,component,final,edge,edge,final,int,id,final,array,list,edge,edges,edge,any,edge,while,any,coordinate,x,dateline,any,coordinate,x,dateline,if,any,any,next,edge,break,double,shift,offset,any,coordinate,x,dateline,dateline,any,coordinate,x,dateline,dateline,0,if,debug,enabled,logger,debug,shift,shift,offset,int,length,0,connected,components,0,int,split,index,1,edge,current,edge,edge,prev,edge,hash,map,coordinate,tuple,edge,edge,visited,edge,new,hash,map,do,current,coordinate,shift,current,coordinate,shift,offset,current,component,id,if,edges,null,if,visited,edge,contains,key,current,coordinate,if,connected,components,0,current,next,edge,throw,new,invalid,shape,exception,shape,contains,more,than,one,shared,point,final,int,visit,id,id,edge,first,appearance,visited,edge,get,current,coordinate,v2,edge,temp,first,appearance,next,first,appearance,next,current,next,current,next,temp,current,component,visit,id,do,prev,component,visit,id,prev,visited,edge,get,prev,coordinate,v1,split,index,while,current,coordinate,equals,prev,coordinate,connected,components,else,visited,edge,put,current,coordinate,new,tuple,edge,edge,prev,current,edges,add,current,prev,current,length,while,connected,components,0,current,current,next,edge,return,split,index,1,length,split,index,length
PolygonBuilder -> private static int component(final Edge edge, final int id, final ArrayList<Edge> edges);1528762805;This method sets the component id of all edges in a ring to a given id and shifts the_coordinates of this component according to the dateline__@param edge An arbitrary edge of the component_@param id id to apply to the component_@param edges a list of edges to which all edges of the component will be added (could be <code>null</code>)_@return number of edges that belong to this component;private static int component(final Edge edge, final int id, final ArrayList<Edge> edges) {_        _        Edge any = edge__        while(any.coordinate.x == +DATELINE || any.coordinate.x == -DATELINE) {_            if((any = any.next) == edge) {_                break__            }_        }__        double shiftOffset = any.coordinate.x > DATELINE ? DATELINE : (any.coordinate.x < -DATELINE ? -DATELINE : 0)__        if (debugEnabled()) {_            LOGGER.debug("shift: [{}]", shiftOffset)__        }__        _        _        _        int length = 0, connectedComponents = 0__        _        _        int splitIndex = 1__        Edge current = edge__        Edge prev = edge__        _        HashMap<Coordinate, Tuple<Edge, Edge>> visitedEdge = new HashMap<>()__        do {_            current.coordinate = shift(current.coordinate, shiftOffset)__            current.component = id___            if (edges != null) {_                _                if (visitedEdge.containsKey(current.coordinate)) {_                    if (connectedComponents > 0 && current.next != edge) {_                        throw new InvalidShapeException("Shape contains more than one shared point")__                    }__                    _                    _                    _                    final int visitID = -id__                    Edge firstAppearance = visitedEdge.get(current.coordinate).v2()__                    _                    _                    Edge temp = firstAppearance.next__                    firstAppearance.next = current.next__                    current.next = temp__                    current.component = visitID__                    _                    _                    do {_                        prev.component = visitID__                        prev = visitedEdge.get(prev.coordinate).v1()__                        ++splitIndex__                    } while (!current.coordinate.equals(prev.coordinate))__                    ++connectedComponents__                } else {_                    visitedEdge.put(current.coordinate, new Tuple<Edge, Edge>(prev, current))__                }_                edges.add(current)__                prev = current__            }_            length++__        } while(connectedComponents == 0 && (current = current.next) != edge)___        return (splitIndex != 1) ? length-splitIndex: length__    };this,method,sets,the,component,id,of,all,edges,in,a,ring,to,a,given,id,and,shifts,the,coordinates,of,this,component,according,to,the,dateline,param,edge,an,arbitrary,edge,of,the,component,param,id,id,to,apply,to,the,component,param,edges,a,list,of,edges,to,which,all,edges,of,the,component,will,be,added,could,be,code,null,code,return,number,of,edges,that,belong,to,this,component;private,static,int,component,final,edge,edge,final,int,id,final,array,list,edge,edges,edge,any,edge,while,any,coordinate,x,dateline,any,coordinate,x,dateline,if,any,any,next,edge,break,double,shift,offset,any,coordinate,x,dateline,dateline,any,coordinate,x,dateline,dateline,0,if,debug,enabled,logger,debug,shift,shift,offset,int,length,0,connected,components,0,int,split,index,1,edge,current,edge,edge,prev,edge,hash,map,coordinate,tuple,edge,edge,visited,edge,new,hash,map,do,current,coordinate,shift,current,coordinate,shift,offset,current,component,id,if,edges,null,if,visited,edge,contains,key,current,coordinate,if,connected,components,0,current,next,edge,throw,new,invalid,shape,exception,shape,contains,more,than,one,shared,point,final,int,visit,id,id,edge,first,appearance,visited,edge,get,current,coordinate,v2,edge,temp,first,appearance,next,first,appearance,next,current,next,current,next,temp,current,component,visit,id,do,prev,component,visit,id,prev,visited,edge,get,prev,coordinate,v1,split,index,while,current,coordinate,equals,prev,coordinate,connected,components,else,visited,edge,put,current,coordinate,new,tuple,edge,edge,prev,current,edges,add,current,prev,current,length,while,connected,components,0,current,current,next,edge,return,split,index,1,length,split,index,length
PolygonBuilder -> private static int component(final Edge edge, final int id, final ArrayList<Edge> edges);1533063033;This method sets the component id of all edges in a ring to a given id and shifts the_coordinates of this component according to the dateline__@param edge An arbitrary edge of the component_@param id id to apply to the component_@param edges a list of edges to which all edges of the component will be added (could be <code>null</code>)_@return number of edges that belong to this component;private static int component(final Edge edge, final int id, final ArrayList<Edge> edges) {_        _        Edge any = edge__        while(any.coordinate.x == +DATELINE || any.coordinate.x == -DATELINE) {_            if((any = any.next) == edge) {_                break__            }_        }__        double shiftOffset = any.coordinate.x > DATELINE ? DATELINE : (any.coordinate.x < -DATELINE ? -DATELINE : 0)__        if (debugEnabled()) {_            LOGGER.debug("shift: [{}]", shiftOffset)__        }__        _        _        _        int length = 0, connectedComponents = 0__        _        _        int splitIndex = 1__        Edge current = edge__        Edge prev = edge__        _        HashMap<Coordinate, Tuple<Edge, Edge>> visitedEdge = new HashMap<>()__        do {_            current.coordinate = shift(current.coordinate, shiftOffset)__            current.component = id___            if (edges != null) {_                _                if (visitedEdge.containsKey(current.coordinate)) {_                    if (connectedComponents > 0 && current.next != edge) {_                        throw new InvalidShapeException("Shape contains more than one shared point")__                    }__                    _                    _                    _                    final int visitID = -id__                    Edge firstAppearance = visitedEdge.get(current.coordinate).v2()__                    _                    _                    Edge temp = firstAppearance.next__                    firstAppearance.next = current.next__                    current.next = temp__                    current.component = visitID__                    _                    _                    do {_                        prev.component = visitID__                        prev = visitedEdge.get(prev.coordinate).v1()__                        ++splitIndex__                    } while (!current.coordinate.equals(prev.coordinate))__                    ++connectedComponents__                } else {_                    visitedEdge.put(current.coordinate, new Tuple<Edge, Edge>(prev, current))__                }_                edges.add(current)__                prev = current__            }_            length++__        } while(connectedComponents == 0 && (current = current.next) != edge)___        return (splitIndex != 1) ? length-splitIndex: length__    };this,method,sets,the,component,id,of,all,edges,in,a,ring,to,a,given,id,and,shifts,the,coordinates,of,this,component,according,to,the,dateline,param,edge,an,arbitrary,edge,of,the,component,param,id,id,to,apply,to,the,component,param,edges,a,list,of,edges,to,which,all,edges,of,the,component,will,be,added,could,be,code,null,code,return,number,of,edges,that,belong,to,this,component;private,static,int,component,final,edge,edge,final,int,id,final,array,list,edge,edges,edge,any,edge,while,any,coordinate,x,dateline,any,coordinate,x,dateline,if,any,any,next,edge,break,double,shift,offset,any,coordinate,x,dateline,dateline,any,coordinate,x,dateline,dateline,0,if,debug,enabled,logger,debug,shift,shift,offset,int,length,0,connected,components,0,int,split,index,1,edge,current,edge,edge,prev,edge,hash,map,coordinate,tuple,edge,edge,visited,edge,new,hash,map,do,current,coordinate,shift,current,coordinate,shift,offset,current,component,id,if,edges,null,if,visited,edge,contains,key,current,coordinate,if,connected,components,0,current,next,edge,throw,new,invalid,shape,exception,shape,contains,more,than,one,shared,point,final,int,visit,id,id,edge,first,appearance,visited,edge,get,current,coordinate,v2,edge,temp,first,appearance,next,first,appearance,next,current,next,current,next,temp,current,component,visit,id,do,prev,component,visit,id,prev,visited,edge,get,prev,coordinate,v1,split,index,while,current,coordinate,equals,prev,coordinate,connected,components,else,visited,edge,put,current,coordinate,new,tuple,edge,edge,prev,current,edges,add,current,prev,current,length,while,connected,components,0,current,current,next,edge,return,split,index,1,length,split,index,length
PolygonBuilder -> private static int component(final Edge edge, final int id, final ArrayList<Edge> edges);1542820501;This method sets the component id of all edges in a ring to a given id and shifts the_coordinates of this component according to the dateline__@param edge An arbitrary edge of the component_@param id id to apply to the component_@param edges a list of edges to which all edges of the component will be added (could be <code>null</code>)_@return number of edges that belong to this component;private static int component(final Edge edge, final int id, final ArrayList<Edge> edges) {_        _        Edge any = edge__        while(any.coordinate.x == +DATELINE || any.coordinate.x == -DATELINE) {_            if((any = any.next) == edge) {_                break__            }_        }__        double shiftOffset = any.coordinate.x > DATELINE ? DATELINE : (any.coordinate.x < -DATELINE ? -DATELINE : 0)__        if (debugEnabled()) {_            LOGGER.debug("shift: [{}]", shiftOffset)__        }__        _        _        _        int length = 0, connectedComponents = 0__        _        _        int splitIndex = 1__        Edge current = edge__        Edge prev = edge__        _        HashMap<Coordinate, Tuple<Edge, Edge>> visitedEdge = new HashMap<>()__        do {_            current.coordinate = shift(current.coordinate, shiftOffset)__            current.component = id___            if (edges != null) {_                _                if (visitedEdge.containsKey(current.coordinate)) {_                    if (connectedComponents > 0 && current.next != edge) {_                        throw new InvalidShapeException("Shape contains more than one shared point")__                    }__                    _                    _                    _                    final int visitID = -id__                    Edge firstAppearance = visitedEdge.get(current.coordinate).v2()__                    _                    _                    Edge temp = firstAppearance.next__                    firstAppearance.next = current.next__                    current.next = temp__                    current.component = visitID__                    _                    _                    do {_                        prev.component = visitID__                        prev = visitedEdge.get(prev.coordinate).v1()__                        ++splitIndex__                    } while (!current.coordinate.equals(prev.coordinate))__                    ++connectedComponents__                } else {_                    visitedEdge.put(current.coordinate, new Tuple<Edge, Edge>(prev, current))__                }_                edges.add(current)__                prev = current__            }_            length++__        } while(connectedComponents == 0 && (current = current.next) != edge)___        return (splitIndex != 1) ? length-splitIndex: length__    };this,method,sets,the,component,id,of,all,edges,in,a,ring,to,a,given,id,and,shifts,the,coordinates,of,this,component,according,to,the,dateline,param,edge,an,arbitrary,edge,of,the,component,param,id,id,to,apply,to,the,component,param,edges,a,list,of,edges,to,which,all,edges,of,the,component,will,be,added,could,be,code,null,code,return,number,of,edges,that,belong,to,this,component;private,static,int,component,final,edge,edge,final,int,id,final,array,list,edge,edges,edge,any,edge,while,any,coordinate,x,dateline,any,coordinate,x,dateline,if,any,any,next,edge,break,double,shift,offset,any,coordinate,x,dateline,dateline,any,coordinate,x,dateline,dateline,0,if,debug,enabled,logger,debug,shift,shift,offset,int,length,0,connected,components,0,int,split,index,1,edge,current,edge,edge,prev,edge,hash,map,coordinate,tuple,edge,edge,visited,edge,new,hash,map,do,current,coordinate,shift,current,coordinate,shift,offset,current,component,id,if,edges,null,if,visited,edge,contains,key,current,coordinate,if,connected,components,0,current,next,edge,throw,new,invalid,shape,exception,shape,contains,more,than,one,shared,point,final,int,visit,id,id,edge,first,appearance,visited,edge,get,current,coordinate,v2,edge,temp,first,appearance,next,first,appearance,next,current,next,current,next,temp,current,component,visit,id,do,prev,component,visit,id,prev,visited,edge,get,prev,coordinate,v1,split,index,while,current,coordinate,equals,prev,coordinate,connected,components,else,visited,edge,put,current,coordinate,new,tuple,edge,edge,prev,current,edges,add,current,prev,current,length,while,connected,components,0,current,current,next,edge,return,split,index,1,length,split,index,length
PolygonBuilder -> private static int component(final Edge edge, final int id, final ArrayList<Edge> edges);1547195838;This method sets the component id of all edges in a ring to a given id and shifts the_coordinates of this component according to the dateline__@param edge An arbitrary edge of the component_@param id id to apply to the component_@param edges a list of edges to which all edges of the component will be added (could be <code>null</code>)_@return number of edges that belong to this component;private static int component(final Edge edge, final int id, final ArrayList<Edge> edges) {_        _        Edge any = edge__        while(any.coordinate.x == +DATELINE || any.coordinate.x == -DATELINE) {_            if((any = any.next) == edge) {_                break__            }_        }__        double shiftOffset = any.coordinate.x > DATELINE ? DATELINE : (any.coordinate.x < -DATELINE ? -DATELINE : 0)__        if (debugEnabled()) {_            LOGGER.debug("shift: [{}]", shiftOffset)__        }__        _        _        _        int length = 0, connectedComponents = 0__        _        _        int splitIndex = 1__        Edge current = edge__        Edge prev = edge__        _        HashMap<Coordinate, Tuple<Edge, Edge>> visitedEdge = new HashMap<>()__        do {_            current.coordinate = shift(current.coordinate, shiftOffset)__            current.component = id___            if (edges != null) {_                _                if (visitedEdge.containsKey(current.coordinate)) {_                    if (connectedComponents > 0 && current.next != edge) {_                        throw new InvalidShapeException("Shape contains more than one shared point")__                    }__                    _                    _                    _                    final int visitID = -id__                    Edge firstAppearance = visitedEdge.get(current.coordinate).v2()__                    _                    _                    Edge temp = firstAppearance.next__                    firstAppearance.next = current.next__                    current.next = temp__                    current.component = visitID__                    _                    _                    do {_                        prev.component = visitID__                        prev = visitedEdge.get(prev.coordinate).v1()__                        ++splitIndex__                    } while (!current.coordinate.equals(prev.coordinate))__                    ++connectedComponents__                } else {_                    visitedEdge.put(current.coordinate, new Tuple<Edge, Edge>(prev, current))__                }_                edges.add(current)__                prev = current__            }_            length++__        } while(connectedComponents == 0 && (current = current.next) != edge)___        return (splitIndex != 1) ? length-splitIndex: length__    };this,method,sets,the,component,id,of,all,edges,in,a,ring,to,a,given,id,and,shifts,the,coordinates,of,this,component,according,to,the,dateline,param,edge,an,arbitrary,edge,of,the,component,param,id,id,to,apply,to,the,component,param,edges,a,list,of,edges,to,which,all,edges,of,the,component,will,be,added,could,be,code,null,code,return,number,of,edges,that,belong,to,this,component;private,static,int,component,final,edge,edge,final,int,id,final,array,list,edge,edges,edge,any,edge,while,any,coordinate,x,dateline,any,coordinate,x,dateline,if,any,any,next,edge,break,double,shift,offset,any,coordinate,x,dateline,dateline,any,coordinate,x,dateline,dateline,0,if,debug,enabled,logger,debug,shift,shift,offset,int,length,0,connected,components,0,int,split,index,1,edge,current,edge,edge,prev,edge,hash,map,coordinate,tuple,edge,edge,visited,edge,new,hash,map,do,current,coordinate,shift,current,coordinate,shift,offset,current,component,id,if,edges,null,if,visited,edge,contains,key,current,coordinate,if,connected,components,0,current,next,edge,throw,new,invalid,shape,exception,shape,contains,more,than,one,shared,point,final,int,visit,id,id,edge,first,appearance,visited,edge,get,current,coordinate,v2,edge,temp,first,appearance,next,first,appearance,next,current,next,current,next,temp,current,component,visit,id,do,prev,component,visit,id,prev,visited,edge,get,prev,coordinate,v1,split,index,while,current,coordinate,equals,prev,coordinate,connected,components,else,visited,edge,put,current,coordinate,new,tuple,edge,edge,prev,current,edges,add,current,prev,current,length,while,connected,components,0,current,current,next,edge,return,split,index,1,length,split,index,length
PolygonBuilder -> private static int component(final Edge edge, final int id, final ArrayList<Edge> edges);1548434247;This method sets the component id of all edges in a ring to a given id and shifts the_coordinates of this component according to the dateline__@param edge An arbitrary edge of the component_@param id id to apply to the component_@param edges a list of edges to which all edges of the component will be added (could be <code>null</code>)_@return number of edges that belong to this component;private static int component(final Edge edge, final int id, final ArrayList<Edge> edges) {_        _        Edge any = edge__        while(any.coordinate.x == +DATELINE || any.coordinate.x == -DATELINE) {_            if((any = any.next) == edge) {_                break__            }_        }__        double shiftOffset = any.coordinate.x > DATELINE ? DATELINE : (any.coordinate.x < -DATELINE ? -DATELINE : 0)__        if (debugEnabled()) {_            LOGGER.debug("shift: [{}]", shiftOffset)__        }__        _        _        _        int length = 0, connectedComponents = 0__        _        _        int splitIndex = 1__        Edge current = edge__        Edge prev = edge__        _        HashMap<Coordinate, Tuple<Edge, Edge>> visitedEdge = new HashMap<>()__        do {_            current.coordinate = shift(current.coordinate, shiftOffset)__            current.component = id___            if (edges != null) {_                _                if (visitedEdge.containsKey(current.coordinate)) {_                    if (connectedComponents > 0 && current.next != edge) {_                        throw new InvalidShapeException("Shape contains more than one shared point")__                    }__                    _                    _                    _                    final int visitID = -id__                    Edge firstAppearance = visitedEdge.get(current.coordinate).v2()__                    _                    _                    Edge temp = firstAppearance.next__                    firstAppearance.next = current.next__                    current.next = temp__                    current.component = visitID__                    _                    _                    do {_                        prev.component = visitID__                        prev = visitedEdge.get(prev.coordinate).v1()__                        ++splitIndex__                    } while (!current.coordinate.equals(prev.coordinate))__                    ++connectedComponents__                } else {_                    visitedEdge.put(current.coordinate, new Tuple<Edge, Edge>(prev, current))__                }_                edges.add(current)__                prev = current__            }_            length++__        } while(connectedComponents == 0 && (current = current.next) != edge)___        return (splitIndex != 1) ? length-splitIndex: length__    };this,method,sets,the,component,id,of,all,edges,in,a,ring,to,a,given,id,and,shifts,the,coordinates,of,this,component,according,to,the,dateline,param,edge,an,arbitrary,edge,of,the,component,param,id,id,to,apply,to,the,component,param,edges,a,list,of,edges,to,which,all,edges,of,the,component,will,be,added,could,be,code,null,code,return,number,of,edges,that,belong,to,this,component;private,static,int,component,final,edge,edge,final,int,id,final,array,list,edge,edges,edge,any,edge,while,any,coordinate,x,dateline,any,coordinate,x,dateline,if,any,any,next,edge,break,double,shift,offset,any,coordinate,x,dateline,dateline,any,coordinate,x,dateline,dateline,0,if,debug,enabled,logger,debug,shift,shift,offset,int,length,0,connected,components,0,int,split,index,1,edge,current,edge,edge,prev,edge,hash,map,coordinate,tuple,edge,edge,visited,edge,new,hash,map,do,current,coordinate,shift,current,coordinate,shift,offset,current,component,id,if,edges,null,if,visited,edge,contains,key,current,coordinate,if,connected,components,0,current,next,edge,throw,new,invalid,shape,exception,shape,contains,more,than,one,shared,point,final,int,visit,id,id,edge,first,appearance,visited,edge,get,current,coordinate,v2,edge,temp,first,appearance,next,first,appearance,next,current,next,current,next,temp,current,component,visit,id,do,prev,component,visit,id,prev,visited,edge,get,prev,coordinate,v1,split,index,while,current,coordinate,equals,prev,coordinate,connected,components,else,visited,edge,put,current,coordinate,new,tuple,edge,edge,prev,current,edges,add,current,prev,current,length,while,connected,components,0,current,current,next,edge,return,split,index,1,length,split,index,length
PolygonBuilder -> private static int top(Coordinate[] points, int offset, int length);1533063033;@return the (offset) index of the point that is furthest west amongst_those points that are the furthest south in the set.;private static int top(Coordinate[] points, int offset, int length) {_        int top = 0_ _        for (int i = 1_ i < length_ i++) {_            if (points[offset + i].y < points[offset + top].y) {_                top = i__            } else if (points[offset + i].y == points[offset + top].y) {_                if (points[offset + i].x < points[offset + top].x) {_                    top = i__                }_            }_        }_        return top__    };return,the,offset,index,of,the,point,that,is,furthest,west,amongst,those,points,that,are,the,furthest,south,in,the,set;private,static,int,top,coordinate,points,int,offset,int,length,int,top,0,for,int,i,1,i,length,i,if,points,offset,i,y,points,offset,top,y,top,i,else,if,points,offset,i,y,points,offset,top,y,if,points,offset,i,x,points,offset,top,x,top,i,return,top
PolygonBuilder -> private static int top(Coordinate[] points, int offset, int length);1542820501;@return the (offset) index of the point that is furthest west amongst_those points that are the furthest south in the set.;private static int top(Coordinate[] points, int offset, int length) {_        int top = 0_ _        for (int i = 1_ i < length_ i++) {_            if (points[offset + i].y < points[offset + top].y) {_                top = i__            } else if (points[offset + i].y == points[offset + top].y) {_                if (points[offset + i].x < points[offset + top].x) {_                    top = i__                }_            }_        }_        return top__    };return,the,offset,index,of,the,point,that,is,furthest,west,amongst,those,points,that,are,the,furthest,south,in,the,set;private,static,int,top,coordinate,points,int,offset,int,length,int,top,0,for,int,i,1,i,length,i,if,points,offset,i,y,points,offset,top,y,top,i,else,if,points,offset,i,y,points,offset,top,y,if,points,offset,i,x,points,offset,top,x,top,i,return,top
PolygonBuilder -> private static int top(Coordinate[] points, int offset, int length);1547195838;@return the (offset) index of the point that is furthest west amongst_those points that are the furthest south in the set.;private static int top(Coordinate[] points, int offset, int length) {_        int top = 0_ _        for (int i = 1_ i < length_ i++) {_            if (points[offset + i].y < points[offset + top].y) {_                top = i__            } else if (points[offset + i].y == points[offset + top].y) {_                if (points[offset + i].x < points[offset + top].x) {_                    top = i__                }_            }_        }_        return top__    };return,the,offset,index,of,the,point,that,is,furthest,west,amongst,those,points,that,are,the,furthest,south,in,the,set;private,static,int,top,coordinate,points,int,offset,int,length,int,top,0,for,int,i,1,i,length,i,if,points,offset,i,y,points,offset,top,y,top,i,else,if,points,offset,i,y,points,offset,top,y,if,points,offset,i,x,points,offset,top,x,top,i,return,top
PolygonBuilder -> private static int top(Coordinate[] points, int offset, int length);1548434247;@return the (offset) index of the point that is furthest west amongst_those points that are the furthest south in the set.;private static int top(Coordinate[] points, int offset, int length) {_        int top = 0_ _        for (int i = 1_ i < length_ i++) {_            if (points[offset + i].y < points[offset + top].y) {_                top = i__            } else if (points[offset + i].y == points[offset + top].y) {_                if (points[offset + i].x < points[offset + top].x) {_                    top = i__                }_            }_        }_        return top__    };return,the,offset,index,of,the,point,that,is,furthest,west,amongst,those,points,that,are,the,furthest,south,in,the,set;private,static,int,top,coordinate,points,int,offset,int,length,int,top,0,for,int,i,1,i,length,i,if,points,offset,i,y,points,offset,top,y,top,i,else,if,points,offset,i,y,points,offset,top,y,if,points,offset,i,x,points,offset,top,x,top,i,return,top
PolygonBuilder -> private static boolean getOrientation(Coordinate[] points, int offset, int length);1533063033;@return whether the points are clockwise (true) or anticlockwise (false);private static boolean getOrientation(Coordinate[] points, int offset, int length) {_        _        __        final int top = top(points, offset, length)__        final int prev = (top + length - 1) % length__        final int next = (top + 1) % length___        final int determinantSign = orient(_            points[offset + prev].x, points[offset + prev].y,_            points[offset + top].x, points[offset + top].y,_            points[offset + next].x, points[offset + next].y)___        if (determinantSign == 0) {_            _            throw new InvalidShapeException("Cannot determine orientation: edges adjacent to ("_                + points[offset + top].x + "," + points[offset +top].y + ") coincide")__        }__        return determinantSign < 0__    };return,whether,the,points,are,clockwise,true,or,anticlockwise,false;private,static,boolean,get,orientation,coordinate,points,int,offset,int,length,final,int,top,top,points,offset,length,final,int,prev,top,length,1,length,final,int,next,top,1,length,final,int,determinant,sign,orient,points,offset,prev,x,points,offset,prev,y,points,offset,top,x,points,offset,top,y,points,offset,next,x,points,offset,next,y,if,determinant,sign,0,throw,new,invalid,shape,exception,cannot,determine,orientation,edges,adjacent,to,points,offset,top,x,points,offset,top,y,coincide,return,determinant,sign,0
PolygonBuilder -> private static boolean getOrientation(Coordinate[] points, int offset, int length);1542820501;@return whether the points are clockwise (true) or anticlockwise (false);private static boolean getOrientation(Coordinate[] points, int offset, int length) {_        _        __        final int top = top(points, offset, length)__        final int prev = (top + length - 1) % length__        final int next = (top + 1) % length___        final int determinantSign = orient(_            points[offset + prev].x, points[offset + prev].y,_            points[offset + top].x, points[offset + top].y,_            points[offset + next].x, points[offset + next].y)___        if (determinantSign == 0) {_            _            throw new InvalidShapeException("Cannot determine orientation: edges adjacent to ("_                + points[offset + top].x + "," + points[offset +top].y + ") coincide")__        }__        return determinantSign < 0__    };return,whether,the,points,are,clockwise,true,or,anticlockwise,false;private,static,boolean,get,orientation,coordinate,points,int,offset,int,length,final,int,top,top,points,offset,length,final,int,prev,top,length,1,length,final,int,next,top,1,length,final,int,determinant,sign,orient,points,offset,prev,x,points,offset,prev,y,points,offset,top,x,points,offset,top,y,points,offset,next,x,points,offset,next,y,if,determinant,sign,0,throw,new,invalid,shape,exception,cannot,determine,orientation,edges,adjacent,to,points,offset,top,x,points,offset,top,y,coincide,return,determinant,sign,0
PolygonBuilder -> private static boolean getOrientation(Coordinate[] points, int offset, int length);1547195838;@return whether the points are clockwise (true) or anticlockwise (false);private static boolean getOrientation(Coordinate[] points, int offset, int length) {_        _        __        final int top = top(points, offset, length)__        final int prev = (top + length - 1) % length__        final int next = (top + 1) % length___        final int determinantSign = orient(_            points[offset + prev].x, points[offset + prev].y,_            points[offset + top].x, points[offset + top].y,_            points[offset + next].x, points[offset + next].y)___        if (determinantSign == 0) {_            _            throw new InvalidShapeException("Cannot determine orientation: edges adjacent to ("_                + points[offset + top].x + "," + points[offset +top].y + ") coincide")__        }__        return determinantSign < 0__    };return,whether,the,points,are,clockwise,true,or,anticlockwise,false;private,static,boolean,get,orientation,coordinate,points,int,offset,int,length,final,int,top,top,points,offset,length,final,int,prev,top,length,1,length,final,int,next,top,1,length,final,int,determinant,sign,orient,points,offset,prev,x,points,offset,prev,y,points,offset,top,x,points,offset,top,y,points,offset,next,x,points,offset,next,y,if,determinant,sign,0,throw,new,invalid,shape,exception,cannot,determine,orientation,edges,adjacent,to,points,offset,top,x,points,offset,top,y,coincide,return,determinant,sign,0
PolygonBuilder -> private static boolean getOrientation(Coordinate[] points, int offset, int length);1548434247;@return whether the points are clockwise (true) or anticlockwise (false);private static boolean getOrientation(Coordinate[] points, int offset, int length) {_        _        __        final int top = top(points, offset, length)__        final int prev = (top + length - 1) % length__        final int next = (top + 1) % length___        final int determinantSign = orient(_            points[offset + prev].x, points[offset + prev].y,_            points[offset + top].x, points[offset + top].y,_            points[offset + next].x, points[offset + next].y)___        if (determinantSign == 0) {_            _            throw new InvalidShapeException("Cannot determine orientation: edges adjacent to ("_                + points[offset + top].x + "," + points[offset +top].y + ") coincide")__        }__        return determinantSign < 0__    };return,whether,the,points,are,clockwise,true,or,anticlockwise,false;private,static,boolean,get,orientation,coordinate,points,int,offset,int,length,final,int,top,top,points,offset,length,final,int,prev,top,length,1,length,final,int,next,top,1,length,final,int,determinant,sign,orient,points,offset,prev,x,points,offset,prev,y,points,offset,top,x,points,offset,top,y,points,offset,next,x,points,offset,next,y,if,determinant,sign,0,throw,new,invalid,shape,exception,cannot,determine,orientation,edges,adjacent,to,points,offset,top,x,points,offset,top,y,coincide,return,determinant,sign,0
PolygonBuilder -> public PolygonBuilder close();1524684173;Close the shell of the polygon;public PolygonBuilder close() {_        shell.close()__        return this__    };close,the,shell,of,the,polygon;public,polygon,builder,close,shell,close,return,this
PolygonBuilder -> public PolygonBuilder close();1528762805;Close the shell of the polygon;public PolygonBuilder close() {_        shell.close()__        return this__    };close,the,shell,of,the,polygon;public,polygon,builder,close,shell,close,return,this
PolygonBuilder -> public PolygonBuilder close();1533063033;Close the shell of the polygon;public PolygonBuilder close() {_        shell.close()__        return this__    };close,the,shell,of,the,polygon;public,polygon,builder,close,shell,close,return,this
PolygonBuilder -> public PolygonBuilder close();1542820501;Close the shell of the polygon;public PolygonBuilder close() {_        shell.close()__        return this__    };close,the,shell,of,the,polygon;public,polygon,builder,close,shell,close,return,this
PolygonBuilder -> public PolygonBuilder close();1547195838;Close the shell of the polygon;public PolygonBuilder close() {_        shell.close()__        return this__    };close,the,shell,of,the,polygon;public,polygon,builder,close,shell,close,return,this
PolygonBuilder -> public PolygonBuilder close();1548434247;Close the shell of the polygon;public PolygonBuilder close() {_        shell.close()__        return this__    };close,the,shell,of,the,polygon;public,polygon,builder,close,shell,close,return,this
PolygonBuilder -> public PolygonBuilder(StreamInput in) throws IOException;1524684173;Read from a stream.;public PolygonBuilder(StreamInput in) throws IOException {_        shell = new LineStringBuilder(in)__        orientation = Orientation.readFrom(in)__        int holes = in.readVInt()__        for (int i = 0_ i < holes_ i++) {_            hole(new LineStringBuilder(in))__        }_    };read,from,a,stream;public,polygon,builder,stream,input,in,throws,ioexception,shell,new,line,string,builder,in,orientation,orientation,read,from,in,int,holes,in,read,vint,for,int,i,0,i,holes,i,hole,new,line,string,builder,in
PolygonBuilder -> public PolygonBuilder(StreamInput in) throws IOException;1528762805;Read from a stream.;public PolygonBuilder(StreamInput in) throws IOException {_        shell = new LineStringBuilder(in)__        orientation = Orientation.readFrom(in)__        int holes = in.readVInt()__        for (int i = 0_ i < holes_ i++) {_            hole(new LineStringBuilder(in))__        }_    };read,from,a,stream;public,polygon,builder,stream,input,in,throws,ioexception,shell,new,line,string,builder,in,orientation,orientation,read,from,in,int,holes,in,read,vint,for,int,i,0,i,holes,i,hole,new,line,string,builder,in
PolygonBuilder -> public PolygonBuilder(StreamInput in) throws IOException;1533063033;Read from a stream.;public PolygonBuilder(StreamInput in) throws IOException {_        shell = new LineStringBuilder(in)__        orientation = Orientation.readFrom(in)__        int holes = in.readVInt()__        for (int i = 0_ i < holes_ i++) {_            hole(new LineStringBuilder(in))__        }_    };read,from,a,stream;public,polygon,builder,stream,input,in,throws,ioexception,shell,new,line,string,builder,in,orientation,orientation,read,from,in,int,holes,in,read,vint,for,int,i,0,i,holes,i,hole,new,line,string,builder,in
PolygonBuilder -> public PolygonBuilder(StreamInput in) throws IOException;1542820501;Read from a stream.;public PolygonBuilder(StreamInput in) throws IOException {_        shell = new LineStringBuilder(in)__        orientation = Orientation.readFrom(in)__        int holes = in.readVInt()__        for (int i = 0_ i < holes_ i++) {_            hole(new LineStringBuilder(in))__        }_    };read,from,a,stream;public,polygon,builder,stream,input,in,throws,ioexception,shell,new,line,string,builder,in,orientation,orientation,read,from,in,int,holes,in,read,vint,for,int,i,0,i,holes,i,hole,new,line,string,builder,in
PolygonBuilder -> public PolygonBuilder(StreamInput in) throws IOException;1547195838;Read from a stream.;public PolygonBuilder(StreamInput in) throws IOException {_        shell = new LineStringBuilder(in)__        orientation = Orientation.readFrom(in)__        int holes = in.readVInt()__        for (int i = 0_ i < holes_ i++) {_            hole(new LineStringBuilder(in))__        }_    };read,from,a,stream;public,polygon,builder,stream,input,in,throws,ioexception,shell,new,line,string,builder,in,orientation,orientation,read,from,in,int,holes,in,read,vint,for,int,i,0,i,holes,i,hole,new,line,string,builder,in
PolygonBuilder -> public PolygonBuilder(StreamInput in) throws IOException;1548434247;Read from a stream.;public PolygonBuilder(StreamInput in) throws IOException {_        shell = new LineStringBuilder(in)__        orientation = Orientation.readFrom(in)__        int holes = in.readVInt()__        for (int i = 0_ i < holes_ i++) {_            hole(new LineStringBuilder(in))__        }_    };read,from,a,stream;public,polygon,builder,stream,input,in,throws,ioexception,shell,new,line,string,builder,in,orientation,orientation,read,from,in,int,holes,in,read,vint,for,int,i,0,i,holes,i,hole,new,line,string,builder,in
PolygonBuilder -> protected void validateHole(LineStringBuilder shell, LineStringBuilder hole);1524684173;Validates only 1 vertex is tangential (shared) between the interior and exterior of a polygon;protected void validateHole(LineStringBuilder shell, LineStringBuilder hole) {_        HashSet<Coordinate> exterior = Sets.newHashSet(shell.coordinates)__        HashSet<Coordinate> interior = Sets.newHashSet(hole.coordinates)__        exterior.retainAll(interior)__        if (exterior.size() >= 2) {_            throw new InvalidShapeException("Invalid polygon, interior cannot share more than one point with the exterior")__        }_    };validates,only,1,vertex,is,tangential,shared,between,the,interior,and,exterior,of,a,polygon;protected,void,validate,hole,line,string,builder,shell,line,string,builder,hole,hash,set,coordinate,exterior,sets,new,hash,set,shell,coordinates,hash,set,coordinate,interior,sets,new,hash,set,hole,coordinates,exterior,retain,all,interior,if,exterior,size,2,throw,new,invalid,shape,exception,invalid,polygon,interior,cannot,share,more,than,one,point,with,the,exterior
PolygonBuilder -> protected void validateHole(LineStringBuilder shell, LineStringBuilder hole);1528762805;Validates only 1 vertex is tangential (shared) between the interior and exterior of a polygon;protected void validateHole(LineStringBuilder shell, LineStringBuilder hole) {_        HashSet<Coordinate> exterior = Sets.newHashSet(shell.coordinates)__        HashSet<Coordinate> interior = Sets.newHashSet(hole.coordinates)__        exterior.retainAll(interior)__        if (exterior.size() >= 2) {_            throw new InvalidShapeException("Invalid polygon, interior cannot share more than one point with the exterior")__        }_    };validates,only,1,vertex,is,tangential,shared,between,the,interior,and,exterior,of,a,polygon;protected,void,validate,hole,line,string,builder,shell,line,string,builder,hole,hash,set,coordinate,exterior,sets,new,hash,set,shell,coordinates,hash,set,coordinate,interior,sets,new,hash,set,hole,coordinates,exterior,retain,all,interior,if,exterior,size,2,throw,new,invalid,shape,exception,invalid,polygon,interior,cannot,share,more,than,one,point,with,the,exterior
PolygonBuilder -> protected void validateHole(LineStringBuilder shell, LineStringBuilder hole);1533063033;Validates only 1 vertex is tangential (shared) between the interior and exterior of a polygon;protected void validateHole(LineStringBuilder shell, LineStringBuilder hole) {_        HashSet<Coordinate> exterior = Sets.newHashSet(shell.coordinates)__        HashSet<Coordinate> interior = Sets.newHashSet(hole.coordinates)__        exterior.retainAll(interior)__        if (exterior.size() >= 2) {_            throw new InvalidShapeException("Invalid polygon, interior cannot share more than one point with the exterior")__        }_    };validates,only,1,vertex,is,tangential,shared,between,the,interior,and,exterior,of,a,polygon;protected,void,validate,hole,line,string,builder,shell,line,string,builder,hole,hash,set,coordinate,exterior,sets,new,hash,set,shell,coordinates,hash,set,coordinate,interior,sets,new,hash,set,hole,coordinates,exterior,retain,all,interior,if,exterior,size,2,throw,new,invalid,shape,exception,invalid,polygon,interior,cannot,share,more,than,one,point,with,the,exterior
PolygonBuilder -> protected void validateHole(LineStringBuilder shell, LineStringBuilder hole);1542820501;Validates only 1 vertex is tangential (shared) between the interior and exterior of a polygon;protected void validateHole(LineStringBuilder shell, LineStringBuilder hole) {_        HashSet<Coordinate> exterior = Sets.newHashSet(shell.coordinates)__        HashSet<Coordinate> interior = Sets.newHashSet(hole.coordinates)__        exterior.retainAll(interior)__        if (exterior.size() >= 2) {_            throw new InvalidShapeException("Invalid polygon, interior cannot share more than one point with the exterior")__        }_    };validates,only,1,vertex,is,tangential,shared,between,the,interior,and,exterior,of,a,polygon;protected,void,validate,hole,line,string,builder,shell,line,string,builder,hole,hash,set,coordinate,exterior,sets,new,hash,set,shell,coordinates,hash,set,coordinate,interior,sets,new,hash,set,hole,coordinates,exterior,retain,all,interior,if,exterior,size,2,throw,new,invalid,shape,exception,invalid,polygon,interior,cannot,share,more,than,one,point,with,the,exterior
PolygonBuilder -> protected void validateHole(LineStringBuilder shell, LineStringBuilder hole);1547195838;Validates only 1 vertex is tangential (shared) between the interior and exterior of a polygon;protected void validateHole(LineStringBuilder shell, LineStringBuilder hole) {_        HashSet<Coordinate> exterior = Sets.newHashSet(shell.coordinates)__        HashSet<Coordinate> interior = Sets.newHashSet(hole.coordinates)__        exterior.retainAll(interior)__        if (exterior.size() >= 2) {_            throw new InvalidShapeException("Invalid polygon, interior cannot share more than one point with the exterior")__        }_    };validates,only,1,vertex,is,tangential,shared,between,the,interior,and,exterior,of,a,polygon;protected,void,validate,hole,line,string,builder,shell,line,string,builder,hole,hash,set,coordinate,exterior,sets,new,hash,set,shell,coordinates,hash,set,coordinate,interior,sets,new,hash,set,hole,coordinates,exterior,retain,all,interior,if,exterior,size,2,throw,new,invalid,shape,exception,invalid,polygon,interior,cannot,share,more,than,one,point,with,the,exterior
PolygonBuilder -> protected void validateHole(LineStringBuilder shell, LineStringBuilder hole);1548434247;Validates only 1 vertex is tangential (shared) between the interior and exterior of a polygon;protected void validateHole(LineStringBuilder shell, LineStringBuilder hole) {_        HashSet<Coordinate> exterior = Sets.newHashSet(shell.coordinates)__        HashSet<Coordinate> interior = Sets.newHashSet(hole.coordinates)__        exterior.retainAll(interior)__        if (exterior.size() >= 2) {_            throw new InvalidShapeException("Invalid polygon, interior cannot share more than one point with the exterior")__        }_    };validates,only,1,vertex,is,tangential,shared,between,the,interior,and,exterior,of,a,polygon;protected,void,validate,hole,line,string,builder,shell,line,string,builder,hole,hash,set,coordinate,exterior,sets,new,hash,set,shell,coordinates,hash,set,coordinate,interior,sets,new,hash,set,hole,coordinates,exterior,retain,all,interior,if,exterior,size,2,throw,new,invalid,shape,exception,invalid,polygon,interior,cannot,share,more,than,one,point,with,the,exterior
PolygonBuilder -> private static void translate(Coordinate[] points);1524684173;Transforms coordinates in the eastern hemisphere (-180:0) to a (180:360) range;private static void translate(Coordinate[] points) {_        for (Coordinate c : points) {_            if (c.x < 0) {_                c.x += 2*DATELINE__            }_        }_    };transforms,coordinates,in,the,eastern,hemisphere,180,0,to,a,180,360,range;private,static,void,translate,coordinate,points,for,coordinate,c,points,if,c,x,0,c,x,2,dateline
PolygonBuilder -> private static void translate(Coordinate[] points);1528762805;Transforms coordinates in the eastern hemisphere (-180:0) to a (180:360) range;private static void translate(Coordinate[] points) {_        for (Coordinate c : points) {_            if (c.x < 0) {_                c.x += 2*DATELINE__            }_        }_    };transforms,coordinates,in,the,eastern,hemisphere,180,0,to,a,180,360,range;private,static,void,translate,coordinate,points,for,coordinate,c,points,if,c,x,0,c,x,2,dateline
PolygonBuilder -> private static void translate(Coordinate[] points);1533063033;Transforms coordinates in the eastern hemisphere (-180:0) to a (180:360) range;private static void translate(Coordinate[] points) {_        for (Coordinate c : points) {_            if (c.x < 0) {_                c.x += 2*DATELINE__            }_        }_    };transforms,coordinates,in,the,eastern,hemisphere,180,0,to,a,180,360,range;private,static,void,translate,coordinate,points,for,coordinate,c,points,if,c,x,0,c,x,2,dateline
PolygonBuilder -> private static void translate(Coordinate[] points);1542820501;Transforms coordinates in the eastern hemisphere (-180:0) to a (180:360) range;private static void translate(Coordinate[] points) {_        for (Coordinate c : points) {_            if (c.x < 0) {_                c.x += 2*DATELINE__            }_        }_    };transforms,coordinates,in,the,eastern,hemisphere,180,0,to,a,180,360,range;private,static,void,translate,coordinate,points,for,coordinate,c,points,if,c,x,0,c,x,2,dateline
PolygonBuilder -> private static void translate(Coordinate[] points);1547195838;Transforms coordinates in the eastern hemisphere (-180:0) to a (180:360) range;private static void translate(Coordinate[] points) {_        for (Coordinate c : points) {_            if (c.x < 0) {_                c.x += 2*DATELINE__            }_        }_    };transforms,coordinates,in,the,eastern,hemisphere,180,0,to,a,180,360,range;private,static,void,translate,coordinate,points,for,coordinate,c,points,if,c,x,0,c,x,2,dateline
PolygonBuilder -> private static void translate(Coordinate[] points);1548434247;Transforms coordinates in the eastern hemisphere (-180:0) to a (180:360) range;private static void translate(Coordinate[] points) {_        for (Coordinate c : points) {_            if (c.x < 0) {_                c.x += 2*DATELINE__            }_        }_    };transforms,coordinates,in,the,eastern,hemisphere,180,0,to,a,180,360,range;private,static,void,translate,coordinate,points,for,coordinate,c,points,if,c,x,0,c,x,2,dateline
PolygonBuilder -> public PolygonBuilder hole(LineStringBuilder hole, boolean coerce);1524684173;Add a new hole to the polygon_@param hole linear ring defining the hole_@param coerce if set to true, it will try to close the hole by adding starting point as end point_@return this;public PolygonBuilder hole(LineStringBuilder hole, boolean coerce) {_        if (coerce) {_            hole.close()__        }_        validateLinearRing(hole)__        holes.add(hole)__        return this__    };add,a,new,hole,to,the,polygon,param,hole,linear,ring,defining,the,hole,param,coerce,if,set,to,true,it,will,try,to,close,the,hole,by,adding,starting,point,as,end,point,return,this;public,polygon,builder,hole,line,string,builder,hole,boolean,coerce,if,coerce,hole,close,validate,linear,ring,hole,holes,add,hole,return,this
PolygonBuilder -> public PolygonBuilder hole(LineStringBuilder hole, boolean coerce);1528762805;Add a new hole to the polygon_@param hole linear ring defining the hole_@param coerce if set to true, it will try to close the hole by adding starting point as end point_@return this;public PolygonBuilder hole(LineStringBuilder hole, boolean coerce) {_        if (coerce) {_            hole.close()__        }_        validateLinearRing(hole)__        holes.add(hole)__        return this__    };add,a,new,hole,to,the,polygon,param,hole,linear,ring,defining,the,hole,param,coerce,if,set,to,true,it,will,try,to,close,the,hole,by,adding,starting,point,as,end,point,return,this;public,polygon,builder,hole,line,string,builder,hole,boolean,coerce,if,coerce,hole,close,validate,linear,ring,hole,holes,add,hole,return,this
PolygonBuilder -> public PolygonBuilder hole(LineStringBuilder hole, boolean coerce);1533063033;Add a new hole to the polygon_@param hole linear ring defining the hole_@param coerce if set to true, it will try to close the hole by adding starting point as end point_@return this;public PolygonBuilder hole(LineStringBuilder hole, boolean coerce) {_        if (coerce) {_            hole.close()__        }_        validateLinearRing(hole)__        holes.add(hole)__        return this__    };add,a,new,hole,to,the,polygon,param,hole,linear,ring,defining,the,hole,param,coerce,if,set,to,true,it,will,try,to,close,the,hole,by,adding,starting,point,as,end,point,return,this;public,polygon,builder,hole,line,string,builder,hole,boolean,coerce,if,coerce,hole,close,validate,linear,ring,hole,holes,add,hole,return,this
PolygonBuilder -> public PolygonBuilder hole(LineStringBuilder hole, boolean coerce);1542820501;Add a new hole to the polygon_@param hole linear ring defining the hole_@param coerce if set to true, it will try to close the hole by adding starting point as end point_@return this;public PolygonBuilder hole(LineStringBuilder hole, boolean coerce) {_        if (coerce) {_            hole.close()__        }_        validateLinearRing(hole)__        holes.add(hole)__        return this__    };add,a,new,hole,to,the,polygon,param,hole,linear,ring,defining,the,hole,param,coerce,if,set,to,true,it,will,try,to,close,the,hole,by,adding,starting,point,as,end,point,return,this;public,polygon,builder,hole,line,string,builder,hole,boolean,coerce,if,coerce,hole,close,validate,linear,ring,hole,holes,add,hole,return,this
PolygonBuilder -> public PolygonBuilder hole(LineStringBuilder hole, boolean coerce);1547195838;Add a new hole to the polygon_@param hole linear ring defining the hole_@param coerce if set to true, it will try to close the hole by adding starting point as end point_@return this;public PolygonBuilder hole(LineStringBuilder hole, boolean coerce) {_        if (coerce) {_            hole.close()__        }_        validateLinearRing(hole)__        holes.add(hole)__        return this__    };add,a,new,hole,to,the,polygon,param,hole,linear,ring,defining,the,hole,param,coerce,if,set,to,true,it,will,try,to,close,the,hole,by,adding,starting,point,as,end,point,return,this;public,polygon,builder,hole,line,string,builder,hole,boolean,coerce,if,coerce,hole,close,validate,linear,ring,hole,holes,add,hole,return,this
PolygonBuilder -> public PolygonBuilder hole(LineStringBuilder hole, boolean coerce);1548434247;Add a new hole to the polygon_@param hole linear ring defining the hole_@param coerce if set to true, it will try to close the hole by adding starting point as end point_@return this;public PolygonBuilder hole(LineStringBuilder hole, boolean coerce) {_        if (coerce) {_            hole.close()__        }_        validateLinearRing(hole)__        holes.add(hole)__        return this__    };add,a,new,hole,to,the,polygon,param,hole,linear,ring,defining,the,hole,param,coerce,if,set,to,true,it,will,try,to,close,the,hole,by,adding,starting,point,as,end,point,return,this;public,polygon,builder,hole,line,string,builder,hole,boolean,coerce,if,coerce,hole,close,validate,linear,ring,hole,holes,add,hole,return,this
PolygonBuilder -> public LineStringBuilder shell();1524684173;@return the list of points of the shell for this polygon;public LineStringBuilder shell() {_        return this.shell__    };return,the,list,of,points,of,the,shell,for,this,polygon;public,line,string,builder,shell,return,this,shell
PolygonBuilder -> public LineStringBuilder shell();1528762805;@return the list of points of the shell for this polygon;public LineStringBuilder shell() {_        return this.shell__    };return,the,list,of,points,of,the,shell,for,this,polygon;public,line,string,builder,shell,return,this,shell
PolygonBuilder -> public LineStringBuilder shell();1533063033;@return the list of points of the shell for this polygon;public LineStringBuilder shell() {_        return this.shell__    };return,the,list,of,points,of,the,shell,for,this,polygon;public,line,string,builder,shell,return,this,shell
PolygonBuilder -> public LineStringBuilder shell();1542820501;@return the list of points of the shell for this polygon;public LineStringBuilder shell() {_        return this.shell__    };return,the,list,of,points,of,the,shell,for,this,polygon;public,line,string,builder,shell,return,this,shell
PolygonBuilder -> public LineStringBuilder shell();1547195838;@return the list of points of the shell for this polygon;public LineStringBuilder shell() {_        return this.shell__    };return,the,list,of,points,of,the,shell,for,this,polygon;public,line,string,builder,shell,return,this,shell
PolygonBuilder -> public LineStringBuilder shell();1548434247;@return the list of points of the shell for this polygon;public LineStringBuilder shell() {_        return this.shell__    };return,the,list,of,points,of,the,shell,for,this,polygon;public,line,string,builder,shell,return,this,shell
PolygonBuilder -> private static Coordinate[] coordinates(Edge component, Coordinate[] coordinates);1524684173;Compute all coordinates of a component_@param component an arbitrary edge of the component_@param coordinates Array of coordinates to write the result to_@return the coordinates parameter;private static Coordinate[] coordinates(Edge component, Coordinate[] coordinates) {_        for (int i = 0_ i < coordinates.length_ i++) {_            coordinates[i] = (component = component.next).coordinate__        }_        return coordinates__    };compute,all,coordinates,of,a,component,param,component,an,arbitrary,edge,of,the,component,param,coordinates,array,of,coordinates,to,write,the,result,to,return,the,coordinates,parameter;private,static,coordinate,coordinates,edge,component,coordinate,coordinates,for,int,i,0,i,coordinates,length,i,coordinates,i,component,component,next,coordinate,return,coordinates
PolygonBuilder -> private static Coordinate[] coordinates(Edge component, Coordinate[] coordinates);1528762805;Compute all coordinates of a component_@param component an arbitrary edge of the component_@param coordinates Array of coordinates to write the result to_@return the coordinates parameter;private static Coordinate[] coordinates(Edge component, Coordinate[] coordinates) {_        for (int i = 0_ i < coordinates.length_ i++) {_            coordinates[i] = (component = component.next).coordinate__        }_        return coordinates__    };compute,all,coordinates,of,a,component,param,component,an,arbitrary,edge,of,the,component,param,coordinates,array,of,coordinates,to,write,the,result,to,return,the,coordinates,parameter;private,static,coordinate,coordinates,edge,component,coordinate,coordinates,for,int,i,0,i,coordinates,length,i,coordinates,i,component,component,next,coordinate,return,coordinates
PolygonBuilder -> private static Coordinate[] coordinates(Edge component, Coordinate[] coordinates);1533063033;Compute all coordinates of a component_@param component an arbitrary edge of the component_@param coordinates Array of coordinates to write the result to_@return the coordinates parameter;private static Coordinate[] coordinates(Edge component, Coordinate[] coordinates) {_        for (int i = 0_ i < coordinates.length_ i++) {_            coordinates[i] = (component = component.next).coordinate__        }_        return coordinates__    };compute,all,coordinates,of,a,component,param,component,an,arbitrary,edge,of,the,component,param,coordinates,array,of,coordinates,to,write,the,result,to,return,the,coordinates,parameter;private,static,coordinate,coordinates,edge,component,coordinate,coordinates,for,int,i,0,i,coordinates,length,i,coordinates,i,component,component,next,coordinate,return,coordinates
PolygonBuilder -> private static Coordinate[] coordinates(Edge component, Coordinate[] coordinates);1542820501;Compute all coordinates of a component_@param component an arbitrary edge of the component_@param coordinates Array of coordinates to write the result to_@return the coordinates parameter;private static Coordinate[] coordinates(Edge component, Coordinate[] coordinates) {_        for (int i = 0_ i < coordinates.length_ i++) {_            coordinates[i] = (component = component.next).coordinate__        }_        return coordinates__    };compute,all,coordinates,of,a,component,param,component,an,arbitrary,edge,of,the,component,param,coordinates,array,of,coordinates,to,write,the,result,to,return,the,coordinates,parameter;private,static,coordinate,coordinates,edge,component,coordinate,coordinates,for,int,i,0,i,coordinates,length,i,coordinates,i,component,component,next,coordinate,return,coordinates
PolygonBuilder -> private static Coordinate[] coordinates(Edge component, Coordinate[] coordinates);1547195838;Compute all coordinates of a component_@param component an arbitrary edge of the component_@param coordinates Array of coordinates to write the result to_@return the coordinates parameter;private static Coordinate[] coordinates(Edge component, Coordinate[] coordinates) {_        for (int i = 0_ i < coordinates.length_ i++) {_            coordinates[i] = (component = component.next).coordinate__        }_        return coordinates__    };compute,all,coordinates,of,a,component,param,component,an,arbitrary,edge,of,the,component,param,coordinates,array,of,coordinates,to,write,the,result,to,return,the,coordinates,parameter;private,static,coordinate,coordinates,edge,component,coordinate,coordinates,for,int,i,0,i,coordinates,length,i,coordinates,i,component,component,next,coordinate,return,coordinates
PolygonBuilder -> private static Coordinate[] coordinates(Edge component, Coordinate[] coordinates);1548434247;Compute all coordinates of a component_@param component an arbitrary edge of the component_@param coordinates Array of coordinates to write the result to_@return the coordinates parameter;private static Coordinate[] coordinates(Edge component, Coordinate[] coordinates) {_        for (int i = 0_ i < coordinates.length_ i++) {_            coordinates[i] = (component = component.next).coordinate__        }_        return coordinates__    };compute,all,coordinates,of,a,component,param,component,an,arbitrary,edge,of,the,component,param,coordinates,array,of,coordinates,to,write,the,result,to,return,the,coordinates,parameter;private,static,coordinate,coordinates,edge,component,coordinate,coordinates,for,int,i,0,i,coordinates,length,i,coordinates,i,component,component,next,coordinate,return,coordinates
PolygonBuilder -> protected static MultiPolygon multipolygonS4J(GeometryFactory factory, Coordinate[][][] polygons);1542820501;Create a Multipolygon from a set of coordinates. Each primary array contains a polygon which_in turn contains an array of linestrings. These line Strings are represented as an array of_coordinates. The first linestring will be the shell of the polygon the others define holes_within the polygon.__@param factory {@link GeometryFactory} to use_@param polygons definition of polygons_@return a new Multipolygon;protected static MultiPolygon multipolygonS4J(GeometryFactory factory, Coordinate[][][] polygons) {_        Polygon[] polygonSet = new Polygon[polygons.length]__        for (int i = 0_ i < polygonSet.length_ i++) {_            polygonSet[i] = polygonS4J(factory, polygons[i])__        }_        return factory.createMultiPolygon(polygonSet)__    };create,a,multipolygon,from,a,set,of,coordinates,each,primary,array,contains,a,polygon,which,in,turn,contains,an,array,of,linestrings,these,line,strings,are,represented,as,an,array,of,coordinates,the,first,linestring,will,be,the,shell,of,the,polygon,the,others,define,holes,within,the,polygon,param,factory,link,geometry,factory,to,use,param,polygons,definition,of,polygons,return,a,new,multipolygon;protected,static,multi,polygon,multipolygon,s4j,geometry,factory,factory,coordinate,polygons,polygon,polygon,set,new,polygon,polygons,length,for,int,i,0,i,polygon,set,length,i,polygon,set,i,polygon,s4j,factory,polygons,i,return,factory,create,multi,polygon,polygon,set
PolygonBuilder -> protected static MultiPolygon multipolygonS4J(GeometryFactory factory, Coordinate[][][] polygons);1547195838;Create a Multipolygon from a set of coordinates. Each primary array contains a polygon which_in turn contains an array of linestrings. These line Strings are represented as an array of_coordinates. The first linestring will be the shell of the polygon the others define holes_within the polygon.__@param factory {@link GeometryFactory} to use_@param polygons definition of polygons_@return a new Multipolygon;protected static MultiPolygon multipolygonS4J(GeometryFactory factory, Coordinate[][][] polygons) {_        Polygon[] polygonSet = new Polygon[polygons.length]__        for (int i = 0_ i < polygonSet.length_ i++) {_            polygonSet[i] = polygonS4J(factory, polygons[i])__        }_        return factory.createMultiPolygon(polygonSet)__    };create,a,multipolygon,from,a,set,of,coordinates,each,primary,array,contains,a,polygon,which,in,turn,contains,an,array,of,linestrings,these,line,strings,are,represented,as,an,array,of,coordinates,the,first,linestring,will,be,the,shell,of,the,polygon,the,others,define,holes,within,the,polygon,param,factory,link,geometry,factory,to,use,param,polygons,definition,of,polygons,return,a,new,multipolygon;protected,static,multi,polygon,multipolygon,s4j,geometry,factory,factory,coordinate,polygons,polygon,polygon,set,new,polygon,polygons,length,for,int,i,0,i,polygon,set,length,i,polygon,set,i,polygon,s4j,factory,polygons,i,return,factory,create,multi,polygon,polygon,set
PolygonBuilder -> protected static MultiPolygon multipolygonS4J(GeometryFactory factory, Coordinate[][][] polygons);1548434247;Create a Multipolygon from a set of coordinates. Each primary array contains a polygon which_in turn contains an array of linestrings. These line Strings are represented as an array of_coordinates. The first linestring will be the shell of the polygon the others define holes_within the polygon.__@param factory {@link GeometryFactory} to use_@param polygons definition of polygons_@return a new Multipolygon;protected static MultiPolygon multipolygonS4J(GeometryFactory factory, Coordinate[][][] polygons) {_        Polygon[] polygonSet = new Polygon[polygons.length]__        for (int i = 0_ i < polygonSet.length_ i++) {_            polygonSet[i] = polygonS4J(factory, polygons[i])__        }_        return factory.createMultiPolygon(polygonSet)__    };create,a,multipolygon,from,a,set,of,coordinates,each,primary,array,contains,a,polygon,which,in,turn,contains,an,array,of,linestrings,these,line,strings,are,represented,as,an,array,of,coordinates,the,first,linestring,will,be,the,shell,of,the,polygon,the,others,define,holes,within,the,polygon,param,factory,link,geometry,factory,to,use,param,polygons,definition,of,polygons,return,a,new,multipolygon;protected,static,multi,polygon,multipolygon,s4j,geometry,factory,factory,coordinate,polygons,polygon,polygon,set,new,polygon,polygons,length,for,int,i,0,i,polygon,set,length,i,polygon,set,i,polygon,s4j,factory,polygons,i,return,factory,create,multi,polygon,polygon,set
PolygonBuilder -> public PolygonBuilder hole(LineStringBuilder hole);1524684173;Add a new hole to the polygon_@param hole linear ring defining the hole_@return this;public PolygonBuilder hole(LineStringBuilder hole) {_        return this.hole(hole, false)__    };add,a,new,hole,to,the,polygon,param,hole,linear,ring,defining,the,hole,return,this;public,polygon,builder,hole,line,string,builder,hole,return,this,hole,hole,false
PolygonBuilder -> public PolygonBuilder hole(LineStringBuilder hole);1528762805;Add a new hole to the polygon_@param hole linear ring defining the hole_@return this;public PolygonBuilder hole(LineStringBuilder hole) {_        return this.hole(hole, false)__    };add,a,new,hole,to,the,polygon,param,hole,linear,ring,defining,the,hole,return,this;public,polygon,builder,hole,line,string,builder,hole,return,this,hole,hole,false
PolygonBuilder -> public PolygonBuilder hole(LineStringBuilder hole);1533063033;Add a new hole to the polygon_@param hole linear ring defining the hole_@return this;public PolygonBuilder hole(LineStringBuilder hole) {_        return this.hole(hole, false)__    };add,a,new,hole,to,the,polygon,param,hole,linear,ring,defining,the,hole,return,this;public,polygon,builder,hole,line,string,builder,hole,return,this,hole,hole,false
PolygonBuilder -> public PolygonBuilder hole(LineStringBuilder hole);1542820501;Add a new hole to the polygon_@param hole linear ring defining the hole_@return this;public PolygonBuilder hole(LineStringBuilder hole) {_        return this.hole(hole, false)__    };add,a,new,hole,to,the,polygon,param,hole,linear,ring,defining,the,hole,return,this;public,polygon,builder,hole,line,string,builder,hole,return,this,hole,hole,false
PolygonBuilder -> public PolygonBuilder hole(LineStringBuilder hole);1547195838;Add a new hole to the polygon_@param hole linear ring defining the hole_@return this;public PolygonBuilder hole(LineStringBuilder hole) {_        return this.hole(hole, false)__    };add,a,new,hole,to,the,polygon,param,hole,linear,ring,defining,the,hole,return,this;public,polygon,builder,hole,line,string,builder,hole,return,this,hole,hole,false
PolygonBuilder -> public PolygonBuilder hole(LineStringBuilder hole);1548434247;Add a new hole to the polygon_@param hole linear ring defining the hole_@return this;public PolygonBuilder hole(LineStringBuilder hole) {_        return this.hole(hole, false)__    };add,a,new,hole,to,the,polygon,param,hole,linear,ring,defining,the,hole,return,this;public,polygon,builder,hole,line,string,builder,hole,return,this,hole,hole,false
PolygonBuilder -> private static Edge[] ring(int component, boolean direction, boolean handedness,                                  Coordinate[] points, int offset, Edge[] edges, int toffset, int length, final AtomicBoolean translated);1524684173;Create a connected list of a list of coordinates__@param points_array of point_@param offset_index of the first point_@param length_number of points_@return Array of edges;private static Edge[] ring(int component, boolean direction, boolean handedness,_                                 Coordinate[] points, int offset, Edge[] edges, int toffset, int length, final AtomicBoolean translated) {_        _        _        _        _        final int top = top(points, offset, length)__        final int prev = (offset + ((top + length - 1) % length))__        final int next = (offset + ((top + 1) % length))__        boolean orientation = points[offset + prev].x > points[offset + next].x___        _        _        _        __        _        double[] range = range(points, offset, length)__        final double rng = range[1] - range[0]__        _        _        _        _        boolean incorrectOrientation = component == 0 && handedness != orientation__        if ( (incorrectOrientation && (rng > DATELINE && rng != 2*DATELINE)) || (translated.get() && component != 0)) {_            translate(points)__            _            if (component == 0) {_                translated.set(true)__            }_            _            if (component == 0 || (component != 0 && handedness == orientation)) {_                orientation = !orientation__            }_        }_        return concat(component, direction ^ orientation, points, offset, edges, toffset, length)__    };create,a,connected,list,of,a,list,of,coordinates,param,points,array,of,point,param,offset,index,of,the,first,point,param,length,number,of,points,return,array,of,edges;private,static,edge,ring,int,component,boolean,direction,boolean,handedness,coordinate,points,int,offset,edge,edges,int,toffset,int,length,final,atomic,boolean,translated,final,int,top,top,points,offset,length,final,int,prev,offset,top,length,1,length,final,int,next,offset,top,1,length,boolean,orientation,points,offset,prev,x,points,offset,next,x,double,range,range,points,offset,length,final,double,rng,range,1,range,0,boolean,incorrect,orientation,component,0,handedness,orientation,if,incorrect,orientation,rng,dateline,rng,2,dateline,translated,get,component,0,translate,points,if,component,0,translated,set,true,if,component,0,component,0,handedness,orientation,orientation,orientation,return,concat,component,direction,orientation,points,offset,edges,toffset,length
PolygonBuilder -> private static Edge[] ring(int component, boolean direction, boolean handedness,                                  Coordinate[] points, int offset, Edge[] edges, int toffset, int length, final AtomicBoolean translated);1528762805;Create a connected list of a list of coordinates__@param points_array of point_@param offset_index of the first point_@param length_number of points_@return Array of edges;private static Edge[] ring(int component, boolean direction, boolean handedness,_                                 Coordinate[] points, int offset, Edge[] edges, int toffset, int length, final AtomicBoolean translated) {_        _        _        _        _        final int top = top(points, offset, length)__        final int prev = (offset + ((top + length - 1) % length))__        final int next = (offset + ((top + 1) % length))__        boolean orientation = points[offset + prev].x > points[offset + next].x___        _        _        _        __        _        double[] range = range(points, offset, length)__        final double rng = range[1] - range[0]__        _        _        _        _        boolean incorrectOrientation = component == 0 && handedness != orientation__        if ( (incorrectOrientation && (rng > DATELINE && rng != 2*DATELINE)) || (translated.get() && component != 0)) {_            translate(points)__            _            if (component == 0) {_                translated.set(true)__            }_            _            if (component == 0 || (component != 0 && handedness == orientation)) {_                orientation = !orientation__            }_        }_        return concat(component, direction ^ orientation, points, offset, edges, toffset, length)__    };create,a,connected,list,of,a,list,of,coordinates,param,points,array,of,point,param,offset,index,of,the,first,point,param,length,number,of,points,return,array,of,edges;private,static,edge,ring,int,component,boolean,direction,boolean,handedness,coordinate,points,int,offset,edge,edges,int,toffset,int,length,final,atomic,boolean,translated,final,int,top,top,points,offset,length,final,int,prev,offset,top,length,1,length,final,int,next,offset,top,1,length,boolean,orientation,points,offset,prev,x,points,offset,next,x,double,range,range,points,offset,length,final,double,rng,range,1,range,0,boolean,incorrect,orientation,component,0,handedness,orientation,if,incorrect,orientation,rng,dateline,rng,2,dateline,translated,get,component,0,translate,points,if,component,0,translated,set,true,if,component,0,component,0,handedness,orientation,orientation,orientation,return,concat,component,direction,orientation,points,offset,edges,toffset,length
PolygonBuilder -> private static Edge[] ring(int component, boolean direction, boolean handedness,                                  Coordinate[] points, int offset, Edge[] edges, int toffset, int length, final AtomicBoolean translated);1533063033;Create a connected list of a list of coordinates__@param points_array of point_@param offset_index of the first point_@param length_number of points_@return Array of edges;private static Edge[] ring(int component, boolean direction, boolean handedness,_                                 Coordinate[] points, int offset, Edge[] edges, int toffset, int length, final AtomicBoolean translated) {__        boolean orientation = getOrientation(points, offset, length)___        _        _        _        __        _        double[] range = range(points, offset, length)__        final double rng = range[1] - range[0]__        _        _        _        _        boolean incorrectOrientation = component == 0 && handedness != orientation__        if ( (incorrectOrientation && (rng > DATELINE && rng != 2*DATELINE)) || (translated.get() && component != 0)) {_            translate(points)__            _            if (component == 0) {_                translated.set(true)__            }_            _            if (component == 0 || (component != 0 && handedness == orientation)) {_                orientation = !orientation__            }_        }_        return concat(component, direction ^ orientation, points, offset, edges, toffset, length)__    };create,a,connected,list,of,a,list,of,coordinates,param,points,array,of,point,param,offset,index,of,the,first,point,param,length,number,of,points,return,array,of,edges;private,static,edge,ring,int,component,boolean,direction,boolean,handedness,coordinate,points,int,offset,edge,edges,int,toffset,int,length,final,atomic,boolean,translated,boolean,orientation,get,orientation,points,offset,length,double,range,range,points,offset,length,final,double,rng,range,1,range,0,boolean,incorrect,orientation,component,0,handedness,orientation,if,incorrect,orientation,rng,dateline,rng,2,dateline,translated,get,component,0,translate,points,if,component,0,translated,set,true,if,component,0,component,0,handedness,orientation,orientation,orientation,return,concat,component,direction,orientation,points,offset,edges,toffset,length
PolygonBuilder -> private static Edge[] ring(int component, boolean direction, boolean handedness,                                  Coordinate[] points, int offset, Edge[] edges, int toffset, int length, final AtomicBoolean translated);1542820501;Create a connected list of a list of coordinates__@param points_array of point_@param offset_index of the first point_@param length_number of points_@return Array of edges;private static Edge[] ring(int component, boolean direction, boolean handedness,_                                 Coordinate[] points, int offset, Edge[] edges, int toffset, int length, final AtomicBoolean translated) {__        boolean orientation = getOrientation(points, offset, length)___        _        _        _        __        _        double[] range = range(points, offset, length)__        final double rng = range[1] - range[0]__        _        _        _        _        boolean incorrectOrientation = component == 0 && handedness != orientation__        if ( (incorrectOrientation && (rng > DATELINE && rng != 2*DATELINE)) || (translated.get() && component != 0)) {_            translate(points)__            _            if (component == 0) {_                translated.set(true)__            }_            _            if (component == 0 || (component != 0 && handedness == orientation)) {_                orientation = !orientation__            }_        }_        return concat(component, direction ^ orientation, points, offset, edges, toffset, length)__    };create,a,connected,list,of,a,list,of,coordinates,param,points,array,of,point,param,offset,index,of,the,first,point,param,length,number,of,points,return,array,of,edges;private,static,edge,ring,int,component,boolean,direction,boolean,handedness,coordinate,points,int,offset,edge,edges,int,toffset,int,length,final,atomic,boolean,translated,boolean,orientation,get,orientation,points,offset,length,double,range,range,points,offset,length,final,double,rng,range,1,range,0,boolean,incorrect,orientation,component,0,handedness,orientation,if,incorrect,orientation,rng,dateline,rng,2,dateline,translated,get,component,0,translate,points,if,component,0,translated,set,true,if,component,0,component,0,handedness,orientation,orientation,orientation,return,concat,component,direction,orientation,points,offset,edges,toffset,length
PolygonBuilder -> private static Edge[] ring(int component, boolean direction, boolean handedness,                                  Coordinate[] points, int offset, Edge[] edges, int toffset, int length, final AtomicBoolean translated);1547195838;Create a connected list of a list of coordinates__@param points_array of point_@param offset_index of the first point_@param length_number of points_@return Array of edges;private static Edge[] ring(int component, boolean direction, boolean handedness,_                                 Coordinate[] points, int offset, Edge[] edges, int toffset, int length, final AtomicBoolean translated) {__        boolean orientation = getOrientation(points, offset, length)___        _        _        _        __        _        double[] range = range(points, offset, length)__        final double rng = range[1] - range[0]__        _        _        _        _        boolean incorrectOrientation = component == 0 && handedness != orientation__        if ( (incorrectOrientation && (rng > DATELINE && rng != 2*DATELINE)) || (translated.get() && component != 0)) {_            translate(points)__            _            if (component == 0) {_                translated.set(true)__            }_            _            if (component == 0 || (component != 0 && handedness == orientation)) {_                orientation = !orientation__            }_        }_        return concat(component, direction ^ orientation, points, offset, edges, toffset, length)__    };create,a,connected,list,of,a,list,of,coordinates,param,points,array,of,point,param,offset,index,of,the,first,point,param,length,number,of,points,return,array,of,edges;private,static,edge,ring,int,component,boolean,direction,boolean,handedness,coordinate,points,int,offset,edge,edges,int,toffset,int,length,final,atomic,boolean,translated,boolean,orientation,get,orientation,points,offset,length,double,range,range,points,offset,length,final,double,rng,range,1,range,0,boolean,incorrect,orientation,component,0,handedness,orientation,if,incorrect,orientation,rng,dateline,rng,2,dateline,translated,get,component,0,translate,points,if,component,0,translated,set,true,if,component,0,component,0,handedness,orientation,orientation,orientation,return,concat,component,direction,orientation,points,offset,edges,toffset,length
PolygonBuilder -> private static Edge[] ring(int component, boolean direction, boolean handedness,                                  Coordinate[] points, int offset, Edge[] edges, int toffset, int length, final AtomicBoolean translated);1548434247;Create a connected list of a list of coordinates__@param points_array of point_@param offset_index of the first point_@param length_number of points_@return Array of edges;private static Edge[] ring(int component, boolean direction, boolean handedness,_                                 Coordinate[] points, int offset, Edge[] edges, int toffset, int length, final AtomicBoolean translated) {__        boolean orientation = getOrientation(points, offset, length)___        _        _        _        __        _        double[] range = range(points, offset, length)__        final double rng = range[1] - range[0]__        _        _        _        _        boolean incorrectOrientation = component == 0 && handedness != orientation__        if ( (incorrectOrientation && (rng > DATELINE && rng != 2*DATELINE)) || (translated.get() && component != 0)) {_            translate(points)__            _            if (component == 0) {_                translated.set(true)__            }_            _            if (component == 0 || (component != 0 && handedness == orientation)) {_                orientation = !orientation__            }_        }_        return concat(component, direction ^ orientation, points, offset, edges, toffset, length)__    };create,a,connected,list,of,a,list,of,coordinates,param,points,array,of,point,param,offset,index,of,the,first,point,param,length,number,of,points,return,array,of,edges;private,static,edge,ring,int,component,boolean,direction,boolean,handedness,coordinate,points,int,offset,edge,edges,int,toffset,int,length,final,atomic,boolean,translated,boolean,orientation,get,orientation,points,offset,length,double,range,range,points,offset,length,final,double,rng,range,1,range,0,boolean,incorrect,orientation,component,0,handedness,orientation,if,incorrect,orientation,rng,dateline,rng,2,dateline,translated,get,component,0,translate,points,if,component,0,translated,set,true,if,component,0,component,0,handedness,orientation,orientation,orientation,return,concat,component,direction,orientation,points,offset,edges,toffset,length
