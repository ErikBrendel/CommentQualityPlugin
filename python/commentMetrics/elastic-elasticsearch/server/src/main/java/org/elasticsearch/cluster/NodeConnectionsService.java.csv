commented;modifiers;parameterAmount;loc;comment;code
false;public;1;8;;@Override public void onFailure(Exception e) {     // both errors and rejections are logged here. the service     // will try again after `cluster.nodes.reconnect_interval` on all nodes but the current master.     // On the master, node fault detection will remove these nodes from the cluster as their are not     // connected. Note that it is very rare that we end up here on the master.     logger.warn(() -> new ParameterizedMessage("failed to connect to {}", node), e). }
false;protected;0;6;;@Override protected void doRun() {     try (Releasable ignored = nodeLocks.acquire(node)) {         validateAndConnectIfNeeded(node).     } }
false;public;0;4;;@Override public void onAfter() {     latch.countDown(). }
false;public;1;42;;public void connectToNodes(DiscoveryNodes discoveryNodes) {     CountDownLatch latch = new CountDownLatch(discoveryNodes.getSize()).     for (final DiscoveryNode node : discoveryNodes) {         final boolean connected.         try (Releasable ignored = nodeLocks.acquire(node)) {             nodes.putIfAbsent(node, 0).             connected = transportService.nodeConnected(node).         }         if (connected) {             latch.countDown().         } else {             // spawn to another thread to do in parallel             threadPool.executor(ThreadPool.Names.MANAGEMENT).execute(new AbstractRunnable() {                  @Override                 public void onFailure(Exception e) {                     // both errors and rejections are logged here. the service                     // will try again after `cluster.nodes.reconnect_interval` on all nodes but the current master.                     // On the master, node fault detection will remove these nodes from the cluster as their are not                     // connected. Note that it is very rare that we end up here on the master.                     logger.warn(() -> new ParameterizedMessage("failed to connect to {}", node), e).                 }                  @Override                 protected void doRun() {                     try (Releasable ignored = nodeLocks.acquire(node)) {                         validateAndConnectIfNeeded(node).                     }                 }                  @Override                 public void onAfter() {                     latch.countDown().                 }             }).         }     }     try {         latch.await().     } catch (InterruptedException e) {         Thread.currentThread().interrupt().     } }
true;public;1;17;/**  * Disconnects from all nodes except the ones provided as parameter  */ ;/**  * Disconnects from all nodes except the ones provided as parameter  */ public void disconnectFromNodesExcept(DiscoveryNodes nodesToKeep) {     Set<DiscoveryNode> currentNodes = new HashSet<>(nodes.keySet()).     for (DiscoveryNode node : nodesToKeep) {         currentNodes.remove(node).     }     for (final DiscoveryNode node : currentNodes) {         try (Releasable ignored = nodeLocks.acquire(node)) {             Integer current = nodes.remove(node).             assert current != null : "node " + node + " was removed in event but not in internal nodes".             try {                 transportService.disconnectFromNode(node).             } catch (Exception e) {                 logger.warn(() -> new ParameterizedMessage("failed to disconnect to node [{}]", node), e).             }         }     } }
false;;1;24;;void validateAndConnectIfNeeded(DiscoveryNode node) {     assert nodeLocks.isHeldByCurrentThread(node) : "validateAndConnectIfNeeded must be called under lock".     if (lifecycle.stoppedOrClosed() || nodes.containsKey(node) == false) {     // we double check existence of node since connectToNode might take time...     // nothing to do     } else {         try {             // connecting to an already connected node is a noop             transportService.connectToNode(node).             nodes.put(node, 0).         } catch (Exception e) {             Integer nodeFailureCount = nodes.get(node).             assert nodeFailureCount != null : node + " didn't have a counter in nodes map".             nodeFailureCount = nodeFailureCount + 1.             // log every 6th failure             if ((nodeFailureCount % 6) == 1) {                 final int finalNodeFailureCount = nodeFailureCount.                 logger.warn(() -> new ParameterizedMessage("failed to connect to node {} (tried [{}] times)", node, finalNodeFailureCount), e).             }             nodes.put(node, nodeFailureCount).         }     } }
false;public;1;4;;@Override public void onFailure(Exception e) {     logger.warn("unexpected error while checking for node reconnects", e). }
false;protected;0;7;;protected void doRun() {     for (DiscoveryNode node : nodes.keySet()) {         try (Releasable ignored = nodeLocks.acquire(node)) {             validateAndConnectIfNeeded(node).         }     } }
false;public;0;6;;@Override public void onAfter() {     if (lifecycle.started()) {         backgroundCancellable = threadPool.schedule(this, reconnectInterval, ThreadPool.Names.GENERIC).     } }
false;protected;0;4;;@Override protected void doStart() {     backgroundCancellable = threadPool.schedule(new ConnectionChecker(), reconnectInterval, ThreadPool.Names.GENERIC). }
false;protected;0;6;;@Override protected void doStop() {     if (backgroundCancellable != null) {         backgroundCancellable.cancel().     } }
false;protected;0;4;;@Override protected void doClose() { }
