commented;modifiers;parameterAmount;loc;comment;code
false;public,static;2;4;;public static long encodeLatLon(double lat, double lon) {     return (Integer.toUnsignedLong(GeoEncodingUtils.encodeLatitude(lat)) << 32) | Integer.toUnsignedLong(GeoEncodingUtils.encodeLongitude(lon)). }
false;public,static;1;3;;public static double decodeLatitude(long encodedLatLon) {     return GeoEncodingUtils.decodeLatitude((int) (encodedLatLon >>> 32)). }
false;public,static;1;3;;public static double decodeLongitude(long encodedLatLon) {     return GeoEncodingUtils.decodeLongitude((int) (encodedLatLon & 0xFFFFFFFFL)). }
false;protected;1;11;;@Override protected void doWriteTo(StreamOutput out) throws IOException {     out.writeVLong(count).     if (centroid != null) {         out.writeBoolean(true).         // should we just write lat and lon separately?         out.writeLong(encodeLatLon(centroid.lat(), centroid.lon())).     } else {         out.writeBoolean(false).     } }
false;public;0;4;;@Override public String getWriteableName() {     return GeoCentroidAggregationBuilder.NAME. }
false;public;0;4;;@Override public GeoPoint centroid() {     return centroid. }
false;public;0;4;;@Override public long count() {     return count. }
false;public;2;21;;@Override public InternalGeoCentroid doReduce(List<InternalAggregation> aggregations, ReduceContext reduceContext) {     double lonSum = Double.NaN.     double latSum = Double.NaN.     int totalCount = 0.     for (InternalAggregation aggregation : aggregations) {         InternalGeoCentroid centroidAgg = (InternalGeoCentroid) aggregation.         if (centroidAgg.count > 0) {             totalCount += centroidAgg.count.             if (Double.isNaN(lonSum)) {                 lonSum = centroidAgg.count * centroidAgg.centroid.getLon().                 latSum = centroidAgg.count * centroidAgg.centroid.getLat().             } else {                 lonSum += (centroidAgg.count * centroidAgg.centroid.getLon()).                 latSum += (centroidAgg.count * centroidAgg.centroid.getLat()).             }         }     }     final GeoPoint result = (Double.isNaN(lonSum)) ? null : new GeoPoint(latSum / totalCount, lonSum / totalCount).     return new InternalGeoCentroid(name, result, totalCount, pipelineAggregators(), getMetaData()). }
false;public;1;22;;@Override public Object getProperty(List<String> path) {     if (path.isEmpty()) {         return this.     } else if (path.size() == 1) {         String coordinate = path.get(0).         switch(coordinate) {             case "value":                 return centroid.             case "lat":                 return centroid.lat().             case "lon":                 return centroid.lon().             case "count":                 return count.             default:                 throw new IllegalArgumentException("Found unknown path element [" + coordinate + "] in [" + getName() + "]").         }     } else {         throw new IllegalArgumentException("path not supported for [" + getName() + "]: " + path).     } }
false;public;2;13;;@Override public XContentBuilder doXContentBody(XContentBuilder builder, Params params) throws IOException {     if (centroid != null) {         builder.startObject(Fields.CENTROID.getPreferredName()).         {             builder.field(Fields.CENTROID_LAT.getPreferredName(), centroid.lat()).             builder.field(Fields.CENTROID_LON.getPreferredName(), centroid.lon()).         }         builder.endObject().     }     builder.field(Fields.COUNT.getPreferredName(), count).     return builder. }
false;public;1;6;;@Override public boolean doEquals(Object o) {     InternalGeoCentroid that = (InternalGeoCentroid) o.     return count == that.count && Objects.equals(centroid, that.centroid). }
false;protected;0;4;;@Override protected int doHashCode() {     return Objects.hash(centroid, count). }
false;public;0;7;;@Override public String toString() {     return "InternalGeoCentroid{" + "centroid=" + centroid + ", count=" + count + '}'. }
