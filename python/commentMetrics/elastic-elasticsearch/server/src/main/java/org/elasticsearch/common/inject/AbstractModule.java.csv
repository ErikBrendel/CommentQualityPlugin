commented;modifiers;parameterAmount;loc;comment;code
false;public,final,synchronized;1;12;;@Override public final synchronized void configure(Binder builder) {     if (this.binder != null) {         throw new IllegalStateException("Re-entry is not allowed.").     }     this.binder = Objects.requireNonNull(builder, "builder").     try {         configure().     } finally {         this.binder = null.     } }
true;protected,abstract;0;1;/**  * Configures a {@link Binder} via the exposed methods.  */ ;/**  * Configures a {@link Binder} via the exposed methods.  */ protected abstract void configure().
true;protected;0;3;/**  * Gets direct access to the underlying {@code Binder}.  */ ;/**  * Gets direct access to the underlying {@code Binder}.  */ protected Binder binder() {     return binder. }
true;protected;2;4;/**  * @see Binder#bindScope(Class, Scope)  */ ;/**  * @see Binder#bindScope(Class, Scope)  */ protected void bindScope(Class<? extends Annotation> scopeAnnotation, Scope scope) {     binder.bindScope(scopeAnnotation, scope). }
true;protected;1;3;/**  * @see Binder#bind(Key)  */ ;/**  * @see Binder#bind(Key)  */ protected <T> LinkedBindingBuilder<T> bind(Key<T> key) {     return binder.bind(key). }
true;protected;1;3;/**  * @see Binder#bind(TypeLiteral)  */ ;/**  * @see Binder#bind(TypeLiteral)  */ protected <T> AnnotatedBindingBuilder<T> bind(TypeLiteral<T> typeLiteral) {     return binder.bind(typeLiteral). }
true;protected;1;3;/**  * @see Binder#bind(Class)  */ ;/**  * @see Binder#bind(Class)  */ protected <T> AnnotatedBindingBuilder<T> bind(Class<T> clazz) {     return binder.bind(clazz). }
true;protected;0;3;/**  * @see Binder#bindConstant()  */ ;/**  * @see Binder#bindConstant()  */ protected AnnotatedConstantBindingBuilder bindConstant() {     return binder.bindConstant(). }
true;protected;1;3;/**  * @see Binder#install(Module)  */ ;/**  * @see Binder#install(Module)  */ protected void install(Module module) {     binder.install(module). }
true;protected;2;3;/**  * @see Binder#addError(String, Object[])  */ ;/**  * @see Binder#addError(String, Object[])  */ protected void addError(String message, Object... arguments) {     binder.addError(message, arguments). }
true;protected;1;3;/**  * @see Binder#addError(Throwable)  */ ;/**  * @see Binder#addError(Throwable)  */ protected void addError(Throwable t) {     binder.addError(t). }
true;protected;1;3;/**  * @see Binder#addError(Message)  * @since 2.0  */ ;/**  * @see Binder#addError(Message)  * @since 2.0  */ protected void addError(Message message) {     binder.addError(message). }
true;protected;1;3;/**  * @see Binder#requestInjection(Object)  * @since 2.0  */ ;/**  * @see Binder#requestInjection(Object)  * @since 2.0  */ protected void requestInjection(Object instance) {     binder.requestInjection(instance). }
true;protected;1;3;/**  * @see Binder#requestStaticInjection(Class[])  */ ;/**  * @see Binder#requestStaticInjection(Class[])  */ protected void requestStaticInjection(Class<?>... types) {     binder.requestStaticInjection(types). }
true;protected;1;3;/**  * Adds a dependency from this module to {@code key}. When the injector is  * created, Guice will report an error if {@code key} cannot be injected.  * Note that this requirement may be satisfied by implicit binding, such as  * a public no-arguments constructor.  *  * @since 2.0  */ ;/**  * Adds a dependency from this module to {@code key}. When the injector is  * created, Guice will report an error if {@code key} cannot be injected.  * Note that this requirement may be satisfied by implicit binding, such as  * a public no-arguments constructor.  *  * @since 2.0  */ protected void requireBinding(Key<?> key) {     binder.getProvider(key). }
true;protected;1;3;/**  * Adds a dependency from this module to {@code type}. When the injector is  * created, Guice will report an error if {@code type} cannot be injected.  * Note that this requirement may be satisfied by implicit binding, such as  * a public no-arguments constructor.  *  * @since 2.0  */ ;/**  * Adds a dependency from this module to {@code type}. When the injector is  * created, Guice will report an error if {@code type} cannot be injected.  * Note that this requirement may be satisfied by implicit binding, such as  * a public no-arguments constructor.  *  * @since 2.0  */ protected void requireBinding(Class<?> type) {     binder.getProvider(type). }
true;protected;1;3;/**  * @see Binder#getProvider(Key)  * @since 2.0  */ ;/**  * @see Binder#getProvider(Key)  * @since 2.0  */ protected <T> Provider<T> getProvider(Key<T> key) {     return binder.getProvider(key). }
true;protected;1;3;/**  * @see Binder#getProvider(Class)  * @since 2.0  */ ;/**  * @see Binder#getProvider(Class)  * @since 2.0  */ protected <T> Provider<T> getProvider(Class<T> type) {     return binder.getProvider(type). }
true;protected;2;4;/**  * @see Binder#convertToTypes  * @since 2.0  */ ;/**  * @see Binder#convertToTypes  * @since 2.0  */ protected void convertToTypes(Matcher<? super TypeLiteral<?>> typeMatcher, TypeConverter converter) {     binder.convertToTypes(typeMatcher, converter). }
true;protected;0;3;/**  * @see Binder#currentStage()  * @since 2.0  */ ;/**  * @see Binder#currentStage()  * @since 2.0  */ protected Stage currentStage() {     return binder.currentStage(). }
true;protected;1;3;/**  * @see Binder#getMembersInjector(Class)  * @since 2.0  */ ;/**  * @see Binder#getMembersInjector(Class)  * @since 2.0  */ protected <T> MembersInjector<T> getMembersInjector(Class<T> type) {     return binder.getMembersInjector(type). }
true;protected;1;3;/**  * @see Binder#getMembersInjector(TypeLiteral)  * @since 2.0  */ ;/**  * @see Binder#getMembersInjector(TypeLiteral)  * @since 2.0  */ protected <T> MembersInjector<T> getMembersInjector(TypeLiteral<T> type) {     return binder.getMembersInjector(type). }
true;protected;2;4;/**  * @see Binder#bindListener(org.elasticsearch.common.inject.matcher.Matcher,  *      org.elasticsearch.common.inject.spi.TypeListener)  * @since 2.0  */ ;/**  * @see Binder#bindListener(org.elasticsearch.common.inject.matcher.Matcher,  *      org.elasticsearch.common.inject.spi.TypeListener)  * @since 2.0  */ protected void bindListener(Matcher<? super TypeLiteral<?>> typeMatcher, TypeListener listener) {     binder.bindListener(typeMatcher, listener). }
