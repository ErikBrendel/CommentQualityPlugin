commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public LeafScoreFunction getLeafScoreFunction(LeafReaderContext ctx) throws IOException {     return function.getLeafScoreFunction(ctx). }
false;public;0;4;;@Override public boolean needsScores() {     return function.needsScores(). }
false;protected;1;8;;@Override protected boolean doEquals(ScoreFunction other) {     if (getClass() != other.getClass()) {         return false.     }     FilterScoreFunction that = (FilterScoreFunction) other.     return Objects.equals(this.filter, that.filter) && Objects.equals(this.function, that.function). }
false;protected;0;4;;@Override protected int doHashCode() {     return Objects.hash(filter, function). }
false;protected;1;8;;@Override protected ScoreFunction rewrite(IndexReader reader) throws IOException {     Query newFilter = filter.rewrite(reader).     if (newFilter == filter) {         return this.     }     return new FilterScoreFunction(newFilter, function). }
false;public;0;4;;@Override public float getWeight() {     return function.getWeight(). }
false;public;1;4;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeEnum(this). }
false;public,static;1;3;;public static ScoreMode readFromStream(StreamInput in) throws IOException {     return in.readEnum(ScoreMode.class). }
false;public,static;1;3;;public static ScoreMode fromString(String scoreMode) {     return valueOf(scoreMode.toUpperCase(Locale.ROOT)). }
false;public;0;3;;public Query getSubQuery() {     return subQuery. }
false;public;0;3;;public ScoreFunction[] getFunctions() {     return functions. }
false;public;0;3;;public Float getMinScore() {     return minScore. }
false;public;0;3;;public CombineFunction getCombineFunction() {     return combineFunction. }
false;public;1;18;;@Override public Query rewrite(IndexReader reader) throws IOException {     Query rewritten = super.rewrite(reader).     if (rewritten != this) {         return rewritten.     }     Query newQ = subQuery.rewrite(reader).     ScoreFunction[] newFunctions = new ScoreFunction[functions.length].     boolean needsRewrite = (newQ != subQuery).     for (int i = 0. i < functions.length. i++) {         newFunctions[i] = functions[i].rewrite(reader).         needsRewrite |= (newFunctions[i] != functions[i]).     }     if (needsRewrite) {         return new FunctionScoreQuery(newQ, scoreMode, newFunctions, combineFunction, minScore, maxBoost).     }     return this. }
false;public;3;23;;@Override public Weight createWeight(IndexSearcher searcher, org.apache.lucene.search.ScoreMode scoreMode, float boost) throws IOException {     if (scoreMode == org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES && minScore == null) {         return subQuery.createWeight(searcher, scoreMode, boost).     }     org.apache.lucene.search.ScoreMode subQueryScoreMode = combineFunction != CombineFunction.REPLACE ? org.apache.lucene.search.ScoreMode.COMPLETE : org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES.     Weight[] filterWeights = new Weight[functions.length].     for (int i = 0. i < functions.length. ++i) {         if (functions[i].needsScores()) {             subQueryScoreMode = org.apache.lucene.search.ScoreMode.COMPLETE.         }         if (functions[i] instanceof FilterScoreFunction) {             Query filter = ((FilterScoreFunction) functions[i]).filter.             filterWeights[i] = searcher.createWeight(searcher.rewrite(filter), org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES, 1f).         }     }     Weight subQueryWeight = subQuery.createWeight(searcher, subQueryScoreMode, boost).     return new CustomBoostFactorWeight(this, subQueryWeight, filterWeights, subQueryScoreMode.needsScores()). }
false;public;1;4;;@Override public void extractTerms(Set<Term> terms) {     subQueryWeight.extractTerms(terms). }
false;private;1;20;;private FunctionFactorScorer functionScorer(LeafReaderContext context) throws IOException {     Scorer subQueryScorer = subQueryWeight.scorer(context).     if (subQueryScorer == null) {         return null.     }     final LeafScoreFunction[] leafFunctions = new LeafScoreFunction[functions.length].     final Bits[] docSets = new Bits[functions.length].     for (int i = 0. i < functions.length. i++) {         ScoreFunction function = functions[i].         leafFunctions[i] = function.getLeafScoreFunction(context).         if (filterWeights[i] != null) {             ScorerSupplier filterScorerSupplier = filterWeights[i].scorerSupplier(context).             docSets[i] = Lucene.asSequentialAccessBits(context.reader().maxDoc(), filterScorerSupplier).         } else {             docSets[i] = new Bits.MatchAllBits(context.reader().maxDoc()).         }     }     return new FunctionFactorScorer(this, subQueryScorer, scoreMode, functions, maxBoost, leafFunctions, docSets, combineFunction, needsScores). }
false;public;1;8;;@Override public Scorer scorer(LeafReaderContext context) throws IOException {     Scorer scorer = functionScorer(context).     if (scorer != null && minScore != null) {         scorer = new MinScoreScorer(this, scorer, minScore).     }     return scorer. }
false;public;2;53;;@Override public Explanation explain(LeafReaderContext context, int doc) throws IOException {     Explanation expl = subQueryWeight.explain(context, doc).     if (!expl.isMatch()) {         return expl.     }     boolean singleFunction = functions.length == 1 && functions[0] instanceof FilterScoreFunction == false.     if (functions.length > 0) {         // First: Gather explanations for all functions/filters         List<Explanation> functionsExplanations = new ArrayList<>().         for (int i = 0. i < functions.length. ++i) {             if (filterWeights[i] != null) {                 final Bits docSet = Lucene.asSequentialAccessBits(context.reader().maxDoc(), filterWeights[i].scorerSupplier(context)).                 if (docSet.get(doc) == false) {                     continue.                 }             }             ScoreFunction function = functions[i].             Explanation functionExplanation = function.getLeafScoreFunction(context).explainScore(doc, expl).             if (function instanceof FilterScoreFunction) {                 float factor = functionExplanation.getValue().floatValue().                 Query filterQuery = ((FilterScoreFunction) function).filter.                 Explanation filterExplanation = Explanation.match(factor, "function score, product of:", Explanation.match(1.0f, "match filter: " + filterQuery.toString()), functionExplanation).                 functionsExplanations.add(filterExplanation).             } else {                 functionsExplanations.add(functionExplanation).             }         }         final Explanation factorExplanation.         if (functionsExplanations.size() == 0) {             // it is a little weird to add a match although no function matches but that is the way function_score behaves right now             factorExplanation = Explanation.match(1.0f, "No function matched", Collections.emptyList()).         } else if (singleFunction && functionsExplanations.size() == 1) {             factorExplanation = functionsExplanations.get(0).         } else {             FunctionFactorScorer scorer = functionScorer(context).             int actualDoc = scorer.iterator().advance(doc).             assert (actualDoc == doc).             double score = scorer.computeScore(doc, expl.getValue().floatValue()).             factorExplanation = Explanation.match((float) score, "function score, score mode [" + scoreMode.toString().toLowerCase(Locale.ROOT) + "]", functionsExplanations).         }         expl = combineFunction.explain(expl, factorExplanation, maxBoost).     }     if (minScore != null && minScore > expl.getValue().floatValue()) {         expl = Explanation.noMatch("Score value is too low, expected at least " + minScore + " but got " + expl.getValue(), expl).     }     return expl. }
false;public;1;6;;@Override public boolean isCacheable(LeafReaderContext ctx) {     // top-level reader.     return minScore == null. }
false;public;0;21;;@Override public float score() throws IOException {     int docId = docID().     // Even if the weight is created with needsScores=false, it might     // be costly to call score(), so we explicitly check if scores     // are needed     float subQueryScore = needsScores ? super.score() : 0f.     if (leafFunctions.length == 0) {         return subQueryScore.     }     double factor = computeScore(docId, subQueryScore).     float finalScore = scoreCombiner.combine(subQueryScore, factor, maxBoost).     if (finalScore < 0f || Float.isNaN(finalScore)) {         /*                   These scores are invalid for score based {@link org.apache.lucene.search.TopDocsCollector}s.                   See {@link org.apache.lucene.search.TopScoreDocCollector} for details.                  */         throw new ElasticsearchException("function score query returned an invalid score: " + finalScore + " for doc: " + docId).     }     return finalScore. }
false;protected;2;59;;protected double computeScore(int docId, float subQueryScore) throws IOException {     double factor = 1d.     switch(scoreMode) {         case FIRST:             for (int i = 0. i < leafFunctions.length. i++) {                 if (docSets[i].get(docId)) {                     factor = leafFunctions[i].score(docId, subQueryScore).                     break.                 }             }             break.         case MAX:             double maxFactor = Double.NEGATIVE_INFINITY.             for (int i = 0. i < leafFunctions.length. i++) {                 if (docSets[i].get(docId)) {                     maxFactor = Math.max(leafFunctions[i].score(docId, subQueryScore), maxFactor).                 }             }             if (maxFactor != Float.NEGATIVE_INFINITY) {                 factor = maxFactor.             }             break.         case MIN:             double minFactor = Double.POSITIVE_INFINITY.             for (int i = 0. i < leafFunctions.length. i++) {                 if (docSets[i].get(docId)) {                     minFactor = Math.min(leafFunctions[i].score(docId, subQueryScore), minFactor).                 }             }             if (minFactor != Float.POSITIVE_INFINITY) {                 factor = minFactor.             }             break.         case MULTIPLY:             for (int i = 0. i < leafFunctions.length. i++) {                 if (docSets[i].get(docId)) {                     factor *= leafFunctions[i].score(docId, subQueryScore).                 }             }             break.         default:             // Avg / Total             double totalFactor = 0.0f.             double weightSum = 0.             for (int i = 0. i < leafFunctions.length. i++) {                 if (docSets[i].get(docId)) {                     totalFactor += leafFunctions[i].score(docId, subQueryScore).                     weightSum += functions[i].getWeight().                 }             }             if (weightSum != 0) {                 factor = totalFactor.                 if (scoreMode == ScoreMode.AVG) {                     factor /= weightSum.                 }             }             break.     }     return factor. }
false;public;1;4;;@Override public float getMaxScore(int upTo) throws IOException {     // TODO: what would be a good upper bound?     return Float.MAX_VALUE. }
false;public;1;10;;@Override public String toString(String field) {     StringBuilder sb = new StringBuilder().     sb.append("function score (").append(subQuery.toString(field)).append(", functions: [").     for (ScoreFunction function : functions) {         sb.append("{" + (function == null ? "" : function.toString()) + "}").     }     sb.append("])").     return sb.toString(). }
false;public;1;14;;@Override public boolean equals(Object o) {     if (this == o) {         return true.     }     if (sameClassAs(o) == false) {         return false.     }     FunctionScoreQuery other = (FunctionScoreQuery) o.     return Objects.equals(this.subQuery, other.subQuery) && this.maxBoost == other.maxBoost && Objects.equals(this.combineFunction, other.combineFunction) && Objects.equals(this.minScore, other.minScore) && Objects.equals(this.scoreMode, other.scoreMode) && Arrays.equals(this.functions, other.functions). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(classHash(), subQuery, maxBoost, combineFunction, minScore, scoreMode, Arrays.hashCode(functions)). }
