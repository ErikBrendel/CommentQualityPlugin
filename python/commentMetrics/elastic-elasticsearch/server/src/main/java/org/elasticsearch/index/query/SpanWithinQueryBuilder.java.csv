commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;5;;@Override protected void doWriteTo(StreamOutput out) throws IOException {     out.writeNamedWriteable(big).     out.writeNamedWriteable(little). }
true;public;0;3;/**  * @return the little clause, contained within {@code big} for a match.  */ ;/**  * @return the little clause, contained within {@code big} for a match.  */ public SpanQueryBuilder littleQuery() {     return this.little. }
true;public;0;3;/**  * @return the big clause that must enclose {@code little} for a match.  */ ;/**  * @return the big clause that must enclose {@code little} for a match.  */ public SpanQueryBuilder bigQuery() {     return this.big. }
false;protected;2;14;;@Override protected void doXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject(NAME).     builder.field(BIG_FIELD.getPreferredName()).     big.toXContent(builder, params).     builder.field(LITTLE_FIELD.getPreferredName()).     little.toXContent(builder, params).     printBoostAndQueryName(builder).     builder.endObject(). }
false;public,static;1;50;;public static SpanWithinQueryBuilder fromXContent(XContentParser parser) throws IOException {     float boost = AbstractQueryBuilder.DEFAULT_BOOST.     String queryName = null.     SpanQueryBuilder big = null.     SpanQueryBuilder little = null.     String currentFieldName = null.     XContentParser.Token token.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (token == XContentParser.Token.START_OBJECT) {             if (BIG_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 QueryBuilder query = parseInnerQueryBuilder(parser).                 if (query instanceof SpanQueryBuilder == false) {                     throw new ParsingException(parser.getTokenLocation(), "span_within [big] must be of type span query").                 }                 big = (SpanQueryBuilder) query.                 checkNoBoost(NAME, currentFieldName, parser, big).             } else if (LITTLE_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 QueryBuilder query = parseInnerQueryBuilder(parser).                 if (query instanceof SpanQueryBuilder == false) {                     throw new ParsingException(parser.getTokenLocation(), "span_within [little] must be of type span query").                 }                 little = (SpanQueryBuilder) query.                 checkNoBoost(NAME, currentFieldName, parser, little).             } else {                 throw new ParsingException(parser.getTokenLocation(), "[span_within] query does not support [" + currentFieldName + "]").             }         } else if (AbstractQueryBuilder.BOOST_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {             boost = parser.floatValue().         } else if (AbstractQueryBuilder.NAME_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {             queryName = parser.text().         } else {             throw new ParsingException(parser.getTokenLocation(), "[span_within] query does not support [" + currentFieldName + "]").         }     }     if (big == null) {         throw new ParsingException(parser.getTokenLocation(), "span_within must include [big]").     }     if (little == null) {         throw new ParsingException(parser.getTokenLocation(), "span_within must include [little]").     }     SpanWithinQueryBuilder query = new SpanWithinQueryBuilder(big, little).     query.boost(boost).queryName(queryName).     return query. }
false;protected;1;8;;@Override protected Query doToQuery(QueryShardContext context) throws IOException {     Query innerBig = big.toQuery(context).     assert innerBig instanceof SpanQuery.     Query innerLittle = little.toQuery(context).     assert innerLittle instanceof SpanQuery.     return new SpanWithinQuery((SpanQuery) innerBig, (SpanQuery) innerLittle). }
false;protected;0;4;;@Override protected int doHashCode() {     return Objects.hash(big, little). }
false;protected;1;5;;@Override protected boolean doEquals(SpanWithinQueryBuilder other) {     return Objects.equals(big, other.big) && Objects.equals(little, other.little). }
false;public;0;4;;@Override public String getWriteableName() {     return NAME. }
