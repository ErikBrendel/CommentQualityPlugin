commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public boolean isRunning() {     return warningScheduler != null. }
false;public;0;5;;public void start() {     assert warningScheduler == null.     warningScheduler = new WarningScheduler().     warningScheduler.scheduleNextWarning(). }
false;public;0;3;;public void stop() {     warningScheduler = null. }
false;private;0;3;;private boolean isActive() {     return warningScheduler == this. }
false;public;1;4;;@Override public void onFailure(Exception e) {     logger.debug("unexpected exception scheduling cluster formation warning", e). }
false;protected;0;6;;@Override protected void doRun() {     if (isActive()) {         logger.warn(clusterFormationStateSupplier.get().getDescription()).     } }
false;public;0;6;;@Override public void onAfter() {     if (isActive()) {         scheduleNextWarning().     } }
false;public;0;4;;@Override public String toString() {     return "emit warning if cluster not formed". }
false;;0;27;;void scheduleNextWarning() {     threadPool.scheduleUnlessShuttingDown(clusterFormationWarningTimeout, Names.GENERIC, new AbstractRunnable() {          @Override         public void onFailure(Exception e) {             logger.debug("unexpected exception scheduling cluster formation warning", e).         }          @Override         protected void doRun() {             if (isActive()) {                 logger.warn(clusterFormationStateSupplier.get().getDescription()).             }         }          @Override         public void onAfter() {             if (isActive()) {                 scheduleNextWarning().             }         }          @Override         public String toString() {             return "emit warning if cluster not formed".         }     }). }
false;;0;62;;String getDescription() {     final List<String> clusterStateNodes = StreamSupport.stream(clusterState.nodes().spliterator(), false).map(DiscoveryNode::toString).collect(Collectors.toList()).     final String discoveryWillContinueDescription = String.format(Locale.ROOT, "discovery will continue using %s from hosts providers and %s from last-known cluster state. " + "node term %d, last-accepted version %d in term %d", resolvedAddresses, clusterStateNodes, currentTerm, clusterState.version(), clusterState.term()).     final String discoveryStateIgnoringQuorum = String.format(Locale.ROOT, "have discovered %s. %s", foundPeers, discoveryWillContinueDescription).     if (clusterState.nodes().getLocalNode().isMasterNode() == false) {         return String.format(Locale.ROOT, "master not discovered yet: %s", discoveryStateIgnoringQuorum).     }     if (clusterState.getLastAcceptedConfiguration().isEmpty()) {         // TODO handle the case that there is a 6.x node around here, when rolling upgrades are supported         final String bootstrappingDescription.         if (INITIAL_MASTER_NODES_SETTING.get(Settings.EMPTY).equals(INITIAL_MASTER_NODES_SETTING.get(settings))) {             bootstrappingDescription = "[" + INITIAL_MASTER_NODES_SETTING.getKey() + "] is empty on this node".         } else {             // TODO update this when we can bootstrap on only a quorum of the initial nodes             bootstrappingDescription = String.format(Locale.ROOT, "this node must discover master-eligible nodes %s to bootstrap a cluster", INITIAL_MASTER_NODES_SETTING.get(settings)).         }         return String.format(Locale.ROOT, "master not discovered yet, this node has not previously joined a bootstrapped (v%d+) cluster, and %s: %s", Version.V_6_6_0.major + 1, bootstrappingDescription, discoveryStateIgnoringQuorum).     }     assert clusterState.getLastCommittedConfiguration().isEmpty() == false.     if (clusterState.getLastCommittedConfiguration().equals(VotingConfiguration.MUST_JOIN_ELECTED_MASTER)) {         return String.format(Locale.ROOT, "master not discovered yet and this node was detached from its previous cluster, have discovered %s. %s", foundPeers, discoveryWillContinueDescription).     }     final String quorumDescription.     if (clusterState.getLastAcceptedConfiguration().equals(clusterState.getLastCommittedConfiguration())) {         quorumDescription = describeQuorum(clusterState.getLastAcceptedConfiguration()).     } else {         quorumDescription = describeQuorum(clusterState.getLastAcceptedConfiguration()) + " and " + describeQuorum(clusterState.getLastCommittedConfiguration()).     }     final VoteCollection voteCollection = new VoteCollection().     foundPeers.forEach(voteCollection::addVote).     final String isQuorumOrNot = CoordinationState.isElectionQuorum(voteCollection, clusterState) ? "is a quorum" : "is not a quorum".     return String.format(Locale.ROOT, "master not discovered or elected yet, an election requires %s, have discovered %s which %s. %s", quorumDescription, foundPeers, isQuorumOrNot, discoveryWillContinueDescription). }
false;private;1;21;;private String describeQuorum(VotingConfiguration votingConfiguration) {     final Set<String> nodeIds = votingConfiguration.getNodeIds().     assert nodeIds.isEmpty() == false.     final int requiredNodes = nodeIds.size() / 2 + 1.     final Set<String> realNodeIds = new HashSet<>(nodeIds).     realNodeIds.removeIf(ClusterBootstrapService::isBootstrapPlaceholder).     assert requiredNodes <= realNodeIds.size() : nodeIds.     if (nodeIds.size() == 1) {         return "a node with id " + realNodeIds.     } else if (nodeIds.size() == 2) {         return "two nodes with ids " + realNodeIds.     } else {         if (requiredNodes < realNodeIds.size()) {             return "at least " + requiredNodes + " nodes with ids from " + realNodeIds.         } else {             return requiredNodes + " nodes with ids " + realNodeIds.         }     } }
