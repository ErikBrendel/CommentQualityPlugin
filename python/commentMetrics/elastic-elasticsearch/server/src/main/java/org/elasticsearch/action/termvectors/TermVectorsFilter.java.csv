commented;modifiers;parameterAmount;loc;comment;code
false;public;1;23;;public void setSettings(TermVectorsRequest.FilterSettings settings) {     if (settings.maxNumTerms != null) {         setMaxNumTerms(settings.maxNumTerms).     }     if (settings.minTermFreq != null) {         setMinTermFreq(settings.minTermFreq).     }     if (settings.maxTermFreq != null) {         setMaxTermFreq(settings.maxTermFreq).     }     if (settings.minDocFreq != null) {         setMinDocFreq(settings.minDocFreq).     }     if (settings.maxDocFreq != null) {         setMaxDocFreq(settings.maxDocFreq).     }     if (settings.minWordLength != null) {         setMinWordLength(settings.minWordLength).     }     if (settings.maxWordLength != null) {         setMaxWordLength(settings.maxWordLength).     } }
false;public;1;3;;public ScoreTerm getScoreTerm(Term term) {     return scoreTerms.get(term). }
false;public;1;3;;public boolean hasScoreTerm(Term term) {     return getScoreTerm(term) != null. }
false;public;1;3;;public long size(String fieldName) {     return sizes.get(fieldName). }
false;public;0;3;;public int getMaxNumTerms() {     return maxNumTerms. }
false;public;0;3;;public int getMinTermFreq() {     return minTermFreq. }
false;public;0;3;;public int getMaxTermFreq() {     return maxTermFreq. }
false;public;0;3;;public int getMinDocFreq() {     return minDocFreq. }
false;public;0;3;;public int getMaxDocFreq() {     return maxDocFreq. }
false;public;0;3;;public int getMinWordLength() {     return minWordLength. }
false;public;0;3;;public int getMaxWordLength() {     return maxWordLength. }
false;public;1;3;;public void setMaxNumTerms(int maxNumTerms) {     this.maxNumTerms = maxNumTerms. }
false;public;1;3;;public void setMinTermFreq(int minTermFreq) {     this.minTermFreq = minTermFreq. }
false;public;1;3;;public void setMaxTermFreq(int maxTermFreq) {     this.maxTermFreq = maxTermFreq. }
false;public;1;3;;public void setMinDocFreq(int minDocFreq) {     this.minDocFreq = minDocFreq. }
false;public;1;3;;public void setMaxDocFreq(int maxDocFreq) {     this.maxDocFreq = maxDocFreq. }
false;public;1;3;;public void setMinWordLength(int minWordLength) {     this.minWordLength = minWordLength. }
false;public;1;3;;public void setMaxWordLength(int maxWordLength) {     this.maxWordLength = maxWordLength. }
false;;3;5;;void update(String field, String word, float score) {     this.field = field.     this.word = word.     this.score = score. }
false;public;0;58;;public void selectBestTerms() throws IOException {     PostingsEnum docsEnum = null.     for (String fieldName : fields) {         if ((selectedFields != null) && (!selectedFields.contains(fieldName))) {             continue.         }         Terms terms = fields.terms(fieldName).         Terms topLevelTerms = topLevelFields.terms(fieldName).         // if no terms found, take the retrieved term vector fields for stats         if (topLevelTerms == null) {             topLevelTerms = terms.         }         long numDocs = getDocCount(fieldName, topLevelTerms).         // one queue per field name         ScoreTermsQueue queue = new ScoreTermsQueue(Math.min(maxNumTerms, (int) terms.size())).         // select terms with highest tf-idf         TermsEnum termsEnum = terms.iterator().         TermsEnum topLevelTermsEnum = topLevelTerms.iterator().         while (termsEnum.next() != null) {             BytesRef termBytesRef = termsEnum.term().             boolean foundTerm = topLevelTermsEnum.seekExact(termBytesRef).             assert foundTerm : "Term: " + termBytesRef.utf8ToString() + " not found!".             Term term = new Term(fieldName, termBytesRef).             // remove noise words             int freq = getTermFreq(termsEnum, docsEnum).             if (isNoise(term.bytes().utf8ToString(), freq)) {                 continue.             }             // now call on docFreq             long docFreq = getTermStatistics(topLevelTermsEnum, term).docFreq().             if (!isAccepted(docFreq)) {                 continue.             }             // filter based on score             float score = computeScore(docFreq, freq, numDocs).             queue.addOrUpdate(new ScoreTerm(term.field(), term.bytes().utf8ToString(), score)).         }         // retain the best terms for quick lookups         ScoreTerm scoreTerm.         int count = 0.         while ((scoreTerm = queue.pop()) != null) {             scoreTerms.put(new Term(scoreTerm.field, scoreTerm.word), scoreTerm).             count++.         }         sizes.put(fieldName, count).     } }
false;private;2;19;;private boolean isNoise(String word, int freq) {     // filter out words based on length     int len = word.length().     if (minWordLength > 0 && len < minWordLength) {         return true.     }     if (maxWordLength > 0 && len > maxWordLength) {         return true.     }     // filter out words that don't occur enough times in the source     if (minTermFreq > 0 && freq < minTermFreq) {         return true.     }     // filter out words that occur too many times in the source     if (freq > maxTermFreq) {         return true.     }     return false. }
false;private;1;15;;private boolean isAccepted(long docFreq) {     // filter out words that don't occur in enough docs     if (minDocFreq > 0 && docFreq < minDocFreq) {         return false.     }     // filter out words that occur in too many docs     if (docFreq > maxDocFreq) {         return false.     }     // index update problem?     if (docFreq == 0) {         return false.     }     return true. }
false;private;2;6;;private long getDocCount(String fieldName, Terms topLevelTerms) throws IOException {     if (dfs != null) {         return dfs.fieldStatistics().get(fieldName).docCount().     }     return topLevelTerms.getDocCount(). }
false;private;2;6;;private TermStatistics getTermStatistics(TermsEnum termsEnum, Term term) throws IOException {     if (dfs != null) {         return dfs.termStatistics().get(term).     }     return new TermStatistics(termsEnum.term(), termsEnum.docFreq(), termsEnum.totalTermFreq()). }
false;private;2;5;;private int getTermFreq(TermsEnum termsEnum, PostingsEnum docsEnum) throws IOException {     docsEnum = termsEnum.postings(docsEnum).     docsEnum.nextDoc().     return docsEnum.freq(). }
false;private;3;3;;private float computeScore(long docFreq, int freq, long numDocs) {     return freq * similarity.idf(docFreq, numDocs). }
false;protected;2;4;;@Override protected boolean lessThan(ScoreTerm a, ScoreTerm b) {     return a.score < b.score. }
false;public;1;13;;public void addOrUpdate(ScoreTerm scoreTerm) {     if (this.size() < limit) {         // there is still space in the queue         this.add(scoreTerm).     } else {         // otherwise update the smallest in the queue in place and update the queue         ScoreTerm scoreTermTop = this.top().         if (scoreTermTop.score < scoreTerm.score) {             scoreTermTop.update(scoreTerm.field, scoreTerm.word, scoreTerm.score).             this.updateTop().         }     } }
