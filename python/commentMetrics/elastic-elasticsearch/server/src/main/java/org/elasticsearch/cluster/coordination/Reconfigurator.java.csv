commented;modifiers;parameterAmount;loc;comment;code
false;public;1;3;;public void setAutoShrinkVotingConfiguration(boolean autoShrinkVotingConfiguration) {     this.autoShrinkVotingConfiguration = autoShrinkVotingConfiguration. }
false;private,static;1;3;;private static int roundDownToOdd(int size) {     return size - (size % 2 == 0 ? 1 : 0). }
false;public;0;6;;@Override public String toString() {     return "Reconfigurator{" + "autoShrinkVotingConfiguration=" + autoShrinkVotingConfiguration + '}'. }
true;public;4;84;/**  * Compute an optimal configuration for the cluster.  *  * @param liveNodes      The live nodes in the cluster. The optimal configuration prefers live nodes over non-live nodes as far as  *                       possible.  * @param retiredNodeIds Nodes that are leaving the cluster and which should not appear in the configuration if possible. Nodes that are  *                       retired and not in the current configuration will never appear in the resulting configuration. this is useful  *                       for shifting the vote in a 2-node cluster so one of the nodes can be restarted without harming availability.  * @param currentMaster  The current master. Unless retired, we prefer to keep the current master in the config.  * @param currentConfig  The current configuration. As far as possible, we prefer to keep the current config as-is.  * @return An optimal configuration, or leave the current configuration unchanged if the optimal configuration has no live quorum.  */ ;/**  * Compute an optimal configuration for the cluster.  *  * @param liveNodes      The live nodes in the cluster. The optimal configuration prefers live nodes over non-live nodes as far as  *                       possible.  * @param retiredNodeIds Nodes that are leaving the cluster and which should not appear in the configuration if possible. Nodes that are  *                       retired and not in the current configuration will never appear in the resulting configuration. this is useful  *                       for shifting the vote in a 2-node cluster so one of the nodes can be restarted without harming availability.  * @param currentMaster  The current master. Unless retired, we prefer to keep the current master in the config.  * @param currentConfig  The current configuration. As far as possible, we prefer to keep the current config as-is.  * @return An optimal configuration, or leave the current configuration unchanged if the optimal configuration has no live quorum.  */ public VotingConfiguration reconfigure(Set<DiscoveryNode> liveNodes, Set<String> retiredNodeIds, DiscoveryNode currentMaster, VotingConfiguration currentConfig) {     assert liveNodes.stream().noneMatch(Coordinator::isZen1Node) : liveNodes.     assert liveNodes.contains(currentMaster) : "liveNodes = " + liveNodes + " master = " + currentMaster.     logger.trace("{} reconfiguring {} based on liveNodes={}, retiredNodeIds={}, currentMaster={}", this, currentConfig, liveNodes, retiredNodeIds, currentMaster).     /*          *  There are three true/false properties of each node in play: live/non-live, retired/non-retired and in-config/not-in-config.          *  Firstly we divide the nodes into disjoint sets based on these properties:          *          *  - nonRetiredMaster          *  - nonRetiredNotMasterInConfigNotLiveIds          *  - nonRetiredInConfigLiveIds          *  - nonRetiredLiveNotInConfigIds          *          *  The other 5 possibilities are not relevant:          *  - retired, in-config, live             -- retired nodes should be removed from the config          *  - retired, in-config, non-live         -- retired nodes should be removed from the config          *  - retired, not-in-config, live         -- cannot add a retired node back to the config          *  - retired, not-in-config, non-live     -- cannot add a retired node back to the config          *  - non-retired, non-live, not-in-config -- no evidence this node exists at all          */     final Set<String> liveNodeIds = liveNodes.stream().filter(DiscoveryNode::isMasterNode).map(DiscoveryNode::getId).collect(Collectors.toSet()).     final Set<String> liveInConfigIds = new TreeSet<>(currentConfig.getNodeIds()).     liveInConfigIds.retainAll(liveNodeIds).     final Set<String> inConfigNotLiveIds = Sets.sortedDifference(currentConfig.getNodeIds(), liveInConfigIds).     final Set<String> nonRetiredInConfigNotLiveIds = new TreeSet<>(inConfigNotLiveIds).     nonRetiredInConfigNotLiveIds.removeAll(retiredNodeIds).     final Set<String> nonRetiredInConfigLiveIds = new TreeSet<>(liveInConfigIds).     nonRetiredInConfigLiveIds.removeAll(retiredNodeIds).     final Set<String> nonRetiredInConfigLiveMasterIds.     final Set<String> nonRetiredInConfigLiveNotMasterIds.     if (nonRetiredInConfigLiveIds.contains(currentMaster.getId())) {         nonRetiredInConfigLiveNotMasterIds = new TreeSet<>(nonRetiredInConfigLiveIds).         nonRetiredInConfigLiveNotMasterIds.remove(currentMaster.getId()).         nonRetiredInConfigLiveMasterIds = Collections.singleton(currentMaster.getId()).     } else {         nonRetiredInConfigLiveNotMasterIds = nonRetiredInConfigLiveIds.         nonRetiredInConfigLiveMasterIds = Collections.emptySet().     }     final Set<String> nonRetiredLiveNotInConfigIds = Sets.sortedDifference(liveNodeIds, currentConfig.getNodeIds()).     nonRetiredLiveNotInConfigIds.removeAll(retiredNodeIds).     /*          * Now we work out how many nodes should be in the configuration:          */     final int targetSize.     final int nonRetiredLiveNodeCount = nonRetiredInConfigLiveIds.size() + nonRetiredLiveNotInConfigIds.size().     final int nonRetiredConfigSize = nonRetiredInConfigLiveIds.size() + nonRetiredInConfigNotLiveIds.size().     if (autoShrinkVotingConfiguration) {         if (nonRetiredLiveNodeCount >= 3) {             targetSize = roundDownToOdd(nonRetiredLiveNodeCount).         } else {             // only have one or two available nodes. may not shrink below 3 nodes automatically, but if             // the config (excluding retired nodes) is already smaller than 3 then it's ok.             targetSize = nonRetiredConfigSize < 3 ? 1 : 3.         }     } else {         targetSize = Math.max(roundDownToOdd(nonRetiredLiveNodeCount), nonRetiredConfigSize).     }     /*          * The new configuration is formed by taking this many nodes in the following preference order:          */     final VotingConfiguration newConfig = new VotingConfiguration(// live master first, then other live nodes, preferring the current config, and if we need more then use non-live nodes     Stream.of(nonRetiredInConfigLiveMasterIds, nonRetiredInConfigLiveNotMasterIds, nonRetiredLiveNotInConfigIds, nonRetiredInConfigNotLiveIds).flatMap(Collection::stream).limit(targetSize).collect(Collectors.toSet())).     if (newConfig.hasQuorum(liveNodeIds)) {         return newConfig.     } else {         // If there are not enough live nodes to form a quorum in the newly-proposed configuration, it's better to do nothing.         return currentConfig.     } }
