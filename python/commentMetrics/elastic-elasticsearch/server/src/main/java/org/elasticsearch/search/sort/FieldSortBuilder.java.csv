commented;modifiers;parameterAmount;loc;comment;code
false;public;1;13;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeString(fieldName).     out.writeOptionalNamedWriteable(nestedFilter).     out.writeOptionalString(nestedPath).     out.writeGenericValue(missing).     out.writeOptionalWriteable(order).     out.writeOptionalWriteable(sortMode).     out.writeOptionalString(unmappedType).     if (out.getVersion().onOrAfter(Version.V_6_1_0)) {         out.writeOptionalWriteable(nestedSort).     } }
true;public;0;3;/**  * Returns the document field this sort should be based on.  */ ;/**  * Returns the document field this sort should be based on.  */ public String getFieldName() {     return this.fieldName. }
true;public;1;4;/**  * Sets the value when a field is missing in a doc. Can also be set to {@code _last} or  * {@code _first} to sort missing last or first respectively.  */ ;/**  * Sets the value when a field is missing in a doc. Can also be set to {@code _last} or  * {@code _first} to sort missing last or first respectively.  */ public FieldSortBuilder missing(Object missing) {     this.missing = missing.     return this. }
true;public;0;3;/**  * Returns the value used when a field is missing in a doc.  */ ;/**  * Returns the value used when a field is missing in a doc.  */ public Object missing() {     return missing. }
true;public;1;4;/**  * Set the type to use in case the current field is not mapped in an index.  * Specifying a type tells Elasticsearch what type the sort values should  * have, which is important for cross-index search, if there are sort fields  * that exist on some indices only. If the unmapped type is {@code null}  * then query execution will fail if one or more indices don't have a  * mapping for the current field.  */ ;/**  * Set the type to use in case the current field is not mapped in an index.  * Specifying a type tells Elasticsearch what type the sort values should  * have, which is important for cross-index search, if there are sort fields  * that exist on some indices only. If the unmapped type is {@code null}  * then query execution will fail if one or more indices don't have a  * mapping for the current field.  */ public FieldSortBuilder unmappedType(String type) {     this.unmappedType = type.     return this. }
true;public;0;3;/**  * Returns the type to use in case the current field is not mapped in an  * index.  */ ;/**  * Returns the type to use in case the current field is not mapped in an  * index.  */ public String unmappedType() {     return this.unmappedType. }
true;public;1;5;/**  * Defines what values to pick in the case a document contains multiple  * values for the targeted sort field. Possible values: min, max, sum and  * avg  *  * <p>  * The last two values are only applicable for number based fields.  */ ;/**  * Defines what values to pick in the case a document contains multiple  * values for the targeted sort field. Possible values: min, max, sum and  * avg  *  * <p>  * The last two values are only applicable for number based fields.  */ public FieldSortBuilder sortMode(SortMode sortMode) {     Objects.requireNonNull(sortMode, "sort mode cannot be null").     this.sortMode = sortMode.     return this. }
true;public;0;3;/**  * Returns what values to pick in the case a document contains multiple  * values for the targeted sort field.  */ ;/**  * Returns what values to pick in the case a document contains multiple  * values for the targeted sort field.  */ public SortMode sortMode() {     return this.sortMode. }
true;public;1;8;/**  * Sets the nested filter that the nested objects should match with in order  * to be taken into account for sorting.  *  * @deprecated set nested sort with {@link #setNestedSort(NestedSortBuilder)} and retrieve with {@link #getNestedSort()}  */ ;/**  * Sets the nested filter that the nested objects should match with in order  * to be taken into account for sorting.  *  * @deprecated set nested sort with {@link #setNestedSort(NestedSortBuilder)} and retrieve with {@link #getNestedSort()}  */ @Deprecated public FieldSortBuilder setNestedFilter(QueryBuilder nestedFilter) {     if (this.nestedSort != null) {         throw new IllegalArgumentException("Setting both nested_path/nested_filter and nested not allowed").     }     this.nestedFilter = nestedFilter.     return this. }
true;public;0;4;/**  * Returns the nested filter that the nested objects should match with in  * order to be taken into account for sorting.  *  * @deprecated set nested sort with {@link #setNestedSort(NestedSortBuilder)} and retrieve with {@link #getNestedSort()}  */ ;/**  * Returns the nested filter that the nested objects should match with in  * order to be taken into account for sorting.  *  * @deprecated set nested sort with {@link #setNestedSort(NestedSortBuilder)} and retrieve with {@link #getNestedSort()}  */ @Deprecated public QueryBuilder getNestedFilter() {     return this.nestedFilter. }
true;public;1;8;/**  * Sets the nested path if sorting occurs on a field that is inside a nested  * object. By default when sorting on a field inside a nested object, the  * nearest upper nested object is selected as nested path.  *  * @deprecated set nested sort with {@link #setNestedSort(NestedSortBuilder)} and retrieve with {@link #getNestedSort()}  */ ;/**  * Sets the nested path if sorting occurs on a field that is inside a nested  * object. By default when sorting on a field inside a nested object, the  * nearest upper nested object is selected as nested path.  *  * @deprecated set nested sort with {@link #setNestedSort(NestedSortBuilder)} and retrieve with {@link #getNestedSort()}  */ @Deprecated public FieldSortBuilder setNestedPath(String nestedPath) {     if (this.nestedSort != null) {         throw new IllegalArgumentException("Setting both nested_path/nested_filter and nested not allowed").     }     this.nestedPath = nestedPath.     return this. }
true;public;0;4;/**  * Returns the nested path if sorting occurs in a field that is inside a  * nested object.  * @deprecated set nested sort with {@link #setNestedSort(NestedSortBuilder)} and retrieve with {@link #getNestedSort()}  */ ;/**  * Returns the nested path if sorting occurs in a field that is inside a  * nested object.  * @deprecated set nested sort with {@link #setNestedSort(NestedSortBuilder)} and retrieve with {@link #getNestedSort()}  */ @Deprecated public String getNestedPath() {     return this.nestedPath. }
true;public;0;3;/**  * Returns the {@link NestedSortBuilder}  */ ;/**  * Returns the {@link NestedSortBuilder}  */ public NestedSortBuilder getNestedSort() {     return this.nestedSort. }
true;public;1;7;/**  * Sets the {@link NestedSortBuilder} to be used for fields that are inside a nested  * object. The {@link NestedSortBuilder} takes a `path` argument and an optional  * nested filter that the nested objects should match with in  * order to be taken into account for sorting.  */ ;/**  * Sets the {@link NestedSortBuilder} to be used for fields that are inside a nested  * object. The {@link NestedSortBuilder} takes a `path` argument and an optional  * nested filter that the nested objects should match with in  * order to be taken into account for sorting.  */ public FieldSortBuilder setNestedSort(final NestedSortBuilder nestedSort) {     if (this.nestedFilter != null || this.nestedPath != null) {         throw new IllegalArgumentException("Setting both nested_path/nested_filter and nested not allowed").     }     this.nestedSort = nestedSort.     return this. }
false;public;2;27;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     builder.startObject(fieldName).     builder.field(ORDER_FIELD.getPreferredName(), order).     if (missing != null) {         builder.field(MISSING.getPreferredName(), missing).     }     if (unmappedType != null) {         builder.field(UNMAPPED_TYPE.getPreferredName(), unmappedType).     }     if (sortMode != null) {         builder.field(SORT_MODE.getPreferredName(), sortMode).     }     if (nestedFilter != null) {         builder.field(NESTED_FILTER_FIELD.getPreferredName(), nestedFilter, params).     }     if (nestedPath != null) {         builder.field(NESTED_PATH_FIELD.getPreferredName(), nestedPath).     }     if (nestedSort != null) {         builder.field(NESTED_FIELD.getPreferredName(), nestedSort).     }     builder.endObject().     builder.endObject().     return builder. }
false;public;1;53;;@Override public SortFieldAndFormat build(QueryShardContext context) throws IOException {     if (DOC_FIELD_NAME.equals(fieldName)) {         if (order == SortOrder.DESC) {             return SORT_DOC_REVERSE.         } else {             return SORT_DOC.         }     } else {         MappedFieldType fieldType = context.fieldMapper(fieldName).         if (fieldType == null) {             if (unmappedType != null) {                 fieldType = context.getMapperService().unmappedFieldType(unmappedType).             } else {                 throw new QueryShardException(context, "No mapping found for [" + fieldName + "] in order to sort on").             }         }         MultiValueMode localSortMode = null.         if (sortMode != null) {             localSortMode = MultiValueMode.fromString(sortMode.toString()).         }         boolean reverse = (order == SortOrder.DESC).         if (localSortMode == null) {             localSortMode = reverse ? MultiValueMode.MAX : MultiValueMode.MIN.         }         final Nested nested.         if (nestedSort != null) {             if (context.indexVersionCreated().before(Version.V_6_5_0) && nestedSort.getMaxChildren() != Integer.MAX_VALUE) {                 throw new QueryShardException(context, "max_children is only supported on v6.5.0 or higher").             }             if (nestedSort.getNestedSort() != null && nestedSort.getMaxChildren() != Integer.MAX_VALUE) {                 throw new QueryShardException(context, "max_children is only supported on last level of nested sort").             }             // new nested sorts takes priority             nested = resolveNested(context, nestedSort).         } else {             nested = resolveNested(context, nestedPath, nestedFilter).         }         IndexFieldData<?> fieldData = context.getForField(fieldType).         if (fieldData instanceof IndexNumericFieldData == false && (sortMode == SortMode.SUM || sortMode == SortMode.AVG || sortMode == SortMode.MEDIAN)) {             throw new QueryShardException(context, "we only support AVG, MEDIAN and SUM on number based fields").         }         SortField field = fieldData.sortField(missing, localSortMode, nested, reverse).         return new SortFieldAndFormat(field, fieldType.docValueFormat(null, null)).     } }
false;public;1;16;;@Override public boolean equals(Object other) {     if (this == other) {         return true.     }     if (other == null || getClass() != other.getClass()) {         return false.     }     FieldSortBuilder builder = (FieldSortBuilder) other.     return (Objects.equals(this.fieldName, builder.fieldName) && Objects.equals(this.nestedFilter, builder.nestedFilter) && Objects.equals(this.nestedPath, builder.nestedPath) && Objects.equals(this.missing, builder.missing) && Objects.equals(this.order, builder.order) && Objects.equals(this.sortMode, builder.sortMode) && Objects.equals(this.unmappedType, builder.unmappedType) && Objects.equals(this.nestedSort, builder.nestedSort)). }
false;public;0;5;;@Override public int hashCode() {     return Objects.hash(this.fieldName, this.nestedFilter, this.nestedPath, this.nestedSort, this.missing, this.order, this.sortMode, this.unmappedType). }
false;public;0;4;;@Override public String getWriteableName() {     return NAME. }
true;public,static;2;3;/**  * Creates a new {@link FieldSortBuilder} from the query held by the {@link XContentParser} in  * {@link org.elasticsearch.common.xcontent.XContent} format.  *  * @param parser the input parser. The state on the parser contained in this context will be changed as a side effect of this  *        method call  * @param fieldName in some sort syntax variations the field name precedes the xContent object that specifies further parameters, e.g.  *        in '{ "foo": { "order" : "asc"} }'. When parsing the inner object, the field name can be passed in via this argument  */ ;/**  * Creates a new {@link FieldSortBuilder} from the query held by the {@link XContentParser} in  * {@link org.elasticsearch.common.xcontent.XContent} format.  *  * @param parser the input parser. The state on the parser contained in this context will be changed as a side effect of this  *        method call  * @param fieldName in some sort syntax variations the field name precedes the xContent object that specifies further parameters, e.g.  *        in '{ "foo": { "order" : "asc"} }'. When parsing the inner object, the field name can be passed in via this argument  */ public static FieldSortBuilder fromXContent(XContentParser parser, String fieldName) throws IOException {     return PARSER.parse(parser, new FieldSortBuilder(fieldName), null). }
false;public;1;19;;@Override public FieldSortBuilder rewrite(QueryRewriteContext ctx) throws IOException {     if (nestedFilter == null && nestedSort == null) {         return this.     }     if (nestedFilter != null) {         QueryBuilder rewrite = nestedFilter.rewrite(ctx).         if (nestedFilter == rewrite) {             return this.         }         return new FieldSortBuilder(this).setNestedFilter(rewrite).     } else {         NestedSortBuilder rewrite = nestedSort.rewrite(ctx).         if (nestedSort == rewrite) {             return this.         }         return new FieldSortBuilder(this).setNestedSort(rewrite).     } }
