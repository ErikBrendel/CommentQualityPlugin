commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;5;;@Override protected void doWriteTo(StreamOutput out) throws IOException {     writeQueries(out, queries).     out.writeFloat(tieBreaker). }
true;public;1;7;/**  * Add a sub-query to this disjunction.  */ ;/**  * Add a sub-query to this disjunction.  */ public DisMaxQueryBuilder add(QueryBuilder queryBuilder) {     if (queryBuilder == null) {         throw new IllegalArgumentException("inner dismax query clause cannot be null").     }     queries.add(queryBuilder).     return this. }
true;public;0;3;/**  * @return an immutable list copy of the current sub-queries of this disjunction  */ ;/**  * @return an immutable list copy of the current sub-queries of this disjunction  */ public List<QueryBuilder> innerQueries() {     return this.queries. }
true;public;1;4;/**  * The score of each non-maximum disjunct for a document is multiplied by this weight  * and added into the final score.  If non-zero, the value should be small, on the order of 0.1, which says that  * 10 occurrences of word in a lower-scored field that is also in a higher scored field is just as good as a unique  * word in the lower scored field (i.e., one that is not in any higher scored field.  */ ;/**  * The score of each non-maximum disjunct for a document is multiplied by this weight  * and added into the final score.  If non-zero, the value should be small, on the order of 0.1, which says that  * 10 occurrences of word in a lower-scored field that is also in a higher scored field is just as good as a unique  * word in the lower scored field (i.e., one that is not in any higher scored field.  */ public DisMaxQueryBuilder tieBreaker(float tieBreaker) {     this.tieBreaker = tieBreaker.     return this. }
true;public;0;3;/**  * @return the tie breaker score  * @see DisMaxQueryBuilder#tieBreaker(float)  */ ;/**  * @return the tie breaker score  * @see DisMaxQueryBuilder#tieBreaker(float)  */ public float tieBreaker() {     return this.tieBreaker. }
false;protected;2;12;;@Override protected void doXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject(NAME).     builder.field(TIE_BREAKER_FIELD.getPreferredName(), tieBreaker).     builder.startArray(QUERIES_FIELD.getPreferredName()).     for (QueryBuilder queryBuilder : queries) {         queryBuilder.toXContent(builder, params).     }     builder.endArray().     printBoostAndQueryName(builder).     builder.endObject(). }
false;public,static;1;56;;public static DisMaxQueryBuilder fromXContent(XContentParser parser) throws IOException {     float boost = AbstractQueryBuilder.DEFAULT_BOOST.     float tieBreaker = DisMaxQueryBuilder.DEFAULT_TIE_BREAKER.     final List<QueryBuilder> queries = new ArrayList<>().     boolean queriesFound = false.     String queryName = null.     String currentFieldName = null.     XContentParser.Token token.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (token == XContentParser.Token.START_OBJECT) {             if (QUERIES_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 queriesFound = true.                 queries.add(parseInnerQueryBuilder(parser)).             } else {                 throw new ParsingException(parser.getTokenLocation(), "[dis_max] query does not support [" + currentFieldName + "]").             }         } else if (token == XContentParser.Token.START_ARRAY) {             if (QUERIES_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 queriesFound = true.                 while (token != XContentParser.Token.END_ARRAY) {                     queries.add(parseInnerQueryBuilder(parser)).                     token = parser.nextToken().                 }             } else {                 throw new ParsingException(parser.getTokenLocation(), "[dis_max] query does not support [" + currentFieldName + "]").             }         } else {             if (AbstractQueryBuilder.BOOST_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 boost = parser.floatValue().             } else if (TIE_BREAKER_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 tieBreaker = parser.floatValue().             } else if (AbstractQueryBuilder.NAME_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 queryName = parser.text().             } else {                 throw new ParsingException(parser.getTokenLocation(), "[dis_max] query does not support [" + currentFieldName + "]").             }         }     }     if (!queriesFound) {         throw new ParsingException(parser.getTokenLocation(), "[dis_max] requires 'queries' field with at least one clause").     }     DisMaxQueryBuilder disMaxQuery = new DisMaxQueryBuilder().     disMaxQuery.tieBreaker(tieBreaker).     disMaxQuery.queryName(queryName).     disMaxQuery.boost(boost).     for (QueryBuilder query : queries) {         disMaxQuery.add(query).     }     return disMaxQuery. }
false;protected;1;10;;@Override protected Query doToQuery(QueryShardContext context) throws IOException {     // return null if there are no queries at all     Collection<Query> luceneQueries = toQueries(queries, context).     if (luceneQueries.isEmpty()) {         return Queries.newMatchNoDocsQuery("no clauses for dismax query.").     }     return new DisjunctionMaxQuery(luceneQueries, tieBreaker). }
false;protected;0;4;;@Override protected int doHashCode() {     return Objects.hash(queries, tieBreaker). }
false;protected;1;5;;@Override protected boolean doEquals(DisMaxQueryBuilder other) {     return Objects.equals(queries, other.queries) && Objects.equals(tieBreaker, other.tieBreaker). }
false;public;0;4;;@Override public String getWriteableName() {     return NAME. }
false;protected;1;6;;@Override protected void extractInnerHitBuilders(Map<String, InnerHitContextBuilder> innerHits) {     for (QueryBuilder query : queries) {         InnerHitContextBuilder.extractInnerHits(query, innerHits).     } }
