commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected String executor() {     return ThreadPool.Names.WRITE. }
false;protected;0;4;;@Override protected UpdateResponse newResponse() {     return new UpdateResponse(). }
false;protected;1;4;;@Override protected boolean retryOnFailure(Exception e) {     return TransportActions.isShardNotAvailableException(e). }
false;protected;2;4;;@Override protected void resolveRequest(ClusterState state, UpdateRequest request) {     resolveAndValidateRouting(state.metaData(), request.concreteIndex(), request). }
false;public,static;3;7;;public static void resolveAndValidateRouting(MetaData metaData, String concreteIndex, UpdateRequest request) {     request.routing((metaData.resolveWriteIndexRouting(request.routing(), request.index()))).     // Fail fast on the node that received the request, rather than failing when translating on the index or delete request.     if (request.routing() == null && metaData.routingRequired(concreteIndex)) {         throw new RoutingMissingException(concreteIndex, request.type(), request.id()).     } }
false;public;1;4;;@Override public void onResponse(CreateIndexResponse result) {     innerExecute(task, request, listener). }
false;public;1;14;;@Override public void onFailure(Exception e) {     if (unwrapCause(e) instanceof ResourceAlreadyExistsException) {         // we have the index, do it         try {             innerExecute(task, request, listener).         } catch (Exception inner) {             inner.addSuppressed(e).             listener.onFailure(inner).         }     } else {         listener.onFailure(e).     } }
false;protected;3;30;;@Override protected void doExecute(Task task, final UpdateRequest request, final ActionListener<UpdateResponse> listener) {     // if we don't have a master, we don't have metadata, that's fine, let it find a master using create index API     if (autoCreateIndex.shouldAutoCreate(request.index(), clusterService.state())) {         client.admin().indices().create(new CreateIndexRequest().index(request.index()).cause("auto(update api)").masterNodeTimeout(request.timeout()), new ActionListener<CreateIndexResponse>() {              @Override             public void onResponse(CreateIndexResponse result) {                 innerExecute(task, request, listener).             }              @Override             public void onFailure(Exception e) {                 if (unwrapCause(e) instanceof ResourceAlreadyExistsException) {                     // we have the index, do it                     try {                         innerExecute(task, request, listener).                     } catch (Exception inner) {                         inner.addSuppressed(e).                         listener.onFailure(inner).                     }                 } else {                     listener.onFailure(e).                 }             }         }).     } else {         innerExecute(task, request, listener).     } }
false;private;3;3;;private void innerExecute(final Task task, final UpdateRequest request, final ActionListener<UpdateResponse> listener) {     super.doExecute(task, request, listener). }
false;protected;2;15;;@Override protected ShardIterator shards(ClusterState clusterState, UpdateRequest request) {     if (request.getShardId() != null) {         return clusterState.routingTable().index(request.concreteIndex()).shard(request.getShardId().getId()).primaryShardIt().     }     ShardIterator shardIterator = clusterService.operationRouting().indexShards(clusterState, request.concreteIndex(), request.id(), request.routing()).     ShardRouting shard.     while ((shard = shardIterator.nextOrNull()) != null) {         if (shard.primary()) {             return new PlainShardIterator(shardIterator.shardId(), Collections.singletonList(shard)).         }     }     return new PlainShardIterator(shardIterator.shardId(), Collections.emptyList()). }
false;protected;2;4;;@Override protected void shardOperation(final UpdateRequest request, final ActionListener<UpdateResponse> listener) {     shardOperation(request, listener, 0). }
false;protected;3;77;;protected void shardOperation(final UpdateRequest request, final ActionListener<UpdateResponse> listener, final int retryCount) {     final ShardId shardId = request.getShardId().     final IndexService indexService = indicesService.indexServiceSafe(shardId.getIndex()).     final IndexShard indexShard = indexService.getShard(shardId.getId()).     final UpdateHelper.Result result = updateHelper.prepare(request, indexShard, threadPool::absoluteTimeInMillis).     switch(result.getResponseResult()) {         case CREATED:             IndexRequest upsertRequest = result.action().             // we fetch it from the index request so we don't generate the bytes twice, its already done in the index request             final BytesReference upsertSourceBytes = upsertRequest.source().             client.bulk(toSingleItemBulkRequest(upsertRequest), wrapBulkResponse(ActionListener.<IndexResponse>wrap(response -> {                 UpdateResponse update = new UpdateResponse(response.getShardInfo(), response.getShardId(), response.getType(), response.getId(), response.getSeqNo(), response.getPrimaryTerm(), response.getVersion(), response.getResult()).                 if (request.fetchSource() != null && request.fetchSource().fetchSource()) {                     Tuple<XContentType, Map<String, Object>> sourceAndContent = XContentHelper.convertToMap(upsertSourceBytes, true, upsertRequest.getContentType()).                     update.setGetResult(UpdateHelper.extractGetResult(request, request.concreteIndex(), response.getSeqNo(), response.getPrimaryTerm(), response.getVersion(), sourceAndContent.v2(), sourceAndContent.v1(), upsertSourceBytes)).                 } else {                     update.setGetResult(null).                 }                 update.setForcedRefresh(response.forcedRefresh()).                 listener.onResponse(update).             }, exception -> handleUpdateFailureWithRetry(listener, request, exception, retryCount)))).             break.         case UPDATED:             IndexRequest indexRequest = result.action().             // we fetch it from the index request so we don't generate the bytes twice, its already done in the index request             final BytesReference indexSourceBytes = indexRequest.source().             client.bulk(toSingleItemBulkRequest(indexRequest), wrapBulkResponse(ActionListener.<IndexResponse>wrap(response -> {                 UpdateResponse update = new UpdateResponse(response.getShardInfo(), response.getShardId(), response.getType(), response.getId(), response.getSeqNo(), response.getPrimaryTerm(), response.getVersion(), response.getResult()).                 update.setGetResult(UpdateHelper.extractGetResult(request, request.concreteIndex(), response.getSeqNo(), response.getPrimaryTerm(), response.getVersion(), result.updatedSourceAsMap(), result.updateSourceContentType(), indexSourceBytes)).                 update.setForcedRefresh(response.forcedRefresh()).                 listener.onResponse(update).             }, exception -> handleUpdateFailureWithRetry(listener, request, exception, retryCount)))).             break.         case DELETED:             DeleteRequest deleteRequest = result.action().             client.bulk(toSingleItemBulkRequest(deleteRequest), wrapBulkResponse(ActionListener.<DeleteResponse>wrap(response -> {                 UpdateResponse update = new UpdateResponse(response.getShardInfo(), response.getShardId(), response.getType(), response.getId(), response.getSeqNo(), response.getPrimaryTerm(), response.getVersion(), response.getResult()).                 update.setGetResult(UpdateHelper.extractGetResult(request, request.concreteIndex(), response.getSeqNo(), response.getPrimaryTerm(), response.getVersion(), result.updatedSourceAsMap(), result.updateSourceContentType(), null)).                 update.setForcedRefresh(response.forcedRefresh()).                 listener.onResponse(update).             }, exception -> handleUpdateFailureWithRetry(listener, request, exception, retryCount)))).             break.         case NOOP:             UpdateResponse update = result.action().             IndexService indexServiceOrNull = indicesService.indexService(shardId.getIndex()).             if (indexServiceOrNull != null) {                 IndexShard shard = indexService.getShardOrNull(shardId.getId()).                 if (shard != null) {                     shard.noopUpdate(request.type()).                 }             }             listener.onResponse(update).             break.         default:             throw new IllegalStateException("Illegal result " + result.getResponseResult()).     } }
false;protected;0;4;;@Override protected void doRun() {     shardOperation(request, listener, retryCount + 1). }
false;private;4;18;;private void handleUpdateFailureWithRetry(final ActionListener<UpdateResponse> listener, final UpdateRequest request, final Exception failure, int retryCount) {     final Throwable cause = unwrapCause(failure).     if (cause instanceof VersionConflictEngineException) {         if (retryCount < request.retryOnConflict()) {             logger.trace("Retry attempt [{}] of [{}] on version conflict on [{}][{}][{}]", retryCount + 1, request.retryOnConflict(), request.index(), request.getShardId(), request.id()).             threadPool.executor(executor()).execute(new ActionRunnable<UpdateResponse>(listener) {                  @Override                 protected void doRun() {                     shardOperation(request, listener, retryCount + 1).                 }             }).             return.         }     }     listener.onFailure(cause instanceof Exception ? (Exception) cause : new NotSerializableExceptionWrapper(cause)). }
