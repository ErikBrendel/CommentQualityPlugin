commented;modifiers;parameterAmount;loc;comment;code
false;public;1;5;;@Override public void onResponse(Response response) {     taskManager.unregister(task).     listener.onResponse(response). }
false;public;1;5;;@Override public void onFailure(Exception e) {     taskManager.unregister(task).     listener.onFailure(e). }
true;public,final;2;24;/**  * Use this method when the transport action call should result in creation of a new task associated with the call.  *  * This is a typical behavior.  */ ;/**  * Use this method when the transport action call should result in creation of a new task associated with the call.  *  * This is a typical behavior.  */ public final Task execute(Request request, ActionListener<Response> listener) {     /*          * While this version of execute could delegate to the TaskListener          * version of execute that'd add yet another layer of wrapping on the          * listener and prevent us from using the listener bare if there isn't a          * task. That just seems like too many objects. Thus the two versions of          * this method.          */     Task task = taskManager.register("transport", actionName, request).     execute(task, request, new ActionListener<Response>() {          @Override         public void onResponse(Response response) {             taskManager.unregister(task).             listener.onResponse(response).         }          @Override         public void onFailure(Exception e) {             taskManager.unregister(task).             listener.onFailure(e).         }     }).     return task. }
false;public;1;7;;@Override public void onResponse(Response response) {     if (task != null) {         taskManager.unregister(task).     }     listener.onResponse(task, response). }
false;public;1;7;;@Override public void onFailure(Exception e) {     if (task != null) {         taskManager.unregister(task).     }     listener.onFailure(task, e). }
true;public,final;2;21;/**  * Execute the transport action on the local node, returning the {@link Task} used to track its execution and accepting a  * {@link TaskListener} which listens for the completion of the action.  */ ;/**  * Execute the transport action on the local node, returning the {@link Task} used to track its execution and accepting a  * {@link TaskListener} which listens for the completion of the action.  */ public final Task execute(Request request, TaskListener<Response> listener) {     Task task = taskManager.register("transport", actionName, request).     execute(task, request, new ActionListener<Response>() {          @Override         public void onResponse(Response response) {             if (task != null) {                 taskManager.unregister(task).             }             listener.onResponse(task, response).         }          @Override         public void onFailure(Exception e) {             if (task != null) {                 taskManager.unregister(task).             }             listener.onFailure(task, e).         }     }).     return task. }
true;public,final;3;14;/**  * Use this method when the transport action should continue to run in the context of the current task  */ ;/**  * Use this method when the transport action should continue to run in the context of the current task  */ public final void execute(Task task, Request request, ActionListener<Response> listener) {     ActionRequestValidationException validationException = request.validate().     if (validationException != null) {         listener.onFailure(validationException).         return.     }     if (task != null && request.getShouldStoreResult()) {         listener = new TaskResultStoringActionListener<>(taskManager, task, listener).     }     RequestFilterChain<Request, Response> requestFilterChain = new RequestFilterChain<>(this, logger).     requestFilterChain.proceed(task, actionName, request, listener). }
false;protected,abstract;3;1;;protected abstract void doExecute(Task task, Request request, ActionListener<Response> listener).
false;public;4;16;;@Override public void proceed(Task task, String actionName, Request request, ActionListener<Response> listener) {     int i = index.getAndIncrement().     try {         if (i < this.action.filters.length) {             this.action.filters[i].apply(task, actionName, request, listener, this).         } else if (i == this.action.filters.length) {             this.action.doExecute(task, request, listener).         } else {             listener.onFailure(new IllegalStateException("proceed was called too many times")).         }     } catch (Exception e) {         logger.trace("Error during transport action execution.", e).         listener.onFailure(e).     } }
false;public;1;8;;@Override public void onResponse(Response response) {     try {         taskManager.storeResult(task, response, delegate).     } catch (Exception e) {         delegate.onFailure(e).     } }
false;public;1;9;;@Override public void onFailure(Exception e) {     try {         taskManager.storeResult(task, e, delegate).     } catch (Exception inner) {         inner.addSuppressed(e).         delegate.onFailure(inner).     } }
