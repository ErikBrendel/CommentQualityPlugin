commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public KeywordFieldType fieldType() {     return (KeywordFieldType) super.fieldType(). }
false;public;1;7;;public Builder ignoreAbove(int ignoreAbove) {     if (ignoreAbove < 0) {         throw new IllegalArgumentException("[ignore_above] must be positive, got " + ignoreAbove).     }     this.ignoreAbove = ignoreAbove.     return this. }
false;public;1;8;;@Override public Builder indexOptions(IndexOptions indexOptions) {     if (indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS) > 0) {         throw new IllegalArgumentException("The [keyword] field does not support positions, got [index_options]=" + indexOptionToString(indexOptions)).     }     return super.indexOptions(indexOptions). }
false;public;1;4;;public Builder eagerGlobalOrdinals(boolean eagerGlobalOrdinals) {     fieldType().setEagerGlobalOrdinals(eagerGlobalOrdinals).     return builder. }
false;public;1;4;;public Builder splitQueriesOnWhitespace(boolean splitQueriesOnWhitespace) {     fieldType().setSplitQueriesOnWhitespace(splitQueriesOnWhitespace).     return builder. }
false;public;2;5;;public Builder normalizer(IndexAnalyzers indexAnalyzers, String name) {     this.indexAnalyzers = indexAnalyzers.     this.normalizerName = name.     return builder. }
false;public;1;23;;@Override public KeywordFieldMapper build(BuilderContext context) {     setupFieldType(context).     if (normalizerName != null) {         NamedAnalyzer normalizer = indexAnalyzers.getNormalizer(normalizerName).         if (normalizer == null) {             throw new MapperParsingException("normalizer [" + normalizerName + "] not found for field [" + name + "]").         }         fieldType().setNormalizer(normalizer).         final NamedAnalyzer searchAnalyzer.         if (fieldType().splitQueriesOnWhitespace) {             searchAnalyzer = indexAnalyzers.getWhitespaceNormalizer(normalizerName).         } else {             searchAnalyzer = normalizer.         }         fieldType().setSearchAnalyzer(searchAnalyzer).     } else if (fieldType().splitQueriesOnWhitespace) {         fieldType().setSearchAnalyzer(new NamedAnalyzer("whitespace", AnalyzerScope.INDEX, new WhitespaceAnalyzer())).     }     return new KeywordFieldMapper(name, fieldType, defaultFieldType, ignoreAbove, context.indexSettings(), multiFieldsBuilder.build(this, context), copyTo). }
false;public;3;35;;@Override public Mapper.Builder<?, ?> parse(String name, Map<String, Object> node, ParserContext parserContext) throws MapperParsingException {     KeywordFieldMapper.Builder builder = new KeywordFieldMapper.Builder(name).     parseField(builder, name, node, parserContext).     for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(). iterator.hasNext(). ) {         Map.Entry<String, Object> entry = iterator.next().         String propName = entry.getKey().         Object propNode = entry.getValue().         if (propName.equals("null_value")) {             if (propNode == null) {                 throw new MapperParsingException("Property [null_value] cannot be null.").             }             builder.nullValue(propNode.toString()).             iterator.remove().         } else if (propName.equals("ignore_above")) {             builder.ignoreAbove(XContentMapValues.nodeIntegerValue(propNode, -1)).             iterator.remove().         } else if (propName.equals("norms")) {             TypeParsers.parseNorms(builder, name, propNode).             iterator.remove().         } else if (propName.equals("eager_global_ordinals")) {             builder.eagerGlobalOrdinals(XContentMapValues.nodeBooleanValue(propNode, "eager_global_ordinals")).             iterator.remove().         } else if (propName.equals("normalizer")) {             if (propNode != null) {                 builder.normalizer(parserContext.getIndexAnalyzers(), propNode.toString()).             }             iterator.remove().         } else if (propName.equals("split_queries_on_whitespace")) {             builder.splitQueriesOnWhitespace(XContentMapValues.nodeBooleanValue(propNode, "split_queries_on_whitespace")).             iterator.remove().         }     }     return builder. }
false;public;0;3;;public KeywordFieldType clone() {     return new KeywordFieldType(this). }
false;public;1;9;;@Override public boolean equals(Object o) {     if (super.equals(o) == false) {         return false.     }     KeywordFieldType other = (KeywordFieldType) o.     return Objects.equals(normalizer, other.normalizer) && splitQueriesOnWhitespace == other.splitQueriesOnWhitespace. }
false;public;2;8;;@Override public void checkCompatibility(MappedFieldType otherFT, List<String> conflicts) {     super.checkCompatibility(otherFT, conflicts).     KeywordFieldType other = (KeywordFieldType) otherFT.     if (Objects.equals(normalizer, other.normalizer) == false) {         conflicts.add("mapper [" + name() + "] has different [normalizer]").     } }
false;public;0;4;;@Override public int hashCode() {     return 31 * super.hashCode() + Objects.hash(normalizer, splitQueriesOnWhitespace). }
false;public;0;4;;@Override public String typeName() {     return CONTENT_TYPE. }
false;public;0;3;;public NamedAnalyzer normalizer() {     return normalizer. }
false;public;1;4;;public void setNormalizer(NamedAnalyzer normalizer) {     checkIfFrozen().     this.normalizer = normalizer. }
false;public;0;3;;public boolean splitQueriesOnWhitespace() {     return splitQueriesOnWhitespace. }
false;public;1;4;;public void setSplitQueriesOnWhitespace(boolean splitQueriesOnWhitespace) {     checkIfFrozen().     this.splitQueriesOnWhitespace = splitQueriesOnWhitespace. }
false;public;1;10;;@Override public Query existsQuery(QueryShardContext context) {     if (hasDocValues()) {         return new DocValuesFieldExistsQuery(name()).     } else if (omitNorms()) {         return new TermQuery(new Term(FieldNamesFieldMapper.NAME, name())).     } else {         return new NormsFieldExistsQuery(name()).     } }
false;public;1;5;;@Override public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName) {     failIfNoDocValues().     return new DocValuesIndexFieldData.Builder(). }
false;public;1;9;;@Override public Object valueForDisplay(Object value) {     if (value == null) {         return null.     }     // keywords are internally stored as utf8 bytes     BytesRef binaryValue = (BytesRef) value.     return binaryValue.utf8ToString(). }
false;protected;1;19;;@Override protected BytesRef indexedValueForSearch(Object value) {     if (searchAnalyzer() == Lucene.KEYWORD_ANALYZER) {         // This if statement will be used whenever a normalizer is NOT configured         return super.indexedValueForSearch(value).     }     if (value == null) {         return null.     }     if (value instanceof BytesRef) {         value = ((BytesRef) value).utf8ToString().     }     return searchAnalyzer().normalize(name(), value.toString()). }
true;;0;3;// pkg-private for testing ;/**  * Values that have more chars than the return value of this method will  *  be skipped at parsing time.  */ // pkg-private for testing int ignoreAbove() {     return ignoreAbove. }
false;protected;0;4;;@Override protected KeywordFieldMapper clone() {     return (KeywordFieldMapper) super.clone(). }
false;public;0;4;;@Override public KeywordFieldType fieldType() {     return (KeywordFieldType) super.fieldType(). }
false;protected;2;54;;@Override protected void parseCreateField(ParseContext context, List<IndexableField> fields) throws IOException {     String value.     if (context.externalValueSet()) {         value = context.externalValue().toString().     } else {         XContentParser parser = context.parser().         if (parser.currentToken() == XContentParser.Token.VALUE_NULL) {             value = fieldType().nullValueAsString().         } else {             value = parser.textOrNull().         }     }     if (value == null || value.length() > ignoreAbove) {         return.     }     final NamedAnalyzer normalizer = fieldType().normalizer().     if (normalizer != null) {         try (TokenStream ts = normalizer.tokenStream(name(), value)) {             final CharTermAttribute termAtt = ts.addAttribute(CharTermAttribute.class).             ts.reset().             if (ts.incrementToken() == false) {                 throw new IllegalStateException("The normalization token stream is " + "expected to produce exactly 1 token, but got 0 for analyzer " + normalizer + " and input \"" + value + "\"").             }             final String newValue = termAtt.toString().             if (ts.incrementToken()) {                 throw new IllegalStateException("The normalization token stream is " + "expected to produce exactly 1 token, but got 2+ for analyzer " + normalizer + " and input \"" + value + "\"").             }             ts.end().             value = newValue.         }     }     // convert to utf8 only once before feeding postings/dv/stored fields     final BytesRef binaryValue = new BytesRef(value).     if (fieldType().indexOptions() != IndexOptions.NONE || fieldType().stored()) {         Field field = new Field(fieldType().name(), binaryValue, fieldType()).         fields.add(field).         if (fieldType().hasDocValues() == false && fieldType().omitNorms()) {             createFieldNamesField(context, fields).         }     }     if (fieldType().hasDocValues()) {         fields.add(new SortedSetDocValuesField(fieldType().name(), binaryValue)).     } }
false;protected;0;4;;@Override protected String contentType() {     return CONTENT_TYPE. }
false;protected;1;5;;@Override protected void doMerge(Mapper mergeWith) {     super.doMerge(mergeWith).     this.ignoreAbove = ((KeywordFieldMapper) mergeWith).ignoreAbove. }
false;protected;3;22;;@Override protected void doXContentBody(XContentBuilder builder, boolean includeDefaults, Params params) throws IOException {     super.doXContentBody(builder, includeDefaults, params).     if (includeDefaults || fieldType().nullValue() != null) {         builder.field("null_value", fieldType().nullValue()).     }     if (includeDefaults || ignoreAbove != Defaults.IGNORE_ABOVE) {         builder.field("ignore_above", ignoreAbove).     }     if (fieldType().normalizer() != null) {         builder.field("normalizer", fieldType().normalizer().name()).     } else if (includeDefaults) {         builder.nullField("normalizer").     }     if (includeDefaults || fieldType().splitQueriesOnWhitespace) {         builder.field("split_queries_on_whitespace", fieldType().splitQueriesOnWhitespace).     } }
