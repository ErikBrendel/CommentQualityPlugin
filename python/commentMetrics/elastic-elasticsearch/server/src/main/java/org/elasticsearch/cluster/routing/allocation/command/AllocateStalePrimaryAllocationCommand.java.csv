commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String name() {     return NAME. }
false;public;0;4;;@Override public Optional<String> getMessage() {     return Optional.of("allocated a stale primary for [" + index + "][" + shardId + "] on node [" + node + "] from user command"). }
false;public,static;1;3;;public static AllocateStalePrimaryAllocationCommand fromXContent(XContentParser parser) throws IOException {     return new Builder().parse(parser).build(). }
false;public;1;4;;@Override public Builder parse(XContentParser parser) throws IOException {     return STALE_PRIMARY_PARSER.parse(parser, this, null). }
false;public;0;5;;@Override public AllocateStalePrimaryAllocationCommand build() {     validate().     return new AllocateStalePrimaryAllocationCommand(index, shard, node, acceptDataLoss). }
false;public;2;39;;@Override public RerouteExplanation execute(RoutingAllocation allocation, boolean explain) {     final DiscoveryNode discoNode.     try {         discoNode = allocation.nodes().resolveNode(node).     } catch (IllegalArgumentException e) {         return explainOrThrowRejectedCommand(explain, allocation, e).     }     final RoutingNodes routingNodes = allocation.routingNodes().     RoutingNode routingNode = routingNodes.node(discoNode.getId()).     if (routingNode == null) {         return explainOrThrowMissingRoutingNode(allocation, explain, discoNode).     }     final ShardRouting shardRouting.     try {         shardRouting = allocation.routingTable().shardRoutingTable(index, shardId).primaryShard().     } catch (IndexNotFoundException | ShardNotFoundException e) {         return explainOrThrowRejectedCommand(explain, allocation, e).     }     if (shardRouting.unassigned() == false) {         return explainOrThrowRejectedCommand(explain, allocation, "primary [" + index + "][" + shardId + "] is already assigned").     }     if (acceptDataLoss == false) {         String dataLossWarning = "allocating an empty primary for [" + index + "][" + shardId + "] can result in data loss. Please " + "confirm by setting the accept_data_loss parameter to true".         return explainOrThrowRejectedCommand(explain, allocation, dataLossWarning).     }     if (shardRouting.recoverySource().getType() != RecoverySource.Type.EXISTING_STORE) {         return explainOrThrowRejectedCommand(explain, allocation, "trying to allocate an existing primary shard [" + index + "][" + shardId + "], while no such shard has ever been active").     }     initializeUnassignedShard(allocation, routingNodes, routingNode, shardRouting, null, RecoverySource.ExistingStoreRecoverySource.FORCE_STALE_PRIMARY_INSTANCE).     return new RerouteExplanation(this, allocation.decision(Decision.YES, name() + " (allocation command)", "ignore deciders")). }
