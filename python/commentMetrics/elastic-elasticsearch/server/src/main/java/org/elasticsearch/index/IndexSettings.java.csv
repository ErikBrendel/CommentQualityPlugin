commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * The maximum age of a retention lease before it is considered expired.  *  * @return the maximum age  */ ;/**  * The maximum age of a retention lease before it is considered expired.  *  * @return the maximum age  */ public long getRetentionLeaseMillis() {     return retentionLeaseMillis. }
false;private;1;3;;private void setRetentionLeaseMillis(final TimeValue retentionLease) {     this.retentionLeaseMillis = retentionLease.millis(). }
true;public;0;3;/**  * Returns the default search fields for this index.  */ ;/**  * Returns the default search fields for this index.  */ public List<String> getDefaultFields() {     return defaultFields. }
false;private;1;3;;private void setDefaultFields(List<String> defaultFields) {     this.defaultFields = defaultFields. }
true;public;0;3;/**  * Returns <code>true</code> if query string parsing should be lenient. The default is <code>false</code>  */ ;/**  * Returns <code>true</code> if query string parsing should be lenient. The default is <code>false</code>  */ public boolean isQueryStringLenient() {     return queryStringLenient. }
true;public;0;3;/**  * Returns <code>true</code> if the query string should analyze wildcards. The default is <code>false</code>  */ ;/**  * Returns <code>true</code> if the query string should analyze wildcards. The default is <code>false</code>  */ public boolean isQueryStringAnalyzeWildcard() {     return queryStringAnalyzeWildcard. }
true;public;0;3;/**  * Returns <code>true</code> if the query string parser should allow leading wildcards. The default is <code>true</code>  */ ;/**  * Returns <code>true</code> if the query string parser should allow leading wildcards. The default is <code>true</code>  */ public boolean isQueryStringAllowLeadingWildcard() {     return queryStringAllowLeadingWildcard. }
true;public;0;3;/**  * Returns <code>true</code> if queries should be lenient about unmapped fields. The default is <code>true</code>  */ ;/**  * Returns <code>true</code> if queries should be lenient about unmapped fields. The default is <code>true</code>  */ public boolean isDefaultAllowUnmappedFields() {     return defaultAllowUnmappedFields. }
false;private;1;1;;private void setSearchIdleAfter(TimeValue searchIdleAfter) {     this.searchIdleAfter = searchIdleAfter. }
false;private;1;3;;private void setTranslogFlushThresholdSize(ByteSizeValue byteSizeValue) {     this.flushThresholdSize = byteSizeValue. }
false;private;1;3;;private void setTranslogRetentionSize(ByteSizeValue byteSizeValue) {     this.translogRetentionSize = byteSizeValue. }
false;private;1;3;;private void setTranslogRetentionAge(TimeValue age) {     this.translogRetentionAge = age. }
false;private;1;3;;private void setGenerationThresholdSize(final ByteSizeValue generationThresholdSize) {     this.generationThresholdSize = generationThresholdSize. }
false;private;1;3;;private void setGCDeletes(TimeValue timeValue) {     this.gcDeletesInMillis = timeValue.getMillis(). }
false;private;1;3;;private void setRefreshInterval(TimeValue timeValue) {     this.refreshInterval = timeValue. }
true;public;0;1;/**  * Returns the settings for this index. These settings contain the node and index level settings where  * settings that are specified on both index and node level are overwritten by the index settings.  */ ;/**  * Returns the settings for this index. These settings contain the node and index level settings where  * settings that are specified on both index and node level are overwritten by the index settings.  */ public Settings getSettings() {     return settings. }
true;public;0;3;/**  * Returns the index this settings object belongs to  */ ;/**  * Returns the index this settings object belongs to  */ public Index getIndex() {     return index. }
true;public;0;3;/**  * Returns the indexes UUID  */ ;/**  * Returns the indexes UUID  */ public String getUUID() {     return getIndex().getUUID(). }
true;public;0;3;/**  * Returns <code>true</code> if the index has a custom data path  */ ;/**  * Returns <code>true</code> if the index has a custom data path  */ public boolean hasCustomDataPath() {     return customDataPath() != null. }
true;public;0;3;/**  * Returns the customDataPath for this index, if configured. <code>null</code> o.w.  */ ;/**  * Returns the customDataPath for this index, if configured. <code>null</code> o.w.  */ public String customDataPath() {     return settings.get(IndexMetaData.SETTING_DATA_PATH). }
true;public;0;3;/**  * Returns the version the index was created on.  * @see Version#indexCreated(Settings)  */ ;/**  * Returns the version the index was created on.  * @see Version#indexCreated(Settings)  */ public Version getIndexVersionCreated() {     return version. }
true;public;0;3;/**  * Returns the current node name  */ ;/**  * Returns the current node name  */ public String getNodeName() {     return nodeName. }
true;public;0;3;/**  * Returns the current IndexMetaData for this index  */ ;/**  * Returns the current IndexMetaData for this index  */ public IndexMetaData getIndexMetaData() {     return indexMetaData. }
true;public;0;1;/**  * Returns the number of shards this index has.  */ ;/**  * Returns the number of shards this index has.  */ public int getNumberOfShards() {     return numberOfShards. }
true;public;0;1;/**  * Returns the number of replicas this index has.  */ ;/**  * Returns the number of replicas this index has.  */ public int getNumberOfReplicas() {     return settings.getAsInt(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, null). }
true;public;0;3;/**  * Returns the node settings. The settings returned from {@link #getSettings()} are a merged version of the  * index settings and the node settings where node settings are overwritten by index settings.  */ ;/**  * Returns the node settings. The settings returned from {@link #getSettings()} are a merged version of the  * index settings and the node settings where node settings are overwritten by index settings.  */ public Settings getNodeSettings() {     return nodeSettings. }
true;public,synchronized;1;20;/**  * Updates the settings and index metadata and notifies all registered settings consumers with the new settings iff at least one  * setting has changed.  *  * @return <code>true</code> iff any setting has been updated otherwise <code>false</code>.  */ ;/**  * Updates the settings and index metadata and notifies all registered settings consumers with the new settings iff at least one  * setting has changed.  *  * @return <code>true</code> iff any setting has been updated otherwise <code>false</code>.  */ public synchronized boolean updateIndexMetaData(IndexMetaData indexMetaData) {     final Settings newSettings = indexMetaData.getSettings().     if (version.equals(Version.indexCreated(newSettings)) == false) {         throw new IllegalArgumentException("version mismatch on settings update expected: " + version + " but was: " + Version.indexCreated(newSettings)).     }     final String newUUID = newSettings.get(IndexMetaData.SETTING_INDEX_UUID, IndexMetaData.INDEX_UUID_NA_VALUE).     if (newUUID.equals(getUUID()) == false) {         throw new IllegalArgumentException("uuid mismatch on settings update expected: " + getUUID() + " but was: " + newUUID).     }     this.indexMetaData = indexMetaData.     final Settings newIndexSettings = Settings.builder().put(nodeSettings).put(newSettings).build().     if (same(this.settings, newIndexSettings)) {         // nothing to update, same settings         return false.     }     scopedSettings.applySettings(newSettings).     this.settings = newIndexSettings.     return true. }
true;public,static;2;4;/**  * Compare the specified settings for equality.  *  * @param left  the left settings  * @param right the right settings  * @return true if the settings are the same, otherwise false  */ ;/**  * Compare the specified settings for equality.  *  * @param left  the left settings  * @param right the right settings  * @return true if the settings are the same, otherwise false  */ public static boolean same(final Settings left, final Settings right) {     return left.filter(IndexScopedSettings.INDEX_SETTINGS_KEY_PREDICATE).equals(right.filter(IndexScopedSettings.INDEX_SETTINGS_KEY_PREDICATE)). }
true;public;0;3;/**  * Returns the translog durability for this index.  */ ;/**  * Returns the translog durability for this index.  */ public Translog.Durability getTranslogDurability() {     return durability. }
false;private;1;3;;private void setTranslogDurability(Translog.Durability durability) {     this.durability = durability. }
true;public;0;3;/**  * Returns true if index warmers are enabled, otherwise <code>false</code>  */ ;/**  * Returns true if index warmers are enabled, otherwise <code>false</code>  */ public boolean isWarmerEnabled() {     return warmerEnabled. }
false;private;1;3;;private void setEnableWarmer(boolean enableWarmer) {     this.warmerEnabled = enableWarmer. }
true;public;0;3;/**  * Returns the translog sync interval. This is the interval in which the transaction log is asynchronously fsynced unless  * the transaction log is fsyncing on every operations  */ ;/**  * Returns the translog sync interval. This is the interval in which the transaction log is asynchronously fsynced unless  * the transaction log is fsyncing on every operations  */ public TimeValue getTranslogSyncInterval() {     return syncInterval. }
true;public;0;3;/**  * Returns this interval in which the shards of this index are asynchronously refreshed. {@code -1} means async refresh is disabled.  */ ;/**  * Returns this interval in which the shards of this index are asynchronously refreshed. {@code -1} means async refresh is disabled.  */ public TimeValue getRefreshInterval() {     return refreshInterval. }
true;public;0;1;/**  * Returns the transaction log threshold size when to forcefully flush the index and clear the transaction log.  */ ;/**  * Returns the transaction log threshold size when to forcefully flush the index and clear the transaction log.  */ public ByteSizeValue getFlushThresholdSize() {     return flushThresholdSize. }
true;public;0;1;/**  * Returns the transaction log retention size which controls how much of the translog is kept around to allow for ops based recoveries  */ ;/**  * Returns the transaction log retention size which controls how much of the translog is kept around to allow for ops based recoveries  */ public ByteSizeValue getTranslogRetentionSize() {     return translogRetentionSize. }
true;public;0;1;/**  * Returns the transaction log retention age which controls the maximum age (time from creation) that translog files will be kept  * around  */ ;/**  * Returns the transaction log retention age which controls the maximum age (time from creation) that translog files will be kept  * around  */ public TimeValue getTranslogRetentionAge() {     return translogRetentionAge. }
true;public;0;3;/**  * Returns the generation threshold size. As sequence numbers can cause multiple generations to  * be preserved for rollback purposes, we want to keep the size of individual generations from  * growing too large to avoid excessive disk space consumption. Therefore, the translog is  * automatically rolled to a new generation when the current generation exceeds this generation  * threshold size.  *  * @return the generation threshold size  */ ;/**  * Returns the generation threshold size. As sequence numbers can cause multiple generations to  * be preserved for rollback purposes, we want to keep the size of individual generations from  * growing too large to avoid excessive disk space consumption. Therefore, the translog is  * automatically rolled to a new generation when the current generation exceeds this generation  * threshold size.  *  * @return the generation threshold size  */ public ByteSizeValue getGenerationThresholdSize() {     return generationThresholdSize. }
true;public;0;1;/**  * Returns the {@link MergeSchedulerConfig}  */ ;/**  * Returns the {@link MergeSchedulerConfig}  */ public MergeSchedulerConfig getMergeSchedulerConfig() {     return mergeSchedulerConfig. }
true;public;0;3;/**  * Returns the max result window for search requests, describing the maximum value of from + size on a query.  */ ;/**  * Returns the max result window for search requests, describing the maximum value of from + size on a query.  */ public int getMaxResultWindow() {     return this.maxResultWindow. }
false;private;1;3;;private void setMaxResultWindow(int maxResultWindow) {     this.maxResultWindow = maxResultWindow. }
true;public;0;3;/**  * Returns the max result window for an individual inner hit definition or top hits aggregation.  */ ;/**  * Returns the max result window for an individual inner hit definition or top hits aggregation.  */ public int getMaxInnerResultWindow() {     return maxInnerResultWindow. }
false;private;1;3;;private void setMaxInnerResultWindow(int maxInnerResultWindow) {     this.maxInnerResultWindow = maxInnerResultWindow. }
true;public;0;3;/**  * Returns the max number of filters in adjacency_matrix aggregation search requests  */ ;/**  * Returns the max number of filters in adjacency_matrix aggregation search requests  */ public int getMaxAdjacencyMatrixFilters() {     return this.maxAdjacencyMatrixFilters. }
false;private;1;3;;private void setMaxAdjacencyMatrixFilters(int maxAdjacencyFilters) {     this.maxAdjacencyMatrixFilters = maxAdjacencyFilters. }
true;public;0;3;/**  * Returns the maximum rescore window for search requests.  */ ;/**  * Returns the maximum rescore window for search requests.  */ public int getMaxRescoreWindow() {     return maxRescoreWindow. }
false;private;1;3;;private void setMaxRescoreWindow(int maxRescoreWindow) {     this.maxRescoreWindow = maxRescoreWindow. }
true;public;0;3;/**  * Returns the maximum number of allowed docvalue_fields to retrieve in a search request  */ ;/**  * Returns the maximum number of allowed docvalue_fields to retrieve in a search request  */ public int getMaxDocvalueFields() {     return this.maxDocvalueFields. }
false;private;1;3;;private void setMaxDocvalueFields(int maxDocvalueFields) {     this.maxDocvalueFields = maxDocvalueFields. }
true;public;0;3;/**  * Returns the maximum number of tokens that can be produced  */ ;/**  * Returns the maximum number of tokens that can be produced  */ public int getMaxTokenCount() {     return maxTokenCount. }
false;private;1;3;;private void setMaxTokenCount(int maxTokenCount) {     this.maxTokenCount = maxTokenCount. }
true;public;0;1;/**  * Returns the maximum allowed difference between max and min length of ngram  */ ;/**  * Returns the maximum allowed difference between max and min length of ngram  */ public int getMaxNgramDiff() {     return this.maxNgramDiff. }
false;private;1;1;;private void setMaxNgramDiff(int maxNgramDiff) {     this.maxNgramDiff = maxNgramDiff. }
true;public;0;1;/**  * Returns the maximum allowed difference between max and min shingle_size  */ ;/**  * Returns the maximum allowed difference between max and min shingle_size  */ public int getMaxShingleDiff() {     return this.maxShingleDiff. }
false;private;1;1;;private void setMaxShingleDiff(int maxShingleDiff) {     this.maxShingleDiff = maxShingleDiff. }
true;public;0;1;/**  *  Returns the maximum number of chars that will be analyzed in a highlight request  */ ;/**  *  Returns the maximum number of chars that will be analyzed in a highlight request  */ public int getHighlightMaxAnalyzedOffset() {     return this.maxAnalyzedOffset. }
false;private;1;1;;private void setHighlightMaxAnalyzedOffset(int maxAnalyzedOffset) {     this.maxAnalyzedOffset = maxAnalyzedOffset. }
true;public;0;1;/**  *  Returns the maximum number of terms that can be used in a Terms Query request  */ ;/**  *  Returns the maximum number of terms that can be used in a Terms Query request  */ public int getMaxTermsCount() {     return this.maxTermsCount. }
false;private;1;1;;private void setMaxTermsCount(int maxTermsCount) {     this.maxTermsCount = maxTermsCount. }
true;public;0;3;/**  * Returns the maximum number of allowed script_fields to retrieve in a search request  */ ;/**  * Returns the maximum number of allowed script_fields to retrieve in a search request  */ public int getMaxScriptFields() {     return this.maxScriptFields. }
false;private;1;3;;private void setMaxScriptFields(int maxScriptFields) {     this.maxScriptFields = maxScriptFields. }
true;public;0;3;/**  * Returns the GC deletes cycle in milliseconds.  */ ;/**  * Returns the GC deletes cycle in milliseconds.  */ public long getGcDeletesInMillis() {     return gcDeletesInMillis. }
true;public;0;3;/**  * Returns the merge policy that should be used for this index.  */ ;/**  * Returns the merge policy that should be used for this index.  */ public MergePolicy getMergePolicy() {     return mergePolicyConfig.getMergePolicy(). }
false;public;1;3;;public <T> T getValue(Setting<T> setting) {     return scopedSettings.get(setting). }
true;public;0;3;/**  * The maximum number of refresh listeners allows on this shard.  */ ;/**  * The maximum number of refresh listeners allows on this shard.  */ public int getMaxRefreshListeners() {     return maxRefreshListeners. }
false;private;1;3;;private void setMaxRefreshListeners(int maxRefreshListeners) {     this.maxRefreshListeners = maxRefreshListeners. }
true;public;0;3;/**  * The maximum number of slices allowed in a scroll request.  */ ;/**  * The maximum number of slices allowed in a scroll request.  */ public int getMaxSlicesPerScroll() {     return maxSlicesPerScroll. }
false;private;1;3;;private void setMaxSlicesPerScroll(int value) {     this.maxSlicesPerScroll = value. }
true;public;0;3;/**  * The maximum length of regex string allowed in a regexp query.  */ ;/**  * The maximum length of regex string allowed in a regexp query.  */ public int getMaxRegexLength() {     return maxRegexLength. }
false;private;1;3;;private void setMaxRegexLength(int maxRegexLength) {     this.maxRegexLength = maxRegexLength. }
true;public;0;3;/**  * Returns the index sort config that should be used for this index.  */ ;/**  * Returns the index sort config that should be used for this index.  */ public IndexSortConfig getIndexSortConfig() {     return indexSortConfig. }
false;public;0;1;;public IndexScopedSettings getScopedSettings() {     return scopedSettings. }
true;public;0;3;/**  * Returns true iff the refresh setting exists or in other words is explicitly set.  */ ;/**  * Returns true iff the refresh setting exists or in other words is explicitly set.  */ public boolean isExplicitRefresh() {     return INDEX_REFRESH_INTERVAL_SETTING.exists(settings). }
true;public;0;1;/**  * Returns the time that an index shard becomes search idle unless it's accessed in between  */ ;/**  * Returns the time that an index shard becomes search idle unless it's accessed in between  */ public TimeValue getSearchIdleAfter() {     return searchIdleAfter. }
false;public;0;3;;public String getDefaultPipeline() {     return defaultPipeline. }
false;public;1;3;;public void setDefaultPipeline(String defaultPipeline) {     this.defaultPipeline = defaultPipeline. }
true;public;0;3;/**  * Returns <code>true</code> if soft-delete is enabled.  */ ;/**  * Returns <code>true</code> if soft-delete is enabled.  */ public boolean isSoftDeleteEnabled() {     return softDeleteEnabled. }
false;private;1;3;;private void setSoftDeleteRetentionOperations(long ops) {     this.softDeleteRetentionOperations = ops. }
true;public;0;3;/**  * Returns the number of extra operations (i.e. soft-deleted documents) to be kept for recoveries and history purpose.  */ ;/**  * Returns the number of extra operations (i.e. soft-deleted documents) to be kept for recoveries and history purpose.  */ public long getSoftDeleteRetentionOperations() {     return this.softDeleteRetentionOperations. }
true;public;0;3;/**  * Returns true if the this index should be searched throttled ie. using the  * {@link org.elasticsearch.threadpool.ThreadPool.Names#SEARCH_THROTTLED} thread-pool  */ ;/**  * Returns true if the this index should be searched throttled ie. using the  * {@link org.elasticsearch.threadpool.ThreadPool.Names#SEARCH_THROTTLED} thread-pool  */ public boolean isSearchThrottled() {     return searchThrottled. }
false;private;1;3;;private void setSearchThrottled(boolean searchThrottled) {     this.searchThrottled = searchThrottled. }
