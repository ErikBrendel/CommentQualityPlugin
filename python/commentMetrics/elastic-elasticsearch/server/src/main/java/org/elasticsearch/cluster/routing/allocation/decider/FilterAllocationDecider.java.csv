commented;modifiers;parameterAmount;loc;comment;code
false;public;3;19;;@Override public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {     if (shardRouting.unassigned()) {         // only for unassigned - we filter allocation right after the index creation ie. for shard shrinking etc. to ensure         // that once it has been allocated post API the replicas can be allocated elsewhere without user interaction         // this is a setting that can only be set within the system!         IndexMetaData indexMd = allocation.metaData().getIndexSafe(shardRouting.index()).         DiscoveryNodeFilters initialRecoveryFilters = indexMd.getInitialRecoveryFilters().         if (initialRecoveryFilters != null && INITIAL_RECOVERY_TYPES.contains(shardRouting.recoverySource().getType()) && initialRecoveryFilters.match(node.node()) == false) {             String explanation = (shardRouting.recoverySource().getType() == RecoverySource.Type.LOCAL_SHARDS) ? "initial allocation of the shrunken index is only allowed on nodes [%s] that hold a copy of every shard in the index" : "initial allocation of the index is only allowed on nodes [%s]".             return allocation.decision(Decision.NO, NAME, explanation, initialRecoveryFilters).         }     }     return shouldFilter(shardRouting, node, allocation). }
false;public;3;4;;@Override public Decision canAllocate(IndexMetaData indexMetaData, RoutingNode node, RoutingAllocation allocation) {     return shouldFilter(indexMetaData, node, allocation). }
false;public;3;4;;@Override public Decision canRemain(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {     return shouldFilter(shardRouting, node, allocation). }
false;private;3;9;;private Decision shouldFilter(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {     Decision decision = shouldClusterFilter(node, allocation).     if (decision != null)         return decision.     decision = shouldIndexFilter(allocation.metaData().getIndexSafe(shardRouting.index()), node, allocation).     if (decision != null)         return decision.     return allocation.decision(Decision.YES, NAME, "node passes include/exclude/require filters"). }
false;private;3;9;;private Decision shouldFilter(IndexMetaData indexMd, RoutingNode node, RoutingAllocation allocation) {     Decision decision = shouldClusterFilter(node, allocation).     if (decision != null)         return decision.     decision = shouldIndexFilter(indexMd, node, allocation).     if (decision != null)         return decision.     return allocation.decision(Decision.YES, NAME, "node passes include/exclude/require filters"). }
false;private;3;21;;private Decision shouldIndexFilter(IndexMetaData indexMd, RoutingNode node, RoutingAllocation allocation) {     if (indexMd.requireFilters() != null) {         if (indexMd.requireFilters().match(node.node()) == false) {             return allocation.decision(Decision.NO, NAME, "node does not match index setting [%s] filters [%s]", IndexMetaData.INDEX_ROUTING_REQUIRE_GROUP_PREFIX, indexMd.requireFilters()).         }     }     if (indexMd.includeFilters() != null) {         if (indexMd.includeFilters().match(node.node()) == false) {             return allocation.decision(Decision.NO, NAME, "node does not match index setting [%s] filters [%s]", IndexMetaData.INDEX_ROUTING_INCLUDE_GROUP_PREFIX, indexMd.includeFilters()).         }     }     if (indexMd.excludeFilters() != null) {         if (indexMd.excludeFilters().match(node.node())) {             return allocation.decision(Decision.NO, NAME, "node matches index setting [%s] filters [%s]", IndexMetaData.INDEX_ROUTING_EXCLUDE_GROUP_SETTING.getKey(), indexMd.excludeFilters()).         }     }     return null. }
false;private;2;21;;private Decision shouldClusterFilter(RoutingNode node, RoutingAllocation allocation) {     if (clusterRequireFilters != null) {         if (clusterRequireFilters.match(node.node()) == false) {             return allocation.decision(Decision.NO, NAME, "node does not match cluster setting [%s] filters [%s]", CLUSTER_ROUTING_REQUIRE_GROUP_PREFIX, clusterRequireFilters).         }     }     if (clusterIncludeFilters != null) {         if (clusterIncludeFilters.match(node.node()) == false) {             return allocation.decision(Decision.NO, NAME, "node does not cluster setting [%s] filters [%s]", CLUSTER_ROUTING_INCLUDE_GROUP_PREFIX, clusterIncludeFilters).         }     }     if (clusterExcludeFilters != null) {         if (clusterExcludeFilters.match(node.node())) {             return allocation.decision(Decision.NO, NAME, "node matches cluster setting [%s] filters [%s]", CLUSTER_ROUTING_EXCLUDE_GROUP_PREFIX, clusterExcludeFilters).         }     }     return null. }
false;private;1;3;;private void setClusterRequireFilters(Map<String, String> filters) {     clusterRequireFilters = DiscoveryNodeFilters.buildFromKeyValue(AND, filters). }
false;private;1;3;;private void setClusterIncludeFilters(Map<String, String> filters) {     clusterIncludeFilters = DiscoveryNodeFilters.buildFromKeyValue(OR, filters). }
false;private;1;3;;private void setClusterExcludeFilters(Map<String, String> filters) {     clusterExcludeFilters = DiscoveryNodeFilters.buildFromKeyValue(OR, filters). }
