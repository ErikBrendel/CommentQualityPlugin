commented;modifiers;parameterAmount;loc;comment;code
false;private;0;4;;private ClusterFormationState getClusterFormationState() {     return new ClusterFormationState(settings, getStateForMasterService(), peerFinder.getLastResolvedAddresses(), StreamSupport.stream(peerFinder.getFoundPeers().spliterator(), false).collect(Collectors.toList()), getCurrentTerm()). }
false;public;0;6;;@Override public void run() {     synchronized (mutex) {         becomeCandidate("onLeaderFailure").     } }
false;public;0;4;;@Override public String toString() {     return "notification of leader failure". }
false;private;0;15;;private Runnable getOnLeaderFailure() {     return new Runnable() {          @Override         public void run() {             synchronized (mutex) {                 becomeCandidate("onLeaderFailure").             }         }          @Override         public String toString() {             return "notification of leader failure".         }     }. }
false;private;2;11;;private void removeNode(DiscoveryNode discoveryNode, String reason) {     synchronized (mutex) {         if (mode == Mode.LEADER) {             masterService.submitStateUpdateTask("node-left", new NodeRemovalClusterStateTaskExecutor.Task(discoveryNode, reason), ClusterStateTaskConfig.build(Priority.IMMEDIATE), nodeRemovalExecutor, nodeRemovalExecutor).         }     } }
false;;1;19;;void onFollowerCheckRequest(FollowerCheckRequest followerCheckRequest) {     synchronized (mutex) {         ensureTermAtLeast(followerCheckRequest.getSender(), followerCheckRequest.getTerm()).         if (getCurrentTerm() != followerCheckRequest.getTerm()) {             logger.trace("onFollowerCheckRequest: current term is [{}], rejecting {}", getCurrentTerm(), followerCheckRequest).             throw new CoordinationStateRejectedException("onFollowerCheckRequest: current term is [" + getCurrentTerm() + "], rejecting " + followerCheckRequest).         }         // where we would possibly have to remove the NO_MASTER_BLOCK from the applierState when turning a candidate back to follower.         if (getLastAcceptedState().term() < getCurrentTerm()) {             becomeFollower("onFollowerCheckRequest", followerCheckRequest.getSender()).         }     } }
false;public;2;4;;@Override public void onFailure(String source, Exception e) {     applyListener.onFailure(e). }
false;public;1;4;;@Override public void onSuccess(String source) {     applyListener.onResponse(null). }
false;private;2;27;;private void handleApplyCommit(ApplyCommitRequest applyCommitRequest, ActionListener<Void> applyListener) {     synchronized (mutex) {         logger.trace("handleApplyCommit: applying commit {}", applyCommitRequest).         coordinationState.get().handleCommit(applyCommitRequest).         final ClusterState committedState = hideStateIfNotRecovered(coordinationState.get().getLastAcceptedState()).         applierState = mode == Mode.CANDIDATE ? clusterStateWithNoMasterBlock(committedState) : committedState.         if (applyCommitRequest.getSourceNode().equals(getLocalNode())) {             // master node applies the committed state at the end of the publication process, not here.             applyListener.onResponse(null).         } else {             clusterApplier.onNewClusterState(applyCommitRequest.toString(), () -> applierState, new ClusterApplyListener() {                  @Override                 public void onFailure(String source, Exception e) {                     applyListener.onFailure(e).                 }                  @Override                 public void onSuccess(String source) {                     applyListener.onResponse(null).                 }             }).         }     } }
false;;1;51;;PublishWithJoinResponse handlePublishRequest(PublishRequest publishRequest) {     assert publishRequest.getAcceptedState().nodes().getLocalNode().equals(getLocalNode()) : publishRequest.getAcceptedState().nodes().getLocalNode() + " != " + getLocalNode().     synchronized (mutex) {         final DiscoveryNode sourceNode = publishRequest.getAcceptedState().nodes().getMasterNode().         logger.trace("handlePublishRequest: handling [{}] from [{}]", publishRequest, sourceNode).         if (sourceNode.equals(getLocalNode()) && mode != Mode.LEADER) {             // is already failed so there is no point in proceeding.             throw new CoordinationStateRejectedException("no longer leading this publication's term: " + publishRequest).         }         if (publishRequest.getAcceptedState().term() == ZEN1_BWC_TERM && getCurrentTerm() == ZEN1_BWC_TERM && mode == Mode.FOLLOWER && Optional.of(sourceNode).equals(lastKnownLeader) == false) {             logger.debug("received cluster state from {} but currently following {}, rejecting", sourceNode, lastKnownLeader).             throw new CoordinationStateRejectedException("received cluster state from " + sourceNode + " but currently following " + lastKnownLeader + ", rejecting").         }         final ClusterState localState = coordinationState.get().getLastAcceptedState().         if (localState.metaData().clusterUUIDCommitted() && localState.metaData().clusterUUID().equals(publishRequest.getAcceptedState().metaData().clusterUUID()) == false) {             logger.warn("received cluster state from {} with a different cluster uuid {} than local cluster uuid {}, rejecting", sourceNode, publishRequest.getAcceptedState().metaData().clusterUUID(), localState.metaData().clusterUUID()).             throw new CoordinationStateRejectedException("received cluster state from " + sourceNode + " with a different cluster uuid " + publishRequest.getAcceptedState().metaData().clusterUUID() + " than local cluster uuid " + localState.metaData().clusterUUID() + ", rejecting").         }         if (publishRequest.getAcceptedState().term() > localState.term()) {             // only do join validation if we have not accepted state from this master yet             onJoinValidators.forEach(a -> a.accept(getLocalNode(), publishRequest.getAcceptedState())).         }         ensureTermAtLeast(sourceNode, publishRequest.getAcceptedState().term()).         final PublishResponse publishResponse = coordinationState.get().handlePublishRequest(publishRequest).         if (sourceNode.equals(getLocalNode())) {             preVoteCollector.update(getPreVoteResponse(), getLocalNode()).         } else {             // also updates preVoteCollector             becomeFollower("handlePublishRequest", sourceNode).         }         return new PublishWithJoinResponse(publishResponse, joinWithDestination(lastJoin, sourceNode, publishRequest.getAcceptedState().term())).     } }
false;private,static;3;9;;private static Optional<Join> joinWithDestination(Optional<Join> lastJoin, DiscoveryNode leader, long term) {     if (lastJoin.isPresent() && lastJoin.get().targetMatches(leader) && lastJoin.get().getTerm() == term) {         return lastJoin.     }     return Optional.empty(). }
false;private;0;11;;private void closePrevotingAndElectionScheduler() {     if (prevotingRound != null) {         prevotingRound.close().         prevotingRound = null.     }     if (electionScheduler != null) {         electionScheduler.close().         electionScheduler = null.     } }
false;private;1;22;;private void updateMaxTermSeen(final long term) {     synchronized (mutex) {         maxTermSeen = Math.max(maxTermSeen, term).         final long currentTerm = getCurrentTerm().         if (mode == Mode.LEADER && maxTermSeen > currentTerm) {             // since we check whether a term bump is needed at the end of the publication too.             if (publicationInProgress()) {                 logger.debug("updateMaxTermSeen: maxTermSeen = {} > currentTerm = {}, enqueueing term bump", maxTermSeen, currentTerm).             } else {                 try {                     logger.debug("updateMaxTermSeen: maxTermSeen = {} > currentTerm = {}, bumping term", maxTermSeen, currentTerm).                     ensureTermAtLeast(getLocalNode(), maxTermSeen).                     startElection().                 } catch (Exception e) {                     logger.warn(new ParameterizedMessage("failed to bump term to {}", maxTermSeen), e).                     becomeCandidate("updateMaxTermSeen").                 }             }         }     } }
false;private;0;22;;private void startElection() {     synchronized (mutex) {         // to check our mode again here.         if (mode == Mode.CANDIDATE) {             if (electionQuorumContainsLocalNode(getLastAcceptedState()) == false) {                 logger.trace("skip election as local node is not part of election quorum: {}", getLastAcceptedState().coordinationMetaData()).                 return.             }             final StartJoinRequest startJoinRequest = new StartJoinRequest(getLocalNode(), Math.max(getCurrentTerm(), maxTermSeen) + 1).             logger.debug("starting election with {}", startJoinRequest).             getDiscoveredNodes().forEach(node -> {                 if (isZen1Node(node) == false) {                     joinHelper.sendStartJoinRequest(startJoinRequest, node).                 }             }).         }     } }
false;private;1;16;;private void abdicateTo(DiscoveryNode newMaster) {     assert Thread.holdsLock(mutex).     assert mode == Mode.LEADER : "expected to be leader on abdication but was " + mode.     assert newMaster.isMasterNode() : "should only abdicate to master-eligible node but was " + newMaster.     final StartJoinRequest startJoinRequest = new StartJoinRequest(newMaster, Math.max(getCurrentTerm(), maxTermSeen) + 1).     logger.info("abdicating to {} with term {}", newMaster, startJoinRequest.getTerm()).     getLastAcceptedState().nodes().mastersFirstStream().forEach(node -> {         if (isZen1Node(node) == false) {             joinHelper.sendStartJoinRequest(startJoinRequest, node).         }     }).     // handling of start join messages on the local node will be dispatched to the generic thread-pool     assert mode == Mode.LEADER : "should still be leader after sending abdication messages " + mode.     // explicitly move node to candidate state so that the next cluster state update task yields an onNoLongerMaster event     becomeCandidate("after abdicating to " + newMaster). }
false;private,static;1;5;;private static boolean electionQuorumContainsLocalNode(ClusterState lastAcceptedState) {     final DiscoveryNode localNode = lastAcceptedState.nodes().getLocalNode().     assert localNode != null.     return electionQuorumContains(lastAcceptedState, localNode). }
false;private,static;2;5;;private static boolean electionQuorumContains(ClusterState lastAcceptedState, DiscoveryNode node) {     final String nodeId = node.getId().     return lastAcceptedState.getLastCommittedConfiguration().getNodeIds().contains(nodeId) || lastAcceptedState.getLastAcceptedConfiguration().getNodeIds().contains(nodeId). }
false;private;2;7;;private Optional<Join> ensureTermAtLeast(DiscoveryNode sourceNode, long targetTerm) {     assert Thread.holdsLock(mutex) : "Coordinator mutex not held".     if (getCurrentTerm() < targetTerm) {         return Optional.of(joinLeaderInTerm(new StartJoinRequest(sourceNode, targetTerm))).     }     return Optional.empty(). }
false;private;1;15;;private Join joinLeaderInTerm(StartJoinRequest startJoinRequest) {     synchronized (mutex) {         logger.debug("joinLeaderInTerm: for [{}] with term {}", startJoinRequest.getSourceNode(), startJoinRequest.getTerm()).         final Join join = coordinationState.get().handleStartJoin(startJoinRequest).         lastJoin = Optional.of(join).         peerFinder.setCurrentTerm(getCurrentTerm()).         if (mode != Mode.CANDIDATE) {             // updates followersChecker and preVoteCollector             becomeCandidate("joinLeaderInTerm").         } else {             followersChecker.updateFastResponseState(getCurrentTerm(), mode).             preVoteCollector.update(getPreVoteResponse(), null).         }         return join.     } }
false;private;2;22;;private void handleJoinRequest(JoinRequest joinRequest, JoinHelper.JoinCallback joinCallback) {     assert Thread.holdsLock(mutex) == false.     assert getLocalNode().isMasterNode() : getLocalNode() + " received a join but is not master-eligible".     logger.trace("handleJoinRequest: as {}, handling {}", mode, joinRequest).     transportService.connectToNode(joinRequest.getSourceNode()).     final ClusterState stateForJoinValidation = getStateForMasterService().     if (stateForJoinValidation.nodes().isLocalNodeElectedMaster()) {         onJoinValidators.forEach(a -> a.accept(joinRequest.getSourceNode(), stateForJoinValidation)).         if (stateForJoinValidation.getBlocks().hasGlobalBlock(STATE_NOT_RECOVERED_BLOCK) == false) {             // we do this in a couple of places including the cluster update thread. This one here is really just best effort             // to ensure we fail as fast as possible.             JoinTaskExecutor.ensureMajorVersionBarrier(joinRequest.getSourceNode().getVersion(), stateForJoinValidation.getNodes().getMinNodeVersion()).         }         sendValidateJoinRequest(stateForJoinValidation, joinRequest, joinCallback).     } else {         processJoinRequest(joinRequest, joinCallback).     } }
false;public;1;8;;@Override public void onResponse(Empty empty) {     try {         processJoinRequest(joinRequest, joinCallback).     } catch (Exception e) {         joinCallback.onFailure(e).     } }
false;public;1;6;;@Override public void onFailure(Exception e) {     logger.warn(() -> new ParameterizedMessage("failed to validate incoming join request from node [{}]", joinRequest.getSourceNode()), e).     joinCallback.onFailure(new IllegalStateException("failure when sending a validation request to node", e)). }
true;;3;21;// package private for tests ;// package private for tests void sendValidateJoinRequest(ClusterState stateForJoinValidation, JoinRequest joinRequest, JoinHelper.JoinCallback joinCallback) {     // validate the join on the joining node, will throw a failure if it fails the validation     joinHelper.sendValidateJoinRequest(joinRequest.getSourceNode(), stateForJoinValidation, new ActionListener<Empty>() {          @Override         public void onResponse(Empty empty) {             try {                 processJoinRequest(joinRequest, joinCallback).             } catch (Exception e) {                 joinCallback.onFailure(e).             }         }          @Override         public void onFailure(Exception e) {             logger.warn(() -> new ParameterizedMessage("failed to validate incoming join request from node [{}]", joinRequest.getSourceNode()), e).             joinCallback.onFailure(new IllegalStateException("failure when sending a validation request to node", e)).         }     }). }
false;private;2;14;;private void processJoinRequest(JoinRequest joinRequest, JoinHelper.JoinCallback joinCallback) {     final Optional<Join> optionalJoin = joinRequest.getOptionalJoin().     synchronized (mutex) {         final CoordinationState coordState = coordinationState.get().         final boolean prevElectionWon = coordState.electionWon().         optionalJoin.ifPresent(this::handleJoin).         joinAccumulator.handleJoinRequest(joinRequest.getSourceNode(), joinCallback).         if (prevElectionWon == false && coordState.electionWon()) {             becomeLeader("handleJoinRequest").         }     } }
false;;1;35;;void becomeCandidate(String method) {     assert Thread.holdsLock(mutex) : "Coordinator mutex not held".     logger.debug("{}: coordinator becoming CANDIDATE in term {} (was {}, lastKnownLeader was [{}])", method, getCurrentTerm(), mode, lastKnownLeader).     if (mode != Mode.CANDIDATE) {         final Mode prevMode = mode.         mode = Mode.CANDIDATE.         cancelActivePublication("become candidate: " + method).         joinAccumulator.close(mode).         joinAccumulator = joinHelper.new CandidateJoinAccumulator().         peerFinder.activate(coordinationState.get().getLastAcceptedState().nodes()).         clusterFormationFailureHelper.start().         leaderChecker.setCurrentNodes(DiscoveryNodes.EMPTY_NODES).         leaderChecker.updateLeader(null).         followersChecker.clearCurrentNodes().         followersChecker.updateFastResponseState(getCurrentTerm(), mode).         lagDetector.clearTrackedNodes().         if (prevMode == Mode.LEADER) {             cleanMasterService().         }         if (applierState.nodes().getMasterNodeId() != null) {             applierState = clusterStateWithNoMasterBlock(applierState).             clusterApplier.onNewClusterState("becoming candidate: " + method, () -> applierState, (source, e) -> {             }).         }     }     preVoteCollector.update(getPreVoteResponse(), null). }
false;;1;21;;void becomeLeader(String method) {     assert Thread.holdsLock(mutex) : "Coordinator mutex not held".     assert mode == Mode.CANDIDATE : "expected candidate but was " + mode.     assert getLocalNode().isMasterNode() : getLocalNode() + " became a leader but is not master-eligible".     logger.debug("{}: coordinator becoming LEADER in term {} (was {}, lastKnownLeader was [{}])", method, getCurrentTerm(), mode, lastKnownLeader).     mode = Mode.LEADER.     joinAccumulator.close(mode).     joinAccumulator = joinHelper.new LeaderJoinAccumulator().     lastKnownLeader = Optional.of(getLocalNode()).     peerFinder.deactivate(getLocalNode()).     clusterFormationFailureHelper.stop().     closePrevotingAndElectionScheduler().     preVoteCollector.update(getPreVoteResponse(), getLocalNode()).     assert leaderChecker.leader() == null : leaderChecker.leader().     followersChecker.updateFastResponseState(getCurrentTerm(), mode). }
false;;2;37;;void becomeFollower(String method, DiscoveryNode leaderNode) {     assert Thread.holdsLock(mutex) : "Coordinator mutex not held".     assert leaderNode.isMasterNode() : leaderNode + " became a leader but is not master-eligible".     assert mode != Mode.LEADER : "do not switch to follower from leader (should be candidate first)".     if (mode == Mode.FOLLOWER && Optional.of(leaderNode).equals(lastKnownLeader)) {         logger.trace("{}: coordinator remaining FOLLOWER of [{}] in term {}", method, leaderNode, getCurrentTerm()).     } else {         logger.debug("{}: coordinator becoming FOLLOWER of [{}] in term {} (was {}, lastKnownLeader was [{}])", method, leaderNode, getCurrentTerm(), mode, lastKnownLeader).     }     final boolean restartLeaderChecker = (mode == Mode.FOLLOWER && Optional.of(leaderNode).equals(lastKnownLeader)) == false.     if (mode != Mode.FOLLOWER) {         mode = Mode.FOLLOWER.         joinAccumulator.close(mode).         joinAccumulator = new JoinHelper.FollowerJoinAccumulator().         leaderChecker.setCurrentNodes(DiscoveryNodes.EMPTY_NODES).     }     lastKnownLeader = Optional.of(leaderNode).     peerFinder.deactivate(leaderNode).     clusterFormationFailureHelper.stop().     closePrevotingAndElectionScheduler().     cancelActivePublication("become follower: " + method).     preVoteCollector.update(getPreVoteResponse(), leaderNode).     if (restartLeaderChecker) {         leaderChecker.updateLeader(leaderNode).     }     followersChecker.clearCurrentNodes().     followersChecker.updateFastResponseState(getCurrentTerm(), mode).     lagDetector.clearTrackedNodes(). }
false;public;2;5;;@Override public void onFailure(String source, Exception e) {     // ignore     logger.trace("failed to clean-up after stepping down as master", e). }
false;public;1;7;;@Override public ClusterTasksResult<LocalClusterUpdateTask> execute(ClusterState currentState) {     if (currentState.nodes().isLocalNodeElectedMaster() == false) {         allocationService.cleanCaches().     }     return unchanged(). }
false;private;0;19;;private void cleanMasterService() {     masterService.submitStateUpdateTask("clean-up after stepping down as master", new LocalClusterUpdateTask() {          @Override         public void onFailure(String source, Exception e) {             // ignore             logger.trace("failed to clean-up after stepping down as master", e).         }          @Override         public ClusterTasksResult<LocalClusterUpdateTask> execute(ClusterState currentState) {             if (currentState.nodes().isLocalNodeElectedMaster() == false) {                 allocationService.cleanCaches().             }             return unchanged().         }     }). }
false;private;0;4;;private PreVoteResponse getPreVoteResponse() {     return new PreVoteResponse(getCurrentTerm(), coordinationState.get().getLastAcceptedTerm(), coordinationState.get().getLastAcceptedState().getVersionOrMetaDataVersion()). }
true;;0;5;// package-visible for testing ;// package-visible for testing long getCurrentTerm() {     synchronized (mutex) {         return coordinationState.get().getCurrentTerm().     } }
true;;0;5;// package-visible for testing ;// package-visible for testing Mode getMode() {     synchronized (mutex) {         return mode.     } }
true;;0;3;// visible for testing ;// visible for testing DiscoveryNode getLocalNode() {     return transportService.getLocalNode(). }
true;;0;5;// package-visible for testing ;// package-visible for testing boolean publicationInProgress() {     synchronized (mutex) {         return currentPublication.isPresent().     } }
false;protected;0;17;;@Override protected void doStart() {     synchronized (mutex) {         CoordinationState.PersistedState persistedState = persistedStateSupplier.get().         coordinationState.set(new CoordinationState(settings, getLocalNode(), persistedState)).         peerFinder.setCurrentTerm(getCurrentTerm()).         configuredHostsResolver.start().         ClusterState initialState = ClusterState.builder(ClusterName.CLUSTER_NAME_SETTING.get(settings)).blocks(ClusterBlocks.builder().addGlobalBlock(STATE_NOT_RECOVERED_BLOCK).addGlobalBlock(noMasterBlockService.getNoMasterBlock())).nodes(DiscoveryNodes.builder().add(getLocalNode()).localNodeId(getLocalNode().getId())).build().         applierState = initialState.         clusterApplier.setInitialState(initialState).     } }
false;public;0;4;;@Override public DiscoveryStats stats() {     return new DiscoveryStats(new PendingClusterStateStats(0, 0, 0), publicationHandler.stats()). }
false;public;0;7;;@Override public void startInitialJoin() {     synchronized (mutex) {         becomeCandidate("startInitialJoin").     }     clusterBootstrapService.scheduleUnconfiguredBootstrap(). }
false;protected;0;4;;@Override protected void doStop() {     configuredHostsResolver.stop(). }
false;protected;0;3;;@Override protected void doClose() { }
false;public;0;88;;public void invariant() {     synchronized (mutex) {         final Optional<DiscoveryNode> peerFinderLeader = peerFinder.getLeader().         assert peerFinder.getCurrentTerm() == getCurrentTerm().         assert followersChecker.getFastResponseState().term == getCurrentTerm() : followersChecker.getFastResponseState().         assert followersChecker.getFastResponseState().mode == getMode() : followersChecker.getFastResponseState().         assert (applierState.nodes().getMasterNodeId() == null) == applierState.blocks().hasGlobalBlockWithId(NO_MASTER_BLOCK_ID).         assert applierState.nodes().getMasterNodeId() == null || applierState.metaData().clusterUUIDCommitted().         assert preVoteCollector.getPreVoteResponse().equals(getPreVoteResponse()) : preVoteCollector + " vs " + getPreVoteResponse().         assert lagDetector.getTrackedNodes().contains(getLocalNode()) == false : lagDetector.getTrackedNodes().         assert followersChecker.getKnownFollowers().equals(lagDetector.getTrackedNodes()) : followersChecker.getKnownFollowers() + " vs " + lagDetector.getTrackedNodes().         if (mode == Mode.LEADER) {             final boolean becomingMaster = getStateForMasterService().term() != getCurrentTerm().             assert coordinationState.get().electionWon().             assert lastKnownLeader.isPresent() && lastKnownLeader.get().equals(getLocalNode()).             assert joinAccumulator instanceof JoinHelper.LeaderJoinAccumulator.             assert peerFinderLeader.equals(lastKnownLeader) : peerFinderLeader.             assert electionScheduler == null : electionScheduler.             assert prevotingRound == null : prevotingRound.             assert becomingMaster || getStateForMasterService().nodes().getMasterNodeId() != null : getStateForMasterService().             assert leaderChecker.leader() == null : leaderChecker.leader().             assert getLocalNode().equals(applierState.nodes().getMasterNode()) || (applierState.nodes().getMasterNodeId() == null && applierState.term() < getCurrentTerm()).             assert preVoteCollector.getLeader() == getLocalNode() : preVoteCollector.             assert clusterFormationFailureHelper.isRunning() == false.             final boolean activePublication = currentPublication.map(CoordinatorPublication::isActiveForCurrentLeader).orElse(false).             if (becomingMaster && activePublication == false) {                 // cluster state update task to become master is submitted to MasterService, but publication has not started yet                 assert followersChecker.getKnownFollowers().isEmpty() : followersChecker.getKnownFollowers().             } else {                 final ClusterState lastPublishedState.                 if (activePublication) {                     // active publication in progress: followersChecker is up-to-date with nodes that we're actively publishing to                     lastPublishedState = currentPublication.get().publishedState().                 } else {                     // no active publication: followersChecker is up-to-date with the nodes of the latest publication                     lastPublishedState = coordinationState.get().getLastAcceptedState().                 }                 final Set<DiscoveryNode> lastPublishedNodes = new HashSet<>().                 lastPublishedState.nodes().forEach(lastPublishedNodes::add).                 // followersChecker excludes local node                 assert lastPublishedNodes.remove(getLocalNode()).                 assert lastPublishedNodes.equals(followersChecker.getKnownFollowers()) : lastPublishedNodes + " != " + followersChecker.getKnownFollowers().             }             assert becomingMaster || activePublication || coordinationState.get().getLastAcceptedConfiguration().equals(coordinationState.get().getLastCommittedConfiguration()) : coordinationState.get().getLastAcceptedConfiguration() + " != " + coordinationState.get().getLastCommittedConfiguration().         } else if (mode == Mode.FOLLOWER) {             assert coordinationState.get().electionWon() == false : getLocalNode() + " is FOLLOWER so electionWon() should be false".             assert lastKnownLeader.isPresent() && (lastKnownLeader.get().equals(getLocalNode()) == false).             assert joinAccumulator instanceof JoinHelper.FollowerJoinAccumulator.             assert peerFinderLeader.equals(lastKnownLeader) : peerFinderLeader.             assert electionScheduler == null : electionScheduler.             assert prevotingRound == null : prevotingRound.             assert getStateForMasterService().nodes().getMasterNodeId() == null : getStateForMasterService().             assert leaderChecker.currentNodeIsMaster() == false.             assert lastKnownLeader.equals(Optional.of(leaderChecker.leader())).             assert followersChecker.getKnownFollowers().isEmpty().             assert lastKnownLeader.get().equals(applierState.nodes().getMasterNode()) || (applierState.nodes().getMasterNodeId() == null && (applierState.term() < getCurrentTerm() || applierState.version() < getLastAcceptedState().version())).             assert currentPublication.map(Publication::isCommitted).orElse(true).             assert preVoteCollector.getLeader().equals(lastKnownLeader.get()) : preVoteCollector.             assert clusterFormationFailureHelper.isRunning() == false.         } else {             assert mode == Mode.CANDIDATE.             assert joinAccumulator instanceof JoinHelper.CandidateJoinAccumulator.             assert peerFinderLeader.isPresent() == false : peerFinderLeader.             assert prevotingRound == null || electionScheduler != null.             assert getStateForMasterService().nodes().getMasterNodeId() == null : getStateForMasterService().             assert leaderChecker.currentNodeIsMaster() == false.             assert leaderChecker.leader() == null : leaderChecker.leader().             assert followersChecker.getKnownFollowers().isEmpty().             assert applierState.nodes().getMasterNodeId() == null.             assert currentPublication.map(Publication::isCommitted).orElse(true).             assert preVoteCollector.getLeader() == null : preVoteCollector.             assert clusterFormationFailureHelper.isRunning().         }     } }
false;public;0;3;;public boolean isInitialConfigurationSet() {     return getStateForMasterService().getLastAcceptedConfiguration().isEmpty() == false. }
true;public;1;50;/**  * Sets the initial configuration to the given {@link VotingConfiguration}. This method is safe to call  * more than once, as long as the argument to each call is the same.  *  * @param votingConfiguration The nodes that should form the initial configuration.  * @return whether this call successfully set the initial configuration - if false, the cluster has already been bootstrapped.  */ ;/**  * Sets the initial configuration to the given {@link VotingConfiguration}. This method is safe to call  * more than once, as long as the argument to each call is the same.  *  * @param votingConfiguration The nodes that should form the initial configuration.  * @return whether this call successfully set the initial configuration - if false, the cluster has already been bootstrapped.  */ public boolean setInitialConfiguration(final VotingConfiguration votingConfiguration) {     synchronized (mutex) {         final ClusterState currentState = getStateForMasterService().         if (isInitialConfigurationSet()) {             logger.debug("initial configuration already set, ignoring {}", votingConfiguration).             return false.         }         if (getLocalNode().isMasterNode() == false) {             logger.debug("skip setting initial configuration as local node is not a master-eligible node").             throw new CoordinationStateRejectedException("this node is not master-eligible, but cluster bootstrapping can only happen on a master-eligible node").         }         if (votingConfiguration.getNodeIds().contains(getLocalNode().getId()) == false) {             logger.debug("skip setting initial configuration as local node is not part of initial configuration").             throw new CoordinationStateRejectedException("local node is not part of initial configuration").         }         final List<DiscoveryNode> knownNodes = new ArrayList<>().         knownNodes.add(getLocalNode()).         peerFinder.getFoundPeers().forEach(knownNodes::add).         if (votingConfiguration.hasQuorum(knownNodes.stream().map(DiscoveryNode::getId).collect(Collectors.toList())) == false) {             logger.debug("skip setting initial configuration as not enough nodes discovered to form a quorum in the " + "initial configuration [knownNodes={}, {}]", knownNodes, votingConfiguration).             throw new CoordinationStateRejectedException("not enough nodes discovered to form a quorum in the initial configuration " + "[knownNodes=" + knownNodes + ", " + votingConfiguration + "]").         }         logger.info("setting initial configuration to {}", votingConfiguration).         final CoordinationMetaData coordinationMetaData = CoordinationMetaData.builder(currentState.coordinationMetaData()).lastAcceptedConfiguration(votingConfiguration).lastCommittedConfiguration(votingConfiguration).build().         MetaData.Builder metaDataBuilder = MetaData.builder(currentState.metaData()).         // automatically generate a UID for the metadata if we need to         // TODO generate UUID in bootstrapping tool?         metaDataBuilder.generateClusterUuidIfNeeded().         metaDataBuilder.coordinationMetaData(coordinationMetaData).         coordinationState.get().setInitialState(ClusterState.builder(currentState).metaData(metaDataBuilder).build()).         assert electionQuorumContainsLocalNode(getLastAcceptedState()) : "initial state does not have local node in its election quorum: " + getLastAcceptedState().coordinationMetaData().         // pick up the change to last-accepted version         preVoteCollector.update(getPreVoteResponse(), null).         startElectionScheduler().         return true.     } }
true;;1;16;// Package-private for testing ;// Package-private for testing ClusterState improveConfiguration(ClusterState clusterState) {     assert Thread.holdsLock(mutex) : "Coordinator mutex not held".     final Set<DiscoveryNode> liveNodes = StreamSupport.stream(clusterState.nodes().spliterator(), false).filter(this::hasJoinVoteFrom).filter(discoveryNode -> isZen1Node(discoveryNode) == false).collect(Collectors.toSet()).     final VotingConfiguration newConfig = reconfigurator.reconfigure(liveNodes, clusterState.getVotingConfigExclusions().stream().map(VotingConfigExclusion::getNodeId).collect(Collectors.toSet()), getLocalNode(), clusterState.getLastAcceptedConfiguration()).     if (newConfig.equals(clusterState.getLastAcceptedConfiguration()) == false) {         assert coordinationState.get().joinVotesHaveQuorumFor(newConfig).         return ClusterState.builder(clusterState).metaData(MetaData.builder(clusterState.metaData()).coordinationMetaData(CoordinationMetaData.builder(clusterState.coordinationMetaData()).lastAcceptedConfiguration(newConfig).build())).build().     }     return clusterState. }
false;public;1;7;;@Override public ClusterState execute(ClusterState currentState) {     reconfigurationTaskScheduled.set(false).     synchronized (mutex) {         return improveConfiguration(currentState).     } }
false;public;2;5;;@Override public void onFailure(String source, Exception e) {     reconfigurationTaskScheduled.set(false).     logger.debug("reconfiguration failed", e). }
false;private;0;25;;private void scheduleReconfigurationIfNeeded() {     assert Thread.holdsLock(mutex) : "Coordinator mutex not held".     assert mode == Mode.LEADER : mode.     assert currentPublication.isPresent() == false : "Expected no publication in progress".     final ClusterState state = getLastAcceptedState().     if (improveConfiguration(state) != state && reconfigurationTaskScheduled.compareAndSet(false, true)) {         logger.trace("scheduling reconfiguration").         masterService.submitStateUpdateTask("reconfigure", new ClusterStateUpdateTask(Priority.URGENT) {              @Override             public ClusterState execute(ClusterState currentState) {                 reconfigurationTaskScheduled.set(false).                 synchronized (mutex) {                     return improveConfiguration(currentState).                 }             }              @Override             public void onFailure(String source, Exception e) {                 reconfigurationTaskScheduled.set(false).                 logger.debug("reconfiguration failed", e).             }         }).     } }
true;;1;3;// for tests ;// for tests boolean hasJoinVoteFrom(DiscoveryNode node) {     return coordinationState.get().containsJoinVoteFor(node). }
false;private;1;20;;private void handleJoin(Join join) {     synchronized (mutex) {         ensureTermAtLeast(getLocalNode(), join.getTerm()).ifPresent(this::handleJoin).         if (coordinationState.get().electionWon()) {             // If we have already won the election then the actual join does not matter for election purposes, so swallow any exception             final boolean isNewJoin = handleJoinIgnoringExceptions(join).             // If we haven't completely finished becoming master then there's already a publication scheduled which will, in turn,             // schedule a reconfiguration if needed. It's benign to schedule a reconfiguration anyway, but it might fail if it wins the             // race against the election-winning publication and log a big error message, which we can prevent by checking this here:             final boolean establishedAsMaster = mode == Mode.LEADER && getLastAcceptedState().term() == getCurrentTerm().             if (isNewJoin && establishedAsMaster && publicationInProgress() == false) {                 scheduleReconfigurationIfNeeded().             }         } else {             // this might fail and bubble up the exception             coordinationState.get().handleJoin(join).         }     } }
true;private;1;8;/**  * @return true iff the join was from a new node and was successfully added  */ ;/**  * @return true iff the join was from a new node and was successfully added  */ private boolean handleJoinIgnoringExceptions(Join join) {     try {         return coordinationState.get().handleJoin(join).     } catch (CoordinationStateRejectedException e) {         logger.debug(new ParameterizedMessage("failed to add {} - ignoring", join), e).         return false.     } }
false;public;0;5;;public ClusterState getLastAcceptedState() {     synchronized (mutex) {         return coordinationState.get().getLastAcceptedState().     } }
false;public;0;4;;@Nullable public ClusterState getApplierState() {     return applierState. }
false;private;0;6;;private List<DiscoveryNode> getDiscoveredNodes() {     final List<DiscoveryNode> nodes = new ArrayList<>().     nodes.add(getLocalNode()).     peerFinder.getFoundPeers().forEach(nodes::add).     return nodes. }
false;;0;12;;ClusterState getStateForMasterService() {     synchronized (mutex) {         // expose last accepted cluster state as base state upon which the master service         // speculatively calculates the next cluster state update         final ClusterState clusterState = coordinationState.get().getLastAcceptedState().         if (mode != Mode.LEADER || clusterState.term() != getCurrentTerm()) {             // the master service checks if the local node is the master node in order to fail execution of the state update early             return clusterStateWithNoMasterBlock(clusterState).         }         return clusterState.     } }
false;private;1;13;;private ClusterState clusterStateWithNoMasterBlock(ClusterState clusterState) {     if (clusterState.nodes().getMasterNodeId() != null) {         // remove block if it already exists before adding new one         assert clusterState.blocks().hasGlobalBlockWithId(NO_MASTER_BLOCK_ID) == false : "NO_MASTER_BLOCK should only be added by Coordinator".         final ClusterBlocks clusterBlocks = ClusterBlocks.builder().blocks(clusterState.blocks()).addGlobalBlock(noMasterBlockService.getNoMasterBlock()).build().         final DiscoveryNodes discoveryNodes = new DiscoveryNodes.Builder(clusterState.nodes()).masterNodeId(null).build().         return ClusterState.builder(clusterState).blocks(clusterBlocks).nodes(discoveryNodes).build().     } else {         return clusterState.     } }
false;public;0;6;;@Override public void run() {     synchronized (mutex) {         publication.cancel("timed out after " + publishTimeout).     } }
false;public;0;4;;@Override public String toString() {     return "scheduled timeout for " + publication. }
false;public;3;59;;@Override public void publish(ClusterChangedEvent clusterChangedEvent, ActionListener<Void> publishListener, AckListener ackListener) {     try {         synchronized (mutex) {             if (mode != Mode.LEADER) {                 logger.debug(() -> new ParameterizedMessage("[{}] failed publication as not currently leading", clusterChangedEvent.source())).                 publishListener.onFailure(new FailedToCommitClusterStateException("node stepped down as leader during publication")).                 return.             }             if (currentPublication.isPresent()) {                 assert false : "[" + currentPublication.get() + "] in progress, cannot start new publication".                 logger.warn(() -> new ParameterizedMessage("[{}] failed publication as already publication in progress", clusterChangedEvent.source())).                 publishListener.onFailure(new FailedToCommitClusterStateException("publication " + currentPublication.get() + " already in progress")).                 return.             }             assert assertPreviousStateConsistency(clusterChangedEvent).             final ClusterState clusterState = clusterChangedEvent.state().             assert getLocalNode().equals(clusterState.getNodes().get(getLocalNode().getId())) : getLocalNode() + " should be in published " + clusterState.             final PublishRequest publishRequest = coordinationState.get().handleClientValue(clusterState).             final PublicationTransportHandler.PublicationContext publicationContext = publicationHandler.newPublicationContext(clusterChangedEvent).             final CoordinatorPublication publication = new CoordinatorPublication(publishRequest, publicationContext, new ListenableFuture<>(), ackListener, publishListener).             currentPublication = Optional.of(publication).             transportService.getThreadPool().schedule(new Runnable() {                  @Override                 public void run() {                     synchronized (mutex) {                         publication.cancel("timed out after " + publishTimeout).                     }                 }                  @Override                 public String toString() {                     return "scheduled timeout for " + publication.                 }             }, publishTimeout, Names.GENERIC).             final DiscoveryNodes publishNodes = publishRequest.getAcceptedState().nodes().             leaderChecker.setCurrentNodes(publishNodes).             followersChecker.setCurrentNodes(publishNodes).             lagDetector.setTrackedNodes(publishNodes).             publication.start(followersChecker.getFaultyNodes()).         }     } catch (Exception e) {         logger.debug(() -> new ParameterizedMessage("[{}] publishing failed", clusterChangedEvent.source()), e).         publishListener.onFailure(new FailedToCommitClusterStateException("publishing failed", e)).     } }
true;private;1;13;// deserialized from the resulting JSON ;// there is no equals on cluster state, so we just serialize it to XContent and compare Maps // deserialized from the resulting JSON private boolean assertPreviousStateConsistency(ClusterChangedEvent event) {     assert event.previousState() == coordinationState.get().getLastAcceptedState() || XContentHelper.convertToMap(JsonXContent.jsonXContent, Strings.toString(event.previousState()), false).equals(XContentHelper.convertToMap(JsonXContent.jsonXContent, Strings.toString(clusterStateWithNoMasterBlock(coordinationState.get().getLastAcceptedState())), false)) : Strings.toString(event.previousState()) + " vs " + Strings.toString(clusterStateWithNoMasterBlock(coordinationState.get().getLastAcceptedState())).     return true. }
false;public;1;6;;@Override public void onResponse(T t) {     synchronized (mutex) {         listener.onResponse(t).     } }
false;public;1;6;;@Override public void onFailure(Exception e) {     synchronized (mutex) {         listener.onFailure(e).     } }
false;private;1;17;;private <T> ActionListener<T> wrapWithMutex(ActionListener<T> listener) {     return new ActionListener<T>() {          @Override         public void onResponse(T t) {             synchronized (mutex) {                 listener.onResponse(t).             }         }          @Override         public void onFailure(Exception e) {             synchronized (mutex) {                 listener.onFailure(e).             }         }     }. }
false;private;1;6;;private void cancelActivePublication(String reason) {     assert Thread.holdsLock(mutex) : "Coordinator mutex not held".     if (currentPublication.isPresent()) {         currentPublication.get().cancel(reason).     } }
false;protected;2;7;;@Override protected void onActiveMasterFound(DiscoveryNode masterNode, long term) {     synchronized (mutex) {         ensureTermAtLeast(masterNode, term).         joinHelper.sendJoinRequest(masterNode, joinWithDestination(lastJoin, masterNode, term)).     } }
false;protected;0;23;;@Override protected void onFoundPeersUpdated() {     synchronized (mutex) {         final Iterable<DiscoveryNode> foundPeers = getFoundPeers().         if (mode == Mode.CANDIDATE) {             final CoordinationState.VoteCollection expectedVotes = new CoordinationState.VoteCollection().             foundPeers.forEach(expectedVotes::addVote).             expectedVotes.addVote(Coordinator.this.getLocalNode()).             final ClusterState lastAcceptedState = coordinationState.get().getLastAcceptedState().             final boolean foundQuorum = CoordinationState.isElectionQuorum(expectedVotes, lastAcceptedState).             if (foundQuorum) {                 if (electionScheduler == null) {                     startElectionScheduler().                 }             } else {                 closePrevotingAndElectionScheduler().             }         }     }     clusterBootstrapService.onFoundPeersUpdated(). }
false;public;0;22;;@Override public void run() {     synchronized (mutex) {         if (mode == Mode.CANDIDATE) {             final ClusterState lastAcceptedState = coordinationState.get().getLastAcceptedState().             if (electionQuorumContainsLocalNode(lastAcceptedState) == false) {                 logger.trace("skip prevoting as local node is not part of election quorum: {}", lastAcceptedState.coordinationMetaData()).                 return.             }             if (prevotingRound != null) {                 prevotingRound.close().             }             final List<DiscoveryNode> discoveredNodes = getDiscoveredNodes().stream().filter(n -> isZen1Node(n) == false).collect(Collectors.toList()).             prevotingRound = preVoteCollector.start(lastAcceptedState, discoveredNodes).         }     } }
false;public;0;4;;@Override public String toString() {     return "scheduling of new prevoting round". }
false;private;0;38;;private void startElectionScheduler() {     assert electionScheduler == null : electionScheduler.     if (getLocalNode().isMasterNode() == false) {         return.     }     // TODO variable grace period     final TimeValue gracePeriod = TimeValue.ZERO.     electionScheduler = electionSchedulerFactory.startElectionScheduler(gracePeriod, new Runnable() {          @Override         public void run() {             synchronized (mutex) {                 if (mode == Mode.CANDIDATE) {                     final ClusterState lastAcceptedState = coordinationState.get().getLastAcceptedState().                     if (electionQuorumContainsLocalNode(lastAcceptedState) == false) {                         logger.trace("skip prevoting as local node is not part of election quorum: {}", lastAcceptedState.coordinationMetaData()).                         return.                     }                     if (prevotingRound != null) {                         prevotingRound.close().                     }                     final List<DiscoveryNode> discoveredNodes = getDiscoveredNodes().stream().filter(n -> isZen1Node(n) == false).collect(Collectors.toList()).                     prevotingRound = preVoteCollector.start(lastAcceptedState, discoveredNodes).                 }             }         }          @Override         public String toString() {             return "scheduling of new prevoting round".         }     }). }
false;public;0;4;;public Iterable<DiscoveryNode> getFoundPeers() {     // TODO everyone takes this and adds the local node. Maybe just add the local node here?     return peerFinder.getFoundPeers(). }
true;;0;9;/**  * If there is any current committed publication, this method cancels it.  * This method is used exclusively by tests.  * @return true if publication was cancelled, false if there is no current committed publication.  */ ;/**  * If there is any current committed publication, this method cancels it.  * This method is used exclusively by tests.  * @return true if publication was cancelled, false if there is no current committed publication.  */ boolean cancelCommittedPublication() {     synchronized (mutex) {         if (currentPublication.isPresent() && currentPublication.get().isCommitted()) {             currentPublication.get().cancel("cancelCommittedPublication").             return true.         }         return false.     } }
false;public;1;4;;@Override public void onCommit(TimeValue commitTime) {     ackListener.onCommit(commitTime). }
false;public;2;18;;@Override public void onNodeAck(DiscoveryNode node, Exception e) {     // acking and cluster state application for local node is handled specially     if (node.equals(getLocalNode())) {         synchronized (mutex) {             if (e == null) {                 localNodeAckEvent.onResponse(null).             } else {                 localNodeAckEvent.onFailure(e).             }         }     } else {         ackListener.onNodeAck(node, e).         if (e == null) {             lagDetector.setAppliedVersion(node, publishRequest.getAcceptedState().version()).         }     } }
false;private;1;12;;private void removePublicationAndPossiblyBecomeCandidate(String reason) {     assert Thread.holdsLock(mutex) : "Coordinator mutex not held".     assert currentPublication.get() == this.     currentPublication = Optional.empty().     logger.debug("publication ended unsuccessfully: {}", this).     // check if node has not already switched modes (by bumping term)     if (isActiveForCurrentLeader()) {         becomeCandidate(reason).     } }
false;;0;4;;boolean isActiveForCurrentLeader() {     // checks if this publication can still influence the mode of the current publication     return mode == Mode.LEADER && publishRequest.getAcceptedState().term() == getCurrentTerm(). }
false;public;2;8;;@Override public void onFailure(String source, Exception e) {     synchronized (mutex) {         removePublicationAndPossiblyBecomeCandidate("clusterApplier#onNewClusterState").     }     ackListener.onNodeAck(getLocalNode(), e).     publishListener.onFailure(e). }
false;public;1;28;;@Override public void onSuccess(String source) {     synchronized (mutex) {         assert currentPublication.get() == CoordinatorPublication.this.         currentPublication = Optional.empty().         logger.debug("publication ended successfully: {}", CoordinatorPublication.this).         // trigger term bump if new term was found during publication         updateMaxTermSeen(getCurrentTerm()).         if (mode == Mode.LEADER) {             // committed state             final ClusterState state = getLastAcceptedState().             if (electionQuorumContainsLocalNode(state) == false) {                 final List<DiscoveryNode> masterCandidates = completedNodes().stream().filter(DiscoveryNode::isMasterNode).filter(node -> electionQuorumContains(state, node)).collect(Collectors.toList()).                 if (masterCandidates.isEmpty() == false) {                     abdicateTo(masterCandidates.get(random.nextInt(masterCandidates.size()))).                 }             } else {                 scheduleReconfigurationIfNeeded().             }         }         lagDetector.startLagDetector(publishRequest.getAcceptedState().version()).     }     ackListener.onNodeAck(getLocalNode(), null).     publishListener.onResponse(null). }
false;public;1;50;;@Override public void onResponse(Void ignore) {     assert Thread.holdsLock(mutex) : "Coordinator mutex not held".     assert committed.     receivedJoins.forEach(CoordinatorPublication.this::handleAssociatedJoin).     assert receivedJoinsProcessed == false.     receivedJoinsProcessed = true.     clusterApplier.onNewClusterState(CoordinatorPublication.this.toString(), () -> applierState, new ClusterApplyListener() {          @Override         public void onFailure(String source, Exception e) {             synchronized (mutex) {                 removePublicationAndPossiblyBecomeCandidate("clusterApplier#onNewClusterState").             }             ackListener.onNodeAck(getLocalNode(), e).             publishListener.onFailure(e).         }          @Override         public void onSuccess(String source) {             synchronized (mutex) {                 assert currentPublication.get() == CoordinatorPublication.this.                 currentPublication = Optional.empty().                 logger.debug("publication ended successfully: {}", CoordinatorPublication.this).                 // trigger term bump if new term was found during publication                 updateMaxTermSeen(getCurrentTerm()).                 if (mode == Mode.LEADER) {                     // committed state                     final ClusterState state = getLastAcceptedState().                     if (electionQuorumContainsLocalNode(state) == false) {                         final List<DiscoveryNode> masterCandidates = completedNodes().stream().filter(DiscoveryNode::isMasterNode).filter(node -> electionQuorumContains(state, node)).collect(Collectors.toList()).                         if (masterCandidates.isEmpty() == false) {                             abdicateTo(masterCandidates.get(random.nextInt(masterCandidates.size()))).                         }                     } else {                         scheduleReconfigurationIfNeeded().                     }                 }                 lagDetector.startLagDetector(publishRequest.getAcceptedState().version()).             }             ackListener.onNodeAck(getLocalNode(), null).             publishListener.onResponse(null).         }     }). }
false;public;1;9;;@Override public void onFailure(Exception e) {     assert Thread.holdsLock(mutex) : "Coordinator mutex not held".     removePublicationAndPossiblyBecomeCandidate("Publication.onCompletion(false)").     final FailedToCommitClusterStateException exception = new FailedToCommitClusterStateException("publication failed", e).     // other nodes have acked, but not the master.     ackListener.onNodeAck(getLocalNode(), exception).     publishListener.onFailure(exception). }
false;protected;1;67;;@Override protected void onCompletion(boolean committed) {     assert Thread.holdsLock(mutex) : "Coordinator mutex not held".     localNodeAckEvent.addListener(new ActionListener<Void>() {          @Override         public void onResponse(Void ignore) {             assert Thread.holdsLock(mutex) : "Coordinator mutex not held".             assert committed.             receivedJoins.forEach(CoordinatorPublication.this::handleAssociatedJoin).             assert receivedJoinsProcessed == false.             receivedJoinsProcessed = true.             clusterApplier.onNewClusterState(CoordinatorPublication.this.toString(), () -> applierState, new ClusterApplyListener() {                  @Override                 public void onFailure(String source, Exception e) {                     synchronized (mutex) {                         removePublicationAndPossiblyBecomeCandidate("clusterApplier#onNewClusterState").                     }                     ackListener.onNodeAck(getLocalNode(), e).                     publishListener.onFailure(e).                 }                  @Override                 public void onSuccess(String source) {                     synchronized (mutex) {                         assert currentPublication.get() == CoordinatorPublication.this.                         currentPublication = Optional.empty().                         logger.debug("publication ended successfully: {}", CoordinatorPublication.this).                         // trigger term bump if new term was found during publication                         updateMaxTermSeen(getCurrentTerm()).                         if (mode == Mode.LEADER) {                             // committed state                             final ClusterState state = getLastAcceptedState().                             if (electionQuorumContainsLocalNode(state) == false) {                                 final List<DiscoveryNode> masterCandidates = completedNodes().stream().filter(DiscoveryNode::isMasterNode).filter(node -> electionQuorumContains(state, node)).collect(Collectors.toList()).                                 if (masterCandidates.isEmpty() == false) {                                     abdicateTo(masterCandidates.get(random.nextInt(masterCandidates.size()))).                                 }                             } else {                                 scheduleReconfigurationIfNeeded().                             }                         }                         lagDetector.startLagDetector(publishRequest.getAcceptedState().version()).                     }                     ackListener.onNodeAck(getLocalNode(), null).                     publishListener.onResponse(null).                 }             }).         }          @Override         public void onFailure(Exception e) {             assert Thread.holdsLock(mutex) : "Coordinator mutex not held".             removePublicationAndPossiblyBecomeCandidate("Publication.onCompletion(false)").             final FailedToCommitClusterStateException exception = new FailedToCommitClusterStateException("publication failed", e).             // other nodes have acked, but not the master.             ackListener.onNodeAck(getLocalNode(), exception).             publishListener.onFailure(exception).         }     }, EsExecutors.newDirectExecutorService(), transportService.getThreadPool().getThreadContext()). }
false;private;1;6;;private void handleAssociatedJoin(Join join) {     if (join.getTerm() == getCurrentTerm() && hasJoinVoteFrom(join.getSourceNode()) == false) {         logger.trace("handling {}", join).         handleJoin(join).     } }
false;protected;1;5;;@Override protected boolean isPublishQuorum(CoordinationState.VoteCollection votes) {     assert Thread.holdsLock(mutex) : "Coordinator mutex not held".     return coordinationState.get().isPublishQuorum(votes). }
false;protected;2;7;;@Override protected Optional<ApplyCommitRequest> handlePublishResponse(DiscoveryNode sourceNode, PublishResponse publishResponse) {     assert Thread.holdsLock(mutex) : "Coordinator mutex not held".     assert getCurrentTerm() >= publishResponse.getTerm().     return coordinationState.get().handlePublishResponse(sourceNode, publishResponse). }
false;protected;1;11;;@Override protected void onJoin(Join join) {     assert Thread.holdsLock(mutex) : "Coordinator mutex not held".     if (receivedJoinsProcessed) {         // a late response may arrive after the state has been locally applied, meaning that receivedJoins has already been         // processed, so we have to handle this late response here.         handleAssociatedJoin(join).     } else {         receivedJoins.add(join).     } }
false;protected;1;12;;@Override protected void onMissingJoin(DiscoveryNode discoveryNode) {     assert Thread.holdsLock(mutex) : "Coordinator mutex not held".     // of a join from this node then we assume the latter and bump our term to obtain a vote from this node.     if (hasJoinVoteFrom(discoveryNode) == false) {         final long term = publishRequest.getAcceptedState().term().         logger.debug("onMissingJoin: no join vote from {}, bumping term to exceed {}", discoveryNode, term).         updateMaxTermSeen(term + 1).     } }
false;protected;3;5;;@Override protected void sendPublishRequest(DiscoveryNode destination, PublishRequest publishRequest, ActionListener<PublishWithJoinResponse> responseActionListener) {     publicationContext.sendPublishRequest(destination, publishRequest, wrapWithMutex(responseActionListener)). }
false;protected;3;5;;@Override protected void sendApplyCommit(DiscoveryNode destination, ApplyCommitRequest applyCommit, ActionListener<Empty> responseActionListener) {     publicationContext.sendApplyCommit(destination, applyCommit, wrapWithMutex(responseActionListener)). }
true;public,static;2;3;// TODO: only here temporarily for BWC development, remove once complete ;// TODO: only here temporarily for BWC development, remove once complete public static Settings.Builder addZen1Attribute(boolean isZen1Node, Settings.Builder builder) {     return builder.put("node.attr.zen1", isZen1Node). }
true;public,static;1;4;// TODO: only here temporarily for BWC development, remove once complete ;// TODO: only here temporarily for BWC development, remove once complete public static boolean isZen1Node(DiscoveryNode discoveryNode) {     return discoveryNode.getVersion().before(Version.V_7_0_0) || (Booleans.isTrue(discoveryNode.getAttributes().getOrDefault("zen1", "false"))). }
