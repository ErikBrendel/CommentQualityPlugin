commented;modifiers;parameterAmount;loc;comment;code
false;protected;2;17;;@Override protected XContentBuilder doXContentBody(XContentBuilder builder, Params params) throws IOException {     if (keyed) {         builder.startObject(CommonFields.BUCKETS.getPreferredName()).     } else {         builder.startArray(CommonFields.BUCKETS.getPreferredName()).     }     for (B bucket : buckets) {         bucket.toXContent(builder, params).     }     if (keyed) {         builder.endObject().     } else {         builder.endArray().     }     return builder. }
false;protected,static;3;19;;protected static void declareMultiBucketAggregationFields(final ObjectParser<? extends ParsedMultiBucketAggregation, Void> objectParser, final CheckedFunction<XContentParser, ParsedBucket, IOException> bucketParser, final CheckedFunction<XContentParser, ParsedBucket, IOException> keyedBucketParser) {     declareAggregationFields(objectParser).     objectParser.declareField((parser, aggregation, context) -> {         XContentParser.Token token = parser.currentToken().         if (token == XContentParser.Token.START_OBJECT) {             aggregation.keyed = true.             while (parser.nextToken() != XContentParser.Token.END_OBJECT) {                 aggregation.buckets.add(keyedBucketParser.apply(parser)).             }         } else if (token == XContentParser.Token.START_ARRAY) {             aggregation.keyed = false.             while (parser.nextToken() != XContentParser.Token.END_ARRAY) {                 aggregation.buckets.add(bucketParser.apply(parser)).             }         }     }, CommonFields.BUCKETS, ObjectParser.ValueType.OBJECT_ARRAY). }
false;protected;1;3;;protected void setKeyAsString(String keyAsString) {     this.keyAsString = keyAsString. }
false;public;0;4;;@Override public String getKeyAsString() {     return keyAsString. }
false;protected;1;3;;protected void setDocCount(long docCount) {     this.docCount = docCount. }
false;public;0;4;;@Override public long getDocCount() {     return docCount. }
false;public;1;3;;public void setKeyed(boolean keyed) {     this.keyed = keyed. }
false;protected;0;3;;protected boolean isKeyed() {     return keyed. }
false;protected;1;3;;protected void setAggregations(Aggregations aggregations) {     this.aggregations = aggregations. }
false;public;0;4;;@Override public Aggregations getAggregations() {     return aggregations. }
false;public;2;19;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     if (keyed) {         // Subclasses can override the getKeyAsString method to handle specific cases like         // keyed bucket with RAW doc value format where the key_as_string field is not printed         // out but we still need to have a string version of the key to use as the bucket's name.         builder.startObject(getKeyAsString()).     } else {         builder.startObject().     }     if (keyAsString != null) {         builder.field(CommonFields.KEY_AS_STRING.getPreferredName(), getKeyAsString()).     }     keyToXContent(builder).     builder.field(CommonFields.DOC_COUNT.getPreferredName(), docCount).     aggregations.toXContentInternal(builder, params).     builder.endObject().     return builder. }
false;protected;1;3;;protected XContentBuilder keyToXContent(XContentBuilder builder) throws IOException {     return builder.field(CommonFields.KEY.getPreferredName(), getKey()). }
false;protected,static;4;38;;protected static <B extends ParsedBucket> B parseXContent(final XContentParser parser, final boolean keyed, final Supplier<B> bucketSupplier, final CheckedBiConsumer<XContentParser, B, IOException> keyConsumer) throws IOException {     final B bucket = bucketSupplier.get().     bucket.setKeyed(keyed).     XContentParser.Token token = parser.currentToken().     String currentFieldName = parser.currentName().     if (keyed) {         ensureExpectedToken(XContentParser.Token.FIELD_NAME, token, parser::getTokenLocation).         ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation).     }     List<Aggregation> aggregations = new ArrayList<>().     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (token.isValue()) {             if (CommonFields.KEY_AS_STRING.getPreferredName().equals(currentFieldName)) {                 bucket.setKeyAsString(parser.text()).             } else if (CommonFields.KEY.getPreferredName().equals(currentFieldName)) {                 keyConsumer.accept(parser, bucket).             } else if (CommonFields.DOC_COUNT.getPreferredName().equals(currentFieldName)) {                 bucket.setDocCount(parser.longValue()).             }         } else if (token == XContentParser.Token.START_OBJECT) {             if (CommonFields.KEY.getPreferredName().equals(currentFieldName)) {                 keyConsumer.accept(parser, bucket).             } else {                 XContentParserUtils.parseTypedKeysObject(parser, Aggregation.TYPED_KEYS_DELIMITER, Aggregation.class, aggregations::add).             }         }     }     bucket.setAggregations(new Aggregations(aggregations)).     return bucket. }
