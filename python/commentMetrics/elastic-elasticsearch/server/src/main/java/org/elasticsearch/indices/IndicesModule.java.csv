commented;modifiers;parameterAmount;loc;comment;code
false;private;0;5;;private void registerBuiltinWritables() {     namedWritables.add(new NamedWriteableRegistry.Entry(Condition.class, MaxAgeCondition.NAME, MaxAgeCondition::new)).     namedWritables.add(new NamedWriteableRegistry.Entry(Condition.class, MaxDocsCondition.NAME, MaxDocsCondition::new)).     namedWritables.add(new NamedWriteableRegistry.Entry(Condition.class, MaxSizeCondition.NAME, MaxSizeCondition::new)). }
false;public;0;3;;public List<NamedWriteableRegistry.Entry> getNamedWriteables() {     return namedWritables. }
false;public;0;10;;public List<NamedXContentRegistry.Entry> getNamedXContents() {     return Arrays.asList(new NamedXContentRegistry.Entry(Condition.class, new ParseField(MaxAgeCondition.NAME), (p, c) -> MaxAgeCondition.fromXContent(p)), new NamedXContentRegistry.Entry(Condition.class, new ParseField(MaxDocsCondition.NAME), (p, c) -> MaxDocsCondition.fromXContent(p)), new NamedXContentRegistry.Entry(Condition.class, new ParseField(MaxSizeCondition.NAME), (p, c) -> MaxSizeCondition.fromXContent(p))). }
false;private;1;35;;private Map<String, Mapper.TypeParser> getMappers(List<MapperPlugin> mapperPlugins) {     Map<String, Mapper.TypeParser> mappers = new LinkedHashMap<>().     // builtin mappers     for (NumberFieldMapper.NumberType type : NumberFieldMapper.NumberType.values()) {         mappers.put(type.typeName(), new NumberFieldMapper.TypeParser(type)).     }     for (RangeFieldMapper.RangeType type : RangeFieldMapper.RangeType.values()) {         mappers.put(type.typeName(), new RangeFieldMapper.TypeParser(type)).     }     mappers.put(BooleanFieldMapper.CONTENT_TYPE, new BooleanFieldMapper.TypeParser()).     mappers.put(BinaryFieldMapper.CONTENT_TYPE, new BinaryFieldMapper.TypeParser()).     DateFieldMapper.Resolution milliseconds = DateFieldMapper.Resolution.MILLISECONDS.     mappers.put(milliseconds.type(), new DateFieldMapper.TypeParser(milliseconds)).     DateFieldMapper.Resolution nanoseconds = DateFieldMapper.Resolution.NANOSECONDS.     mappers.put(nanoseconds.type(), new DateFieldMapper.TypeParser(nanoseconds)).     mappers.put(IpFieldMapper.CONTENT_TYPE, new IpFieldMapper.TypeParser()).     mappers.put(TextFieldMapper.CONTENT_TYPE, new TextFieldMapper.TypeParser()).     mappers.put(KeywordFieldMapper.CONTENT_TYPE, new KeywordFieldMapper.TypeParser()).     mappers.put(ObjectMapper.CONTENT_TYPE, new ObjectMapper.TypeParser()).     mappers.put(ObjectMapper.NESTED_CONTENT_TYPE, new ObjectMapper.TypeParser()).     mappers.put(CompletionFieldMapper.CONTENT_TYPE, new CompletionFieldMapper.TypeParser()).     mappers.put(FieldAliasMapper.CONTENT_TYPE, new FieldAliasMapper.TypeParser()).     mappers.put(GeoPointFieldMapper.CONTENT_TYPE, new GeoPointFieldMapper.TypeParser()).     mappers.put(BaseGeoShapeFieldMapper.CONTENT_TYPE, new BaseGeoShapeFieldMapper.TypeParser()).     for (MapperPlugin mapperPlugin : mapperPlugins) {         for (Map.Entry<String, Mapper.TypeParser> entry : mapperPlugin.getMappers().entrySet()) {             if (mappers.put(entry.getKey(), entry.getValue()) != null) {                 throw new IllegalArgumentException("Mapper [" + entry.getKey() + "] is already registered").             }         }     }     return Collections.unmodifiableMap(mappers). }
false;private,static;0;19;;private static Map<String, MetadataFieldMapper.TypeParser> initBuiltInMetadataMappers() {     Map<String, MetadataFieldMapper.TypeParser> builtInMetadataMappers.     // Use a LinkedHashMap for metadataMappers because iteration order matters     builtInMetadataMappers = new LinkedHashMap<>().     // _ignored first so that we always load it, even if only _id is requested     builtInMetadataMappers.put(IgnoredFieldMapper.NAME, new IgnoredFieldMapper.TypeParser()).     // ID second so it will be the first (if no ignored fields) stored field to load     // (so will benefit from "fields: []" early termination     builtInMetadataMappers.put(IdFieldMapper.NAME, new IdFieldMapper.TypeParser()).     builtInMetadataMappers.put(RoutingFieldMapper.NAME, new RoutingFieldMapper.TypeParser()).     builtInMetadataMappers.put(IndexFieldMapper.NAME, new IndexFieldMapper.TypeParser()).     builtInMetadataMappers.put(SourceFieldMapper.NAME, new SourceFieldMapper.TypeParser()).     builtInMetadataMappers.put(TypeFieldMapper.NAME, new TypeFieldMapper.TypeParser()).     builtInMetadataMappers.put(VersionFieldMapper.NAME, new VersionFieldMapper.TypeParser()).     builtInMetadataMappers.put(SeqNoFieldMapper.NAME, new SeqNoFieldMapper.TypeParser()).     // _field_names must be added last so that it has a chance to see all the other mappers     builtInMetadataMappers.put(FieldNamesFieldMapper.NAME, new FieldNamesFieldMapper.TypeParser()).     return Collections.unmodifiableMap(builtInMetadataMappers). }
false;private,static;1;31;;private static Map<String, MetadataFieldMapper.TypeParser> getMetadataMappers(List<MapperPlugin> mapperPlugins) {     Map<String, MetadataFieldMapper.TypeParser> metadataMappers = new LinkedHashMap<>().     int i = 0.     Map.Entry<String, MetadataFieldMapper.TypeParser> fieldNamesEntry = null.     for (Map.Entry<String, MetadataFieldMapper.TypeParser> entry : builtInMetadataMappers.entrySet()) {         if (i < builtInMetadataMappers.size() - 1) {             metadataMappers.put(entry.getKey(), entry.getValue()).         } else {             assert entry.getKey().equals(FieldNamesFieldMapper.NAME) : "_field_names must be the last registered mapper, order counts".             fieldNamesEntry = entry.         }         i++.     }     assert fieldNamesEntry != null.     for (MapperPlugin mapperPlugin : mapperPlugins) {         for (Map.Entry<String, MetadataFieldMapper.TypeParser> entry : mapperPlugin.getMetadataMappers().entrySet()) {             if (entry.getKey().equals(FieldNamesFieldMapper.NAME)) {                 throw new IllegalArgumentException("Plugin cannot contain metadata mapper [" + FieldNamesFieldMapper.NAME + "]").             }             if (metadataMappers.put(entry.getKey(), entry.getValue()) != null) {                 throw new IllegalArgumentException("MetadataFieldMapper [" + entry.getKey() + "] is already registered").             }         }     }     // we register _field_names here so that it has a chance to see all the other mappers, including from plugins     metadataMappers.put(fieldNamesEntry.getKey(), fieldNamesEntry.getValue()).     return Collections.unmodifiableMap(metadataMappers). }
true;public,static;0;3;/**  * Returns a set containing all of the builtin metadata fields  */ ;/**  * Returns a set containing all of the builtin metadata fields  */ public static Set<String> getBuiltInMetaDataFields() {     return builtInMetadataMappers.keySet(). }
false;private,static;1;7;;private static Function<String, Predicate<String>> getFieldFilter(List<MapperPlugin> mapperPlugins) {     Function<String, Predicate<String>> fieldFilter = MapperPlugin.NOOP_FIELD_FILTER.     for (MapperPlugin mapperPlugin : mapperPlugins) {         fieldFilter = and(fieldFilter, mapperPlugin.getFieldFilter()).     }     return fieldFilter. }
false;private,static;2;22;;private static Function<String, Predicate<String>> and(Function<String, Predicate<String>> first, Function<String, Predicate<String>> second) {     // a field filter, hence skip the mappings filtering part as a whole, as it requires parsing mappings into a map.     if (first == MapperPlugin.NOOP_FIELD_FILTER) {         return second.     }     if (second == MapperPlugin.NOOP_FIELD_FILTER) {         return first.     }     return index -> {         Predicate<String> firstPredicate = first.apply(index).         Predicate<String> secondPredicate = second.apply(index).         if (firstPredicate == MapperPlugin.NOOP_FIELD_PREDICATE) {             return secondPredicate.         }         if (secondPredicate == MapperPlugin.NOOP_FIELD_PREDICATE) {             return firstPredicate.         }         return firstPredicate.and(secondPredicate).     }. }
false;protected;0;10;;@Override protected void configure() {     bind(IndicesStore.class).asEagerSingleton().     bind(IndicesClusterStateService.class).asEagerSingleton().     bind(SyncedFlushService.class).asEagerSingleton().     bind(TransportNodesListShardStoreMetaData.class).asEagerSingleton().     bind(GlobalCheckpointSyncAction.class).asEagerSingleton().     bind(TransportResyncReplicationAction.class).asEagerSingleton().     bind(PrimaryReplicaSyncer.class).asEagerSingleton(). }
true;public;0;3;/**  * A registry for all field mappers.  */ ;/**  * A registry for all field mappers.  */ public MapperRegistry getMapperRegistry() {     return mapperRegistry. }
false;public;0;3;;public Collection<Function<IndexSettings, Optional<EngineFactory>>> getEngineFactories() {     return Collections.emptyList(). }
