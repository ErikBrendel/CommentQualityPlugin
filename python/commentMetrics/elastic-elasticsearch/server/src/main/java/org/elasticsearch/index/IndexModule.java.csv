commented;modifiers;parameterAmount;loc;comment;code
true;public;2;7;/**  * Adds a Setting and it's consumer for this index.  */ ;/**  * Adds a Setting and it's consumer for this index.  */ public <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer) {     ensureNotFrozen().     if (setting == null) {         throw new IllegalArgumentException("setting must not be null").     }     indexSettings.getScopedSettings().addSettingsUpdateConsumer(setting, consumer). }
true;public;3;7;/**  * Adds a Setting, it's consumer and validator for this index.  */ ;/**  * Adds a Setting, it's consumer and validator for this index.  */ public <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer, Consumer<T> validator) {     ensureNotFrozen().     if (setting == null) {         throw new IllegalArgumentException("setting must not be null").     }     indexSettings.getScopedSettings().addSettingsUpdateConsumer(setting, consumer, validator). }
true;public;0;3;/**  * Returns the index {@link Settings} for this index  */ ;/**  * Returns the index {@link Settings} for this index  */ public Settings getSettings() {     return indexSettings.getSettings(). }
true;public;0;3;/**  * Returns the index this module is associated with  */ ;/**  * Returns the index this module is associated with  */ public Index getIndex() {     return indexSettings.getIndex(). }
true;;0;3;/**  * The engine factory provided during construction of this index module.  *  * @return the engine factory  */ ;/**  * The engine factory provided during construction of this index module.  *  * @return the engine factory  */ EngineFactory getEngineFactory() {     return engineFactory. }
true;public;1;11;/**  * Adds an {@link IndexEventListener} for this index. All listeners added here  * are maintained for the entire index lifecycle on this node. Once an index is closed or deleted these  * listeners go out of scope.  * <p>  * Note: an index might be created on a node multiple times. For instance if the last shard from an index is  * relocated to another node the internal representation will be destroyed which includes the registered listeners.  * Once the node holds at least one shard of an index all modules are reloaded and listeners are registered again.  * Listeners can't be unregistered they will stay alive for the entire time the index is allocated on a node.  * </p>  */ ;/**  * Adds an {@link IndexEventListener} for this index. All listeners added here  * are maintained for the entire index lifecycle on this node. Once an index is closed or deleted these  * listeners go out of scope.  * <p>  * Note: an index might be created on a node multiple times. For instance if the last shard from an index is  * relocated to another node the internal representation will be destroyed which includes the registered listeners.  * Once the node holds at least one shard of an index all modules are reloaded and listeners are registered again.  * Listeners can't be unregistered they will stay alive for the entire time the index is allocated on a node.  * </p>  */ public void addIndexEventListener(IndexEventListener listener) {     ensureNotFrozen().     if (listener == null) {         throw new IllegalArgumentException("listener must not be null").     }     if (indexEventListeners.contains(listener)) {         throw new IllegalArgumentException("listener already added").     }     this.indexEventListeners.add(listener). }
true;public;1;11;/**  * Adds an {@link SearchOperationListener} for this index. All listeners added here  * are maintained for the entire index lifecycle on this node. Once an index is closed or deleted these  * listeners go out of scope.  * <p>  * Note: an index might be created on a node multiple times. For instance if the last shard from an index is  * relocated to another node the internal representation will be destroyed which includes the registered listeners.  * Once the node holds at least one shard of an index all modules are reloaded and listeners are registered again.  * Listeners can't be unregistered they will stay alive for the entire time the index is allocated on a node.  * </p>  */ ;/**  * Adds an {@link SearchOperationListener} for this index. All listeners added here  * are maintained for the entire index lifecycle on this node. Once an index is closed or deleted these  * listeners go out of scope.  * <p>  * Note: an index might be created on a node multiple times. For instance if the last shard from an index is  * relocated to another node the internal representation will be destroyed which includes the registered listeners.  * Once the node holds at least one shard of an index all modules are reloaded and listeners are registered again.  * Listeners can't be unregistered they will stay alive for the entire time the index is allocated on a node.  * </p>  */ public void addSearchOperationListener(SearchOperationListener listener) {     ensureNotFrozen().     if (listener == null) {         throw new IllegalArgumentException("listener must not be null").     }     if (searchOperationListeners.contains(listener)) {         throw new IllegalArgumentException("listener already added").     }     this.searchOperationListeners.add(listener). }
true;public;1;11;/**  * Adds an {@link IndexingOperationListener} for this index. All listeners added here  * are maintained for the entire index lifecycle on this node. Once an index is closed or deleted these  * listeners go out of scope.  * <p>  * Note: an index might be created on a node multiple times. For instance if the last shard from an index is  * relocated to another node the internal representation will be destroyed which includes the registered listeners.  * Once the node holds at least one shard of an index all modules are reloaded and listeners are registered again.  * Listeners can't be unregistered they will stay alive for the entire time the index is allocated on a node.  * </p>  */ ;/**  * Adds an {@link IndexingOperationListener} for this index. All listeners added here  * are maintained for the entire index lifecycle on this node. Once an index is closed or deleted these  * listeners go out of scope.  * <p>  * Note: an index might be created on a node multiple times. For instance if the last shard from an index is  * relocated to another node the internal representation will be destroyed which includes the registered listeners.  * Once the node holds at least one shard of an index all modules are reloaded and listeners are registered again.  * Listeners can't be unregistered they will stay alive for the entire time the index is allocated on a node.  * </p>  */ public void addIndexOperationListener(IndexingOperationListener listener) {     ensureNotFrozen().     if (listener == null) {         throw new IllegalArgumentException("listener must not be null").     }     if (indexOperationListeners.contains(listener)) {         throw new IllegalArgumentException("listener already added").     }     this.indexOperationListeners.add(listener). }
true;public;2;7;/**  * Registers the given {@link Similarity} with the given name.  * The function takes as parameters:<ul>  *   <li>settings for this similarity  *   <li>version of Elasticsearch when the index was created  *   <li>ScriptService, for script-based similarities  * </ul>  *  * @param name Name of the SimilarityProvider  * @param similarity SimilarityProvider to register  */ ;/**  * Registers the given {@link Similarity} with the given name.  * The function takes as parameters:<ul>  *   <li>settings for this similarity  *   <li>version of Elasticsearch when the index was created  *   <li>ScriptService, for script-based similarities  * </ul>  *  * @param name Name of the SimilarityProvider  * @param similarity SimilarityProvider to register  */ public void addSimilarity(String name, TriFunction<Settings, Version, ScriptService, Similarity> similarity) {     ensureNotFrozen().     if (similarities.containsKey(name) || SimilarityService.BUILT_IN.containsKey(name)) {         throw new IllegalArgumentException("similarity for name: [" + name + " is already registered").     }     similarities.put(name, similarity). }
true;public;1;4;/**  * Sets a {@link org.elasticsearch.index.IndexModule.IndexSearcherWrapperFactory} that is called once the IndexService  * is fully constructed.  * Note: this method can only be called once per index. Multiple wrappers are not supported.  */ ;/**  * Sets a {@link org.elasticsearch.index.IndexModule.IndexSearcherWrapperFactory} that is called once the IndexService  * is fully constructed.  * Note: this method can only be called once per index. Multiple wrappers are not supported.  */ public void setSearcherWrapper(IndexSearcherWrapperFactory indexSearcherWrapperFactory) {     ensureNotFrozen().     this.indexSearcherWrapper.set(indexSearcherWrapperFactory). }
false;;0;7;;IndexEventListener freeze() {     // pkg private for testing     if (this.frozen.compareAndSet(false, true)) {         return new CompositeIndexEventListener(indexSettings, indexEventListeners).     } else {         throw new IllegalStateException("already frozen").     } }
false;public,static;1;8;;public static boolean isBuiltinType(String storeType) {     for (Type type : Type.values()) {         if (type.match(storeType)) {             return true.         }     }     return false. }
false;public;0;3;;public String getSettingsKey() {     return this.settingsKey. }
false;public,static;1;7;;public static Type fromSettingsKey(final String key) {     final Type type = TYPES.get(key).     if (type == null) {         throw new IllegalArgumentException("no matching store type for [" + key + "]").     }     return type. }
true;public;1;3;/**  * Returns true iff this settings matches the type.  */ ;/**  * Returns true iff this settings matches the type.  */ public boolean match(String setting) {     return getSettingsKey().equals(setting). }
true;;1;1;/**  * Returns a new IndexSearcherWrapper. This method is called once per index per node  */ ;/**  * Returns a new IndexSearcherWrapper. This method is called once per index per node  */ IndexSearcherWrapper newWrapper(IndexService indexService).
false;public,static;1;9;;public static Type defaultStoreType(final boolean allowMmap) {     if (allowMmap && Constants.JRE_IS_64BIT && MMapDirectory.UNMAP_SUPPORTED) {         return Type.HYBRIDFS.     } else if (Constants.WINDOWS) {         return Type.SIMPLEFS.     } else {         return Type.NIOFS.     } }
false;public;12;36;;public IndexService newIndexService(NodeEnvironment environment, NamedXContentRegistry xContentRegistry, IndexService.ShardStoreDeleter shardStoreDeleter, CircuitBreakerService circuitBreakerService, BigArrays bigArrays, ThreadPool threadPool, ScriptService scriptService, Client client, IndicesQueryCache indicesQueryCache, MapperRegistry mapperRegistry, IndicesFieldDataCache indicesFieldDataCache, NamedWriteableRegistry namedWriteableRegistry) throws IOException {     final IndexEventListener eventListener = freeze().     IndexSearcherWrapperFactory searcherWrapperFactory = indexSearcherWrapper.get() == null ? (shard) -> null : indexSearcherWrapper.get().     eventListener.beforeIndexCreated(indexSettings.getIndex(), indexSettings.getSettings()).     final IndexStore store = getIndexStore(indexSettings, indexStoreFactories).     final QueryCache queryCache.     if (indexSettings.getValue(INDEX_QUERY_CACHE_ENABLED_SETTING)) {         BiFunction<IndexSettings, IndicesQueryCache, QueryCache> queryCacheProvider = forceQueryCacheProvider.get().         if (queryCacheProvider == null) {             queryCache = new IndexQueryCache(indexSettings, indicesQueryCache).         } else {             queryCache = queryCacheProvider.apply(indexSettings, indicesQueryCache).         }     } else {         queryCache = new DisabledQueryCache(indexSettings).     }     return new IndexService(indexSettings, environment, xContentRegistry, new SimilarityService(indexSettings, scriptService, similarities), shardStoreDeleter, analysisRegistry, engineFactory, circuitBreakerService, bigArrays, threadPool, scriptService, client, queryCache, store, eventListener, searcherWrapperFactory, mapperRegistry, indicesFieldDataCache, searchOperationListeners, indexOperationListeners, namedWriteableRegistry). }
false;private,static;2;32;;private static IndexStore getIndexStore(final IndexSettings indexSettings, final Map<String, Function<IndexSettings, IndexStore>> indexStoreFactories) {     final String storeType = indexSettings.getValue(INDEX_STORE_TYPE_SETTING).     final Type type.     final Boolean allowMmap = NODE_STORE_ALLOW_MMAP.get(indexSettings.getNodeSettings()).     if (storeType.isEmpty() || Type.FS.getSettingsKey().equals(storeType)) {         type = defaultStoreType(allowMmap).     } else {         if (isBuiltinType(storeType)) {             type = Type.fromSettingsKey(storeType).         } else {             type = null.         }     }     if (allowMmap == false && (type == Type.MMAPFS || type == Type.HYBRIDFS)) {         throw new IllegalArgumentException("store type [" + storeType + "] is not allowed because mmap is disabled").     }     final IndexStore store.     if (storeType.isEmpty() || isBuiltinType(storeType)) {         store = new IndexStore(indexSettings).     } else {         Function<IndexSettings, IndexStore> factory = indexStoreFactories.get(storeType).         if (factory == null) {             throw new IllegalArgumentException("Unknown store type [" + storeType + "]").         }         store = factory.apply(indexSettings).         if (store == null) {             throw new IllegalStateException("store must not be null").         }     }     return store. }
true;public;3;6;/**  * creates a new mapper service to do administrative work like mapping updates. This *should not* be used for document parsing.  * doing so will result in an exception.  */ ;/**  * creates a new mapper service to do administrative work like mapping updates. This *should not* be used for document parsing.  * doing so will result in an exception.  */ public MapperService newIndexMapperService(NamedXContentRegistry xContentRegistry, MapperRegistry mapperRegistry, ScriptService scriptService) throws IOException {     return new MapperService(indexSettings, analysisRegistry.build(indexSettings), xContentRegistry, new SimilarityService(indexSettings, scriptService, similarities), mapperRegistry, () -> {         throw new UnsupportedOperationException("no index query shard context available").     }). }
true;public;1;4;/**  * Forces a certain query cache to use instead of the default one. If this is set  * and query caching is not disabled with {@code index.queries.cache.enabled}, then  * the given provider will be used.  * NOTE: this can only be set once  *  * @see #INDEX_QUERY_CACHE_ENABLED_SETTING  */ ;/**  * Forces a certain query cache to use instead of the default one. If this is set  * and query caching is not disabled with {@code index.queries.cache.enabled}, then  * the given provider will be used.  * NOTE: this can only be set once  *  * @see #INDEX_QUERY_CACHE_ENABLED_SETTING  */ public void forceQueryCacheProvider(BiFunction<IndexSettings, IndicesQueryCache, QueryCache> queryCacheProvider) {     ensureNotFrozen().     this.forceQueryCacheProvider.set(queryCacheProvider). }
false;private;0;5;;private void ensureNotFrozen() {     if (this.frozen.get()) {         throw new IllegalStateException("Can't modify IndexModule once the index service has been created").     } }
