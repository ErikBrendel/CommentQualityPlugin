commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public byte id() {     return id. }
false;public,static;1;6;;public static Stage fromId(byte id) {     if (id < 0 || id >= STAGES.length) {         throw new IllegalArgumentException("No mapping for id [" + id + "]").     }     return STAGES[id]. }
false;public;1;13;;@Override public void writeTo(StreamOutput out) throws IOException {     timer.writeTo(out).     out.writeByte(stage.id()).     shardId.writeTo(out).     recoverySource.writeTo(out).     targetNode.writeTo(out).     out.writeOptionalWriteable(sourceNode).     index.writeTo(out).     translog.writeTo(out).     verifyIndex.writeTo(out).     out.writeBoolean(primary). }
false;public;0;3;;public ShardId getShardId() {     return shardId. }
false;public,synchronized;0;3;;public synchronized Stage getStage() {     return this.stage. }
false;private;2;7;;private void validateAndSetStage(Stage expected, Stage next) {     if (stage != expected) {         throw new IllegalStateException("can't move recovery to stage [" + next + "]. current stage: [" + stage + "] (expected [" + expected + "])").     }     stage = next. }
true;public,synchronized;1;36;// synchronized is strictly speaking not needed (this is called by a single thread), but just to be safe ;// synchronized is strictly speaking not needed (this is called by a single thread), but just to be safe public synchronized RecoveryState setStage(Stage stage) {     switch(stage) {         case INIT:             // reinitializing stop remove all state except for start time             this.stage = Stage.INIT.             getIndex().reset().             getVerifyIndex().reset().             getTranslog().reset().             break.         case INDEX:             validateAndSetStage(Stage.INIT, stage).             getIndex().start().             break.         case VERIFY_INDEX:             validateAndSetStage(Stage.INDEX, stage).             getIndex().stop().             getVerifyIndex().start().             break.         case TRANSLOG:             validateAndSetStage(Stage.VERIFY_INDEX, stage).             getVerifyIndex().stop().             getTranslog().start().             break.         case FINALIZE:             validateAndSetStage(Stage.TRANSLOG, stage).             getTranslog().stop().             break.         case DONE:             validateAndSetStage(Stage.FINALIZE, stage).             getTimer().stop().             break.         default:             throw new IllegalArgumentException("unknown RecoveryState.Stage [" + stage + "]").     }     return this. }
false;public;0;3;;public Index getIndex() {     return index. }
false;public;0;3;;public VerifyIndex getVerifyIndex() {     return this.verifyIndex. }
false;public;0;3;;public Translog getTranslog() {     return translog. }
false;public;0;3;;public Timer getTimer() {     return timer. }
false;public;0;3;;public RecoverySource getRecoverySource() {     return recoverySource. }
true;public;0;4;/**  * Returns recovery source node (only non-null if peer recovery)  */ ;/**  * Returns recovery source node (only non-null if peer recovery)  */ @Nullable public DiscoveryNode getSourceNode() {     return sourceNode. }
false;public;0;3;;public DiscoveryNode getTargetNode() {     return targetNode. }
false;public;0;3;;public boolean getPrimary() {     return primary. }
false;public,static;1;3;;public static RecoveryState readRecoveryState(StreamInput in) throws IOException {     return new RecoveryState(in). }
false;public,synchronized;1;4;;@Override public synchronized void readFrom(StreamInput in) throws IOException {     throw new UnsupportedOperationException("usage of Streamable is to be replaced by Writeable"). }
false;public;2;49;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.field(Fields.ID, shardId.id()).     builder.field(Fields.TYPE, recoverySource.getType()).     builder.field(Fields.STAGE, stage.toString()).     builder.field(Fields.PRIMARY, primary).     builder.timeField(Fields.START_TIME_IN_MILLIS, Fields.START_TIME, timer.startTime).     if (timer.stopTime > 0) {         builder.timeField(Fields.STOP_TIME_IN_MILLIS, Fields.STOP_TIME, timer.stopTime).     }     builder.humanReadableField(Fields.TOTAL_TIME_IN_MILLIS, Fields.TOTAL_TIME, new TimeValue(timer.time())).     if (recoverySource.getType() == RecoverySource.Type.PEER) {         builder.startObject(Fields.SOURCE).         builder.field(Fields.ID, sourceNode.getId()).         builder.field(Fields.HOST, sourceNode.getHostName()).         builder.field(Fields.TRANSPORT_ADDRESS, sourceNode.getAddress().toString()).         builder.field(Fields.IP, sourceNode.getHostAddress()).         builder.field(Fields.NAME, sourceNode.getName()).         builder.endObject().     } else {         builder.startObject(Fields.SOURCE).         recoverySource.addAdditionalFields(builder, params).         builder.endObject().     }     builder.startObject(Fields.TARGET).     builder.field(Fields.ID, targetNode.getId()).     builder.field(Fields.HOST, targetNode.getHostName()).     builder.field(Fields.TRANSPORT_ADDRESS, targetNode.getAddress().toString()).     builder.field(Fields.IP, targetNode.getHostAddress()).     builder.field(Fields.NAME, targetNode.getName()).     builder.endObject().     builder.startObject(Fields.INDEX).     index.toXContent(builder, params).     builder.endObject().     builder.startObject(Fields.TRANSLOG).     translog.toXContent(builder, params).     builder.endObject().     builder.startObject(Fields.VERIFY_INDEX).     verifyIndex.toXContent(builder, params).     builder.endObject().     return builder. }
false;public,synchronized;1;8;;@Override public synchronized void writeTo(StreamOutput out) throws IOException {     out.writeVLong(startTime).     out.writeVLong(startNanoTime).     out.writeVLong(stopTime).     // write a snapshot of current time, which is not per se the time field     out.writeVLong(time()). }
false;public,synchronized;0;5;;public synchronized void start() {     assert startTime == 0 : "already started".     startTime = System.currentTimeMillis().     startNanoTime = System.nanoTime(). }
true;public,synchronized;0;3;/**  * Returns start time in millis  */ ;/**  * Returns start time in millis  */ public synchronized long startTime() {     return startTime. }
true;public,synchronized;0;9;/**  * Returns elapsed time in millis, or 0 if timer was not started  */ ;/**  * Returns elapsed time in millis, or 0 if timer was not started  */ public synchronized long time() {     if (startNanoTime == 0) {         return 0.     }     if (time >= 0) {         return time.     }     return Math.max(0, TimeValue.nsecToMSec(System.nanoTime() - startNanoTime)). }
true;public,synchronized;0;3;/**  * Returns stop time in millis  */ ;/**  * Returns stop time in millis  */ public synchronized long stopTime() {     return stopTime. }
false;public,synchronized;0;6;;public synchronized void stop() {     assert stopTime == 0 : "already stopped".     stopTime = Math.max(System.currentTimeMillis(), startTime).     time = TimeValue.nsecToMSec(System.nanoTime() - startNanoTime).     assert time >= 0. }
false;public,synchronized;0;6;;public synchronized void reset() {     startTime = 0.     startNanoTime = 0.     time = -1.     stopTime = 0. }
true;public;0;3;// for tests ;// for tests public long getStartNanoTime() {     return startNanoTime. }
false;public;1;5;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeVLong(checkIndexTime). }
false;public;0;4;;public void reset() {     super.reset().     checkIndexTime = 0. }
false;public;0;3;;public long checkIndexTime() {     return checkIndexTime. }
false;public;1;3;;public void checkIndexTime(long checkIndexTime) {     this.checkIndexTime = checkIndexTime. }
false;public;2;6;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.humanReadableField(Fields.CHECK_INDEX_TIME_IN_MILLIS, Fields.CHECK_INDEX_TIME, new TimeValue(checkIndexTime)).     builder.humanReadableField(Fields.TOTAL_TIME_IN_MILLIS, Fields.TOTAL_TIME, new TimeValue(time())).     return builder. }
false;public;1;7;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeVInt(recovered).     out.writeVInt(total).     out.writeVInt(totalOnStart). }
false;public,synchronized;0;6;;public synchronized void reset() {     super.reset().     recovered = 0.     total = UNKNOWN.     totalOnStart = UNKNOWN. }
false;public,synchronized;0;5;;public synchronized void incrementRecoveredOperations() {     recovered++.     assert total == UNKNOWN || total >= recovered : "total, if known, should be > recovered. total [" + total + "], recovered [" + recovered + "]". }
false;public,synchronized;1;5;;public synchronized void incrementRecoveredOperations(int ops) {     recovered += ops.     assert total == UNKNOWN || total >= recovered : "total, if known, should be > recovered. total [" + total + "], recovered [" + recovered + "]". }
false;public,synchronized;1;7;;public synchronized void decrementRecoveredOperations(int ops) {     recovered -= ops.     assert recovered >= 0 : "recovered operations must be non-negative. Because [" + recovered + "] after decrementing [" + ops + "]".     assert total == UNKNOWN || total >= recovered : "total, if known, should be > recovered. total [" + total + "], recovered [" + recovered + "]". }
true;public,synchronized;0;3;/**  * returns the total number of translog operations recovered so far  */ ;/**  * returns the total number of translog operations recovered so far  */ public synchronized int recoveredOperations() {     return recovered. }
true;public,synchronized;0;3;/**  * returns the total number of translog operations needed to be recovered at this moment.  * Note that this can change as the number of operations grows during recovery.  * <p>  * A value of -1 ({@link RecoveryState.Translog#UNKNOWN} is return if this is unknown (typically a gateway recovery)  */ ;/**  * returns the total number of translog operations needed to be recovered at this moment.  * Note that this can change as the number of operations grows during recovery.  * <p>  * A value of -1 ({@link RecoveryState.Translog#UNKNOWN} is return if this is unknown (typically a gateway recovery)  */ public synchronized int totalOperations() {     return total. }
false;public,synchronized;1;5;;public synchronized void totalOperations(int total) {     this.total = total.     assert total == UNKNOWN || total >= recovered : "total, if known, should be > recovered. total [" + total + "], recovered [" + recovered + "]". }
true;public,synchronized;0;3;/**  * returns the total number of translog operations to recovered, on the start of the recovery. Unlike {@link #totalOperations}  * this does change during recovery.  * <p>  * A value of -1 ({@link RecoveryState.Translog#UNKNOWN} is return if this is unknown (typically a gateway recovery)  */ ;/**  * returns the total number of translog operations to recovered, on the start of the recovery. Unlike {@link #totalOperations}  * this does change during recovery.  * <p>  * A value of -1 ({@link RecoveryState.Translog#UNKNOWN} is return if this is unknown (typically a gateway recovery)  */ public synchronized int totalOperationsOnStart() {     return this.totalOnStart. }
false;public,synchronized;1;3;;public synchronized void totalOperationsOnStart(int total) {     this.totalOnStart = total. }
false;public,synchronized;0;9;;public synchronized float recoveredPercent() {     if (total == UNKNOWN) {         return -1.f.     }     if (total == 0) {         return 100.f.     }     return recovered * 100.0f / total. }
false;public,synchronized;2;9;;@Override public synchronized XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.field(Fields.RECOVERED, recovered).     builder.field(Fields.TOTAL, total).     builder.field(Fields.PERCENT, String.format(Locale.ROOT, "%1.1f%%", recoveredPercent())).     builder.field(Fields.TOTAL_ON_START, totalOnStart).     builder.humanReadableField(Fields.TOTAL_TIME_IN_MILLIS, Fields.TOTAL_TIME, new TimeValue(time())).     return builder. }
false;public;1;7;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeString(name).     out.writeVLong(length).     out.writeVLong(recovered).     out.writeBoolean(reused). }
false;;1;5;;void addRecoveredBytes(long bytes) {     assert reused == false : "file is marked as reused, can't update recovered bytes".     assert bytes >= 0 : "can't recovered negative bytes. got [" + bytes + "]".     recovered += bytes. }
true;public;0;3;/**  * file name *  */ ;/**  * file name *  */ public String name() {     return name. }
true;public;0;3;/**  * file length *  */ ;/**  * file length *  */ public long length() {     return length. }
true;public;0;3;/**  * number of bytes recovered for this file (so far). 0 if the file is reused *  */ ;/**  * number of bytes recovered for this file (so far). 0 if the file is reused *  */ public long recovered() {     return recovered. }
true;public;0;3;/**  * returns true if the file is reused from a local copy  */ ;/**  * returns true if the file is reused from a local copy  */ public boolean reused() {     return reused. }
false;;0;3;;boolean fullyRecovered() {     return reused == false && length == recovered. }
false;public;2;10;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     builder.field(Fields.NAME, name).     builder.humanReadableField(Fields.LENGTH_IN_BYTES, Fields.LENGTH, new ByteSizeValue(length)).     builder.field(Fields.REUSED, reused).     builder.humanReadableField(Fields.RECOVERED_IN_BYTES, Fields.RECOVERED, new ByteSizeValue(recovered)).     builder.endObject().     return builder. }
false;public;1;8;;@Override public boolean equals(Object obj) {     if (obj instanceof File) {         File other = (File) obj.         return name.equals(other.name) && length == other.length() && reused == other.reused() && recovered == other.recovered().     }     return false. }
false;public;0;8;;@Override public int hashCode() {     int result = name.hashCode().     result = 31 * result + Long.hashCode(length).     result = 31 * result + Long.hashCode(recovered).     result = 31 * result + (reused ? 1 : 0).     return result. }
false;public;0;4;;@Override public String toString() {     return "file (name [" + name + "], reused [" + reused + "], length [" + length + "], recovered [" + recovered + "])". }
false;public,synchronized;1;11;;@Override public synchronized void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     final File[] files = fileDetails.values().toArray(new File[0]).     out.writeVInt(files.length).     for (File file : files) {         file.writeTo(out).     }     out.writeLong(sourceThrottlingInNanos).     out.writeLong(targetThrottleTimeInNanos). }
false;public,synchronized;0;3;;public synchronized List<File> fileDetails() {     return Collections.unmodifiableList(new ArrayList<>(fileDetails.values())). }
false;public,synchronized;0;7;;public synchronized void reset() {     super.reset().     version = UNKNOWN.     fileDetails.clear().     sourceThrottlingInNanos = UNKNOWN.     targetThrottleTimeInNanos = UNKNOWN. }
false;public,synchronized;3;5;;public synchronized void addFileDetail(String name, long length, boolean reused) {     File file = new File(name, length, reused).     File existing = fileDetails.put(name, file).     assert existing == null : "file [" + name + "] is already reported". }
false;public,synchronized;2;4;;public synchronized void addRecoveredBytesToFile(String name, long bytes) {     File file = fileDetails.get(name).     file.addRecoveredBytes(bytes). }
false;public,synchronized;0;3;;public synchronized long version() {     return this.version. }
false;public,synchronized;1;7;;public synchronized void addSourceThrottling(long timeInNanos) {     if (sourceThrottlingInNanos == UNKNOWN) {         sourceThrottlingInNanos = timeInNanos.     } else {         sourceThrottlingInNanos += timeInNanos.     } }
false;public,synchronized;1;7;;public synchronized void addTargetThrottling(long timeInNanos) {     if (targetThrottleTimeInNanos == UNKNOWN) {         targetThrottleTimeInNanos = timeInNanos.     } else {         targetThrottleTimeInNanos += timeInNanos.     } }
false;public,synchronized;0;3;;public synchronized TimeValue sourceThrottling() {     return TimeValue.timeValueNanos(sourceThrottlingInNanos). }
false;public,synchronized;0;3;;public synchronized TimeValue targetThrottling() {     return TimeValue.timeValueNanos(targetThrottleTimeInNanos). }
true;public,synchronized;0;3;/**  * total number of files that are part of this recovery, both re-used and recovered  */ ;/**  * total number of files that are part of this recovery, both re-used and recovered  */ public synchronized int totalFileCount() {     return fileDetails.size(). }
true;public,synchronized;0;9;/**  * total number of files to be recovered (potentially not yet done)  */ ;/**  * total number of files to be recovered (potentially not yet done)  */ public synchronized int totalRecoverFiles() {     int total = 0.     for (File file : fileDetails.values()) {         if (file.reused() == false) {             total++.         }     }     return total. }
true;public,synchronized;0;9;/**  * number of file that were recovered (excluding on ongoing files)  */ ;/**  * number of file that were recovered (excluding on ongoing files)  */ public synchronized int recoveredFileCount() {     int count = 0.     for (File file : fileDetails.values()) {         if (file.fullyRecovered()) {             count++.         }     }     return count. }
true;public,synchronized;0;21;/**  * percent of recovered (i.e., not reused) files out of the total files to be recovered  */ ;/**  * percent of recovered (i.e., not reused) files out of the total files to be recovered  */ public synchronized float recoveredFilesPercent() {     int total = 0.     int recovered = 0.     for (File file : fileDetails.values()) {         if (file.reused() == false) {             total++.             if (file.fullyRecovered()) {                 recovered++.             }         }     }     if (total == 0 && fileDetails.size() == 0) {         // indicates we are still in init phase         return 0.0f.     }     if (total == recovered) {         return 100.0f.     } else {         float result = 100.0f * (recovered / (float) total).         return result.     } }
true;public,synchronized;0;7;/**  * total number of bytes in th shard  */ ;/**  * total number of bytes in th shard  */ public synchronized long totalBytes() {     long total = 0.     for (File file : fileDetails.values()) {         total += file.length().     }     return total. }
true;public,synchronized;0;7;/**  * total number of bytes recovered so far, including both existing and reused  */ ;/**  * total number of bytes recovered so far, including both existing and reused  */ public synchronized long recoveredBytes() {     long recovered = 0.     for (File file : fileDetails.values()) {         recovered += file.recovered().     }     return recovered. }
true;public,synchronized;0;9;/**  * total bytes of files to be recovered (potentially not yet done)  */ ;/**  * total bytes of files to be recovered (potentially not yet done)  */ public synchronized long totalRecoverBytes() {     long total = 0.     for (File file : fileDetails.values()) {         if (file.reused() == false) {             total += file.length().         }     }     return total. }
false;public,synchronized;0;9;;public synchronized long totalReuseBytes() {     long total = 0.     for (File file : fileDetails.values()) {         if (file.reused()) {             total += file.length().         }     }     return total. }
true;public,synchronized;0;19;/**  * percent of bytes recovered out of total files bytes *to be* recovered  */ ;/**  * percent of bytes recovered out of total files bytes *to be* recovered  */ public synchronized float recoveredBytesPercent() {     long total = 0.     long recovered = 0.     for (File file : fileDetails.values()) {         if (file.reused() == false) {             total += file.length().             recovered += file.recovered().         }     }     if (total == 0 && fileDetails.size() == 0) {         // indicates we are still in init phase         return 0.0f.     }     if (total == recovered) {         return 100.0f.     } else {         return 100.0f * recovered / total.     } }
false;public,synchronized;0;9;;public synchronized int reusedFileCount() {     int reused = 0.     for (File file : fileDetails.values()) {         if (file.reused()) {             reused++.         }     }     return reused. }
false;public,synchronized;0;9;;public synchronized long reusedBytes() {     long reused = 0.     for (File file : fileDetails.values()) {         if (file.reused()) {             reused += file.length().         }     }     return reused. }
false;public,synchronized;1;3;;public synchronized void updateVersion(long version) {     this.version = version. }
false;public,synchronized;2;28;;@Override public synchronized XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     // stream size first, as it matters more and the files section can be long     builder.startObject(Fields.SIZE).     builder.humanReadableField(Fields.TOTAL_IN_BYTES, Fields.TOTAL, new ByteSizeValue(totalBytes())).     builder.humanReadableField(Fields.REUSED_IN_BYTES, Fields.REUSED, new ByteSizeValue(reusedBytes())).     builder.humanReadableField(Fields.RECOVERED_IN_BYTES, Fields.RECOVERED, new ByteSizeValue(recoveredBytes())).     builder.field(Fields.PERCENT, String.format(Locale.ROOT, "%1.1f%%", recoveredBytesPercent())).     builder.endObject().     builder.startObject(Fields.FILES).     builder.field(Fields.TOTAL, totalFileCount()).     builder.field(Fields.REUSED, reusedFileCount()).     builder.field(Fields.RECOVERED, recoveredFileCount()).     builder.field(Fields.PERCENT, String.format(Locale.ROOT, "%1.1f%%", recoveredFilesPercent())).     if (params.paramAsBoolean("details", false)) {         builder.startArray(Fields.DETAILS).         for (File file : fileDetails.values()) {             file.toXContent(builder, params).         }         builder.endArray().     }     builder.endObject().     builder.humanReadableField(Fields.TOTAL_TIME_IN_MILLIS, Fields.TOTAL_TIME, new TimeValue(time())).     builder.humanReadableField(Fields.SOURCE_THROTTLE_TIME_IN_MILLIS, Fields.SOURCE_THROTTLE_TIME, sourceThrottling()).     builder.humanReadableField(Fields.TARGET_THROTTLE_TIME_IN_MILLIS, Fields.TARGET_THROTTLE_TIME, targetThrottling()).     return builder. }
false;public,synchronized;0;12;;@Override public synchronized String toString() {     try {         XContentBuilder builder = XContentFactory.jsonBuilder().prettyPrint().         builder.startObject().         toXContent(builder, EMPTY_PARAMS).         builder.endObject().         return Strings.toString(builder).     } catch (IOException e) {         return "{ \"error\" : \"" + e.getMessage() + "\"}".     } }
false;public;1;3;;public File getFileDetails(String dest) {     return fileDetails.get(dest). }
