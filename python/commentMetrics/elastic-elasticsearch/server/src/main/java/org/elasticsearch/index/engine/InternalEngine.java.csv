# id;timestamp;commentText;codeText;commentWords;codeWords
InternalEngine -> private String loadHistoryUUID(final IndexWriter writer) throws IOException;1524684173;Reads the current stored history ID from the IW commit data.;private String loadHistoryUUID(final IndexWriter writer) throws IOException {_        final String uuid = commitDataAsMap(writer).get(HISTORY_UUID_KEY)__        if (uuid == null) {_            throw new IllegalStateException("commit doesn't contain history uuid")__        }_        return uuid__    };reads,the,current,stored,history,id,from,the,iw,commit,data;private,string,load,history,uuid,final,index,writer,writer,throws,ioexception,final,string,uuid,commit,data,as,map,writer,get,if,uuid,null,throw,new,illegal,state,exception,commit,doesn,t,contain,history,uuid,return,uuid
InternalEngine -> private String loadHistoryUUID(final IndexWriter writer) throws IOException;1524780945;Reads the current stored history ID from the IW commit data.;private String loadHistoryUUID(final IndexWriter writer) throws IOException {_        final String uuid = commitDataAsMap(writer).get(HISTORY_UUID_KEY)__        if (uuid == null) {_            throw new IllegalStateException("commit doesn't contain history uuid")__        }_        return uuid__    };reads,the,current,stored,history,id,from,the,iw,commit,data;private,string,load,history,uuid,final,index,writer,writer,throws,ioexception,final,string,uuid,commit,data,as,map,writer,get,if,uuid,null,throw,new,illegal,state,exception,commit,doesn,t,contain,history,uuid,return,uuid
InternalEngine -> private String loadHistoryUUID(final IndexWriter writer) throws IOException;1525162917;Reads the current stored history ID from the IW commit data.;private String loadHistoryUUID(final IndexWriter writer) throws IOException {_        final String uuid = commitDataAsMap(writer).get(HISTORY_UUID_KEY)__        if (uuid == null) {_            throw new IllegalStateException("commit doesn't contain history uuid")__        }_        return uuid__    };reads,the,current,stored,history,id,from,the,iw,commit,data;private,string,load,history,uuid,final,index,writer,writer,throws,ioexception,final,string,uuid,commit,data,as,map,writer,get,if,uuid,null,throw,new,illegal,state,exception,commit,doesn,t,contain,history,uuid,return,uuid
InternalEngine -> private String loadHistoryUUID(final IndexWriter writer) throws IOException;1528706846;Reads the current stored history ID from the IW commit data.;private String loadHistoryUUID(final IndexWriter writer) throws IOException {_        final String uuid = commitDataAsMap(writer).get(HISTORY_UUID_KEY)__        if (uuid == null) {_            throw new IllegalStateException("commit doesn't contain history uuid")__        }_        return uuid__    };reads,the,current,stored,history,id,from,the,iw,commit,data;private,string,load,history,uuid,final,index,writer,writer,throws,ioexception,final,string,uuid,commit,data,as,map,writer,get,if,uuid,null,throw,new,illegal,state,exception,commit,doesn,t,contain,history,uuid,return,uuid
InternalEngine -> private String loadHistoryUUID(final IndexWriter writer) throws IOException;1528762805;Reads the current stored history ID from the IW commit data.;private String loadHistoryUUID(final IndexWriter writer) throws IOException {_        final String uuid = commitDataAsMap(writer).get(HISTORY_UUID_KEY)__        if (uuid == null) {_            throw new IllegalStateException("commit doesn't contain history uuid")__        }_        return uuid__    };reads,the,current,stored,history,id,from,the,iw,commit,data;private,string,load,history,uuid,final,index,writer,writer,throws,ioexception,final,string,uuid,commit,data,as,map,writer,get,if,uuid,null,throw,new,illegal,state,exception,commit,doesn,t,contain,history,uuid,return,uuid
InternalEngine -> private String loadHistoryUUID(final IndexWriter writer) throws IOException;1531910483;Reads the current stored history ID from the IW commit data.;private String loadHistoryUUID(final IndexWriter writer) throws IOException {_        final String uuid = commitDataAsMap(writer).get(HISTORY_UUID_KEY)__        if (uuid == null) {_            throw new IllegalStateException("commit doesn't contain history uuid")__        }_        return uuid__    };reads,the,current,stored,history,id,from,the,iw,commit,data;private,string,load,history,uuid,final,index,writer,writer,throws,ioexception,final,string,uuid,commit,data,as,map,writer,get,if,uuid,null,throw,new,illegal,state,exception,commit,doesn,t,contain,history,uuid,return,uuid
InternalEngine -> private String loadHistoryUUID(final IndexWriter writer) throws IOException;1533295538;Reads the current stored history ID from the IW commit data.;private String loadHistoryUUID(final IndexWriter writer) throws IOException {_        final String uuid = commitDataAsMap(writer).get(HISTORY_UUID_KEY)__        if (uuid == null) {_            throw new IllegalStateException("commit doesn't contain history uuid")__        }_        return uuid__    };reads,the,current,stored,history,id,from,the,iw,commit,data;private,string,load,history,uuid,final,index,writer,writer,throws,ioexception,final,string,uuid,commit,data,as,map,writer,get,if,uuid,null,throw,new,illegal,state,exception,commit,doesn,t,contain,history,uuid,return,uuid
InternalEngine -> private String loadHistoryUUID(final IndexWriter writer) throws IOException;1534848846;Reads the current stored history ID from the IW commit data.;private String loadHistoryUUID(final IndexWriter writer) throws IOException {_        final String uuid = commitDataAsMap(writer).get(HISTORY_UUID_KEY)__        if (uuid == null) {_            throw new IllegalStateException("commit doesn't contain history uuid")__        }_        return uuid__    };reads,the,current,stored,history,id,from,the,iw,commit,data;private,string,load,history,uuid,final,index,writer,writer,throws,ioexception,final,string,uuid,commit,data,as,map,writer,get,if,uuid,null,throw,new,illegal,state,exception,commit,doesn,t,contain,history,uuid,return,uuid
InternalEngine -> private String loadHistoryUUID(final IndexWriter writer) throws IOException;1535046779;Reads the current stored history ID from the IW commit data.;private String loadHistoryUUID(final IndexWriter writer) throws IOException {_        final String uuid = commitDataAsMap(writer).get(HISTORY_UUID_KEY)__        if (uuid == null) {_            throw new IllegalStateException("commit doesn't contain history uuid")__        }_        return uuid__    };reads,the,current,stored,history,id,from,the,iw,commit,data;private,string,load,history,uuid,final,index,writer,writer,throws,ioexception,final,string,uuid,commit,data,as,map,writer,get,if,uuid,null,throw,new,illegal,state,exception,commit,doesn,t,contain,history,uuid,return,uuid
InternalEngine -> private String loadHistoryUUID(final IndexWriter writer) throws IOException;1535405719;Reads the current stored history ID from the IW commit data.;private String loadHistoryUUID(final IndexWriter writer) throws IOException {_        final String uuid = commitDataAsMap(writer).get(HISTORY_UUID_KEY)__        if (uuid == null) {_            throw new IllegalStateException("commit doesn't contain history uuid")__        }_        return uuid__    };reads,the,current,stored,history,id,from,the,iw,commit,data;private,string,load,history,uuid,final,index,writer,writer,throws,ioexception,final,string,uuid,commit,data,as,map,writer,get,if,uuid,null,throw,new,illegal,state,exception,commit,doesn,t,contain,history,uuid,return,uuid
InternalEngine -> private String loadHistoryUUID(final IndexWriter writer) throws IOException;1535723122;Reads the current stored history ID from the IW commit data.;private String loadHistoryUUID(final IndexWriter writer) throws IOException {_        final String uuid = commitDataAsMap(writer).get(HISTORY_UUID_KEY)__        if (uuid == null) {_            throw new IllegalStateException("commit doesn't contain history uuid")__        }_        return uuid__    };reads,the,current,stored,history,id,from,the,iw,commit,data;private,string,load,history,uuid,final,index,writer,writer,throws,ioexception,final,string,uuid,commit,data,as,map,writer,get,if,uuid,null,throw,new,illegal,state,exception,commit,doesn,t,contain,history,uuid,return,uuid
InternalEngine -> private String loadHistoryUUID(final IndexWriter writer) throws IOException;1535965276;Reads the current stored history ID from the IW commit data.;private String loadHistoryUUID(final IndexWriter writer) throws IOException {_        final String uuid = commitDataAsMap(writer).get(HISTORY_UUID_KEY)__        if (uuid == null) {_            throw new IllegalStateException("commit doesn't contain history uuid")__        }_        return uuid__    };reads,the,current,stored,history,id,from,the,iw,commit,data;private,string,load,history,uuid,final,index,writer,writer,throws,ioexception,final,string,uuid,commit,data,as,map,writer,get,if,uuid,null,throw,new,illegal,state,exception,commit,doesn,t,contain,history,uuid,return,uuid
InternalEngine -> private String loadHistoryUUID(final IndexWriter writer) throws IOException;1536218260;Reads the current stored history ID from the IW commit data.;private String loadHistoryUUID(final IndexWriter writer) throws IOException {_        final String uuid = commitDataAsMap(writer).get(HISTORY_UUID_KEY)__        if (uuid == null) {_            throw new IllegalStateException("commit doesn't contain history uuid")__        }_        return uuid__    };reads,the,current,stored,history,id,from,the,iw,commit,data;private,string,load,history,uuid,final,index,writer,writer,throws,ioexception,final,string,uuid,commit,data,as,map,writer,get,if,uuid,null,throw,new,illegal,state,exception,commit,doesn,t,contain,history,uuid,return,uuid
InternalEngine -> private String loadHistoryUUID(final IndexWriter writer) throws IOException;1536314350;Reads the current stored history ID from the IW commit data.;private String loadHistoryUUID(final IndexWriter writer) throws IOException {_        final String uuid = commitDataAsMap(writer).get(HISTORY_UUID_KEY)__        if (uuid == null) {_            throw new IllegalStateException("commit doesn't contain history uuid")__        }_        return uuid__    };reads,the,current,stored,history,id,from,the,iw,commit,data;private,string,load,history,uuid,final,index,writer,writer,throws,ioexception,final,string,uuid,commit,data,as,map,writer,get,if,uuid,null,throw,new,illegal,state,exception,commit,doesn,t,contain,history,uuid,return,uuid
InternalEngine -> private String loadHistoryUUID(final IndexWriter writer) throws IOException;1536828374;Reads the current stored history ID from the IW commit data.;private String loadHistoryUUID(final IndexWriter writer) throws IOException {_        final String uuid = commitDataAsMap(writer).get(HISTORY_UUID_KEY)__        if (uuid == null) {_            throw new IllegalStateException("commit doesn't contain history uuid")__        }_        return uuid__    };reads,the,current,stored,history,id,from,the,iw,commit,data;private,string,load,history,uuid,final,index,writer,writer,throws,ioexception,final,string,uuid,commit,data,as,map,writer,get,if,uuid,null,throw,new,illegal,state,exception,commit,doesn,t,contain,history,uuid,return,uuid
InternalEngine -> private String loadHistoryUUID(final IndexWriter writer) throws IOException;1537806831;Reads the current stored history ID from the IW commit data.;private String loadHistoryUUID(final IndexWriter writer) throws IOException {_        final String uuid = commitDataAsMap(writer).get(HISTORY_UUID_KEY)__        if (uuid == null) {_            throw new IllegalStateException("commit doesn't contain history uuid")__        }_        return uuid__    };reads,the,current,stored,history,id,from,the,iw,commit,data;private,string,load,history,uuid,final,index,writer,writer,throws,ioexception,final,string,uuid,commit,data,as,map,writer,get,if,uuid,null,throw,new,illegal,state,exception,commit,doesn,t,contain,history,uuid,return,uuid
InternalEngine -> private String loadHistoryUUID(final IndexWriter writer) throws IOException;1538067637;Reads the current stored history ID from the IW commit data.;private String loadHistoryUUID(final IndexWriter writer) throws IOException {_        final String uuid = commitDataAsMap(writer).get(HISTORY_UUID_KEY)__        if (uuid == null) {_            throw new IllegalStateException("commit doesn't contain history uuid")__        }_        return uuid__    };reads,the,current,stored,history,id,from,the,iw,commit,data;private,string,load,history,uuid,final,index,writer,writer,throws,ioexception,final,string,uuid,commit,data,as,map,writer,get,if,uuid,null,throw,new,illegal,state,exception,commit,doesn,t,contain,history,uuid,return,uuid
InternalEngine -> private String loadHistoryUUID(final IndexWriter writer) throws IOException;1538424609;Reads the current stored history ID from the IW commit data.;private String loadHistoryUUID(final IndexWriter writer) throws IOException {_        final String uuid = commitDataAsMap(writer).get(HISTORY_UUID_KEY)__        if (uuid == null) {_            throw new IllegalStateException("commit doesn't contain history uuid")__        }_        return uuid__    };reads,the,current,stored,history,id,from,the,iw,commit,data;private,string,load,history,uuid,final,index,writer,writer,throws,ioexception,final,string,uuid,commit,data,as,map,writer,get,if,uuid,null,throw,new,illegal,state,exception,commit,doesn,t,contain,history,uuid,return,uuid
InternalEngine -> private String loadHistoryUUID(final IndexWriter writer) throws IOException;1539615817;Reads the current stored history ID from the IW commit data.;private String loadHistoryUUID(final IndexWriter writer) throws IOException {_        final String uuid = commitDataAsMap(writer).get(HISTORY_UUID_KEY)__        if (uuid == null) {_            throw new IllegalStateException("commit doesn't contain history uuid")__        }_        return uuid__    };reads,the,current,stored,history,id,from,the,iw,commit,data;private,string,load,history,uuid,final,index,writer,writer,throws,ioexception,final,string,uuid,commit,data,as,map,writer,get,if,uuid,null,throw,new,illegal,state,exception,commit,doesn,t,contain,history,uuid,return,uuid
InternalEngine -> private String loadHistoryUUID(final IndexWriter writer) throws IOException;1539723533;Reads the current stored history ID from the IW commit data.;private String loadHistoryUUID(final IndexWriter writer) throws IOException {_        final String uuid = commitDataAsMap(writer).get(HISTORY_UUID_KEY)__        if (uuid == null) {_            throw new IllegalStateException("commit doesn't contain history uuid")__        }_        return uuid__    };reads,the,current,stored,history,id,from,the,iw,commit,data;private,string,load,history,uuid,final,index,writer,writer,throws,ioexception,final,string,uuid,commit,data,as,map,writer,get,if,uuid,null,throw,new,illegal,state,exception,commit,doesn,t,contain,history,uuid,return,uuid
InternalEngine -> private String loadHistoryUUID(final IndexWriter writer) throws IOException;1540238977;Reads the current stored history ID from the IW commit data.;private String loadHistoryUUID(final IndexWriter writer) throws IOException {_        final String uuid = commitDataAsMap(writer).get(HISTORY_UUID_KEY)__        if (uuid == null) {_            throw new IllegalStateException("commit doesn't contain history uuid")__        }_        return uuid__    };reads,the,current,stored,history,id,from,the,iw,commit,data;private,string,load,history,uuid,final,index,writer,writer,throws,ioexception,final,string,uuid,commit,data,as,map,writer,get,if,uuid,null,throw,new,illegal,state,exception,commit,doesn,t,contain,history,uuid,return,uuid
InternalEngine -> private String loadHistoryUUID(final IndexWriter writer) throws IOException;1541335413;Reads the current stored history ID from the IW commit data.;private String loadHistoryUUID(final IndexWriter writer) throws IOException {_        final String uuid = commitDataAsMap(writer).get(HISTORY_UUID_KEY)__        if (uuid == null) {_            throw new IllegalStateException("commit doesn't contain history uuid")__        }_        return uuid__    };reads,the,current,stored,history,id,from,the,iw,commit,data;private,string,load,history,uuid,final,index,writer,writer,throws,ioexception,final,string,uuid,commit,data,as,map,writer,get,if,uuid,null,throw,new,illegal,state,exception,commit,doesn,t,contain,history,uuid,return,uuid
InternalEngine -> private String loadHistoryUUID(final IndexWriter writer) throws IOException;1541622390;Reads the current stored history ID from the IW commit data.;private String loadHistoryUUID(final IndexWriter writer) throws IOException {_        final String uuid = commitDataAsMap(writer).get(HISTORY_UUID_KEY)__        if (uuid == null) {_            throw new IllegalStateException("commit doesn't contain history uuid")__        }_        return uuid__    };reads,the,current,stored,history,id,from,the,iw,commit,data;private,string,load,history,uuid,final,index,writer,writer,throws,ioexception,final,string,uuid,commit,data,as,map,writer,get,if,uuid,null,throw,new,illegal,state,exception,commit,doesn,t,contain,history,uuid,return,uuid
InternalEngine -> private String loadHistoryUUID(final IndexWriter writer) throws IOException;1542697754;Reads the current stored history ID from the IW commit data.;private String loadHistoryUUID(final IndexWriter writer) throws IOException {_        final String uuid = commitDataAsMap(writer).get(HISTORY_UUID_KEY)__        if (uuid == null) {_            throw new IllegalStateException("commit doesn't contain history uuid")__        }_        return uuid__    };reads,the,current,stored,history,id,from,the,iw,commit,data;private,string,load,history,uuid,final,index,writer,writer,throws,ioexception,final,string,uuid,commit,data,as,map,writer,get,if,uuid,null,throw,new,illegal,state,exception,commit,doesn,t,contain,history,uuid,return,uuid
InternalEngine -> private String loadHistoryUUID(final IndexWriter writer) throws IOException;1543940134;Reads the current stored history ID from the IW commit data.;private String loadHistoryUUID(final IndexWriter writer) throws IOException {_        final String uuid = commitDataAsMap(writer).get(HISTORY_UUID_KEY)__        if (uuid == null) {_            throw new IllegalStateException("commit doesn't contain history uuid")__        }_        return uuid__    };reads,the,current,stored,history,id,from,the,iw,commit,data;private,string,load,history,uuid,final,index,writer,writer,throws,ioexception,final,string,uuid,commit,data,as,map,writer,get,if,uuid,null,throw,new,illegal,state,exception,commit,doesn,t,contain,history,uuid,return,uuid
InternalEngine -> private String loadHistoryUUID(final IndexWriter writer) throws IOException;1544322276;Reads the current stored history ID from the IW commit data.;private String loadHistoryUUID(final IndexWriter writer) throws IOException {_        final String uuid = commitDataAsMap(writer).get(HISTORY_UUID_KEY)__        if (uuid == null) {_            throw new IllegalStateException("commit doesn't contain history uuid")__        }_        return uuid__    };reads,the,current,stored,history,id,from,the,iw,commit,data;private,string,load,history,uuid,final,index,writer,writer,throws,ioexception,final,string,uuid,commit,data,as,map,writer,get,if,uuid,null,throw,new,illegal,state,exception,commit,doesn,t,contain,history,uuid,return,uuid
InternalEngine -> private String loadHistoryUUID(final IndexWriter writer) throws IOException;1544545090;Reads the current stored history ID from the IW commit data.;private String loadHistoryUUID(final IndexWriter writer) throws IOException {_        final String uuid = commitDataAsMap(writer).get(HISTORY_UUID_KEY)__        if (uuid == null) {_            throw new IllegalStateException("commit doesn't contain history uuid")__        }_        return uuid__    };reads,the,current,stored,history,id,from,the,iw,commit,data;private,string,load,history,uuid,final,index,writer,writer,throws,ioexception,final,string,uuid,commit,data,as,map,writer,get,if,uuid,null,throw,new,illegal,state,exception,commit,doesn,t,contain,history,uuid,return,uuid
InternalEngine -> private String loadHistoryUUID(final IndexWriter writer) throws IOException;1544684920;Reads the current stored history ID from the IW commit data.;private String loadHistoryUUID(final IndexWriter writer) throws IOException {_        final String uuid = commitDataAsMap(writer).get(HISTORY_UUID_KEY)__        if (uuid == null) {_            throw new IllegalStateException("commit doesn't contain history uuid")__        }_        return uuid__    };reads,the,current,stored,history,id,from,the,iw,commit,data;private,string,load,history,uuid,final,index,writer,writer,throws,ioexception,final,string,uuid,commit,data,as,map,writer,get,if,uuid,null,throw,new,illegal,state,exception,commit,doesn,t,contain,history,uuid,return,uuid
InternalEngine -> private String loadHistoryUUID(final IndexWriter writer) throws IOException;1545140118;Reads the current stored history ID from the IW commit data.;private String loadHistoryUUID(final IndexWriter writer) throws IOException {_        final String uuid = commitDataAsMap(writer).get(HISTORY_UUID_KEY)__        if (uuid == null) {_            throw new IllegalStateException("commit doesn't contain history uuid")__        }_        return uuid__    };reads,the,current,stored,history,id,from,the,iw,commit,data;private,string,load,history,uuid,final,index,writer,writer,throws,ioexception,final,string,uuid,commit,data,as,map,writer,get,if,uuid,null,throw,new,illegal,state,exception,commit,doesn,t,contain,history,uuid,return,uuid
InternalEngine -> private String loadHistoryUUID(final IndexWriter writer) throws IOException;1546875837;Reads the current stored history ID from the IW commit data.;private String loadHistoryUUID(final IndexWriter writer) throws IOException {_        final String uuid = commitDataAsMap(writer).get(HISTORY_UUID_KEY)__        if (uuid == null) {_            throw new IllegalStateException("commit doesn't contain history uuid")__        }_        return uuid__    };reads,the,current,stored,history,id,from,the,iw,commit,data;private,string,load,history,uuid,final,index,writer,writer,throws,ioexception,final,string,uuid,commit,data,as,map,writer,get,if,uuid,null,throw,new,illegal,state,exception,commit,doesn,t,contain,history,uuid,return,uuid
InternalEngine -> private String loadHistoryUUID(final IndexWriter writer) throws IOException;1547332999;Reads the current stored history ID from the IW commit data.;private String loadHistoryUUID(final IndexWriter writer) throws IOException {_        final String uuid = commitDataAsMap(writer).get(HISTORY_UUID_KEY)__        if (uuid == null) {_            throw new IllegalStateException("commit doesn't contain history uuid")__        }_        return uuid__    };reads,the,current,stored,history,id,from,the,iw,commit,data;private,string,load,history,uuid,final,index,writer,writer,throws,ioexception,final,string,uuid,commit,data,as,map,writer,get,if,uuid,null,throw,new,illegal,state,exception,commit,doesn,t,contain,history,uuid,return,uuid
InternalEngine -> private String loadHistoryUUID(final IndexWriter writer) throws IOException;1548771485;Reads the current stored history ID from the IW commit data.;private String loadHistoryUUID(final IndexWriter writer) throws IOException {_        final String uuid = commitDataAsMap(writer).get(HISTORY_UUID_KEY)__        if (uuid == null) {_            throw new IllegalStateException("commit doesn't contain history uuid")__        }_        return uuid__    };reads,the,current,stored,history,id,from,the,iw,commit,data;private,string,load,history,uuid,final,index,writer,writer,throws,ioexception,final,string,uuid,commit,data,as,map,writer,get,if,uuid,null,throw,new,illegal,state,exception,commit,doesn,t,contain,history,uuid,return,uuid
InternalEngine -> private String loadHistoryUUID(final IndexWriter writer) throws IOException;1549059559;Reads the current stored history ID from the IW commit data.;private String loadHistoryUUID(final IndexWriter writer) throws IOException {_        final String uuid = commitDataAsMap(writer).get(HISTORY_UUID_KEY)__        if (uuid == null) {_            throw new IllegalStateException("commit doesn't contain history uuid")__        }_        return uuid__    };reads,the,current,stored,history,id,from,the,iw,commit,data;private,string,load,history,uuid,final,index,writer,writer,throws,ioexception,final,string,uuid,commit,data,as,map,writer,get,if,uuid,null,throw,new,illegal,state,exception,commit,doesn,t,contain,history,uuid,return,uuid
InternalEngine -> private String loadHistoryUUID(final IndexWriter writer) throws IOException;1549663373;Reads the current stored history ID from the IW commit data.;private String loadHistoryUUID(final IndexWriter writer) throws IOException {_        final String uuid = commitDataAsMap(writer).get(HISTORY_UUID_KEY)__        if (uuid == null) {_            throw new IllegalStateException("commit doesn't contain history uuid")__        }_        return uuid__    };reads,the,current,stored,history,id,from,the,iw,commit,data;private,string,load,history,uuid,final,index,writer,writer,throws,ioexception,final,string,uuid,commit,data,as,map,writer,get,if,uuid,null,throw,new,illegal,state,exception,commit,doesn,t,contain,history,uuid,return,uuid
InternalEngine -> private String loadHistoryUUID(final IndexWriter writer) throws IOException;1549975032;Reads the current stored history ID from the IW commit data.;private String loadHistoryUUID(final IndexWriter writer) throws IOException {_        final String uuid = commitDataAsMap(writer).get(HISTORY_UUID_KEY)__        if (uuid == null) {_            throw new IllegalStateException("commit doesn't contain history uuid")__        }_        return uuid__    };reads,the,current,stored,history,id,from,the,iw,commit,data;private,string,load,history,uuid,final,index,writer,writer,throws,ioexception,final,string,uuid,commit,data,as,map,writer,get,if,uuid,null,throw,new,illegal,state,exception,commit,doesn,t,contain,history,uuid,return,uuid
InternalEngine -> private String loadHistoryUUID(final IndexWriter writer) throws IOException;1550220204;Reads the current stored history ID from the IW commit data.;private String loadHistoryUUID(final IndexWriter writer) throws IOException {_        final String uuid = commitDataAsMap(writer).get(HISTORY_UUID_KEY)__        if (uuid == null) {_            throw new IllegalStateException("commit doesn't contain history uuid")__        }_        return uuid__    };reads,the,current,stored,history,id,from,the,iw,commit,data;private,string,load,history,uuid,final,index,writer,writer,throws,ioexception,final,string,uuid,commit,data,as,map,writer,get,if,uuid,null,throw,new,illegal,state,exception,commit,doesn,t,contain,history,uuid,return,uuid
InternalEngine -> private String loadHistoryUUID(final IndexWriter writer) throws IOException;1550256122;Reads the current stored history ID from the IW commit data.;private String loadHistoryUUID(final IndexWriter writer) throws IOException {_        final String uuid = commitDataAsMap(writer).get(HISTORY_UUID_KEY)__        if (uuid == null) {_            throw new IllegalStateException("commit doesn't contain history uuid")__        }_        return uuid__    };reads,the,current,stored,history,id,from,the,iw,commit,data;private,string,load,history,uuid,final,index,writer,writer,throws,ioexception,final,string,uuid,commit,data,as,map,writer,get,if,uuid,null,throw,new,illegal,state,exception,commit,doesn,t,contain,history,uuid,return,uuid
InternalEngine -> private String loadHistoryUUID(final IndexWriter writer) throws IOException;1550342051;Reads the current stored history ID from the IW commit data.;private String loadHistoryUUID(final IndexWriter writer) throws IOException {_        final String uuid = commitDataAsMap(writer).get(HISTORY_UUID_KEY)__        if (uuid == null) {_            throw new IllegalStateException("commit doesn't contain history uuid")__        }_        return uuid__    };reads,the,current,stored,history,id,from,the,iw,commit,data;private,string,load,history,uuid,final,index,writer,writer,throws,ioexception,final,string,uuid,commit,data,as,map,writer,get,if,uuid,null,throw,new,illegal,state,exception,commit,doesn,t,contain,history,uuid,return,uuid
InternalEngine -> private String loadHistoryUUID(final IndexWriter writer) throws IOException;1550526771;Reads the current stored history ID from the IW commit data.;private String loadHistoryUUID(final IndexWriter writer) throws IOException {_        final String uuid = commitDataAsMap(writer).get(HISTORY_UUID_KEY)__        if (uuid == null) {_            throw new IllegalStateException("commit doesn't contain history uuid")__        }_        return uuid__    };reads,the,current,stored,history,id,from,the,iw,commit,data;private,string,load,history,uuid,final,index,writer,writer,throws,ioexception,final,string,uuid,commit,data,as,map,writer,get,if,uuid,null,throw,new,illegal,state,exception,commit,doesn,t,contain,history,uuid,return,uuid
InternalEngine -> private String loadHistoryUUID(final IndexWriter writer) throws IOException;1551110274;Reads the current stored history ID from the IW commit data.;private String loadHistoryUUID(final IndexWriter writer) throws IOException {_        final String uuid = commitDataAsMap(writer).get(HISTORY_UUID_KEY)__        if (uuid == null) {_            throw new IllegalStateException("commit doesn't contain history uuid")__        }_        return uuid__    };reads,the,current,stored,history,id,from,the,iw,commit,data;private,string,load,history,uuid,final,index,writer,writer,throws,ioexception,final,string,uuid,commit,data,as,map,writer,get,if,uuid,null,throw,new,illegal,state,exception,commit,doesn,t,contain,history,uuid,return,uuid
InternalEngine -> private String loadHistoryUUID(final IndexWriter writer) throws IOException;1551126708;Reads the current stored history ID from the IW commit data.;private String loadHistoryUUID(final IndexWriter writer) throws IOException {_        final String uuid = commitDataAsMap(writer).get(HISTORY_UUID_KEY)__        if (uuid == null) {_            throw new IllegalStateException("commit doesn't contain history uuid")__        }_        return uuid__    };reads,the,current,stored,history,id,from,the,iw,commit,data;private,string,load,history,uuid,final,index,writer,writer,throws,ioexception,final,string,uuid,commit,data,as,map,writer,get,if,uuid,null,throw,new,illegal,state,exception,commit,doesn,t,contain,history,uuid,return,uuid
InternalEngine -> public final long getMinRetainedSeqNo();1549975032;Returns the minimum seqno that is retained in the Lucene index._Operations whose seq# are at least this value should exist in the Lucene index.;public final long getMinRetainedSeqNo() {_        assert softDeleteEnabled : Thread.currentThread().getName()__        return softDeletesPolicy.getMinRetainedSeqNo()__    };returns,the,minimum,seqno,that,is,retained,in,the,lucene,index,operations,whose,seq,are,at,least,this,value,should,exist,in,the,lucene,index;public,final,long,get,min,retained,seq,no,assert,soft,delete,enabled,thread,current,thread,get,name,return,soft,deletes,policy,get,min,retained,seq,no
InternalEngine -> public final long getMinRetainedSeqNo();1550220204;Returns the minimum seqno that is retained in the Lucene index._Operations whose seq# are at least this value should exist in the Lucene index.;public final long getMinRetainedSeqNo() {_        assert softDeleteEnabled : Thread.currentThread().getName()__        return softDeletesPolicy.getMinRetainedSeqNo()__    };returns,the,minimum,seqno,that,is,retained,in,the,lucene,index,operations,whose,seq,are,at,least,this,value,should,exist,in,the,lucene,index;public,final,long,get,min,retained,seq,no,assert,soft,delete,enabled,thread,current,thread,get,name,return,soft,deletes,policy,get,min,retained,seq,no
InternalEngine -> public final long getMinRetainedSeqNo();1550256122;Returns the minimum seqno that is retained in the Lucene index._Operations whose seq# are at least this value should exist in the Lucene index.;public final long getMinRetainedSeqNo() {_        assert softDeleteEnabled : Thread.currentThread().getName()__        return softDeletesPolicy.getMinRetainedSeqNo()__    };returns,the,minimum,seqno,that,is,retained,in,the,lucene,index,operations,whose,seq,are,at,least,this,value,should,exist,in,the,lucene,index;public,final,long,get,min,retained,seq,no,assert,soft,delete,enabled,thread,current,thread,get,name,return,soft,deletes,policy,get,min,retained,seq,no
InternalEngine -> public final long getMinRetainedSeqNo();1550342051;Returns the minimum seqno that is retained in the Lucene index._Operations whose seq# are at least this value should exist in the Lucene index.;public final long getMinRetainedSeqNo() {_        assert softDeleteEnabled : Thread.currentThread().getName()__        return softDeletesPolicy.getMinRetainedSeqNo()__    };returns,the,minimum,seqno,that,is,retained,in,the,lucene,index,operations,whose,seq,are,at,least,this,value,should,exist,in,the,lucene,index;public,final,long,get,min,retained,seq,no,assert,soft,delete,enabled,thread,current,thread,get,name,return,soft,deletes,policy,get,min,retained,seq,no
InternalEngine -> public final long getMinRetainedSeqNo();1550526771;Returns the minimum seqno that is retained in the Lucene index._Operations whose seq# are at least this value should exist in the Lucene index.;public final long getMinRetainedSeqNo() {_        assert softDeleteEnabled : Thread.currentThread().getName()__        return softDeletesPolicy.getMinRetainedSeqNo()__    };returns,the,minimum,seqno,that,is,retained,in,the,lucene,index,operations,whose,seq,are,at,least,this,value,should,exist,in,the,lucene,index;public,final,long,get,min,retained,seq,no,assert,soft,delete,enabled,thread,current,thread,get,name,return,soft,deletes,policy,get,min,retained,seq,no
InternalEngine -> public final long getMinRetainedSeqNo();1551110274;Returns the minimum seqno that is retained in the Lucene index._Operations whose seq# are at least this value should exist in the Lucene index.;public final long getMinRetainedSeqNo() {_        assert softDeleteEnabled : Thread.currentThread().getName()__        return softDeletesPolicy.getMinRetainedSeqNo()__    };returns,the,minimum,seqno,that,is,retained,in,the,lucene,index,operations,whose,seq,are,at,least,this,value,should,exist,in,the,lucene,index;public,final,long,get,min,retained,seq,no,assert,soft,delete,enabled,thread,current,thread,get,name,return,soft,deletes,policy,get,min,retained,seq,no
InternalEngine -> public final long getMinRetainedSeqNo();1551126708;Returns the minimum seqno that is retained in the Lucene index._Operations whose seq# are at least this value should exist in the Lucene index.;public final long getMinRetainedSeqNo() {_        assert softDeleteEnabled : Thread.currentThread().getName()__        return softDeletesPolicy.getMinRetainedSeqNo()__    };returns,the,minimum,seqno,that,is,retained,in,the,lucene,index,operations,whose,seq,are,at,least,this,value,should,exist,in,the,lucene,index;public,final,long,get,min,retained,seq,no,assert,soft,delete,enabled,thread,current,thread,get,name,return,soft,deletes,policy,get,min,retained,seq,no
InternalEngine -> @Override     protected final void closeNoLock(String reason, CountDownLatch closedLatch);1524684173;Closes the engine without acquiring the write lock. This should only be_called while the write lock is hold or in a disaster condition ie. if the engine_is failed.;@Override_    protected final void closeNoLock(String reason, CountDownLatch closedLatch) {_        if (isClosed.compareAndSet(false, true)) {_            assert rwl.isWriteLockedByCurrentThread() || failEngineLock.isHeldByCurrentThread() : "Either the write lock must be held or the engine must be currently be failing itself"__            try {_                this.versionMap.clear()__                if (internalSearcherManager != null) {_                    internalSearcherManager.removeListener(versionMap)__                }_                try {_                    IOUtils.close(externalSearcherManager, internalSearcherManager)__                } catch (Exception e) {_                    logger.warn("Failed to close SearcherManager", e)__                }_                try {_                    IOUtils.close(translog)__                } catch (Exception e) {_                    logger.warn("Failed to close translog", e)__                }_                _                logger.trace("rollback indexWriter")__                try {_                    indexWriter.rollback()__                } catch (AlreadyClosedException ex) {_                    failOnTragicEvent(ex)__                    throw ex__                }_                logger.trace("rollback indexWriter done")__            } catch (Exception e) {_                logger.warn("failed to rollback writer on close", e)__            } finally {_                try {_                    store.decRef()__                    logger.debug("engine closed [{}]", reason)__                } finally {_                    closedLatch.countDown()__                }_            }_        }_    };closes,the,engine,without,acquiring,the,write,lock,this,should,only,be,called,while,the,write,lock,is,hold,or,in,a,disaster,condition,ie,if,the,engine,is,failed;override,protected,final,void,close,no,lock,string,reason,count,down,latch,closed,latch,if,is,closed,compare,and,set,false,true,assert,rwl,is,write,locked,by,current,thread,fail,engine,lock,is,held,by,current,thread,either,the,write,lock,must,be,held,or,the,engine,must,be,currently,be,failing,itself,try,this,version,map,clear,if,internal,searcher,manager,null,internal,searcher,manager,remove,listener,version,map,try,ioutils,close,external,searcher,manager,internal,searcher,manager,catch,exception,e,logger,warn,failed,to,close,searcher,manager,e,try,ioutils,close,translog,catch,exception,e,logger,warn,failed,to,close,translog,e,logger,trace,rollback,index,writer,try,index,writer,rollback,catch,already,closed,exception,ex,fail,on,tragic,event,ex,throw,ex,logger,trace,rollback,index,writer,done,catch,exception,e,logger,warn,failed,to,rollback,writer,on,close,e,finally,try,store,dec,ref,logger,debug,engine,closed,reason,finally,closed,latch,count,down
InternalEngine -> @Override     protected final void closeNoLock(String reason, CountDownLatch closedLatch);1524780945;Closes the engine without acquiring the write lock. This should only be_called while the write lock is hold or in a disaster condition ie. if the engine_is failed.;@Override_    protected final void closeNoLock(String reason, CountDownLatch closedLatch) {_        if (isClosed.compareAndSet(false, true)) {_            assert rwl.isWriteLockedByCurrentThread() || failEngineLock.isHeldByCurrentThread() : "Either the write lock must be held or the engine must be currently be failing itself"__            try {_                this.versionMap.clear()__                if (internalSearcherManager != null) {_                    internalSearcherManager.removeListener(versionMap)__                }_                try {_                    IOUtils.close(externalSearcherManager, internalSearcherManager)__                } catch (Exception e) {_                    logger.warn("Failed to close SearcherManager", e)__                }_                try {_                    IOUtils.close(translog)__                } catch (Exception e) {_                    logger.warn("Failed to close translog", e)__                }_                _                logger.trace("rollback indexWriter")__                try {_                    indexWriter.rollback()__                } catch (AlreadyClosedException ex) {_                    failOnTragicEvent(ex)__                    throw ex__                }_                logger.trace("rollback indexWriter done")__            } catch (Exception e) {_                logger.warn("failed to rollback writer on close", e)__            } finally {_                try {_                    store.decRef()__                    logger.debug("engine closed [{}]", reason)__                } finally {_                    closedLatch.countDown()__                }_            }_        }_    };closes,the,engine,without,acquiring,the,write,lock,this,should,only,be,called,while,the,write,lock,is,hold,or,in,a,disaster,condition,ie,if,the,engine,is,failed;override,protected,final,void,close,no,lock,string,reason,count,down,latch,closed,latch,if,is,closed,compare,and,set,false,true,assert,rwl,is,write,locked,by,current,thread,fail,engine,lock,is,held,by,current,thread,either,the,write,lock,must,be,held,or,the,engine,must,be,currently,be,failing,itself,try,this,version,map,clear,if,internal,searcher,manager,null,internal,searcher,manager,remove,listener,version,map,try,ioutils,close,external,searcher,manager,internal,searcher,manager,catch,exception,e,logger,warn,failed,to,close,searcher,manager,e,try,ioutils,close,translog,catch,exception,e,logger,warn,failed,to,close,translog,e,logger,trace,rollback,index,writer,try,index,writer,rollback,catch,already,closed,exception,ex,fail,on,tragic,event,ex,throw,ex,logger,trace,rollback,index,writer,done,catch,exception,e,logger,warn,failed,to,rollback,writer,on,close,e,finally,try,store,dec,ref,logger,debug,engine,closed,reason,finally,closed,latch,count,down
InternalEngine -> @Override     protected final void closeNoLock(String reason, CountDownLatch closedLatch);1525162917;Closes the engine without acquiring the write lock. This should only be_called while the write lock is hold or in a disaster condition ie. if the engine_is failed.;@Override_    protected final void closeNoLock(String reason, CountDownLatch closedLatch) {_        if (isClosed.compareAndSet(false, true)) {_            assert rwl.isWriteLockedByCurrentThread() || failEngineLock.isHeldByCurrentThread() : "Either the write lock must be held or the engine must be currently be failing itself"__            try {_                this.versionMap.clear()__                if (internalSearcherManager != null) {_                    internalSearcherManager.removeListener(versionMap)__                }_                try {_                    IOUtils.close(externalSearcherManager, internalSearcherManager)__                } catch (Exception e) {_                    logger.warn("Failed to close SearcherManager", e)__                }_                try {_                    IOUtils.close(translog)__                } catch (Exception e) {_                    logger.warn("Failed to close translog", e)__                }_                _                logger.trace("rollback indexWriter")__                try {_                    indexWriter.rollback()__                } catch (AlreadyClosedException ex) {_                    failOnTragicEvent(ex)__                    throw ex__                }_                logger.trace("rollback indexWriter done")__            } catch (Exception e) {_                logger.warn("failed to rollback writer on close", e)__            } finally {_                try {_                    store.decRef()__                    logger.debug("engine closed [{}]", reason)__                } finally {_                    closedLatch.countDown()__                }_            }_        }_    };closes,the,engine,without,acquiring,the,write,lock,this,should,only,be,called,while,the,write,lock,is,hold,or,in,a,disaster,condition,ie,if,the,engine,is,failed;override,protected,final,void,close,no,lock,string,reason,count,down,latch,closed,latch,if,is,closed,compare,and,set,false,true,assert,rwl,is,write,locked,by,current,thread,fail,engine,lock,is,held,by,current,thread,either,the,write,lock,must,be,held,or,the,engine,must,be,currently,be,failing,itself,try,this,version,map,clear,if,internal,searcher,manager,null,internal,searcher,manager,remove,listener,version,map,try,ioutils,close,external,searcher,manager,internal,searcher,manager,catch,exception,e,logger,warn,failed,to,close,searcher,manager,e,try,ioutils,close,translog,catch,exception,e,logger,warn,failed,to,close,translog,e,logger,trace,rollback,index,writer,try,index,writer,rollback,catch,already,closed,exception,ex,fail,on,tragic,event,ex,throw,ex,logger,trace,rollback,index,writer,done,catch,exception,e,logger,warn,failed,to,rollback,writer,on,close,e,finally,try,store,dec,ref,logger,debug,engine,closed,reason,finally,closed,latch,count,down
InternalEngine -> @Override     protected final void closeNoLock(String reason, CountDownLatch closedLatch);1528706846;Closes the engine without acquiring the write lock. This should only be_called while the write lock is hold or in a disaster condition ie. if the engine_is failed.;@Override_    protected final void closeNoLock(String reason, CountDownLatch closedLatch) {_        if (isClosed.compareAndSet(false, true)) {_            assert rwl.isWriteLockedByCurrentThread() || failEngineLock.isHeldByCurrentThread() : "Either the write lock must be held or the engine must be currently be failing itself"__            try {_                this.versionMap.clear()__                if (internalSearcherManager != null) {_                    internalSearcherManager.removeListener(versionMap)__                }_                try {_                    IOUtils.close(externalSearcherManager, internalSearcherManager)__                } catch (Exception e) {_                    logger.warn("Failed to close SearcherManager", e)__                }_                try {_                    IOUtils.close(translog)__                } catch (Exception e) {_                    logger.warn("Failed to close translog", e)__                }_                _                logger.trace("rollback indexWriter")__                try {_                    indexWriter.rollback()__                } catch (AlreadyClosedException ex) {_                    failOnTragicEvent(ex)__                    throw ex__                }_                logger.trace("rollback indexWriter done")__            } catch (Exception e) {_                logger.warn("failed to rollback writer on close", e)__            } finally {_                try {_                    store.decRef()__                    logger.debug("engine closed [{}]", reason)__                } finally {_                    closedLatch.countDown()__                }_            }_        }_    };closes,the,engine,without,acquiring,the,write,lock,this,should,only,be,called,while,the,write,lock,is,hold,or,in,a,disaster,condition,ie,if,the,engine,is,failed;override,protected,final,void,close,no,lock,string,reason,count,down,latch,closed,latch,if,is,closed,compare,and,set,false,true,assert,rwl,is,write,locked,by,current,thread,fail,engine,lock,is,held,by,current,thread,either,the,write,lock,must,be,held,or,the,engine,must,be,currently,be,failing,itself,try,this,version,map,clear,if,internal,searcher,manager,null,internal,searcher,manager,remove,listener,version,map,try,ioutils,close,external,searcher,manager,internal,searcher,manager,catch,exception,e,logger,warn,failed,to,close,searcher,manager,e,try,ioutils,close,translog,catch,exception,e,logger,warn,failed,to,close,translog,e,logger,trace,rollback,index,writer,try,index,writer,rollback,catch,already,closed,exception,ex,fail,on,tragic,event,ex,throw,ex,logger,trace,rollback,index,writer,done,catch,exception,e,logger,warn,failed,to,rollback,writer,on,close,e,finally,try,store,dec,ref,logger,debug,engine,closed,reason,finally,closed,latch,count,down
InternalEngine -> @Override     protected final void closeNoLock(String reason, CountDownLatch closedLatch);1528762805;Closes the engine without acquiring the write lock. This should only be_called while the write lock is hold or in a disaster condition ie. if the engine_is failed.;@Override_    protected final void closeNoLock(String reason, CountDownLatch closedLatch) {_        if (isClosed.compareAndSet(false, true)) {_            assert rwl.isWriteLockedByCurrentThread() || failEngineLock.isHeldByCurrentThread() : "Either the write lock must be held or the engine must be currently be failing itself"__            try {_                this.versionMap.clear()__                if (internalSearcherManager != null) {_                    internalSearcherManager.removeListener(versionMap)__                }_                try {_                    IOUtils.close(externalSearcherManager, internalSearcherManager)__                } catch (Exception e) {_                    logger.warn("Failed to close SearcherManager", e)__                }_                try {_                    IOUtils.close(translog)__                } catch (Exception e) {_                    logger.warn("Failed to close translog", e)__                }_                _                logger.trace("rollback indexWriter")__                try {_                    indexWriter.rollback()__                } catch (AlreadyClosedException ex) {_                    failOnTragicEvent(ex)__                    throw ex__                }_                logger.trace("rollback indexWriter done")__            } catch (Exception e) {_                logger.warn("failed to rollback writer on close", e)__            } finally {_                try {_                    store.decRef()__                    logger.debug("engine closed [{}]", reason)__                } finally {_                    closedLatch.countDown()__                }_            }_        }_    };closes,the,engine,without,acquiring,the,write,lock,this,should,only,be,called,while,the,write,lock,is,hold,or,in,a,disaster,condition,ie,if,the,engine,is,failed;override,protected,final,void,close,no,lock,string,reason,count,down,latch,closed,latch,if,is,closed,compare,and,set,false,true,assert,rwl,is,write,locked,by,current,thread,fail,engine,lock,is,held,by,current,thread,either,the,write,lock,must,be,held,or,the,engine,must,be,currently,be,failing,itself,try,this,version,map,clear,if,internal,searcher,manager,null,internal,searcher,manager,remove,listener,version,map,try,ioutils,close,external,searcher,manager,internal,searcher,manager,catch,exception,e,logger,warn,failed,to,close,searcher,manager,e,try,ioutils,close,translog,catch,exception,e,logger,warn,failed,to,close,translog,e,logger,trace,rollback,index,writer,try,index,writer,rollback,catch,already,closed,exception,ex,fail,on,tragic,event,ex,throw,ex,logger,trace,rollback,index,writer,done,catch,exception,e,logger,warn,failed,to,rollback,writer,on,close,e,finally,try,store,dec,ref,logger,debug,engine,closed,reason,finally,closed,latch,count,down
InternalEngine -> @Override     protected final void closeNoLock(String reason, CountDownLatch closedLatch);1531910483;Closes the engine without acquiring the write lock. This should only be_called while the write lock is hold or in a disaster condition ie. if the engine_is failed.;@Override_    protected final void closeNoLock(String reason, CountDownLatch closedLatch) {_        if (isClosed.compareAndSet(false, true)) {_            assert rwl.isWriteLockedByCurrentThread() || failEngineLock.isHeldByCurrentThread() : "Either the write lock must be held or the engine must be currently be failing itself"__            try {_                this.versionMap.clear()__                if (internalSearcherManager != null) {_                    internalSearcherManager.removeListener(versionMap)__                }_                try {_                    IOUtils.close(externalSearcherManager, internalSearcherManager)__                } catch (Exception e) {_                    logger.warn("Failed to close SearcherManager", e)__                }_                try {_                    IOUtils.close(translog)__                } catch (Exception e) {_                    logger.warn("Failed to close translog", e)__                }_                _                logger.trace("rollback indexWriter")__                try {_                    indexWriter.rollback()__                } catch (AlreadyClosedException ex) {_                    failOnTragicEvent(ex)__                    throw ex__                }_                logger.trace("rollback indexWriter done")__            } catch (Exception e) {_                logger.warn("failed to rollback writer on close", e)__            } finally {_                try {_                    store.decRef()__                    logger.debug("engine closed [{}]", reason)__                } finally {_                    closedLatch.countDown()__                }_            }_        }_    };closes,the,engine,without,acquiring,the,write,lock,this,should,only,be,called,while,the,write,lock,is,hold,or,in,a,disaster,condition,ie,if,the,engine,is,failed;override,protected,final,void,close,no,lock,string,reason,count,down,latch,closed,latch,if,is,closed,compare,and,set,false,true,assert,rwl,is,write,locked,by,current,thread,fail,engine,lock,is,held,by,current,thread,either,the,write,lock,must,be,held,or,the,engine,must,be,currently,be,failing,itself,try,this,version,map,clear,if,internal,searcher,manager,null,internal,searcher,manager,remove,listener,version,map,try,ioutils,close,external,searcher,manager,internal,searcher,manager,catch,exception,e,logger,warn,failed,to,close,searcher,manager,e,try,ioutils,close,translog,catch,exception,e,logger,warn,failed,to,close,translog,e,logger,trace,rollback,index,writer,try,index,writer,rollback,catch,already,closed,exception,ex,fail,on,tragic,event,ex,throw,ex,logger,trace,rollback,index,writer,done,catch,exception,e,logger,warn,failed,to,rollback,writer,on,close,e,finally,try,store,dec,ref,logger,debug,engine,closed,reason,finally,closed,latch,count,down
InternalEngine -> @Override     protected final void closeNoLock(String reason, CountDownLatch closedLatch);1533295538;Closes the engine without acquiring the write lock. This should only be_called while the write lock is hold or in a disaster condition ie. if the engine_is failed.;@Override_    protected final void closeNoLock(String reason, CountDownLatch closedLatch) {_        if (isClosed.compareAndSet(false, true)) {_            assert rwl.isWriteLockedByCurrentThread() || failEngineLock.isHeldByCurrentThread() : "Either the write lock must be held or the engine must be currently be failing itself"__            try {_                this.versionMap.clear()__                if (internalSearcherManager != null) {_                    internalSearcherManager.removeListener(versionMap)__                }_                try {_                    IOUtils.close(externalSearcherManager, internalSearcherManager)__                } catch (Exception e) {_                    logger.warn("Failed to close SearcherManager", e)__                }_                try {_                    IOUtils.close(translog)__                } catch (Exception e) {_                    logger.warn("Failed to close translog", e)__                }_                _                logger.trace("rollback indexWriter")__                try {_                    indexWriter.rollback()__                } catch (AlreadyClosedException ex) {_                    failOnTragicEvent(ex)__                    throw ex__                }_                logger.trace("rollback indexWriter done")__            } catch (Exception e) {_                logger.warn("failed to rollback writer on close", e)__            } finally {_                try {_                    store.decRef()__                    logger.debug("engine closed [{}]", reason)__                } finally {_                    closedLatch.countDown()__                }_            }_        }_    };closes,the,engine,without,acquiring,the,write,lock,this,should,only,be,called,while,the,write,lock,is,hold,or,in,a,disaster,condition,ie,if,the,engine,is,failed;override,protected,final,void,close,no,lock,string,reason,count,down,latch,closed,latch,if,is,closed,compare,and,set,false,true,assert,rwl,is,write,locked,by,current,thread,fail,engine,lock,is,held,by,current,thread,either,the,write,lock,must,be,held,or,the,engine,must,be,currently,be,failing,itself,try,this,version,map,clear,if,internal,searcher,manager,null,internal,searcher,manager,remove,listener,version,map,try,ioutils,close,external,searcher,manager,internal,searcher,manager,catch,exception,e,logger,warn,failed,to,close,searcher,manager,e,try,ioutils,close,translog,catch,exception,e,logger,warn,failed,to,close,translog,e,logger,trace,rollback,index,writer,try,index,writer,rollback,catch,already,closed,exception,ex,fail,on,tragic,event,ex,throw,ex,logger,trace,rollback,index,writer,done,catch,exception,e,logger,warn,failed,to,rollback,writer,on,close,e,finally,try,store,dec,ref,logger,debug,engine,closed,reason,finally,closed,latch,count,down
InternalEngine -> @Override     protected final void closeNoLock(String reason, CountDownLatch closedLatch);1534848846;Closes the engine without acquiring the write lock. This should only be_called while the write lock is hold or in a disaster condition ie. if the engine_is failed.;@Override_    protected final void closeNoLock(String reason, CountDownLatch closedLatch) {_        if (isClosed.compareAndSet(false, true)) {_            assert rwl.isWriteLockedByCurrentThread() || failEngineLock.isHeldByCurrentThread() : "Either the write lock must be held or the engine must be currently be failing itself"__            try {_                this.versionMap.clear()__                if (internalSearcherManager != null) {_                    internalSearcherManager.removeListener(versionMap)__                }_                try {_                    IOUtils.close(externalSearcherManager, internalSearcherManager)__                } catch (Exception e) {_                    logger.warn("Failed to close SearcherManager", e)__                }_                try {_                    IOUtils.close(translog)__                } catch (Exception e) {_                    logger.warn("Failed to close translog", e)__                }_                _                logger.trace("rollback indexWriter")__                try {_                    indexWriter.rollback()__                } catch (AlreadyClosedException ex) {_                    failOnTragicEvent(ex)__                    throw ex__                }_                logger.trace("rollback indexWriter done")__            } catch (Exception e) {_                logger.warn("failed to rollback writer on close", e)__            } finally {_                try {_                    store.decRef()__                    logger.debug("engine closed [{}]", reason)__                } finally {_                    closedLatch.countDown()__                }_            }_        }_    };closes,the,engine,without,acquiring,the,write,lock,this,should,only,be,called,while,the,write,lock,is,hold,or,in,a,disaster,condition,ie,if,the,engine,is,failed;override,protected,final,void,close,no,lock,string,reason,count,down,latch,closed,latch,if,is,closed,compare,and,set,false,true,assert,rwl,is,write,locked,by,current,thread,fail,engine,lock,is,held,by,current,thread,either,the,write,lock,must,be,held,or,the,engine,must,be,currently,be,failing,itself,try,this,version,map,clear,if,internal,searcher,manager,null,internal,searcher,manager,remove,listener,version,map,try,ioutils,close,external,searcher,manager,internal,searcher,manager,catch,exception,e,logger,warn,failed,to,close,searcher,manager,e,try,ioutils,close,translog,catch,exception,e,logger,warn,failed,to,close,translog,e,logger,trace,rollback,index,writer,try,index,writer,rollback,catch,already,closed,exception,ex,fail,on,tragic,event,ex,throw,ex,logger,trace,rollback,index,writer,done,catch,exception,e,logger,warn,failed,to,rollback,writer,on,close,e,finally,try,store,dec,ref,logger,debug,engine,closed,reason,finally,closed,latch,count,down
InternalEngine -> @Override     protected final void closeNoLock(String reason, CountDownLatch closedLatch);1535046779;Closes the engine without acquiring the write lock. This should only be_called while the write lock is hold or in a disaster condition ie. if the engine_is failed.;@Override_    protected final void closeNoLock(String reason, CountDownLatch closedLatch) {_        if (isClosed.compareAndSet(false, true)) {_            assert rwl.isWriteLockedByCurrentThread() || failEngineLock.isHeldByCurrentThread() : "Either the write lock must be held or the engine must be currently be failing itself"__            try {_                this.versionMap.clear()__                if (internalSearcherManager != null) {_                    internalSearcherManager.removeListener(versionMap)__                }_                try {_                    IOUtils.close(externalSearcherManager, internalSearcherManager)__                } catch (Exception e) {_                    logger.warn("Failed to close SearcherManager", e)__                }_                try {_                    IOUtils.close(translog)__                } catch (Exception e) {_                    logger.warn("Failed to close translog", e)__                }_                _                logger.trace("rollback indexWriter")__                try {_                    indexWriter.rollback()__                } catch (AlreadyClosedException ex) {_                    failOnTragicEvent(ex)__                    throw ex__                }_                logger.trace("rollback indexWriter done")__            } catch (Exception e) {_                logger.warn("failed to rollback writer on close", e)__            } finally {_                try {_                    store.decRef()__                    logger.debug("engine closed [{}]", reason)__                } finally {_                    closedLatch.countDown()__                }_            }_        }_    };closes,the,engine,without,acquiring,the,write,lock,this,should,only,be,called,while,the,write,lock,is,hold,or,in,a,disaster,condition,ie,if,the,engine,is,failed;override,protected,final,void,close,no,lock,string,reason,count,down,latch,closed,latch,if,is,closed,compare,and,set,false,true,assert,rwl,is,write,locked,by,current,thread,fail,engine,lock,is,held,by,current,thread,either,the,write,lock,must,be,held,or,the,engine,must,be,currently,be,failing,itself,try,this,version,map,clear,if,internal,searcher,manager,null,internal,searcher,manager,remove,listener,version,map,try,ioutils,close,external,searcher,manager,internal,searcher,manager,catch,exception,e,logger,warn,failed,to,close,searcher,manager,e,try,ioutils,close,translog,catch,exception,e,logger,warn,failed,to,close,translog,e,logger,trace,rollback,index,writer,try,index,writer,rollback,catch,already,closed,exception,ex,fail,on,tragic,event,ex,throw,ex,logger,trace,rollback,index,writer,done,catch,exception,e,logger,warn,failed,to,rollback,writer,on,close,e,finally,try,store,dec,ref,logger,debug,engine,closed,reason,finally,closed,latch,count,down
InternalEngine -> @Override     protected final void closeNoLock(String reason, CountDownLatch closedLatch);1535405719;Closes the engine without acquiring the write lock. This should only be_called while the write lock is hold or in a disaster condition ie. if the engine_is failed.;@Override_    protected final void closeNoLock(String reason, CountDownLatch closedLatch) {_        if (isClosed.compareAndSet(false, true)) {_            assert rwl.isWriteLockedByCurrentThread() || failEngineLock.isHeldByCurrentThread() : "Either the write lock must be held or the engine must be currently be failing itself"__            try {_                this.versionMap.clear()__                if (internalSearcherManager != null) {_                    internalSearcherManager.removeListener(versionMap)__                }_                try {_                    IOUtils.close(externalSearcherManager, internalSearcherManager)__                } catch (Exception e) {_                    logger.warn("Failed to close SearcherManager", e)__                }_                try {_                    IOUtils.close(translog)__                } catch (Exception e) {_                    logger.warn("Failed to close translog", e)__                }_                _                logger.trace("rollback indexWriter")__                try {_                    indexWriter.rollback()__                } catch (AlreadyClosedException ex) {_                    failOnTragicEvent(ex)__                    throw ex__                }_                logger.trace("rollback indexWriter done")__            } catch (Exception e) {_                logger.warn("failed to rollback writer on close", e)__            } finally {_                try {_                    store.decRef()__                    logger.debug("engine closed [{}]", reason)__                } finally {_                    closedLatch.countDown()__                }_            }_        }_    };closes,the,engine,without,acquiring,the,write,lock,this,should,only,be,called,while,the,write,lock,is,hold,or,in,a,disaster,condition,ie,if,the,engine,is,failed;override,protected,final,void,close,no,lock,string,reason,count,down,latch,closed,latch,if,is,closed,compare,and,set,false,true,assert,rwl,is,write,locked,by,current,thread,fail,engine,lock,is,held,by,current,thread,either,the,write,lock,must,be,held,or,the,engine,must,be,currently,be,failing,itself,try,this,version,map,clear,if,internal,searcher,manager,null,internal,searcher,manager,remove,listener,version,map,try,ioutils,close,external,searcher,manager,internal,searcher,manager,catch,exception,e,logger,warn,failed,to,close,searcher,manager,e,try,ioutils,close,translog,catch,exception,e,logger,warn,failed,to,close,translog,e,logger,trace,rollback,index,writer,try,index,writer,rollback,catch,already,closed,exception,ex,fail,on,tragic,event,ex,throw,ex,logger,trace,rollback,index,writer,done,catch,exception,e,logger,warn,failed,to,rollback,writer,on,close,e,finally,try,store,dec,ref,logger,debug,engine,closed,reason,finally,closed,latch,count,down
InternalEngine -> @Override     protected final void closeNoLock(String reason, CountDownLatch closedLatch);1535723122;Closes the engine without acquiring the write lock. This should only be_called while the write lock is hold or in a disaster condition ie. if the engine_is failed.;@Override_    protected final void closeNoLock(String reason, CountDownLatch closedLatch) {_        if (isClosed.compareAndSet(false, true)) {_            assert rwl.isWriteLockedByCurrentThread() || failEngineLock.isHeldByCurrentThread() : "Either the write lock must be held or the engine must be currently be failing itself"__            try {_                this.versionMap.clear()__                if (internalSearcherManager != null) {_                    internalSearcherManager.removeListener(versionMap)__                }_                try {_                    IOUtils.close(externalSearcherManager, internalSearcherManager)__                } catch (Exception e) {_                    logger.warn("Failed to close SearcherManager", e)__                }_                try {_                    IOUtils.close(translog)__                } catch (Exception e) {_                    logger.warn("Failed to close translog", e)__                }_                _                logger.trace("rollback indexWriter")__                try {_                    indexWriter.rollback()__                } catch (AlreadyClosedException ex) {_                    failOnTragicEvent(ex)__                    throw ex__                }_                logger.trace("rollback indexWriter done")__            } catch (Exception e) {_                logger.warn("failed to rollback writer on close", e)__            } finally {_                try {_                    store.decRef()__                    logger.debug("engine closed [{}]", reason)__                } finally {_                    closedLatch.countDown()__                }_            }_        }_    };closes,the,engine,without,acquiring,the,write,lock,this,should,only,be,called,while,the,write,lock,is,hold,or,in,a,disaster,condition,ie,if,the,engine,is,failed;override,protected,final,void,close,no,lock,string,reason,count,down,latch,closed,latch,if,is,closed,compare,and,set,false,true,assert,rwl,is,write,locked,by,current,thread,fail,engine,lock,is,held,by,current,thread,either,the,write,lock,must,be,held,or,the,engine,must,be,currently,be,failing,itself,try,this,version,map,clear,if,internal,searcher,manager,null,internal,searcher,manager,remove,listener,version,map,try,ioutils,close,external,searcher,manager,internal,searcher,manager,catch,exception,e,logger,warn,failed,to,close,searcher,manager,e,try,ioutils,close,translog,catch,exception,e,logger,warn,failed,to,close,translog,e,logger,trace,rollback,index,writer,try,index,writer,rollback,catch,already,closed,exception,ex,fail,on,tragic,event,ex,throw,ex,logger,trace,rollback,index,writer,done,catch,exception,e,logger,warn,failed,to,rollback,writer,on,close,e,finally,try,store,dec,ref,logger,debug,engine,closed,reason,finally,closed,latch,count,down
InternalEngine -> @Override     protected final void closeNoLock(String reason, CountDownLatch closedLatch);1535965276;Closes the engine without acquiring the write lock. This should only be_called while the write lock is hold or in a disaster condition ie. if the engine_is failed.;@Override_    protected final void closeNoLock(String reason, CountDownLatch closedLatch) {_        if (isClosed.compareAndSet(false, true)) {_            assert rwl.isWriteLockedByCurrentThread() || failEngineLock.isHeldByCurrentThread() : "Either the write lock must be held or the engine must be currently be failing itself"__            try {_                this.versionMap.clear()__                if (internalSearcherManager != null) {_                    internalSearcherManager.removeListener(versionMap)__                }_                try {_                    IOUtils.close(externalSearcherManager, internalSearcherManager)__                } catch (Exception e) {_                    logger.warn("Failed to close SearcherManager", e)__                }_                try {_                    IOUtils.close(translog)__                } catch (Exception e) {_                    logger.warn("Failed to close translog", e)__                }_                _                logger.trace("rollback indexWriter")__                try {_                    indexWriter.rollback()__                } catch (AlreadyClosedException ex) {_                    failOnTragicEvent(ex)__                    throw ex__                }_                logger.trace("rollback indexWriter done")__            } catch (Exception e) {_                logger.warn("failed to rollback writer on close", e)__            } finally {_                try {_                    store.decRef()__                    logger.debug("engine closed [{}]", reason)__                } finally {_                    closedLatch.countDown()__                }_            }_        }_    };closes,the,engine,without,acquiring,the,write,lock,this,should,only,be,called,while,the,write,lock,is,hold,or,in,a,disaster,condition,ie,if,the,engine,is,failed;override,protected,final,void,close,no,lock,string,reason,count,down,latch,closed,latch,if,is,closed,compare,and,set,false,true,assert,rwl,is,write,locked,by,current,thread,fail,engine,lock,is,held,by,current,thread,either,the,write,lock,must,be,held,or,the,engine,must,be,currently,be,failing,itself,try,this,version,map,clear,if,internal,searcher,manager,null,internal,searcher,manager,remove,listener,version,map,try,ioutils,close,external,searcher,manager,internal,searcher,manager,catch,exception,e,logger,warn,failed,to,close,searcher,manager,e,try,ioutils,close,translog,catch,exception,e,logger,warn,failed,to,close,translog,e,logger,trace,rollback,index,writer,try,index,writer,rollback,catch,already,closed,exception,ex,fail,on,tragic,event,ex,throw,ex,logger,trace,rollback,index,writer,done,catch,exception,e,logger,warn,failed,to,rollback,writer,on,close,e,finally,try,store,dec,ref,logger,debug,engine,closed,reason,finally,closed,latch,count,down
InternalEngine -> @Override     protected final void closeNoLock(String reason, CountDownLatch closedLatch);1536218260;Closes the engine without acquiring the write lock. This should only be_called while the write lock is hold or in a disaster condition ie. if the engine_is failed.;@Override_    protected final void closeNoLock(String reason, CountDownLatch closedLatch) {_        if (isClosed.compareAndSet(false, true)) {_            assert rwl.isWriteLockedByCurrentThread() || failEngineLock.isHeldByCurrentThread() : "Either the write lock must be held or the engine must be currently be failing itself"__            try {_                this.versionMap.clear()__                if (internalSearcherManager != null) {_                    internalSearcherManager.removeListener(versionMap)__                }_                try {_                    IOUtils.close(externalSearcherManager, internalSearcherManager)__                } catch (Exception e) {_                    logger.warn("Failed to close SearcherManager", e)__                }_                try {_                    IOUtils.close(translog)__                } catch (Exception e) {_                    logger.warn("Failed to close translog", e)__                }_                _                logger.trace("rollback indexWriter")__                try {_                    indexWriter.rollback()__                } catch (AlreadyClosedException ex) {_                    failOnTragicEvent(ex)__                    throw ex__                }_                logger.trace("rollback indexWriter done")__            } catch (Exception e) {_                logger.warn("failed to rollback writer on close", e)__            } finally {_                try {_                    store.decRef()__                    logger.debug("engine closed [{}]", reason)__                } finally {_                    closedLatch.countDown()__                }_            }_        }_    };closes,the,engine,without,acquiring,the,write,lock,this,should,only,be,called,while,the,write,lock,is,hold,or,in,a,disaster,condition,ie,if,the,engine,is,failed;override,protected,final,void,close,no,lock,string,reason,count,down,latch,closed,latch,if,is,closed,compare,and,set,false,true,assert,rwl,is,write,locked,by,current,thread,fail,engine,lock,is,held,by,current,thread,either,the,write,lock,must,be,held,or,the,engine,must,be,currently,be,failing,itself,try,this,version,map,clear,if,internal,searcher,manager,null,internal,searcher,manager,remove,listener,version,map,try,ioutils,close,external,searcher,manager,internal,searcher,manager,catch,exception,e,logger,warn,failed,to,close,searcher,manager,e,try,ioutils,close,translog,catch,exception,e,logger,warn,failed,to,close,translog,e,logger,trace,rollback,index,writer,try,index,writer,rollback,catch,already,closed,exception,ex,fail,on,tragic,event,ex,throw,ex,logger,trace,rollback,index,writer,done,catch,exception,e,logger,warn,failed,to,rollback,writer,on,close,e,finally,try,store,dec,ref,logger,debug,engine,closed,reason,finally,closed,latch,count,down
InternalEngine -> @Override     protected final void closeNoLock(String reason, CountDownLatch closedLatch);1536314350;Closes the engine without acquiring the write lock. This should only be_called while the write lock is hold or in a disaster condition ie. if the engine_is failed.;@Override_    protected final void closeNoLock(String reason, CountDownLatch closedLatch) {_        if (isClosed.compareAndSet(false, true)) {_            assert rwl.isWriteLockedByCurrentThread() || failEngineLock.isHeldByCurrentThread() : "Either the write lock must be held or the engine must be currently be failing itself"__            try {_                this.versionMap.clear()__                if (internalSearcherManager != null) {_                    internalSearcherManager.removeListener(versionMap)__                }_                try {_                    IOUtils.close(externalSearcherManager, internalSearcherManager)__                } catch (Exception e) {_                    logger.warn("Failed to close SearcherManager", e)__                }_                try {_                    IOUtils.close(translog)__                } catch (Exception e) {_                    logger.warn("Failed to close translog", e)__                }_                _                logger.trace("rollback indexWriter")__                try {_                    indexWriter.rollback()__                } catch (AlreadyClosedException ex) {_                    failOnTragicEvent(ex)__                    throw ex__                }_                logger.trace("rollback indexWriter done")__            } catch (Exception e) {_                logger.warn("failed to rollback writer on close", e)__            } finally {_                try {_                    store.decRef()__                    logger.debug("engine closed [{}]", reason)__                } finally {_                    closedLatch.countDown()__                }_            }_        }_    };closes,the,engine,without,acquiring,the,write,lock,this,should,only,be,called,while,the,write,lock,is,hold,or,in,a,disaster,condition,ie,if,the,engine,is,failed;override,protected,final,void,close,no,lock,string,reason,count,down,latch,closed,latch,if,is,closed,compare,and,set,false,true,assert,rwl,is,write,locked,by,current,thread,fail,engine,lock,is,held,by,current,thread,either,the,write,lock,must,be,held,or,the,engine,must,be,currently,be,failing,itself,try,this,version,map,clear,if,internal,searcher,manager,null,internal,searcher,manager,remove,listener,version,map,try,ioutils,close,external,searcher,manager,internal,searcher,manager,catch,exception,e,logger,warn,failed,to,close,searcher,manager,e,try,ioutils,close,translog,catch,exception,e,logger,warn,failed,to,close,translog,e,logger,trace,rollback,index,writer,try,index,writer,rollback,catch,already,closed,exception,ex,fail,on,tragic,event,ex,throw,ex,logger,trace,rollback,index,writer,done,catch,exception,e,logger,warn,failed,to,rollback,writer,on,close,e,finally,try,store,dec,ref,logger,debug,engine,closed,reason,finally,closed,latch,count,down
InternalEngine -> @Override     protected final void closeNoLock(String reason, CountDownLatch closedLatch);1536828374;Closes the engine without acquiring the write lock. This should only be_called while the write lock is hold or in a disaster condition ie. if the engine_is failed.;@Override_    protected final void closeNoLock(String reason, CountDownLatch closedLatch) {_        if (isClosed.compareAndSet(false, true)) {_            assert rwl.isWriteLockedByCurrentThread() || failEngineLock.isHeldByCurrentThread() : "Either the write lock must be held or the engine must be currently be failing itself"__            try {_                this.versionMap.clear()__                if (internalSearcherManager != null) {_                    internalSearcherManager.removeListener(versionMap)__                }_                try {_                    IOUtils.close(externalSearcherManager, internalSearcherManager)__                } catch (Exception e) {_                    logger.warn("Failed to close SearcherManager", e)__                }_                try {_                    IOUtils.close(translog)__                } catch (Exception e) {_                    logger.warn("Failed to close translog", e)__                }_                _                logger.trace("rollback indexWriter")__                try {_                    indexWriter.rollback()__                } catch (AlreadyClosedException ex) {_                    failOnTragicEvent(ex)__                    throw ex__                }_                logger.trace("rollback indexWriter done")__            } catch (Exception e) {_                logger.warn("failed to rollback writer on close", e)__            } finally {_                try {_                    store.decRef()__                    logger.debug("engine closed [{}]", reason)__                } finally {_                    closedLatch.countDown()__                }_            }_        }_    };closes,the,engine,without,acquiring,the,write,lock,this,should,only,be,called,while,the,write,lock,is,hold,or,in,a,disaster,condition,ie,if,the,engine,is,failed;override,protected,final,void,close,no,lock,string,reason,count,down,latch,closed,latch,if,is,closed,compare,and,set,false,true,assert,rwl,is,write,locked,by,current,thread,fail,engine,lock,is,held,by,current,thread,either,the,write,lock,must,be,held,or,the,engine,must,be,currently,be,failing,itself,try,this,version,map,clear,if,internal,searcher,manager,null,internal,searcher,manager,remove,listener,version,map,try,ioutils,close,external,searcher,manager,internal,searcher,manager,catch,exception,e,logger,warn,failed,to,close,searcher,manager,e,try,ioutils,close,translog,catch,exception,e,logger,warn,failed,to,close,translog,e,logger,trace,rollback,index,writer,try,index,writer,rollback,catch,already,closed,exception,ex,fail,on,tragic,event,ex,throw,ex,logger,trace,rollback,index,writer,done,catch,exception,e,logger,warn,failed,to,rollback,writer,on,close,e,finally,try,store,dec,ref,logger,debug,engine,closed,reason,finally,closed,latch,count,down
InternalEngine -> @Override     protected final void closeNoLock(String reason, CountDownLatch closedLatch);1537806831;Closes the engine without acquiring the write lock. This should only be_called while the write lock is hold or in a disaster condition ie. if the engine_is failed.;@Override_    protected final void closeNoLock(String reason, CountDownLatch closedLatch) {_        if (isClosed.compareAndSet(false, true)) {_            assert rwl.isWriteLockedByCurrentThread() || failEngineLock.isHeldByCurrentThread() : "Either the write lock must be held or the engine must be currently be failing itself"__            try {_                this.versionMap.clear()__                if (internalSearcherManager != null) {_                    internalSearcherManager.removeListener(versionMap)__                }_                try {_                    IOUtils.close(externalSearcherManager, internalSearcherManager)__                } catch (Exception e) {_                    logger.warn("Failed to close SearcherManager", e)__                }_                try {_                    IOUtils.close(translog)__                } catch (Exception e) {_                    logger.warn("Failed to close translog", e)__                }_                _                logger.trace("rollback indexWriter")__                try {_                    indexWriter.rollback()__                } catch (AlreadyClosedException ex) {_                    failOnTragicEvent(ex)__                    throw ex__                }_                logger.trace("rollback indexWriter done")__            } catch (Exception e) {_                logger.warn("failed to rollback writer on close", e)__            } finally {_                try {_                    store.decRef()__                    logger.debug("engine closed [{}]", reason)__                } finally {_                    closedLatch.countDown()__                }_            }_        }_    };closes,the,engine,without,acquiring,the,write,lock,this,should,only,be,called,while,the,write,lock,is,hold,or,in,a,disaster,condition,ie,if,the,engine,is,failed;override,protected,final,void,close,no,lock,string,reason,count,down,latch,closed,latch,if,is,closed,compare,and,set,false,true,assert,rwl,is,write,locked,by,current,thread,fail,engine,lock,is,held,by,current,thread,either,the,write,lock,must,be,held,or,the,engine,must,be,currently,be,failing,itself,try,this,version,map,clear,if,internal,searcher,manager,null,internal,searcher,manager,remove,listener,version,map,try,ioutils,close,external,searcher,manager,internal,searcher,manager,catch,exception,e,logger,warn,failed,to,close,searcher,manager,e,try,ioutils,close,translog,catch,exception,e,logger,warn,failed,to,close,translog,e,logger,trace,rollback,index,writer,try,index,writer,rollback,catch,already,closed,exception,ex,fail,on,tragic,event,ex,throw,ex,logger,trace,rollback,index,writer,done,catch,exception,e,logger,warn,failed,to,rollback,writer,on,close,e,finally,try,store,dec,ref,logger,debug,engine,closed,reason,finally,closed,latch,count,down
InternalEngine -> @Override     protected final void closeNoLock(String reason, CountDownLatch closedLatch);1538067637;Closes the engine without acquiring the write lock. This should only be_called while the write lock is hold or in a disaster condition ie. if the engine_is failed.;@Override_    protected final void closeNoLock(String reason, CountDownLatch closedLatch) {_        if (isClosed.compareAndSet(false, true)) {_            assert rwl.isWriteLockedByCurrentThread() || failEngineLock.isHeldByCurrentThread() : "Either the write lock must be held or the engine must be currently be failing itself"__            try {_                this.versionMap.clear()__                if (internalSearcherManager != null) {_                    internalSearcherManager.removeListener(versionMap)__                }_                try {_                    IOUtils.close(externalSearcherManager, internalSearcherManager)__                } catch (Exception e) {_                    logger.warn("Failed to close SearcherManager", e)__                }_                try {_                    IOUtils.close(translog)__                } catch (Exception e) {_                    logger.warn("Failed to close translog", e)__                }_                _                logger.trace("rollback indexWriter")__                try {_                    indexWriter.rollback()__                } catch (AlreadyClosedException ex) {_                    failOnTragicEvent(ex)__                    throw ex__                }_                logger.trace("rollback indexWriter done")__            } catch (Exception e) {_                logger.warn("failed to rollback writer on close", e)__            } finally {_                try {_                    store.decRef()__                    logger.debug("engine closed [{}]", reason)__                } finally {_                    closedLatch.countDown()__                }_            }_        }_    };closes,the,engine,without,acquiring,the,write,lock,this,should,only,be,called,while,the,write,lock,is,hold,or,in,a,disaster,condition,ie,if,the,engine,is,failed;override,protected,final,void,close,no,lock,string,reason,count,down,latch,closed,latch,if,is,closed,compare,and,set,false,true,assert,rwl,is,write,locked,by,current,thread,fail,engine,lock,is,held,by,current,thread,either,the,write,lock,must,be,held,or,the,engine,must,be,currently,be,failing,itself,try,this,version,map,clear,if,internal,searcher,manager,null,internal,searcher,manager,remove,listener,version,map,try,ioutils,close,external,searcher,manager,internal,searcher,manager,catch,exception,e,logger,warn,failed,to,close,searcher,manager,e,try,ioutils,close,translog,catch,exception,e,logger,warn,failed,to,close,translog,e,logger,trace,rollback,index,writer,try,index,writer,rollback,catch,already,closed,exception,ex,fail,on,tragic,event,ex,throw,ex,logger,trace,rollback,index,writer,done,catch,exception,e,logger,warn,failed,to,rollback,writer,on,close,e,finally,try,store,dec,ref,logger,debug,engine,closed,reason,finally,closed,latch,count,down
InternalEngine -> @Override     protected final void closeNoLock(String reason, CountDownLatch closedLatch);1538424609;Closes the engine without acquiring the write lock. This should only be_called while the write lock is hold or in a disaster condition ie. if the engine_is failed.;@Override_    protected final void closeNoLock(String reason, CountDownLatch closedLatch) {_        if (isClosed.compareAndSet(false, true)) {_            assert rwl.isWriteLockedByCurrentThread() || failEngineLock.isHeldByCurrentThread() : "Either the write lock must be held or the engine must be currently be failing itself"__            try {_                this.versionMap.clear()__                if (internalSearcherManager != null) {_                    internalSearcherManager.removeListener(versionMap)__                }_                try {_                    IOUtils.close(externalSearcherManager, internalSearcherManager)__                } catch (Exception e) {_                    logger.warn("Failed to close SearcherManager", e)__                }_                try {_                    IOUtils.close(translog)__                } catch (Exception e) {_                    logger.warn("Failed to close translog", e)__                }_                _                logger.trace("rollback indexWriter")__                try {_                    indexWriter.rollback()__                } catch (AlreadyClosedException ex) {_                    failOnTragicEvent(ex)__                    throw ex__                }_                logger.trace("rollback indexWriter done")__            } catch (Exception e) {_                logger.warn("failed to rollback writer on close", e)__            } finally {_                try {_                    store.decRef()__                    logger.debug("engine closed [{}]", reason)__                } finally {_                    closedLatch.countDown()__                }_            }_        }_    };closes,the,engine,without,acquiring,the,write,lock,this,should,only,be,called,while,the,write,lock,is,hold,or,in,a,disaster,condition,ie,if,the,engine,is,failed;override,protected,final,void,close,no,lock,string,reason,count,down,latch,closed,latch,if,is,closed,compare,and,set,false,true,assert,rwl,is,write,locked,by,current,thread,fail,engine,lock,is,held,by,current,thread,either,the,write,lock,must,be,held,or,the,engine,must,be,currently,be,failing,itself,try,this,version,map,clear,if,internal,searcher,manager,null,internal,searcher,manager,remove,listener,version,map,try,ioutils,close,external,searcher,manager,internal,searcher,manager,catch,exception,e,logger,warn,failed,to,close,searcher,manager,e,try,ioutils,close,translog,catch,exception,e,logger,warn,failed,to,close,translog,e,logger,trace,rollback,index,writer,try,index,writer,rollback,catch,already,closed,exception,ex,fail,on,tragic,event,ex,throw,ex,logger,trace,rollback,index,writer,done,catch,exception,e,logger,warn,failed,to,rollback,writer,on,close,e,finally,try,store,dec,ref,logger,debug,engine,closed,reason,finally,closed,latch,count,down
InternalEngine -> @Override     protected final void closeNoLock(String reason, CountDownLatch closedLatch);1539615817;Closes the engine without acquiring the write lock. This should only be_called while the write lock is hold or in a disaster condition ie. if the engine_is failed.;@Override_    protected final void closeNoLock(String reason, CountDownLatch closedLatch) {_        if (isClosed.compareAndSet(false, true)) {_            assert rwl.isWriteLockedByCurrentThread() || failEngineLock.isHeldByCurrentThread() : "Either the write lock must be held or the engine must be currently be failing itself"__            try {_                this.versionMap.clear()__                if (internalSearcherManager != null) {_                    internalSearcherManager.removeListener(versionMap)__                }_                try {_                    IOUtils.close(externalSearcherManager, internalSearcherManager)__                } catch (Exception e) {_                    logger.warn("Failed to close SearcherManager", e)__                }_                try {_                    IOUtils.close(translog)__                } catch (Exception e) {_                    logger.warn("Failed to close translog", e)__                }_                _                logger.trace("rollback indexWriter")__                try {_                    indexWriter.rollback()__                } catch (AlreadyClosedException ex) {_                    failOnTragicEvent(ex)__                    throw ex__                }_                logger.trace("rollback indexWriter done")__            } catch (Exception e) {_                logger.warn("failed to rollback writer on close", e)__            } finally {_                try {_                    store.decRef()__                    logger.debug("engine closed [{}]", reason)__                } finally {_                    closedLatch.countDown()__                }_            }_        }_    };closes,the,engine,without,acquiring,the,write,lock,this,should,only,be,called,while,the,write,lock,is,hold,or,in,a,disaster,condition,ie,if,the,engine,is,failed;override,protected,final,void,close,no,lock,string,reason,count,down,latch,closed,latch,if,is,closed,compare,and,set,false,true,assert,rwl,is,write,locked,by,current,thread,fail,engine,lock,is,held,by,current,thread,either,the,write,lock,must,be,held,or,the,engine,must,be,currently,be,failing,itself,try,this,version,map,clear,if,internal,searcher,manager,null,internal,searcher,manager,remove,listener,version,map,try,ioutils,close,external,searcher,manager,internal,searcher,manager,catch,exception,e,logger,warn,failed,to,close,searcher,manager,e,try,ioutils,close,translog,catch,exception,e,logger,warn,failed,to,close,translog,e,logger,trace,rollback,index,writer,try,index,writer,rollback,catch,already,closed,exception,ex,fail,on,tragic,event,ex,throw,ex,logger,trace,rollback,index,writer,done,catch,exception,e,logger,warn,failed,to,rollback,writer,on,close,e,finally,try,store,dec,ref,logger,debug,engine,closed,reason,finally,closed,latch,count,down
InternalEngine -> @Override     protected final void closeNoLock(String reason, CountDownLatch closedLatch);1539723533;Closes the engine without acquiring the write lock. This should only be_called while the write lock is hold or in a disaster condition ie. if the engine_is failed.;@Override_    protected final void closeNoLock(String reason, CountDownLatch closedLatch) {_        if (isClosed.compareAndSet(false, true)) {_            assert rwl.isWriteLockedByCurrentThread() || failEngineLock.isHeldByCurrentThread() : "Either the write lock must be held or the engine must be currently be failing itself"__            try {_                this.versionMap.clear()__                if (internalSearcherManager != null) {_                    internalSearcherManager.removeListener(versionMap)__                }_                try {_                    IOUtils.close(externalSearcherManager, internalSearcherManager)__                } catch (Exception e) {_                    logger.warn("Failed to close SearcherManager", e)__                }_                try {_                    IOUtils.close(translog)__                } catch (Exception e) {_                    logger.warn("Failed to close translog", e)__                }_                _                logger.trace("rollback indexWriter")__                try {_                    indexWriter.rollback()__                } catch (AlreadyClosedException ex) {_                    failOnTragicEvent(ex)__                    throw ex__                }_                logger.trace("rollback indexWriter done")__            } catch (Exception e) {_                logger.warn("failed to rollback writer on close", e)__            } finally {_                try {_                    store.decRef()__                    logger.debug("engine closed [{}]", reason)__                } finally {_                    closedLatch.countDown()__                }_            }_        }_    };closes,the,engine,without,acquiring,the,write,lock,this,should,only,be,called,while,the,write,lock,is,hold,or,in,a,disaster,condition,ie,if,the,engine,is,failed;override,protected,final,void,close,no,lock,string,reason,count,down,latch,closed,latch,if,is,closed,compare,and,set,false,true,assert,rwl,is,write,locked,by,current,thread,fail,engine,lock,is,held,by,current,thread,either,the,write,lock,must,be,held,or,the,engine,must,be,currently,be,failing,itself,try,this,version,map,clear,if,internal,searcher,manager,null,internal,searcher,manager,remove,listener,version,map,try,ioutils,close,external,searcher,manager,internal,searcher,manager,catch,exception,e,logger,warn,failed,to,close,searcher,manager,e,try,ioutils,close,translog,catch,exception,e,logger,warn,failed,to,close,translog,e,logger,trace,rollback,index,writer,try,index,writer,rollback,catch,already,closed,exception,ex,fail,on,tragic,event,ex,throw,ex,logger,trace,rollback,index,writer,done,catch,exception,e,logger,warn,failed,to,rollback,writer,on,close,e,finally,try,store,dec,ref,logger,debug,engine,closed,reason,finally,closed,latch,count,down
InternalEngine -> @Override     protected final void closeNoLock(String reason, CountDownLatch closedLatch);1540238977;Closes the engine without acquiring the write lock. This should only be_called while the write lock is hold or in a disaster condition ie. if the engine_is failed.;@Override_    protected final void closeNoLock(String reason, CountDownLatch closedLatch) {_        if (isClosed.compareAndSet(false, true)) {_            assert rwl.isWriteLockedByCurrentThread() || failEngineLock.isHeldByCurrentThread() : "Either the write lock must be held or the engine must be currently be failing itself"__            try {_                this.versionMap.clear()__                if (internalSearcherManager != null) {_                    internalSearcherManager.removeListener(versionMap)__                }_                try {_                    IOUtils.close(externalSearcherManager, internalSearcherManager)__                } catch (Exception e) {_                    logger.warn("Failed to close SearcherManager", e)__                }_                try {_                    IOUtils.close(translog)__                } catch (Exception e) {_                    logger.warn("Failed to close translog", e)__                }_                _                logger.trace("rollback indexWriter")__                try {_                    indexWriter.rollback()__                } catch (AlreadyClosedException ex) {_                    failOnTragicEvent(ex)__                    throw ex__                }_                logger.trace("rollback indexWriter done")__            } catch (Exception e) {_                logger.warn("failed to rollback writer on close", e)__            } finally {_                try {_                    store.decRef()__                    logger.debug("engine closed [{}]", reason)__                } finally {_                    closedLatch.countDown()__                }_            }_        }_    };closes,the,engine,without,acquiring,the,write,lock,this,should,only,be,called,while,the,write,lock,is,hold,or,in,a,disaster,condition,ie,if,the,engine,is,failed;override,protected,final,void,close,no,lock,string,reason,count,down,latch,closed,latch,if,is,closed,compare,and,set,false,true,assert,rwl,is,write,locked,by,current,thread,fail,engine,lock,is,held,by,current,thread,either,the,write,lock,must,be,held,or,the,engine,must,be,currently,be,failing,itself,try,this,version,map,clear,if,internal,searcher,manager,null,internal,searcher,manager,remove,listener,version,map,try,ioutils,close,external,searcher,manager,internal,searcher,manager,catch,exception,e,logger,warn,failed,to,close,searcher,manager,e,try,ioutils,close,translog,catch,exception,e,logger,warn,failed,to,close,translog,e,logger,trace,rollback,index,writer,try,index,writer,rollback,catch,already,closed,exception,ex,fail,on,tragic,event,ex,throw,ex,logger,trace,rollback,index,writer,done,catch,exception,e,logger,warn,failed,to,rollback,writer,on,close,e,finally,try,store,dec,ref,logger,debug,engine,closed,reason,finally,closed,latch,count,down
InternalEngine -> @Override     protected final void closeNoLock(String reason, CountDownLatch closedLatch);1541335413;Closes the engine without acquiring the write lock. This should only be_called while the write lock is hold or in a disaster condition ie. if the engine_is failed.;@Override_    protected final void closeNoLock(String reason, CountDownLatch closedLatch) {_        if (isClosed.compareAndSet(false, true)) {_            assert rwl.isWriteLockedByCurrentThread() || failEngineLock.isHeldByCurrentThread() : "Either the write lock must be held or the engine must be currently be failing itself"__            try {_                this.versionMap.clear()__                if (internalSearcherManager != null) {_                    internalSearcherManager.removeListener(versionMap)__                }_                try {_                    IOUtils.close(externalSearcherManager, internalSearcherManager)__                } catch (Exception e) {_                    logger.warn("Failed to close SearcherManager", e)__                }_                try {_                    IOUtils.close(translog)__                } catch (Exception e) {_                    logger.warn("Failed to close translog", e)__                }_                _                logger.trace("rollback indexWriter")__                try {_                    indexWriter.rollback()__                } catch (AlreadyClosedException ex) {_                    failOnTragicEvent(ex)__                    throw ex__                }_                logger.trace("rollback indexWriter done")__            } catch (Exception e) {_                logger.warn("failed to rollback writer on close", e)__            } finally {_                try {_                    store.decRef()__                    logger.debug("engine closed [{}]", reason)__                } finally {_                    closedLatch.countDown()__                }_            }_        }_    };closes,the,engine,without,acquiring,the,write,lock,this,should,only,be,called,while,the,write,lock,is,hold,or,in,a,disaster,condition,ie,if,the,engine,is,failed;override,protected,final,void,close,no,lock,string,reason,count,down,latch,closed,latch,if,is,closed,compare,and,set,false,true,assert,rwl,is,write,locked,by,current,thread,fail,engine,lock,is,held,by,current,thread,either,the,write,lock,must,be,held,or,the,engine,must,be,currently,be,failing,itself,try,this,version,map,clear,if,internal,searcher,manager,null,internal,searcher,manager,remove,listener,version,map,try,ioutils,close,external,searcher,manager,internal,searcher,manager,catch,exception,e,logger,warn,failed,to,close,searcher,manager,e,try,ioutils,close,translog,catch,exception,e,logger,warn,failed,to,close,translog,e,logger,trace,rollback,index,writer,try,index,writer,rollback,catch,already,closed,exception,ex,fail,on,tragic,event,ex,throw,ex,logger,trace,rollback,index,writer,done,catch,exception,e,logger,warn,failed,to,rollback,writer,on,close,e,finally,try,store,dec,ref,logger,debug,engine,closed,reason,finally,closed,latch,count,down
InternalEngine -> @Override     protected final void closeNoLock(String reason, CountDownLatch closedLatch);1541622390;Closes the engine without acquiring the write lock. This should only be_called while the write lock is hold or in a disaster condition ie. if the engine_is failed.;@Override_    protected final void closeNoLock(String reason, CountDownLatch closedLatch) {_        if (isClosed.compareAndSet(false, true)) {_            assert rwl.isWriteLockedByCurrentThread() || failEngineLock.isHeldByCurrentThread() : "Either the write lock must be held or the engine must be currently be failing itself"__            try {_                this.versionMap.clear()__                if (internalSearcherManager != null) {_                    internalSearcherManager.removeListener(versionMap)__                }_                try {_                    IOUtils.close(externalSearcherManager, internalSearcherManager)__                } catch (Exception e) {_                    logger.warn("Failed to close SearcherManager", e)__                }_                try {_                    IOUtils.close(translog)__                } catch (Exception e) {_                    logger.warn("Failed to close translog", e)__                }_                _                logger.trace("rollback indexWriter")__                try {_                    indexWriter.rollback()__                } catch (AlreadyClosedException ex) {_                    failOnTragicEvent(ex)__                    throw ex__                }_                logger.trace("rollback indexWriter done")__            } catch (Exception e) {_                logger.warn("failed to rollback writer on close", e)__            } finally {_                try {_                    store.decRef()__                    logger.debug("engine closed [{}]", reason)__                } finally {_                    closedLatch.countDown()__                }_            }_        }_    };closes,the,engine,without,acquiring,the,write,lock,this,should,only,be,called,while,the,write,lock,is,hold,or,in,a,disaster,condition,ie,if,the,engine,is,failed;override,protected,final,void,close,no,lock,string,reason,count,down,latch,closed,latch,if,is,closed,compare,and,set,false,true,assert,rwl,is,write,locked,by,current,thread,fail,engine,lock,is,held,by,current,thread,either,the,write,lock,must,be,held,or,the,engine,must,be,currently,be,failing,itself,try,this,version,map,clear,if,internal,searcher,manager,null,internal,searcher,manager,remove,listener,version,map,try,ioutils,close,external,searcher,manager,internal,searcher,manager,catch,exception,e,logger,warn,failed,to,close,searcher,manager,e,try,ioutils,close,translog,catch,exception,e,logger,warn,failed,to,close,translog,e,logger,trace,rollback,index,writer,try,index,writer,rollback,catch,already,closed,exception,ex,fail,on,tragic,event,ex,throw,ex,logger,trace,rollback,index,writer,done,catch,exception,e,logger,warn,failed,to,rollback,writer,on,close,e,finally,try,store,dec,ref,logger,debug,engine,closed,reason,finally,closed,latch,count,down
InternalEngine -> @Override     protected final void closeNoLock(String reason, CountDownLatch closedLatch);1542697754;Closes the engine without acquiring the write lock. This should only be_called while the write lock is hold or in a disaster condition ie. if the engine_is failed.;@Override_    protected final void closeNoLock(String reason, CountDownLatch closedLatch) {_        if (isClosed.compareAndSet(false, true)) {_            assert rwl.isWriteLockedByCurrentThread() || failEngineLock.isHeldByCurrentThread() :_                "Either the write lock must be held or the engine must be currently be failing itself"__            try {_                this.versionMap.clear()__                if (internalSearcherManager != null) {_                    internalSearcherManager.removeListener(versionMap)__                }_                try {_                    IOUtils.close(externalSearcherManager, internalSearcherManager)__                } catch (Exception e) {_                    logger.warn("Failed to close SearcherManager", e)__                }_                try {_                    IOUtils.close(translog)__                } catch (Exception e) {_                    logger.warn("Failed to close translog", e)__                }_                _                logger.trace("rollback indexWriter")__                try {_                    indexWriter.rollback()__                } catch (AlreadyClosedException ex) {_                    failOnTragicEvent(ex)__                    throw ex__                }_                logger.trace("rollback indexWriter done")__            } catch (Exception e) {_                logger.warn("failed to rollback writer on close", e)__            } finally {_                try {_                    store.decRef()__                    logger.debug("engine closed [{}]", reason)__                } finally {_                    closedLatch.countDown()__                }_            }_        }_    };closes,the,engine,without,acquiring,the,write,lock,this,should,only,be,called,while,the,write,lock,is,hold,or,in,a,disaster,condition,ie,if,the,engine,is,failed;override,protected,final,void,close,no,lock,string,reason,count,down,latch,closed,latch,if,is,closed,compare,and,set,false,true,assert,rwl,is,write,locked,by,current,thread,fail,engine,lock,is,held,by,current,thread,either,the,write,lock,must,be,held,or,the,engine,must,be,currently,be,failing,itself,try,this,version,map,clear,if,internal,searcher,manager,null,internal,searcher,manager,remove,listener,version,map,try,ioutils,close,external,searcher,manager,internal,searcher,manager,catch,exception,e,logger,warn,failed,to,close,searcher,manager,e,try,ioutils,close,translog,catch,exception,e,logger,warn,failed,to,close,translog,e,logger,trace,rollback,index,writer,try,index,writer,rollback,catch,already,closed,exception,ex,fail,on,tragic,event,ex,throw,ex,logger,trace,rollback,index,writer,done,catch,exception,e,logger,warn,failed,to,rollback,writer,on,close,e,finally,try,store,dec,ref,logger,debug,engine,closed,reason,finally,closed,latch,count,down
InternalEngine -> @Override     protected final void closeNoLock(String reason, CountDownLatch closedLatch);1543940134;Closes the engine without acquiring the write lock. This should only be_called while the write lock is hold or in a disaster condition ie. if the engine_is failed.;@Override_    protected final void closeNoLock(String reason, CountDownLatch closedLatch) {_        if (isClosed.compareAndSet(false, true)) {_            assert rwl.isWriteLockedByCurrentThread() || failEngineLock.isHeldByCurrentThread() :_                "Either the write lock must be held or the engine must be currently be failing itself"__            try {_                this.versionMap.clear()__                if (internalSearcherManager != null) {_                    internalSearcherManager.removeListener(versionMap)__                }_                try {_                    IOUtils.close(externalSearcherManager, internalSearcherManager)__                } catch (Exception e) {_                    logger.warn("Failed to close SearcherManager", e)__                }_                try {_                    IOUtils.close(translog)__                } catch (Exception e) {_                    logger.warn("Failed to close translog", e)__                }_                _                logger.trace("rollback indexWriter")__                try {_                    indexWriter.rollback()__                } catch (AlreadyClosedException ex) {_                    failOnTragicEvent(ex)__                    throw ex__                }_                logger.trace("rollback indexWriter done")__            } catch (Exception e) {_                logger.warn("failed to rollback writer on close", e)__            } finally {_                try {_                    store.decRef()__                    logger.debug("engine closed [{}]", reason)__                } finally {_                    closedLatch.countDown()__                }_            }_        }_    };closes,the,engine,without,acquiring,the,write,lock,this,should,only,be,called,while,the,write,lock,is,hold,or,in,a,disaster,condition,ie,if,the,engine,is,failed;override,protected,final,void,close,no,lock,string,reason,count,down,latch,closed,latch,if,is,closed,compare,and,set,false,true,assert,rwl,is,write,locked,by,current,thread,fail,engine,lock,is,held,by,current,thread,either,the,write,lock,must,be,held,or,the,engine,must,be,currently,be,failing,itself,try,this,version,map,clear,if,internal,searcher,manager,null,internal,searcher,manager,remove,listener,version,map,try,ioutils,close,external,searcher,manager,internal,searcher,manager,catch,exception,e,logger,warn,failed,to,close,searcher,manager,e,try,ioutils,close,translog,catch,exception,e,logger,warn,failed,to,close,translog,e,logger,trace,rollback,index,writer,try,index,writer,rollback,catch,already,closed,exception,ex,fail,on,tragic,event,ex,throw,ex,logger,trace,rollback,index,writer,done,catch,exception,e,logger,warn,failed,to,rollback,writer,on,close,e,finally,try,store,dec,ref,logger,debug,engine,closed,reason,finally,closed,latch,count,down
InternalEngine -> @Override     protected final void closeNoLock(String reason, CountDownLatch closedLatch);1544322276;Closes the engine without acquiring the write lock. This should only be_called while the write lock is hold or in a disaster condition ie. if the engine_is failed.;@Override_    protected final void closeNoLock(String reason, CountDownLatch closedLatch) {_        if (isClosed.compareAndSet(false, true)) {_            assert rwl.isWriteLockedByCurrentThread() || failEngineLock.isHeldByCurrentThread() :_                "Either the write lock must be held or the engine must be currently be failing itself"__            try {_                this.versionMap.clear()__                if (internalSearcherManager != null) {_                    internalSearcherManager.removeListener(versionMap)__                }_                try {_                    IOUtils.close(externalSearcherManager, internalSearcherManager)__                } catch (Exception e) {_                    logger.warn("Failed to close SearcherManager", e)__                }_                try {_                    IOUtils.close(translog)__                } catch (Exception e) {_                    logger.warn("Failed to close translog", e)__                }_                _                logger.trace("rollback indexWriter")__                try {_                    indexWriter.rollback()__                } catch (AlreadyClosedException ex) {_                    failOnTragicEvent(ex)__                    throw ex__                }_                logger.trace("rollback indexWriter done")__            } catch (Exception e) {_                logger.warn("failed to rollback writer on close", e)__            } finally {_                try {_                    store.decRef()__                    logger.debug("engine closed [{}]", reason)__                } finally {_                    closedLatch.countDown()__                }_            }_        }_    };closes,the,engine,without,acquiring,the,write,lock,this,should,only,be,called,while,the,write,lock,is,hold,or,in,a,disaster,condition,ie,if,the,engine,is,failed;override,protected,final,void,close,no,lock,string,reason,count,down,latch,closed,latch,if,is,closed,compare,and,set,false,true,assert,rwl,is,write,locked,by,current,thread,fail,engine,lock,is,held,by,current,thread,either,the,write,lock,must,be,held,or,the,engine,must,be,currently,be,failing,itself,try,this,version,map,clear,if,internal,searcher,manager,null,internal,searcher,manager,remove,listener,version,map,try,ioutils,close,external,searcher,manager,internal,searcher,manager,catch,exception,e,logger,warn,failed,to,close,searcher,manager,e,try,ioutils,close,translog,catch,exception,e,logger,warn,failed,to,close,translog,e,logger,trace,rollback,index,writer,try,index,writer,rollback,catch,already,closed,exception,ex,fail,on,tragic,event,ex,throw,ex,logger,trace,rollback,index,writer,done,catch,exception,e,logger,warn,failed,to,rollback,writer,on,close,e,finally,try,store,dec,ref,logger,debug,engine,closed,reason,finally,closed,latch,count,down
InternalEngine -> @Override     protected final void closeNoLock(String reason, CountDownLatch closedLatch);1544545090;Closes the engine without acquiring the write lock. This should only be_called while the write lock is hold or in a disaster condition ie. if the engine_is failed.;@Override_    protected final void closeNoLock(String reason, CountDownLatch closedLatch) {_        if (isClosed.compareAndSet(false, true)) {_            assert rwl.isWriteLockedByCurrentThread() || failEngineLock.isHeldByCurrentThread() :_                "Either the write lock must be held or the engine must be currently be failing itself"__            try {_                this.versionMap.clear()__                if (internalSearcherManager != null) {_                    internalSearcherManager.removeListener(versionMap)__                }_                try {_                    IOUtils.close(externalSearcherManager, internalSearcherManager)__                } catch (Exception e) {_                    logger.warn("Failed to close SearcherManager", e)__                }_                try {_                    IOUtils.close(translog)__                } catch (Exception e) {_                    logger.warn("Failed to close translog", e)__                }_                _                logger.trace("rollback indexWriter")__                try {_                    indexWriter.rollback()__                } catch (AlreadyClosedException ex) {_                    failOnTragicEvent(ex)__                    throw ex__                }_                logger.trace("rollback indexWriter done")__            } catch (Exception e) {_                logger.warn("failed to rollback writer on close", e)__            } finally {_                try {_                    store.decRef()__                    logger.debug("engine closed [{}]", reason)__                } finally {_                    closedLatch.countDown()__                }_            }_        }_    };closes,the,engine,without,acquiring,the,write,lock,this,should,only,be,called,while,the,write,lock,is,hold,or,in,a,disaster,condition,ie,if,the,engine,is,failed;override,protected,final,void,close,no,lock,string,reason,count,down,latch,closed,latch,if,is,closed,compare,and,set,false,true,assert,rwl,is,write,locked,by,current,thread,fail,engine,lock,is,held,by,current,thread,either,the,write,lock,must,be,held,or,the,engine,must,be,currently,be,failing,itself,try,this,version,map,clear,if,internal,searcher,manager,null,internal,searcher,manager,remove,listener,version,map,try,ioutils,close,external,searcher,manager,internal,searcher,manager,catch,exception,e,logger,warn,failed,to,close,searcher,manager,e,try,ioutils,close,translog,catch,exception,e,logger,warn,failed,to,close,translog,e,logger,trace,rollback,index,writer,try,index,writer,rollback,catch,already,closed,exception,ex,fail,on,tragic,event,ex,throw,ex,logger,trace,rollback,index,writer,done,catch,exception,e,logger,warn,failed,to,rollback,writer,on,close,e,finally,try,store,dec,ref,logger,debug,engine,closed,reason,finally,closed,latch,count,down
InternalEngine -> @Override     protected final void closeNoLock(String reason, CountDownLatch closedLatch);1544684920;Closes the engine without acquiring the write lock. This should only be_called while the write lock is hold or in a disaster condition ie. if the engine_is failed.;@Override_    protected final void closeNoLock(String reason, CountDownLatch closedLatch) {_        if (isClosed.compareAndSet(false, true)) {_            assert rwl.isWriteLockedByCurrentThread() || failEngineLock.isHeldByCurrentThread() :_                "Either the write lock must be held or the engine must be currently be failing itself"__            try {_                this.versionMap.clear()__                if (internalSearcherManager != null) {_                    internalSearcherManager.removeListener(versionMap)__                }_                try {_                    IOUtils.close(externalSearcherManager, internalSearcherManager)__                } catch (Exception e) {_                    logger.warn("Failed to close SearcherManager", e)__                }_                try {_                    IOUtils.close(translog)__                } catch (Exception e) {_                    logger.warn("Failed to close translog", e)__                }_                _                logger.trace("rollback indexWriter")__                try {_                    indexWriter.rollback()__                } catch (AlreadyClosedException ex) {_                    failOnTragicEvent(ex)__                    throw ex__                }_                logger.trace("rollback indexWriter done")__            } catch (Exception e) {_                logger.warn("failed to rollback writer on close", e)__            } finally {_                try {_                    store.decRef()__                    logger.debug("engine closed [{}]", reason)__                } finally {_                    closedLatch.countDown()__                }_            }_        }_    };closes,the,engine,without,acquiring,the,write,lock,this,should,only,be,called,while,the,write,lock,is,hold,or,in,a,disaster,condition,ie,if,the,engine,is,failed;override,protected,final,void,close,no,lock,string,reason,count,down,latch,closed,latch,if,is,closed,compare,and,set,false,true,assert,rwl,is,write,locked,by,current,thread,fail,engine,lock,is,held,by,current,thread,either,the,write,lock,must,be,held,or,the,engine,must,be,currently,be,failing,itself,try,this,version,map,clear,if,internal,searcher,manager,null,internal,searcher,manager,remove,listener,version,map,try,ioutils,close,external,searcher,manager,internal,searcher,manager,catch,exception,e,logger,warn,failed,to,close,searcher,manager,e,try,ioutils,close,translog,catch,exception,e,logger,warn,failed,to,close,translog,e,logger,trace,rollback,index,writer,try,index,writer,rollback,catch,already,closed,exception,ex,fail,on,tragic,event,ex,throw,ex,logger,trace,rollback,index,writer,done,catch,exception,e,logger,warn,failed,to,rollback,writer,on,close,e,finally,try,store,dec,ref,logger,debug,engine,closed,reason,finally,closed,latch,count,down
InternalEngine -> @Override     protected final void closeNoLock(String reason, CountDownLatch closedLatch);1545140118;Closes the engine without acquiring the write lock. This should only be_called while the write lock is hold or in a disaster condition ie. if the engine_is failed.;@Override_    protected final void closeNoLock(String reason, CountDownLatch closedLatch) {_        if (isClosed.compareAndSet(false, true)) {_            assert rwl.isWriteLockedByCurrentThread() || failEngineLock.isHeldByCurrentThread() :_                "Either the write lock must be held or the engine must be currently be failing itself"__            try {_                this.versionMap.clear()__                if (internalSearcherManager != null) {_                    internalSearcherManager.removeListener(versionMap)__                }_                try {_                    IOUtils.close(externalSearcherManager, internalSearcherManager)__                } catch (Exception e) {_                    logger.warn("Failed to close SearcherManager", e)__                }_                try {_                    IOUtils.close(translog)__                } catch (Exception e) {_                    logger.warn("Failed to close translog", e)__                }_                _                logger.trace("rollback indexWriter")__                try {_                    indexWriter.rollback()__                } catch (AlreadyClosedException ex) {_                    failOnTragicEvent(ex)__                    throw ex__                }_                logger.trace("rollback indexWriter done")__            } catch (Exception e) {_                logger.warn("failed to rollback writer on close", e)__            } finally {_                try {_                    store.decRef()__                    logger.debug("engine closed [{}]", reason)__                } finally {_                    closedLatch.countDown()__                }_            }_        }_    };closes,the,engine,without,acquiring,the,write,lock,this,should,only,be,called,while,the,write,lock,is,hold,or,in,a,disaster,condition,ie,if,the,engine,is,failed;override,protected,final,void,close,no,lock,string,reason,count,down,latch,closed,latch,if,is,closed,compare,and,set,false,true,assert,rwl,is,write,locked,by,current,thread,fail,engine,lock,is,held,by,current,thread,either,the,write,lock,must,be,held,or,the,engine,must,be,currently,be,failing,itself,try,this,version,map,clear,if,internal,searcher,manager,null,internal,searcher,manager,remove,listener,version,map,try,ioutils,close,external,searcher,manager,internal,searcher,manager,catch,exception,e,logger,warn,failed,to,close,searcher,manager,e,try,ioutils,close,translog,catch,exception,e,logger,warn,failed,to,close,translog,e,logger,trace,rollback,index,writer,try,index,writer,rollback,catch,already,closed,exception,ex,fail,on,tragic,event,ex,throw,ex,logger,trace,rollback,index,writer,done,catch,exception,e,logger,warn,failed,to,rollback,writer,on,close,e,finally,try,store,dec,ref,logger,debug,engine,closed,reason,finally,closed,latch,count,down
InternalEngine -> @Override     protected final void closeNoLock(String reason, CountDownLatch closedLatch);1546875837;Closes the engine without acquiring the write lock. This should only be_called while the write lock is hold or in a disaster condition ie. if the engine_is failed.;@Override_    protected final void closeNoLock(String reason, CountDownLatch closedLatch) {_        if (isClosed.compareAndSet(false, true)) {_            assert rwl.isWriteLockedByCurrentThread() || failEngineLock.isHeldByCurrentThread() :_                "Either the write lock must be held or the engine must be currently be failing itself"__            try {_                this.versionMap.clear()__                if (internalSearcherManager != null) {_                    internalSearcherManager.removeListener(versionMap)__                }_                try {_                    IOUtils.close(externalSearcherManager, internalSearcherManager)__                } catch (Exception e) {_                    logger.warn("Failed to close SearcherManager", e)__                }_                try {_                    IOUtils.close(translog)__                } catch (Exception e) {_                    logger.warn("Failed to close translog", e)__                }_                _                logger.trace("rollback indexWriter")__                try {_                    indexWriter.rollback()__                } catch (AlreadyClosedException ex) {_                    failOnTragicEvent(ex)__                    throw ex__                }_                logger.trace("rollback indexWriter done")__            } catch (Exception e) {_                logger.warn("failed to rollback writer on close", e)__            } finally {_                try {_                    store.decRef()__                    logger.debug("engine closed [{}]", reason)__                } finally {_                    closedLatch.countDown()__                }_            }_        }_    };closes,the,engine,without,acquiring,the,write,lock,this,should,only,be,called,while,the,write,lock,is,hold,or,in,a,disaster,condition,ie,if,the,engine,is,failed;override,protected,final,void,close,no,lock,string,reason,count,down,latch,closed,latch,if,is,closed,compare,and,set,false,true,assert,rwl,is,write,locked,by,current,thread,fail,engine,lock,is,held,by,current,thread,either,the,write,lock,must,be,held,or,the,engine,must,be,currently,be,failing,itself,try,this,version,map,clear,if,internal,searcher,manager,null,internal,searcher,manager,remove,listener,version,map,try,ioutils,close,external,searcher,manager,internal,searcher,manager,catch,exception,e,logger,warn,failed,to,close,searcher,manager,e,try,ioutils,close,translog,catch,exception,e,logger,warn,failed,to,close,translog,e,logger,trace,rollback,index,writer,try,index,writer,rollback,catch,already,closed,exception,ex,fail,on,tragic,event,ex,throw,ex,logger,trace,rollback,index,writer,done,catch,exception,e,logger,warn,failed,to,rollback,writer,on,close,e,finally,try,store,dec,ref,logger,debug,engine,closed,reason,finally,closed,latch,count,down
InternalEngine -> @Override     protected final void closeNoLock(String reason, CountDownLatch closedLatch);1547332999;Closes the engine without acquiring the write lock. This should only be_called while the write lock is hold or in a disaster condition ie. if the engine_is failed.;@Override_    protected final void closeNoLock(String reason, CountDownLatch closedLatch) {_        if (isClosed.compareAndSet(false, true)) {_            assert rwl.isWriteLockedByCurrentThread() || failEngineLock.isHeldByCurrentThread() :_                "Either the write lock must be held or the engine must be currently be failing itself"__            try {_                this.versionMap.clear()__                if (internalSearcherManager != null) {_                    internalSearcherManager.removeListener(versionMap)__                }_                try {_                    IOUtils.close(externalSearcherManager, internalSearcherManager)__                } catch (Exception e) {_                    logger.warn("Failed to close SearcherManager", e)__                }_                try {_                    IOUtils.close(translog)__                } catch (Exception e) {_                    logger.warn("Failed to close translog", e)__                }_                _                logger.trace("rollback indexWriter")__                try {_                    indexWriter.rollback()__                } catch (AlreadyClosedException ex) {_                    failOnTragicEvent(ex)__                    throw ex__                }_                logger.trace("rollback indexWriter done")__            } catch (Exception e) {_                logger.warn("failed to rollback writer on close", e)__            } finally {_                try {_                    store.decRef()__                    logger.debug("engine closed [{}]", reason)__                } finally {_                    closedLatch.countDown()__                }_            }_        }_    };closes,the,engine,without,acquiring,the,write,lock,this,should,only,be,called,while,the,write,lock,is,hold,or,in,a,disaster,condition,ie,if,the,engine,is,failed;override,protected,final,void,close,no,lock,string,reason,count,down,latch,closed,latch,if,is,closed,compare,and,set,false,true,assert,rwl,is,write,locked,by,current,thread,fail,engine,lock,is,held,by,current,thread,either,the,write,lock,must,be,held,or,the,engine,must,be,currently,be,failing,itself,try,this,version,map,clear,if,internal,searcher,manager,null,internal,searcher,manager,remove,listener,version,map,try,ioutils,close,external,searcher,manager,internal,searcher,manager,catch,exception,e,logger,warn,failed,to,close,searcher,manager,e,try,ioutils,close,translog,catch,exception,e,logger,warn,failed,to,close,translog,e,logger,trace,rollback,index,writer,try,index,writer,rollback,catch,already,closed,exception,ex,fail,on,tragic,event,ex,throw,ex,logger,trace,rollback,index,writer,done,catch,exception,e,logger,warn,failed,to,rollback,writer,on,close,e,finally,try,store,dec,ref,logger,debug,engine,closed,reason,finally,closed,latch,count,down
InternalEngine -> @Override     protected final void closeNoLock(String reason, CountDownLatch closedLatch);1548771485;Closes the engine without acquiring the write lock. This should only be_called while the write lock is hold or in a disaster condition ie. if the engine_is failed.;@Override_    protected final void closeNoLock(String reason, CountDownLatch closedLatch) {_        if (isClosed.compareAndSet(false, true)) {_            assert rwl.isWriteLockedByCurrentThread() || failEngineLock.isHeldByCurrentThread() :_                "Either the write lock must be held or the engine must be currently be failing itself"__            try {_                this.versionMap.clear()__                if (internalSearcherManager != null) {_                    internalSearcherManager.removeListener(versionMap)__                }_                try {_                    IOUtils.close(externalSearcherManager, internalSearcherManager)__                } catch (Exception e) {_                    logger.warn("Failed to close SearcherManager", e)__                }_                try {_                    IOUtils.close(translog)__                } catch (Exception e) {_                    logger.warn("Failed to close translog", e)__                }_                _                logger.trace("rollback indexWriter")__                try {_                    indexWriter.rollback()__                } catch (AlreadyClosedException ex) {_                    failOnTragicEvent(ex)__                    throw ex__                }_                logger.trace("rollback indexWriter done")__            } catch (Exception e) {_                logger.warn("failed to rollback writer on close", e)__            } finally {_                try {_                    store.decRef()__                    logger.debug("engine closed [{}]", reason)__                } finally {_                    closedLatch.countDown()__                }_            }_        }_    };closes,the,engine,without,acquiring,the,write,lock,this,should,only,be,called,while,the,write,lock,is,hold,or,in,a,disaster,condition,ie,if,the,engine,is,failed;override,protected,final,void,close,no,lock,string,reason,count,down,latch,closed,latch,if,is,closed,compare,and,set,false,true,assert,rwl,is,write,locked,by,current,thread,fail,engine,lock,is,held,by,current,thread,either,the,write,lock,must,be,held,or,the,engine,must,be,currently,be,failing,itself,try,this,version,map,clear,if,internal,searcher,manager,null,internal,searcher,manager,remove,listener,version,map,try,ioutils,close,external,searcher,manager,internal,searcher,manager,catch,exception,e,logger,warn,failed,to,close,searcher,manager,e,try,ioutils,close,translog,catch,exception,e,logger,warn,failed,to,close,translog,e,logger,trace,rollback,index,writer,try,index,writer,rollback,catch,already,closed,exception,ex,fail,on,tragic,event,ex,throw,ex,logger,trace,rollback,index,writer,done,catch,exception,e,logger,warn,failed,to,rollback,writer,on,close,e,finally,try,store,dec,ref,logger,debug,engine,closed,reason,finally,closed,latch,count,down
InternalEngine -> @Override     protected final void closeNoLock(String reason, CountDownLatch closedLatch);1549059559;Closes the engine without acquiring the write lock. This should only be_called while the write lock is hold or in a disaster condition ie. if the engine_is failed.;@Override_    protected final void closeNoLock(String reason, CountDownLatch closedLatch) {_        if (isClosed.compareAndSet(false, true)) {_            assert rwl.isWriteLockedByCurrentThread() || failEngineLock.isHeldByCurrentThread() :_                "Either the write lock must be held or the engine must be currently be failing itself"__            try {_                this.versionMap.clear()__                if (internalSearcherManager != null) {_                    internalSearcherManager.removeListener(versionMap)__                }_                try {_                    IOUtils.close(externalSearcherManager, internalSearcherManager)__                } catch (Exception e) {_                    logger.warn("Failed to close SearcherManager", e)__                }_                try {_                    IOUtils.close(translog)__                } catch (Exception e) {_                    logger.warn("Failed to close translog", e)__                }_                _                logger.trace("rollback indexWriter")__                try {_                    indexWriter.rollback()__                } catch (AlreadyClosedException ex) {_                    failOnTragicEvent(ex)__                    throw ex__                }_                logger.trace("rollback indexWriter done")__            } catch (Exception e) {_                logger.warn("failed to rollback writer on close", e)__            } finally {_                try {_                    store.decRef()__                    logger.debug("engine closed [{}]", reason)__                } finally {_                    closedLatch.countDown()__                }_            }_        }_    };closes,the,engine,without,acquiring,the,write,lock,this,should,only,be,called,while,the,write,lock,is,hold,or,in,a,disaster,condition,ie,if,the,engine,is,failed;override,protected,final,void,close,no,lock,string,reason,count,down,latch,closed,latch,if,is,closed,compare,and,set,false,true,assert,rwl,is,write,locked,by,current,thread,fail,engine,lock,is,held,by,current,thread,either,the,write,lock,must,be,held,or,the,engine,must,be,currently,be,failing,itself,try,this,version,map,clear,if,internal,searcher,manager,null,internal,searcher,manager,remove,listener,version,map,try,ioutils,close,external,searcher,manager,internal,searcher,manager,catch,exception,e,logger,warn,failed,to,close,searcher,manager,e,try,ioutils,close,translog,catch,exception,e,logger,warn,failed,to,close,translog,e,logger,trace,rollback,index,writer,try,index,writer,rollback,catch,already,closed,exception,ex,fail,on,tragic,event,ex,throw,ex,logger,trace,rollback,index,writer,done,catch,exception,e,logger,warn,failed,to,rollback,writer,on,close,e,finally,try,store,dec,ref,logger,debug,engine,closed,reason,finally,closed,latch,count,down
InternalEngine -> @Override     protected final void closeNoLock(String reason, CountDownLatch closedLatch);1549663373;Closes the engine without acquiring the write lock. This should only be_called while the write lock is hold or in a disaster condition ie. if the engine_is failed.;@Override_    protected final void closeNoLock(String reason, CountDownLatch closedLatch) {_        if (isClosed.compareAndSet(false, true)) {_            assert rwl.isWriteLockedByCurrentThread() || failEngineLock.isHeldByCurrentThread() :_                "Either the write lock must be held or the engine must be currently be failing itself"__            try {_                this.versionMap.clear()__                if (internalSearcherManager != null) {_                    internalSearcherManager.removeListener(versionMap)__                }_                try {_                    IOUtils.close(externalSearcherManager, internalSearcherManager)__                } catch (Exception e) {_                    logger.warn("Failed to close SearcherManager", e)__                }_                try {_                    IOUtils.close(translog)__                } catch (Exception e) {_                    logger.warn("Failed to close translog", e)__                }_                _                logger.trace("rollback indexWriter")__                try {_                    indexWriter.rollback()__                } catch (AlreadyClosedException ex) {_                    failOnTragicEvent(ex)__                    throw ex__                }_                logger.trace("rollback indexWriter done")__            } catch (Exception e) {_                logger.warn("failed to rollback writer on close", e)__            } finally {_                try {_                    store.decRef()__                    logger.debug("engine closed [{}]", reason)__                } finally {_                    closedLatch.countDown()__                }_            }_        }_    };closes,the,engine,without,acquiring,the,write,lock,this,should,only,be,called,while,the,write,lock,is,hold,or,in,a,disaster,condition,ie,if,the,engine,is,failed;override,protected,final,void,close,no,lock,string,reason,count,down,latch,closed,latch,if,is,closed,compare,and,set,false,true,assert,rwl,is,write,locked,by,current,thread,fail,engine,lock,is,held,by,current,thread,either,the,write,lock,must,be,held,or,the,engine,must,be,currently,be,failing,itself,try,this,version,map,clear,if,internal,searcher,manager,null,internal,searcher,manager,remove,listener,version,map,try,ioutils,close,external,searcher,manager,internal,searcher,manager,catch,exception,e,logger,warn,failed,to,close,searcher,manager,e,try,ioutils,close,translog,catch,exception,e,logger,warn,failed,to,close,translog,e,logger,trace,rollback,index,writer,try,index,writer,rollback,catch,already,closed,exception,ex,fail,on,tragic,event,ex,throw,ex,logger,trace,rollback,index,writer,done,catch,exception,e,logger,warn,failed,to,rollback,writer,on,close,e,finally,try,store,dec,ref,logger,debug,engine,closed,reason,finally,closed,latch,count,down
InternalEngine -> @Override     protected final void closeNoLock(String reason, CountDownLatch closedLatch);1549975032;Closes the engine without acquiring the write lock. This should only be_called while the write lock is hold or in a disaster condition ie. if the engine_is failed.;@Override_    protected final void closeNoLock(String reason, CountDownLatch closedLatch) {_        if (isClosed.compareAndSet(false, true)) {_            assert rwl.isWriteLockedByCurrentThread() || failEngineLock.isHeldByCurrentThread() :_                "Either the write lock must be held or the engine must be currently be failing itself"__            try {_                this.versionMap.clear()__                if (internalSearcherManager != null) {_                    internalSearcherManager.removeListener(versionMap)__                }_                try {_                    IOUtils.close(externalSearcherManager, internalSearcherManager)__                } catch (Exception e) {_                    logger.warn("Failed to close SearcherManager", e)__                }_                try {_                    IOUtils.close(translog)__                } catch (Exception e) {_                    logger.warn("Failed to close translog", e)__                }_                _                logger.trace("rollback indexWriter")__                try {_                    indexWriter.rollback()__                } catch (AlreadyClosedException ex) {_                    failOnTragicEvent(ex)__                    throw ex__                }_                logger.trace("rollback indexWriter done")__            } catch (Exception e) {_                logger.warn("failed to rollback writer on close", e)__            } finally {_                try {_                    store.decRef()__                    logger.debug("engine closed [{}]", reason)__                } finally {_                    closedLatch.countDown()__                }_            }_        }_    };closes,the,engine,without,acquiring,the,write,lock,this,should,only,be,called,while,the,write,lock,is,hold,or,in,a,disaster,condition,ie,if,the,engine,is,failed;override,protected,final,void,close,no,lock,string,reason,count,down,latch,closed,latch,if,is,closed,compare,and,set,false,true,assert,rwl,is,write,locked,by,current,thread,fail,engine,lock,is,held,by,current,thread,either,the,write,lock,must,be,held,or,the,engine,must,be,currently,be,failing,itself,try,this,version,map,clear,if,internal,searcher,manager,null,internal,searcher,manager,remove,listener,version,map,try,ioutils,close,external,searcher,manager,internal,searcher,manager,catch,exception,e,logger,warn,failed,to,close,searcher,manager,e,try,ioutils,close,translog,catch,exception,e,logger,warn,failed,to,close,translog,e,logger,trace,rollback,index,writer,try,index,writer,rollback,catch,already,closed,exception,ex,fail,on,tragic,event,ex,throw,ex,logger,trace,rollback,index,writer,done,catch,exception,e,logger,warn,failed,to,rollback,writer,on,close,e,finally,try,store,dec,ref,logger,debug,engine,closed,reason,finally,closed,latch,count,down
InternalEngine -> @Override     protected final void closeNoLock(String reason, CountDownLatch closedLatch);1550220204;Closes the engine without acquiring the write lock. This should only be_called while the write lock is hold or in a disaster condition ie. if the engine_is failed.;@Override_    protected final void closeNoLock(String reason, CountDownLatch closedLatch) {_        if (isClosed.compareAndSet(false, true)) {_            assert rwl.isWriteLockedByCurrentThread() || failEngineLock.isHeldByCurrentThread() :_                "Either the write lock must be held or the engine must be currently be failing itself"__            try {_                this.versionMap.clear()__                if (internalSearcherManager != null) {_                    internalSearcherManager.removeListener(versionMap)__                }_                try {_                    IOUtils.close(externalSearcherManager, internalSearcherManager)__                } catch (Exception e) {_                    logger.warn("Failed to close SearcherManager", e)__                }_                try {_                    IOUtils.close(translog)__                } catch (Exception e) {_                    logger.warn("Failed to close translog", e)__                }_                _                logger.trace("rollback indexWriter")__                try {_                    indexWriter.rollback()__                } catch (AlreadyClosedException ex) {_                    failOnTragicEvent(ex)__                    throw ex__                }_                logger.trace("rollback indexWriter done")__            } catch (Exception e) {_                logger.warn("failed to rollback writer on close", e)__            } finally {_                try {_                    store.decRef()__                    logger.debug("engine closed [{}]", reason)__                } finally {_                    closedLatch.countDown()__                }_            }_        }_    };closes,the,engine,without,acquiring,the,write,lock,this,should,only,be,called,while,the,write,lock,is,hold,or,in,a,disaster,condition,ie,if,the,engine,is,failed;override,protected,final,void,close,no,lock,string,reason,count,down,latch,closed,latch,if,is,closed,compare,and,set,false,true,assert,rwl,is,write,locked,by,current,thread,fail,engine,lock,is,held,by,current,thread,either,the,write,lock,must,be,held,or,the,engine,must,be,currently,be,failing,itself,try,this,version,map,clear,if,internal,searcher,manager,null,internal,searcher,manager,remove,listener,version,map,try,ioutils,close,external,searcher,manager,internal,searcher,manager,catch,exception,e,logger,warn,failed,to,close,searcher,manager,e,try,ioutils,close,translog,catch,exception,e,logger,warn,failed,to,close,translog,e,logger,trace,rollback,index,writer,try,index,writer,rollback,catch,already,closed,exception,ex,fail,on,tragic,event,ex,throw,ex,logger,trace,rollback,index,writer,done,catch,exception,e,logger,warn,failed,to,rollback,writer,on,close,e,finally,try,store,dec,ref,logger,debug,engine,closed,reason,finally,closed,latch,count,down
InternalEngine -> @Override     protected final void closeNoLock(String reason, CountDownLatch closedLatch);1550256122;Closes the engine without acquiring the write lock. This should only be_called while the write lock is hold or in a disaster condition ie. if the engine_is failed.;@Override_    protected final void closeNoLock(String reason, CountDownLatch closedLatch) {_        if (isClosed.compareAndSet(false, true)) {_            assert rwl.isWriteLockedByCurrentThread() || failEngineLock.isHeldByCurrentThread() :_                "Either the write lock must be held or the engine must be currently be failing itself"__            try {_                this.versionMap.clear()__                if (internalSearcherManager != null) {_                    internalSearcherManager.removeListener(versionMap)__                }_                try {_                    IOUtils.close(externalSearcherManager, internalSearcherManager)__                } catch (Exception e) {_                    logger.warn("Failed to close SearcherManager", e)__                }_                try {_                    IOUtils.close(translog)__                } catch (Exception e) {_                    logger.warn("Failed to close translog", e)__                }_                _                logger.trace("rollback indexWriter")__                try {_                    indexWriter.rollback()__                } catch (AlreadyClosedException ex) {_                    failOnTragicEvent(ex)__                    throw ex__                }_                logger.trace("rollback indexWriter done")__            } catch (Exception e) {_                logger.warn("failed to rollback writer on close", e)__            } finally {_                try {_                    store.decRef()__                    logger.debug("engine closed [{}]", reason)__                } finally {_                    closedLatch.countDown()__                }_            }_        }_    };closes,the,engine,without,acquiring,the,write,lock,this,should,only,be,called,while,the,write,lock,is,hold,or,in,a,disaster,condition,ie,if,the,engine,is,failed;override,protected,final,void,close,no,lock,string,reason,count,down,latch,closed,latch,if,is,closed,compare,and,set,false,true,assert,rwl,is,write,locked,by,current,thread,fail,engine,lock,is,held,by,current,thread,either,the,write,lock,must,be,held,or,the,engine,must,be,currently,be,failing,itself,try,this,version,map,clear,if,internal,searcher,manager,null,internal,searcher,manager,remove,listener,version,map,try,ioutils,close,external,searcher,manager,internal,searcher,manager,catch,exception,e,logger,warn,failed,to,close,searcher,manager,e,try,ioutils,close,translog,catch,exception,e,logger,warn,failed,to,close,translog,e,logger,trace,rollback,index,writer,try,index,writer,rollback,catch,already,closed,exception,ex,fail,on,tragic,event,ex,throw,ex,logger,trace,rollback,index,writer,done,catch,exception,e,logger,warn,failed,to,rollback,writer,on,close,e,finally,try,store,dec,ref,logger,debug,engine,closed,reason,finally,closed,latch,count,down
InternalEngine -> @Override     protected final void closeNoLock(String reason, CountDownLatch closedLatch);1550342051;Closes the engine without acquiring the write lock. This should only be_called while the write lock is hold or in a disaster condition ie. if the engine_is failed.;@Override_    protected final void closeNoLock(String reason, CountDownLatch closedLatch) {_        if (isClosed.compareAndSet(false, true)) {_            assert rwl.isWriteLockedByCurrentThread() || failEngineLock.isHeldByCurrentThread() :_                "Either the write lock must be held or the engine must be currently be failing itself"__            try {_                this.versionMap.clear()__                if (internalSearcherManager != null) {_                    internalSearcherManager.removeListener(versionMap)__                }_                try {_                    IOUtils.close(externalSearcherManager, internalSearcherManager)__                } catch (Exception e) {_                    logger.warn("Failed to close SearcherManager", e)__                }_                try {_                    IOUtils.close(translog)__                } catch (Exception e) {_                    logger.warn("Failed to close translog", e)__                }_                _                logger.trace("rollback indexWriter")__                try {_                    indexWriter.rollback()__                } catch (AlreadyClosedException ex) {_                    failOnTragicEvent(ex)__                    throw ex__                }_                logger.trace("rollback indexWriter done")__            } catch (Exception e) {_                logger.warn("failed to rollback writer on close", e)__            } finally {_                try {_                    store.decRef()__                    logger.debug("engine closed [{}]", reason)__                } finally {_                    closedLatch.countDown()__                }_            }_        }_    };closes,the,engine,without,acquiring,the,write,lock,this,should,only,be,called,while,the,write,lock,is,hold,or,in,a,disaster,condition,ie,if,the,engine,is,failed;override,protected,final,void,close,no,lock,string,reason,count,down,latch,closed,latch,if,is,closed,compare,and,set,false,true,assert,rwl,is,write,locked,by,current,thread,fail,engine,lock,is,held,by,current,thread,either,the,write,lock,must,be,held,or,the,engine,must,be,currently,be,failing,itself,try,this,version,map,clear,if,internal,searcher,manager,null,internal,searcher,manager,remove,listener,version,map,try,ioutils,close,external,searcher,manager,internal,searcher,manager,catch,exception,e,logger,warn,failed,to,close,searcher,manager,e,try,ioutils,close,translog,catch,exception,e,logger,warn,failed,to,close,translog,e,logger,trace,rollback,index,writer,try,index,writer,rollback,catch,already,closed,exception,ex,fail,on,tragic,event,ex,throw,ex,logger,trace,rollback,index,writer,done,catch,exception,e,logger,warn,failed,to,rollback,writer,on,close,e,finally,try,store,dec,ref,logger,debug,engine,closed,reason,finally,closed,latch,count,down
InternalEngine -> @Override     protected final void closeNoLock(String reason, CountDownLatch closedLatch);1550526771;Closes the engine without acquiring the write lock. This should only be_called while the write lock is hold or in a disaster condition ie. if the engine_is failed.;@Override_    protected final void closeNoLock(String reason, CountDownLatch closedLatch) {_        if (isClosed.compareAndSet(false, true)) {_            assert rwl.isWriteLockedByCurrentThread() || failEngineLock.isHeldByCurrentThread() :_                "Either the write lock must be held or the engine must be currently be failing itself"__            try {_                this.versionMap.clear()__                if (internalSearcherManager != null) {_                    internalSearcherManager.removeListener(versionMap)__                }_                try {_                    IOUtils.close(externalSearcherManager, internalSearcherManager)__                } catch (Exception e) {_                    logger.warn("Failed to close SearcherManager", e)__                }_                try {_                    IOUtils.close(translog)__                } catch (Exception e) {_                    logger.warn("Failed to close translog", e)__                }_                _                logger.trace("rollback indexWriter")__                try {_                    indexWriter.rollback()__                } catch (AlreadyClosedException ex) {_                    failOnTragicEvent(ex)__                    throw ex__                }_                logger.trace("rollback indexWriter done")__            } catch (Exception e) {_                logger.warn("failed to rollback writer on close", e)__            } finally {_                try {_                    store.decRef()__                    logger.debug("engine closed [{}]", reason)__                } finally {_                    closedLatch.countDown()__                }_            }_        }_    };closes,the,engine,without,acquiring,the,write,lock,this,should,only,be,called,while,the,write,lock,is,hold,or,in,a,disaster,condition,ie,if,the,engine,is,failed;override,protected,final,void,close,no,lock,string,reason,count,down,latch,closed,latch,if,is,closed,compare,and,set,false,true,assert,rwl,is,write,locked,by,current,thread,fail,engine,lock,is,held,by,current,thread,either,the,write,lock,must,be,held,or,the,engine,must,be,currently,be,failing,itself,try,this,version,map,clear,if,internal,searcher,manager,null,internal,searcher,manager,remove,listener,version,map,try,ioutils,close,external,searcher,manager,internal,searcher,manager,catch,exception,e,logger,warn,failed,to,close,searcher,manager,e,try,ioutils,close,translog,catch,exception,e,logger,warn,failed,to,close,translog,e,logger,trace,rollback,index,writer,try,index,writer,rollback,catch,already,closed,exception,ex,fail,on,tragic,event,ex,throw,ex,logger,trace,rollback,index,writer,done,catch,exception,e,logger,warn,failed,to,rollback,writer,on,close,e,finally,try,store,dec,ref,logger,debug,engine,closed,reason,finally,closed,latch,count,down
InternalEngine -> @Override     protected final void closeNoLock(String reason, CountDownLatch closedLatch);1551110274;Closes the engine without acquiring the write lock. This should only be_called while the write lock is hold or in a disaster condition ie. if the engine_is failed.;@Override_    protected final void closeNoLock(String reason, CountDownLatch closedLatch) {_        if (isClosed.compareAndSet(false, true)) {_            assert rwl.isWriteLockedByCurrentThread() || failEngineLock.isHeldByCurrentThread() :_                "Either the write lock must be held or the engine must be currently be failing itself"__            try {_                this.versionMap.clear()__                if (internalSearcherManager != null) {_                    internalSearcherManager.removeListener(versionMap)__                }_                try {_                    IOUtils.close(externalSearcherManager, internalSearcherManager)__                } catch (Exception e) {_                    logger.warn("Failed to close SearcherManager", e)__                }_                try {_                    IOUtils.close(translog)__                } catch (Exception e) {_                    logger.warn("Failed to close translog", e)__                }_                _                logger.trace("rollback indexWriter")__                try {_                    indexWriter.rollback()__                } catch (AlreadyClosedException ex) {_                    failOnTragicEvent(ex)__                    throw ex__                }_                logger.trace("rollback indexWriter done")__            } catch (Exception e) {_                logger.warn("failed to rollback writer on close", e)__            } finally {_                try {_                    store.decRef()__                    logger.debug("engine closed [{}]", reason)__                } finally {_                    closedLatch.countDown()__                }_            }_        }_    };closes,the,engine,without,acquiring,the,write,lock,this,should,only,be,called,while,the,write,lock,is,hold,or,in,a,disaster,condition,ie,if,the,engine,is,failed;override,protected,final,void,close,no,lock,string,reason,count,down,latch,closed,latch,if,is,closed,compare,and,set,false,true,assert,rwl,is,write,locked,by,current,thread,fail,engine,lock,is,held,by,current,thread,either,the,write,lock,must,be,held,or,the,engine,must,be,currently,be,failing,itself,try,this,version,map,clear,if,internal,searcher,manager,null,internal,searcher,manager,remove,listener,version,map,try,ioutils,close,external,searcher,manager,internal,searcher,manager,catch,exception,e,logger,warn,failed,to,close,searcher,manager,e,try,ioutils,close,translog,catch,exception,e,logger,warn,failed,to,close,translog,e,logger,trace,rollback,index,writer,try,index,writer,rollback,catch,already,closed,exception,ex,fail,on,tragic,event,ex,throw,ex,logger,trace,rollback,index,writer,done,catch,exception,e,logger,warn,failed,to,rollback,writer,on,close,e,finally,try,store,dec,ref,logger,debug,engine,closed,reason,finally,closed,latch,count,down
InternalEngine -> @Override     protected final void closeNoLock(String reason, CountDownLatch closedLatch);1551126708;Closes the engine without acquiring the write lock. This should only be_called while the write lock is hold or in a disaster condition ie. if the engine_is failed.;@Override_    protected final void closeNoLock(String reason, CountDownLatch closedLatch) {_        if (isClosed.compareAndSet(false, true)) {_            assert rwl.isWriteLockedByCurrentThread() || failEngineLock.isHeldByCurrentThread() :_                "Either the write lock must be held or the engine must be currently be failing itself"__            try {_                this.versionMap.clear()__                if (internalSearcherManager != null) {_                    internalSearcherManager.removeListener(versionMap)__                }_                try {_                    IOUtils.close(externalSearcherManager, internalSearcherManager)__                } catch (Exception e) {_                    logger.warn("Failed to close SearcherManager", e)__                }_                try {_                    IOUtils.close(translog)__                } catch (Exception e) {_                    logger.warn("Failed to close translog", e)__                }_                _                logger.trace("rollback indexWriter")__                try {_                    indexWriter.rollback()__                } catch (AlreadyClosedException ex) {_                    failOnTragicEvent(ex)__                    throw ex__                }_                logger.trace("rollback indexWriter done")__            } catch (Exception e) {_                logger.warn("failed to rollback writer on close", e)__            } finally {_                try {_                    store.decRef()__                    logger.debug("engine closed [{}]", reason)__                } finally {_                    closedLatch.countDown()__                }_            }_        }_    };closes,the,engine,without,acquiring,the,write,lock,this,should,only,be,called,while,the,write,lock,is,hold,or,in,a,disaster,condition,ie,if,the,engine,is,failed;override,protected,final,void,close,no,lock,string,reason,count,down,latch,closed,latch,if,is,closed,compare,and,set,false,true,assert,rwl,is,write,locked,by,current,thread,fail,engine,lock,is,held,by,current,thread,either,the,write,lock,must,be,held,or,the,engine,must,be,currently,be,failing,itself,try,this,version,map,clear,if,internal,searcher,manager,null,internal,searcher,manager,remove,listener,version,map,try,ioutils,close,external,searcher,manager,internal,searcher,manager,catch,exception,e,logger,warn,failed,to,close,searcher,manager,e,try,ioutils,close,translog,catch,exception,e,logger,warn,failed,to,close,translog,e,logger,trace,rollback,index,writer,try,index,writer,rollback,catch,already,closed,exception,ex,fail,on,tragic,event,ex,throw,ex,logger,trace,rollback,index,writer,done,catch,exception,e,logger,warn,failed,to,rollback,writer,on,close,e,finally,try,store,dec,ref,logger,debug,engine,closed,reason,finally,closed,latch,count,down
InternalEngine -> final long lastRefreshedCheckpoint();1535723122;Returned the last local checkpoint value has been refreshed internally.;final long lastRefreshedCheckpoint() {_        return lastRefreshedCheckpointListener.refreshedCheckpoint.get()__    };returned,the,last,local,checkpoint,value,has,been,refreshed,internally;final,long,last,refreshed,checkpoint,return,last,refreshed,checkpoint,listener,refreshed,checkpoint,get
InternalEngine -> final long lastRefreshedCheckpoint();1535965276;Returned the last local checkpoint value has been refreshed internally.;final long lastRefreshedCheckpoint() {_        return lastRefreshedCheckpointListener.refreshedCheckpoint.get()__    };returned,the,last,local,checkpoint,value,has,been,refreshed,internally;final,long,last,refreshed,checkpoint,return,last,refreshed,checkpoint,listener,refreshed,checkpoint,get
InternalEngine -> final long lastRefreshedCheckpoint();1536218260;Returned the last local checkpoint value has been refreshed internally.;final long lastRefreshedCheckpoint() {_        return lastRefreshedCheckpointListener.refreshedCheckpoint.get()__    };returned,the,last,local,checkpoint,value,has,been,refreshed,internally;final,long,last,refreshed,checkpoint,return,last,refreshed,checkpoint,listener,refreshed,checkpoint,get
InternalEngine -> final long lastRefreshedCheckpoint();1536314350;Returned the last local checkpoint value has been refreshed internally.;final long lastRefreshedCheckpoint() {_        return lastRefreshedCheckpointListener.refreshedCheckpoint.get()__    };returned,the,last,local,checkpoint,value,has,been,refreshed,internally;final,long,last,refreshed,checkpoint,return,last,refreshed,checkpoint,listener,refreshed,checkpoint,get
InternalEngine -> final long lastRefreshedCheckpoint();1536828374;Returned the last local checkpoint value has been refreshed internally.;final long lastRefreshedCheckpoint() {_        return lastRefreshedCheckpointListener.refreshedCheckpoint.get()__    };returned,the,last,local,checkpoint,value,has,been,refreshed,internally;final,long,last,refreshed,checkpoint,return,last,refreshed,checkpoint,listener,refreshed,checkpoint,get
InternalEngine -> final long lastRefreshedCheckpoint();1537806831;Returned the last local checkpoint value has been refreshed internally.;final long lastRefreshedCheckpoint() {_        return lastRefreshedCheckpointListener.refreshedCheckpoint.get()__    };returned,the,last,local,checkpoint,value,has,been,refreshed,internally;final,long,last,refreshed,checkpoint,return,last,refreshed,checkpoint,listener,refreshed,checkpoint,get
InternalEngine -> final long lastRefreshedCheckpoint();1538067637;Returned the last local checkpoint value has been refreshed internally.;final long lastRefreshedCheckpoint() {_        return lastRefreshedCheckpointListener.refreshedCheckpoint.get()__    };returned,the,last,local,checkpoint,value,has,been,refreshed,internally;final,long,last,refreshed,checkpoint,return,last,refreshed,checkpoint,listener,refreshed,checkpoint,get
InternalEngine -> final long lastRefreshedCheckpoint();1538424609;Returned the last local checkpoint value has been refreshed internally.;final long lastRefreshedCheckpoint() {_        return lastRefreshedCheckpointListener.refreshedCheckpoint.get()__    };returned,the,last,local,checkpoint,value,has,been,refreshed,internally;final,long,last,refreshed,checkpoint,return,last,refreshed,checkpoint,listener,refreshed,checkpoint,get
InternalEngine -> final long lastRefreshedCheckpoint();1539615817;Returned the last local checkpoint value has been refreshed internally.;final long lastRefreshedCheckpoint() {_        return lastRefreshedCheckpointListener.refreshedCheckpoint.get()__    };returned,the,last,local,checkpoint,value,has,been,refreshed,internally;final,long,last,refreshed,checkpoint,return,last,refreshed,checkpoint,listener,refreshed,checkpoint,get
InternalEngine -> final long lastRefreshedCheckpoint();1539723533;Returned the last local checkpoint value has been refreshed internally.;final long lastRefreshedCheckpoint() {_        return lastRefreshedCheckpointListener.refreshedCheckpoint.get()__    };returned,the,last,local,checkpoint,value,has,been,refreshed,internally;final,long,last,refreshed,checkpoint,return,last,refreshed,checkpoint,listener,refreshed,checkpoint,get
InternalEngine -> final long lastRefreshedCheckpoint();1540238977;Returned the last local checkpoint value has been refreshed internally.;final long lastRefreshedCheckpoint() {_        return lastRefreshedCheckpointListener.refreshedCheckpoint.get()__    };returned,the,last,local,checkpoint,value,has,been,refreshed,internally;final,long,last,refreshed,checkpoint,return,last,refreshed,checkpoint,listener,refreshed,checkpoint,get
InternalEngine -> final long lastRefreshedCheckpoint();1541335413;Returned the last local checkpoint value has been refreshed internally.;final long lastRefreshedCheckpoint() {_        return lastRefreshedCheckpointListener.refreshedCheckpoint.get()__    };returned,the,last,local,checkpoint,value,has,been,refreshed,internally;final,long,last,refreshed,checkpoint,return,last,refreshed,checkpoint,listener,refreshed,checkpoint,get
InternalEngine -> final long lastRefreshedCheckpoint();1541622390;Returned the last local checkpoint value has been refreshed internally.;final long lastRefreshedCheckpoint() {_        return lastRefreshedCheckpointListener.refreshedCheckpoint.get()__    };returned,the,last,local,checkpoint,value,has,been,refreshed,internally;final,long,last,refreshed,checkpoint,return,last,refreshed,checkpoint,listener,refreshed,checkpoint,get
InternalEngine -> final long lastRefreshedCheckpoint();1542697754;Returned the last local checkpoint value has been refreshed internally.;final long lastRefreshedCheckpoint() {_        return lastRefreshedCheckpointListener.refreshedCheckpoint.get()__    };returned,the,last,local,checkpoint,value,has,been,refreshed,internally;final,long,last,refreshed,checkpoint,return,last,refreshed,checkpoint,listener,refreshed,checkpoint,get
InternalEngine -> final long lastRefreshedCheckpoint();1543940134;Returned the last local checkpoint value has been refreshed internally.;final long lastRefreshedCheckpoint() {_        return lastRefreshedCheckpointListener.refreshedCheckpoint.get()__    };returned,the,last,local,checkpoint,value,has,been,refreshed,internally;final,long,last,refreshed,checkpoint,return,last,refreshed,checkpoint,listener,refreshed,checkpoint,get
InternalEngine -> final long lastRefreshedCheckpoint();1544322276;Returned the last local checkpoint value has been refreshed internally.;final long lastRefreshedCheckpoint() {_        return lastRefreshedCheckpointListener.refreshedCheckpoint.get()__    };returned,the,last,local,checkpoint,value,has,been,refreshed,internally;final,long,last,refreshed,checkpoint,return,last,refreshed,checkpoint,listener,refreshed,checkpoint,get
InternalEngine -> final long lastRefreshedCheckpoint();1544545090;Returned the last local checkpoint value has been refreshed internally.;final long lastRefreshedCheckpoint() {_        return lastRefreshedCheckpointListener.refreshedCheckpoint.get()__    };returned,the,last,local,checkpoint,value,has,been,refreshed,internally;final,long,last,refreshed,checkpoint,return,last,refreshed,checkpoint,listener,refreshed,checkpoint,get
InternalEngine -> final long lastRefreshedCheckpoint();1544684920;Returned the last local checkpoint value has been refreshed internally.;final long lastRefreshedCheckpoint() {_        return lastRefreshedCheckpointListener.refreshedCheckpoint.get()__    };returned,the,last,local,checkpoint,value,has,been,refreshed,internally;final,long,last,refreshed,checkpoint,return,last,refreshed,checkpoint,listener,refreshed,checkpoint,get
InternalEngine -> final long lastRefreshedCheckpoint();1545140118;Returned the last local checkpoint value has been refreshed internally.;final long lastRefreshedCheckpoint() {_        return lastRefreshedCheckpointListener.refreshedCheckpoint.get()__    };returned,the,last,local,checkpoint,value,has,been,refreshed,internally;final,long,last,refreshed,checkpoint,return,last,refreshed,checkpoint,listener,refreshed,checkpoint,get
InternalEngine -> final long lastRefreshedCheckpoint();1546875837;Returned the last local checkpoint value has been refreshed internally.;final long lastRefreshedCheckpoint() {_        return lastRefreshedCheckpointListener.refreshedCheckpoint.get()__    };returned,the,last,local,checkpoint,value,has,been,refreshed,internally;final,long,last,refreshed,checkpoint,return,last,refreshed,checkpoint,listener,refreshed,checkpoint,get
InternalEngine -> final long lastRefreshedCheckpoint();1547332999;Returned the last local checkpoint value has been refreshed internally.;final long lastRefreshedCheckpoint() {_        return lastRefreshedCheckpointListener.refreshedCheckpoint.get()__    };returned,the,last,local,checkpoint,value,has,been,refreshed,internally;final,long,last,refreshed,checkpoint,return,last,refreshed,checkpoint,listener,refreshed,checkpoint,get
InternalEngine -> final long lastRefreshedCheckpoint();1548771485;Returned the last local checkpoint value has been refreshed internally.;final long lastRefreshedCheckpoint() {_        return lastRefreshedCheckpointListener.refreshedCheckpoint.get()__    };returned,the,last,local,checkpoint,value,has,been,refreshed,internally;final,long,last,refreshed,checkpoint,return,last,refreshed,checkpoint,listener,refreshed,checkpoint,get
InternalEngine -> final long lastRefreshedCheckpoint();1549059559;Returned the last local checkpoint value has been refreshed internally.;final long lastRefreshedCheckpoint() {_        return lastRefreshedCheckpointListener.refreshedCheckpoint.get()__    };returned,the,last,local,checkpoint,value,has,been,refreshed,internally;final,long,last,refreshed,checkpoint,return,last,refreshed,checkpoint,listener,refreshed,checkpoint,get
InternalEngine -> final long lastRefreshedCheckpoint();1549663373;Returned the last local checkpoint value has been refreshed internally.;final long lastRefreshedCheckpoint() {_        return lastRefreshedCheckpointListener.refreshedCheckpoint.get()__    };returned,the,last,local,checkpoint,value,has,been,refreshed,internally;final,long,last,refreshed,checkpoint,return,last,refreshed,checkpoint,listener,refreshed,checkpoint,get
InternalEngine -> final long lastRefreshedCheckpoint();1549975032;Returned the last local checkpoint value has been refreshed internally.;final long lastRefreshedCheckpoint() {_        return lastRefreshedCheckpointListener.refreshedCheckpoint.get()__    };returned,the,last,local,checkpoint,value,has,been,refreshed,internally;final,long,last,refreshed,checkpoint,return,last,refreshed,checkpoint,listener,refreshed,checkpoint,get
InternalEngine -> final long lastRefreshedCheckpoint();1550220204;Returned the last local checkpoint value has been refreshed internally.;final long lastRefreshedCheckpoint() {_        return lastRefreshedCheckpointListener.refreshedCheckpoint.get()__    };returned,the,last,local,checkpoint,value,has,been,refreshed,internally;final,long,last,refreshed,checkpoint,return,last,refreshed,checkpoint,listener,refreshed,checkpoint,get
InternalEngine -> final long lastRefreshedCheckpoint();1550256122;Returned the last local checkpoint value has been refreshed internally.;final long lastRefreshedCheckpoint() {_        return lastRefreshedCheckpointListener.refreshedCheckpoint.get()__    };returned,the,last,local,checkpoint,value,has,been,refreshed,internally;final,long,last,refreshed,checkpoint,return,last,refreshed,checkpoint,listener,refreshed,checkpoint,get
InternalEngine -> final long lastRefreshedCheckpoint();1550342051;Returned the last local checkpoint value has been refreshed internally.;final long lastRefreshedCheckpoint() {_        return lastRefreshedCheckpointListener.refreshedCheckpoint.get()__    };returned,the,last,local,checkpoint,value,has,been,refreshed,internally;final,long,last,refreshed,checkpoint,return,last,refreshed,checkpoint,listener,refreshed,checkpoint,get
InternalEngine -> final long lastRefreshedCheckpoint();1550526771;Returned the last local checkpoint value has been refreshed internally.;final long lastRefreshedCheckpoint() {_        return lastRefreshedCheckpointListener.refreshedCheckpoint.get()__    };returned,the,last,local,checkpoint,value,has,been,refreshed,internally;final,long,last,refreshed,checkpoint,return,last,refreshed,checkpoint,listener,refreshed,checkpoint,get
InternalEngine -> final long lastRefreshedCheckpoint();1551110274;Returned the last local checkpoint value has been refreshed internally.;final long lastRefreshedCheckpoint() {_        return lastRefreshedCheckpointListener.refreshedCheckpoint.get()__    };returned,the,last,local,checkpoint,value,has,been,refreshed,internally;final,long,last,refreshed,checkpoint,return,last,refreshed,checkpoint,listener,refreshed,checkpoint,get
InternalEngine -> final long lastRefreshedCheckpoint();1551126708;Returned the last local checkpoint value has been refreshed internally.;final long lastRefreshedCheckpoint() {_        return lastRefreshedCheckpointListener.refreshedCheckpoint.get()__    };returned,the,last,local,checkpoint,value,has,been,refreshed,internally;final,long,last,refreshed,checkpoint,return,last,refreshed,checkpoint,listener,refreshed,checkpoint,get
InternalEngine -> long getNumVersionLookups();1524684173;Returns the number of times a version was looked up either from memory or from the index._Note this is only available if assertions are enabled;long getNumVersionLookups() { _        return numVersionLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,memory,or,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,version,lookups,return,num,version,lookups,count
InternalEngine -> long getNumVersionLookups();1524780945;Returns the number of times a version was looked up either from memory or from the index._Note this is only available if assertions are enabled;long getNumVersionLookups() { _        return numVersionLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,memory,or,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,version,lookups,return,num,version,lookups,count
InternalEngine -> long getNumVersionLookups();1525162917;Returns the number of times a version was looked up either from memory or from the index._Note this is only available if assertions are enabled;long getNumVersionLookups() { _        return numVersionLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,memory,or,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,version,lookups,return,num,version,lookups,count
InternalEngine -> long getNumVersionLookups();1528706846;Returns the number of times a version was looked up either from memory or from the index._Note this is only available if assertions are enabled;long getNumVersionLookups() { _        return numVersionLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,memory,or,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,version,lookups,return,num,version,lookups,count
InternalEngine -> long getNumVersionLookups();1528762805;Returns the number of times a version was looked up either from memory or from the index._Note this is only available if assertions are enabled;long getNumVersionLookups() { _        return numVersionLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,memory,or,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,version,lookups,return,num,version,lookups,count
InternalEngine -> long getNumVersionLookups();1531910483;Returns the number of times a version was looked up either from memory or from the index._Note this is only available if assertions are enabled;long getNumVersionLookups() { _        return numVersionLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,memory,or,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,version,lookups,return,num,version,lookups,count
InternalEngine -> long getNumVersionLookups();1533295538;Returns the number of times a version was looked up either from memory or from the index._Note this is only available if assertions are enabled;long getNumVersionLookups() { _        return numVersionLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,memory,or,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,version,lookups,return,num,version,lookups,count
InternalEngine -> long getNumVersionLookups();1534848846;Returns the number of times a version was looked up either from memory or from the index._Note this is only available if assertions are enabled;long getNumVersionLookups() { _        return numVersionLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,memory,or,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,version,lookups,return,num,version,lookups,count
InternalEngine -> long getNumVersionLookups();1535046779;Returns the number of times a version was looked up either from memory or from the index._Note this is only available if assertions are enabled;long getNumVersionLookups() { _        return numVersionLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,memory,or,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,version,lookups,return,num,version,lookups,count
InternalEngine -> long getNumVersionLookups();1535405719;Returns the number of times a version was looked up either from memory or from the index._Note this is only available if assertions are enabled;long getNumVersionLookups() { _        return numVersionLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,memory,or,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,version,lookups,return,num,version,lookups,count
InternalEngine -> long getNumVersionLookups();1535723122;Returns the number of times a version was looked up either from memory or from the index._Note this is only available if assertions are enabled;long getNumVersionLookups() { _        return numVersionLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,memory,or,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,version,lookups,return,num,version,lookups,count
InternalEngine -> long getNumVersionLookups();1535965276;Returns the number of times a version was looked up either from memory or from the index._Note this is only available if assertions are enabled;long getNumVersionLookups() { _        return numVersionLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,memory,or,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,version,lookups,return,num,version,lookups,count
InternalEngine -> long getNumVersionLookups();1536218260;Returns the number of times a version was looked up either from memory or from the index._Note this is only available if assertions are enabled;long getNumVersionLookups() { _        return numVersionLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,memory,or,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,version,lookups,return,num,version,lookups,count
InternalEngine -> long getNumVersionLookups();1536314350;Returns the number of times a version was looked up either from memory or from the index._Note this is only available if assertions are enabled;long getNumVersionLookups() { _        return numVersionLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,memory,or,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,version,lookups,return,num,version,lookups,count
InternalEngine -> long getNumVersionLookups();1536828374;Returns the number of times a version was looked up either from memory or from the index._Note this is only available if assertions are enabled;long getNumVersionLookups() { _        return numVersionLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,memory,or,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,version,lookups,return,num,version,lookups,count
InternalEngine -> long getNumVersionLookups();1537806831;Returns the number of times a version was looked up either from memory or from the index._Note this is only available if assertions are enabled;long getNumVersionLookups() { _        return numVersionLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,memory,or,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,version,lookups,return,num,version,lookups,count
InternalEngine -> long getNumVersionLookups();1538067637;Returns the number of times a version was looked up either from memory or from the index._Note this is only available if assertions are enabled;long getNumVersionLookups() { _        return numVersionLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,memory,or,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,version,lookups,return,num,version,lookups,count
InternalEngine -> long getNumVersionLookups();1538424609;Returns the number of times a version was looked up either from memory or from the index._Note this is only available if assertions are enabled;long getNumVersionLookups() { _        return numVersionLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,memory,or,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,version,lookups,return,num,version,lookups,count
InternalEngine -> long getNumVersionLookups();1539615817;Returns the number of times a version was looked up either from memory or from the index._Note this is only available if assertions are enabled;long getNumVersionLookups() { _        return numVersionLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,memory,or,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,version,lookups,return,num,version,lookups,count
InternalEngine -> long getNumVersionLookups();1539723533;Returns the number of times a version was looked up either from memory or from the index._Note this is only available if assertions are enabled;long getNumVersionLookups() { _        return numVersionLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,memory,or,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,version,lookups,return,num,version,lookups,count
InternalEngine -> long getNumVersionLookups();1540238977;Returns the number of times a version was looked up either from memory or from the index._Note this is only available if assertions are enabled;long getNumVersionLookups() { _        return numVersionLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,memory,or,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,version,lookups,return,num,version,lookups,count
InternalEngine -> long getNumVersionLookups();1541335413;Returns the number of times a version was looked up either from memory or from the index._Note this is only available if assertions are enabled;long getNumVersionLookups() { _        return numVersionLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,memory,or,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,version,lookups,return,num,version,lookups,count
InternalEngine -> long getNumVersionLookups();1541622390;Returns the number of times a version was looked up either from memory or from the index._Note this is only available if assertions are enabled;long getNumVersionLookups() { _        return numVersionLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,memory,or,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,version,lookups,return,num,version,lookups,count
InternalEngine -> long getNumVersionLookups();1542697754;Returns the number of times a version was looked up either from memory or from the index._Note this is only available if assertions are enabled;long getNumVersionLookups() { _        return numVersionLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,memory,or,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,version,lookups,return,num,version,lookups,count
InternalEngine -> long getNumVersionLookups();1543940134;Returns the number of times a version was looked up either from memory or from the index._Note this is only available if assertions are enabled;long getNumVersionLookups() { _        return numVersionLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,memory,or,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,version,lookups,return,num,version,lookups,count
InternalEngine -> long getNumVersionLookups();1544322276;Returns the number of times a version was looked up either from memory or from the index._Note this is only available if assertions are enabled;long getNumVersionLookups() { _        return numVersionLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,memory,or,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,version,lookups,return,num,version,lookups,count
InternalEngine -> long getNumVersionLookups();1544545090;Returns the number of times a version was looked up either from memory or from the index._Note this is only available if assertions are enabled;long getNumVersionLookups() { _        return numVersionLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,memory,or,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,version,lookups,return,num,version,lookups,count
InternalEngine -> long getNumVersionLookups();1544684920;Returns the number of times a version was looked up either from memory or from the index._Note this is only available if assertions are enabled;long getNumVersionLookups() { _        return numVersionLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,memory,or,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,version,lookups,return,num,version,lookups,count
InternalEngine -> long getNumVersionLookups();1545140118;Returns the number of times a version was looked up either from memory or from the index._Note this is only available if assertions are enabled;long getNumVersionLookups() { _        return numVersionLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,memory,or,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,version,lookups,return,num,version,lookups,count
InternalEngine -> long getNumVersionLookups();1546875837;Returns the number of times a version was looked up either from memory or from the index._Note this is only available if assertions are enabled;long getNumVersionLookups() { _        return numVersionLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,memory,or,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,version,lookups,return,num,version,lookups,count
InternalEngine -> long getNumVersionLookups();1547332999;Returns the number of times a version was looked up either from memory or from the index._Note this is only available if assertions are enabled;long getNumVersionLookups() { _        return numVersionLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,memory,or,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,version,lookups,return,num,version,lookups,count
InternalEngine -> long getNumVersionLookups();1548771485;Returns the number of times a version was looked up either from memory or from the index._Note this is only available if assertions are enabled;long getNumVersionLookups() { _        return numVersionLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,memory,or,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,version,lookups,return,num,version,lookups,count
InternalEngine -> long getNumVersionLookups();1549059559;Returns the number of times a version was looked up either from memory or from the index._Note this is only available if assertions are enabled;long getNumVersionLookups() { _        return numVersionLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,memory,or,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,version,lookups,return,num,version,lookups,count
InternalEngine -> long getNumVersionLookups();1549663373;Returns the number of times a version was looked up either from memory or from the index._Note this is only available if assertions are enabled;long getNumVersionLookups() { _        return numVersionLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,memory,or,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,version,lookups,return,num,version,lookups,count
InternalEngine -> long getNumVersionLookups();1549975032;Returns the number of times a version was looked up either from memory or from the index._Note this is only available if assertions are enabled;long getNumVersionLookups() { _        return numVersionLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,memory,or,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,version,lookups,return,num,version,lookups,count
InternalEngine -> long getNumVersionLookups();1550220204;Returns the number of times a version was looked up either from memory or from the index._Note this is only available if assertions are enabled;long getNumVersionLookups() { _        return numVersionLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,memory,or,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,version,lookups,return,num,version,lookups,count
InternalEngine -> long getNumVersionLookups();1550256122;Returns the number of times a version was looked up either from memory or from the index._Note this is only available if assertions are enabled;long getNumVersionLookups() { _        return numVersionLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,memory,or,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,version,lookups,return,num,version,lookups,count
InternalEngine -> long getNumVersionLookups();1550342051;Returns the number of times a version was looked up either from memory or from the index._Note this is only available if assertions are enabled;long getNumVersionLookups() { _        return numVersionLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,memory,or,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,version,lookups,return,num,version,lookups,count
InternalEngine -> long getNumVersionLookups();1550526771;Returns the number of times a version was looked up either from memory or from the index._Note this is only available if assertions are enabled;long getNumVersionLookups() { _        return numVersionLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,memory,or,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,version,lookups,return,num,version,lookups,count
InternalEngine -> long getNumVersionLookups();1551110274;Returns the number of times a version was looked up either from memory or from the index._Note this is only available if assertions are enabled;long getNumVersionLookups() { _        return numVersionLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,memory,or,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,version,lookups,return,num,version,lookups,count
InternalEngine -> long getNumVersionLookups();1551126708;Returns the number of times a version was looked up either from memory or from the index._Note this is only available if assertions are enabled;long getNumVersionLookups() { _        return numVersionLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,memory,or,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,version,lookups,return,num,version,lookups,count
InternalEngine -> private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter);1524684173;Gets the commit data from {@link IndexWriter} as a map.;private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter) {_        Map<String, String> commitData = new HashMap<>(6)__        for (Map.Entry<String, String> entry : indexWriter.getLiveCommitData()) {_            commitData.put(entry.getKey(), entry.getValue())__        }_        return commitData__    };gets,the,commit,data,from,link,index,writer,as,a,map;private,static,map,string,string,commit,data,as,map,final,index,writer,index,writer,map,string,string,commit,data,new,hash,map,6,for,map,entry,string,string,entry,index,writer,get,live,commit,data,commit,data,put,entry,get,key,entry,get,value,return,commit,data
InternalEngine -> private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter);1524780945;Gets the commit data from {@link IndexWriter} as a map.;private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter) {_        Map<String, String> commitData = new HashMap<>(6)__        for (Map.Entry<String, String> entry : indexWriter.getLiveCommitData()) {_            commitData.put(entry.getKey(), entry.getValue())__        }_        return commitData__    };gets,the,commit,data,from,link,index,writer,as,a,map;private,static,map,string,string,commit,data,as,map,final,index,writer,index,writer,map,string,string,commit,data,new,hash,map,6,for,map,entry,string,string,entry,index,writer,get,live,commit,data,commit,data,put,entry,get,key,entry,get,value,return,commit,data
InternalEngine -> private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter);1525162917;Gets the commit data from {@link IndexWriter} as a map.;private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter) {_        Map<String, String> commitData = new HashMap<>(6)__        for (Map.Entry<String, String> entry : indexWriter.getLiveCommitData()) {_            commitData.put(entry.getKey(), entry.getValue())__        }_        return commitData__    };gets,the,commit,data,from,link,index,writer,as,a,map;private,static,map,string,string,commit,data,as,map,final,index,writer,index,writer,map,string,string,commit,data,new,hash,map,6,for,map,entry,string,string,entry,index,writer,get,live,commit,data,commit,data,put,entry,get,key,entry,get,value,return,commit,data
InternalEngine -> private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter);1528706846;Gets the commit data from {@link IndexWriter} as a map.;private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter) {_        Map<String, String> commitData = new HashMap<>(6)__        for (Map.Entry<String, String> entry : indexWriter.getLiveCommitData()) {_            commitData.put(entry.getKey(), entry.getValue())__        }_        return commitData__    };gets,the,commit,data,from,link,index,writer,as,a,map;private,static,map,string,string,commit,data,as,map,final,index,writer,index,writer,map,string,string,commit,data,new,hash,map,6,for,map,entry,string,string,entry,index,writer,get,live,commit,data,commit,data,put,entry,get,key,entry,get,value,return,commit,data
InternalEngine -> private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter);1528762805;Gets the commit data from {@link IndexWriter} as a map.;private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter) {_        Map<String, String> commitData = new HashMap<>(6)__        for (Map.Entry<String, String> entry : indexWriter.getLiveCommitData()) {_            commitData.put(entry.getKey(), entry.getValue())__        }_        return commitData__    };gets,the,commit,data,from,link,index,writer,as,a,map;private,static,map,string,string,commit,data,as,map,final,index,writer,index,writer,map,string,string,commit,data,new,hash,map,6,for,map,entry,string,string,entry,index,writer,get,live,commit,data,commit,data,put,entry,get,key,entry,get,value,return,commit,data
InternalEngine -> private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter);1531910483;Gets the commit data from {@link IndexWriter} as a map.;private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter) {_        Map<String, String> commitData = new HashMap<>(6)__        for (Map.Entry<String, String> entry : indexWriter.getLiveCommitData()) {_            commitData.put(entry.getKey(), entry.getValue())__        }_        return commitData__    };gets,the,commit,data,from,link,index,writer,as,a,map;private,static,map,string,string,commit,data,as,map,final,index,writer,index,writer,map,string,string,commit,data,new,hash,map,6,for,map,entry,string,string,entry,index,writer,get,live,commit,data,commit,data,put,entry,get,key,entry,get,value,return,commit,data
InternalEngine -> private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter);1533295538;Gets the commit data from {@link IndexWriter} as a map.;private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter) {_        Map<String, String> commitData = new HashMap<>(6)__        for (Map.Entry<String, String> entry : indexWriter.getLiveCommitData()) {_            commitData.put(entry.getKey(), entry.getValue())__        }_        return commitData__    };gets,the,commit,data,from,link,index,writer,as,a,map;private,static,map,string,string,commit,data,as,map,final,index,writer,index,writer,map,string,string,commit,data,new,hash,map,6,for,map,entry,string,string,entry,index,writer,get,live,commit,data,commit,data,put,entry,get,key,entry,get,value,return,commit,data
InternalEngine -> private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter);1534848846;Gets the commit data from {@link IndexWriter} as a map.;private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter) {_        Map<String, String> commitData = new HashMap<>(6)__        for (Map.Entry<String, String> entry : indexWriter.getLiveCommitData()) {_            commitData.put(entry.getKey(), entry.getValue())__        }_        return commitData__    };gets,the,commit,data,from,link,index,writer,as,a,map;private,static,map,string,string,commit,data,as,map,final,index,writer,index,writer,map,string,string,commit,data,new,hash,map,6,for,map,entry,string,string,entry,index,writer,get,live,commit,data,commit,data,put,entry,get,key,entry,get,value,return,commit,data
InternalEngine -> private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter);1535046779;Gets the commit data from {@link IndexWriter} as a map.;private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter) {_        Map<String, String> commitData = new HashMap<>(6)__        for (Map.Entry<String, String> entry : indexWriter.getLiveCommitData()) {_            commitData.put(entry.getKey(), entry.getValue())__        }_        return commitData__    };gets,the,commit,data,from,link,index,writer,as,a,map;private,static,map,string,string,commit,data,as,map,final,index,writer,index,writer,map,string,string,commit,data,new,hash,map,6,for,map,entry,string,string,entry,index,writer,get,live,commit,data,commit,data,put,entry,get,key,entry,get,value,return,commit,data
InternalEngine -> private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter);1535405719;Gets the commit data from {@link IndexWriter} as a map.;private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter) {_        Map<String, String> commitData = new HashMap<>(6)__        for (Map.Entry<String, String> entry : indexWriter.getLiveCommitData()) {_            commitData.put(entry.getKey(), entry.getValue())__        }_        return commitData__    };gets,the,commit,data,from,link,index,writer,as,a,map;private,static,map,string,string,commit,data,as,map,final,index,writer,index,writer,map,string,string,commit,data,new,hash,map,6,for,map,entry,string,string,entry,index,writer,get,live,commit,data,commit,data,put,entry,get,key,entry,get,value,return,commit,data
InternalEngine -> private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter);1535723122;Gets the commit data from {@link IndexWriter} as a map.;private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter) {_        Map<String, String> commitData = new HashMap<>(6)__        for (Map.Entry<String, String> entry : indexWriter.getLiveCommitData()) {_            commitData.put(entry.getKey(), entry.getValue())__        }_        return commitData__    };gets,the,commit,data,from,link,index,writer,as,a,map;private,static,map,string,string,commit,data,as,map,final,index,writer,index,writer,map,string,string,commit,data,new,hash,map,6,for,map,entry,string,string,entry,index,writer,get,live,commit,data,commit,data,put,entry,get,key,entry,get,value,return,commit,data
InternalEngine -> private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter);1535965276;Gets the commit data from {@link IndexWriter} as a map.;private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter) {_        Map<String, String> commitData = new HashMap<>(6)__        for (Map.Entry<String, String> entry : indexWriter.getLiveCommitData()) {_            commitData.put(entry.getKey(), entry.getValue())__        }_        return commitData__    };gets,the,commit,data,from,link,index,writer,as,a,map;private,static,map,string,string,commit,data,as,map,final,index,writer,index,writer,map,string,string,commit,data,new,hash,map,6,for,map,entry,string,string,entry,index,writer,get,live,commit,data,commit,data,put,entry,get,key,entry,get,value,return,commit,data
InternalEngine -> private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter);1536218260;Gets the commit data from {@link IndexWriter} as a map.;private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter) {_        Map<String, String> commitData = new HashMap<>(6)__        for (Map.Entry<String, String> entry : indexWriter.getLiveCommitData()) {_            commitData.put(entry.getKey(), entry.getValue())__        }_        return commitData__    };gets,the,commit,data,from,link,index,writer,as,a,map;private,static,map,string,string,commit,data,as,map,final,index,writer,index,writer,map,string,string,commit,data,new,hash,map,6,for,map,entry,string,string,entry,index,writer,get,live,commit,data,commit,data,put,entry,get,key,entry,get,value,return,commit,data
InternalEngine -> private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter);1536314350;Gets the commit data from {@link IndexWriter} as a map.;private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter) {_        Map<String, String> commitData = new HashMap<>(6)__        for (Map.Entry<String, String> entry : indexWriter.getLiveCommitData()) {_            commitData.put(entry.getKey(), entry.getValue())__        }_        return commitData__    };gets,the,commit,data,from,link,index,writer,as,a,map;private,static,map,string,string,commit,data,as,map,final,index,writer,index,writer,map,string,string,commit,data,new,hash,map,6,for,map,entry,string,string,entry,index,writer,get,live,commit,data,commit,data,put,entry,get,key,entry,get,value,return,commit,data
InternalEngine -> private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter);1536828374;Gets the commit data from {@link IndexWriter} as a map.;private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter) {_        Map<String, String> commitData = new HashMap<>(6)__        for (Map.Entry<String, String> entry : indexWriter.getLiveCommitData()) {_            commitData.put(entry.getKey(), entry.getValue())__        }_        return commitData__    };gets,the,commit,data,from,link,index,writer,as,a,map;private,static,map,string,string,commit,data,as,map,final,index,writer,index,writer,map,string,string,commit,data,new,hash,map,6,for,map,entry,string,string,entry,index,writer,get,live,commit,data,commit,data,put,entry,get,key,entry,get,value,return,commit,data
InternalEngine -> private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter);1537806831;Gets the commit data from {@link IndexWriter} as a map.;private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter) {_        Map<String, String> commitData = new HashMap<>(6)__        for (Map.Entry<String, String> entry : indexWriter.getLiveCommitData()) {_            commitData.put(entry.getKey(), entry.getValue())__        }_        return commitData__    };gets,the,commit,data,from,link,index,writer,as,a,map;private,static,map,string,string,commit,data,as,map,final,index,writer,index,writer,map,string,string,commit,data,new,hash,map,6,for,map,entry,string,string,entry,index,writer,get,live,commit,data,commit,data,put,entry,get,key,entry,get,value,return,commit,data
InternalEngine -> private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter);1538067637;Gets the commit data from {@link IndexWriter} as a map.;private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter) {_        Map<String, String> commitData = new HashMap<>(6)__        for (Map.Entry<String, String> entry : indexWriter.getLiveCommitData()) {_            commitData.put(entry.getKey(), entry.getValue())__        }_        return commitData__    };gets,the,commit,data,from,link,index,writer,as,a,map;private,static,map,string,string,commit,data,as,map,final,index,writer,index,writer,map,string,string,commit,data,new,hash,map,6,for,map,entry,string,string,entry,index,writer,get,live,commit,data,commit,data,put,entry,get,key,entry,get,value,return,commit,data
InternalEngine -> private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter);1538424609;Gets the commit data from {@link IndexWriter} as a map.;private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter) {_        Map<String, String> commitData = new HashMap<>(6)__        for (Map.Entry<String, String> entry : indexWriter.getLiveCommitData()) {_            commitData.put(entry.getKey(), entry.getValue())__        }_        return commitData__    };gets,the,commit,data,from,link,index,writer,as,a,map;private,static,map,string,string,commit,data,as,map,final,index,writer,index,writer,map,string,string,commit,data,new,hash,map,6,for,map,entry,string,string,entry,index,writer,get,live,commit,data,commit,data,put,entry,get,key,entry,get,value,return,commit,data
InternalEngine -> private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter);1539615817;Gets the commit data from {@link IndexWriter} as a map.;private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter) {_        Map<String, String> commitData = new HashMap<>(6)__        for (Map.Entry<String, String> entry : indexWriter.getLiveCommitData()) {_            commitData.put(entry.getKey(), entry.getValue())__        }_        return commitData__    };gets,the,commit,data,from,link,index,writer,as,a,map;private,static,map,string,string,commit,data,as,map,final,index,writer,index,writer,map,string,string,commit,data,new,hash,map,6,for,map,entry,string,string,entry,index,writer,get,live,commit,data,commit,data,put,entry,get,key,entry,get,value,return,commit,data
InternalEngine -> private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter);1539723533;Gets the commit data from {@link IndexWriter} as a map.;private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter) {_        Map<String, String> commitData = new HashMap<>(6)__        for (Map.Entry<String, String> entry : indexWriter.getLiveCommitData()) {_            commitData.put(entry.getKey(), entry.getValue())__        }_        return commitData__    };gets,the,commit,data,from,link,index,writer,as,a,map;private,static,map,string,string,commit,data,as,map,final,index,writer,index,writer,map,string,string,commit,data,new,hash,map,6,for,map,entry,string,string,entry,index,writer,get,live,commit,data,commit,data,put,entry,get,key,entry,get,value,return,commit,data
InternalEngine -> private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter);1540238977;Gets the commit data from {@link IndexWriter} as a map.;private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter) {_        Map<String, String> commitData = new HashMap<>(6)__        for (Map.Entry<String, String> entry : indexWriter.getLiveCommitData()) {_            commitData.put(entry.getKey(), entry.getValue())__        }_        return commitData__    };gets,the,commit,data,from,link,index,writer,as,a,map;private,static,map,string,string,commit,data,as,map,final,index,writer,index,writer,map,string,string,commit,data,new,hash,map,6,for,map,entry,string,string,entry,index,writer,get,live,commit,data,commit,data,put,entry,get,key,entry,get,value,return,commit,data
InternalEngine -> private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter);1541335413;Gets the commit data from {@link IndexWriter} as a map.;private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter) {_        Map<String, String> commitData = new HashMap<>(6)__        for (Map.Entry<String, String> entry : indexWriter.getLiveCommitData()) {_            commitData.put(entry.getKey(), entry.getValue())__        }_        return commitData__    };gets,the,commit,data,from,link,index,writer,as,a,map;private,static,map,string,string,commit,data,as,map,final,index,writer,index,writer,map,string,string,commit,data,new,hash,map,6,for,map,entry,string,string,entry,index,writer,get,live,commit,data,commit,data,put,entry,get,key,entry,get,value,return,commit,data
InternalEngine -> private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter);1541622390;Gets the commit data from {@link IndexWriter} as a map.;private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter) {_        Map<String, String> commitData = new HashMap<>(6)__        for (Map.Entry<String, String> entry : indexWriter.getLiveCommitData()) {_            commitData.put(entry.getKey(), entry.getValue())__        }_        return commitData__    };gets,the,commit,data,from,link,index,writer,as,a,map;private,static,map,string,string,commit,data,as,map,final,index,writer,index,writer,map,string,string,commit,data,new,hash,map,6,for,map,entry,string,string,entry,index,writer,get,live,commit,data,commit,data,put,entry,get,key,entry,get,value,return,commit,data
InternalEngine -> private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter);1542697754;Gets the commit data from {@link IndexWriter} as a map.;private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter) {_        Map<String, String> commitData = new HashMap<>(6)__        for (Map.Entry<String, String> entry : indexWriter.getLiveCommitData()) {_            commitData.put(entry.getKey(), entry.getValue())__        }_        return commitData__    };gets,the,commit,data,from,link,index,writer,as,a,map;private,static,map,string,string,commit,data,as,map,final,index,writer,index,writer,map,string,string,commit,data,new,hash,map,6,for,map,entry,string,string,entry,index,writer,get,live,commit,data,commit,data,put,entry,get,key,entry,get,value,return,commit,data
InternalEngine -> private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter);1543940134;Gets the commit data from {@link IndexWriter} as a map.;private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter) {_        Map<String, String> commitData = new HashMap<>(6)__        for (Map.Entry<String, String> entry : indexWriter.getLiveCommitData()) {_            commitData.put(entry.getKey(), entry.getValue())__        }_        return commitData__    };gets,the,commit,data,from,link,index,writer,as,a,map;private,static,map,string,string,commit,data,as,map,final,index,writer,index,writer,map,string,string,commit,data,new,hash,map,6,for,map,entry,string,string,entry,index,writer,get,live,commit,data,commit,data,put,entry,get,key,entry,get,value,return,commit,data
InternalEngine -> private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter);1544322276;Gets the commit data from {@link IndexWriter} as a map.;private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter) {_        Map<String, String> commitData = new HashMap<>(6)__        for (Map.Entry<String, String> entry : indexWriter.getLiveCommitData()) {_            commitData.put(entry.getKey(), entry.getValue())__        }_        return commitData__    };gets,the,commit,data,from,link,index,writer,as,a,map;private,static,map,string,string,commit,data,as,map,final,index,writer,index,writer,map,string,string,commit,data,new,hash,map,6,for,map,entry,string,string,entry,index,writer,get,live,commit,data,commit,data,put,entry,get,key,entry,get,value,return,commit,data
InternalEngine -> private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter);1544545090;Gets the commit data from {@link IndexWriter} as a map.;private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter) {_        Map<String, String> commitData = new HashMap<>(6)__        for (Map.Entry<String, String> entry : indexWriter.getLiveCommitData()) {_            commitData.put(entry.getKey(), entry.getValue())__        }_        return commitData__    };gets,the,commit,data,from,link,index,writer,as,a,map;private,static,map,string,string,commit,data,as,map,final,index,writer,index,writer,map,string,string,commit,data,new,hash,map,6,for,map,entry,string,string,entry,index,writer,get,live,commit,data,commit,data,put,entry,get,key,entry,get,value,return,commit,data
InternalEngine -> private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter);1544684920;Gets the commit data from {@link IndexWriter} as a map.;private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter) {_        Map<String, String> commitData = new HashMap<>(6)__        for (Map.Entry<String, String> entry : indexWriter.getLiveCommitData()) {_            commitData.put(entry.getKey(), entry.getValue())__        }_        return commitData__    };gets,the,commit,data,from,link,index,writer,as,a,map;private,static,map,string,string,commit,data,as,map,final,index,writer,index,writer,map,string,string,commit,data,new,hash,map,6,for,map,entry,string,string,entry,index,writer,get,live,commit,data,commit,data,put,entry,get,key,entry,get,value,return,commit,data
InternalEngine -> private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter);1545140118;Gets the commit data from {@link IndexWriter} as a map.;private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter) {_        Map<String, String> commitData = new HashMap<>(6)__        for (Map.Entry<String, String> entry : indexWriter.getLiveCommitData()) {_            commitData.put(entry.getKey(), entry.getValue())__        }_        return commitData__    };gets,the,commit,data,from,link,index,writer,as,a,map;private,static,map,string,string,commit,data,as,map,final,index,writer,index,writer,map,string,string,commit,data,new,hash,map,6,for,map,entry,string,string,entry,index,writer,get,live,commit,data,commit,data,put,entry,get,key,entry,get,value,return,commit,data
InternalEngine -> private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter);1546875837;Gets the commit data from {@link IndexWriter} as a map.;private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter) {_        Map<String, String> commitData = new HashMap<>(6)__        for (Map.Entry<String, String> entry : indexWriter.getLiveCommitData()) {_            commitData.put(entry.getKey(), entry.getValue())__        }_        return commitData__    };gets,the,commit,data,from,link,index,writer,as,a,map;private,static,map,string,string,commit,data,as,map,final,index,writer,index,writer,map,string,string,commit,data,new,hash,map,6,for,map,entry,string,string,entry,index,writer,get,live,commit,data,commit,data,put,entry,get,key,entry,get,value,return,commit,data
InternalEngine -> private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter);1547332999;Gets the commit data from {@link IndexWriter} as a map.;private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter) {_        Map<String, String> commitData = new HashMap<>(6)__        for (Map.Entry<String, String> entry : indexWriter.getLiveCommitData()) {_            commitData.put(entry.getKey(), entry.getValue())__        }_        return commitData__    };gets,the,commit,data,from,link,index,writer,as,a,map;private,static,map,string,string,commit,data,as,map,final,index,writer,index,writer,map,string,string,commit,data,new,hash,map,6,for,map,entry,string,string,entry,index,writer,get,live,commit,data,commit,data,put,entry,get,key,entry,get,value,return,commit,data
InternalEngine -> private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter);1548771485;Gets the commit data from {@link IndexWriter} as a map.;private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter) {_        Map<String, String> commitData = new HashMap<>(6)__        for (Map.Entry<String, String> entry : indexWriter.getLiveCommitData()) {_            commitData.put(entry.getKey(), entry.getValue())__        }_        return commitData__    };gets,the,commit,data,from,link,index,writer,as,a,map;private,static,map,string,string,commit,data,as,map,final,index,writer,index,writer,map,string,string,commit,data,new,hash,map,6,for,map,entry,string,string,entry,index,writer,get,live,commit,data,commit,data,put,entry,get,key,entry,get,value,return,commit,data
InternalEngine -> private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter);1549059559;Gets the commit data from {@link IndexWriter} as a map.;private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter) {_        Map<String, String> commitData = new HashMap<>(6)__        for (Map.Entry<String, String> entry : indexWriter.getLiveCommitData()) {_            commitData.put(entry.getKey(), entry.getValue())__        }_        return commitData__    };gets,the,commit,data,from,link,index,writer,as,a,map;private,static,map,string,string,commit,data,as,map,final,index,writer,index,writer,map,string,string,commit,data,new,hash,map,6,for,map,entry,string,string,entry,index,writer,get,live,commit,data,commit,data,put,entry,get,key,entry,get,value,return,commit,data
InternalEngine -> private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter);1549663373;Gets the commit data from {@link IndexWriter} as a map.;private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter) {_        Map<String, String> commitData = new HashMap<>(6)__        for (Map.Entry<String, String> entry : indexWriter.getLiveCommitData()) {_            commitData.put(entry.getKey(), entry.getValue())__        }_        return commitData__    };gets,the,commit,data,from,link,index,writer,as,a,map;private,static,map,string,string,commit,data,as,map,final,index,writer,index,writer,map,string,string,commit,data,new,hash,map,6,for,map,entry,string,string,entry,index,writer,get,live,commit,data,commit,data,put,entry,get,key,entry,get,value,return,commit,data
InternalEngine -> private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter);1549975032;Gets the commit data from {@link IndexWriter} as a map.;private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter) {_        Map<String, String> commitData = new HashMap<>(6)__        for (Map.Entry<String, String> entry : indexWriter.getLiveCommitData()) {_            commitData.put(entry.getKey(), entry.getValue())__        }_        return commitData__    };gets,the,commit,data,from,link,index,writer,as,a,map;private,static,map,string,string,commit,data,as,map,final,index,writer,index,writer,map,string,string,commit,data,new,hash,map,6,for,map,entry,string,string,entry,index,writer,get,live,commit,data,commit,data,put,entry,get,key,entry,get,value,return,commit,data
InternalEngine -> private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter);1550220204;Gets the commit data from {@link IndexWriter} as a map.;private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter) {_        Map<String, String> commitData = new HashMap<>(6)__        for (Map.Entry<String, String> entry : indexWriter.getLiveCommitData()) {_            commitData.put(entry.getKey(), entry.getValue())__        }_        return commitData__    };gets,the,commit,data,from,link,index,writer,as,a,map;private,static,map,string,string,commit,data,as,map,final,index,writer,index,writer,map,string,string,commit,data,new,hash,map,6,for,map,entry,string,string,entry,index,writer,get,live,commit,data,commit,data,put,entry,get,key,entry,get,value,return,commit,data
InternalEngine -> private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter);1550256122;Gets the commit data from {@link IndexWriter} as a map.;private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter) {_        Map<String, String> commitData = new HashMap<>(6)__        for (Map.Entry<String, String> entry : indexWriter.getLiveCommitData()) {_            commitData.put(entry.getKey(), entry.getValue())__        }_        return commitData__    };gets,the,commit,data,from,link,index,writer,as,a,map;private,static,map,string,string,commit,data,as,map,final,index,writer,index,writer,map,string,string,commit,data,new,hash,map,6,for,map,entry,string,string,entry,index,writer,get,live,commit,data,commit,data,put,entry,get,key,entry,get,value,return,commit,data
InternalEngine -> private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter);1550342051;Gets the commit data from {@link IndexWriter} as a map.;private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter) {_        Map<String, String> commitData = new HashMap<>(6)__        for (Map.Entry<String, String> entry : indexWriter.getLiveCommitData()) {_            commitData.put(entry.getKey(), entry.getValue())__        }_        return commitData__    };gets,the,commit,data,from,link,index,writer,as,a,map;private,static,map,string,string,commit,data,as,map,final,index,writer,index,writer,map,string,string,commit,data,new,hash,map,6,for,map,entry,string,string,entry,index,writer,get,live,commit,data,commit,data,put,entry,get,key,entry,get,value,return,commit,data
InternalEngine -> private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter);1550526771;Gets the commit data from {@link IndexWriter} as a map.;private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter) {_        Map<String, String> commitData = new HashMap<>(6)__        for (Map.Entry<String, String> entry : indexWriter.getLiveCommitData()) {_            commitData.put(entry.getKey(), entry.getValue())__        }_        return commitData__    };gets,the,commit,data,from,link,index,writer,as,a,map;private,static,map,string,string,commit,data,as,map,final,index,writer,index,writer,map,string,string,commit,data,new,hash,map,6,for,map,entry,string,string,entry,index,writer,get,live,commit,data,commit,data,put,entry,get,key,entry,get,value,return,commit,data
InternalEngine -> private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter);1551110274;Gets the commit data from {@link IndexWriter} as a map.;private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter) {_        Map<String, String> commitData = new HashMap<>(6)__        for (Map.Entry<String, String> entry : indexWriter.getLiveCommitData()) {_            commitData.put(entry.getKey(), entry.getValue())__        }_        return commitData__    };gets,the,commit,data,from,link,index,writer,as,a,map;private,static,map,string,string,commit,data,as,map,final,index,writer,index,writer,map,string,string,commit,data,new,hash,map,6,for,map,entry,string,string,entry,index,writer,get,live,commit,data,commit,data,put,entry,get,key,entry,get,value,return,commit,data
InternalEngine -> private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter);1551126708;Gets the commit data from {@link IndexWriter} as a map.;private static Map<String, String> commitDataAsMap(final IndexWriter indexWriter) {_        Map<String, String> commitData = new HashMap<>(6)__        for (Map.Entry<String, String> entry : indexWriter.getLiveCommitData()) {_            commitData.put(entry.getKey(), entry.getValue())__        }_        return commitData__    };gets,the,commit,data,from,link,index,writer,as,a,map;private,static,map,string,string,commit,data,as,map,final,index,writer,index,writer,map,string,string,commit,data,new,hash,map,6,for,map,entry,string,string,entry,index,writer,get,live,commit,data,commit,data,put,entry,get,key,entry,get,value,return,commit,data
InternalEngine -> long getNumDocUpdates();1524684173;Returns the number of documents have been updated since this engine was opened._This count does not include the updates from the existing segments before opening engine.;long getNumDocUpdates() {_        return numDocUpdates.count()__    };returns,the,number,of,documents,have,been,updated,since,this,engine,was,opened,this,count,does,not,include,the,updates,from,the,existing,segments,before,opening,engine;long,get,num,doc,updates,return,num,doc,updates,count
InternalEngine -> long getNumDocUpdates();1524780945;Returns the number of documents have been updated since this engine was opened._This count does not include the updates from the existing segments before opening engine.;long getNumDocUpdates() {_        return numDocUpdates.count()__    };returns,the,number,of,documents,have,been,updated,since,this,engine,was,opened,this,count,does,not,include,the,updates,from,the,existing,segments,before,opening,engine;long,get,num,doc,updates,return,num,doc,updates,count
InternalEngine -> long getNumDocUpdates();1525162917;Returns the number of documents have been updated since this engine was opened._This count does not include the updates from the existing segments before opening engine.;long getNumDocUpdates() {_        return numDocUpdates.count()__    };returns,the,number,of,documents,have,been,updated,since,this,engine,was,opened,this,count,does,not,include,the,updates,from,the,existing,segments,before,opening,engine;long,get,num,doc,updates,return,num,doc,updates,count
InternalEngine -> long getNumDocUpdates();1528706846;Returns the number of documents have been updated since this engine was opened._This count does not include the updates from the existing segments before opening engine.;long getNumDocUpdates() {_        return numDocUpdates.count()__    };returns,the,number,of,documents,have,been,updated,since,this,engine,was,opened,this,count,does,not,include,the,updates,from,the,existing,segments,before,opening,engine;long,get,num,doc,updates,return,num,doc,updates,count
InternalEngine -> long getNumDocUpdates();1528762805;Returns the number of documents have been updated since this engine was opened._This count does not include the updates from the existing segments before opening engine.;long getNumDocUpdates() {_        return numDocUpdates.count()__    };returns,the,number,of,documents,have,been,updated,since,this,engine,was,opened,this,count,does,not,include,the,updates,from,the,existing,segments,before,opening,engine;long,get,num,doc,updates,return,num,doc,updates,count
InternalEngine -> long getNumDocUpdates();1531910483;Returns the number of documents have been updated since this engine was opened._This count does not include the updates from the existing segments before opening engine.;long getNumDocUpdates() {_        return numDocUpdates.count()__    };returns,the,number,of,documents,have,been,updated,since,this,engine,was,opened,this,count,does,not,include,the,updates,from,the,existing,segments,before,opening,engine;long,get,num,doc,updates,return,num,doc,updates,count
InternalEngine -> long getNumDocUpdates();1533295538;Returns the number of documents have been updated since this engine was opened._This count does not include the updates from the existing segments before opening engine.;long getNumDocUpdates() {_        return numDocUpdates.count()__    };returns,the,number,of,documents,have,been,updated,since,this,engine,was,opened,this,count,does,not,include,the,updates,from,the,existing,segments,before,opening,engine;long,get,num,doc,updates,return,num,doc,updates,count
InternalEngine -> long getNumDocUpdates();1534848846;Returns the number of documents have been updated since this engine was opened._This count does not include the updates from the existing segments before opening engine.;long getNumDocUpdates() {_        return numDocUpdates.count()__    };returns,the,number,of,documents,have,been,updated,since,this,engine,was,opened,this,count,does,not,include,the,updates,from,the,existing,segments,before,opening,engine;long,get,num,doc,updates,return,num,doc,updates,count
InternalEngine -> long getNumDocUpdates();1535046779;Returns the number of documents have been updated since this engine was opened._This count does not include the updates from the existing segments before opening engine.;long getNumDocUpdates() {_        return numDocUpdates.count()__    };returns,the,number,of,documents,have,been,updated,since,this,engine,was,opened,this,count,does,not,include,the,updates,from,the,existing,segments,before,opening,engine;long,get,num,doc,updates,return,num,doc,updates,count
InternalEngine -> long getNumDocUpdates();1535405719;Returns the number of documents have been updated since this engine was opened._This count does not include the updates from the existing segments before opening engine.;long getNumDocUpdates() {_        return numDocUpdates.count()__    };returns,the,number,of,documents,have,been,updated,since,this,engine,was,opened,this,count,does,not,include,the,updates,from,the,existing,segments,before,opening,engine;long,get,num,doc,updates,return,num,doc,updates,count
InternalEngine -> long getNumDocUpdates();1535723122;Returns the number of documents have been updated since this engine was opened._This count does not include the updates from the existing segments before opening engine.;long getNumDocUpdates() {_        return numDocUpdates.count()__    };returns,the,number,of,documents,have,been,updated,since,this,engine,was,opened,this,count,does,not,include,the,updates,from,the,existing,segments,before,opening,engine;long,get,num,doc,updates,return,num,doc,updates,count
InternalEngine -> long getNumDocUpdates();1535965276;Returns the number of documents have been updated since this engine was opened._This count does not include the updates from the existing segments before opening engine.;long getNumDocUpdates() {_        return numDocUpdates.count()__    };returns,the,number,of,documents,have,been,updated,since,this,engine,was,opened,this,count,does,not,include,the,updates,from,the,existing,segments,before,opening,engine;long,get,num,doc,updates,return,num,doc,updates,count
InternalEngine -> long getNumDocUpdates();1536218260;Returns the number of documents have been updated since this engine was opened._This count does not include the updates from the existing segments before opening engine.;long getNumDocUpdates() {_        return numDocUpdates.count()__    };returns,the,number,of,documents,have,been,updated,since,this,engine,was,opened,this,count,does,not,include,the,updates,from,the,existing,segments,before,opening,engine;long,get,num,doc,updates,return,num,doc,updates,count
InternalEngine -> long getNumDocUpdates();1536314350;Returns the number of documents have been updated since this engine was opened._This count does not include the updates from the existing segments before opening engine.;long getNumDocUpdates() {_        return numDocUpdates.count()__    };returns,the,number,of,documents,have,been,updated,since,this,engine,was,opened,this,count,does,not,include,the,updates,from,the,existing,segments,before,opening,engine;long,get,num,doc,updates,return,num,doc,updates,count
InternalEngine -> long getNumDocUpdates();1536828374;Returns the number of documents have been updated since this engine was opened._This count does not include the updates from the existing segments before opening engine.;long getNumDocUpdates() {_        return numDocUpdates.count()__    };returns,the,number,of,documents,have,been,updated,since,this,engine,was,opened,this,count,does,not,include,the,updates,from,the,existing,segments,before,opening,engine;long,get,num,doc,updates,return,num,doc,updates,count
InternalEngine -> long getNumDocUpdates();1537806831;Returns the number of documents have been updated since this engine was opened._This count does not include the updates from the existing segments before opening engine.;long getNumDocUpdates() {_        return numDocUpdates.count()__    };returns,the,number,of,documents,have,been,updated,since,this,engine,was,opened,this,count,does,not,include,the,updates,from,the,existing,segments,before,opening,engine;long,get,num,doc,updates,return,num,doc,updates,count
InternalEngine -> long getNumDocUpdates();1538067637;Returns the number of documents have been updated since this engine was opened._This count does not include the updates from the existing segments before opening engine.;long getNumDocUpdates() {_        return numDocUpdates.count()__    };returns,the,number,of,documents,have,been,updated,since,this,engine,was,opened,this,count,does,not,include,the,updates,from,the,existing,segments,before,opening,engine;long,get,num,doc,updates,return,num,doc,updates,count
InternalEngine -> long getNumDocUpdates();1538424609;Returns the number of documents have been updated since this engine was opened._This count does not include the updates from the existing segments before opening engine.;long getNumDocUpdates() {_        return numDocUpdates.count()__    };returns,the,number,of,documents,have,been,updated,since,this,engine,was,opened,this,count,does,not,include,the,updates,from,the,existing,segments,before,opening,engine;long,get,num,doc,updates,return,num,doc,updates,count
InternalEngine -> long getNumDocUpdates();1539615817;Returns the number of documents have been updated since this engine was opened._This count does not include the updates from the existing segments before opening engine.;long getNumDocUpdates() {_        return numDocUpdates.count()__    };returns,the,number,of,documents,have,been,updated,since,this,engine,was,opened,this,count,does,not,include,the,updates,from,the,existing,segments,before,opening,engine;long,get,num,doc,updates,return,num,doc,updates,count
InternalEngine -> long getNumDocUpdates();1539723533;Returns the number of documents have been updated since this engine was opened._This count does not include the updates from the existing segments before opening engine.;long getNumDocUpdates() {_        return numDocUpdates.count()__    };returns,the,number,of,documents,have,been,updated,since,this,engine,was,opened,this,count,does,not,include,the,updates,from,the,existing,segments,before,opening,engine;long,get,num,doc,updates,return,num,doc,updates,count
InternalEngine -> long getNumDocUpdates();1540238977;Returns the number of documents have been updated since this engine was opened._This count does not include the updates from the existing segments before opening engine.;long getNumDocUpdates() {_        return numDocUpdates.count()__    };returns,the,number,of,documents,have,been,updated,since,this,engine,was,opened,this,count,does,not,include,the,updates,from,the,existing,segments,before,opening,engine;long,get,num,doc,updates,return,num,doc,updates,count
InternalEngine -> long getNumDocUpdates();1541335413;Returns the number of documents have been updated since this engine was opened._This count does not include the updates from the existing segments before opening engine.;long getNumDocUpdates() {_        return numDocUpdates.count()__    };returns,the,number,of,documents,have,been,updated,since,this,engine,was,opened,this,count,does,not,include,the,updates,from,the,existing,segments,before,opening,engine;long,get,num,doc,updates,return,num,doc,updates,count
InternalEngine -> long getNumDocUpdates();1541622390;Returns the number of documents have been updated since this engine was opened._This count does not include the updates from the existing segments before opening engine.;long getNumDocUpdates() {_        return numDocUpdates.count()__    };returns,the,number,of,documents,have,been,updated,since,this,engine,was,opened,this,count,does,not,include,the,updates,from,the,existing,segments,before,opening,engine;long,get,num,doc,updates,return,num,doc,updates,count
InternalEngine -> long getNumDocUpdates();1542697754;Returns the number of documents have been updated since this engine was opened._This count does not include the updates from the existing segments before opening engine.;long getNumDocUpdates() {_        return numDocUpdates.count()__    };returns,the,number,of,documents,have,been,updated,since,this,engine,was,opened,this,count,does,not,include,the,updates,from,the,existing,segments,before,opening,engine;long,get,num,doc,updates,return,num,doc,updates,count
InternalEngine -> long getNumDocUpdates();1543940134;Returns the number of documents have been updated since this engine was opened._This count does not include the updates from the existing segments before opening engine.;long getNumDocUpdates() {_        return numDocUpdates.count()__    };returns,the,number,of,documents,have,been,updated,since,this,engine,was,opened,this,count,does,not,include,the,updates,from,the,existing,segments,before,opening,engine;long,get,num,doc,updates,return,num,doc,updates,count
InternalEngine -> long getNumDocUpdates();1544322276;Returns the number of documents have been updated since this engine was opened._This count does not include the updates from the existing segments before opening engine.;long getNumDocUpdates() {_        return numDocUpdates.count()__    };returns,the,number,of,documents,have,been,updated,since,this,engine,was,opened,this,count,does,not,include,the,updates,from,the,existing,segments,before,opening,engine;long,get,num,doc,updates,return,num,doc,updates,count
InternalEngine -> long getNumDocUpdates();1544545090;Returns the number of documents have been updated since this engine was opened._This count does not include the updates from the existing segments before opening engine.;long getNumDocUpdates() {_        return numDocUpdates.count()__    };returns,the,number,of,documents,have,been,updated,since,this,engine,was,opened,this,count,does,not,include,the,updates,from,the,existing,segments,before,opening,engine;long,get,num,doc,updates,return,num,doc,updates,count
InternalEngine -> long getNumDocUpdates();1544684920;Returns the number of documents have been updated since this engine was opened._This count does not include the updates from the existing segments before opening engine.;long getNumDocUpdates() {_        return numDocUpdates.count()__    };returns,the,number,of,documents,have,been,updated,since,this,engine,was,opened,this,count,does,not,include,the,updates,from,the,existing,segments,before,opening,engine;long,get,num,doc,updates,return,num,doc,updates,count
InternalEngine -> long getNumDocUpdates();1545140118;Returns the number of documents have been updated since this engine was opened._This count does not include the updates from the existing segments before opening engine.;long getNumDocUpdates() {_        return numDocUpdates.count()__    };returns,the,number,of,documents,have,been,updated,since,this,engine,was,opened,this,count,does,not,include,the,updates,from,the,existing,segments,before,opening,engine;long,get,num,doc,updates,return,num,doc,updates,count
InternalEngine -> long getNumDocUpdates();1546875837;Returns the number of documents have been updated since this engine was opened._This count does not include the updates from the existing segments before opening engine.;long getNumDocUpdates() {_        return numDocUpdates.count()__    };returns,the,number,of,documents,have,been,updated,since,this,engine,was,opened,this,count,does,not,include,the,updates,from,the,existing,segments,before,opening,engine;long,get,num,doc,updates,return,num,doc,updates,count
InternalEngine -> long getNumDocUpdates();1547332999;Returns the number of documents have been updated since this engine was opened._This count does not include the updates from the existing segments before opening engine.;long getNumDocUpdates() {_        return numDocUpdates.count()__    };returns,the,number,of,documents,have,been,updated,since,this,engine,was,opened,this,count,does,not,include,the,updates,from,the,existing,segments,before,opening,engine;long,get,num,doc,updates,return,num,doc,updates,count
InternalEngine -> long getNumDocUpdates();1548771485;Returns the number of documents have been updated since this engine was opened._This count does not include the updates from the existing segments before opening engine.;long getNumDocUpdates() {_        return numDocUpdates.count()__    };returns,the,number,of,documents,have,been,updated,since,this,engine,was,opened,this,count,does,not,include,the,updates,from,the,existing,segments,before,opening,engine;long,get,num,doc,updates,return,num,doc,updates,count
InternalEngine -> long getNumDocUpdates();1549059559;Returns the number of documents have been updated since this engine was opened._This count does not include the updates from the existing segments before opening engine.;long getNumDocUpdates() {_        return numDocUpdates.count()__    };returns,the,number,of,documents,have,been,updated,since,this,engine,was,opened,this,count,does,not,include,the,updates,from,the,existing,segments,before,opening,engine;long,get,num,doc,updates,return,num,doc,updates,count
InternalEngine -> long getNumDocUpdates();1549663373;Returns the number of documents have been updated since this engine was opened._This count does not include the updates from the existing segments before opening engine.;long getNumDocUpdates() {_        return numDocUpdates.count()__    };returns,the,number,of,documents,have,been,updated,since,this,engine,was,opened,this,count,does,not,include,the,updates,from,the,existing,segments,before,opening,engine;long,get,num,doc,updates,return,num,doc,updates,count
InternalEngine -> long getNumDocUpdates();1549975032;Returns the number of documents have been updated since this engine was opened._This count does not include the updates from the existing segments before opening engine.;long getNumDocUpdates() {_        return numDocUpdates.count()__    };returns,the,number,of,documents,have,been,updated,since,this,engine,was,opened,this,count,does,not,include,the,updates,from,the,existing,segments,before,opening,engine;long,get,num,doc,updates,return,num,doc,updates,count
InternalEngine -> long getNumDocUpdates();1550220204;Returns the number of documents have been updated since this engine was opened._This count does not include the updates from the existing segments before opening engine.;long getNumDocUpdates() {_        return numDocUpdates.count()__    };returns,the,number,of,documents,have,been,updated,since,this,engine,was,opened,this,count,does,not,include,the,updates,from,the,existing,segments,before,opening,engine;long,get,num,doc,updates,return,num,doc,updates,count
InternalEngine -> long getNumDocUpdates();1550256122;Returns the number of documents have been updated since this engine was opened._This count does not include the updates from the existing segments before opening engine.;long getNumDocUpdates() {_        return numDocUpdates.count()__    };returns,the,number,of,documents,have,been,updated,since,this,engine,was,opened,this,count,does,not,include,the,updates,from,the,existing,segments,before,opening,engine;long,get,num,doc,updates,return,num,doc,updates,count
InternalEngine -> long getNumDocUpdates();1550342051;Returns the number of documents have been updated since this engine was opened._This count does not include the updates from the existing segments before opening engine.;long getNumDocUpdates() {_        return numDocUpdates.count()__    };returns,the,number,of,documents,have,been,updated,since,this,engine,was,opened,this,count,does,not,include,the,updates,from,the,existing,segments,before,opening,engine;long,get,num,doc,updates,return,num,doc,updates,count
InternalEngine -> long getNumDocUpdates();1550526771;Returns the number of documents have been updated since this engine was opened._This count does not include the updates from the existing segments before opening engine.;long getNumDocUpdates() {_        return numDocUpdates.count()__    };returns,the,number,of,documents,have,been,updated,since,this,engine,was,opened,this,count,does,not,include,the,updates,from,the,existing,segments,before,opening,engine;long,get,num,doc,updates,return,num,doc,updates,count
InternalEngine -> long getNumDocUpdates();1551110274;Returns the number of documents have been updated since this engine was opened._This count does not include the updates from the existing segments before opening engine.;long getNumDocUpdates() {_        return numDocUpdates.count()__    };returns,the,number,of,documents,have,been,updated,since,this,engine,was,opened,this,count,does,not,include,the,updates,from,the,existing,segments,before,opening,engine;long,get,num,doc,updates,return,num,doc,updates,count
InternalEngine -> long getNumDocUpdates();1551126708;Returns the number of documents have been updated since this engine was opened._This count does not include the updates from the existing segments before opening engine.;long getNumDocUpdates() {_        return numDocUpdates.count()__    };returns,the,number,of,documents,have,been,updated,since,this,engine,was,opened,this,count,does,not,include,the,updates,from,the,existing,segments,before,opening,engine;long,get,num,doc,updates,return,num,doc,updates,count
InternalEngine -> protected final boolean hasBeenProcessedBefore(Operation op);1538424609;Checks if the given operation has been processed in this engine or not._@return true if the given operation was processed_ otherwise false.;protected final boolean hasBeenProcessedBefore(Operation op) {_        assert op.seqNo() != SequenceNumbers.UNASSIGNED_SEQ_NO : "operation is not assigned seq_no"__        assert versionMap.assertKeyedLockHeldByCurrentThread(op.uid().bytes())__        return localCheckpointTracker.contains(op.seqNo())__    };checks,if,the,given,operation,has,been,processed,in,this,engine,or,not,return,true,if,the,given,operation,was,processed,otherwise,false;protected,final,boolean,has,been,processed,before,operation,op,assert,op,seq,no,sequence,numbers,operation,is,not,assigned,assert,version,map,assert,keyed,lock,held,by,current,thread,op,uid,bytes,return,local,checkpoint,tracker,contains,op,seq,no
InternalEngine -> protected final boolean hasBeenProcessedBefore(Operation op);1539615817;Checks if the given operation has been processed in this engine or not._@return true if the given operation was processed_ otherwise false.;protected final boolean hasBeenProcessedBefore(Operation op) {_        assert op.seqNo() != SequenceNumbers.UNASSIGNED_SEQ_NO : "operation is not assigned seq_no"__        assert versionMap.assertKeyedLockHeldByCurrentThread(op.uid().bytes())__        return localCheckpointTracker.contains(op.seqNo())__    };checks,if,the,given,operation,has,been,processed,in,this,engine,or,not,return,true,if,the,given,operation,was,processed,otherwise,false;protected,final,boolean,has,been,processed,before,operation,op,assert,op,seq,no,sequence,numbers,operation,is,not,assigned,assert,version,map,assert,keyed,lock,held,by,current,thread,op,uid,bytes,return,local,checkpoint,tracker,contains,op,seq,no
InternalEngine -> protected final boolean hasBeenProcessedBefore(Operation op);1539723533;Checks if the given operation has been processed in this engine or not._@return true if the given operation was processed_ otherwise false.;protected final boolean hasBeenProcessedBefore(Operation op) {_        assert op.seqNo() != SequenceNumbers.UNASSIGNED_SEQ_NO : "operation is not assigned seq_no"__        assert versionMap.assertKeyedLockHeldByCurrentThread(op.uid().bytes())__        return localCheckpointTracker.contains(op.seqNo())__    };checks,if,the,given,operation,has,been,processed,in,this,engine,or,not,return,true,if,the,given,operation,was,processed,otherwise,false;protected,final,boolean,has,been,processed,before,operation,op,assert,op,seq,no,sequence,numbers,operation,is,not,assigned,assert,version,map,assert,keyed,lock,held,by,current,thread,op,uid,bytes,return,local,checkpoint,tracker,contains,op,seq,no
InternalEngine -> protected final boolean hasBeenProcessedBefore(Operation op);1540238977;Checks if the given operation has been processed in this engine or not._@return true if the given operation was processed_ otherwise false.;protected final boolean hasBeenProcessedBefore(Operation op) {_        if (Assertions.ENABLED) {_            assert op.seqNo() != SequenceNumbers.UNASSIGNED_SEQ_NO : "operation is not assigned seq_no"__            if (op.operationType() == Operation.TYPE.NO_OP) {_                assert noOpKeyedLock.isHeldByCurrentThread(op.seqNo())__            } else {_                assert versionMap.assertKeyedLockHeldByCurrentThread(op.uid().bytes())__            }_        }_        return localCheckpointTracker.contains(op.seqNo())__    };checks,if,the,given,operation,has,been,processed,in,this,engine,or,not,return,true,if,the,given,operation,was,processed,otherwise,false;protected,final,boolean,has,been,processed,before,operation,op,if,assertions,enabled,assert,op,seq,no,sequence,numbers,operation,is,not,assigned,if,op,operation,type,operation,type,assert,no,op,keyed,lock,is,held,by,current,thread,op,seq,no,else,assert,version,map,assert,keyed,lock,held,by,current,thread,op,uid,bytes,return,local,checkpoint,tracker,contains,op,seq,no
InternalEngine -> protected final boolean hasBeenProcessedBefore(Operation op);1541335413;Checks if the given operation has been processed in this engine or not._@return true if the given operation was processed_ otherwise false.;protected final boolean hasBeenProcessedBefore(Operation op) {_        if (Assertions.ENABLED) {_            assert op.seqNo() != SequenceNumbers.UNASSIGNED_SEQ_NO : "operation is not assigned seq_no"__            if (op.operationType() == Operation.TYPE.NO_OP) {_                assert noOpKeyedLock.isHeldByCurrentThread(op.seqNo())__            } else {_                assert versionMap.assertKeyedLockHeldByCurrentThread(op.uid().bytes())__            }_        }_        return localCheckpointTracker.contains(op.seqNo())__    };checks,if,the,given,operation,has,been,processed,in,this,engine,or,not,return,true,if,the,given,operation,was,processed,otherwise,false;protected,final,boolean,has,been,processed,before,operation,op,if,assertions,enabled,assert,op,seq,no,sequence,numbers,operation,is,not,assigned,if,op,operation,type,operation,type,assert,no,op,keyed,lock,is,held,by,current,thread,op,seq,no,else,assert,version,map,assert,keyed,lock,held,by,current,thread,op,uid,bytes,return,local,checkpoint,tracker,contains,op,seq,no
InternalEngine -> protected final boolean hasBeenProcessedBefore(Operation op);1541622390;Checks if the given operation has been processed in this engine or not._@return true if the given operation was processed_ otherwise false.;protected final boolean hasBeenProcessedBefore(Operation op) {_        if (Assertions.ENABLED) {_            assert op.seqNo() != SequenceNumbers.UNASSIGNED_SEQ_NO : "operation is not assigned seq_no"__            if (op.operationType() == Operation.TYPE.NO_OP) {_                assert noOpKeyedLock.isHeldByCurrentThread(op.seqNo())__            } else {_                assert versionMap.assertKeyedLockHeldByCurrentThread(op.uid().bytes())__            }_        }_        return localCheckpointTracker.contains(op.seqNo())__    };checks,if,the,given,operation,has,been,processed,in,this,engine,or,not,return,true,if,the,given,operation,was,processed,otherwise,false;protected,final,boolean,has,been,processed,before,operation,op,if,assertions,enabled,assert,op,seq,no,sequence,numbers,operation,is,not,assigned,if,op,operation,type,operation,type,assert,no,op,keyed,lock,is,held,by,current,thread,op,seq,no,else,assert,version,map,assert,keyed,lock,held,by,current,thread,op,uid,bytes,return,local,checkpoint,tracker,contains,op,seq,no
InternalEngine -> protected final boolean hasBeenProcessedBefore(Operation op);1542697754;Checks if the given operation has been processed in this engine or not._@return true if the given operation was processed_ otherwise false.;protected final boolean hasBeenProcessedBefore(Operation op) {_        if (Assertions.ENABLED) {_            assert op.seqNo() != SequenceNumbers.UNASSIGNED_SEQ_NO : "operation is not assigned seq_no"__            if (op.operationType() == Operation.TYPE.NO_OP) {_                assert noOpKeyedLock.isHeldByCurrentThread(op.seqNo())__            } else {_                assert versionMap.assertKeyedLockHeldByCurrentThread(op.uid().bytes())__            }_        }_        return localCheckpointTracker.contains(op.seqNo())__    };checks,if,the,given,operation,has,been,processed,in,this,engine,or,not,return,true,if,the,given,operation,was,processed,otherwise,false;protected,final,boolean,has,been,processed,before,operation,op,if,assertions,enabled,assert,op,seq,no,sequence,numbers,operation,is,not,assigned,if,op,operation,type,operation,type,assert,no,op,keyed,lock,is,held,by,current,thread,op,seq,no,else,assert,version,map,assert,keyed,lock,held,by,current,thread,op,uid,bytes,return,local,checkpoint,tracker,contains,op,seq,no
InternalEngine -> protected final boolean hasBeenProcessedBefore(Operation op);1543940134;Checks if the given operation has been processed in this engine or not._@return true if the given operation was processed_ otherwise false.;protected final boolean hasBeenProcessedBefore(Operation op) {_        if (Assertions.ENABLED) {_            assert op.seqNo() != SequenceNumbers.UNASSIGNED_SEQ_NO : "operation is not assigned seq_no"__            if (op.operationType() == Operation.TYPE.NO_OP) {_                assert noOpKeyedLock.isHeldByCurrentThread(op.seqNo())__            } else {_                assert versionMap.assertKeyedLockHeldByCurrentThread(op.uid().bytes())__            }_        }_        return localCheckpointTracker.contains(op.seqNo())__    };checks,if,the,given,operation,has,been,processed,in,this,engine,or,not,return,true,if,the,given,operation,was,processed,otherwise,false;protected,final,boolean,has,been,processed,before,operation,op,if,assertions,enabled,assert,op,seq,no,sequence,numbers,operation,is,not,assigned,if,op,operation,type,operation,type,assert,no,op,keyed,lock,is,held,by,current,thread,op,seq,no,else,assert,version,map,assert,keyed,lock,held,by,current,thread,op,uid,bytes,return,local,checkpoint,tracker,contains,op,seq,no
InternalEngine -> protected final boolean hasBeenProcessedBefore(Operation op);1544322276;Checks if the given operation has been processed in this engine or not._@return true if the given operation was processed_ otherwise false.;protected final boolean hasBeenProcessedBefore(Operation op) {_        if (Assertions.ENABLED) {_            assert op.seqNo() != SequenceNumbers.UNASSIGNED_SEQ_NO : "operation is not assigned seq_no"__            if (op.operationType() == Operation.TYPE.NO_OP) {_                assert noOpKeyedLock.isHeldByCurrentThread(op.seqNo())__            } else {_                assert versionMap.assertKeyedLockHeldByCurrentThread(op.uid().bytes())__            }_        }_        return localCheckpointTracker.contains(op.seqNo())__    };checks,if,the,given,operation,has,been,processed,in,this,engine,or,not,return,true,if,the,given,operation,was,processed,otherwise,false;protected,final,boolean,has,been,processed,before,operation,op,if,assertions,enabled,assert,op,seq,no,sequence,numbers,operation,is,not,assigned,if,op,operation,type,operation,type,assert,no,op,keyed,lock,is,held,by,current,thread,op,seq,no,else,assert,version,map,assert,keyed,lock,held,by,current,thread,op,uid,bytes,return,local,checkpoint,tracker,contains,op,seq,no
InternalEngine -> protected final boolean hasBeenProcessedBefore(Operation op);1544545090;Checks if the given operation has been processed in this engine or not._@return true if the given operation was processed_ otherwise false.;protected final boolean hasBeenProcessedBefore(Operation op) {_        if (Assertions.ENABLED) {_            assert op.seqNo() != SequenceNumbers.UNASSIGNED_SEQ_NO : "operation is not assigned seq_no"__            if (op.operationType() == Operation.TYPE.NO_OP) {_                assert noOpKeyedLock.isHeldByCurrentThread(op.seqNo())__            } else {_                assert versionMap.assertKeyedLockHeldByCurrentThread(op.uid().bytes())__            }_        }_        return localCheckpointTracker.contains(op.seqNo())__    };checks,if,the,given,operation,has,been,processed,in,this,engine,or,not,return,true,if,the,given,operation,was,processed,otherwise,false;protected,final,boolean,has,been,processed,before,operation,op,if,assertions,enabled,assert,op,seq,no,sequence,numbers,operation,is,not,assigned,if,op,operation,type,operation,type,assert,no,op,keyed,lock,is,held,by,current,thread,op,seq,no,else,assert,version,map,assert,keyed,lock,held,by,current,thread,op,uid,bytes,return,local,checkpoint,tracker,contains,op,seq,no
InternalEngine -> protected final boolean hasBeenProcessedBefore(Operation op);1544684920;Checks if the given operation has been processed in this engine or not._@return true if the given operation was processed_ otherwise false.;protected final boolean hasBeenProcessedBefore(Operation op) {_        if (Assertions.ENABLED) {_            assert op.seqNo() != SequenceNumbers.UNASSIGNED_SEQ_NO : "operation is not assigned seq_no"__            if (op.operationType() == Operation.TYPE.NO_OP) {_                assert noOpKeyedLock.isHeldByCurrentThread(op.seqNo())__            } else {_                assert versionMap.assertKeyedLockHeldByCurrentThread(op.uid().bytes())__            }_        }_        return localCheckpointTracker.contains(op.seqNo())__    };checks,if,the,given,operation,has,been,processed,in,this,engine,or,not,return,true,if,the,given,operation,was,processed,otherwise,false;protected,final,boolean,has,been,processed,before,operation,op,if,assertions,enabled,assert,op,seq,no,sequence,numbers,operation,is,not,assigned,if,op,operation,type,operation,type,assert,no,op,keyed,lock,is,held,by,current,thread,op,seq,no,else,assert,version,map,assert,keyed,lock,held,by,current,thread,op,uid,bytes,return,local,checkpoint,tracker,contains,op,seq,no
InternalEngine -> protected final boolean hasBeenProcessedBefore(Operation op);1545140118;Checks if the given operation has been processed in this engine or not._@return true if the given operation was processed_ otherwise false.;protected final boolean hasBeenProcessedBefore(Operation op) {_        if (Assertions.ENABLED) {_            assert op.seqNo() != SequenceNumbers.UNASSIGNED_SEQ_NO : "operation is not assigned seq_no"__            if (op.operationType() == Operation.TYPE.NO_OP) {_                assert noOpKeyedLock.isHeldByCurrentThread(op.seqNo())__            } else {_                assert versionMap.assertKeyedLockHeldByCurrentThread(op.uid().bytes())__            }_        }_        return localCheckpointTracker.contains(op.seqNo())__    };checks,if,the,given,operation,has,been,processed,in,this,engine,or,not,return,true,if,the,given,operation,was,processed,otherwise,false;protected,final,boolean,has,been,processed,before,operation,op,if,assertions,enabled,assert,op,seq,no,sequence,numbers,operation,is,not,assigned,if,op,operation,type,operation,type,assert,no,op,keyed,lock,is,held,by,current,thread,op,seq,no,else,assert,version,map,assert,keyed,lock,held,by,current,thread,op,uid,bytes,return,local,checkpoint,tracker,contains,op,seq,no
InternalEngine -> protected final boolean hasBeenProcessedBefore(Operation op);1546875837;Checks if the given operation has been processed in this engine or not._@return true if the given operation was processed_ otherwise false.;protected final boolean hasBeenProcessedBefore(Operation op) {_        if (Assertions.ENABLED) {_            assert op.seqNo() != SequenceNumbers.UNASSIGNED_SEQ_NO : "operation is not assigned seq_no"__            if (op.operationType() == Operation.TYPE.NO_OP) {_                assert noOpKeyedLock.isHeldByCurrentThread(op.seqNo())__            } else {_                assert versionMap.assertKeyedLockHeldByCurrentThread(op.uid().bytes())__            }_        }_        return localCheckpointTracker.contains(op.seqNo())__    };checks,if,the,given,operation,has,been,processed,in,this,engine,or,not,return,true,if,the,given,operation,was,processed,otherwise,false;protected,final,boolean,has,been,processed,before,operation,op,if,assertions,enabled,assert,op,seq,no,sequence,numbers,operation,is,not,assigned,if,op,operation,type,operation,type,assert,no,op,keyed,lock,is,held,by,current,thread,op,seq,no,else,assert,version,map,assert,keyed,lock,held,by,current,thread,op,uid,bytes,return,local,checkpoint,tracker,contains,op,seq,no
InternalEngine -> protected final boolean hasBeenProcessedBefore(Operation op);1547332999;Checks if the given operation has been processed in this engine or not._@return true if the given operation was processed_ otherwise false.;protected final boolean hasBeenProcessedBefore(Operation op) {_        if (Assertions.ENABLED) {_            assert op.seqNo() != SequenceNumbers.UNASSIGNED_SEQ_NO : "operation is not assigned seq_no"__            if (op.operationType() == Operation.TYPE.NO_OP) {_                assert noOpKeyedLock.isHeldByCurrentThread(op.seqNo())__            } else {_                assert versionMap.assertKeyedLockHeldByCurrentThread(op.uid().bytes())__            }_        }_        return localCheckpointTracker.contains(op.seqNo())__    };checks,if,the,given,operation,has,been,processed,in,this,engine,or,not,return,true,if,the,given,operation,was,processed,otherwise,false;protected,final,boolean,has,been,processed,before,operation,op,if,assertions,enabled,assert,op,seq,no,sequence,numbers,operation,is,not,assigned,if,op,operation,type,operation,type,assert,no,op,keyed,lock,is,held,by,current,thread,op,seq,no,else,assert,version,map,assert,keyed,lock,held,by,current,thread,op,uid,bytes,return,local,checkpoint,tracker,contains,op,seq,no
InternalEngine -> protected final boolean hasBeenProcessedBefore(Operation op);1548771485;Checks if the given operation has been processed in this engine or not._@return true if the given operation was processed_ otherwise false.;protected final boolean hasBeenProcessedBefore(Operation op) {_        if (Assertions.ENABLED) {_            assert op.seqNo() != SequenceNumbers.UNASSIGNED_SEQ_NO : "operation is not assigned seq_no"__            if (op.operationType() == Operation.TYPE.NO_OP) {_                assert noOpKeyedLock.isHeldByCurrentThread(op.seqNo())__            } else {_                assert versionMap.assertKeyedLockHeldByCurrentThread(op.uid().bytes())__            }_        }_        return localCheckpointTracker.contains(op.seqNo())__    };checks,if,the,given,operation,has,been,processed,in,this,engine,or,not,return,true,if,the,given,operation,was,processed,otherwise,false;protected,final,boolean,has,been,processed,before,operation,op,if,assertions,enabled,assert,op,seq,no,sequence,numbers,operation,is,not,assigned,if,op,operation,type,operation,type,assert,no,op,keyed,lock,is,held,by,current,thread,op,seq,no,else,assert,version,map,assert,keyed,lock,held,by,current,thread,op,uid,bytes,return,local,checkpoint,tracker,contains,op,seq,no
InternalEngine -> protected final boolean hasBeenProcessedBefore(Operation op);1549059559;Checks if the given operation has been processed in this engine or not._@return true if the given operation was processed_ otherwise false.;protected final boolean hasBeenProcessedBefore(Operation op) {_        if (Assertions.ENABLED) {_            assert op.seqNo() != SequenceNumbers.UNASSIGNED_SEQ_NO : "operation is not assigned seq_no"__            if (op.operationType() == Operation.TYPE.NO_OP) {_                assert noOpKeyedLock.isHeldByCurrentThread(op.seqNo())__            } else {_                assert versionMap.assertKeyedLockHeldByCurrentThread(op.uid().bytes())__            }_        }_        return localCheckpointTracker.contains(op.seqNo())__    };checks,if,the,given,operation,has,been,processed,in,this,engine,or,not,return,true,if,the,given,operation,was,processed,otherwise,false;protected,final,boolean,has,been,processed,before,operation,op,if,assertions,enabled,assert,op,seq,no,sequence,numbers,operation,is,not,assigned,if,op,operation,type,operation,type,assert,no,op,keyed,lock,is,held,by,current,thread,op,seq,no,else,assert,version,map,assert,keyed,lock,held,by,current,thread,op,uid,bytes,return,local,checkpoint,tracker,contains,op,seq,no
InternalEngine -> protected final boolean hasBeenProcessedBefore(Operation op);1549663373;Checks if the given operation has been processed in this engine or not._@return true if the given operation was processed_ otherwise false.;protected final boolean hasBeenProcessedBefore(Operation op) {_        if (Assertions.ENABLED) {_            assert op.seqNo() != SequenceNumbers.UNASSIGNED_SEQ_NO : "operation is not assigned seq_no"__            if (op.operationType() == Operation.TYPE.NO_OP) {_                assert noOpKeyedLock.isHeldByCurrentThread(op.seqNo())__            } else {_                assert versionMap.assertKeyedLockHeldByCurrentThread(op.uid().bytes())__            }_        }_        return localCheckpointTracker.contains(op.seqNo())__    };checks,if,the,given,operation,has,been,processed,in,this,engine,or,not,return,true,if,the,given,operation,was,processed,otherwise,false;protected,final,boolean,has,been,processed,before,operation,op,if,assertions,enabled,assert,op,seq,no,sequence,numbers,operation,is,not,assigned,if,op,operation,type,operation,type,assert,no,op,keyed,lock,is,held,by,current,thread,op,seq,no,else,assert,version,map,assert,keyed,lock,held,by,current,thread,op,uid,bytes,return,local,checkpoint,tracker,contains,op,seq,no
InternalEngine -> protected final boolean hasBeenProcessedBefore(Operation op);1549975032;Checks if the given operation has been processed in this engine or not._@return true if the given operation was processed_ otherwise false.;protected final boolean hasBeenProcessedBefore(Operation op) {_        if (Assertions.ENABLED) {_            assert op.seqNo() != SequenceNumbers.UNASSIGNED_SEQ_NO : "operation is not assigned seq_no"__            if (op.operationType() == Operation.TYPE.NO_OP) {_                assert noOpKeyedLock.isHeldByCurrentThread(op.seqNo())__            } else {_                assert versionMap.assertKeyedLockHeldByCurrentThread(op.uid().bytes())__            }_        }_        return localCheckpointTracker.contains(op.seqNo())__    };checks,if,the,given,operation,has,been,processed,in,this,engine,or,not,return,true,if,the,given,operation,was,processed,otherwise,false;protected,final,boolean,has,been,processed,before,operation,op,if,assertions,enabled,assert,op,seq,no,sequence,numbers,operation,is,not,assigned,if,op,operation,type,operation,type,assert,no,op,keyed,lock,is,held,by,current,thread,op,seq,no,else,assert,version,map,assert,keyed,lock,held,by,current,thread,op,uid,bytes,return,local,checkpoint,tracker,contains,op,seq,no
InternalEngine -> protected final boolean hasBeenProcessedBefore(Operation op);1550220204;Checks if the given operation has been processed in this engine or not._@return true if the given operation was processed_ otherwise false.;protected final boolean hasBeenProcessedBefore(Operation op) {_        if (Assertions.ENABLED) {_            assert op.seqNo() != SequenceNumbers.UNASSIGNED_SEQ_NO : "operation is not assigned seq_no"__            if (op.operationType() == Operation.TYPE.NO_OP) {_                assert noOpKeyedLock.isHeldByCurrentThread(op.seqNo())__            } else {_                assert versionMap.assertKeyedLockHeldByCurrentThread(op.uid().bytes())__            }_        }_        return localCheckpointTracker.contains(op.seqNo())__    };checks,if,the,given,operation,has,been,processed,in,this,engine,or,not,return,true,if,the,given,operation,was,processed,otherwise,false;protected,final,boolean,has,been,processed,before,operation,op,if,assertions,enabled,assert,op,seq,no,sequence,numbers,operation,is,not,assigned,if,op,operation,type,operation,type,assert,no,op,keyed,lock,is,held,by,current,thread,op,seq,no,else,assert,version,map,assert,keyed,lock,held,by,current,thread,op,uid,bytes,return,local,checkpoint,tracker,contains,op,seq,no
InternalEngine -> protected final boolean hasBeenProcessedBefore(Operation op);1550256122;Checks if the given operation has been processed in this engine or not._@return true if the given operation was processed_ otherwise false.;protected final boolean hasBeenProcessedBefore(Operation op) {_        if (Assertions.ENABLED) {_            assert op.seqNo() != SequenceNumbers.UNASSIGNED_SEQ_NO : "operation is not assigned seq_no"__            if (op.operationType() == Operation.TYPE.NO_OP) {_                assert noOpKeyedLock.isHeldByCurrentThread(op.seqNo())__            } else {_                assert versionMap.assertKeyedLockHeldByCurrentThread(op.uid().bytes())__            }_        }_        return localCheckpointTracker.contains(op.seqNo())__    };checks,if,the,given,operation,has,been,processed,in,this,engine,or,not,return,true,if,the,given,operation,was,processed,otherwise,false;protected,final,boolean,has,been,processed,before,operation,op,if,assertions,enabled,assert,op,seq,no,sequence,numbers,operation,is,not,assigned,if,op,operation,type,operation,type,assert,no,op,keyed,lock,is,held,by,current,thread,op,seq,no,else,assert,version,map,assert,keyed,lock,held,by,current,thread,op,uid,bytes,return,local,checkpoint,tracker,contains,op,seq,no
InternalEngine -> protected final boolean hasBeenProcessedBefore(Operation op);1550342051;Checks if the given operation has been processed in this engine or not._@return true if the given operation was processed_ otherwise false.;protected final boolean hasBeenProcessedBefore(Operation op) {_        if (Assertions.ENABLED) {_            assert op.seqNo() != SequenceNumbers.UNASSIGNED_SEQ_NO : "operation is not assigned seq_no"__            if (op.operationType() == Operation.TYPE.NO_OP) {_                assert noOpKeyedLock.isHeldByCurrentThread(op.seqNo())__            } else {_                assert versionMap.assertKeyedLockHeldByCurrentThread(op.uid().bytes())__            }_        }_        return localCheckpointTracker.contains(op.seqNo())__    };checks,if,the,given,operation,has,been,processed,in,this,engine,or,not,return,true,if,the,given,operation,was,processed,otherwise,false;protected,final,boolean,has,been,processed,before,operation,op,if,assertions,enabled,assert,op,seq,no,sequence,numbers,operation,is,not,assigned,if,op,operation,type,operation,type,assert,no,op,keyed,lock,is,held,by,current,thread,op,seq,no,else,assert,version,map,assert,keyed,lock,held,by,current,thread,op,uid,bytes,return,local,checkpoint,tracker,contains,op,seq,no
InternalEngine -> protected final boolean hasBeenProcessedBefore(Operation op);1550526771;Checks if the given operation has been processed in this engine or not._@return true if the given operation was processed_ otherwise false.;protected final boolean hasBeenProcessedBefore(Operation op) {_        if (Assertions.ENABLED) {_            assert op.seqNo() != SequenceNumbers.UNASSIGNED_SEQ_NO : "operation is not assigned seq_no"__            if (op.operationType() == Operation.TYPE.NO_OP) {_                assert noOpKeyedLock.isHeldByCurrentThread(op.seqNo())__            } else {_                assert versionMap.assertKeyedLockHeldByCurrentThread(op.uid().bytes())__            }_        }_        return localCheckpointTracker.contains(op.seqNo())__    };checks,if,the,given,operation,has,been,processed,in,this,engine,or,not,return,true,if,the,given,operation,was,processed,otherwise,false;protected,final,boolean,has,been,processed,before,operation,op,if,assertions,enabled,assert,op,seq,no,sequence,numbers,operation,is,not,assigned,if,op,operation,type,operation,type,assert,no,op,keyed,lock,is,held,by,current,thread,op,seq,no,else,assert,version,map,assert,keyed,lock,held,by,current,thread,op,uid,bytes,return,local,checkpoint,tracker,contains,op,seq,no
InternalEngine -> protected final boolean hasBeenProcessedBefore(Operation op);1551110274;Checks if the given operation has been processed in this engine or not._@return true if the given operation was processed_ otherwise false.;protected final boolean hasBeenProcessedBefore(Operation op) {_        if (Assertions.ENABLED) {_            assert op.seqNo() != SequenceNumbers.UNASSIGNED_SEQ_NO : "operation is not assigned seq_no"__            if (op.operationType() == Operation.TYPE.NO_OP) {_                assert noOpKeyedLock.isHeldByCurrentThread(op.seqNo())__            } else {_                assert versionMap.assertKeyedLockHeldByCurrentThread(op.uid().bytes())__            }_        }_        return localCheckpointTracker.contains(op.seqNo())__    };checks,if,the,given,operation,has,been,processed,in,this,engine,or,not,return,true,if,the,given,operation,was,processed,otherwise,false;protected,final,boolean,has,been,processed,before,operation,op,if,assertions,enabled,assert,op,seq,no,sequence,numbers,operation,is,not,assigned,if,op,operation,type,operation,type,assert,no,op,keyed,lock,is,held,by,current,thread,op,seq,no,else,assert,version,map,assert,keyed,lock,held,by,current,thread,op,uid,bytes,return,local,checkpoint,tracker,contains,op,seq,no
InternalEngine -> protected final boolean hasBeenProcessedBefore(Operation op);1551126708;Checks if the given operation has been processed in this engine or not._@return true if the given operation was processed_ otherwise false.;protected final boolean hasBeenProcessedBefore(Operation op) {_        if (Assertions.ENABLED) {_            assert op.seqNo() != SequenceNumbers.UNASSIGNED_SEQ_NO : "operation is not assigned seq_no"__            if (op.operationType() == Operation.TYPE.NO_OP) {_                assert noOpKeyedLock.isHeldByCurrentThread(op.seqNo())__            } else {_                assert versionMap.assertKeyedLockHeldByCurrentThread(op.uid().bytes())__            }_        }_        return localCheckpointTracker.contains(op.seqNo())__    };checks,if,the,given,operation,has,been,processed,in,this,engine,or,not,return,true,if,the,given,operation,was,processed,otherwise,false;protected,final,boolean,has,been,processed,before,operation,op,if,assertions,enabled,assert,op,seq,no,sequence,numbers,operation,is,not,assigned,if,op,operation,type,operation,type,assert,no,op,keyed,lock,is,held,by,current,thread,op,seq,no,else,assert,version,map,assert,keyed,lock,held,by,current,thread,op,uid,bytes,return,local,checkpoint,tracker,contains,op,seq,no
InternalEngine -> long getNumDocAppends();1524684173;Returns the number of documents have been appended since this engine was opened._This count does not include the appends from the existing segments before opening engine.;long getNumDocAppends() {_        return numDocAppends.count()__    };returns,the,number,of,documents,have,been,appended,since,this,engine,was,opened,this,count,does,not,include,the,appends,from,the,existing,segments,before,opening,engine;long,get,num,doc,appends,return,num,doc,appends,count
InternalEngine -> long getNumDocAppends();1524780945;Returns the number of documents have been appended since this engine was opened._This count does not include the appends from the existing segments before opening engine.;long getNumDocAppends() {_        return numDocAppends.count()__    };returns,the,number,of,documents,have,been,appended,since,this,engine,was,opened,this,count,does,not,include,the,appends,from,the,existing,segments,before,opening,engine;long,get,num,doc,appends,return,num,doc,appends,count
InternalEngine -> long getNumDocAppends();1525162917;Returns the number of documents have been appended since this engine was opened._This count does not include the appends from the existing segments before opening engine.;long getNumDocAppends() {_        return numDocAppends.count()__    };returns,the,number,of,documents,have,been,appended,since,this,engine,was,opened,this,count,does,not,include,the,appends,from,the,existing,segments,before,opening,engine;long,get,num,doc,appends,return,num,doc,appends,count
InternalEngine -> long getNumDocAppends();1528706846;Returns the number of documents have been appended since this engine was opened._This count does not include the appends from the existing segments before opening engine.;long getNumDocAppends() {_        return numDocAppends.count()__    };returns,the,number,of,documents,have,been,appended,since,this,engine,was,opened,this,count,does,not,include,the,appends,from,the,existing,segments,before,opening,engine;long,get,num,doc,appends,return,num,doc,appends,count
InternalEngine -> long getNumDocAppends();1528762805;Returns the number of documents have been appended since this engine was opened._This count does not include the appends from the existing segments before opening engine.;long getNumDocAppends() {_        return numDocAppends.count()__    };returns,the,number,of,documents,have,been,appended,since,this,engine,was,opened,this,count,does,not,include,the,appends,from,the,existing,segments,before,opening,engine;long,get,num,doc,appends,return,num,doc,appends,count
InternalEngine -> long getNumDocAppends();1531910483;Returns the number of documents have been appended since this engine was opened._This count does not include the appends from the existing segments before opening engine.;long getNumDocAppends() {_        return numDocAppends.count()__    };returns,the,number,of,documents,have,been,appended,since,this,engine,was,opened,this,count,does,not,include,the,appends,from,the,existing,segments,before,opening,engine;long,get,num,doc,appends,return,num,doc,appends,count
InternalEngine -> long getNumDocAppends();1533295538;Returns the number of documents have been appended since this engine was opened._This count does not include the appends from the existing segments before opening engine.;long getNumDocAppends() {_        return numDocAppends.count()__    };returns,the,number,of,documents,have,been,appended,since,this,engine,was,opened,this,count,does,not,include,the,appends,from,the,existing,segments,before,opening,engine;long,get,num,doc,appends,return,num,doc,appends,count
InternalEngine -> long getNumDocAppends();1534848846;Returns the number of documents have been appended since this engine was opened._This count does not include the appends from the existing segments before opening engine.;long getNumDocAppends() {_        return numDocAppends.count()__    };returns,the,number,of,documents,have,been,appended,since,this,engine,was,opened,this,count,does,not,include,the,appends,from,the,existing,segments,before,opening,engine;long,get,num,doc,appends,return,num,doc,appends,count
InternalEngine -> long getNumDocAppends();1535046779;Returns the number of documents have been appended since this engine was opened._This count does not include the appends from the existing segments before opening engine.;long getNumDocAppends() {_        return numDocAppends.count()__    };returns,the,number,of,documents,have,been,appended,since,this,engine,was,opened,this,count,does,not,include,the,appends,from,the,existing,segments,before,opening,engine;long,get,num,doc,appends,return,num,doc,appends,count
InternalEngine -> long getNumDocAppends();1535405719;Returns the number of documents have been appended since this engine was opened._This count does not include the appends from the existing segments before opening engine.;long getNumDocAppends() {_        return numDocAppends.count()__    };returns,the,number,of,documents,have,been,appended,since,this,engine,was,opened,this,count,does,not,include,the,appends,from,the,existing,segments,before,opening,engine;long,get,num,doc,appends,return,num,doc,appends,count
InternalEngine -> long getNumDocAppends();1535723122;Returns the number of documents have been appended since this engine was opened._This count does not include the appends from the existing segments before opening engine.;long getNumDocAppends() {_        return numDocAppends.count()__    };returns,the,number,of,documents,have,been,appended,since,this,engine,was,opened,this,count,does,not,include,the,appends,from,the,existing,segments,before,opening,engine;long,get,num,doc,appends,return,num,doc,appends,count
InternalEngine -> long getNumDocAppends();1535965276;Returns the number of documents have been appended since this engine was opened._This count does not include the appends from the existing segments before opening engine.;long getNumDocAppends() {_        return numDocAppends.count()__    };returns,the,number,of,documents,have,been,appended,since,this,engine,was,opened,this,count,does,not,include,the,appends,from,the,existing,segments,before,opening,engine;long,get,num,doc,appends,return,num,doc,appends,count
InternalEngine -> long getNumDocAppends();1536218260;Returns the number of documents have been appended since this engine was opened._This count does not include the appends from the existing segments before opening engine.;long getNumDocAppends() {_        return numDocAppends.count()__    };returns,the,number,of,documents,have,been,appended,since,this,engine,was,opened,this,count,does,not,include,the,appends,from,the,existing,segments,before,opening,engine;long,get,num,doc,appends,return,num,doc,appends,count
InternalEngine -> long getNumDocAppends();1536314350;Returns the number of documents have been appended since this engine was opened._This count does not include the appends from the existing segments before opening engine.;long getNumDocAppends() {_        return numDocAppends.count()__    };returns,the,number,of,documents,have,been,appended,since,this,engine,was,opened,this,count,does,not,include,the,appends,from,the,existing,segments,before,opening,engine;long,get,num,doc,appends,return,num,doc,appends,count
InternalEngine -> long getNumDocAppends();1536828374;Returns the number of documents have been appended since this engine was opened._This count does not include the appends from the existing segments before opening engine.;long getNumDocAppends() {_        return numDocAppends.count()__    };returns,the,number,of,documents,have,been,appended,since,this,engine,was,opened,this,count,does,not,include,the,appends,from,the,existing,segments,before,opening,engine;long,get,num,doc,appends,return,num,doc,appends,count
InternalEngine -> long getNumDocAppends();1537806831;Returns the number of documents have been appended since this engine was opened._This count does not include the appends from the existing segments before opening engine.;long getNumDocAppends() {_        return numDocAppends.count()__    };returns,the,number,of,documents,have,been,appended,since,this,engine,was,opened,this,count,does,not,include,the,appends,from,the,existing,segments,before,opening,engine;long,get,num,doc,appends,return,num,doc,appends,count
InternalEngine -> long getNumDocAppends();1538067637;Returns the number of documents have been appended since this engine was opened._This count does not include the appends from the existing segments before opening engine.;long getNumDocAppends() {_        return numDocAppends.count()__    };returns,the,number,of,documents,have,been,appended,since,this,engine,was,opened,this,count,does,not,include,the,appends,from,the,existing,segments,before,opening,engine;long,get,num,doc,appends,return,num,doc,appends,count
InternalEngine -> long getNumDocAppends();1538424609;Returns the number of documents have been appended since this engine was opened._This count does not include the appends from the existing segments before opening engine.;long getNumDocAppends() {_        return numDocAppends.count()__    };returns,the,number,of,documents,have,been,appended,since,this,engine,was,opened,this,count,does,not,include,the,appends,from,the,existing,segments,before,opening,engine;long,get,num,doc,appends,return,num,doc,appends,count
InternalEngine -> long getNumDocAppends();1539615817;Returns the number of documents have been appended since this engine was opened._This count does not include the appends from the existing segments before opening engine.;long getNumDocAppends() {_        return numDocAppends.count()__    };returns,the,number,of,documents,have,been,appended,since,this,engine,was,opened,this,count,does,not,include,the,appends,from,the,existing,segments,before,opening,engine;long,get,num,doc,appends,return,num,doc,appends,count
InternalEngine -> long getNumDocAppends();1539723533;Returns the number of documents have been appended since this engine was opened._This count does not include the appends from the existing segments before opening engine.;long getNumDocAppends() {_        return numDocAppends.count()__    };returns,the,number,of,documents,have,been,appended,since,this,engine,was,opened,this,count,does,not,include,the,appends,from,the,existing,segments,before,opening,engine;long,get,num,doc,appends,return,num,doc,appends,count
InternalEngine -> long getNumDocAppends();1540238977;Returns the number of documents have been appended since this engine was opened._This count does not include the appends from the existing segments before opening engine.;long getNumDocAppends() {_        return numDocAppends.count()__    };returns,the,number,of,documents,have,been,appended,since,this,engine,was,opened,this,count,does,not,include,the,appends,from,the,existing,segments,before,opening,engine;long,get,num,doc,appends,return,num,doc,appends,count
InternalEngine -> long getNumDocAppends();1541335413;Returns the number of documents have been appended since this engine was opened._This count does not include the appends from the existing segments before opening engine.;long getNumDocAppends() {_        return numDocAppends.count()__    };returns,the,number,of,documents,have,been,appended,since,this,engine,was,opened,this,count,does,not,include,the,appends,from,the,existing,segments,before,opening,engine;long,get,num,doc,appends,return,num,doc,appends,count
InternalEngine -> long getNumDocAppends();1541622390;Returns the number of documents have been appended since this engine was opened._This count does not include the appends from the existing segments before opening engine.;long getNumDocAppends() {_        return numDocAppends.count()__    };returns,the,number,of,documents,have,been,appended,since,this,engine,was,opened,this,count,does,not,include,the,appends,from,the,existing,segments,before,opening,engine;long,get,num,doc,appends,return,num,doc,appends,count
InternalEngine -> long getNumDocAppends();1542697754;Returns the number of documents have been appended since this engine was opened._This count does not include the appends from the existing segments before opening engine.;long getNumDocAppends() {_        return numDocAppends.count()__    };returns,the,number,of,documents,have,been,appended,since,this,engine,was,opened,this,count,does,not,include,the,appends,from,the,existing,segments,before,opening,engine;long,get,num,doc,appends,return,num,doc,appends,count
InternalEngine -> long getNumDocAppends();1543940134;Returns the number of documents have been appended since this engine was opened._This count does not include the appends from the existing segments before opening engine.;long getNumDocAppends() {_        return numDocAppends.count()__    };returns,the,number,of,documents,have,been,appended,since,this,engine,was,opened,this,count,does,not,include,the,appends,from,the,existing,segments,before,opening,engine;long,get,num,doc,appends,return,num,doc,appends,count
InternalEngine -> long getNumDocAppends();1544322276;Returns the number of documents have been appended since this engine was opened._This count does not include the appends from the existing segments before opening engine.;long getNumDocAppends() {_        return numDocAppends.count()__    };returns,the,number,of,documents,have,been,appended,since,this,engine,was,opened,this,count,does,not,include,the,appends,from,the,existing,segments,before,opening,engine;long,get,num,doc,appends,return,num,doc,appends,count
InternalEngine -> long getNumDocAppends();1544545090;Returns the number of documents have been appended since this engine was opened._This count does not include the appends from the existing segments before opening engine.;long getNumDocAppends() {_        return numDocAppends.count()__    };returns,the,number,of,documents,have,been,appended,since,this,engine,was,opened,this,count,does,not,include,the,appends,from,the,existing,segments,before,opening,engine;long,get,num,doc,appends,return,num,doc,appends,count
InternalEngine -> long getNumDocAppends();1544684920;Returns the number of documents have been appended since this engine was opened._This count does not include the appends from the existing segments before opening engine.;long getNumDocAppends() {_        return numDocAppends.count()__    };returns,the,number,of,documents,have,been,appended,since,this,engine,was,opened,this,count,does,not,include,the,appends,from,the,existing,segments,before,opening,engine;long,get,num,doc,appends,return,num,doc,appends,count
InternalEngine -> long getNumDocAppends();1545140118;Returns the number of documents have been appended since this engine was opened._This count does not include the appends from the existing segments before opening engine.;long getNumDocAppends() {_        return numDocAppends.count()__    };returns,the,number,of,documents,have,been,appended,since,this,engine,was,opened,this,count,does,not,include,the,appends,from,the,existing,segments,before,opening,engine;long,get,num,doc,appends,return,num,doc,appends,count
InternalEngine -> long getNumDocAppends();1546875837;Returns the number of documents have been appended since this engine was opened._This count does not include the appends from the existing segments before opening engine.;long getNumDocAppends() {_        return numDocAppends.count()__    };returns,the,number,of,documents,have,been,appended,since,this,engine,was,opened,this,count,does,not,include,the,appends,from,the,existing,segments,before,opening,engine;long,get,num,doc,appends,return,num,doc,appends,count
InternalEngine -> long getNumDocAppends();1547332999;Returns the number of documents have been appended since this engine was opened._This count does not include the appends from the existing segments before opening engine.;long getNumDocAppends() {_        return numDocAppends.count()__    };returns,the,number,of,documents,have,been,appended,since,this,engine,was,opened,this,count,does,not,include,the,appends,from,the,existing,segments,before,opening,engine;long,get,num,doc,appends,return,num,doc,appends,count
InternalEngine -> long getNumDocAppends();1548771485;Returns the number of documents have been appended since this engine was opened._This count does not include the appends from the existing segments before opening engine.;long getNumDocAppends() {_        return numDocAppends.count()__    };returns,the,number,of,documents,have,been,appended,since,this,engine,was,opened,this,count,does,not,include,the,appends,from,the,existing,segments,before,opening,engine;long,get,num,doc,appends,return,num,doc,appends,count
InternalEngine -> long getNumDocAppends();1549059559;Returns the number of documents have been appended since this engine was opened._This count does not include the appends from the existing segments before opening engine.;long getNumDocAppends() {_        return numDocAppends.count()__    };returns,the,number,of,documents,have,been,appended,since,this,engine,was,opened,this,count,does,not,include,the,appends,from,the,existing,segments,before,opening,engine;long,get,num,doc,appends,return,num,doc,appends,count
InternalEngine -> long getNumDocAppends();1549663373;Returns the number of documents have been appended since this engine was opened._This count does not include the appends from the existing segments before opening engine.;long getNumDocAppends() {_        return numDocAppends.count()__    };returns,the,number,of,documents,have,been,appended,since,this,engine,was,opened,this,count,does,not,include,the,appends,from,the,existing,segments,before,opening,engine;long,get,num,doc,appends,return,num,doc,appends,count
InternalEngine -> long getNumDocAppends();1549975032;Returns the number of documents have been appended since this engine was opened._This count does not include the appends from the existing segments before opening engine.;long getNumDocAppends() {_        return numDocAppends.count()__    };returns,the,number,of,documents,have,been,appended,since,this,engine,was,opened,this,count,does,not,include,the,appends,from,the,existing,segments,before,opening,engine;long,get,num,doc,appends,return,num,doc,appends,count
InternalEngine -> long getNumDocAppends();1550220204;Returns the number of documents have been appended since this engine was opened._This count does not include the appends from the existing segments before opening engine.;long getNumDocAppends() {_        return numDocAppends.count()__    };returns,the,number,of,documents,have,been,appended,since,this,engine,was,opened,this,count,does,not,include,the,appends,from,the,existing,segments,before,opening,engine;long,get,num,doc,appends,return,num,doc,appends,count
InternalEngine -> long getNumDocAppends();1550256122;Returns the number of documents have been appended since this engine was opened._This count does not include the appends from the existing segments before opening engine.;long getNumDocAppends() {_        return numDocAppends.count()__    };returns,the,number,of,documents,have,been,appended,since,this,engine,was,opened,this,count,does,not,include,the,appends,from,the,existing,segments,before,opening,engine;long,get,num,doc,appends,return,num,doc,appends,count
InternalEngine -> long getNumDocAppends();1550342051;Returns the number of documents have been appended since this engine was opened._This count does not include the appends from the existing segments before opening engine.;long getNumDocAppends() {_        return numDocAppends.count()__    };returns,the,number,of,documents,have,been,appended,since,this,engine,was,opened,this,count,does,not,include,the,appends,from,the,existing,segments,before,opening,engine;long,get,num,doc,appends,return,num,doc,appends,count
InternalEngine -> long getNumDocAppends();1550526771;Returns the number of documents have been appended since this engine was opened._This count does not include the appends from the existing segments before opening engine.;long getNumDocAppends() {_        return numDocAppends.count()__    };returns,the,number,of,documents,have,been,appended,since,this,engine,was,opened,this,count,does,not,include,the,appends,from,the,existing,segments,before,opening,engine;long,get,num,doc,appends,return,num,doc,appends,count
InternalEngine -> long getNumDocAppends();1551110274;Returns the number of documents have been appended since this engine was opened._This count does not include the appends from the existing segments before opening engine.;long getNumDocAppends() {_        return numDocAppends.count()__    };returns,the,number,of,documents,have,been,appended,since,this,engine,was,opened,this,count,does,not,include,the,appends,from,the,existing,segments,before,opening,engine;long,get,num,doc,appends,return,num,doc,appends,count
InternalEngine -> long getNumDocAppends();1551126708;Returns the number of documents have been appended since this engine was opened._This count does not include the appends from the existing segments before opening engine.;long getNumDocAppends() {_        return numDocAppends.count()__    };returns,the,number,of,documents,have,been,appended,since,this,engine,was,opened,this,count,does,not,include,the,appends,from,the,existing,segments,before,opening,engine;long,get,num,doc,appends,return,num,doc,appends,count
InternalEngine -> private boolean mayHaveBeenIndexedBefore(Index index);1524684173;returns true if the indexing operation may have already be processed by this engine._Note that it is OK to rarely return true even if this is not the case. However a `false`_return value must always be correct.;private boolean mayHaveBeenIndexedBefore(Index index) {_        assert canOptimizeAddDocument(index)__        final boolean mayHaveBeenIndexBefore__        if (index.isRetry()) {_            mayHaveBeenIndexBefore = true__            maxUnsafeAutoIdTimestamp.updateAndGet(curr -> Math.max(index.getAutoGeneratedIdTimestamp(), curr))__            assert maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__        } else {_            _            mayHaveBeenIndexBefore = maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__        }_        return mayHaveBeenIndexBefore__    };returns,true,if,the,indexing,operation,may,have,already,be,processed,by,this,engine,note,that,it,is,ok,to,rarely,return,true,even,if,this,is,not,the,case,however,a,false,return,value,must,always,be,correct;private,boolean,may,have,been,indexed,before,index,index,assert,can,optimize,add,document,index,final,boolean,may,have,been,index,before,if,index,is,retry,may,have,been,index,before,true,max,unsafe,auto,id,timestamp,update,and,get,curr,math,max,index,get,auto,generated,id,timestamp,curr,assert,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,else,may,have,been,index,before,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,return,may,have,been,index,before
InternalEngine -> private boolean mayHaveBeenIndexedBefore(Index index);1524780945;returns true if the indexing operation may have already be processed by this engine._Note that it is OK to rarely return true even if this is not the case. However a `false`_return value must always be correct.;private boolean mayHaveBeenIndexedBefore(Index index) {_        assert canOptimizeAddDocument(index)__        final boolean mayHaveBeenIndexBefore__        if (index.isRetry()) {_            mayHaveBeenIndexBefore = true__            maxUnsafeAutoIdTimestamp.updateAndGet(curr -> Math.max(index.getAutoGeneratedIdTimestamp(), curr))__            assert maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__        } else {_            _            mayHaveBeenIndexBefore = maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__        }_        return mayHaveBeenIndexBefore__    };returns,true,if,the,indexing,operation,may,have,already,be,processed,by,this,engine,note,that,it,is,ok,to,rarely,return,true,even,if,this,is,not,the,case,however,a,false,return,value,must,always,be,correct;private,boolean,may,have,been,indexed,before,index,index,assert,can,optimize,add,document,index,final,boolean,may,have,been,index,before,if,index,is,retry,may,have,been,index,before,true,max,unsafe,auto,id,timestamp,update,and,get,curr,math,max,index,get,auto,generated,id,timestamp,curr,assert,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,else,may,have,been,index,before,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,return,may,have,been,index,before
InternalEngine -> private boolean mayHaveBeenIndexedBefore(Index index);1525162917;returns true if the indexing operation may have already be processed by this engine._Note that it is OK to rarely return true even if this is not the case. However a `false`_return value must always be correct.;private boolean mayHaveBeenIndexedBefore(Index index) {_        assert canOptimizeAddDocument(index)__        final boolean mayHaveBeenIndexBefore__        if (index.isRetry()) {_            mayHaveBeenIndexBefore = true__            maxUnsafeAutoIdTimestamp.updateAndGet(curr -> Math.max(index.getAutoGeneratedIdTimestamp(), curr))__            assert maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__        } else {_            _            mayHaveBeenIndexBefore = maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__        }_        return mayHaveBeenIndexBefore__    };returns,true,if,the,indexing,operation,may,have,already,be,processed,by,this,engine,note,that,it,is,ok,to,rarely,return,true,even,if,this,is,not,the,case,however,a,false,return,value,must,always,be,correct;private,boolean,may,have,been,indexed,before,index,index,assert,can,optimize,add,document,index,final,boolean,may,have,been,index,before,if,index,is,retry,may,have,been,index,before,true,max,unsafe,auto,id,timestamp,update,and,get,curr,math,max,index,get,auto,generated,id,timestamp,curr,assert,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,else,may,have,been,index,before,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,return,may,have,been,index,before
InternalEngine -> private boolean mayHaveBeenIndexedBefore(Index index);1528706846;returns true if the indexing operation may have already be processed by this engine._Note that it is OK to rarely return true even if this is not the case. However a `false`_return value must always be correct.;private boolean mayHaveBeenIndexedBefore(Index index) {_        assert canOptimizeAddDocument(index)__        final boolean mayHaveBeenIndexBefore__        if (index.isRetry()) {_            mayHaveBeenIndexBefore = true__            maxUnsafeAutoIdTimestamp.updateAndGet(curr -> Math.max(index.getAutoGeneratedIdTimestamp(), curr))__            assert maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__        } else {_            _            mayHaveBeenIndexBefore = maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__        }_        return mayHaveBeenIndexBefore__    };returns,true,if,the,indexing,operation,may,have,already,be,processed,by,this,engine,note,that,it,is,ok,to,rarely,return,true,even,if,this,is,not,the,case,however,a,false,return,value,must,always,be,correct;private,boolean,may,have,been,indexed,before,index,index,assert,can,optimize,add,document,index,final,boolean,may,have,been,index,before,if,index,is,retry,may,have,been,index,before,true,max,unsafe,auto,id,timestamp,update,and,get,curr,math,max,index,get,auto,generated,id,timestamp,curr,assert,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,else,may,have,been,index,before,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,return,may,have,been,index,before
InternalEngine -> private boolean mayHaveBeenIndexedBefore(Index index);1528762805;returns true if the indexing operation may have already be processed by this engine._Note that it is OK to rarely return true even if this is not the case. However a `false`_return value must always be correct.;private boolean mayHaveBeenIndexedBefore(Index index) {_        assert canOptimizeAddDocument(index)__        final boolean mayHaveBeenIndexBefore__        if (index.isRetry()) {_            mayHaveBeenIndexBefore = true__            maxUnsafeAutoIdTimestamp.updateAndGet(curr -> Math.max(index.getAutoGeneratedIdTimestamp(), curr))__            assert maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__        } else {_            _            mayHaveBeenIndexBefore = maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__        }_        return mayHaveBeenIndexBefore__    };returns,true,if,the,indexing,operation,may,have,already,be,processed,by,this,engine,note,that,it,is,ok,to,rarely,return,true,even,if,this,is,not,the,case,however,a,false,return,value,must,always,be,correct;private,boolean,may,have,been,indexed,before,index,index,assert,can,optimize,add,document,index,final,boolean,may,have,been,index,before,if,index,is,retry,may,have,been,index,before,true,max,unsafe,auto,id,timestamp,update,and,get,curr,math,max,index,get,auto,generated,id,timestamp,curr,assert,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,else,may,have,been,index,before,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,return,may,have,been,index,before
InternalEngine -> private boolean mayHaveBeenIndexedBefore(Index index);1531910483;returns true if the indexing operation may have already be processed by this engine._Note that it is OK to rarely return true even if this is not the case. However a `false`_return value must always be correct.;private boolean mayHaveBeenIndexedBefore(Index index) {_        assert canOptimizeAddDocument(index)__        final boolean mayHaveBeenIndexBefore__        if (index.isRetry()) {_            mayHaveBeenIndexBefore = true__            maxUnsafeAutoIdTimestamp.updateAndGet(curr -> Math.max(index.getAutoGeneratedIdTimestamp(), curr))__            assert maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__        } else {_            _            mayHaveBeenIndexBefore = maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__        }_        return mayHaveBeenIndexBefore__    };returns,true,if,the,indexing,operation,may,have,already,be,processed,by,this,engine,note,that,it,is,ok,to,rarely,return,true,even,if,this,is,not,the,case,however,a,false,return,value,must,always,be,correct;private,boolean,may,have,been,indexed,before,index,index,assert,can,optimize,add,document,index,final,boolean,may,have,been,index,before,if,index,is,retry,may,have,been,index,before,true,max,unsafe,auto,id,timestamp,update,and,get,curr,math,max,index,get,auto,generated,id,timestamp,curr,assert,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,else,may,have,been,index,before,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,return,may,have,been,index,before
InternalEngine -> private boolean mayHaveBeenIndexedBefore(Index index);1533295538;returns true if the indexing operation may have already be processed by this engine._Note that it is OK to rarely return true even if this is not the case. However a `false`_return value must always be correct.;private boolean mayHaveBeenIndexedBefore(Index index) {_        assert canOptimizeAddDocument(index)__        final boolean mayHaveBeenIndexBefore__        if (index.isRetry()) {_            mayHaveBeenIndexBefore = true__            maxUnsafeAutoIdTimestamp.updateAndGet(curr -> Math.max(index.getAutoGeneratedIdTimestamp(), curr))__            assert maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__        } else {_            _            mayHaveBeenIndexBefore = maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__        }_        return mayHaveBeenIndexBefore__    };returns,true,if,the,indexing,operation,may,have,already,be,processed,by,this,engine,note,that,it,is,ok,to,rarely,return,true,even,if,this,is,not,the,case,however,a,false,return,value,must,always,be,correct;private,boolean,may,have,been,indexed,before,index,index,assert,can,optimize,add,document,index,final,boolean,may,have,been,index,before,if,index,is,retry,may,have,been,index,before,true,max,unsafe,auto,id,timestamp,update,and,get,curr,math,max,index,get,auto,generated,id,timestamp,curr,assert,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,else,may,have,been,index,before,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,return,may,have,been,index,before
InternalEngine -> private boolean mayHaveBeenIndexedBefore(Index index);1534848846;returns true if the indexing operation may have already be processed by this engine._Note that it is OK to rarely return true even if this is not the case. However a `false`_return value must always be correct.;private boolean mayHaveBeenIndexedBefore(Index index) {_        assert canOptimizeAddDocument(index)__        final boolean mayHaveBeenIndexBefore__        if (index.isRetry()) {_            mayHaveBeenIndexBefore = true__            maxUnsafeAutoIdTimestamp.updateAndGet(curr -> Math.max(index.getAutoGeneratedIdTimestamp(), curr))__            assert maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__        } else {_            _            mayHaveBeenIndexBefore = maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__        }_        return mayHaveBeenIndexBefore__    };returns,true,if,the,indexing,operation,may,have,already,be,processed,by,this,engine,note,that,it,is,ok,to,rarely,return,true,even,if,this,is,not,the,case,however,a,false,return,value,must,always,be,correct;private,boolean,may,have,been,indexed,before,index,index,assert,can,optimize,add,document,index,final,boolean,may,have,been,index,before,if,index,is,retry,may,have,been,index,before,true,max,unsafe,auto,id,timestamp,update,and,get,curr,math,max,index,get,auto,generated,id,timestamp,curr,assert,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,else,may,have,been,index,before,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,return,may,have,been,index,before
InternalEngine -> private boolean mayHaveBeenIndexedBefore(Index index);1535046779;returns true if the indexing operation may have already be processed by this engine._Note that it is OK to rarely return true even if this is not the case. However a `false`_return value must always be correct.;private boolean mayHaveBeenIndexedBefore(Index index) {_        assert canOptimizeAddDocument(index)__        final boolean mayHaveBeenIndexBefore__        if (index.isRetry()) {_            mayHaveBeenIndexBefore = true__            maxUnsafeAutoIdTimestamp.updateAndGet(curr -> Math.max(index.getAutoGeneratedIdTimestamp(), curr))__            assert maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__        } else {_            _            mayHaveBeenIndexBefore = maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__        }_        return mayHaveBeenIndexBefore__    };returns,true,if,the,indexing,operation,may,have,already,be,processed,by,this,engine,note,that,it,is,ok,to,rarely,return,true,even,if,this,is,not,the,case,however,a,false,return,value,must,always,be,correct;private,boolean,may,have,been,indexed,before,index,index,assert,can,optimize,add,document,index,final,boolean,may,have,been,index,before,if,index,is,retry,may,have,been,index,before,true,max,unsafe,auto,id,timestamp,update,and,get,curr,math,max,index,get,auto,generated,id,timestamp,curr,assert,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,else,may,have,been,index,before,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,return,may,have,been,index,before
InternalEngine -> private boolean mayHaveBeenIndexedBefore(Index index);1535405719;returns true if the indexing operation may have already be processed by this engine._Note that it is OK to rarely return true even if this is not the case. However a `false`_return value must always be correct.;private boolean mayHaveBeenIndexedBefore(Index index) {_        assert canOptimizeAddDocument(index)__        final boolean mayHaveBeenIndexBefore__        if (index.isRetry()) {_            mayHaveBeenIndexBefore = true__            maxUnsafeAutoIdTimestamp.updateAndGet(curr -> Math.max(index.getAutoGeneratedIdTimestamp(), curr))__            assert maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__        } else {_            _            mayHaveBeenIndexBefore = maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__        }_        return mayHaveBeenIndexBefore__    };returns,true,if,the,indexing,operation,may,have,already,be,processed,by,this,engine,note,that,it,is,ok,to,rarely,return,true,even,if,this,is,not,the,case,however,a,false,return,value,must,always,be,correct;private,boolean,may,have,been,indexed,before,index,index,assert,can,optimize,add,document,index,final,boolean,may,have,been,index,before,if,index,is,retry,may,have,been,index,before,true,max,unsafe,auto,id,timestamp,update,and,get,curr,math,max,index,get,auto,generated,id,timestamp,curr,assert,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,else,may,have,been,index,before,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,return,may,have,been,index,before
InternalEngine -> private boolean mayHaveBeenIndexedBefore(Index index);1535723122;returns true if the indexing operation may have already be processed by this engine._Note that it is OK to rarely return true even if this is not the case. However a `false`_return value must always be correct.;private boolean mayHaveBeenIndexedBefore(Index index) {_        assert canOptimizeAddDocument(index)__        final boolean mayHaveBeenIndexBefore__        if (index.isRetry()) {_            mayHaveBeenIndexBefore = true__            maxUnsafeAutoIdTimestamp.updateAndGet(curr -> Math.max(index.getAutoGeneratedIdTimestamp(), curr))__            assert maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__        } else {_            _            mayHaveBeenIndexBefore = maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__        }_        return mayHaveBeenIndexBefore__    };returns,true,if,the,indexing,operation,may,have,already,be,processed,by,this,engine,note,that,it,is,ok,to,rarely,return,true,even,if,this,is,not,the,case,however,a,false,return,value,must,always,be,correct;private,boolean,may,have,been,indexed,before,index,index,assert,can,optimize,add,document,index,final,boolean,may,have,been,index,before,if,index,is,retry,may,have,been,index,before,true,max,unsafe,auto,id,timestamp,update,and,get,curr,math,max,index,get,auto,generated,id,timestamp,curr,assert,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,else,may,have,been,index,before,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,return,may,have,been,index,before
InternalEngine -> private boolean mayHaveBeenIndexedBefore(Index index);1535965276;returns true if the indexing operation may have already be processed by this engine._Note that it is OK to rarely return true even if this is not the case. However a `false`_return value must always be correct.;private boolean mayHaveBeenIndexedBefore(Index index) {_        assert canOptimizeAddDocument(index)__        final boolean mayHaveBeenIndexBefore__        if (index.isRetry()) {_            mayHaveBeenIndexBefore = true__            maxUnsafeAutoIdTimestamp.updateAndGet(curr -> Math.max(index.getAutoGeneratedIdTimestamp(), curr))__            assert maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__        } else {_            _            mayHaveBeenIndexBefore = maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__        }_        return mayHaveBeenIndexBefore__    };returns,true,if,the,indexing,operation,may,have,already,be,processed,by,this,engine,note,that,it,is,ok,to,rarely,return,true,even,if,this,is,not,the,case,however,a,false,return,value,must,always,be,correct;private,boolean,may,have,been,indexed,before,index,index,assert,can,optimize,add,document,index,final,boolean,may,have,been,index,before,if,index,is,retry,may,have,been,index,before,true,max,unsafe,auto,id,timestamp,update,and,get,curr,math,max,index,get,auto,generated,id,timestamp,curr,assert,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,else,may,have,been,index,before,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,return,may,have,been,index,before
InternalEngine -> private boolean mayHaveBeenIndexedBefore(Index index);1536218260;returns true if the indexing operation may have already be processed by this engine._Note that it is OK to rarely return true even if this is not the case. However a `false`_return value must always be correct.;private boolean mayHaveBeenIndexedBefore(Index index) {_        assert canOptimizeAddDocument(index)__        final boolean mayHaveBeenIndexBefore__        if (index.isRetry()) {_            mayHaveBeenIndexBefore = true__            maxUnsafeAutoIdTimestamp.updateAndGet(curr -> Math.max(index.getAutoGeneratedIdTimestamp(), curr))__            assert maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__        } else {_            _            mayHaveBeenIndexBefore = maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__        }_        return mayHaveBeenIndexBefore__    };returns,true,if,the,indexing,operation,may,have,already,be,processed,by,this,engine,note,that,it,is,ok,to,rarely,return,true,even,if,this,is,not,the,case,however,a,false,return,value,must,always,be,correct;private,boolean,may,have,been,indexed,before,index,index,assert,can,optimize,add,document,index,final,boolean,may,have,been,index,before,if,index,is,retry,may,have,been,index,before,true,max,unsafe,auto,id,timestamp,update,and,get,curr,math,max,index,get,auto,generated,id,timestamp,curr,assert,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,else,may,have,been,index,before,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,return,may,have,been,index,before
InternalEngine -> private boolean mayHaveBeenIndexedBefore(Index index);1536314350;returns true if the indexing operation may have already be processed by this engine._Note that it is OK to rarely return true even if this is not the case. However a `false`_return value must always be correct.;private boolean mayHaveBeenIndexedBefore(Index index) {_        assert canOptimizeAddDocument(index)__        final boolean mayHaveBeenIndexBefore__        if (index.isRetry()) {_            mayHaveBeenIndexBefore = true__            maxUnsafeAutoIdTimestamp.updateAndGet(curr -> Math.max(index.getAutoGeneratedIdTimestamp(), curr))__            assert maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__        } else {_            _            mayHaveBeenIndexBefore = maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__        }_        return mayHaveBeenIndexBefore__    };returns,true,if,the,indexing,operation,may,have,already,be,processed,by,this,engine,note,that,it,is,ok,to,rarely,return,true,even,if,this,is,not,the,case,however,a,false,return,value,must,always,be,correct;private,boolean,may,have,been,indexed,before,index,index,assert,can,optimize,add,document,index,final,boolean,may,have,been,index,before,if,index,is,retry,may,have,been,index,before,true,max,unsafe,auto,id,timestamp,update,and,get,curr,math,max,index,get,auto,generated,id,timestamp,curr,assert,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,else,may,have,been,index,before,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,return,may,have,been,index,before
InternalEngine -> private boolean mayHaveBeenIndexedBefore(Index index);1536828374;returns true if the indexing operation may have already be processed by this engine._Note that it is OK to rarely return true even if this is not the case. However a `false`_return value must always be correct.;private boolean mayHaveBeenIndexedBefore(Index index) {_        assert canOptimizeAddDocument(index)__        final boolean mayHaveBeenIndexBefore__        if (index.isRetry()) {_            mayHaveBeenIndexBefore = true__            maxUnsafeAutoIdTimestamp.updateAndGet(curr -> Math.max(index.getAutoGeneratedIdTimestamp(), curr))__            assert maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__        } else {_            _            mayHaveBeenIndexBefore = maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__        }_        return mayHaveBeenIndexBefore__    };returns,true,if,the,indexing,operation,may,have,already,be,processed,by,this,engine,note,that,it,is,ok,to,rarely,return,true,even,if,this,is,not,the,case,however,a,false,return,value,must,always,be,correct;private,boolean,may,have,been,indexed,before,index,index,assert,can,optimize,add,document,index,final,boolean,may,have,been,index,before,if,index,is,retry,may,have,been,index,before,true,max,unsafe,auto,id,timestamp,update,and,get,curr,math,max,index,get,auto,generated,id,timestamp,curr,assert,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,else,may,have,been,index,before,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,return,may,have,been,index,before
InternalEngine -> private boolean mayHaveBeenIndexedBefore(Index index);1537806831;returns true if the indexing operation may have already be processed by this engine._Note that it is OK to rarely return true even if this is not the case. However a `false`_return value must always be correct.;private boolean mayHaveBeenIndexedBefore(Index index) {_        assert canOptimizeAddDocument(index)__        final boolean mayHaveBeenIndexBefore__        if (index.isRetry()) {_            mayHaveBeenIndexBefore = true__            updateAutoIdTimestamp(index.getAutoGeneratedIdTimestamp(), true)__            assert maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__        } else {_            _            mayHaveBeenIndexBefore = maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__            updateAutoIdTimestamp(index.getAutoGeneratedIdTimestamp(), false)__        }_        return mayHaveBeenIndexBefore__    };returns,true,if,the,indexing,operation,may,have,already,be,processed,by,this,engine,note,that,it,is,ok,to,rarely,return,true,even,if,this,is,not,the,case,however,a,false,return,value,must,always,be,correct;private,boolean,may,have,been,indexed,before,index,index,assert,can,optimize,add,document,index,final,boolean,may,have,been,index,before,if,index,is,retry,may,have,been,index,before,true,update,auto,id,timestamp,index,get,auto,generated,id,timestamp,true,assert,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,else,may,have,been,index,before,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,update,auto,id,timestamp,index,get,auto,generated,id,timestamp,false,return,may,have,been,index,before
InternalEngine -> private boolean mayHaveBeenIndexedBefore(Index index);1538067637;returns true if the indexing operation may have already be processed by this engine._Note that it is OK to rarely return true even if this is not the case. However a `false`_return value must always be correct.;private boolean mayHaveBeenIndexedBefore(Index index) {_        assert canOptimizeAddDocument(index)__        final boolean mayHaveBeenIndexBefore__        if (index.isRetry()) {_            mayHaveBeenIndexBefore = true__            updateAutoIdTimestamp(index.getAutoGeneratedIdTimestamp(), true)__            assert maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__        } else {_            _            mayHaveBeenIndexBefore = maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__            updateAutoIdTimestamp(index.getAutoGeneratedIdTimestamp(), false)__        }_        return mayHaveBeenIndexBefore__    };returns,true,if,the,indexing,operation,may,have,already,be,processed,by,this,engine,note,that,it,is,ok,to,rarely,return,true,even,if,this,is,not,the,case,however,a,false,return,value,must,always,be,correct;private,boolean,may,have,been,indexed,before,index,index,assert,can,optimize,add,document,index,final,boolean,may,have,been,index,before,if,index,is,retry,may,have,been,index,before,true,update,auto,id,timestamp,index,get,auto,generated,id,timestamp,true,assert,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,else,may,have,been,index,before,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,update,auto,id,timestamp,index,get,auto,generated,id,timestamp,false,return,may,have,been,index,before
InternalEngine -> private boolean mayHaveBeenIndexedBefore(Index index);1538424609;returns true if the indexing operation may have already be processed by this engine._Note that it is OK to rarely return true even if this is not the case. However a `false`_return value must always be correct.;private boolean mayHaveBeenIndexedBefore(Index index) {_        assert canOptimizeAddDocument(index)__        final boolean mayHaveBeenIndexBefore__        if (index.isRetry()) {_            mayHaveBeenIndexBefore = true__            updateAutoIdTimestamp(index.getAutoGeneratedIdTimestamp(), true)__            assert maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__        } else {_            _            mayHaveBeenIndexBefore = maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__            updateAutoIdTimestamp(index.getAutoGeneratedIdTimestamp(), false)__        }_        return mayHaveBeenIndexBefore__    };returns,true,if,the,indexing,operation,may,have,already,be,processed,by,this,engine,note,that,it,is,ok,to,rarely,return,true,even,if,this,is,not,the,case,however,a,false,return,value,must,always,be,correct;private,boolean,may,have,been,indexed,before,index,index,assert,can,optimize,add,document,index,final,boolean,may,have,been,index,before,if,index,is,retry,may,have,been,index,before,true,update,auto,id,timestamp,index,get,auto,generated,id,timestamp,true,assert,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,else,may,have,been,index,before,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,update,auto,id,timestamp,index,get,auto,generated,id,timestamp,false,return,may,have,been,index,before
InternalEngine -> private boolean mayHaveBeenIndexedBefore(Index index);1539615817;returns true if the indexing operation may have already be processed by this engine._Note that it is OK to rarely return true even if this is not the case. However a `false`_return value must always be correct.;private boolean mayHaveBeenIndexedBefore(Index index) {_        assert canOptimizeAddDocument(index)__        final boolean mayHaveBeenIndexBefore__        if (index.isRetry()) {_            mayHaveBeenIndexBefore = true__            updateAutoIdTimestamp(index.getAutoGeneratedIdTimestamp(), true)__            assert maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__        } else {_            _            mayHaveBeenIndexBefore = maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__            updateAutoIdTimestamp(index.getAutoGeneratedIdTimestamp(), false)__        }_        return mayHaveBeenIndexBefore__    };returns,true,if,the,indexing,operation,may,have,already,be,processed,by,this,engine,note,that,it,is,ok,to,rarely,return,true,even,if,this,is,not,the,case,however,a,false,return,value,must,always,be,correct;private,boolean,may,have,been,indexed,before,index,index,assert,can,optimize,add,document,index,final,boolean,may,have,been,index,before,if,index,is,retry,may,have,been,index,before,true,update,auto,id,timestamp,index,get,auto,generated,id,timestamp,true,assert,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,else,may,have,been,index,before,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,update,auto,id,timestamp,index,get,auto,generated,id,timestamp,false,return,may,have,been,index,before
InternalEngine -> private boolean mayHaveBeenIndexedBefore(Index index);1539723533;returns true if the indexing operation may have already be processed by this engine._Note that it is OK to rarely return true even if this is not the case. However a `false`_return value must always be correct.;private boolean mayHaveBeenIndexedBefore(Index index) {_        assert canOptimizeAddDocument(index)__        final boolean mayHaveBeenIndexBefore__        if (index.isRetry()) {_            mayHaveBeenIndexBefore = true__            updateAutoIdTimestamp(index.getAutoGeneratedIdTimestamp(), true)__            assert maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__        } else {_            _            mayHaveBeenIndexBefore = maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__            updateAutoIdTimestamp(index.getAutoGeneratedIdTimestamp(), false)__        }_        return mayHaveBeenIndexBefore__    };returns,true,if,the,indexing,operation,may,have,already,be,processed,by,this,engine,note,that,it,is,ok,to,rarely,return,true,even,if,this,is,not,the,case,however,a,false,return,value,must,always,be,correct;private,boolean,may,have,been,indexed,before,index,index,assert,can,optimize,add,document,index,final,boolean,may,have,been,index,before,if,index,is,retry,may,have,been,index,before,true,update,auto,id,timestamp,index,get,auto,generated,id,timestamp,true,assert,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,else,may,have,been,index,before,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,update,auto,id,timestamp,index,get,auto,generated,id,timestamp,false,return,may,have,been,index,before
InternalEngine -> private boolean mayHaveBeenIndexedBefore(Index index);1540238977;returns true if the indexing operation may have already be processed by this engine._Note that it is OK to rarely return true even if this is not the case. However a `false`_return value must always be correct.;private boolean mayHaveBeenIndexedBefore(Index index) {_        assert canOptimizeAddDocument(index)__        final boolean mayHaveBeenIndexBefore__        if (index.isRetry()) {_            mayHaveBeenIndexBefore = true__            updateAutoIdTimestamp(index.getAutoGeneratedIdTimestamp(), true)__            assert maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__        } else {_            _            mayHaveBeenIndexBefore = maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__            updateAutoIdTimestamp(index.getAutoGeneratedIdTimestamp(), false)__        }_        return mayHaveBeenIndexBefore__    };returns,true,if,the,indexing,operation,may,have,already,be,processed,by,this,engine,note,that,it,is,ok,to,rarely,return,true,even,if,this,is,not,the,case,however,a,false,return,value,must,always,be,correct;private,boolean,may,have,been,indexed,before,index,index,assert,can,optimize,add,document,index,final,boolean,may,have,been,index,before,if,index,is,retry,may,have,been,index,before,true,update,auto,id,timestamp,index,get,auto,generated,id,timestamp,true,assert,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,else,may,have,been,index,before,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,update,auto,id,timestamp,index,get,auto,generated,id,timestamp,false,return,may,have,been,index,before
InternalEngine -> private boolean mayHaveBeenIndexedBefore(Index index);1541335413;returns true if the indexing operation may have already be processed by this engine._Note that it is OK to rarely return true even if this is not the case. However a `false`_return value must always be correct.;private boolean mayHaveBeenIndexedBefore(Index index) {_        assert canOptimizeAddDocument(index)__        final boolean mayHaveBeenIndexBefore__        if (index.isRetry()) {_            mayHaveBeenIndexBefore = true__            updateAutoIdTimestamp(index.getAutoGeneratedIdTimestamp(), true)__            assert maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__        } else {_            _            mayHaveBeenIndexBefore = maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__            updateAutoIdTimestamp(index.getAutoGeneratedIdTimestamp(), false)__        }_        return mayHaveBeenIndexBefore__    };returns,true,if,the,indexing,operation,may,have,already,be,processed,by,this,engine,note,that,it,is,ok,to,rarely,return,true,even,if,this,is,not,the,case,however,a,false,return,value,must,always,be,correct;private,boolean,may,have,been,indexed,before,index,index,assert,can,optimize,add,document,index,final,boolean,may,have,been,index,before,if,index,is,retry,may,have,been,index,before,true,update,auto,id,timestamp,index,get,auto,generated,id,timestamp,true,assert,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,else,may,have,been,index,before,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,update,auto,id,timestamp,index,get,auto,generated,id,timestamp,false,return,may,have,been,index,before
InternalEngine -> private boolean mayHaveBeenIndexedBefore(Index index);1541622390;returns true if the indexing operation may have already be processed by this engine._Note that it is OK to rarely return true even if this is not the case. However a `false`_return value must always be correct.;private boolean mayHaveBeenIndexedBefore(Index index) {_        assert canOptimizeAddDocument(index)__        final boolean mayHaveBeenIndexBefore__        if (index.isRetry()) {_            mayHaveBeenIndexBefore = true__            updateAutoIdTimestamp(index.getAutoGeneratedIdTimestamp(), true)__            assert maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__        } else {_            _            mayHaveBeenIndexBefore = maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__            updateAutoIdTimestamp(index.getAutoGeneratedIdTimestamp(), false)__        }_        return mayHaveBeenIndexBefore__    };returns,true,if,the,indexing,operation,may,have,already,be,processed,by,this,engine,note,that,it,is,ok,to,rarely,return,true,even,if,this,is,not,the,case,however,a,false,return,value,must,always,be,correct;private,boolean,may,have,been,indexed,before,index,index,assert,can,optimize,add,document,index,final,boolean,may,have,been,index,before,if,index,is,retry,may,have,been,index,before,true,update,auto,id,timestamp,index,get,auto,generated,id,timestamp,true,assert,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,else,may,have,been,index,before,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,update,auto,id,timestamp,index,get,auto,generated,id,timestamp,false,return,may,have,been,index,before
InternalEngine -> private boolean mayHaveBeenIndexedBefore(Index index);1542697754;returns true if the indexing operation may have already be processed by this engine._Note that it is OK to rarely return true even if this is not the case. However a `false`_return value must always be correct.;private boolean mayHaveBeenIndexedBefore(Index index) {_        assert canOptimizeAddDocument(index)__        final boolean mayHaveBeenIndexBefore__        if (index.isRetry()) {_            mayHaveBeenIndexBefore = true__            updateAutoIdTimestamp(index.getAutoGeneratedIdTimestamp(), true)__            assert maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__        } else {_            _            mayHaveBeenIndexBefore = maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__            updateAutoIdTimestamp(index.getAutoGeneratedIdTimestamp(), false)__        }_        return mayHaveBeenIndexBefore__    };returns,true,if,the,indexing,operation,may,have,already,be,processed,by,this,engine,note,that,it,is,ok,to,rarely,return,true,even,if,this,is,not,the,case,however,a,false,return,value,must,always,be,correct;private,boolean,may,have,been,indexed,before,index,index,assert,can,optimize,add,document,index,final,boolean,may,have,been,index,before,if,index,is,retry,may,have,been,index,before,true,update,auto,id,timestamp,index,get,auto,generated,id,timestamp,true,assert,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,else,may,have,been,index,before,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,update,auto,id,timestamp,index,get,auto,generated,id,timestamp,false,return,may,have,been,index,before
InternalEngine -> private boolean mayHaveBeenIndexedBefore(Index index);1543940134;returns true if the indexing operation may have already be processed by this engine._Note that it is OK to rarely return true even if this is not the case. However a `false`_return value must always be correct.;private boolean mayHaveBeenIndexedBefore(Index index) {_        assert canOptimizeAddDocument(index)__        final boolean mayHaveBeenIndexBefore__        if (index.isRetry()) {_            mayHaveBeenIndexBefore = true__            updateAutoIdTimestamp(index.getAutoGeneratedIdTimestamp(), true)__            assert maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__        } else {_            _            mayHaveBeenIndexBefore = maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__            updateAutoIdTimestamp(index.getAutoGeneratedIdTimestamp(), false)__        }_        return mayHaveBeenIndexBefore__    };returns,true,if,the,indexing,operation,may,have,already,be,processed,by,this,engine,note,that,it,is,ok,to,rarely,return,true,even,if,this,is,not,the,case,however,a,false,return,value,must,always,be,correct;private,boolean,may,have,been,indexed,before,index,index,assert,can,optimize,add,document,index,final,boolean,may,have,been,index,before,if,index,is,retry,may,have,been,index,before,true,update,auto,id,timestamp,index,get,auto,generated,id,timestamp,true,assert,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,else,may,have,been,index,before,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,update,auto,id,timestamp,index,get,auto,generated,id,timestamp,false,return,may,have,been,index,before
InternalEngine -> private boolean mayHaveBeenIndexedBefore(Index index);1544322276;returns true if the indexing operation may have already be processed by this engine._Note that it is OK to rarely return true even if this is not the case. However a `false`_return value must always be correct.;private boolean mayHaveBeenIndexedBefore(Index index) {_        assert canOptimizeAddDocument(index)__        final boolean mayHaveBeenIndexBefore__        if (index.isRetry()) {_            mayHaveBeenIndexBefore = true__            updateAutoIdTimestamp(index.getAutoGeneratedIdTimestamp(), true)__            assert maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__        } else {_            _            mayHaveBeenIndexBefore = maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__            updateAutoIdTimestamp(index.getAutoGeneratedIdTimestamp(), false)__        }_        return mayHaveBeenIndexBefore__    };returns,true,if,the,indexing,operation,may,have,already,be,processed,by,this,engine,note,that,it,is,ok,to,rarely,return,true,even,if,this,is,not,the,case,however,a,false,return,value,must,always,be,correct;private,boolean,may,have,been,indexed,before,index,index,assert,can,optimize,add,document,index,final,boolean,may,have,been,index,before,if,index,is,retry,may,have,been,index,before,true,update,auto,id,timestamp,index,get,auto,generated,id,timestamp,true,assert,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,else,may,have,been,index,before,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,update,auto,id,timestamp,index,get,auto,generated,id,timestamp,false,return,may,have,been,index,before
InternalEngine -> private boolean mayHaveBeenIndexedBefore(Index index);1544545090;returns true if the indexing operation may have already be processed by this engine._Note that it is OK to rarely return true even if this is not the case. However a `false`_return value must always be correct.;private boolean mayHaveBeenIndexedBefore(Index index) {_        assert canOptimizeAddDocument(index)__        final boolean mayHaveBeenIndexBefore__        if (index.isRetry()) {_            mayHaveBeenIndexBefore = true__            updateAutoIdTimestamp(index.getAutoGeneratedIdTimestamp(), true)__            assert maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__        } else {_            _            mayHaveBeenIndexBefore = maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__            updateAutoIdTimestamp(index.getAutoGeneratedIdTimestamp(), false)__        }_        return mayHaveBeenIndexBefore__    };returns,true,if,the,indexing,operation,may,have,already,be,processed,by,this,engine,note,that,it,is,ok,to,rarely,return,true,even,if,this,is,not,the,case,however,a,false,return,value,must,always,be,correct;private,boolean,may,have,been,indexed,before,index,index,assert,can,optimize,add,document,index,final,boolean,may,have,been,index,before,if,index,is,retry,may,have,been,index,before,true,update,auto,id,timestamp,index,get,auto,generated,id,timestamp,true,assert,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,else,may,have,been,index,before,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,update,auto,id,timestamp,index,get,auto,generated,id,timestamp,false,return,may,have,been,index,before
InternalEngine -> private boolean mayHaveBeenIndexedBefore(Index index);1544684920;returns true if the indexing operation may have already be processed by this engine._Note that it is OK to rarely return true even if this is not the case. However a `false`_return value must always be correct.;private boolean mayHaveBeenIndexedBefore(Index index) {_        assert canOptimizeAddDocument(index)__        final boolean mayHaveBeenIndexBefore__        if (index.isRetry()) {_            mayHaveBeenIndexBefore = true__            updateAutoIdTimestamp(index.getAutoGeneratedIdTimestamp(), true)__            assert maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__        } else {_            _            mayHaveBeenIndexBefore = maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__            updateAutoIdTimestamp(index.getAutoGeneratedIdTimestamp(), false)__        }_        return mayHaveBeenIndexBefore__    };returns,true,if,the,indexing,operation,may,have,already,be,processed,by,this,engine,note,that,it,is,ok,to,rarely,return,true,even,if,this,is,not,the,case,however,a,false,return,value,must,always,be,correct;private,boolean,may,have,been,indexed,before,index,index,assert,can,optimize,add,document,index,final,boolean,may,have,been,index,before,if,index,is,retry,may,have,been,index,before,true,update,auto,id,timestamp,index,get,auto,generated,id,timestamp,true,assert,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,else,may,have,been,index,before,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,update,auto,id,timestamp,index,get,auto,generated,id,timestamp,false,return,may,have,been,index,before
InternalEngine -> private boolean mayHaveBeenIndexedBefore(Index index);1545140118;returns true if the indexing operation may have already be processed by this engine._Note that it is OK to rarely return true even if this is not the case. However a `false`_return value must always be correct.;private boolean mayHaveBeenIndexedBefore(Index index) {_        assert canOptimizeAddDocument(index)__        final boolean mayHaveBeenIndexBefore__        if (index.isRetry()) {_            mayHaveBeenIndexBefore = true__            updateAutoIdTimestamp(index.getAutoGeneratedIdTimestamp(), true)__            assert maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__        } else {_            _            mayHaveBeenIndexBefore = maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__            updateAutoIdTimestamp(index.getAutoGeneratedIdTimestamp(), false)__        }_        return mayHaveBeenIndexBefore__    };returns,true,if,the,indexing,operation,may,have,already,be,processed,by,this,engine,note,that,it,is,ok,to,rarely,return,true,even,if,this,is,not,the,case,however,a,false,return,value,must,always,be,correct;private,boolean,may,have,been,indexed,before,index,index,assert,can,optimize,add,document,index,final,boolean,may,have,been,index,before,if,index,is,retry,may,have,been,index,before,true,update,auto,id,timestamp,index,get,auto,generated,id,timestamp,true,assert,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,else,may,have,been,index,before,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,update,auto,id,timestamp,index,get,auto,generated,id,timestamp,false,return,may,have,been,index,before
InternalEngine -> private boolean mayHaveBeenIndexedBefore(Index index);1546875837;returns true if the indexing operation may have already be processed by this engine._Note that it is OK to rarely return true even if this is not the case. However a `false`_return value must always be correct.;private boolean mayHaveBeenIndexedBefore(Index index) {_        assert canOptimizeAddDocument(index)__        final boolean mayHaveBeenIndexBefore__        if (index.isRetry()) {_            mayHaveBeenIndexBefore = true__            updateAutoIdTimestamp(index.getAutoGeneratedIdTimestamp(), true)__            assert maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__        } else {_            _            mayHaveBeenIndexBefore = maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__            updateAutoIdTimestamp(index.getAutoGeneratedIdTimestamp(), false)__        }_        return mayHaveBeenIndexBefore__    };returns,true,if,the,indexing,operation,may,have,already,be,processed,by,this,engine,note,that,it,is,ok,to,rarely,return,true,even,if,this,is,not,the,case,however,a,false,return,value,must,always,be,correct;private,boolean,may,have,been,indexed,before,index,index,assert,can,optimize,add,document,index,final,boolean,may,have,been,index,before,if,index,is,retry,may,have,been,index,before,true,update,auto,id,timestamp,index,get,auto,generated,id,timestamp,true,assert,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,else,may,have,been,index,before,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,update,auto,id,timestamp,index,get,auto,generated,id,timestamp,false,return,may,have,been,index,before
InternalEngine -> private boolean mayHaveBeenIndexedBefore(Index index);1547332999;returns true if the indexing operation may have already be processed by this engine._Note that it is OK to rarely return true even if this is not the case. However a `false`_return value must always be correct.;private boolean mayHaveBeenIndexedBefore(Index index) {_        assert canOptimizeAddDocument(index)__        final boolean mayHaveBeenIndexBefore__        if (index.isRetry()) {_            mayHaveBeenIndexBefore = true__            updateAutoIdTimestamp(index.getAutoGeneratedIdTimestamp(), true)__            assert maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__        } else {_            _            mayHaveBeenIndexBefore = maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__            updateAutoIdTimestamp(index.getAutoGeneratedIdTimestamp(), false)__        }_        return mayHaveBeenIndexBefore__    };returns,true,if,the,indexing,operation,may,have,already,be,processed,by,this,engine,note,that,it,is,ok,to,rarely,return,true,even,if,this,is,not,the,case,however,a,false,return,value,must,always,be,correct;private,boolean,may,have,been,indexed,before,index,index,assert,can,optimize,add,document,index,final,boolean,may,have,been,index,before,if,index,is,retry,may,have,been,index,before,true,update,auto,id,timestamp,index,get,auto,generated,id,timestamp,true,assert,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,else,may,have,been,index,before,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,update,auto,id,timestamp,index,get,auto,generated,id,timestamp,false,return,may,have,been,index,before
InternalEngine -> private boolean mayHaveBeenIndexedBefore(Index index);1548771485;returns true if the indexing operation may have already be processed by this engine._Note that it is OK to rarely return true even if this is not the case. However a `false`_return value must always be correct.;private boolean mayHaveBeenIndexedBefore(Index index) {_        assert canOptimizeAddDocument(index)__        final boolean mayHaveBeenIndexBefore__        if (index.isRetry()) {_            mayHaveBeenIndexBefore = true__            updateAutoIdTimestamp(index.getAutoGeneratedIdTimestamp(), true)__            assert maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__        } else {_            _            mayHaveBeenIndexBefore = maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__            updateAutoIdTimestamp(index.getAutoGeneratedIdTimestamp(), false)__        }_        return mayHaveBeenIndexBefore__    };returns,true,if,the,indexing,operation,may,have,already,be,processed,by,this,engine,note,that,it,is,ok,to,rarely,return,true,even,if,this,is,not,the,case,however,a,false,return,value,must,always,be,correct;private,boolean,may,have,been,indexed,before,index,index,assert,can,optimize,add,document,index,final,boolean,may,have,been,index,before,if,index,is,retry,may,have,been,index,before,true,update,auto,id,timestamp,index,get,auto,generated,id,timestamp,true,assert,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,else,may,have,been,index,before,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,update,auto,id,timestamp,index,get,auto,generated,id,timestamp,false,return,may,have,been,index,before
InternalEngine -> private boolean mayHaveBeenIndexedBefore(Index index);1549059559;returns true if the indexing operation may have already be processed by this engine._Note that it is OK to rarely return true even if this is not the case. However a `false`_return value must always be correct.;private boolean mayHaveBeenIndexedBefore(Index index) {_        assert canOptimizeAddDocument(index)__        final boolean mayHaveBeenIndexBefore__        if (index.isRetry()) {_            mayHaveBeenIndexBefore = true__            updateAutoIdTimestamp(index.getAutoGeneratedIdTimestamp(), true)__            assert maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__        } else {_            _            mayHaveBeenIndexBefore = maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__            updateAutoIdTimestamp(index.getAutoGeneratedIdTimestamp(), false)__        }_        return mayHaveBeenIndexBefore__    };returns,true,if,the,indexing,operation,may,have,already,be,processed,by,this,engine,note,that,it,is,ok,to,rarely,return,true,even,if,this,is,not,the,case,however,a,false,return,value,must,always,be,correct;private,boolean,may,have,been,indexed,before,index,index,assert,can,optimize,add,document,index,final,boolean,may,have,been,index,before,if,index,is,retry,may,have,been,index,before,true,update,auto,id,timestamp,index,get,auto,generated,id,timestamp,true,assert,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,else,may,have,been,index,before,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,update,auto,id,timestamp,index,get,auto,generated,id,timestamp,false,return,may,have,been,index,before
InternalEngine -> private boolean mayHaveBeenIndexedBefore(Index index);1549663373;returns true if the indexing operation may have already be processed by this engine._Note that it is OK to rarely return true even if this is not the case. However a `false`_return value must always be correct.;private boolean mayHaveBeenIndexedBefore(Index index) {_        assert canOptimizeAddDocument(index)__        final boolean mayHaveBeenIndexBefore__        if (index.isRetry()) {_            mayHaveBeenIndexBefore = true__            updateAutoIdTimestamp(index.getAutoGeneratedIdTimestamp(), true)__            assert maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__        } else {_            _            mayHaveBeenIndexBefore = maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__            updateAutoIdTimestamp(index.getAutoGeneratedIdTimestamp(), false)__        }_        return mayHaveBeenIndexBefore__    };returns,true,if,the,indexing,operation,may,have,already,be,processed,by,this,engine,note,that,it,is,ok,to,rarely,return,true,even,if,this,is,not,the,case,however,a,false,return,value,must,always,be,correct;private,boolean,may,have,been,indexed,before,index,index,assert,can,optimize,add,document,index,final,boolean,may,have,been,index,before,if,index,is,retry,may,have,been,index,before,true,update,auto,id,timestamp,index,get,auto,generated,id,timestamp,true,assert,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,else,may,have,been,index,before,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,update,auto,id,timestamp,index,get,auto,generated,id,timestamp,false,return,may,have,been,index,before
InternalEngine -> private boolean mayHaveBeenIndexedBefore(Index index);1549975032;returns true if the indexing operation may have already be processed by this engine._Note that it is OK to rarely return true even if this is not the case. However a `false`_return value must always be correct.;private boolean mayHaveBeenIndexedBefore(Index index) {_        assert canOptimizeAddDocument(index)__        final boolean mayHaveBeenIndexBefore__        if (index.isRetry()) {_            mayHaveBeenIndexBefore = true__            updateAutoIdTimestamp(index.getAutoGeneratedIdTimestamp(), true)__            assert maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__        } else {_            _            mayHaveBeenIndexBefore = maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__            updateAutoIdTimestamp(index.getAutoGeneratedIdTimestamp(), false)__        }_        return mayHaveBeenIndexBefore__    };returns,true,if,the,indexing,operation,may,have,already,be,processed,by,this,engine,note,that,it,is,ok,to,rarely,return,true,even,if,this,is,not,the,case,however,a,false,return,value,must,always,be,correct;private,boolean,may,have,been,indexed,before,index,index,assert,can,optimize,add,document,index,final,boolean,may,have,been,index,before,if,index,is,retry,may,have,been,index,before,true,update,auto,id,timestamp,index,get,auto,generated,id,timestamp,true,assert,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,else,may,have,been,index,before,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,update,auto,id,timestamp,index,get,auto,generated,id,timestamp,false,return,may,have,been,index,before
InternalEngine -> private boolean mayHaveBeenIndexedBefore(Index index);1550220204;returns true if the indexing operation may have already be processed by this engine._Note that it is OK to rarely return true even if this is not the case. However a `false`_return value must always be correct.;private boolean mayHaveBeenIndexedBefore(Index index) {_        assert canOptimizeAddDocument(index)__        final boolean mayHaveBeenIndexBefore__        if (index.isRetry()) {_            mayHaveBeenIndexBefore = true__            updateAutoIdTimestamp(index.getAutoGeneratedIdTimestamp(), true)__            assert maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__        } else {_            _            mayHaveBeenIndexBefore = maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__            updateAutoIdTimestamp(index.getAutoGeneratedIdTimestamp(), false)__        }_        return mayHaveBeenIndexBefore__    };returns,true,if,the,indexing,operation,may,have,already,be,processed,by,this,engine,note,that,it,is,ok,to,rarely,return,true,even,if,this,is,not,the,case,however,a,false,return,value,must,always,be,correct;private,boolean,may,have,been,indexed,before,index,index,assert,can,optimize,add,document,index,final,boolean,may,have,been,index,before,if,index,is,retry,may,have,been,index,before,true,update,auto,id,timestamp,index,get,auto,generated,id,timestamp,true,assert,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,else,may,have,been,index,before,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,update,auto,id,timestamp,index,get,auto,generated,id,timestamp,false,return,may,have,been,index,before
InternalEngine -> private boolean mayHaveBeenIndexedBefore(Index index);1550256122;returns true if the indexing operation may have already be processed by this engine._Note that it is OK to rarely return true even if this is not the case. However a `false`_return value must always be correct.;private boolean mayHaveBeenIndexedBefore(Index index) {_        assert canOptimizeAddDocument(index)__        final boolean mayHaveBeenIndexBefore__        if (index.isRetry()) {_            mayHaveBeenIndexBefore = true__            updateAutoIdTimestamp(index.getAutoGeneratedIdTimestamp(), true)__            assert maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__        } else {_            _            mayHaveBeenIndexBefore = maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__            updateAutoIdTimestamp(index.getAutoGeneratedIdTimestamp(), false)__        }_        return mayHaveBeenIndexBefore__    };returns,true,if,the,indexing,operation,may,have,already,be,processed,by,this,engine,note,that,it,is,ok,to,rarely,return,true,even,if,this,is,not,the,case,however,a,false,return,value,must,always,be,correct;private,boolean,may,have,been,indexed,before,index,index,assert,can,optimize,add,document,index,final,boolean,may,have,been,index,before,if,index,is,retry,may,have,been,index,before,true,update,auto,id,timestamp,index,get,auto,generated,id,timestamp,true,assert,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,else,may,have,been,index,before,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,update,auto,id,timestamp,index,get,auto,generated,id,timestamp,false,return,may,have,been,index,before
InternalEngine -> private boolean mayHaveBeenIndexedBefore(Index index);1550342051;returns true if the indexing operation may have already be processed by this engine._Note that it is OK to rarely return true even if this is not the case. However a `false`_return value must always be correct.;private boolean mayHaveBeenIndexedBefore(Index index) {_        assert canOptimizeAddDocument(index)__        final boolean mayHaveBeenIndexBefore__        if (index.isRetry()) {_            mayHaveBeenIndexBefore = true__            updateAutoIdTimestamp(index.getAutoGeneratedIdTimestamp(), true)__            assert maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__        } else {_            _            mayHaveBeenIndexBefore = maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__            updateAutoIdTimestamp(index.getAutoGeneratedIdTimestamp(), false)__        }_        return mayHaveBeenIndexBefore__    };returns,true,if,the,indexing,operation,may,have,already,be,processed,by,this,engine,note,that,it,is,ok,to,rarely,return,true,even,if,this,is,not,the,case,however,a,false,return,value,must,always,be,correct;private,boolean,may,have,been,indexed,before,index,index,assert,can,optimize,add,document,index,final,boolean,may,have,been,index,before,if,index,is,retry,may,have,been,index,before,true,update,auto,id,timestamp,index,get,auto,generated,id,timestamp,true,assert,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,else,may,have,been,index,before,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,update,auto,id,timestamp,index,get,auto,generated,id,timestamp,false,return,may,have,been,index,before
InternalEngine -> private boolean mayHaveBeenIndexedBefore(Index index);1550526771;returns true if the indexing operation may have already be processed by this engine._Note that it is OK to rarely return true even if this is not the case. However a `false`_return value must always be correct.;private boolean mayHaveBeenIndexedBefore(Index index) {_        assert canOptimizeAddDocument(index)__        final boolean mayHaveBeenIndexBefore__        if (index.isRetry()) {_            mayHaveBeenIndexBefore = true__            updateAutoIdTimestamp(index.getAutoGeneratedIdTimestamp(), true)__            assert maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__        } else {_            _            mayHaveBeenIndexBefore = maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__            updateAutoIdTimestamp(index.getAutoGeneratedIdTimestamp(), false)__        }_        return mayHaveBeenIndexBefore__    };returns,true,if,the,indexing,operation,may,have,already,be,processed,by,this,engine,note,that,it,is,ok,to,rarely,return,true,even,if,this,is,not,the,case,however,a,false,return,value,must,always,be,correct;private,boolean,may,have,been,indexed,before,index,index,assert,can,optimize,add,document,index,final,boolean,may,have,been,index,before,if,index,is,retry,may,have,been,index,before,true,update,auto,id,timestamp,index,get,auto,generated,id,timestamp,true,assert,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,else,may,have,been,index,before,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,update,auto,id,timestamp,index,get,auto,generated,id,timestamp,false,return,may,have,been,index,before
InternalEngine -> private boolean mayHaveBeenIndexedBefore(Index index);1551110274;returns true if the indexing operation may have already be processed by this engine._Note that it is OK to rarely return true even if this is not the case. However a `false`_return value must always be correct.;private boolean mayHaveBeenIndexedBefore(Index index) {_        assert canOptimizeAddDocument(index)__        final boolean mayHaveBeenIndexBefore__        if (index.isRetry()) {_            mayHaveBeenIndexBefore = true__            updateAutoIdTimestamp(index.getAutoGeneratedIdTimestamp(), true)__            assert maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__        } else {_            _            mayHaveBeenIndexBefore = maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__            updateAutoIdTimestamp(index.getAutoGeneratedIdTimestamp(), false)__        }_        return mayHaveBeenIndexBefore__    };returns,true,if,the,indexing,operation,may,have,already,be,processed,by,this,engine,note,that,it,is,ok,to,rarely,return,true,even,if,this,is,not,the,case,however,a,false,return,value,must,always,be,correct;private,boolean,may,have,been,indexed,before,index,index,assert,can,optimize,add,document,index,final,boolean,may,have,been,index,before,if,index,is,retry,may,have,been,index,before,true,update,auto,id,timestamp,index,get,auto,generated,id,timestamp,true,assert,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,else,may,have,been,index,before,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,update,auto,id,timestamp,index,get,auto,generated,id,timestamp,false,return,may,have,been,index,before
InternalEngine -> private boolean mayHaveBeenIndexedBefore(Index index);1551126708;returns true if the indexing operation may have already be processed by this engine._Note that it is OK to rarely return true even if this is not the case. However a `false`_return value must always be correct.;private boolean mayHaveBeenIndexedBefore(Index index) {_        assert canOptimizeAddDocument(index)__        final boolean mayHaveBeenIndexBefore__        if (index.isRetry()) {_            mayHaveBeenIndexBefore = true__            updateAutoIdTimestamp(index.getAutoGeneratedIdTimestamp(), true)__            assert maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__        } else {_            _            mayHaveBeenIndexBefore = maxUnsafeAutoIdTimestamp.get() >= index.getAutoGeneratedIdTimestamp()__            updateAutoIdTimestamp(index.getAutoGeneratedIdTimestamp(), false)__        }_        return mayHaveBeenIndexBefore__    };returns,true,if,the,indexing,operation,may,have,already,be,processed,by,this,engine,note,that,it,is,ok,to,rarely,return,true,even,if,this,is,not,the,case,however,a,false,return,value,must,always,be,correct;private,boolean,may,have,been,indexed,before,index,index,assert,can,optimize,add,document,index,final,boolean,may,have,been,index,before,if,index,is,retry,may,have,been,index,before,true,update,auto,id,timestamp,index,get,auto,generated,id,timestamp,true,assert,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,else,may,have,been,index,before,max,unsafe,auto,id,timestamp,get,index,get,auto,generated,id,timestamp,update,auto,id,timestamp,index,get,auto,generated,id,timestamp,false,return,may,have,been,index,before
InternalEngine -> protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException;1524684173;Commits the specified index writer.__@param writer   the index writer to commit_@param translog the translog_@param syncId   the sync flush ID ({@code null} if not committing a synced flush)_@throws IOException if an I/O exception occurs committing the specfied writer;protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException {_        ensureCanFlush()__        try {_            final long localCheckpoint = localCheckpointTracker.getCheckpoint()__            final Translog.TranslogGeneration translogGeneration = translog.getMinGenerationForSeqNo(localCheckpoint + 1)__            final String translogFileGeneration = Long.toString(translogGeneration.translogFileGeneration)__            final String translogUUID = translogGeneration.translogUUID__            final String localCheckpointValue = Long.toString(localCheckpoint)___            writer.setLiveCommitData(() -> {_                _                final Map<String, String> commitData = new HashMap<>(6)__                commitData.put(Translog.TRANSLOG_GENERATION_KEY, translogFileGeneration)__                commitData.put(Translog.TRANSLOG_UUID_KEY, translogUUID)__                commitData.put(SequenceNumbers.LOCAL_CHECKPOINT_KEY, localCheckpointValue)__                if (syncId != null) {_                    commitData.put(Engine.SYNC_COMMIT_ID, syncId)__                }_                commitData.put(SequenceNumbers.MAX_SEQ_NO, Long.toString(localCheckpointTracker.getMaxSeqNo()))__                commitData.put(MAX_UNSAFE_AUTO_ID_TIMESTAMP_COMMIT_ID, Long.toString(maxUnsafeAutoIdTimestamp.get()))__                commitData.put(HISTORY_UUID_KEY, historyUUID)__                logger.trace("committing writer with commit data [{}]", commitData)__                return commitData.entrySet().iterator()__            })___            writer.commit()__        } catch (final Exception ex) {_            try {_                failEngine("lucene commit failed", ex)__            } catch (final Exception inner) {_                ex.addSuppressed(inner)__            }_            throw ex__        } catch (final AssertionError e) {_            _            if (ExceptionsHelper.stackTrace(e).contains("org.apache.lucene.index.IndexWriter.filesExist")) {_                final EngineException engineException = new EngineException(shardId, "failed to commit engine", e)__                try {_                    failEngine("lucene commit failed", engineException)__                } catch (final Exception inner) {_                    engineException.addSuppressed(inner)__                }_                throw engineException__            } else {_                throw e__            }_        }_    };commits,the,specified,index,writer,param,writer,the,index,writer,to,commit,param,translog,the,translog,param,sync,id,the,sync,flush,id,code,null,if,not,committing,a,synced,flush,throws,ioexception,if,an,i,o,exception,occurs,committing,the,specfied,writer;protected,void,commit,index,writer,final,index,writer,writer,final,translog,translog,nullable,final,string,sync,id,throws,ioexception,ensure,can,flush,try,final,long,local,checkpoint,local,checkpoint,tracker,get,checkpoint,final,translog,translog,generation,translog,generation,translog,get,min,generation,for,seq,no,local,checkpoint,1,final,string,translog,file,generation,long,to,string,translog,generation,translog,file,generation,final,string,translog,uuid,translog,generation,translog,uuid,final,string,local,checkpoint,value,long,to,string,local,checkpoint,writer,set,live,commit,data,final,map,string,string,commit,data,new,hash,map,6,commit,data,put,translog,translog,file,generation,commit,data,put,translog,translog,uuid,commit,data,put,sequence,numbers,local,checkpoint,value,if,sync,id,null,commit,data,put,engine,sync,id,commit,data,put,sequence,numbers,long,to,string,local,checkpoint,tracker,get,max,seq,no,commit,data,put,long,to,string,max,unsafe,auto,id,timestamp,get,commit,data,put,history,uuid,logger,trace,committing,writer,with,commit,data,commit,data,return,commit,data,entry,set,iterator,writer,commit,catch,final,exception,ex,try,fail,engine,lucene,commit,failed,ex,catch,final,exception,inner,ex,add,suppressed,inner,throw,ex,catch,final,assertion,error,e,if,exceptions,helper,stack,trace,e,contains,org,apache,lucene,index,index,writer,files,exist,final,engine,exception,engine,exception,new,engine,exception,shard,id,failed,to,commit,engine,e,try,fail,engine,lucene,commit,failed,engine,exception,catch,final,exception,inner,engine,exception,add,suppressed,inner,throw,engine,exception,else,throw,e
InternalEngine -> protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException;1524780945;Commits the specified index writer.__@param writer   the index writer to commit_@param translog the translog_@param syncId   the sync flush ID ({@code null} if not committing a synced flush)_@throws IOException if an I/O exception occurs committing the specfied writer;protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException {_        ensureCanFlush()__        try {_            final long localCheckpoint = localCheckpointTracker.getCheckpoint()__            final Translog.TranslogGeneration translogGeneration = translog.getMinGenerationForSeqNo(localCheckpoint + 1)__            final String translogFileGeneration = Long.toString(translogGeneration.translogFileGeneration)__            final String translogUUID = translogGeneration.translogUUID__            final String localCheckpointValue = Long.toString(localCheckpoint)___            writer.setLiveCommitData(() -> {_                _                final Map<String, String> commitData = new HashMap<>(6)__                commitData.put(Translog.TRANSLOG_GENERATION_KEY, translogFileGeneration)__                commitData.put(Translog.TRANSLOG_UUID_KEY, translogUUID)__                commitData.put(SequenceNumbers.LOCAL_CHECKPOINT_KEY, localCheckpointValue)__                if (syncId != null) {_                    commitData.put(Engine.SYNC_COMMIT_ID, syncId)__                }_                commitData.put(SequenceNumbers.MAX_SEQ_NO, Long.toString(localCheckpointTracker.getMaxSeqNo()))__                commitData.put(MAX_UNSAFE_AUTO_ID_TIMESTAMP_COMMIT_ID, Long.toString(maxUnsafeAutoIdTimestamp.get()))__                commitData.put(HISTORY_UUID_KEY, historyUUID)__                logger.trace("committing writer with commit data [{}]", commitData)__                return commitData.entrySet().iterator()__            })___            writer.commit()__        } catch (final Exception ex) {_            try {_                failEngine("lucene commit failed", ex)__            } catch (final Exception inner) {_                ex.addSuppressed(inner)__            }_            throw ex__        } catch (final AssertionError e) {_            _            if (ExceptionsHelper.stackTrace(e).contains("org.apache.lucene.index.IndexWriter.filesExist")) {_                final EngineException engineException = new EngineException(shardId, "failed to commit engine", e)__                try {_                    failEngine("lucene commit failed", engineException)__                } catch (final Exception inner) {_                    engineException.addSuppressed(inner)__                }_                throw engineException__            } else {_                throw e__            }_        }_    };commits,the,specified,index,writer,param,writer,the,index,writer,to,commit,param,translog,the,translog,param,sync,id,the,sync,flush,id,code,null,if,not,committing,a,synced,flush,throws,ioexception,if,an,i,o,exception,occurs,committing,the,specfied,writer;protected,void,commit,index,writer,final,index,writer,writer,final,translog,translog,nullable,final,string,sync,id,throws,ioexception,ensure,can,flush,try,final,long,local,checkpoint,local,checkpoint,tracker,get,checkpoint,final,translog,translog,generation,translog,generation,translog,get,min,generation,for,seq,no,local,checkpoint,1,final,string,translog,file,generation,long,to,string,translog,generation,translog,file,generation,final,string,translog,uuid,translog,generation,translog,uuid,final,string,local,checkpoint,value,long,to,string,local,checkpoint,writer,set,live,commit,data,final,map,string,string,commit,data,new,hash,map,6,commit,data,put,translog,translog,file,generation,commit,data,put,translog,translog,uuid,commit,data,put,sequence,numbers,local,checkpoint,value,if,sync,id,null,commit,data,put,engine,sync,id,commit,data,put,sequence,numbers,long,to,string,local,checkpoint,tracker,get,max,seq,no,commit,data,put,long,to,string,max,unsafe,auto,id,timestamp,get,commit,data,put,history,uuid,logger,trace,committing,writer,with,commit,data,commit,data,return,commit,data,entry,set,iterator,writer,commit,catch,final,exception,ex,try,fail,engine,lucene,commit,failed,ex,catch,final,exception,inner,ex,add,suppressed,inner,throw,ex,catch,final,assertion,error,e,if,exceptions,helper,stack,trace,e,contains,org,apache,lucene,index,index,writer,files,exist,final,engine,exception,engine,exception,new,engine,exception,shard,id,failed,to,commit,engine,e,try,fail,engine,lucene,commit,failed,engine,exception,catch,final,exception,inner,engine,exception,add,suppressed,inner,throw,engine,exception,else,throw,e
InternalEngine -> protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException;1525162917;Commits the specified index writer.__@param writer   the index writer to commit_@param translog the translog_@param syncId   the sync flush ID ({@code null} if not committing a synced flush)_@throws IOException if an I/O exception occurs committing the specfied writer;protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException {_        ensureCanFlush()__        try {_            final long localCheckpoint = localCheckpointTracker.getCheckpoint()__            final Translog.TranslogGeneration translogGeneration = translog.getMinGenerationForSeqNo(localCheckpoint + 1)__            final String translogFileGeneration = Long.toString(translogGeneration.translogFileGeneration)__            final String translogUUID = translogGeneration.translogUUID__            final String localCheckpointValue = Long.toString(localCheckpoint)___            writer.setLiveCommitData(() -> {_                _                final Map<String, String> commitData = new HashMap<>(6)__                commitData.put(Translog.TRANSLOG_GENERATION_KEY, translogFileGeneration)__                commitData.put(Translog.TRANSLOG_UUID_KEY, translogUUID)__                commitData.put(SequenceNumbers.LOCAL_CHECKPOINT_KEY, localCheckpointValue)__                if (syncId != null) {_                    commitData.put(Engine.SYNC_COMMIT_ID, syncId)__                }_                commitData.put(SequenceNumbers.MAX_SEQ_NO, Long.toString(localCheckpointTracker.getMaxSeqNo()))__                commitData.put(MAX_UNSAFE_AUTO_ID_TIMESTAMP_COMMIT_ID, Long.toString(maxUnsafeAutoIdTimestamp.get()))__                commitData.put(HISTORY_UUID_KEY, historyUUID)__                logger.trace("committing writer with commit data [{}]", commitData)__                return commitData.entrySet().iterator()__            })___            writer.commit()__        } catch (final Exception ex) {_            try {_                failEngine("lucene commit failed", ex)__            } catch (final Exception inner) {_                ex.addSuppressed(inner)__            }_            throw ex__        } catch (final AssertionError e) {_            _            if (ExceptionsHelper.stackTrace(e).contains("org.apache.lucene.index.IndexWriter.filesExist")) {_                final EngineException engineException = new EngineException(shardId, "failed to commit engine", e)__                try {_                    failEngine("lucene commit failed", engineException)__                } catch (final Exception inner) {_                    engineException.addSuppressed(inner)__                }_                throw engineException__            } else {_                throw e__            }_        }_    };commits,the,specified,index,writer,param,writer,the,index,writer,to,commit,param,translog,the,translog,param,sync,id,the,sync,flush,id,code,null,if,not,committing,a,synced,flush,throws,ioexception,if,an,i,o,exception,occurs,committing,the,specfied,writer;protected,void,commit,index,writer,final,index,writer,writer,final,translog,translog,nullable,final,string,sync,id,throws,ioexception,ensure,can,flush,try,final,long,local,checkpoint,local,checkpoint,tracker,get,checkpoint,final,translog,translog,generation,translog,generation,translog,get,min,generation,for,seq,no,local,checkpoint,1,final,string,translog,file,generation,long,to,string,translog,generation,translog,file,generation,final,string,translog,uuid,translog,generation,translog,uuid,final,string,local,checkpoint,value,long,to,string,local,checkpoint,writer,set,live,commit,data,final,map,string,string,commit,data,new,hash,map,6,commit,data,put,translog,translog,file,generation,commit,data,put,translog,translog,uuid,commit,data,put,sequence,numbers,local,checkpoint,value,if,sync,id,null,commit,data,put,engine,sync,id,commit,data,put,sequence,numbers,long,to,string,local,checkpoint,tracker,get,max,seq,no,commit,data,put,long,to,string,max,unsafe,auto,id,timestamp,get,commit,data,put,history,uuid,logger,trace,committing,writer,with,commit,data,commit,data,return,commit,data,entry,set,iterator,writer,commit,catch,final,exception,ex,try,fail,engine,lucene,commit,failed,ex,catch,final,exception,inner,ex,add,suppressed,inner,throw,ex,catch,final,assertion,error,e,if,exceptions,helper,stack,trace,e,contains,org,apache,lucene,index,index,writer,files,exist,final,engine,exception,engine,exception,new,engine,exception,shard,id,failed,to,commit,engine,e,try,fail,engine,lucene,commit,failed,engine,exception,catch,final,exception,inner,engine,exception,add,suppressed,inner,throw,engine,exception,else,throw,e
InternalEngine -> protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException;1528706846;Commits the specified index writer.__@param writer   the index writer to commit_@param translog the translog_@param syncId   the sync flush ID ({@code null} if not committing a synced flush)_@throws IOException if an I/O exception occurs committing the specfied writer;protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException {_        ensureCanFlush()__        try {_            final long localCheckpoint = localCheckpointTracker.getCheckpoint()__            final Translog.TranslogGeneration translogGeneration = translog.getMinGenerationForSeqNo(localCheckpoint + 1)__            final String translogFileGeneration = Long.toString(translogGeneration.translogFileGeneration)__            final String translogUUID = translogGeneration.translogUUID__            final String localCheckpointValue = Long.toString(localCheckpoint)___            writer.setLiveCommitData(() -> {_                _                final Map<String, String> commitData = new HashMap<>(6)__                commitData.put(Translog.TRANSLOG_GENERATION_KEY, translogFileGeneration)__                commitData.put(Translog.TRANSLOG_UUID_KEY, translogUUID)__                commitData.put(SequenceNumbers.LOCAL_CHECKPOINT_KEY, localCheckpointValue)__                if (syncId != null) {_                    commitData.put(Engine.SYNC_COMMIT_ID, syncId)__                }_                commitData.put(SequenceNumbers.MAX_SEQ_NO, Long.toString(localCheckpointTracker.getMaxSeqNo()))__                commitData.put(MAX_UNSAFE_AUTO_ID_TIMESTAMP_COMMIT_ID, Long.toString(maxUnsafeAutoIdTimestamp.get()))__                commitData.put(HISTORY_UUID_KEY, historyUUID)__                logger.trace("committing writer with commit data [{}]", commitData)__                return commitData.entrySet().iterator()__            })___            writer.commit()__        } catch (final Exception ex) {_            try {_                failEngine("lucene commit failed", ex)__            } catch (final Exception inner) {_                ex.addSuppressed(inner)__            }_            throw ex__        } catch (final AssertionError e) {_            _            if (ExceptionsHelper.stackTrace(e).contains("org.apache.lucene.index.IndexWriter.filesExist")) {_                final EngineException engineException = new EngineException(shardId, "failed to commit engine", e)__                try {_                    failEngine("lucene commit failed", engineException)__                } catch (final Exception inner) {_                    engineException.addSuppressed(inner)__                }_                throw engineException__            } else {_                throw e__            }_        }_    };commits,the,specified,index,writer,param,writer,the,index,writer,to,commit,param,translog,the,translog,param,sync,id,the,sync,flush,id,code,null,if,not,committing,a,synced,flush,throws,ioexception,if,an,i,o,exception,occurs,committing,the,specfied,writer;protected,void,commit,index,writer,final,index,writer,writer,final,translog,translog,nullable,final,string,sync,id,throws,ioexception,ensure,can,flush,try,final,long,local,checkpoint,local,checkpoint,tracker,get,checkpoint,final,translog,translog,generation,translog,generation,translog,get,min,generation,for,seq,no,local,checkpoint,1,final,string,translog,file,generation,long,to,string,translog,generation,translog,file,generation,final,string,translog,uuid,translog,generation,translog,uuid,final,string,local,checkpoint,value,long,to,string,local,checkpoint,writer,set,live,commit,data,final,map,string,string,commit,data,new,hash,map,6,commit,data,put,translog,translog,file,generation,commit,data,put,translog,translog,uuid,commit,data,put,sequence,numbers,local,checkpoint,value,if,sync,id,null,commit,data,put,engine,sync,id,commit,data,put,sequence,numbers,long,to,string,local,checkpoint,tracker,get,max,seq,no,commit,data,put,long,to,string,max,unsafe,auto,id,timestamp,get,commit,data,put,history,uuid,logger,trace,committing,writer,with,commit,data,commit,data,return,commit,data,entry,set,iterator,writer,commit,catch,final,exception,ex,try,fail,engine,lucene,commit,failed,ex,catch,final,exception,inner,ex,add,suppressed,inner,throw,ex,catch,final,assertion,error,e,if,exceptions,helper,stack,trace,e,contains,org,apache,lucene,index,index,writer,files,exist,final,engine,exception,engine,exception,new,engine,exception,shard,id,failed,to,commit,engine,e,try,fail,engine,lucene,commit,failed,engine,exception,catch,final,exception,inner,engine,exception,add,suppressed,inner,throw,engine,exception,else,throw,e
InternalEngine -> protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException;1528762805;Commits the specified index writer.__@param writer   the index writer to commit_@param translog the translog_@param syncId   the sync flush ID ({@code null} if not committing a synced flush)_@throws IOException if an I/O exception occurs committing the specfied writer;protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException {_        ensureCanFlush()__        try {_            final long localCheckpoint = localCheckpointTracker.getCheckpoint()__            final Translog.TranslogGeneration translogGeneration = translog.getMinGenerationForSeqNo(localCheckpoint + 1)__            final String translogFileGeneration = Long.toString(translogGeneration.translogFileGeneration)__            final String translogUUID = translogGeneration.translogUUID__            final String localCheckpointValue = Long.toString(localCheckpoint)___            writer.setLiveCommitData(() -> {_                _                final Map<String, String> commitData = new HashMap<>(6)__                commitData.put(Translog.TRANSLOG_GENERATION_KEY, translogFileGeneration)__                commitData.put(Translog.TRANSLOG_UUID_KEY, translogUUID)__                commitData.put(SequenceNumbers.LOCAL_CHECKPOINT_KEY, localCheckpointValue)__                if (syncId != null) {_                    commitData.put(Engine.SYNC_COMMIT_ID, syncId)__                }_                commitData.put(SequenceNumbers.MAX_SEQ_NO, Long.toString(localCheckpointTracker.getMaxSeqNo()))__                commitData.put(MAX_UNSAFE_AUTO_ID_TIMESTAMP_COMMIT_ID, Long.toString(maxUnsafeAutoIdTimestamp.get()))__                commitData.put(HISTORY_UUID_KEY, historyUUID)__                logger.trace("committing writer with commit data [{}]", commitData)__                return commitData.entrySet().iterator()__            })___            writer.commit()__        } catch (final Exception ex) {_            try {_                failEngine("lucene commit failed", ex)__            } catch (final Exception inner) {_                ex.addSuppressed(inner)__            }_            throw ex__        } catch (final AssertionError e) {_            _            if (ExceptionsHelper.stackTrace(e).contains("org.apache.lucene.index.IndexWriter.filesExist")) {_                final EngineException engineException = new EngineException(shardId, "failed to commit engine", e)__                try {_                    failEngine("lucene commit failed", engineException)__                } catch (final Exception inner) {_                    engineException.addSuppressed(inner)__                }_                throw engineException__            } else {_                throw e__            }_        }_    };commits,the,specified,index,writer,param,writer,the,index,writer,to,commit,param,translog,the,translog,param,sync,id,the,sync,flush,id,code,null,if,not,committing,a,synced,flush,throws,ioexception,if,an,i,o,exception,occurs,committing,the,specfied,writer;protected,void,commit,index,writer,final,index,writer,writer,final,translog,translog,nullable,final,string,sync,id,throws,ioexception,ensure,can,flush,try,final,long,local,checkpoint,local,checkpoint,tracker,get,checkpoint,final,translog,translog,generation,translog,generation,translog,get,min,generation,for,seq,no,local,checkpoint,1,final,string,translog,file,generation,long,to,string,translog,generation,translog,file,generation,final,string,translog,uuid,translog,generation,translog,uuid,final,string,local,checkpoint,value,long,to,string,local,checkpoint,writer,set,live,commit,data,final,map,string,string,commit,data,new,hash,map,6,commit,data,put,translog,translog,file,generation,commit,data,put,translog,translog,uuid,commit,data,put,sequence,numbers,local,checkpoint,value,if,sync,id,null,commit,data,put,engine,sync,id,commit,data,put,sequence,numbers,long,to,string,local,checkpoint,tracker,get,max,seq,no,commit,data,put,long,to,string,max,unsafe,auto,id,timestamp,get,commit,data,put,history,uuid,logger,trace,committing,writer,with,commit,data,commit,data,return,commit,data,entry,set,iterator,writer,commit,catch,final,exception,ex,try,fail,engine,lucene,commit,failed,ex,catch,final,exception,inner,ex,add,suppressed,inner,throw,ex,catch,final,assertion,error,e,if,exceptions,helper,stack,trace,e,contains,org,apache,lucene,index,index,writer,files,exist,final,engine,exception,engine,exception,new,engine,exception,shard,id,failed,to,commit,engine,e,try,fail,engine,lucene,commit,failed,engine,exception,catch,final,exception,inner,engine,exception,add,suppressed,inner,throw,engine,exception,else,throw,e
InternalEngine -> protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException;1531910483;Commits the specified index writer.__@param writer   the index writer to commit_@param translog the translog_@param syncId   the sync flush ID ({@code null} if not committing a synced flush)_@throws IOException if an I/O exception occurs committing the specfied writer;protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException {_        ensureCanFlush()__        try {_            final long localCheckpoint = localCheckpointTracker.getCheckpoint()__            final Translog.TranslogGeneration translogGeneration = translog.getMinGenerationForSeqNo(localCheckpoint + 1)__            final String translogFileGeneration = Long.toString(translogGeneration.translogFileGeneration)__            final String translogUUID = translogGeneration.translogUUID__            final String localCheckpointValue = Long.toString(localCheckpoint)___            writer.setLiveCommitData(() -> {_                _                final Map<String, String> commitData = new HashMap<>(6)__                commitData.put(Translog.TRANSLOG_GENERATION_KEY, translogFileGeneration)__                commitData.put(Translog.TRANSLOG_UUID_KEY, translogUUID)__                commitData.put(SequenceNumbers.LOCAL_CHECKPOINT_KEY, localCheckpointValue)__                if (syncId != null) {_                    commitData.put(Engine.SYNC_COMMIT_ID, syncId)__                }_                commitData.put(SequenceNumbers.MAX_SEQ_NO, Long.toString(localCheckpointTracker.getMaxSeqNo()))__                commitData.put(MAX_UNSAFE_AUTO_ID_TIMESTAMP_COMMIT_ID, Long.toString(maxUnsafeAutoIdTimestamp.get()))__                commitData.put(HISTORY_UUID_KEY, historyUUID)__                logger.trace("committing writer with commit data [{}]", commitData)__                return commitData.entrySet().iterator()__            })___            writer.commit()__        } catch (final Exception ex) {_            try {_                failEngine("lucene commit failed", ex)__            } catch (final Exception inner) {_                ex.addSuppressed(inner)__            }_            throw ex__        } catch (final AssertionError e) {_            _            if (ExceptionsHelper.stackTrace(e).contains("org.apache.lucene.index.IndexWriter.filesExist")) {_                final EngineException engineException = new EngineException(shardId, "failed to commit engine", e)__                try {_                    failEngine("lucene commit failed", engineException)__                } catch (final Exception inner) {_                    engineException.addSuppressed(inner)__                }_                throw engineException__            } else {_                throw e__            }_        }_    };commits,the,specified,index,writer,param,writer,the,index,writer,to,commit,param,translog,the,translog,param,sync,id,the,sync,flush,id,code,null,if,not,committing,a,synced,flush,throws,ioexception,if,an,i,o,exception,occurs,committing,the,specfied,writer;protected,void,commit,index,writer,final,index,writer,writer,final,translog,translog,nullable,final,string,sync,id,throws,ioexception,ensure,can,flush,try,final,long,local,checkpoint,local,checkpoint,tracker,get,checkpoint,final,translog,translog,generation,translog,generation,translog,get,min,generation,for,seq,no,local,checkpoint,1,final,string,translog,file,generation,long,to,string,translog,generation,translog,file,generation,final,string,translog,uuid,translog,generation,translog,uuid,final,string,local,checkpoint,value,long,to,string,local,checkpoint,writer,set,live,commit,data,final,map,string,string,commit,data,new,hash,map,6,commit,data,put,translog,translog,file,generation,commit,data,put,translog,translog,uuid,commit,data,put,sequence,numbers,local,checkpoint,value,if,sync,id,null,commit,data,put,engine,sync,id,commit,data,put,sequence,numbers,long,to,string,local,checkpoint,tracker,get,max,seq,no,commit,data,put,long,to,string,max,unsafe,auto,id,timestamp,get,commit,data,put,history,uuid,logger,trace,committing,writer,with,commit,data,commit,data,return,commit,data,entry,set,iterator,writer,commit,catch,final,exception,ex,try,fail,engine,lucene,commit,failed,ex,catch,final,exception,inner,ex,add,suppressed,inner,throw,ex,catch,final,assertion,error,e,if,exceptions,helper,stack,trace,e,contains,org,apache,lucene,index,index,writer,files,exist,final,engine,exception,engine,exception,new,engine,exception,shard,id,failed,to,commit,engine,e,try,fail,engine,lucene,commit,failed,engine,exception,catch,final,exception,inner,engine,exception,add,suppressed,inner,throw,engine,exception,else,throw,e
InternalEngine -> protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException;1533295538;Commits the specified index writer.__@param writer   the index writer to commit_@param translog the translog_@param syncId   the sync flush ID ({@code null} if not committing a synced flush)_@throws IOException if an I/O exception occurs committing the specfied writer;protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException {_        ensureCanFlush()__        try {_            final long localCheckpoint = localCheckpointTracker.getCheckpoint()__            final Translog.TranslogGeneration translogGeneration = translog.getMinGenerationForSeqNo(localCheckpoint + 1)__            final String translogFileGeneration = Long.toString(translogGeneration.translogFileGeneration)__            final String translogUUID = translogGeneration.translogUUID__            final String localCheckpointValue = Long.toString(localCheckpoint)___            writer.setLiveCommitData(() -> {_                _                final Map<String, String> commitData = new HashMap<>(6)__                commitData.put(Translog.TRANSLOG_GENERATION_KEY, translogFileGeneration)__                commitData.put(Translog.TRANSLOG_UUID_KEY, translogUUID)__                commitData.put(SequenceNumbers.LOCAL_CHECKPOINT_KEY, localCheckpointValue)__                if (syncId != null) {_                    commitData.put(Engine.SYNC_COMMIT_ID, syncId)__                }_                commitData.put(SequenceNumbers.MAX_SEQ_NO, Long.toString(localCheckpointTracker.getMaxSeqNo()))__                commitData.put(MAX_UNSAFE_AUTO_ID_TIMESTAMP_COMMIT_ID, Long.toString(maxUnsafeAutoIdTimestamp.get()))__                commitData.put(HISTORY_UUID_KEY, historyUUID)__                logger.trace("committing writer with commit data [{}]", commitData)__                return commitData.entrySet().iterator()__            })___            writer.commit()__        } catch (final Exception ex) {_            try {_                failEngine("lucene commit failed", ex)__            } catch (final Exception inner) {_                ex.addSuppressed(inner)__            }_            throw ex__        } catch (final AssertionError e) {_            _            if (ExceptionsHelper.stackTrace(e).contains("org.apache.lucene.index.IndexWriter.filesExist")) {_                final EngineException engineException = new EngineException(shardId, "failed to commit engine", e)__                try {_                    failEngine("lucene commit failed", engineException)__                } catch (final Exception inner) {_                    engineException.addSuppressed(inner)__                }_                throw engineException__            } else {_                throw e__            }_        }_    };commits,the,specified,index,writer,param,writer,the,index,writer,to,commit,param,translog,the,translog,param,sync,id,the,sync,flush,id,code,null,if,not,committing,a,synced,flush,throws,ioexception,if,an,i,o,exception,occurs,committing,the,specfied,writer;protected,void,commit,index,writer,final,index,writer,writer,final,translog,translog,nullable,final,string,sync,id,throws,ioexception,ensure,can,flush,try,final,long,local,checkpoint,local,checkpoint,tracker,get,checkpoint,final,translog,translog,generation,translog,generation,translog,get,min,generation,for,seq,no,local,checkpoint,1,final,string,translog,file,generation,long,to,string,translog,generation,translog,file,generation,final,string,translog,uuid,translog,generation,translog,uuid,final,string,local,checkpoint,value,long,to,string,local,checkpoint,writer,set,live,commit,data,final,map,string,string,commit,data,new,hash,map,6,commit,data,put,translog,translog,file,generation,commit,data,put,translog,translog,uuid,commit,data,put,sequence,numbers,local,checkpoint,value,if,sync,id,null,commit,data,put,engine,sync,id,commit,data,put,sequence,numbers,long,to,string,local,checkpoint,tracker,get,max,seq,no,commit,data,put,long,to,string,max,unsafe,auto,id,timestamp,get,commit,data,put,history,uuid,logger,trace,committing,writer,with,commit,data,commit,data,return,commit,data,entry,set,iterator,writer,commit,catch,final,exception,ex,try,fail,engine,lucene,commit,failed,ex,catch,final,exception,inner,ex,add,suppressed,inner,throw,ex,catch,final,assertion,error,e,if,exceptions,helper,stack,trace,e,contains,org,apache,lucene,index,index,writer,files,exist,final,engine,exception,engine,exception,new,engine,exception,shard,id,failed,to,commit,engine,e,try,fail,engine,lucene,commit,failed,engine,exception,catch,final,exception,inner,engine,exception,add,suppressed,inner,throw,engine,exception,else,throw,e
InternalEngine -> protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException;1534848846;Commits the specified index writer.__@param writer   the index writer to commit_@param translog the translog_@param syncId   the sync flush ID ({@code null} if not committing a synced flush)_@throws IOException if an I/O exception occurs committing the specfied writer;protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException {_        ensureCanFlush()__        try {_            final long localCheckpoint = localCheckpointTracker.getCheckpoint()__            final Translog.TranslogGeneration translogGeneration = translog.getMinGenerationForSeqNo(localCheckpoint + 1)__            final String translogFileGeneration = Long.toString(translogGeneration.translogFileGeneration)__            final String translogUUID = translogGeneration.translogUUID__            final String localCheckpointValue = Long.toString(localCheckpoint)___            writer.setLiveCommitData(() -> {_                _                final Map<String, String> commitData = new HashMap<>(6)__                commitData.put(Translog.TRANSLOG_GENERATION_KEY, translogFileGeneration)__                commitData.put(Translog.TRANSLOG_UUID_KEY, translogUUID)__                commitData.put(SequenceNumbers.LOCAL_CHECKPOINT_KEY, localCheckpointValue)__                if (syncId != null) {_                    commitData.put(Engine.SYNC_COMMIT_ID, syncId)__                }_                commitData.put(SequenceNumbers.MAX_SEQ_NO, Long.toString(localCheckpointTracker.getMaxSeqNo()))__                commitData.put(MAX_UNSAFE_AUTO_ID_TIMESTAMP_COMMIT_ID, Long.toString(maxUnsafeAutoIdTimestamp.get()))__                commitData.put(HISTORY_UUID_KEY, historyUUID)__                logger.trace("committing writer with commit data [{}]", commitData)__                return commitData.entrySet().iterator()__            })___            writer.commit()__        } catch (final Exception ex) {_            try {_                failEngine("lucene commit failed", ex)__            } catch (final Exception inner) {_                ex.addSuppressed(inner)__            }_            throw ex__        } catch (final AssertionError e) {_            _            if (ExceptionsHelper.stackTrace(e).contains("org.apache.lucene.index.IndexWriter.filesExist")) {_                final EngineException engineException = new EngineException(shardId, "failed to commit engine", e)__                try {_                    failEngine("lucene commit failed", engineException)__                } catch (final Exception inner) {_                    engineException.addSuppressed(inner)__                }_                throw engineException__            } else {_                throw e__            }_        }_    };commits,the,specified,index,writer,param,writer,the,index,writer,to,commit,param,translog,the,translog,param,sync,id,the,sync,flush,id,code,null,if,not,committing,a,synced,flush,throws,ioexception,if,an,i,o,exception,occurs,committing,the,specfied,writer;protected,void,commit,index,writer,final,index,writer,writer,final,translog,translog,nullable,final,string,sync,id,throws,ioexception,ensure,can,flush,try,final,long,local,checkpoint,local,checkpoint,tracker,get,checkpoint,final,translog,translog,generation,translog,generation,translog,get,min,generation,for,seq,no,local,checkpoint,1,final,string,translog,file,generation,long,to,string,translog,generation,translog,file,generation,final,string,translog,uuid,translog,generation,translog,uuid,final,string,local,checkpoint,value,long,to,string,local,checkpoint,writer,set,live,commit,data,final,map,string,string,commit,data,new,hash,map,6,commit,data,put,translog,translog,file,generation,commit,data,put,translog,translog,uuid,commit,data,put,sequence,numbers,local,checkpoint,value,if,sync,id,null,commit,data,put,engine,sync,id,commit,data,put,sequence,numbers,long,to,string,local,checkpoint,tracker,get,max,seq,no,commit,data,put,long,to,string,max,unsafe,auto,id,timestamp,get,commit,data,put,history,uuid,logger,trace,committing,writer,with,commit,data,commit,data,return,commit,data,entry,set,iterator,writer,commit,catch,final,exception,ex,try,fail,engine,lucene,commit,failed,ex,catch,final,exception,inner,ex,add,suppressed,inner,throw,ex,catch,final,assertion,error,e,if,exceptions,helper,stack,trace,e,contains,org,apache,lucene,index,index,writer,files,exist,final,engine,exception,engine,exception,new,engine,exception,shard,id,failed,to,commit,engine,e,try,fail,engine,lucene,commit,failed,engine,exception,catch,final,exception,inner,engine,exception,add,suppressed,inner,throw,engine,exception,else,throw,e
InternalEngine -> protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException;1535046779;Commits the specified index writer.__@param writer   the index writer to commit_@param translog the translog_@param syncId   the sync flush ID ({@code null} if not committing a synced flush)_@throws IOException if an I/O exception occurs committing the specfied writer;protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException {_        ensureCanFlush()__        try {_            final long localCheckpoint = localCheckpointTracker.getCheckpoint()__            final Translog.TranslogGeneration translogGeneration = translog.getMinGenerationForSeqNo(localCheckpoint + 1)__            final String translogFileGeneration = Long.toString(translogGeneration.translogFileGeneration)__            final String translogUUID = translogGeneration.translogUUID__            final String localCheckpointValue = Long.toString(localCheckpoint)___            writer.setLiveCommitData(() -> {_                _                final Map<String, String> commitData = new HashMap<>(6)__                commitData.put(Translog.TRANSLOG_GENERATION_KEY, translogFileGeneration)__                commitData.put(Translog.TRANSLOG_UUID_KEY, translogUUID)__                commitData.put(SequenceNumbers.LOCAL_CHECKPOINT_KEY, localCheckpointValue)__                if (syncId != null) {_                    commitData.put(Engine.SYNC_COMMIT_ID, syncId)__                }_                commitData.put(SequenceNumbers.MAX_SEQ_NO, Long.toString(localCheckpointTracker.getMaxSeqNo()))__                commitData.put(MAX_UNSAFE_AUTO_ID_TIMESTAMP_COMMIT_ID, Long.toString(maxUnsafeAutoIdTimestamp.get()))__                commitData.put(HISTORY_UUID_KEY, historyUUID)__                logger.trace("committing writer with commit data [{}]", commitData)__                return commitData.entrySet().iterator()__            })___            writer.commit()__        } catch (final Exception ex) {_            try {_                failEngine("lucene commit failed", ex)__            } catch (final Exception inner) {_                ex.addSuppressed(inner)__            }_            throw ex__        } catch (final AssertionError e) {_            _            if (ExceptionsHelper.stackTrace(e).contains("org.apache.lucene.index.IndexWriter.filesExist")) {_                final EngineException engineException = new EngineException(shardId, "failed to commit engine", e)__                try {_                    failEngine("lucene commit failed", engineException)__                } catch (final Exception inner) {_                    engineException.addSuppressed(inner)__                }_                throw engineException__            } else {_                throw e__            }_        }_    };commits,the,specified,index,writer,param,writer,the,index,writer,to,commit,param,translog,the,translog,param,sync,id,the,sync,flush,id,code,null,if,not,committing,a,synced,flush,throws,ioexception,if,an,i,o,exception,occurs,committing,the,specfied,writer;protected,void,commit,index,writer,final,index,writer,writer,final,translog,translog,nullable,final,string,sync,id,throws,ioexception,ensure,can,flush,try,final,long,local,checkpoint,local,checkpoint,tracker,get,checkpoint,final,translog,translog,generation,translog,generation,translog,get,min,generation,for,seq,no,local,checkpoint,1,final,string,translog,file,generation,long,to,string,translog,generation,translog,file,generation,final,string,translog,uuid,translog,generation,translog,uuid,final,string,local,checkpoint,value,long,to,string,local,checkpoint,writer,set,live,commit,data,final,map,string,string,commit,data,new,hash,map,6,commit,data,put,translog,translog,file,generation,commit,data,put,translog,translog,uuid,commit,data,put,sequence,numbers,local,checkpoint,value,if,sync,id,null,commit,data,put,engine,sync,id,commit,data,put,sequence,numbers,long,to,string,local,checkpoint,tracker,get,max,seq,no,commit,data,put,long,to,string,max,unsafe,auto,id,timestamp,get,commit,data,put,history,uuid,logger,trace,committing,writer,with,commit,data,commit,data,return,commit,data,entry,set,iterator,writer,commit,catch,final,exception,ex,try,fail,engine,lucene,commit,failed,ex,catch,final,exception,inner,ex,add,suppressed,inner,throw,ex,catch,final,assertion,error,e,if,exceptions,helper,stack,trace,e,contains,org,apache,lucene,index,index,writer,files,exist,final,engine,exception,engine,exception,new,engine,exception,shard,id,failed,to,commit,engine,e,try,fail,engine,lucene,commit,failed,engine,exception,catch,final,exception,inner,engine,exception,add,suppressed,inner,throw,engine,exception,else,throw,e
InternalEngine -> protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException;1535405719;Commits the specified index writer.__@param writer   the index writer to commit_@param translog the translog_@param syncId   the sync flush ID ({@code null} if not committing a synced flush)_@throws IOException if an I/O exception occurs committing the specfied writer;protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException {_        ensureCanFlush()__        try {_            final long localCheckpoint = localCheckpointTracker.getCheckpoint()__            final Translog.TranslogGeneration translogGeneration = translog.getMinGenerationForSeqNo(localCheckpoint + 1)__            final String translogFileGeneration = Long.toString(translogGeneration.translogFileGeneration)__            final String translogUUID = translogGeneration.translogUUID__            final String localCheckpointValue = Long.toString(localCheckpoint)___            writer.setLiveCommitData(() -> {_                _                final Map<String, String> commitData = new HashMap<>(6)__                commitData.put(Translog.TRANSLOG_GENERATION_KEY, translogFileGeneration)__                commitData.put(Translog.TRANSLOG_UUID_KEY, translogUUID)__                commitData.put(SequenceNumbers.LOCAL_CHECKPOINT_KEY, localCheckpointValue)__                if (syncId != null) {_                    commitData.put(Engine.SYNC_COMMIT_ID, syncId)__                }_                commitData.put(SequenceNumbers.MAX_SEQ_NO, Long.toString(localCheckpointTracker.getMaxSeqNo()))__                commitData.put(MAX_UNSAFE_AUTO_ID_TIMESTAMP_COMMIT_ID, Long.toString(maxUnsafeAutoIdTimestamp.get()))__                commitData.put(HISTORY_UUID_KEY, historyUUID)__                logger.trace("committing writer with commit data [{}]", commitData)__                return commitData.entrySet().iterator()__            })___            writer.commit()__        } catch (final Exception ex) {_            try {_                failEngine("lucene commit failed", ex)__            } catch (final Exception inner) {_                ex.addSuppressed(inner)__            }_            throw ex__        } catch (final AssertionError e) {_            _            if (ExceptionsHelper.stackTrace(e).contains("org.apache.lucene.index.IndexWriter.filesExist")) {_                final EngineException engineException = new EngineException(shardId, "failed to commit engine", e)__                try {_                    failEngine("lucene commit failed", engineException)__                } catch (final Exception inner) {_                    engineException.addSuppressed(inner)__                }_                throw engineException__            } else {_                throw e__            }_        }_    };commits,the,specified,index,writer,param,writer,the,index,writer,to,commit,param,translog,the,translog,param,sync,id,the,sync,flush,id,code,null,if,not,committing,a,synced,flush,throws,ioexception,if,an,i,o,exception,occurs,committing,the,specfied,writer;protected,void,commit,index,writer,final,index,writer,writer,final,translog,translog,nullable,final,string,sync,id,throws,ioexception,ensure,can,flush,try,final,long,local,checkpoint,local,checkpoint,tracker,get,checkpoint,final,translog,translog,generation,translog,generation,translog,get,min,generation,for,seq,no,local,checkpoint,1,final,string,translog,file,generation,long,to,string,translog,generation,translog,file,generation,final,string,translog,uuid,translog,generation,translog,uuid,final,string,local,checkpoint,value,long,to,string,local,checkpoint,writer,set,live,commit,data,final,map,string,string,commit,data,new,hash,map,6,commit,data,put,translog,translog,file,generation,commit,data,put,translog,translog,uuid,commit,data,put,sequence,numbers,local,checkpoint,value,if,sync,id,null,commit,data,put,engine,sync,id,commit,data,put,sequence,numbers,long,to,string,local,checkpoint,tracker,get,max,seq,no,commit,data,put,long,to,string,max,unsafe,auto,id,timestamp,get,commit,data,put,history,uuid,logger,trace,committing,writer,with,commit,data,commit,data,return,commit,data,entry,set,iterator,writer,commit,catch,final,exception,ex,try,fail,engine,lucene,commit,failed,ex,catch,final,exception,inner,ex,add,suppressed,inner,throw,ex,catch,final,assertion,error,e,if,exceptions,helper,stack,trace,e,contains,org,apache,lucene,index,index,writer,files,exist,final,engine,exception,engine,exception,new,engine,exception,shard,id,failed,to,commit,engine,e,try,fail,engine,lucene,commit,failed,engine,exception,catch,final,exception,inner,engine,exception,add,suppressed,inner,throw,engine,exception,else,throw,e
InternalEngine -> protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException;1535723122;Commits the specified index writer.__@param writer   the index writer to commit_@param translog the translog_@param syncId   the sync flush ID ({@code null} if not committing a synced flush)_@throws IOException if an I/O exception occurs committing the specfied writer;protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException {_        ensureCanFlush()__        try {_            final long localCheckpoint = localCheckpointTracker.getCheckpoint()__            final Translog.TranslogGeneration translogGeneration = translog.getMinGenerationForSeqNo(localCheckpoint + 1)__            final String translogFileGeneration = Long.toString(translogGeneration.translogFileGeneration)__            final String translogUUID = translogGeneration.translogUUID__            final String localCheckpointValue = Long.toString(localCheckpoint)___            writer.setLiveCommitData(() -> {_                _                final Map<String, String> commitData = new HashMap<>(6)__                commitData.put(Translog.TRANSLOG_GENERATION_KEY, translogFileGeneration)__                commitData.put(Translog.TRANSLOG_UUID_KEY, translogUUID)__                commitData.put(SequenceNumbers.LOCAL_CHECKPOINT_KEY, localCheckpointValue)__                if (syncId != null) {_                    commitData.put(Engine.SYNC_COMMIT_ID, syncId)__                }_                commitData.put(SequenceNumbers.MAX_SEQ_NO, Long.toString(localCheckpointTracker.getMaxSeqNo()))__                commitData.put(MAX_UNSAFE_AUTO_ID_TIMESTAMP_COMMIT_ID, Long.toString(maxUnsafeAutoIdTimestamp.get()))__                commitData.put(HISTORY_UUID_KEY, historyUUID)__                if (softDeleteEnabled) {_                    commitData.put(Engine.MIN_RETAINED_SEQNO, Long.toString(softDeletesPolicy.getMinRetainedSeqNo()))__                }_                logger.trace("committing writer with commit data [{}]", commitData)__                return commitData.entrySet().iterator()__            })___            writer.commit()__        } catch (final Exception ex) {_            try {_                failEngine("lucene commit failed", ex)__            } catch (final Exception inner) {_                ex.addSuppressed(inner)__            }_            throw ex__        } catch (final AssertionError e) {_            _            if (ExceptionsHelper.stackTrace(e).contains("org.apache.lucene.index.IndexWriter.filesExist")) {_                final EngineException engineException = new EngineException(shardId, "failed to commit engine", e)__                try {_                    failEngine("lucene commit failed", engineException)__                } catch (final Exception inner) {_                    engineException.addSuppressed(inner)__                }_                throw engineException__            } else {_                throw e__            }_        }_    };commits,the,specified,index,writer,param,writer,the,index,writer,to,commit,param,translog,the,translog,param,sync,id,the,sync,flush,id,code,null,if,not,committing,a,synced,flush,throws,ioexception,if,an,i,o,exception,occurs,committing,the,specfied,writer;protected,void,commit,index,writer,final,index,writer,writer,final,translog,translog,nullable,final,string,sync,id,throws,ioexception,ensure,can,flush,try,final,long,local,checkpoint,local,checkpoint,tracker,get,checkpoint,final,translog,translog,generation,translog,generation,translog,get,min,generation,for,seq,no,local,checkpoint,1,final,string,translog,file,generation,long,to,string,translog,generation,translog,file,generation,final,string,translog,uuid,translog,generation,translog,uuid,final,string,local,checkpoint,value,long,to,string,local,checkpoint,writer,set,live,commit,data,final,map,string,string,commit,data,new,hash,map,6,commit,data,put,translog,translog,file,generation,commit,data,put,translog,translog,uuid,commit,data,put,sequence,numbers,local,checkpoint,value,if,sync,id,null,commit,data,put,engine,sync,id,commit,data,put,sequence,numbers,long,to,string,local,checkpoint,tracker,get,max,seq,no,commit,data,put,long,to,string,max,unsafe,auto,id,timestamp,get,commit,data,put,history,uuid,if,soft,delete,enabled,commit,data,put,engine,long,to,string,soft,deletes,policy,get,min,retained,seq,no,logger,trace,committing,writer,with,commit,data,commit,data,return,commit,data,entry,set,iterator,writer,commit,catch,final,exception,ex,try,fail,engine,lucene,commit,failed,ex,catch,final,exception,inner,ex,add,suppressed,inner,throw,ex,catch,final,assertion,error,e,if,exceptions,helper,stack,trace,e,contains,org,apache,lucene,index,index,writer,files,exist,final,engine,exception,engine,exception,new,engine,exception,shard,id,failed,to,commit,engine,e,try,fail,engine,lucene,commit,failed,engine,exception,catch,final,exception,inner,engine,exception,add,suppressed,inner,throw,engine,exception,else,throw,e
InternalEngine -> protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException;1535965276;Commits the specified index writer.__@param writer   the index writer to commit_@param translog the translog_@param syncId   the sync flush ID ({@code null} if not committing a synced flush)_@throws IOException if an I/O exception occurs committing the specfied writer;protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException {_        ensureCanFlush()__        try {_            final long localCheckpoint = localCheckpointTracker.getCheckpoint()__            final Translog.TranslogGeneration translogGeneration = translog.getMinGenerationForSeqNo(localCheckpoint + 1)__            final String translogFileGeneration = Long.toString(translogGeneration.translogFileGeneration)__            final String translogUUID = translogGeneration.translogUUID__            final String localCheckpointValue = Long.toString(localCheckpoint)___            writer.setLiveCommitData(() -> {_                _                final Map<String, String> commitData = new HashMap<>(6)__                commitData.put(Translog.TRANSLOG_GENERATION_KEY, translogFileGeneration)__                commitData.put(Translog.TRANSLOG_UUID_KEY, translogUUID)__                commitData.put(SequenceNumbers.LOCAL_CHECKPOINT_KEY, localCheckpointValue)__                if (syncId != null) {_                    commitData.put(Engine.SYNC_COMMIT_ID, syncId)__                }_                commitData.put(SequenceNumbers.MAX_SEQ_NO, Long.toString(localCheckpointTracker.getMaxSeqNo()))__                commitData.put(MAX_UNSAFE_AUTO_ID_TIMESTAMP_COMMIT_ID, Long.toString(maxUnsafeAutoIdTimestamp.get()))__                commitData.put(HISTORY_UUID_KEY, historyUUID)__                if (softDeleteEnabled) {_                    commitData.put(Engine.MIN_RETAINED_SEQNO, Long.toString(softDeletesPolicy.getMinRetainedSeqNo()))__                }_                logger.trace("committing writer with commit data [{}]", commitData)__                return commitData.entrySet().iterator()__            })___            writer.commit()__        } catch (final Exception ex) {_            try {_                failEngine("lucene commit failed", ex)__            } catch (final Exception inner) {_                ex.addSuppressed(inner)__            }_            throw ex__        } catch (final AssertionError e) {_            _            if (ExceptionsHelper.stackTrace(e).contains("org.apache.lucene.index.IndexWriter.filesExist")) {_                final EngineException engineException = new EngineException(shardId, "failed to commit engine", e)__                try {_                    failEngine("lucene commit failed", engineException)__                } catch (final Exception inner) {_                    engineException.addSuppressed(inner)__                }_                throw engineException__            } else {_                throw e__            }_        }_    };commits,the,specified,index,writer,param,writer,the,index,writer,to,commit,param,translog,the,translog,param,sync,id,the,sync,flush,id,code,null,if,not,committing,a,synced,flush,throws,ioexception,if,an,i,o,exception,occurs,committing,the,specfied,writer;protected,void,commit,index,writer,final,index,writer,writer,final,translog,translog,nullable,final,string,sync,id,throws,ioexception,ensure,can,flush,try,final,long,local,checkpoint,local,checkpoint,tracker,get,checkpoint,final,translog,translog,generation,translog,generation,translog,get,min,generation,for,seq,no,local,checkpoint,1,final,string,translog,file,generation,long,to,string,translog,generation,translog,file,generation,final,string,translog,uuid,translog,generation,translog,uuid,final,string,local,checkpoint,value,long,to,string,local,checkpoint,writer,set,live,commit,data,final,map,string,string,commit,data,new,hash,map,6,commit,data,put,translog,translog,file,generation,commit,data,put,translog,translog,uuid,commit,data,put,sequence,numbers,local,checkpoint,value,if,sync,id,null,commit,data,put,engine,sync,id,commit,data,put,sequence,numbers,long,to,string,local,checkpoint,tracker,get,max,seq,no,commit,data,put,long,to,string,max,unsafe,auto,id,timestamp,get,commit,data,put,history,uuid,if,soft,delete,enabled,commit,data,put,engine,long,to,string,soft,deletes,policy,get,min,retained,seq,no,logger,trace,committing,writer,with,commit,data,commit,data,return,commit,data,entry,set,iterator,writer,commit,catch,final,exception,ex,try,fail,engine,lucene,commit,failed,ex,catch,final,exception,inner,ex,add,suppressed,inner,throw,ex,catch,final,assertion,error,e,if,exceptions,helper,stack,trace,e,contains,org,apache,lucene,index,index,writer,files,exist,final,engine,exception,engine,exception,new,engine,exception,shard,id,failed,to,commit,engine,e,try,fail,engine,lucene,commit,failed,engine,exception,catch,final,exception,inner,engine,exception,add,suppressed,inner,throw,engine,exception,else,throw,e
InternalEngine -> protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException;1536218260;Commits the specified index writer.__@param writer   the index writer to commit_@param translog the translog_@param syncId   the sync flush ID ({@code null} if not committing a synced flush)_@throws IOException if an I/O exception occurs committing the specfied writer;protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException {_        ensureCanFlush()__        try {_            final long localCheckpoint = localCheckpointTracker.getCheckpoint()__            final Translog.TranslogGeneration translogGeneration = translog.getMinGenerationForSeqNo(localCheckpoint + 1)__            final String translogFileGeneration = Long.toString(translogGeneration.translogFileGeneration)__            final String translogUUID = translogGeneration.translogUUID__            final String localCheckpointValue = Long.toString(localCheckpoint)___            writer.setLiveCommitData(() -> {_                _                final Map<String, String> commitData = new HashMap<>(6)__                commitData.put(Translog.TRANSLOG_GENERATION_KEY, translogFileGeneration)__                commitData.put(Translog.TRANSLOG_UUID_KEY, translogUUID)__                commitData.put(SequenceNumbers.LOCAL_CHECKPOINT_KEY, localCheckpointValue)__                if (syncId != null) {_                    commitData.put(Engine.SYNC_COMMIT_ID, syncId)__                }_                commitData.put(SequenceNumbers.MAX_SEQ_NO, Long.toString(localCheckpointTracker.getMaxSeqNo()))__                commitData.put(MAX_UNSAFE_AUTO_ID_TIMESTAMP_COMMIT_ID, Long.toString(maxUnsafeAutoIdTimestamp.get()))__                commitData.put(HISTORY_UUID_KEY, historyUUID)__                if (softDeleteEnabled) {_                    commitData.put(Engine.MIN_RETAINED_SEQNO, Long.toString(softDeletesPolicy.getMinRetainedSeqNo()))__                }_                logger.trace("committing writer with commit data [{}]", commitData)__                return commitData.entrySet().iterator()__            })___            writer.commit()__        } catch (final Exception ex) {_            try {_                failEngine("lucene commit failed", ex)__            } catch (final Exception inner) {_                ex.addSuppressed(inner)__            }_            throw ex__        } catch (final AssertionError e) {_            _            if (ExceptionsHelper.stackTrace(e).contains("org.apache.lucene.index.IndexWriter.filesExist")) {_                final EngineException engineException = new EngineException(shardId, "failed to commit engine", e)__                try {_                    failEngine("lucene commit failed", engineException)__                } catch (final Exception inner) {_                    engineException.addSuppressed(inner)__                }_                throw engineException__            } else {_                throw e__            }_        }_    };commits,the,specified,index,writer,param,writer,the,index,writer,to,commit,param,translog,the,translog,param,sync,id,the,sync,flush,id,code,null,if,not,committing,a,synced,flush,throws,ioexception,if,an,i,o,exception,occurs,committing,the,specfied,writer;protected,void,commit,index,writer,final,index,writer,writer,final,translog,translog,nullable,final,string,sync,id,throws,ioexception,ensure,can,flush,try,final,long,local,checkpoint,local,checkpoint,tracker,get,checkpoint,final,translog,translog,generation,translog,generation,translog,get,min,generation,for,seq,no,local,checkpoint,1,final,string,translog,file,generation,long,to,string,translog,generation,translog,file,generation,final,string,translog,uuid,translog,generation,translog,uuid,final,string,local,checkpoint,value,long,to,string,local,checkpoint,writer,set,live,commit,data,final,map,string,string,commit,data,new,hash,map,6,commit,data,put,translog,translog,file,generation,commit,data,put,translog,translog,uuid,commit,data,put,sequence,numbers,local,checkpoint,value,if,sync,id,null,commit,data,put,engine,sync,id,commit,data,put,sequence,numbers,long,to,string,local,checkpoint,tracker,get,max,seq,no,commit,data,put,long,to,string,max,unsafe,auto,id,timestamp,get,commit,data,put,history,uuid,if,soft,delete,enabled,commit,data,put,engine,long,to,string,soft,deletes,policy,get,min,retained,seq,no,logger,trace,committing,writer,with,commit,data,commit,data,return,commit,data,entry,set,iterator,writer,commit,catch,final,exception,ex,try,fail,engine,lucene,commit,failed,ex,catch,final,exception,inner,ex,add,suppressed,inner,throw,ex,catch,final,assertion,error,e,if,exceptions,helper,stack,trace,e,contains,org,apache,lucene,index,index,writer,files,exist,final,engine,exception,engine,exception,new,engine,exception,shard,id,failed,to,commit,engine,e,try,fail,engine,lucene,commit,failed,engine,exception,catch,final,exception,inner,engine,exception,add,suppressed,inner,throw,engine,exception,else,throw,e
InternalEngine -> protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException;1536314350;Commits the specified index writer.__@param writer   the index writer to commit_@param translog the translog_@param syncId   the sync flush ID ({@code null} if not committing a synced flush)_@throws IOException if an I/O exception occurs committing the specfied writer;protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException {_        ensureCanFlush()__        try {_            final long localCheckpoint = localCheckpointTracker.getCheckpoint()__            final Translog.TranslogGeneration translogGeneration = translog.getMinGenerationForSeqNo(localCheckpoint + 1)__            final String translogFileGeneration = Long.toString(translogGeneration.translogFileGeneration)__            final String translogUUID = translogGeneration.translogUUID__            final String localCheckpointValue = Long.toString(localCheckpoint)___            writer.setLiveCommitData(() -> {_                _                final Map<String, String> commitData = new HashMap<>(6)__                commitData.put(Translog.TRANSLOG_GENERATION_KEY, translogFileGeneration)__                commitData.put(Translog.TRANSLOG_UUID_KEY, translogUUID)__                commitData.put(SequenceNumbers.LOCAL_CHECKPOINT_KEY, localCheckpointValue)__                if (syncId != null) {_                    commitData.put(Engine.SYNC_COMMIT_ID, syncId)__                }_                commitData.put(SequenceNumbers.MAX_SEQ_NO, Long.toString(localCheckpointTracker.getMaxSeqNo()))__                commitData.put(MAX_UNSAFE_AUTO_ID_TIMESTAMP_COMMIT_ID, Long.toString(maxUnsafeAutoIdTimestamp.get()))__                commitData.put(HISTORY_UUID_KEY, historyUUID)__                if (softDeleteEnabled) {_                    commitData.put(Engine.MIN_RETAINED_SEQNO, Long.toString(softDeletesPolicy.getMinRetainedSeqNo()))__                }_                logger.trace("committing writer with commit data [{}]", commitData)__                return commitData.entrySet().iterator()__            })___            writer.commit()__        } catch (final Exception ex) {_            try {_                failEngine("lucene commit failed", ex)__            } catch (final Exception inner) {_                ex.addSuppressed(inner)__            }_            throw ex__        } catch (final AssertionError e) {_            _            if (ExceptionsHelper.stackTrace(e).contains("org.apache.lucene.index.IndexWriter.filesExist")) {_                final EngineException engineException = new EngineException(shardId, "failed to commit engine", e)__                try {_                    failEngine("lucene commit failed", engineException)__                } catch (final Exception inner) {_                    engineException.addSuppressed(inner)__                }_                throw engineException__            } else {_                throw e__            }_        }_    };commits,the,specified,index,writer,param,writer,the,index,writer,to,commit,param,translog,the,translog,param,sync,id,the,sync,flush,id,code,null,if,not,committing,a,synced,flush,throws,ioexception,if,an,i,o,exception,occurs,committing,the,specfied,writer;protected,void,commit,index,writer,final,index,writer,writer,final,translog,translog,nullable,final,string,sync,id,throws,ioexception,ensure,can,flush,try,final,long,local,checkpoint,local,checkpoint,tracker,get,checkpoint,final,translog,translog,generation,translog,generation,translog,get,min,generation,for,seq,no,local,checkpoint,1,final,string,translog,file,generation,long,to,string,translog,generation,translog,file,generation,final,string,translog,uuid,translog,generation,translog,uuid,final,string,local,checkpoint,value,long,to,string,local,checkpoint,writer,set,live,commit,data,final,map,string,string,commit,data,new,hash,map,6,commit,data,put,translog,translog,file,generation,commit,data,put,translog,translog,uuid,commit,data,put,sequence,numbers,local,checkpoint,value,if,sync,id,null,commit,data,put,engine,sync,id,commit,data,put,sequence,numbers,long,to,string,local,checkpoint,tracker,get,max,seq,no,commit,data,put,long,to,string,max,unsafe,auto,id,timestamp,get,commit,data,put,history,uuid,if,soft,delete,enabled,commit,data,put,engine,long,to,string,soft,deletes,policy,get,min,retained,seq,no,logger,trace,committing,writer,with,commit,data,commit,data,return,commit,data,entry,set,iterator,writer,commit,catch,final,exception,ex,try,fail,engine,lucene,commit,failed,ex,catch,final,exception,inner,ex,add,suppressed,inner,throw,ex,catch,final,assertion,error,e,if,exceptions,helper,stack,trace,e,contains,org,apache,lucene,index,index,writer,files,exist,final,engine,exception,engine,exception,new,engine,exception,shard,id,failed,to,commit,engine,e,try,fail,engine,lucene,commit,failed,engine,exception,catch,final,exception,inner,engine,exception,add,suppressed,inner,throw,engine,exception,else,throw,e
InternalEngine -> protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException;1536828374;Commits the specified index writer.__@param writer   the index writer to commit_@param translog the translog_@param syncId   the sync flush ID ({@code null} if not committing a synced flush)_@throws IOException if an I/O exception occurs committing the specfied writer;protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException {_        ensureCanFlush()__        try {_            final long localCheckpoint = localCheckpointTracker.getCheckpoint()__            final Translog.TranslogGeneration translogGeneration = translog.getMinGenerationForSeqNo(localCheckpoint + 1)__            final String translogFileGeneration = Long.toString(translogGeneration.translogFileGeneration)__            final String translogUUID = translogGeneration.translogUUID__            final String localCheckpointValue = Long.toString(localCheckpoint)___            writer.setLiveCommitData(() -> {_                _                final Map<String, String> commitData = new HashMap<>(6)__                commitData.put(Translog.TRANSLOG_GENERATION_KEY, translogFileGeneration)__                commitData.put(Translog.TRANSLOG_UUID_KEY, translogUUID)__                commitData.put(SequenceNumbers.LOCAL_CHECKPOINT_KEY, localCheckpointValue)__                if (syncId != null) {_                    commitData.put(Engine.SYNC_COMMIT_ID, syncId)__                }_                commitData.put(SequenceNumbers.MAX_SEQ_NO, Long.toString(localCheckpointTracker.getMaxSeqNo()))__                commitData.put(MAX_UNSAFE_AUTO_ID_TIMESTAMP_COMMIT_ID, Long.toString(maxUnsafeAutoIdTimestamp.get()))__                commitData.put(HISTORY_UUID_KEY, historyUUID)__                if (softDeleteEnabled) {_                    commitData.put(Engine.MIN_RETAINED_SEQNO, Long.toString(softDeletesPolicy.getMinRetainedSeqNo()))__                }_                logger.trace("committing writer with commit data [{}]", commitData)__                return commitData.entrySet().iterator()__            })___            writer.commit()__        } catch (final Exception ex) {_            try {_                failEngine("lucene commit failed", ex)__            } catch (final Exception inner) {_                ex.addSuppressed(inner)__            }_            throw ex__        } catch (final AssertionError e) {_            _            if (ExceptionsHelper.stackTrace(e).contains("org.apache.lucene.index.IndexWriter.filesExist")) {_                final EngineException engineException = new EngineException(shardId, "failed to commit engine", e)__                try {_                    failEngine("lucene commit failed", engineException)__                } catch (final Exception inner) {_                    engineException.addSuppressed(inner)__                }_                throw engineException__            } else {_                throw e__            }_        }_    };commits,the,specified,index,writer,param,writer,the,index,writer,to,commit,param,translog,the,translog,param,sync,id,the,sync,flush,id,code,null,if,not,committing,a,synced,flush,throws,ioexception,if,an,i,o,exception,occurs,committing,the,specfied,writer;protected,void,commit,index,writer,final,index,writer,writer,final,translog,translog,nullable,final,string,sync,id,throws,ioexception,ensure,can,flush,try,final,long,local,checkpoint,local,checkpoint,tracker,get,checkpoint,final,translog,translog,generation,translog,generation,translog,get,min,generation,for,seq,no,local,checkpoint,1,final,string,translog,file,generation,long,to,string,translog,generation,translog,file,generation,final,string,translog,uuid,translog,generation,translog,uuid,final,string,local,checkpoint,value,long,to,string,local,checkpoint,writer,set,live,commit,data,final,map,string,string,commit,data,new,hash,map,6,commit,data,put,translog,translog,file,generation,commit,data,put,translog,translog,uuid,commit,data,put,sequence,numbers,local,checkpoint,value,if,sync,id,null,commit,data,put,engine,sync,id,commit,data,put,sequence,numbers,long,to,string,local,checkpoint,tracker,get,max,seq,no,commit,data,put,long,to,string,max,unsafe,auto,id,timestamp,get,commit,data,put,history,uuid,if,soft,delete,enabled,commit,data,put,engine,long,to,string,soft,deletes,policy,get,min,retained,seq,no,logger,trace,committing,writer,with,commit,data,commit,data,return,commit,data,entry,set,iterator,writer,commit,catch,final,exception,ex,try,fail,engine,lucene,commit,failed,ex,catch,final,exception,inner,ex,add,suppressed,inner,throw,ex,catch,final,assertion,error,e,if,exceptions,helper,stack,trace,e,contains,org,apache,lucene,index,index,writer,files,exist,final,engine,exception,engine,exception,new,engine,exception,shard,id,failed,to,commit,engine,e,try,fail,engine,lucene,commit,failed,engine,exception,catch,final,exception,inner,engine,exception,add,suppressed,inner,throw,engine,exception,else,throw,e
InternalEngine -> protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException;1537806831;Commits the specified index writer.__@param writer   the index writer to commit_@param translog the translog_@param syncId   the sync flush ID ({@code null} if not committing a synced flush)_@throws IOException if an I/O exception occurs committing the specfied writer;protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException {_        ensureCanFlush()__        try {_            final long localCheckpoint = localCheckpointTracker.getCheckpoint()__            final Translog.TranslogGeneration translogGeneration = translog.getMinGenerationForSeqNo(localCheckpoint + 1)__            final String translogFileGeneration = Long.toString(translogGeneration.translogFileGeneration)__            final String translogUUID = translogGeneration.translogUUID__            final String localCheckpointValue = Long.toString(localCheckpoint)___            writer.setLiveCommitData(() -> {_                _                final Map<String, String> commitData = new HashMap<>(6)__                commitData.put(Translog.TRANSLOG_GENERATION_KEY, translogFileGeneration)__                commitData.put(Translog.TRANSLOG_UUID_KEY, translogUUID)__                commitData.put(SequenceNumbers.LOCAL_CHECKPOINT_KEY, localCheckpointValue)__                if (syncId != null) {_                    commitData.put(Engine.SYNC_COMMIT_ID, syncId)__                }_                commitData.put(SequenceNumbers.MAX_SEQ_NO, Long.toString(localCheckpointTracker.getMaxSeqNo()))__                commitData.put(MAX_UNSAFE_AUTO_ID_TIMESTAMP_COMMIT_ID, Long.toString(maxUnsafeAutoIdTimestamp.get()))__                commitData.put(HISTORY_UUID_KEY, historyUUID)__                if (softDeleteEnabled) {_                    commitData.put(Engine.MIN_RETAINED_SEQNO, Long.toString(softDeletesPolicy.getMinRetainedSeqNo()))__                }_                logger.trace("committing writer with commit data [{}]", commitData)__                return commitData.entrySet().iterator()__            })___            writer.commit()__        } catch (final Exception ex) {_            try {_                failEngine("lucene commit failed", ex)__            } catch (final Exception inner) {_                ex.addSuppressed(inner)__            }_            throw ex__        } catch (final AssertionError e) {_            _            if (ExceptionsHelper.stackTrace(e).contains("org.apache.lucene.index.IndexWriter.filesExist")) {_                final EngineException engineException = new EngineException(shardId, "failed to commit engine", e)__                try {_                    failEngine("lucene commit failed", engineException)__                } catch (final Exception inner) {_                    engineException.addSuppressed(inner)__                }_                throw engineException__            } else {_                throw e__            }_        }_    };commits,the,specified,index,writer,param,writer,the,index,writer,to,commit,param,translog,the,translog,param,sync,id,the,sync,flush,id,code,null,if,not,committing,a,synced,flush,throws,ioexception,if,an,i,o,exception,occurs,committing,the,specfied,writer;protected,void,commit,index,writer,final,index,writer,writer,final,translog,translog,nullable,final,string,sync,id,throws,ioexception,ensure,can,flush,try,final,long,local,checkpoint,local,checkpoint,tracker,get,checkpoint,final,translog,translog,generation,translog,generation,translog,get,min,generation,for,seq,no,local,checkpoint,1,final,string,translog,file,generation,long,to,string,translog,generation,translog,file,generation,final,string,translog,uuid,translog,generation,translog,uuid,final,string,local,checkpoint,value,long,to,string,local,checkpoint,writer,set,live,commit,data,final,map,string,string,commit,data,new,hash,map,6,commit,data,put,translog,translog,file,generation,commit,data,put,translog,translog,uuid,commit,data,put,sequence,numbers,local,checkpoint,value,if,sync,id,null,commit,data,put,engine,sync,id,commit,data,put,sequence,numbers,long,to,string,local,checkpoint,tracker,get,max,seq,no,commit,data,put,long,to,string,max,unsafe,auto,id,timestamp,get,commit,data,put,history,uuid,if,soft,delete,enabled,commit,data,put,engine,long,to,string,soft,deletes,policy,get,min,retained,seq,no,logger,trace,committing,writer,with,commit,data,commit,data,return,commit,data,entry,set,iterator,writer,commit,catch,final,exception,ex,try,fail,engine,lucene,commit,failed,ex,catch,final,exception,inner,ex,add,suppressed,inner,throw,ex,catch,final,assertion,error,e,if,exceptions,helper,stack,trace,e,contains,org,apache,lucene,index,index,writer,files,exist,final,engine,exception,engine,exception,new,engine,exception,shard,id,failed,to,commit,engine,e,try,fail,engine,lucene,commit,failed,engine,exception,catch,final,exception,inner,engine,exception,add,suppressed,inner,throw,engine,exception,else,throw,e
InternalEngine -> protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException;1538067637;Commits the specified index writer.__@param writer   the index writer to commit_@param translog the translog_@param syncId   the sync flush ID ({@code null} if not committing a synced flush)_@throws IOException if an I/O exception occurs committing the specfied writer;protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException {_        ensureCanFlush()__        try {_            final long localCheckpoint = localCheckpointTracker.getCheckpoint()__            final Translog.TranslogGeneration translogGeneration = translog.getMinGenerationForSeqNo(localCheckpoint + 1)__            final String translogFileGeneration = Long.toString(translogGeneration.translogFileGeneration)__            final String translogUUID = translogGeneration.translogUUID__            final String localCheckpointValue = Long.toString(localCheckpoint)___            writer.setLiveCommitData(() -> {_                _                final Map<String, String> commitData = new HashMap<>(6)__                commitData.put(Translog.TRANSLOG_GENERATION_KEY, translogFileGeneration)__                commitData.put(Translog.TRANSLOG_UUID_KEY, translogUUID)__                commitData.put(SequenceNumbers.LOCAL_CHECKPOINT_KEY, localCheckpointValue)__                if (syncId != null) {_                    commitData.put(Engine.SYNC_COMMIT_ID, syncId)__                }_                commitData.put(SequenceNumbers.MAX_SEQ_NO, Long.toString(localCheckpointTracker.getMaxSeqNo()))__                commitData.put(MAX_UNSAFE_AUTO_ID_TIMESTAMP_COMMIT_ID, Long.toString(maxUnsafeAutoIdTimestamp.get()))__                commitData.put(HISTORY_UUID_KEY, historyUUID)__                if (softDeleteEnabled) {_                    commitData.put(Engine.MIN_RETAINED_SEQNO, Long.toString(softDeletesPolicy.getMinRetainedSeqNo()))__                }_                logger.trace("committing writer with commit data [{}]", commitData)__                return commitData.entrySet().iterator()__            })___            writer.commit()__        } catch (final Exception ex) {_            try {_                failEngine("lucene commit failed", ex)__            } catch (final Exception inner) {_                ex.addSuppressed(inner)__            }_            throw ex__        } catch (final AssertionError e) {_            _            if (ExceptionsHelper.stackTrace(e).contains("org.apache.lucene.index.IndexWriter.filesExist")) {_                final EngineException engineException = new EngineException(shardId, "failed to commit engine", e)__                try {_                    failEngine("lucene commit failed", engineException)__                } catch (final Exception inner) {_                    engineException.addSuppressed(inner)__                }_                throw engineException__            } else {_                throw e__            }_        }_    };commits,the,specified,index,writer,param,writer,the,index,writer,to,commit,param,translog,the,translog,param,sync,id,the,sync,flush,id,code,null,if,not,committing,a,synced,flush,throws,ioexception,if,an,i,o,exception,occurs,committing,the,specfied,writer;protected,void,commit,index,writer,final,index,writer,writer,final,translog,translog,nullable,final,string,sync,id,throws,ioexception,ensure,can,flush,try,final,long,local,checkpoint,local,checkpoint,tracker,get,checkpoint,final,translog,translog,generation,translog,generation,translog,get,min,generation,for,seq,no,local,checkpoint,1,final,string,translog,file,generation,long,to,string,translog,generation,translog,file,generation,final,string,translog,uuid,translog,generation,translog,uuid,final,string,local,checkpoint,value,long,to,string,local,checkpoint,writer,set,live,commit,data,final,map,string,string,commit,data,new,hash,map,6,commit,data,put,translog,translog,file,generation,commit,data,put,translog,translog,uuid,commit,data,put,sequence,numbers,local,checkpoint,value,if,sync,id,null,commit,data,put,engine,sync,id,commit,data,put,sequence,numbers,long,to,string,local,checkpoint,tracker,get,max,seq,no,commit,data,put,long,to,string,max,unsafe,auto,id,timestamp,get,commit,data,put,history,uuid,if,soft,delete,enabled,commit,data,put,engine,long,to,string,soft,deletes,policy,get,min,retained,seq,no,logger,trace,committing,writer,with,commit,data,commit,data,return,commit,data,entry,set,iterator,writer,commit,catch,final,exception,ex,try,fail,engine,lucene,commit,failed,ex,catch,final,exception,inner,ex,add,suppressed,inner,throw,ex,catch,final,assertion,error,e,if,exceptions,helper,stack,trace,e,contains,org,apache,lucene,index,index,writer,files,exist,final,engine,exception,engine,exception,new,engine,exception,shard,id,failed,to,commit,engine,e,try,fail,engine,lucene,commit,failed,engine,exception,catch,final,exception,inner,engine,exception,add,suppressed,inner,throw,engine,exception,else,throw,e
InternalEngine -> protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException;1538424609;Commits the specified index writer.__@param writer   the index writer to commit_@param translog the translog_@param syncId   the sync flush ID ({@code null} if not committing a synced flush)_@throws IOException if an I/O exception occurs committing the specfied writer;protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException {_        ensureCanFlush()__        try {_            final long localCheckpoint = localCheckpointTracker.getCheckpoint()__            final Translog.TranslogGeneration translogGeneration = translog.getMinGenerationForSeqNo(localCheckpoint + 1)__            final String translogFileGeneration = Long.toString(translogGeneration.translogFileGeneration)__            final String translogUUID = translogGeneration.translogUUID__            final String localCheckpointValue = Long.toString(localCheckpoint)___            writer.setLiveCommitData(() -> {_                _                final Map<String, String> commitData = new HashMap<>(6)__                commitData.put(Translog.TRANSLOG_GENERATION_KEY, translogFileGeneration)__                commitData.put(Translog.TRANSLOG_UUID_KEY, translogUUID)__                commitData.put(SequenceNumbers.LOCAL_CHECKPOINT_KEY, localCheckpointValue)__                if (syncId != null) {_                    commitData.put(Engine.SYNC_COMMIT_ID, syncId)__                }_                commitData.put(SequenceNumbers.MAX_SEQ_NO, Long.toString(localCheckpointTracker.getMaxSeqNo()))__                commitData.put(MAX_UNSAFE_AUTO_ID_TIMESTAMP_COMMIT_ID, Long.toString(maxUnsafeAutoIdTimestamp.get()))__                commitData.put(HISTORY_UUID_KEY, historyUUID)__                if (softDeleteEnabled) {_                    commitData.put(Engine.MIN_RETAINED_SEQNO, Long.toString(softDeletesPolicy.getMinRetainedSeqNo()))__                }_                logger.trace("committing writer with commit data [{}]", commitData)__                return commitData.entrySet().iterator()__            })___            writer.commit()__        } catch (final Exception ex) {_            try {_                failEngine("lucene commit failed", ex)__            } catch (final Exception inner) {_                ex.addSuppressed(inner)__            }_            throw ex__        } catch (final AssertionError e) {_            _            if (ExceptionsHelper.stackTrace(e).contains("org.apache.lucene.index.IndexWriter.filesExist")) {_                final EngineException engineException = new EngineException(shardId, "failed to commit engine", e)__                try {_                    failEngine("lucene commit failed", engineException)__                } catch (final Exception inner) {_                    engineException.addSuppressed(inner)__                }_                throw engineException__            } else {_                throw e__            }_        }_    };commits,the,specified,index,writer,param,writer,the,index,writer,to,commit,param,translog,the,translog,param,sync,id,the,sync,flush,id,code,null,if,not,committing,a,synced,flush,throws,ioexception,if,an,i,o,exception,occurs,committing,the,specfied,writer;protected,void,commit,index,writer,final,index,writer,writer,final,translog,translog,nullable,final,string,sync,id,throws,ioexception,ensure,can,flush,try,final,long,local,checkpoint,local,checkpoint,tracker,get,checkpoint,final,translog,translog,generation,translog,generation,translog,get,min,generation,for,seq,no,local,checkpoint,1,final,string,translog,file,generation,long,to,string,translog,generation,translog,file,generation,final,string,translog,uuid,translog,generation,translog,uuid,final,string,local,checkpoint,value,long,to,string,local,checkpoint,writer,set,live,commit,data,final,map,string,string,commit,data,new,hash,map,6,commit,data,put,translog,translog,file,generation,commit,data,put,translog,translog,uuid,commit,data,put,sequence,numbers,local,checkpoint,value,if,sync,id,null,commit,data,put,engine,sync,id,commit,data,put,sequence,numbers,long,to,string,local,checkpoint,tracker,get,max,seq,no,commit,data,put,long,to,string,max,unsafe,auto,id,timestamp,get,commit,data,put,history,uuid,if,soft,delete,enabled,commit,data,put,engine,long,to,string,soft,deletes,policy,get,min,retained,seq,no,logger,trace,committing,writer,with,commit,data,commit,data,return,commit,data,entry,set,iterator,writer,commit,catch,final,exception,ex,try,fail,engine,lucene,commit,failed,ex,catch,final,exception,inner,ex,add,suppressed,inner,throw,ex,catch,final,assertion,error,e,if,exceptions,helper,stack,trace,e,contains,org,apache,lucene,index,index,writer,files,exist,final,engine,exception,engine,exception,new,engine,exception,shard,id,failed,to,commit,engine,e,try,fail,engine,lucene,commit,failed,engine,exception,catch,final,exception,inner,engine,exception,add,suppressed,inner,throw,engine,exception,else,throw,e
InternalEngine -> protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException;1539615817;Commits the specified index writer.__@param writer   the index writer to commit_@param translog the translog_@param syncId   the sync flush ID ({@code null} if not committing a synced flush)_@throws IOException if an I/O exception occurs committing the specfied writer;protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException {_        ensureCanFlush()__        try {_            final long localCheckpoint = localCheckpointTracker.getCheckpoint()__            final Translog.TranslogGeneration translogGeneration = translog.getMinGenerationForSeqNo(localCheckpoint + 1)__            final String translogFileGeneration = Long.toString(translogGeneration.translogFileGeneration)__            final String translogUUID = translogGeneration.translogUUID__            final String localCheckpointValue = Long.toString(localCheckpoint)___            writer.setLiveCommitData(() -> {_                _                final Map<String, String> commitData = new HashMap<>(6)__                commitData.put(Translog.TRANSLOG_GENERATION_KEY, translogFileGeneration)__                commitData.put(Translog.TRANSLOG_UUID_KEY, translogUUID)__                commitData.put(SequenceNumbers.LOCAL_CHECKPOINT_KEY, localCheckpointValue)__                if (syncId != null) {_                    commitData.put(Engine.SYNC_COMMIT_ID, syncId)__                }_                commitData.put(SequenceNumbers.MAX_SEQ_NO, Long.toString(localCheckpointTracker.getMaxSeqNo()))__                commitData.put(MAX_UNSAFE_AUTO_ID_TIMESTAMP_COMMIT_ID, Long.toString(maxUnsafeAutoIdTimestamp.get()))__                commitData.put(HISTORY_UUID_KEY, historyUUID)__                if (softDeleteEnabled) {_                    commitData.put(Engine.MIN_RETAINED_SEQNO, Long.toString(softDeletesPolicy.getMinRetainedSeqNo()))__                }_                logger.trace("committing writer with commit data [{}]", commitData)__                return commitData.entrySet().iterator()__            })___            writer.commit()__        } catch (final Exception ex) {_            try {_                failEngine("lucene commit failed", ex)__            } catch (final Exception inner) {_                ex.addSuppressed(inner)__            }_            throw ex__        } catch (final AssertionError e) {_            _            if (ExceptionsHelper.stackTrace(e).contains("org.apache.lucene.index.IndexWriter.filesExist")) {_                final EngineException engineException = new EngineException(shardId, "failed to commit engine", e)__                try {_                    failEngine("lucene commit failed", engineException)__                } catch (final Exception inner) {_                    engineException.addSuppressed(inner)__                }_                throw engineException__            } else {_                throw e__            }_        }_    };commits,the,specified,index,writer,param,writer,the,index,writer,to,commit,param,translog,the,translog,param,sync,id,the,sync,flush,id,code,null,if,not,committing,a,synced,flush,throws,ioexception,if,an,i,o,exception,occurs,committing,the,specfied,writer;protected,void,commit,index,writer,final,index,writer,writer,final,translog,translog,nullable,final,string,sync,id,throws,ioexception,ensure,can,flush,try,final,long,local,checkpoint,local,checkpoint,tracker,get,checkpoint,final,translog,translog,generation,translog,generation,translog,get,min,generation,for,seq,no,local,checkpoint,1,final,string,translog,file,generation,long,to,string,translog,generation,translog,file,generation,final,string,translog,uuid,translog,generation,translog,uuid,final,string,local,checkpoint,value,long,to,string,local,checkpoint,writer,set,live,commit,data,final,map,string,string,commit,data,new,hash,map,6,commit,data,put,translog,translog,file,generation,commit,data,put,translog,translog,uuid,commit,data,put,sequence,numbers,local,checkpoint,value,if,sync,id,null,commit,data,put,engine,sync,id,commit,data,put,sequence,numbers,long,to,string,local,checkpoint,tracker,get,max,seq,no,commit,data,put,long,to,string,max,unsafe,auto,id,timestamp,get,commit,data,put,history,uuid,if,soft,delete,enabled,commit,data,put,engine,long,to,string,soft,deletes,policy,get,min,retained,seq,no,logger,trace,committing,writer,with,commit,data,commit,data,return,commit,data,entry,set,iterator,writer,commit,catch,final,exception,ex,try,fail,engine,lucene,commit,failed,ex,catch,final,exception,inner,ex,add,suppressed,inner,throw,ex,catch,final,assertion,error,e,if,exceptions,helper,stack,trace,e,contains,org,apache,lucene,index,index,writer,files,exist,final,engine,exception,engine,exception,new,engine,exception,shard,id,failed,to,commit,engine,e,try,fail,engine,lucene,commit,failed,engine,exception,catch,final,exception,inner,engine,exception,add,suppressed,inner,throw,engine,exception,else,throw,e
InternalEngine -> protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException;1539723533;Commits the specified index writer.__@param writer   the index writer to commit_@param translog the translog_@param syncId   the sync flush ID ({@code null} if not committing a synced flush)_@throws IOException if an I/O exception occurs committing the specfied writer;protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException {_        ensureCanFlush()__        try {_            final long localCheckpoint = localCheckpointTracker.getCheckpoint()__            final Translog.TranslogGeneration translogGeneration = translog.getMinGenerationForSeqNo(localCheckpoint + 1)__            final String translogFileGeneration = Long.toString(translogGeneration.translogFileGeneration)__            final String translogUUID = translogGeneration.translogUUID__            final String localCheckpointValue = Long.toString(localCheckpoint)___            writer.setLiveCommitData(() -> {_                _                final Map<String, String> commitData = new HashMap<>(6)__                commitData.put(Translog.TRANSLOG_GENERATION_KEY, translogFileGeneration)__                commitData.put(Translog.TRANSLOG_UUID_KEY, translogUUID)__                commitData.put(SequenceNumbers.LOCAL_CHECKPOINT_KEY, localCheckpointValue)__                if (syncId != null) {_                    commitData.put(Engine.SYNC_COMMIT_ID, syncId)__                }_                commitData.put(SequenceNumbers.MAX_SEQ_NO, Long.toString(localCheckpointTracker.getMaxSeqNo()))__                commitData.put(MAX_UNSAFE_AUTO_ID_TIMESTAMP_COMMIT_ID, Long.toString(maxUnsafeAutoIdTimestamp.get()))__                commitData.put(HISTORY_UUID_KEY, historyUUID)__                if (softDeleteEnabled) {_                    commitData.put(Engine.MIN_RETAINED_SEQNO, Long.toString(softDeletesPolicy.getMinRetainedSeqNo()))__                }_                logger.trace("committing writer with commit data [{}]", commitData)__                return commitData.entrySet().iterator()__            })___            writer.commit()__        } catch (final Exception ex) {_            try {_                failEngine("lucene commit failed", ex)__            } catch (final Exception inner) {_                ex.addSuppressed(inner)__            }_            throw ex__        } catch (final AssertionError e) {_            _            if (ExceptionsHelper.stackTrace(e).contains("org.apache.lucene.index.IndexWriter.filesExist")) {_                final EngineException engineException = new EngineException(shardId, "failed to commit engine", e)__                try {_                    failEngine("lucene commit failed", engineException)__                } catch (final Exception inner) {_                    engineException.addSuppressed(inner)__                }_                throw engineException__            } else {_                throw e__            }_        }_    };commits,the,specified,index,writer,param,writer,the,index,writer,to,commit,param,translog,the,translog,param,sync,id,the,sync,flush,id,code,null,if,not,committing,a,synced,flush,throws,ioexception,if,an,i,o,exception,occurs,committing,the,specfied,writer;protected,void,commit,index,writer,final,index,writer,writer,final,translog,translog,nullable,final,string,sync,id,throws,ioexception,ensure,can,flush,try,final,long,local,checkpoint,local,checkpoint,tracker,get,checkpoint,final,translog,translog,generation,translog,generation,translog,get,min,generation,for,seq,no,local,checkpoint,1,final,string,translog,file,generation,long,to,string,translog,generation,translog,file,generation,final,string,translog,uuid,translog,generation,translog,uuid,final,string,local,checkpoint,value,long,to,string,local,checkpoint,writer,set,live,commit,data,final,map,string,string,commit,data,new,hash,map,6,commit,data,put,translog,translog,file,generation,commit,data,put,translog,translog,uuid,commit,data,put,sequence,numbers,local,checkpoint,value,if,sync,id,null,commit,data,put,engine,sync,id,commit,data,put,sequence,numbers,long,to,string,local,checkpoint,tracker,get,max,seq,no,commit,data,put,long,to,string,max,unsafe,auto,id,timestamp,get,commit,data,put,history,uuid,if,soft,delete,enabled,commit,data,put,engine,long,to,string,soft,deletes,policy,get,min,retained,seq,no,logger,trace,committing,writer,with,commit,data,commit,data,return,commit,data,entry,set,iterator,writer,commit,catch,final,exception,ex,try,fail,engine,lucene,commit,failed,ex,catch,final,exception,inner,ex,add,suppressed,inner,throw,ex,catch,final,assertion,error,e,if,exceptions,helper,stack,trace,e,contains,org,apache,lucene,index,index,writer,files,exist,final,engine,exception,engine,exception,new,engine,exception,shard,id,failed,to,commit,engine,e,try,fail,engine,lucene,commit,failed,engine,exception,catch,final,exception,inner,engine,exception,add,suppressed,inner,throw,engine,exception,else,throw,e
InternalEngine -> protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException;1540238977;Commits the specified index writer.__@param writer   the index writer to commit_@param translog the translog_@param syncId   the sync flush ID ({@code null} if not committing a synced flush)_@throws IOException if an I/O exception occurs committing the specfied writer;protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException {_        ensureCanFlush()__        try {_            final long localCheckpoint = localCheckpointTracker.getCheckpoint()__            final Translog.TranslogGeneration translogGeneration = translog.getMinGenerationForSeqNo(localCheckpoint + 1)__            final String translogFileGeneration = Long.toString(translogGeneration.translogFileGeneration)__            final String translogUUID = translogGeneration.translogUUID__            final String localCheckpointValue = Long.toString(localCheckpoint)___            writer.setLiveCommitData(() -> {_                _                final Map<String, String> commitData = new HashMap<>(6)__                commitData.put(Translog.TRANSLOG_GENERATION_KEY, translogFileGeneration)__                commitData.put(Translog.TRANSLOG_UUID_KEY, translogUUID)__                commitData.put(SequenceNumbers.LOCAL_CHECKPOINT_KEY, localCheckpointValue)__                if (syncId != null) {_                    commitData.put(Engine.SYNC_COMMIT_ID, syncId)__                }_                commitData.put(SequenceNumbers.MAX_SEQ_NO, Long.toString(localCheckpointTracker.getMaxSeqNo()))__                commitData.put(MAX_UNSAFE_AUTO_ID_TIMESTAMP_COMMIT_ID, Long.toString(maxUnsafeAutoIdTimestamp.get()))__                commitData.put(HISTORY_UUID_KEY, historyUUID)__                if (softDeleteEnabled) {_                    commitData.put(Engine.MIN_RETAINED_SEQNO, Long.toString(softDeletesPolicy.getMinRetainedSeqNo()))__                }_                logger.trace("committing writer with commit data [{}]", commitData)__                return commitData.entrySet().iterator()__            })___            writer.commit()__        } catch (final Exception ex) {_            try {_                failEngine("lucene commit failed", ex)__            } catch (final Exception inner) {_                ex.addSuppressed(inner)__            }_            throw ex__        } catch (final AssertionError e) {_            _            if (ExceptionsHelper.stackTrace(e).contains("org.apache.lucene.index.IndexWriter.filesExist")) {_                final EngineException engineException = new EngineException(shardId, "failed to commit engine", e)__                try {_                    failEngine("lucene commit failed", engineException)__                } catch (final Exception inner) {_                    engineException.addSuppressed(inner)__                }_                throw engineException__            } else {_                throw e__            }_        }_    };commits,the,specified,index,writer,param,writer,the,index,writer,to,commit,param,translog,the,translog,param,sync,id,the,sync,flush,id,code,null,if,not,committing,a,synced,flush,throws,ioexception,if,an,i,o,exception,occurs,committing,the,specfied,writer;protected,void,commit,index,writer,final,index,writer,writer,final,translog,translog,nullable,final,string,sync,id,throws,ioexception,ensure,can,flush,try,final,long,local,checkpoint,local,checkpoint,tracker,get,checkpoint,final,translog,translog,generation,translog,generation,translog,get,min,generation,for,seq,no,local,checkpoint,1,final,string,translog,file,generation,long,to,string,translog,generation,translog,file,generation,final,string,translog,uuid,translog,generation,translog,uuid,final,string,local,checkpoint,value,long,to,string,local,checkpoint,writer,set,live,commit,data,final,map,string,string,commit,data,new,hash,map,6,commit,data,put,translog,translog,file,generation,commit,data,put,translog,translog,uuid,commit,data,put,sequence,numbers,local,checkpoint,value,if,sync,id,null,commit,data,put,engine,sync,id,commit,data,put,sequence,numbers,long,to,string,local,checkpoint,tracker,get,max,seq,no,commit,data,put,long,to,string,max,unsafe,auto,id,timestamp,get,commit,data,put,history,uuid,if,soft,delete,enabled,commit,data,put,engine,long,to,string,soft,deletes,policy,get,min,retained,seq,no,logger,trace,committing,writer,with,commit,data,commit,data,return,commit,data,entry,set,iterator,writer,commit,catch,final,exception,ex,try,fail,engine,lucene,commit,failed,ex,catch,final,exception,inner,ex,add,suppressed,inner,throw,ex,catch,final,assertion,error,e,if,exceptions,helper,stack,trace,e,contains,org,apache,lucene,index,index,writer,files,exist,final,engine,exception,engine,exception,new,engine,exception,shard,id,failed,to,commit,engine,e,try,fail,engine,lucene,commit,failed,engine,exception,catch,final,exception,inner,engine,exception,add,suppressed,inner,throw,engine,exception,else,throw,e
InternalEngine -> protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException;1541335413;Commits the specified index writer.__@param writer   the index writer to commit_@param translog the translog_@param syncId   the sync flush ID ({@code null} if not committing a synced flush)_@throws IOException if an I/O exception occurs committing the specfied writer;protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException {_        ensureCanFlush()__        try {_            final long localCheckpoint = localCheckpointTracker.getCheckpoint()__            final Translog.TranslogGeneration translogGeneration = translog.getMinGenerationForSeqNo(localCheckpoint + 1)__            final String translogFileGeneration = Long.toString(translogGeneration.translogFileGeneration)__            final String translogUUID = translogGeneration.translogUUID__            final String localCheckpointValue = Long.toString(localCheckpoint)___            writer.setLiveCommitData(() -> {_                _                final Map<String, String> commitData = new HashMap<>(6)__                commitData.put(Translog.TRANSLOG_GENERATION_KEY, translogFileGeneration)__                commitData.put(Translog.TRANSLOG_UUID_KEY, translogUUID)__                commitData.put(SequenceNumbers.LOCAL_CHECKPOINT_KEY, localCheckpointValue)__                if (syncId != null) {_                    commitData.put(Engine.SYNC_COMMIT_ID, syncId)__                }_                commitData.put(SequenceNumbers.MAX_SEQ_NO, Long.toString(localCheckpointTracker.getMaxSeqNo()))__                commitData.put(MAX_UNSAFE_AUTO_ID_TIMESTAMP_COMMIT_ID, Long.toString(maxUnsafeAutoIdTimestamp.get()))__                commitData.put(HISTORY_UUID_KEY, historyUUID)__                if (softDeleteEnabled) {_                    commitData.put(Engine.MIN_RETAINED_SEQNO, Long.toString(softDeletesPolicy.getMinRetainedSeqNo()))__                }_                logger.trace("committing writer with commit data [{}]", commitData)__                return commitData.entrySet().iterator()__            })___            writer.commit()__        } catch (final Exception ex) {_            try {_                failEngine("lucene commit failed", ex)__            } catch (final Exception inner) {_                ex.addSuppressed(inner)__            }_            throw ex__        } catch (final AssertionError e) {_            _            if (ExceptionsHelper.stackTrace(e).contains("org.apache.lucene.index.IndexWriter.filesExist")) {_                final EngineException engineException = new EngineException(shardId, "failed to commit engine", e)__                try {_                    failEngine("lucene commit failed", engineException)__                } catch (final Exception inner) {_                    engineException.addSuppressed(inner)__                }_                throw engineException__            } else {_                throw e__            }_        }_    };commits,the,specified,index,writer,param,writer,the,index,writer,to,commit,param,translog,the,translog,param,sync,id,the,sync,flush,id,code,null,if,not,committing,a,synced,flush,throws,ioexception,if,an,i,o,exception,occurs,committing,the,specfied,writer;protected,void,commit,index,writer,final,index,writer,writer,final,translog,translog,nullable,final,string,sync,id,throws,ioexception,ensure,can,flush,try,final,long,local,checkpoint,local,checkpoint,tracker,get,checkpoint,final,translog,translog,generation,translog,generation,translog,get,min,generation,for,seq,no,local,checkpoint,1,final,string,translog,file,generation,long,to,string,translog,generation,translog,file,generation,final,string,translog,uuid,translog,generation,translog,uuid,final,string,local,checkpoint,value,long,to,string,local,checkpoint,writer,set,live,commit,data,final,map,string,string,commit,data,new,hash,map,6,commit,data,put,translog,translog,file,generation,commit,data,put,translog,translog,uuid,commit,data,put,sequence,numbers,local,checkpoint,value,if,sync,id,null,commit,data,put,engine,sync,id,commit,data,put,sequence,numbers,long,to,string,local,checkpoint,tracker,get,max,seq,no,commit,data,put,long,to,string,max,unsafe,auto,id,timestamp,get,commit,data,put,history,uuid,if,soft,delete,enabled,commit,data,put,engine,long,to,string,soft,deletes,policy,get,min,retained,seq,no,logger,trace,committing,writer,with,commit,data,commit,data,return,commit,data,entry,set,iterator,writer,commit,catch,final,exception,ex,try,fail,engine,lucene,commit,failed,ex,catch,final,exception,inner,ex,add,suppressed,inner,throw,ex,catch,final,assertion,error,e,if,exceptions,helper,stack,trace,e,contains,org,apache,lucene,index,index,writer,files,exist,final,engine,exception,engine,exception,new,engine,exception,shard,id,failed,to,commit,engine,e,try,fail,engine,lucene,commit,failed,engine,exception,catch,final,exception,inner,engine,exception,add,suppressed,inner,throw,engine,exception,else,throw,e
InternalEngine -> protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException;1541622390;Commits the specified index writer.__@param writer   the index writer to commit_@param translog the translog_@param syncId   the sync flush ID ({@code null} if not committing a synced flush)_@throws IOException if an I/O exception occurs committing the specfied writer;protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException {_        ensureCanFlush()__        try {_            final long localCheckpoint = localCheckpointTracker.getCheckpoint()__            final Translog.TranslogGeneration translogGeneration = translog.getMinGenerationForSeqNo(localCheckpoint + 1)__            final String translogFileGeneration = Long.toString(translogGeneration.translogFileGeneration)__            final String translogUUID = translogGeneration.translogUUID__            final String localCheckpointValue = Long.toString(localCheckpoint)___            writer.setLiveCommitData(() -> {_                _                final Map<String, String> commitData = new HashMap<>(6)__                commitData.put(Translog.TRANSLOG_GENERATION_KEY, translogFileGeneration)__                commitData.put(Translog.TRANSLOG_UUID_KEY, translogUUID)__                commitData.put(SequenceNumbers.LOCAL_CHECKPOINT_KEY, localCheckpointValue)__                if (syncId != null) {_                    commitData.put(Engine.SYNC_COMMIT_ID, syncId)__                }_                commitData.put(SequenceNumbers.MAX_SEQ_NO, Long.toString(localCheckpointTracker.getMaxSeqNo()))__                commitData.put(MAX_UNSAFE_AUTO_ID_TIMESTAMP_COMMIT_ID, Long.toString(maxUnsafeAutoIdTimestamp.get()))__                commitData.put(HISTORY_UUID_KEY, historyUUID)__                if (softDeleteEnabled) {_                    commitData.put(Engine.MIN_RETAINED_SEQNO, Long.toString(softDeletesPolicy.getMinRetainedSeqNo()))__                }_                logger.trace("committing writer with commit data [{}]", commitData)__                return commitData.entrySet().iterator()__            })___            writer.commit()__        } catch (final Exception ex) {_            try {_                failEngine("lucene commit failed", ex)__            } catch (final Exception inner) {_                ex.addSuppressed(inner)__            }_            throw ex__        } catch (final AssertionError e) {_            _            if (ExceptionsHelper.stackTrace(e).contains("org.apache.lucene.index.IndexWriter.filesExist")) {_                final EngineException engineException = new EngineException(shardId, "failed to commit engine", e)__                try {_                    failEngine("lucene commit failed", engineException)__                } catch (final Exception inner) {_                    engineException.addSuppressed(inner)__                }_                throw engineException__            } else {_                throw e__            }_        }_    };commits,the,specified,index,writer,param,writer,the,index,writer,to,commit,param,translog,the,translog,param,sync,id,the,sync,flush,id,code,null,if,not,committing,a,synced,flush,throws,ioexception,if,an,i,o,exception,occurs,committing,the,specfied,writer;protected,void,commit,index,writer,final,index,writer,writer,final,translog,translog,nullable,final,string,sync,id,throws,ioexception,ensure,can,flush,try,final,long,local,checkpoint,local,checkpoint,tracker,get,checkpoint,final,translog,translog,generation,translog,generation,translog,get,min,generation,for,seq,no,local,checkpoint,1,final,string,translog,file,generation,long,to,string,translog,generation,translog,file,generation,final,string,translog,uuid,translog,generation,translog,uuid,final,string,local,checkpoint,value,long,to,string,local,checkpoint,writer,set,live,commit,data,final,map,string,string,commit,data,new,hash,map,6,commit,data,put,translog,translog,file,generation,commit,data,put,translog,translog,uuid,commit,data,put,sequence,numbers,local,checkpoint,value,if,sync,id,null,commit,data,put,engine,sync,id,commit,data,put,sequence,numbers,long,to,string,local,checkpoint,tracker,get,max,seq,no,commit,data,put,long,to,string,max,unsafe,auto,id,timestamp,get,commit,data,put,history,uuid,if,soft,delete,enabled,commit,data,put,engine,long,to,string,soft,deletes,policy,get,min,retained,seq,no,logger,trace,committing,writer,with,commit,data,commit,data,return,commit,data,entry,set,iterator,writer,commit,catch,final,exception,ex,try,fail,engine,lucene,commit,failed,ex,catch,final,exception,inner,ex,add,suppressed,inner,throw,ex,catch,final,assertion,error,e,if,exceptions,helper,stack,trace,e,contains,org,apache,lucene,index,index,writer,files,exist,final,engine,exception,engine,exception,new,engine,exception,shard,id,failed,to,commit,engine,e,try,fail,engine,lucene,commit,failed,engine,exception,catch,final,exception,inner,engine,exception,add,suppressed,inner,throw,engine,exception,else,throw,e
InternalEngine -> protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException;1542697754;Commits the specified index writer.__@param writer   the index writer to commit_@param translog the translog_@param syncId   the sync flush ID ({@code null} if not committing a synced flush)_@throws IOException if an I/O exception occurs committing the specfied writer;protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException {_        ensureCanFlush()__        try {_            final long localCheckpoint = localCheckpointTracker.getCheckpoint()__            final Translog.TranslogGeneration translogGeneration = translog.getMinGenerationForSeqNo(localCheckpoint + 1)__            final String translogFileGeneration = Long.toString(translogGeneration.translogFileGeneration)__            final String translogUUID = translogGeneration.translogUUID__            final String localCheckpointValue = Long.toString(localCheckpoint)___            writer.setLiveCommitData(() -> {_                _                final Map<String, String> commitData = new HashMap<>(6)__                commitData.put(Translog.TRANSLOG_GENERATION_KEY, translogFileGeneration)__                commitData.put(Translog.TRANSLOG_UUID_KEY, translogUUID)__                commitData.put(SequenceNumbers.LOCAL_CHECKPOINT_KEY, localCheckpointValue)__                if (syncId != null) {_                    commitData.put(Engine.SYNC_COMMIT_ID, syncId)__                }_                commitData.put(SequenceNumbers.MAX_SEQ_NO, Long.toString(localCheckpointTracker.getMaxSeqNo()))__                commitData.put(MAX_UNSAFE_AUTO_ID_TIMESTAMP_COMMIT_ID, Long.toString(maxUnsafeAutoIdTimestamp.get()))__                commitData.put(HISTORY_UUID_KEY, historyUUID)__                if (softDeleteEnabled) {_                    commitData.put(Engine.MIN_RETAINED_SEQNO, Long.toString(softDeletesPolicy.getMinRetainedSeqNo()))__                }_                logger.trace("committing writer with commit data [{}]", commitData)__                return commitData.entrySet().iterator()__            })___            writer.commit()__        } catch (final Exception ex) {_            try {_                failEngine("lucene commit failed", ex)__            } catch (final Exception inner) {_                ex.addSuppressed(inner)__            }_            throw ex__        } catch (final AssertionError e) {_            _            if (ExceptionsHelper.stackTrace(e).contains("org.apache.lucene.index.IndexWriter.filesExist")) {_                final EngineException engineException = new EngineException(shardId, "failed to commit engine", e)__                try {_                    failEngine("lucene commit failed", engineException)__                } catch (final Exception inner) {_                    engineException.addSuppressed(inner)__                }_                throw engineException__            } else {_                throw e__            }_        }_    };commits,the,specified,index,writer,param,writer,the,index,writer,to,commit,param,translog,the,translog,param,sync,id,the,sync,flush,id,code,null,if,not,committing,a,synced,flush,throws,ioexception,if,an,i,o,exception,occurs,committing,the,specfied,writer;protected,void,commit,index,writer,final,index,writer,writer,final,translog,translog,nullable,final,string,sync,id,throws,ioexception,ensure,can,flush,try,final,long,local,checkpoint,local,checkpoint,tracker,get,checkpoint,final,translog,translog,generation,translog,generation,translog,get,min,generation,for,seq,no,local,checkpoint,1,final,string,translog,file,generation,long,to,string,translog,generation,translog,file,generation,final,string,translog,uuid,translog,generation,translog,uuid,final,string,local,checkpoint,value,long,to,string,local,checkpoint,writer,set,live,commit,data,final,map,string,string,commit,data,new,hash,map,6,commit,data,put,translog,translog,file,generation,commit,data,put,translog,translog,uuid,commit,data,put,sequence,numbers,local,checkpoint,value,if,sync,id,null,commit,data,put,engine,sync,id,commit,data,put,sequence,numbers,long,to,string,local,checkpoint,tracker,get,max,seq,no,commit,data,put,long,to,string,max,unsafe,auto,id,timestamp,get,commit,data,put,history,uuid,if,soft,delete,enabled,commit,data,put,engine,long,to,string,soft,deletes,policy,get,min,retained,seq,no,logger,trace,committing,writer,with,commit,data,commit,data,return,commit,data,entry,set,iterator,writer,commit,catch,final,exception,ex,try,fail,engine,lucene,commit,failed,ex,catch,final,exception,inner,ex,add,suppressed,inner,throw,ex,catch,final,assertion,error,e,if,exceptions,helper,stack,trace,e,contains,org,apache,lucene,index,index,writer,files,exist,final,engine,exception,engine,exception,new,engine,exception,shard,id,failed,to,commit,engine,e,try,fail,engine,lucene,commit,failed,engine,exception,catch,final,exception,inner,engine,exception,add,suppressed,inner,throw,engine,exception,else,throw,e
InternalEngine -> protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException;1543940134;Commits the specified index writer.__@param writer   the index writer to commit_@param translog the translog_@param syncId   the sync flush ID ({@code null} if not committing a synced flush)_@throws IOException if an I/O exception occurs committing the specfied writer;protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException {_        ensureCanFlush()__        try {_            final long localCheckpoint = localCheckpointTracker.getCheckpoint()__            final Translog.TranslogGeneration translogGeneration = translog.getMinGenerationForSeqNo(localCheckpoint + 1)__            final String translogFileGeneration = Long.toString(translogGeneration.translogFileGeneration)__            final String translogUUID = translogGeneration.translogUUID__            final String localCheckpointValue = Long.toString(localCheckpoint)___            writer.setLiveCommitData(() -> {_                _                final Map<String, String> commitData = new HashMap<>(6)__                commitData.put(Translog.TRANSLOG_GENERATION_KEY, translogFileGeneration)__                commitData.put(Translog.TRANSLOG_UUID_KEY, translogUUID)__                commitData.put(SequenceNumbers.LOCAL_CHECKPOINT_KEY, localCheckpointValue)__                if (syncId != null) {_                    commitData.put(Engine.SYNC_COMMIT_ID, syncId)__                }_                commitData.put(SequenceNumbers.MAX_SEQ_NO, Long.toString(localCheckpointTracker.getMaxSeqNo()))__                commitData.put(MAX_UNSAFE_AUTO_ID_TIMESTAMP_COMMIT_ID, Long.toString(maxUnsafeAutoIdTimestamp.get()))__                commitData.put(HISTORY_UUID_KEY, historyUUID)__                if (softDeleteEnabled) {_                    commitData.put(Engine.MIN_RETAINED_SEQNO, Long.toString(softDeletesPolicy.getMinRetainedSeqNo()))__                }_                logger.trace("committing writer with commit data [{}]", commitData)__                return commitData.entrySet().iterator()__            })___            writer.commit()__        } catch (final Exception ex) {_            try {_                failEngine("lucene commit failed", ex)__            } catch (final Exception inner) {_                ex.addSuppressed(inner)__            }_            throw ex__        } catch (final AssertionError e) {_            _            if (ExceptionsHelper.stackTrace(e).contains("org.apache.lucene.index.IndexWriter.filesExist")) {_                final EngineException engineException = new EngineException(shardId, "failed to commit engine", e)__                try {_                    failEngine("lucene commit failed", engineException)__                } catch (final Exception inner) {_                    engineException.addSuppressed(inner)__                }_                throw engineException__            } else {_                throw e__            }_        }_    };commits,the,specified,index,writer,param,writer,the,index,writer,to,commit,param,translog,the,translog,param,sync,id,the,sync,flush,id,code,null,if,not,committing,a,synced,flush,throws,ioexception,if,an,i,o,exception,occurs,committing,the,specfied,writer;protected,void,commit,index,writer,final,index,writer,writer,final,translog,translog,nullable,final,string,sync,id,throws,ioexception,ensure,can,flush,try,final,long,local,checkpoint,local,checkpoint,tracker,get,checkpoint,final,translog,translog,generation,translog,generation,translog,get,min,generation,for,seq,no,local,checkpoint,1,final,string,translog,file,generation,long,to,string,translog,generation,translog,file,generation,final,string,translog,uuid,translog,generation,translog,uuid,final,string,local,checkpoint,value,long,to,string,local,checkpoint,writer,set,live,commit,data,final,map,string,string,commit,data,new,hash,map,6,commit,data,put,translog,translog,file,generation,commit,data,put,translog,translog,uuid,commit,data,put,sequence,numbers,local,checkpoint,value,if,sync,id,null,commit,data,put,engine,sync,id,commit,data,put,sequence,numbers,long,to,string,local,checkpoint,tracker,get,max,seq,no,commit,data,put,long,to,string,max,unsafe,auto,id,timestamp,get,commit,data,put,history,uuid,if,soft,delete,enabled,commit,data,put,engine,long,to,string,soft,deletes,policy,get,min,retained,seq,no,logger,trace,committing,writer,with,commit,data,commit,data,return,commit,data,entry,set,iterator,writer,commit,catch,final,exception,ex,try,fail,engine,lucene,commit,failed,ex,catch,final,exception,inner,ex,add,suppressed,inner,throw,ex,catch,final,assertion,error,e,if,exceptions,helper,stack,trace,e,contains,org,apache,lucene,index,index,writer,files,exist,final,engine,exception,engine,exception,new,engine,exception,shard,id,failed,to,commit,engine,e,try,fail,engine,lucene,commit,failed,engine,exception,catch,final,exception,inner,engine,exception,add,suppressed,inner,throw,engine,exception,else,throw,e
InternalEngine -> protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException;1544322276;Commits the specified index writer.__@param writer   the index writer to commit_@param translog the translog_@param syncId   the sync flush ID ({@code null} if not committing a synced flush)_@throws IOException if an I/O exception occurs committing the specfied writer;protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException {_        ensureCanFlush()__        try {_            final long localCheckpoint = localCheckpointTracker.getCheckpoint()__            final Translog.TranslogGeneration translogGeneration = translog.getMinGenerationForSeqNo(localCheckpoint + 1)__            final String translogFileGeneration = Long.toString(translogGeneration.translogFileGeneration)__            final String translogUUID = translogGeneration.translogUUID__            final String localCheckpointValue = Long.toString(localCheckpoint)___            writer.setLiveCommitData(() -> {_                _                final Map<String, String> commitData = new HashMap<>(6)__                commitData.put(Translog.TRANSLOG_GENERATION_KEY, translogFileGeneration)__                commitData.put(Translog.TRANSLOG_UUID_KEY, translogUUID)__                commitData.put(SequenceNumbers.LOCAL_CHECKPOINT_KEY, localCheckpointValue)__                if (syncId != null) {_                    commitData.put(Engine.SYNC_COMMIT_ID, syncId)__                }_                commitData.put(SequenceNumbers.MAX_SEQ_NO, Long.toString(localCheckpointTracker.getMaxSeqNo()))__                commitData.put(MAX_UNSAFE_AUTO_ID_TIMESTAMP_COMMIT_ID, Long.toString(maxUnsafeAutoIdTimestamp.get()))__                commitData.put(HISTORY_UUID_KEY, historyUUID)__                if (softDeleteEnabled) {_                    commitData.put(Engine.MIN_RETAINED_SEQNO, Long.toString(softDeletesPolicy.getMinRetainedSeqNo()))__                }_                logger.trace("committing writer with commit data [{}]", commitData)__                return commitData.entrySet().iterator()__            })___            writer.commit()__        } catch (final Exception ex) {_            try {_                failEngine("lucene commit failed", ex)__            } catch (final Exception inner) {_                ex.addSuppressed(inner)__            }_            throw ex__        } catch (final AssertionError e) {_            _            if (ExceptionsHelper.stackTrace(e).contains("org.apache.lucene.index.IndexWriter.filesExist")) {_                final EngineException engineException = new EngineException(shardId, "failed to commit engine", e)__                try {_                    failEngine("lucene commit failed", engineException)__                } catch (final Exception inner) {_                    engineException.addSuppressed(inner)__                }_                throw engineException__            } else {_                throw e__            }_        }_    };commits,the,specified,index,writer,param,writer,the,index,writer,to,commit,param,translog,the,translog,param,sync,id,the,sync,flush,id,code,null,if,not,committing,a,synced,flush,throws,ioexception,if,an,i,o,exception,occurs,committing,the,specfied,writer;protected,void,commit,index,writer,final,index,writer,writer,final,translog,translog,nullable,final,string,sync,id,throws,ioexception,ensure,can,flush,try,final,long,local,checkpoint,local,checkpoint,tracker,get,checkpoint,final,translog,translog,generation,translog,generation,translog,get,min,generation,for,seq,no,local,checkpoint,1,final,string,translog,file,generation,long,to,string,translog,generation,translog,file,generation,final,string,translog,uuid,translog,generation,translog,uuid,final,string,local,checkpoint,value,long,to,string,local,checkpoint,writer,set,live,commit,data,final,map,string,string,commit,data,new,hash,map,6,commit,data,put,translog,translog,file,generation,commit,data,put,translog,translog,uuid,commit,data,put,sequence,numbers,local,checkpoint,value,if,sync,id,null,commit,data,put,engine,sync,id,commit,data,put,sequence,numbers,long,to,string,local,checkpoint,tracker,get,max,seq,no,commit,data,put,long,to,string,max,unsafe,auto,id,timestamp,get,commit,data,put,history,uuid,if,soft,delete,enabled,commit,data,put,engine,long,to,string,soft,deletes,policy,get,min,retained,seq,no,logger,trace,committing,writer,with,commit,data,commit,data,return,commit,data,entry,set,iterator,writer,commit,catch,final,exception,ex,try,fail,engine,lucene,commit,failed,ex,catch,final,exception,inner,ex,add,suppressed,inner,throw,ex,catch,final,assertion,error,e,if,exceptions,helper,stack,trace,e,contains,org,apache,lucene,index,index,writer,files,exist,final,engine,exception,engine,exception,new,engine,exception,shard,id,failed,to,commit,engine,e,try,fail,engine,lucene,commit,failed,engine,exception,catch,final,exception,inner,engine,exception,add,suppressed,inner,throw,engine,exception,else,throw,e
InternalEngine -> protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException;1544545090;Commits the specified index writer.__@param writer   the index writer to commit_@param translog the translog_@param syncId   the sync flush ID ({@code null} if not committing a synced flush)_@throws IOException if an I/O exception occurs committing the specfied writer;protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException {_        ensureCanFlush()__        try {_            final long localCheckpoint = localCheckpointTracker.getCheckpoint()__            final Translog.TranslogGeneration translogGeneration = translog.getMinGenerationForSeqNo(localCheckpoint + 1)__            final String translogFileGeneration = Long.toString(translogGeneration.translogFileGeneration)__            final String translogUUID = translogGeneration.translogUUID__            final String localCheckpointValue = Long.toString(localCheckpoint)___            writer.setLiveCommitData(() -> {_                _                final Map<String, String> commitData = new HashMap<>(6)__                commitData.put(Translog.TRANSLOG_GENERATION_KEY, translogFileGeneration)__                commitData.put(Translog.TRANSLOG_UUID_KEY, translogUUID)__                commitData.put(SequenceNumbers.LOCAL_CHECKPOINT_KEY, localCheckpointValue)__                if (syncId != null) {_                    commitData.put(Engine.SYNC_COMMIT_ID, syncId)__                }_                commitData.put(SequenceNumbers.MAX_SEQ_NO, Long.toString(localCheckpointTracker.getMaxSeqNo()))__                commitData.put(MAX_UNSAFE_AUTO_ID_TIMESTAMP_COMMIT_ID, Long.toString(maxUnsafeAutoIdTimestamp.get()))__                commitData.put(HISTORY_UUID_KEY, historyUUID)__                if (softDeleteEnabled) {_                    commitData.put(Engine.MIN_RETAINED_SEQNO, Long.toString(softDeletesPolicy.getMinRetainedSeqNo()))__                }_                logger.trace("committing writer with commit data [{}]", commitData)__                return commitData.entrySet().iterator()__            })___            writer.commit()__        } catch (final Exception ex) {_            try {_                failEngine("lucene commit failed", ex)__            } catch (final Exception inner) {_                ex.addSuppressed(inner)__            }_            throw ex__        } catch (final AssertionError e) {_            _            if (ExceptionsHelper.stackTrace(e).contains("org.apache.lucene.index.IndexWriter.filesExist")) {_                final EngineException engineException = new EngineException(shardId, "failed to commit engine", e)__                try {_                    failEngine("lucene commit failed", engineException)__                } catch (final Exception inner) {_                    engineException.addSuppressed(inner)__                }_                throw engineException__            } else {_                throw e__            }_        }_    };commits,the,specified,index,writer,param,writer,the,index,writer,to,commit,param,translog,the,translog,param,sync,id,the,sync,flush,id,code,null,if,not,committing,a,synced,flush,throws,ioexception,if,an,i,o,exception,occurs,committing,the,specfied,writer;protected,void,commit,index,writer,final,index,writer,writer,final,translog,translog,nullable,final,string,sync,id,throws,ioexception,ensure,can,flush,try,final,long,local,checkpoint,local,checkpoint,tracker,get,checkpoint,final,translog,translog,generation,translog,generation,translog,get,min,generation,for,seq,no,local,checkpoint,1,final,string,translog,file,generation,long,to,string,translog,generation,translog,file,generation,final,string,translog,uuid,translog,generation,translog,uuid,final,string,local,checkpoint,value,long,to,string,local,checkpoint,writer,set,live,commit,data,final,map,string,string,commit,data,new,hash,map,6,commit,data,put,translog,translog,file,generation,commit,data,put,translog,translog,uuid,commit,data,put,sequence,numbers,local,checkpoint,value,if,sync,id,null,commit,data,put,engine,sync,id,commit,data,put,sequence,numbers,long,to,string,local,checkpoint,tracker,get,max,seq,no,commit,data,put,long,to,string,max,unsafe,auto,id,timestamp,get,commit,data,put,history,uuid,if,soft,delete,enabled,commit,data,put,engine,long,to,string,soft,deletes,policy,get,min,retained,seq,no,logger,trace,committing,writer,with,commit,data,commit,data,return,commit,data,entry,set,iterator,writer,commit,catch,final,exception,ex,try,fail,engine,lucene,commit,failed,ex,catch,final,exception,inner,ex,add,suppressed,inner,throw,ex,catch,final,assertion,error,e,if,exceptions,helper,stack,trace,e,contains,org,apache,lucene,index,index,writer,files,exist,final,engine,exception,engine,exception,new,engine,exception,shard,id,failed,to,commit,engine,e,try,fail,engine,lucene,commit,failed,engine,exception,catch,final,exception,inner,engine,exception,add,suppressed,inner,throw,engine,exception,else,throw,e
InternalEngine -> protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException;1544684920;Commits the specified index writer.__@param writer   the index writer to commit_@param translog the translog_@param syncId   the sync flush ID ({@code null} if not committing a synced flush)_@throws IOException if an I/O exception occurs committing the specfied writer;protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException {_        ensureCanFlush()__        try {_            final long localCheckpoint = localCheckpointTracker.getCheckpoint()__            final Translog.TranslogGeneration translogGeneration = translog.getMinGenerationForSeqNo(localCheckpoint + 1)__            final String translogFileGeneration = Long.toString(translogGeneration.translogFileGeneration)__            final String translogUUID = translogGeneration.translogUUID__            final String localCheckpointValue = Long.toString(localCheckpoint)___            writer.setLiveCommitData(() -> {_                _                final Map<String, String> commitData = new HashMap<>(6)__                commitData.put(Translog.TRANSLOG_GENERATION_KEY, translogFileGeneration)__                commitData.put(Translog.TRANSLOG_UUID_KEY, translogUUID)__                commitData.put(SequenceNumbers.LOCAL_CHECKPOINT_KEY, localCheckpointValue)__                if (syncId != null) {_                    commitData.put(Engine.SYNC_COMMIT_ID, syncId)__                }_                commitData.put(SequenceNumbers.MAX_SEQ_NO, Long.toString(localCheckpointTracker.getMaxSeqNo()))__                commitData.put(MAX_UNSAFE_AUTO_ID_TIMESTAMP_COMMIT_ID, Long.toString(maxUnsafeAutoIdTimestamp.get()))__                commitData.put(HISTORY_UUID_KEY, historyUUID)__                if (softDeleteEnabled) {_                    commitData.put(Engine.MIN_RETAINED_SEQNO, Long.toString(softDeletesPolicy.getMinRetainedSeqNo()))__                }_                logger.trace("committing writer with commit data [{}]", commitData)__                return commitData.entrySet().iterator()__            })___            writer.commit()__        } catch (final Exception ex) {_            try {_                failEngine("lucene commit failed", ex)__            } catch (final Exception inner) {_                ex.addSuppressed(inner)__            }_            throw ex__        } catch (final AssertionError e) {_            _            if (ExceptionsHelper.stackTrace(e).contains("org.apache.lucene.index.IndexWriter.filesExist")) {_                final EngineException engineException = new EngineException(shardId, "failed to commit engine", e)__                try {_                    failEngine("lucene commit failed", engineException)__                } catch (final Exception inner) {_                    engineException.addSuppressed(inner)__                }_                throw engineException__            } else {_                throw e__            }_        }_    };commits,the,specified,index,writer,param,writer,the,index,writer,to,commit,param,translog,the,translog,param,sync,id,the,sync,flush,id,code,null,if,not,committing,a,synced,flush,throws,ioexception,if,an,i,o,exception,occurs,committing,the,specfied,writer;protected,void,commit,index,writer,final,index,writer,writer,final,translog,translog,nullable,final,string,sync,id,throws,ioexception,ensure,can,flush,try,final,long,local,checkpoint,local,checkpoint,tracker,get,checkpoint,final,translog,translog,generation,translog,generation,translog,get,min,generation,for,seq,no,local,checkpoint,1,final,string,translog,file,generation,long,to,string,translog,generation,translog,file,generation,final,string,translog,uuid,translog,generation,translog,uuid,final,string,local,checkpoint,value,long,to,string,local,checkpoint,writer,set,live,commit,data,final,map,string,string,commit,data,new,hash,map,6,commit,data,put,translog,translog,file,generation,commit,data,put,translog,translog,uuid,commit,data,put,sequence,numbers,local,checkpoint,value,if,sync,id,null,commit,data,put,engine,sync,id,commit,data,put,sequence,numbers,long,to,string,local,checkpoint,tracker,get,max,seq,no,commit,data,put,long,to,string,max,unsafe,auto,id,timestamp,get,commit,data,put,history,uuid,if,soft,delete,enabled,commit,data,put,engine,long,to,string,soft,deletes,policy,get,min,retained,seq,no,logger,trace,committing,writer,with,commit,data,commit,data,return,commit,data,entry,set,iterator,writer,commit,catch,final,exception,ex,try,fail,engine,lucene,commit,failed,ex,catch,final,exception,inner,ex,add,suppressed,inner,throw,ex,catch,final,assertion,error,e,if,exceptions,helper,stack,trace,e,contains,org,apache,lucene,index,index,writer,files,exist,final,engine,exception,engine,exception,new,engine,exception,shard,id,failed,to,commit,engine,e,try,fail,engine,lucene,commit,failed,engine,exception,catch,final,exception,inner,engine,exception,add,suppressed,inner,throw,engine,exception,else,throw,e
InternalEngine -> protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException;1545140118;Commits the specified index writer.__@param writer   the index writer to commit_@param translog the translog_@param syncId   the sync flush ID ({@code null} if not committing a synced flush)_@throws IOException if an I/O exception occurs committing the specfied writer;protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException {_        ensureCanFlush()__        try {_            final long localCheckpoint = localCheckpointTracker.getCheckpoint()__            final Translog.TranslogGeneration translogGeneration = translog.getMinGenerationForSeqNo(localCheckpoint + 1)__            final String translogFileGeneration = Long.toString(translogGeneration.translogFileGeneration)__            final String translogUUID = translogGeneration.translogUUID__            final String localCheckpointValue = Long.toString(localCheckpoint)___            writer.setLiveCommitData(() -> {_                _                final Map<String, String> commitData = new HashMap<>(6)__                commitData.put(Translog.TRANSLOG_GENERATION_KEY, translogFileGeneration)__                commitData.put(Translog.TRANSLOG_UUID_KEY, translogUUID)__                commitData.put(SequenceNumbers.LOCAL_CHECKPOINT_KEY, localCheckpointValue)__                if (syncId != null) {_                    commitData.put(Engine.SYNC_COMMIT_ID, syncId)__                }_                commitData.put(SequenceNumbers.MAX_SEQ_NO, Long.toString(localCheckpointTracker.getMaxSeqNo()))__                commitData.put(MAX_UNSAFE_AUTO_ID_TIMESTAMP_COMMIT_ID, Long.toString(maxUnsafeAutoIdTimestamp.get()))__                commitData.put(HISTORY_UUID_KEY, historyUUID)__                if (softDeleteEnabled) {_                    commitData.put(Engine.MIN_RETAINED_SEQNO, Long.toString(softDeletesPolicy.getMinRetainedSeqNo()))__                }_                logger.trace("committing writer with commit data [{}]", commitData)__                return commitData.entrySet().iterator()__            })___            writer.commit()__        } catch (final Exception ex) {_            try {_                failEngine("lucene commit failed", ex)__            } catch (final Exception inner) {_                ex.addSuppressed(inner)__            }_            throw ex__        } catch (final AssertionError e) {_            _            if (ExceptionsHelper.stackTrace(e).contains("org.apache.lucene.index.IndexWriter.filesExist")) {_                final EngineException engineException = new EngineException(shardId, "failed to commit engine", e)__                try {_                    failEngine("lucene commit failed", engineException)__                } catch (final Exception inner) {_                    engineException.addSuppressed(inner)__                }_                throw engineException__            } else {_                throw e__            }_        }_    };commits,the,specified,index,writer,param,writer,the,index,writer,to,commit,param,translog,the,translog,param,sync,id,the,sync,flush,id,code,null,if,not,committing,a,synced,flush,throws,ioexception,if,an,i,o,exception,occurs,committing,the,specfied,writer;protected,void,commit,index,writer,final,index,writer,writer,final,translog,translog,nullable,final,string,sync,id,throws,ioexception,ensure,can,flush,try,final,long,local,checkpoint,local,checkpoint,tracker,get,checkpoint,final,translog,translog,generation,translog,generation,translog,get,min,generation,for,seq,no,local,checkpoint,1,final,string,translog,file,generation,long,to,string,translog,generation,translog,file,generation,final,string,translog,uuid,translog,generation,translog,uuid,final,string,local,checkpoint,value,long,to,string,local,checkpoint,writer,set,live,commit,data,final,map,string,string,commit,data,new,hash,map,6,commit,data,put,translog,translog,file,generation,commit,data,put,translog,translog,uuid,commit,data,put,sequence,numbers,local,checkpoint,value,if,sync,id,null,commit,data,put,engine,sync,id,commit,data,put,sequence,numbers,long,to,string,local,checkpoint,tracker,get,max,seq,no,commit,data,put,long,to,string,max,unsafe,auto,id,timestamp,get,commit,data,put,history,uuid,if,soft,delete,enabled,commit,data,put,engine,long,to,string,soft,deletes,policy,get,min,retained,seq,no,logger,trace,committing,writer,with,commit,data,commit,data,return,commit,data,entry,set,iterator,writer,commit,catch,final,exception,ex,try,fail,engine,lucene,commit,failed,ex,catch,final,exception,inner,ex,add,suppressed,inner,throw,ex,catch,final,assertion,error,e,if,exceptions,helper,stack,trace,e,contains,org,apache,lucene,index,index,writer,files,exist,final,engine,exception,engine,exception,new,engine,exception,shard,id,failed,to,commit,engine,e,try,fail,engine,lucene,commit,failed,engine,exception,catch,final,exception,inner,engine,exception,add,suppressed,inner,throw,engine,exception,else,throw,e
InternalEngine -> protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException;1546875837;Commits the specified index writer.__@param writer   the index writer to commit_@param translog the translog_@param syncId   the sync flush ID ({@code null} if not committing a synced flush)_@throws IOException if an I/O exception occurs committing the specfied writer;protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException {_        ensureCanFlush()__        try {_            final long localCheckpoint = localCheckpointTracker.getCheckpoint()__            final Translog.TranslogGeneration translogGeneration = translog.getMinGenerationForSeqNo(localCheckpoint + 1)__            final String translogFileGeneration = Long.toString(translogGeneration.translogFileGeneration)__            final String translogUUID = translogGeneration.translogUUID__            final String localCheckpointValue = Long.toString(localCheckpoint)___            writer.setLiveCommitData(() -> {_                _                final Map<String, String> commitData = new HashMap<>(6)__                commitData.put(Translog.TRANSLOG_GENERATION_KEY, translogFileGeneration)__                commitData.put(Translog.TRANSLOG_UUID_KEY, translogUUID)__                commitData.put(SequenceNumbers.LOCAL_CHECKPOINT_KEY, localCheckpointValue)__                if (syncId != null) {_                    commitData.put(Engine.SYNC_COMMIT_ID, syncId)__                }_                commitData.put(SequenceNumbers.MAX_SEQ_NO, Long.toString(localCheckpointTracker.getMaxSeqNo()))__                commitData.put(MAX_UNSAFE_AUTO_ID_TIMESTAMP_COMMIT_ID, Long.toString(maxUnsafeAutoIdTimestamp.get()))__                commitData.put(HISTORY_UUID_KEY, historyUUID)__                if (softDeleteEnabled) {_                    commitData.put(Engine.MIN_RETAINED_SEQNO, Long.toString(softDeletesPolicy.getMinRetainedSeqNo()))__                }_                logger.trace("committing writer with commit data [{}]", commitData)__                return commitData.entrySet().iterator()__            })___            writer.commit()__        } catch (final Exception ex) {_            try {_                failEngine("lucene commit failed", ex)__            } catch (final Exception inner) {_                ex.addSuppressed(inner)__            }_            throw ex__        } catch (final AssertionError e) {_            _            if (ExceptionsHelper.stackTrace(e).contains("org.apache.lucene.index.IndexWriter.filesExist")) {_                final EngineException engineException = new EngineException(shardId, "failed to commit engine", e)__                try {_                    failEngine("lucene commit failed", engineException)__                } catch (final Exception inner) {_                    engineException.addSuppressed(inner)__                }_                throw engineException__            } else {_                throw e__            }_        }_    };commits,the,specified,index,writer,param,writer,the,index,writer,to,commit,param,translog,the,translog,param,sync,id,the,sync,flush,id,code,null,if,not,committing,a,synced,flush,throws,ioexception,if,an,i,o,exception,occurs,committing,the,specfied,writer;protected,void,commit,index,writer,final,index,writer,writer,final,translog,translog,nullable,final,string,sync,id,throws,ioexception,ensure,can,flush,try,final,long,local,checkpoint,local,checkpoint,tracker,get,checkpoint,final,translog,translog,generation,translog,generation,translog,get,min,generation,for,seq,no,local,checkpoint,1,final,string,translog,file,generation,long,to,string,translog,generation,translog,file,generation,final,string,translog,uuid,translog,generation,translog,uuid,final,string,local,checkpoint,value,long,to,string,local,checkpoint,writer,set,live,commit,data,final,map,string,string,commit,data,new,hash,map,6,commit,data,put,translog,translog,file,generation,commit,data,put,translog,translog,uuid,commit,data,put,sequence,numbers,local,checkpoint,value,if,sync,id,null,commit,data,put,engine,sync,id,commit,data,put,sequence,numbers,long,to,string,local,checkpoint,tracker,get,max,seq,no,commit,data,put,long,to,string,max,unsafe,auto,id,timestamp,get,commit,data,put,history,uuid,if,soft,delete,enabled,commit,data,put,engine,long,to,string,soft,deletes,policy,get,min,retained,seq,no,logger,trace,committing,writer,with,commit,data,commit,data,return,commit,data,entry,set,iterator,writer,commit,catch,final,exception,ex,try,fail,engine,lucene,commit,failed,ex,catch,final,exception,inner,ex,add,suppressed,inner,throw,ex,catch,final,assertion,error,e,if,exceptions,helper,stack,trace,e,contains,org,apache,lucene,index,index,writer,files,exist,final,engine,exception,engine,exception,new,engine,exception,shard,id,failed,to,commit,engine,e,try,fail,engine,lucene,commit,failed,engine,exception,catch,final,exception,inner,engine,exception,add,suppressed,inner,throw,engine,exception,else,throw,e
InternalEngine -> protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException;1547332999;Commits the specified index writer.__@param writer   the index writer to commit_@param translog the translog_@param syncId   the sync flush ID ({@code null} if not committing a synced flush)_@throws IOException if an I/O exception occurs committing the specfied writer;protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException {_        ensureCanFlush()__        try {_            final long localCheckpoint = localCheckpointTracker.getCheckpoint()__            final Translog.TranslogGeneration translogGeneration = translog.getMinGenerationForSeqNo(localCheckpoint + 1)__            final String translogFileGeneration = Long.toString(translogGeneration.translogFileGeneration)__            final String translogUUID = translogGeneration.translogUUID__            final String localCheckpointValue = Long.toString(localCheckpoint)___            writer.setLiveCommitData(() -> {_                _                final Map<String, String> commitData = new HashMap<>(6)__                commitData.put(Translog.TRANSLOG_GENERATION_KEY, translogFileGeneration)__                commitData.put(Translog.TRANSLOG_UUID_KEY, translogUUID)__                commitData.put(SequenceNumbers.LOCAL_CHECKPOINT_KEY, localCheckpointValue)__                if (syncId != null) {_                    commitData.put(Engine.SYNC_COMMIT_ID, syncId)__                }_                commitData.put(SequenceNumbers.MAX_SEQ_NO, Long.toString(localCheckpointTracker.getMaxSeqNo()))__                commitData.put(MAX_UNSAFE_AUTO_ID_TIMESTAMP_COMMIT_ID, Long.toString(maxUnsafeAutoIdTimestamp.get()))__                commitData.put(HISTORY_UUID_KEY, historyUUID)__                if (softDeleteEnabled) {_                    _                    final Tuple<Long, Collection<RetentionLease>> retentionPolicy = softDeletesPolicy.getRetentionPolicy()__                    commitData.put(Engine.MIN_RETAINED_SEQNO, Long.toString(retentionPolicy.v1()))__                    commitData.put(Engine.RETENTION_LEASES, RetentionLease.encodeRetentionLeases(retentionPolicy.v2()))__                }_                logger.trace("committing writer with commit data [{}]", commitData)__                return commitData.entrySet().iterator()__            })___            writer.commit()__        } catch (final Exception ex) {_            try {_                failEngine("lucene commit failed", ex)__            } catch (final Exception inner) {_                ex.addSuppressed(inner)__            }_            throw ex__        } catch (final AssertionError e) {_            _            if (ExceptionsHelper.stackTrace(e).contains("org.apache.lucene.index.IndexWriter.filesExist")) {_                final EngineException engineException = new EngineException(shardId, "failed to commit engine", e)__                try {_                    failEngine("lucene commit failed", engineException)__                } catch (final Exception inner) {_                    engineException.addSuppressed(inner)__                }_                throw engineException__            } else {_                throw e__            }_        }_    };commits,the,specified,index,writer,param,writer,the,index,writer,to,commit,param,translog,the,translog,param,sync,id,the,sync,flush,id,code,null,if,not,committing,a,synced,flush,throws,ioexception,if,an,i,o,exception,occurs,committing,the,specfied,writer;protected,void,commit,index,writer,final,index,writer,writer,final,translog,translog,nullable,final,string,sync,id,throws,ioexception,ensure,can,flush,try,final,long,local,checkpoint,local,checkpoint,tracker,get,checkpoint,final,translog,translog,generation,translog,generation,translog,get,min,generation,for,seq,no,local,checkpoint,1,final,string,translog,file,generation,long,to,string,translog,generation,translog,file,generation,final,string,translog,uuid,translog,generation,translog,uuid,final,string,local,checkpoint,value,long,to,string,local,checkpoint,writer,set,live,commit,data,final,map,string,string,commit,data,new,hash,map,6,commit,data,put,translog,translog,file,generation,commit,data,put,translog,translog,uuid,commit,data,put,sequence,numbers,local,checkpoint,value,if,sync,id,null,commit,data,put,engine,sync,id,commit,data,put,sequence,numbers,long,to,string,local,checkpoint,tracker,get,max,seq,no,commit,data,put,long,to,string,max,unsafe,auto,id,timestamp,get,commit,data,put,history,uuid,if,soft,delete,enabled,final,tuple,long,collection,retention,lease,retention,policy,soft,deletes,policy,get,retention,policy,commit,data,put,engine,long,to,string,retention,policy,v1,commit,data,put,engine,retention,lease,encode,retention,leases,retention,policy,v2,logger,trace,committing,writer,with,commit,data,commit,data,return,commit,data,entry,set,iterator,writer,commit,catch,final,exception,ex,try,fail,engine,lucene,commit,failed,ex,catch,final,exception,inner,ex,add,suppressed,inner,throw,ex,catch,final,assertion,error,e,if,exceptions,helper,stack,trace,e,contains,org,apache,lucene,index,index,writer,files,exist,final,engine,exception,engine,exception,new,engine,exception,shard,id,failed,to,commit,engine,e,try,fail,engine,lucene,commit,failed,engine,exception,catch,final,exception,inner,engine,exception,add,suppressed,inner,throw,engine,exception,else,throw,e
InternalEngine -> protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException;1548771485;Commits the specified index writer.__@param writer   the index writer to commit_@param translog the translog_@param syncId   the sync flush ID ({@code null} if not committing a synced flush)_@throws IOException if an I/O exception occurs committing the specfied writer;protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException {_        ensureCanFlush()__        try {_            final long localCheckpoint = localCheckpointTracker.getCheckpoint()__            final Translog.TranslogGeneration translogGeneration = translog.getMinGenerationForSeqNo(localCheckpoint + 1)__            final String translogFileGeneration = Long.toString(translogGeneration.translogFileGeneration)__            final String translogUUID = translogGeneration.translogUUID__            final String localCheckpointValue = Long.toString(localCheckpoint)___            writer.setLiveCommitData(() -> {_                _                final Map<String, String> commitData = new HashMap<>(6)__                commitData.put(Translog.TRANSLOG_GENERATION_KEY, translogFileGeneration)__                commitData.put(Translog.TRANSLOG_UUID_KEY, translogUUID)__                commitData.put(SequenceNumbers.LOCAL_CHECKPOINT_KEY, localCheckpointValue)__                if (syncId != null) {_                    commitData.put(Engine.SYNC_COMMIT_ID, syncId)__                }_                commitData.put(SequenceNumbers.MAX_SEQ_NO, Long.toString(localCheckpointTracker.getMaxSeqNo()))__                commitData.put(MAX_UNSAFE_AUTO_ID_TIMESTAMP_COMMIT_ID, Long.toString(maxUnsafeAutoIdTimestamp.get()))__                commitData.put(HISTORY_UUID_KEY, historyUUID)__                if (softDeleteEnabled) {_                    _                    final Tuple<Long, Collection<RetentionLease>> retentionPolicy = softDeletesPolicy.getRetentionPolicy()__                    commitData.put(Engine.MIN_RETAINED_SEQNO, Long.toString(retentionPolicy.v1()))__                    commitData.put(Engine.RETENTION_LEASES, RetentionLease.encodeRetentionLeases(retentionPolicy.v2()))__                }_                logger.trace("committing writer with commit data [{}]", commitData)__                return commitData.entrySet().iterator()__            })___            writer.commit()__        } catch (final Exception ex) {_            try {_                failEngine("lucene commit failed", ex)__            } catch (final Exception inner) {_                ex.addSuppressed(inner)__            }_            throw ex__        } catch (final AssertionError e) {_            _            if (ExceptionsHelper.stackTrace(e).contains("org.apache.lucene.index.IndexWriter.filesExist")) {_                final EngineException engineException = new EngineException(shardId, "failed to commit engine", e)__                try {_                    failEngine("lucene commit failed", engineException)__                } catch (final Exception inner) {_                    engineException.addSuppressed(inner)__                }_                throw engineException__            } else {_                throw e__            }_        }_    };commits,the,specified,index,writer,param,writer,the,index,writer,to,commit,param,translog,the,translog,param,sync,id,the,sync,flush,id,code,null,if,not,committing,a,synced,flush,throws,ioexception,if,an,i,o,exception,occurs,committing,the,specfied,writer;protected,void,commit,index,writer,final,index,writer,writer,final,translog,translog,nullable,final,string,sync,id,throws,ioexception,ensure,can,flush,try,final,long,local,checkpoint,local,checkpoint,tracker,get,checkpoint,final,translog,translog,generation,translog,generation,translog,get,min,generation,for,seq,no,local,checkpoint,1,final,string,translog,file,generation,long,to,string,translog,generation,translog,file,generation,final,string,translog,uuid,translog,generation,translog,uuid,final,string,local,checkpoint,value,long,to,string,local,checkpoint,writer,set,live,commit,data,final,map,string,string,commit,data,new,hash,map,6,commit,data,put,translog,translog,file,generation,commit,data,put,translog,translog,uuid,commit,data,put,sequence,numbers,local,checkpoint,value,if,sync,id,null,commit,data,put,engine,sync,id,commit,data,put,sequence,numbers,long,to,string,local,checkpoint,tracker,get,max,seq,no,commit,data,put,long,to,string,max,unsafe,auto,id,timestamp,get,commit,data,put,history,uuid,if,soft,delete,enabled,final,tuple,long,collection,retention,lease,retention,policy,soft,deletes,policy,get,retention,policy,commit,data,put,engine,long,to,string,retention,policy,v1,commit,data,put,engine,retention,lease,encode,retention,leases,retention,policy,v2,logger,trace,committing,writer,with,commit,data,commit,data,return,commit,data,entry,set,iterator,writer,commit,catch,final,exception,ex,try,fail,engine,lucene,commit,failed,ex,catch,final,exception,inner,ex,add,suppressed,inner,throw,ex,catch,final,assertion,error,e,if,exceptions,helper,stack,trace,e,contains,org,apache,lucene,index,index,writer,files,exist,final,engine,exception,engine,exception,new,engine,exception,shard,id,failed,to,commit,engine,e,try,fail,engine,lucene,commit,failed,engine,exception,catch,final,exception,inner,engine,exception,add,suppressed,inner,throw,engine,exception,else,throw,e
InternalEngine -> protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException;1549059559;Commits the specified index writer.__@param writer   the index writer to commit_@param translog the translog_@param syncId   the sync flush ID ({@code null} if not committing a synced flush)_@throws IOException if an I/O exception occurs committing the specfied writer;protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException {_        ensureCanFlush()__        try {_            final long localCheckpoint = localCheckpointTracker.getCheckpoint()__            final Translog.TranslogGeneration translogGeneration = translog.getMinGenerationForSeqNo(localCheckpoint + 1)__            final String translogFileGeneration = Long.toString(translogGeneration.translogFileGeneration)__            final String translogUUID = translogGeneration.translogUUID__            final String localCheckpointValue = Long.toString(localCheckpoint)___            writer.setLiveCommitData(() -> {_                _                final Map<String, String> commitData = new HashMap<>(6)__                commitData.put(Translog.TRANSLOG_GENERATION_KEY, translogFileGeneration)__                commitData.put(Translog.TRANSLOG_UUID_KEY, translogUUID)__                commitData.put(SequenceNumbers.LOCAL_CHECKPOINT_KEY, localCheckpointValue)__                if (syncId != null) {_                    commitData.put(Engine.SYNC_COMMIT_ID, syncId)__                }_                commitData.put(SequenceNumbers.MAX_SEQ_NO, Long.toString(localCheckpointTracker.getMaxSeqNo()))__                commitData.put(MAX_UNSAFE_AUTO_ID_TIMESTAMP_COMMIT_ID, Long.toString(maxUnsafeAutoIdTimestamp.get()))__                commitData.put(HISTORY_UUID_KEY, historyUUID)__                if (softDeleteEnabled) {_                    _                    final Tuple<Long, RetentionLeases> retentionPolicy = softDeletesPolicy.getRetentionPolicy()__                    commitData.put(Engine.MIN_RETAINED_SEQNO, Long.toString(retentionPolicy.v1()))__                    commitData.put(Engine.RETENTION_LEASES, RetentionLeases.encodeRetentionLeases(retentionPolicy.v2()))__                }_                logger.trace("committing writer with commit data [{}]", commitData)__                return commitData.entrySet().iterator()__            })___            writer.commit()__        } catch (final Exception ex) {_            try {_                failEngine("lucene commit failed", ex)__            } catch (final Exception inner) {_                ex.addSuppressed(inner)__            }_            throw ex__        } catch (final AssertionError e) {_            _            if (ExceptionsHelper.stackTrace(e).contains("org.apache.lucene.index.IndexWriter.filesExist")) {_                final EngineException engineException = new EngineException(shardId, "failed to commit engine", e)__                try {_                    failEngine("lucene commit failed", engineException)__                } catch (final Exception inner) {_                    engineException.addSuppressed(inner)__                }_                throw engineException__            } else {_                throw e__            }_        }_    };commits,the,specified,index,writer,param,writer,the,index,writer,to,commit,param,translog,the,translog,param,sync,id,the,sync,flush,id,code,null,if,not,committing,a,synced,flush,throws,ioexception,if,an,i,o,exception,occurs,committing,the,specfied,writer;protected,void,commit,index,writer,final,index,writer,writer,final,translog,translog,nullable,final,string,sync,id,throws,ioexception,ensure,can,flush,try,final,long,local,checkpoint,local,checkpoint,tracker,get,checkpoint,final,translog,translog,generation,translog,generation,translog,get,min,generation,for,seq,no,local,checkpoint,1,final,string,translog,file,generation,long,to,string,translog,generation,translog,file,generation,final,string,translog,uuid,translog,generation,translog,uuid,final,string,local,checkpoint,value,long,to,string,local,checkpoint,writer,set,live,commit,data,final,map,string,string,commit,data,new,hash,map,6,commit,data,put,translog,translog,file,generation,commit,data,put,translog,translog,uuid,commit,data,put,sequence,numbers,local,checkpoint,value,if,sync,id,null,commit,data,put,engine,sync,id,commit,data,put,sequence,numbers,long,to,string,local,checkpoint,tracker,get,max,seq,no,commit,data,put,long,to,string,max,unsafe,auto,id,timestamp,get,commit,data,put,history,uuid,if,soft,delete,enabled,final,tuple,long,retention,leases,retention,policy,soft,deletes,policy,get,retention,policy,commit,data,put,engine,long,to,string,retention,policy,v1,commit,data,put,engine,retention,leases,encode,retention,leases,retention,policy,v2,logger,trace,committing,writer,with,commit,data,commit,data,return,commit,data,entry,set,iterator,writer,commit,catch,final,exception,ex,try,fail,engine,lucene,commit,failed,ex,catch,final,exception,inner,ex,add,suppressed,inner,throw,ex,catch,final,assertion,error,e,if,exceptions,helper,stack,trace,e,contains,org,apache,lucene,index,index,writer,files,exist,final,engine,exception,engine,exception,new,engine,exception,shard,id,failed,to,commit,engine,e,try,fail,engine,lucene,commit,failed,engine,exception,catch,final,exception,inner,engine,exception,add,suppressed,inner,throw,engine,exception,else,throw,e
InternalEngine -> protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException;1549663373;Commits the specified index writer.__@param writer   the index writer to commit_@param translog the translog_@param syncId   the sync flush ID ({@code null} if not committing a synced flush)_@throws IOException if an I/O exception occurs committing the specfied writer;protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException {_        ensureCanFlush()__        try {_            final long localCheckpoint = localCheckpointTracker.getCheckpoint()__            final Translog.TranslogGeneration translogGeneration = translog.getMinGenerationForSeqNo(localCheckpoint + 1)__            final String translogFileGeneration = Long.toString(translogGeneration.translogFileGeneration)__            final String translogUUID = translogGeneration.translogUUID__            final String localCheckpointValue = Long.toString(localCheckpoint)___            writer.setLiveCommitData(() -> {_                _                final Map<String, String> commitData = new HashMap<>(6)__                commitData.put(Translog.TRANSLOG_GENERATION_KEY, translogFileGeneration)__                commitData.put(Translog.TRANSLOG_UUID_KEY, translogUUID)__                commitData.put(SequenceNumbers.LOCAL_CHECKPOINT_KEY, localCheckpointValue)__                if (syncId != null) {_                    commitData.put(Engine.SYNC_COMMIT_ID, syncId)__                }_                commitData.put(SequenceNumbers.MAX_SEQ_NO, Long.toString(localCheckpointTracker.getMaxSeqNo()))__                commitData.put(MAX_UNSAFE_AUTO_ID_TIMESTAMP_COMMIT_ID, Long.toString(maxUnsafeAutoIdTimestamp.get()))__                commitData.put(HISTORY_UUID_KEY, historyUUID)__                if (softDeleteEnabled) {_                    _                    final Tuple<Long, RetentionLeases> retentionPolicy = softDeletesPolicy.getRetentionPolicy()__                    commitData.put(Engine.MIN_RETAINED_SEQNO, Long.toString(retentionPolicy.v1()))__                    commitData.put(Engine.RETENTION_LEASES, RetentionLeases.encodeRetentionLeases(retentionPolicy.v2()))__                }_                logger.trace("committing writer with commit data [{}]", commitData)__                return commitData.entrySet().iterator()__            })___            writer.commit()__        } catch (final Exception ex) {_            try {_                failEngine("lucene commit failed", ex)__            } catch (final Exception inner) {_                ex.addSuppressed(inner)__            }_            throw ex__        } catch (final AssertionError e) {_            _            if (ExceptionsHelper.stackTrace(e).contains("org.apache.lucene.index.IndexWriter.filesExist")) {_                final EngineException engineException = new EngineException(shardId, "failed to commit engine", e)__                try {_                    failEngine("lucene commit failed", engineException)__                } catch (final Exception inner) {_                    engineException.addSuppressed(inner)__                }_                throw engineException__            } else {_                throw e__            }_        }_    };commits,the,specified,index,writer,param,writer,the,index,writer,to,commit,param,translog,the,translog,param,sync,id,the,sync,flush,id,code,null,if,not,committing,a,synced,flush,throws,ioexception,if,an,i,o,exception,occurs,committing,the,specfied,writer;protected,void,commit,index,writer,final,index,writer,writer,final,translog,translog,nullable,final,string,sync,id,throws,ioexception,ensure,can,flush,try,final,long,local,checkpoint,local,checkpoint,tracker,get,checkpoint,final,translog,translog,generation,translog,generation,translog,get,min,generation,for,seq,no,local,checkpoint,1,final,string,translog,file,generation,long,to,string,translog,generation,translog,file,generation,final,string,translog,uuid,translog,generation,translog,uuid,final,string,local,checkpoint,value,long,to,string,local,checkpoint,writer,set,live,commit,data,final,map,string,string,commit,data,new,hash,map,6,commit,data,put,translog,translog,file,generation,commit,data,put,translog,translog,uuid,commit,data,put,sequence,numbers,local,checkpoint,value,if,sync,id,null,commit,data,put,engine,sync,id,commit,data,put,sequence,numbers,long,to,string,local,checkpoint,tracker,get,max,seq,no,commit,data,put,long,to,string,max,unsafe,auto,id,timestamp,get,commit,data,put,history,uuid,if,soft,delete,enabled,final,tuple,long,retention,leases,retention,policy,soft,deletes,policy,get,retention,policy,commit,data,put,engine,long,to,string,retention,policy,v1,commit,data,put,engine,retention,leases,encode,retention,leases,retention,policy,v2,logger,trace,committing,writer,with,commit,data,commit,data,return,commit,data,entry,set,iterator,writer,commit,catch,final,exception,ex,try,fail,engine,lucene,commit,failed,ex,catch,final,exception,inner,ex,add,suppressed,inner,throw,ex,catch,final,assertion,error,e,if,exceptions,helper,stack,trace,e,contains,org,apache,lucene,index,index,writer,files,exist,final,engine,exception,engine,exception,new,engine,exception,shard,id,failed,to,commit,engine,e,try,fail,engine,lucene,commit,failed,engine,exception,catch,final,exception,inner,engine,exception,add,suppressed,inner,throw,engine,exception,else,throw,e
InternalEngine -> protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException;1549975032;Commits the specified index writer.__@param writer   the index writer to commit_@param translog the translog_@param syncId   the sync flush ID ({@code null} if not committing a synced flush)_@throws IOException if an I/O exception occurs committing the specfied writer;protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException {_        ensureCanFlush()__        try {_            final long localCheckpoint = localCheckpointTracker.getCheckpoint()__            final Translog.TranslogGeneration translogGeneration = translog.getMinGenerationForSeqNo(localCheckpoint + 1)__            final String translogFileGeneration = Long.toString(translogGeneration.translogFileGeneration)__            final String translogUUID = translogGeneration.translogUUID__            final String localCheckpointValue = Long.toString(localCheckpoint)___            writer.setLiveCommitData(() -> {_                _                final Map<String, String> commitData = new HashMap<>(6)__                commitData.put(Translog.TRANSLOG_GENERATION_KEY, translogFileGeneration)__                commitData.put(Translog.TRANSLOG_UUID_KEY, translogUUID)__                commitData.put(SequenceNumbers.LOCAL_CHECKPOINT_KEY, localCheckpointValue)__                if (syncId != null) {_                    commitData.put(Engine.SYNC_COMMIT_ID, syncId)__                }_                commitData.put(SequenceNumbers.MAX_SEQ_NO, Long.toString(localCheckpointTracker.getMaxSeqNo()))__                commitData.put(MAX_UNSAFE_AUTO_ID_TIMESTAMP_COMMIT_ID, Long.toString(maxUnsafeAutoIdTimestamp.get()))__                commitData.put(HISTORY_UUID_KEY, historyUUID)__                if (softDeleteEnabled) {_                    _                    final Tuple<Long, RetentionLeases> retentionPolicy = softDeletesPolicy.getRetentionPolicy()__                    commitData.put(Engine.MIN_RETAINED_SEQNO, Long.toString(retentionPolicy.v1()))__                    commitData.put(Engine.RETENTION_LEASES, RetentionLeases.encodeRetentionLeases(retentionPolicy.v2()))__                }_                logger.trace("committing writer with commit data [{}]", commitData)__                return commitData.entrySet().iterator()__            })___            writer.commit()__        } catch (final Exception ex) {_            try {_                failEngine("lucene commit failed", ex)__            } catch (final Exception inner) {_                ex.addSuppressed(inner)__            }_            throw ex__        } catch (final AssertionError e) {_            _            if (ExceptionsHelper.stackTrace(e).contains("org.apache.lucene.index.IndexWriter.filesExist")) {_                final EngineException engineException = new EngineException(shardId, "failed to commit engine", e)__                try {_                    failEngine("lucene commit failed", engineException)__                } catch (final Exception inner) {_                    engineException.addSuppressed(inner)__                }_                throw engineException__            } else {_                throw e__            }_        }_    };commits,the,specified,index,writer,param,writer,the,index,writer,to,commit,param,translog,the,translog,param,sync,id,the,sync,flush,id,code,null,if,not,committing,a,synced,flush,throws,ioexception,if,an,i,o,exception,occurs,committing,the,specfied,writer;protected,void,commit,index,writer,final,index,writer,writer,final,translog,translog,nullable,final,string,sync,id,throws,ioexception,ensure,can,flush,try,final,long,local,checkpoint,local,checkpoint,tracker,get,checkpoint,final,translog,translog,generation,translog,generation,translog,get,min,generation,for,seq,no,local,checkpoint,1,final,string,translog,file,generation,long,to,string,translog,generation,translog,file,generation,final,string,translog,uuid,translog,generation,translog,uuid,final,string,local,checkpoint,value,long,to,string,local,checkpoint,writer,set,live,commit,data,final,map,string,string,commit,data,new,hash,map,6,commit,data,put,translog,translog,file,generation,commit,data,put,translog,translog,uuid,commit,data,put,sequence,numbers,local,checkpoint,value,if,sync,id,null,commit,data,put,engine,sync,id,commit,data,put,sequence,numbers,long,to,string,local,checkpoint,tracker,get,max,seq,no,commit,data,put,long,to,string,max,unsafe,auto,id,timestamp,get,commit,data,put,history,uuid,if,soft,delete,enabled,final,tuple,long,retention,leases,retention,policy,soft,deletes,policy,get,retention,policy,commit,data,put,engine,long,to,string,retention,policy,v1,commit,data,put,engine,retention,leases,encode,retention,leases,retention,policy,v2,logger,trace,committing,writer,with,commit,data,commit,data,return,commit,data,entry,set,iterator,writer,commit,catch,final,exception,ex,try,fail,engine,lucene,commit,failed,ex,catch,final,exception,inner,ex,add,suppressed,inner,throw,ex,catch,final,assertion,error,e,if,exceptions,helper,stack,trace,e,contains,org,apache,lucene,index,index,writer,files,exist,final,engine,exception,engine,exception,new,engine,exception,shard,id,failed,to,commit,engine,e,try,fail,engine,lucene,commit,failed,engine,exception,catch,final,exception,inner,engine,exception,add,suppressed,inner,throw,engine,exception,else,throw,e
InternalEngine -> protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException;1550220204;Commits the specified index writer.__@param writer   the index writer to commit_@param translog the translog_@param syncId   the sync flush ID ({@code null} if not committing a synced flush)_@throws IOException if an I/O exception occurs committing the specfied writer;protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException {_        ensureCanFlush()__        try {_            final long localCheckpoint = localCheckpointTracker.getCheckpoint()__            final Translog.TranslogGeneration translogGeneration = translog.getMinGenerationForSeqNo(localCheckpoint + 1)__            final String translogFileGeneration = Long.toString(translogGeneration.translogFileGeneration)__            final String translogUUID = translogGeneration.translogUUID__            final String localCheckpointValue = Long.toString(localCheckpoint)___            writer.setLiveCommitData(() -> {_                _                final Map<String, String> commitData = new HashMap<>(6)__                commitData.put(Translog.TRANSLOG_GENERATION_KEY, translogFileGeneration)__                commitData.put(Translog.TRANSLOG_UUID_KEY, translogUUID)__                commitData.put(SequenceNumbers.LOCAL_CHECKPOINT_KEY, localCheckpointValue)__                if (syncId != null) {_                    commitData.put(Engine.SYNC_COMMIT_ID, syncId)__                }_                commitData.put(SequenceNumbers.MAX_SEQ_NO, Long.toString(localCheckpointTracker.getMaxSeqNo()))__                commitData.put(MAX_UNSAFE_AUTO_ID_TIMESTAMP_COMMIT_ID, Long.toString(maxUnsafeAutoIdTimestamp.get()))__                commitData.put(HISTORY_UUID_KEY, historyUUID)__                if (softDeleteEnabled) {_                    _                    final Tuple<Long, RetentionLeases> retentionPolicy = softDeletesPolicy.getRetentionPolicy()__                    commitData.put(Engine.MIN_RETAINED_SEQNO, Long.toString(retentionPolicy.v1()))__                    commitData.put(Engine.RETENTION_LEASES, RetentionLeases.encodeRetentionLeases(retentionPolicy.v2()))__                }_                logger.trace("committing writer with commit data [{}]", commitData)__                return commitData.entrySet().iterator()__            })___            writer.commit()__        } catch (final Exception ex) {_            try {_                failEngine("lucene commit failed", ex)__            } catch (final Exception inner) {_                ex.addSuppressed(inner)__            }_            throw ex__        } catch (final AssertionError e) {_            _            if (ExceptionsHelper.stackTrace(e).contains("org.apache.lucene.index.IndexWriter.filesExist")) {_                final EngineException engineException = new EngineException(shardId, "failed to commit engine", e)__                try {_                    failEngine("lucene commit failed", engineException)__                } catch (final Exception inner) {_                    engineException.addSuppressed(inner)__                }_                throw engineException__            } else {_                throw e__            }_        }_    };commits,the,specified,index,writer,param,writer,the,index,writer,to,commit,param,translog,the,translog,param,sync,id,the,sync,flush,id,code,null,if,not,committing,a,synced,flush,throws,ioexception,if,an,i,o,exception,occurs,committing,the,specfied,writer;protected,void,commit,index,writer,final,index,writer,writer,final,translog,translog,nullable,final,string,sync,id,throws,ioexception,ensure,can,flush,try,final,long,local,checkpoint,local,checkpoint,tracker,get,checkpoint,final,translog,translog,generation,translog,generation,translog,get,min,generation,for,seq,no,local,checkpoint,1,final,string,translog,file,generation,long,to,string,translog,generation,translog,file,generation,final,string,translog,uuid,translog,generation,translog,uuid,final,string,local,checkpoint,value,long,to,string,local,checkpoint,writer,set,live,commit,data,final,map,string,string,commit,data,new,hash,map,6,commit,data,put,translog,translog,file,generation,commit,data,put,translog,translog,uuid,commit,data,put,sequence,numbers,local,checkpoint,value,if,sync,id,null,commit,data,put,engine,sync,id,commit,data,put,sequence,numbers,long,to,string,local,checkpoint,tracker,get,max,seq,no,commit,data,put,long,to,string,max,unsafe,auto,id,timestamp,get,commit,data,put,history,uuid,if,soft,delete,enabled,final,tuple,long,retention,leases,retention,policy,soft,deletes,policy,get,retention,policy,commit,data,put,engine,long,to,string,retention,policy,v1,commit,data,put,engine,retention,leases,encode,retention,leases,retention,policy,v2,logger,trace,committing,writer,with,commit,data,commit,data,return,commit,data,entry,set,iterator,writer,commit,catch,final,exception,ex,try,fail,engine,lucene,commit,failed,ex,catch,final,exception,inner,ex,add,suppressed,inner,throw,ex,catch,final,assertion,error,e,if,exceptions,helper,stack,trace,e,contains,org,apache,lucene,index,index,writer,files,exist,final,engine,exception,engine,exception,new,engine,exception,shard,id,failed,to,commit,engine,e,try,fail,engine,lucene,commit,failed,engine,exception,catch,final,exception,inner,engine,exception,add,suppressed,inner,throw,engine,exception,else,throw,e
InternalEngine -> protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException;1550256122;Commits the specified index writer.__@param writer   the index writer to commit_@param translog the translog_@param syncId   the sync flush ID ({@code null} if not committing a synced flush)_@throws IOException if an I/O exception occurs committing the specfied writer;protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException {_        ensureCanFlush()__        try {_            final long localCheckpoint = localCheckpointTracker.getCheckpoint()__            final Translog.TranslogGeneration translogGeneration = translog.getMinGenerationForSeqNo(localCheckpoint + 1)__            final String translogFileGeneration = Long.toString(translogGeneration.translogFileGeneration)__            final String translogUUID = translogGeneration.translogUUID__            final String localCheckpointValue = Long.toString(localCheckpoint)___            writer.setLiveCommitData(() -> {_                _                final Map<String, String> commitData = new HashMap<>(6)__                commitData.put(Translog.TRANSLOG_GENERATION_KEY, translogFileGeneration)__                commitData.put(Translog.TRANSLOG_UUID_KEY, translogUUID)__                commitData.put(SequenceNumbers.LOCAL_CHECKPOINT_KEY, localCheckpointValue)__                if (syncId != null) {_                    commitData.put(Engine.SYNC_COMMIT_ID, syncId)__                }_                commitData.put(SequenceNumbers.MAX_SEQ_NO, Long.toString(localCheckpointTracker.getMaxSeqNo()))__                commitData.put(MAX_UNSAFE_AUTO_ID_TIMESTAMP_COMMIT_ID, Long.toString(maxUnsafeAutoIdTimestamp.get()))__                commitData.put(HISTORY_UUID_KEY, historyUUID)__                if (softDeleteEnabled) {_                    _                    final Tuple<Long, RetentionLeases> retentionPolicy = softDeletesPolicy.getRetentionPolicy()__                    commitData.put(Engine.MIN_RETAINED_SEQNO, Long.toString(retentionPolicy.v1()))__                    commitData.put(Engine.RETENTION_LEASES, RetentionLeases.encodeRetentionLeases(retentionPolicy.v2()))__                }_                logger.trace("committing writer with commit data [{}]", commitData)__                return commitData.entrySet().iterator()__            })___            writer.commit()__        } catch (final Exception ex) {_            try {_                failEngine("lucene commit failed", ex)__            } catch (final Exception inner) {_                ex.addSuppressed(inner)__            }_            throw ex__        } catch (final AssertionError e) {_            _            if (ExceptionsHelper.stackTrace(e).contains("org.apache.lucene.index.IndexWriter.filesExist")) {_                final EngineException engineException = new EngineException(shardId, "failed to commit engine", e)__                try {_                    failEngine("lucene commit failed", engineException)__                } catch (final Exception inner) {_                    engineException.addSuppressed(inner)__                }_                throw engineException__            } else {_                throw e__            }_        }_    };commits,the,specified,index,writer,param,writer,the,index,writer,to,commit,param,translog,the,translog,param,sync,id,the,sync,flush,id,code,null,if,not,committing,a,synced,flush,throws,ioexception,if,an,i,o,exception,occurs,committing,the,specfied,writer;protected,void,commit,index,writer,final,index,writer,writer,final,translog,translog,nullable,final,string,sync,id,throws,ioexception,ensure,can,flush,try,final,long,local,checkpoint,local,checkpoint,tracker,get,checkpoint,final,translog,translog,generation,translog,generation,translog,get,min,generation,for,seq,no,local,checkpoint,1,final,string,translog,file,generation,long,to,string,translog,generation,translog,file,generation,final,string,translog,uuid,translog,generation,translog,uuid,final,string,local,checkpoint,value,long,to,string,local,checkpoint,writer,set,live,commit,data,final,map,string,string,commit,data,new,hash,map,6,commit,data,put,translog,translog,file,generation,commit,data,put,translog,translog,uuid,commit,data,put,sequence,numbers,local,checkpoint,value,if,sync,id,null,commit,data,put,engine,sync,id,commit,data,put,sequence,numbers,long,to,string,local,checkpoint,tracker,get,max,seq,no,commit,data,put,long,to,string,max,unsafe,auto,id,timestamp,get,commit,data,put,history,uuid,if,soft,delete,enabled,final,tuple,long,retention,leases,retention,policy,soft,deletes,policy,get,retention,policy,commit,data,put,engine,long,to,string,retention,policy,v1,commit,data,put,engine,retention,leases,encode,retention,leases,retention,policy,v2,logger,trace,committing,writer,with,commit,data,commit,data,return,commit,data,entry,set,iterator,writer,commit,catch,final,exception,ex,try,fail,engine,lucene,commit,failed,ex,catch,final,exception,inner,ex,add,suppressed,inner,throw,ex,catch,final,assertion,error,e,if,exceptions,helper,stack,trace,e,contains,org,apache,lucene,index,index,writer,files,exist,final,engine,exception,engine,exception,new,engine,exception,shard,id,failed,to,commit,engine,e,try,fail,engine,lucene,commit,failed,engine,exception,catch,final,exception,inner,engine,exception,add,suppressed,inner,throw,engine,exception,else,throw,e
InternalEngine -> protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException;1550342051;Commits the specified index writer.__@param writer   the index writer to commit_@param translog the translog_@param syncId   the sync flush ID ({@code null} if not committing a synced flush)_@throws IOException if an I/O exception occurs committing the specfied writer;protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException {_        ensureCanFlush()__        try {_            final long localCheckpoint = localCheckpointTracker.getCheckpoint()__            final Translog.TranslogGeneration translogGeneration = translog.getMinGenerationForSeqNo(localCheckpoint + 1)__            final String translogFileGeneration = Long.toString(translogGeneration.translogFileGeneration)__            final String translogUUID = translogGeneration.translogUUID__            final String localCheckpointValue = Long.toString(localCheckpoint)___            writer.setLiveCommitData(() -> {_                _                final Map<String, String> commitData = new HashMap<>(6)__                commitData.put(Translog.TRANSLOG_GENERATION_KEY, translogFileGeneration)__                commitData.put(Translog.TRANSLOG_UUID_KEY, translogUUID)__                commitData.put(SequenceNumbers.LOCAL_CHECKPOINT_KEY, localCheckpointValue)__                if (syncId != null) {_                    commitData.put(Engine.SYNC_COMMIT_ID, syncId)__                }_                commitData.put(SequenceNumbers.MAX_SEQ_NO, Long.toString(localCheckpointTracker.getMaxSeqNo()))__                commitData.put(MAX_UNSAFE_AUTO_ID_TIMESTAMP_COMMIT_ID, Long.toString(maxUnsafeAutoIdTimestamp.get()))__                commitData.put(HISTORY_UUID_KEY, historyUUID)__                if (softDeleteEnabled) {_                    _                    final Tuple<Long, RetentionLeases> retentionPolicy = softDeletesPolicy.getRetentionPolicy()__                    commitData.put(Engine.MIN_RETAINED_SEQNO, Long.toString(retentionPolicy.v1()))__                    commitData.put(Engine.RETENTION_LEASES, RetentionLeases.encodeRetentionLeases(retentionPolicy.v2()))__                }_                logger.trace("committing writer with commit data [{}]", commitData)__                return commitData.entrySet().iterator()__            })___            writer.commit()__        } catch (final Exception ex) {_            try {_                failEngine("lucene commit failed", ex)__            } catch (final Exception inner) {_                ex.addSuppressed(inner)__            }_            throw ex__        } catch (final AssertionError e) {_            _            if (ExceptionsHelper.stackTrace(e).contains("org.apache.lucene.index.IndexWriter.filesExist")) {_                final EngineException engineException = new EngineException(shardId, "failed to commit engine", e)__                try {_                    failEngine("lucene commit failed", engineException)__                } catch (final Exception inner) {_                    engineException.addSuppressed(inner)__                }_                throw engineException__            } else {_                throw e__            }_        }_    };commits,the,specified,index,writer,param,writer,the,index,writer,to,commit,param,translog,the,translog,param,sync,id,the,sync,flush,id,code,null,if,not,committing,a,synced,flush,throws,ioexception,if,an,i,o,exception,occurs,committing,the,specfied,writer;protected,void,commit,index,writer,final,index,writer,writer,final,translog,translog,nullable,final,string,sync,id,throws,ioexception,ensure,can,flush,try,final,long,local,checkpoint,local,checkpoint,tracker,get,checkpoint,final,translog,translog,generation,translog,generation,translog,get,min,generation,for,seq,no,local,checkpoint,1,final,string,translog,file,generation,long,to,string,translog,generation,translog,file,generation,final,string,translog,uuid,translog,generation,translog,uuid,final,string,local,checkpoint,value,long,to,string,local,checkpoint,writer,set,live,commit,data,final,map,string,string,commit,data,new,hash,map,6,commit,data,put,translog,translog,file,generation,commit,data,put,translog,translog,uuid,commit,data,put,sequence,numbers,local,checkpoint,value,if,sync,id,null,commit,data,put,engine,sync,id,commit,data,put,sequence,numbers,long,to,string,local,checkpoint,tracker,get,max,seq,no,commit,data,put,long,to,string,max,unsafe,auto,id,timestamp,get,commit,data,put,history,uuid,if,soft,delete,enabled,final,tuple,long,retention,leases,retention,policy,soft,deletes,policy,get,retention,policy,commit,data,put,engine,long,to,string,retention,policy,v1,commit,data,put,engine,retention,leases,encode,retention,leases,retention,policy,v2,logger,trace,committing,writer,with,commit,data,commit,data,return,commit,data,entry,set,iterator,writer,commit,catch,final,exception,ex,try,fail,engine,lucene,commit,failed,ex,catch,final,exception,inner,ex,add,suppressed,inner,throw,ex,catch,final,assertion,error,e,if,exceptions,helper,stack,trace,e,contains,org,apache,lucene,index,index,writer,files,exist,final,engine,exception,engine,exception,new,engine,exception,shard,id,failed,to,commit,engine,e,try,fail,engine,lucene,commit,failed,engine,exception,catch,final,exception,inner,engine,exception,add,suppressed,inner,throw,engine,exception,else,throw,e
InternalEngine -> protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException;1550526771;Commits the specified index writer.__@param writer   the index writer to commit_@param translog the translog_@param syncId   the sync flush ID ({@code null} if not committing a synced flush)_@throws IOException if an I/O exception occurs committing the specfied writer;protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException {_        ensureCanFlush()__        try {_            final long localCheckpoint = localCheckpointTracker.getCheckpoint()__            final Translog.TranslogGeneration translogGeneration = translog.getMinGenerationForSeqNo(localCheckpoint + 1)__            final String translogFileGeneration = Long.toString(translogGeneration.translogFileGeneration)__            final String translogUUID = translogGeneration.translogUUID__            final String localCheckpointValue = Long.toString(localCheckpoint)___            writer.setLiveCommitData(() -> {_                _                final Map<String, String> commitData = new HashMap<>(6)__                commitData.put(Translog.TRANSLOG_GENERATION_KEY, translogFileGeneration)__                commitData.put(Translog.TRANSLOG_UUID_KEY, translogUUID)__                commitData.put(SequenceNumbers.LOCAL_CHECKPOINT_KEY, localCheckpointValue)__                if (syncId != null) {_                    commitData.put(Engine.SYNC_COMMIT_ID, syncId)__                }_                commitData.put(SequenceNumbers.MAX_SEQ_NO, Long.toString(localCheckpointTracker.getMaxSeqNo()))__                commitData.put(MAX_UNSAFE_AUTO_ID_TIMESTAMP_COMMIT_ID, Long.toString(maxUnsafeAutoIdTimestamp.get()))__                commitData.put(HISTORY_UUID_KEY, historyUUID)__                if (softDeleteEnabled) {_                    commitData.put(Engine.MIN_RETAINED_SEQNO, Long.toString(softDeletesPolicy.getMinRetainedSeqNo()))__                }_                logger.trace("committing writer with commit data [{}]", commitData)__                return commitData.entrySet().iterator()__            })___            writer.commit()__        } catch (final Exception ex) {_            try {_                failEngine("lucene commit failed", ex)__            } catch (final Exception inner) {_                ex.addSuppressed(inner)__            }_            throw ex__        } catch (final AssertionError e) {_            _            if (ExceptionsHelper.stackTrace(e).contains("org.apache.lucene.index.IndexWriter.filesExist")) {_                final EngineException engineException = new EngineException(shardId, "failed to commit engine", e)__                try {_                    failEngine("lucene commit failed", engineException)__                } catch (final Exception inner) {_                    engineException.addSuppressed(inner)__                }_                throw engineException__            } else {_                throw e__            }_        }_    };commits,the,specified,index,writer,param,writer,the,index,writer,to,commit,param,translog,the,translog,param,sync,id,the,sync,flush,id,code,null,if,not,committing,a,synced,flush,throws,ioexception,if,an,i,o,exception,occurs,committing,the,specfied,writer;protected,void,commit,index,writer,final,index,writer,writer,final,translog,translog,nullable,final,string,sync,id,throws,ioexception,ensure,can,flush,try,final,long,local,checkpoint,local,checkpoint,tracker,get,checkpoint,final,translog,translog,generation,translog,generation,translog,get,min,generation,for,seq,no,local,checkpoint,1,final,string,translog,file,generation,long,to,string,translog,generation,translog,file,generation,final,string,translog,uuid,translog,generation,translog,uuid,final,string,local,checkpoint,value,long,to,string,local,checkpoint,writer,set,live,commit,data,final,map,string,string,commit,data,new,hash,map,6,commit,data,put,translog,translog,file,generation,commit,data,put,translog,translog,uuid,commit,data,put,sequence,numbers,local,checkpoint,value,if,sync,id,null,commit,data,put,engine,sync,id,commit,data,put,sequence,numbers,long,to,string,local,checkpoint,tracker,get,max,seq,no,commit,data,put,long,to,string,max,unsafe,auto,id,timestamp,get,commit,data,put,history,uuid,if,soft,delete,enabled,commit,data,put,engine,long,to,string,soft,deletes,policy,get,min,retained,seq,no,logger,trace,committing,writer,with,commit,data,commit,data,return,commit,data,entry,set,iterator,writer,commit,catch,final,exception,ex,try,fail,engine,lucene,commit,failed,ex,catch,final,exception,inner,ex,add,suppressed,inner,throw,ex,catch,final,assertion,error,e,if,exceptions,helper,stack,trace,e,contains,org,apache,lucene,index,index,writer,files,exist,final,engine,exception,engine,exception,new,engine,exception,shard,id,failed,to,commit,engine,e,try,fail,engine,lucene,commit,failed,engine,exception,catch,final,exception,inner,engine,exception,add,suppressed,inner,throw,engine,exception,else,throw,e
InternalEngine -> protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException;1551110274;Commits the specified index writer.__@param writer   the index writer to commit_@param translog the translog_@param syncId   the sync flush ID ({@code null} if not committing a synced flush)_@throws IOException if an I/O exception occurs committing the specfied writer;protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException {_        ensureCanFlush()__        try {_            final long localCheckpoint = localCheckpointTracker.getCheckpoint()__            final Translog.TranslogGeneration translogGeneration = translog.getMinGenerationForSeqNo(localCheckpoint + 1)__            final String translogFileGeneration = Long.toString(translogGeneration.translogFileGeneration)__            final String translogUUID = translogGeneration.translogUUID__            final String localCheckpointValue = Long.toString(localCheckpoint)___            writer.setLiveCommitData(() -> {_                _                final Map<String, String> commitData = new HashMap<>(6)__                commitData.put(Translog.TRANSLOG_GENERATION_KEY, translogFileGeneration)__                commitData.put(Translog.TRANSLOG_UUID_KEY, translogUUID)__                commitData.put(SequenceNumbers.LOCAL_CHECKPOINT_KEY, localCheckpointValue)__                if (syncId != null) {_                    commitData.put(Engine.SYNC_COMMIT_ID, syncId)__                }_                commitData.put(SequenceNumbers.MAX_SEQ_NO, Long.toString(localCheckpointTracker.getMaxSeqNo()))__                commitData.put(MAX_UNSAFE_AUTO_ID_TIMESTAMP_COMMIT_ID, Long.toString(maxUnsafeAutoIdTimestamp.get()))__                commitData.put(HISTORY_UUID_KEY, historyUUID)__                if (softDeleteEnabled) {_                    commitData.put(Engine.MIN_RETAINED_SEQNO, Long.toString(softDeletesPolicy.getMinRetainedSeqNo()))__                }_                logger.trace("committing writer with commit data [{}]", commitData)__                return commitData.entrySet().iterator()__            })___            writer.commit()__        } catch (final Exception ex) {_            try {_                failEngine("lucene commit failed", ex)__            } catch (final Exception inner) {_                ex.addSuppressed(inner)__            }_            throw ex__        } catch (final AssertionError e) {_            _            if (ExceptionsHelper.stackTrace(e).contains("org.apache.lucene.index.IndexWriter.filesExist")) {_                final EngineException engineException = new EngineException(shardId, "failed to commit engine", e)__                try {_                    failEngine("lucene commit failed", engineException)__                } catch (final Exception inner) {_                    engineException.addSuppressed(inner)__                }_                throw engineException__            } else {_                throw e__            }_        }_    };commits,the,specified,index,writer,param,writer,the,index,writer,to,commit,param,translog,the,translog,param,sync,id,the,sync,flush,id,code,null,if,not,committing,a,synced,flush,throws,ioexception,if,an,i,o,exception,occurs,committing,the,specfied,writer;protected,void,commit,index,writer,final,index,writer,writer,final,translog,translog,nullable,final,string,sync,id,throws,ioexception,ensure,can,flush,try,final,long,local,checkpoint,local,checkpoint,tracker,get,checkpoint,final,translog,translog,generation,translog,generation,translog,get,min,generation,for,seq,no,local,checkpoint,1,final,string,translog,file,generation,long,to,string,translog,generation,translog,file,generation,final,string,translog,uuid,translog,generation,translog,uuid,final,string,local,checkpoint,value,long,to,string,local,checkpoint,writer,set,live,commit,data,final,map,string,string,commit,data,new,hash,map,6,commit,data,put,translog,translog,file,generation,commit,data,put,translog,translog,uuid,commit,data,put,sequence,numbers,local,checkpoint,value,if,sync,id,null,commit,data,put,engine,sync,id,commit,data,put,sequence,numbers,long,to,string,local,checkpoint,tracker,get,max,seq,no,commit,data,put,long,to,string,max,unsafe,auto,id,timestamp,get,commit,data,put,history,uuid,if,soft,delete,enabled,commit,data,put,engine,long,to,string,soft,deletes,policy,get,min,retained,seq,no,logger,trace,committing,writer,with,commit,data,commit,data,return,commit,data,entry,set,iterator,writer,commit,catch,final,exception,ex,try,fail,engine,lucene,commit,failed,ex,catch,final,exception,inner,ex,add,suppressed,inner,throw,ex,catch,final,assertion,error,e,if,exceptions,helper,stack,trace,e,contains,org,apache,lucene,index,index,writer,files,exist,final,engine,exception,engine,exception,new,engine,exception,shard,id,failed,to,commit,engine,e,try,fail,engine,lucene,commit,failed,engine,exception,catch,final,exception,inner,engine,exception,add,suppressed,inner,throw,engine,exception,else,throw,e
InternalEngine -> protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException;1551126708;Commits the specified index writer.__@param writer   the index writer to commit_@param translog the translog_@param syncId   the sync flush ID ({@code null} if not committing a synced flush)_@throws IOException if an I/O exception occurs committing the specfied writer;protected void commitIndexWriter(final IndexWriter writer, final Translog translog, @Nullable final String syncId) throws IOException {_        ensureCanFlush()__        try {_            final long localCheckpoint = localCheckpointTracker.getCheckpoint()__            final Translog.TranslogGeneration translogGeneration = translog.getMinGenerationForSeqNo(localCheckpoint + 1)__            final String translogFileGeneration = Long.toString(translogGeneration.translogFileGeneration)__            final String translogUUID = translogGeneration.translogUUID__            final String localCheckpointValue = Long.toString(localCheckpoint)___            writer.setLiveCommitData(() -> {_                _                final Map<String, String> commitData = new HashMap<>(6)__                commitData.put(Translog.TRANSLOG_GENERATION_KEY, translogFileGeneration)__                commitData.put(Translog.TRANSLOG_UUID_KEY, translogUUID)__                commitData.put(SequenceNumbers.LOCAL_CHECKPOINT_KEY, localCheckpointValue)__                if (syncId != null) {_                    commitData.put(Engine.SYNC_COMMIT_ID, syncId)__                }_                commitData.put(SequenceNumbers.MAX_SEQ_NO, Long.toString(localCheckpointTracker.getMaxSeqNo()))__                commitData.put(MAX_UNSAFE_AUTO_ID_TIMESTAMP_COMMIT_ID, Long.toString(maxUnsafeAutoIdTimestamp.get()))__                commitData.put(HISTORY_UUID_KEY, historyUUID)__                if (softDeleteEnabled) {_                    commitData.put(Engine.MIN_RETAINED_SEQNO, Long.toString(softDeletesPolicy.getMinRetainedSeqNo()))__                }_                logger.trace("committing writer with commit data [{}]", commitData)__                return commitData.entrySet().iterator()__            })___            writer.commit()__        } catch (final Exception ex) {_            try {_                failEngine("lucene commit failed", ex)__            } catch (final Exception inner) {_                ex.addSuppressed(inner)__            }_            throw ex__        } catch (final AssertionError e) {_            _            if (ExceptionsHelper.stackTrace(e).contains("org.apache.lucene.index.IndexWriter.filesExist")) {_                final EngineException engineException = new EngineException(shardId, "failed to commit engine", e)__                try {_                    failEngine("lucene commit failed", engineException)__                } catch (final Exception inner) {_                    engineException.addSuppressed(inner)__                }_                throw engineException__            } else {_                throw e__            }_        }_    };commits,the,specified,index,writer,param,writer,the,index,writer,to,commit,param,translog,the,translog,param,sync,id,the,sync,flush,id,code,null,if,not,committing,a,synced,flush,throws,ioexception,if,an,i,o,exception,occurs,committing,the,specfied,writer;protected,void,commit,index,writer,final,index,writer,writer,final,translog,translog,nullable,final,string,sync,id,throws,ioexception,ensure,can,flush,try,final,long,local,checkpoint,local,checkpoint,tracker,get,checkpoint,final,translog,translog,generation,translog,generation,translog,get,min,generation,for,seq,no,local,checkpoint,1,final,string,translog,file,generation,long,to,string,translog,generation,translog,file,generation,final,string,translog,uuid,translog,generation,translog,uuid,final,string,local,checkpoint,value,long,to,string,local,checkpoint,writer,set,live,commit,data,final,map,string,string,commit,data,new,hash,map,6,commit,data,put,translog,translog,file,generation,commit,data,put,translog,translog,uuid,commit,data,put,sequence,numbers,local,checkpoint,value,if,sync,id,null,commit,data,put,engine,sync,id,commit,data,put,sequence,numbers,long,to,string,local,checkpoint,tracker,get,max,seq,no,commit,data,put,long,to,string,max,unsafe,auto,id,timestamp,get,commit,data,put,history,uuid,if,soft,delete,enabled,commit,data,put,engine,long,to,string,soft,deletes,policy,get,min,retained,seq,no,logger,trace,committing,writer,with,commit,data,commit,data,return,commit,data,entry,set,iterator,writer,commit,catch,final,exception,ex,try,fail,engine,lucene,commit,failed,ex,catch,final,exception,inner,ex,add,suppressed,inner,throw,ex,catch,final,assertion,error,e,if,exceptions,helper,stack,trace,e,contains,org,apache,lucene,index,index,writer,files,exist,final,engine,exception,engine,exception,new,engine,exception,shard,id,failed,to,commit,engine,e,try,fail,engine,lucene,commit,failed,engine,exception,catch,final,exception,inner,engine,exception,add,suppressed,inner,throw,engine,exception,else,throw,e
InternalEngine -> long doGenerateSeqNoForOperation(final Operation operation);1535965276;Generate the sequence number for the specified operation.__@param operation the operation_@return the sequence number;long doGenerateSeqNoForOperation(final Operation operation) {_        return localCheckpointTracker.generateSeqNo()__    };generate,the,sequence,number,for,the,specified,operation,param,operation,the,operation,return,the,sequence,number;long,do,generate,seq,no,for,operation,final,operation,operation,return,local,checkpoint,tracker,generate,seq,no
InternalEngine -> long doGenerateSeqNoForOperation(final Operation operation);1536218260;Generate the sequence number for the specified operation.__@param operation the operation_@return the sequence number;long doGenerateSeqNoForOperation(final Operation operation) {_        return localCheckpointTracker.generateSeqNo()__    };generate,the,sequence,number,for,the,specified,operation,param,operation,the,operation,return,the,sequence,number;long,do,generate,seq,no,for,operation,final,operation,operation,return,local,checkpoint,tracker,generate,seq,no
InternalEngine -> long doGenerateSeqNoForOperation(final Operation operation);1536314350;Generate the sequence number for the specified operation.__@param operation the operation_@return the sequence number;long doGenerateSeqNoForOperation(final Operation operation) {_        return localCheckpointTracker.generateSeqNo()__    };generate,the,sequence,number,for,the,specified,operation,param,operation,the,operation,return,the,sequence,number;long,do,generate,seq,no,for,operation,final,operation,operation,return,local,checkpoint,tracker,generate,seq,no
InternalEngine -> long doGenerateSeqNoForOperation(final Operation operation);1536828374;Generate the sequence number for the specified operation.__@param operation the operation_@return the sequence number;long doGenerateSeqNoForOperation(final Operation operation) {_        return localCheckpointTracker.generateSeqNo()__    };generate,the,sequence,number,for,the,specified,operation,param,operation,the,operation,return,the,sequence,number;long,do,generate,seq,no,for,operation,final,operation,operation,return,local,checkpoint,tracker,generate,seq,no
InternalEngine -> long doGenerateSeqNoForOperation(final Operation operation);1537806831;Generate the sequence number for the specified operation.__@param operation the operation_@return the sequence number;long doGenerateSeqNoForOperation(final Operation operation) {_        return localCheckpointTracker.generateSeqNo()__    };generate,the,sequence,number,for,the,specified,operation,param,operation,the,operation,return,the,sequence,number;long,do,generate,seq,no,for,operation,final,operation,operation,return,local,checkpoint,tracker,generate,seq,no
InternalEngine -> long doGenerateSeqNoForOperation(final Operation operation);1538067637;Generate the sequence number for the specified operation.__@param operation the operation_@return the sequence number;long doGenerateSeqNoForOperation(final Operation operation) {_        return localCheckpointTracker.generateSeqNo()__    };generate,the,sequence,number,for,the,specified,operation,param,operation,the,operation,return,the,sequence,number;long,do,generate,seq,no,for,operation,final,operation,operation,return,local,checkpoint,tracker,generate,seq,no
InternalEngine -> long doGenerateSeqNoForOperation(final Operation operation);1538424609;Generate the sequence number for the specified operation.__@param operation the operation_@return the sequence number;long doGenerateSeqNoForOperation(final Operation operation) {_        return localCheckpointTracker.generateSeqNo()__    };generate,the,sequence,number,for,the,specified,operation,param,operation,the,operation,return,the,sequence,number;long,do,generate,seq,no,for,operation,final,operation,operation,return,local,checkpoint,tracker,generate,seq,no
InternalEngine -> long doGenerateSeqNoForOperation(final Operation operation);1539615817;Generate the sequence number for the specified operation.__@param operation the operation_@return the sequence number;long doGenerateSeqNoForOperation(final Operation operation) {_        return localCheckpointTracker.generateSeqNo()__    };generate,the,sequence,number,for,the,specified,operation,param,operation,the,operation,return,the,sequence,number;long,do,generate,seq,no,for,operation,final,operation,operation,return,local,checkpoint,tracker,generate,seq,no
InternalEngine -> long doGenerateSeqNoForOperation(final Operation operation);1539723533;Generate the sequence number for the specified operation.__@param operation the operation_@return the sequence number;long doGenerateSeqNoForOperation(final Operation operation) {_        return localCheckpointTracker.generateSeqNo()__    };generate,the,sequence,number,for,the,specified,operation,param,operation,the,operation,return,the,sequence,number;long,do,generate,seq,no,for,operation,final,operation,operation,return,local,checkpoint,tracker,generate,seq,no
InternalEngine -> long doGenerateSeqNoForOperation(final Operation operation);1540238977;Generate the sequence number for the specified operation.__@param operation the operation_@return the sequence number;long doGenerateSeqNoForOperation(final Operation operation) {_        return localCheckpointTracker.generateSeqNo()__    };generate,the,sequence,number,for,the,specified,operation,param,operation,the,operation,return,the,sequence,number;long,do,generate,seq,no,for,operation,final,operation,operation,return,local,checkpoint,tracker,generate,seq,no
InternalEngine -> long doGenerateSeqNoForOperation(final Operation operation);1541335413;Generate the sequence number for the specified operation.__@param operation the operation_@return the sequence number;long doGenerateSeqNoForOperation(final Operation operation) {_        return localCheckpointTracker.generateSeqNo()__    };generate,the,sequence,number,for,the,specified,operation,param,operation,the,operation,return,the,sequence,number;long,do,generate,seq,no,for,operation,final,operation,operation,return,local,checkpoint,tracker,generate,seq,no
InternalEngine -> long doGenerateSeqNoForOperation(final Operation operation);1541622390;Generate the sequence number for the specified operation.__@param operation the operation_@return the sequence number;long doGenerateSeqNoForOperation(final Operation operation) {_        return localCheckpointTracker.generateSeqNo()__    };generate,the,sequence,number,for,the,specified,operation,param,operation,the,operation,return,the,sequence,number;long,do,generate,seq,no,for,operation,final,operation,operation,return,local,checkpoint,tracker,generate,seq,no
InternalEngine -> long doGenerateSeqNoForOperation(final Operation operation);1542697754;Generate the sequence number for the specified operation.__@param operation the operation_@return the sequence number;long doGenerateSeqNoForOperation(final Operation operation) {_        return localCheckpointTracker.generateSeqNo()__    };generate,the,sequence,number,for,the,specified,operation,param,operation,the,operation,return,the,sequence,number;long,do,generate,seq,no,for,operation,final,operation,operation,return,local,checkpoint,tracker,generate,seq,no
InternalEngine -> long doGenerateSeqNoForOperation(final Operation operation);1543940134;Generate the sequence number for the specified operation.__@param operation the operation_@return the sequence number;long doGenerateSeqNoForOperation(final Operation operation) {_        return localCheckpointTracker.generateSeqNo()__    };generate,the,sequence,number,for,the,specified,operation,param,operation,the,operation,return,the,sequence,number;long,do,generate,seq,no,for,operation,final,operation,operation,return,local,checkpoint,tracker,generate,seq,no
InternalEngine -> long doGenerateSeqNoForOperation(final Operation operation);1544322276;Generate the sequence number for the specified operation.__@param operation the operation_@return the sequence number;long doGenerateSeqNoForOperation(final Operation operation) {_        return localCheckpointTracker.generateSeqNo()__    };generate,the,sequence,number,for,the,specified,operation,param,operation,the,operation,return,the,sequence,number;long,do,generate,seq,no,for,operation,final,operation,operation,return,local,checkpoint,tracker,generate,seq,no
InternalEngine -> long doGenerateSeqNoForOperation(final Operation operation);1544545090;Generate the sequence number for the specified operation.__@param operation the operation_@return the sequence number;long doGenerateSeqNoForOperation(final Operation operation) {_        return localCheckpointTracker.generateSeqNo()__    };generate,the,sequence,number,for,the,specified,operation,param,operation,the,operation,return,the,sequence,number;long,do,generate,seq,no,for,operation,final,operation,operation,return,local,checkpoint,tracker,generate,seq,no
InternalEngine -> long doGenerateSeqNoForOperation(final Operation operation);1544684920;Generate the sequence number for the specified operation.__@param operation the operation_@return the sequence number;long doGenerateSeqNoForOperation(final Operation operation) {_        return localCheckpointTracker.generateSeqNo()__    };generate,the,sequence,number,for,the,specified,operation,param,operation,the,operation,return,the,sequence,number;long,do,generate,seq,no,for,operation,final,operation,operation,return,local,checkpoint,tracker,generate,seq,no
InternalEngine -> long doGenerateSeqNoForOperation(final Operation operation);1545140118;Generate the sequence number for the specified operation.__@param operation the operation_@return the sequence number;long doGenerateSeqNoForOperation(final Operation operation) {_        return localCheckpointTracker.generateSeqNo()__    };generate,the,sequence,number,for,the,specified,operation,param,operation,the,operation,return,the,sequence,number;long,do,generate,seq,no,for,operation,final,operation,operation,return,local,checkpoint,tracker,generate,seq,no
InternalEngine -> long doGenerateSeqNoForOperation(final Operation operation);1546875837;Generate the sequence number for the specified operation.__@param operation the operation_@return the sequence number;long doGenerateSeqNoForOperation(final Operation operation) {_        return localCheckpointTracker.generateSeqNo()__    };generate,the,sequence,number,for,the,specified,operation,param,operation,the,operation,return,the,sequence,number;long,do,generate,seq,no,for,operation,final,operation,operation,return,local,checkpoint,tracker,generate,seq,no
InternalEngine -> long doGenerateSeqNoForOperation(final Operation operation);1547332999;Generate the sequence number for the specified operation.__@param operation the operation_@return the sequence number;long doGenerateSeqNoForOperation(final Operation operation) {_        return localCheckpointTracker.generateSeqNo()__    };generate,the,sequence,number,for,the,specified,operation,param,operation,the,operation,return,the,sequence,number;long,do,generate,seq,no,for,operation,final,operation,operation,return,local,checkpoint,tracker,generate,seq,no
InternalEngine -> long doGenerateSeqNoForOperation(final Operation operation);1548771485;Generate the sequence number for the specified operation.__@param operation the operation_@return the sequence number;long doGenerateSeqNoForOperation(final Operation operation) {_        return localCheckpointTracker.generateSeqNo()__    };generate,the,sequence,number,for,the,specified,operation,param,operation,the,operation,return,the,sequence,number;long,do,generate,seq,no,for,operation,final,operation,operation,return,local,checkpoint,tracker,generate,seq,no
InternalEngine -> long doGenerateSeqNoForOperation(final Operation operation);1549059559;Generate the sequence number for the specified operation.__@param operation the operation_@return the sequence number;long doGenerateSeqNoForOperation(final Operation operation) {_        return localCheckpointTracker.generateSeqNo()__    };generate,the,sequence,number,for,the,specified,operation,param,operation,the,operation,return,the,sequence,number;long,do,generate,seq,no,for,operation,final,operation,operation,return,local,checkpoint,tracker,generate,seq,no
InternalEngine -> long doGenerateSeqNoForOperation(final Operation operation);1549663373;Generate the sequence number for the specified operation.__@param operation the operation_@return the sequence number;long doGenerateSeqNoForOperation(final Operation operation) {_        return localCheckpointTracker.generateSeqNo()__    };generate,the,sequence,number,for,the,specified,operation,param,operation,the,operation,return,the,sequence,number;long,do,generate,seq,no,for,operation,final,operation,operation,return,local,checkpoint,tracker,generate,seq,no
InternalEngine -> long doGenerateSeqNoForOperation(final Operation operation);1549975032;Generate the sequence number for the specified operation.__@param operation the operation_@return the sequence number;long doGenerateSeqNoForOperation(final Operation operation) {_        return localCheckpointTracker.generateSeqNo()__    };generate,the,sequence,number,for,the,specified,operation,param,operation,the,operation,return,the,sequence,number;long,do,generate,seq,no,for,operation,final,operation,operation,return,local,checkpoint,tracker,generate,seq,no
InternalEngine -> long doGenerateSeqNoForOperation(final Operation operation);1550220204;Generate the sequence number for the specified operation.__@param operation the operation_@return the sequence number;long doGenerateSeqNoForOperation(final Operation operation) {_        return localCheckpointTracker.generateSeqNo()__    };generate,the,sequence,number,for,the,specified,operation,param,operation,the,operation,return,the,sequence,number;long,do,generate,seq,no,for,operation,final,operation,operation,return,local,checkpoint,tracker,generate,seq,no
InternalEngine -> long doGenerateSeqNoForOperation(final Operation operation);1550256122;Generate the sequence number for the specified operation.__@param operation the operation_@return the sequence number;long doGenerateSeqNoForOperation(final Operation operation) {_        return localCheckpointTracker.generateSeqNo()__    };generate,the,sequence,number,for,the,specified,operation,param,operation,the,operation,return,the,sequence,number;long,do,generate,seq,no,for,operation,final,operation,operation,return,local,checkpoint,tracker,generate,seq,no
InternalEngine -> long doGenerateSeqNoForOperation(final Operation operation);1550342051;Generate the sequence number for the specified operation.__@param operation the operation_@return the sequence number;long doGenerateSeqNoForOperation(final Operation operation) {_        return localCheckpointTracker.generateSeqNo()__    };generate,the,sequence,number,for,the,specified,operation,param,operation,the,operation,return,the,sequence,number;long,do,generate,seq,no,for,operation,final,operation,operation,return,local,checkpoint,tracker,generate,seq,no
InternalEngine -> long doGenerateSeqNoForOperation(final Operation operation);1550526771;Generate the sequence number for the specified operation.__@param operation the operation_@return the sequence number;long doGenerateSeqNoForOperation(final Operation operation) {_        return localCheckpointTracker.generateSeqNo()__    };generate,the,sequence,number,for,the,specified,operation,param,operation,the,operation,return,the,sequence,number;long,do,generate,seq,no,for,operation,final,operation,operation,return,local,checkpoint,tracker,generate,seq,no
InternalEngine -> long doGenerateSeqNoForOperation(final Operation operation);1551110274;Generate the sequence number for the specified operation.__@param operation the operation_@return the sequence number;long doGenerateSeqNoForOperation(final Operation operation) {_        return localCheckpointTracker.generateSeqNo()__    };generate,the,sequence,number,for,the,specified,operation,param,operation,the,operation,return,the,sequence,number;long,do,generate,seq,no,for,operation,final,operation,operation,return,local,checkpoint,tracker,generate,seq,no
InternalEngine -> long doGenerateSeqNoForOperation(final Operation operation);1551126708;Generate the sequence number for the specified operation.__@param operation the operation_@return the sequence number;long doGenerateSeqNoForOperation(final Operation operation) {_        return localCheckpointTracker.generateSeqNo()__    };generate,the,sequence,number,for,the,specified,operation,param,operation,the,operation,return,the,sequence,number;long,do,generate,seq,no,for,operation,final,operation,operation,return,local,checkpoint,tracker,generate,seq,no
InternalEngine -> private VersionValue resolveDocVersion(final Operation op) throws IOException;1524684173;resolves the current version of the document, returning null if not found;private VersionValue resolveDocVersion(final Operation op) throws IOException {_        assert incrementVersionLookup()_ _        VersionValue versionValue = getVersionFromMap(op.uid().bytes())__        if (versionValue == null) {_            assert incrementIndexVersionLookup()_ _            final long currentVersion = loadCurrentVersionFromIndex(op.uid())__            if (currentVersion != Versions.NOT_FOUND) {_                versionValue = new IndexVersionValue(null, currentVersion, SequenceNumbers.UNASSIGNED_SEQ_NO, 0L)__            }_        } else if (engineConfig.isEnableGcDeletes() && versionValue.isDelete() &&_            (engineConfig.getThreadPool().relativeTimeInMillis() - ((DeleteVersionValue)versionValue).time) > getGcDeletesInMillis()) {_            versionValue = null__        }_        return versionValue__    };resolves,the,current,version,of,the,document,returning,null,if,not,found;private,version,value,resolve,doc,version,final,operation,op,throws,ioexception,assert,increment,version,lookup,version,value,version,value,get,version,from,map,op,uid,bytes,if,version,value,null,assert,increment,index,version,lookup,final,long,current,version,load,current,version,from,index,op,uid,if,current,version,versions,version,value,new,index,version,value,null,current,version,sequence,numbers,0l,else,if,engine,config,is,enable,gc,deletes,version,value,is,delete,engine,config,get,thread,pool,relative,time,in,millis,delete,version,value,version,value,time,get,gc,deletes,in,millis,version,value,null,return,version,value
InternalEngine -> private VersionValue resolveDocVersion(final Operation op) throws IOException;1524780945;resolves the current version of the document, returning null if not found;private VersionValue resolveDocVersion(final Operation op) throws IOException {_        assert incrementVersionLookup()_ _        VersionValue versionValue = getVersionFromMap(op.uid().bytes())__        if (versionValue == null) {_            assert incrementIndexVersionLookup()_ _            final long currentVersion = loadCurrentVersionFromIndex(op.uid())__            if (currentVersion != Versions.NOT_FOUND) {_                versionValue = new IndexVersionValue(null, currentVersion, SequenceNumbers.UNASSIGNED_SEQ_NO, 0L)__            }_        } else if (engineConfig.isEnableGcDeletes() && versionValue.isDelete() &&_            (engineConfig.getThreadPool().relativeTimeInMillis() - ((DeleteVersionValue)versionValue).time) > getGcDeletesInMillis()) {_            versionValue = null__        }_        return versionValue__    };resolves,the,current,version,of,the,document,returning,null,if,not,found;private,version,value,resolve,doc,version,final,operation,op,throws,ioexception,assert,increment,version,lookup,version,value,version,value,get,version,from,map,op,uid,bytes,if,version,value,null,assert,increment,index,version,lookup,final,long,current,version,load,current,version,from,index,op,uid,if,current,version,versions,version,value,new,index,version,value,null,current,version,sequence,numbers,0l,else,if,engine,config,is,enable,gc,deletes,version,value,is,delete,engine,config,get,thread,pool,relative,time,in,millis,delete,version,value,version,value,time,get,gc,deletes,in,millis,version,value,null,return,version,value
InternalEngine -> private VersionValue resolveDocVersion(final Operation op) throws IOException;1525162917;resolves the current version of the document, returning null if not found;private VersionValue resolveDocVersion(final Operation op) throws IOException {_        assert incrementVersionLookup()_ _        VersionValue versionValue = getVersionFromMap(op.uid().bytes())__        if (versionValue == null) {_            assert incrementIndexVersionLookup()_ _            final long currentVersion = loadCurrentVersionFromIndex(op.uid())__            if (currentVersion != Versions.NOT_FOUND) {_                versionValue = new IndexVersionValue(null, currentVersion, SequenceNumbers.UNASSIGNED_SEQ_NO, 0L)__            }_        } else if (engineConfig.isEnableGcDeletes() && versionValue.isDelete() &&_            (engineConfig.getThreadPool().relativeTimeInMillis() - ((DeleteVersionValue)versionValue).time) > getGcDeletesInMillis()) {_            versionValue = null__        }_        return versionValue__    };resolves,the,current,version,of,the,document,returning,null,if,not,found;private,version,value,resolve,doc,version,final,operation,op,throws,ioexception,assert,increment,version,lookup,version,value,version,value,get,version,from,map,op,uid,bytes,if,version,value,null,assert,increment,index,version,lookup,final,long,current,version,load,current,version,from,index,op,uid,if,current,version,versions,version,value,new,index,version,value,null,current,version,sequence,numbers,0l,else,if,engine,config,is,enable,gc,deletes,version,value,is,delete,engine,config,get,thread,pool,relative,time,in,millis,delete,version,value,version,value,time,get,gc,deletes,in,millis,version,value,null,return,version,value
InternalEngine -> private VersionValue resolveDocVersion(final Operation op) throws IOException;1528706846;resolves the current version of the document, returning null if not found;private VersionValue resolveDocVersion(final Operation op) throws IOException {_        assert incrementVersionLookup()_ _        VersionValue versionValue = getVersionFromMap(op.uid().bytes())__        if (versionValue == null) {_            assert incrementIndexVersionLookup()_ _            final long currentVersion = loadCurrentVersionFromIndex(op.uid())__            if (currentVersion != Versions.NOT_FOUND) {_                versionValue = new IndexVersionValue(null, currentVersion, SequenceNumbers.UNASSIGNED_SEQ_NO, 0L)__            }_        } else if (engineConfig.isEnableGcDeletes() && versionValue.isDelete() &&_            (engineConfig.getThreadPool().relativeTimeInMillis() - ((DeleteVersionValue)versionValue).time) > getGcDeletesInMillis()) {_            versionValue = null__        }_        return versionValue__    };resolves,the,current,version,of,the,document,returning,null,if,not,found;private,version,value,resolve,doc,version,final,operation,op,throws,ioexception,assert,increment,version,lookup,version,value,version,value,get,version,from,map,op,uid,bytes,if,version,value,null,assert,increment,index,version,lookup,final,long,current,version,load,current,version,from,index,op,uid,if,current,version,versions,version,value,new,index,version,value,null,current,version,sequence,numbers,0l,else,if,engine,config,is,enable,gc,deletes,version,value,is,delete,engine,config,get,thread,pool,relative,time,in,millis,delete,version,value,version,value,time,get,gc,deletes,in,millis,version,value,null,return,version,value
InternalEngine -> private VersionValue resolveDocVersion(final Operation op) throws IOException;1528762805;resolves the current version of the document, returning null if not found;private VersionValue resolveDocVersion(final Operation op) throws IOException {_        assert incrementVersionLookup()_ _        VersionValue versionValue = getVersionFromMap(op.uid().bytes())__        if (versionValue == null) {_            assert incrementIndexVersionLookup()_ _            final long currentVersion = loadCurrentVersionFromIndex(op.uid())__            if (currentVersion != Versions.NOT_FOUND) {_                versionValue = new IndexVersionValue(null, currentVersion, SequenceNumbers.UNASSIGNED_SEQ_NO, 0L)__            }_        } else if (engineConfig.isEnableGcDeletes() && versionValue.isDelete() &&_            (engineConfig.getThreadPool().relativeTimeInMillis() - ((DeleteVersionValue)versionValue).time) > getGcDeletesInMillis()) {_            versionValue = null__        }_        return versionValue__    };resolves,the,current,version,of,the,document,returning,null,if,not,found;private,version,value,resolve,doc,version,final,operation,op,throws,ioexception,assert,increment,version,lookup,version,value,version,value,get,version,from,map,op,uid,bytes,if,version,value,null,assert,increment,index,version,lookup,final,long,current,version,load,current,version,from,index,op,uid,if,current,version,versions,version,value,new,index,version,value,null,current,version,sequence,numbers,0l,else,if,engine,config,is,enable,gc,deletes,version,value,is,delete,engine,config,get,thread,pool,relative,time,in,millis,delete,version,value,version,value,time,get,gc,deletes,in,millis,version,value,null,return,version,value
InternalEngine -> private VersionValue resolveDocVersion(final Operation op) throws IOException;1531910483;resolves the current version of the document, returning null if not found;private VersionValue resolveDocVersion(final Operation op) throws IOException {_        assert incrementVersionLookup()_ _        VersionValue versionValue = getVersionFromMap(op.uid().bytes())__        if (versionValue == null) {_            assert incrementIndexVersionLookup()_ _            final long currentVersion = loadCurrentVersionFromIndex(op.uid())__            if (currentVersion != Versions.NOT_FOUND) {_                versionValue = new IndexVersionValue(null, currentVersion, SequenceNumbers.UNASSIGNED_SEQ_NO, 0L)__            }_        } else if (engineConfig.isEnableGcDeletes() && versionValue.isDelete() &&_            (engineConfig.getThreadPool().relativeTimeInMillis() - ((DeleteVersionValue)versionValue).time) > getGcDeletesInMillis()) {_            versionValue = null__        }_        return versionValue__    };resolves,the,current,version,of,the,document,returning,null,if,not,found;private,version,value,resolve,doc,version,final,operation,op,throws,ioexception,assert,increment,version,lookup,version,value,version,value,get,version,from,map,op,uid,bytes,if,version,value,null,assert,increment,index,version,lookup,final,long,current,version,load,current,version,from,index,op,uid,if,current,version,versions,version,value,new,index,version,value,null,current,version,sequence,numbers,0l,else,if,engine,config,is,enable,gc,deletes,version,value,is,delete,engine,config,get,thread,pool,relative,time,in,millis,delete,version,value,version,value,time,get,gc,deletes,in,millis,version,value,null,return,version,value
InternalEngine -> private VersionValue resolveDocVersion(final Operation op) throws IOException;1533295538;resolves the current version of the document, returning null if not found;private VersionValue resolveDocVersion(final Operation op) throws IOException {_        assert incrementVersionLookup()_ _        VersionValue versionValue = getVersionFromMap(op.uid().bytes())__        if (versionValue == null) {_            assert incrementIndexVersionLookup()_ _            final long currentVersion = loadCurrentVersionFromIndex(op.uid())__            if (currentVersion != Versions.NOT_FOUND) {_                versionValue = new IndexVersionValue(null, currentVersion, SequenceNumbers.UNASSIGNED_SEQ_NO, 0L)__            }_        } else if (engineConfig.isEnableGcDeletes() && versionValue.isDelete() &&_            (engineConfig.getThreadPool().relativeTimeInMillis() - ((DeleteVersionValue)versionValue).time) > getGcDeletesInMillis()) {_            versionValue = null__        }_        return versionValue__    };resolves,the,current,version,of,the,document,returning,null,if,not,found;private,version,value,resolve,doc,version,final,operation,op,throws,ioexception,assert,increment,version,lookup,version,value,version,value,get,version,from,map,op,uid,bytes,if,version,value,null,assert,increment,index,version,lookup,final,long,current,version,load,current,version,from,index,op,uid,if,current,version,versions,version,value,new,index,version,value,null,current,version,sequence,numbers,0l,else,if,engine,config,is,enable,gc,deletes,version,value,is,delete,engine,config,get,thread,pool,relative,time,in,millis,delete,version,value,version,value,time,get,gc,deletes,in,millis,version,value,null,return,version,value
InternalEngine -> private VersionValue resolveDocVersion(final Operation op) throws IOException;1534848846;resolves the current version of the document, returning null if not found;private VersionValue resolveDocVersion(final Operation op) throws IOException {_        assert incrementVersionLookup()_ _        VersionValue versionValue = getVersionFromMap(op.uid().bytes())__        if (versionValue == null) {_            assert incrementIndexVersionLookup()_ _            final long currentVersion = loadCurrentVersionFromIndex(op.uid())__            if (currentVersion != Versions.NOT_FOUND) {_                versionValue = new IndexVersionValue(null, currentVersion, SequenceNumbers.UNASSIGNED_SEQ_NO, 0L)__            }_        } else if (engineConfig.isEnableGcDeletes() && versionValue.isDelete() &&_            (engineConfig.getThreadPool().relativeTimeInMillis() - ((DeleteVersionValue)versionValue).time) > getGcDeletesInMillis()) {_            versionValue = null__        }_        return versionValue__    };resolves,the,current,version,of,the,document,returning,null,if,not,found;private,version,value,resolve,doc,version,final,operation,op,throws,ioexception,assert,increment,version,lookup,version,value,version,value,get,version,from,map,op,uid,bytes,if,version,value,null,assert,increment,index,version,lookup,final,long,current,version,load,current,version,from,index,op,uid,if,current,version,versions,version,value,new,index,version,value,null,current,version,sequence,numbers,0l,else,if,engine,config,is,enable,gc,deletes,version,value,is,delete,engine,config,get,thread,pool,relative,time,in,millis,delete,version,value,version,value,time,get,gc,deletes,in,millis,version,value,null,return,version,value
InternalEngine -> private VersionValue resolveDocVersion(final Operation op) throws IOException;1535046779;resolves the current version of the document, returning null if not found;private VersionValue resolveDocVersion(final Operation op) throws IOException {_        assert incrementVersionLookup()_ _        VersionValue versionValue = getVersionFromMap(op.uid().bytes())__        if (versionValue == null) {_            assert incrementIndexVersionLookup()_ _            final long currentVersion = loadCurrentVersionFromIndex(op.uid())__            if (currentVersion != Versions.NOT_FOUND) {_                versionValue = new IndexVersionValue(null, currentVersion, SequenceNumbers.UNASSIGNED_SEQ_NO, 0L)__            }_        } else if (engineConfig.isEnableGcDeletes() && versionValue.isDelete() &&_            (engineConfig.getThreadPool().relativeTimeInMillis() - ((DeleteVersionValue)versionValue).time) > getGcDeletesInMillis()) {_            versionValue = null__        }_        return versionValue__    };resolves,the,current,version,of,the,document,returning,null,if,not,found;private,version,value,resolve,doc,version,final,operation,op,throws,ioexception,assert,increment,version,lookup,version,value,version,value,get,version,from,map,op,uid,bytes,if,version,value,null,assert,increment,index,version,lookup,final,long,current,version,load,current,version,from,index,op,uid,if,current,version,versions,version,value,new,index,version,value,null,current,version,sequence,numbers,0l,else,if,engine,config,is,enable,gc,deletes,version,value,is,delete,engine,config,get,thread,pool,relative,time,in,millis,delete,version,value,version,value,time,get,gc,deletes,in,millis,version,value,null,return,version,value
InternalEngine -> private VersionValue resolveDocVersion(final Operation op) throws IOException;1535405719;resolves the current version of the document, returning null if not found;private VersionValue resolveDocVersion(final Operation op) throws IOException {_        assert incrementVersionLookup()_ _        VersionValue versionValue = getVersionFromMap(op.uid().bytes())__        if (versionValue == null) {_            assert incrementIndexVersionLookup()_ _            final long currentVersion = loadCurrentVersionFromIndex(op.uid())__            if (currentVersion != Versions.NOT_FOUND) {_                versionValue = new IndexVersionValue(null, currentVersion, SequenceNumbers.UNASSIGNED_SEQ_NO, 0L)__            }_        } else if (engineConfig.isEnableGcDeletes() && versionValue.isDelete() &&_            (engineConfig.getThreadPool().relativeTimeInMillis() - ((DeleteVersionValue)versionValue).time) > getGcDeletesInMillis()) {_            versionValue = null__        }_        return versionValue__    };resolves,the,current,version,of,the,document,returning,null,if,not,found;private,version,value,resolve,doc,version,final,operation,op,throws,ioexception,assert,increment,version,lookup,version,value,version,value,get,version,from,map,op,uid,bytes,if,version,value,null,assert,increment,index,version,lookup,final,long,current,version,load,current,version,from,index,op,uid,if,current,version,versions,version,value,new,index,version,value,null,current,version,sequence,numbers,0l,else,if,engine,config,is,enable,gc,deletes,version,value,is,delete,engine,config,get,thread,pool,relative,time,in,millis,delete,version,value,version,value,time,get,gc,deletes,in,millis,version,value,null,return,version,value
InternalEngine -> private VersionValue resolveDocVersion(final Operation op) throws IOException;1535723122;resolves the current version of the document, returning null if not found;private VersionValue resolveDocVersion(final Operation op) throws IOException {_        assert incrementVersionLookup()_ _        VersionValue versionValue = getVersionFromMap(op.uid().bytes())__        if (versionValue == null) {_            assert incrementIndexVersionLookup()_ _            final long currentVersion = loadCurrentVersionFromIndex(op.uid())__            if (currentVersion != Versions.NOT_FOUND) {_                versionValue = new IndexVersionValue(null, currentVersion, SequenceNumbers.UNASSIGNED_SEQ_NO, 0L)__            }_        } else if (engineConfig.isEnableGcDeletes() && versionValue.isDelete() &&_            (engineConfig.getThreadPool().relativeTimeInMillis() - ((DeleteVersionValue)versionValue).time) > getGcDeletesInMillis()) {_            versionValue = null__        }_        return versionValue__    };resolves,the,current,version,of,the,document,returning,null,if,not,found;private,version,value,resolve,doc,version,final,operation,op,throws,ioexception,assert,increment,version,lookup,version,value,version,value,get,version,from,map,op,uid,bytes,if,version,value,null,assert,increment,index,version,lookup,final,long,current,version,load,current,version,from,index,op,uid,if,current,version,versions,version,value,new,index,version,value,null,current,version,sequence,numbers,0l,else,if,engine,config,is,enable,gc,deletes,version,value,is,delete,engine,config,get,thread,pool,relative,time,in,millis,delete,version,value,version,value,time,get,gc,deletes,in,millis,version,value,null,return,version,value
InternalEngine -> private VersionValue resolveDocVersion(final Operation op) throws IOException;1535965276;resolves the current version of the document, returning null if not found;private VersionValue resolveDocVersion(final Operation op) throws IOException {_        assert incrementVersionLookup()_ _        VersionValue versionValue = getVersionFromMap(op.uid().bytes())__        if (versionValue == null) {_            assert incrementIndexVersionLookup()_ _            final long currentVersion = loadCurrentVersionFromIndex(op.uid())__            if (currentVersion != Versions.NOT_FOUND) {_                versionValue = new IndexVersionValue(null, currentVersion, SequenceNumbers.UNASSIGNED_SEQ_NO, 0L)__            }_        } else if (engineConfig.isEnableGcDeletes() && versionValue.isDelete() &&_            (engineConfig.getThreadPool().relativeTimeInMillis() - ((DeleteVersionValue)versionValue).time) > getGcDeletesInMillis()) {_            versionValue = null__        }_        return versionValue__    };resolves,the,current,version,of,the,document,returning,null,if,not,found;private,version,value,resolve,doc,version,final,operation,op,throws,ioexception,assert,increment,version,lookup,version,value,version,value,get,version,from,map,op,uid,bytes,if,version,value,null,assert,increment,index,version,lookup,final,long,current,version,load,current,version,from,index,op,uid,if,current,version,versions,version,value,new,index,version,value,null,current,version,sequence,numbers,0l,else,if,engine,config,is,enable,gc,deletes,version,value,is,delete,engine,config,get,thread,pool,relative,time,in,millis,delete,version,value,version,value,time,get,gc,deletes,in,millis,version,value,null,return,version,value
InternalEngine -> private VersionValue resolveDocVersion(final Operation op) throws IOException;1536218260;resolves the current version of the document, returning null if not found;private VersionValue resolveDocVersion(final Operation op) throws IOException {_        assert incrementVersionLookup()_ _        VersionValue versionValue = getVersionFromMap(op.uid().bytes())__        if (versionValue == null) {_            assert incrementIndexVersionLookup()_ _            final long currentVersion = loadCurrentVersionFromIndex(op.uid())__            if (currentVersion != Versions.NOT_FOUND) {_                versionValue = new IndexVersionValue(null, currentVersion, SequenceNumbers.UNASSIGNED_SEQ_NO, 0L)__            }_        } else if (engineConfig.isEnableGcDeletes() && versionValue.isDelete() &&_            (engineConfig.getThreadPool().relativeTimeInMillis() - ((DeleteVersionValue)versionValue).time) > getGcDeletesInMillis()) {_            versionValue = null__        }_        return versionValue__    };resolves,the,current,version,of,the,document,returning,null,if,not,found;private,version,value,resolve,doc,version,final,operation,op,throws,ioexception,assert,increment,version,lookup,version,value,version,value,get,version,from,map,op,uid,bytes,if,version,value,null,assert,increment,index,version,lookup,final,long,current,version,load,current,version,from,index,op,uid,if,current,version,versions,version,value,new,index,version,value,null,current,version,sequence,numbers,0l,else,if,engine,config,is,enable,gc,deletes,version,value,is,delete,engine,config,get,thread,pool,relative,time,in,millis,delete,version,value,version,value,time,get,gc,deletes,in,millis,version,value,null,return,version,value
InternalEngine -> private VersionValue resolveDocVersion(final Operation op) throws IOException;1536314350;resolves the current version of the document, returning null if not found;private VersionValue resolveDocVersion(final Operation op) throws IOException {_        assert incrementVersionLookup()_ _        VersionValue versionValue = getVersionFromMap(op.uid().bytes())__        if (versionValue == null) {_            assert incrementIndexVersionLookup()_ _            final long currentVersion = loadCurrentVersionFromIndex(op.uid())__            if (currentVersion != Versions.NOT_FOUND) {_                versionValue = new IndexVersionValue(null, currentVersion, SequenceNumbers.UNASSIGNED_SEQ_NO, 0L)__            }_        } else if (engineConfig.isEnableGcDeletes() && versionValue.isDelete() &&_            (engineConfig.getThreadPool().relativeTimeInMillis() - ((DeleteVersionValue)versionValue).time) > getGcDeletesInMillis()) {_            versionValue = null__        }_        return versionValue__    };resolves,the,current,version,of,the,document,returning,null,if,not,found;private,version,value,resolve,doc,version,final,operation,op,throws,ioexception,assert,increment,version,lookup,version,value,version,value,get,version,from,map,op,uid,bytes,if,version,value,null,assert,increment,index,version,lookup,final,long,current,version,load,current,version,from,index,op,uid,if,current,version,versions,version,value,new,index,version,value,null,current,version,sequence,numbers,0l,else,if,engine,config,is,enable,gc,deletes,version,value,is,delete,engine,config,get,thread,pool,relative,time,in,millis,delete,version,value,version,value,time,get,gc,deletes,in,millis,version,value,null,return,version,value
InternalEngine -> private VersionValue resolveDocVersion(final Operation op) throws IOException;1536828374;resolves the current version of the document, returning null if not found;private VersionValue resolveDocVersion(final Operation op) throws IOException {_        assert incrementVersionLookup()_ _        VersionValue versionValue = getVersionFromMap(op.uid().bytes())__        if (versionValue == null) {_            assert incrementIndexVersionLookup()_ _            final long currentVersion = loadCurrentVersionFromIndex(op.uid())__            if (currentVersion != Versions.NOT_FOUND) {_                versionValue = new IndexVersionValue(null, currentVersion, SequenceNumbers.UNASSIGNED_SEQ_NO, 0L)__            }_        } else if (engineConfig.isEnableGcDeletes() && versionValue.isDelete() &&_            (engineConfig.getThreadPool().relativeTimeInMillis() - ((DeleteVersionValue)versionValue).time) > getGcDeletesInMillis()) {_            versionValue = null__        }_        return versionValue__    };resolves,the,current,version,of,the,document,returning,null,if,not,found;private,version,value,resolve,doc,version,final,operation,op,throws,ioexception,assert,increment,version,lookup,version,value,version,value,get,version,from,map,op,uid,bytes,if,version,value,null,assert,increment,index,version,lookup,final,long,current,version,load,current,version,from,index,op,uid,if,current,version,versions,version,value,new,index,version,value,null,current,version,sequence,numbers,0l,else,if,engine,config,is,enable,gc,deletes,version,value,is,delete,engine,config,get,thread,pool,relative,time,in,millis,delete,version,value,version,value,time,get,gc,deletes,in,millis,version,value,null,return,version,value
InternalEngine -> private VersionValue resolveDocVersion(final Operation op) throws IOException;1537806831;resolves the current version of the document, returning null if not found;private VersionValue resolveDocVersion(final Operation op) throws IOException {_        assert incrementVersionLookup()_ _        VersionValue versionValue = getVersionFromMap(op.uid().bytes())__        if (versionValue == null) {_            assert incrementIndexVersionLookup()_ _            final long currentVersion = loadCurrentVersionFromIndex(op.uid())__            if (currentVersion != Versions.NOT_FOUND) {_                versionValue = new IndexVersionValue(null, currentVersion, SequenceNumbers.UNASSIGNED_SEQ_NO, 0L)__            }_        } else if (engineConfig.isEnableGcDeletes() && versionValue.isDelete() &&_            (engineConfig.getThreadPool().relativeTimeInMillis() - ((DeleteVersionValue)versionValue).time) > getGcDeletesInMillis()) {_            versionValue = null__        }_        return versionValue__    };resolves,the,current,version,of,the,document,returning,null,if,not,found;private,version,value,resolve,doc,version,final,operation,op,throws,ioexception,assert,increment,version,lookup,version,value,version,value,get,version,from,map,op,uid,bytes,if,version,value,null,assert,increment,index,version,lookup,final,long,current,version,load,current,version,from,index,op,uid,if,current,version,versions,version,value,new,index,version,value,null,current,version,sequence,numbers,0l,else,if,engine,config,is,enable,gc,deletes,version,value,is,delete,engine,config,get,thread,pool,relative,time,in,millis,delete,version,value,version,value,time,get,gc,deletes,in,millis,version,value,null,return,version,value
InternalEngine -> private VersionValue resolveDocVersion(final Operation op) throws IOException;1538067637;resolves the current version of the document, returning null if not found;private VersionValue resolveDocVersion(final Operation op) throws IOException {_        assert incrementVersionLookup()_ _        VersionValue versionValue = getVersionFromMap(op.uid().bytes())__        if (versionValue == null) {_            assert incrementIndexVersionLookup()_ _            final long currentVersion = loadCurrentVersionFromIndex(op.uid())__            if (currentVersion != Versions.NOT_FOUND) {_                versionValue = new IndexVersionValue(null, currentVersion, SequenceNumbers.UNASSIGNED_SEQ_NO, 0L)__            }_        } else if (engineConfig.isEnableGcDeletes() && versionValue.isDelete() &&_            (engineConfig.getThreadPool().relativeTimeInMillis() - ((DeleteVersionValue)versionValue).time) > getGcDeletesInMillis()) {_            versionValue = null__        }_        return versionValue__    };resolves,the,current,version,of,the,document,returning,null,if,not,found;private,version,value,resolve,doc,version,final,operation,op,throws,ioexception,assert,increment,version,lookup,version,value,version,value,get,version,from,map,op,uid,bytes,if,version,value,null,assert,increment,index,version,lookup,final,long,current,version,load,current,version,from,index,op,uid,if,current,version,versions,version,value,new,index,version,value,null,current,version,sequence,numbers,0l,else,if,engine,config,is,enable,gc,deletes,version,value,is,delete,engine,config,get,thread,pool,relative,time,in,millis,delete,version,value,version,value,time,get,gc,deletes,in,millis,version,value,null,return,version,value
InternalEngine -> private VersionValue resolveDocVersion(final Operation op) throws IOException;1538424609;resolves the current version of the document, returning null if not found;private VersionValue resolveDocVersion(final Operation op) throws IOException {_        assert incrementVersionLookup()_ _        VersionValue versionValue = getVersionFromMap(op.uid().bytes())__        if (versionValue == null) {_            assert incrementIndexVersionLookup()_ _            final long currentVersion = loadCurrentVersionFromIndex(op.uid())__            if (currentVersion != Versions.NOT_FOUND) {_                versionValue = new IndexVersionValue(null, currentVersion, SequenceNumbers.UNASSIGNED_SEQ_NO, 0L)__            }_        } else if (engineConfig.isEnableGcDeletes() && versionValue.isDelete() &&_            (engineConfig.getThreadPool().relativeTimeInMillis() - ((DeleteVersionValue)versionValue).time) > getGcDeletesInMillis()) {_            versionValue = null__        }_        return versionValue__    };resolves,the,current,version,of,the,document,returning,null,if,not,found;private,version,value,resolve,doc,version,final,operation,op,throws,ioexception,assert,increment,version,lookup,version,value,version,value,get,version,from,map,op,uid,bytes,if,version,value,null,assert,increment,index,version,lookup,final,long,current,version,load,current,version,from,index,op,uid,if,current,version,versions,version,value,new,index,version,value,null,current,version,sequence,numbers,0l,else,if,engine,config,is,enable,gc,deletes,version,value,is,delete,engine,config,get,thread,pool,relative,time,in,millis,delete,version,value,version,value,time,get,gc,deletes,in,millis,version,value,null,return,version,value
InternalEngine -> private VersionValue resolveDocVersion(final Operation op) throws IOException;1539615817;resolves the current version of the document, returning null if not found;private VersionValue resolveDocVersion(final Operation op) throws IOException {_        assert incrementVersionLookup()_ _        VersionValue versionValue = getVersionFromMap(op.uid().bytes())__        if (versionValue == null) {_            assert incrementIndexVersionLookup()_ _            final long currentVersion = loadCurrentVersionFromIndex(op.uid())__            if (currentVersion != Versions.NOT_FOUND) {_                versionValue = new IndexVersionValue(null, currentVersion, SequenceNumbers.UNASSIGNED_SEQ_NO, 0L)__            }_        } else if (engineConfig.isEnableGcDeletes() && versionValue.isDelete() &&_            (engineConfig.getThreadPool().relativeTimeInMillis() - ((DeleteVersionValue)versionValue).time) > getGcDeletesInMillis()) {_            versionValue = null__        }_        return versionValue__    };resolves,the,current,version,of,the,document,returning,null,if,not,found;private,version,value,resolve,doc,version,final,operation,op,throws,ioexception,assert,increment,version,lookup,version,value,version,value,get,version,from,map,op,uid,bytes,if,version,value,null,assert,increment,index,version,lookup,final,long,current,version,load,current,version,from,index,op,uid,if,current,version,versions,version,value,new,index,version,value,null,current,version,sequence,numbers,0l,else,if,engine,config,is,enable,gc,deletes,version,value,is,delete,engine,config,get,thread,pool,relative,time,in,millis,delete,version,value,version,value,time,get,gc,deletes,in,millis,version,value,null,return,version,value
InternalEngine -> private VersionValue resolveDocVersion(final Operation op) throws IOException;1539723533;resolves the current version of the document, returning null if not found;private VersionValue resolveDocVersion(final Operation op) throws IOException {_        assert incrementVersionLookup()_ _        VersionValue versionValue = getVersionFromMap(op.uid().bytes())__        if (versionValue == null) {_            assert incrementIndexVersionLookup()_ _            final long currentVersion = loadCurrentVersionFromIndex(op.uid())__            if (currentVersion != Versions.NOT_FOUND) {_                versionValue = new IndexVersionValue(null, currentVersion, SequenceNumbers.UNASSIGNED_SEQ_NO, 0L)__            }_        } else if (engineConfig.isEnableGcDeletes() && versionValue.isDelete() &&_            (engineConfig.getThreadPool().relativeTimeInMillis() - ((DeleteVersionValue)versionValue).time) > getGcDeletesInMillis()) {_            versionValue = null__        }_        return versionValue__    };resolves,the,current,version,of,the,document,returning,null,if,not,found;private,version,value,resolve,doc,version,final,operation,op,throws,ioexception,assert,increment,version,lookup,version,value,version,value,get,version,from,map,op,uid,bytes,if,version,value,null,assert,increment,index,version,lookup,final,long,current,version,load,current,version,from,index,op,uid,if,current,version,versions,version,value,new,index,version,value,null,current,version,sequence,numbers,0l,else,if,engine,config,is,enable,gc,deletes,version,value,is,delete,engine,config,get,thread,pool,relative,time,in,millis,delete,version,value,version,value,time,get,gc,deletes,in,millis,version,value,null,return,version,value
InternalEngine -> private VersionValue resolveDocVersion(final Operation op) throws IOException;1540238977;resolves the current version of the document, returning null if not found;private VersionValue resolveDocVersion(final Operation op) throws IOException {_        assert incrementVersionLookup()_ _        VersionValue versionValue = getVersionFromMap(op.uid().bytes())__        if (versionValue == null) {_            assert incrementIndexVersionLookup()_ _            final long currentVersion = loadCurrentVersionFromIndex(op.uid())__            if (currentVersion != Versions.NOT_FOUND) {_                versionValue = new IndexVersionValue(null, currentVersion, SequenceNumbers.UNASSIGNED_SEQ_NO, 0L)__            }_        } else if (engineConfig.isEnableGcDeletes() && versionValue.isDelete() &&_            (engineConfig.getThreadPool().relativeTimeInMillis() - ((DeleteVersionValue)versionValue).time) > getGcDeletesInMillis()) {_            versionValue = null__        }_        return versionValue__    };resolves,the,current,version,of,the,document,returning,null,if,not,found;private,version,value,resolve,doc,version,final,operation,op,throws,ioexception,assert,increment,version,lookup,version,value,version,value,get,version,from,map,op,uid,bytes,if,version,value,null,assert,increment,index,version,lookup,final,long,current,version,load,current,version,from,index,op,uid,if,current,version,versions,version,value,new,index,version,value,null,current,version,sequence,numbers,0l,else,if,engine,config,is,enable,gc,deletes,version,value,is,delete,engine,config,get,thread,pool,relative,time,in,millis,delete,version,value,version,value,time,get,gc,deletes,in,millis,version,value,null,return,version,value
InternalEngine -> private VersionValue resolveDocVersion(final Operation op) throws IOException;1541335413;resolves the current version of the document, returning null if not found;private VersionValue resolveDocVersion(final Operation op) throws IOException {_        assert incrementVersionLookup()_ _        VersionValue versionValue = getVersionFromMap(op.uid().bytes())__        if (versionValue == null) {_            assert incrementIndexVersionLookup()_ _            final long currentVersion = loadCurrentVersionFromIndex(op.uid())__            if (currentVersion != Versions.NOT_FOUND) {_                versionValue = new IndexVersionValue(null, currentVersion, SequenceNumbers.UNASSIGNED_SEQ_NO, 0L)__            }_        } else if (engineConfig.isEnableGcDeletes() && versionValue.isDelete() &&_            (engineConfig.getThreadPool().relativeTimeInMillis() - ((DeleteVersionValue)versionValue).time) > getGcDeletesInMillis()) {_            versionValue = null__        }_        return versionValue__    };resolves,the,current,version,of,the,document,returning,null,if,not,found;private,version,value,resolve,doc,version,final,operation,op,throws,ioexception,assert,increment,version,lookup,version,value,version,value,get,version,from,map,op,uid,bytes,if,version,value,null,assert,increment,index,version,lookup,final,long,current,version,load,current,version,from,index,op,uid,if,current,version,versions,version,value,new,index,version,value,null,current,version,sequence,numbers,0l,else,if,engine,config,is,enable,gc,deletes,version,value,is,delete,engine,config,get,thread,pool,relative,time,in,millis,delete,version,value,version,value,time,get,gc,deletes,in,millis,version,value,null,return,version,value
InternalEngine -> private VersionValue resolveDocVersion(final Operation op) throws IOException;1541622390;resolves the current version of the document, returning null if not found;private VersionValue resolveDocVersion(final Operation op) throws IOException {_        assert incrementVersionLookup()_ _        VersionValue versionValue = getVersionFromMap(op.uid().bytes())__        if (versionValue == null) {_            assert incrementIndexVersionLookup()_ _            final long currentVersion = loadCurrentVersionFromIndex(op.uid())__            if (currentVersion != Versions.NOT_FOUND) {_                versionValue = new IndexVersionValue(null, currentVersion, SequenceNumbers.UNASSIGNED_SEQ_NO, 0L)__            }_        } else if (engineConfig.isEnableGcDeletes() && versionValue.isDelete() &&_            (engineConfig.getThreadPool().relativeTimeInMillis() - ((DeleteVersionValue)versionValue).time) > getGcDeletesInMillis()) {_            versionValue = null__        }_        return versionValue__    };resolves,the,current,version,of,the,document,returning,null,if,not,found;private,version,value,resolve,doc,version,final,operation,op,throws,ioexception,assert,increment,version,lookup,version,value,version,value,get,version,from,map,op,uid,bytes,if,version,value,null,assert,increment,index,version,lookup,final,long,current,version,load,current,version,from,index,op,uid,if,current,version,versions,version,value,new,index,version,value,null,current,version,sequence,numbers,0l,else,if,engine,config,is,enable,gc,deletes,version,value,is,delete,engine,config,get,thread,pool,relative,time,in,millis,delete,version,value,version,value,time,get,gc,deletes,in,millis,version,value,null,return,version,value
InternalEngine -> private VersionValue resolveDocVersion(final Operation op) throws IOException;1542697754;resolves the current version of the document, returning null if not found;private VersionValue resolveDocVersion(final Operation op) throws IOException {_        assert incrementVersionLookup()_ _        VersionValue versionValue = getVersionFromMap(op.uid().bytes())__        if (versionValue == null) {_            assert incrementIndexVersionLookup()_ _            final long currentVersion = loadCurrentVersionFromIndex(op.uid())__            if (currentVersion != Versions.NOT_FOUND) {_                versionValue = new IndexVersionValue(null, currentVersion, SequenceNumbers.UNASSIGNED_SEQ_NO, 0L)__            }_        } else if (engineConfig.isEnableGcDeletes() && versionValue.isDelete() &&_            (engineConfig.getThreadPool().relativeTimeInMillis() - ((DeleteVersionValue)versionValue).time) > getGcDeletesInMillis()) {_            versionValue = null__        }_        return versionValue__    };resolves,the,current,version,of,the,document,returning,null,if,not,found;private,version,value,resolve,doc,version,final,operation,op,throws,ioexception,assert,increment,version,lookup,version,value,version,value,get,version,from,map,op,uid,bytes,if,version,value,null,assert,increment,index,version,lookup,final,long,current,version,load,current,version,from,index,op,uid,if,current,version,versions,version,value,new,index,version,value,null,current,version,sequence,numbers,0l,else,if,engine,config,is,enable,gc,deletes,version,value,is,delete,engine,config,get,thread,pool,relative,time,in,millis,delete,version,value,version,value,time,get,gc,deletes,in,millis,version,value,null,return,version,value
InternalEngine -> private VersionValue resolveDocVersion(final Operation op) throws IOException;1543940134;resolves the current version of the document, returning null if not found;private VersionValue resolveDocVersion(final Operation op) throws IOException {_        assert incrementVersionLookup()_ _        VersionValue versionValue = getVersionFromMap(op.uid().bytes())__        if (versionValue == null) {_            assert incrementIndexVersionLookup()_ _            final long currentVersion = loadCurrentVersionFromIndex(op.uid())__            if (currentVersion != Versions.NOT_FOUND) {_                versionValue = new IndexVersionValue(null, currentVersion, SequenceNumbers.UNASSIGNED_SEQ_NO, 0L)__            }_        } else if (engineConfig.isEnableGcDeletes() && versionValue.isDelete() &&_            (engineConfig.getThreadPool().relativeTimeInMillis() - ((DeleteVersionValue)versionValue).time) > getGcDeletesInMillis()) {_            versionValue = null__        }_        return versionValue__    };resolves,the,current,version,of,the,document,returning,null,if,not,found;private,version,value,resolve,doc,version,final,operation,op,throws,ioexception,assert,increment,version,lookup,version,value,version,value,get,version,from,map,op,uid,bytes,if,version,value,null,assert,increment,index,version,lookup,final,long,current,version,load,current,version,from,index,op,uid,if,current,version,versions,version,value,new,index,version,value,null,current,version,sequence,numbers,0l,else,if,engine,config,is,enable,gc,deletes,version,value,is,delete,engine,config,get,thread,pool,relative,time,in,millis,delete,version,value,version,value,time,get,gc,deletes,in,millis,version,value,null,return,version,value
InternalEngine -> private VersionValue resolveDocVersion(final Operation op) throws IOException;1544322276;resolves the current version of the document, returning null if not found;private VersionValue resolveDocVersion(final Operation op) throws IOException {_        assert incrementVersionLookup()_ _        VersionValue versionValue = getVersionFromMap(op.uid().bytes())__        if (versionValue == null) {_            assert incrementIndexVersionLookup()_ _            final long currentVersion = loadCurrentVersionFromIndex(op.uid())__            if (currentVersion != Versions.NOT_FOUND) {_                versionValue = new IndexVersionValue(null, currentVersion, SequenceNumbers.UNASSIGNED_SEQ_NO, 0L)__            }_        } else if (engineConfig.isEnableGcDeletes() && versionValue.isDelete() &&_            (engineConfig.getThreadPool().relativeTimeInMillis() - ((DeleteVersionValue)versionValue).time) > getGcDeletesInMillis()) {_            versionValue = null__        }_        return versionValue__    };resolves,the,current,version,of,the,document,returning,null,if,not,found;private,version,value,resolve,doc,version,final,operation,op,throws,ioexception,assert,increment,version,lookup,version,value,version,value,get,version,from,map,op,uid,bytes,if,version,value,null,assert,increment,index,version,lookup,final,long,current,version,load,current,version,from,index,op,uid,if,current,version,versions,version,value,new,index,version,value,null,current,version,sequence,numbers,0l,else,if,engine,config,is,enable,gc,deletes,version,value,is,delete,engine,config,get,thread,pool,relative,time,in,millis,delete,version,value,version,value,time,get,gc,deletes,in,millis,version,value,null,return,version,value
InternalEngine -> private VersionValue resolveDocVersion(final Operation op) throws IOException;1544545090;resolves the current version of the document, returning null if not found;private VersionValue resolveDocVersion(final Operation op) throws IOException {_        assert incrementVersionLookup()_ _        VersionValue versionValue = getVersionFromMap(op.uid().bytes())__        if (versionValue == null) {_            assert incrementIndexVersionLookup()_ _            final long currentVersion = loadCurrentVersionFromIndex(op.uid())__            if (currentVersion != Versions.NOT_FOUND) {_                versionValue = new IndexVersionValue(null, currentVersion, SequenceNumbers.UNASSIGNED_SEQ_NO, 0L)__            }_        } else if (engineConfig.isEnableGcDeletes() && versionValue.isDelete() &&_            (engineConfig.getThreadPool().relativeTimeInMillis() - ((DeleteVersionValue)versionValue).time) > getGcDeletesInMillis()) {_            versionValue = null__        }_        return versionValue__    };resolves,the,current,version,of,the,document,returning,null,if,not,found;private,version,value,resolve,doc,version,final,operation,op,throws,ioexception,assert,increment,version,lookup,version,value,version,value,get,version,from,map,op,uid,bytes,if,version,value,null,assert,increment,index,version,lookup,final,long,current,version,load,current,version,from,index,op,uid,if,current,version,versions,version,value,new,index,version,value,null,current,version,sequence,numbers,0l,else,if,engine,config,is,enable,gc,deletes,version,value,is,delete,engine,config,get,thread,pool,relative,time,in,millis,delete,version,value,version,value,time,get,gc,deletes,in,millis,version,value,null,return,version,value
InternalEngine -> private VersionValue resolveDocVersion(final Operation op, boolean loadSeqNo) throws IOException;1544684920;resolves the current version of the document, returning null if not found;private VersionValue resolveDocVersion(final Operation op, boolean loadSeqNo) throws IOException {_        assert incrementVersionLookup()_ _        VersionValue versionValue = getVersionFromMap(op.uid().bytes())__        if (versionValue == null) {_            assert incrementIndexVersionLookup()_ _            final VersionsAndSeqNoResolver.DocIdAndVersion docIdAndVersion__            try (Searcher searcher = acquireSearcher("load_version", SearcherScope.INTERNAL)) {_                 docIdAndVersion = VersionsAndSeqNoResolver.loadDocIdAndVersion(searcher.reader(), op.uid(), loadSeqNo)__            }_            if (docIdAndVersion != null) {_                versionValue = new IndexVersionValue(null, docIdAndVersion.version, docIdAndVersion.seqNo, docIdAndVersion.primaryTerm)__            }_        } else if (engineConfig.isEnableGcDeletes() && versionValue.isDelete() &&_            (engineConfig.getThreadPool().relativeTimeInMillis() - ((DeleteVersionValue)versionValue).time) > getGcDeletesInMillis()) {_            versionValue = null__        }_        return versionValue__    };resolves,the,current,version,of,the,document,returning,null,if,not,found;private,version,value,resolve,doc,version,final,operation,op,boolean,load,seq,no,throws,ioexception,assert,increment,version,lookup,version,value,version,value,get,version,from,map,op,uid,bytes,if,version,value,null,assert,increment,index,version,lookup,final,versions,and,seq,no,resolver,doc,id,and,version,doc,id,and,version,try,searcher,searcher,acquire,searcher,searcher,scope,internal,doc,id,and,version,versions,and,seq,no,resolver,load,doc,id,and,version,searcher,reader,op,uid,load,seq,no,if,doc,id,and,version,null,version,value,new,index,version,value,null,doc,id,and,version,version,doc,id,and,version,seq,no,doc,id,and,version,primary,term,else,if,engine,config,is,enable,gc,deletes,version,value,is,delete,engine,config,get,thread,pool,relative,time,in,millis,delete,version,value,version,value,time,get,gc,deletes,in,millis,version,value,null,return,version,value
InternalEngine -> private VersionValue resolveDocVersion(final Operation op, boolean loadSeqNo) throws IOException;1545140118;resolves the current version of the document, returning null if not found;private VersionValue resolveDocVersion(final Operation op, boolean loadSeqNo) throws IOException {_        assert incrementVersionLookup()_ _        VersionValue versionValue = getVersionFromMap(op.uid().bytes())__        if (versionValue == null) {_            assert incrementIndexVersionLookup()_ _            final VersionsAndSeqNoResolver.DocIdAndVersion docIdAndVersion__            try (Searcher searcher = acquireSearcher("load_version", SearcherScope.INTERNAL)) {_                 docIdAndVersion = VersionsAndSeqNoResolver.loadDocIdAndVersion(searcher.reader(), op.uid(), loadSeqNo)__            }_            if (docIdAndVersion != null) {_                versionValue = new IndexVersionValue(null, docIdAndVersion.version, docIdAndVersion.seqNo, docIdAndVersion.primaryTerm)__            }_        } else if (engineConfig.isEnableGcDeletes() && versionValue.isDelete() &&_            (engineConfig.getThreadPool().relativeTimeInMillis() - ((DeleteVersionValue)versionValue).time) > getGcDeletesInMillis()) {_            versionValue = null__        }_        return versionValue__    };resolves,the,current,version,of,the,document,returning,null,if,not,found;private,version,value,resolve,doc,version,final,operation,op,boolean,load,seq,no,throws,ioexception,assert,increment,version,lookup,version,value,version,value,get,version,from,map,op,uid,bytes,if,version,value,null,assert,increment,index,version,lookup,final,versions,and,seq,no,resolver,doc,id,and,version,doc,id,and,version,try,searcher,searcher,acquire,searcher,searcher,scope,internal,doc,id,and,version,versions,and,seq,no,resolver,load,doc,id,and,version,searcher,reader,op,uid,load,seq,no,if,doc,id,and,version,null,version,value,new,index,version,value,null,doc,id,and,version,version,doc,id,and,version,seq,no,doc,id,and,version,primary,term,else,if,engine,config,is,enable,gc,deletes,version,value,is,delete,engine,config,get,thread,pool,relative,time,in,millis,delete,version,value,version,value,time,get,gc,deletes,in,millis,version,value,null,return,version,value
InternalEngine -> private VersionValue resolveDocVersion(final Operation op, boolean loadSeqNo) throws IOException;1546875837;resolves the current version of the document, returning null if not found;private VersionValue resolveDocVersion(final Operation op, boolean loadSeqNo) throws IOException {_        assert incrementVersionLookup()_ _        VersionValue versionValue = getVersionFromMap(op.uid().bytes())__        if (versionValue == null) {_            assert incrementIndexVersionLookup()_ _            final VersionsAndSeqNoResolver.DocIdAndVersion docIdAndVersion__            try (Searcher searcher = acquireSearcher("load_version", SearcherScope.INTERNAL)) {_                 docIdAndVersion = VersionsAndSeqNoResolver.loadDocIdAndVersion(searcher.reader(), op.uid(), loadSeqNo)__            }_            if (docIdAndVersion != null) {_                versionValue = new IndexVersionValue(null, docIdAndVersion.version, docIdAndVersion.seqNo, docIdAndVersion.primaryTerm)__            }_        } else if (engineConfig.isEnableGcDeletes() && versionValue.isDelete() &&_            (engineConfig.getThreadPool().relativeTimeInMillis() - ((DeleteVersionValue)versionValue).time) > getGcDeletesInMillis()) {_            versionValue = null__        }_        return versionValue__    };resolves,the,current,version,of,the,document,returning,null,if,not,found;private,version,value,resolve,doc,version,final,operation,op,boolean,load,seq,no,throws,ioexception,assert,increment,version,lookup,version,value,version,value,get,version,from,map,op,uid,bytes,if,version,value,null,assert,increment,index,version,lookup,final,versions,and,seq,no,resolver,doc,id,and,version,doc,id,and,version,try,searcher,searcher,acquire,searcher,searcher,scope,internal,doc,id,and,version,versions,and,seq,no,resolver,load,doc,id,and,version,searcher,reader,op,uid,load,seq,no,if,doc,id,and,version,null,version,value,new,index,version,value,null,doc,id,and,version,version,doc,id,and,version,seq,no,doc,id,and,version,primary,term,else,if,engine,config,is,enable,gc,deletes,version,value,is,delete,engine,config,get,thread,pool,relative,time,in,millis,delete,version,value,version,value,time,get,gc,deletes,in,millis,version,value,null,return,version,value
InternalEngine -> private VersionValue resolveDocVersion(final Operation op, boolean loadSeqNo) throws IOException;1547332999;resolves the current version of the document, returning null if not found;private VersionValue resolveDocVersion(final Operation op, boolean loadSeqNo) throws IOException {_        assert incrementVersionLookup()_ _        VersionValue versionValue = getVersionFromMap(op.uid().bytes())__        if (versionValue == null) {_            assert incrementIndexVersionLookup()_ _            final VersionsAndSeqNoResolver.DocIdAndVersion docIdAndVersion__            try (Searcher searcher = acquireSearcher("load_version", SearcherScope.INTERNAL)) {_                 docIdAndVersion = VersionsAndSeqNoResolver.loadDocIdAndVersion(searcher.reader(), op.uid(), loadSeqNo)__            }_            if (docIdAndVersion != null) {_                versionValue = new IndexVersionValue(null, docIdAndVersion.version, docIdAndVersion.seqNo, docIdAndVersion.primaryTerm)__            }_        } else if (engineConfig.isEnableGcDeletes() && versionValue.isDelete() &&_            (engineConfig.getThreadPool().relativeTimeInMillis() - ((DeleteVersionValue)versionValue).time) > getGcDeletesInMillis()) {_            versionValue = null__        }_        return versionValue__    };resolves,the,current,version,of,the,document,returning,null,if,not,found;private,version,value,resolve,doc,version,final,operation,op,boolean,load,seq,no,throws,ioexception,assert,increment,version,lookup,version,value,version,value,get,version,from,map,op,uid,bytes,if,version,value,null,assert,increment,index,version,lookup,final,versions,and,seq,no,resolver,doc,id,and,version,doc,id,and,version,try,searcher,searcher,acquire,searcher,searcher,scope,internal,doc,id,and,version,versions,and,seq,no,resolver,load,doc,id,and,version,searcher,reader,op,uid,load,seq,no,if,doc,id,and,version,null,version,value,new,index,version,value,null,doc,id,and,version,version,doc,id,and,version,seq,no,doc,id,and,version,primary,term,else,if,engine,config,is,enable,gc,deletes,version,value,is,delete,engine,config,get,thread,pool,relative,time,in,millis,delete,version,value,version,value,time,get,gc,deletes,in,millis,version,value,null,return,version,value
InternalEngine -> private VersionValue resolveDocVersion(final Operation op, boolean loadSeqNo) throws IOException;1548771485;resolves the current version of the document, returning null if not found;private VersionValue resolveDocVersion(final Operation op, boolean loadSeqNo) throws IOException {_        assert incrementVersionLookup()_ _        VersionValue versionValue = getVersionFromMap(op.uid().bytes())__        if (versionValue == null) {_            assert incrementIndexVersionLookup()_ _            final VersionsAndSeqNoResolver.DocIdAndVersion docIdAndVersion__            try (Searcher searcher = acquireSearcher("load_version", SearcherScope.INTERNAL)) {_                 docIdAndVersion = VersionsAndSeqNoResolver.loadDocIdAndVersion(searcher.reader(), op.uid(), loadSeqNo)__            }_            if (docIdAndVersion != null) {_                versionValue = new IndexVersionValue(null, docIdAndVersion.version, docIdAndVersion.seqNo, docIdAndVersion.primaryTerm)__            }_        } else if (engineConfig.isEnableGcDeletes() && versionValue.isDelete() &&_            (engineConfig.getThreadPool().relativeTimeInMillis() - ((DeleteVersionValue)versionValue).time) > getGcDeletesInMillis()) {_            versionValue = null__        }_        return versionValue__    };resolves,the,current,version,of,the,document,returning,null,if,not,found;private,version,value,resolve,doc,version,final,operation,op,boolean,load,seq,no,throws,ioexception,assert,increment,version,lookup,version,value,version,value,get,version,from,map,op,uid,bytes,if,version,value,null,assert,increment,index,version,lookup,final,versions,and,seq,no,resolver,doc,id,and,version,doc,id,and,version,try,searcher,searcher,acquire,searcher,searcher,scope,internal,doc,id,and,version,versions,and,seq,no,resolver,load,doc,id,and,version,searcher,reader,op,uid,load,seq,no,if,doc,id,and,version,null,version,value,new,index,version,value,null,doc,id,and,version,version,doc,id,and,version,seq,no,doc,id,and,version,primary,term,else,if,engine,config,is,enable,gc,deletes,version,value,is,delete,engine,config,get,thread,pool,relative,time,in,millis,delete,version,value,version,value,time,get,gc,deletes,in,millis,version,value,null,return,version,value
InternalEngine -> private VersionValue resolveDocVersion(final Operation op, boolean loadSeqNo) throws IOException;1549059559;resolves the current version of the document, returning null if not found;private VersionValue resolveDocVersion(final Operation op, boolean loadSeqNo) throws IOException {_        assert incrementVersionLookup()_ _        VersionValue versionValue = getVersionFromMap(op.uid().bytes())__        if (versionValue == null) {_            assert incrementIndexVersionLookup()_ _            final VersionsAndSeqNoResolver.DocIdAndVersion docIdAndVersion__            try (Searcher searcher = acquireSearcher("load_version", SearcherScope.INTERNAL)) {_                 docIdAndVersion = VersionsAndSeqNoResolver.loadDocIdAndVersion(searcher.reader(), op.uid(), loadSeqNo)__            }_            if (docIdAndVersion != null) {_                versionValue = new IndexVersionValue(null, docIdAndVersion.version, docIdAndVersion.seqNo, docIdAndVersion.primaryTerm)__            }_        } else if (engineConfig.isEnableGcDeletes() && versionValue.isDelete() &&_            (engineConfig.getThreadPool().relativeTimeInMillis() - ((DeleteVersionValue)versionValue).time) > getGcDeletesInMillis()) {_            versionValue = null__        }_        return versionValue__    };resolves,the,current,version,of,the,document,returning,null,if,not,found;private,version,value,resolve,doc,version,final,operation,op,boolean,load,seq,no,throws,ioexception,assert,increment,version,lookup,version,value,version,value,get,version,from,map,op,uid,bytes,if,version,value,null,assert,increment,index,version,lookup,final,versions,and,seq,no,resolver,doc,id,and,version,doc,id,and,version,try,searcher,searcher,acquire,searcher,searcher,scope,internal,doc,id,and,version,versions,and,seq,no,resolver,load,doc,id,and,version,searcher,reader,op,uid,load,seq,no,if,doc,id,and,version,null,version,value,new,index,version,value,null,doc,id,and,version,version,doc,id,and,version,seq,no,doc,id,and,version,primary,term,else,if,engine,config,is,enable,gc,deletes,version,value,is,delete,engine,config,get,thread,pool,relative,time,in,millis,delete,version,value,version,value,time,get,gc,deletes,in,millis,version,value,null,return,version,value
InternalEngine -> private VersionValue resolveDocVersion(final Operation op, boolean loadSeqNo) throws IOException;1549663373;resolves the current version of the document, returning null if not found;private VersionValue resolveDocVersion(final Operation op, boolean loadSeqNo) throws IOException {_        assert incrementVersionLookup()_ _        VersionValue versionValue = getVersionFromMap(op.uid().bytes())__        if (versionValue == null) {_            assert incrementIndexVersionLookup()_ _            final VersionsAndSeqNoResolver.DocIdAndVersion docIdAndVersion__            try (Searcher searcher = acquireSearcher("load_version", SearcherScope.INTERNAL)) {_                 docIdAndVersion = VersionsAndSeqNoResolver.loadDocIdAndVersion(searcher.reader(), op.uid(), loadSeqNo)__            }_            if (docIdAndVersion != null) {_                versionValue = new IndexVersionValue(null, docIdAndVersion.version, docIdAndVersion.seqNo, docIdAndVersion.primaryTerm)__            }_        } else if (engineConfig.isEnableGcDeletes() && versionValue.isDelete() &&_            (engineConfig.getThreadPool().relativeTimeInMillis() - ((DeleteVersionValue)versionValue).time) > getGcDeletesInMillis()) {_            versionValue = null__        }_        return versionValue__    };resolves,the,current,version,of,the,document,returning,null,if,not,found;private,version,value,resolve,doc,version,final,operation,op,boolean,load,seq,no,throws,ioexception,assert,increment,version,lookup,version,value,version,value,get,version,from,map,op,uid,bytes,if,version,value,null,assert,increment,index,version,lookup,final,versions,and,seq,no,resolver,doc,id,and,version,doc,id,and,version,try,searcher,searcher,acquire,searcher,searcher,scope,internal,doc,id,and,version,versions,and,seq,no,resolver,load,doc,id,and,version,searcher,reader,op,uid,load,seq,no,if,doc,id,and,version,null,version,value,new,index,version,value,null,doc,id,and,version,version,doc,id,and,version,seq,no,doc,id,and,version,primary,term,else,if,engine,config,is,enable,gc,deletes,version,value,is,delete,engine,config,get,thread,pool,relative,time,in,millis,delete,version,value,version,value,time,get,gc,deletes,in,millis,version,value,null,return,version,value
InternalEngine -> private VersionValue resolveDocVersion(final Operation op, boolean loadSeqNo) throws IOException;1549975032;resolves the current version of the document, returning null if not found;private VersionValue resolveDocVersion(final Operation op, boolean loadSeqNo) throws IOException {_        assert incrementVersionLookup()_ _        VersionValue versionValue = getVersionFromMap(op.uid().bytes())__        if (versionValue == null) {_            assert incrementIndexVersionLookup()_ _            final VersionsAndSeqNoResolver.DocIdAndVersion docIdAndVersion__            try (Searcher searcher = acquireSearcher("load_version", SearcherScope.INTERNAL)) {_                 docIdAndVersion = VersionsAndSeqNoResolver.loadDocIdAndVersion(searcher.reader(), op.uid(), loadSeqNo)__            }_            if (docIdAndVersion != null) {_                versionValue = new IndexVersionValue(null, docIdAndVersion.version, docIdAndVersion.seqNo, docIdAndVersion.primaryTerm)__            }_        } else if (engineConfig.isEnableGcDeletes() && versionValue.isDelete() &&_            (engineConfig.getThreadPool().relativeTimeInMillis() - ((DeleteVersionValue)versionValue).time) > getGcDeletesInMillis()) {_            versionValue = null__        }_        return versionValue__    };resolves,the,current,version,of,the,document,returning,null,if,not,found;private,version,value,resolve,doc,version,final,operation,op,boolean,load,seq,no,throws,ioexception,assert,increment,version,lookup,version,value,version,value,get,version,from,map,op,uid,bytes,if,version,value,null,assert,increment,index,version,lookup,final,versions,and,seq,no,resolver,doc,id,and,version,doc,id,and,version,try,searcher,searcher,acquire,searcher,searcher,scope,internal,doc,id,and,version,versions,and,seq,no,resolver,load,doc,id,and,version,searcher,reader,op,uid,load,seq,no,if,doc,id,and,version,null,version,value,new,index,version,value,null,doc,id,and,version,version,doc,id,and,version,seq,no,doc,id,and,version,primary,term,else,if,engine,config,is,enable,gc,deletes,version,value,is,delete,engine,config,get,thread,pool,relative,time,in,millis,delete,version,value,version,value,time,get,gc,deletes,in,millis,version,value,null,return,version,value
InternalEngine -> private VersionValue resolveDocVersion(final Operation op, boolean loadSeqNo) throws IOException;1550220204;resolves the current version of the document, returning null if not found;private VersionValue resolveDocVersion(final Operation op, boolean loadSeqNo) throws IOException {_        assert incrementVersionLookup()_ _        VersionValue versionValue = getVersionFromMap(op.uid().bytes())__        if (versionValue == null) {_            assert incrementIndexVersionLookup()_ _            final VersionsAndSeqNoResolver.DocIdAndVersion docIdAndVersion__            try (Searcher searcher = acquireSearcher("load_version", SearcherScope.INTERNAL)) {_                 docIdAndVersion = VersionsAndSeqNoResolver.loadDocIdAndVersion(searcher.reader(), op.uid(), loadSeqNo)__            }_            if (docIdAndVersion != null) {_                versionValue = new IndexVersionValue(null, docIdAndVersion.version, docIdAndVersion.seqNo, docIdAndVersion.primaryTerm)__            }_        } else if (engineConfig.isEnableGcDeletes() && versionValue.isDelete() &&_            (engineConfig.getThreadPool().relativeTimeInMillis() - ((DeleteVersionValue)versionValue).time) > getGcDeletesInMillis()) {_            versionValue = null__        }_        return versionValue__    };resolves,the,current,version,of,the,document,returning,null,if,not,found;private,version,value,resolve,doc,version,final,operation,op,boolean,load,seq,no,throws,ioexception,assert,increment,version,lookup,version,value,version,value,get,version,from,map,op,uid,bytes,if,version,value,null,assert,increment,index,version,lookup,final,versions,and,seq,no,resolver,doc,id,and,version,doc,id,and,version,try,searcher,searcher,acquire,searcher,searcher,scope,internal,doc,id,and,version,versions,and,seq,no,resolver,load,doc,id,and,version,searcher,reader,op,uid,load,seq,no,if,doc,id,and,version,null,version,value,new,index,version,value,null,doc,id,and,version,version,doc,id,and,version,seq,no,doc,id,and,version,primary,term,else,if,engine,config,is,enable,gc,deletes,version,value,is,delete,engine,config,get,thread,pool,relative,time,in,millis,delete,version,value,version,value,time,get,gc,deletes,in,millis,version,value,null,return,version,value
InternalEngine -> private VersionValue resolveDocVersion(final Operation op, boolean loadSeqNo) throws IOException;1550256122;resolves the current version of the document, returning null if not found;private VersionValue resolveDocVersion(final Operation op, boolean loadSeqNo) throws IOException {_        assert incrementVersionLookup()_ _        VersionValue versionValue = getVersionFromMap(op.uid().bytes())__        if (versionValue == null) {_            assert incrementIndexVersionLookup()_ _            final VersionsAndSeqNoResolver.DocIdAndVersion docIdAndVersion__            try (Searcher searcher = acquireSearcher("load_version", SearcherScope.INTERNAL)) {_                 docIdAndVersion = VersionsAndSeqNoResolver.loadDocIdAndVersion(searcher.reader(), op.uid(), loadSeqNo)__            }_            if (docIdAndVersion != null) {_                versionValue = new IndexVersionValue(null, docIdAndVersion.version, docIdAndVersion.seqNo, docIdAndVersion.primaryTerm)__            }_        } else if (engineConfig.isEnableGcDeletes() && versionValue.isDelete() &&_            (engineConfig.getThreadPool().relativeTimeInMillis() - ((DeleteVersionValue)versionValue).time) > getGcDeletesInMillis()) {_            versionValue = null__        }_        return versionValue__    };resolves,the,current,version,of,the,document,returning,null,if,not,found;private,version,value,resolve,doc,version,final,operation,op,boolean,load,seq,no,throws,ioexception,assert,increment,version,lookup,version,value,version,value,get,version,from,map,op,uid,bytes,if,version,value,null,assert,increment,index,version,lookup,final,versions,and,seq,no,resolver,doc,id,and,version,doc,id,and,version,try,searcher,searcher,acquire,searcher,searcher,scope,internal,doc,id,and,version,versions,and,seq,no,resolver,load,doc,id,and,version,searcher,reader,op,uid,load,seq,no,if,doc,id,and,version,null,version,value,new,index,version,value,null,doc,id,and,version,version,doc,id,and,version,seq,no,doc,id,and,version,primary,term,else,if,engine,config,is,enable,gc,deletes,version,value,is,delete,engine,config,get,thread,pool,relative,time,in,millis,delete,version,value,version,value,time,get,gc,deletes,in,millis,version,value,null,return,version,value
InternalEngine -> private VersionValue resolveDocVersion(final Operation op, boolean loadSeqNo) throws IOException;1550342051;resolves the current version of the document, returning null if not found;private VersionValue resolveDocVersion(final Operation op, boolean loadSeqNo) throws IOException {_        assert incrementVersionLookup()_ _        VersionValue versionValue = getVersionFromMap(op.uid().bytes())__        if (versionValue == null) {_            assert incrementIndexVersionLookup()_ _            final VersionsAndSeqNoResolver.DocIdAndVersion docIdAndVersion__            try (Searcher searcher = acquireSearcher("load_version", SearcherScope.INTERNAL)) {_                 docIdAndVersion = VersionsAndSeqNoResolver.loadDocIdAndVersion(searcher.reader(), op.uid(), loadSeqNo)__            }_            if (docIdAndVersion != null) {_                versionValue = new IndexVersionValue(null, docIdAndVersion.version, docIdAndVersion.seqNo, docIdAndVersion.primaryTerm)__            }_        } else if (engineConfig.isEnableGcDeletes() && versionValue.isDelete() &&_            (engineConfig.getThreadPool().relativeTimeInMillis() - ((DeleteVersionValue)versionValue).time) > getGcDeletesInMillis()) {_            versionValue = null__        }_        return versionValue__    };resolves,the,current,version,of,the,document,returning,null,if,not,found;private,version,value,resolve,doc,version,final,operation,op,boolean,load,seq,no,throws,ioexception,assert,increment,version,lookup,version,value,version,value,get,version,from,map,op,uid,bytes,if,version,value,null,assert,increment,index,version,lookup,final,versions,and,seq,no,resolver,doc,id,and,version,doc,id,and,version,try,searcher,searcher,acquire,searcher,searcher,scope,internal,doc,id,and,version,versions,and,seq,no,resolver,load,doc,id,and,version,searcher,reader,op,uid,load,seq,no,if,doc,id,and,version,null,version,value,new,index,version,value,null,doc,id,and,version,version,doc,id,and,version,seq,no,doc,id,and,version,primary,term,else,if,engine,config,is,enable,gc,deletes,version,value,is,delete,engine,config,get,thread,pool,relative,time,in,millis,delete,version,value,version,value,time,get,gc,deletes,in,millis,version,value,null,return,version,value
InternalEngine -> private VersionValue resolveDocVersion(final Operation op, boolean loadSeqNo) throws IOException;1550526771;resolves the current version of the document, returning null if not found;private VersionValue resolveDocVersion(final Operation op, boolean loadSeqNo) throws IOException {_        assert incrementVersionLookup()_ _        VersionValue versionValue = getVersionFromMap(op.uid().bytes())__        if (versionValue == null) {_            assert incrementIndexVersionLookup()_ _            final VersionsAndSeqNoResolver.DocIdAndVersion docIdAndVersion__            try (Searcher searcher = acquireSearcher("load_version", SearcherScope.INTERNAL)) {_                 docIdAndVersion = VersionsAndSeqNoResolver.loadDocIdAndVersion(searcher.reader(), op.uid(), loadSeqNo)__            }_            if (docIdAndVersion != null) {_                versionValue = new IndexVersionValue(null, docIdAndVersion.version, docIdAndVersion.seqNo, docIdAndVersion.primaryTerm)__            }_        } else if (engineConfig.isEnableGcDeletes() && versionValue.isDelete() &&_            (engineConfig.getThreadPool().relativeTimeInMillis() - ((DeleteVersionValue)versionValue).time) > getGcDeletesInMillis()) {_            versionValue = null__        }_        return versionValue__    };resolves,the,current,version,of,the,document,returning,null,if,not,found;private,version,value,resolve,doc,version,final,operation,op,boolean,load,seq,no,throws,ioexception,assert,increment,version,lookup,version,value,version,value,get,version,from,map,op,uid,bytes,if,version,value,null,assert,increment,index,version,lookup,final,versions,and,seq,no,resolver,doc,id,and,version,doc,id,and,version,try,searcher,searcher,acquire,searcher,searcher,scope,internal,doc,id,and,version,versions,and,seq,no,resolver,load,doc,id,and,version,searcher,reader,op,uid,load,seq,no,if,doc,id,and,version,null,version,value,new,index,version,value,null,doc,id,and,version,version,doc,id,and,version,seq,no,doc,id,and,version,primary,term,else,if,engine,config,is,enable,gc,deletes,version,value,is,delete,engine,config,get,thread,pool,relative,time,in,millis,delete,version,value,version,value,time,get,gc,deletes,in,millis,version,value,null,return,version,value
InternalEngine -> private VersionValue resolveDocVersion(final Operation op, boolean loadSeqNo) throws IOException;1551110274;resolves the current version of the document, returning null if not found;private VersionValue resolveDocVersion(final Operation op, boolean loadSeqNo) throws IOException {_        assert incrementVersionLookup()_ _        VersionValue versionValue = getVersionFromMap(op.uid().bytes())__        if (versionValue == null) {_            assert incrementIndexVersionLookup()_ _            final VersionsAndSeqNoResolver.DocIdAndVersion docIdAndVersion__            try (Searcher searcher = acquireSearcher("load_version", SearcherScope.INTERNAL)) {_                 docIdAndVersion = VersionsAndSeqNoResolver.loadDocIdAndVersion(searcher.reader(), op.uid(), loadSeqNo)__            }_            if (docIdAndVersion != null) {_                versionValue = new IndexVersionValue(null, docIdAndVersion.version, docIdAndVersion.seqNo, docIdAndVersion.primaryTerm)__            }_        } else if (engineConfig.isEnableGcDeletes() && versionValue.isDelete() &&_            (engineConfig.getThreadPool().relativeTimeInMillis() - ((DeleteVersionValue)versionValue).time) > getGcDeletesInMillis()) {_            versionValue = null__        }_        return versionValue__    };resolves,the,current,version,of,the,document,returning,null,if,not,found;private,version,value,resolve,doc,version,final,operation,op,boolean,load,seq,no,throws,ioexception,assert,increment,version,lookup,version,value,version,value,get,version,from,map,op,uid,bytes,if,version,value,null,assert,increment,index,version,lookup,final,versions,and,seq,no,resolver,doc,id,and,version,doc,id,and,version,try,searcher,searcher,acquire,searcher,searcher,scope,internal,doc,id,and,version,versions,and,seq,no,resolver,load,doc,id,and,version,searcher,reader,op,uid,load,seq,no,if,doc,id,and,version,null,version,value,new,index,version,value,null,doc,id,and,version,version,doc,id,and,version,seq,no,doc,id,and,version,primary,term,else,if,engine,config,is,enable,gc,deletes,version,value,is,delete,engine,config,get,thread,pool,relative,time,in,millis,delete,version,value,version,value,time,get,gc,deletes,in,millis,version,value,null,return,version,value
InternalEngine -> private VersionValue resolveDocVersion(final Operation op, boolean loadSeqNo) throws IOException;1551126708;resolves the current version of the document, returning null if not found;private VersionValue resolveDocVersion(final Operation op, boolean loadSeqNo) throws IOException {_        assert incrementVersionLookup()_ _        VersionValue versionValue = getVersionFromMap(op.uid().bytes())__        if (versionValue == null) {_            assert incrementIndexVersionLookup()_ _            final VersionsAndSeqNoResolver.DocIdAndVersion docIdAndVersion__            try (Searcher searcher = acquireSearcher("load_version", SearcherScope.INTERNAL)) {_                 docIdAndVersion = VersionsAndSeqNoResolver.loadDocIdAndVersion(searcher.reader(), op.uid(), loadSeqNo)__            }_            if (docIdAndVersion != null) {_                versionValue = new IndexVersionValue(null, docIdAndVersion.version, docIdAndVersion.seqNo, docIdAndVersion.primaryTerm)__            }_        } else if (engineConfig.isEnableGcDeletes() && versionValue.isDelete() &&_            (engineConfig.getThreadPool().relativeTimeInMillis() - ((DeleteVersionValue)versionValue).time) > getGcDeletesInMillis()) {_            versionValue = null__        }_        return versionValue__    };resolves,the,current,version,of,the,document,returning,null,if,not,found;private,version,value,resolve,doc,version,final,operation,op,boolean,load,seq,no,throws,ioexception,assert,increment,version,lookup,version,value,version,value,get,version,from,map,op,uid,bytes,if,version,value,null,assert,increment,index,version,lookup,final,versions,and,seq,no,resolver,doc,id,and,version,doc,id,and,version,try,searcher,searcher,acquire,searcher,searcher,scope,internal,doc,id,and,version,versions,and,seq,no,resolver,load,doc,id,and,version,searcher,reader,op,uid,load,seq,no,if,doc,id,and,version,null,version,value,new,index,version,value,null,doc,id,and,version,version,doc,id,and,version,seq,no,doc,id,and,version,primary,term,else,if,engine,config,is,enable,gc,deletes,version,value,is,delete,engine,config,get,thread,pool,relative,time,in,millis,delete,version,value,version,value,time,get,gc,deletes,in,millis,version,value,null,return,version,value
InternalEngine -> final long getMinRetainedSeqNo();1535723122;Returns the minimum seqno that is retained in the Lucene index._Operations whose seq# are at least this value should exist in the Lucene index.;final long getMinRetainedSeqNo() {_        assert softDeleteEnabled : Thread.currentThread().getName()__        return softDeletesPolicy.getMinRetainedSeqNo()__    };returns,the,minimum,seqno,that,is,retained,in,the,lucene,index,operations,whose,seq,are,at,least,this,value,should,exist,in,the,lucene,index;final,long,get,min,retained,seq,no,assert,soft,delete,enabled,thread,current,thread,get,name,return,soft,deletes,policy,get,min,retained,seq,no
InternalEngine -> final long getMinRetainedSeqNo();1535965276;Returns the minimum seqno that is retained in the Lucene index._Operations whose seq# are at least this value should exist in the Lucene index.;final long getMinRetainedSeqNo() {_        assert softDeleteEnabled : Thread.currentThread().getName()__        return softDeletesPolicy.getMinRetainedSeqNo()__    };returns,the,minimum,seqno,that,is,retained,in,the,lucene,index,operations,whose,seq,are,at,least,this,value,should,exist,in,the,lucene,index;final,long,get,min,retained,seq,no,assert,soft,delete,enabled,thread,current,thread,get,name,return,soft,deletes,policy,get,min,retained,seq,no
InternalEngine -> final long getMinRetainedSeqNo();1536218260;Returns the minimum seqno that is retained in the Lucene index._Operations whose seq# are at least this value should exist in the Lucene index.;final long getMinRetainedSeqNo() {_        assert softDeleteEnabled : Thread.currentThread().getName()__        return softDeletesPolicy.getMinRetainedSeqNo()__    };returns,the,minimum,seqno,that,is,retained,in,the,lucene,index,operations,whose,seq,are,at,least,this,value,should,exist,in,the,lucene,index;final,long,get,min,retained,seq,no,assert,soft,delete,enabled,thread,current,thread,get,name,return,soft,deletes,policy,get,min,retained,seq,no
InternalEngine -> final long getMinRetainedSeqNo();1536314350;Returns the minimum seqno that is retained in the Lucene index._Operations whose seq# are at least this value should exist in the Lucene index.;final long getMinRetainedSeqNo() {_        assert softDeleteEnabled : Thread.currentThread().getName()__        return softDeletesPolicy.getMinRetainedSeqNo()__    };returns,the,minimum,seqno,that,is,retained,in,the,lucene,index,operations,whose,seq,are,at,least,this,value,should,exist,in,the,lucene,index;final,long,get,min,retained,seq,no,assert,soft,delete,enabled,thread,current,thread,get,name,return,soft,deletes,policy,get,min,retained,seq,no
InternalEngine -> final long getMinRetainedSeqNo();1536828374;Returns the minimum seqno that is retained in the Lucene index._Operations whose seq# are at least this value should exist in the Lucene index.;final long getMinRetainedSeqNo() {_        assert softDeleteEnabled : Thread.currentThread().getName()__        return softDeletesPolicy.getMinRetainedSeqNo()__    };returns,the,minimum,seqno,that,is,retained,in,the,lucene,index,operations,whose,seq,are,at,least,this,value,should,exist,in,the,lucene,index;final,long,get,min,retained,seq,no,assert,soft,delete,enabled,thread,current,thread,get,name,return,soft,deletes,policy,get,min,retained,seq,no
InternalEngine -> final long getMinRetainedSeqNo();1537806831;Returns the minimum seqno that is retained in the Lucene index._Operations whose seq# are at least this value should exist in the Lucene index.;final long getMinRetainedSeqNo() {_        assert softDeleteEnabled : Thread.currentThread().getName()__        return softDeletesPolicy.getMinRetainedSeqNo()__    };returns,the,minimum,seqno,that,is,retained,in,the,lucene,index,operations,whose,seq,are,at,least,this,value,should,exist,in,the,lucene,index;final,long,get,min,retained,seq,no,assert,soft,delete,enabled,thread,current,thread,get,name,return,soft,deletes,policy,get,min,retained,seq,no
InternalEngine -> final long getMinRetainedSeqNo();1538067637;Returns the minimum seqno that is retained in the Lucene index._Operations whose seq# are at least this value should exist in the Lucene index.;final long getMinRetainedSeqNo() {_        assert softDeleteEnabled : Thread.currentThread().getName()__        return softDeletesPolicy.getMinRetainedSeqNo()__    };returns,the,minimum,seqno,that,is,retained,in,the,lucene,index,operations,whose,seq,are,at,least,this,value,should,exist,in,the,lucene,index;final,long,get,min,retained,seq,no,assert,soft,delete,enabled,thread,current,thread,get,name,return,soft,deletes,policy,get,min,retained,seq,no
InternalEngine -> final long getMinRetainedSeqNo();1538424609;Returns the minimum seqno that is retained in the Lucene index._Operations whose seq# are at least this value should exist in the Lucene index.;final long getMinRetainedSeqNo() {_        assert softDeleteEnabled : Thread.currentThread().getName()__        return softDeletesPolicy.getMinRetainedSeqNo()__    };returns,the,minimum,seqno,that,is,retained,in,the,lucene,index,operations,whose,seq,are,at,least,this,value,should,exist,in,the,lucene,index;final,long,get,min,retained,seq,no,assert,soft,delete,enabled,thread,current,thread,get,name,return,soft,deletes,policy,get,min,retained,seq,no
InternalEngine -> final long getMinRetainedSeqNo();1539615817;Returns the minimum seqno that is retained in the Lucene index._Operations whose seq# are at least this value should exist in the Lucene index.;final long getMinRetainedSeqNo() {_        assert softDeleteEnabled : Thread.currentThread().getName()__        return softDeletesPolicy.getMinRetainedSeqNo()__    };returns,the,minimum,seqno,that,is,retained,in,the,lucene,index,operations,whose,seq,are,at,least,this,value,should,exist,in,the,lucene,index;final,long,get,min,retained,seq,no,assert,soft,delete,enabled,thread,current,thread,get,name,return,soft,deletes,policy,get,min,retained,seq,no
InternalEngine -> final long getMinRetainedSeqNo();1539723533;Returns the minimum seqno that is retained in the Lucene index._Operations whose seq# are at least this value should exist in the Lucene index.;final long getMinRetainedSeqNo() {_        assert softDeleteEnabled : Thread.currentThread().getName()__        return softDeletesPolicy.getMinRetainedSeqNo()__    };returns,the,minimum,seqno,that,is,retained,in,the,lucene,index,operations,whose,seq,are,at,least,this,value,should,exist,in,the,lucene,index;final,long,get,min,retained,seq,no,assert,soft,delete,enabled,thread,current,thread,get,name,return,soft,deletes,policy,get,min,retained,seq,no
InternalEngine -> final long getMinRetainedSeqNo();1540238977;Returns the minimum seqno that is retained in the Lucene index._Operations whose seq# are at least this value should exist in the Lucene index.;final long getMinRetainedSeqNo() {_        assert softDeleteEnabled : Thread.currentThread().getName()__        return softDeletesPolicy.getMinRetainedSeqNo()__    };returns,the,minimum,seqno,that,is,retained,in,the,lucene,index,operations,whose,seq,are,at,least,this,value,should,exist,in,the,lucene,index;final,long,get,min,retained,seq,no,assert,soft,delete,enabled,thread,current,thread,get,name,return,soft,deletes,policy,get,min,retained,seq,no
InternalEngine -> final long getMinRetainedSeqNo();1541335413;Returns the minimum seqno that is retained in the Lucene index._Operations whose seq# are at least this value should exist in the Lucene index.;final long getMinRetainedSeqNo() {_        assert softDeleteEnabled : Thread.currentThread().getName()__        return softDeletesPolicy.getMinRetainedSeqNo()__    };returns,the,minimum,seqno,that,is,retained,in,the,lucene,index,operations,whose,seq,are,at,least,this,value,should,exist,in,the,lucene,index;final,long,get,min,retained,seq,no,assert,soft,delete,enabled,thread,current,thread,get,name,return,soft,deletes,policy,get,min,retained,seq,no
InternalEngine -> final long getMinRetainedSeqNo();1541622390;Returns the minimum seqno that is retained in the Lucene index._Operations whose seq# are at least this value should exist in the Lucene index.;final long getMinRetainedSeqNo() {_        assert softDeleteEnabled : Thread.currentThread().getName()__        return softDeletesPolicy.getMinRetainedSeqNo()__    };returns,the,minimum,seqno,that,is,retained,in,the,lucene,index,operations,whose,seq,are,at,least,this,value,should,exist,in,the,lucene,index;final,long,get,min,retained,seq,no,assert,soft,delete,enabled,thread,current,thread,get,name,return,soft,deletes,policy,get,min,retained,seq,no
InternalEngine -> final long getMinRetainedSeqNo();1542697754;Returns the minimum seqno that is retained in the Lucene index._Operations whose seq# are at least this value should exist in the Lucene index.;final long getMinRetainedSeqNo() {_        assert softDeleteEnabled : Thread.currentThread().getName()__        return softDeletesPolicy.getMinRetainedSeqNo()__    };returns,the,minimum,seqno,that,is,retained,in,the,lucene,index,operations,whose,seq,are,at,least,this,value,should,exist,in,the,lucene,index;final,long,get,min,retained,seq,no,assert,soft,delete,enabled,thread,current,thread,get,name,return,soft,deletes,policy,get,min,retained,seq,no
InternalEngine -> final long getMinRetainedSeqNo();1543940134;Returns the minimum seqno that is retained in the Lucene index._Operations whose seq# are at least this value should exist in the Lucene index.;final long getMinRetainedSeqNo() {_        assert softDeleteEnabled : Thread.currentThread().getName()__        return softDeletesPolicy.getMinRetainedSeqNo()__    };returns,the,minimum,seqno,that,is,retained,in,the,lucene,index,operations,whose,seq,are,at,least,this,value,should,exist,in,the,lucene,index;final,long,get,min,retained,seq,no,assert,soft,delete,enabled,thread,current,thread,get,name,return,soft,deletes,policy,get,min,retained,seq,no
InternalEngine -> final long getMinRetainedSeqNo();1544322276;Returns the minimum seqno that is retained in the Lucene index._Operations whose seq# are at least this value should exist in the Lucene index.;final long getMinRetainedSeqNo() {_        assert softDeleteEnabled : Thread.currentThread().getName()__        return softDeletesPolicy.getMinRetainedSeqNo()__    };returns,the,minimum,seqno,that,is,retained,in,the,lucene,index,operations,whose,seq,are,at,least,this,value,should,exist,in,the,lucene,index;final,long,get,min,retained,seq,no,assert,soft,delete,enabled,thread,current,thread,get,name,return,soft,deletes,policy,get,min,retained,seq,no
InternalEngine -> final long getMinRetainedSeqNo();1544545090;Returns the minimum seqno that is retained in the Lucene index._Operations whose seq# are at least this value should exist in the Lucene index.;final long getMinRetainedSeqNo() {_        assert softDeleteEnabled : Thread.currentThread().getName()__        return softDeletesPolicy.getMinRetainedSeqNo()__    };returns,the,minimum,seqno,that,is,retained,in,the,lucene,index,operations,whose,seq,are,at,least,this,value,should,exist,in,the,lucene,index;final,long,get,min,retained,seq,no,assert,soft,delete,enabled,thread,current,thread,get,name,return,soft,deletes,policy,get,min,retained,seq,no
InternalEngine -> final long getMinRetainedSeqNo();1544684920;Returns the minimum seqno that is retained in the Lucene index._Operations whose seq# are at least this value should exist in the Lucene index.;final long getMinRetainedSeqNo() {_        assert softDeleteEnabled : Thread.currentThread().getName()__        return softDeletesPolicy.getMinRetainedSeqNo()__    };returns,the,minimum,seqno,that,is,retained,in,the,lucene,index,operations,whose,seq,are,at,least,this,value,should,exist,in,the,lucene,index;final,long,get,min,retained,seq,no,assert,soft,delete,enabled,thread,current,thread,get,name,return,soft,deletes,policy,get,min,retained,seq,no
InternalEngine -> final long getMinRetainedSeqNo();1545140118;Returns the minimum seqno that is retained in the Lucene index._Operations whose seq# are at least this value should exist in the Lucene index.;final long getMinRetainedSeqNo() {_        assert softDeleteEnabled : Thread.currentThread().getName()__        return softDeletesPolicy.getMinRetainedSeqNo()__    };returns,the,minimum,seqno,that,is,retained,in,the,lucene,index,operations,whose,seq,are,at,least,this,value,should,exist,in,the,lucene,index;final,long,get,min,retained,seq,no,assert,soft,delete,enabled,thread,current,thread,get,name,return,soft,deletes,policy,get,min,retained,seq,no
InternalEngine -> final long getMinRetainedSeqNo();1546875837;Returns the minimum seqno that is retained in the Lucene index._Operations whose seq# are at least this value should exist in the Lucene index.;final long getMinRetainedSeqNo() {_        assert softDeleteEnabled : Thread.currentThread().getName()__        return softDeletesPolicy.getMinRetainedSeqNo()__    };returns,the,minimum,seqno,that,is,retained,in,the,lucene,index,operations,whose,seq,are,at,least,this,value,should,exist,in,the,lucene,index;final,long,get,min,retained,seq,no,assert,soft,delete,enabled,thread,current,thread,get,name,return,soft,deletes,policy,get,min,retained,seq,no
InternalEngine -> final long getMinRetainedSeqNo();1547332999;Returns the minimum seqno that is retained in the Lucene index._Operations whose seq# are at least this value should exist in the Lucene index.;final long getMinRetainedSeqNo() {_        assert softDeleteEnabled : Thread.currentThread().getName()__        return softDeletesPolicy.getMinRetainedSeqNo()__    };returns,the,minimum,seqno,that,is,retained,in,the,lucene,index,operations,whose,seq,are,at,least,this,value,should,exist,in,the,lucene,index;final,long,get,min,retained,seq,no,assert,soft,delete,enabled,thread,current,thread,get,name,return,soft,deletes,policy,get,min,retained,seq,no
InternalEngine -> final long getMinRetainedSeqNo();1548771485;Returns the minimum seqno that is retained in the Lucene index._Operations whose seq# are at least this value should exist in the Lucene index.;final long getMinRetainedSeqNo() {_        assert softDeleteEnabled : Thread.currentThread().getName()__        return softDeletesPolicy.getMinRetainedSeqNo()__    };returns,the,minimum,seqno,that,is,retained,in,the,lucene,index,operations,whose,seq,are,at,least,this,value,should,exist,in,the,lucene,index;final,long,get,min,retained,seq,no,assert,soft,delete,enabled,thread,current,thread,get,name,return,soft,deletes,policy,get,min,retained,seq,no
InternalEngine -> final long getMinRetainedSeqNo();1549059559;Returns the minimum seqno that is retained in the Lucene index._Operations whose seq# are at least this value should exist in the Lucene index.;final long getMinRetainedSeqNo() {_        assert softDeleteEnabled : Thread.currentThread().getName()__        return softDeletesPolicy.getMinRetainedSeqNo()__    };returns,the,minimum,seqno,that,is,retained,in,the,lucene,index,operations,whose,seq,are,at,least,this,value,should,exist,in,the,lucene,index;final,long,get,min,retained,seq,no,assert,soft,delete,enabled,thread,current,thread,get,name,return,soft,deletes,policy,get,min,retained,seq,no
InternalEngine -> final long getMinRetainedSeqNo();1549663373;Returns the minimum seqno that is retained in the Lucene index._Operations whose seq# are at least this value should exist in the Lucene index.;final long getMinRetainedSeqNo() {_        assert softDeleteEnabled : Thread.currentThread().getName()__        return softDeletesPolicy.getMinRetainedSeqNo()__    };returns,the,minimum,seqno,that,is,retained,in,the,lucene,index,operations,whose,seq,are,at,least,this,value,should,exist,in,the,lucene,index;final,long,get,min,retained,seq,no,assert,soft,delete,enabled,thread,current,thread,get,name,return,soft,deletes,policy,get,min,retained,seq,no
InternalEngine -> protected long doGenerateSeqNoForOperation(final Operation operation);1524684173;Generate the sequence number for the specified operation.__@param operation the operation_@return the sequence number;protected long doGenerateSeqNoForOperation(final Operation operation) {_        return localCheckpointTracker.generateSeqNo()__    };generate,the,sequence,number,for,the,specified,operation,param,operation,the,operation,return,the,sequence,number;protected,long,do,generate,seq,no,for,operation,final,operation,operation,return,local,checkpoint,tracker,generate,seq,no
InternalEngine -> protected long doGenerateSeqNoForOperation(final Operation operation);1524780945;Generate the sequence number for the specified operation.__@param operation the operation_@return the sequence number;protected long doGenerateSeqNoForOperation(final Operation operation) {_        return localCheckpointTracker.generateSeqNo()__    };generate,the,sequence,number,for,the,specified,operation,param,operation,the,operation,return,the,sequence,number;protected,long,do,generate,seq,no,for,operation,final,operation,operation,return,local,checkpoint,tracker,generate,seq,no
InternalEngine -> protected long doGenerateSeqNoForOperation(final Operation operation);1525162917;Generate the sequence number for the specified operation.__@param operation the operation_@return the sequence number;protected long doGenerateSeqNoForOperation(final Operation operation) {_        return localCheckpointTracker.generateSeqNo()__    };generate,the,sequence,number,for,the,specified,operation,param,operation,the,operation,return,the,sequence,number;protected,long,do,generate,seq,no,for,operation,final,operation,operation,return,local,checkpoint,tracker,generate,seq,no
InternalEngine -> protected long doGenerateSeqNoForOperation(final Operation operation);1528706846;Generate the sequence number for the specified operation.__@param operation the operation_@return the sequence number;protected long doGenerateSeqNoForOperation(final Operation operation) {_        return localCheckpointTracker.generateSeqNo()__    };generate,the,sequence,number,for,the,specified,operation,param,operation,the,operation,return,the,sequence,number;protected,long,do,generate,seq,no,for,operation,final,operation,operation,return,local,checkpoint,tracker,generate,seq,no
InternalEngine -> protected long doGenerateSeqNoForOperation(final Operation operation);1528762805;Generate the sequence number for the specified operation.__@param operation the operation_@return the sequence number;protected long doGenerateSeqNoForOperation(final Operation operation) {_        return localCheckpointTracker.generateSeqNo()__    };generate,the,sequence,number,for,the,specified,operation,param,operation,the,operation,return,the,sequence,number;protected,long,do,generate,seq,no,for,operation,final,operation,operation,return,local,checkpoint,tracker,generate,seq,no
InternalEngine -> protected long doGenerateSeqNoForOperation(final Operation operation);1531910483;Generate the sequence number for the specified operation.__@param operation the operation_@return the sequence number;protected long doGenerateSeqNoForOperation(final Operation operation) {_        return localCheckpointTracker.generateSeqNo()__    };generate,the,sequence,number,for,the,specified,operation,param,operation,the,operation,return,the,sequence,number;protected,long,do,generate,seq,no,for,operation,final,operation,operation,return,local,checkpoint,tracker,generate,seq,no
InternalEngine -> protected long doGenerateSeqNoForOperation(final Operation operation);1533295538;Generate the sequence number for the specified operation.__@param operation the operation_@return the sequence number;protected long doGenerateSeqNoForOperation(final Operation operation) {_        return localCheckpointTracker.generateSeqNo()__    };generate,the,sequence,number,for,the,specified,operation,param,operation,the,operation,return,the,sequence,number;protected,long,do,generate,seq,no,for,operation,final,operation,operation,return,local,checkpoint,tracker,generate,seq,no
InternalEngine -> protected long doGenerateSeqNoForOperation(final Operation operation);1534848846;Generate the sequence number for the specified operation.__@param operation the operation_@return the sequence number;protected long doGenerateSeqNoForOperation(final Operation operation) {_        return localCheckpointTracker.generateSeqNo()__    };generate,the,sequence,number,for,the,specified,operation,param,operation,the,operation,return,the,sequence,number;protected,long,do,generate,seq,no,for,operation,final,operation,operation,return,local,checkpoint,tracker,generate,seq,no
InternalEngine -> protected long doGenerateSeqNoForOperation(final Operation operation);1535046779;Generate the sequence number for the specified operation.__@param operation the operation_@return the sequence number;protected long doGenerateSeqNoForOperation(final Operation operation) {_        return localCheckpointTracker.generateSeqNo()__    };generate,the,sequence,number,for,the,specified,operation,param,operation,the,operation,return,the,sequence,number;protected,long,do,generate,seq,no,for,operation,final,operation,operation,return,local,checkpoint,tracker,generate,seq,no
InternalEngine -> protected long doGenerateSeqNoForOperation(final Operation operation);1535405719;Generate the sequence number for the specified operation.__@param operation the operation_@return the sequence number;protected long doGenerateSeqNoForOperation(final Operation operation) {_        return localCheckpointTracker.generateSeqNo()__    };generate,the,sequence,number,for,the,specified,operation,param,operation,the,operation,return,the,sequence,number;protected,long,do,generate,seq,no,for,operation,final,operation,operation,return,local,checkpoint,tracker,generate,seq,no
InternalEngine -> protected long doGenerateSeqNoForOperation(final Operation operation);1535723122;Generate the sequence number for the specified operation.__@param operation the operation_@return the sequence number;protected long doGenerateSeqNoForOperation(final Operation operation) {_        return localCheckpointTracker.generateSeqNo()__    };generate,the,sequence,number,for,the,specified,operation,param,operation,the,operation,return,the,sequence,number;protected,long,do,generate,seq,no,for,operation,final,operation,operation,return,local,checkpoint,tracker,generate,seq,no
InternalEngine -> @Override     public long getWritingBytes();1524684173;Returns how many bytes we are currently moving from indexing buffer to segments on disk;@Override_    public long getWritingBytes() {_        return writingBytes.get()__    };returns,how,many,bytes,we,are,currently,moving,from,indexing,buffer,to,segments,on,disk;override,public,long,get,writing,bytes,return,writing,bytes,get
InternalEngine -> @Override     public long getWritingBytes();1524780945;Returns how many bytes we are currently moving from indexing buffer to segments on disk;@Override_    public long getWritingBytes() {_        return writingBytes.get()__    };returns,how,many,bytes,we,are,currently,moving,from,indexing,buffer,to,segments,on,disk;override,public,long,get,writing,bytes,return,writing,bytes,get
InternalEngine -> @Override     public long getWritingBytes();1525162917;Returns how many bytes we are currently moving from indexing buffer to segments on disk;@Override_    public long getWritingBytes() {_        return writingBytes.get()__    };returns,how,many,bytes,we,are,currently,moving,from,indexing,buffer,to,segments,on,disk;override,public,long,get,writing,bytes,return,writing,bytes,get
InternalEngine -> @Override     public long getWritingBytes();1528706846;Returns how many bytes we are currently moving from indexing buffer to segments on disk;@Override_    public long getWritingBytes() {_        return writingBytes.get()__    };returns,how,many,bytes,we,are,currently,moving,from,indexing,buffer,to,segments,on,disk;override,public,long,get,writing,bytes,return,writing,bytes,get
InternalEngine -> @Override     public long getWritingBytes();1528762805;Returns how many bytes we are currently moving from indexing buffer to segments on disk;@Override_    public long getWritingBytes() {_        return writingBytes.get()__    };returns,how,many,bytes,we,are,currently,moving,from,indexing,buffer,to,segments,on,disk;override,public,long,get,writing,bytes,return,writing,bytes,get
InternalEngine -> @Override     public long getWritingBytes();1531910483;Returns how many bytes we are currently moving from indexing buffer to segments on disk;@Override_    public long getWritingBytes() {_        return writingBytes.get()__    };returns,how,many,bytes,we,are,currently,moving,from,indexing,buffer,to,segments,on,disk;override,public,long,get,writing,bytes,return,writing,bytes,get
InternalEngine -> @Override     public long getWritingBytes();1533295538;Returns how many bytes we are currently moving from indexing buffer to segments on disk;@Override_    public long getWritingBytes() {_        return writingBytes.get()__    };returns,how,many,bytes,we,are,currently,moving,from,indexing,buffer,to,segments,on,disk;override,public,long,get,writing,bytes,return,writing,bytes,get
InternalEngine -> @Override     public long getWritingBytes();1534848846;Returns how many bytes we are currently moving from indexing buffer to segments on disk;@Override_    public long getWritingBytes() {_        return writingBytes.get()__    };returns,how,many,bytes,we,are,currently,moving,from,indexing,buffer,to,segments,on,disk;override,public,long,get,writing,bytes,return,writing,bytes,get
InternalEngine -> @Override     public long getWritingBytes();1535046779;Returns how many bytes we are currently moving from indexing buffer to segments on disk;@Override_    public long getWritingBytes() {_        return writingBytes.get()__    };returns,how,many,bytes,we,are,currently,moving,from,indexing,buffer,to,segments,on,disk;override,public,long,get,writing,bytes,return,writing,bytes,get
InternalEngine -> @Override     public long getWritingBytes();1535405719;Returns how many bytes we are currently moving from indexing buffer to segments on disk;@Override_    public long getWritingBytes() {_        return writingBytes.get()__    };returns,how,many,bytes,we,are,currently,moving,from,indexing,buffer,to,segments,on,disk;override,public,long,get,writing,bytes,return,writing,bytes,get
InternalEngine -> @Override     public long getWritingBytes();1535723122;Returns how many bytes we are currently moving from indexing buffer to segments on disk;@Override_    public long getWritingBytes() {_        return writingBytes.get()__    };returns,how,many,bytes,we,are,currently,moving,from,indexing,buffer,to,segments,on,disk;override,public,long,get,writing,bytes,return,writing,bytes,get
InternalEngine -> @Override     public long getWritingBytes();1535965276;Returns how many bytes we are currently moving from indexing buffer to segments on disk;@Override_    public long getWritingBytes() {_        return writingBytes.get()__    };returns,how,many,bytes,we,are,currently,moving,from,indexing,buffer,to,segments,on,disk;override,public,long,get,writing,bytes,return,writing,bytes,get
InternalEngine -> @Override     public long getWritingBytes();1536218260;Returns how many bytes we are currently moving from indexing buffer to segments on disk;@Override_    public long getWritingBytes() {_        return writingBytes.get()__    };returns,how,many,bytes,we,are,currently,moving,from,indexing,buffer,to,segments,on,disk;override,public,long,get,writing,bytes,return,writing,bytes,get
InternalEngine -> @Override     public long getWritingBytes();1536314350;Returns how many bytes we are currently moving from indexing buffer to segments on disk;@Override_    public long getWritingBytes() {_        return writingBytes.get()__    };returns,how,many,bytes,we,are,currently,moving,from,indexing,buffer,to,segments,on,disk;override,public,long,get,writing,bytes,return,writing,bytes,get
InternalEngine -> @Override     public long getWritingBytes();1536828374;Returns how many bytes we are currently moving from indexing buffer to segments on disk;@Override_    public long getWritingBytes() {_        return indexWriter.getFlushingBytes() + versionMap.getRefreshingBytes()__    };returns,how,many,bytes,we,are,currently,moving,from,indexing,buffer,to,segments,on,disk;override,public,long,get,writing,bytes,return,index,writer,get,flushing,bytes,version,map,get,refreshing,bytes
InternalEngine -> @Override     public long getWritingBytes();1537806831;Returns how many bytes we are currently moving from indexing buffer to segments on disk;@Override_    public long getWritingBytes() {_        return indexWriter.getFlushingBytes() + versionMap.getRefreshingBytes()__    };returns,how,many,bytes,we,are,currently,moving,from,indexing,buffer,to,segments,on,disk;override,public,long,get,writing,bytes,return,index,writer,get,flushing,bytes,version,map,get,refreshing,bytes
InternalEngine -> @Override     public long getWritingBytes();1538067637;Returns how many bytes we are currently moving from indexing buffer to segments on disk;@Override_    public long getWritingBytes() {_        return indexWriter.getFlushingBytes() + versionMap.getRefreshingBytes()__    };returns,how,many,bytes,we,are,currently,moving,from,indexing,buffer,to,segments,on,disk;override,public,long,get,writing,bytes,return,index,writer,get,flushing,bytes,version,map,get,refreshing,bytes
InternalEngine -> @Override     public long getWritingBytes();1538424609;Returns how many bytes we are currently moving from indexing buffer to segments on disk;@Override_    public long getWritingBytes() {_        return indexWriter.getFlushingBytes() + versionMap.getRefreshingBytes()__    };returns,how,many,bytes,we,are,currently,moving,from,indexing,buffer,to,segments,on,disk;override,public,long,get,writing,bytes,return,index,writer,get,flushing,bytes,version,map,get,refreshing,bytes
InternalEngine -> @Override     public long getWritingBytes();1539615817;Returns how many bytes we are currently moving from indexing buffer to segments on disk;@Override_    public long getWritingBytes() {_        return indexWriter.getFlushingBytes() + versionMap.getRefreshingBytes()__    };returns,how,many,bytes,we,are,currently,moving,from,indexing,buffer,to,segments,on,disk;override,public,long,get,writing,bytes,return,index,writer,get,flushing,bytes,version,map,get,refreshing,bytes
InternalEngine -> @Override     public long getWritingBytes();1539723533;Returns how many bytes we are currently moving from indexing buffer to segments on disk;@Override_    public long getWritingBytes() {_        return indexWriter.getFlushingBytes() + versionMap.getRefreshingBytes()__    };returns,how,many,bytes,we,are,currently,moving,from,indexing,buffer,to,segments,on,disk;override,public,long,get,writing,bytes,return,index,writer,get,flushing,bytes,version,map,get,refreshing,bytes
InternalEngine -> @Override     public long getWritingBytes();1540238977;Returns how many bytes we are currently moving from indexing buffer to segments on disk;@Override_    public long getWritingBytes() {_        return indexWriter.getFlushingBytes() + versionMap.getRefreshingBytes()__    };returns,how,many,bytes,we,are,currently,moving,from,indexing,buffer,to,segments,on,disk;override,public,long,get,writing,bytes,return,index,writer,get,flushing,bytes,version,map,get,refreshing,bytes
InternalEngine -> @Override     public long getWritingBytes();1541335413;Returns how many bytes we are currently moving from indexing buffer to segments on disk;@Override_    public long getWritingBytes() {_        return indexWriter.getFlushingBytes() + versionMap.getRefreshingBytes()__    };returns,how,many,bytes,we,are,currently,moving,from,indexing,buffer,to,segments,on,disk;override,public,long,get,writing,bytes,return,index,writer,get,flushing,bytes,version,map,get,refreshing,bytes
InternalEngine -> @Override     public long getWritingBytes();1541622390;Returns how many bytes we are currently moving from indexing buffer to segments on disk;@Override_    public long getWritingBytes() {_        return indexWriter.getFlushingBytes() + versionMap.getRefreshingBytes()__    };returns,how,many,bytes,we,are,currently,moving,from,indexing,buffer,to,segments,on,disk;override,public,long,get,writing,bytes,return,index,writer,get,flushing,bytes,version,map,get,refreshing,bytes
InternalEngine -> @Override     public long getWritingBytes();1542697754;Returns how many bytes we are currently moving from indexing buffer to segments on disk;@Override_    public long getWritingBytes() {_        return indexWriter.getFlushingBytes() + versionMap.getRefreshingBytes()__    };returns,how,many,bytes,we,are,currently,moving,from,indexing,buffer,to,segments,on,disk;override,public,long,get,writing,bytes,return,index,writer,get,flushing,bytes,version,map,get,refreshing,bytes
InternalEngine -> @Override     public long getWritingBytes();1543940134;Returns how many bytes we are currently moving from indexing buffer to segments on disk;@Override_    public long getWritingBytes() {_        return indexWriter.getFlushingBytes() + versionMap.getRefreshingBytes()__    };returns,how,many,bytes,we,are,currently,moving,from,indexing,buffer,to,segments,on,disk;override,public,long,get,writing,bytes,return,index,writer,get,flushing,bytes,version,map,get,refreshing,bytes
InternalEngine -> @Override     public long getWritingBytes();1544322276;Returns how many bytes we are currently moving from indexing buffer to segments on disk;@Override_    public long getWritingBytes() {_        return indexWriter.getFlushingBytes() + versionMap.getRefreshingBytes()__    };returns,how,many,bytes,we,are,currently,moving,from,indexing,buffer,to,segments,on,disk;override,public,long,get,writing,bytes,return,index,writer,get,flushing,bytes,version,map,get,refreshing,bytes
InternalEngine -> @Override     public long getWritingBytes();1544545090;Returns how many bytes we are currently moving from indexing buffer to segments on disk;@Override_    public long getWritingBytes() {_        return indexWriter.getFlushingBytes() + versionMap.getRefreshingBytes()__    };returns,how,many,bytes,we,are,currently,moving,from,indexing,buffer,to,segments,on,disk;override,public,long,get,writing,bytes,return,index,writer,get,flushing,bytes,version,map,get,refreshing,bytes
InternalEngine -> @Override     public long getWritingBytes();1544684920;Returns how many bytes we are currently moving from indexing buffer to segments on disk;@Override_    public long getWritingBytes() {_        return indexWriter.getFlushingBytes() + versionMap.getRefreshingBytes()__    };returns,how,many,bytes,we,are,currently,moving,from,indexing,buffer,to,segments,on,disk;override,public,long,get,writing,bytes,return,index,writer,get,flushing,bytes,version,map,get,refreshing,bytes
InternalEngine -> @Override     public long getWritingBytes();1545140118;Returns how many bytes we are currently moving from indexing buffer to segments on disk;@Override_    public long getWritingBytes() {_        return indexWriter.getFlushingBytes() + versionMap.getRefreshingBytes()__    };returns,how,many,bytes,we,are,currently,moving,from,indexing,buffer,to,segments,on,disk;override,public,long,get,writing,bytes,return,index,writer,get,flushing,bytes,version,map,get,refreshing,bytes
InternalEngine -> @Override     public long getWritingBytes();1546875837;Returns how many bytes we are currently moving from indexing buffer to segments on disk;@Override_    public long getWritingBytes() {_        return indexWriter.getFlushingBytes() + versionMap.getRefreshingBytes()__    };returns,how,many,bytes,we,are,currently,moving,from,indexing,buffer,to,segments,on,disk;override,public,long,get,writing,bytes,return,index,writer,get,flushing,bytes,version,map,get,refreshing,bytes
InternalEngine -> @Override     public long getWritingBytes();1547332999;Returns how many bytes we are currently moving from indexing buffer to segments on disk;@Override_    public long getWritingBytes() {_        return indexWriter.getFlushingBytes() + versionMap.getRefreshingBytes()__    };returns,how,many,bytes,we,are,currently,moving,from,indexing,buffer,to,segments,on,disk;override,public,long,get,writing,bytes,return,index,writer,get,flushing,bytes,version,map,get,refreshing,bytes
InternalEngine -> @Override     public long getWritingBytes();1548771485;Returns how many bytes we are currently moving from indexing buffer to segments on disk;@Override_    public long getWritingBytes() {_        return indexWriter.getFlushingBytes() + versionMap.getRefreshingBytes()__    };returns,how,many,bytes,we,are,currently,moving,from,indexing,buffer,to,segments,on,disk;override,public,long,get,writing,bytes,return,index,writer,get,flushing,bytes,version,map,get,refreshing,bytes
InternalEngine -> @Override     public long getWritingBytes();1549059559;Returns how many bytes we are currently moving from indexing buffer to segments on disk;@Override_    public long getWritingBytes() {_        return indexWriter.getFlushingBytes() + versionMap.getRefreshingBytes()__    };returns,how,many,bytes,we,are,currently,moving,from,indexing,buffer,to,segments,on,disk;override,public,long,get,writing,bytes,return,index,writer,get,flushing,bytes,version,map,get,refreshing,bytes
InternalEngine -> @Override     public long getWritingBytes();1549663373;Returns how many bytes we are currently moving from indexing buffer to segments on disk;@Override_    public long getWritingBytes() {_        return indexWriter.getFlushingBytes() + versionMap.getRefreshingBytes()__    };returns,how,many,bytes,we,are,currently,moving,from,indexing,buffer,to,segments,on,disk;override,public,long,get,writing,bytes,return,index,writer,get,flushing,bytes,version,map,get,refreshing,bytes
InternalEngine -> @Override     public long getWritingBytes();1549975032;Returns how many bytes we are currently moving from indexing buffer to segments on disk;@Override_    public long getWritingBytes() {_        return indexWriter.getFlushingBytes() + versionMap.getRefreshingBytes()__    };returns,how,many,bytes,we,are,currently,moving,from,indexing,buffer,to,segments,on,disk;override,public,long,get,writing,bytes,return,index,writer,get,flushing,bytes,version,map,get,refreshing,bytes
InternalEngine -> @Override     public long getWritingBytes();1550220204;Returns how many bytes we are currently moving from indexing buffer to segments on disk;@Override_    public long getWritingBytes() {_        return indexWriter.getFlushingBytes() + versionMap.getRefreshingBytes()__    };returns,how,many,bytes,we,are,currently,moving,from,indexing,buffer,to,segments,on,disk;override,public,long,get,writing,bytes,return,index,writer,get,flushing,bytes,version,map,get,refreshing,bytes
InternalEngine -> @Override     public long getWritingBytes();1550256122;Returns how many bytes we are currently moving from indexing buffer to segments on disk;@Override_    public long getWritingBytes() {_        return indexWriter.getFlushingBytes() + versionMap.getRefreshingBytes()__    };returns,how,many,bytes,we,are,currently,moving,from,indexing,buffer,to,segments,on,disk;override,public,long,get,writing,bytes,return,index,writer,get,flushing,bytes,version,map,get,refreshing,bytes
InternalEngine -> @Override     public long getWritingBytes();1550342051;Returns how many bytes we are currently moving from indexing buffer to segments on disk;@Override_    public long getWritingBytes() {_        return indexWriter.getFlushingBytes() + versionMap.getRefreshingBytes()__    };returns,how,many,bytes,we,are,currently,moving,from,indexing,buffer,to,segments,on,disk;override,public,long,get,writing,bytes,return,index,writer,get,flushing,bytes,version,map,get,refreshing,bytes
InternalEngine -> @Override     public long getWritingBytes();1550526771;Returns how many bytes we are currently moving from indexing buffer to segments on disk;@Override_    public long getWritingBytes() {_        return indexWriter.getFlushingBytes() + versionMap.getRefreshingBytes()__    };returns,how,many,bytes,we,are,currently,moving,from,indexing,buffer,to,segments,on,disk;override,public,long,get,writing,bytes,return,index,writer,get,flushing,bytes,version,map,get,refreshing,bytes
InternalEngine -> @Override     public long getWritingBytes();1551110274;Returns how many bytes we are currently moving from indexing buffer to segments on disk;@Override_    public long getWritingBytes() {_        return indexWriter.getFlushingBytes() + versionMap.getRefreshingBytes()__    };returns,how,many,bytes,we,are,currently,moving,from,indexing,buffer,to,segments,on,disk;override,public,long,get,writing,bytes,return,index,writer,get,flushing,bytes,version,map,get,refreshing,bytes
InternalEngine -> @Override     public long getWritingBytes();1551126708;Returns how many bytes we are currently moving from indexing buffer to segments on disk;@Override_    public long getWritingBytes() {_        return indexWriter.getFlushingBytes() + versionMap.getRefreshingBytes()__    };returns,how,many,bytes,we,are,currently,moving,from,indexing,buffer,to,segments,on,disk;override,public,long,get,writing,bytes,return,index,writer,get,flushing,bytes,version,map,get,refreshing,bytes
InternalEngine -> long getNumIndexVersionsLookups();1524684173;Returns the number of times a version was looked up either from the index._Note this is only available if assertions are enabled;long getNumIndexVersionsLookups() { _        return numIndexVersionsLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,index,versions,lookups,return,num,index,versions,lookups,count
InternalEngine -> long getNumIndexVersionsLookups();1524780945;Returns the number of times a version was looked up either from the index._Note this is only available if assertions are enabled;long getNumIndexVersionsLookups() { _        return numIndexVersionsLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,index,versions,lookups,return,num,index,versions,lookups,count
InternalEngine -> long getNumIndexVersionsLookups();1525162917;Returns the number of times a version was looked up either from the index._Note this is only available if assertions are enabled;long getNumIndexVersionsLookups() { _        return numIndexVersionsLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,index,versions,lookups,return,num,index,versions,lookups,count
InternalEngine -> long getNumIndexVersionsLookups();1528706846;Returns the number of times a version was looked up either from the index._Note this is only available if assertions are enabled;long getNumIndexVersionsLookups() { _        return numIndexVersionsLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,index,versions,lookups,return,num,index,versions,lookups,count
InternalEngine -> long getNumIndexVersionsLookups();1528762805;Returns the number of times a version was looked up either from the index._Note this is only available if assertions are enabled;long getNumIndexVersionsLookups() { _        return numIndexVersionsLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,index,versions,lookups,return,num,index,versions,lookups,count
InternalEngine -> long getNumIndexVersionsLookups();1531910483;Returns the number of times a version was looked up either from the index._Note this is only available if assertions are enabled;long getNumIndexVersionsLookups() { _        return numIndexVersionsLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,index,versions,lookups,return,num,index,versions,lookups,count
InternalEngine -> long getNumIndexVersionsLookups();1533295538;Returns the number of times a version was looked up either from the index._Note this is only available if assertions are enabled;long getNumIndexVersionsLookups() { _        return numIndexVersionsLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,index,versions,lookups,return,num,index,versions,lookups,count
InternalEngine -> long getNumIndexVersionsLookups();1534848846;Returns the number of times a version was looked up either from the index._Note this is only available if assertions are enabled;long getNumIndexVersionsLookups() { _        return numIndexVersionsLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,index,versions,lookups,return,num,index,versions,lookups,count
InternalEngine -> long getNumIndexVersionsLookups();1535046779;Returns the number of times a version was looked up either from the index._Note this is only available if assertions are enabled;long getNumIndexVersionsLookups() { _        return numIndexVersionsLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,index,versions,lookups,return,num,index,versions,lookups,count
InternalEngine -> long getNumIndexVersionsLookups();1535405719;Returns the number of times a version was looked up either from the index._Note this is only available if assertions are enabled;long getNumIndexVersionsLookups() { _        return numIndexVersionsLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,index,versions,lookups,return,num,index,versions,lookups,count
InternalEngine -> long getNumIndexVersionsLookups();1535723122;Returns the number of times a version was looked up either from the index._Note this is only available if assertions are enabled;long getNumIndexVersionsLookups() { _        return numIndexVersionsLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,index,versions,lookups,return,num,index,versions,lookups,count
InternalEngine -> long getNumIndexVersionsLookups();1535965276;Returns the number of times a version was looked up either from the index._Note this is only available if assertions are enabled;long getNumIndexVersionsLookups() { _        return numIndexVersionsLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,index,versions,lookups,return,num,index,versions,lookups,count
InternalEngine -> long getNumIndexVersionsLookups();1536218260;Returns the number of times a version was looked up either from the index._Note this is only available if assertions are enabled;long getNumIndexVersionsLookups() { _        return numIndexVersionsLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,index,versions,lookups,return,num,index,versions,lookups,count
InternalEngine -> long getNumIndexVersionsLookups();1536314350;Returns the number of times a version was looked up either from the index._Note this is only available if assertions are enabled;long getNumIndexVersionsLookups() { _        return numIndexVersionsLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,index,versions,lookups,return,num,index,versions,lookups,count
InternalEngine -> long getNumIndexVersionsLookups();1536828374;Returns the number of times a version was looked up either from the index._Note this is only available if assertions are enabled;long getNumIndexVersionsLookups() { _        return numIndexVersionsLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,index,versions,lookups,return,num,index,versions,lookups,count
InternalEngine -> long getNumIndexVersionsLookups();1537806831;Returns the number of times a version was looked up either from the index._Note this is only available if assertions are enabled;long getNumIndexVersionsLookups() { _        return numIndexVersionsLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,index,versions,lookups,return,num,index,versions,lookups,count
InternalEngine -> long getNumIndexVersionsLookups();1538067637;Returns the number of times a version was looked up either from the index._Note this is only available if assertions are enabled;long getNumIndexVersionsLookups() { _        return numIndexVersionsLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,index,versions,lookups,return,num,index,versions,lookups,count
InternalEngine -> long getNumIndexVersionsLookups();1538424609;Returns the number of times a version was looked up either from the index._Note this is only available if assertions are enabled;long getNumIndexVersionsLookups() { _        return numIndexVersionsLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,index,versions,lookups,return,num,index,versions,lookups,count
InternalEngine -> long getNumIndexVersionsLookups();1539615817;Returns the number of times a version was looked up either from the index._Note this is only available if assertions are enabled;long getNumIndexVersionsLookups() { _        return numIndexVersionsLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,index,versions,lookups,return,num,index,versions,lookups,count
InternalEngine -> long getNumIndexVersionsLookups();1539723533;Returns the number of times a version was looked up either from the index._Note this is only available if assertions are enabled;long getNumIndexVersionsLookups() { _        return numIndexVersionsLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,index,versions,lookups,return,num,index,versions,lookups,count
InternalEngine -> long getNumIndexVersionsLookups();1540238977;Returns the number of times a version was looked up either from the index._Note this is only available if assertions are enabled;long getNumIndexVersionsLookups() { _        return numIndexVersionsLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,index,versions,lookups,return,num,index,versions,lookups,count
InternalEngine -> long getNumIndexVersionsLookups();1541335413;Returns the number of times a version was looked up either from the index._Note this is only available if assertions are enabled;long getNumIndexVersionsLookups() { _        return numIndexVersionsLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,index,versions,lookups,return,num,index,versions,lookups,count
InternalEngine -> long getNumIndexVersionsLookups();1541622390;Returns the number of times a version was looked up either from the index._Note this is only available if assertions are enabled;long getNumIndexVersionsLookups() { _        return numIndexVersionsLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,index,versions,lookups,return,num,index,versions,lookups,count
InternalEngine -> long getNumIndexVersionsLookups();1542697754;Returns the number of times a version was looked up either from the index._Note this is only available if assertions are enabled;long getNumIndexVersionsLookups() { _        return numIndexVersionsLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,index,versions,lookups,return,num,index,versions,lookups,count
InternalEngine -> long getNumIndexVersionsLookups();1543940134;Returns the number of times a version was looked up either from the index._Note this is only available if assertions are enabled;long getNumIndexVersionsLookups() { _        return numIndexVersionsLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,index,versions,lookups,return,num,index,versions,lookups,count
InternalEngine -> long getNumIndexVersionsLookups();1544322276;Returns the number of times a version was looked up either from the index._Note this is only available if assertions are enabled;long getNumIndexVersionsLookups() { _        return numIndexVersionsLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,index,versions,lookups,return,num,index,versions,lookups,count
InternalEngine -> long getNumIndexVersionsLookups();1544545090;Returns the number of times a version was looked up either from the index._Note this is only available if assertions are enabled;long getNumIndexVersionsLookups() { _        return numIndexVersionsLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,index,versions,lookups,return,num,index,versions,lookups,count
InternalEngine -> long getNumIndexVersionsLookups();1544684920;Returns the number of times a version was looked up either from the index._Note this is only available if assertions are enabled;long getNumIndexVersionsLookups() { _        return numIndexVersionsLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,index,versions,lookups,return,num,index,versions,lookups,count
InternalEngine -> long getNumIndexVersionsLookups();1545140118;Returns the number of times a version was looked up either from the index._Note this is only available if assertions are enabled;long getNumIndexVersionsLookups() { _        return numIndexVersionsLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,index,versions,lookups,return,num,index,versions,lookups,count
InternalEngine -> long getNumIndexVersionsLookups();1546875837;Returns the number of times a version was looked up either from the index._Note this is only available if assertions are enabled;long getNumIndexVersionsLookups() { _        return numIndexVersionsLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,index,versions,lookups,return,num,index,versions,lookups,count
InternalEngine -> long getNumIndexVersionsLookups();1547332999;Returns the number of times a version was looked up either from the index._Note this is only available if assertions are enabled;long getNumIndexVersionsLookups() { _        return numIndexVersionsLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,index,versions,lookups,return,num,index,versions,lookups,count
InternalEngine -> long getNumIndexVersionsLookups();1548771485;Returns the number of times a version was looked up either from the index._Note this is only available if assertions are enabled;long getNumIndexVersionsLookups() { _        return numIndexVersionsLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,index,versions,lookups,return,num,index,versions,lookups,count
InternalEngine -> long getNumIndexVersionsLookups();1549059559;Returns the number of times a version was looked up either from the index._Note this is only available if assertions are enabled;long getNumIndexVersionsLookups() { _        return numIndexVersionsLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,index,versions,lookups,return,num,index,versions,lookups,count
InternalEngine -> long getNumIndexVersionsLookups();1549663373;Returns the number of times a version was looked up either from the index._Note this is only available if assertions are enabled;long getNumIndexVersionsLookups() { _        return numIndexVersionsLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,index,versions,lookups,return,num,index,versions,lookups,count
InternalEngine -> long getNumIndexVersionsLookups();1549975032;Returns the number of times a version was looked up either from the index._Note this is only available if assertions are enabled;long getNumIndexVersionsLookups() { _        return numIndexVersionsLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,index,versions,lookups,return,num,index,versions,lookups,count
InternalEngine -> long getNumIndexVersionsLookups();1550220204;Returns the number of times a version was looked up either from the index._Note this is only available if assertions are enabled;long getNumIndexVersionsLookups() { _        return numIndexVersionsLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,index,versions,lookups,return,num,index,versions,lookups,count
InternalEngine -> long getNumIndexVersionsLookups();1550256122;Returns the number of times a version was looked up either from the index._Note this is only available if assertions are enabled;long getNumIndexVersionsLookups() { _        return numIndexVersionsLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,index,versions,lookups,return,num,index,versions,lookups,count
InternalEngine -> long getNumIndexVersionsLookups();1550342051;Returns the number of times a version was looked up either from the index._Note this is only available if assertions are enabled;long getNumIndexVersionsLookups() { _        return numIndexVersionsLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,index,versions,lookups,return,num,index,versions,lookups,count
InternalEngine -> long getNumIndexVersionsLookups();1550526771;Returns the number of times a version was looked up either from the index._Note this is only available if assertions are enabled;long getNumIndexVersionsLookups() { _        return numIndexVersionsLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,index,versions,lookups,return,num,index,versions,lookups,count
InternalEngine -> long getNumIndexVersionsLookups();1551110274;Returns the number of times a version was looked up either from the index._Note this is only available if assertions are enabled;long getNumIndexVersionsLookups() { _        return numIndexVersionsLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,index,versions,lookups,return,num,index,versions,lookups,count
InternalEngine -> long getNumIndexVersionsLookups();1551126708;Returns the number of times a version was looked up either from the index._Note this is only available if assertions are enabled;long getNumIndexVersionsLookups() { _        return numIndexVersionsLookups.count()__    };returns,the,number,of,times,a,version,was,looked,up,either,from,the,index,note,this,is,only,available,if,assertions,are,enabled;long,get,num,index,versions,lookups,return,num,index,versions,lookups,count
InternalEngine -> long getNumDocDeletes();1524684173;Returns the number of documents have been deleted since this engine was opened._This count does not include the deletions from the existing segments before opening engine.;long getNumDocDeletes() {_        return numDocDeletes.count()__    };returns,the,number,of,documents,have,been,deleted,since,this,engine,was,opened,this,count,does,not,include,the,deletions,from,the,existing,segments,before,opening,engine;long,get,num,doc,deletes,return,num,doc,deletes,count
InternalEngine -> long getNumDocDeletes();1524780945;Returns the number of documents have been deleted since this engine was opened._This count does not include the deletions from the existing segments before opening engine.;long getNumDocDeletes() {_        return numDocDeletes.count()__    };returns,the,number,of,documents,have,been,deleted,since,this,engine,was,opened,this,count,does,not,include,the,deletions,from,the,existing,segments,before,opening,engine;long,get,num,doc,deletes,return,num,doc,deletes,count
InternalEngine -> long getNumDocDeletes();1525162917;Returns the number of documents have been deleted since this engine was opened._This count does not include the deletions from the existing segments before opening engine.;long getNumDocDeletes() {_        return numDocDeletes.count()__    };returns,the,number,of,documents,have,been,deleted,since,this,engine,was,opened,this,count,does,not,include,the,deletions,from,the,existing,segments,before,opening,engine;long,get,num,doc,deletes,return,num,doc,deletes,count
InternalEngine -> long getNumDocDeletes();1528706846;Returns the number of documents have been deleted since this engine was opened._This count does not include the deletions from the existing segments before opening engine.;long getNumDocDeletes() {_        return numDocDeletes.count()__    };returns,the,number,of,documents,have,been,deleted,since,this,engine,was,opened,this,count,does,not,include,the,deletions,from,the,existing,segments,before,opening,engine;long,get,num,doc,deletes,return,num,doc,deletes,count
InternalEngine -> long getNumDocDeletes();1528762805;Returns the number of documents have been deleted since this engine was opened._This count does not include the deletions from the existing segments before opening engine.;long getNumDocDeletes() {_        return numDocDeletes.count()__    };returns,the,number,of,documents,have,been,deleted,since,this,engine,was,opened,this,count,does,not,include,the,deletions,from,the,existing,segments,before,opening,engine;long,get,num,doc,deletes,return,num,doc,deletes,count
InternalEngine -> long getNumDocDeletes();1531910483;Returns the number of documents have been deleted since this engine was opened._This count does not include the deletions from the existing segments before opening engine.;long getNumDocDeletes() {_        return numDocDeletes.count()__    };returns,the,number,of,documents,have,been,deleted,since,this,engine,was,opened,this,count,does,not,include,the,deletions,from,the,existing,segments,before,opening,engine;long,get,num,doc,deletes,return,num,doc,deletes,count
InternalEngine -> long getNumDocDeletes();1533295538;Returns the number of documents have been deleted since this engine was opened._This count does not include the deletions from the existing segments before opening engine.;long getNumDocDeletes() {_        return numDocDeletes.count()__    };returns,the,number,of,documents,have,been,deleted,since,this,engine,was,opened,this,count,does,not,include,the,deletions,from,the,existing,segments,before,opening,engine;long,get,num,doc,deletes,return,num,doc,deletes,count
InternalEngine -> long getNumDocDeletes();1534848846;Returns the number of documents have been deleted since this engine was opened._This count does not include the deletions from the existing segments before opening engine.;long getNumDocDeletes() {_        return numDocDeletes.count()__    };returns,the,number,of,documents,have,been,deleted,since,this,engine,was,opened,this,count,does,not,include,the,deletions,from,the,existing,segments,before,opening,engine;long,get,num,doc,deletes,return,num,doc,deletes,count
InternalEngine -> long getNumDocDeletes();1535046779;Returns the number of documents have been deleted since this engine was opened._This count does not include the deletions from the existing segments before opening engine.;long getNumDocDeletes() {_        return numDocDeletes.count()__    };returns,the,number,of,documents,have,been,deleted,since,this,engine,was,opened,this,count,does,not,include,the,deletions,from,the,existing,segments,before,opening,engine;long,get,num,doc,deletes,return,num,doc,deletes,count
InternalEngine -> long getNumDocDeletes();1535405719;Returns the number of documents have been deleted since this engine was opened._This count does not include the deletions from the existing segments before opening engine.;long getNumDocDeletes() {_        return numDocDeletes.count()__    };returns,the,number,of,documents,have,been,deleted,since,this,engine,was,opened,this,count,does,not,include,the,deletions,from,the,existing,segments,before,opening,engine;long,get,num,doc,deletes,return,num,doc,deletes,count
InternalEngine -> long getNumDocDeletes();1535723122;Returns the number of documents have been deleted since this engine was opened._This count does not include the deletions from the existing segments before opening engine.;long getNumDocDeletes() {_        return numDocDeletes.count()__    };returns,the,number,of,documents,have,been,deleted,since,this,engine,was,opened,this,count,does,not,include,the,deletions,from,the,existing,segments,before,opening,engine;long,get,num,doc,deletes,return,num,doc,deletes,count
InternalEngine -> long getNumDocDeletes();1535965276;Returns the number of documents have been deleted since this engine was opened._This count does not include the deletions from the existing segments before opening engine.;long getNumDocDeletes() {_        return numDocDeletes.count()__    };returns,the,number,of,documents,have,been,deleted,since,this,engine,was,opened,this,count,does,not,include,the,deletions,from,the,existing,segments,before,opening,engine;long,get,num,doc,deletes,return,num,doc,deletes,count
InternalEngine -> long getNumDocDeletes();1536218260;Returns the number of documents have been deleted since this engine was opened._This count does not include the deletions from the existing segments before opening engine.;long getNumDocDeletes() {_        return numDocDeletes.count()__    };returns,the,number,of,documents,have,been,deleted,since,this,engine,was,opened,this,count,does,not,include,the,deletions,from,the,existing,segments,before,opening,engine;long,get,num,doc,deletes,return,num,doc,deletes,count
InternalEngine -> long getNumDocDeletes();1536314350;Returns the number of documents have been deleted since this engine was opened._This count does not include the deletions from the existing segments before opening engine.;long getNumDocDeletes() {_        return numDocDeletes.count()__    };returns,the,number,of,documents,have,been,deleted,since,this,engine,was,opened,this,count,does,not,include,the,deletions,from,the,existing,segments,before,opening,engine;long,get,num,doc,deletes,return,num,doc,deletes,count
InternalEngine -> long getNumDocDeletes();1536828374;Returns the number of documents have been deleted since this engine was opened._This count does not include the deletions from the existing segments before opening engine.;long getNumDocDeletes() {_        return numDocDeletes.count()__    };returns,the,number,of,documents,have,been,deleted,since,this,engine,was,opened,this,count,does,not,include,the,deletions,from,the,existing,segments,before,opening,engine;long,get,num,doc,deletes,return,num,doc,deletes,count
InternalEngine -> long getNumDocDeletes();1537806831;Returns the number of documents have been deleted since this engine was opened._This count does not include the deletions from the existing segments before opening engine.;long getNumDocDeletes() {_        return numDocDeletes.count()__    };returns,the,number,of,documents,have,been,deleted,since,this,engine,was,opened,this,count,does,not,include,the,deletions,from,the,existing,segments,before,opening,engine;long,get,num,doc,deletes,return,num,doc,deletes,count
InternalEngine -> long getNumDocDeletes();1538067637;Returns the number of documents have been deleted since this engine was opened._This count does not include the deletions from the existing segments before opening engine.;long getNumDocDeletes() {_        return numDocDeletes.count()__    };returns,the,number,of,documents,have,been,deleted,since,this,engine,was,opened,this,count,does,not,include,the,deletions,from,the,existing,segments,before,opening,engine;long,get,num,doc,deletes,return,num,doc,deletes,count
InternalEngine -> long getNumDocDeletes();1538424609;Returns the number of documents have been deleted since this engine was opened._This count does not include the deletions from the existing segments before opening engine.;long getNumDocDeletes() {_        return numDocDeletes.count()__    };returns,the,number,of,documents,have,been,deleted,since,this,engine,was,opened,this,count,does,not,include,the,deletions,from,the,existing,segments,before,opening,engine;long,get,num,doc,deletes,return,num,doc,deletes,count
InternalEngine -> long getNumDocDeletes();1539615817;Returns the number of documents have been deleted since this engine was opened._This count does not include the deletions from the existing segments before opening engine.;long getNumDocDeletes() {_        return numDocDeletes.count()__    };returns,the,number,of,documents,have,been,deleted,since,this,engine,was,opened,this,count,does,not,include,the,deletions,from,the,existing,segments,before,opening,engine;long,get,num,doc,deletes,return,num,doc,deletes,count
InternalEngine -> long getNumDocDeletes();1539723533;Returns the number of documents have been deleted since this engine was opened._This count does not include the deletions from the existing segments before opening engine.;long getNumDocDeletes() {_        return numDocDeletes.count()__    };returns,the,number,of,documents,have,been,deleted,since,this,engine,was,opened,this,count,does,not,include,the,deletions,from,the,existing,segments,before,opening,engine;long,get,num,doc,deletes,return,num,doc,deletes,count
InternalEngine -> long getNumDocDeletes();1540238977;Returns the number of documents have been deleted since this engine was opened._This count does not include the deletions from the existing segments before opening engine.;long getNumDocDeletes() {_        return numDocDeletes.count()__    };returns,the,number,of,documents,have,been,deleted,since,this,engine,was,opened,this,count,does,not,include,the,deletions,from,the,existing,segments,before,opening,engine;long,get,num,doc,deletes,return,num,doc,deletes,count
InternalEngine -> long getNumDocDeletes();1541335413;Returns the number of documents have been deleted since this engine was opened._This count does not include the deletions from the existing segments before opening engine.;long getNumDocDeletes() {_        return numDocDeletes.count()__    };returns,the,number,of,documents,have,been,deleted,since,this,engine,was,opened,this,count,does,not,include,the,deletions,from,the,existing,segments,before,opening,engine;long,get,num,doc,deletes,return,num,doc,deletes,count
InternalEngine -> long getNumDocDeletes();1541622390;Returns the number of documents have been deleted since this engine was opened._This count does not include the deletions from the existing segments before opening engine.;long getNumDocDeletes() {_        return numDocDeletes.count()__    };returns,the,number,of,documents,have,been,deleted,since,this,engine,was,opened,this,count,does,not,include,the,deletions,from,the,existing,segments,before,opening,engine;long,get,num,doc,deletes,return,num,doc,deletes,count
InternalEngine -> long getNumDocDeletes();1542697754;Returns the number of documents have been deleted since this engine was opened._This count does not include the deletions from the existing segments before opening engine.;long getNumDocDeletes() {_        return numDocDeletes.count()__    };returns,the,number,of,documents,have,been,deleted,since,this,engine,was,opened,this,count,does,not,include,the,deletions,from,the,existing,segments,before,opening,engine;long,get,num,doc,deletes,return,num,doc,deletes,count
InternalEngine -> long getNumDocDeletes();1543940134;Returns the number of documents have been deleted since this engine was opened._This count does not include the deletions from the existing segments before opening engine.;long getNumDocDeletes() {_        return numDocDeletes.count()__    };returns,the,number,of,documents,have,been,deleted,since,this,engine,was,opened,this,count,does,not,include,the,deletions,from,the,existing,segments,before,opening,engine;long,get,num,doc,deletes,return,num,doc,deletes,count
InternalEngine -> long getNumDocDeletes();1544322276;Returns the number of documents have been deleted since this engine was opened._This count does not include the deletions from the existing segments before opening engine.;long getNumDocDeletes() {_        return numDocDeletes.count()__    };returns,the,number,of,documents,have,been,deleted,since,this,engine,was,opened,this,count,does,not,include,the,deletions,from,the,existing,segments,before,opening,engine;long,get,num,doc,deletes,return,num,doc,deletes,count
InternalEngine -> long getNumDocDeletes();1544545090;Returns the number of documents have been deleted since this engine was opened._This count does not include the deletions from the existing segments before opening engine.;long getNumDocDeletes() {_        return numDocDeletes.count()__    };returns,the,number,of,documents,have,been,deleted,since,this,engine,was,opened,this,count,does,not,include,the,deletions,from,the,existing,segments,before,opening,engine;long,get,num,doc,deletes,return,num,doc,deletes,count
InternalEngine -> long getNumDocDeletes();1544684920;Returns the number of documents have been deleted since this engine was opened._This count does not include the deletions from the existing segments before opening engine.;long getNumDocDeletes() {_        return numDocDeletes.count()__    };returns,the,number,of,documents,have,been,deleted,since,this,engine,was,opened,this,count,does,not,include,the,deletions,from,the,existing,segments,before,opening,engine;long,get,num,doc,deletes,return,num,doc,deletes,count
InternalEngine -> long getNumDocDeletes();1545140118;Returns the number of documents have been deleted since this engine was opened._This count does not include the deletions from the existing segments before opening engine.;long getNumDocDeletes() {_        return numDocDeletes.count()__    };returns,the,number,of,documents,have,been,deleted,since,this,engine,was,opened,this,count,does,not,include,the,deletions,from,the,existing,segments,before,opening,engine;long,get,num,doc,deletes,return,num,doc,deletes,count
InternalEngine -> long getNumDocDeletes();1546875837;Returns the number of documents have been deleted since this engine was opened._This count does not include the deletions from the existing segments before opening engine.;long getNumDocDeletes() {_        return numDocDeletes.count()__    };returns,the,number,of,documents,have,been,deleted,since,this,engine,was,opened,this,count,does,not,include,the,deletions,from,the,existing,segments,before,opening,engine;long,get,num,doc,deletes,return,num,doc,deletes,count
InternalEngine -> long getNumDocDeletes();1547332999;Returns the number of documents have been deleted since this engine was opened._This count does not include the deletions from the existing segments before opening engine.;long getNumDocDeletes() {_        return numDocDeletes.count()__    };returns,the,number,of,documents,have,been,deleted,since,this,engine,was,opened,this,count,does,not,include,the,deletions,from,the,existing,segments,before,opening,engine;long,get,num,doc,deletes,return,num,doc,deletes,count
InternalEngine -> long getNumDocDeletes();1548771485;Returns the number of documents have been deleted since this engine was opened._This count does not include the deletions from the existing segments before opening engine.;long getNumDocDeletes() {_        return numDocDeletes.count()__    };returns,the,number,of,documents,have,been,deleted,since,this,engine,was,opened,this,count,does,not,include,the,deletions,from,the,existing,segments,before,opening,engine;long,get,num,doc,deletes,return,num,doc,deletes,count
InternalEngine -> long getNumDocDeletes();1549059559;Returns the number of documents have been deleted since this engine was opened._This count does not include the deletions from the existing segments before opening engine.;long getNumDocDeletes() {_        return numDocDeletes.count()__    };returns,the,number,of,documents,have,been,deleted,since,this,engine,was,opened,this,count,does,not,include,the,deletions,from,the,existing,segments,before,opening,engine;long,get,num,doc,deletes,return,num,doc,deletes,count
InternalEngine -> long getNumDocDeletes();1549663373;Returns the number of documents have been deleted since this engine was opened._This count does not include the deletions from the existing segments before opening engine.;long getNumDocDeletes() {_        return numDocDeletes.count()__    };returns,the,number,of,documents,have,been,deleted,since,this,engine,was,opened,this,count,does,not,include,the,deletions,from,the,existing,segments,before,opening,engine;long,get,num,doc,deletes,return,num,doc,deletes,count
InternalEngine -> long getNumDocDeletes();1549975032;Returns the number of documents have been deleted since this engine was opened._This count does not include the deletions from the existing segments before opening engine.;long getNumDocDeletes() {_        return numDocDeletes.count()__    };returns,the,number,of,documents,have,been,deleted,since,this,engine,was,opened,this,count,does,not,include,the,deletions,from,the,existing,segments,before,opening,engine;long,get,num,doc,deletes,return,num,doc,deletes,count
InternalEngine -> long getNumDocDeletes();1550220204;Returns the number of documents have been deleted since this engine was opened._This count does not include the deletions from the existing segments before opening engine.;long getNumDocDeletes() {_        return numDocDeletes.count()__    };returns,the,number,of,documents,have,been,deleted,since,this,engine,was,opened,this,count,does,not,include,the,deletions,from,the,existing,segments,before,opening,engine;long,get,num,doc,deletes,return,num,doc,deletes,count
InternalEngine -> long getNumDocDeletes();1550256122;Returns the number of documents have been deleted since this engine was opened._This count does not include the deletions from the existing segments before opening engine.;long getNumDocDeletes() {_        return numDocDeletes.count()__    };returns,the,number,of,documents,have,been,deleted,since,this,engine,was,opened,this,count,does,not,include,the,deletions,from,the,existing,segments,before,opening,engine;long,get,num,doc,deletes,return,num,doc,deletes,count
InternalEngine -> long getNumDocDeletes();1550342051;Returns the number of documents have been deleted since this engine was opened._This count does not include the deletions from the existing segments before opening engine.;long getNumDocDeletes() {_        return numDocDeletes.count()__    };returns,the,number,of,documents,have,been,deleted,since,this,engine,was,opened,this,count,does,not,include,the,deletions,from,the,existing,segments,before,opening,engine;long,get,num,doc,deletes,return,num,doc,deletes,count
InternalEngine -> long getNumDocDeletes();1550526771;Returns the number of documents have been deleted since this engine was opened._This count does not include the deletions from the existing segments before opening engine.;long getNumDocDeletes() {_        return numDocDeletes.count()__    };returns,the,number,of,documents,have,been,deleted,since,this,engine,was,opened,this,count,does,not,include,the,deletions,from,the,existing,segments,before,opening,engine;long,get,num,doc,deletes,return,num,doc,deletes,count
InternalEngine -> long getNumDocDeletes();1551110274;Returns the number of documents have been deleted since this engine was opened._This count does not include the deletions from the existing segments before opening engine.;long getNumDocDeletes() {_        return numDocDeletes.count()__    };returns,the,number,of,documents,have,been,deleted,since,this,engine,was,opened,this,count,does,not,include,the,deletions,from,the,existing,segments,before,opening,engine;long,get,num,doc,deletes,return,num,doc,deletes,count
InternalEngine -> long getNumDocDeletes();1551126708;Returns the number of documents have been deleted since this engine was opened._This count does not include the deletions from the existing segments before opening engine.;long getNumDocDeletes() {_        return numDocDeletes.count()__    };returns,the,number,of,documents,have,been,deleted,since,this,engine,was,opened,this,count,does,not,include,the,deletions,from,the,existing,segments,before,opening,engine;long,get,num,doc,deletes,return,num,doc,deletes,count
InternalEngine -> protected final void refreshIfNeeded(String source, long requestingSeqNo);1540238977;Refresh this engine **internally** iff the requesting seq_no is greater than the last refreshed checkpoint.;protected final void refreshIfNeeded(String source, long requestingSeqNo) {_        if (lastRefreshedCheckpoint() < requestingSeqNo) {_            refresh(source, SearcherScope.INTERNAL)__        }_    };refresh,this,engine,internally,iff,the,requesting,is,greater,than,the,last,refreshed,checkpoint;protected,final,void,refresh,if,needed,string,source,long,requesting,seq,no,if,last,refreshed,checkpoint,requesting,seq,no,refresh,source,searcher,scope,internal
InternalEngine -> protected final void refreshIfNeeded(String source, long requestingSeqNo);1541335413;Refresh this engine **internally** iff the requesting seq_no is greater than the last refreshed checkpoint.;protected final void refreshIfNeeded(String source, long requestingSeqNo) {_        if (lastRefreshedCheckpoint() < requestingSeqNo) {_            synchronized (refreshIfNeededMutex) {_                if (lastRefreshedCheckpoint() < requestingSeqNo) {_                    refresh(source, SearcherScope.INTERNAL)__                }_            }_        }_    };refresh,this,engine,internally,iff,the,requesting,is,greater,than,the,last,refreshed,checkpoint;protected,final,void,refresh,if,needed,string,source,long,requesting,seq,no,if,last,refreshed,checkpoint,requesting,seq,no,synchronized,refresh,if,needed,mutex,if,last,refreshed,checkpoint,requesting,seq,no,refresh,source,searcher,scope,internal
InternalEngine -> protected final void refreshIfNeeded(String source, long requestingSeqNo);1541622390;Refresh this engine **internally** iff the requesting seq_no is greater than the last refreshed checkpoint.;protected final void refreshIfNeeded(String source, long requestingSeqNo) {_        if (lastRefreshedCheckpoint() < requestingSeqNo) {_            synchronized (refreshIfNeededMutex) {_                if (lastRefreshedCheckpoint() < requestingSeqNo) {_                    refresh(source, SearcherScope.INTERNAL)__                }_            }_        }_    };refresh,this,engine,internally,iff,the,requesting,is,greater,than,the,last,refreshed,checkpoint;protected,final,void,refresh,if,needed,string,source,long,requesting,seq,no,if,last,refreshed,checkpoint,requesting,seq,no,synchronized,refresh,if,needed,mutex,if,last,refreshed,checkpoint,requesting,seq,no,refresh,source,searcher,scope,internal
InternalEngine -> protected final void refreshIfNeeded(String source, long requestingSeqNo);1542697754;Refresh this engine **internally** iff the requesting seq_no is greater than the last refreshed checkpoint.;protected final void refreshIfNeeded(String source, long requestingSeqNo) {_        if (lastRefreshedCheckpoint() < requestingSeqNo) {_            synchronized (refreshIfNeededMutex) {_                if (lastRefreshedCheckpoint() < requestingSeqNo) {_                    refresh(source, SearcherScope.INTERNAL)__                }_            }_        }_    };refresh,this,engine,internally,iff,the,requesting,is,greater,than,the,last,refreshed,checkpoint;protected,final,void,refresh,if,needed,string,source,long,requesting,seq,no,if,last,refreshed,checkpoint,requesting,seq,no,synchronized,refresh,if,needed,mutex,if,last,refreshed,checkpoint,requesting,seq,no,refresh,source,searcher,scope,internal
InternalEngine -> protected final void refreshIfNeeded(String source, long requestingSeqNo);1543940134;Refresh this engine **internally** iff the requesting seq_no is greater than the last refreshed checkpoint.;protected final void refreshIfNeeded(String source, long requestingSeqNo) {_        if (lastRefreshedCheckpoint() < requestingSeqNo) {_            synchronized (refreshIfNeededMutex) {_                if (lastRefreshedCheckpoint() < requestingSeqNo) {_                    refresh(source, SearcherScope.INTERNAL)__                }_            }_        }_    };refresh,this,engine,internally,iff,the,requesting,is,greater,than,the,last,refreshed,checkpoint;protected,final,void,refresh,if,needed,string,source,long,requesting,seq,no,if,last,refreshed,checkpoint,requesting,seq,no,synchronized,refresh,if,needed,mutex,if,last,refreshed,checkpoint,requesting,seq,no,refresh,source,searcher,scope,internal
InternalEngine -> protected final void refreshIfNeeded(String source, long requestingSeqNo);1544322276;Refresh this engine **internally** iff the requesting seq_no is greater than the last refreshed checkpoint.;protected final void refreshIfNeeded(String source, long requestingSeqNo) {_        if (lastRefreshedCheckpoint() < requestingSeqNo) {_            synchronized (refreshIfNeededMutex) {_                if (lastRefreshedCheckpoint() < requestingSeqNo) {_                    refresh(source, SearcherScope.INTERNAL)__                }_            }_        }_    };refresh,this,engine,internally,iff,the,requesting,is,greater,than,the,last,refreshed,checkpoint;protected,final,void,refresh,if,needed,string,source,long,requesting,seq,no,if,last,refreshed,checkpoint,requesting,seq,no,synchronized,refresh,if,needed,mutex,if,last,refreshed,checkpoint,requesting,seq,no,refresh,source,searcher,scope,internal
InternalEngine -> protected final void refreshIfNeeded(String source, long requestingSeqNo);1544545090;Refresh this engine **internally** iff the requesting seq_no is greater than the last refreshed checkpoint.;protected final void refreshIfNeeded(String source, long requestingSeqNo) {_        if (lastRefreshedCheckpoint() < requestingSeqNo) {_            synchronized (refreshIfNeededMutex) {_                if (lastRefreshedCheckpoint() < requestingSeqNo) {_                    refresh(source, SearcherScope.INTERNAL)__                }_            }_        }_    };refresh,this,engine,internally,iff,the,requesting,is,greater,than,the,last,refreshed,checkpoint;protected,final,void,refresh,if,needed,string,source,long,requesting,seq,no,if,last,refreshed,checkpoint,requesting,seq,no,synchronized,refresh,if,needed,mutex,if,last,refreshed,checkpoint,requesting,seq,no,refresh,source,searcher,scope,internal
InternalEngine -> protected final void refreshIfNeeded(String source, long requestingSeqNo);1544684920;Refresh this engine **internally** iff the requesting seq_no is greater than the last refreshed checkpoint.;protected final void refreshIfNeeded(String source, long requestingSeqNo) {_        if (lastRefreshedCheckpoint() < requestingSeqNo) {_            synchronized (refreshIfNeededMutex) {_                if (lastRefreshedCheckpoint() < requestingSeqNo) {_                    refresh(source, SearcherScope.INTERNAL)__                }_            }_        }_    };refresh,this,engine,internally,iff,the,requesting,is,greater,than,the,last,refreshed,checkpoint;protected,final,void,refresh,if,needed,string,source,long,requesting,seq,no,if,last,refreshed,checkpoint,requesting,seq,no,synchronized,refresh,if,needed,mutex,if,last,refreshed,checkpoint,requesting,seq,no,refresh,source,searcher,scope,internal
InternalEngine -> protected final void refreshIfNeeded(String source, long requestingSeqNo);1545140118;Refresh this engine **internally** iff the requesting seq_no is greater than the last refreshed checkpoint.;protected final void refreshIfNeeded(String source, long requestingSeqNo) {_        if (lastRefreshedCheckpoint() < requestingSeqNo) {_            synchronized (refreshIfNeededMutex) {_                if (lastRefreshedCheckpoint() < requestingSeqNo) {_                    refresh(source, SearcherScope.INTERNAL)__                }_            }_        }_    };refresh,this,engine,internally,iff,the,requesting,is,greater,than,the,last,refreshed,checkpoint;protected,final,void,refresh,if,needed,string,source,long,requesting,seq,no,if,last,refreshed,checkpoint,requesting,seq,no,synchronized,refresh,if,needed,mutex,if,last,refreshed,checkpoint,requesting,seq,no,refresh,source,searcher,scope,internal
InternalEngine -> protected final void refreshIfNeeded(String source, long requestingSeqNo);1546875837;Refresh this engine **internally** iff the requesting seq_no is greater than the last refreshed checkpoint.;protected final void refreshIfNeeded(String source, long requestingSeqNo) {_        if (lastRefreshedCheckpoint() < requestingSeqNo) {_            synchronized (refreshIfNeededMutex) {_                if (lastRefreshedCheckpoint() < requestingSeqNo) {_                    refresh(source, SearcherScope.INTERNAL)__                }_            }_        }_    };refresh,this,engine,internally,iff,the,requesting,is,greater,than,the,last,refreshed,checkpoint;protected,final,void,refresh,if,needed,string,source,long,requesting,seq,no,if,last,refreshed,checkpoint,requesting,seq,no,synchronized,refresh,if,needed,mutex,if,last,refreshed,checkpoint,requesting,seq,no,refresh,source,searcher,scope,internal
InternalEngine -> protected final void refreshIfNeeded(String source, long requestingSeqNo);1547332999;Refresh this engine **internally** iff the requesting seq_no is greater than the last refreshed checkpoint.;protected final void refreshIfNeeded(String source, long requestingSeqNo) {_        if (lastRefreshedCheckpoint() < requestingSeqNo) {_            synchronized (refreshIfNeededMutex) {_                if (lastRefreshedCheckpoint() < requestingSeqNo) {_                    refresh(source, SearcherScope.INTERNAL)__                }_            }_        }_    };refresh,this,engine,internally,iff,the,requesting,is,greater,than,the,last,refreshed,checkpoint;protected,final,void,refresh,if,needed,string,source,long,requesting,seq,no,if,last,refreshed,checkpoint,requesting,seq,no,synchronized,refresh,if,needed,mutex,if,last,refreshed,checkpoint,requesting,seq,no,refresh,source,searcher,scope,internal
InternalEngine -> protected final void refreshIfNeeded(String source, long requestingSeqNo);1548771485;Refresh this engine **internally** iff the requesting seq_no is greater than the last refreshed checkpoint.;protected final void refreshIfNeeded(String source, long requestingSeqNo) {_        if (lastRefreshedCheckpoint() < requestingSeqNo) {_            synchronized (refreshIfNeededMutex) {_                if (lastRefreshedCheckpoint() < requestingSeqNo) {_                    refresh(source, SearcherScope.INTERNAL)__                }_            }_        }_    };refresh,this,engine,internally,iff,the,requesting,is,greater,than,the,last,refreshed,checkpoint;protected,final,void,refresh,if,needed,string,source,long,requesting,seq,no,if,last,refreshed,checkpoint,requesting,seq,no,synchronized,refresh,if,needed,mutex,if,last,refreshed,checkpoint,requesting,seq,no,refresh,source,searcher,scope,internal
InternalEngine -> protected final void refreshIfNeeded(String source, long requestingSeqNo);1549059559;Refresh this engine **internally** iff the requesting seq_no is greater than the last refreshed checkpoint.;protected final void refreshIfNeeded(String source, long requestingSeqNo) {_        if (lastRefreshedCheckpoint() < requestingSeqNo) {_            synchronized (refreshIfNeededMutex) {_                if (lastRefreshedCheckpoint() < requestingSeqNo) {_                    refresh(source, SearcherScope.INTERNAL)__                }_            }_        }_    };refresh,this,engine,internally,iff,the,requesting,is,greater,than,the,last,refreshed,checkpoint;protected,final,void,refresh,if,needed,string,source,long,requesting,seq,no,if,last,refreshed,checkpoint,requesting,seq,no,synchronized,refresh,if,needed,mutex,if,last,refreshed,checkpoint,requesting,seq,no,refresh,source,searcher,scope,internal
InternalEngine -> protected final void refreshIfNeeded(String source, long requestingSeqNo);1549663373;Refresh this engine **internally** iff the requesting seq_no is greater than the last refreshed checkpoint.;protected final void refreshIfNeeded(String source, long requestingSeqNo) {_        if (lastRefreshedCheckpoint() < requestingSeqNo) {_            synchronized (refreshIfNeededMutex) {_                if (lastRefreshedCheckpoint() < requestingSeqNo) {_                    refresh(source, SearcherScope.INTERNAL)__                }_            }_        }_    };refresh,this,engine,internally,iff,the,requesting,is,greater,than,the,last,refreshed,checkpoint;protected,final,void,refresh,if,needed,string,source,long,requesting,seq,no,if,last,refreshed,checkpoint,requesting,seq,no,synchronized,refresh,if,needed,mutex,if,last,refreshed,checkpoint,requesting,seq,no,refresh,source,searcher,scope,internal
InternalEngine -> protected final void refreshIfNeeded(String source, long requestingSeqNo);1549975032;Refresh this engine **internally** iff the requesting seq_no is greater than the last refreshed checkpoint.;protected final void refreshIfNeeded(String source, long requestingSeqNo) {_        if (lastRefreshedCheckpoint() < requestingSeqNo) {_            synchronized (refreshIfNeededMutex) {_                if (lastRefreshedCheckpoint() < requestingSeqNo) {_                    refresh(source, SearcherScope.INTERNAL)__                }_            }_        }_    };refresh,this,engine,internally,iff,the,requesting,is,greater,than,the,last,refreshed,checkpoint;protected,final,void,refresh,if,needed,string,source,long,requesting,seq,no,if,last,refreshed,checkpoint,requesting,seq,no,synchronized,refresh,if,needed,mutex,if,last,refreshed,checkpoint,requesting,seq,no,refresh,source,searcher,scope,internal
InternalEngine -> protected final void refreshIfNeeded(String source, long requestingSeqNo);1550220204;Refresh this engine **internally** iff the requesting seq_no is greater than the last refreshed checkpoint.;protected final void refreshIfNeeded(String source, long requestingSeqNo) {_        if (lastRefreshedCheckpoint() < requestingSeqNo) {_            synchronized (refreshIfNeededMutex) {_                if (lastRefreshedCheckpoint() < requestingSeqNo) {_                    refresh(source, SearcherScope.INTERNAL)__                }_            }_        }_    };refresh,this,engine,internally,iff,the,requesting,is,greater,than,the,last,refreshed,checkpoint;protected,final,void,refresh,if,needed,string,source,long,requesting,seq,no,if,last,refreshed,checkpoint,requesting,seq,no,synchronized,refresh,if,needed,mutex,if,last,refreshed,checkpoint,requesting,seq,no,refresh,source,searcher,scope,internal
InternalEngine -> protected final void refreshIfNeeded(String source, long requestingSeqNo);1550256122;Refresh this engine **internally** iff the requesting seq_no is greater than the last refreshed checkpoint.;protected final void refreshIfNeeded(String source, long requestingSeqNo) {_        if (lastRefreshedCheckpoint() < requestingSeqNo) {_            synchronized (refreshIfNeededMutex) {_                if (lastRefreshedCheckpoint() < requestingSeqNo) {_                    refresh(source, SearcherScope.INTERNAL)__                }_            }_        }_    };refresh,this,engine,internally,iff,the,requesting,is,greater,than,the,last,refreshed,checkpoint;protected,final,void,refresh,if,needed,string,source,long,requesting,seq,no,if,last,refreshed,checkpoint,requesting,seq,no,synchronized,refresh,if,needed,mutex,if,last,refreshed,checkpoint,requesting,seq,no,refresh,source,searcher,scope,internal
InternalEngine -> protected final void refreshIfNeeded(String source, long requestingSeqNo);1550342051;Refresh this engine **internally** iff the requesting seq_no is greater than the last refreshed checkpoint.;protected final void refreshIfNeeded(String source, long requestingSeqNo) {_        if (lastRefreshedCheckpoint() < requestingSeqNo) {_            synchronized (refreshIfNeededMutex) {_                if (lastRefreshedCheckpoint() < requestingSeqNo) {_                    refresh(source, SearcherScope.INTERNAL)__                }_            }_        }_    };refresh,this,engine,internally,iff,the,requesting,is,greater,than,the,last,refreshed,checkpoint;protected,final,void,refresh,if,needed,string,source,long,requesting,seq,no,if,last,refreshed,checkpoint,requesting,seq,no,synchronized,refresh,if,needed,mutex,if,last,refreshed,checkpoint,requesting,seq,no,refresh,source,searcher,scope,internal
InternalEngine -> protected final void refreshIfNeeded(String source, long requestingSeqNo);1550526771;Refresh this engine **internally** iff the requesting seq_no is greater than the last refreshed checkpoint.;protected final void refreshIfNeeded(String source, long requestingSeqNo) {_        if (lastRefreshedCheckpoint() < requestingSeqNo) {_            synchronized (refreshIfNeededMutex) {_                if (lastRefreshedCheckpoint() < requestingSeqNo) {_                    refresh(source, SearcherScope.INTERNAL)__                }_            }_        }_    };refresh,this,engine,internally,iff,the,requesting,is,greater,than,the,last,refreshed,checkpoint;protected,final,void,refresh,if,needed,string,source,long,requesting,seq,no,if,last,refreshed,checkpoint,requesting,seq,no,synchronized,refresh,if,needed,mutex,if,last,refreshed,checkpoint,requesting,seq,no,refresh,source,searcher,scope,internal
InternalEngine -> protected final void refreshIfNeeded(String source, long requestingSeqNo);1551110274;Refresh this engine **internally** iff the requesting seq_no is greater than the last refreshed checkpoint.;protected final void refreshIfNeeded(String source, long requestingSeqNo) {_        if (lastRefreshedCheckpoint() < requestingSeqNo) {_            synchronized (refreshIfNeededMutex) {_                if (lastRefreshedCheckpoint() < requestingSeqNo) {_                    refresh(source, SearcherScope.INTERNAL)__                }_            }_        }_    };refresh,this,engine,internally,iff,the,requesting,is,greater,than,the,last,refreshed,checkpoint;protected,final,void,refresh,if,needed,string,source,long,requesting,seq,no,if,last,refreshed,checkpoint,requesting,seq,no,synchronized,refresh,if,needed,mutex,if,last,refreshed,checkpoint,requesting,seq,no,refresh,source,searcher,scope,internal
InternalEngine -> protected final void refreshIfNeeded(String source, long requestingSeqNo);1551126708;Refresh this engine **internally** iff the requesting seq_no is greater than the last refreshed checkpoint.;protected final void refreshIfNeeded(String source, long requestingSeqNo) {_        if (lastRefreshedCheckpoint() < requestingSeqNo) {_            synchronized (refreshIfNeededMutex) {_                if (lastRefreshedCheckpoint() < requestingSeqNo) {_                    refresh(source, SearcherScope.INTERNAL)__                }_            }_        }_    };refresh,this,engine,internally,iff,the,requesting,is,greater,than,the,last,refreshed,checkpoint;protected,final,void,refresh,if,needed,string,source,long,requesting,seq,no,if,last,refreshed,checkpoint,requesting,seq,no,synchronized,refresh,if,needed,mutex,if,last,refreshed,checkpoint,requesting,seq,no,refresh,source,searcher,scope,internal
InternalEngine -> @Override     public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1535723122;Returns the estimated number of history operations whose seq# at least the provided seq# in this engine.;@Override_    public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        if (engineConfig.getIndexSettings().isSoftDeleteEnabled()) {_            try (Translog.Snapshot snapshot = newChangesSnapshot(source, mapperService, Math.max(0, startingSeqNo), Long.MAX_VALUE, false)) {_                return snapshot.totalOperations()__            }_        } else {_            return getTranslog().estimateTotalOperationsFromMinSeq(startingSeqNo)__        }_    };returns,the,estimated,number,of,history,operations,whose,seq,at,least,the,provided,seq,in,this,engine;override,public,int,estimate,number,of,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,if,engine,config,get,index,settings,is,soft,delete,enabled,try,translog,snapshot,snapshot,new,changes,snapshot,source,mapper,service,math,max,0,starting,seq,no,long,false,return,snapshot,total,operations,else,return,get,translog,estimate,total,operations,from,min,seq,starting,seq,no
InternalEngine -> @Override     public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1535965276;Returns the estimated number of history operations whose seq# at least the provided seq# in this engine.;@Override_    public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        if (engineConfig.getIndexSettings().isSoftDeleteEnabled()) {_            try (Translog.Snapshot snapshot = newChangesSnapshot(source, mapperService, Math.max(0, startingSeqNo), Long.MAX_VALUE, false)) {_                return snapshot.totalOperations()__            }_        } else {_            return getTranslog().estimateTotalOperationsFromMinSeq(startingSeqNo)__        }_    };returns,the,estimated,number,of,history,operations,whose,seq,at,least,the,provided,seq,in,this,engine;override,public,int,estimate,number,of,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,if,engine,config,get,index,settings,is,soft,delete,enabled,try,translog,snapshot,snapshot,new,changes,snapshot,source,mapper,service,math,max,0,starting,seq,no,long,false,return,snapshot,total,operations,else,return,get,translog,estimate,total,operations,from,min,seq,starting,seq,no
InternalEngine -> @Override     public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1536218260;Returns the estimated number of history operations whose seq# at least the provided seq# in this engine.;@Override_    public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        if (engineConfig.getIndexSettings().isSoftDeleteEnabled()) {_            try (Translog.Snapshot snapshot = newChangesSnapshot(source, mapperService, Math.max(0, startingSeqNo), Long.MAX_VALUE, false)) {_                return snapshot.totalOperations()__            }_        } else {_            return getTranslog().estimateTotalOperationsFromMinSeq(startingSeqNo)__        }_    };returns,the,estimated,number,of,history,operations,whose,seq,at,least,the,provided,seq,in,this,engine;override,public,int,estimate,number,of,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,if,engine,config,get,index,settings,is,soft,delete,enabled,try,translog,snapshot,snapshot,new,changes,snapshot,source,mapper,service,math,max,0,starting,seq,no,long,false,return,snapshot,total,operations,else,return,get,translog,estimate,total,operations,from,min,seq,starting,seq,no
InternalEngine -> @Override     public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1536314350;Returns the estimated number of history operations whose seq# at least the provided seq# in this engine.;@Override_    public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        if (engineConfig.getIndexSettings().isSoftDeleteEnabled()) {_            try (Translog.Snapshot snapshot = newChangesSnapshot(source, mapperService, Math.max(0, startingSeqNo), Long.MAX_VALUE, false)) {_                return snapshot.totalOperations()__            }_        } else {_            return getTranslog().estimateTotalOperationsFromMinSeq(startingSeqNo)__        }_    };returns,the,estimated,number,of,history,operations,whose,seq,at,least,the,provided,seq,in,this,engine;override,public,int,estimate,number,of,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,if,engine,config,get,index,settings,is,soft,delete,enabled,try,translog,snapshot,snapshot,new,changes,snapshot,source,mapper,service,math,max,0,starting,seq,no,long,false,return,snapshot,total,operations,else,return,get,translog,estimate,total,operations,from,min,seq,starting,seq,no
InternalEngine -> @Override     public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1536828374;Returns the estimated number of history operations whose seq# at least the provided seq# in this engine.;@Override_    public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        if (engineConfig.getIndexSettings().isSoftDeleteEnabled()) {_            try (Translog.Snapshot snapshot = newChangesSnapshot(source, mapperService, Math.max(0, startingSeqNo), Long.MAX_VALUE, false)) {_                return snapshot.totalOperations()__            }_        } else {_            return getTranslog().estimateTotalOperationsFromMinSeq(startingSeqNo)__        }_    };returns,the,estimated,number,of,history,operations,whose,seq,at,least,the,provided,seq,in,this,engine;override,public,int,estimate,number,of,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,if,engine,config,get,index,settings,is,soft,delete,enabled,try,translog,snapshot,snapshot,new,changes,snapshot,source,mapper,service,math,max,0,starting,seq,no,long,false,return,snapshot,total,operations,else,return,get,translog,estimate,total,operations,from,min,seq,starting,seq,no
InternalEngine -> @Override     public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1537806831;Returns the estimated number of history operations whose seq# at least the provided seq# in this engine.;@Override_    public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        if (engineConfig.getIndexSettings().isSoftDeleteEnabled()) {_            try (Translog.Snapshot snapshot = newChangesSnapshot(source, mapperService, Math.max(0, startingSeqNo), Long.MAX_VALUE, false)) {_                return snapshot.totalOperations()__            }_        } else {_            return getTranslog().estimateTotalOperationsFromMinSeq(startingSeqNo)__        }_    };returns,the,estimated,number,of,history,operations,whose,seq,at,least,the,provided,seq,in,this,engine;override,public,int,estimate,number,of,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,if,engine,config,get,index,settings,is,soft,delete,enabled,try,translog,snapshot,snapshot,new,changes,snapshot,source,mapper,service,math,max,0,starting,seq,no,long,false,return,snapshot,total,operations,else,return,get,translog,estimate,total,operations,from,min,seq,starting,seq,no
InternalEngine -> @Override     public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1538067637;Returns the estimated number of history operations whose seq# at least the provided seq# in this engine.;@Override_    public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        if (engineConfig.getIndexSettings().isSoftDeleteEnabled()) {_            try (Translog.Snapshot snapshot = newChangesSnapshot(source, mapperService, Math.max(0, startingSeqNo), Long.MAX_VALUE, false)) {_                return snapshot.totalOperations()__            }_        } else {_            return getTranslog().estimateTotalOperationsFromMinSeq(startingSeqNo)__        }_    };returns,the,estimated,number,of,history,operations,whose,seq,at,least,the,provided,seq,in,this,engine;override,public,int,estimate,number,of,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,if,engine,config,get,index,settings,is,soft,delete,enabled,try,translog,snapshot,snapshot,new,changes,snapshot,source,mapper,service,math,max,0,starting,seq,no,long,false,return,snapshot,total,operations,else,return,get,translog,estimate,total,operations,from,min,seq,starting,seq,no
InternalEngine -> @Override     public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1538424609;Returns the estimated number of history operations whose seq# at least the provided seq# in this engine.;@Override_    public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        if (engineConfig.getIndexSettings().isSoftDeleteEnabled()) {_            try (Translog.Snapshot snapshot = newChangesSnapshot(source, mapperService, Math.max(0, startingSeqNo), Long.MAX_VALUE, false)) {_                return snapshot.totalOperations()__            }_        } else {_            return getTranslog().estimateTotalOperationsFromMinSeq(startingSeqNo)__        }_    };returns,the,estimated,number,of,history,operations,whose,seq,at,least,the,provided,seq,in,this,engine;override,public,int,estimate,number,of,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,if,engine,config,get,index,settings,is,soft,delete,enabled,try,translog,snapshot,snapshot,new,changes,snapshot,source,mapper,service,math,max,0,starting,seq,no,long,false,return,snapshot,total,operations,else,return,get,translog,estimate,total,operations,from,min,seq,starting,seq,no
InternalEngine -> @Override     public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1539615817;Returns the estimated number of history operations whose seq# at least the provided seq# in this engine.;@Override_    public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        if (engineConfig.getIndexSettings().isSoftDeleteEnabled()) {_            try (Translog.Snapshot snapshot = newChangesSnapshot(source, mapperService, Math.max(0, startingSeqNo), Long.MAX_VALUE, false)) {_                return snapshot.totalOperations()__            }_        } else {_            return getTranslog().estimateTotalOperationsFromMinSeq(startingSeqNo)__        }_    };returns,the,estimated,number,of,history,operations,whose,seq,at,least,the,provided,seq,in,this,engine;override,public,int,estimate,number,of,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,if,engine,config,get,index,settings,is,soft,delete,enabled,try,translog,snapshot,snapshot,new,changes,snapshot,source,mapper,service,math,max,0,starting,seq,no,long,false,return,snapshot,total,operations,else,return,get,translog,estimate,total,operations,from,min,seq,starting,seq,no
InternalEngine -> @Override     public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1539723533;Returns the estimated number of history operations whose seq# at least the provided seq# in this engine.;@Override_    public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        if (engineConfig.getIndexSettings().isSoftDeleteEnabled()) {_            try (Translog.Snapshot snapshot = newChangesSnapshot(source, mapperService, Math.max(0, startingSeqNo), Long.MAX_VALUE, false)) {_                return snapshot.totalOperations()__            }_        } else {_            return getTranslog().estimateTotalOperationsFromMinSeq(startingSeqNo)__        }_    };returns,the,estimated,number,of,history,operations,whose,seq,at,least,the,provided,seq,in,this,engine;override,public,int,estimate,number,of,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,if,engine,config,get,index,settings,is,soft,delete,enabled,try,translog,snapshot,snapshot,new,changes,snapshot,source,mapper,service,math,max,0,starting,seq,no,long,false,return,snapshot,total,operations,else,return,get,translog,estimate,total,operations,from,min,seq,starting,seq,no
InternalEngine -> @Override     public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1540238977;Returns the estimated number of history operations whose seq# at least the provided seq# in this engine.;@Override_    public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        if (engineConfig.getIndexSettings().isSoftDeleteEnabled()) {_            try (Translog.Snapshot snapshot = newChangesSnapshot(source, mapperService, Math.max(0, startingSeqNo), Long.MAX_VALUE, false)) {_                return snapshot.totalOperations()__            }_        } else {_            return getTranslog().estimateTotalOperationsFromMinSeq(startingSeqNo)__        }_    };returns,the,estimated,number,of,history,operations,whose,seq,at,least,the,provided,seq,in,this,engine;override,public,int,estimate,number,of,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,if,engine,config,get,index,settings,is,soft,delete,enabled,try,translog,snapshot,snapshot,new,changes,snapshot,source,mapper,service,math,max,0,starting,seq,no,long,false,return,snapshot,total,operations,else,return,get,translog,estimate,total,operations,from,min,seq,starting,seq,no
InternalEngine -> @Override     public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1541335413;Returns the estimated number of history operations whose seq# at least the provided seq# in this engine.;@Override_    public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        if (engineConfig.getIndexSettings().isSoftDeleteEnabled()) {_            try (Translog.Snapshot snapshot = newChangesSnapshot(source, mapperService, Math.max(0, startingSeqNo), Long.MAX_VALUE, false)) {_                return snapshot.totalOperations()__            }_        } else {_            return getTranslog().estimateTotalOperationsFromMinSeq(startingSeqNo)__        }_    };returns,the,estimated,number,of,history,operations,whose,seq,at,least,the,provided,seq,in,this,engine;override,public,int,estimate,number,of,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,if,engine,config,get,index,settings,is,soft,delete,enabled,try,translog,snapshot,snapshot,new,changes,snapshot,source,mapper,service,math,max,0,starting,seq,no,long,false,return,snapshot,total,operations,else,return,get,translog,estimate,total,operations,from,min,seq,starting,seq,no
InternalEngine -> @Override     public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1541622390;Returns the estimated number of history operations whose seq# at least the provided seq# in this engine.;@Override_    public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        if (engineConfig.getIndexSettings().isSoftDeleteEnabled()) {_            try (Translog.Snapshot snapshot = newChangesSnapshot(source, mapperService, Math.max(0, startingSeqNo), Long.MAX_VALUE, false)) {_                return snapshot.totalOperations()__            }_        } else {_            return getTranslog().estimateTotalOperationsFromMinSeq(startingSeqNo)__        }_    };returns,the,estimated,number,of,history,operations,whose,seq,at,least,the,provided,seq,in,this,engine;override,public,int,estimate,number,of,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,if,engine,config,get,index,settings,is,soft,delete,enabled,try,translog,snapshot,snapshot,new,changes,snapshot,source,mapper,service,math,max,0,starting,seq,no,long,false,return,snapshot,total,operations,else,return,get,translog,estimate,total,operations,from,min,seq,starting,seq,no
InternalEngine -> @Override     public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1542697754;Returns the estimated number of history operations whose seq# at least the provided seq# in this engine.;@Override_    public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        if (engineConfig.getIndexSettings().isSoftDeleteEnabled()) {_            try (Translog.Snapshot snapshot = newChangesSnapshot(source, mapperService, Math.max(0, startingSeqNo),_                Long.MAX_VALUE, false)) {_                return snapshot.totalOperations()__            }_        } else {_            return getTranslog().estimateTotalOperationsFromMinSeq(startingSeqNo)__        }_    };returns,the,estimated,number,of,history,operations,whose,seq,at,least,the,provided,seq,in,this,engine;override,public,int,estimate,number,of,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,if,engine,config,get,index,settings,is,soft,delete,enabled,try,translog,snapshot,snapshot,new,changes,snapshot,source,mapper,service,math,max,0,starting,seq,no,long,false,return,snapshot,total,operations,else,return,get,translog,estimate,total,operations,from,min,seq,starting,seq,no
InternalEngine -> @Override     public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1543940134;Returns the estimated number of history operations whose seq# at least the provided seq# in this engine.;@Override_    public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        if (engineConfig.getIndexSettings().isSoftDeleteEnabled()) {_            try (Translog.Snapshot snapshot = newChangesSnapshot(source, mapperService, Math.max(0, startingSeqNo),_                Long.MAX_VALUE, false)) {_                return snapshot.totalOperations()__            }_        } else {_            return getTranslog().estimateTotalOperationsFromMinSeq(startingSeqNo)__        }_    };returns,the,estimated,number,of,history,operations,whose,seq,at,least,the,provided,seq,in,this,engine;override,public,int,estimate,number,of,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,if,engine,config,get,index,settings,is,soft,delete,enabled,try,translog,snapshot,snapshot,new,changes,snapshot,source,mapper,service,math,max,0,starting,seq,no,long,false,return,snapshot,total,operations,else,return,get,translog,estimate,total,operations,from,min,seq,starting,seq,no
InternalEngine -> @Override     public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1544322276;Returns the estimated number of history operations whose seq# at least the provided seq# in this engine.;@Override_    public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        if (engineConfig.getIndexSettings().isSoftDeleteEnabled()) {_            try (Translog.Snapshot snapshot = newChangesSnapshot(source, mapperService, Math.max(0, startingSeqNo),_                Long.MAX_VALUE, false)) {_                return snapshot.totalOperations()__            }_        } else {_            return getTranslog().estimateTotalOperationsFromMinSeq(startingSeqNo)__        }_    };returns,the,estimated,number,of,history,operations,whose,seq,at,least,the,provided,seq,in,this,engine;override,public,int,estimate,number,of,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,if,engine,config,get,index,settings,is,soft,delete,enabled,try,translog,snapshot,snapshot,new,changes,snapshot,source,mapper,service,math,max,0,starting,seq,no,long,false,return,snapshot,total,operations,else,return,get,translog,estimate,total,operations,from,min,seq,starting,seq,no
InternalEngine -> @Override     public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1544545090;Returns the estimated number of history operations whose seq# at least the provided seq# in this engine.;@Override_    public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        if (engineConfig.getIndexSettings().isSoftDeleteEnabled()) {_            try (Translog.Snapshot snapshot = newChangesSnapshot(source, mapperService, Math.max(0, startingSeqNo),_                Long.MAX_VALUE, false)) {_                return snapshot.totalOperations()__            }_        } else {_            return getTranslog().estimateTotalOperationsFromMinSeq(startingSeqNo)__        }_    };returns,the,estimated,number,of,history,operations,whose,seq,at,least,the,provided,seq,in,this,engine;override,public,int,estimate,number,of,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,if,engine,config,get,index,settings,is,soft,delete,enabled,try,translog,snapshot,snapshot,new,changes,snapshot,source,mapper,service,math,max,0,starting,seq,no,long,false,return,snapshot,total,operations,else,return,get,translog,estimate,total,operations,from,min,seq,starting,seq,no
InternalEngine -> @Override     public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1544684920;Returns the estimated number of history operations whose seq# at least the provided seq# in this engine.;@Override_    public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        if (engineConfig.getIndexSettings().isSoftDeleteEnabled()) {_            try (Translog.Snapshot snapshot = newChangesSnapshot(source, mapperService, Math.max(0, startingSeqNo),_                Long.MAX_VALUE, false)) {_                return snapshot.totalOperations()__            }_        } else {_            return getTranslog().estimateTotalOperationsFromMinSeq(startingSeqNo)__        }_    };returns,the,estimated,number,of,history,operations,whose,seq,at,least,the,provided,seq,in,this,engine;override,public,int,estimate,number,of,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,if,engine,config,get,index,settings,is,soft,delete,enabled,try,translog,snapshot,snapshot,new,changes,snapshot,source,mapper,service,math,max,0,starting,seq,no,long,false,return,snapshot,total,operations,else,return,get,translog,estimate,total,operations,from,min,seq,starting,seq,no
InternalEngine -> @Override     public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1545140118;Returns the estimated number of history operations whose seq# at least the provided seq# in this engine.;@Override_    public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        if (engineConfig.getIndexSettings().isSoftDeleteEnabled()) {_            try (Translog.Snapshot snapshot = newChangesSnapshot(source, mapperService, Math.max(0, startingSeqNo),_                Long.MAX_VALUE, false)) {_                return snapshot.totalOperations()__            }_        } else {_            return getTranslog().estimateTotalOperationsFromMinSeq(startingSeqNo)__        }_    };returns,the,estimated,number,of,history,operations,whose,seq,at,least,the,provided,seq,in,this,engine;override,public,int,estimate,number,of,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,if,engine,config,get,index,settings,is,soft,delete,enabled,try,translog,snapshot,snapshot,new,changes,snapshot,source,mapper,service,math,max,0,starting,seq,no,long,false,return,snapshot,total,operations,else,return,get,translog,estimate,total,operations,from,min,seq,starting,seq,no
InternalEngine -> @Override     public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1546875837;Returns the estimated number of history operations whose seq# at least the provided seq# in this engine.;@Override_    public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        if (engineConfig.getIndexSettings().isSoftDeleteEnabled()) {_            try (Translog.Snapshot snapshot = newChangesSnapshot(source, mapperService, Math.max(0, startingSeqNo),_                Long.MAX_VALUE, false)) {_                return snapshot.totalOperations()__            }_        } else {_            return getTranslog().estimateTotalOperationsFromMinSeq(startingSeqNo)__        }_    };returns,the,estimated,number,of,history,operations,whose,seq,at,least,the,provided,seq,in,this,engine;override,public,int,estimate,number,of,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,if,engine,config,get,index,settings,is,soft,delete,enabled,try,translog,snapshot,snapshot,new,changes,snapshot,source,mapper,service,math,max,0,starting,seq,no,long,false,return,snapshot,total,operations,else,return,get,translog,estimate,total,operations,from,min,seq,starting,seq,no
InternalEngine -> @Override     public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1547332999;Returns the estimated number of history operations whose seq# at least the provided seq# in this engine.;@Override_    public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        if (engineConfig.getIndexSettings().isSoftDeleteEnabled()) {_            try (Translog.Snapshot snapshot = newChangesSnapshot(source, mapperService, Math.max(0, startingSeqNo),_                Long.MAX_VALUE, false)) {_                return snapshot.totalOperations()__            }_        } else {_            return getTranslog().estimateTotalOperationsFromMinSeq(startingSeqNo)__        }_    };returns,the,estimated,number,of,history,operations,whose,seq,at,least,the,provided,seq,in,this,engine;override,public,int,estimate,number,of,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,if,engine,config,get,index,settings,is,soft,delete,enabled,try,translog,snapshot,snapshot,new,changes,snapshot,source,mapper,service,math,max,0,starting,seq,no,long,false,return,snapshot,total,operations,else,return,get,translog,estimate,total,operations,from,min,seq,starting,seq,no
InternalEngine -> @Override     public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1548771485;Returns the estimated number of history operations whose seq# at least the provided seq# in this engine.;@Override_    public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        if (engineConfig.getIndexSettings().isSoftDeleteEnabled()) {_            try (Translog.Snapshot snapshot = newChangesSnapshot(source, mapperService, Math.max(0, startingSeqNo),_                Long.MAX_VALUE, false)) {_                return snapshot.totalOperations()__            }_        } else {_            return getTranslog().estimateTotalOperationsFromMinSeq(startingSeqNo)__        }_    };returns,the,estimated,number,of,history,operations,whose,seq,at,least,the,provided,seq,in,this,engine;override,public,int,estimate,number,of,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,if,engine,config,get,index,settings,is,soft,delete,enabled,try,translog,snapshot,snapshot,new,changes,snapshot,source,mapper,service,math,max,0,starting,seq,no,long,false,return,snapshot,total,operations,else,return,get,translog,estimate,total,operations,from,min,seq,starting,seq,no
InternalEngine -> @Override     public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1549059559;Returns the estimated number of history operations whose seq# at least the provided seq# in this engine.;@Override_    public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        if (engineConfig.getIndexSettings().isSoftDeleteEnabled()) {_            try (Translog.Snapshot snapshot = newChangesSnapshot(source, mapperService, Math.max(0, startingSeqNo),_                Long.MAX_VALUE, false)) {_                return snapshot.totalOperations()__            }_        } else {_            return getTranslog().estimateTotalOperationsFromMinSeq(startingSeqNo)__        }_    };returns,the,estimated,number,of,history,operations,whose,seq,at,least,the,provided,seq,in,this,engine;override,public,int,estimate,number,of,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,if,engine,config,get,index,settings,is,soft,delete,enabled,try,translog,snapshot,snapshot,new,changes,snapshot,source,mapper,service,math,max,0,starting,seq,no,long,false,return,snapshot,total,operations,else,return,get,translog,estimate,total,operations,from,min,seq,starting,seq,no
InternalEngine -> @Override     public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1549663373;Returns the estimated number of history operations whose seq# at least the provided seq# in this engine.;@Override_    public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        if (engineConfig.getIndexSettings().isSoftDeleteEnabled()) {_            try (Translog.Snapshot snapshot = newChangesSnapshot(source, mapperService, Math.max(0, startingSeqNo),_                Long.MAX_VALUE, false)) {_                return snapshot.totalOperations()__            }_        } else {_            return getTranslog().estimateTotalOperationsFromMinSeq(startingSeqNo)__        }_    };returns,the,estimated,number,of,history,operations,whose,seq,at,least,the,provided,seq,in,this,engine;override,public,int,estimate,number,of,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,if,engine,config,get,index,settings,is,soft,delete,enabled,try,translog,snapshot,snapshot,new,changes,snapshot,source,mapper,service,math,max,0,starting,seq,no,long,false,return,snapshot,total,operations,else,return,get,translog,estimate,total,operations,from,min,seq,starting,seq,no
InternalEngine -> @Override     public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1549975032;Returns the estimated number of history operations whose seq# at least the provided seq# in this engine.;@Override_    public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        if (engineConfig.getIndexSettings().isSoftDeleteEnabled()) {_            try (Translog.Snapshot snapshot = newChangesSnapshot(source, mapperService, Math.max(0, startingSeqNo),_                Long.MAX_VALUE, false)) {_                return snapshot.totalOperations()__            }_        } else {_            return getTranslog().estimateTotalOperationsFromMinSeq(startingSeqNo)__        }_    };returns,the,estimated,number,of,history,operations,whose,seq,at,least,the,provided,seq,in,this,engine;override,public,int,estimate,number,of,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,if,engine,config,get,index,settings,is,soft,delete,enabled,try,translog,snapshot,snapshot,new,changes,snapshot,source,mapper,service,math,max,0,starting,seq,no,long,false,return,snapshot,total,operations,else,return,get,translog,estimate,total,operations,from,min,seq,starting,seq,no
InternalEngine -> @Override     public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1550220204;Returns the estimated number of history operations whose seq# at least the provided seq# in this engine.;@Override_    public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        if (engineConfig.getIndexSettings().isSoftDeleteEnabled()) {_            try (Translog.Snapshot snapshot = newChangesSnapshot(source, mapperService, Math.max(0, startingSeqNo),_                Long.MAX_VALUE, false)) {_                return snapshot.totalOperations()__            }_        } else {_            return getTranslog().estimateTotalOperationsFromMinSeq(startingSeqNo)__        }_    };returns,the,estimated,number,of,history,operations,whose,seq,at,least,the,provided,seq,in,this,engine;override,public,int,estimate,number,of,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,if,engine,config,get,index,settings,is,soft,delete,enabled,try,translog,snapshot,snapshot,new,changes,snapshot,source,mapper,service,math,max,0,starting,seq,no,long,false,return,snapshot,total,operations,else,return,get,translog,estimate,total,operations,from,min,seq,starting,seq,no
InternalEngine -> @Override     public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1550256122;Returns the estimated number of history operations whose seq# at least the provided seq# in this engine.;@Override_    public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        if (engineConfig.getIndexSettings().isSoftDeleteEnabled()) {_            try (Translog.Snapshot snapshot = newChangesSnapshot(source, mapperService, Math.max(0, startingSeqNo),_                Long.MAX_VALUE, false)) {_                return snapshot.totalOperations()__            }_        } else {_            return getTranslog().estimateTotalOperationsFromMinSeq(startingSeqNo)__        }_    };returns,the,estimated,number,of,history,operations,whose,seq,at,least,the,provided,seq,in,this,engine;override,public,int,estimate,number,of,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,if,engine,config,get,index,settings,is,soft,delete,enabled,try,translog,snapshot,snapshot,new,changes,snapshot,source,mapper,service,math,max,0,starting,seq,no,long,false,return,snapshot,total,operations,else,return,get,translog,estimate,total,operations,from,min,seq,starting,seq,no
InternalEngine -> @Override     public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1550342051;Returns the estimated number of history operations whose seq# at least the provided seq# in this engine.;@Override_    public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        if (engineConfig.getIndexSettings().isSoftDeleteEnabled()) {_            try (Translog.Snapshot snapshot = newChangesSnapshot(source, mapperService, Math.max(0, startingSeqNo),_                Long.MAX_VALUE, false)) {_                return snapshot.totalOperations()__            }_        } else {_            return getTranslog().estimateTotalOperationsFromMinSeq(startingSeqNo)__        }_    };returns,the,estimated,number,of,history,operations,whose,seq,at,least,the,provided,seq,in,this,engine;override,public,int,estimate,number,of,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,if,engine,config,get,index,settings,is,soft,delete,enabled,try,translog,snapshot,snapshot,new,changes,snapshot,source,mapper,service,math,max,0,starting,seq,no,long,false,return,snapshot,total,operations,else,return,get,translog,estimate,total,operations,from,min,seq,starting,seq,no
InternalEngine -> @Override     public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1550526771;Returns the estimated number of history operations whose seq# at least the provided seq# in this engine.;@Override_    public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        if (engineConfig.getIndexSettings().isSoftDeleteEnabled()) {_            try (Translog.Snapshot snapshot = newChangesSnapshot(source, mapperService, Math.max(0, startingSeqNo),_                Long.MAX_VALUE, false)) {_                return snapshot.totalOperations()__            }_        } else {_            return getTranslog().estimateTotalOperationsFromMinSeq(startingSeqNo)__        }_    };returns,the,estimated,number,of,history,operations,whose,seq,at,least,the,provided,seq,in,this,engine;override,public,int,estimate,number,of,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,if,engine,config,get,index,settings,is,soft,delete,enabled,try,translog,snapshot,snapshot,new,changes,snapshot,source,mapper,service,math,max,0,starting,seq,no,long,false,return,snapshot,total,operations,else,return,get,translog,estimate,total,operations,from,min,seq,starting,seq,no
InternalEngine -> @Override     public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1551110274;Returns the estimated number of history operations whose seq# at least the provided seq# in this engine.;@Override_    public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        if (engineConfig.getIndexSettings().isSoftDeleteEnabled()) {_            try (Translog.Snapshot snapshot = newChangesSnapshot(source, mapperService, Math.max(0, startingSeqNo),_                Long.MAX_VALUE, false)) {_                return snapshot.totalOperations()__            }_        } else {_            return getTranslog().estimateTotalOperationsFromMinSeq(startingSeqNo)__        }_    };returns,the,estimated,number,of,history,operations,whose,seq,at,least,the,provided,seq,in,this,engine;override,public,int,estimate,number,of,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,if,engine,config,get,index,settings,is,soft,delete,enabled,try,translog,snapshot,snapshot,new,changes,snapshot,source,mapper,service,math,max,0,starting,seq,no,long,false,return,snapshot,total,operations,else,return,get,translog,estimate,total,operations,from,min,seq,starting,seq,no
InternalEngine -> @Override     public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1551126708;Returns the estimated number of history operations whose seq# at least the provided seq# in this engine.;@Override_    public int estimateNumberOfHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        if (engineConfig.getIndexSettings().isSoftDeleteEnabled()) {_            try (Translog.Snapshot snapshot = newChangesSnapshot(source, mapperService, Math.max(0, startingSeqNo),_                Long.MAX_VALUE, false)) {_                return snapshot.totalOperations()__            }_        } else {_            return getTranslog().estimateTotalOperationsFromMinSeq(startingSeqNo)__        }_    };returns,the,estimated,number,of,history,operations,whose,seq,at,least,the,provided,seq,in,this,engine;override,public,int,estimate,number,of,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,if,engine,config,get,index,settings,is,soft,delete,enabled,try,translog,snapshot,snapshot,new,changes,snapshot,source,mapper,service,math,max,0,starting,seq,no,long,false,return,snapshot,total,operations,else,return,get,translog,estimate,total,operations,from,min,seq,starting,seq,no
InternalEngine -> @Override     public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1535723122;Creates a new history snapshot for reading operations since the provided seqno._The returned snapshot can be retrieved from either Lucene index or translog files.;@Override_    public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        if (engineConfig.getIndexSettings().isSoftDeleteEnabled()) {_            return newChangesSnapshot(source, mapperService, Math.max(0, startingSeqNo), Long.MAX_VALUE, false)__        } else {_            return getTranslog().newSnapshotFromMinSeqNo(startingSeqNo)__        }_    };creates,a,new,history,snapshot,for,reading,operations,since,the,provided,seqno,the,returned,snapshot,can,be,retrieved,from,either,lucene,index,or,translog,files;override,public,translog,snapshot,read,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,if,engine,config,get,index,settings,is,soft,delete,enabled,return,new,changes,snapshot,source,mapper,service,math,max,0,starting,seq,no,long,false,else,return,get,translog,new,snapshot,from,min,seq,no,starting,seq,no
InternalEngine -> @Override     public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1535965276;Creates a new history snapshot for reading operations since the provided seqno._The returned snapshot can be retrieved from either Lucene index or translog files.;@Override_    public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        if (engineConfig.getIndexSettings().isSoftDeleteEnabled()) {_            return newChangesSnapshot(source, mapperService, Math.max(0, startingSeqNo), Long.MAX_VALUE, false)__        } else {_            return getTranslog().newSnapshotFromMinSeqNo(startingSeqNo)__        }_    };creates,a,new,history,snapshot,for,reading,operations,since,the,provided,seqno,the,returned,snapshot,can,be,retrieved,from,either,lucene,index,or,translog,files;override,public,translog,snapshot,read,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,if,engine,config,get,index,settings,is,soft,delete,enabled,return,new,changes,snapshot,source,mapper,service,math,max,0,starting,seq,no,long,false,else,return,get,translog,new,snapshot,from,min,seq,no,starting,seq,no
InternalEngine -> @Override     public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1536218260;Creates a new history snapshot for reading operations since the provided seqno._The returned snapshot can be retrieved from either Lucene index or translog files.;@Override_    public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        if (engineConfig.getIndexSettings().isSoftDeleteEnabled()) {_            return newChangesSnapshot(source, mapperService, Math.max(0, startingSeqNo), Long.MAX_VALUE, false)__        } else {_            return getTranslog().newSnapshotFromMinSeqNo(startingSeqNo)__        }_    };creates,a,new,history,snapshot,for,reading,operations,since,the,provided,seqno,the,returned,snapshot,can,be,retrieved,from,either,lucene,index,or,translog,files;override,public,translog,snapshot,read,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,if,engine,config,get,index,settings,is,soft,delete,enabled,return,new,changes,snapshot,source,mapper,service,math,max,0,starting,seq,no,long,false,else,return,get,translog,new,snapshot,from,min,seq,no,starting,seq,no
InternalEngine -> @Override     public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1536314350;Creates a new history snapshot for reading operations since the provided seqno._The returned snapshot can be retrieved from either Lucene index or translog files.;@Override_    public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        if (engineConfig.getIndexSettings().isSoftDeleteEnabled()) {_            return newChangesSnapshot(source, mapperService, Math.max(0, startingSeqNo), Long.MAX_VALUE, false)__        } else {_            return getTranslog().newSnapshotFromMinSeqNo(startingSeqNo)__        }_    };creates,a,new,history,snapshot,for,reading,operations,since,the,provided,seqno,the,returned,snapshot,can,be,retrieved,from,either,lucene,index,or,translog,files;override,public,translog,snapshot,read,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,if,engine,config,get,index,settings,is,soft,delete,enabled,return,new,changes,snapshot,source,mapper,service,math,max,0,starting,seq,no,long,false,else,return,get,translog,new,snapshot,from,min,seq,no,starting,seq,no
InternalEngine -> @Override     public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1536828374;Creates a new history snapshot for reading operations since the provided seqno._The returned snapshot can be retrieved from either Lucene index or translog files.;@Override_    public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        if (engineConfig.getIndexSettings().isSoftDeleteEnabled()) {_            return newChangesSnapshot(source, mapperService, Math.max(0, startingSeqNo), Long.MAX_VALUE, false)__        } else {_            return getTranslog().newSnapshotFromMinSeqNo(startingSeqNo)__        }_    };creates,a,new,history,snapshot,for,reading,operations,since,the,provided,seqno,the,returned,snapshot,can,be,retrieved,from,either,lucene,index,or,translog,files;override,public,translog,snapshot,read,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,if,engine,config,get,index,settings,is,soft,delete,enabled,return,new,changes,snapshot,source,mapper,service,math,max,0,starting,seq,no,long,false,else,return,get,translog,new,snapshot,from,min,seq,no,starting,seq,no
InternalEngine -> @Override     public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1537806831;Creates a new history snapshot for reading operations since the provided seqno._The returned snapshot can be retrieved from either Lucene index or translog files.;@Override_    public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        if (engineConfig.getIndexSettings().isSoftDeleteEnabled()) {_            return newChangesSnapshot(source, mapperService, Math.max(0, startingSeqNo), Long.MAX_VALUE, false)__        } else {_            return getTranslog().newSnapshotFromMinSeqNo(startingSeqNo)__        }_    };creates,a,new,history,snapshot,for,reading,operations,since,the,provided,seqno,the,returned,snapshot,can,be,retrieved,from,either,lucene,index,or,translog,files;override,public,translog,snapshot,read,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,if,engine,config,get,index,settings,is,soft,delete,enabled,return,new,changes,snapshot,source,mapper,service,math,max,0,starting,seq,no,long,false,else,return,get,translog,new,snapshot,from,min,seq,no,starting,seq,no
InternalEngine -> @Override     public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1538067637;Creates a new history snapshot for reading operations since the provided seqno._The returned snapshot can be retrieved from either Lucene index or translog files.;@Override_    public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        if (engineConfig.getIndexSettings().isSoftDeleteEnabled()) {_            return newChangesSnapshot(source, mapperService, Math.max(0, startingSeqNo), Long.MAX_VALUE, false)__        } else {_            return getTranslog().newSnapshotFromMinSeqNo(startingSeqNo)__        }_    };creates,a,new,history,snapshot,for,reading,operations,since,the,provided,seqno,the,returned,snapshot,can,be,retrieved,from,either,lucene,index,or,translog,files;override,public,translog,snapshot,read,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,if,engine,config,get,index,settings,is,soft,delete,enabled,return,new,changes,snapshot,source,mapper,service,math,max,0,starting,seq,no,long,false,else,return,get,translog,new,snapshot,from,min,seq,no,starting,seq,no
InternalEngine -> @Override     public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1538424609;Creates a new history snapshot for reading operations since the provided seqno._The returned snapshot can be retrieved from either Lucene index or translog files.;@Override_    public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        if (engineConfig.getIndexSettings().isSoftDeleteEnabled()) {_            return newChangesSnapshot(source, mapperService, Math.max(0, startingSeqNo), Long.MAX_VALUE, false)__        } else {_            return getTranslog().newSnapshotFromMinSeqNo(startingSeqNo)__        }_    };creates,a,new,history,snapshot,for,reading,operations,since,the,provided,seqno,the,returned,snapshot,can,be,retrieved,from,either,lucene,index,or,translog,files;override,public,translog,snapshot,read,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,if,engine,config,get,index,settings,is,soft,delete,enabled,return,new,changes,snapshot,source,mapper,service,math,max,0,starting,seq,no,long,false,else,return,get,translog,new,snapshot,from,min,seq,no,starting,seq,no
InternalEngine -> @Override     public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1539615817;Creates a new history snapshot for reading operations since the provided seqno._The returned snapshot can be retrieved from either Lucene index or translog files.;@Override_    public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        if (engineConfig.getIndexSettings().isSoftDeleteEnabled()) {_            return newChangesSnapshot(source, mapperService, Math.max(0, startingSeqNo), Long.MAX_VALUE, false)__        } else {_            return getTranslog().newSnapshotFromMinSeqNo(startingSeqNo)__        }_    };creates,a,new,history,snapshot,for,reading,operations,since,the,provided,seqno,the,returned,snapshot,can,be,retrieved,from,either,lucene,index,or,translog,files;override,public,translog,snapshot,read,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,if,engine,config,get,index,settings,is,soft,delete,enabled,return,new,changes,snapshot,source,mapper,service,math,max,0,starting,seq,no,long,false,else,return,get,translog,new,snapshot,from,min,seq,no,starting,seq,no
InternalEngine -> @Override     public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1539723533;Creates a new history snapshot for reading operations since the provided seqno._The returned snapshot can be retrieved from either Lucene index or translog files.;@Override_    public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        if (engineConfig.getIndexSettings().isSoftDeleteEnabled()) {_            return newChangesSnapshot(source, mapperService, Math.max(0, startingSeqNo), Long.MAX_VALUE, false)__        } else {_            return getTranslog().newSnapshotFromMinSeqNo(startingSeqNo)__        }_    };creates,a,new,history,snapshot,for,reading,operations,since,the,provided,seqno,the,returned,snapshot,can,be,retrieved,from,either,lucene,index,or,translog,files;override,public,translog,snapshot,read,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,if,engine,config,get,index,settings,is,soft,delete,enabled,return,new,changes,snapshot,source,mapper,service,math,max,0,starting,seq,no,long,false,else,return,get,translog,new,snapshot,from,min,seq,no,starting,seq,no
InternalEngine -> @Override     public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1540238977;Creates a new history snapshot for reading operations since the provided seqno._The returned snapshot can be retrieved from either Lucene index or translog files.;@Override_    public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        if (engineConfig.getIndexSettings().isSoftDeleteEnabled()) {_            return newChangesSnapshot(source, mapperService, Math.max(0, startingSeqNo), Long.MAX_VALUE, false)__        } else {_            return getTranslog().newSnapshotFromMinSeqNo(startingSeqNo)__        }_    };creates,a,new,history,snapshot,for,reading,operations,since,the,provided,seqno,the,returned,snapshot,can,be,retrieved,from,either,lucene,index,or,translog,files;override,public,translog,snapshot,read,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,if,engine,config,get,index,settings,is,soft,delete,enabled,return,new,changes,snapshot,source,mapper,service,math,max,0,starting,seq,no,long,false,else,return,get,translog,new,snapshot,from,min,seq,no,starting,seq,no
InternalEngine -> @Override     public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1541335413;Creates a new history snapshot for reading operations since the provided seqno._The returned snapshot can be retrieved from either Lucene index or translog files.;@Override_    public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        if (engineConfig.getIndexSettings().isSoftDeleteEnabled()) {_            return newChangesSnapshot(source, mapperService, Math.max(0, startingSeqNo), Long.MAX_VALUE, false)__        } else {_            return getTranslog().newSnapshotFromMinSeqNo(startingSeqNo)__        }_    };creates,a,new,history,snapshot,for,reading,operations,since,the,provided,seqno,the,returned,snapshot,can,be,retrieved,from,either,lucene,index,or,translog,files;override,public,translog,snapshot,read,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,if,engine,config,get,index,settings,is,soft,delete,enabled,return,new,changes,snapshot,source,mapper,service,math,max,0,starting,seq,no,long,false,else,return,get,translog,new,snapshot,from,min,seq,no,starting,seq,no
InternalEngine -> @Override     public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1541622390;Creates a new history snapshot for reading operations since the provided seqno._The returned snapshot can be retrieved from either Lucene index or translog files.;@Override_    public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        if (engineConfig.getIndexSettings().isSoftDeleteEnabled()) {_            return newChangesSnapshot(source, mapperService, Math.max(0, startingSeqNo), Long.MAX_VALUE, false)__        } else {_            return getTranslog().newSnapshotFromMinSeqNo(startingSeqNo)__        }_    };creates,a,new,history,snapshot,for,reading,operations,since,the,provided,seqno,the,returned,snapshot,can,be,retrieved,from,either,lucene,index,or,translog,files;override,public,translog,snapshot,read,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,if,engine,config,get,index,settings,is,soft,delete,enabled,return,new,changes,snapshot,source,mapper,service,math,max,0,starting,seq,no,long,false,else,return,get,translog,new,snapshot,from,min,seq,no,starting,seq,no
InternalEngine -> @Override     public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1542697754;Creates a new history snapshot for reading operations since the provided seqno._The returned snapshot can be retrieved from either Lucene index or translog files.;@Override_    public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        if (engineConfig.getIndexSettings().isSoftDeleteEnabled()) {_            return newChangesSnapshot(source, mapperService, Math.max(0, startingSeqNo), Long.MAX_VALUE, false)__        } else {_            return getTranslog().newSnapshotFromMinSeqNo(startingSeqNo)__        }_    };creates,a,new,history,snapshot,for,reading,operations,since,the,provided,seqno,the,returned,snapshot,can,be,retrieved,from,either,lucene,index,or,translog,files;override,public,translog,snapshot,read,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,if,engine,config,get,index,settings,is,soft,delete,enabled,return,new,changes,snapshot,source,mapper,service,math,max,0,starting,seq,no,long,false,else,return,get,translog,new,snapshot,from,min,seq,no,starting,seq,no
InternalEngine -> @Override     public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1543940134;Creates a new history snapshot for reading operations since the provided seqno._The returned snapshot can be retrieved from either Lucene index or translog files.;@Override_    public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        if (engineConfig.getIndexSettings().isSoftDeleteEnabled()) {_            return newChangesSnapshot(source, mapperService, Math.max(0, startingSeqNo), Long.MAX_VALUE, false)__        } else {_            return getTranslog().newSnapshotFromMinSeqNo(startingSeqNo)__        }_    };creates,a,new,history,snapshot,for,reading,operations,since,the,provided,seqno,the,returned,snapshot,can,be,retrieved,from,either,lucene,index,or,translog,files;override,public,translog,snapshot,read,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,if,engine,config,get,index,settings,is,soft,delete,enabled,return,new,changes,snapshot,source,mapper,service,math,max,0,starting,seq,no,long,false,else,return,get,translog,new,snapshot,from,min,seq,no,starting,seq,no
InternalEngine -> @Override     public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1544322276;Creates a new history snapshot for reading operations since the provided seqno._The returned snapshot can be retrieved from either Lucene index or translog files.;@Override_    public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        if (engineConfig.getIndexSettings().isSoftDeleteEnabled()) {_            return newChangesSnapshot(source, mapperService, Math.max(0, startingSeqNo), Long.MAX_VALUE, false)__        } else {_            return getTranslog().newSnapshotFromMinSeqNo(startingSeqNo)__        }_    };creates,a,new,history,snapshot,for,reading,operations,since,the,provided,seqno,the,returned,snapshot,can,be,retrieved,from,either,lucene,index,or,translog,files;override,public,translog,snapshot,read,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,if,engine,config,get,index,settings,is,soft,delete,enabled,return,new,changes,snapshot,source,mapper,service,math,max,0,starting,seq,no,long,false,else,return,get,translog,new,snapshot,from,min,seq,no,starting,seq,no
InternalEngine -> @Override     public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1544545090;Creates a new history snapshot for reading operations since the provided seqno._The returned snapshot can be retrieved from either Lucene index or translog files.;@Override_    public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        if (engineConfig.getIndexSettings().isSoftDeleteEnabled()) {_            return newChangesSnapshot(source, mapperService, Math.max(0, startingSeqNo), Long.MAX_VALUE, false)__        } else {_            return getTranslog().newSnapshotFromMinSeqNo(startingSeqNo)__        }_    };creates,a,new,history,snapshot,for,reading,operations,since,the,provided,seqno,the,returned,snapshot,can,be,retrieved,from,either,lucene,index,or,translog,files;override,public,translog,snapshot,read,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,if,engine,config,get,index,settings,is,soft,delete,enabled,return,new,changes,snapshot,source,mapper,service,math,max,0,starting,seq,no,long,false,else,return,get,translog,new,snapshot,from,min,seq,no,starting,seq,no
InternalEngine -> @Override     public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1544684920;Creates a new history snapshot for reading operations since the provided seqno._The returned snapshot can be retrieved from either Lucene index or translog files.;@Override_    public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        if (engineConfig.getIndexSettings().isSoftDeleteEnabled()) {_            return newChangesSnapshot(source, mapperService, Math.max(0, startingSeqNo), Long.MAX_VALUE, false)__        } else {_            return getTranslog().newSnapshotFromMinSeqNo(startingSeqNo)__        }_    };creates,a,new,history,snapshot,for,reading,operations,since,the,provided,seqno,the,returned,snapshot,can,be,retrieved,from,either,lucene,index,or,translog,files;override,public,translog,snapshot,read,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,if,engine,config,get,index,settings,is,soft,delete,enabled,return,new,changes,snapshot,source,mapper,service,math,max,0,starting,seq,no,long,false,else,return,get,translog,new,snapshot,from,min,seq,no,starting,seq,no
InternalEngine -> @Override     public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1545140118;Creates a new history snapshot for reading operations since the provided seqno._The returned snapshot can be retrieved from either Lucene index or translog files.;@Override_    public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        if (engineConfig.getIndexSettings().isSoftDeleteEnabled()) {_            return newChangesSnapshot(source, mapperService, Math.max(0, startingSeqNo), Long.MAX_VALUE, false)__        } else {_            return getTranslog().newSnapshotFromMinSeqNo(startingSeqNo)__        }_    };creates,a,new,history,snapshot,for,reading,operations,since,the,provided,seqno,the,returned,snapshot,can,be,retrieved,from,either,lucene,index,or,translog,files;override,public,translog,snapshot,read,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,if,engine,config,get,index,settings,is,soft,delete,enabled,return,new,changes,snapshot,source,mapper,service,math,max,0,starting,seq,no,long,false,else,return,get,translog,new,snapshot,from,min,seq,no,starting,seq,no
InternalEngine -> @Override     public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1546875837;Creates a new history snapshot for reading operations since the provided seqno._The returned snapshot can be retrieved from either Lucene index or translog files.;@Override_    public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        if (engineConfig.getIndexSettings().isSoftDeleteEnabled()) {_            return newChangesSnapshot(source, mapperService, Math.max(0, startingSeqNo), Long.MAX_VALUE, false)__        } else {_            return getTranslog().newSnapshotFromMinSeqNo(startingSeqNo)__        }_    };creates,a,new,history,snapshot,for,reading,operations,since,the,provided,seqno,the,returned,snapshot,can,be,retrieved,from,either,lucene,index,or,translog,files;override,public,translog,snapshot,read,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,if,engine,config,get,index,settings,is,soft,delete,enabled,return,new,changes,snapshot,source,mapper,service,math,max,0,starting,seq,no,long,false,else,return,get,translog,new,snapshot,from,min,seq,no,starting,seq,no
InternalEngine -> @Override     public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1547332999;Creates a new history snapshot for reading operations since the provided seqno._The returned snapshot can be retrieved from either Lucene index or translog files.;@Override_    public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        if (engineConfig.getIndexSettings().isSoftDeleteEnabled()) {_            return newChangesSnapshot(source, mapperService, Math.max(0, startingSeqNo), Long.MAX_VALUE, false)__        } else {_            return getTranslog().newSnapshotFromMinSeqNo(startingSeqNo)__        }_    };creates,a,new,history,snapshot,for,reading,operations,since,the,provided,seqno,the,returned,snapshot,can,be,retrieved,from,either,lucene,index,or,translog,files;override,public,translog,snapshot,read,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,if,engine,config,get,index,settings,is,soft,delete,enabled,return,new,changes,snapshot,source,mapper,service,math,max,0,starting,seq,no,long,false,else,return,get,translog,new,snapshot,from,min,seq,no,starting,seq,no
InternalEngine -> @Override     public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1548771485;Creates a new history snapshot for reading operations since the provided seqno._The returned snapshot can be retrieved from either Lucene index or translog files.;@Override_    public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        if (engineConfig.getIndexSettings().isSoftDeleteEnabled()) {_            return newChangesSnapshot(source, mapperService, Math.max(0, startingSeqNo), Long.MAX_VALUE, false)__        } else {_            return getTranslog().newSnapshotFromMinSeqNo(startingSeqNo)__        }_    };creates,a,new,history,snapshot,for,reading,operations,since,the,provided,seqno,the,returned,snapshot,can,be,retrieved,from,either,lucene,index,or,translog,files;override,public,translog,snapshot,read,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,if,engine,config,get,index,settings,is,soft,delete,enabled,return,new,changes,snapshot,source,mapper,service,math,max,0,starting,seq,no,long,false,else,return,get,translog,new,snapshot,from,min,seq,no,starting,seq,no
InternalEngine -> @Override     public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1549059559;Creates a new history snapshot for reading operations since the provided seqno._The returned snapshot can be retrieved from either Lucene index or translog files.;@Override_    public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        if (engineConfig.getIndexSettings().isSoftDeleteEnabled()) {_            return newChangesSnapshot(source, mapperService, Math.max(0, startingSeqNo), Long.MAX_VALUE, false)__        } else {_            return getTranslog().newSnapshotFromMinSeqNo(startingSeqNo)__        }_    };creates,a,new,history,snapshot,for,reading,operations,since,the,provided,seqno,the,returned,snapshot,can,be,retrieved,from,either,lucene,index,or,translog,files;override,public,translog,snapshot,read,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,if,engine,config,get,index,settings,is,soft,delete,enabled,return,new,changes,snapshot,source,mapper,service,math,max,0,starting,seq,no,long,false,else,return,get,translog,new,snapshot,from,min,seq,no,starting,seq,no
InternalEngine -> @Override     public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1549663373;Creates a new history snapshot for reading operations since the provided seqno._The returned snapshot can be retrieved from either Lucene index or translog files.;@Override_    public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        if (engineConfig.getIndexSettings().isSoftDeleteEnabled()) {_            return newChangesSnapshot(source, mapperService, Math.max(0, startingSeqNo), Long.MAX_VALUE, false)__        } else {_            return getTranslog().newSnapshotFromMinSeqNo(startingSeqNo)__        }_    };creates,a,new,history,snapshot,for,reading,operations,since,the,provided,seqno,the,returned,snapshot,can,be,retrieved,from,either,lucene,index,or,translog,files;override,public,translog,snapshot,read,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,if,engine,config,get,index,settings,is,soft,delete,enabled,return,new,changes,snapshot,source,mapper,service,math,max,0,starting,seq,no,long,false,else,return,get,translog,new,snapshot,from,min,seq,no,starting,seq,no
InternalEngine -> @Override     public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1549975032;Creates a new history snapshot for reading operations since the provided seqno._The returned snapshot can be retrieved from either Lucene index or translog files.;@Override_    public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        if (engineConfig.getIndexSettings().isSoftDeleteEnabled()) {_            return newChangesSnapshot(source, mapperService, Math.max(0, startingSeqNo), Long.MAX_VALUE, false)__        } else {_            return getTranslog().newSnapshotFromMinSeqNo(startingSeqNo)__        }_    };creates,a,new,history,snapshot,for,reading,operations,since,the,provided,seqno,the,returned,snapshot,can,be,retrieved,from,either,lucene,index,or,translog,files;override,public,translog,snapshot,read,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,if,engine,config,get,index,settings,is,soft,delete,enabled,return,new,changes,snapshot,source,mapper,service,math,max,0,starting,seq,no,long,false,else,return,get,translog,new,snapshot,from,min,seq,no,starting,seq,no
InternalEngine -> @Override     public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1550220204;Creates a new history snapshot for reading operations since the provided seqno from the translog.;@Override_    public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        return getTranslog().newSnapshotFromMinSeqNo(startingSeqNo)__    };creates,a,new,history,snapshot,for,reading,operations,since,the,provided,seqno,from,the,translog;override,public,translog,snapshot,read,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,return,get,translog,new,snapshot,from,min,seq,no,starting,seq,no
InternalEngine -> @Override     public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1550256122;Creates a new history snapshot for reading operations since the provided seqno from the translog.;@Override_    public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        return getTranslog().newSnapshotFromMinSeqNo(startingSeqNo)__    };creates,a,new,history,snapshot,for,reading,operations,since,the,provided,seqno,from,the,translog;override,public,translog,snapshot,read,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,return,get,translog,new,snapshot,from,min,seq,no,starting,seq,no
InternalEngine -> @Override     public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1550342051;Creates a new history snapshot for reading operations since the provided seqno from the translog.;@Override_    public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        return getTranslog().newSnapshotFromMinSeqNo(startingSeqNo)__    };creates,a,new,history,snapshot,for,reading,operations,since,the,provided,seqno,from,the,translog;override,public,translog,snapshot,read,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,return,get,translog,new,snapshot,from,min,seq,no,starting,seq,no
InternalEngine -> @Override     public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1550526771;Creates a new history snapshot for reading operations since the provided seqno from the translog.;@Override_    public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        return getTranslog().newSnapshotFromMinSeqNo(startingSeqNo)__    };creates,a,new,history,snapshot,for,reading,operations,since,the,provided,seqno,from,the,translog;override,public,translog,snapshot,read,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,return,get,translog,new,snapshot,from,min,seq,no,starting,seq,no
InternalEngine -> @Override     public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1551110274;Creates a new history snapshot for reading operations since the provided seqno from the translog.;@Override_    public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        return getTranslog().newSnapshotFromMinSeqNo(startingSeqNo)__    };creates,a,new,history,snapshot,for,reading,operations,since,the,provided,seqno,from,the,translog;override,public,translog,snapshot,read,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,return,get,translog,new,snapshot,from,min,seq,no,starting,seq,no
InternalEngine -> @Override     public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException;1551126708;Creates a new history snapshot for reading operations since the provided seqno from the translog.;@Override_    public Translog.Snapshot readHistoryOperations(String source, MapperService mapperService, long startingSeqNo) throws IOException {_        return getTranslog().newSnapshotFromMinSeqNo(startingSeqNo)__    };creates,a,new,history,snapshot,for,reading,operations,since,the,provided,seqno,from,the,translog;override,public,translog,snapshot,read,history,operations,string,source,mapper,service,mapper,service,long,starting,seq,no,throws,ioexception,return,get,translog,new,snapshot,from,min,seq,no,starting,seq,no
InternalEngine -> @Nullable     private String loadTranslogUUIDFromLastCommit() throws IOException;1524684173;Reads the current stored translog ID from the last commit data.;@Nullable_    private String loadTranslogUUIDFromLastCommit() throws IOException {_        final Map<String, String> commitUserData = store.readLastCommittedSegmentsInfo().getUserData()__        if (commitUserData.containsKey(Translog.TRANSLOG_GENERATION_KEY) == false) {_            throw new IllegalStateException("commit doesn't contain translog generation id")__        }_        return commitUserData.get(Translog.TRANSLOG_UUID_KEY)__    };reads,the,current,stored,translog,id,from,the,last,commit,data;nullable,private,string,load,translog,uuidfrom,last,commit,throws,ioexception,final,map,string,string,commit,user,data,store,read,last,committed,segments,info,get,user,data,if,commit,user,data,contains,key,translog,false,throw,new,illegal,state,exception,commit,doesn,t,contain,translog,generation,id,return,commit,user,data,get,translog
InternalEngine -> @Nullable     private String loadTranslogUUIDFromLastCommit() throws IOException;1524780945;Reads the current stored translog ID from the last commit data.;@Nullable_    private String loadTranslogUUIDFromLastCommit() throws IOException {_        final Map<String, String> commitUserData = store.readLastCommittedSegmentsInfo().getUserData()__        if (commitUserData.containsKey(Translog.TRANSLOG_GENERATION_KEY) == false) {_            throw new IllegalStateException("commit doesn't contain translog generation id")__        }_        return commitUserData.get(Translog.TRANSLOG_UUID_KEY)__    };reads,the,current,stored,translog,id,from,the,last,commit,data;nullable,private,string,load,translog,uuidfrom,last,commit,throws,ioexception,final,map,string,string,commit,user,data,store,read,last,committed,segments,info,get,user,data,if,commit,user,data,contains,key,translog,false,throw,new,illegal,state,exception,commit,doesn,t,contain,translog,generation,id,return,commit,user,data,get,translog
InternalEngine -> @Nullable     private String loadTranslogUUIDFromLastCommit() throws IOException;1525162917;Reads the current stored translog ID from the last commit data.;@Nullable_    private String loadTranslogUUIDFromLastCommit() throws IOException {_        final Map<String, String> commitUserData = store.readLastCommittedSegmentsInfo().getUserData()__        if (commitUserData.containsKey(Translog.TRANSLOG_GENERATION_KEY) == false) {_            throw new IllegalStateException("commit doesn't contain translog generation id")__        }_        return commitUserData.get(Translog.TRANSLOG_UUID_KEY)__    };reads,the,current,stored,translog,id,from,the,last,commit,data;nullable,private,string,load,translog,uuidfrom,last,commit,throws,ioexception,final,map,string,string,commit,user,data,store,read,last,committed,segments,info,get,user,data,if,commit,user,data,contains,key,translog,false,throw,new,illegal,state,exception,commit,doesn,t,contain,translog,generation,id,return,commit,user,data,get,translog
InternalEngine -> @Nullable     private String loadTranslogUUIDFromLastCommit() throws IOException;1528706846;Reads the current stored translog ID from the last commit data.;@Nullable_    private String loadTranslogUUIDFromLastCommit() throws IOException {_        final Map<String, String> commitUserData = store.readLastCommittedSegmentsInfo().getUserData()__        if (commitUserData.containsKey(Translog.TRANSLOG_GENERATION_KEY) == false) {_            throw new IllegalStateException("commit doesn't contain translog generation id")__        }_        return commitUserData.get(Translog.TRANSLOG_UUID_KEY)__    };reads,the,current,stored,translog,id,from,the,last,commit,data;nullable,private,string,load,translog,uuidfrom,last,commit,throws,ioexception,final,map,string,string,commit,user,data,store,read,last,committed,segments,info,get,user,data,if,commit,user,data,contains,key,translog,false,throw,new,illegal,state,exception,commit,doesn,t,contain,translog,generation,id,return,commit,user,data,get,translog
InternalEngine -> @Nullable     private String loadTranslogUUIDFromLastCommit() throws IOException;1528762805;Reads the current stored translog ID from the last commit data.;@Nullable_    private String loadTranslogUUIDFromLastCommit() throws IOException {_        final Map<String, String> commitUserData = store.readLastCommittedSegmentsInfo().getUserData()__        if (commitUserData.containsKey(Translog.TRANSLOG_GENERATION_KEY) == false) {_            throw new IllegalStateException("commit doesn't contain translog generation id")__        }_        return commitUserData.get(Translog.TRANSLOG_UUID_KEY)__    };reads,the,current,stored,translog,id,from,the,last,commit,data;nullable,private,string,load,translog,uuidfrom,last,commit,throws,ioexception,final,map,string,string,commit,user,data,store,read,last,committed,segments,info,get,user,data,if,commit,user,data,contains,key,translog,false,throw,new,illegal,state,exception,commit,doesn,t,contain,translog,generation,id,return,commit,user,data,get,translog
InternalEngine -> @Nullable     private String loadTranslogUUIDFromLastCommit() throws IOException;1531910483;Reads the current stored translog ID from the last commit data.;@Nullable_    private String loadTranslogUUIDFromLastCommit() throws IOException {_        final Map<String, String> commitUserData = store.readLastCommittedSegmentsInfo().getUserData()__        if (commitUserData.containsKey(Translog.TRANSLOG_GENERATION_KEY) == false) {_            throw new IllegalStateException("commit doesn't contain translog generation id")__        }_        return commitUserData.get(Translog.TRANSLOG_UUID_KEY)__    };reads,the,current,stored,translog,id,from,the,last,commit,data;nullable,private,string,load,translog,uuidfrom,last,commit,throws,ioexception,final,map,string,string,commit,user,data,store,read,last,committed,segments,info,get,user,data,if,commit,user,data,contains,key,translog,false,throw,new,illegal,state,exception,commit,doesn,t,contain,translog,generation,id,return,commit,user,data,get,translog
InternalEngine -> @Nullable     private String loadTranslogUUIDFromLastCommit() throws IOException;1533295538;Reads the current stored translog ID from the last commit data.;@Nullable_    private String loadTranslogUUIDFromLastCommit() throws IOException {_        final Map<String, String> commitUserData = store.readLastCommittedSegmentsInfo().getUserData()__        if (commitUserData.containsKey(Translog.TRANSLOG_GENERATION_KEY) == false) {_            throw new IllegalStateException("commit doesn't contain translog generation id")__        }_        return commitUserData.get(Translog.TRANSLOG_UUID_KEY)__    };reads,the,current,stored,translog,id,from,the,last,commit,data;nullable,private,string,load,translog,uuidfrom,last,commit,throws,ioexception,final,map,string,string,commit,user,data,store,read,last,committed,segments,info,get,user,data,if,commit,user,data,contains,key,translog,false,throw,new,illegal,state,exception,commit,doesn,t,contain,translog,generation,id,return,commit,user,data,get,translog
InternalEngine -> @Nullable     private String loadTranslogUUIDFromLastCommit() throws IOException;1534848846;Reads the current stored translog ID from the last commit data.;@Nullable_    private String loadTranslogUUIDFromLastCommit() throws IOException {_        final Map<String, String> commitUserData = store.readLastCommittedSegmentsInfo().getUserData()__        if (commitUserData.containsKey(Translog.TRANSLOG_GENERATION_KEY) == false) {_            throw new IllegalStateException("commit doesn't contain translog generation id")__        }_        return commitUserData.get(Translog.TRANSLOG_UUID_KEY)__    };reads,the,current,stored,translog,id,from,the,last,commit,data;nullable,private,string,load,translog,uuidfrom,last,commit,throws,ioexception,final,map,string,string,commit,user,data,store,read,last,committed,segments,info,get,user,data,if,commit,user,data,contains,key,translog,false,throw,new,illegal,state,exception,commit,doesn,t,contain,translog,generation,id,return,commit,user,data,get,translog
InternalEngine -> @Nullable     private String loadTranslogUUIDFromLastCommit() throws IOException;1535046779;Reads the current stored translog ID from the last commit data.;@Nullable_    private String loadTranslogUUIDFromLastCommit() throws IOException {_        final Map<String, String> commitUserData = store.readLastCommittedSegmentsInfo().getUserData()__        if (commitUserData.containsKey(Translog.TRANSLOG_GENERATION_KEY) == false) {_            throw new IllegalStateException("commit doesn't contain translog generation id")__        }_        return commitUserData.get(Translog.TRANSLOG_UUID_KEY)__    };reads,the,current,stored,translog,id,from,the,last,commit,data;nullable,private,string,load,translog,uuidfrom,last,commit,throws,ioexception,final,map,string,string,commit,user,data,store,read,last,committed,segments,info,get,user,data,if,commit,user,data,contains,key,translog,false,throw,new,illegal,state,exception,commit,doesn,t,contain,translog,generation,id,return,commit,user,data,get,translog
InternalEngine -> @Nullable     private String loadTranslogUUIDFromLastCommit() throws IOException;1535405719;Reads the current stored translog ID from the last commit data.;@Nullable_    private String loadTranslogUUIDFromLastCommit() throws IOException {_        final Map<String, String> commitUserData = store.readLastCommittedSegmentsInfo().getUserData()__        if (commitUserData.containsKey(Translog.TRANSLOG_GENERATION_KEY) == false) {_            throw new IllegalStateException("commit doesn't contain translog generation id")__        }_        return commitUserData.get(Translog.TRANSLOG_UUID_KEY)__    };reads,the,current,stored,translog,id,from,the,last,commit,data;nullable,private,string,load,translog,uuidfrom,last,commit,throws,ioexception,final,map,string,string,commit,user,data,store,read,last,committed,segments,info,get,user,data,if,commit,user,data,contains,key,translog,false,throw,new,illegal,state,exception,commit,doesn,t,contain,translog,generation,id,return,commit,user,data,get,translog
InternalEngine -> @Nullable     private String loadTranslogUUIDFromLastCommit() throws IOException;1535723122;Reads the current stored translog ID from the last commit data.;@Nullable_    private String loadTranslogUUIDFromLastCommit() throws IOException {_        final Map<String, String> commitUserData = store.readLastCommittedSegmentsInfo().getUserData()__        if (commitUserData.containsKey(Translog.TRANSLOG_GENERATION_KEY) == false) {_            throw new IllegalStateException("commit doesn't contain translog generation id")__        }_        return commitUserData.get(Translog.TRANSLOG_UUID_KEY)__    };reads,the,current,stored,translog,id,from,the,last,commit,data;nullable,private,string,load,translog,uuidfrom,last,commit,throws,ioexception,final,map,string,string,commit,user,data,store,read,last,committed,segments,info,get,user,data,if,commit,user,data,contains,key,translog,false,throw,new,illegal,state,exception,commit,doesn,t,contain,translog,generation,id,return,commit,user,data,get,translog
InternalEngine -> @Nullable     private String loadTranslogUUIDFromLastCommit() throws IOException;1535965276;Reads the current stored translog ID from the last commit data.;@Nullable_    private String loadTranslogUUIDFromLastCommit() throws IOException {_        final Map<String, String> commitUserData = store.readLastCommittedSegmentsInfo().getUserData()__        if (commitUserData.containsKey(Translog.TRANSLOG_GENERATION_KEY) == false) {_            throw new IllegalStateException("commit doesn't contain translog generation id")__        }_        return commitUserData.get(Translog.TRANSLOG_UUID_KEY)__    };reads,the,current,stored,translog,id,from,the,last,commit,data;nullable,private,string,load,translog,uuidfrom,last,commit,throws,ioexception,final,map,string,string,commit,user,data,store,read,last,committed,segments,info,get,user,data,if,commit,user,data,contains,key,translog,false,throw,new,illegal,state,exception,commit,doesn,t,contain,translog,generation,id,return,commit,user,data,get,translog
InternalEngine -> @Nullable     private String loadTranslogUUIDFromLastCommit() throws IOException;1536218260;Reads the current stored translog ID from the last commit data.;@Nullable_    private String loadTranslogUUIDFromLastCommit() throws IOException {_        final Map<String, String> commitUserData = store.readLastCommittedSegmentsInfo().getUserData()__        if (commitUserData.containsKey(Translog.TRANSLOG_GENERATION_KEY) == false) {_            throw new IllegalStateException("commit doesn't contain translog generation id")__        }_        return commitUserData.get(Translog.TRANSLOG_UUID_KEY)__    };reads,the,current,stored,translog,id,from,the,last,commit,data;nullable,private,string,load,translog,uuidfrom,last,commit,throws,ioexception,final,map,string,string,commit,user,data,store,read,last,committed,segments,info,get,user,data,if,commit,user,data,contains,key,translog,false,throw,new,illegal,state,exception,commit,doesn,t,contain,translog,generation,id,return,commit,user,data,get,translog
InternalEngine -> @Nullable     private String loadTranslogUUIDFromLastCommit() throws IOException;1536314350;Reads the current stored translog ID from the last commit data.;@Nullable_    private String loadTranslogUUIDFromLastCommit() throws IOException {_        final Map<String, String> commitUserData = store.readLastCommittedSegmentsInfo().getUserData()__        if (commitUserData.containsKey(Translog.TRANSLOG_GENERATION_KEY) == false) {_            throw new IllegalStateException("commit doesn't contain translog generation id")__        }_        return commitUserData.get(Translog.TRANSLOG_UUID_KEY)__    };reads,the,current,stored,translog,id,from,the,last,commit,data;nullable,private,string,load,translog,uuidfrom,last,commit,throws,ioexception,final,map,string,string,commit,user,data,store,read,last,committed,segments,info,get,user,data,if,commit,user,data,contains,key,translog,false,throw,new,illegal,state,exception,commit,doesn,t,contain,translog,generation,id,return,commit,user,data,get,translog
InternalEngine -> @Nullable     private String loadTranslogUUIDFromLastCommit() throws IOException;1536828374;Reads the current stored translog ID from the last commit data.;@Nullable_    private String loadTranslogUUIDFromLastCommit() throws IOException {_        final Map<String, String> commitUserData = store.readLastCommittedSegmentsInfo().getUserData()__        if (commitUserData.containsKey(Translog.TRANSLOG_GENERATION_KEY) == false) {_            throw new IllegalStateException("commit doesn't contain translog generation id")__        }_        return commitUserData.get(Translog.TRANSLOG_UUID_KEY)__    };reads,the,current,stored,translog,id,from,the,last,commit,data;nullable,private,string,load,translog,uuidfrom,last,commit,throws,ioexception,final,map,string,string,commit,user,data,store,read,last,committed,segments,info,get,user,data,if,commit,user,data,contains,key,translog,false,throw,new,illegal,state,exception,commit,doesn,t,contain,translog,generation,id,return,commit,user,data,get,translog
InternalEngine -> @Nullable     private String loadTranslogUUIDFromLastCommit() throws IOException;1537806831;Reads the current stored translog ID from the last commit data.;@Nullable_    private String loadTranslogUUIDFromLastCommit() throws IOException {_        final Map<String, String> commitUserData = store.readLastCommittedSegmentsInfo().getUserData()__        if (commitUserData.containsKey(Translog.TRANSLOG_GENERATION_KEY) == false) {_            throw new IllegalStateException("commit doesn't contain translog generation id")__        }_        return commitUserData.get(Translog.TRANSLOG_UUID_KEY)__    };reads,the,current,stored,translog,id,from,the,last,commit,data;nullable,private,string,load,translog,uuidfrom,last,commit,throws,ioexception,final,map,string,string,commit,user,data,store,read,last,committed,segments,info,get,user,data,if,commit,user,data,contains,key,translog,false,throw,new,illegal,state,exception,commit,doesn,t,contain,translog,generation,id,return,commit,user,data,get,translog
InternalEngine -> @Nullable     private String loadTranslogUUIDFromLastCommit() throws IOException;1538067637;Reads the current stored translog ID from the last commit data.;@Nullable_    private String loadTranslogUUIDFromLastCommit() throws IOException {_        final Map<String, String> commitUserData = store.readLastCommittedSegmentsInfo().getUserData()__        if (commitUserData.containsKey(Translog.TRANSLOG_GENERATION_KEY) == false) {_            throw new IllegalStateException("commit doesn't contain translog generation id")__        }_        return commitUserData.get(Translog.TRANSLOG_UUID_KEY)__    };reads,the,current,stored,translog,id,from,the,last,commit,data;nullable,private,string,load,translog,uuidfrom,last,commit,throws,ioexception,final,map,string,string,commit,user,data,store,read,last,committed,segments,info,get,user,data,if,commit,user,data,contains,key,translog,false,throw,new,illegal,state,exception,commit,doesn,t,contain,translog,generation,id,return,commit,user,data,get,translog
InternalEngine -> @Nullable     private String loadTranslogUUIDFromLastCommit() throws IOException;1538424609;Reads the current stored translog ID from the last commit data.;@Nullable_    private String loadTranslogUUIDFromLastCommit() throws IOException {_        final Map<String, String> commitUserData = store.readLastCommittedSegmentsInfo().getUserData()__        if (commitUserData.containsKey(Translog.TRANSLOG_GENERATION_KEY) == false) {_            throw new IllegalStateException("commit doesn't contain translog generation id")__        }_        return commitUserData.get(Translog.TRANSLOG_UUID_KEY)__    };reads,the,current,stored,translog,id,from,the,last,commit,data;nullable,private,string,load,translog,uuidfrom,last,commit,throws,ioexception,final,map,string,string,commit,user,data,store,read,last,committed,segments,info,get,user,data,if,commit,user,data,contains,key,translog,false,throw,new,illegal,state,exception,commit,doesn,t,contain,translog,generation,id,return,commit,user,data,get,translog
InternalEngine -> @Nullable     private String loadTranslogUUIDFromLastCommit() throws IOException;1539615817;Reads the current stored translog ID from the last commit data.;@Nullable_    private String loadTranslogUUIDFromLastCommit() throws IOException {_        final Map<String, String> commitUserData = store.readLastCommittedSegmentsInfo().getUserData()__        if (commitUserData.containsKey(Translog.TRANSLOG_GENERATION_KEY) == false) {_            throw new IllegalStateException("commit doesn't contain translog generation id")__        }_        return commitUserData.get(Translog.TRANSLOG_UUID_KEY)__    };reads,the,current,stored,translog,id,from,the,last,commit,data;nullable,private,string,load,translog,uuidfrom,last,commit,throws,ioexception,final,map,string,string,commit,user,data,store,read,last,committed,segments,info,get,user,data,if,commit,user,data,contains,key,translog,false,throw,new,illegal,state,exception,commit,doesn,t,contain,translog,generation,id,return,commit,user,data,get,translog
InternalEngine -> @Nullable     private String loadTranslogUUIDFromLastCommit() throws IOException;1539723533;Reads the current stored translog ID from the last commit data.;@Nullable_    private String loadTranslogUUIDFromLastCommit() throws IOException {_        final Map<String, String> commitUserData = store.readLastCommittedSegmentsInfo().getUserData()__        if (commitUserData.containsKey(Translog.TRANSLOG_GENERATION_KEY) == false) {_            throw new IllegalStateException("commit doesn't contain translog generation id")__        }_        return commitUserData.get(Translog.TRANSLOG_UUID_KEY)__    };reads,the,current,stored,translog,id,from,the,last,commit,data;nullable,private,string,load,translog,uuidfrom,last,commit,throws,ioexception,final,map,string,string,commit,user,data,store,read,last,committed,segments,info,get,user,data,if,commit,user,data,contains,key,translog,false,throw,new,illegal,state,exception,commit,doesn,t,contain,translog,generation,id,return,commit,user,data,get,translog
InternalEngine -> @Nullable     private String loadTranslogUUIDFromLastCommit() throws IOException;1540238977;Reads the current stored translog ID from the last commit data.;@Nullable_    private String loadTranslogUUIDFromLastCommit() throws IOException {_        final Map<String, String> commitUserData = store.readLastCommittedSegmentsInfo().getUserData()__        if (commitUserData.containsKey(Translog.TRANSLOG_GENERATION_KEY) == false) {_            throw new IllegalStateException("commit doesn't contain translog generation id")__        }_        return commitUserData.get(Translog.TRANSLOG_UUID_KEY)__    };reads,the,current,stored,translog,id,from,the,last,commit,data;nullable,private,string,load,translog,uuidfrom,last,commit,throws,ioexception,final,map,string,string,commit,user,data,store,read,last,committed,segments,info,get,user,data,if,commit,user,data,contains,key,translog,false,throw,new,illegal,state,exception,commit,doesn,t,contain,translog,generation,id,return,commit,user,data,get,translog
InternalEngine -> @Nullable     private String loadTranslogUUIDFromLastCommit() throws IOException;1541335413;Reads the current stored translog ID from the last commit data.;@Nullable_    private String loadTranslogUUIDFromLastCommit() throws IOException {_        final Map<String, String> commitUserData = store.readLastCommittedSegmentsInfo().getUserData()__        if (commitUserData.containsKey(Translog.TRANSLOG_GENERATION_KEY) == false) {_            throw new IllegalStateException("commit doesn't contain translog generation id")__        }_        return commitUserData.get(Translog.TRANSLOG_UUID_KEY)__    };reads,the,current,stored,translog,id,from,the,last,commit,data;nullable,private,string,load,translog,uuidfrom,last,commit,throws,ioexception,final,map,string,string,commit,user,data,store,read,last,committed,segments,info,get,user,data,if,commit,user,data,contains,key,translog,false,throw,new,illegal,state,exception,commit,doesn,t,contain,translog,generation,id,return,commit,user,data,get,translog
InternalEngine -> @Nullable     private String loadTranslogUUIDFromLastCommit() throws IOException;1541622390;Reads the current stored translog ID from the last commit data.;@Nullable_    private String loadTranslogUUIDFromLastCommit() throws IOException {_        final Map<String, String> commitUserData = store.readLastCommittedSegmentsInfo().getUserData()__        if (commitUserData.containsKey(Translog.TRANSLOG_GENERATION_KEY) == false) {_            throw new IllegalStateException("commit doesn't contain translog generation id")__        }_        return commitUserData.get(Translog.TRANSLOG_UUID_KEY)__    };reads,the,current,stored,translog,id,from,the,last,commit,data;nullable,private,string,load,translog,uuidfrom,last,commit,throws,ioexception,final,map,string,string,commit,user,data,store,read,last,committed,segments,info,get,user,data,if,commit,user,data,contains,key,translog,false,throw,new,illegal,state,exception,commit,doesn,t,contain,translog,generation,id,return,commit,user,data,get,translog
InternalEngine -> @Nullable     private String loadTranslogUUIDFromLastCommit() throws IOException;1542697754;Reads the current stored translog ID from the last commit data.;@Nullable_    private String loadTranslogUUIDFromLastCommit() throws IOException {_        final Map<String, String> commitUserData = store.readLastCommittedSegmentsInfo().getUserData()__        if (commitUserData.containsKey(Translog.TRANSLOG_GENERATION_KEY) == false) {_            throw new IllegalStateException("commit doesn't contain translog generation id")__        }_        return commitUserData.get(Translog.TRANSLOG_UUID_KEY)__    };reads,the,current,stored,translog,id,from,the,last,commit,data;nullable,private,string,load,translog,uuidfrom,last,commit,throws,ioexception,final,map,string,string,commit,user,data,store,read,last,committed,segments,info,get,user,data,if,commit,user,data,contains,key,translog,false,throw,new,illegal,state,exception,commit,doesn,t,contain,translog,generation,id,return,commit,user,data,get,translog
InternalEngine -> @Nullable     private String loadTranslogUUIDFromLastCommit() throws IOException;1543940134;Reads the current stored translog ID from the last commit data.;@Nullable_    private String loadTranslogUUIDFromLastCommit() throws IOException {_        final Map<String, String> commitUserData = store.readLastCommittedSegmentsInfo().getUserData()__        if (commitUserData.containsKey(Translog.TRANSLOG_GENERATION_KEY) == false) {_            throw new IllegalStateException("commit doesn't contain translog generation id")__        }_        return commitUserData.get(Translog.TRANSLOG_UUID_KEY)__    };reads,the,current,stored,translog,id,from,the,last,commit,data;nullable,private,string,load,translog,uuidfrom,last,commit,throws,ioexception,final,map,string,string,commit,user,data,store,read,last,committed,segments,info,get,user,data,if,commit,user,data,contains,key,translog,false,throw,new,illegal,state,exception,commit,doesn,t,contain,translog,generation,id,return,commit,user,data,get,translog
InternalEngine -> @Nullable     private String loadTranslogUUIDFromLastCommit() throws IOException;1544322276;Reads the current stored translog ID from the last commit data.;@Nullable_    private String loadTranslogUUIDFromLastCommit() throws IOException {_        final Map<String, String> commitUserData = store.readLastCommittedSegmentsInfo().getUserData()__        if (commitUserData.containsKey(Translog.TRANSLOG_GENERATION_KEY) == false) {_            throw new IllegalStateException("commit doesn't contain translog generation id")__        }_        return commitUserData.get(Translog.TRANSLOG_UUID_KEY)__    };reads,the,current,stored,translog,id,from,the,last,commit,data;nullable,private,string,load,translog,uuidfrom,last,commit,throws,ioexception,final,map,string,string,commit,user,data,store,read,last,committed,segments,info,get,user,data,if,commit,user,data,contains,key,translog,false,throw,new,illegal,state,exception,commit,doesn,t,contain,translog,generation,id,return,commit,user,data,get,translog
InternalEngine -> @Nullable     private String loadTranslogUUIDFromLastCommit() throws IOException;1544545090;Reads the current stored translog ID from the last commit data.;@Nullable_    private String loadTranslogUUIDFromLastCommit() throws IOException {_        final Map<String, String> commitUserData = store.readLastCommittedSegmentsInfo().getUserData()__        if (commitUserData.containsKey(Translog.TRANSLOG_GENERATION_KEY) == false) {_            throw new IllegalStateException("commit doesn't contain translog generation id")__        }_        return commitUserData.get(Translog.TRANSLOG_UUID_KEY)__    };reads,the,current,stored,translog,id,from,the,last,commit,data;nullable,private,string,load,translog,uuidfrom,last,commit,throws,ioexception,final,map,string,string,commit,user,data,store,read,last,committed,segments,info,get,user,data,if,commit,user,data,contains,key,translog,false,throw,new,illegal,state,exception,commit,doesn,t,contain,translog,generation,id,return,commit,user,data,get,translog
InternalEngine -> @Nullable     private String loadTranslogUUIDFromLastCommit() throws IOException;1544684920;Reads the current stored translog ID from the last commit data.;@Nullable_    private String loadTranslogUUIDFromLastCommit() throws IOException {_        final Map<String, String> commitUserData = store.readLastCommittedSegmentsInfo().getUserData()__        if (commitUserData.containsKey(Translog.TRANSLOG_GENERATION_KEY) == false) {_            throw new IllegalStateException("commit doesn't contain translog generation id")__        }_        return commitUserData.get(Translog.TRANSLOG_UUID_KEY)__    };reads,the,current,stored,translog,id,from,the,last,commit,data;nullable,private,string,load,translog,uuidfrom,last,commit,throws,ioexception,final,map,string,string,commit,user,data,store,read,last,committed,segments,info,get,user,data,if,commit,user,data,contains,key,translog,false,throw,new,illegal,state,exception,commit,doesn,t,contain,translog,generation,id,return,commit,user,data,get,translog
InternalEngine -> @Nullable     private String loadTranslogUUIDFromLastCommit() throws IOException;1545140118;Reads the current stored translog ID from the last commit data.;@Nullable_    private String loadTranslogUUIDFromLastCommit() throws IOException {_        final Map<String, String> commitUserData = store.readLastCommittedSegmentsInfo().getUserData()__        if (commitUserData.containsKey(Translog.TRANSLOG_GENERATION_KEY) == false) {_            throw new IllegalStateException("commit doesn't contain translog generation id")__        }_        return commitUserData.get(Translog.TRANSLOG_UUID_KEY)__    };reads,the,current,stored,translog,id,from,the,last,commit,data;nullable,private,string,load,translog,uuidfrom,last,commit,throws,ioexception,final,map,string,string,commit,user,data,store,read,last,committed,segments,info,get,user,data,if,commit,user,data,contains,key,translog,false,throw,new,illegal,state,exception,commit,doesn,t,contain,translog,generation,id,return,commit,user,data,get,translog
InternalEngine -> @Nullable     private String loadTranslogUUIDFromLastCommit() throws IOException;1546875837;Reads the current stored translog ID from the last commit data.;@Nullable_    private String loadTranslogUUIDFromLastCommit() throws IOException {_        final Map<String, String> commitUserData = store.readLastCommittedSegmentsInfo().getUserData()__        if (commitUserData.containsKey(Translog.TRANSLOG_GENERATION_KEY) == false) {_            throw new IllegalStateException("commit doesn't contain translog generation id")__        }_        return commitUserData.get(Translog.TRANSLOG_UUID_KEY)__    };reads,the,current,stored,translog,id,from,the,last,commit,data;nullable,private,string,load,translog,uuidfrom,last,commit,throws,ioexception,final,map,string,string,commit,user,data,store,read,last,committed,segments,info,get,user,data,if,commit,user,data,contains,key,translog,false,throw,new,illegal,state,exception,commit,doesn,t,contain,translog,generation,id,return,commit,user,data,get,translog
InternalEngine -> @Nullable     private String loadTranslogUUIDFromLastCommit() throws IOException;1547332999;Reads the current stored translog ID from the last commit data.;@Nullable_    private String loadTranslogUUIDFromLastCommit() throws IOException {_        final Map<String, String> commitUserData = store.readLastCommittedSegmentsInfo().getUserData()__        if (commitUserData.containsKey(Translog.TRANSLOG_GENERATION_KEY) == false) {_            throw new IllegalStateException("commit doesn't contain translog generation id")__        }_        return commitUserData.get(Translog.TRANSLOG_UUID_KEY)__    };reads,the,current,stored,translog,id,from,the,last,commit,data;nullable,private,string,load,translog,uuidfrom,last,commit,throws,ioexception,final,map,string,string,commit,user,data,store,read,last,committed,segments,info,get,user,data,if,commit,user,data,contains,key,translog,false,throw,new,illegal,state,exception,commit,doesn,t,contain,translog,generation,id,return,commit,user,data,get,translog
InternalEngine -> @Nullable     private String loadTranslogUUIDFromLastCommit() throws IOException;1548771485;Reads the current stored translog ID from the last commit data.;@Nullable_    private String loadTranslogUUIDFromLastCommit() throws IOException {_        final Map<String, String> commitUserData = store.readLastCommittedSegmentsInfo().getUserData()__        if (commitUserData.containsKey(Translog.TRANSLOG_GENERATION_KEY) == false) {_            throw new IllegalStateException("commit doesn't contain translog generation id")__        }_        return commitUserData.get(Translog.TRANSLOG_UUID_KEY)__    };reads,the,current,stored,translog,id,from,the,last,commit,data;nullable,private,string,load,translog,uuidfrom,last,commit,throws,ioexception,final,map,string,string,commit,user,data,store,read,last,committed,segments,info,get,user,data,if,commit,user,data,contains,key,translog,false,throw,new,illegal,state,exception,commit,doesn,t,contain,translog,generation,id,return,commit,user,data,get,translog
InternalEngine -> @Nullable     private String loadTranslogUUIDFromLastCommit() throws IOException;1549059559;Reads the current stored translog ID from the last commit data.;@Nullable_    private String loadTranslogUUIDFromLastCommit() throws IOException {_        final Map<String, String> commitUserData = store.readLastCommittedSegmentsInfo().getUserData()__        if (commitUserData.containsKey(Translog.TRANSLOG_GENERATION_KEY) == false) {_            throw new IllegalStateException("commit doesn't contain translog generation id")__        }_        return commitUserData.get(Translog.TRANSLOG_UUID_KEY)__    };reads,the,current,stored,translog,id,from,the,last,commit,data;nullable,private,string,load,translog,uuidfrom,last,commit,throws,ioexception,final,map,string,string,commit,user,data,store,read,last,committed,segments,info,get,user,data,if,commit,user,data,contains,key,translog,false,throw,new,illegal,state,exception,commit,doesn,t,contain,translog,generation,id,return,commit,user,data,get,translog
InternalEngine -> @Nullable     private String loadTranslogUUIDFromLastCommit() throws IOException;1549663373;Reads the current stored translog ID from the last commit data.;@Nullable_    private String loadTranslogUUIDFromLastCommit() throws IOException {_        final Map<String, String> commitUserData = store.readLastCommittedSegmentsInfo().getUserData()__        if (commitUserData.containsKey(Translog.TRANSLOG_GENERATION_KEY) == false) {_            throw new IllegalStateException("commit doesn't contain translog generation id")__        }_        return commitUserData.get(Translog.TRANSLOG_UUID_KEY)__    };reads,the,current,stored,translog,id,from,the,last,commit,data;nullable,private,string,load,translog,uuidfrom,last,commit,throws,ioexception,final,map,string,string,commit,user,data,store,read,last,committed,segments,info,get,user,data,if,commit,user,data,contains,key,translog,false,throw,new,illegal,state,exception,commit,doesn,t,contain,translog,generation,id,return,commit,user,data,get,translog
InternalEngine -> @Nullable     private String loadTranslogUUIDFromLastCommit() throws IOException;1549975032;Reads the current stored translog ID from the last commit data.;@Nullable_    private String loadTranslogUUIDFromLastCommit() throws IOException {_        final Map<String, String> commitUserData = store.readLastCommittedSegmentsInfo().getUserData()__        if (commitUserData.containsKey(Translog.TRANSLOG_GENERATION_KEY) == false) {_            throw new IllegalStateException("commit doesn't contain translog generation id")__        }_        return commitUserData.get(Translog.TRANSLOG_UUID_KEY)__    };reads,the,current,stored,translog,id,from,the,last,commit,data;nullable,private,string,load,translog,uuidfrom,last,commit,throws,ioexception,final,map,string,string,commit,user,data,store,read,last,committed,segments,info,get,user,data,if,commit,user,data,contains,key,translog,false,throw,new,illegal,state,exception,commit,doesn,t,contain,translog,generation,id,return,commit,user,data,get,translog
InternalEngine -> @Nullable     private String loadTranslogUUIDFromLastCommit() throws IOException;1550220204;Reads the current stored translog ID from the last commit data.;@Nullable_    private String loadTranslogUUIDFromLastCommit() throws IOException {_        final Map<String, String> commitUserData = store.readLastCommittedSegmentsInfo().getUserData()__        if (commitUserData.containsKey(Translog.TRANSLOG_GENERATION_KEY) == false) {_            throw new IllegalStateException("commit doesn't contain translog generation id")__        }_        return commitUserData.get(Translog.TRANSLOG_UUID_KEY)__    };reads,the,current,stored,translog,id,from,the,last,commit,data;nullable,private,string,load,translog,uuidfrom,last,commit,throws,ioexception,final,map,string,string,commit,user,data,store,read,last,committed,segments,info,get,user,data,if,commit,user,data,contains,key,translog,false,throw,new,illegal,state,exception,commit,doesn,t,contain,translog,generation,id,return,commit,user,data,get,translog
InternalEngine -> @Nullable     private String loadTranslogUUIDFromLastCommit() throws IOException;1550256122;Reads the current stored translog ID from the last commit data.;@Nullable_    private String loadTranslogUUIDFromLastCommit() throws IOException {_        final Map<String, String> commitUserData = store.readLastCommittedSegmentsInfo().getUserData()__        if (commitUserData.containsKey(Translog.TRANSLOG_GENERATION_KEY) == false) {_            throw new IllegalStateException("commit doesn't contain translog generation id")__        }_        return commitUserData.get(Translog.TRANSLOG_UUID_KEY)__    };reads,the,current,stored,translog,id,from,the,last,commit,data;nullable,private,string,load,translog,uuidfrom,last,commit,throws,ioexception,final,map,string,string,commit,user,data,store,read,last,committed,segments,info,get,user,data,if,commit,user,data,contains,key,translog,false,throw,new,illegal,state,exception,commit,doesn,t,contain,translog,generation,id,return,commit,user,data,get,translog
InternalEngine -> @Nullable     private String loadTranslogUUIDFromLastCommit() throws IOException;1550342051;Reads the current stored translog ID from the last commit data.;@Nullable_    private String loadTranslogUUIDFromLastCommit() throws IOException {_        final Map<String, String> commitUserData = store.readLastCommittedSegmentsInfo().getUserData()__        if (commitUserData.containsKey(Translog.TRANSLOG_GENERATION_KEY) == false) {_            throw new IllegalStateException("commit doesn't contain translog generation id")__        }_        return commitUserData.get(Translog.TRANSLOG_UUID_KEY)__    };reads,the,current,stored,translog,id,from,the,last,commit,data;nullable,private,string,load,translog,uuidfrom,last,commit,throws,ioexception,final,map,string,string,commit,user,data,store,read,last,committed,segments,info,get,user,data,if,commit,user,data,contains,key,translog,false,throw,new,illegal,state,exception,commit,doesn,t,contain,translog,generation,id,return,commit,user,data,get,translog
InternalEngine -> @Nullable     private String loadTranslogUUIDFromLastCommit() throws IOException;1550526771;Reads the current stored translog ID from the last commit data.;@Nullable_    private String loadTranslogUUIDFromLastCommit() throws IOException {_        final Map<String, String> commitUserData = store.readLastCommittedSegmentsInfo().getUserData()__        if (commitUserData.containsKey(Translog.TRANSLOG_GENERATION_KEY) == false) {_            throw new IllegalStateException("commit doesn't contain translog generation id")__        }_        return commitUserData.get(Translog.TRANSLOG_UUID_KEY)__    };reads,the,current,stored,translog,id,from,the,last,commit,data;nullable,private,string,load,translog,uuidfrom,last,commit,throws,ioexception,final,map,string,string,commit,user,data,store,read,last,committed,segments,info,get,user,data,if,commit,user,data,contains,key,translog,false,throw,new,illegal,state,exception,commit,doesn,t,contain,translog,generation,id,return,commit,user,data,get,translog
InternalEngine -> @Nullable     private String loadTranslogUUIDFromLastCommit() throws IOException;1551110274;Reads the current stored translog ID from the last commit data.;@Nullable_    private String loadTranslogUUIDFromLastCommit() throws IOException {_        final Map<String, String> commitUserData = store.readLastCommittedSegmentsInfo().getUserData()__        if (commitUserData.containsKey(Translog.TRANSLOG_GENERATION_KEY) == false) {_            throw new IllegalStateException("commit doesn't contain translog generation id")__        }_        return commitUserData.get(Translog.TRANSLOG_UUID_KEY)__    };reads,the,current,stored,translog,id,from,the,last,commit,data;nullable,private,string,load,translog,uuidfrom,last,commit,throws,ioexception,final,map,string,string,commit,user,data,store,read,last,committed,segments,info,get,user,data,if,commit,user,data,contains,key,translog,false,throw,new,illegal,state,exception,commit,doesn,t,contain,translog,generation,id,return,commit,user,data,get,translog
InternalEngine -> @Nullable     private String loadTranslogUUIDFromLastCommit() throws IOException;1551126708;Reads the current stored translog ID from the last commit data.;@Nullable_    private String loadTranslogUUIDFromLastCommit() throws IOException {_        final Map<String, String> commitUserData = store.readLastCommittedSegmentsInfo().getUserData()__        if (commitUserData.containsKey(Translog.TRANSLOG_GENERATION_KEY) == false) {_            throw new IllegalStateException("commit doesn't contain translog generation id")__        }_        return commitUserData.get(Translog.TRANSLOG_UUID_KEY)__    };reads,the,current,stored,translog,id,from,the,last,commit,data;nullable,private,string,load,translog,uuidfrom,last,commit,throws,ioexception,final,map,string,string,commit,user,data,store,read,last,committed,segments,info,get,user,data,if,commit,user,data,contains,key,translog,false,throw,new,illegal,state,exception,commit,doesn,t,contain,translog,generation,id,return,commit,user,data,get,translog
InternalEngine -> protected final void markSeqNoAsSeen(long seqNo);1550256122;Marks the given seq_no as seen and advances the max_seq_no of this engine to at least that value.;protected final void markSeqNoAsSeen(long seqNo) {_        localCheckpointTracker.advanceMaxSeqNo(seqNo)__    };marks,the,given,as,seen,and,advances,the,of,this,engine,to,at,least,that,value;protected,final,void,mark,seq,no,as,seen,long,seq,no,local,checkpoint,tracker,advance,max,seq,no,seq,no
InternalEngine -> protected final void markSeqNoAsSeen(long seqNo);1550342051;Marks the given seq_no as seen and advances the max_seq_no of this engine to at least that value.;protected final void markSeqNoAsSeen(long seqNo) {_        localCheckpointTracker.advanceMaxSeqNo(seqNo)__    };marks,the,given,as,seen,and,advances,the,of,this,engine,to,at,least,that,value;protected,final,void,mark,seq,no,as,seen,long,seq,no,local,checkpoint,tracker,advance,max,seq,no,seq,no
InternalEngine -> protected final void markSeqNoAsSeen(long seqNo);1550526771;Marks the given seq_no as seen and advances the max_seq_no of this engine to at least that value.;protected final void markSeqNoAsSeen(long seqNo) {_        localCheckpointTracker.advanceMaxSeqNo(seqNo)__    };marks,the,given,as,seen,and,advances,the,of,this,engine,to,at,least,that,value;protected,final,void,mark,seq,no,as,seen,long,seq,no,local,checkpoint,tracker,advance,max,seq,no,seq,no
InternalEngine -> protected final void markSeqNoAsSeen(long seqNo);1551110274;Marks the given seq_no as seen and advances the max_seq_no of this engine to at least that value.;protected final void markSeqNoAsSeen(long seqNo) {_        localCheckpointTracker.advanceMaxSeqNo(seqNo)__    };marks,the,given,as,seen,and,advances,the,of,this,engine,to,at,least,that,value;protected,final,void,mark,seq,no,as,seen,long,seq,no,local,checkpoint,tracker,advance,max,seq,no,seq,no
InternalEngine -> protected final void markSeqNoAsSeen(long seqNo);1551126708;Marks the given seq_no as seen and advances the max_seq_no of this engine to at least that value.;protected final void markSeqNoAsSeen(long seqNo) {_        localCheckpointTracker.advanceMaxSeqNo(seqNo)__    };marks,the,given,as,seen,and,advances,the,of,this,engine,to,at,least,that,value;protected,final,void,mark,seq,no,as,seen,long,seq,no,local,checkpoint,tracker,advance,max,seq,no,seq,no
InternalEngine -> private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException;1524684173;Asserts that the doc in the index operation really doesn't exist;private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException {_        _        _        final VersionValue versionValue = versionMap.getVersionForAssert(index.uid().bytes())__        if (versionValue != null) {_            if (versionValue.isDelete() == false || allowDeleted == false) {_                throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists in version map (version " + versionValue + ")")__            }_        } else {_            try (Searcher searcher = acquireSearcher("assert doc doesn't exist", SearcherScope.INTERNAL)) {_                final long docsWithId = searcher.searcher().count(new TermQuery(index.uid()))__                if (docsWithId > 0) {_                    throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists [" + docsWithId + "] times in index")__                }_            }_        }_        return true__    };asserts,that,the,doc,in,the,index,operation,really,doesn,t,exist;private,boolean,assert,doc,does,not,exist,final,index,index,final,boolean,allow,deleted,throws,ioexception,final,version,value,version,value,version,map,get,version,for,assert,index,uid,bytes,if,version,value,null,if,version,value,is,delete,false,allow,deleted,false,throw,new,assertion,error,doc,index,type,index,id,exists,in,version,map,version,version,value,else,try,searcher,searcher,acquire,searcher,assert,doc,doesn,t,exist,searcher,scope,internal,final,long,docs,with,id,searcher,searcher,count,new,term,query,index,uid,if,docs,with,id,0,throw,new,assertion,error,doc,index,type,index,id,exists,docs,with,id,times,in,index,return,true
InternalEngine -> private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException;1524780945;Asserts that the doc in the index operation really doesn't exist;private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException {_        _        _        final VersionValue versionValue = versionMap.getVersionForAssert(index.uid().bytes())__        if (versionValue != null) {_            if (versionValue.isDelete() == false || allowDeleted == false) {_                throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists in version map (version " + versionValue + ")")__            }_        } else {_            try (Searcher searcher = acquireSearcher("assert doc doesn't exist", SearcherScope.INTERNAL)) {_                final long docsWithId = searcher.searcher().count(new TermQuery(index.uid()))__                if (docsWithId > 0) {_                    throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists [" + docsWithId + "] times in index")__                }_            }_        }_        return true__    };asserts,that,the,doc,in,the,index,operation,really,doesn,t,exist;private,boolean,assert,doc,does,not,exist,final,index,index,final,boolean,allow,deleted,throws,ioexception,final,version,value,version,value,version,map,get,version,for,assert,index,uid,bytes,if,version,value,null,if,version,value,is,delete,false,allow,deleted,false,throw,new,assertion,error,doc,index,type,index,id,exists,in,version,map,version,version,value,else,try,searcher,searcher,acquire,searcher,assert,doc,doesn,t,exist,searcher,scope,internal,final,long,docs,with,id,searcher,searcher,count,new,term,query,index,uid,if,docs,with,id,0,throw,new,assertion,error,doc,index,type,index,id,exists,docs,with,id,times,in,index,return,true
InternalEngine -> private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException;1525162917;Asserts that the doc in the index operation really doesn't exist;private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException {_        _        _        final VersionValue versionValue = versionMap.getVersionForAssert(index.uid().bytes())__        if (versionValue != null) {_            if (versionValue.isDelete() == false || allowDeleted == false) {_                throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists in version map (version " + versionValue + ")")__            }_        } else {_            try (Searcher searcher = acquireSearcher("assert doc doesn't exist", SearcherScope.INTERNAL)) {_                final long docsWithId = searcher.searcher().count(new TermQuery(index.uid()))__                if (docsWithId > 0) {_                    throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists [" + docsWithId + "] times in index")__                }_            }_        }_        return true__    };asserts,that,the,doc,in,the,index,operation,really,doesn,t,exist;private,boolean,assert,doc,does,not,exist,final,index,index,final,boolean,allow,deleted,throws,ioexception,final,version,value,version,value,version,map,get,version,for,assert,index,uid,bytes,if,version,value,null,if,version,value,is,delete,false,allow,deleted,false,throw,new,assertion,error,doc,index,type,index,id,exists,in,version,map,version,version,value,else,try,searcher,searcher,acquire,searcher,assert,doc,doesn,t,exist,searcher,scope,internal,final,long,docs,with,id,searcher,searcher,count,new,term,query,index,uid,if,docs,with,id,0,throw,new,assertion,error,doc,index,type,index,id,exists,docs,with,id,times,in,index,return,true
InternalEngine -> private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException;1528706846;Asserts that the doc in the index operation really doesn't exist;private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException {_        _        _        final VersionValue versionValue = versionMap.getVersionForAssert(index.uid().bytes())__        if (versionValue != null) {_            if (versionValue.isDelete() == false || allowDeleted == false) {_                throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists in version map (version " + versionValue + ")")__            }_        } else {_            try (Searcher searcher = acquireSearcher("assert doc doesn't exist", SearcherScope.INTERNAL)) {_                final long docsWithId = searcher.searcher().count(new TermQuery(index.uid()))__                if (docsWithId > 0) {_                    throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists [" + docsWithId + "] times in index")__                }_            }_        }_        return true__    };asserts,that,the,doc,in,the,index,operation,really,doesn,t,exist;private,boolean,assert,doc,does,not,exist,final,index,index,final,boolean,allow,deleted,throws,ioexception,final,version,value,version,value,version,map,get,version,for,assert,index,uid,bytes,if,version,value,null,if,version,value,is,delete,false,allow,deleted,false,throw,new,assertion,error,doc,index,type,index,id,exists,in,version,map,version,version,value,else,try,searcher,searcher,acquire,searcher,assert,doc,doesn,t,exist,searcher,scope,internal,final,long,docs,with,id,searcher,searcher,count,new,term,query,index,uid,if,docs,with,id,0,throw,new,assertion,error,doc,index,type,index,id,exists,docs,with,id,times,in,index,return,true
InternalEngine -> private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException;1528762805;Asserts that the doc in the index operation really doesn't exist;private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException {_        _        _        final VersionValue versionValue = versionMap.getVersionForAssert(index.uid().bytes())__        if (versionValue != null) {_            if (versionValue.isDelete() == false || allowDeleted == false) {_                throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists in version map (version " + versionValue + ")")__            }_        } else {_            try (Searcher searcher = acquireSearcher("assert doc doesn't exist", SearcherScope.INTERNAL)) {_                final long docsWithId = searcher.searcher().count(new TermQuery(index.uid()))__                if (docsWithId > 0) {_                    throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists [" + docsWithId + "] times in index")__                }_            }_        }_        return true__    };asserts,that,the,doc,in,the,index,operation,really,doesn,t,exist;private,boolean,assert,doc,does,not,exist,final,index,index,final,boolean,allow,deleted,throws,ioexception,final,version,value,version,value,version,map,get,version,for,assert,index,uid,bytes,if,version,value,null,if,version,value,is,delete,false,allow,deleted,false,throw,new,assertion,error,doc,index,type,index,id,exists,in,version,map,version,version,value,else,try,searcher,searcher,acquire,searcher,assert,doc,doesn,t,exist,searcher,scope,internal,final,long,docs,with,id,searcher,searcher,count,new,term,query,index,uid,if,docs,with,id,0,throw,new,assertion,error,doc,index,type,index,id,exists,docs,with,id,times,in,index,return,true
InternalEngine -> private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException;1531910483;Asserts that the doc in the index operation really doesn't exist;private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException {_        _        _        final VersionValue versionValue = versionMap.getVersionForAssert(index.uid().bytes())__        if (versionValue != null) {_            if (versionValue.isDelete() == false || allowDeleted == false) {_                throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists in version map (version " + versionValue + ")")__            }_        } else {_            try (Searcher searcher = acquireSearcher("assert doc doesn't exist", SearcherScope.INTERNAL)) {_                final long docsWithId = searcher.searcher().count(new TermQuery(index.uid()))__                if (docsWithId > 0) {_                    throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists [" + docsWithId + "] times in index")__                }_            }_        }_        return true__    };asserts,that,the,doc,in,the,index,operation,really,doesn,t,exist;private,boolean,assert,doc,does,not,exist,final,index,index,final,boolean,allow,deleted,throws,ioexception,final,version,value,version,value,version,map,get,version,for,assert,index,uid,bytes,if,version,value,null,if,version,value,is,delete,false,allow,deleted,false,throw,new,assertion,error,doc,index,type,index,id,exists,in,version,map,version,version,value,else,try,searcher,searcher,acquire,searcher,assert,doc,doesn,t,exist,searcher,scope,internal,final,long,docs,with,id,searcher,searcher,count,new,term,query,index,uid,if,docs,with,id,0,throw,new,assertion,error,doc,index,type,index,id,exists,docs,with,id,times,in,index,return,true
InternalEngine -> private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException;1533295538;Asserts that the doc in the index operation really doesn't exist;private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException {_        _        _        final VersionValue versionValue = versionMap.getVersionForAssert(index.uid().bytes())__        if (versionValue != null) {_            if (versionValue.isDelete() == false || allowDeleted == false) {_                throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists in version map (version " + versionValue + ")")__            }_        } else {_            try (Searcher searcher = acquireSearcher("assert doc doesn't exist", SearcherScope.INTERNAL)) {_                final long docsWithId = searcher.searcher().count(new TermQuery(index.uid()))__                if (docsWithId > 0) {_                    throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists [" + docsWithId + "] times in index")__                }_            }_        }_        return true__    };asserts,that,the,doc,in,the,index,operation,really,doesn,t,exist;private,boolean,assert,doc,does,not,exist,final,index,index,final,boolean,allow,deleted,throws,ioexception,final,version,value,version,value,version,map,get,version,for,assert,index,uid,bytes,if,version,value,null,if,version,value,is,delete,false,allow,deleted,false,throw,new,assertion,error,doc,index,type,index,id,exists,in,version,map,version,version,value,else,try,searcher,searcher,acquire,searcher,assert,doc,doesn,t,exist,searcher,scope,internal,final,long,docs,with,id,searcher,searcher,count,new,term,query,index,uid,if,docs,with,id,0,throw,new,assertion,error,doc,index,type,index,id,exists,docs,with,id,times,in,index,return,true
InternalEngine -> private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException;1534848846;Asserts that the doc in the index operation really doesn't exist;private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException {_        _        _        final VersionValue versionValue = versionMap.getVersionForAssert(index.uid().bytes())__        if (versionValue != null) {_            if (versionValue.isDelete() == false || allowDeleted == false) {_                throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists in version map (version " + versionValue + ")")__            }_        } else {_            try (Searcher searcher = acquireSearcher("assert doc doesn't exist", SearcherScope.INTERNAL)) {_                final long docsWithId = searcher.searcher().count(new TermQuery(index.uid()))__                if (docsWithId > 0) {_                    throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists [" + docsWithId + "] times in index")__                }_            }_        }_        return true__    };asserts,that,the,doc,in,the,index,operation,really,doesn,t,exist;private,boolean,assert,doc,does,not,exist,final,index,index,final,boolean,allow,deleted,throws,ioexception,final,version,value,version,value,version,map,get,version,for,assert,index,uid,bytes,if,version,value,null,if,version,value,is,delete,false,allow,deleted,false,throw,new,assertion,error,doc,index,type,index,id,exists,in,version,map,version,version,value,else,try,searcher,searcher,acquire,searcher,assert,doc,doesn,t,exist,searcher,scope,internal,final,long,docs,with,id,searcher,searcher,count,new,term,query,index,uid,if,docs,with,id,0,throw,new,assertion,error,doc,index,type,index,id,exists,docs,with,id,times,in,index,return,true
InternalEngine -> private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException;1535046779;Asserts that the doc in the index operation really doesn't exist;private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException {_        _        _        final VersionValue versionValue = versionMap.getVersionForAssert(index.uid().bytes())__        if (versionValue != null) {_            if (versionValue.isDelete() == false || allowDeleted == false) {_                throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists in version map (version " + versionValue + ")")__            }_        } else {_            try (Searcher searcher = acquireSearcher("assert doc doesn't exist", SearcherScope.INTERNAL)) {_                final long docsWithId = searcher.searcher().count(new TermQuery(index.uid()))__                if (docsWithId > 0) {_                    throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists [" + docsWithId + "] times in index")__                }_            }_        }_        return true__    };asserts,that,the,doc,in,the,index,operation,really,doesn,t,exist;private,boolean,assert,doc,does,not,exist,final,index,index,final,boolean,allow,deleted,throws,ioexception,final,version,value,version,value,version,map,get,version,for,assert,index,uid,bytes,if,version,value,null,if,version,value,is,delete,false,allow,deleted,false,throw,new,assertion,error,doc,index,type,index,id,exists,in,version,map,version,version,value,else,try,searcher,searcher,acquire,searcher,assert,doc,doesn,t,exist,searcher,scope,internal,final,long,docs,with,id,searcher,searcher,count,new,term,query,index,uid,if,docs,with,id,0,throw,new,assertion,error,doc,index,type,index,id,exists,docs,with,id,times,in,index,return,true
InternalEngine -> private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException;1535405719;Asserts that the doc in the index operation really doesn't exist;private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException {_        _        _        final VersionValue versionValue = versionMap.getVersionForAssert(index.uid().bytes())__        if (versionValue != null) {_            if (versionValue.isDelete() == false || allowDeleted == false) {_                throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists in version map (version " + versionValue + ")")__            }_        } else {_            try (Searcher searcher = acquireSearcher("assert doc doesn't exist", SearcherScope.INTERNAL)) {_                final long docsWithId = searcher.searcher().count(new TermQuery(index.uid()))__                if (docsWithId > 0) {_                    throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists [" + docsWithId + "] times in index")__                }_            }_        }_        return true__    };asserts,that,the,doc,in,the,index,operation,really,doesn,t,exist;private,boolean,assert,doc,does,not,exist,final,index,index,final,boolean,allow,deleted,throws,ioexception,final,version,value,version,value,version,map,get,version,for,assert,index,uid,bytes,if,version,value,null,if,version,value,is,delete,false,allow,deleted,false,throw,new,assertion,error,doc,index,type,index,id,exists,in,version,map,version,version,value,else,try,searcher,searcher,acquire,searcher,assert,doc,doesn,t,exist,searcher,scope,internal,final,long,docs,with,id,searcher,searcher,count,new,term,query,index,uid,if,docs,with,id,0,throw,new,assertion,error,doc,index,type,index,id,exists,docs,with,id,times,in,index,return,true
InternalEngine -> private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException;1535723122;Asserts that the doc in the index operation really doesn't exist;private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException {_        _        _        final VersionValue versionValue = versionMap.getVersionForAssert(index.uid().bytes())__        if (versionValue != null) {_            if (versionValue.isDelete() == false || allowDeleted == false) {_                throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists in version map (version " + versionValue + ")")__            }_        } else {_            try (Searcher searcher = acquireSearcher("assert doc doesn't exist", SearcherScope.INTERNAL)) {_                final long docsWithId = searcher.searcher().count(new TermQuery(index.uid()))__                if (docsWithId > 0) {_                    throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists [" + docsWithId + "] times in index")__                }_            }_        }_        return true__    };asserts,that,the,doc,in,the,index,operation,really,doesn,t,exist;private,boolean,assert,doc,does,not,exist,final,index,index,final,boolean,allow,deleted,throws,ioexception,final,version,value,version,value,version,map,get,version,for,assert,index,uid,bytes,if,version,value,null,if,version,value,is,delete,false,allow,deleted,false,throw,new,assertion,error,doc,index,type,index,id,exists,in,version,map,version,version,value,else,try,searcher,searcher,acquire,searcher,assert,doc,doesn,t,exist,searcher,scope,internal,final,long,docs,with,id,searcher,searcher,count,new,term,query,index,uid,if,docs,with,id,0,throw,new,assertion,error,doc,index,type,index,id,exists,docs,with,id,times,in,index,return,true
InternalEngine -> private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException;1535965276;Asserts that the doc in the index operation really doesn't exist;private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException {_        _        _        final VersionValue versionValue = versionMap.getVersionForAssert(index.uid().bytes())__        if (versionValue != null) {_            if (versionValue.isDelete() == false || allowDeleted == false) {_                throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists in version map (version " + versionValue + ")")__            }_        } else {_            try (Searcher searcher = acquireSearcher("assert doc doesn't exist", SearcherScope.INTERNAL)) {_                final long docsWithId = searcher.searcher().count(new TermQuery(index.uid()))__                if (docsWithId > 0) {_                    throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists [" + docsWithId + "] times in index")__                }_            }_        }_        return true__    };asserts,that,the,doc,in,the,index,operation,really,doesn,t,exist;private,boolean,assert,doc,does,not,exist,final,index,index,final,boolean,allow,deleted,throws,ioexception,final,version,value,version,value,version,map,get,version,for,assert,index,uid,bytes,if,version,value,null,if,version,value,is,delete,false,allow,deleted,false,throw,new,assertion,error,doc,index,type,index,id,exists,in,version,map,version,version,value,else,try,searcher,searcher,acquire,searcher,assert,doc,doesn,t,exist,searcher,scope,internal,final,long,docs,with,id,searcher,searcher,count,new,term,query,index,uid,if,docs,with,id,0,throw,new,assertion,error,doc,index,type,index,id,exists,docs,with,id,times,in,index,return,true
InternalEngine -> private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException;1536218260;Asserts that the doc in the index operation really doesn't exist;private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException {_        _        _        final VersionValue versionValue = versionMap.getVersionForAssert(index.uid().bytes())__        if (versionValue != null) {_            if (versionValue.isDelete() == false || allowDeleted == false) {_                throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists in version map (version " + versionValue + ")")__            }_        } else {_            try (Searcher searcher = acquireSearcher("assert doc doesn't exist", SearcherScope.INTERNAL)) {_                final long docsWithId = searcher.searcher().count(new TermQuery(index.uid()))__                if (docsWithId > 0) {_                    throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists [" + docsWithId + "] times in index")__                }_            }_        }_        return true__    };asserts,that,the,doc,in,the,index,operation,really,doesn,t,exist;private,boolean,assert,doc,does,not,exist,final,index,index,final,boolean,allow,deleted,throws,ioexception,final,version,value,version,value,version,map,get,version,for,assert,index,uid,bytes,if,version,value,null,if,version,value,is,delete,false,allow,deleted,false,throw,new,assertion,error,doc,index,type,index,id,exists,in,version,map,version,version,value,else,try,searcher,searcher,acquire,searcher,assert,doc,doesn,t,exist,searcher,scope,internal,final,long,docs,with,id,searcher,searcher,count,new,term,query,index,uid,if,docs,with,id,0,throw,new,assertion,error,doc,index,type,index,id,exists,docs,with,id,times,in,index,return,true
InternalEngine -> private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException;1536314350;Asserts that the doc in the index operation really doesn't exist;private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException {_        _        _        final VersionValue versionValue = versionMap.getVersionForAssert(index.uid().bytes())__        if (versionValue != null) {_            if (versionValue.isDelete() == false || allowDeleted == false) {_                throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists in version map (version " + versionValue + ")")__            }_        } else {_            try (Searcher searcher = acquireSearcher("assert doc doesn't exist", SearcherScope.INTERNAL)) {_                final long docsWithId = searcher.searcher().count(new TermQuery(index.uid()))__                if (docsWithId > 0) {_                    throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists [" + docsWithId + "] times in index")__                }_            }_        }_        return true__    };asserts,that,the,doc,in,the,index,operation,really,doesn,t,exist;private,boolean,assert,doc,does,not,exist,final,index,index,final,boolean,allow,deleted,throws,ioexception,final,version,value,version,value,version,map,get,version,for,assert,index,uid,bytes,if,version,value,null,if,version,value,is,delete,false,allow,deleted,false,throw,new,assertion,error,doc,index,type,index,id,exists,in,version,map,version,version,value,else,try,searcher,searcher,acquire,searcher,assert,doc,doesn,t,exist,searcher,scope,internal,final,long,docs,with,id,searcher,searcher,count,new,term,query,index,uid,if,docs,with,id,0,throw,new,assertion,error,doc,index,type,index,id,exists,docs,with,id,times,in,index,return,true
InternalEngine -> private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException;1536828374;Asserts that the doc in the index operation really doesn't exist;private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException {_        _        _        final VersionValue versionValue = versionMap.getVersionForAssert(index.uid().bytes())__        if (versionValue != null) {_            if (versionValue.isDelete() == false || allowDeleted == false) {_                throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists in version map (version " + versionValue + ")")__            }_        } else {_            try (Searcher searcher = acquireSearcher("assert doc doesn't exist", SearcherScope.INTERNAL)) {_                final long docsWithId = searcher.searcher().count(new TermQuery(index.uid()))__                if (docsWithId > 0) {_                    throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists [" + docsWithId + "] times in index")__                }_            }_        }_        return true__    };asserts,that,the,doc,in,the,index,operation,really,doesn,t,exist;private,boolean,assert,doc,does,not,exist,final,index,index,final,boolean,allow,deleted,throws,ioexception,final,version,value,version,value,version,map,get,version,for,assert,index,uid,bytes,if,version,value,null,if,version,value,is,delete,false,allow,deleted,false,throw,new,assertion,error,doc,index,type,index,id,exists,in,version,map,version,version,value,else,try,searcher,searcher,acquire,searcher,assert,doc,doesn,t,exist,searcher,scope,internal,final,long,docs,with,id,searcher,searcher,count,new,term,query,index,uid,if,docs,with,id,0,throw,new,assertion,error,doc,index,type,index,id,exists,docs,with,id,times,in,index,return,true
InternalEngine -> private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException;1537806831;Asserts that the doc in the index operation really doesn't exist;private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException {_        _        _        final VersionValue versionValue = versionMap.getVersionForAssert(index.uid().bytes())__        if (versionValue != null) {_            if (versionValue.isDelete() == false || allowDeleted == false) {_                throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists in version map (version " + versionValue + ")")__            }_        } else {_            try (Searcher searcher = acquireSearcher("assert doc doesn't exist", SearcherScope.INTERNAL)) {_                final long docsWithId = searcher.searcher().count(new TermQuery(index.uid()))__                if (docsWithId > 0) {_                    throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists [" + docsWithId + "] times in index")__                }_            }_        }_        return true__    };asserts,that,the,doc,in,the,index,operation,really,doesn,t,exist;private,boolean,assert,doc,does,not,exist,final,index,index,final,boolean,allow,deleted,throws,ioexception,final,version,value,version,value,version,map,get,version,for,assert,index,uid,bytes,if,version,value,null,if,version,value,is,delete,false,allow,deleted,false,throw,new,assertion,error,doc,index,type,index,id,exists,in,version,map,version,version,value,else,try,searcher,searcher,acquire,searcher,assert,doc,doesn,t,exist,searcher,scope,internal,final,long,docs,with,id,searcher,searcher,count,new,term,query,index,uid,if,docs,with,id,0,throw,new,assertion,error,doc,index,type,index,id,exists,docs,with,id,times,in,index,return,true
InternalEngine -> private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException;1538067637;Asserts that the doc in the index operation really doesn't exist;private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException {_        _        _        final VersionValue versionValue = versionMap.getVersionForAssert(index.uid().bytes())__        if (versionValue != null) {_            if (versionValue.isDelete() == false || allowDeleted == false) {_                throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists in version map (version " + versionValue + ")")__            }_        } else {_            try (Searcher searcher = acquireSearcher("assert doc doesn't exist", SearcherScope.INTERNAL)) {_                final long docsWithId = searcher.searcher().count(new TermQuery(index.uid()))__                if (docsWithId > 0) {_                    throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists [" + docsWithId + "] times in index")__                }_            }_        }_        return true__    };asserts,that,the,doc,in,the,index,operation,really,doesn,t,exist;private,boolean,assert,doc,does,not,exist,final,index,index,final,boolean,allow,deleted,throws,ioexception,final,version,value,version,value,version,map,get,version,for,assert,index,uid,bytes,if,version,value,null,if,version,value,is,delete,false,allow,deleted,false,throw,new,assertion,error,doc,index,type,index,id,exists,in,version,map,version,version,value,else,try,searcher,searcher,acquire,searcher,assert,doc,doesn,t,exist,searcher,scope,internal,final,long,docs,with,id,searcher,searcher,count,new,term,query,index,uid,if,docs,with,id,0,throw,new,assertion,error,doc,index,type,index,id,exists,docs,with,id,times,in,index,return,true
InternalEngine -> private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException;1538424609;Asserts that the doc in the index operation really doesn't exist;private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException {_        _        _        final VersionValue versionValue = versionMap.getVersionForAssert(index.uid().bytes())__        if (versionValue != null) {_            if (versionValue.isDelete() == false || allowDeleted == false) {_                throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists in version map (version " + versionValue + ")")__            }_        } else {_            try (Searcher searcher = acquireSearcher("assert doc doesn't exist", SearcherScope.INTERNAL)) {_                final long docsWithId = searcher.searcher().count(new TermQuery(index.uid()))__                if (docsWithId > 0) {_                    throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists [" + docsWithId + "] times in index")__                }_            }_        }_        return true__    };asserts,that,the,doc,in,the,index,operation,really,doesn,t,exist;private,boolean,assert,doc,does,not,exist,final,index,index,final,boolean,allow,deleted,throws,ioexception,final,version,value,version,value,version,map,get,version,for,assert,index,uid,bytes,if,version,value,null,if,version,value,is,delete,false,allow,deleted,false,throw,new,assertion,error,doc,index,type,index,id,exists,in,version,map,version,version,value,else,try,searcher,searcher,acquire,searcher,assert,doc,doesn,t,exist,searcher,scope,internal,final,long,docs,with,id,searcher,searcher,count,new,term,query,index,uid,if,docs,with,id,0,throw,new,assertion,error,doc,index,type,index,id,exists,docs,with,id,times,in,index,return,true
InternalEngine -> private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException;1539615817;Asserts that the doc in the index operation really doesn't exist;private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException {_        _        _        final VersionValue versionValue = versionMap.getVersionForAssert(index.uid().bytes())__        if (versionValue != null) {_            if (versionValue.isDelete() == false || allowDeleted == false) {_                throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists in version map (version " + versionValue + ")")__            }_        } else {_            try (Searcher searcher = acquireSearcher("assert doc doesn't exist", SearcherScope.INTERNAL)) {_                final long docsWithId = searcher.searcher().count(new TermQuery(index.uid()))__                if (docsWithId > 0) {_                    throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists [" + docsWithId + "] times in index")__                }_            }_        }_        return true__    };asserts,that,the,doc,in,the,index,operation,really,doesn,t,exist;private,boolean,assert,doc,does,not,exist,final,index,index,final,boolean,allow,deleted,throws,ioexception,final,version,value,version,value,version,map,get,version,for,assert,index,uid,bytes,if,version,value,null,if,version,value,is,delete,false,allow,deleted,false,throw,new,assertion,error,doc,index,type,index,id,exists,in,version,map,version,version,value,else,try,searcher,searcher,acquire,searcher,assert,doc,doesn,t,exist,searcher,scope,internal,final,long,docs,with,id,searcher,searcher,count,new,term,query,index,uid,if,docs,with,id,0,throw,new,assertion,error,doc,index,type,index,id,exists,docs,with,id,times,in,index,return,true
InternalEngine -> private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException;1539723533;Asserts that the doc in the index operation really doesn't exist;private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException {_        _        _        final VersionValue versionValue = versionMap.getVersionForAssert(index.uid().bytes())__        if (versionValue != null) {_            if (versionValue.isDelete() == false || allowDeleted == false) {_                throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists in version map (version " + versionValue + ")")__            }_        } else {_            try (Searcher searcher = acquireSearcher("assert doc doesn't exist", SearcherScope.INTERNAL)) {_                final long docsWithId = searcher.searcher().count(new TermQuery(index.uid()))__                if (docsWithId > 0) {_                    throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists [" + docsWithId + "] times in index")__                }_            }_        }_        return true__    };asserts,that,the,doc,in,the,index,operation,really,doesn,t,exist;private,boolean,assert,doc,does,not,exist,final,index,index,final,boolean,allow,deleted,throws,ioexception,final,version,value,version,value,version,map,get,version,for,assert,index,uid,bytes,if,version,value,null,if,version,value,is,delete,false,allow,deleted,false,throw,new,assertion,error,doc,index,type,index,id,exists,in,version,map,version,version,value,else,try,searcher,searcher,acquire,searcher,assert,doc,doesn,t,exist,searcher,scope,internal,final,long,docs,with,id,searcher,searcher,count,new,term,query,index,uid,if,docs,with,id,0,throw,new,assertion,error,doc,index,type,index,id,exists,docs,with,id,times,in,index,return,true
InternalEngine -> private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException;1540238977;Asserts that the doc in the index operation really doesn't exist;private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException {_        _        _        final VersionValue versionValue = versionMap.getVersionForAssert(index.uid().bytes())__        if (versionValue != null) {_            if (versionValue.isDelete() == false || allowDeleted == false) {_                throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists in version map (version " + versionValue + ")")__            }_        } else {_            try (Searcher searcher = acquireSearcher("assert doc doesn't exist", SearcherScope.INTERNAL)) {_                final long docsWithId = searcher.searcher().count(new TermQuery(index.uid()))__                if (docsWithId > 0) {_                    throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists [" + docsWithId + "] times in index")__                }_            }_        }_        return true__    };asserts,that,the,doc,in,the,index,operation,really,doesn,t,exist;private,boolean,assert,doc,does,not,exist,final,index,index,final,boolean,allow,deleted,throws,ioexception,final,version,value,version,value,version,map,get,version,for,assert,index,uid,bytes,if,version,value,null,if,version,value,is,delete,false,allow,deleted,false,throw,new,assertion,error,doc,index,type,index,id,exists,in,version,map,version,version,value,else,try,searcher,searcher,acquire,searcher,assert,doc,doesn,t,exist,searcher,scope,internal,final,long,docs,with,id,searcher,searcher,count,new,term,query,index,uid,if,docs,with,id,0,throw,new,assertion,error,doc,index,type,index,id,exists,docs,with,id,times,in,index,return,true
InternalEngine -> private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException;1541335413;Asserts that the doc in the index operation really doesn't exist;private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException {_        _        _        final VersionValue versionValue = versionMap.getVersionForAssert(index.uid().bytes())__        if (versionValue != null) {_            if (versionValue.isDelete() == false || allowDeleted == false) {_                throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists in version map (version " + versionValue + ")")__            }_        } else {_            try (Searcher searcher = acquireSearcher("assert doc doesn't exist", SearcherScope.INTERNAL)) {_                final long docsWithId = searcher.searcher().count(new TermQuery(index.uid()))__                if (docsWithId > 0) {_                    throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists [" + docsWithId + "] times in index")__                }_            }_        }_        return true__    };asserts,that,the,doc,in,the,index,operation,really,doesn,t,exist;private,boolean,assert,doc,does,not,exist,final,index,index,final,boolean,allow,deleted,throws,ioexception,final,version,value,version,value,version,map,get,version,for,assert,index,uid,bytes,if,version,value,null,if,version,value,is,delete,false,allow,deleted,false,throw,new,assertion,error,doc,index,type,index,id,exists,in,version,map,version,version,value,else,try,searcher,searcher,acquire,searcher,assert,doc,doesn,t,exist,searcher,scope,internal,final,long,docs,with,id,searcher,searcher,count,new,term,query,index,uid,if,docs,with,id,0,throw,new,assertion,error,doc,index,type,index,id,exists,docs,with,id,times,in,index,return,true
InternalEngine -> private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException;1541622390;Asserts that the doc in the index operation really doesn't exist;private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException {_        _        _        final VersionValue versionValue = versionMap.getVersionForAssert(index.uid().bytes())__        if (versionValue != null) {_            if (versionValue.isDelete() == false || allowDeleted == false) {_                throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists in version map (version " + versionValue + ")")__            }_        } else {_            try (Searcher searcher = acquireSearcher("assert doc doesn't exist", SearcherScope.INTERNAL)) {_                final long docsWithId = searcher.searcher().count(new TermQuery(index.uid()))__                if (docsWithId > 0) {_                    throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists [" + docsWithId + "] times in index")__                }_            }_        }_        return true__    };asserts,that,the,doc,in,the,index,operation,really,doesn,t,exist;private,boolean,assert,doc,does,not,exist,final,index,index,final,boolean,allow,deleted,throws,ioexception,final,version,value,version,value,version,map,get,version,for,assert,index,uid,bytes,if,version,value,null,if,version,value,is,delete,false,allow,deleted,false,throw,new,assertion,error,doc,index,type,index,id,exists,in,version,map,version,version,value,else,try,searcher,searcher,acquire,searcher,assert,doc,doesn,t,exist,searcher,scope,internal,final,long,docs,with,id,searcher,searcher,count,new,term,query,index,uid,if,docs,with,id,0,throw,new,assertion,error,doc,index,type,index,id,exists,docs,with,id,times,in,index,return,true
InternalEngine -> private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException;1542697754;Asserts that the doc in the index operation really doesn't exist;private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException {_        _        _        final VersionValue versionValue = versionMap.getVersionForAssert(index.uid().bytes())__        if (versionValue != null) {_            if (versionValue.isDelete() == false || allowDeleted == false) {_                throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists in version map (version " +_                    versionValue + ")")__            }_        } else {_            try (Searcher searcher = acquireSearcher("assert doc doesn't exist", SearcherScope.INTERNAL)) {_                final long docsWithId = searcher.searcher().count(new TermQuery(index.uid()))__                if (docsWithId > 0) {_                    throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists [" + docsWithId +_                        "] times in index")__                }_            }_        }_        return true__    };asserts,that,the,doc,in,the,index,operation,really,doesn,t,exist;private,boolean,assert,doc,does,not,exist,final,index,index,final,boolean,allow,deleted,throws,ioexception,final,version,value,version,value,version,map,get,version,for,assert,index,uid,bytes,if,version,value,null,if,version,value,is,delete,false,allow,deleted,false,throw,new,assertion,error,doc,index,type,index,id,exists,in,version,map,version,version,value,else,try,searcher,searcher,acquire,searcher,assert,doc,doesn,t,exist,searcher,scope,internal,final,long,docs,with,id,searcher,searcher,count,new,term,query,index,uid,if,docs,with,id,0,throw,new,assertion,error,doc,index,type,index,id,exists,docs,with,id,times,in,index,return,true
InternalEngine -> private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException;1543940134;Asserts that the doc in the index operation really doesn't exist;private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException {_        _        _        final VersionValue versionValue = versionMap.getVersionForAssert(index.uid().bytes())__        if (versionValue != null) {_            if (versionValue.isDelete() == false || allowDeleted == false) {_                throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists in version map (version " +_                    versionValue + ")")__            }_        } else {_            try (Searcher searcher = acquireSearcher("assert doc doesn't exist", SearcherScope.INTERNAL)) {_                final long docsWithId = searcher.searcher().count(new TermQuery(index.uid()))__                if (docsWithId > 0) {_                    throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists [" + docsWithId +_                        "] times in index")__                }_            }_        }_        return true__    };asserts,that,the,doc,in,the,index,operation,really,doesn,t,exist;private,boolean,assert,doc,does,not,exist,final,index,index,final,boolean,allow,deleted,throws,ioexception,final,version,value,version,value,version,map,get,version,for,assert,index,uid,bytes,if,version,value,null,if,version,value,is,delete,false,allow,deleted,false,throw,new,assertion,error,doc,index,type,index,id,exists,in,version,map,version,version,value,else,try,searcher,searcher,acquire,searcher,assert,doc,doesn,t,exist,searcher,scope,internal,final,long,docs,with,id,searcher,searcher,count,new,term,query,index,uid,if,docs,with,id,0,throw,new,assertion,error,doc,index,type,index,id,exists,docs,with,id,times,in,index,return,true
InternalEngine -> private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException;1544322276;Asserts that the doc in the index operation really doesn't exist;private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException {_        _        _        final VersionValue versionValue = versionMap.getVersionForAssert(index.uid().bytes())__        if (versionValue != null) {_            if (versionValue.isDelete() == false || allowDeleted == false) {_                throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists in version map (version " +_                    versionValue + ")")__            }_        } else {_            try (Searcher searcher = acquireSearcher("assert doc doesn't exist", SearcherScope.INTERNAL)) {_                final long docsWithId = searcher.searcher().count(new TermQuery(index.uid()))__                if (docsWithId > 0) {_                    throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists [" + docsWithId +_                        "] times in index")__                }_            }_        }_        return true__    };asserts,that,the,doc,in,the,index,operation,really,doesn,t,exist;private,boolean,assert,doc,does,not,exist,final,index,index,final,boolean,allow,deleted,throws,ioexception,final,version,value,version,value,version,map,get,version,for,assert,index,uid,bytes,if,version,value,null,if,version,value,is,delete,false,allow,deleted,false,throw,new,assertion,error,doc,index,type,index,id,exists,in,version,map,version,version,value,else,try,searcher,searcher,acquire,searcher,assert,doc,doesn,t,exist,searcher,scope,internal,final,long,docs,with,id,searcher,searcher,count,new,term,query,index,uid,if,docs,with,id,0,throw,new,assertion,error,doc,index,type,index,id,exists,docs,with,id,times,in,index,return,true
InternalEngine -> private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException;1544545090;Asserts that the doc in the index operation really doesn't exist;private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException {_        _        _        final VersionValue versionValue = versionMap.getVersionForAssert(index.uid().bytes())__        if (versionValue != null) {_            if (versionValue.isDelete() == false || allowDeleted == false) {_                throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists in version map (version " +_                    versionValue + ")")__            }_        } else {_            try (Searcher searcher = acquireSearcher("assert doc doesn't exist", SearcherScope.INTERNAL)) {_                final long docsWithId = searcher.searcher().count(new TermQuery(index.uid()))__                if (docsWithId > 0) {_                    throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists [" + docsWithId +_                        "] times in index")__                }_            }_        }_        return true__    };asserts,that,the,doc,in,the,index,operation,really,doesn,t,exist;private,boolean,assert,doc,does,not,exist,final,index,index,final,boolean,allow,deleted,throws,ioexception,final,version,value,version,value,version,map,get,version,for,assert,index,uid,bytes,if,version,value,null,if,version,value,is,delete,false,allow,deleted,false,throw,new,assertion,error,doc,index,type,index,id,exists,in,version,map,version,version,value,else,try,searcher,searcher,acquire,searcher,assert,doc,doesn,t,exist,searcher,scope,internal,final,long,docs,with,id,searcher,searcher,count,new,term,query,index,uid,if,docs,with,id,0,throw,new,assertion,error,doc,index,type,index,id,exists,docs,with,id,times,in,index,return,true
InternalEngine -> private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException;1544684920;Asserts that the doc in the index operation really doesn't exist;private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException {_        _        _        final VersionValue versionValue = versionMap.getVersionForAssert(index.uid().bytes())__        if (versionValue != null) {_            if (versionValue.isDelete() == false || allowDeleted == false) {_                throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists in version map (version " +_                    versionValue + ")")__            }_        } else {_            try (Searcher searcher = acquireSearcher("assert doc doesn't exist", SearcherScope.INTERNAL)) {_                final long docsWithId = searcher.searcher().count(new TermQuery(index.uid()))__                if (docsWithId > 0) {_                    throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists [" + docsWithId +_                        "] times in index")__                }_            }_        }_        return true__    };asserts,that,the,doc,in,the,index,operation,really,doesn,t,exist;private,boolean,assert,doc,does,not,exist,final,index,index,final,boolean,allow,deleted,throws,ioexception,final,version,value,version,value,version,map,get,version,for,assert,index,uid,bytes,if,version,value,null,if,version,value,is,delete,false,allow,deleted,false,throw,new,assertion,error,doc,index,type,index,id,exists,in,version,map,version,version,value,else,try,searcher,searcher,acquire,searcher,assert,doc,doesn,t,exist,searcher,scope,internal,final,long,docs,with,id,searcher,searcher,count,new,term,query,index,uid,if,docs,with,id,0,throw,new,assertion,error,doc,index,type,index,id,exists,docs,with,id,times,in,index,return,true
InternalEngine -> private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException;1545140118;Asserts that the doc in the index operation really doesn't exist;private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException {_        _        _        final VersionValue versionValue = versionMap.getVersionForAssert(index.uid().bytes())__        if (versionValue != null) {_            if (versionValue.isDelete() == false || allowDeleted == false) {_                throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists in version map (version " +_                    versionValue + ")")__            }_        } else {_            try (Searcher searcher = acquireSearcher("assert doc doesn't exist", SearcherScope.INTERNAL)) {_                final long docsWithId = searcher.searcher().count(new TermQuery(index.uid()))__                if (docsWithId > 0) {_                    throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists [" + docsWithId +_                        "] times in index")__                }_            }_        }_        return true__    };asserts,that,the,doc,in,the,index,operation,really,doesn,t,exist;private,boolean,assert,doc,does,not,exist,final,index,index,final,boolean,allow,deleted,throws,ioexception,final,version,value,version,value,version,map,get,version,for,assert,index,uid,bytes,if,version,value,null,if,version,value,is,delete,false,allow,deleted,false,throw,new,assertion,error,doc,index,type,index,id,exists,in,version,map,version,version,value,else,try,searcher,searcher,acquire,searcher,assert,doc,doesn,t,exist,searcher,scope,internal,final,long,docs,with,id,searcher,searcher,count,new,term,query,index,uid,if,docs,with,id,0,throw,new,assertion,error,doc,index,type,index,id,exists,docs,with,id,times,in,index,return,true
InternalEngine -> private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException;1546875837;Asserts that the doc in the index operation really doesn't exist;private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException {_        _        _        final VersionValue versionValue = versionMap.getVersionForAssert(index.uid().bytes())__        if (versionValue != null) {_            if (versionValue.isDelete() == false || allowDeleted == false) {_                throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists in version map (version " +_                    versionValue + ")")__            }_        } else {_            try (Searcher searcher = acquireSearcher("assert doc doesn't exist", SearcherScope.INTERNAL)) {_                final long docsWithId = searcher.searcher().count(new TermQuery(index.uid()))__                if (docsWithId > 0) {_                    throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists [" + docsWithId +_                        "] times in index")__                }_            }_        }_        return true__    };asserts,that,the,doc,in,the,index,operation,really,doesn,t,exist;private,boolean,assert,doc,does,not,exist,final,index,index,final,boolean,allow,deleted,throws,ioexception,final,version,value,version,value,version,map,get,version,for,assert,index,uid,bytes,if,version,value,null,if,version,value,is,delete,false,allow,deleted,false,throw,new,assertion,error,doc,index,type,index,id,exists,in,version,map,version,version,value,else,try,searcher,searcher,acquire,searcher,assert,doc,doesn,t,exist,searcher,scope,internal,final,long,docs,with,id,searcher,searcher,count,new,term,query,index,uid,if,docs,with,id,0,throw,new,assertion,error,doc,index,type,index,id,exists,docs,with,id,times,in,index,return,true
InternalEngine -> private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException;1547332999;Asserts that the doc in the index operation really doesn't exist;private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException {_        _        _        final VersionValue versionValue = versionMap.getVersionForAssert(index.uid().bytes())__        if (versionValue != null) {_            if (versionValue.isDelete() == false || allowDeleted == false) {_                throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists in version map (version " +_                    versionValue + ")")__            }_        } else {_            try (Searcher searcher = acquireSearcher("assert doc doesn't exist", SearcherScope.INTERNAL)) {_                final long docsWithId = searcher.searcher().count(new TermQuery(index.uid()))__                if (docsWithId > 0) {_                    throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists [" + docsWithId +_                        "] times in index")__                }_            }_        }_        return true__    };asserts,that,the,doc,in,the,index,operation,really,doesn,t,exist;private,boolean,assert,doc,does,not,exist,final,index,index,final,boolean,allow,deleted,throws,ioexception,final,version,value,version,value,version,map,get,version,for,assert,index,uid,bytes,if,version,value,null,if,version,value,is,delete,false,allow,deleted,false,throw,new,assertion,error,doc,index,type,index,id,exists,in,version,map,version,version,value,else,try,searcher,searcher,acquire,searcher,assert,doc,doesn,t,exist,searcher,scope,internal,final,long,docs,with,id,searcher,searcher,count,new,term,query,index,uid,if,docs,with,id,0,throw,new,assertion,error,doc,index,type,index,id,exists,docs,with,id,times,in,index,return,true
InternalEngine -> private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException;1548771485;Asserts that the doc in the index operation really doesn't exist;private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException {_        _        _        final VersionValue versionValue = versionMap.getVersionForAssert(index.uid().bytes())__        if (versionValue != null) {_            if (versionValue.isDelete() == false || allowDeleted == false) {_                throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists in version map (version " +_                    versionValue + ")")__            }_        } else {_            try (Searcher searcher = acquireSearcher("assert doc doesn't exist", SearcherScope.INTERNAL)) {_                final long docsWithId = searcher.searcher().count(new TermQuery(index.uid()))__                if (docsWithId > 0) {_                    throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists [" + docsWithId +_                        "] times in index")__                }_            }_        }_        return true__    };asserts,that,the,doc,in,the,index,operation,really,doesn,t,exist;private,boolean,assert,doc,does,not,exist,final,index,index,final,boolean,allow,deleted,throws,ioexception,final,version,value,version,value,version,map,get,version,for,assert,index,uid,bytes,if,version,value,null,if,version,value,is,delete,false,allow,deleted,false,throw,new,assertion,error,doc,index,type,index,id,exists,in,version,map,version,version,value,else,try,searcher,searcher,acquire,searcher,assert,doc,doesn,t,exist,searcher,scope,internal,final,long,docs,with,id,searcher,searcher,count,new,term,query,index,uid,if,docs,with,id,0,throw,new,assertion,error,doc,index,type,index,id,exists,docs,with,id,times,in,index,return,true
InternalEngine -> private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException;1549059559;Asserts that the doc in the index operation really doesn't exist;private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException {_        _        _        final VersionValue versionValue = versionMap.getVersionForAssert(index.uid().bytes())__        if (versionValue != null) {_            if (versionValue.isDelete() == false || allowDeleted == false) {_                throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists in version map (version " +_                    versionValue + ")")__            }_        } else {_            try (Searcher searcher = acquireSearcher("assert doc doesn't exist", SearcherScope.INTERNAL)) {_                final long docsWithId = searcher.searcher().count(new TermQuery(index.uid()))__                if (docsWithId > 0) {_                    throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists [" + docsWithId +_                        "] times in index")__                }_            }_        }_        return true__    };asserts,that,the,doc,in,the,index,operation,really,doesn,t,exist;private,boolean,assert,doc,does,not,exist,final,index,index,final,boolean,allow,deleted,throws,ioexception,final,version,value,version,value,version,map,get,version,for,assert,index,uid,bytes,if,version,value,null,if,version,value,is,delete,false,allow,deleted,false,throw,new,assertion,error,doc,index,type,index,id,exists,in,version,map,version,version,value,else,try,searcher,searcher,acquire,searcher,assert,doc,doesn,t,exist,searcher,scope,internal,final,long,docs,with,id,searcher,searcher,count,new,term,query,index,uid,if,docs,with,id,0,throw,new,assertion,error,doc,index,type,index,id,exists,docs,with,id,times,in,index,return,true
InternalEngine -> private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException;1549663373;Asserts that the doc in the index operation really doesn't exist;private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException {_        _        _        final VersionValue versionValue = versionMap.getVersionForAssert(index.uid().bytes())__        if (versionValue != null) {_            if (versionValue.isDelete() == false || allowDeleted == false) {_                throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists in version map (version " +_                    versionValue + ")")__            }_        } else {_            try (Searcher searcher = acquireSearcher("assert doc doesn't exist", SearcherScope.INTERNAL)) {_                final long docsWithId = searcher.searcher().count(new TermQuery(index.uid()))__                if (docsWithId > 0) {_                    throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists [" + docsWithId +_                        "] times in index")__                }_            }_        }_        return true__    };asserts,that,the,doc,in,the,index,operation,really,doesn,t,exist;private,boolean,assert,doc,does,not,exist,final,index,index,final,boolean,allow,deleted,throws,ioexception,final,version,value,version,value,version,map,get,version,for,assert,index,uid,bytes,if,version,value,null,if,version,value,is,delete,false,allow,deleted,false,throw,new,assertion,error,doc,index,type,index,id,exists,in,version,map,version,version,value,else,try,searcher,searcher,acquire,searcher,assert,doc,doesn,t,exist,searcher,scope,internal,final,long,docs,with,id,searcher,searcher,count,new,term,query,index,uid,if,docs,with,id,0,throw,new,assertion,error,doc,index,type,index,id,exists,docs,with,id,times,in,index,return,true
InternalEngine -> private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException;1549975032;Asserts that the doc in the index operation really doesn't exist;private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException {_        _        _        final VersionValue versionValue = versionMap.getVersionForAssert(index.uid().bytes())__        if (versionValue != null) {_            if (versionValue.isDelete() == false || allowDeleted == false) {_                throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists in version map (version " +_                    versionValue + ")")__            }_        } else {_            try (Searcher searcher = acquireSearcher("assert doc doesn't exist", SearcherScope.INTERNAL)) {_                final long docsWithId = searcher.searcher().count(new TermQuery(index.uid()))__                if (docsWithId > 0) {_                    throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists [" + docsWithId +_                        "] times in index")__                }_            }_        }_        return true__    };asserts,that,the,doc,in,the,index,operation,really,doesn,t,exist;private,boolean,assert,doc,does,not,exist,final,index,index,final,boolean,allow,deleted,throws,ioexception,final,version,value,version,value,version,map,get,version,for,assert,index,uid,bytes,if,version,value,null,if,version,value,is,delete,false,allow,deleted,false,throw,new,assertion,error,doc,index,type,index,id,exists,in,version,map,version,version,value,else,try,searcher,searcher,acquire,searcher,assert,doc,doesn,t,exist,searcher,scope,internal,final,long,docs,with,id,searcher,searcher,count,new,term,query,index,uid,if,docs,with,id,0,throw,new,assertion,error,doc,index,type,index,id,exists,docs,with,id,times,in,index,return,true
InternalEngine -> private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException;1550220204;Asserts that the doc in the index operation really doesn't exist;private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException {_        _        _        final VersionValue versionValue = versionMap.getVersionForAssert(index.uid().bytes())__        if (versionValue != null) {_            if (versionValue.isDelete() == false || allowDeleted == false) {_                throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists in version map (version " +_                    versionValue + ")")__            }_        } else {_            try (Searcher searcher = acquireSearcher("assert doc doesn't exist", SearcherScope.INTERNAL)) {_                final long docsWithId = searcher.searcher().count(new TermQuery(index.uid()))__                if (docsWithId > 0) {_                    throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists [" + docsWithId +_                        "] times in index")__                }_            }_        }_        return true__    };asserts,that,the,doc,in,the,index,operation,really,doesn,t,exist;private,boolean,assert,doc,does,not,exist,final,index,index,final,boolean,allow,deleted,throws,ioexception,final,version,value,version,value,version,map,get,version,for,assert,index,uid,bytes,if,version,value,null,if,version,value,is,delete,false,allow,deleted,false,throw,new,assertion,error,doc,index,type,index,id,exists,in,version,map,version,version,value,else,try,searcher,searcher,acquire,searcher,assert,doc,doesn,t,exist,searcher,scope,internal,final,long,docs,with,id,searcher,searcher,count,new,term,query,index,uid,if,docs,with,id,0,throw,new,assertion,error,doc,index,type,index,id,exists,docs,with,id,times,in,index,return,true
InternalEngine -> private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException;1550256122;Asserts that the doc in the index operation really doesn't exist;private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException {_        _        _        final VersionValue versionValue = versionMap.getVersionForAssert(index.uid().bytes())__        if (versionValue != null) {_            if (versionValue.isDelete() == false || allowDeleted == false) {_                throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists in version map (version " +_                    versionValue + ")")__            }_        } else {_            try (Searcher searcher = acquireSearcher("assert doc doesn't exist", SearcherScope.INTERNAL)) {_                final long docsWithId = searcher.searcher().count(new TermQuery(index.uid()))__                if (docsWithId > 0) {_                    throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists [" + docsWithId +_                        "] times in index")__                }_            }_        }_        return true__    };asserts,that,the,doc,in,the,index,operation,really,doesn,t,exist;private,boolean,assert,doc,does,not,exist,final,index,index,final,boolean,allow,deleted,throws,ioexception,final,version,value,version,value,version,map,get,version,for,assert,index,uid,bytes,if,version,value,null,if,version,value,is,delete,false,allow,deleted,false,throw,new,assertion,error,doc,index,type,index,id,exists,in,version,map,version,version,value,else,try,searcher,searcher,acquire,searcher,assert,doc,doesn,t,exist,searcher,scope,internal,final,long,docs,with,id,searcher,searcher,count,new,term,query,index,uid,if,docs,with,id,0,throw,new,assertion,error,doc,index,type,index,id,exists,docs,with,id,times,in,index,return,true
InternalEngine -> private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException;1550342051;Asserts that the doc in the index operation really doesn't exist;private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException {_        _        _        final VersionValue versionValue = versionMap.getVersionForAssert(index.uid().bytes())__        if (versionValue != null) {_            if (versionValue.isDelete() == false || allowDeleted == false) {_                throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists in version map (version " +_                    versionValue + ")")__            }_        } else {_            try (Searcher searcher = acquireSearcher("assert doc doesn't exist", SearcherScope.INTERNAL)) {_                final long docsWithId = searcher.searcher().count(new TermQuery(index.uid()))__                if (docsWithId > 0) {_                    throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists [" + docsWithId +_                        "] times in index")__                }_            }_        }_        return true__    };asserts,that,the,doc,in,the,index,operation,really,doesn,t,exist;private,boolean,assert,doc,does,not,exist,final,index,index,final,boolean,allow,deleted,throws,ioexception,final,version,value,version,value,version,map,get,version,for,assert,index,uid,bytes,if,version,value,null,if,version,value,is,delete,false,allow,deleted,false,throw,new,assertion,error,doc,index,type,index,id,exists,in,version,map,version,version,value,else,try,searcher,searcher,acquire,searcher,assert,doc,doesn,t,exist,searcher,scope,internal,final,long,docs,with,id,searcher,searcher,count,new,term,query,index,uid,if,docs,with,id,0,throw,new,assertion,error,doc,index,type,index,id,exists,docs,with,id,times,in,index,return,true
InternalEngine -> private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException;1550526771;Asserts that the doc in the index operation really doesn't exist;private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException {_        _        _        final VersionValue versionValue = versionMap.getVersionForAssert(index.uid().bytes())__        if (versionValue != null) {_            if (versionValue.isDelete() == false || allowDeleted == false) {_                throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists in version map (version " +_                    versionValue + ")")__            }_        } else {_            try (Searcher searcher = acquireSearcher("assert doc doesn't exist", SearcherScope.INTERNAL)) {_                final long docsWithId = searcher.searcher().count(new TermQuery(index.uid()))__                if (docsWithId > 0) {_                    throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists [" + docsWithId +_                        "] times in index")__                }_            }_        }_        return true__    };asserts,that,the,doc,in,the,index,operation,really,doesn,t,exist;private,boolean,assert,doc,does,not,exist,final,index,index,final,boolean,allow,deleted,throws,ioexception,final,version,value,version,value,version,map,get,version,for,assert,index,uid,bytes,if,version,value,null,if,version,value,is,delete,false,allow,deleted,false,throw,new,assertion,error,doc,index,type,index,id,exists,in,version,map,version,version,value,else,try,searcher,searcher,acquire,searcher,assert,doc,doesn,t,exist,searcher,scope,internal,final,long,docs,with,id,searcher,searcher,count,new,term,query,index,uid,if,docs,with,id,0,throw,new,assertion,error,doc,index,type,index,id,exists,docs,with,id,times,in,index,return,true
InternalEngine -> private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException;1551110274;Asserts that the doc in the index operation really doesn't exist;private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException {_        _        _        final VersionValue versionValue = versionMap.getVersionForAssert(index.uid().bytes())__        if (versionValue != null) {_            if (versionValue.isDelete() == false || allowDeleted == false) {_                throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists in version map (version " +_                    versionValue + ")")__            }_        } else {_            try (Searcher searcher = acquireSearcher("assert doc doesn't exist", SearcherScope.INTERNAL)) {_                final long docsWithId = searcher.searcher().count(new TermQuery(index.uid()))__                if (docsWithId > 0) {_                    throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists [" + docsWithId +_                        "] times in index")__                }_            }_        }_        return true__    };asserts,that,the,doc,in,the,index,operation,really,doesn,t,exist;private,boolean,assert,doc,does,not,exist,final,index,index,final,boolean,allow,deleted,throws,ioexception,final,version,value,version,value,version,map,get,version,for,assert,index,uid,bytes,if,version,value,null,if,version,value,is,delete,false,allow,deleted,false,throw,new,assertion,error,doc,index,type,index,id,exists,in,version,map,version,version,value,else,try,searcher,searcher,acquire,searcher,assert,doc,doesn,t,exist,searcher,scope,internal,final,long,docs,with,id,searcher,searcher,count,new,term,query,index,uid,if,docs,with,id,0,throw,new,assertion,error,doc,index,type,index,id,exists,docs,with,id,times,in,index,return,true
InternalEngine -> private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException;1551126708;Asserts that the doc in the index operation really doesn't exist;private boolean assertDocDoesNotExist(final Index index, final boolean allowDeleted) throws IOException {_        _        _        final VersionValue versionValue = versionMap.getVersionForAssert(index.uid().bytes())__        if (versionValue != null) {_            if (versionValue.isDelete() == false || allowDeleted == false) {_                throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists in version map (version " +_                    versionValue + ")")__            }_        } else {_            try (Searcher searcher = acquireSearcher("assert doc doesn't exist", SearcherScope.INTERNAL)) {_                final long docsWithId = searcher.searcher().count(new TermQuery(index.uid()))__                if (docsWithId > 0) {_                    throw new AssertionError("doc [" + index.type() + "][" + index.id() + "] exists [" + docsWithId +_                        "] times in index")__                }_            }_        }_        return true__    };asserts,that,the,doc,in,the,index,operation,really,doesn,t,exist;private,boolean,assert,doc,does,not,exist,final,index,index,final,boolean,allow,deleted,throws,ioexception,final,version,value,version,value,version,map,get,version,for,assert,index,uid,bytes,if,version,value,null,if,version,value,is,delete,false,allow,deleted,false,throw,new,assertion,error,doc,index,type,index,id,exists,in,version,map,version,version,value,else,try,searcher,searcher,acquire,searcher,assert,doc,doesn,t,exist,searcher,scope,internal,final,long,docs,with,id,searcher,searcher,count,new,term,query,index,uid,if,docs,with,id,0,throw,new,assertion,error,doc,index,type,index,id,exists,docs,with,id,times,in,index,return,true
InternalEngine -> protected Optional<Exception> preFlightCheckForNoOp(final NoOp noOp) throws IOException;1540238977;Executes a pre-flight check for a given NoOp._If this method returns a non-empty result, the engine won't process this NoOp and returns a failure.;protected Optional<Exception> preFlightCheckForNoOp(final NoOp noOp) throws IOException {_        return Optional.empty()__    };executes,a,pre,flight,check,for,a,given,no,op,if,this,method,returns,a,non,empty,result,the,engine,won,t,process,this,no,op,and,returns,a,failure;protected,optional,exception,pre,flight,check,for,no,op,final,no,op,no,op,throws,ioexception,return,optional,empty
InternalEngine -> protected Optional<Exception> preFlightCheckForNoOp(final NoOp noOp) throws IOException;1541335413;Executes a pre-flight check for a given NoOp._If this method returns a non-empty result, the engine won't process this NoOp and returns a failure.;protected Optional<Exception> preFlightCheckForNoOp(final NoOp noOp) throws IOException {_        return Optional.empty()__    };executes,a,pre,flight,check,for,a,given,no,op,if,this,method,returns,a,non,empty,result,the,engine,won,t,process,this,no,op,and,returns,a,failure;protected,optional,exception,pre,flight,check,for,no,op,final,no,op,no,op,throws,ioexception,return,optional,empty
InternalEngine -> protected Optional<Exception> preFlightCheckForNoOp(final NoOp noOp) throws IOException;1541622390;Executes a pre-flight check for a given NoOp._If this method returns a non-empty result, the engine won't process this NoOp and returns a failure.;protected Optional<Exception> preFlightCheckForNoOp(final NoOp noOp) throws IOException {_        return Optional.empty()__    };executes,a,pre,flight,check,for,a,given,no,op,if,this,method,returns,a,non,empty,result,the,engine,won,t,process,this,no,op,and,returns,a,failure;protected,optional,exception,pre,flight,check,for,no,op,final,no,op,no,op,throws,ioexception,return,optional,empty
InternalEngine -> protected Optional<Exception> preFlightCheckForNoOp(final NoOp noOp) throws IOException;1542697754;Executes a pre-flight check for a given NoOp._If this method returns a non-empty result, the engine won't process this NoOp and returns a failure.;protected Optional<Exception> preFlightCheckForNoOp(final NoOp noOp) throws IOException {_        return Optional.empty()__    };executes,a,pre,flight,check,for,a,given,no,op,if,this,method,returns,a,non,empty,result,the,engine,won,t,process,this,no,op,and,returns,a,failure;protected,optional,exception,pre,flight,check,for,no,op,final,no,op,no,op,throws,ioexception,return,optional,empty
InternalEngine -> protected Optional<Exception> preFlightCheckForNoOp(final NoOp noOp) throws IOException;1543940134;Executes a pre-flight check for a given NoOp._If this method returns a non-empty result, the engine won't process this NoOp and returns a failure.;protected Optional<Exception> preFlightCheckForNoOp(final NoOp noOp) throws IOException {_        return Optional.empty()__    };executes,a,pre,flight,check,for,a,given,no,op,if,this,method,returns,a,non,empty,result,the,engine,won,t,process,this,no,op,and,returns,a,failure;protected,optional,exception,pre,flight,check,for,no,op,final,no,op,no,op,throws,ioexception,return,optional,empty
InternalEngine -> protected Optional<Exception> preFlightCheckForNoOp(final NoOp noOp) throws IOException;1544322276;Executes a pre-flight check for a given NoOp._If this method returns a non-empty result, the engine won't process this NoOp and returns a failure.;protected Optional<Exception> preFlightCheckForNoOp(final NoOp noOp) throws IOException {_        return Optional.empty()__    };executes,a,pre,flight,check,for,a,given,no,op,if,this,method,returns,a,non,empty,result,the,engine,won,t,process,this,no,op,and,returns,a,failure;protected,optional,exception,pre,flight,check,for,no,op,final,no,op,no,op,throws,ioexception,return,optional,empty
InternalEngine -> protected Optional<Exception> preFlightCheckForNoOp(final NoOp noOp) throws IOException;1544545090;Executes a pre-flight check for a given NoOp._If this method returns a non-empty result, the engine won't process this NoOp and returns a failure.;protected Optional<Exception> preFlightCheckForNoOp(final NoOp noOp) throws IOException {_        return Optional.empty()__    };executes,a,pre,flight,check,for,a,given,no,op,if,this,method,returns,a,non,empty,result,the,engine,won,t,process,this,no,op,and,returns,a,failure;protected,optional,exception,pre,flight,check,for,no,op,final,no,op,no,op,throws,ioexception,return,optional,empty
InternalEngine -> protected Optional<Exception> preFlightCheckForNoOp(final NoOp noOp) throws IOException;1544684920;Executes a pre-flight check for a given NoOp._If this method returns a non-empty result, the engine won't process this NoOp and returns a failure.;protected Optional<Exception> preFlightCheckForNoOp(final NoOp noOp) throws IOException {_        return Optional.empty()__    };executes,a,pre,flight,check,for,a,given,no,op,if,this,method,returns,a,non,empty,result,the,engine,won,t,process,this,no,op,and,returns,a,failure;protected,optional,exception,pre,flight,check,for,no,op,final,no,op,no,op,throws,ioexception,return,optional,empty
InternalEngine -> protected Optional<Exception> preFlightCheckForNoOp(final NoOp noOp) throws IOException;1545140118;Executes a pre-flight check for a given NoOp._If this method returns a non-empty result, the engine won't process this NoOp and returns a failure.;protected Optional<Exception> preFlightCheckForNoOp(final NoOp noOp) throws IOException {_        return Optional.empty()__    };executes,a,pre,flight,check,for,a,given,no,op,if,this,method,returns,a,non,empty,result,the,engine,won,t,process,this,no,op,and,returns,a,failure;protected,optional,exception,pre,flight,check,for,no,op,final,no,op,no,op,throws,ioexception,return,optional,empty
InternalEngine -> protected Optional<Exception> preFlightCheckForNoOp(final NoOp noOp) throws IOException;1546875837;Executes a pre-flight check for a given NoOp._If this method returns a non-empty result, the engine won't process this NoOp and returns a failure.;protected Optional<Exception> preFlightCheckForNoOp(final NoOp noOp) throws IOException {_        return Optional.empty()__    };executes,a,pre,flight,check,for,a,given,no,op,if,this,method,returns,a,non,empty,result,the,engine,won,t,process,this,no,op,and,returns,a,failure;protected,optional,exception,pre,flight,check,for,no,op,final,no,op,no,op,throws,ioexception,return,optional,empty
InternalEngine -> protected Optional<Exception> preFlightCheckForNoOp(final NoOp noOp) throws IOException;1547332999;Executes a pre-flight check for a given NoOp._If this method returns a non-empty result, the engine won't process this NoOp and returns a failure.;protected Optional<Exception> preFlightCheckForNoOp(final NoOp noOp) throws IOException {_        return Optional.empty()__    };executes,a,pre,flight,check,for,a,given,no,op,if,this,method,returns,a,non,empty,result,the,engine,won,t,process,this,no,op,and,returns,a,failure;protected,optional,exception,pre,flight,check,for,no,op,final,no,op,no,op,throws,ioexception,return,optional,empty
InternalEngine -> protected Optional<Exception> preFlightCheckForNoOp(final NoOp noOp) throws IOException;1548771485;Executes a pre-flight check for a given NoOp._If this method returns a non-empty result, the engine won't process this NoOp and returns a failure.;protected Optional<Exception> preFlightCheckForNoOp(final NoOp noOp) throws IOException {_        return Optional.empty()__    };executes,a,pre,flight,check,for,a,given,no,op,if,this,method,returns,a,non,empty,result,the,engine,won,t,process,this,no,op,and,returns,a,failure;protected,optional,exception,pre,flight,check,for,no,op,final,no,op,no,op,throws,ioexception,return,optional,empty
InternalEngine -> protected Optional<Exception> preFlightCheckForNoOp(final NoOp noOp) throws IOException;1549059559;Executes a pre-flight check for a given NoOp._If this method returns a non-empty result, the engine won't process this NoOp and returns a failure.;protected Optional<Exception> preFlightCheckForNoOp(final NoOp noOp) throws IOException {_        return Optional.empty()__    };executes,a,pre,flight,check,for,a,given,no,op,if,this,method,returns,a,non,empty,result,the,engine,won,t,process,this,no,op,and,returns,a,failure;protected,optional,exception,pre,flight,check,for,no,op,final,no,op,no,op,throws,ioexception,return,optional,empty
InternalEngine -> protected Optional<Exception> preFlightCheckForNoOp(final NoOp noOp) throws IOException;1549663373;Executes a pre-flight check for a given NoOp._If this method returns a non-empty result, the engine won't process this NoOp and returns a failure.;protected Optional<Exception> preFlightCheckForNoOp(final NoOp noOp) throws IOException {_        return Optional.empty()__    };executes,a,pre,flight,check,for,a,given,no,op,if,this,method,returns,a,non,empty,result,the,engine,won,t,process,this,no,op,and,returns,a,failure;protected,optional,exception,pre,flight,check,for,no,op,final,no,op,no,op,throws,ioexception,return,optional,empty
InternalEngine -> protected Optional<Exception> preFlightCheckForNoOp(final NoOp noOp) throws IOException;1549975032;Executes a pre-flight check for a given NoOp._If this method returns a non-empty result, the engine won't process this NoOp and returns a failure.;protected Optional<Exception> preFlightCheckForNoOp(final NoOp noOp) throws IOException {_        return Optional.empty()__    };executes,a,pre,flight,check,for,a,given,no,op,if,this,method,returns,a,non,empty,result,the,engine,won,t,process,this,no,op,and,returns,a,failure;protected,optional,exception,pre,flight,check,for,no,op,final,no,op,no,op,throws,ioexception,return,optional,empty
InternalEngine -> protected Optional<Exception> preFlightCheckForNoOp(final NoOp noOp) throws IOException;1550220204;Executes a pre-flight check for a given NoOp._If this method returns a non-empty result, the engine won't process this NoOp and returns a failure.;protected Optional<Exception> preFlightCheckForNoOp(final NoOp noOp) throws IOException {_        return Optional.empty()__    };executes,a,pre,flight,check,for,a,given,no,op,if,this,method,returns,a,non,empty,result,the,engine,won,t,process,this,no,op,and,returns,a,failure;protected,optional,exception,pre,flight,check,for,no,op,final,no,op,no,op,throws,ioexception,return,optional,empty
InternalEngine -> protected Optional<Exception> preFlightCheckForNoOp(final NoOp noOp) throws IOException;1550256122;Executes a pre-flight check for a given NoOp._If this method returns a non-empty result, the engine won't process this NoOp and returns a failure.;protected Optional<Exception> preFlightCheckForNoOp(final NoOp noOp) throws IOException {_        return Optional.empty()__    };executes,a,pre,flight,check,for,a,given,no,op,if,this,method,returns,a,non,empty,result,the,engine,won,t,process,this,no,op,and,returns,a,failure;protected,optional,exception,pre,flight,check,for,no,op,final,no,op,no,op,throws,ioexception,return,optional,empty
InternalEngine -> protected Optional<Exception> preFlightCheckForNoOp(final NoOp noOp) throws IOException;1550342051;Executes a pre-flight check for a given NoOp._If this method returns a non-empty result, the engine won't process this NoOp and returns a failure.;protected Optional<Exception> preFlightCheckForNoOp(final NoOp noOp) throws IOException {_        return Optional.empty()__    };executes,a,pre,flight,check,for,a,given,no,op,if,this,method,returns,a,non,empty,result,the,engine,won,t,process,this,no,op,and,returns,a,failure;protected,optional,exception,pre,flight,check,for,no,op,final,no,op,no,op,throws,ioexception,return,optional,empty
InternalEngine -> protected Optional<Exception> preFlightCheckForNoOp(final NoOp noOp) throws IOException;1550526771;Executes a pre-flight check for a given NoOp._If this method returns a non-empty result, the engine won't process this NoOp and returns a failure.;protected Optional<Exception> preFlightCheckForNoOp(final NoOp noOp) throws IOException {_        return Optional.empty()__    };executes,a,pre,flight,check,for,a,given,no,op,if,this,method,returns,a,non,empty,result,the,engine,won,t,process,this,no,op,and,returns,a,failure;protected,optional,exception,pre,flight,check,for,no,op,final,no,op,no,op,throws,ioexception,return,optional,empty
InternalEngine -> protected Optional<Exception> preFlightCheckForNoOp(final NoOp noOp) throws IOException;1551110274;Executes a pre-flight check for a given NoOp._If this method returns a non-empty result, the engine won't process this NoOp and returns a failure.;protected Optional<Exception> preFlightCheckForNoOp(final NoOp noOp) throws IOException {_        return Optional.empty()__    };executes,a,pre,flight,check,for,a,given,no,op,if,this,method,returns,a,non,empty,result,the,engine,won,t,process,this,no,op,and,returns,a,failure;protected,optional,exception,pre,flight,check,for,no,op,final,no,op,no,op,throws,ioexception,return,optional,empty
InternalEngine -> protected Optional<Exception> preFlightCheckForNoOp(final NoOp noOp) throws IOException;1551126708;Executes a pre-flight check for a given NoOp._If this method returns a non-empty result, the engine won't process this NoOp and returns a failure.;protected Optional<Exception> preFlightCheckForNoOp(final NoOp noOp) throws IOException {_        return Optional.empty()__    };executes,a,pre,flight,check,for,a,given,no,op,if,this,method,returns,a,non,empty,result,the,engine,won,t,process,this,no,op,and,returns,a,failure;protected,optional,exception,pre,flight,check,for,no,op,final,no,op,no,op,throws,ioexception,return,optional,empty
