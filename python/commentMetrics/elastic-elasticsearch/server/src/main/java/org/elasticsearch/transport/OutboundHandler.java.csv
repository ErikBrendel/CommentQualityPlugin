commented;modifiers;parameterAmount;loc;comment;code
false;;3;10;;void sendBytes(TcpChannel channel, BytesReference bytes, ActionListener<Void> listener) {     channel.getChannelStats().markAccessed(threadPool.relativeTimeInMillis()).     SendContext sendContext = new SendContext(channel, () -> bytes, listener).     try {         internalSendMessage(channel, sendContext).     } catch (IOException e) {         // This should not happen as the bytes are already serialized         throw new AssertionError(e).     } }
false;;3;6;;void sendMessage(TcpChannel channel, OutboundMessage networkMessage, ActionListener<Void> listener) throws IOException {     channel.getChannelStats().markAccessed(threadPool.relativeTimeInMillis()).     MessageSerializer serializer = new MessageSerializer(networkMessage, bigArrays).     SendContext sendContext = new SendContext(channel, serializer, listener, serializer).     internalSendMessage(channel, sendContext). }
true;private;2;12;/**  * sends a message to the given channel, using the given callbacks.  */ ;/**  * sends a message to the given channel, using the given callbacks.  */ private void internalSendMessage(TcpChannel channel, SendContext sendContext) throws IOException {     channel.getChannelStats().markAccessed(threadPool.relativeTimeInMillis()).     BytesReference reference = sendContext.get().     try {         channel.sendMessage(reference, sendContext).     } catch (RuntimeException ex) {         sendContext.onFailure(ex).         CloseableChannel.closeChannel(channel).         throw ex.     } }
false;;0;3;;MeanMetric getTransmittedBytes() {     return transmittedBytesMetric. }
false;public;0;5;;@Override public BytesReference get() throws IOException {     bytesStreamOutput = new ReleasableBytesStreamOutput(bigArrays).     return message.serialize(bytesStreamOutput). }
false;public;0;4;;@Override public void close() {     IOUtils.closeWhileHandlingException(bytesStreamOutput). }
false;public;0;12;;public BytesReference get() throws IOException {     BytesReference message.     try {         message = messageSupplier.get().         messageSize = message.length().         transportLogger.logOutboundMessage(channel, message).         return message.     } catch (Exception e) {         onFailure(e).         throw e.     } }
false;protected;1;6;;@Override protected void innerOnResponse(Void v) {     assert messageSize != -1 : "If onResponse is being called, the message should have been serialized".     transmittedBytesMetric.inc(messageSize).     closeAndCallback(() -> listener.onResponse(v)). }
false;protected;1;5;;@Override protected void innerOnFailure(Exception e) {     logger.warn(() -> new ParameterizedMessage("send message failed [channel: {}]", channel), e).     closeAndCallback(() -> listener.onFailure(e)). }
false;private;1;3;;private void closeAndCallback(Runnable runnable) {     Releasables.close(optionalReleasable, runnable::run). }
