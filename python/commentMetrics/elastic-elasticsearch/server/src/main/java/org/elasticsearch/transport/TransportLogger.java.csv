commented;modifiers;parameterAmount;loc;comment;code
false;;2;10;;void logInboundMessage(TcpChannel channel, BytesReference message) {     if (logger.isTraceEnabled()) {         try {             String logMessage = format(channel, message, "READ").             logger.trace(logMessage).         } catch (IOException e) {             logger.trace("an exception occurred formatting a READ trace message", e).         }     } }
false;;2;15;;void logOutboundMessage(TcpChannel channel, BytesReference message) {     if (logger.isTraceEnabled()) {         try {             if (message.get(0) != 'E') {                 // This is not an Elasticsearch transport message.                 return.             }             BytesReference withoutHeader = message.slice(HEADER_SIZE, message.length() - HEADER_SIZE).             String logMessage = format(channel, withoutHeader, "WRITE").             logger.trace(logMessage).         } catch (IOException e) {             logger.trace("an exception occurred formatting a WRITE trace message", e).         }     } }
false;private;3;55;;private String format(TcpChannel channel, BytesReference message, String event) throws IOException {     final StringBuilder sb = new StringBuilder().     sb.append(channel).     int messageLengthWithHeader = HEADER_SIZE + message.length().     // This is a ping     if (message.length() == 0) {         sb.append(" [ping]").append(' ').append(event).append(": ").append(messageLengthWithHeader).append('B').     } else {         boolean success = false.         StreamInput streamInput = message.streamInput().         try {             final long requestId = streamInput.readLong().             final byte status = streamInput.readByte().             final boolean isRequest = TransportStatus.isRequest(status).             final String type = isRequest ? "request" : "response".             final String version = Version.fromId(streamInput.readInt()).toString().             sb.append(" [length: ").append(messageLengthWithHeader).             sb.append(", request id: ").append(requestId).             sb.append(", type: ").append(type).             sb.append(", version: ").append(version).             if (isRequest) {                 if (TransportStatus.isCompress(status)) {                     Compressor compressor.                     try {                         final int bytesConsumed = TcpHeader.REQUEST_ID_SIZE + TcpHeader.STATUS_SIZE + TcpHeader.VERSION_ID_SIZE.                         compressor = CompressorFactory.compressor(message.slice(bytesConsumed, message.length() - bytesConsumed)).                     } catch (NotCompressedException ex) {                         throw new IllegalStateException(ex).                     }                     streamInput = compressor.streamInput(streamInput).                 }                 try (ThreadContext context = new ThreadContext(Settings.EMPTY)) {                     context.readHeaders(streamInput).                 }                 // now we decode the features                 if (streamInput.getVersion().onOrAfter(Version.V_6_3_0)) {                     streamInput.readStringArray().                 }                 sb.append(", action: ").append(streamInput.readString()).             }             sb.append(']').             sb.append(' ').append(event).append(": ").append(messageLengthWithHeader).append('B').             success = true.         } finally {             if (success) {                 IOUtils.close(streamInput).             } else {                 IOUtils.closeWhileHandlingException(streamInput).             }         }     }     return sb.toString(). }
