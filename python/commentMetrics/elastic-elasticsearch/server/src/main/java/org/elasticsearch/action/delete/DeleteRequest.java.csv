commented;modifiers;parameterAmount;loc;comment;code
false;public;0;14;;@Override public ActionRequestValidationException validate() {     ActionRequestValidationException validationException = super.validate().     if (Strings.isEmpty(type())) {         validationException = addValidationError("type is missing", validationException).     }     if (Strings.isEmpty(id)) {         validationException = addValidationError("id is missing", validationException).     }     validationException = DocWriteRequest.validateSeqNoBasedCASParams(this, validationException).     return validationException. }
true;public;0;8;/**  * The type of the document to delete.  *  * @deprecated Types are in the process of being removed.  */ ;/**  * The type of the document to delete.  *  * @deprecated Types are in the process of being removed.  */ @Deprecated @Override public String type() {     if (type == null) {         return MapperService.SINGLE_MAPPING_NAME.     }     return type. }
true;public;1;6;/**  * Sets the type of the document to delete.  *  * @deprecated Types are in the process of being removed.  */ ;/**  * Sets the type of the document to delete.  *  * @deprecated Types are in the process of being removed.  */ @Deprecated @Override public DeleteRequest type(String type) {     this.type = type.     return this. }
true;public;1;8;/**  * Set the default type supplied to a bulk  * request if this individual request's type is null  * or empty  *  * @deprecated Types are in the process of being removed.  */ ;/**  * Set the default type supplied to a bulk  * request if this individual request's type is null  * or empty  *  * @deprecated Types are in the process of being removed.  */ @Deprecated @Override public DeleteRequest defaultTypeIfNull(String defaultType) {     if (Strings.isNullOrEmpty(type)) {         type = defaultType.     }     return this. }
true;public;0;4;/**  * The id of the document to delete.  */ ;/**  * The id of the document to delete.  */ @Override public String id() {     return id. }
true;public;1;4;/**  * Sets the id of the document to delete.  */ ;/**  * Sets the id of the document to delete.  */ public DeleteRequest id(String id) {     this.id = id.     return this. }
true;public;1;9;/**  * Controls the shard routing of the request. Using this value to hash the shard  * and not the id.  */ ;/**  * Controls the shard routing of the request. Using this value to hash the shard  * and not the id.  */ @Override public DeleteRequest routing(String routing) {     if (routing != null && routing.length() == 0) {         this.routing = null.     } else {         this.routing = routing.     }     return this. }
true;public;0;4;/**  * Controls the shard routing of the delete request. Using this value to hash the shard  * and not the id.  */ ;/**  * Controls the shard routing of the delete request. Using this value to hash the shard  * and not the id.  */ @Override public String routing() {     return this.routing. }
false;public;1;5;;@Override public DeleteRequest version(long version) {     this.version = version.     return this. }
false;public;0;4;;@Override public long version() {     return this.version. }
false;public;1;5;;@Override public DeleteRequest versionType(VersionType versionType) {     this.versionType = versionType.     return this. }
true;public;0;3;/**  * If set, only perform this delete request if the document was last modification was assigned this sequence number.  * If the document last modification was assigned a different sequence number a  * {@link org.elasticsearch.index.engine.VersionConflictEngineException} will be thrown.  */ ;/**  * If set, only perform this delete request if the document was last modification was assigned this sequence number.  * If the document last modification was assigned a different sequence number a  * {@link org.elasticsearch.index.engine.VersionConflictEngineException} will be thrown.  */ public long ifSeqNo() {     return ifSeqNo. }
true;public;0;3;/**  * If set, only perform this delete request if the document was last modification was assigned this primary term.  *  * If the document last modification was assigned a different term a  * {@link org.elasticsearch.index.engine.VersionConflictEngineException} will be thrown.  */ ;/**  * If set, only perform this delete request if the document was last modification was assigned this primary term.  *  * If the document last modification was assigned a different term a  * {@link org.elasticsearch.index.engine.VersionConflictEngineException} will be thrown.  */ public long ifPrimaryTerm() {     return ifPrimaryTerm. }
true;public;1;7;/**  * only perform this delete request if the document was last modification was assigned the given  * sequence number. Must be used in combination with {@link #setIfPrimaryTerm(long)}  *  * If the document last modification was assigned a different sequence number a  * {@link org.elasticsearch.index.engine.VersionConflictEngineException} will be thrown.  */ ;/**  * only perform this delete request if the document was last modification was assigned the given  * sequence number. Must be used in combination with {@link #setIfPrimaryTerm(long)}  *  * If the document last modification was assigned a different sequence number a  * {@link org.elasticsearch.index.engine.VersionConflictEngineException} will be thrown.  */ public DeleteRequest setIfSeqNo(long seqNo) {     if (seqNo < 0 && seqNo != UNASSIGNED_SEQ_NO) {         throw new IllegalArgumentException("sequence numbers must be non negative. got [" + seqNo + "].").     }     ifSeqNo = seqNo.     return this. }
true;public;1;7;/**  * only perform this delete request if the document was last modification was assigned the given  * primary term. Must be used in combination with {@link #setIfSeqNo(long)}  *  * If the document last modification was assigned a different primary term a  * {@link org.elasticsearch.index.engine.VersionConflictEngineException} will be thrown.  */ ;/**  * only perform this delete request if the document was last modification was assigned the given  * primary term. Must be used in combination with {@link #setIfSeqNo(long)}  *  * If the document last modification was assigned a different primary term a  * {@link org.elasticsearch.index.engine.VersionConflictEngineException} will be thrown.  */ public DeleteRequest setIfPrimaryTerm(long term) {     if (term < 0) {         throw new IllegalArgumentException("primary term must be non negative. got [" + term + "]").     }     ifPrimaryTerm = term.     return this. }
false;public;0;4;;@Override public VersionType versionType() {     return this.versionType. }
false;public;0;4;;@Override public OpType opType() {     return OpType.DELETE. }
false;public;1;19;;@Override public void readFrom(StreamInput in) throws IOException {     super.readFrom(in).     type = in.readString().     id = in.readString().     routing = in.readOptionalString().     if (in.getVersion().before(Version.V_7_0_0)) {         // _parent         in.readOptionalString().     }     version = in.readLong().     versionType = VersionType.fromValue(in.readByte()).     if (in.getVersion().onOrAfter(Version.V_6_6_0)) {         ifSeqNo = in.readZLong().         ifPrimaryTerm = in.readVLong().     } else {         ifSeqNo = UNASSIGNED_SEQ_NO.         ifPrimaryTerm = UNASSIGNED_PRIMARY_TERM.     } }
false;public;1;23;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     // A 7.x request allows null types but if deserialized in a 6.x node will cause nullpointer exceptions.     // So we use the type accessor method here to make the type non-null (will default it to "_doc").     out.writeString(type()).     out.writeString(id).     out.writeOptionalString(routing()).     if (out.getVersion().before(Version.V_7_0_0)) {         // _parent         out.writeOptionalString(null).     }     out.writeLong(version).     out.writeByte(versionType.getValue()).     if (out.getVersion().onOrAfter(Version.V_6_6_0)) {         out.writeZLong(ifSeqNo).         out.writeVLong(ifPrimaryTerm).     } else if (ifSeqNo != UNASSIGNED_SEQ_NO || ifPrimaryTerm != UNASSIGNED_PRIMARY_TERM) {         assert false : "setIfMatch [" + ifSeqNo + "], currentDocTem [" + ifPrimaryTerm + "]".         throw new IllegalStateException("sequence number based compare and write is not supported until all nodes are on version 7.0 or higher. " + "Stream version [" + out.getVersion() + "]").     } }
false;public;0;4;;@Override public String toString() {     return "delete {[" + index + "][" + type() + "][" + id + "]}". }
true;public;1;4;/**  * Override this method from ReplicationAction, this is where we are storing our state in the request object (which we really shouldn't  * do). Once the transport client goes away we can move away from making this available, but in the meantime this is dangerous to set or  * use because the DeleteRequest object will always be wrapped in a bulk request envelope, which is where this *should* be set.  */ ;/**  * Override this method from ReplicationAction, this is where we are storing our state in the request object (which we really shouldn't  * do). Once the transport client goes away we can move away from making this available, but in the meantime this is dangerous to set or  * use because the DeleteRequest object will always be wrapped in a bulk request envelope, which is where this *should* be set.  */ @Override public DeleteRequest setShardId(ShardId shardId) {     throw new UnsupportedOperationException("shard id should never be set on DeleteRequest"). }
