commented;modifiers;parameterAmount;loc;comment;code
true;static;1;8;/**  * Returns the type from super class's type parameter in {@link MoreTypes#canonicalize(Type)  * canonical form}.  */ ;/**  * Returns the type from super class's type parameter in {@link MoreTypes#canonicalize(Type)  * canonical form}.  */ static Type getSuperclassTypeParameter(Class<?> subclass) {     Type superclass = subclass.getGenericSuperclass().     if (superclass instanceof Class) {         throw new RuntimeException("Missing type parameter.").     }     ParameterizedType parameterized = (ParameterizedType) superclass.     return canonicalize(parameterized.getActualTypeArguments()[0]). }
true;static;1;3;/**  * Gets type literal from super class's type parameter.  */ ;/**  * Gets type literal from super class's type parameter.  */ static TypeLiteral<?> fromSuperclassTypeParameter(Class<?> subclass) {     return new TypeLiteral<Object>(getSuperclassTypeParameter(subclass)). }
true;public,final;0;3;/**  * Returns the raw (non-generic) type for this type.  *  * @since 2.0  */ ;/**  * Returns the raw (non-generic) type for this type.  *  * @since 2.0  */ public final Class<? super T> getRawType() {     return rawType. }
true;public,final;0;3;/**  * Gets underlying {@code Type} instance.  */ ;/**  * Gets underlying {@code Type} instance.  */ public final Type getType() {     return type. }
true;final;0;6;/**  * Gets the type of this type's provider.  */ ;/**  * Gets the type of this type's provider.  */ @SuppressWarnings("unchecked") final TypeLiteral<Provider<T>> providerType() {     // parameter.     return (TypeLiteral<Provider<T>>) get(Types.providerOf(getType())). }
false;public,final;0;4;;@Override public final int hashCode() {     return this.hashCode. }
false;public,final;1;5;;@Override public final boolean equals(Object o) {     return o instanceof TypeLiteral<?> && MoreTypes.equals(type, ((TypeLiteral) o).type). }
false;public,final;0;4;;@Override public final String toString() {     return MoreTypes.toString(type). }
true;public,static;1;3;/**  * Gets type literal for the given {@code Type} instance.  */ ;/**  * Gets type literal for the given {@code Type} instance.  */ public static TypeLiteral<?> get(Type type) {     return new TypeLiteral<Object>(type). }
true;public,static;1;3;/**  * Gets type literal for the given {@code Class} instance.  */ ;/**  * Gets type literal for the given {@code Class} instance.  */ public static <T> TypeLiteral<T> get(Class<T> type) {     return new TypeLiteral<>(type). }
true;private;1;7;/**  * Returns an immutable list of the resolved types.  */ ;/**  * Returns an immutable list of the resolved types.  */ private List<TypeLiteral<?>> resolveAll(Type[] types) {     TypeLiteral<?>[] result = new TypeLiteral<?>[types.length].     for (int t = 0. t < types.length. t++) {         result[t] = resolve(types[t]).     }     return Arrays.asList(result). }
true;;1;3;/**  * Resolves known type parameters in {@code toResolve} and returns the result.  */ ;/**  * Resolves known type parameters in {@code toResolve} and returns the result.  */ TypeLiteral<?> resolve(Type toResolve) {     return TypeLiteral.get(resolveType(toResolve)). }
false;;1;63;;Type resolveType(Type toResolve) {     // this implementation is made a little more complicated in an attempt to avoid object-creation     while (true) {         if (toResolve instanceof TypeVariable) {             TypeVariable original = (TypeVariable) toResolve.             toResolve = MoreTypes.resolveTypeVariable(type, rawType, original).             if (toResolve == original) {                 return toResolve.             }         } else if (toResolve instanceof GenericArrayType) {             GenericArrayType original = (GenericArrayType) toResolve.             Type componentType = original.getGenericComponentType().             Type newComponentType = resolveType(componentType).             return componentType == newComponentType ? original : Types.arrayOf(newComponentType).         } else if (toResolve instanceof ParameterizedType) {             ParameterizedType original = (ParameterizedType) toResolve.             Type ownerType = original.getOwnerType().             Type newOwnerType = resolveType(ownerType).             boolean changed = newOwnerType != ownerType.             Type[] args = original.getActualTypeArguments().             for (int t = 0, length = args.length. t < length. t++) {                 Type resolvedTypeArgument = resolveType(args[t]).                 if (resolvedTypeArgument != args[t]) {                     if (!changed) {                         args = args.clone().                         changed = true.                     }                     args[t] = resolvedTypeArgument.                 }             }             return changed ? Types.newParameterizedTypeWithOwner(newOwnerType, original.getRawType(), args) : original.         } else if (toResolve instanceof WildcardType) {             WildcardType original = (WildcardType) toResolve.             Type[] originalLowerBound = original.getLowerBounds().             Type[] originalUpperBound = original.getUpperBounds().             if (originalLowerBound.length == 1) {                 Type lowerBound = resolveType(originalLowerBound[0]).                 if (lowerBound != originalLowerBound[0]) {                     return Types.supertypeOf(lowerBound).                 }             } else if (originalUpperBound.length == 1) {                 Type upperBound = resolveType(originalUpperBound[0]).                 if (upperBound != originalUpperBound[0]) {                     return Types.subtypeOf(upperBound).                 }             }             return original.         } else {             return toResolve.         }     } }
true;public;1;6;/**  * Returns the generic form of {@code supertype}. For example, if this is {@code  * ArrayList<String>}, this returns {@code Iterable<String>} given the input {@code  * Iterable.class}.  *  * @param supertype a superclass of, or interface implemented by, this.  * @since 2.0  */ ;/**  * Returns the generic form of {@code supertype}. For example, if this is {@code  * ArrayList<String>}, this returns {@code Iterable<String>} given the input {@code  * Iterable.class}.  *  * @param supertype a superclass of, or interface implemented by, this.  * @since 2.0  */ public TypeLiteral<?> getSupertype(Class<?> supertype) {     if (!supertype.isAssignableFrom(rawType)) {         throw new IllegalArgumentException(supertype + " is not a supertype of " + type).     }     return resolve(MoreTypes.getGenericSupertype(type, rawType, supertype)). }
true;public;1;6;/**  * Returns the resolved generic type of {@code field}.  *  * @param field a field defined by this or any superclass.  * @since 2.0  */ ;/**  * Returns the resolved generic type of {@code field}.  *  * @param field a field defined by this or any superclass.  * @since 2.0  */ public TypeLiteral<?> getFieldType(Field field) {     if (!field.getDeclaringClass().isAssignableFrom(rawType)) {         throw new IllegalArgumentException(field + " is not defined by a supertype of " + type).     }     return resolve(field.getGenericType()). }
true;public;1;24;/**  * Returns the resolved generic parameter types of {@code methodOrConstructor}.  *  * @param methodOrConstructor a method or constructor defined by this or any supertype.  * @since 2.0  */ ;/**  * Returns the resolved generic parameter types of {@code methodOrConstructor}.  *  * @param methodOrConstructor a method or constructor defined by this or any supertype.  * @since 2.0  */ public List<TypeLiteral<?>> getParameterTypes(Member methodOrConstructor) {     Type[] genericParameterTypes.     if (methodOrConstructor instanceof Method) {         Method method = (Method) methodOrConstructor.         if (!method.getDeclaringClass().isAssignableFrom(rawType)) {             throw new IllegalArgumentException(method + " is not defined by a supertype of " + type).         }         genericParameterTypes = method.getGenericParameterTypes().     } else if (methodOrConstructor instanceof Constructor) {         Constructor constructor = (Constructor) methodOrConstructor.         if (!constructor.getDeclaringClass().isAssignableFrom(rawType)) {             throw new IllegalArgumentException(constructor + " does not construct a supertype of " + type).         }         genericParameterTypes = constructor.getGenericParameterTypes().     } else {         throw new IllegalArgumentException("Not a method or a constructor: " + methodOrConstructor).     }     return resolveAll(genericParameterTypes). }
true;public;1;24;/**  * Returns the resolved generic exception types thrown by {@code constructor}.  *  * @param methodOrConstructor a method or constructor defined by this or any supertype.  * @since 2.0  */ ;/**  * Returns the resolved generic exception types thrown by {@code constructor}.  *  * @param methodOrConstructor a method or constructor defined by this or any supertype.  * @since 2.0  */ public List<TypeLiteral<?>> getExceptionTypes(Member methodOrConstructor) {     Type[] genericExceptionTypes.     if (methodOrConstructor instanceof Method) {         Method method = (Method) methodOrConstructor.         if (!method.getDeclaringClass().isAssignableFrom(rawType)) {             throw new IllegalArgumentException(method + " is not defined by a supertype of " + type).         }         genericExceptionTypes = method.getGenericExceptionTypes().     } else if (methodOrConstructor instanceof Constructor) {         Constructor<?> constructor = (Constructor<?>) methodOrConstructor.         if (!constructor.getDeclaringClass().isAssignableFrom(rawType)) {             throw new IllegalArgumentException(constructor + " does not construct a supertype of " + type).         }         genericExceptionTypes = constructor.getGenericExceptionTypes().     } else {         throw new IllegalArgumentException("Not a method or a constructor: " + methodOrConstructor).     }     return resolveAll(genericExceptionTypes). }
true;public;1;7;/**  * Returns the resolved generic return type of {@code method}.  *  * @param method a method defined by this or any supertype.  * @since 2.0  */ ;/**  * Returns the resolved generic return type of {@code method}.  *  * @param method a method defined by this or any supertype.  * @since 2.0  */ public TypeLiteral<?> getReturnType(Method method) {     if (!method.getDeclaringClass().isAssignableFrom(rawType)) {         throw new IllegalArgumentException(method + " is not defined by a supertype of " + type).     }     return resolve(method.getGenericReturnType()). }
