commented;modifiers;parameterAmount;loc;comment;code
false;public;0;7;;@Override public ScoreMode scoreMode() {     if (valuesSource != null && valuesSource.needsScores()) {         return ScoreMode.COMPLETE.     }     return super.scoreMode(). }
false;public;2;27;;@Override public void collect(int doc, long bucket) throws IOException {     assert bucket == 0.     if (values.advanceExact(doc)) {         final int valuesCount = values.docValueCount().         long previousRounded = Long.MIN_VALUE.         for (int i = 0. i < valuesCount. ++i) {             long value = values.nextValue().             // We can use shardRounding here, which is sometimes more efficient             // if daylight saving times are involved.             long rounded = shardRounding.round(value - offset) + offset.             assert rounded >= previousRounded.             if (rounded == previousRounded) {                 continue.             }             long bucketOrd = bucketOrds.add(rounded).             if (bucketOrd < 0) {                 // already seen                 bucketOrd = -1 - bucketOrd.                 collectExistingBucket(sub, doc, bucketOrd).             } else {                 collectBucket(sub, doc, bucketOrd).             }             previousRounded = rounded.         }     } }
false;public;2;37;;@Override public LeafBucketCollector getLeafCollector(LeafReaderContext ctx, final LeafBucketCollector sub) throws IOException {     if (valuesSource == null) {         return LeafBucketCollector.NO_OP_COLLECTOR.     }     final SortedNumericDocValues values = valuesSource.longValues(ctx).     return new LeafBucketCollectorBase(sub, values) {          @Override         public void collect(int doc, long bucket) throws IOException {             assert bucket == 0.             if (values.advanceExact(doc)) {                 final int valuesCount = values.docValueCount().                 long previousRounded = Long.MIN_VALUE.                 for (int i = 0. i < valuesCount. ++i) {                     long value = values.nextValue().                     // We can use shardRounding here, which is sometimes more efficient                     // if daylight saving times are involved.                     long rounded = shardRounding.round(value - offset) + offset.                     assert rounded >= previousRounded.                     if (rounded == previousRounded) {                         continue.                     }                     long bucketOrd = bucketOrds.add(rounded).                     if (bucketOrd < 0) {                         // already seen                         bucketOrd = -1 - bucketOrd.                         collectExistingBucket(sub, doc, bucketOrd).                     } else {                         collectBucket(sub, doc, bucketOrd).                     }                     previousRounded = rounded.                 }             }         }     }. }
false;public;1;21;;@Override public InternalAggregation buildAggregation(long owningBucketOrdinal) throws IOException {     assert owningBucketOrdinal == 0.     consumeBucketsAndMaybeBreak((int) bucketOrds.size()).     List<InternalDateHistogram.Bucket> buckets = new ArrayList<>((int) bucketOrds.size()).     for (long i = 0. i < bucketOrds.size(). i++) {         buckets.add(new InternalDateHistogram.Bucket(bucketOrds.get(i), bucketDocCount(i), keyed, formatter, bucketAggregations(i))).     }     // the contract of the histogram aggregation is that shards must return buckets ordered by key in ascending order     CollectionUtil.introSort(buckets, BucketOrder.key(true).comparator(this)).     // value source will be null for unmapped fields     // Important: use `rounding` here, not `shardRounding`     InternalDateHistogram.EmptyBucketInfo emptyBucketInfo = minDocCount == 0 ? new InternalDateHistogram.EmptyBucketInfo(rounding, buildEmptySubAggregations(), extendedBounds) : null.     return new InternalDateHistogram(name, buckets, order, minDocCount, offset, emptyBucketInfo, formatter, keyed, pipelineAggregators(), metaData()). }
false;public;0;8;;@Override public InternalAggregation buildEmptyAggregation() {     InternalDateHistogram.EmptyBucketInfo emptyBucketInfo = minDocCount == 0 ? new InternalDateHistogram.EmptyBucketInfo(rounding, buildEmptySubAggregations(), extendedBounds) : null.     return new InternalDateHistogram(name, Collections.emptyList(), order, minDocCount, offset, emptyBucketInfo, formatter, keyed, pipelineAggregators(), metaData()). }
false;public;0;4;;@Override public void doClose() {     Releasables.close(bucketOrds). }
