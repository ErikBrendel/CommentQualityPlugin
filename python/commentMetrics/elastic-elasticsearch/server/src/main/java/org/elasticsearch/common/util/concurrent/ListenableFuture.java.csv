commented;modifiers;parameterAmount;loc;comment;code
true;public;3;29;/**  * Adds a listener to this future. If the future has not yet completed, the listener will be  * notified of a response or exception in a runnable submitted to the ExecutorService provided.  * If the future has completed, the listener will be notified immediately without forking to  * a different thread.  */ ;/**  * Adds a listener to this future. If the future has not yet completed, the listener will be  * notified of a response or exception in a runnable submitted to the ExecutorService provided.  * If the future has completed, the listener will be notified immediately without forking to  * a different thread.  */ public void addListener(ActionListener<V> listener, ExecutorService executor, ThreadContext threadContext) {     if (done) {         // run the callback directly, we don't hold the lock and don't need to fork!         notifyListener(listener, EsExecutors.newDirectExecutorService()).     } else {         final boolean run.         // to the list under lock         synchronized (this) {             if (done) {                 run = true.             } else {                 final ActionListener<V> wrappedListener.                 if (threadContext == null) {                     wrappedListener = listener.                 } else {                     wrappedListener = ContextPreservingActionListener.wrapPreservingContext(listener, threadContext).                 }                 listeners.add(new Tuple<>(wrappedListener, executor)).                 run = false.             }         }         if (run) {             // run the callback directly, we don't hold the lock and don't need to fork!             notifyListener(listener, EsExecutors.newDirectExecutorService()).         }     } }
false;protected,synchronized;0;8;;@Override protected synchronized void done() {     done = true.     listeners.forEach(t -> notifyListener(t.v1(), t.v2())).     // release references to any listeners as we no longer need them and will live     // much longer than the listeners in most cases     listeners.clear(). }
false;public;0;11;;@Override public void run() {     try {         // call get in a non-blocking fashion as we could be on a network thread         // or another thread like the scheduler, which we should never block!         V value = FutureUtils.get(ListenableFuture.this, 0L, TimeUnit.NANOSECONDS).         listener.onResponse(value).     } catch (Exception e) {         listener.onFailure(e).     } }
false;public;0;4;;@Override public String toString() {     return "ListenableFuture notification". }
false;private;2;24;;private void notifyListener(ActionListener<V> listener, ExecutorService executorService) {     try {         executorService.execute(new Runnable() {              @Override             public void run() {                 try {                     // call get in a non-blocking fashion as we could be on a network thread                     // or another thread like the scheduler, which we should never block!                     V value = FutureUtils.get(ListenableFuture.this, 0L, TimeUnit.NANOSECONDS).                     listener.onResponse(value).                 } catch (Exception e) {                     listener.onFailure(e).                 }             }              @Override             public String toString() {                 return "ListenableFuture notification".             }         }).     } catch (Exception e) {         listener.onFailure(e).     } }
false;public;1;7;;@Override public void onResponse(V v) {     final boolean set = set(v).     if (set == false) {         throw new IllegalStateException("did not set value, value or exception already set?").     } }
false;public;1;7;;@Override public void onFailure(Exception e) {     final boolean set = setException(e).     if (set == false) {         throw new IllegalStateException("did not set exception, value already set or exception already set?").     } }
