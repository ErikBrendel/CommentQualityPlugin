commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public void onResponse(SearchFreeContextResponse response) { // no need to respond if it was freed or not }
false;public;1;4;;@Override public void onFailure(Exception e) { }
false;public;3;14;;public void sendFreeContext(Transport.Connection connection, final long contextId, OriginalIndices originalIndices) {     transportService.sendRequest(connection, FREE_CONTEXT_ACTION_NAME, new SearchFreeContextRequest(originalIndices, contextId), TransportRequestOptions.EMPTY, new ActionListenerResponseHandler<>(new ActionListener<SearchFreeContextResponse>() {          @Override         public void onResponse(SearchFreeContextResponse response) {         // no need to respond if it was freed or not         }          @Override         public void onFailure(Exception e) {         }     }, SearchFreeContextResponse::new)). }
false;public;3;4;;public void sendFreeContext(Transport.Connection connection, long contextId, final ActionListener<SearchFreeContextResponse> listener) {     transportService.sendRequest(connection, FREE_CONTEXT_SCROLL_ACTION_NAME, new ScrollFreeContextRequest(contextId), TransportRequestOptions.EMPTY, new ActionListenerResponseHandler<>(listener, SearchFreeContextResponse::new)). }
false;public;4;5;;public void sendCanMatch(Transport.Connection connection, final ShardSearchTransportRequest request, SearchTask task, final ActionListener<SearchService.CanMatchResponse> listener) {     transportService.sendChildRequest(connection, QUERY_CAN_MATCH_NAME, request, task, TransportRequestOptions.EMPTY, new ActionListenerResponseHandler<>(listener, SearchService.CanMatchResponse::new)). }
false;public;2;4;;public void sendClearAllScrollContexts(Transport.Connection connection, final ActionListener<TransportResponse> listener) {     transportService.sendRequest(connection, CLEAR_SCROLL_CONTEXTS_ACTION_NAME, TransportRequest.Empty.INSTANCE, TransportRequestOptions.EMPTY, new ActionListenerResponseHandler<>(listener, (in) -> TransportResponse.Empty.INSTANCE)). }
false;public;4;5;;public void sendExecuteDfs(Transport.Connection connection, final ShardSearchTransportRequest request, SearchTask task, final SearchActionListener<DfsSearchResult> listener) {     transportService.sendChildRequest(connection, DFS_ACTION_NAME, request, task, new ConnectionCountingHandler<>(listener, DfsSearchResult::new, clientConnections, connection.getNode().getId())). }
false;public;4;11;;public void sendExecuteQuery(Transport.Connection connection, final ShardSearchTransportRequest request, SearchTask task, final SearchActionListener<SearchPhaseResult> listener) {     // we optimize this and expect a QueryFetchSearchResult if we only have a single shard in the search request     // this used to be the QUERY_AND_FETCH which doesn't exist anymore.     final boolean fetchDocuments = request.numberOfShards() == 1.     Writeable.Reader<SearchPhaseResult> reader = fetchDocuments ? QueryFetchSearchResult::new : QuerySearchResult::new.     final ActionListener handler = responseWrapper.apply(connection, listener).     transportService.sendChildRequest(connection, QUERY_ACTION_NAME, request, task, new ConnectionCountingHandler<>(handler, reader, clientConnections, connection.getNode().getId())). }
false;public;4;5;;public void sendExecuteQuery(Transport.Connection connection, final QuerySearchRequest request, SearchTask task, final SearchActionListener<QuerySearchResult> listener) {     transportService.sendChildRequest(connection, QUERY_ID_ACTION_NAME, request, task, new ConnectionCountingHandler<>(listener, QuerySearchResult::new, clientConnections, connection.getNode().getId())). }
false;public;4;5;;public void sendExecuteScrollQuery(Transport.Connection connection, final InternalScrollSearchRequest request, SearchTask task, final SearchActionListener<ScrollQuerySearchResult> listener) {     transportService.sendChildRequest(connection, QUERY_SCROLL_ACTION_NAME, request, task, new ConnectionCountingHandler<>(listener, ScrollQuerySearchResult::new, clientConnections, connection.getNode().getId())). }
false;public;4;6;;public void sendExecuteScrollFetch(Transport.Connection connection, final InternalScrollSearchRequest request, SearchTask task, final SearchActionListener<ScrollQueryFetchSearchResult> listener) {     transportService.sendChildRequest(connection, QUERY_FETCH_SCROLL_ACTION_NAME, request, task, new ConnectionCountingHandler<>(listener, ScrollQueryFetchSearchResult::new, clientConnections, connection.getNode().getId())). }
false;public;4;4;;public void sendExecuteFetch(Transport.Connection connection, final ShardFetchSearchRequest request, SearchTask task, final SearchActionListener<FetchSearchResult> listener) {     sendExecuteFetch(connection, FETCH_ID_ACTION_NAME, request, task, listener). }
false;public;4;4;;public void sendExecuteFetchScroll(Transport.Connection connection, final ShardFetchRequest request, SearchTask task, final SearchActionListener<FetchSearchResult> listener) {     sendExecuteFetch(connection, FETCH_ID_SCROLL_ACTION_NAME, request, task, listener). }
false;private;5;5;;private void sendExecuteFetch(Transport.Connection connection, String action, final ShardFetchRequest request, SearchTask task, final SearchActionListener<FetchSearchResult> listener) {     transportService.sendChildRequest(connection, action, request, task, new ConnectionCountingHandler<>(listener, FetchSearchResult::new, clientConnections, connection.getNode().getId())). }
true;;3;6;/**  * Used by {@link TransportSearchAction} to send the expand queries (field collapsing).  */ ;/**  * Used by {@link TransportSearchAction} to send the expand queries (field collapsing).  */ void sendExecuteMultiSearch(final MultiSearchRequest request, SearchTask task, final ActionListener<MultiSearchResponse> listener) {     final Transport.Connection connection = transportService.getConnection(transportService.getLocalNode()).     transportService.sendChildRequest(connection, MultiSearchAction.NAME, request, task, new ConnectionCountingHandler<>(listener, MultiSearchResponse::new, clientConnections, connection.getNode().getId())). }
false;public;0;3;;public RemoteClusterService getRemoteClusterService() {     return transportService.getRemoteClusterService(). }
true;public;0;3;/**  * Return a map of nodeId to pending number of search requests.  * This is a snapshot of the current pending search and not a live map.  */ ;/**  * Return a map of nodeId to pending number of search requests.  * This is a snapshot of the current pending search and not a live map.  */ public Map<String, Long> getPendingSearchRequests() {     return new HashMap<>(clientConnections). }
false;public;1;5;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeLong(id). }
false;public;0;3;;public long id() {     return this.id. }
false;public;1;4;;@Override public void readFrom(StreamInput in) throws IOException {     throw new UnsupportedOperationException("usage of Streamable is to be replaced by Writeable"). }
false;public;1;5;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     OriginalIndices.writeOriginalIndices(originalIndices, out). }
false;public;0;7;;@Override public String[] indices() {     if (originalIndices == null) {         return null.     }     return originalIndices.indices(). }
false;public;0;7;;@Override public IndicesOptions indicesOptions() {     if (originalIndices == null) {         return null.     }     return originalIndices.indicesOptions(). }
false;public;1;4;;@Override public void readFrom(StreamInput in) throws IOException {     throw new UnsupportedOperationException("usage of Streamable is to be replaced by Writeable"). }
false;public;0;3;;public boolean isFreed() {     return freed. }
false;public;1;5;;@Override public void readFrom(StreamInput in) throws IOException {     super.readFrom(in).     freed = in.readBoolean(). }
false;public;1;5;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeBoolean(freed). }
false;public;1;8;;@Override public void onResponse(SearchPhaseResult searchPhaseResult) {     try {         channel.sendResponse(searchPhaseResult).     } catch (IOException e) {         throw new UncheckedIOException(e).     } }
false;public;1;8;;@Override public void onFailure(Exception e) {     try {         channel.sendResponse(e).     } catch (IOException e1) {         throw new UncheckedIOException(e1).     } }
false;public,static;2;95;;public static void registerRequestHandler(TransportService transportService, SearchService searchService) {     transportService.registerRequestHandler(FREE_CONTEXT_SCROLL_ACTION_NAME, ThreadPool.Names.SAME, ScrollFreeContextRequest::new, (request, channel, task) -> {         boolean freed = searchService.freeContext(request.id()).         channel.sendResponse(new SearchFreeContextResponse(freed)).     }).     TransportActionProxy.registerProxyAction(transportService, FREE_CONTEXT_SCROLL_ACTION_NAME, SearchFreeContextResponse::new).     transportService.registerRequestHandler(FREE_CONTEXT_ACTION_NAME, ThreadPool.Names.SAME, SearchFreeContextRequest::new, (request, channel, task) -> {         boolean freed = searchService.freeContext(request.id()).         channel.sendResponse(new SearchFreeContextResponse(freed)).     }).     TransportActionProxy.registerProxyAction(transportService, FREE_CONTEXT_ACTION_NAME, SearchFreeContextResponse::new).     transportService.registerRequestHandler(CLEAR_SCROLL_CONTEXTS_ACTION_NAME, () -> TransportRequest.Empty.INSTANCE, ThreadPool.Names.SAME, (request, channel, task) -> {         searchService.freeAllScrollContexts().         channel.sendResponse(TransportResponse.Empty.INSTANCE).     }).     TransportActionProxy.registerProxyAction(transportService, CLEAR_SCROLL_CONTEXTS_ACTION_NAME, (in) -> TransportResponse.Empty.INSTANCE).     transportService.registerRequestHandler(DFS_ACTION_NAME, ThreadPool.Names.SAME, ShardSearchTransportRequest::new, (request, channel, task) -> {         searchService.executeDfsPhase(request, (SearchTask) task, new ActionListener<SearchPhaseResult>() {              @Override             public void onResponse(SearchPhaseResult searchPhaseResult) {                 try {                     channel.sendResponse(searchPhaseResult).                 } catch (IOException e) {                     throw new UncheckedIOException(e).                 }             }              @Override             public void onFailure(Exception e) {                 try {                     channel.sendResponse(e).                 } catch (IOException e1) {                     throw new UncheckedIOException(e1).                 }             }         }).     }).     TransportActionProxy.registerProxyAction(transportService, DFS_ACTION_NAME, DfsSearchResult::new).     transportService.registerRequestHandler(QUERY_ACTION_NAME, ThreadPool.Names.SAME, ShardSearchTransportRequest::new, (request, channel, task) -> {         searchService.executeQueryPhase(request, (SearchTask) task, new ChannelActionListener<>(channel, QUERY_ACTION_NAME, request)).     }).     TransportActionProxy.registerProxyActionWithDynamicResponseType(transportService, QUERY_ACTION_NAME, (request) -> ((ShardSearchRequest) request).numberOfShards() == 1 ? QueryFetchSearchResult::new : QuerySearchResult::new).     transportService.registerRequestHandler(QUERY_ID_ACTION_NAME, ThreadPool.Names.SAME, QuerySearchRequest::new, (request, channel, task) -> {         searchService.executeQueryPhase(request, (SearchTask) task, new ChannelActionListener<>(channel, QUERY_ID_ACTION_NAME, request)).     }).     TransportActionProxy.registerProxyAction(transportService, QUERY_ID_ACTION_NAME, QuerySearchResult::new).     transportService.registerRequestHandler(QUERY_SCROLL_ACTION_NAME, ThreadPool.Names.SAME, InternalScrollSearchRequest::new, (request, channel, task) -> {         searchService.executeQueryPhase(request, (SearchTask) task, new ChannelActionListener<>(channel, QUERY_SCROLL_ACTION_NAME, request)).     }).     TransportActionProxy.registerProxyAction(transportService, QUERY_SCROLL_ACTION_NAME, ScrollQuerySearchResult::new).     transportService.registerRequestHandler(QUERY_FETCH_SCROLL_ACTION_NAME, ThreadPool.Names.SAME, InternalScrollSearchRequest::new, (request, channel, task) -> {         searchService.executeFetchPhase(request, (SearchTask) task, new ChannelActionListener<>(channel, QUERY_FETCH_SCROLL_ACTION_NAME, request)).     }).     TransportActionProxy.registerProxyAction(transportService, QUERY_FETCH_SCROLL_ACTION_NAME, ScrollQueryFetchSearchResult::new).     transportService.registerRequestHandler(FETCH_ID_SCROLL_ACTION_NAME, ThreadPool.Names.SAME, ShardFetchRequest::new, (request, channel, task) -> {         searchService.executeFetchPhase(request, (SearchTask) task, new ChannelActionListener<>(channel, FETCH_ID_SCROLL_ACTION_NAME, request)).     }).     TransportActionProxy.registerProxyAction(transportService, FETCH_ID_SCROLL_ACTION_NAME, FetchSearchResult::new).     transportService.registerRequestHandler(FETCH_ID_ACTION_NAME, ThreadPool.Names.SAME, true, true, ShardFetchSearchRequest::new, (request, channel, task) -> {         searchService.executeFetchPhase(request, (SearchTask) task, new ChannelActionListener<>(channel, FETCH_ID_ACTION_NAME, request)).     }).     TransportActionProxy.registerProxyAction(transportService, FETCH_ID_ACTION_NAME, FetchSearchResult::new).     // this is cheap, it does not fetch during the rewrite phase, so we can let it quickly execute on a networking thread     transportService.registerRequestHandler(QUERY_CAN_MATCH_NAME, ThreadPool.Names.SAME, ShardSearchTransportRequest::new, (request, channel, task) -> {         searchService.canMatch(request, new ChannelActionListener<>(channel, QUERY_CAN_MATCH_NAME, request)).     }).     TransportActionProxy.registerProxyAction(transportService, QUERY_CAN_MATCH_NAME, SearchService.CanMatchResponse::new). }
true;;2;7;/**  * Returns a connection to the given node on the provided cluster. If the cluster alias is <code>null</code> the node will be resolved  * against the local cluster.  * @param clusterAlias the cluster alias the node should be resolved against  * @param node the node to resolve  * @return a connection to the given node belonging to the cluster with the provided alias.  */ ;/**  * Returns a connection to the given node on the provided cluster. If the cluster alias is <code>null</code> the node will be resolved  * against the local cluster.  * @param clusterAlias the cluster alias the node should be resolved against  * @param node the node to resolve  * @return a connection to the given node belonging to the cluster with the provided alias.  */ Transport.Connection getConnection(@Nullable String clusterAlias, DiscoveryNode node) {     if (clusterAlias == null) {         return transportService.getConnection(node).     } else {         return transportService.getRemoteClusterService().getConnection(node, clusterAlias).     } }
false;public;1;8;;@Override public void handleResponse(Response response) {     super.handleResponse(response).     // We need to remove the entry here so we don't leak when nodes go away forever     assert assertNodePresent().     clientConnections.computeIfPresent(nodeId, (id, conns) -> conns.longValue() == 1 ? null : conns - 1). }
false;public;1;8;;@Override public void handleException(TransportException e) {     super.handleException(e).     // We need to remove the entry here so we don't leak when nodes go away forever     assert assertNodePresent().     clientConnections.computeIfPresent(nodeId, (id, conns) -> conns.longValue() == 1 ? null : conns - 1). }
false;private;0;10;;private boolean assertNodePresent() {     clientConnections.compute(nodeId, (id, conns) -> {         assert conns != null : "number of connections for " + id + " is null, but should be an integer".         assert conns >= 1 : "number of connections for " + id + " should be >= 1 but was " + conns.         return conns.     }).     // can be skipped when assertions are not enabled     return true. }
