commented;modifiers;parameterAmount;loc;comment;code
false;public;0;55;;@Override public ActionRequestValidationException validate() {     ActionRequestValidationException validationException = super.validate().     if (source == null) {         validationException = addValidationError("source is missing", validationException).     }     if (Strings.isEmpty(type())) {         validationException = addValidationError("type is missing", validationException).     }     if (contentType == null) {         validationException = addValidationError("content type is missing", validationException).     }     final long resolvedVersion = resolveVersionDefaults().     if (opType() == OpType.CREATE) {         if (versionType != VersionType.INTERNAL) {             validationException = addValidationError("create operations only support internal versioning. use index instead", validationException).             return validationException.         }         if (resolvedVersion != Versions.MATCH_DELETED) {             validationException = addValidationError("create operations do not support explicit versions. use index instead", validationException).             return validationException.         }         if (ifSeqNo != UNASSIGNED_SEQ_NO || ifPrimaryTerm != UNASSIGNED_PRIMARY_TERM) {             validationException = addValidationError("create operations do not support compare and set. use index instead", validationException).             return validationException.         }     }     if (opType() != OpType.INDEX && id == null) {         addValidationError("an id is required for a " + opType() + " operation", validationException).     }     validationException = DocWriteRequest.validateSeqNoBasedCASParams(this, validationException).     if (id != null && id.getBytes(StandardCharsets.UTF_8).length > 512) {         validationException = addValidationError("id is too long, must be no longer than 512 bytes but was: " + id.getBytes(StandardCharsets.UTF_8).length, validationException).     }     if (id == null && (versionType == VersionType.INTERNAL && resolvedVersion == Versions.MATCH_ANY) == false) {         validationException = addValidationError("an id must be provided if version type or value are set", validationException).     }     if (pipeline != null && pipeline.isEmpty()) {         validationException = addValidationError("pipeline cannot be an empty string", validationException).     }     return validationException. }
true;public;0;3;/**  * The content type. This will be used when generating a document from user provided objects like Maps and when parsing the  * source at index time  */ ;/**  * The content type. This will be used when generating a document from user provided objects like Maps and when parsing the  * source at index time  */ public XContentType getContentType() {     return contentType. }
true;public;0;8;/**  * The type of the indexed document.  * @deprecated Types are in the process of being removed.  */ ;/**  * The type of the indexed document.  * @deprecated Types are in the process of being removed.  */ @Deprecated @Override public String type() {     if (type == null) {         return MapperService.SINGLE_MAPPING_NAME.     }     return type. }
true;public;1;6;/**  * Sets the type of the indexed document.  * @deprecated Types are in the process of being removed.  */ ;/**  * Sets the type of the indexed document.  * @deprecated Types are in the process of being removed.  */ @Deprecated @Override public IndexRequest type(String type) {     this.type = type.     return this. }
true;public;1;8;/**  * Set the default type supplied to a bulk  * request if this individual request's type is null  * or empty  * @deprecated Types are in the process of being removed.  */ ;/**  * Set the default type supplied to a bulk  * request if this individual request's type is null  * or empty  * @deprecated Types are in the process of being removed.  */ @Deprecated @Override public IndexRequest defaultTypeIfNull(String defaultType) {     if (Strings.isNullOrEmpty(type)) {         type = defaultType.     }     return this. }
true;public;0;4;/**  * The id of the indexed document. If not set, will be automatically generated.  */ ;/**  * The id of the indexed document. If not set, will be automatically generated.  */ @Override public String id() {     return id. }
true;public;1;4;/**  * Sets the id of the indexed document. If not set, will be automatically generated.  */ ;/**  * Sets the id of the indexed document. If not set, will be automatically generated.  */ public IndexRequest id(String id) {     this.id = id.     return this. }
true;public;1;9;/**  * Controls the shard routing of the request. Using this value to hash the shard  * and not the id.  */ ;/**  * Controls the shard routing of the request. Using this value to hash the shard  * and not the id.  */ @Override public IndexRequest routing(String routing) {     if (routing != null && routing.length() == 0) {         this.routing = null.     } else {         this.routing = routing.     }     return this. }
true;public;0;4;/**  * Controls the shard routing of the request. Using this value to hash the shard  * and not the id.  */ ;/**  * Controls the shard routing of the request. Using this value to hash the shard  * and not the id.  */ @Override public String routing() {     return this.routing. }
true;public;1;4;/**  * Sets the ingest pipeline to be executed before indexing the document  */ ;/**  * Sets the ingest pipeline to be executed before indexing the document  */ public IndexRequest setPipeline(String pipeline) {     this.pipeline = pipeline.     return this. }
true;public;0;3;/**  * Returns the ingest pipeline to be executed before indexing the document  */ ;/**  * Returns the ingest pipeline to be executed before indexing the document  */ public String getPipeline() {     return this.pipeline. }
true;public;0;3;/**  * The source of the document to index, recopied to a new array if it is unsafe.  */ ;/**  * The source of the document to index, recopied to a new array if it is unsafe.  */ public BytesReference source() {     return source. }
false;public;0;3;;public Map<String, Object> sourceAsMap() {     return XContentHelper.convertToMap(source, false, contentType).v2(). }
true;public;1;3;/**  * Index the Map in {@link Requests#INDEX_CONTENT_TYPE} format  *  * @param source The map to index  */ ;/**  * Index the Map in {@link Requests#INDEX_CONTENT_TYPE} format  *  * @param source The map to index  */ public IndexRequest source(Map<String, ?> source) throws ElasticsearchGenerationException {     return source(source, Requests.INDEX_CONTENT_TYPE). }
true;public;2;9;/**  * Index the Map as the provided content type.  *  * @param source The map to index  */ ;/**  * Index the Map as the provided content type.  *  * @param source The map to index  */ public IndexRequest source(Map<String, ?> source, XContentType contentType) throws ElasticsearchGenerationException {     try {         XContentBuilder builder = XContentFactory.contentBuilder(contentType).         builder.map(source).         return source(builder).     } catch (IOException e) {         throw new ElasticsearchGenerationException("Failed to generate [" + source + "]", e).     } }
true;public;2;3;/**  * Sets the document source to index.  *  * Note, its preferable to either set it using {@link #source(org.elasticsearch.common.xcontent.XContentBuilder)}  * or using the {@link #source(byte[], XContentType)}.  */ ;/**  * Sets the document source to index.  *  * Note, its preferable to either set it using {@link #source(org.elasticsearch.common.xcontent.XContentBuilder)}  * or using the {@link #source(byte[], XContentType)}.  */ public IndexRequest source(String source, XContentType xContentType) {     return source(new BytesArray(source), xContentType). }
true;public;1;3;/**  * Sets the content source to index.  */ ;/**  * Sets the content source to index.  */ public IndexRequest source(XContentBuilder sourceBuilder) {     return source(BytesReference.bytes(sourceBuilder), sourceBuilder.contentType()). }
true;public;1;3;/**  * Sets the content source to index using the default content type ({@link Requests#INDEX_CONTENT_TYPE})  * <p>  * <b>Note: the number of objects passed to this method must be an even  * number. Also the first argument in each pair (the field name) must have a  * valid String representation.</b>  * </p>  */ ;/**  * Sets the content source to index using the default content type ({@link Requests#INDEX_CONTENT_TYPE})  * <p>  * <b>Note: the number of objects passed to this method must be an even  * number. Also the first argument in each pair (the field name) must have a  * valid String representation.</b>  * </p>  */ public IndexRequest source(Object... source) {     return source(Requests.INDEX_CONTENT_TYPE, source). }
true;public;2;20;/**  * Sets the content source to index.  * <p>  * <b>Note: the number of objects passed to this method as varargs must be an even  * number. Also the first argument in each pair (the field name) must have a  * valid String representation.</b>  * </p>  */ ;/**  * Sets the content source to index.  * <p>  * <b>Note: the number of objects passed to this method as varargs must be an even  * number. Also the first argument in each pair (the field name) must have a  * valid String representation.</b>  * </p>  */ public IndexRequest source(XContentType xContentType, Object... source) {     if (source.length % 2 != 0) {         throw new IllegalArgumentException("The number of object passed must be even but was [" + source.length + "]").     }     if (source.length == 2 && source[0] instanceof BytesReference && source[1] instanceof Boolean) {         throw new IllegalArgumentException("you are using the removed method for source with bytes and unsafe flag, the unsafe flag" + " was removed, please just use source(BytesReference)").     }     try {         XContentBuilder builder = XContentFactory.contentBuilder(xContentType).         builder.startObject().         for (int i = 0. i < source.length. i++) {             builder.field(source[i++].toString(), source[i]).         }         builder.endObject().         return source(builder).     } catch (IOException e) {         throw new ElasticsearchGenerationException("Failed to generate", e).     } }
true;public;2;5;/**  * Sets the document to index in bytes form.  */ ;/**  * Sets the document to index in bytes form.  */ public IndexRequest source(BytesReference source, XContentType xContentType) {     this.source = Objects.requireNonNull(source).     this.contentType = Objects.requireNonNull(xContentType).     return this. }
true;public;2;3;/**  * Sets the document to index in bytes form.  */ ;/**  * Sets the document to index in bytes form.  */ public IndexRequest source(byte[] source, XContentType xContentType) {     return source(source, 0, source.length, xContentType). }
true;public;4;3;/**  * Sets the document to index in bytes form (assumed to be safe to be used from different  * threads).  *  * @param source The source to index  * @param offset The offset in the byte array  * @param length The length of the data  */ ;/**  * Sets the document to index in bytes form (assumed to be safe to be used from different  * threads).  *  * @param source The source to index  * @param offset The offset in the byte array  * @param length The length of the data  */ public IndexRequest source(byte[] source, int offset, int length, XContentType xContentType) {     return source(new BytesArray(source, offset, length), xContentType). }
true;public;1;7;/**  * Sets the type of operation to perform.  */ ;/**  * Sets the type of operation to perform.  */ public IndexRequest opType(OpType opType) {     if (opType != OpType.CREATE && opType != OpType.INDEX) {         throw new IllegalArgumentException("opType must be 'create' or 'index', found: [" + opType + "]").     }     this.opType = opType.     return this. }
true;public;1;11;/**  * Sets a string representation of the {@link #opType(OpType)}. Can  * be either "index" or "create".  */ ;/**  * Sets a string representation of the {@link #opType(OpType)}. Can  * be either "index" or "create".  */ public IndexRequest opType(String opType) {     String op = opType.toLowerCase(Locale.ROOT).     if (op.equals("create")) {         opType(OpType.CREATE).     } else if (op.equals("index")) {         opType(OpType.INDEX).     } else {         throw new IllegalArgumentException("opType must be 'create' or 'index', found: [" + opType + "]").     }     return this. }
true;public;1;7;/**  * Set to {@code true} to force this index to use {@link OpType#CREATE}.  */ ;/**  * Set to {@code true} to force this index to use {@link OpType#CREATE}.  */ public IndexRequest create(boolean create) {     if (create) {         return opType(OpType.CREATE).     } else {         return opType(OpType.INDEX).     } }
false;public;0;4;;@Override public OpType opType() {     return this.opType. }
false;public;1;5;;@Override public IndexRequest version(long version) {     this.version = version.     return this. }
true;public;0;4;/**  * Returns stored version. If currently stored version is {@link Versions#MATCH_ANY} and  * opType is {@link OpType#CREATE}, returns {@link Versions#MATCH_DELETED}.  */ ;/**  * Returns stored version. If currently stored version is {@link Versions#MATCH_ANY} and  * opType is {@link OpType#CREATE}, returns {@link Versions#MATCH_DELETED}.  */ @Override public long version() {     return resolveVersionDefaults(). }
true;private;0;7;/**  * Resolves the version based on operation type {@link #opType()}.  */ ;/**  * Resolves the version based on operation type {@link #opType()}.  */ private long resolveVersionDefaults() {     if (opType == OpType.CREATE && version == Versions.MATCH_ANY) {         return Versions.MATCH_DELETED.     } else {         return version.     } }
false;public;1;5;;@Override public IndexRequest versionType(VersionType versionType) {     this.versionType = versionType.     return this. }
true;public;1;7;/**  * only perform this indexing request if the document was last modification was assigned the given  * sequence number. Must be used in combination with {@link #setIfPrimaryTerm(long)}  *  * If the document last modification was assigned a different sequence number a  * {@link org.elasticsearch.index.engine.VersionConflictEngineException} will be thrown.  */ ;/**  * only perform this indexing request if the document was last modification was assigned the given  * sequence number. Must be used in combination with {@link #setIfPrimaryTerm(long)}  *  * If the document last modification was assigned a different sequence number a  * {@link org.elasticsearch.index.engine.VersionConflictEngineException} will be thrown.  */ public IndexRequest setIfSeqNo(long seqNo) {     if (seqNo < 0 && seqNo != UNASSIGNED_SEQ_NO) {         throw new IllegalArgumentException("sequence numbers must be non negative. got [" + seqNo + "].").     }     ifSeqNo = seqNo.     return this. }
true;public;1;7;/**  * only performs this indexing request if the document was last modification was assigned the given  * primary term. Must be used in combination with {@link #setIfSeqNo(long)}  *  * If the document last modification was assigned a different term a  * {@link org.elasticsearch.index.engine.VersionConflictEngineException} will be thrown.  */ ;/**  * only performs this indexing request if the document was last modification was assigned the given  * primary term. Must be used in combination with {@link #setIfSeqNo(long)}  *  * If the document last modification was assigned a different term a  * {@link org.elasticsearch.index.engine.VersionConflictEngineException} will be thrown.  */ public IndexRequest setIfPrimaryTerm(long term) {     if (term < 0) {         throw new IllegalArgumentException("primary term must be non negative. got [" + term + "]").     }     ifPrimaryTerm = term.     return this. }
true;public;0;3;/**  * If set, only perform this indexing request if the document was last modification was assigned this sequence number.  * If the document last modification was assigned a different sequence number a  * {@link org.elasticsearch.index.engine.VersionConflictEngineException} will be thrown.  */ ;/**  * If set, only perform this indexing request if the document was last modification was assigned this sequence number.  * If the document last modification was assigned a different sequence number a  * {@link org.elasticsearch.index.engine.VersionConflictEngineException} will be thrown.  */ public long ifSeqNo() {     return ifSeqNo. }
true;public;0;3;/**  * If set, only perform this indexing request if the document was last modification was assigned this primary term.  *  * If the document last modification was assigned a different term a  * {@link org.elasticsearch.index.engine.VersionConflictEngineException} will be thrown.  */ ;/**  * If set, only perform this indexing request if the document was last modification was assigned this primary term.  *  * If the document last modification was assigned a different term a  * {@link org.elasticsearch.index.engine.VersionConflictEngineException} will be thrown.  */ public long ifPrimaryTerm() {     return ifPrimaryTerm. }
false;public;0;4;;@Override public VersionType versionType() {     return this.versionType. }
false;public;3;27;;public void process(Version indexCreatedVersion, @Nullable MappingMetaData mappingMd, String concreteIndex) {     if (mappingMd != null) {         // might as well check for routing here         if (mappingMd.routing().required() && routing == null) {             throw new RoutingMissingException(concreteIndex, type(), id).         }     }     if ("".equals(id)) {         throw new IllegalArgumentException("if _id is specified it must not be empty").     }     // generate id if not already provided     if (id == null) {         assert autoGeneratedTimestamp == -1 : "timestamp has already been generated!".         assert ifSeqNo == UNASSIGNED_SEQ_NO.         assert ifPrimaryTerm == UNASSIGNED_PRIMARY_TERM.         // extra paranoia         autoGeneratedTimestamp = Math.max(0, System.currentTimeMillis()).         String uid.         if (indexCreatedVersion.onOrAfter(Version.V_6_0_0_beta1)) {             uid = UUIDs.base64UUID().         } else {             uid = UUIDs.legacyBase64UUID().         }         id(uid).     } }
true;public;1;3;/* resolve the routing if needed */ ;/* resolve the routing if needed */ public void resolveRouting(MetaData metaData) {     routing(metaData.resolveWriteIndexRouting(routing, index)). }
false;public;1;33;;@Override public void readFrom(StreamInput in) throws IOException {     super.readFrom(in).     type = in.readOptionalString().     id = in.readOptionalString().     routing = in.readOptionalString().     if (in.getVersion().before(Version.V_7_0_0)) {         // _parent         in.readOptionalString().     }     if (in.getVersion().before(Version.V_6_0_0_alpha1)) {         // timestamp         in.readOptionalString().         // ttl         in.readOptionalTimeValue().     }     source = in.readBytesReference().     opType = OpType.fromId(in.readByte()).     version = in.readLong().     versionType = VersionType.fromValue(in.readByte()).     pipeline = in.readOptionalString().     isRetry = in.readBoolean().     autoGeneratedTimestamp = in.readLong().     if (in.readBoolean()) {         contentType = in.readEnum(XContentType.class).     } else {         contentType = null.     }     if (in.getVersion().onOrAfter(Version.V_6_6_0)) {         ifSeqNo = in.readZLong().         ifPrimaryTerm = in.readVLong().     } else {         ifSeqNo = UNASSIGNED_SEQ_NO.         ifPrimaryTerm = UNASSIGNED_PRIMARY_TERM.     } }
false;public;1;41;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     // A 7.x request allows null types but if deserialized in a 6.x node will cause nullpointer exceptions.     // So we use the type accessor method here to make the type non-null (will default it to "_doc").     out.writeOptionalString(type()).     out.writeOptionalString(id).     out.writeOptionalString(routing).     if (out.getVersion().before(Version.V_7_0_0)) {         // _parent         out.writeOptionalString(null).     }     if (out.getVersion().before(Version.V_6_0_0_alpha1)) {         // Serialize a fake timestamp. 5.x expect this value to be set by the #process method so we can't use null.         // On the other hand, indices created on 5.x do not index the timestamp field.  Therefore passing a 0 (or any value) for         // the transport layer OK as it will be ignored.         out.writeOptionalString("0").         out.writeOptionalWriteable(null).     }     out.writeBytesReference(source).     out.writeByte(opType.getId()).     out.writeLong(version).     out.writeByte(versionType.getValue()).     out.writeOptionalString(pipeline).     out.writeBoolean(isRetry).     out.writeLong(autoGeneratedTimestamp).     if (contentType != null) {         out.writeBoolean(true).         out.writeEnum(contentType).     } else {         out.writeBoolean(false).     }     if (out.getVersion().onOrAfter(Version.V_6_6_0)) {         out.writeZLong(ifSeqNo).         out.writeVLong(ifPrimaryTerm).     } else if (ifSeqNo != UNASSIGNED_SEQ_NO || ifPrimaryTerm != UNASSIGNED_PRIMARY_TERM) {         assert false : "setIfMatch [" + ifSeqNo + "], currentDocTem [" + ifPrimaryTerm + "]".         throw new IllegalStateException("sequence number based compare and write is not supported until all nodes are on version 7.0 or higher. " + "Stream version [" + out.getVersion() + "]").     } }
false;public;0;15;;@Override public String toString() {     String sSource = "_na_".     try {         if (source.length() > MAX_SOURCE_LENGTH_IN_TOSTRING) {             sSource = "n/a, actual length: [" + new ByteSizeValue(source.length()).toString() + "], max length: " + new ByteSizeValue(MAX_SOURCE_LENGTH_IN_TOSTRING).toString().         } else {             sSource = XContentHelper.convertToJson(source, false).         }     } catch (Exception e) {     // ignore     }     return "index {[" + index + "][" + type() + "][" + id + "], source[" + sSource + "]}". }
true;public;0;3;/**  * Returns <code>true</code> if this request has been sent to a shard copy more than once.  */ ;/**  * Returns <code>true</code> if this request has been sent to a shard copy more than once.  */ public boolean isRetry() {     return isRetry. }
false;public;0;4;;@Override public void onRetry() {     isRetry = true. }
true;public;0;3;/**  * Returns the timestamp the auto generated ID was created or {@value #UNSET_AUTO_GENERATED_TIMESTAMP} if the  * document has no auto generated timestamp. This method will return a positive value iff the id was auto generated.  */ ;/**  * Returns the timestamp the auto generated ID was created or {@value #UNSET_AUTO_GENERATED_TIMESTAMP} if the  * document has no auto generated timestamp. This method will return a positive value iff the id was auto generated.  */ public long getAutoGeneratedTimestamp() {     return autoGeneratedTimestamp. }
true;public;1;4;/**  * Override this method from ReplicationAction, this is where we are storing our state in the request object (which we really shouldn't  * do). Once the transport client goes away we can move away from making this available, but in the meantime this is dangerous to set or  * use because the IndexRequest object will always be wrapped in a bulk request envelope, which is where this *should* be set.  */ ;/**  * Override this method from ReplicationAction, this is where we are storing our state in the request object (which we really shouldn't  * do). Once the transport client goes away we can move away from making this available, but in the meantime this is dangerous to set or  * use because the IndexRequest object will always be wrapped in a bulk request envelope, which is where this *should* be set.  */ @Override public IndexRequest setShardId(ShardId shardId) {     throw new UnsupportedOperationException("shard id should never be set on IndexRequest"). }
