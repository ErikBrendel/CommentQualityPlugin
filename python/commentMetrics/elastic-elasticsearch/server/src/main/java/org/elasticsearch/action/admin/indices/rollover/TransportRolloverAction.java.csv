commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;5;;@Override protected String executor() {     // we go async right away     return ThreadPool.Names.SAME. }
false;protected;0;4;;@Override protected RolloverResponse newResponse() {     return new RolloverResponse(). }
false;protected;2;7;;@Override protected ClusterBlockException checkBlock(RolloverRequest request, ClusterState state) {     IndicesOptions indicesOptions = IndicesOptions.fromOptions(true, true, request.indicesOptions().expandWildcardsOpen(), request.indicesOptions().expandWildcardsClosed()).     return state.blocks().indicesBlockedException(ClusterBlockLevel.METADATA_WRITE, indexNameExpressionResolver.concreteIndexNames(state, indicesOptions, request.indices())). }
false;public;1;9;;@Override public ClusterState execute(ClusterState currentState) {     RolloverInfo rolloverInfo = new RolloverInfo(rolloverRequest.getAlias(), metConditions, threadPool.absoluteTimeInMillis()).     return ClusterState.builder(currentState).metaData(MetaData.builder(currentState.metaData()).put(IndexMetaData.builder(currentState.metaData().index(sourceIndexName)).putRolloverInfo(rolloverInfo))).build(). }
false;public;2;4;;@Override public void onFailure(String source, Exception e) {     listener.onFailure(e). }
false;public;3;10;;@Override public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {     activeShardsObserver.waitForActiveShards(new String[] { rolloverIndexName }, rolloverRequest.getCreateIndexRequest().waitForActiveShards(), rolloverRequest.masterNodeTimeout(), isShardsAcknowledged -> listener.onResponse(new RolloverResponse(sourceIndexName, rolloverIndexName, conditionResults, false, true, true, isShardsAcknowledged)), listener::onFailure). }
false;public;1;67;;@Override public void onResponse(IndicesStatsResponse statsResponse) {     final Map<String, Boolean> conditionResults = evaluateConditions(rolloverRequest.getConditions().values(), metaData.index(sourceIndexName), statsResponse).     if (rolloverRequest.isDryRun()) {         listener.onResponse(new RolloverResponse(sourceIndexName, rolloverIndexName, conditionResults, true, false, false, false)).         return.     }     List<Condition<?>> metConditions = rolloverRequest.getConditions().values().stream().filter(condition -> conditionResults.get(condition.toString())).collect(Collectors.toList()).     if (conditionResults.size() == 0 || metConditions.size() > 0) {         CreateIndexClusterStateUpdateRequest updateRequest = prepareCreateIndexRequest(unresolvedName, rolloverIndexName, rolloverRequest).         createIndexService.createIndex(updateRequest, ActionListener.wrap(createIndexClusterStateUpdateResponse -> {             final IndicesAliasesClusterStateUpdateRequest aliasesUpdateRequest.             if (explicitWriteIndex) {                 aliasesUpdateRequest = prepareRolloverAliasesWriteIndexUpdateRequest(sourceIndexName, rolloverIndexName, rolloverRequest).             } else {                 aliasesUpdateRequest = prepareRolloverAliasesUpdateRequest(sourceIndexName, rolloverIndexName, rolloverRequest).             }             indexAliasesService.indicesAliases(aliasesUpdateRequest, ActionListener.wrap(aliasClusterStateUpdateResponse -> {                 if (aliasClusterStateUpdateResponse.isAcknowledged()) {                     clusterService.submitStateUpdateTask("update_rollover_info", new ClusterStateUpdateTask() {                          @Override                         public ClusterState execute(ClusterState currentState) {                             RolloverInfo rolloverInfo = new RolloverInfo(rolloverRequest.getAlias(), metConditions, threadPool.absoluteTimeInMillis()).                             return ClusterState.builder(currentState).metaData(MetaData.builder(currentState.metaData()).put(IndexMetaData.builder(currentState.metaData().index(sourceIndexName)).putRolloverInfo(rolloverInfo))).build().                         }                          @Override                         public void onFailure(String source, Exception e) {                             listener.onFailure(e).                         }                          @Override                         public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {                             activeShardsObserver.waitForActiveShards(new String[] { rolloverIndexName }, rolloverRequest.getCreateIndexRequest().waitForActiveShards(), rolloverRequest.masterNodeTimeout(), isShardsAcknowledged -> listener.onResponse(new RolloverResponse(sourceIndexName, rolloverIndexName, conditionResults, false, true, true, isShardsAcknowledged)), listener::onFailure).                         }                     }).                 } else {                     listener.onResponse(new RolloverResponse(sourceIndexName, rolloverIndexName, conditionResults, false, true, false, false)).                 }             }, listener::onFailure)).         }, listener::onFailure)).     } else {         // conditions not met         listener.onResponse(new RolloverResponse(sourceIndexName, rolloverIndexName, conditionResults, false, false, false, false)).     } }
false;public;1;4;;@Override public void onFailure(Exception e) {     listener.onFailure(e). }
false;protected;3;94;;@Override protected void masterOperation(final RolloverRequest rolloverRequest, final ClusterState state, final ActionListener<RolloverResponse> listener) {     final MetaData metaData = state.metaData().     validate(metaData, rolloverRequest).     final AliasOrIndex.Alias alias = (AliasOrIndex.Alias) metaData.getAliasAndIndexLookup().get(rolloverRequest.getAlias()).     final IndexMetaData indexMetaData = alias.getWriteIndex().     final boolean explicitWriteIndex = Boolean.TRUE.equals(indexMetaData.getAliases().get(alias.getAliasName()).writeIndex()).     final String sourceProvidedName = indexMetaData.getSettings().get(IndexMetaData.SETTING_INDEX_PROVIDED_NAME, indexMetaData.getIndex().getName()).     final String sourceIndexName = indexMetaData.getIndex().getName().     final String unresolvedName = (rolloverRequest.getNewIndexName() != null) ? rolloverRequest.getNewIndexName() : generateRolloverIndexName(sourceProvidedName, indexNameExpressionResolver).     final String rolloverIndexName = indexNameExpressionResolver.resolveDateMathExpression(unresolvedName).     // will fail if the index already exists     MetaDataCreateIndexService.validateIndexName(rolloverIndexName, state).     checkNoDuplicatedAliasInIndexTemplate(metaData, rolloverIndexName, rolloverRequest.getAlias()).     client.admin().indices().prepareStats(sourceIndexName).clear().setDocs(true).execute(new ActionListener<IndicesStatsResponse>() {          @Override         public void onResponse(IndicesStatsResponse statsResponse) {             final Map<String, Boolean> conditionResults = evaluateConditions(rolloverRequest.getConditions().values(), metaData.index(sourceIndexName), statsResponse).             if (rolloverRequest.isDryRun()) {                 listener.onResponse(new RolloverResponse(sourceIndexName, rolloverIndexName, conditionResults, true, false, false, false)).                 return.             }             List<Condition<?>> metConditions = rolloverRequest.getConditions().values().stream().filter(condition -> conditionResults.get(condition.toString())).collect(Collectors.toList()).             if (conditionResults.size() == 0 || metConditions.size() > 0) {                 CreateIndexClusterStateUpdateRequest updateRequest = prepareCreateIndexRequest(unresolvedName, rolloverIndexName, rolloverRequest).                 createIndexService.createIndex(updateRequest, ActionListener.wrap(createIndexClusterStateUpdateResponse -> {                     final IndicesAliasesClusterStateUpdateRequest aliasesUpdateRequest.                     if (explicitWriteIndex) {                         aliasesUpdateRequest = prepareRolloverAliasesWriteIndexUpdateRequest(sourceIndexName, rolloverIndexName, rolloverRequest).                     } else {                         aliasesUpdateRequest = prepareRolloverAliasesUpdateRequest(sourceIndexName, rolloverIndexName, rolloverRequest).                     }                     indexAliasesService.indicesAliases(aliasesUpdateRequest, ActionListener.wrap(aliasClusterStateUpdateResponse -> {                         if (aliasClusterStateUpdateResponse.isAcknowledged()) {                             clusterService.submitStateUpdateTask("update_rollover_info", new ClusterStateUpdateTask() {                                  @Override                                 public ClusterState execute(ClusterState currentState) {                                     RolloverInfo rolloverInfo = new RolloverInfo(rolloverRequest.getAlias(), metConditions, threadPool.absoluteTimeInMillis()).                                     return ClusterState.builder(currentState).metaData(MetaData.builder(currentState.metaData()).put(IndexMetaData.builder(currentState.metaData().index(sourceIndexName)).putRolloverInfo(rolloverInfo))).build().                                 }                                  @Override                                 public void onFailure(String source, Exception e) {                                     listener.onFailure(e).                                 }                                  @Override                                 public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {                                     activeShardsObserver.waitForActiveShards(new String[] { rolloverIndexName }, rolloverRequest.getCreateIndexRequest().waitForActiveShards(), rolloverRequest.masterNodeTimeout(), isShardsAcknowledged -> listener.onResponse(new RolloverResponse(sourceIndexName, rolloverIndexName, conditionResults, false, true, true, isShardsAcknowledged)), listener::onFailure).                                 }                             }).                         } else {                             listener.onResponse(new RolloverResponse(sourceIndexName, rolloverIndexName, conditionResults, false, true, false, false)).                         }                     }, listener::onFailure)).                 }, listener::onFailure)).             } else {                 // conditions not met                 listener.onResponse(new RolloverResponse(sourceIndexName, rolloverIndexName, conditionResults, false, false, false, false)).             }         }          @Override         public void onFailure(Exception e) {             listener.onFailure(e).         }     }). }
false;static;3;10;;static IndicesAliasesClusterStateUpdateRequest prepareRolloverAliasesUpdateRequest(String oldIndex, String newIndex, RolloverRequest request) {     List<AliasAction> actions = unmodifiableList(Arrays.asList(new AliasAction.Add(newIndex, request.getAlias(), null, null, null, null), new AliasAction.Remove(oldIndex, request.getAlias()))).     final IndicesAliasesClusterStateUpdateRequest updateRequest = new IndicesAliasesClusterStateUpdateRequest(actions).ackTimeout(request.ackTimeout()).masterNodeTimeout(request.masterNodeTimeout()).     return updateRequest. }
false;static;3;10;;static IndicesAliasesClusterStateUpdateRequest prepareRolloverAliasesWriteIndexUpdateRequest(String oldIndex, String newIndex, RolloverRequest request) {     List<AliasAction> actions = unmodifiableList(Arrays.asList(new AliasAction.Add(newIndex, request.getAlias(), null, null, null, true), new AliasAction.Add(oldIndex, request.getAlias(), null, null, null, false))).     final IndicesAliasesClusterStateUpdateRequest updateRequest = new IndicesAliasesClusterStateUpdateRequest(actions).ackTimeout(request.ackTimeout()).masterNodeTimeout(request.masterNodeTimeout()).     return updateRequest. }
false;static;2;15;;static String generateRolloverIndexName(String sourceIndexName, IndexNameExpressionResolver indexNameExpressionResolver) {     String resolvedName = indexNameExpressionResolver.resolveDateMathExpression(sourceIndexName).     final boolean isDateMath = sourceIndexName.equals(resolvedName) == false.     if (INDEX_NAME_PATTERN.matcher(resolvedName).matches()) {         int numberIndex = sourceIndexName.lastIndexOf("-").         assert numberIndex != -1 : "no separator '-' found".         int counter = Integer.parseInt(sourceIndexName.substring(numberIndex + 1, isDateMath ? sourceIndexName.length() - 1 : sourceIndexName.length())).         String newName = sourceIndexName.substring(0, numberIndex) + "-" + String.format(Locale.ROOT, "%06d", ++counter) + (isDateMath ? ">" : "").         return newName.     } else {         throw new IllegalArgumentException("index name [" + sourceIndexName + "] does not match pattern '^.*-\\d+$'").     } }
false;static;3;9;;static Map<String, Boolean> evaluateConditions(final Collection<Condition<?>> conditions, final DocsStats docsStats, final IndexMetaData metaData) {     final long numDocs = docsStats == null ? 0 : docsStats.getCount().     final long indexSize = docsStats == null ? 0 : docsStats.getTotalSizeInBytes().     final Condition.Stats stats = new Condition.Stats(numDocs, metaData.getCreationDate(), new ByteSizeValue(indexSize)).     return conditions.stream().map(condition -> condition.evaluate(stats)).collect(Collectors.toMap(result -> result.condition.toString(), result -> result.matched)). }
false;static;3;4;;static Map<String, Boolean> evaluateConditions(final Collection<Condition<?>> conditions, final IndexMetaData metaData, final IndicesStatsResponse statsResponse) {     return evaluateConditions(conditions, statsResponse.getPrimaries().getDocs(), metaData). }
false;static;2;13;;static void validate(MetaData metaData, RolloverRequest request) {     final AliasOrIndex aliasOrIndex = metaData.getAliasAndIndexLookup().get(request.getAlias()).     if (aliasOrIndex == null) {         throw new IllegalArgumentException("source alias does not exist").     }     if (aliasOrIndex.isAlias() == false) {         throw new IllegalArgumentException("source alias is a concrete index").     }     final AliasOrIndex.Alias alias = (AliasOrIndex.Alias) aliasOrIndex.     if (alias.getWriteIndex() == null) {         throw new IllegalArgumentException("source alias [" + alias.getAliasName() + "] does not point to a write index").     } }
false;static;3;15;;static CreateIndexClusterStateUpdateRequest prepareCreateIndexRequest(final String providedIndexName, final String targetIndexName, final RolloverRequest rolloverRequest) {     final CreateIndexRequest createIndexRequest = rolloverRequest.getCreateIndexRequest().     createIndexRequest.cause("rollover_index").     createIndexRequest.index(targetIndexName).     return new CreateIndexClusterStateUpdateRequest(createIndexRequest, "rollover_index", targetIndexName, providedIndexName).ackTimeout(createIndexRequest.timeout()).masterNodeTimeout(createIndexRequest.masterNodeTimeout()).settings(createIndexRequest.settings()).aliases(createIndexRequest.aliases()).waitForActiveShards(// not waiting for shards here, will wait on the alias switch operation     ActiveShardCount.NONE).mappings(createIndexRequest.mappings()). }
true;static;3;10;/**  * If the newly created index matches with an index template whose aliases contains the rollover alias,  * the rollover alias will point to multiple indices. This causes indexing requests to be rejected.  * To avoid this, we make sure that there is no duplicated alias in index templates before creating a new index.  */ ;/**  * If the newly created index matches with an index template whose aliases contains the rollover alias,  * the rollover alias will point to multiple indices. This causes indexing requests to be rejected.  * To avoid this, we make sure that there is no duplicated alias in index templates before creating a new index.  */ static void checkNoDuplicatedAliasInIndexTemplate(MetaData metaData, String rolloverIndexName, String rolloverRequestAlias) {     final List<IndexTemplateMetaData> matchedTemplates = MetaDataIndexTemplateService.findTemplates(metaData, rolloverIndexName).     for (IndexTemplateMetaData template : matchedTemplates) {         if (template.aliases().containsKey(rolloverRequestAlias)) {             throw new IllegalArgumentException(String.format(Locale.ROOT, "Rollover alias [%s] can point to multiple indices, found duplicated alias [%s] in index template [%s]", rolloverRequestAlias, template.aliases().keys(), template.name())).         }     } }
