commented;modifiers;parameterAmount;loc;comment;code
false;private,static;2;8;;private static PluginsService newPluginService(final Settings settings, Collection<Class<? extends Plugin>> plugins) {     final Settings.Builder settingsBuilder = Settings.builder().put(TransportSettings.PING_SCHEDULE.getKey(), // enable by default the transport schedule ping interval     "5s").put(InternalSettingsPreparer.prepareSettings(settings)).put(NetworkService.NETWORK_SERVER.getKey(), false).put(CLIENT_TYPE_SETTING_S.getKey(), CLIENT_TYPE).     return new PluginsService(settingsBuilder.build(), null, null, null, plugins). }
false;protected,static;2;4;;protected static Collection<Class<? extends Plugin>> addPlugins(Collection<Class<? extends Plugin>> collection, Class<? extends Plugin>... plugins) {     return addPlugins(collection, Arrays.asList(plugins)). }
false;protected,static;2;11;;protected static Collection<Class<? extends Plugin>> addPlugins(Collection<Class<? extends Plugin>> collection, Collection<Class<? extends Plugin>> plugins) {     ArrayList<Class<? extends Plugin>> list = new ArrayList<>(collection).     for (Class<? extends Plugin> p : plugins) {         if (list.contains(p)) {             throw new IllegalArgumentException("plugin already exists: " + p).         }         list.add(p).     }     return list. }
false;private,static;4;108;;private static ClientTemplate buildTemplate(Settings providedSettings, Settings defaultSettings, Collection<Class<? extends Plugin>> plugins, HostFailureListener failureListner) {     if (Node.NODE_NAME_SETTING.exists(providedSettings) == false) {         providedSettings = Settings.builder().put(providedSettings).put(Node.NODE_NAME_SETTING.getKey(), "_client_").build().     }     final PluginsService pluginsService = newPluginService(providedSettings, plugins).     final Settings settings = Settings.builder().put(defaultSettings).put(pluginsService.updatedSettings()).put(TransportSettings.FEATURE_PREFIX + "." + TRANSPORT_CLIENT_FEATURE, true).build().     final List<Closeable> resourcesToClose = new ArrayList<>().     final ThreadPool threadPool = new ThreadPool(settings).     resourcesToClose.add(() -> ThreadPool.terminate(threadPool, 10, TimeUnit.SECONDS)).     final NetworkService networkService = new NetworkService(Collections.emptyList()).     try {         final List<Setting<?>> additionalSettings = new ArrayList<>(pluginsService.getPluginSettings()).         final List<String> additionalSettingsFilter = new ArrayList<>(pluginsService.getPluginSettingsFilter()).         for (final ExecutorBuilder<?> builder : threadPool.builders()) {             additionalSettings.addAll(builder.getRegisteredSettings()).         }         SettingsModule settingsModule = new SettingsModule(settings, additionalSettings, additionalSettingsFilter, Collections.emptySet()).         SearchModule searchModule = new SearchModule(settings, true, pluginsService.filterPlugins(SearchPlugin.class)).         IndicesModule indicesModule = new IndicesModule(Collections.emptyList()).         List<NamedWriteableRegistry.Entry> entries = new ArrayList<>().         entries.addAll(NetworkModule.getNamedWriteables()).         entries.addAll(searchModule.getNamedWriteables()).         entries.addAll(indicesModule.getNamedWriteables()).         entries.addAll(ClusterModule.getNamedWriteables()).         entries.addAll(pluginsService.filterPlugins(Plugin.class).stream().flatMap(p -> p.getNamedWriteables().stream()).collect(Collectors.toList())).         NamedWriteableRegistry namedWriteableRegistry = new NamedWriteableRegistry(entries).         NamedXContentRegistry xContentRegistry = new NamedXContentRegistry(Stream.of(searchModule.getNamedXContents().stream(), pluginsService.filterPlugins(Plugin.class).stream().flatMap(p -> p.getNamedXContent().stream())).flatMap(Function.identity()).collect(toList())).         ModulesBuilder modules = new ModulesBuilder().         // plugin modules must be added here, before others or we can get crazy injection errors...         for (Module pluginModule : pluginsService.createGuiceModules()) {             modules.add(pluginModule).         }         modules.add(b -> b.bind(ThreadPool.class).toInstance(threadPool)).         ActionModule actionModule = new ActionModule(true, settings, null, settingsModule.getIndexScopedSettings(), settingsModule.getClusterSettings(), settingsModule.getSettingsFilter(), threadPool, pluginsService.filterPlugins(ActionPlugin.class), null, null, null).         modules.add(actionModule).         CircuitBreakerService circuitBreakerService = Node.createCircuitBreakerService(settingsModule.getSettings(), settingsModule.getClusterSettings()).         resourcesToClose.add(circuitBreakerService).         PageCacheRecycler pageCacheRecycler = new PageCacheRecycler(settings).         BigArrays bigArrays = new BigArrays(pageCacheRecycler, circuitBreakerService, CircuitBreaker.REQUEST).         resourcesToClose.add(pageCacheRecycler).         modules.add(settingsModule).         NetworkModule networkModule = new NetworkModule(settings, true, pluginsService.filterPlugins(NetworkPlugin.class), threadPool, bigArrays, pageCacheRecycler, circuitBreakerService, namedWriteableRegistry, xContentRegistry, networkService, null).         final Transport transport = networkModule.getTransportSupplier().get().         final TransportService transportService = new TransportService(settings, transport, threadPool, networkModule.getTransportInterceptor(), boundTransportAddress -> DiscoveryNode.createLocal(settings, new TransportAddress(TransportAddress.META_ADDRESS, 0), UUIDs.randomBase64UUID()), null, Collections.emptySet()).         modules.add((b -> {             b.bind(BigArrays.class).toInstance(bigArrays).             b.bind(PageCacheRecycler.class).toInstance(pageCacheRecycler).             b.bind(PluginsService.class).toInstance(pluginsService).             b.bind(CircuitBreakerService.class).toInstance(circuitBreakerService).             b.bind(NamedWriteableRegistry.class).toInstance(namedWriteableRegistry).             b.bind(Transport.class).toInstance(transport).             b.bind(TransportService.class).toInstance(transportService).             b.bind(NetworkService.class).toInstance(networkService).         })).         Injector injector = modules.createInjector().         final TransportClientNodesService nodesService = new TransportClientNodesService(settings, transportService, threadPool, failureListner == null ? (t, e) -> {         } : failureListner).         // construct the list of client actions         final List<ActionPlugin> actionPlugins = pluginsService.filterPlugins(ActionPlugin.class).         final List<Action> clientActions = actionPlugins.stream().flatMap(p -> p.getClientActions().stream()).collect(Collectors.toList()).         // add all the base actions         final List<? extends Action<?>> baseActions = actionModule.getActions().values().stream().map(ActionPlugin.ActionHandler::getAction).collect(Collectors.toList()).         clientActions.addAll(baseActions).         final TransportProxyClient proxy = new TransportProxyClient(settings, transportService, nodesService, clientActions).         List<LifecycleComponent> pluginLifecycleComponents = new ArrayList<>(pluginsService.getGuiceServiceClasses().stream().map(injector::getInstance).collect(Collectors.toList())).         resourcesToClose.addAll(pluginLifecycleComponents).         transportService.start().         transportService.acceptIncomingRequests().         ClientTemplate transportClient = new ClientTemplate(injector, pluginLifecycleComponents, nodesService, proxy, namedWriteableRegistry).         resourcesToClose.clear().         return transportClient.     } finally {         IOUtils.closeWhileHandlingException(resourcesToClose).     } }
false;;0;3;;Settings getSettings() {     return injector.getInstance(Settings.class). }
false;;0;3;;ThreadPool getThreadPool() {     return injector.getInstance(ThreadPool.class). }
true;public;0;3;/**  * Returns the current registered transport addresses to use (added using  * {@link #addTransportAddress(org.elasticsearch.common.transport.TransportAddress)}.  */ ;/**  * Returns the current registered transport addresses to use (added using  * {@link #addTransportAddress(org.elasticsearch.common.transport.TransportAddress)}.  */ public List<TransportAddress> transportAddresses() {     return nodesService.transportAddresses(). }
true;public;0;3;/**  * Returns the current connected transport nodes that this client will use.  * <p>  * The nodes include all the nodes that are currently alive based on the transport  * addresses provided.  */ ;/**  * Returns the current connected transport nodes that this client will use.  * <p>  * The nodes include all the nodes that are currently alive based on the transport  * addresses provided.  */ public List<DiscoveryNode> connectedNodes() {     return nodesService.connectedNodes(). }
true;public;0;3;/**  * The list of filtered nodes that were not connected to, for example, due to  * mismatch in cluster name.  */ ;/**  * The list of filtered nodes that were not connected to, for example, due to  * mismatch in cluster name.  */ public List<DiscoveryNode> filteredNodes() {     return nodesService.filteredNodes(). }
true;public;0;3;/**  * Returns the listed nodes in the transport client (ones added to it).  */ ;/**  * Returns the listed nodes in the transport client (ones added to it).  */ public List<DiscoveryNode> listedNodes() {     return nodesService.listedNodes(). }
true;public;1;4;/**  * Adds a transport address that will be used to connect to.  * <p>  * The Node this transport address represents will be used if its possible to connect to it.  * If it is unavailable, it will be automatically connected to once it is up.  * <p>  * In order to get the list of all the current connected nodes, please see {@link #connectedNodes()}.  */ ;/**  * Adds a transport address that will be used to connect to.  * <p>  * The Node this transport address represents will be used if its possible to connect to it.  * If it is unavailable, it will be automatically connected to once it is up.  * <p>  * In order to get the list of all the current connected nodes, please see {@link #connectedNodes()}.  */ public TransportClient addTransportAddress(TransportAddress transportAddress) {     nodesService.addTransportAddresses(transportAddress).     return this. }
true;public;1;4;/**  * Adds a list of transport addresses that will be used to connect to.  * <p>  * The Node this transport address represents will be used if its possible to connect to it.  * If it is unavailable, it will be automatically connected to once it is up.  * <p>  * In order to get the list of all the current connected nodes, please see {@link #connectedNodes()}.  */ ;/**  * Adds a list of transport addresses that will be used to connect to.  * <p>  * The Node this transport address represents will be used if its possible to connect to it.  * If it is unavailable, it will be automatically connected to once it is up.  * <p>  * In order to get the list of all the current connected nodes, please see {@link #connectedNodes()}.  */ public TransportClient addTransportAddresses(TransportAddress... transportAddress) {     nodesService.addTransportAddresses(transportAddress).     return this. }
true;public;1;4;/**  * Removes a transport address from the list of transport addresses that are used to connect to.  */ ;/**  * Removes a transport address from the list of transport addresses that are used to connect to.  */ public TransportClient removeTransportAddress(TransportAddress transportAddress) {     nodesService.removeTransportAddress(transportAddress).     return this. }
true;public;0;13;/**  * Closes the client.  */ ;/**  * Closes the client.  */ @Override public void close() {     List<Closeable> closeables = new ArrayList<>().     closeables.add(nodesService).     closeables.add(injector.getInstance(TransportService.class)).     for (LifecycleComponent plugin : pluginLifecycleComponents) {         closeables.add(plugin).     }     closeables.add(() -> ThreadPool.terminate(injector.getInstance(ThreadPool.class), 10, TimeUnit.SECONDS)).     closeables.add(injector.getInstance(PageCacheRecycler.class)).     IOUtils.closeWhileHandlingException(closeables). }
false;protected;3;5;;@Override protected <Request extends ActionRequest, Response extends ActionResponse> void doExecute(Action<Response> action, Request request, ActionListener<Response> listener) {     proxy.execute(action, request, listener). }
true;;2;1;/**  * Called once a node disconnect is detected.  * @param node the node that has been disconnected  * @param ex the exception causing the disconnection  */ ;/**  * Called once a node disconnect is detected.  * @param node the node that has been disconnected  * @param ex the exception causing the disconnection  */ void onNodeDisconnected(DiscoveryNode node, Exception ex).
true;;0;3;// pkg private for testing ;// pkg private for testing TransportClientNodesService getNodesService() {     return nodesService. }
