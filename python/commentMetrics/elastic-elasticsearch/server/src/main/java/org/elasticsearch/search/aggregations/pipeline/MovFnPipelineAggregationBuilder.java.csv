commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;8;;@Override protected void doWriteTo(StreamOutput out) throws IOException {     out.writeString(bucketsPathString).     script.writeTo(out).     out.writeOptionalString(format).     gapPolicy.writeTo(out).     out.writeInt(window). }
true;public;1;7;/**  * Sets the format to use on the output of this aggregation.  */ ;/**  * Sets the format to use on the output of this aggregation.  */ public MovFnPipelineAggregationBuilder format(String format) {     if (Strings.isNullOrEmpty(format)) {         throw new IllegalArgumentException("[" + FORMAT.getPreferredName() + "] must not be null or an empty string.").     }     this.format = format.     return this. }
true;public;0;3;/**  * Gets the format to use on the output of this aggregation.  */ ;/**  * Gets the format to use on the output of this aggregation.  */ public String format() {     return format. }
false;protected;0;6;;protected DocValueFormat formatter() {     if (format != null) {         return new DocValueFormat.Decimal(format).     }     return DocValueFormat.RAW. }
true;public;1;7;/**  * Sets the gap policy to use for this aggregation.  */ ;/**  * Sets the gap policy to use for this aggregation.  */ public MovFnPipelineAggregationBuilder gapPolicy(GapPolicy gapPolicy) {     if (gapPolicy == null) {         throw new IllegalArgumentException("[" + GAP_POLICY.getPreferredName() + "] must not be null.").     }     this.gapPolicy = gapPolicy.     return this. }
true;public;0;3;/**  * Gets the gap policy to use for this aggregation.  */ ;/**  * Gets the gap policy to use for this aggregation.  */ public GapPolicy gapPolicy() {     return gapPolicy. }
true;public;0;3;/**  * Returns the window size for this aggregation  */ ;/**  * Returns the window size for this aggregation  */ public int getWindow() {     return window. }
true;public;1;6;/**  * Sets the window size for this aggregation  */ ;/**  * Sets the window size for this aggregation  */ public void setWindow(int window) {     if (window <= 0) {         throw new IllegalArgumentException("[" + WINDOW.getPreferredName() + "] must be a positive, non-zero integer.").     }     this.window = window. }
false;public;3;9;;@Override public void doValidate(AggregatorFactory<?> parent, Collection<AggregationBuilder> aggFactories, Collection<PipelineAggregationBuilder> pipelineAggregatoractories) {     if (window <= 0) {         throw new IllegalArgumentException("[" + WINDOW.getPreferredName() + "] must be a positive, non-zero integer.").     }     validateSequentiallyOrderedParentAggs(parent, NAME, name). }
false;protected;1;4;;@Override protected PipelineAggregator createInternal(Map<String, Object> metaData) throws IOException {     return new MovFnPipelineAggregator(name, bucketsPathString, script, window, formatter(), gapPolicy, metaData). }
false;protected;2;11;;@Override protected XContentBuilder internalXContent(XContentBuilder builder, Params params) throws IOException {     builder.field(BUCKETS_PATH.getPreferredName(), bucketsPathString).     builder.field(Script.SCRIPT_PARSE_FIELD.getPreferredName(), script).     if (format != null) {         builder.field(FORMAT.getPreferredName(), format).     }     builder.field(GAP_POLICY.getPreferredName(), gapPolicy.getName()).     builder.field(WINDOW.getPreferredName(), window).     return builder. }
false;public,static;2;3;;public static MovFnPipelineAggregationBuilder parse(String aggName, XContentParser parser) {     return PARSER.apply(aggName).apply(parser, null). }
true;static;1;14;/**  * Used for serialization testing, since pipeline aggs serialize themselves as a named object but are parsed  * as a regular object with the name passed in.  */ ;/**  * Used for serialization testing, since pipeline aggs serialize themselves as a named object but are parsed  * as a regular object with the name passed in.  */ static MovFnPipelineAggregationBuilder parse(XContentParser parser) throws IOException {     parser.nextToken().     if (parser.currentToken().equals(XContentParser.Token.START_OBJECT)) {         parser.nextToken().         if (parser.currentToken().equals(XContentParser.Token.FIELD_NAME)) {             String aggName = parser.currentName().             // "moving_fn"             parser.nextToken().             // start_object             parser.nextToken().             return PARSER.apply(aggName).apply(parser, null).         }     }     throw new IllegalStateException("Expected aggregation name but none found"). }
false;protected;0;4;;@Override protected boolean overrideBucketsPath() {     return true. }
false;protected;0;4;;@Override protected int doHashCode() {     return Objects.hash(bucketsPathString, script, format, gapPolicy, window). }
false;protected;1;9;;@Override protected boolean doEquals(Object obj) {     MovFnPipelineAggregationBuilder other = (MovFnPipelineAggregationBuilder) obj.     return Objects.equals(bucketsPathString, other.bucketsPathString) && Objects.equals(script, other.script) && Objects.equals(format, other.format) && Objects.equals(gapPolicy, other.gapPolicy) && Objects.equals(window, other.window). }
false;public;0;4;;@Override public String getWriteableName() {     return NAME. }
