commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * @return Returns the value associated with the given key or the default value  * for the key type, if the key is not associated with any value.  * <p>  * <b>Important note:</b> For primitive type values, the value returned for a non-existing  * key may not be the default value of the primitive type (it may be any value previously  * assigned to that slot).  */ ;/**  * @return Returns the value associated with the given key or the default value  * for the key type, if the key is not associated with any value.  * <p>  * <b>Important note:</b> For primitive type values, the value returned for a non-existing  * key may not be the default value of the primitive type (it may be any value previously  * assigned to that slot).  */ public VType get(KType key) {     return map.get(key). }
true;public;2;3;/**  * @return Returns the value associated with the given key or the provided default value if the  * key is not associated with any value.  */ ;/**  * @return Returns the value associated with the given key or the provided default value if the  * key is not associated with any value.  */ public VType getOrDefault(KType key, VType defaultValue) {     return map.getOrDefault(key, defaultValue). }
true;public;1;3;/**  * Returns <code>true</code> if this container has an association to a value for  * the given key.  */ ;/**  * Returns <code>true</code> if this container has an association to a value for  * the given key.  */ public boolean containsKey(KType key) {     return map.containsKey(key). }
true;public;0;3;/**  * @return Returns the current size (number of assigned keys) in the container.  */ ;/**  * @return Returns the current size (number of assigned keys) in the container.  */ public int size() {     return map.size(). }
true;public;0;3;/**  * @return Return <code>true</code> if this hash map contains no assigned keys.  */ ;/**  * @return Return <code>true</code> if this hash map contains no assigned keys.  */ public boolean isEmpty() {     return map.isEmpty(). }
true;public;0;4;/**  * Returns a cursor over the entries (key-value pairs) in this map. The iterator is  * implemented as a cursor and it returns <b>the same cursor instance</b> on every  * call to {@link Iterator#next()}. To read the current key and value use the cursor's  * public fields. An example is shown below.  * <pre>  * for (IntShortCursor c : intShortMap)  * {  *     System.out.println(&quot.index=&quot. + c.index  *       + &quot. key=&quot. + c.key  *       + &quot. value=&quot. + c.value).  * }  * </pre>  * <p>  * The <code>index</code> field inside the cursor gives the internal index inside  * the container's implementation. The interpretation of this index depends on  * to the container.  */ ;/**  * Returns a cursor over the entries (key-value pairs) in this map. The iterator is  * implemented as a cursor and it returns <b>the same cursor instance</b> on every  * call to {@link Iterator#next()}. To read the current key and value use the cursor's  * public fields. An example is shown below.  * <pre>  * for (IntShortCursor c : intShortMap)  * {  *     System.out.println(&quot.index=&quot. + c.index  *       + &quot. key=&quot. + c.key  *       + &quot. value=&quot. + c.value).  * }  * </pre>  * <p>  * The <code>index</code> field inside the cursor gives the internal index inside  * the container's implementation. The interpretation of this index depends on  * to the container.  */ @Override public Iterator<ObjectObjectCursor<KType, VType>> iterator() {     return map.iterator(). }
true;public;0;3;/**  * Returns a specialized view of the keys of this associated container.  * The view additionally implements {@link ObjectLookupContainer}.  */ ;/**  * Returns a specialized view of the keys of this associated container.  * The view additionally implements {@link ObjectLookupContainer}.  */ public ObjectLookupContainer<KType> keys() {     return map.keys(). }
false;public;0;2;;@Override public boolean hasNext() {     return iterator.hasNext(). }
false;public;0;4;;@Override public KType next() {     return iterator.next().value. }
false;public;0;4;;@Override public void remove() {     throw new UnsupportedOperationException(). }
true;public;0;17;/**  * Returns a direct iterator over the keys.  */ ;/**  * Returns a direct iterator over the keys.  */ public Iterator<KType> keysIt() {     final Iterator<ObjectCursor<KType>> iterator = map.keys().iterator().     return new Iterator<KType>() {          @Override         public boolean hasNext() {             return iterator.hasNext().         }          @Override         public KType next() {             return iterator.next().value.         }          @Override         public void remove() {             throw new UnsupportedOperationException().         }     }. }
true;public;0;3;/**  * @return Returns a container with all values stored in this map.  */ ;/**  * @return Returns a container with all values stored in this map.  */ public ObjectContainer<VType> values() {     return map.values(). }
false;public;0;2;;@Override public boolean hasNext() {     return iterator.hasNext(). }
false;public;0;4;;@Override public VType next() {     return iterator.next().value. }
false;public;0;4;;@Override public void remove() {     throw new UnsupportedOperationException(). }
true;public;0;17;/**  * Returns a direct iterator over the keys.  */ ;/**  * Returns a direct iterator over the keys.  */ public Iterator<VType> valuesIt() {     final Iterator<ObjectCursor<VType>> iterator = map.values().iterator().     return new Iterator<VType>() {          @Override         public boolean hasNext() {             return iterator.hasNext().         }          @Override         public VType next() {             return iterator.next().value.         }          @Override         public void remove() {             throw new UnsupportedOperationException().         }     }. }
false;public;0;4;;@Override public String toString() {     return map.toString(). }
false;public;1;11;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     ImmutableOpenMap that = (ImmutableOpenMap) o.     if (!map.equals(that.map))         return false.     return true. }
false;public;0;4;;@Override public int hashCode() {     return map.hashCode(). }
false;public,static;0;4;;@SuppressWarnings("unchecked") public static <KType, VType> ImmutableOpenMap<KType, VType> of() {     return EMPTY. }
true;public,static;1;5;/**  * @return  An immutable copy of the given map  */ ;/**  * @return  An immutable copy of the given map  */ public static <KType, VType> ImmutableOpenMap<KType, VType> copyOf(ObjectObjectMap<KType, VType> map) {     Builder<KType, VType> builder = builder().     builder.putAll(map).     return builder.build(). }
false;public,static;0;3;;public static <KType, VType> Builder<KType, VType> builder() {     return new Builder<>(). }
false;public,static;1;3;;public static <KType, VType> Builder<KType, VType> builder(int size) {     return new Builder<>(size). }
false;public,static;1;3;;public static <KType, VType> Builder<KType, VType> builder(ImmutableOpenMap<KType, VType> map) {     return new Builder<>(map). }
true;public;0;5;/**  * Builds a new instance of the  */ ;/**  * Builds a new instance of the  */ public ImmutableOpenMap<KType, VType> build() {     ObjectObjectHashMap<KType, VType> map = this.map.     // nullify the map, so any operation post build will fail! (hackish, but safest)     this.map = null.     return new ImmutableOpenMap<>(map). }
true;public;1;6;/**  * Puts all the entries in the map to the builder.  */ ;/**  * Puts all the entries in the map to the builder.  */ public Builder<KType, VType> putAll(Map<KType, VType> map) {     for (Map.Entry<KType, VType> entry : map.entrySet()) {         this.map.put(entry.getKey(), entry.getValue()).     }     return this. }
true;public;2;4;/**  * A put operation that can be used in the fluent pattern.  */ ;/**  * A put operation that can be used in the fluent pattern.  */ public Builder<KType, VType> fPut(KType key, VType value) {     map.put(key, value).     return this. }
false;public;2;4;;@Override public VType put(KType key, VType value) {     return map.put(key, value). }
false;public;1;4;;@Override public VType get(KType key) {     return map.get(key). }
false;public;2;4;;@Override public VType getOrDefault(KType kType, VType vType) {     return map.getOrDefault(kType, vType). }
false;public;1;4;;@Override public int putAll(ObjectObjectAssociativeContainer<? extends KType, ? extends VType> container) {     return map.putAll(container). }
false;public;1;4;;@Override public int putAll(Iterable<? extends ObjectObjectCursor<? extends KType, ? extends VType>> iterable) {     return map.putAll(iterable). }
true;public;1;4;/**  * Remove that can be used in the fluent pattern.  */ ;/**  * Remove that can be used in the fluent pattern.  */ public Builder<KType, VType> fRemove(KType key) {     map.remove(key).     return this. }
false;public;1;4;;@Override public VType remove(KType key) {     return map.remove(key). }
false;public;0;4;;@Override public Iterator<ObjectObjectCursor<KType, VType>> iterator() {     return map.iterator(). }
false;public;1;4;;@Override public boolean containsKey(KType key) {     return map.containsKey(key). }
false;public;0;4;;@Override public int size() {     return map.size(). }
false;public;0;4;;@Override public boolean isEmpty() {     return map.isEmpty(). }
false;public;1;4;;@Override public int removeAll(ObjectContainer<? super KType> container) {     return map.removeAll(container). }
false;public;1;4;;@Override public int removeAll(ObjectPredicate<? super KType> predicate) {     return map.removeAll(predicate). }
false;public;1;4;;@Override public <T extends ObjectObjectProcedure<? super KType, ? super VType>> T forEach(T procedure) {     return map.forEach(procedure). }
false;public;0;4;;@Override public void clear() {     map.clear(). }
false;public;0;4;;@Override public ObjectCollection<KType> keys() {     return map.keys(). }
false;public;0;4;;@Override public ObjectContainer<VType> values() {     return map.values(). }
false;public;0;4;;@SuppressWarnings("unchecked") public <K, V> Builder<K, V> cast() {     return (Builder) this. }
false;public;1;4;;@Override public int removeAll(ObjectObjectPredicate<? super KType, ? super VType> predicate) {     return map.removeAll(predicate). }
false;public;1;4;;@Override public <T extends ObjectObjectPredicate<? super KType, ? super VType>> T forEach(T predicate) {     return map.forEach(predicate). }
false;public;1;4;;@Override public int indexOf(KType key) {     return map.indexOf(key). }
false;public;1;4;;@Override public boolean indexExists(int index) {     return map.indexExists(index). }
false;public;1;4;;@Override public VType indexGet(int index) {     return map.indexGet(index). }
false;public;2;4;;@Override public VType indexReplace(int index, VType newValue) {     return map.indexReplace(index, newValue). }
false;public;3;4;;@Override public void indexInsert(int index, KType key, VType value) {     map.indexInsert(index, key, value). }
false;public;0;4;;@Override public void release() {     map.release(). }
false;public;1;4;;@Override public String visualizeKeyDistribution(int characters) {     return map.visualizeKeyDistribution(characters). }
