commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * @return number of context mappings  * held by this instance  */ ;/**  * @return number of context mappings  * held by this instance  */ public int size() {     return contextMappings.size(). }
true;public;1;9;/**  * Returns a context mapping by its name  */ ;/**  * Returns a context mapping by its name  */ public ContextMapping<?> get(String name) {     ContextMapping<?> contextMapping = contextNameMap.get(name).     if (contextMapping == null) {         List<String> keys = new ArrayList<>(contextNameMap.keySet()).         Collections.sort(keys).         throw new IllegalArgumentException("Unknown context name [" + name + "], must be one of " + keys.toString()).     }     return contextMapping. }
true;public;5;3;/**  * Adds a context-enabled field for all the defined mappings to <code>document</code>  * see {@link org.elasticsearch.search.suggest.completion.context.ContextMappings.TypedContextField}  */ ;/**  * Adds a context-enabled field for all the defined mappings to <code>document</code>  * see {@link org.elasticsearch.search.suggest.completion.context.ContextMappings.TypedContextField}  */ public void addField(ParseContext.Document document, String name, String input, int weight, Map<String, Set<String>> contexts) {     document.add(new TypedContextField(name, input, weight, contexts, document)). }
false;public;0;4;;@Override public Iterator<ContextMapping<?>> iterator() {     return contextMappings.iterator(). }
false;protected;0;24;;@Override protected Iterable<CharSequence> contexts() {     Set<CharsRef> typedContexts = new HashSet<>().     final CharsRefBuilder scratch = new CharsRefBuilder().     scratch.grow(1).     for (int typeId = 0. typeId < contextMappings.size(). typeId++) {         scratch.setCharAt(0, (char) typeId).         scratch.setLength(1).         ContextMapping<?> mapping = contextMappings.get(typeId).         Set<String> contexts = new HashSet<>(mapping.parseContext(document)).         if (this.contexts.get(mapping.name()) != null) {             contexts.addAll(this.contexts.get(mapping.name())).         }         for (String context : contexts) {             scratch.append(context).             typedContexts.add(scratch.toCharsRef()).             scratch.setLength(1).         }     }     if (typedContexts.isEmpty()) {         throw new IllegalArgumentException("Contexts are mandatory in context enabled completion field [" + name + "]").     }     return new ArrayList<CharSequence>(typedContexts). }
true;public;2;26;/**  * Wraps a {@link CompletionQuery} with context queries  *  * @param query base completion query to wrap  * @param queryContexts a map of context mapping name and collected query contexts  * @return a context-enabled query  */ ;/**  * Wraps a {@link CompletionQuery} with context queries  *  * @param query base completion query to wrap  * @param queryContexts a map of context mapping name and collected query contexts  * @return a context-enabled query  */ public ContextQuery toContextQuery(CompletionQuery query, Map<String, List<ContextMapping.InternalQueryContext>> queryContexts) {     ContextQuery typedContextQuery = new ContextQuery(query).     boolean hasContext = false.     if (queryContexts.isEmpty() == false) {         CharsRefBuilder scratch = new CharsRefBuilder().         scratch.grow(1).         for (int typeId = 0. typeId < contextMappings.size(). typeId++) {             scratch.setCharAt(0, (char) typeId).             scratch.setLength(1).             ContextMapping<?> mapping = contextMappings.get(typeId).             List<ContextMapping.InternalQueryContext> internalQueryContext = queryContexts.get(mapping.name()).             if (internalQueryContext != null) {                 for (ContextMapping.InternalQueryContext context : internalQueryContext) {                     scratch.append(context.context).                     typedContextQuery.addContext(scratch.toCharsRef(), context.boost, !context.isPrefix).                     scratch.setLength(1).                     hasContext = true.                 }             }         }     }     if (hasContext == false) {         throw new IllegalArgumentException("Missing mandatory contexts in context query").     }     return typedContextQuery. }
true;public;1;15;/**  * Maps an output context list to a map of context mapping names and their values  *  * see {@link org.elasticsearch.search.suggest.completion.context.ContextMappings.TypedContextField}  * @return a map of context names and their values  */ ;/**  * Maps an output context list to a map of context mapping names and their values  *  * see {@link org.elasticsearch.search.suggest.completion.context.ContextMappings.TypedContextField}  * @return a map of context names and their values  */ public Map<String, Set<String>> getNamedContexts(List<CharSequence> contexts) {     Map<String, Set<String>> contextMap = new HashMap<>(contexts.size()).     for (CharSequence typedContext : contexts) {         int typeId = typedContext.charAt(0).         assert typeId < contextMappings.size() : "Returned context has invalid type".         ContextMapping<?> mapping = contextMappings.get(typeId).         Set<String> contextEntries = contextMap.get(mapping.name()).         if (contextEntries == null) {             contextEntries = new HashSet<>().             contextMap.put(mapping.name(), contextEntries).         }         contextEntries.add(typedContext.subSequence(1, typedContext.length()).toString()).     }     return contextMap. }
true;public,static;2;18;/**  * Loads {@link ContextMappings} from configuration  *  * Expected configuration:  *  List of maps representing {@link ContextMapping}  *  [{"name": .., "type": .., ..}, {..}]  */ ;/**  * Loads {@link ContextMappings} from configuration  *  * Expected configuration:  *  List of maps representing {@link ContextMapping}  *  [{"name": .., "type": .., ..}, {..}]  */ public static ContextMappings load(Object configuration, Version indexVersionCreated) throws ElasticsearchParseException {     final List<ContextMapping<?>> contextMappings.     if (configuration instanceof List) {         contextMappings = new ArrayList<>().         List<Object> configurations = (List<Object>) configuration.         for (Object contextConfig : configurations) {             contextMappings.add(load((Map<String, Object>) contextConfig, indexVersionCreated)).         }         if (contextMappings.size() == 0) {             throw new ElasticsearchParseException("expected at least one context mapping").         }     } else if (configuration instanceof Map) {         contextMappings = Collections.singletonList(load(((Map<String, Object>) configuration), indexVersionCreated)).     } else {         throw new ElasticsearchParseException("expected a list or an entry of context mapping").     }     return new ContextMappings(contextMappings). }
false;private,static;2;17;;private static ContextMapping<?> load(Map<String, Object> contextConfig, Version indexVersionCreated) {     String name = extractRequiredValue(contextConfig, FIELD_NAME).     String type = extractRequiredValue(contextConfig, FIELD_TYPE).     final ContextMapping<?> contextMapping.     switch(Type.fromString(type)) {         case CATEGORY:             contextMapping = CategoryContextMapping.load(name, contextConfig).             break.         case GEO:             contextMapping = GeoContextMapping.load(name, contextConfig).             break.         default:             throw new ElasticsearchParseException("unknown context type[" + type + "]").     }     DocumentMapperParser.checkNoRemainingFields(name, contextConfig, indexVersionCreated).     return contextMapping. }
false;private,static;2;8;;private static String extractRequiredValue(Map<String, Object> contextConfig, String paramName) {     final Object paramValue = contextConfig.get(paramName).     if (paramValue == null) {         throw new ElasticsearchParseException("missing [" + paramName + "] in context mapping").     }     contextConfig.remove(paramName).     return paramValue.toString(). }
true;public;2;9;/**  * Writes a list of objects specified by the defined {@link ContextMapping}s  *  * see {@link ContextMapping#toXContent(XContentBuilder, Params)}  */ ;/**  * Writes a list of objects specified by the defined {@link ContextMapping}s  *  * see {@link ContextMapping#toXContent(XContentBuilder, Params)}  */ @Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     for (ContextMapping<?> contextMapping : contextMappings) {         builder.startObject().         contextMapping.toXContent(builder, params).         builder.endObject().     }     return builder. }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(contextMappings). }
false;public;1;8;;@Override public boolean equals(Object obj) {     if (obj == null || (obj instanceof ContextMappings) == false) {         return false.     }     ContextMappings other = ((ContextMappings) obj).     return contextMappings.equals(other.contextMappings). }
