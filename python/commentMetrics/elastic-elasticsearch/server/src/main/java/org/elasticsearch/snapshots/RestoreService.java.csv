# id;timestamp;commentText;codeText;commentWords;codeWords
RestoreService -> public void restoreSnapshot(final RestoreRequest request, final ActionListener<RestoreCompletionResponse> listener) -> null -> private IndexMetaData updateIndexSettings(IndexMetaData indexMetaData, Settings changeSettings, String[] ignoreSettings);1524684173;Optionally updates index settings in indexMetaData by removing settings listed in ignoreSettings and_merging them with settings in changeSettings.;private IndexMetaData updateIndexSettings(IndexMetaData indexMetaData, Settings changeSettings, String[] ignoreSettings) {_                    if (changeSettings.names().isEmpty() && ignoreSettings.length == 0) {_                        return indexMetaData__                    }_                    Settings normalizedChangeSettings = Settings.builder().put(changeSettings).normalizePrefix(IndexMetaData.INDEX_SETTING_PREFIX).build()__                    IndexMetaData.Builder builder = IndexMetaData.builder(indexMetaData)__                    Settings settings = indexMetaData.getSettings()__                    Set<String> keyFilters = new HashSet<>()__                    List<String> simpleMatchPatterns = new ArrayList<>()__                    for (String ignoredSetting : ignoreSettings) {_                        if (!Regex.isSimpleMatchPattern(ignoredSetting)) {_                            if (UNREMOVABLE_SETTINGS.contains(ignoredSetting)) {_                                throw new SnapshotRestoreException(snapshot, "cannot remove setting [" + ignoredSetting + "] on restore")__                            } else {_                                keyFilters.add(ignoredSetting)__                            }_                        } else {_                            simpleMatchPatterns.add(ignoredSetting)__                        }_                    }_                    Predicate<String> settingsFilter = k -> {_                        if (UNREMOVABLE_SETTINGS.contains(k) == false) {_                            for (String filterKey : keyFilters) {_                                if (k.equals(filterKey)) {_                                    return false__                                }_                            }_                            for (String pattern : simpleMatchPatterns) {_                                if (Regex.simpleMatch(pattern, k)) {_                                    return false__                                }_                            }_                        }_                        return true__                    }__                    Settings.Builder settingsBuilder = Settings.builder()_                        .put(settings.filter(settingsFilter))_                        .put(normalizedChangeSettings.filter(k -> {_                            if (UNMODIFIABLE_SETTINGS.contains(k)) {_                                throw new SnapshotRestoreException(snapshot, "cannot modify setting [" + k + "] on restore")__                            } else {_                                return true__                            }_                        }))__                    return builder.settings(settingsBuilder).build()__                };optionally,updates,index,settings,in,index,meta,data,by,removing,settings,listed,in,ignore,settings,and,merging,them,with,settings,in,change,settings;private,index,meta,data,update,index,settings,index,meta,data,index,meta,data,settings,change,settings,string,ignore,settings,if,change,settings,names,is,empty,ignore,settings,length,0,return,index,meta,data,settings,normalized,change,settings,settings,builder,put,change,settings,normalize,prefix,index,meta,data,build,index,meta,data,builder,builder,index,meta,data,builder,index,meta,data,settings,settings,index,meta,data,get,settings,set,string,key,filters,new,hash,set,list,string,simple,match,patterns,new,array,list,for,string,ignored,setting,ignore,settings,if,regex,is,simple,match,pattern,ignored,setting,if,contains,ignored,setting,throw,new,snapshot,restore,exception,snapshot,cannot,remove,setting,ignored,setting,on,restore,else,key,filters,add,ignored,setting,else,simple,match,patterns,add,ignored,setting,predicate,string,settings,filter,k,if,contains,k,false,for,string,filter,key,key,filters,if,k,equals,filter,key,return,false,for,string,pattern,simple,match,patterns,if,regex,simple,match,pattern,k,return,false,return,true,settings,builder,settings,builder,settings,builder,put,settings,filter,settings,filter,put,normalized,change,settings,filter,k,if,contains,k,throw,new,snapshot,restore,exception,snapshot,cannot,modify,setting,k,on,restore,else,return,true,return,builder,settings,settings,builder,build
RestoreService -> public void restoreSnapshot(final RestoreRequest request, final ActionListener<RestoreCompletionResponse> listener) -> null -> private IndexMetaData updateIndexSettings(IndexMetaData indexMetaData, Settings changeSettings, String[] ignoreSettings);1525248068;Optionally updates index settings in indexMetaData by removing settings listed in ignoreSettings and_merging them with settings in changeSettings.;private IndexMetaData updateIndexSettings(IndexMetaData indexMetaData, Settings changeSettings, String[] ignoreSettings) {_                    if (changeSettings.names().isEmpty() && ignoreSettings.length == 0) {_                        return indexMetaData__                    }_                    Settings normalizedChangeSettings = Settings.builder().put(changeSettings).normalizePrefix(IndexMetaData.INDEX_SETTING_PREFIX).build()__                    IndexMetaData.Builder builder = IndexMetaData.builder(indexMetaData)__                    Settings settings = indexMetaData.getSettings()__                    Set<String> keyFilters = new HashSet<>()__                    List<String> simpleMatchPatterns = new ArrayList<>()__                    for (String ignoredSetting : ignoreSettings) {_                        if (!Regex.isSimpleMatchPattern(ignoredSetting)) {_                            if (UNREMOVABLE_SETTINGS.contains(ignoredSetting)) {_                                throw new SnapshotRestoreException(snapshot, "cannot remove setting [" + ignoredSetting + "] on restore")__                            } else {_                                keyFilters.add(ignoredSetting)__                            }_                        } else {_                            simpleMatchPatterns.add(ignoredSetting)__                        }_                    }_                    Predicate<String> settingsFilter = k -> {_                        if (UNREMOVABLE_SETTINGS.contains(k) == false) {_                            for (String filterKey : keyFilters) {_                                if (k.equals(filterKey)) {_                                    return false__                                }_                            }_                            for (String pattern : simpleMatchPatterns) {_                                if (Regex.simpleMatch(pattern, k)) {_                                    return false__                                }_                            }_                        }_                        return true__                    }__                    Settings.Builder settingsBuilder = Settings.builder()_                        .put(settings.filter(settingsFilter))_                        .put(normalizedChangeSettings.filter(k -> {_                            if (UNMODIFIABLE_SETTINGS.contains(k)) {_                                throw new SnapshotRestoreException(snapshot, "cannot modify setting [" + k + "] on restore")__                            } else {_                                return true__                            }_                        }))__                    return builder.settings(settingsBuilder).build()__                };optionally,updates,index,settings,in,index,meta,data,by,removing,settings,listed,in,ignore,settings,and,merging,them,with,settings,in,change,settings;private,index,meta,data,update,index,settings,index,meta,data,index,meta,data,settings,change,settings,string,ignore,settings,if,change,settings,names,is,empty,ignore,settings,length,0,return,index,meta,data,settings,normalized,change,settings,settings,builder,put,change,settings,normalize,prefix,index,meta,data,build,index,meta,data,builder,builder,index,meta,data,builder,index,meta,data,settings,settings,index,meta,data,get,settings,set,string,key,filters,new,hash,set,list,string,simple,match,patterns,new,array,list,for,string,ignored,setting,ignore,settings,if,regex,is,simple,match,pattern,ignored,setting,if,contains,ignored,setting,throw,new,snapshot,restore,exception,snapshot,cannot,remove,setting,ignored,setting,on,restore,else,key,filters,add,ignored,setting,else,simple,match,patterns,add,ignored,setting,predicate,string,settings,filter,k,if,contains,k,false,for,string,filter,key,key,filters,if,k,equals,filter,key,return,false,for,string,pattern,simple,match,patterns,if,regex,simple,match,pattern,k,return,false,return,true,settings,builder,settings,builder,settings,builder,put,settings,filter,settings,filter,put,normalized,change,settings,filter,k,if,contains,k,throw,new,snapshot,restore,exception,snapshot,cannot,modify,setting,k,on,restore,else,return,true,return,builder,settings,settings,builder,build
RestoreService -> public void restoreSnapshot(final RestoreRequest request, final ActionListener<RestoreCompletionResponse> listener) -> null -> private IndexMetaData updateIndexSettings(IndexMetaData indexMetaData, Settings changeSettings, String[] ignoreSettings);1535405719;Optionally updates index settings in indexMetaData by removing settings listed in ignoreSettings and_merging them with settings in changeSettings.;private IndexMetaData updateIndexSettings(IndexMetaData indexMetaData, Settings changeSettings, String[] ignoreSettings) {_                    if (changeSettings.names().isEmpty() && ignoreSettings.length == 0) {_                        return indexMetaData__                    }_                    Settings normalizedChangeSettings = Settings.builder().put(changeSettings).normalizePrefix(IndexMetaData.INDEX_SETTING_PREFIX).build()__                    IndexMetaData.Builder builder = IndexMetaData.builder(indexMetaData)__                    Settings settings = indexMetaData.getSettings()__                    Set<String> keyFilters = new HashSet<>()__                    List<String> simpleMatchPatterns = new ArrayList<>()__                    for (String ignoredSetting : ignoreSettings) {_                        if (!Regex.isSimpleMatchPattern(ignoredSetting)) {_                            if (UNREMOVABLE_SETTINGS.contains(ignoredSetting)) {_                                throw new SnapshotRestoreException(snapshot, "cannot remove setting [" + ignoredSetting + "] on restore")__                            } else {_                                keyFilters.add(ignoredSetting)__                            }_                        } else {_                            simpleMatchPatterns.add(ignoredSetting)__                        }_                    }_                    Predicate<String> settingsFilter = k -> {_                        if (UNREMOVABLE_SETTINGS.contains(k) == false) {_                            for (String filterKey : keyFilters) {_                                if (k.equals(filterKey)) {_                                    return false__                                }_                            }_                            for (String pattern : simpleMatchPatterns) {_                                if (Regex.simpleMatch(pattern, k)) {_                                    return false__                                }_                            }_                        }_                        return true__                    }__                    Settings.Builder settingsBuilder = Settings.builder()_                        .put(settings.filter(settingsFilter))_                        .put(normalizedChangeSettings.filter(k -> {_                            if (UNMODIFIABLE_SETTINGS.contains(k)) {_                                throw new SnapshotRestoreException(snapshot, "cannot modify setting [" + k + "] on restore")__                            } else {_                                return true__                            }_                        }))__                    return builder.settings(settingsBuilder).build()__                };optionally,updates,index,settings,in,index,meta,data,by,removing,settings,listed,in,ignore,settings,and,merging,them,with,settings,in,change,settings;private,index,meta,data,update,index,settings,index,meta,data,index,meta,data,settings,change,settings,string,ignore,settings,if,change,settings,names,is,empty,ignore,settings,length,0,return,index,meta,data,settings,normalized,change,settings,settings,builder,put,change,settings,normalize,prefix,index,meta,data,build,index,meta,data,builder,builder,index,meta,data,builder,index,meta,data,settings,settings,index,meta,data,get,settings,set,string,key,filters,new,hash,set,list,string,simple,match,patterns,new,array,list,for,string,ignored,setting,ignore,settings,if,regex,is,simple,match,pattern,ignored,setting,if,contains,ignored,setting,throw,new,snapshot,restore,exception,snapshot,cannot,remove,setting,ignored,setting,on,restore,else,key,filters,add,ignored,setting,else,simple,match,patterns,add,ignored,setting,predicate,string,settings,filter,k,if,contains,k,false,for,string,filter,key,key,filters,if,k,equals,filter,key,return,false,for,string,pattern,simple,match,patterns,if,regex,simple,match,pattern,k,return,false,return,true,settings,builder,settings,builder,settings,builder,put,settings,filter,settings,filter,put,normalized,change,settings,filter,k,if,contains,k,throw,new,snapshot,restore,exception,snapshot,cannot,modify,setting,k,on,restore,else,return,true,return,builder,settings,settings,builder,build
RestoreService -> public void restoreSnapshot(final RestoreRequest request, final ActionListener<RestoreCompletionResponse> listener) -> null -> private IndexMetaData updateIndexSettings(IndexMetaData indexMetaData, Settings changeSettings, String[] ignoreSettings);1535723122;Optionally updates index settings in indexMetaData by removing settings listed in ignoreSettings and_merging them with settings in changeSettings.;private IndexMetaData updateIndexSettings(IndexMetaData indexMetaData, Settings changeSettings, String[] ignoreSettings) {_                    if (changeSettings.names().isEmpty() && ignoreSettings.length == 0) {_                        return indexMetaData__                    }_                    Settings normalizedChangeSettings = Settings.builder().put(changeSettings).normalizePrefix(IndexMetaData.INDEX_SETTING_PREFIX).build()__                    IndexMetaData.Builder builder = IndexMetaData.builder(indexMetaData)__                    Settings settings = indexMetaData.getSettings()__                    Set<String> keyFilters = new HashSet<>()__                    List<String> simpleMatchPatterns = new ArrayList<>()__                    for (String ignoredSetting : ignoreSettings) {_                        if (!Regex.isSimpleMatchPattern(ignoredSetting)) {_                            if (UNREMOVABLE_SETTINGS.contains(ignoredSetting)) {_                                throw new SnapshotRestoreException(snapshot, "cannot remove setting [" + ignoredSetting + "] on restore")__                            } else {_                                keyFilters.add(ignoredSetting)__                            }_                        } else {_                            simpleMatchPatterns.add(ignoredSetting)__                        }_                    }_                    Predicate<String> settingsFilter = k -> {_                        if (UNREMOVABLE_SETTINGS.contains(k) == false) {_                            for (String filterKey : keyFilters) {_                                if (k.equals(filterKey)) {_                                    return false__                                }_                            }_                            for (String pattern : simpleMatchPatterns) {_                                if (Regex.simpleMatch(pattern, k)) {_                                    return false__                                }_                            }_                        }_                        return true__                    }__                    Settings.Builder settingsBuilder = Settings.builder()_                        .put(settings.filter(settingsFilter))_                        .put(normalizedChangeSettings.filter(k -> {_                            if (UNMODIFIABLE_SETTINGS.contains(k)) {_                                throw new SnapshotRestoreException(snapshot, "cannot modify setting [" + k + "] on restore")__                            } else {_                                return true__                            }_                        }))__                    return builder.settings(settingsBuilder).build()__                };optionally,updates,index,settings,in,index,meta,data,by,removing,settings,listed,in,ignore,settings,and,merging,them,with,settings,in,change,settings;private,index,meta,data,update,index,settings,index,meta,data,index,meta,data,settings,change,settings,string,ignore,settings,if,change,settings,names,is,empty,ignore,settings,length,0,return,index,meta,data,settings,normalized,change,settings,settings,builder,put,change,settings,normalize,prefix,index,meta,data,build,index,meta,data,builder,builder,index,meta,data,builder,index,meta,data,settings,settings,index,meta,data,get,settings,set,string,key,filters,new,hash,set,list,string,simple,match,patterns,new,array,list,for,string,ignored,setting,ignore,settings,if,regex,is,simple,match,pattern,ignored,setting,if,contains,ignored,setting,throw,new,snapshot,restore,exception,snapshot,cannot,remove,setting,ignored,setting,on,restore,else,key,filters,add,ignored,setting,else,simple,match,patterns,add,ignored,setting,predicate,string,settings,filter,k,if,contains,k,false,for,string,filter,key,key,filters,if,k,equals,filter,key,return,false,for,string,pattern,simple,match,patterns,if,regex,simple,match,pattern,k,return,false,return,true,settings,builder,settings,builder,settings,builder,put,settings,filter,settings,filter,put,normalized,change,settings,filter,k,if,contains,k,throw,new,snapshot,restore,exception,snapshot,cannot,modify,setting,k,on,restore,else,return,true,return,builder,settings,settings,builder,build
RestoreService -> public void restoreSnapshot(final RestoreRequest request, final ActionListener<RestoreCompletionResponse> listener) -> null -> private IndexMetaData updateIndexSettings(IndexMetaData indexMetaData, Settings changeSettings, String[] ignoreSettings);1536137328;Optionally updates index settings in indexMetaData by removing settings listed in ignoreSettings and_merging them with settings in changeSettings.;private IndexMetaData updateIndexSettings(IndexMetaData indexMetaData, Settings changeSettings, String[] ignoreSettings) {_                    if (changeSettings.names().isEmpty() && ignoreSettings.length == 0) {_                        return indexMetaData__                    }_                    Settings normalizedChangeSettings = Settings.builder().put(changeSettings).normalizePrefix(IndexMetaData.INDEX_SETTING_PREFIX).build()__                    IndexMetaData.Builder builder = IndexMetaData.builder(indexMetaData)__                    Settings settings = indexMetaData.getSettings()__                    Set<String> keyFilters = new HashSet<>()__                    List<String> simpleMatchPatterns = new ArrayList<>()__                    for (String ignoredSetting : ignoreSettings) {_                        if (!Regex.isSimpleMatchPattern(ignoredSetting)) {_                            if (UNREMOVABLE_SETTINGS.contains(ignoredSetting)) {_                                throw new SnapshotRestoreException(snapshot, "cannot remove setting [" + ignoredSetting + "] on restore")__                            } else {_                                keyFilters.add(ignoredSetting)__                            }_                        } else {_                            simpleMatchPatterns.add(ignoredSetting)__                        }_                    }_                    Predicate<String> settingsFilter = k -> {_                        if (UNREMOVABLE_SETTINGS.contains(k) == false) {_                            for (String filterKey : keyFilters) {_                                if (k.equals(filterKey)) {_                                    return false__                                }_                            }_                            for (String pattern : simpleMatchPatterns) {_                                if (Regex.simpleMatch(pattern, k)) {_                                    return false__                                }_                            }_                        }_                        return true__                    }__                    Settings.Builder settingsBuilder = Settings.builder()_                        .put(settings.filter(settingsFilter))_                        .put(normalizedChangeSettings.filter(k -> {_                            if (UNMODIFIABLE_SETTINGS.contains(k)) {_                                throw new SnapshotRestoreException(snapshot, "cannot modify setting [" + k + "] on restore")__                            } else {_                                return true__                            }_                        }))__                    return builder.settings(settingsBuilder).build()__                };optionally,updates,index,settings,in,index,meta,data,by,removing,settings,listed,in,ignore,settings,and,merging,them,with,settings,in,change,settings;private,index,meta,data,update,index,settings,index,meta,data,index,meta,data,settings,change,settings,string,ignore,settings,if,change,settings,names,is,empty,ignore,settings,length,0,return,index,meta,data,settings,normalized,change,settings,settings,builder,put,change,settings,normalize,prefix,index,meta,data,build,index,meta,data,builder,builder,index,meta,data,builder,index,meta,data,settings,settings,index,meta,data,get,settings,set,string,key,filters,new,hash,set,list,string,simple,match,patterns,new,array,list,for,string,ignored,setting,ignore,settings,if,regex,is,simple,match,pattern,ignored,setting,if,contains,ignored,setting,throw,new,snapshot,restore,exception,snapshot,cannot,remove,setting,ignored,setting,on,restore,else,key,filters,add,ignored,setting,else,simple,match,patterns,add,ignored,setting,predicate,string,settings,filter,k,if,contains,k,false,for,string,filter,key,key,filters,if,k,equals,filter,key,return,false,for,string,pattern,simple,match,patterns,if,regex,simple,match,pattern,k,return,false,return,true,settings,builder,settings,builder,settings,builder,put,settings,filter,settings,filter,put,normalized,change,settings,filter,k,if,contains,k,throw,new,snapshot,restore,exception,snapshot,cannot,modify,setting,k,on,restore,else,return,true,return,builder,settings,settings,builder,build
RestoreService -> public void restoreSnapshot(final RestoreRequest request, final ActionListener<RestoreCompletionResponse> listener) -> null -> private IndexMetaData updateIndexSettings(IndexMetaData indexMetaData, Settings changeSettings, String[] ignoreSettings);1539723533;Optionally updates index settings in indexMetaData by removing settings listed in ignoreSettings and_merging them with settings in changeSettings.;private IndexMetaData updateIndexSettings(IndexMetaData indexMetaData, Settings changeSettings, String[] ignoreSettings) {_                    if (changeSettings.names().isEmpty() && ignoreSettings.length == 0) {_                        return indexMetaData__                    }_                    Settings normalizedChangeSettings = Settings.builder().put(changeSettings).normalizePrefix(IndexMetaData.INDEX_SETTING_PREFIX).build()__                    IndexMetaData.Builder builder = IndexMetaData.builder(indexMetaData)__                    Settings settings = indexMetaData.getSettings()__                    Set<String> keyFilters = new HashSet<>()__                    List<String> simpleMatchPatterns = new ArrayList<>()__                    for (String ignoredSetting : ignoreSettings) {_                        if (!Regex.isSimpleMatchPattern(ignoredSetting)) {_                            if (UNREMOVABLE_SETTINGS.contains(ignoredSetting)) {_                                throw new SnapshotRestoreException(snapshot, "cannot remove setting [" + ignoredSetting + "] on restore")__                            } else {_                                keyFilters.add(ignoredSetting)__                            }_                        } else {_                            simpleMatchPatterns.add(ignoredSetting)__                        }_                    }_                    Predicate<String> settingsFilter = k -> {_                        if (UNREMOVABLE_SETTINGS.contains(k) == false) {_                            for (String filterKey : keyFilters) {_                                if (k.equals(filterKey)) {_                                    return false__                                }_                            }_                            for (String pattern : simpleMatchPatterns) {_                                if (Regex.simpleMatch(pattern, k)) {_                                    return false__                                }_                            }_                        }_                        return true__                    }__                    Settings.Builder settingsBuilder = Settings.builder()_                        .put(settings.filter(settingsFilter))_                        .put(normalizedChangeSettings.filter(k -> {_                            if (UNMODIFIABLE_SETTINGS.contains(k)) {_                                throw new SnapshotRestoreException(snapshot, "cannot modify setting [" + k + "] on restore")__                            } else {_                                return true__                            }_                        }))__                    return builder.settings(settingsBuilder).build()__                };optionally,updates,index,settings,in,index,meta,data,by,removing,settings,listed,in,ignore,settings,and,merging,them,with,settings,in,change,settings;private,index,meta,data,update,index,settings,index,meta,data,index,meta,data,settings,change,settings,string,ignore,settings,if,change,settings,names,is,empty,ignore,settings,length,0,return,index,meta,data,settings,normalized,change,settings,settings,builder,put,change,settings,normalize,prefix,index,meta,data,build,index,meta,data,builder,builder,index,meta,data,builder,index,meta,data,settings,settings,index,meta,data,get,settings,set,string,key,filters,new,hash,set,list,string,simple,match,patterns,new,array,list,for,string,ignored,setting,ignore,settings,if,regex,is,simple,match,pattern,ignored,setting,if,contains,ignored,setting,throw,new,snapshot,restore,exception,snapshot,cannot,remove,setting,ignored,setting,on,restore,else,key,filters,add,ignored,setting,else,simple,match,patterns,add,ignored,setting,predicate,string,settings,filter,k,if,contains,k,false,for,string,filter,key,key,filters,if,k,equals,filter,key,return,false,for,string,pattern,simple,match,patterns,if,regex,simple,match,pattern,k,return,false,return,true,settings,builder,settings,builder,settings,builder,put,settings,filter,settings,filter,put,normalized,change,settings,filter,k,if,contains,k,throw,new,snapshot,restore,exception,snapshot,cannot,modify,setting,k,on,restore,else,return,true,return,builder,settings,settings,builder,build
RestoreService -> public void restoreSnapshot(final RestoreRequest request, final ActionListener<RestoreCompletionResponse> listener) -> null -> private IndexMetaData updateIndexSettings(IndexMetaData indexMetaData, Settings changeSettings, String[] ignoreSettings);1540486836;Optionally updates index settings in indexMetaData by removing settings listed in ignoreSettings and_merging them with settings in changeSettings.;private IndexMetaData updateIndexSettings(IndexMetaData indexMetaData, Settings changeSettings, String[] ignoreSettings) {_                    if (changeSettings.names().isEmpty() && ignoreSettings.length == 0) {_                        return indexMetaData__                    }_                    Settings normalizedChangeSettings = Settings.builder().put(changeSettings).normalizePrefix(IndexMetaData.INDEX_SETTING_PREFIX).build()__                    IndexMetaData.Builder builder = IndexMetaData.builder(indexMetaData)__                    Settings settings = indexMetaData.getSettings()__                    Set<String> keyFilters = new HashSet<>()__                    List<String> simpleMatchPatterns = new ArrayList<>()__                    for (String ignoredSetting : ignoreSettings) {_                        if (!Regex.isSimpleMatchPattern(ignoredSetting)) {_                            if (UNREMOVABLE_SETTINGS.contains(ignoredSetting)) {_                                throw new SnapshotRestoreException(snapshot, "cannot remove setting [" + ignoredSetting + "] on restore")__                            } else {_                                keyFilters.add(ignoredSetting)__                            }_                        } else {_                            simpleMatchPatterns.add(ignoredSetting)__                        }_                    }_                    Predicate<String> settingsFilter = k -> {_                        if (UNREMOVABLE_SETTINGS.contains(k) == false) {_                            for (String filterKey : keyFilters) {_                                if (k.equals(filterKey)) {_                                    return false__                                }_                            }_                            for (String pattern : simpleMatchPatterns) {_                                if (Regex.simpleMatch(pattern, k)) {_                                    return false__                                }_                            }_                        }_                        return true__                    }__                    Settings.Builder settingsBuilder = Settings.builder()_                        .put(settings.filter(settingsFilter))_                        .put(normalizedChangeSettings.filter(k -> {_                            if (UNMODIFIABLE_SETTINGS.contains(k)) {_                                throw new SnapshotRestoreException(snapshot, "cannot modify setting [" + k + "] on restore")__                            } else {_                                return true__                            }_                        }))__                    return builder.settings(settingsBuilder).build()__                };optionally,updates,index,settings,in,index,meta,data,by,removing,settings,listed,in,ignore,settings,and,merging,them,with,settings,in,change,settings;private,index,meta,data,update,index,settings,index,meta,data,index,meta,data,settings,change,settings,string,ignore,settings,if,change,settings,names,is,empty,ignore,settings,length,0,return,index,meta,data,settings,normalized,change,settings,settings,builder,put,change,settings,normalize,prefix,index,meta,data,build,index,meta,data,builder,builder,index,meta,data,builder,index,meta,data,settings,settings,index,meta,data,get,settings,set,string,key,filters,new,hash,set,list,string,simple,match,patterns,new,array,list,for,string,ignored,setting,ignore,settings,if,regex,is,simple,match,pattern,ignored,setting,if,contains,ignored,setting,throw,new,snapshot,restore,exception,snapshot,cannot,remove,setting,ignored,setting,on,restore,else,key,filters,add,ignored,setting,else,simple,match,patterns,add,ignored,setting,predicate,string,settings,filter,k,if,contains,k,false,for,string,filter,key,key,filters,if,k,equals,filter,key,return,false,for,string,pattern,simple,match,patterns,if,regex,simple,match,pattern,k,return,false,return,true,settings,builder,settings,builder,settings,builder,put,settings,filter,settings,filter,put,normalized,change,settings,filter,k,if,contains,k,throw,new,snapshot,restore,exception,snapshot,cannot,modify,setting,k,on,restore,else,return,true,return,builder,settings,settings,builder,build
RestoreService -> public void restoreSnapshot(final RestoreRequest request, final ActionListener<RestoreCompletionResponse> listener) -> null -> private IndexMetaData updateIndexSettings(IndexMetaData indexMetaData, Settings changeSettings, String[] ignoreSettings);1541092382;Optionally updates index settings in indexMetaData by removing settings listed in ignoreSettings and_merging them with settings in changeSettings.;private IndexMetaData updateIndexSettings(IndexMetaData indexMetaData, Settings changeSettings, String[] ignoreSettings) {_                    if (changeSettings.names().isEmpty() && ignoreSettings.length == 0) {_                        return indexMetaData__                    }_                    Settings normalizedChangeSettings = Settings.builder().put(changeSettings).normalizePrefix(IndexMetaData.INDEX_SETTING_PREFIX).build()__                    IndexMetaData.Builder builder = IndexMetaData.builder(indexMetaData)__                    Settings settings = indexMetaData.getSettings()__                    Set<String> keyFilters = new HashSet<>()__                    List<String> simpleMatchPatterns = new ArrayList<>()__                    for (String ignoredSetting : ignoreSettings) {_                        if (!Regex.isSimpleMatchPattern(ignoredSetting)) {_                            if (UNREMOVABLE_SETTINGS.contains(ignoredSetting)) {_                                throw new SnapshotRestoreException(snapshot, "cannot remove setting [" + ignoredSetting + "] on restore")__                            } else {_                                keyFilters.add(ignoredSetting)__                            }_                        } else {_                            simpleMatchPatterns.add(ignoredSetting)__                        }_                    }_                    Predicate<String> settingsFilter = k -> {_                        if (UNREMOVABLE_SETTINGS.contains(k) == false) {_                            for (String filterKey : keyFilters) {_                                if (k.equals(filterKey)) {_                                    return false__                                }_                            }_                            for (String pattern : simpleMatchPatterns) {_                                if (Regex.simpleMatch(pattern, k)) {_                                    return false__                                }_                            }_                        }_                        return true__                    }__                    Settings.Builder settingsBuilder = Settings.builder()_                        .put(settings.filter(settingsFilter))_                        .put(normalizedChangeSettings.filter(k -> {_                            if (UNMODIFIABLE_SETTINGS.contains(k)) {_                                throw new SnapshotRestoreException(snapshot, "cannot modify setting [" + k + "] on restore")__                            } else {_                                return true__                            }_                        }))__                    return builder.settings(settingsBuilder).build()__                };optionally,updates,index,settings,in,index,meta,data,by,removing,settings,listed,in,ignore,settings,and,merging,them,with,settings,in,change,settings;private,index,meta,data,update,index,settings,index,meta,data,index,meta,data,settings,change,settings,string,ignore,settings,if,change,settings,names,is,empty,ignore,settings,length,0,return,index,meta,data,settings,normalized,change,settings,settings,builder,put,change,settings,normalize,prefix,index,meta,data,build,index,meta,data,builder,builder,index,meta,data,builder,index,meta,data,settings,settings,index,meta,data,get,settings,set,string,key,filters,new,hash,set,list,string,simple,match,patterns,new,array,list,for,string,ignored,setting,ignore,settings,if,regex,is,simple,match,pattern,ignored,setting,if,contains,ignored,setting,throw,new,snapshot,restore,exception,snapshot,cannot,remove,setting,ignored,setting,on,restore,else,key,filters,add,ignored,setting,else,simple,match,patterns,add,ignored,setting,predicate,string,settings,filter,k,if,contains,k,false,for,string,filter,key,key,filters,if,k,equals,filter,key,return,false,for,string,pattern,simple,match,patterns,if,regex,simple,match,pattern,k,return,false,return,true,settings,builder,settings,builder,settings,builder,put,settings,filter,settings,filter,put,normalized,change,settings,filter,k,if,contains,k,throw,new,snapshot,restore,exception,snapshot,cannot,modify,setting,k,on,restore,else,return,true,return,builder,settings,settings,builder,build
RestoreService -> public void restoreSnapshot(final RestoreRequest request, final ActionListener<RestoreCompletionResponse> listener) -> null -> private IndexMetaData updateIndexSettings(IndexMetaData indexMetaData, Settings changeSettings, String[] ignoreSettings);1542402632;Optionally updates index settings in indexMetaData by removing settings listed in ignoreSettings and_merging them with settings in changeSettings.;private IndexMetaData updateIndexSettings(IndexMetaData indexMetaData, Settings changeSettings, String[] ignoreSettings) {_                    if (changeSettings.names().isEmpty() && ignoreSettings.length == 0) {_                        return indexMetaData__                    }_                    Settings normalizedChangeSettings = Settings.builder().put(changeSettings).normalizePrefix(IndexMetaData.INDEX_SETTING_PREFIX).build()__                    IndexMetaData.Builder builder = IndexMetaData.builder(indexMetaData)__                    Settings settings = indexMetaData.getSettings()__                    Set<String> keyFilters = new HashSet<>()__                    List<String> simpleMatchPatterns = new ArrayList<>()__                    for (String ignoredSetting : ignoreSettings) {_                        if (!Regex.isSimpleMatchPattern(ignoredSetting)) {_                            if (UNREMOVABLE_SETTINGS.contains(ignoredSetting)) {_                                throw new SnapshotRestoreException(snapshot, "cannot remove setting [" + ignoredSetting + "] on restore")__                            } else {_                                keyFilters.add(ignoredSetting)__                            }_                        } else {_                            simpleMatchPatterns.add(ignoredSetting)__                        }_                    }_                    Predicate<String> settingsFilter = k -> {_                        if (UNREMOVABLE_SETTINGS.contains(k) == false) {_                            for (String filterKey : keyFilters) {_                                if (k.equals(filterKey)) {_                                    return false__                                }_                            }_                            for (String pattern : simpleMatchPatterns) {_                                if (Regex.simpleMatch(pattern, k)) {_                                    return false__                                }_                            }_                        }_                        return true__                    }__                    Settings.Builder settingsBuilder = Settings.builder()_                        .put(settings.filter(settingsFilter))_                        .put(normalizedChangeSettings.filter(k -> {_                            if (UNMODIFIABLE_SETTINGS.contains(k)) {_                                throw new SnapshotRestoreException(snapshot, "cannot modify setting [" + k + "] on restore")__                            } else {_                                return true__                            }_                        }))__                    return builder.settings(settingsBuilder).build()__                };optionally,updates,index,settings,in,index,meta,data,by,removing,settings,listed,in,ignore,settings,and,merging,them,with,settings,in,change,settings;private,index,meta,data,update,index,settings,index,meta,data,index,meta,data,settings,change,settings,string,ignore,settings,if,change,settings,names,is,empty,ignore,settings,length,0,return,index,meta,data,settings,normalized,change,settings,settings,builder,put,change,settings,normalize,prefix,index,meta,data,build,index,meta,data,builder,builder,index,meta,data,builder,index,meta,data,settings,settings,index,meta,data,get,settings,set,string,key,filters,new,hash,set,list,string,simple,match,patterns,new,array,list,for,string,ignored,setting,ignore,settings,if,regex,is,simple,match,pattern,ignored,setting,if,contains,ignored,setting,throw,new,snapshot,restore,exception,snapshot,cannot,remove,setting,ignored,setting,on,restore,else,key,filters,add,ignored,setting,else,simple,match,patterns,add,ignored,setting,predicate,string,settings,filter,k,if,contains,k,false,for,string,filter,key,key,filters,if,k,equals,filter,key,return,false,for,string,pattern,simple,match,patterns,if,regex,simple,match,pattern,k,return,false,return,true,settings,builder,settings,builder,settings,builder,put,settings,filter,settings,filter,put,normalized,change,settings,filter,k,if,contains,k,throw,new,snapshot,restore,exception,snapshot,cannot,modify,setting,k,on,restore,else,return,true,return,builder,settings,settings,builder,build
RestoreService -> public void restoreSnapshot(final RestoreRequest request, final ActionListener<RestoreCompletionResponse> listener) -> null -> private IndexMetaData updateIndexSettings(IndexMetaData indexMetaData, Settings changeSettings, String[] ignoreSettings);1544783963;Optionally updates index settings in indexMetaData by removing settings listed in ignoreSettings and_merging them with settings in changeSettings.;private IndexMetaData updateIndexSettings(IndexMetaData indexMetaData, Settings changeSettings, String[] ignoreSettings) {_                    if (changeSettings.names().isEmpty() && ignoreSettings.length == 0) {_                        return indexMetaData__                    }_                    Settings normalizedChangeSettings = Settings.builder().put(changeSettings).normalizePrefix(IndexMetaData.INDEX_SETTING_PREFIX).build()__                    IndexMetaData.Builder builder = IndexMetaData.builder(indexMetaData)__                    Settings settings = indexMetaData.getSettings()__                    Set<String> keyFilters = new HashSet<>()__                    List<String> simpleMatchPatterns = new ArrayList<>()__                    for (String ignoredSetting : ignoreSettings) {_                        if (!Regex.isSimpleMatchPattern(ignoredSetting)) {_                            if (UNREMOVABLE_SETTINGS.contains(ignoredSetting)) {_                                throw new SnapshotRestoreException(snapshot, "cannot remove setting [" + ignoredSetting + "] on restore")__                            } else {_                                keyFilters.add(ignoredSetting)__                            }_                        } else {_                            simpleMatchPatterns.add(ignoredSetting)__                        }_                    }_                    Predicate<String> settingsFilter = k -> {_                        if (UNREMOVABLE_SETTINGS.contains(k) == false) {_                            for (String filterKey : keyFilters) {_                                if (k.equals(filterKey)) {_                                    return false__                                }_                            }_                            for (String pattern : simpleMatchPatterns) {_                                if (Regex.simpleMatch(pattern, k)) {_                                    return false__                                }_                            }_                        }_                        return true__                    }__                    Settings.Builder settingsBuilder = Settings.builder()_                        .put(settings.filter(settingsFilter))_                        .put(normalizedChangeSettings.filter(k -> {_                            if (UNMODIFIABLE_SETTINGS.contains(k)) {_                                throw new SnapshotRestoreException(snapshot, "cannot modify setting [" + k + "] on restore")__                            } else {_                                return true__                            }_                        }))__                    return builder.settings(settingsBuilder).build()__                };optionally,updates,index,settings,in,index,meta,data,by,removing,settings,listed,in,ignore,settings,and,merging,them,with,settings,in,change,settings;private,index,meta,data,update,index,settings,index,meta,data,index,meta,data,settings,change,settings,string,ignore,settings,if,change,settings,names,is,empty,ignore,settings,length,0,return,index,meta,data,settings,normalized,change,settings,settings,builder,put,change,settings,normalize,prefix,index,meta,data,build,index,meta,data,builder,builder,index,meta,data,builder,index,meta,data,settings,settings,index,meta,data,get,settings,set,string,key,filters,new,hash,set,list,string,simple,match,patterns,new,array,list,for,string,ignored,setting,ignore,settings,if,regex,is,simple,match,pattern,ignored,setting,if,contains,ignored,setting,throw,new,snapshot,restore,exception,snapshot,cannot,remove,setting,ignored,setting,on,restore,else,key,filters,add,ignored,setting,else,simple,match,patterns,add,ignored,setting,predicate,string,settings,filter,k,if,contains,k,false,for,string,filter,key,key,filters,if,k,equals,filter,key,return,false,for,string,pattern,simple,match,patterns,if,regex,simple,match,pattern,k,return,false,return,true,settings,builder,settings,builder,settings,builder,put,settings,filter,settings,filter,put,normalized,change,settings,filter,k,if,contains,k,throw,new,snapshot,restore,exception,snapshot,cannot,modify,setting,k,on,restore,else,return,true,return,builder,settings,settings,builder,build
RestoreService -> public void restoreSnapshot(final RestoreRequest request, final ActionListener<RestoreCompletionResponse> listener) -> null -> private IndexMetaData updateIndexSettings(IndexMetaData indexMetaData, Settings changeSettings, String[] ignoreSettings);1545215361;Optionally updates index settings in indexMetaData by removing settings listed in ignoreSettings and_merging them with settings in changeSettings.;private IndexMetaData updateIndexSettings(IndexMetaData indexMetaData, Settings changeSettings, String[] ignoreSettings) {_                    if (changeSettings.names().isEmpty() && ignoreSettings.length == 0) {_                        return indexMetaData__                    }_                    Settings normalizedChangeSettings = Settings.builder()_                                                                .put(changeSettings)_                                                                .normalizePrefix(IndexMetaData.INDEX_SETTING_PREFIX)_                                                                .build()__                    IndexMetaData.Builder builder = IndexMetaData.builder(indexMetaData)__                    Settings settings = indexMetaData.getSettings()__                    Set<String> keyFilters = new HashSet<>()__                    List<String> simpleMatchPatterns = new ArrayList<>()__                    for (String ignoredSetting : ignoreSettings) {_                        if (!Regex.isSimpleMatchPattern(ignoredSetting)) {_                            if (UNREMOVABLE_SETTINGS.contains(ignoredSetting)) {_                                throw new SnapshotRestoreException(snapshot, "cannot remove setting [" + ignoredSetting + "] on restore")__                            } else {_                                keyFilters.add(ignoredSetting)__                            }_                        } else {_                            simpleMatchPatterns.add(ignoredSetting)__                        }_                    }_                    Predicate<String> settingsFilter = k -> {_                        if (UNREMOVABLE_SETTINGS.contains(k) == false) {_                            for (String filterKey : keyFilters) {_                                if (k.equals(filterKey)) {_                                    return false__                                }_                            }_                            for (String pattern : simpleMatchPatterns) {_                                if (Regex.simpleMatch(pattern, k)) {_                                    return false__                                }_                            }_                        }_                        return true__                    }__                    Settings.Builder settingsBuilder = Settings.builder()_                        .put(settings.filter(settingsFilter))_                        .put(normalizedChangeSettings.filter(k -> {_                            if (UNMODIFIABLE_SETTINGS.contains(k)) {_                                throw new SnapshotRestoreException(snapshot, "cannot modify setting [" + k + "] on restore")__                            } else {_                                return true__                            }_                        }))__                    return builder.settings(settingsBuilder).build()__                };optionally,updates,index,settings,in,index,meta,data,by,removing,settings,listed,in,ignore,settings,and,merging,them,with,settings,in,change,settings;private,index,meta,data,update,index,settings,index,meta,data,index,meta,data,settings,change,settings,string,ignore,settings,if,change,settings,names,is,empty,ignore,settings,length,0,return,index,meta,data,settings,normalized,change,settings,settings,builder,put,change,settings,normalize,prefix,index,meta,data,build,index,meta,data,builder,builder,index,meta,data,builder,index,meta,data,settings,settings,index,meta,data,get,settings,set,string,key,filters,new,hash,set,list,string,simple,match,patterns,new,array,list,for,string,ignored,setting,ignore,settings,if,regex,is,simple,match,pattern,ignored,setting,if,contains,ignored,setting,throw,new,snapshot,restore,exception,snapshot,cannot,remove,setting,ignored,setting,on,restore,else,key,filters,add,ignored,setting,else,simple,match,patterns,add,ignored,setting,predicate,string,settings,filter,k,if,contains,k,false,for,string,filter,key,key,filters,if,k,equals,filter,key,return,false,for,string,pattern,simple,match,patterns,if,regex,simple,match,pattern,k,return,false,return,true,settings,builder,settings,builder,settings,builder,put,settings,filter,settings,filter,put,normalized,change,settings,filter,k,if,contains,k,throw,new,snapshot,restore,exception,snapshot,cannot,modify,setting,k,on,restore,else,return,true,return,builder,settings,settings,builder,build
RestoreService -> RestoreRequest -> public IndicesOptions indicesOptions();1524684173;Returns indices option flags__@return indices options flags;public IndicesOptions indicesOptions() {_            return indicesOptions__        };returns,indices,option,flags,return,indices,options,flags;public,indices,options,indices,options,return,indices,options
RestoreService -> RestoreRequest -> public IndicesOptions indicesOptions();1525248068;Returns indices option flags__@return indices options flags;public IndicesOptions indicesOptions() {_            return indicesOptions__        };returns,indices,option,flags,return,indices,options,flags;public,indices,options,indices,options,return,indices,options
RestoreService -> RestoreRequest -> public IndicesOptions indicesOptions();1535405719;Returns indices option flags__@return indices options flags;public IndicesOptions indicesOptions() {_            return indicesOptions__        };returns,indices,option,flags,return,indices,options,flags;public,indices,options,indices,options,return,indices,options
RestoreService -> RestoreRequest -> public IndicesOptions indicesOptions();1535723122;Returns indices option flags__@return indices options flags;public IndicesOptions indicesOptions() {_            return indicesOptions__        };returns,indices,option,flags,return,indices,options,flags;public,indices,options,indices,options,return,indices,options
RestoreService -> RestoreRequest -> public IndicesOptions indicesOptions();1536137328;Returns indices option flags__@return indices options flags;public IndicesOptions indicesOptions() {_            return indicesOptions__        };returns,indices,option,flags,return,indices,options,flags;public,indices,options,indices,options,return,indices,options
RestoreService -> RestoreRequest -> public IndicesOptions indicesOptions();1539723533;Returns indices option flags__@return indices options flags;public IndicesOptions indicesOptions() {_            return indicesOptions__        };returns,indices,option,flags,return,indices,options,flags;public,indices,options,indices,options,return,indices,options
RestoreService -> RestoreRequest -> public IndicesOptions indicesOptions();1540486836;Returns indices option flags__@return indices options flags;public IndicesOptions indicesOptions() {_            return indicesOptions__        };returns,indices,option,flags,return,indices,options,flags;public,indices,options,indices,options,return,indices,options
RestoreService -> RestoreRequest -> public IndicesOptions indicesOptions();1541092382;Returns indices option flags__@return indices options flags;public IndicesOptions indicesOptions() {_            return indicesOptions__        };returns,indices,option,flags,return,indices,options,flags;public,indices,options,indices,options,return,indices,options
RestoreService -> RestoreRequest -> public IndicesOptions indicesOptions();1542402632;Returns indices option flags__@return indices options flags;public IndicesOptions indicesOptions() {_            return indicesOptions__        };returns,indices,option,flags,return,indices,options,flags;public,indices,options,indices,options,return,indices,options
RestoreService -> RestoreRequest -> public IndicesOptions indicesOptions();1544783963;Returns indices option flags__@return indices options flags;public IndicesOptions indicesOptions() {_            return indicesOptions__        };returns,indices,option,flags,return,indices,options,flags;public,indices,options,indices,options,return,indices,options
RestoreService -> RestoreRequest -> public IndicesOptions indicesOptions();1545215361;Returns indices option flags__@return indices options flags;public IndicesOptions indicesOptions() {_            return indicesOptions__        };returns,indices,option,flags,return,indices,options,flags;public,indices,options,indices,options,return,indices,options
RestoreService -> RestoreRequest -> public String repositoryName();1524684173;Returns repository name__@return repository name;public String repositoryName() {_            return repositoryName__        };returns,repository,name,return,repository,name;public,string,repository,name,return,repository,name
RestoreService -> RestoreRequest -> public String repositoryName();1525248068;Returns repository name__@return repository name;public String repositoryName() {_            return repositoryName__        };returns,repository,name,return,repository,name;public,string,repository,name,return,repository,name
RestoreService -> RestoreRequest -> public String repositoryName();1535405719;Returns repository name__@return repository name;public String repositoryName() {_            return repositoryName__        };returns,repository,name,return,repository,name;public,string,repository,name,return,repository,name
RestoreService -> RestoreRequest -> public String repositoryName();1535723122;Returns repository name__@return repository name;public String repositoryName() {_            return repositoryName__        };returns,repository,name,return,repository,name;public,string,repository,name,return,repository,name
RestoreService -> RestoreRequest -> public String repositoryName();1536137328;Returns repository name__@return repository name;public String repositoryName() {_            return repositoryName__        };returns,repository,name,return,repository,name;public,string,repository,name,return,repository,name
RestoreService -> RestoreRequest -> public String repositoryName();1539723533;Returns repository name__@return repository name;public String repositoryName() {_            return repositoryName__        };returns,repository,name,return,repository,name;public,string,repository,name,return,repository,name
RestoreService -> RestoreRequest -> public String repositoryName();1540486836;Returns repository name__@return repository name;public String repositoryName() {_            return repositoryName__        };returns,repository,name,return,repository,name;public,string,repository,name,return,repository,name
RestoreService -> RestoreRequest -> public String repositoryName();1541092382;Returns repository name__@return repository name;public String repositoryName() {_            return repositoryName__        };returns,repository,name,return,repository,name;public,string,repository,name,return,repository,name
RestoreService -> RestoreRequest -> public String repositoryName();1542402632;Returns repository name__@return repository name;public String repositoryName() {_            return repositoryName__        };returns,repository,name,return,repository,name;public,string,repository,name,return,repository,name
RestoreService -> RestoreRequest -> public String repositoryName();1544783963;Returns repository name__@return repository name;public String repositoryName() {_            return repositoryName__        };returns,repository,name,return,repository,name;public,string,repository,name,return,repository,name
RestoreService -> RestoreRequest -> public String repositoryName();1545215361;Returns repository name__@return repository name;public String repositoryName() {_            return repositoryName__        };returns,repository,name,return,repository,name;public,string,repository,name,return,repository,name
RestoreService -> public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices);1524684173;Check if any of the indices to be closed are currently being restored from a snapshot and fail closing if such an index_is found as closing an index that is being restored makes the index unusable (it cannot be recovered).;public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices) {_        RestoreInProgress restore = currentState.custom(RestoreInProgress.TYPE)__        if (restore != null) {_            Set<Index> indicesToFail = null__            for (RestoreInProgress.Entry entry : restore.entries()) {_                for (ObjectObjectCursor<ShardId, RestoreInProgress.ShardRestoreStatus> shard : entry.shards()) {_                    if (!shard.value.state().completed()) {_                        IndexMetaData indexMetaData = currentState.metaData().index(shard.key.getIndex())__                        if (indexMetaData != null && indices.contains(indexMetaData)) {_                            if (indicesToFail == null) {_                                indicesToFail = new HashSet<>()__                            }_                            indicesToFail.add(shard.key.getIndex())__                        }_                    }_                }_            }_            if (indicesToFail != null) {_                throw new IllegalArgumentException("Cannot close indices that are being restored: " + indicesToFail)__            }_        }_    };check,if,any,of,the,indices,to,be,closed,are,currently,being,restored,from,a,snapshot,and,fail,closing,if,such,an,index,is,found,as,closing,an,index,that,is,being,restored,makes,the,index,unusable,it,cannot,be,recovered;public,static,void,check,index,closing,cluster,state,current,state,set,index,meta,data,indices,restore,in,progress,restore,current,state,custom,restore,in,progress,type,if,restore,null,set,index,indices,to,fail,null,for,restore,in,progress,entry,entry,restore,entries,for,object,object,cursor,shard,id,restore,in,progress,shard,restore,status,shard,entry,shards,if,shard,value,state,completed,index,meta,data,index,meta,data,current,state,meta,data,index,shard,key,get,index,if,index,meta,data,null,indices,contains,index,meta,data,if,indices,to,fail,null,indices,to,fail,new,hash,set,indices,to,fail,add,shard,key,get,index,if,indices,to,fail,null,throw,new,illegal,argument,exception,cannot,close,indices,that,are,being,restored,indices,to,fail
RestoreService -> public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices);1525248068;Check if any of the indices to be closed are currently being restored from a snapshot and fail closing if such an index_is found as closing an index that is being restored makes the index unusable (it cannot be recovered).;public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices) {_        RestoreInProgress restore = currentState.custom(RestoreInProgress.TYPE)__        if (restore != null) {_            Set<Index> indicesToFail = null__            for (RestoreInProgress.Entry entry : restore.entries()) {_                for (ObjectObjectCursor<ShardId, RestoreInProgress.ShardRestoreStatus> shard : entry.shards()) {_                    if (!shard.value.state().completed()) {_                        IndexMetaData indexMetaData = currentState.metaData().index(shard.key.getIndex())__                        if (indexMetaData != null && indices.contains(indexMetaData)) {_                            if (indicesToFail == null) {_                                indicesToFail = new HashSet<>()__                            }_                            indicesToFail.add(shard.key.getIndex())__                        }_                    }_                }_            }_            if (indicesToFail != null) {_                throw new IllegalArgumentException("Cannot close indices that are being restored: " + indicesToFail)__            }_        }_    };check,if,any,of,the,indices,to,be,closed,are,currently,being,restored,from,a,snapshot,and,fail,closing,if,such,an,index,is,found,as,closing,an,index,that,is,being,restored,makes,the,index,unusable,it,cannot,be,recovered;public,static,void,check,index,closing,cluster,state,current,state,set,index,meta,data,indices,restore,in,progress,restore,current,state,custom,restore,in,progress,type,if,restore,null,set,index,indices,to,fail,null,for,restore,in,progress,entry,entry,restore,entries,for,object,object,cursor,shard,id,restore,in,progress,shard,restore,status,shard,entry,shards,if,shard,value,state,completed,index,meta,data,index,meta,data,current,state,meta,data,index,shard,key,get,index,if,index,meta,data,null,indices,contains,index,meta,data,if,indices,to,fail,null,indices,to,fail,new,hash,set,indices,to,fail,add,shard,key,get,index,if,indices,to,fail,null,throw,new,illegal,argument,exception,cannot,close,indices,that,are,being,restored,indices,to,fail
RestoreService -> public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices);1535405719;Check if any of the indices to be closed are currently being restored from a snapshot and fail closing if such an index_is found as closing an index that is being restored makes the index unusable (it cannot be recovered).;public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices) {_        RestoreInProgress restore = currentState.custom(RestoreInProgress.TYPE)__        if (restore != null) {_            Set<Index> indicesToFail = null__            for (RestoreInProgress.Entry entry : restore.entries()) {_                for (ObjectObjectCursor<ShardId, RestoreInProgress.ShardRestoreStatus> shard : entry.shards()) {_                    if (!shard.value.state().completed()) {_                        IndexMetaData indexMetaData = currentState.metaData().index(shard.key.getIndex())__                        if (indexMetaData != null && indices.contains(indexMetaData)) {_                            if (indicesToFail == null) {_                                indicesToFail = new HashSet<>()__                            }_                            indicesToFail.add(shard.key.getIndex())__                        }_                    }_                }_            }_            if (indicesToFail != null) {_                throw new IllegalArgumentException("Cannot close indices that are being restored: " + indicesToFail)__            }_        }_    };check,if,any,of,the,indices,to,be,closed,are,currently,being,restored,from,a,snapshot,and,fail,closing,if,such,an,index,is,found,as,closing,an,index,that,is,being,restored,makes,the,index,unusable,it,cannot,be,recovered;public,static,void,check,index,closing,cluster,state,current,state,set,index,meta,data,indices,restore,in,progress,restore,current,state,custom,restore,in,progress,type,if,restore,null,set,index,indices,to,fail,null,for,restore,in,progress,entry,entry,restore,entries,for,object,object,cursor,shard,id,restore,in,progress,shard,restore,status,shard,entry,shards,if,shard,value,state,completed,index,meta,data,index,meta,data,current,state,meta,data,index,shard,key,get,index,if,index,meta,data,null,indices,contains,index,meta,data,if,indices,to,fail,null,indices,to,fail,new,hash,set,indices,to,fail,add,shard,key,get,index,if,indices,to,fail,null,throw,new,illegal,argument,exception,cannot,close,indices,that,are,being,restored,indices,to,fail
RestoreService -> public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices);1535723122;Check if any of the indices to be closed are currently being restored from a snapshot and fail closing if such an index_is found as closing an index that is being restored makes the index unusable (it cannot be recovered).;public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices) {_        RestoreInProgress restore = currentState.custom(RestoreInProgress.TYPE)__        if (restore != null) {_            Set<Index> indicesToFail = null__            for (RestoreInProgress.Entry entry : restore.entries()) {_                for (ObjectObjectCursor<ShardId, RestoreInProgress.ShardRestoreStatus> shard : entry.shards()) {_                    if (!shard.value.state().completed()) {_                        IndexMetaData indexMetaData = currentState.metaData().index(shard.key.getIndex())__                        if (indexMetaData != null && indices.contains(indexMetaData)) {_                            if (indicesToFail == null) {_                                indicesToFail = new HashSet<>()__                            }_                            indicesToFail.add(shard.key.getIndex())__                        }_                    }_                }_            }_            if (indicesToFail != null) {_                throw new IllegalArgumentException("Cannot close indices that are being restored: " + indicesToFail)__            }_        }_    };check,if,any,of,the,indices,to,be,closed,are,currently,being,restored,from,a,snapshot,and,fail,closing,if,such,an,index,is,found,as,closing,an,index,that,is,being,restored,makes,the,index,unusable,it,cannot,be,recovered;public,static,void,check,index,closing,cluster,state,current,state,set,index,meta,data,indices,restore,in,progress,restore,current,state,custom,restore,in,progress,type,if,restore,null,set,index,indices,to,fail,null,for,restore,in,progress,entry,entry,restore,entries,for,object,object,cursor,shard,id,restore,in,progress,shard,restore,status,shard,entry,shards,if,shard,value,state,completed,index,meta,data,index,meta,data,current,state,meta,data,index,shard,key,get,index,if,index,meta,data,null,indices,contains,index,meta,data,if,indices,to,fail,null,indices,to,fail,new,hash,set,indices,to,fail,add,shard,key,get,index,if,indices,to,fail,null,throw,new,illegal,argument,exception,cannot,close,indices,that,are,being,restored,indices,to,fail
RestoreService -> public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices);1536137328;Check if any of the indices to be closed are currently being restored from a snapshot and fail closing if such an index_is found as closing an index that is being restored makes the index unusable (it cannot be recovered).;public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices) {_        RestoreInProgress restore = currentState.custom(RestoreInProgress.TYPE)__        if (restore != null) {_            Set<Index> indicesToFail = null__            for (RestoreInProgress.Entry entry : restore.entries()) {_                for (ObjectObjectCursor<ShardId, RestoreInProgress.ShardRestoreStatus> shard : entry.shards()) {_                    if (!shard.value.state().completed()) {_                        IndexMetaData indexMetaData = currentState.metaData().index(shard.key.getIndex())__                        if (indexMetaData != null && indices.contains(indexMetaData)) {_                            if (indicesToFail == null) {_                                indicesToFail = new HashSet<>()__                            }_                            indicesToFail.add(shard.key.getIndex())__                        }_                    }_                }_            }_            if (indicesToFail != null) {_                throw new IllegalArgumentException("Cannot close indices that are being restored: " + indicesToFail)__            }_        }_    };check,if,any,of,the,indices,to,be,closed,are,currently,being,restored,from,a,snapshot,and,fail,closing,if,such,an,index,is,found,as,closing,an,index,that,is,being,restored,makes,the,index,unusable,it,cannot,be,recovered;public,static,void,check,index,closing,cluster,state,current,state,set,index,meta,data,indices,restore,in,progress,restore,current,state,custom,restore,in,progress,type,if,restore,null,set,index,indices,to,fail,null,for,restore,in,progress,entry,entry,restore,entries,for,object,object,cursor,shard,id,restore,in,progress,shard,restore,status,shard,entry,shards,if,shard,value,state,completed,index,meta,data,index,meta,data,current,state,meta,data,index,shard,key,get,index,if,index,meta,data,null,indices,contains,index,meta,data,if,indices,to,fail,null,indices,to,fail,new,hash,set,indices,to,fail,add,shard,key,get,index,if,indices,to,fail,null,throw,new,illegal,argument,exception,cannot,close,indices,that,are,being,restored,indices,to,fail
RestoreService -> public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices);1539723533;Check if any of the indices to be closed are currently being restored from a snapshot and fail closing if such an index_is found as closing an index that is being restored makes the index unusable (it cannot be recovered).;public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices) {_        RestoreInProgress restore = currentState.custom(RestoreInProgress.TYPE)__        if (restore != null) {_            Set<Index> indicesToFail = null__            for (RestoreInProgress.Entry entry : restore.entries()) {_                for (ObjectObjectCursor<ShardId, RestoreInProgress.ShardRestoreStatus> shard : entry.shards()) {_                    if (!shard.value.state().completed()) {_                        IndexMetaData indexMetaData = currentState.metaData().index(shard.key.getIndex())__                        if (indexMetaData != null && indices.contains(indexMetaData)) {_                            if (indicesToFail == null) {_                                indicesToFail = new HashSet<>()__                            }_                            indicesToFail.add(shard.key.getIndex())__                        }_                    }_                }_            }_            if (indicesToFail != null) {_                throw new IllegalArgumentException("Cannot close indices that are being restored: " + indicesToFail)__            }_        }_    };check,if,any,of,the,indices,to,be,closed,are,currently,being,restored,from,a,snapshot,and,fail,closing,if,such,an,index,is,found,as,closing,an,index,that,is,being,restored,makes,the,index,unusable,it,cannot,be,recovered;public,static,void,check,index,closing,cluster,state,current,state,set,index,meta,data,indices,restore,in,progress,restore,current,state,custom,restore,in,progress,type,if,restore,null,set,index,indices,to,fail,null,for,restore,in,progress,entry,entry,restore,entries,for,object,object,cursor,shard,id,restore,in,progress,shard,restore,status,shard,entry,shards,if,shard,value,state,completed,index,meta,data,index,meta,data,current,state,meta,data,index,shard,key,get,index,if,index,meta,data,null,indices,contains,index,meta,data,if,indices,to,fail,null,indices,to,fail,new,hash,set,indices,to,fail,add,shard,key,get,index,if,indices,to,fail,null,throw,new,illegal,argument,exception,cannot,close,indices,that,are,being,restored,indices,to,fail
RestoreService -> public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices);1540486836;Check if any of the indices to be closed are currently being restored from a snapshot and fail closing if such an index_is found as closing an index that is being restored makes the index unusable (it cannot be recovered).;public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices) {_        RestoreInProgress restore = currentState.custom(RestoreInProgress.TYPE)__        if (restore != null) {_            Set<Index> indicesToFail = null__            for (RestoreInProgress.Entry entry : restore.entries()) {_                for (ObjectObjectCursor<ShardId, RestoreInProgress.ShardRestoreStatus> shard : entry.shards()) {_                    if (!shard.value.state().completed()) {_                        IndexMetaData indexMetaData = currentState.metaData().index(shard.key.getIndex())__                        if (indexMetaData != null && indices.contains(indexMetaData)) {_                            if (indicesToFail == null) {_                                indicesToFail = new HashSet<>()__                            }_                            indicesToFail.add(shard.key.getIndex())__                        }_                    }_                }_            }_            if (indicesToFail != null) {_                throw new IllegalArgumentException("Cannot close indices that are being restored: " + indicesToFail)__            }_        }_    };check,if,any,of,the,indices,to,be,closed,are,currently,being,restored,from,a,snapshot,and,fail,closing,if,such,an,index,is,found,as,closing,an,index,that,is,being,restored,makes,the,index,unusable,it,cannot,be,recovered;public,static,void,check,index,closing,cluster,state,current,state,set,index,meta,data,indices,restore,in,progress,restore,current,state,custom,restore,in,progress,type,if,restore,null,set,index,indices,to,fail,null,for,restore,in,progress,entry,entry,restore,entries,for,object,object,cursor,shard,id,restore,in,progress,shard,restore,status,shard,entry,shards,if,shard,value,state,completed,index,meta,data,index,meta,data,current,state,meta,data,index,shard,key,get,index,if,index,meta,data,null,indices,contains,index,meta,data,if,indices,to,fail,null,indices,to,fail,new,hash,set,indices,to,fail,add,shard,key,get,index,if,indices,to,fail,null,throw,new,illegal,argument,exception,cannot,close,indices,that,are,being,restored,indices,to,fail
RestoreService -> public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices);1541092382;Check if any of the indices to be closed are currently being restored from a snapshot and fail closing if such an index_is found as closing an index that is being restored makes the index unusable (it cannot be recovered).;public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices) {_        RestoreInProgress restore = currentState.custom(RestoreInProgress.TYPE)__        if (restore != null) {_            Set<Index> indicesToFail = null__            for (RestoreInProgress.Entry entry : restore.entries()) {_                for (ObjectObjectCursor<ShardId, RestoreInProgress.ShardRestoreStatus> shard : entry.shards()) {_                    if (!shard.value.state().completed()) {_                        IndexMetaData indexMetaData = currentState.metaData().index(shard.key.getIndex())__                        if (indexMetaData != null && indices.contains(indexMetaData)) {_                            if (indicesToFail == null) {_                                indicesToFail = new HashSet<>()__                            }_                            indicesToFail.add(shard.key.getIndex())__                        }_                    }_                }_            }_            if (indicesToFail != null) {_                throw new IllegalArgumentException("Cannot close indices that are being restored: " + indicesToFail)__            }_        }_    };check,if,any,of,the,indices,to,be,closed,are,currently,being,restored,from,a,snapshot,and,fail,closing,if,such,an,index,is,found,as,closing,an,index,that,is,being,restored,makes,the,index,unusable,it,cannot,be,recovered;public,static,void,check,index,closing,cluster,state,current,state,set,index,meta,data,indices,restore,in,progress,restore,current,state,custom,restore,in,progress,type,if,restore,null,set,index,indices,to,fail,null,for,restore,in,progress,entry,entry,restore,entries,for,object,object,cursor,shard,id,restore,in,progress,shard,restore,status,shard,entry,shards,if,shard,value,state,completed,index,meta,data,index,meta,data,current,state,meta,data,index,shard,key,get,index,if,index,meta,data,null,indices,contains,index,meta,data,if,indices,to,fail,null,indices,to,fail,new,hash,set,indices,to,fail,add,shard,key,get,index,if,indices,to,fail,null,throw,new,illegal,argument,exception,cannot,close,indices,that,are,being,restored,indices,to,fail
RestoreService -> public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices);1542402632;Check if any of the indices to be closed are currently being restored from a snapshot and fail closing if such an index_is found as closing an index that is being restored makes the index unusable (it cannot be recovered).;public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices) {_        RestoreInProgress restore = currentState.custom(RestoreInProgress.TYPE)__        if (restore != null) {_            Set<Index> indicesToFail = null__            for (RestoreInProgress.Entry entry : restore.entries()) {_                for (ObjectObjectCursor<ShardId, RestoreInProgress.ShardRestoreStatus> shard : entry.shards()) {_                    if (!shard.value.state().completed()) {_                        IndexMetaData indexMetaData = currentState.metaData().index(shard.key.getIndex())__                        if (indexMetaData != null && indices.contains(indexMetaData)) {_                            if (indicesToFail == null) {_                                indicesToFail = new HashSet<>()__                            }_                            indicesToFail.add(shard.key.getIndex())__                        }_                    }_                }_            }_            if (indicesToFail != null) {_                throw new IllegalArgumentException("Cannot close indices that are being restored: " + indicesToFail)__            }_        }_    };check,if,any,of,the,indices,to,be,closed,are,currently,being,restored,from,a,snapshot,and,fail,closing,if,such,an,index,is,found,as,closing,an,index,that,is,being,restored,makes,the,index,unusable,it,cannot,be,recovered;public,static,void,check,index,closing,cluster,state,current,state,set,index,meta,data,indices,restore,in,progress,restore,current,state,custom,restore,in,progress,type,if,restore,null,set,index,indices,to,fail,null,for,restore,in,progress,entry,entry,restore,entries,for,object,object,cursor,shard,id,restore,in,progress,shard,restore,status,shard,entry,shards,if,shard,value,state,completed,index,meta,data,index,meta,data,current,state,meta,data,index,shard,key,get,index,if,index,meta,data,null,indices,contains,index,meta,data,if,indices,to,fail,null,indices,to,fail,new,hash,set,indices,to,fail,add,shard,key,get,index,if,indices,to,fail,null,throw,new,illegal,argument,exception,cannot,close,indices,that,are,being,restored,indices,to,fail
RestoreService -> public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices);1544783963;Check if any of the indices to be closed are currently being restored from a snapshot and fail closing if such an index_is found as closing an index that is being restored makes the index unusable (it cannot be recovered).;public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices) {_        RestoreInProgress restore = currentState.custom(RestoreInProgress.TYPE)__        if (restore != null) {_            Set<Index> indicesToFail = null__            for (RestoreInProgress.Entry entry : restore) {_                for (ObjectObjectCursor<ShardId, RestoreInProgress.ShardRestoreStatus> shard : entry.shards()) {_                    if (!shard.value.state().completed()) {_                        IndexMetaData indexMetaData = currentState.metaData().index(shard.key.getIndex())__                        if (indexMetaData != null && indices.contains(indexMetaData)) {_                            if (indicesToFail == null) {_                                indicesToFail = new HashSet<>()__                            }_                            indicesToFail.add(shard.key.getIndex())__                        }_                    }_                }_            }_            if (indicesToFail != null) {_                throw new IllegalArgumentException("Cannot close indices that are being restored: " + indicesToFail)__            }_        }_    };check,if,any,of,the,indices,to,be,closed,are,currently,being,restored,from,a,snapshot,and,fail,closing,if,such,an,index,is,found,as,closing,an,index,that,is,being,restored,makes,the,index,unusable,it,cannot,be,recovered;public,static,void,check,index,closing,cluster,state,current,state,set,index,meta,data,indices,restore,in,progress,restore,current,state,custom,restore,in,progress,type,if,restore,null,set,index,indices,to,fail,null,for,restore,in,progress,entry,entry,restore,for,object,object,cursor,shard,id,restore,in,progress,shard,restore,status,shard,entry,shards,if,shard,value,state,completed,index,meta,data,index,meta,data,current,state,meta,data,index,shard,key,get,index,if,index,meta,data,null,indices,contains,index,meta,data,if,indices,to,fail,null,indices,to,fail,new,hash,set,indices,to,fail,add,shard,key,get,index,if,indices,to,fail,null,throw,new,illegal,argument,exception,cannot,close,indices,that,are,being,restored,indices,to,fail
RestoreService -> public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices);1545215361;Check if any of the indices to be closed are currently being restored from a snapshot and fail closing if such an index_is found as closing an index that is being restored makes the index unusable (it cannot be recovered).;public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices) {_        RestoreInProgress restore = currentState.custom(RestoreInProgress.TYPE)__        if (restore != null) {_            Set<Index> indicesToFail = null__            for (RestoreInProgress.Entry entry : restore) {_                for (ObjectObjectCursor<ShardId, RestoreInProgress.ShardRestoreStatus> shard : entry.shards()) {_                    if (!shard.value.state().completed()) {_                        IndexMetaData indexMetaData = currentState.metaData().index(shard.key.getIndex())__                        if (indexMetaData != null && indices.contains(indexMetaData)) {_                            if (indicesToFail == null) {_                                indicesToFail = new HashSet<>()__                            }_                            indicesToFail.add(shard.key.getIndex())__                        }_                    }_                }_            }_            if (indicesToFail != null) {_                throw new IllegalArgumentException("Cannot close indices that are being restored: " + indicesToFail)__            }_        }_    };check,if,any,of,the,indices,to,be,closed,are,currently,being,restored,from,a,snapshot,and,fail,closing,if,such,an,index,is,found,as,closing,an,index,that,is,being,restored,makes,the,index,unusable,it,cannot,be,recovered;public,static,void,check,index,closing,cluster,state,current,state,set,index,meta,data,indices,restore,in,progress,restore,current,state,custom,restore,in,progress,type,if,restore,null,set,index,indices,to,fail,null,for,restore,in,progress,entry,entry,restore,for,object,object,cursor,shard,id,restore,in,progress,shard,restore,status,shard,entry,shards,if,shard,value,state,completed,index,meta,data,index,meta,data,current,state,meta,data,index,shard,key,get,index,if,index,meta,data,null,indices,contains,index,meta,data,if,indices,to,fail,null,indices,to,fail,new,hash,set,indices,to,fail,add,shard,key,get,index,if,indices,to,fail,null,throw,new,illegal,argument,exception,cannot,close,indices,that,are,being,restored,indices,to,fail
RestoreService -> public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices);1547760203;Check if any of the indices to be closed are currently being restored from a snapshot and fail closing if such an index_is found as closing an index that is being restored makes the index unusable (it cannot be recovered).;public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices) {_        RestoreInProgress restore = currentState.custom(RestoreInProgress.TYPE)__        if (restore != null) {_            Set<Index> indicesToFail = null__            for (RestoreInProgress.Entry entry : restore) {_                for (ObjectObjectCursor<ShardId, RestoreInProgress.ShardRestoreStatus> shard : entry.shards()) {_                    if (!shard.value.state().completed()) {_                        IndexMetaData indexMetaData = currentState.metaData().index(shard.key.getIndex())__                        if (indexMetaData != null && indices.contains(indexMetaData)) {_                            if (indicesToFail == null) {_                                indicesToFail = new HashSet<>()__                            }_                            indicesToFail.add(shard.key.getIndex())__                        }_                    }_                }_            }_            if (indicesToFail != null) {_                throw new IllegalArgumentException("Cannot close indices that are being restored: " + indicesToFail)__            }_        }_    };check,if,any,of,the,indices,to,be,closed,are,currently,being,restored,from,a,snapshot,and,fail,closing,if,such,an,index,is,found,as,closing,an,index,that,is,being,restored,makes,the,index,unusable,it,cannot,be,recovered;public,static,void,check,index,closing,cluster,state,current,state,set,index,meta,data,indices,restore,in,progress,restore,current,state,custom,restore,in,progress,type,if,restore,null,set,index,indices,to,fail,null,for,restore,in,progress,entry,entry,restore,for,object,object,cursor,shard,id,restore,in,progress,shard,restore,status,shard,entry,shards,if,shard,value,state,completed,index,meta,data,index,meta,data,current,state,meta,data,index,shard,key,get,index,if,index,meta,data,null,indices,contains,index,meta,data,if,indices,to,fail,null,indices,to,fail,new,hash,set,indices,to,fail,add,shard,key,get,index,if,indices,to,fail,null,throw,new,illegal,argument,exception,cannot,close,indices,that,are,being,restored,indices,to,fail
RestoreService -> public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices);1549033151;Check if any of the indices to be closed are currently being restored from a snapshot and fail closing if such an index_is found as closing an index that is being restored makes the index unusable (it cannot be recovered).;public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices) {_        RestoreInProgress restore = currentState.custom(RestoreInProgress.TYPE)__        if (restore != null) {_            Set<Index> indicesToFail = null__            for (RestoreInProgress.Entry entry : restore) {_                for (ObjectObjectCursor<ShardId, RestoreInProgress.ShardRestoreStatus> shard : entry.shards()) {_                    if (!shard.value.state().completed()) {_                        IndexMetaData indexMetaData = currentState.metaData().index(shard.key.getIndex())__                        if (indexMetaData != null && indices.contains(indexMetaData)) {_                            if (indicesToFail == null) {_                                indicesToFail = new HashSet<>()__                            }_                            indicesToFail.add(shard.key.getIndex())__                        }_                    }_                }_            }_            if (indicesToFail != null) {_                throw new IllegalArgumentException("Cannot close indices that are being restored: " + indicesToFail)__            }_        }_    };check,if,any,of,the,indices,to,be,closed,are,currently,being,restored,from,a,snapshot,and,fail,closing,if,such,an,index,is,found,as,closing,an,index,that,is,being,restored,makes,the,index,unusable,it,cannot,be,recovered;public,static,void,check,index,closing,cluster,state,current,state,set,index,meta,data,indices,restore,in,progress,restore,current,state,custom,restore,in,progress,type,if,restore,null,set,index,indices,to,fail,null,for,restore,in,progress,entry,entry,restore,for,object,object,cursor,shard,id,restore,in,progress,shard,restore,status,shard,entry,shards,if,shard,value,state,completed,index,meta,data,index,meta,data,current,state,meta,data,index,shard,key,get,index,if,index,meta,data,null,indices,contains,index,meta,data,if,indices,to,fail,null,indices,to,fail,new,hash,set,indices,to,fail,add,shard,key,get,index,if,indices,to,fail,null,throw,new,illegal,argument,exception,cannot,close,indices,that,are,being,restored,indices,to,fail
RestoreService -> RestoreRequest -> public String[] indices();1524684173;Return the list of indices to be restored__@return the list of indices;public String[] indices() {_            return indices__        };return,the,list,of,indices,to,be,restored,return,the,list,of,indices;public,string,indices,return,indices
RestoreService -> RestoreRequest -> public String[] indices();1525248068;Return the list of indices to be restored__@return the list of indices;public String[] indices() {_            return indices__        };return,the,list,of,indices,to,be,restored,return,the,list,of,indices;public,string,indices,return,indices
RestoreService -> RestoreRequest -> public String[] indices();1535405719;Return the list of indices to be restored__@return the list of indices;public String[] indices() {_            return indices__        };return,the,list,of,indices,to,be,restored,return,the,list,of,indices;public,string,indices,return,indices
RestoreService -> RestoreRequest -> public String[] indices();1535723122;Return the list of indices to be restored__@return the list of indices;public String[] indices() {_            return indices__        };return,the,list,of,indices,to,be,restored,return,the,list,of,indices;public,string,indices,return,indices
RestoreService -> RestoreRequest -> public String[] indices();1536137328;Return the list of indices to be restored__@return the list of indices;public String[] indices() {_            return indices__        };return,the,list,of,indices,to,be,restored,return,the,list,of,indices;public,string,indices,return,indices
RestoreService -> RestoreRequest -> public String[] indices();1539723533;Return the list of indices to be restored__@return the list of indices;public String[] indices() {_            return indices__        };return,the,list,of,indices,to,be,restored,return,the,list,of,indices;public,string,indices,return,indices
RestoreService -> RestoreRequest -> public String[] indices();1540486836;Return the list of indices to be restored__@return the list of indices;public String[] indices() {_            return indices__        };return,the,list,of,indices,to,be,restored,return,the,list,of,indices;public,string,indices,return,indices
RestoreService -> RestoreRequest -> public String[] indices();1541092382;Return the list of indices to be restored__@return the list of indices;public String[] indices() {_            return indices__        };return,the,list,of,indices,to,be,restored,return,the,list,of,indices;public,string,indices,return,indices
RestoreService -> RestoreRequest -> public String[] indices();1542402632;Return the list of indices to be restored__@return the list of indices;public String[] indices() {_            return indices__        };return,the,list,of,indices,to,be,restored,return,the,list,of,indices;public,string,indices,return,indices
RestoreService -> RestoreRequest -> public String[] indices();1544783963;Return the list of indices to be restored__@return the list of indices;public String[] indices() {_            return indices__        };return,the,list,of,indices,to,be,restored,return,the,list,of,indices;public,string,indices,return,indices
RestoreService -> RestoreRequest -> public String[] indices();1545215361;Return the list of indices to be restored__@return the list of indices;public String[] indices() {_            return indices__        };return,the,list,of,indices,to,be,restored,return,the,list,of,indices;public,string,indices,return,indices
RestoreService -> private void validateSnapshotRestorable(final String repository, final SnapshotInfo snapshotInfo);1524684173;Checks that snapshots can be restored and have compatible version__@param repository      repository name_@param snapshotInfo    snapshot metadata;private void validateSnapshotRestorable(final String repository, final SnapshotInfo snapshotInfo) {_        if (!snapshotInfo.state().restorable()) {_            throw new SnapshotRestoreException(new Snapshot(repository, snapshotInfo.snapshotId()),_                                               "unsupported snapshot state [" + snapshotInfo.state() + "]")__        }_        if (Version.CURRENT.before(snapshotInfo.version())) {_            throw new SnapshotRestoreException(new Snapshot(repository, snapshotInfo.snapshotId()),_                                               "the snapshot was created with Elasticsearch version [" + snapshotInfo.version() +_                                                   "] which is higher than the version of this node [" + Version.CURRENT + "]")__        }_    };checks,that,snapshots,can,be,restored,and,have,compatible,version,param,repository,repository,name,param,snapshot,info,snapshot,metadata;private,void,validate,snapshot,restorable,final,string,repository,final,snapshot,info,snapshot,info,if,snapshot,info,state,restorable,throw,new,snapshot,restore,exception,new,snapshot,repository,snapshot,info,snapshot,id,unsupported,snapshot,state,snapshot,info,state,if,version,current,before,snapshot,info,version,throw,new,snapshot,restore,exception,new,snapshot,repository,snapshot,info,snapshot,id,the,snapshot,was,created,with,elasticsearch,version,snapshot,info,version,which,is,higher,than,the,version,of,this,node,version,current
RestoreService -> private void validateSnapshotRestorable(final String repository, final SnapshotInfo snapshotInfo);1525248068;Checks that snapshots can be restored and have compatible version__@param repository      repository name_@param snapshotInfo    snapshot metadata;private void validateSnapshotRestorable(final String repository, final SnapshotInfo snapshotInfo) {_        if (!snapshotInfo.state().restorable()) {_            throw new SnapshotRestoreException(new Snapshot(repository, snapshotInfo.snapshotId()),_                                               "unsupported snapshot state [" + snapshotInfo.state() + "]")__        }_        if (Version.CURRENT.before(snapshotInfo.version())) {_            throw new SnapshotRestoreException(new Snapshot(repository, snapshotInfo.snapshotId()),_                                               "the snapshot was created with Elasticsearch version [" + snapshotInfo.version() +_                                                   "] which is higher than the version of this node [" + Version.CURRENT + "]")__        }_    };checks,that,snapshots,can,be,restored,and,have,compatible,version,param,repository,repository,name,param,snapshot,info,snapshot,metadata;private,void,validate,snapshot,restorable,final,string,repository,final,snapshot,info,snapshot,info,if,snapshot,info,state,restorable,throw,new,snapshot,restore,exception,new,snapshot,repository,snapshot,info,snapshot,id,unsupported,snapshot,state,snapshot,info,state,if,version,current,before,snapshot,info,version,throw,new,snapshot,restore,exception,new,snapshot,repository,snapshot,info,snapshot,id,the,snapshot,was,created,with,elasticsearch,version,snapshot,info,version,which,is,higher,than,the,version,of,this,node,version,current
RestoreService -> private void validateSnapshotRestorable(final String repository, final SnapshotInfo snapshotInfo);1535405719;Checks that snapshots can be restored and have compatible version__@param repository      repository name_@param snapshotInfo    snapshot metadata;private void validateSnapshotRestorable(final String repository, final SnapshotInfo snapshotInfo) {_        if (!snapshotInfo.state().restorable()) {_            throw new SnapshotRestoreException(new Snapshot(repository, snapshotInfo.snapshotId()),_                                               "unsupported snapshot state [" + snapshotInfo.state() + "]")__        }_        if (Version.CURRENT.before(snapshotInfo.version())) {_            throw new SnapshotRestoreException(new Snapshot(repository, snapshotInfo.snapshotId()),_                                               "the snapshot was created with Elasticsearch version [" + snapshotInfo.version() +_                                                   "] which is higher than the version of this node [" + Version.CURRENT + "]")__        }_    };checks,that,snapshots,can,be,restored,and,have,compatible,version,param,repository,repository,name,param,snapshot,info,snapshot,metadata;private,void,validate,snapshot,restorable,final,string,repository,final,snapshot,info,snapshot,info,if,snapshot,info,state,restorable,throw,new,snapshot,restore,exception,new,snapshot,repository,snapshot,info,snapshot,id,unsupported,snapshot,state,snapshot,info,state,if,version,current,before,snapshot,info,version,throw,new,snapshot,restore,exception,new,snapshot,repository,snapshot,info,snapshot,id,the,snapshot,was,created,with,elasticsearch,version,snapshot,info,version,which,is,higher,than,the,version,of,this,node,version,current
RestoreService -> private void validateSnapshotRestorable(final String repository, final SnapshotInfo snapshotInfo);1535723122;Checks that snapshots can be restored and have compatible version__@param repository      repository name_@param snapshotInfo    snapshot metadata;private void validateSnapshotRestorable(final String repository, final SnapshotInfo snapshotInfo) {_        if (!snapshotInfo.state().restorable()) {_            throw new SnapshotRestoreException(new Snapshot(repository, snapshotInfo.snapshotId()),_                                               "unsupported snapshot state [" + snapshotInfo.state() + "]")__        }_        if (Version.CURRENT.before(snapshotInfo.version())) {_            throw new SnapshotRestoreException(new Snapshot(repository, snapshotInfo.snapshotId()),_                                               "the snapshot was created with Elasticsearch version [" + snapshotInfo.version() +_                                                   "] which is higher than the version of this node [" + Version.CURRENT + "]")__        }_    };checks,that,snapshots,can,be,restored,and,have,compatible,version,param,repository,repository,name,param,snapshot,info,snapshot,metadata;private,void,validate,snapshot,restorable,final,string,repository,final,snapshot,info,snapshot,info,if,snapshot,info,state,restorable,throw,new,snapshot,restore,exception,new,snapshot,repository,snapshot,info,snapshot,id,unsupported,snapshot,state,snapshot,info,state,if,version,current,before,snapshot,info,version,throw,new,snapshot,restore,exception,new,snapshot,repository,snapshot,info,snapshot,id,the,snapshot,was,created,with,elasticsearch,version,snapshot,info,version,which,is,higher,than,the,version,of,this,node,version,current
RestoreService -> private void validateSnapshotRestorable(final String repository, final SnapshotInfo snapshotInfo);1536137328;Checks that snapshots can be restored and have compatible version__@param repository      repository name_@param snapshotInfo    snapshot metadata;private void validateSnapshotRestorable(final String repository, final SnapshotInfo snapshotInfo) {_        if (!snapshotInfo.state().restorable()) {_            throw new SnapshotRestoreException(new Snapshot(repository, snapshotInfo.snapshotId()),_                                               "unsupported snapshot state [" + snapshotInfo.state() + "]")__        }_        if (Version.CURRENT.before(snapshotInfo.version())) {_            throw new SnapshotRestoreException(new Snapshot(repository, snapshotInfo.snapshotId()),_                                               "the snapshot was created with Elasticsearch version [" + snapshotInfo.version() +_                                                   "] which is higher than the version of this node [" + Version.CURRENT + "]")__        }_    };checks,that,snapshots,can,be,restored,and,have,compatible,version,param,repository,repository,name,param,snapshot,info,snapshot,metadata;private,void,validate,snapshot,restorable,final,string,repository,final,snapshot,info,snapshot,info,if,snapshot,info,state,restorable,throw,new,snapshot,restore,exception,new,snapshot,repository,snapshot,info,snapshot,id,unsupported,snapshot,state,snapshot,info,state,if,version,current,before,snapshot,info,version,throw,new,snapshot,restore,exception,new,snapshot,repository,snapshot,info,snapshot,id,the,snapshot,was,created,with,elasticsearch,version,snapshot,info,version,which,is,higher,than,the,version,of,this,node,version,current
RestoreService -> private void validateSnapshotRestorable(final String repository, final SnapshotInfo snapshotInfo);1539723533;Checks that snapshots can be restored and have compatible version__@param repository      repository name_@param snapshotInfo    snapshot metadata;private void validateSnapshotRestorable(final String repository, final SnapshotInfo snapshotInfo) {_        if (!snapshotInfo.state().restorable()) {_            throw new SnapshotRestoreException(new Snapshot(repository, snapshotInfo.snapshotId()),_                                               "unsupported snapshot state [" + snapshotInfo.state() + "]")__        }_        if (Version.CURRENT.before(snapshotInfo.version())) {_            throw new SnapshotRestoreException(new Snapshot(repository, snapshotInfo.snapshotId()),_                                               "the snapshot was created with Elasticsearch version [" + snapshotInfo.version() +_                                                   "] which is higher than the version of this node [" + Version.CURRENT + "]")__        }_    };checks,that,snapshots,can,be,restored,and,have,compatible,version,param,repository,repository,name,param,snapshot,info,snapshot,metadata;private,void,validate,snapshot,restorable,final,string,repository,final,snapshot,info,snapshot,info,if,snapshot,info,state,restorable,throw,new,snapshot,restore,exception,new,snapshot,repository,snapshot,info,snapshot,id,unsupported,snapshot,state,snapshot,info,state,if,version,current,before,snapshot,info,version,throw,new,snapshot,restore,exception,new,snapshot,repository,snapshot,info,snapshot,id,the,snapshot,was,created,with,elasticsearch,version,snapshot,info,version,which,is,higher,than,the,version,of,this,node,version,current
RestoreService -> private void validateSnapshotRestorable(final String repository, final SnapshotInfo snapshotInfo);1540486836;Checks that snapshots can be restored and have compatible version__@param repository      repository name_@param snapshotInfo    snapshot metadata;private void validateSnapshotRestorable(final String repository, final SnapshotInfo snapshotInfo) {_        if (!snapshotInfo.state().restorable()) {_            throw new SnapshotRestoreException(new Snapshot(repository, snapshotInfo.snapshotId()),_                                               "unsupported snapshot state [" + snapshotInfo.state() + "]")__        }_        if (Version.CURRENT.before(snapshotInfo.version())) {_            throw new SnapshotRestoreException(new Snapshot(repository, snapshotInfo.snapshotId()),_                                               "the snapshot was created with Elasticsearch version [" + snapshotInfo.version() +_                                                   "] which is higher than the version of this node [" + Version.CURRENT + "]")__        }_    };checks,that,snapshots,can,be,restored,and,have,compatible,version,param,repository,repository,name,param,snapshot,info,snapshot,metadata;private,void,validate,snapshot,restorable,final,string,repository,final,snapshot,info,snapshot,info,if,snapshot,info,state,restorable,throw,new,snapshot,restore,exception,new,snapshot,repository,snapshot,info,snapshot,id,unsupported,snapshot,state,snapshot,info,state,if,version,current,before,snapshot,info,version,throw,new,snapshot,restore,exception,new,snapshot,repository,snapshot,info,snapshot,id,the,snapshot,was,created,with,elasticsearch,version,snapshot,info,version,which,is,higher,than,the,version,of,this,node,version,current
RestoreService -> private void validateSnapshotRestorable(final String repository, final SnapshotInfo snapshotInfo);1541092382;Checks that snapshots can be restored and have compatible version__@param repository      repository name_@param snapshotInfo    snapshot metadata;private void validateSnapshotRestorable(final String repository, final SnapshotInfo snapshotInfo) {_        if (!snapshotInfo.state().restorable()) {_            throw new SnapshotRestoreException(new Snapshot(repository, snapshotInfo.snapshotId()),_                                               "unsupported snapshot state [" + snapshotInfo.state() + "]")__        }_        if (Version.CURRENT.before(snapshotInfo.version())) {_            throw new SnapshotRestoreException(new Snapshot(repository, snapshotInfo.snapshotId()),_                                               "the snapshot was created with Elasticsearch version [" + snapshotInfo.version() +_                                                   "] which is higher than the version of this node [" + Version.CURRENT + "]")__        }_    };checks,that,snapshots,can,be,restored,and,have,compatible,version,param,repository,repository,name,param,snapshot,info,snapshot,metadata;private,void,validate,snapshot,restorable,final,string,repository,final,snapshot,info,snapshot,info,if,snapshot,info,state,restorable,throw,new,snapshot,restore,exception,new,snapshot,repository,snapshot,info,snapshot,id,unsupported,snapshot,state,snapshot,info,state,if,version,current,before,snapshot,info,version,throw,new,snapshot,restore,exception,new,snapshot,repository,snapshot,info,snapshot,id,the,snapshot,was,created,with,elasticsearch,version,snapshot,info,version,which,is,higher,than,the,version,of,this,node,version,current
RestoreService -> private void validateSnapshotRestorable(final String repository, final SnapshotInfo snapshotInfo);1542402632;Checks that snapshots can be restored and have compatible version__@param repository      repository name_@param snapshotInfo    snapshot metadata;private void validateSnapshotRestorable(final String repository, final SnapshotInfo snapshotInfo) {_        if (!snapshotInfo.state().restorable()) {_            throw new SnapshotRestoreException(new Snapshot(repository, snapshotInfo.snapshotId()),_                                               "unsupported snapshot state [" + snapshotInfo.state() + "]")__        }_        if (Version.CURRENT.before(snapshotInfo.version())) {_            throw new SnapshotRestoreException(new Snapshot(repository, snapshotInfo.snapshotId()),_                                               "the snapshot was created with Elasticsearch version [" + snapshotInfo.version() +_                                                   "] which is higher than the version of this node [" + Version.CURRENT + "]")__        }_    };checks,that,snapshots,can,be,restored,and,have,compatible,version,param,repository,repository,name,param,snapshot,info,snapshot,metadata;private,void,validate,snapshot,restorable,final,string,repository,final,snapshot,info,snapshot,info,if,snapshot,info,state,restorable,throw,new,snapshot,restore,exception,new,snapshot,repository,snapshot,info,snapshot,id,unsupported,snapshot,state,snapshot,info,state,if,version,current,before,snapshot,info,version,throw,new,snapshot,restore,exception,new,snapshot,repository,snapshot,info,snapshot,id,the,snapshot,was,created,with,elasticsearch,version,snapshot,info,version,which,is,higher,than,the,version,of,this,node,version,current
RestoreService -> private void validateSnapshotRestorable(final String repository, final SnapshotInfo snapshotInfo);1544783963;Checks that snapshots can be restored and have compatible version__@param repository      repository name_@param snapshotInfo    snapshot metadata;private void validateSnapshotRestorable(final String repository, final SnapshotInfo snapshotInfo) {_        if (!snapshotInfo.state().restorable()) {_            throw new SnapshotRestoreException(new Snapshot(repository, snapshotInfo.snapshotId()),_                                               "unsupported snapshot state [" + snapshotInfo.state() + "]")__        }_        if (Version.CURRENT.before(snapshotInfo.version())) {_            throw new SnapshotRestoreException(new Snapshot(repository, snapshotInfo.snapshotId()),_                                               "the snapshot was created with Elasticsearch version [" + snapshotInfo.version() +_                                                   "] which is higher than the version of this node [" + Version.CURRENT + "]")__        }_    };checks,that,snapshots,can,be,restored,and,have,compatible,version,param,repository,repository,name,param,snapshot,info,snapshot,metadata;private,void,validate,snapshot,restorable,final,string,repository,final,snapshot,info,snapshot,info,if,snapshot,info,state,restorable,throw,new,snapshot,restore,exception,new,snapshot,repository,snapshot,info,snapshot,id,unsupported,snapshot,state,snapshot,info,state,if,version,current,before,snapshot,info,version,throw,new,snapshot,restore,exception,new,snapshot,repository,snapshot,info,snapshot,id,the,snapshot,was,created,with,elasticsearch,version,snapshot,info,version,which,is,higher,than,the,version,of,this,node,version,current
RestoreService -> private void validateSnapshotRestorable(final String repository, final SnapshotInfo snapshotInfo);1545215361;Checks that snapshots can be restored and have compatible version__@param repository      repository name_@param snapshotInfo    snapshot metadata;private void validateSnapshotRestorable(final String repository, final SnapshotInfo snapshotInfo) {_        if (!snapshotInfo.state().restorable()) {_            throw new SnapshotRestoreException(new Snapshot(repository, snapshotInfo.snapshotId()),_                                               "unsupported snapshot state [" + snapshotInfo.state() + "]")__        }_        if (Version.CURRENT.before(snapshotInfo.version())) {_            throw new SnapshotRestoreException(new Snapshot(repository, snapshotInfo.snapshotId()),_                                               "the snapshot was created with Elasticsearch version [" + snapshotInfo.version() +_                                                   "] which is higher than the version of this node [" + Version.CURRENT + "]")__        }_    };checks,that,snapshots,can,be,restored,and,have,compatible,version,param,repository,repository,name,param,snapshot,info,snapshot,metadata;private,void,validate,snapshot,restorable,final,string,repository,final,snapshot,info,snapshot,info,if,snapshot,info,state,restorable,throw,new,snapshot,restore,exception,new,snapshot,repository,snapshot,info,snapshot,id,unsupported,snapshot,state,snapshot,info,state,if,version,current,before,snapshot,info,version,throw,new,snapshot,restore,exception,new,snapshot,repository,snapshot,info,snapshot,id,the,snapshot,was,created,with,elasticsearch,version,snapshot,info,version,which,is,higher,than,the,version,of,this,node,version,current
RestoreService -> private void validateSnapshotRestorable(final String repository, final SnapshotInfo snapshotInfo);1547760203;Checks that snapshots can be restored and have compatible version__@param repository      repository name_@param snapshotInfo    snapshot metadata;private void validateSnapshotRestorable(final String repository, final SnapshotInfo snapshotInfo) {_        if (!snapshotInfo.state().restorable()) {_            throw new SnapshotRestoreException(new Snapshot(repository, snapshotInfo.snapshotId()),_                                               "unsupported snapshot state [" + snapshotInfo.state() + "]")__        }_        if (Version.CURRENT.before(snapshotInfo.version())) {_            throw new SnapshotRestoreException(new Snapshot(repository, snapshotInfo.snapshotId()),_                                               "the snapshot was created with Elasticsearch version [" + snapshotInfo.version() +_                                                   "] which is higher than the version of this node [" + Version.CURRENT + "]")__        }_    };checks,that,snapshots,can,be,restored,and,have,compatible,version,param,repository,repository,name,param,snapshot,info,snapshot,metadata;private,void,validate,snapshot,restorable,final,string,repository,final,snapshot,info,snapshot,info,if,snapshot,info,state,restorable,throw,new,snapshot,restore,exception,new,snapshot,repository,snapshot,info,snapshot,id,unsupported,snapshot,state,snapshot,info,state,if,version,current,before,snapshot,info,version,throw,new,snapshot,restore,exception,new,snapshot,repository,snapshot,info,snapshot,id,the,snapshot,was,created,with,elasticsearch,version,snapshot,info,version,which,is,higher,than,the,version,of,this,node,version,current
RestoreService -> private void validateSnapshotRestorable(final String repository, final SnapshotInfo snapshotInfo);1549033151;Checks that snapshots can be restored and have compatible version__@param repository      repository name_@param snapshotInfo    snapshot metadata;private void validateSnapshotRestorable(final String repository, final SnapshotInfo snapshotInfo) {_        if (!snapshotInfo.state().restorable()) {_            throw new SnapshotRestoreException(new Snapshot(repository, snapshotInfo.snapshotId()),_                                               "unsupported snapshot state [" + snapshotInfo.state() + "]")__        }_        if (Version.CURRENT.before(snapshotInfo.version())) {_            throw new SnapshotRestoreException(new Snapshot(repository, snapshotInfo.snapshotId()),_                                               "the snapshot was created with Elasticsearch version [" + snapshotInfo.version() +_                                                   "] which is higher than the version of this node [" + Version.CURRENT + "]")__        }_    };checks,that,snapshots,can,be,restored,and,have,compatible,version,param,repository,repository,name,param,snapshot,info,snapshot,metadata;private,void,validate,snapshot,restorable,final,string,repository,final,snapshot,info,snapshot,info,if,snapshot,info,state,restorable,throw,new,snapshot,restore,exception,new,snapshot,repository,snapshot,info,snapshot,id,unsupported,snapshot,state,snapshot,info,state,if,version,current,before,snapshot,info,version,throw,new,snapshot,restore,exception,new,snapshot,repository,snapshot,info,snapshot,id,the,snapshot,was,created,with,elasticsearch,version,snapshot,info,version,which,is,higher,than,the,version,of,this,node,version,current
RestoreService -> RestoreRequest -> public boolean partial();1524684173;Returns true if incomplete indices will be restored__@return partial indices restore flag;public boolean partial() {_            return partial__        };returns,true,if,incomplete,indices,will,be,restored,return,partial,indices,restore,flag;public,boolean,partial,return,partial
RestoreService -> RestoreRequest -> public boolean partial();1525248068;Returns true if incomplete indices will be restored__@return partial indices restore flag;public boolean partial() {_            return partial__        };returns,true,if,incomplete,indices,will,be,restored,return,partial,indices,restore,flag;public,boolean,partial,return,partial
RestoreService -> RestoreRequest -> public boolean partial();1535405719;Returns true if incomplete indices will be restored__@return partial indices restore flag;public boolean partial() {_            return partial__        };returns,true,if,incomplete,indices,will,be,restored,return,partial,indices,restore,flag;public,boolean,partial,return,partial
RestoreService -> RestoreRequest -> public boolean partial();1535723122;Returns true if incomplete indices will be restored__@return partial indices restore flag;public boolean partial() {_            return partial__        };returns,true,if,incomplete,indices,will,be,restored,return,partial,indices,restore,flag;public,boolean,partial,return,partial
RestoreService -> RestoreRequest -> public boolean partial();1536137328;Returns true if incomplete indices will be restored__@return partial indices restore flag;public boolean partial() {_            return partial__        };returns,true,if,incomplete,indices,will,be,restored,return,partial,indices,restore,flag;public,boolean,partial,return,partial
RestoreService -> RestoreRequest -> public boolean partial();1539723533;Returns true if incomplete indices will be restored__@return partial indices restore flag;public boolean partial() {_            return partial__        };returns,true,if,incomplete,indices,will,be,restored,return,partial,indices,restore,flag;public,boolean,partial,return,partial
RestoreService -> RestoreRequest -> public boolean partial();1540486836;Returns true if incomplete indices will be restored__@return partial indices restore flag;public boolean partial() {_            return partial__        };returns,true,if,incomplete,indices,will,be,restored,return,partial,indices,restore,flag;public,boolean,partial,return,partial
RestoreService -> RestoreRequest -> public boolean partial();1541092382;Returns true if incomplete indices will be restored__@return partial indices restore flag;public boolean partial() {_            return partial__        };returns,true,if,incomplete,indices,will,be,restored,return,partial,indices,restore,flag;public,boolean,partial,return,partial
RestoreService -> RestoreRequest -> public boolean partial();1542402632;Returns true if incomplete indices will be restored__@return partial indices restore flag;public boolean partial() {_            return partial__        };returns,true,if,incomplete,indices,will,be,restored,return,partial,indices,restore,flag;public,boolean,partial,return,partial
RestoreService -> RestoreRequest -> public boolean partial();1544783963;Returns true if incomplete indices will be restored__@return partial indices restore flag;public boolean partial() {_            return partial__        };returns,true,if,incomplete,indices,will,be,restored,return,partial,indices,restore,flag;public,boolean,partial,return,partial
RestoreService -> RestoreRequest -> public boolean partial();1545215361;Returns true if incomplete indices will be restored__@return partial indices restore flag;public boolean partial() {_            return partial__        };returns,true,if,incomplete,indices,will,be,restored,return,partial,indices,restore,flag;public,boolean,partial,return,partial
RestoreService -> RestoreRequest -> public RestoreRequest(String repositoryName, String snapshotName, String[] indices, IndicesOptions indicesOptions,                               String renamePattern, String renameReplacement, Settings settings,                               TimeValue masterNodeTimeout, boolean includeGlobalState, boolean partial, boolean includeAliases,                               Settings indexSettings, String[] ignoreIndexSettings, String cause);1524684173;Constructs new restore request__@param repositoryName     repositoryName_@param snapshotName       snapshotName_@param indices            list of indices to restore_@param indicesOptions     indices options_@param renamePattern      pattern to rename indices_@param renameReplacement  replacement for renamed indices_@param settings           repository specific restore settings_@param masterNodeTimeout  master node timeout_@param includeGlobalState include global state into restore_@param partial            allow partial restore_@param indexSettings      index settings that should be changed on restore_@param ignoreIndexSettings index settings that shouldn't be restored_@param cause              cause for restoring the snapshot;public RestoreRequest(String repositoryName, String snapshotName, String[] indices, IndicesOptions indicesOptions,_                              String renamePattern, String renameReplacement, Settings settings,_                              TimeValue masterNodeTimeout, boolean includeGlobalState, boolean partial, boolean includeAliases,_                              Settings indexSettings, String[] ignoreIndexSettings, String cause) {_            this.repositoryName = Objects.requireNonNull(repositoryName)__            this.snapshotName = Objects.requireNonNull(snapshotName)__            this.indices = indices__            this.renamePattern = renamePattern__            this.renameReplacement = renameReplacement__            this.indicesOptions = indicesOptions__            this.settings = settings__            this.masterNodeTimeout = masterNodeTimeout__            this.includeGlobalState = includeGlobalState__            this.partial = partial__            this.includeAliases = includeAliases__            this.indexSettings = indexSettings__            this.ignoreIndexSettings = ignoreIndexSettings__            this.cause = cause__        };constructs,new,restore,request,param,repository,name,repository,name,param,snapshot,name,snapshot,name,param,indices,list,of,indices,to,restore,param,indices,options,indices,options,param,rename,pattern,pattern,to,rename,indices,param,rename,replacement,replacement,for,renamed,indices,param,settings,repository,specific,restore,settings,param,master,node,timeout,master,node,timeout,param,include,global,state,include,global,state,into,restore,param,partial,allow,partial,restore,param,index,settings,index,settings,that,should,be,changed,on,restore,param,ignore,index,settings,index,settings,that,shouldn,t,be,restored,param,cause,cause,for,restoring,the,snapshot;public,restore,request,string,repository,name,string,snapshot,name,string,indices,indices,options,indices,options,string,rename,pattern,string,rename,replacement,settings,settings,time,value,master,node,timeout,boolean,include,global,state,boolean,partial,boolean,include,aliases,settings,index,settings,string,ignore,index,settings,string,cause,this,repository,name,objects,require,non,null,repository,name,this,snapshot,name,objects,require,non,null,snapshot,name,this,indices,indices,this,rename,pattern,rename,pattern,this,rename,replacement,rename,replacement,this,indices,options,indices,options,this,settings,settings,this,master,node,timeout,master,node,timeout,this,include,global,state,include,global,state,this,partial,partial,this,include,aliases,include,aliases,this,index,settings,index,settings,this,ignore,index,settings,ignore,index,settings,this,cause,cause
RestoreService -> RestoreRequest -> public RestoreRequest(String repositoryName, String snapshotName, String[] indices, IndicesOptions indicesOptions,                               String renamePattern, String renameReplacement, Settings settings,                               TimeValue masterNodeTimeout, boolean includeGlobalState, boolean partial, boolean includeAliases,                               Settings indexSettings, String[] ignoreIndexSettings, String cause);1525248068;Constructs new restore request__@param repositoryName     repositoryName_@param snapshotName       snapshotName_@param indices            list of indices to restore_@param indicesOptions     indices options_@param renamePattern      pattern to rename indices_@param renameReplacement  replacement for renamed indices_@param settings           repository specific restore settings_@param masterNodeTimeout  master node timeout_@param includeGlobalState include global state into restore_@param partial            allow partial restore_@param indexSettings      index settings that should be changed on restore_@param ignoreIndexSettings index settings that shouldn't be restored_@param cause              cause for restoring the snapshot;public RestoreRequest(String repositoryName, String snapshotName, String[] indices, IndicesOptions indicesOptions,_                              String renamePattern, String renameReplacement, Settings settings,_                              TimeValue masterNodeTimeout, boolean includeGlobalState, boolean partial, boolean includeAliases,_                              Settings indexSettings, String[] ignoreIndexSettings, String cause) {_            this.repositoryName = Objects.requireNonNull(repositoryName)__            this.snapshotName = Objects.requireNonNull(snapshotName)__            this.indices = indices__            this.renamePattern = renamePattern__            this.renameReplacement = renameReplacement__            this.indicesOptions = indicesOptions__            this.settings = settings__            this.masterNodeTimeout = masterNodeTimeout__            this.includeGlobalState = includeGlobalState__            this.partial = partial__            this.includeAliases = includeAliases__            this.indexSettings = indexSettings__            this.ignoreIndexSettings = ignoreIndexSettings__            this.cause = cause__        };constructs,new,restore,request,param,repository,name,repository,name,param,snapshot,name,snapshot,name,param,indices,list,of,indices,to,restore,param,indices,options,indices,options,param,rename,pattern,pattern,to,rename,indices,param,rename,replacement,replacement,for,renamed,indices,param,settings,repository,specific,restore,settings,param,master,node,timeout,master,node,timeout,param,include,global,state,include,global,state,into,restore,param,partial,allow,partial,restore,param,index,settings,index,settings,that,should,be,changed,on,restore,param,ignore,index,settings,index,settings,that,shouldn,t,be,restored,param,cause,cause,for,restoring,the,snapshot;public,restore,request,string,repository,name,string,snapshot,name,string,indices,indices,options,indices,options,string,rename,pattern,string,rename,replacement,settings,settings,time,value,master,node,timeout,boolean,include,global,state,boolean,partial,boolean,include,aliases,settings,index,settings,string,ignore,index,settings,string,cause,this,repository,name,objects,require,non,null,repository,name,this,snapshot,name,objects,require,non,null,snapshot,name,this,indices,indices,this,rename,pattern,rename,pattern,this,rename,replacement,rename,replacement,this,indices,options,indices,options,this,settings,settings,this,master,node,timeout,master,node,timeout,this,include,global,state,include,global,state,this,partial,partial,this,include,aliases,include,aliases,this,index,settings,index,settings,this,ignore,index,settings,ignore,index,settings,this,cause,cause
RestoreService -> RestoreRequest -> public RestoreRequest(String repositoryName, String snapshotName, String[] indices, IndicesOptions indicesOptions,                               String renamePattern, String renameReplacement, Settings settings,                               TimeValue masterNodeTimeout, boolean includeGlobalState, boolean partial, boolean includeAliases,                               Settings indexSettings, String[] ignoreIndexSettings, String cause);1535405719;Constructs new restore request__@param repositoryName     repositoryName_@param snapshotName       snapshotName_@param indices            list of indices to restore_@param indicesOptions     indices options_@param renamePattern      pattern to rename indices_@param renameReplacement  replacement for renamed indices_@param settings           repository specific restore settings_@param masterNodeTimeout  master node timeout_@param includeGlobalState include global state into restore_@param partial            allow partial restore_@param indexSettings      index settings that should be changed on restore_@param ignoreIndexSettings index settings that shouldn't be restored_@param cause              cause for restoring the snapshot;public RestoreRequest(String repositoryName, String snapshotName, String[] indices, IndicesOptions indicesOptions,_                              String renamePattern, String renameReplacement, Settings settings,_                              TimeValue masterNodeTimeout, boolean includeGlobalState, boolean partial, boolean includeAliases,_                              Settings indexSettings, String[] ignoreIndexSettings, String cause) {_            this.repositoryName = Objects.requireNonNull(repositoryName)__            this.snapshotName = Objects.requireNonNull(snapshotName)__            this.indices = indices__            this.renamePattern = renamePattern__            this.renameReplacement = renameReplacement__            this.indicesOptions = indicesOptions__            this.settings = settings__            this.masterNodeTimeout = masterNodeTimeout__            this.includeGlobalState = includeGlobalState__            this.partial = partial__            this.includeAliases = includeAliases__            this.indexSettings = indexSettings__            this.ignoreIndexSettings = ignoreIndexSettings__            this.cause = cause__        };constructs,new,restore,request,param,repository,name,repository,name,param,snapshot,name,snapshot,name,param,indices,list,of,indices,to,restore,param,indices,options,indices,options,param,rename,pattern,pattern,to,rename,indices,param,rename,replacement,replacement,for,renamed,indices,param,settings,repository,specific,restore,settings,param,master,node,timeout,master,node,timeout,param,include,global,state,include,global,state,into,restore,param,partial,allow,partial,restore,param,index,settings,index,settings,that,should,be,changed,on,restore,param,ignore,index,settings,index,settings,that,shouldn,t,be,restored,param,cause,cause,for,restoring,the,snapshot;public,restore,request,string,repository,name,string,snapshot,name,string,indices,indices,options,indices,options,string,rename,pattern,string,rename,replacement,settings,settings,time,value,master,node,timeout,boolean,include,global,state,boolean,partial,boolean,include,aliases,settings,index,settings,string,ignore,index,settings,string,cause,this,repository,name,objects,require,non,null,repository,name,this,snapshot,name,objects,require,non,null,snapshot,name,this,indices,indices,this,rename,pattern,rename,pattern,this,rename,replacement,rename,replacement,this,indices,options,indices,options,this,settings,settings,this,master,node,timeout,master,node,timeout,this,include,global,state,include,global,state,this,partial,partial,this,include,aliases,include,aliases,this,index,settings,index,settings,this,ignore,index,settings,ignore,index,settings,this,cause,cause
RestoreService -> RestoreRequest -> public RestoreRequest(String repositoryName, String snapshotName, String[] indices, IndicesOptions indicesOptions,                               String renamePattern, String renameReplacement, Settings settings,                               TimeValue masterNodeTimeout, boolean includeGlobalState, boolean partial, boolean includeAliases,                               Settings indexSettings, String[] ignoreIndexSettings, String cause);1535723122;Constructs new restore request__@param repositoryName     repositoryName_@param snapshotName       snapshotName_@param indices            list of indices to restore_@param indicesOptions     indices options_@param renamePattern      pattern to rename indices_@param renameReplacement  replacement for renamed indices_@param settings           repository specific restore settings_@param masterNodeTimeout  master node timeout_@param includeGlobalState include global state into restore_@param partial            allow partial restore_@param indexSettings      index settings that should be changed on restore_@param ignoreIndexSettings index settings that shouldn't be restored_@param cause              cause for restoring the snapshot;public RestoreRequest(String repositoryName, String snapshotName, String[] indices, IndicesOptions indicesOptions,_                              String renamePattern, String renameReplacement, Settings settings,_                              TimeValue masterNodeTimeout, boolean includeGlobalState, boolean partial, boolean includeAliases,_                              Settings indexSettings, String[] ignoreIndexSettings, String cause) {_            this.repositoryName = Objects.requireNonNull(repositoryName)__            this.snapshotName = Objects.requireNonNull(snapshotName)__            this.indices = indices__            this.renamePattern = renamePattern__            this.renameReplacement = renameReplacement__            this.indicesOptions = indicesOptions__            this.settings = settings__            this.masterNodeTimeout = masterNodeTimeout__            this.includeGlobalState = includeGlobalState__            this.partial = partial__            this.includeAliases = includeAliases__            this.indexSettings = indexSettings__            this.ignoreIndexSettings = ignoreIndexSettings__            this.cause = cause__        };constructs,new,restore,request,param,repository,name,repository,name,param,snapshot,name,snapshot,name,param,indices,list,of,indices,to,restore,param,indices,options,indices,options,param,rename,pattern,pattern,to,rename,indices,param,rename,replacement,replacement,for,renamed,indices,param,settings,repository,specific,restore,settings,param,master,node,timeout,master,node,timeout,param,include,global,state,include,global,state,into,restore,param,partial,allow,partial,restore,param,index,settings,index,settings,that,should,be,changed,on,restore,param,ignore,index,settings,index,settings,that,shouldn,t,be,restored,param,cause,cause,for,restoring,the,snapshot;public,restore,request,string,repository,name,string,snapshot,name,string,indices,indices,options,indices,options,string,rename,pattern,string,rename,replacement,settings,settings,time,value,master,node,timeout,boolean,include,global,state,boolean,partial,boolean,include,aliases,settings,index,settings,string,ignore,index,settings,string,cause,this,repository,name,objects,require,non,null,repository,name,this,snapshot,name,objects,require,non,null,snapshot,name,this,indices,indices,this,rename,pattern,rename,pattern,this,rename,replacement,rename,replacement,this,indices,options,indices,options,this,settings,settings,this,master,node,timeout,master,node,timeout,this,include,global,state,include,global,state,this,partial,partial,this,include,aliases,include,aliases,this,index,settings,index,settings,this,ignore,index,settings,ignore,index,settings,this,cause,cause
RestoreService -> RestoreRequest -> public RestoreRequest(String repositoryName, String snapshotName, String[] indices, IndicesOptions indicesOptions,                               String renamePattern, String renameReplacement, Settings settings,                               TimeValue masterNodeTimeout, boolean includeGlobalState, boolean partial, boolean includeAliases,                               Settings indexSettings, String[] ignoreIndexSettings, String cause);1536137328;Constructs new restore request__@param repositoryName     repositoryName_@param snapshotName       snapshotName_@param indices            list of indices to restore_@param indicesOptions     indices options_@param renamePattern      pattern to rename indices_@param renameReplacement  replacement for renamed indices_@param settings           repository specific restore settings_@param masterNodeTimeout  master node timeout_@param includeGlobalState include global state into restore_@param partial            allow partial restore_@param indexSettings      index settings that should be changed on restore_@param ignoreIndexSettings index settings that shouldn't be restored_@param cause              cause for restoring the snapshot;public RestoreRequest(String repositoryName, String snapshotName, String[] indices, IndicesOptions indicesOptions,_                              String renamePattern, String renameReplacement, Settings settings,_                              TimeValue masterNodeTimeout, boolean includeGlobalState, boolean partial, boolean includeAliases,_                              Settings indexSettings, String[] ignoreIndexSettings, String cause) {_            this.repositoryName = Objects.requireNonNull(repositoryName)__            this.snapshotName = Objects.requireNonNull(snapshotName)__            this.indices = indices__            this.renamePattern = renamePattern__            this.renameReplacement = renameReplacement__            this.indicesOptions = indicesOptions__            this.settings = settings__            this.masterNodeTimeout = masterNodeTimeout__            this.includeGlobalState = includeGlobalState__            this.partial = partial__            this.includeAliases = includeAliases__            this.indexSettings = indexSettings__            this.ignoreIndexSettings = ignoreIndexSettings__            this.cause = cause__        };constructs,new,restore,request,param,repository,name,repository,name,param,snapshot,name,snapshot,name,param,indices,list,of,indices,to,restore,param,indices,options,indices,options,param,rename,pattern,pattern,to,rename,indices,param,rename,replacement,replacement,for,renamed,indices,param,settings,repository,specific,restore,settings,param,master,node,timeout,master,node,timeout,param,include,global,state,include,global,state,into,restore,param,partial,allow,partial,restore,param,index,settings,index,settings,that,should,be,changed,on,restore,param,ignore,index,settings,index,settings,that,shouldn,t,be,restored,param,cause,cause,for,restoring,the,snapshot;public,restore,request,string,repository,name,string,snapshot,name,string,indices,indices,options,indices,options,string,rename,pattern,string,rename,replacement,settings,settings,time,value,master,node,timeout,boolean,include,global,state,boolean,partial,boolean,include,aliases,settings,index,settings,string,ignore,index,settings,string,cause,this,repository,name,objects,require,non,null,repository,name,this,snapshot,name,objects,require,non,null,snapshot,name,this,indices,indices,this,rename,pattern,rename,pattern,this,rename,replacement,rename,replacement,this,indices,options,indices,options,this,settings,settings,this,master,node,timeout,master,node,timeout,this,include,global,state,include,global,state,this,partial,partial,this,include,aliases,include,aliases,this,index,settings,index,settings,this,ignore,index,settings,ignore,index,settings,this,cause,cause
RestoreService -> RestoreRequest -> public RestoreRequest(String repositoryName, String snapshotName, String[] indices, IndicesOptions indicesOptions,                               String renamePattern, String renameReplacement, Settings settings,                               TimeValue masterNodeTimeout, boolean includeGlobalState, boolean partial, boolean includeAliases,                               Settings indexSettings, String[] ignoreIndexSettings, String cause);1539723533;Constructs new restore request__@param repositoryName     repositoryName_@param snapshotName       snapshotName_@param indices            list of indices to restore_@param indicesOptions     indices options_@param renamePattern      pattern to rename indices_@param renameReplacement  replacement for renamed indices_@param settings           repository specific restore settings_@param masterNodeTimeout  master node timeout_@param includeGlobalState include global state into restore_@param partial            allow partial restore_@param indexSettings      index settings that should be changed on restore_@param ignoreIndexSettings index settings that shouldn't be restored_@param cause              cause for restoring the snapshot;public RestoreRequest(String repositoryName, String snapshotName, String[] indices, IndicesOptions indicesOptions,_                              String renamePattern, String renameReplacement, Settings settings,_                              TimeValue masterNodeTimeout, boolean includeGlobalState, boolean partial, boolean includeAliases,_                              Settings indexSettings, String[] ignoreIndexSettings, String cause) {_            this.repositoryName = Objects.requireNonNull(repositoryName)__            this.snapshotName = Objects.requireNonNull(snapshotName)__            this.indices = indices__            this.renamePattern = renamePattern__            this.renameReplacement = renameReplacement__            this.indicesOptions = indicesOptions__            this.settings = settings__            this.masterNodeTimeout = masterNodeTimeout__            this.includeGlobalState = includeGlobalState__            this.partial = partial__            this.includeAliases = includeAliases__            this.indexSettings = indexSettings__            this.ignoreIndexSettings = ignoreIndexSettings__            this.cause = cause__        };constructs,new,restore,request,param,repository,name,repository,name,param,snapshot,name,snapshot,name,param,indices,list,of,indices,to,restore,param,indices,options,indices,options,param,rename,pattern,pattern,to,rename,indices,param,rename,replacement,replacement,for,renamed,indices,param,settings,repository,specific,restore,settings,param,master,node,timeout,master,node,timeout,param,include,global,state,include,global,state,into,restore,param,partial,allow,partial,restore,param,index,settings,index,settings,that,should,be,changed,on,restore,param,ignore,index,settings,index,settings,that,shouldn,t,be,restored,param,cause,cause,for,restoring,the,snapshot;public,restore,request,string,repository,name,string,snapshot,name,string,indices,indices,options,indices,options,string,rename,pattern,string,rename,replacement,settings,settings,time,value,master,node,timeout,boolean,include,global,state,boolean,partial,boolean,include,aliases,settings,index,settings,string,ignore,index,settings,string,cause,this,repository,name,objects,require,non,null,repository,name,this,snapshot,name,objects,require,non,null,snapshot,name,this,indices,indices,this,rename,pattern,rename,pattern,this,rename,replacement,rename,replacement,this,indices,options,indices,options,this,settings,settings,this,master,node,timeout,master,node,timeout,this,include,global,state,include,global,state,this,partial,partial,this,include,aliases,include,aliases,this,index,settings,index,settings,this,ignore,index,settings,ignore,index,settings,this,cause,cause
RestoreService -> RestoreRequest -> public RestoreRequest(String repositoryName, String snapshotName, String[] indices, IndicesOptions indicesOptions,                               String renamePattern, String renameReplacement, Settings settings,                               TimeValue masterNodeTimeout, boolean includeGlobalState, boolean partial, boolean includeAliases,                               Settings indexSettings, String[] ignoreIndexSettings, String cause);1540486836;Constructs new restore request__@param repositoryName     repositoryName_@param snapshotName       snapshotName_@param indices            list of indices to restore_@param indicesOptions     indices options_@param renamePattern      pattern to rename indices_@param renameReplacement  replacement for renamed indices_@param settings           repository specific restore settings_@param masterNodeTimeout  master node timeout_@param includeGlobalState include global state into restore_@param partial            allow partial restore_@param indexSettings      index settings that should be changed on restore_@param ignoreIndexSettings index settings that shouldn't be restored_@param cause              cause for restoring the snapshot;public RestoreRequest(String repositoryName, String snapshotName, String[] indices, IndicesOptions indicesOptions,_                              String renamePattern, String renameReplacement, Settings settings,_                              TimeValue masterNodeTimeout, boolean includeGlobalState, boolean partial, boolean includeAliases,_                              Settings indexSettings, String[] ignoreIndexSettings, String cause) {_            this.repositoryName = Objects.requireNonNull(repositoryName)__            this.snapshotName = Objects.requireNonNull(snapshotName)__            this.indices = indices__            this.renamePattern = renamePattern__            this.renameReplacement = renameReplacement__            this.indicesOptions = indicesOptions__            this.settings = settings__            this.masterNodeTimeout = masterNodeTimeout__            this.includeGlobalState = includeGlobalState__            this.partial = partial__            this.includeAliases = includeAliases__            this.indexSettings = indexSettings__            this.ignoreIndexSettings = ignoreIndexSettings__            this.cause = cause__        };constructs,new,restore,request,param,repository,name,repository,name,param,snapshot,name,snapshot,name,param,indices,list,of,indices,to,restore,param,indices,options,indices,options,param,rename,pattern,pattern,to,rename,indices,param,rename,replacement,replacement,for,renamed,indices,param,settings,repository,specific,restore,settings,param,master,node,timeout,master,node,timeout,param,include,global,state,include,global,state,into,restore,param,partial,allow,partial,restore,param,index,settings,index,settings,that,should,be,changed,on,restore,param,ignore,index,settings,index,settings,that,shouldn,t,be,restored,param,cause,cause,for,restoring,the,snapshot;public,restore,request,string,repository,name,string,snapshot,name,string,indices,indices,options,indices,options,string,rename,pattern,string,rename,replacement,settings,settings,time,value,master,node,timeout,boolean,include,global,state,boolean,partial,boolean,include,aliases,settings,index,settings,string,ignore,index,settings,string,cause,this,repository,name,objects,require,non,null,repository,name,this,snapshot,name,objects,require,non,null,snapshot,name,this,indices,indices,this,rename,pattern,rename,pattern,this,rename,replacement,rename,replacement,this,indices,options,indices,options,this,settings,settings,this,master,node,timeout,master,node,timeout,this,include,global,state,include,global,state,this,partial,partial,this,include,aliases,include,aliases,this,index,settings,index,settings,this,ignore,index,settings,ignore,index,settings,this,cause,cause
RestoreService -> RestoreRequest -> public RestoreRequest(String repositoryName, String snapshotName, String[] indices, IndicesOptions indicesOptions,                               String renamePattern, String renameReplacement, Settings settings,                               TimeValue masterNodeTimeout, boolean includeGlobalState, boolean partial, boolean includeAliases,                               Settings indexSettings, String[] ignoreIndexSettings, String cause);1541092382;Constructs new restore request__@param repositoryName     repositoryName_@param snapshotName       snapshotName_@param indices            list of indices to restore_@param indicesOptions     indices options_@param renamePattern      pattern to rename indices_@param renameReplacement  replacement for renamed indices_@param settings           repository specific restore settings_@param masterNodeTimeout  master node timeout_@param includeGlobalState include global state into restore_@param partial            allow partial restore_@param indexSettings      index settings that should be changed on restore_@param ignoreIndexSettings index settings that shouldn't be restored_@param cause              cause for restoring the snapshot;public RestoreRequest(String repositoryName, String snapshotName, String[] indices, IndicesOptions indicesOptions,_                              String renamePattern, String renameReplacement, Settings settings,_                              TimeValue masterNodeTimeout, boolean includeGlobalState, boolean partial, boolean includeAliases,_                              Settings indexSettings, String[] ignoreIndexSettings, String cause) {_            this.repositoryName = Objects.requireNonNull(repositoryName)__            this.snapshotName = Objects.requireNonNull(snapshotName)__            this.indices = indices__            this.renamePattern = renamePattern__            this.renameReplacement = renameReplacement__            this.indicesOptions = indicesOptions__            this.settings = settings__            this.masterNodeTimeout = masterNodeTimeout__            this.includeGlobalState = includeGlobalState__            this.partial = partial__            this.includeAliases = includeAliases__            this.indexSettings = indexSettings__            this.ignoreIndexSettings = ignoreIndexSettings__            this.cause = cause__        };constructs,new,restore,request,param,repository,name,repository,name,param,snapshot,name,snapshot,name,param,indices,list,of,indices,to,restore,param,indices,options,indices,options,param,rename,pattern,pattern,to,rename,indices,param,rename,replacement,replacement,for,renamed,indices,param,settings,repository,specific,restore,settings,param,master,node,timeout,master,node,timeout,param,include,global,state,include,global,state,into,restore,param,partial,allow,partial,restore,param,index,settings,index,settings,that,should,be,changed,on,restore,param,ignore,index,settings,index,settings,that,shouldn,t,be,restored,param,cause,cause,for,restoring,the,snapshot;public,restore,request,string,repository,name,string,snapshot,name,string,indices,indices,options,indices,options,string,rename,pattern,string,rename,replacement,settings,settings,time,value,master,node,timeout,boolean,include,global,state,boolean,partial,boolean,include,aliases,settings,index,settings,string,ignore,index,settings,string,cause,this,repository,name,objects,require,non,null,repository,name,this,snapshot,name,objects,require,non,null,snapshot,name,this,indices,indices,this,rename,pattern,rename,pattern,this,rename,replacement,rename,replacement,this,indices,options,indices,options,this,settings,settings,this,master,node,timeout,master,node,timeout,this,include,global,state,include,global,state,this,partial,partial,this,include,aliases,include,aliases,this,index,settings,index,settings,this,ignore,index,settings,ignore,index,settings,this,cause,cause
RestoreService -> RestoreRequest -> public RestoreRequest(String repositoryName, String snapshotName, String[] indices, IndicesOptions indicesOptions,                               String renamePattern, String renameReplacement, Settings settings,                               TimeValue masterNodeTimeout, boolean includeGlobalState, boolean partial, boolean includeAliases,                               Settings indexSettings, String[] ignoreIndexSettings, String cause);1542402632;Constructs new restore request__@param repositoryName     repositoryName_@param snapshotName       snapshotName_@param indices            list of indices to restore_@param indicesOptions     indices options_@param renamePattern      pattern to rename indices_@param renameReplacement  replacement for renamed indices_@param settings           repository specific restore settings_@param masterNodeTimeout  master node timeout_@param includeGlobalState include global state into restore_@param partial            allow partial restore_@param indexSettings      index settings that should be changed on restore_@param ignoreIndexSettings index settings that shouldn't be restored_@param cause              cause for restoring the snapshot;public RestoreRequest(String repositoryName, String snapshotName, String[] indices, IndicesOptions indicesOptions,_                              String renamePattern, String renameReplacement, Settings settings,_                              TimeValue masterNodeTimeout, boolean includeGlobalState, boolean partial, boolean includeAliases,_                              Settings indexSettings, String[] ignoreIndexSettings, String cause) {_            this.repositoryName = Objects.requireNonNull(repositoryName)__            this.snapshotName = Objects.requireNonNull(snapshotName)__            this.indices = indices__            this.renamePattern = renamePattern__            this.renameReplacement = renameReplacement__            this.indicesOptions = indicesOptions__            this.settings = settings__            this.masterNodeTimeout = masterNodeTimeout__            this.includeGlobalState = includeGlobalState__            this.partial = partial__            this.includeAliases = includeAliases__            this.indexSettings = indexSettings__            this.ignoreIndexSettings = ignoreIndexSettings__            this.cause = cause__        };constructs,new,restore,request,param,repository,name,repository,name,param,snapshot,name,snapshot,name,param,indices,list,of,indices,to,restore,param,indices,options,indices,options,param,rename,pattern,pattern,to,rename,indices,param,rename,replacement,replacement,for,renamed,indices,param,settings,repository,specific,restore,settings,param,master,node,timeout,master,node,timeout,param,include,global,state,include,global,state,into,restore,param,partial,allow,partial,restore,param,index,settings,index,settings,that,should,be,changed,on,restore,param,ignore,index,settings,index,settings,that,shouldn,t,be,restored,param,cause,cause,for,restoring,the,snapshot;public,restore,request,string,repository,name,string,snapshot,name,string,indices,indices,options,indices,options,string,rename,pattern,string,rename,replacement,settings,settings,time,value,master,node,timeout,boolean,include,global,state,boolean,partial,boolean,include,aliases,settings,index,settings,string,ignore,index,settings,string,cause,this,repository,name,objects,require,non,null,repository,name,this,snapshot,name,objects,require,non,null,snapshot,name,this,indices,indices,this,rename,pattern,rename,pattern,this,rename,replacement,rename,replacement,this,indices,options,indices,options,this,settings,settings,this,master,node,timeout,master,node,timeout,this,include,global,state,include,global,state,this,partial,partial,this,include,aliases,include,aliases,this,index,settings,index,settings,this,ignore,index,settings,ignore,index,settings,this,cause,cause
RestoreService -> RestoreRequest -> public RestoreRequest(String repositoryName, String snapshotName, String[] indices, IndicesOptions indicesOptions,                               String renamePattern, String renameReplacement, Settings settings,                               TimeValue masterNodeTimeout, boolean includeGlobalState, boolean partial, boolean includeAliases,                               Settings indexSettings, String[] ignoreIndexSettings, String cause);1544783963;Constructs new restore request__@param repositoryName     repositoryName_@param snapshotName       snapshotName_@param indices            list of indices to restore_@param indicesOptions     indices options_@param renamePattern      pattern to rename indices_@param renameReplacement  replacement for renamed indices_@param settings           repository specific restore settings_@param masterNodeTimeout  master node timeout_@param includeGlobalState include global state into restore_@param partial            allow partial restore_@param indexSettings      index settings that should be changed on restore_@param ignoreIndexSettings index settings that shouldn't be restored_@param cause              cause for restoring the snapshot;public RestoreRequest(String repositoryName, String snapshotName, String[] indices, IndicesOptions indicesOptions,_                              String renamePattern, String renameReplacement, Settings settings,_                              TimeValue masterNodeTimeout, boolean includeGlobalState, boolean partial, boolean includeAliases,_                              Settings indexSettings, String[] ignoreIndexSettings, String cause) {_            this.repositoryName = Objects.requireNonNull(repositoryName)__            this.snapshotName = Objects.requireNonNull(snapshotName)__            this.indices = indices__            this.renamePattern = renamePattern__            this.renameReplacement = renameReplacement__            this.indicesOptions = indicesOptions__            this.settings = settings__            this.masterNodeTimeout = masterNodeTimeout__            this.includeGlobalState = includeGlobalState__            this.partial = partial__            this.includeAliases = includeAliases__            this.indexSettings = indexSettings__            this.ignoreIndexSettings = ignoreIndexSettings__            this.cause = cause__        };constructs,new,restore,request,param,repository,name,repository,name,param,snapshot,name,snapshot,name,param,indices,list,of,indices,to,restore,param,indices,options,indices,options,param,rename,pattern,pattern,to,rename,indices,param,rename,replacement,replacement,for,renamed,indices,param,settings,repository,specific,restore,settings,param,master,node,timeout,master,node,timeout,param,include,global,state,include,global,state,into,restore,param,partial,allow,partial,restore,param,index,settings,index,settings,that,should,be,changed,on,restore,param,ignore,index,settings,index,settings,that,shouldn,t,be,restored,param,cause,cause,for,restoring,the,snapshot;public,restore,request,string,repository,name,string,snapshot,name,string,indices,indices,options,indices,options,string,rename,pattern,string,rename,replacement,settings,settings,time,value,master,node,timeout,boolean,include,global,state,boolean,partial,boolean,include,aliases,settings,index,settings,string,ignore,index,settings,string,cause,this,repository,name,objects,require,non,null,repository,name,this,snapshot,name,objects,require,non,null,snapshot,name,this,indices,indices,this,rename,pattern,rename,pattern,this,rename,replacement,rename,replacement,this,indices,options,indices,options,this,settings,settings,this,master,node,timeout,master,node,timeout,this,include,global,state,include,global,state,this,partial,partial,this,include,aliases,include,aliases,this,index,settings,index,settings,this,ignore,index,settings,ignore,index,settings,this,cause,cause
RestoreService -> RestoreRequest -> public RestoreRequest(String repositoryName, String snapshotName, String[] indices, IndicesOptions indicesOptions,                               String renamePattern, String renameReplacement, Settings settings,                               TimeValue masterNodeTimeout, boolean includeGlobalState, boolean partial, boolean includeAliases,                               Settings indexSettings, String[] ignoreIndexSettings, String cause);1545215361;Constructs new restore request__@param repositoryName     repositoryName_@param snapshotName       snapshotName_@param indices            list of indices to restore_@param indicesOptions     indices options_@param renamePattern      pattern to rename indices_@param renameReplacement  replacement for renamed indices_@param settings           repository specific restore settings_@param masterNodeTimeout  master node timeout_@param includeGlobalState include global state into restore_@param partial            allow partial restore_@param indexSettings      index settings that should be changed on restore_@param ignoreIndexSettings index settings that shouldn't be restored_@param cause              cause for restoring the snapshot;public RestoreRequest(String repositoryName, String snapshotName, String[] indices, IndicesOptions indicesOptions,_                              String renamePattern, String renameReplacement, Settings settings,_                              TimeValue masterNodeTimeout, boolean includeGlobalState, boolean partial, boolean includeAliases,_                              Settings indexSettings, String[] ignoreIndexSettings, String cause) {_            this.repositoryName = Objects.requireNonNull(repositoryName)__            this.snapshotName = Objects.requireNonNull(snapshotName)__            this.indices = indices__            this.renamePattern = renamePattern__            this.renameReplacement = renameReplacement__            this.indicesOptions = indicesOptions__            this.settings = settings__            this.masterNodeTimeout = masterNodeTimeout__            this.includeGlobalState = includeGlobalState__            this.partial = partial__            this.includeAliases = includeAliases__            this.indexSettings = indexSettings__            this.ignoreIndexSettings = ignoreIndexSettings__            this.cause = cause__        };constructs,new,restore,request,param,repository,name,repository,name,param,snapshot,name,snapshot,name,param,indices,list,of,indices,to,restore,param,indices,options,indices,options,param,rename,pattern,pattern,to,rename,indices,param,rename,replacement,replacement,for,renamed,indices,param,settings,repository,specific,restore,settings,param,master,node,timeout,master,node,timeout,param,include,global,state,include,global,state,into,restore,param,partial,allow,partial,restore,param,index,settings,index,settings,that,should,be,changed,on,restore,param,ignore,index,settings,index,settings,that,shouldn,t,be,restored,param,cause,cause,for,restoring,the,snapshot;public,restore,request,string,repository,name,string,snapshot,name,string,indices,indices,options,indices,options,string,rename,pattern,string,rename,replacement,settings,settings,time,value,master,node,timeout,boolean,include,global,state,boolean,partial,boolean,include,aliases,settings,index,settings,string,ignore,index,settings,string,cause,this,repository,name,objects,require,non,null,repository,name,this,snapshot,name,objects,require,non,null,snapshot,name,this,indices,indices,this,rename,pattern,rename,pattern,this,rename,replacement,rename,replacement,this,indices,options,indices,options,this,settings,settings,this,master,node,timeout,master,node,timeout,this,include,global,state,include,global,state,this,partial,partial,this,include,aliases,include,aliases,this,index,settings,index,settings,this,ignore,index,settings,ignore,index,settings,this,cause,cause
RestoreService -> RestoreInProgressUpdater -> private Updates changes(Snapshot snapshot);1524684173;Helper method that creates update entry for the given shard id if such an entry does not exist yet.;private Updates changes(Snapshot snapshot) {_            return shardChanges.computeIfAbsent(snapshot, k -> new Updates())__        };helper,method,that,creates,update,entry,for,the,given,shard,id,if,such,an,entry,does,not,exist,yet;private,updates,changes,snapshot,snapshot,return,shard,changes,compute,if,absent,snapshot,k,new,updates
RestoreService -> RestoreInProgressUpdater -> private Updates changes(Snapshot snapshot);1525248068;Helper method that creates update entry for the given shard id if such an entry does not exist yet.;private Updates changes(Snapshot snapshot) {_            return shardChanges.computeIfAbsent(snapshot, k -> new Updates())__        };helper,method,that,creates,update,entry,for,the,given,shard,id,if,such,an,entry,does,not,exist,yet;private,updates,changes,snapshot,snapshot,return,shard,changes,compute,if,absent,snapshot,k,new,updates
RestoreService -> RestoreInProgressUpdater -> private Updates changes(Snapshot snapshot);1535405719;Helper method that creates update entry for the given shard id if such an entry does not exist yet.;private Updates changes(Snapshot snapshot) {_            return shardChanges.computeIfAbsent(snapshot, k -> new Updates())__        };helper,method,that,creates,update,entry,for,the,given,shard,id,if,such,an,entry,does,not,exist,yet;private,updates,changes,snapshot,snapshot,return,shard,changes,compute,if,absent,snapshot,k,new,updates
RestoreService -> RestoreInProgressUpdater -> private Updates changes(Snapshot snapshot);1535723122;Helper method that creates update entry for the given shard id if such an entry does not exist yet.;private Updates changes(Snapshot snapshot) {_            return shardChanges.computeIfAbsent(snapshot, k -> new Updates())__        };helper,method,that,creates,update,entry,for,the,given,shard,id,if,such,an,entry,does,not,exist,yet;private,updates,changes,snapshot,snapshot,return,shard,changes,compute,if,absent,snapshot,k,new,updates
RestoreService -> RestoreInProgressUpdater -> private Updates changes(Snapshot snapshot);1536137328;Helper method that creates update entry for the given shard id if such an entry does not exist yet.;private Updates changes(Snapshot snapshot) {_            return shardChanges.computeIfAbsent(snapshot, k -> new Updates())__        };helper,method,that,creates,update,entry,for,the,given,shard,id,if,such,an,entry,does,not,exist,yet;private,updates,changes,snapshot,snapshot,return,shard,changes,compute,if,absent,snapshot,k,new,updates
RestoreService -> RestoreInProgressUpdater -> private Updates changes(Snapshot snapshot);1539723533;Helper method that creates update entry for the given shard id if such an entry does not exist yet.;private Updates changes(Snapshot snapshot) {_            return shardChanges.computeIfAbsent(snapshot, k -> new Updates())__        };helper,method,that,creates,update,entry,for,the,given,shard,id,if,such,an,entry,does,not,exist,yet;private,updates,changes,snapshot,snapshot,return,shard,changes,compute,if,absent,snapshot,k,new,updates
RestoreService -> RestoreInProgressUpdater -> private Updates changes(Snapshot snapshot);1540486836;Helper method that creates update entry for the given shard id if such an entry does not exist yet.;private Updates changes(Snapshot snapshot) {_            return shardChanges.computeIfAbsent(snapshot, k -> new Updates())__        };helper,method,that,creates,update,entry,for,the,given,shard,id,if,such,an,entry,does,not,exist,yet;private,updates,changes,snapshot,snapshot,return,shard,changes,compute,if,absent,snapshot,k,new,updates
RestoreService -> RestoreInProgressUpdater -> private Updates changes(Snapshot snapshot);1541092382;Helper method that creates update entry for the given shard id if such an entry does not exist yet.;private Updates changes(Snapshot snapshot) {_            return shardChanges.computeIfAbsent(snapshot, k -> new Updates())__        };helper,method,that,creates,update,entry,for,the,given,shard,id,if,such,an,entry,does,not,exist,yet;private,updates,changes,snapshot,snapshot,return,shard,changes,compute,if,absent,snapshot,k,new,updates
RestoreService -> RestoreInProgressUpdater -> private Updates changes(Snapshot snapshot);1542402632;Helper method that creates update entry for the given shard id if such an entry does not exist yet.;private Updates changes(Snapshot snapshot) {_            return shardChanges.computeIfAbsent(snapshot, k -> new Updates())__        };helper,method,that,creates,update,entry,for,the,given,shard,id,if,such,an,entry,does,not,exist,yet;private,updates,changes,snapshot,snapshot,return,shard,changes,compute,if,absent,snapshot,k,new,updates
RestoreService -> RestoreRequest -> public TimeValue masterNodeTimeout();1524684173;Return master node timeout__@return master node timeout;public TimeValue masterNodeTimeout() {_            return masterNodeTimeout__        };return,master,node,timeout,return,master,node,timeout;public,time,value,master,node,timeout,return,master,node,timeout
RestoreService -> RestoreRequest -> public TimeValue masterNodeTimeout();1525248068;Return master node timeout__@return master node timeout;public TimeValue masterNodeTimeout() {_            return masterNodeTimeout__        };return,master,node,timeout,return,master,node,timeout;public,time,value,master,node,timeout,return,master,node,timeout
RestoreService -> RestoreRequest -> public TimeValue masterNodeTimeout();1535405719;Return master node timeout__@return master node timeout;public TimeValue masterNodeTimeout() {_            return masterNodeTimeout__        };return,master,node,timeout,return,master,node,timeout;public,time,value,master,node,timeout,return,master,node,timeout
RestoreService -> RestoreRequest -> public TimeValue masterNodeTimeout();1535723122;Return master node timeout__@return master node timeout;public TimeValue masterNodeTimeout() {_            return masterNodeTimeout__        };return,master,node,timeout,return,master,node,timeout;public,time,value,master,node,timeout,return,master,node,timeout
RestoreService -> RestoreRequest -> public TimeValue masterNodeTimeout();1536137328;Return master node timeout__@return master node timeout;public TimeValue masterNodeTimeout() {_            return masterNodeTimeout__        };return,master,node,timeout,return,master,node,timeout;public,time,value,master,node,timeout,return,master,node,timeout
RestoreService -> RestoreRequest -> public TimeValue masterNodeTimeout();1539723533;Return master node timeout__@return master node timeout;public TimeValue masterNodeTimeout() {_            return masterNodeTimeout__        };return,master,node,timeout,return,master,node,timeout;public,time,value,master,node,timeout,return,master,node,timeout
RestoreService -> RestoreRequest -> public TimeValue masterNodeTimeout();1540486836;Return master node timeout__@return master node timeout;public TimeValue masterNodeTimeout() {_            return masterNodeTimeout__        };return,master,node,timeout,return,master,node,timeout;public,time,value,master,node,timeout,return,master,node,timeout
RestoreService -> RestoreRequest -> public TimeValue masterNodeTimeout();1541092382;Return master node timeout__@return master node timeout;public TimeValue masterNodeTimeout() {_            return masterNodeTimeout__        };return,master,node,timeout,return,master,node,timeout;public,time,value,master,node,timeout,return,master,node,timeout
RestoreService -> RestoreRequest -> public TimeValue masterNodeTimeout();1542402632;Return master node timeout__@return master node timeout;public TimeValue masterNodeTimeout() {_            return masterNodeTimeout__        };return,master,node,timeout,return,master,node,timeout;public,time,value,master,node,timeout,return,master,node,timeout
RestoreService -> RestoreRequest -> public TimeValue masterNodeTimeout();1544783963;Return master node timeout__@return master node timeout;public TimeValue masterNodeTimeout() {_            return masterNodeTimeout__        };return,master,node,timeout,return,master,node,timeout;public,time,value,master,node,timeout,return,master,node,timeout
RestoreService -> RestoreRequest -> public TimeValue masterNodeTimeout();1545215361;Return master node timeout__@return master node timeout;public TimeValue masterNodeTimeout() {_            return masterNodeTimeout__        };return,master,node,timeout,return,master,node,timeout;public,time,value,master,node,timeout,return,master,node,timeout
RestoreService -> public void restoreSnapshot(final RestoreSnapshotRequest request, final ActionListener<RestoreCompletionResponse> listener);1547760203;Restores snapshot specified in the restore request.__@param request  restore request_@param listener restore listener;public void restoreSnapshot(final RestoreSnapshotRequest request, final ActionListener<RestoreCompletionResponse> listener) {_        try {_            _            final String repositoryName = request.repository()__            Repository repository = repositoriesService.repository(repositoryName)__            final RepositoryData repositoryData = repository.getRepositoryData()__            final String snapshotName = request.snapshot()__            final Optional<SnapshotId> incompatibleSnapshotId =_                repositoryData.getIncompatibleSnapshotIds().stream().filter(s -> snapshotName.equals(s.getName())).findFirst()__            if (incompatibleSnapshotId.isPresent()) {_                throw new SnapshotRestoreException(repositoryName, snapshotName, "cannot restore incompatible snapshot")__            }_            final Optional<SnapshotId> matchingSnapshotId = repositoryData.getSnapshotIds().stream()_                .filter(s -> snapshotName.equals(s.getName())).findFirst()__            if (matchingSnapshotId.isPresent() == false) {_                throw new SnapshotRestoreException(repositoryName, snapshotName, "snapshot does not exist")__            }__            final SnapshotId snapshotId = matchingSnapshotId.get()__            final SnapshotInfo snapshotInfo = repository.getSnapshotInfo(snapshotId)__            final Snapshot snapshot = new Snapshot(repositoryName, snapshotId)___            _            validateSnapshotRestorable(repositoryName, snapshotInfo)___            _            final List<String> indicesInSnapshot = filterIndices(snapshotInfo.indices(), request.indices(), request.indicesOptions())___            final MetaData.Builder metaDataBuilder__            if (request.includeGlobalState()) {_                metaDataBuilder = MetaData.builder(repository.getSnapshotGlobalMetaData(snapshotId))__            } else {_                metaDataBuilder = MetaData.builder()__            }__            final List<IndexId> indexIdsInSnapshot = repositoryData.resolveIndices(indicesInSnapshot)__            for (IndexId indexId : indexIdsInSnapshot) {_                metaDataBuilder.put(repository.getSnapshotIndexMetaData(snapshotId, indexId), false)__            }__            final MetaData metaData = metaDataBuilder.build()___            _            _            final Map<String, String> indices = renamedIndices(request, indicesInSnapshot)___            _            _            clusterService.submitStateUpdateTask("restore_snapshot[" + snapshotName + ']', new ClusterStateUpdateTask() {_                String restoreUUID = UUIDs.randomBase64UUID()__                RestoreInfo restoreInfo = null___                @Override_                public ClusterState execute(ClusterState currentState) {_                    RestoreInProgress restoreInProgress = currentState.custom(RestoreInProgress.TYPE)__                    if (currentState.getNodes().getMinNodeVersion().before(Version.V_7_0_0)) {_                        _                        _                        if (restoreInProgress != null && restoreInProgress.isEmpty() == false) {_                            throw new ConcurrentSnapshotExecutionException(snapshot, "Restore process is already running in this cluster")__                        }_                    }_                    _                    SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                    if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                        throw new ConcurrentSnapshotExecutionException(snapshot,_                            "cannot restore a snapshot while a snapshot deletion is in-progress [" +_                                deletionsInProgress.getEntries().get(0).getSnapshot() + "]")__                    }__                    _                    ClusterState.Builder builder = ClusterState.builder(currentState)__                    MetaData.Builder mdBuilder = MetaData.builder(currentState.metaData())__                    ClusterBlocks.Builder blocks = ClusterBlocks.builder().blocks(currentState.blocks())__                    RoutingTable.Builder rtBuilder = RoutingTable.builder(currentState.routingTable())__                    ImmutableOpenMap<ShardId, RestoreInProgress.ShardRestoreStatus> shards__                    Set<String> aliases = new HashSet<>()___                    if (indices.isEmpty() == false) {_                        _                        ImmutableOpenMap.Builder<ShardId, RestoreInProgress.ShardRestoreStatus> shardsBuilder = ImmutableOpenMap.builder()__                        final Version minIndexCompatibilityVersion = currentState.getNodes().getMaxNodeVersion()_                            .minimumIndexCompatibilityVersion()__                        for (Map.Entry<String, String> indexEntry : indices.entrySet()) {_                            String index = indexEntry.getValue()__                            boolean partial = checkPartial(index)__                            SnapshotRecoverySource recoverySource =_                                new SnapshotRecoverySource(restoreUUID, snapshot, snapshotInfo.version(), index)__                            String renamedIndexName = indexEntry.getKey()__                            IndexMetaData snapshotIndexMetaData = metaData.index(index)__                            snapshotIndexMetaData = updateIndexSettings(snapshotIndexMetaData,_                                                                        request.indexSettings(), request.ignoreIndexSettings())__                            try {_                                snapshotIndexMetaData = metaDataIndexUpgradeService.upgradeIndexMetaData(snapshotIndexMetaData,_                                    minIndexCompatibilityVersion)__                            } catch (Exception ex) {_                                throw new SnapshotRestoreException(snapshot, "cannot restore index [" + index + "] because it cannot be " +_                                    "upgraded", ex)__                            }_                            _                            IndexMetaData currentIndexMetaData = currentState.metaData().index(renamedIndexName)__                            IntSet ignoreShards = new IntHashSet()__                            final Index renamedIndex__                            if (currentIndexMetaData == null) {_                                _                                _                                MetaDataCreateIndexService.validateIndexName(renamedIndexName, currentState)__                                createIndexService.validateIndexSettings(renamedIndexName,_                                                                        snapshotIndexMetaData.getSettings(),_                                                                        currentState,_                                                                        false)__                                IndexMetaData.Builder indexMdBuilder = IndexMetaData.builder(snapshotIndexMetaData)_                                                                                    .state(IndexMetaData.State.OPEN)_                                                                                    .index(renamedIndexName)__                                indexMdBuilder.settings(Settings.builder()_                                                                .put(snapshotIndexMetaData.getSettings())_                                                                .put(IndexMetaData.SETTING_INDEX_UUID, UUIDs.randomBase64UUID()))__                                if (!request.includeAliases() && !snapshotIndexMetaData.getAliases().isEmpty()) {_                                    _                                    indexMdBuilder.removeAllAliases()__                                } else {_                                    for (ObjectCursor<String> alias : snapshotIndexMetaData.getAliases().keys()) {_                                        aliases.add(alias.value)__                                    }_                                }_                                IndexMetaData updatedIndexMetaData = indexMdBuilder.build()__                                if (partial) {_                                    populateIgnoredShards(index, ignoreShards)__                                }_                                rtBuilder.addAsNewRestore(updatedIndexMetaData, recoverySource, ignoreShards)__                                blocks.addBlocks(updatedIndexMetaData)__                                mdBuilder.put(updatedIndexMetaData, true)__                                renamedIndex = updatedIndexMetaData.getIndex()__                            } else {_                                validateExistingIndex(currentIndexMetaData, snapshotIndexMetaData, renamedIndexName, partial)__                                _                                IndexMetaData.Builder indexMdBuilder = IndexMetaData.builder(snapshotIndexMetaData)_                                                                                    .state(IndexMetaData.State.OPEN)__                                indexMdBuilder.version(Math.max(snapshotIndexMetaData.getVersion(), currentIndexMetaData.getVersion() + 1))__                                indexMdBuilder.mappingVersion(Math.max(snapshotIndexMetaData.getMappingVersion(),_                                                                        currentIndexMetaData.getMappingVersion() + 1))__                                indexMdBuilder.settingsVersion(Math.max(snapshotIndexMetaData.getSettingsVersion(),_                                                                        currentIndexMetaData.getSettingsVersion() + 1))__                                if (!request.includeAliases()) {_                                    _                                    if (!snapshotIndexMetaData.getAliases().isEmpty()) {_                                        indexMdBuilder.removeAllAliases()__                                    }_                                    _                                    for (ObjectCursor<AliasMetaData> alias : currentIndexMetaData.getAliases().values()) {_                                        indexMdBuilder.putAlias(alias.value)__                                    }_                                } else {_                                    for (ObjectCursor<String> alias : snapshotIndexMetaData.getAliases().keys()) {_                                        aliases.add(alias.value)__                                    }_                                }_                                indexMdBuilder.settings(Settings.builder()_                                                                .put(snapshotIndexMetaData.getSettings())_                                                                .put(IndexMetaData.SETTING_INDEX_UUID,_                                                                    currentIndexMetaData.getIndexUUID()))__                                IndexMetaData updatedIndexMetaData = indexMdBuilder.index(renamedIndexName).build()__                                rtBuilder.addAsRestore(updatedIndexMetaData, recoverySource)__                                blocks.updateBlocks(updatedIndexMetaData)__                                mdBuilder.put(updatedIndexMetaData, true)__                                renamedIndex = updatedIndexMetaData.getIndex()__                            }__                            for (int shard = 0_ shard < snapshotIndexMetaData.getNumberOfShards()_ shard++) {_                                if (!ignoreShards.contains(shard)) {_                                    shardsBuilder.put(new ShardId(renamedIndex, shard),_                                            new RestoreInProgress.ShardRestoreStatus(clusterService.state().nodes().getLocalNodeId()))__                                } else {_                                    shardsBuilder.put(new ShardId(renamedIndex, shard),_                                            new RestoreInProgress.ShardRestoreStatus(clusterService.state().nodes().getLocalNodeId(),_                                                RestoreInProgress.State.FAILURE))__                                }_                            }_                        }__                        shards = shardsBuilder.build()__                        RestoreInProgress.Entry restoreEntry = new RestoreInProgress.Entry(_                            restoreUUID, snapshot, overallState(RestoreInProgress.State.INIT, shards),_                            Collections.unmodifiableList(new ArrayList<>(indices.keySet())),_                            shards_                        )__                        RestoreInProgress.Builder restoreInProgressBuilder__                        if (restoreInProgress != null) {_                            restoreInProgressBuilder = new RestoreInProgress.Builder(restoreInProgress)__                        } else {_                            restoreInProgressBuilder = new RestoreInProgress.Builder()__                        }_                        builder.putCustom(RestoreInProgress.TYPE, restoreInProgressBuilder.add(restoreEntry).build())__                    } else {_                        shards = ImmutableOpenMap.of()__                    }__                    checkAliasNameConflicts(indices, aliases)___                    _                    if (request.includeGlobalState()) {_                        if (metaData.persistentSettings() != null) {_                            Settings settings = metaData.persistentSettings()__                            clusterSettings.validateUpdate(settings)__                            mdBuilder.persistentSettings(settings)__                        }_                        if (metaData.templates() != null) {_                            _                            for (ObjectCursor<IndexTemplateMetaData> cursor : metaData.templates().values()) {_                                mdBuilder.put(cursor.value)__                            }_                        }_                        if (metaData.customs() != null) {_                            for (ObjectObjectCursor<String, MetaData.Custom> cursor : metaData.customs()) {_                                if (!RepositoriesMetaData.TYPE.equals(cursor.key)) {_                                    _                                    _                                    mdBuilder.putCustom(cursor.key, cursor.value)__                                }_                            }_                        }_                    }__                    if (completed(shards)) {_                        _                        restoreInfo = new RestoreInfo(snapshotId.getName(),_                                                      Collections.unmodifiableList(new ArrayList<>(indices.keySet())),_                                                      shards.size(),_                                                      shards.size() - failedShards(shards))__                    }__                    RoutingTable rt = rtBuilder.build()__                    ClusterState updatedState = builder.metaData(mdBuilder).blocks(blocks).routingTable(rt).build()__                    return allocationService.reroute(updatedState, "restored snapshot [" + snapshot + "]")__                }__                private void checkAliasNameConflicts(Map<String, String> renamedIndices, Set<String> aliases) {_                    for (Map.Entry<String, String> renamedIndex : renamedIndices.entrySet()) {_                        if (aliases.contains(renamedIndex.getKey())) {_                            throw new SnapshotRestoreException(snapshot,_                                "cannot rename index [" + renamedIndex.getValue() + "] into [" + renamedIndex.getKey() + "] because of " +_                                    "conflict with an alias with the same name")__                        }_                    }_                }__                private void populateIgnoredShards(String index, IntSet ignoreShards) {_                    for (SnapshotShardFailure failure : snapshotInfo.shardFailures()) {_                        if (index.equals(failure.index())) {_                            ignoreShards.add(failure.shardId())__                        }_                    }_                }__                private boolean checkPartial(String index) {_                    _                    if (failed(snapshotInfo, index)) {_                        if (request.partial()) {_                            return true__                        } else {_                            throw new SnapshotRestoreException(snapshot, "index [" + index + "] wasn't fully snapshotted - cannot " +_                                "restore")__                        }_                    } else {_                        return false__                    }_                }__                private void validateExistingIndex(IndexMetaData currentIndexMetaData, IndexMetaData snapshotIndexMetaData,_                                                   String renamedIndex, boolean partial) {_                    _                    if (currentIndexMetaData.getState() != IndexMetaData.State.CLOSE) {_                        _                        throw new SnapshotRestoreException(snapshot, "cannot restore index [" + renamedIndex + "] because an open index " +_                            "with same name already exists in the cluster. Either close or delete the existing index or restore the " +_                            "index under a different name by providing a rename pattern and replacement name")__                    }_                    _                    if (partial) {_                        throw new SnapshotRestoreException(snapshot, "cannot restore partial index [" + renamedIndex + "] because such " +_                            "index already exists")__                    }_                    _                    if (currentIndexMetaData.getNumberOfShards() != snapshotIndexMetaData.getNumberOfShards()) {_                        throw new SnapshotRestoreException(snapshot,_                            "cannot restore index [" + renamedIndex + "] with [" + currentIndexMetaData.getNumberOfShards() + "] shards " +_                                "from a snapshot of index [" + snapshotIndexMetaData.getIndex().getName() + "] with [" +_                                snapshotIndexMetaData.getNumberOfShards() + "] shards")__                    }_                }__                _                private IndexMetaData updateIndexSettings(IndexMetaData indexMetaData, Settings changeSettings, String[] ignoreSettings) {_                    if (changeSettings.names().isEmpty() && ignoreSettings.length == 0) {_                        return indexMetaData__                    }_                    Settings normalizedChangeSettings = Settings.builder()_                                                                .put(changeSettings)_                                                                .normalizePrefix(IndexMetaData.INDEX_SETTING_PREFIX)_                                                                .build()__                    IndexMetaData.Builder builder = IndexMetaData.builder(indexMetaData)__                    Settings settings = indexMetaData.getSettings()__                    Set<String> keyFilters = new HashSet<>()__                    List<String> simpleMatchPatterns = new ArrayList<>()__                    for (String ignoredSetting : ignoreSettings) {_                        if (!Regex.isSimpleMatchPattern(ignoredSetting)) {_                            if (UNREMOVABLE_SETTINGS.contains(ignoredSetting)) {_                                throw new SnapshotRestoreException(snapshot, "cannot remove setting [" + ignoredSetting + "] on restore")__                            } else {_                                keyFilters.add(ignoredSetting)__                            }_                        } else {_                            simpleMatchPatterns.add(ignoredSetting)__                        }_                    }_                    Predicate<String> settingsFilter = k -> {_                        if (UNREMOVABLE_SETTINGS.contains(k) == false) {_                            for (String filterKey : keyFilters) {_                                if (k.equals(filterKey)) {_                                    return false__                                }_                            }_                            for (String pattern : simpleMatchPatterns) {_                                if (Regex.simpleMatch(pattern, k)) {_                                    return false__                                }_                            }_                        }_                        return true__                    }__                    Settings.Builder settingsBuilder = Settings.builder()_                        .put(settings.filter(settingsFilter))_                        .put(normalizedChangeSettings.filter(k -> {_                            if (UNMODIFIABLE_SETTINGS.contains(k)) {_                                throw new SnapshotRestoreException(snapshot, "cannot modify setting [" + k + "] on restore")__                            } else {_                                return true__                            }_                        }))__                    return builder.settings(settingsBuilder).build()__                }__                @Override_                public void onFailure(String source, Exception e) {_                    logger.warn(() -> new ParameterizedMessage("[{}] failed to restore snapshot", snapshotId), e)__                    listener.onFailure(e)__                }__                @Override_                public TimeValue timeout() {_                    return request.masterNodeTimeout()__                }__                @Override_                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                    listener.onResponse(new RestoreCompletionResponse(restoreUUID, snapshot, restoreInfo))__                }_            })____        } catch (Exception e) {_            logger.warn(() -> new ParameterizedMessage("[{}] failed to restore snapshot",_                request.repository() + ":" + request.snapshot()), e)__            listener.onFailure(e)__        }_    };restores,snapshot,specified,in,the,restore,request,param,request,restore,request,param,listener,restore,listener;public,void,restore,snapshot,final,restore,snapshot,request,request,final,action,listener,restore,completion,response,listener,try,final,string,repository,name,request,repository,repository,repository,repositories,service,repository,repository,name,final,repository,data,repository,data,repository,get,repository,data,final,string,snapshot,name,request,snapshot,final,optional,snapshot,id,incompatible,snapshot,id,repository,data,get,incompatible,snapshot,ids,stream,filter,s,snapshot,name,equals,s,get,name,find,first,if,incompatible,snapshot,id,is,present,throw,new,snapshot,restore,exception,repository,name,snapshot,name,cannot,restore,incompatible,snapshot,final,optional,snapshot,id,matching,snapshot,id,repository,data,get,snapshot,ids,stream,filter,s,snapshot,name,equals,s,get,name,find,first,if,matching,snapshot,id,is,present,false,throw,new,snapshot,restore,exception,repository,name,snapshot,name,snapshot,does,not,exist,final,snapshot,id,snapshot,id,matching,snapshot,id,get,final,snapshot,info,snapshot,info,repository,get,snapshot,info,snapshot,id,final,snapshot,snapshot,new,snapshot,repository,name,snapshot,id,validate,snapshot,restorable,repository,name,snapshot,info,final,list,string,indices,in,snapshot,filter,indices,snapshot,info,indices,request,indices,request,indices,options,final,meta,data,builder,meta,data,builder,if,request,include,global,state,meta,data,builder,meta,data,builder,repository,get,snapshot,global,meta,data,snapshot,id,else,meta,data,builder,meta,data,builder,final,list,index,id,index,ids,in,snapshot,repository,data,resolve,indices,indices,in,snapshot,for,index,id,index,id,index,ids,in,snapshot,meta,data,builder,put,repository,get,snapshot,index,meta,data,snapshot,id,index,id,false,final,meta,data,meta,data,meta,data,builder,build,final,map,string,string,indices,renamed,indices,request,indices,in,snapshot,cluster,service,submit,state,update,task,snapshot,name,new,cluster,state,update,task,string,restore,uuid,uuids,random,base64uuid,restore,info,restore,info,null,override,public,cluster,state,execute,cluster,state,current,state,restore,in,progress,restore,in,progress,current,state,custom,restore,in,progress,type,if,current,state,get,nodes,get,min,node,version,before,version,if,restore,in,progress,null,restore,in,progress,is,empty,false,throw,new,concurrent,snapshot,execution,exception,snapshot,restore,process,is,already,running,in,this,cluster,snapshot,deletions,in,progress,deletions,in,progress,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,throw,new,concurrent,snapshot,execution,exception,snapshot,cannot,restore,a,snapshot,while,a,snapshot,deletion,is,in,progress,deletions,in,progress,get,entries,get,0,get,snapshot,cluster,state,builder,builder,cluster,state,builder,current,state,meta,data,builder,md,builder,meta,data,builder,current,state,meta,data,cluster,blocks,builder,blocks,cluster,blocks,builder,blocks,current,state,blocks,routing,table,builder,rt,builder,routing,table,builder,current,state,routing,table,immutable,open,map,shard,id,restore,in,progress,shard,restore,status,shards,set,string,aliases,new,hash,set,if,indices,is,empty,false,immutable,open,map,builder,shard,id,restore,in,progress,shard,restore,status,shards,builder,immutable,open,map,builder,final,version,min,index,compatibility,version,current,state,get,nodes,get,max,node,version,minimum,index,compatibility,version,for,map,entry,string,string,index,entry,indices,entry,set,string,index,index,entry,get,value,boolean,partial,check,partial,index,snapshot,recovery,source,recovery,source,new,snapshot,recovery,source,restore,uuid,snapshot,snapshot,info,version,index,string,renamed,index,name,index,entry,get,key,index,meta,data,snapshot,index,meta,data,meta,data,index,index,snapshot,index,meta,data,update,index,settings,snapshot,index,meta,data,request,index,settings,request,ignore,index,settings,try,snapshot,index,meta,data,meta,data,index,upgrade,service,upgrade,index,meta,data,snapshot,index,meta,data,min,index,compatibility,version,catch,exception,ex,throw,new,snapshot,restore,exception,snapshot,cannot,restore,index,index,because,it,cannot,be,upgraded,ex,index,meta,data,current,index,meta,data,current,state,meta,data,index,renamed,index,name,int,set,ignore,shards,new,int,hash,set,final,index,renamed,index,if,current,index,meta,data,null,meta,data,create,index,service,validate,index,name,renamed,index,name,current,state,create,index,service,validate,index,settings,renamed,index,name,snapshot,index,meta,data,get,settings,current,state,false,index,meta,data,builder,index,md,builder,index,meta,data,builder,snapshot,index,meta,data,state,index,meta,data,state,open,index,renamed,index,name,index,md,builder,settings,settings,builder,put,snapshot,index,meta,data,get,settings,put,index,meta,data,uuids,random,base64uuid,if,request,include,aliases,snapshot,index,meta,data,get,aliases,is,empty,index,md,builder,remove,all,aliases,else,for,object,cursor,string,alias,snapshot,index,meta,data,get,aliases,keys,aliases,add,alias,value,index,meta,data,updated,index,meta,data,index,md,builder,build,if,partial,populate,ignored,shards,index,ignore,shards,rt,builder,add,as,new,restore,updated,index,meta,data,recovery,source,ignore,shards,blocks,add,blocks,updated,index,meta,data,md,builder,put,updated,index,meta,data,true,renamed,index,updated,index,meta,data,get,index,else,validate,existing,index,current,index,meta,data,snapshot,index,meta,data,renamed,index,name,partial,index,meta,data,builder,index,md,builder,index,meta,data,builder,snapshot,index,meta,data,state,index,meta,data,state,open,index,md,builder,version,math,max,snapshot,index,meta,data,get,version,current,index,meta,data,get,version,1,index,md,builder,mapping,version,math,max,snapshot,index,meta,data,get,mapping,version,current,index,meta,data,get,mapping,version,1,index,md,builder,settings,version,math,max,snapshot,index,meta,data,get,settings,version,current,index,meta,data,get,settings,version,1,if,request,include,aliases,if,snapshot,index,meta,data,get,aliases,is,empty,index,md,builder,remove,all,aliases,for,object,cursor,alias,meta,data,alias,current,index,meta,data,get,aliases,values,index,md,builder,put,alias,alias,value,else,for,object,cursor,string,alias,snapshot,index,meta,data,get,aliases,keys,aliases,add,alias,value,index,md,builder,settings,settings,builder,put,snapshot,index,meta,data,get,settings,put,index,meta,data,current,index,meta,data,get,index,uuid,index,meta,data,updated,index,meta,data,index,md,builder,index,renamed,index,name,build,rt,builder,add,as,restore,updated,index,meta,data,recovery,source,blocks,update,blocks,updated,index,meta,data,md,builder,put,updated,index,meta,data,true,renamed,index,updated,index,meta,data,get,index,for,int,shard,0,shard,snapshot,index,meta,data,get,number,of,shards,shard,if,ignore,shards,contains,shard,shards,builder,put,new,shard,id,renamed,index,shard,new,restore,in,progress,shard,restore,status,cluster,service,state,nodes,get,local,node,id,else,shards,builder,put,new,shard,id,renamed,index,shard,new,restore,in,progress,shard,restore,status,cluster,service,state,nodes,get,local,node,id,restore,in,progress,state,failure,shards,shards,builder,build,restore,in,progress,entry,restore,entry,new,restore,in,progress,entry,restore,uuid,snapshot,overall,state,restore,in,progress,state,init,shards,collections,unmodifiable,list,new,array,list,indices,key,set,shards,restore,in,progress,builder,restore,in,progress,builder,if,restore,in,progress,null,restore,in,progress,builder,new,restore,in,progress,builder,restore,in,progress,else,restore,in,progress,builder,new,restore,in,progress,builder,builder,put,custom,restore,in,progress,type,restore,in,progress,builder,add,restore,entry,build,else,shards,immutable,open,map,of,check,alias,name,conflicts,indices,aliases,if,request,include,global,state,if,meta,data,persistent,settings,null,settings,settings,meta,data,persistent,settings,cluster,settings,validate,update,settings,md,builder,persistent,settings,settings,if,meta,data,templates,null,for,object,cursor,index,template,meta,data,cursor,meta,data,templates,values,md,builder,put,cursor,value,if,meta,data,customs,null,for,object,object,cursor,string,meta,data,custom,cursor,meta,data,customs,if,repositories,meta,data,type,equals,cursor,key,md,builder,put,custom,cursor,key,cursor,value,if,completed,shards,restore,info,new,restore,info,snapshot,id,get,name,collections,unmodifiable,list,new,array,list,indices,key,set,shards,size,shards,size,failed,shards,shards,routing,table,rt,rt,builder,build,cluster,state,updated,state,builder,meta,data,md,builder,blocks,blocks,routing,table,rt,build,return,allocation,service,reroute,updated,state,restored,snapshot,snapshot,private,void,check,alias,name,conflicts,map,string,string,renamed,indices,set,string,aliases,for,map,entry,string,string,renamed,index,renamed,indices,entry,set,if,aliases,contains,renamed,index,get,key,throw,new,snapshot,restore,exception,snapshot,cannot,rename,index,renamed,index,get,value,into,renamed,index,get,key,because,of,conflict,with,an,alias,with,the,same,name,private,void,populate,ignored,shards,string,index,int,set,ignore,shards,for,snapshot,shard,failure,failure,snapshot,info,shard,failures,if,index,equals,failure,index,ignore,shards,add,failure,shard,id,private,boolean,check,partial,string,index,if,failed,snapshot,info,index,if,request,partial,return,true,else,throw,new,snapshot,restore,exception,snapshot,index,index,wasn,t,fully,snapshotted,cannot,restore,else,return,false,private,void,validate,existing,index,index,meta,data,current,index,meta,data,index,meta,data,snapshot,index,meta,data,string,renamed,index,boolean,partial,if,current,index,meta,data,get,state,index,meta,data,state,close,throw,new,snapshot,restore,exception,snapshot,cannot,restore,index,renamed,index,because,an,open,index,with,same,name,already,exists,in,the,cluster,either,close,or,delete,the,existing,index,or,restore,the,index,under,a,different,name,by,providing,a,rename,pattern,and,replacement,name,if,partial,throw,new,snapshot,restore,exception,snapshot,cannot,restore,partial,index,renamed,index,because,such,index,already,exists,if,current,index,meta,data,get,number,of,shards,snapshot,index,meta,data,get,number,of,shards,throw,new,snapshot,restore,exception,snapshot,cannot,restore,index,renamed,index,with,current,index,meta,data,get,number,of,shards,shards,from,a,snapshot,of,index,snapshot,index,meta,data,get,index,get,name,with,snapshot,index,meta,data,get,number,of,shards,shards,private,index,meta,data,update,index,settings,index,meta,data,index,meta,data,settings,change,settings,string,ignore,settings,if,change,settings,names,is,empty,ignore,settings,length,0,return,index,meta,data,settings,normalized,change,settings,settings,builder,put,change,settings,normalize,prefix,index,meta,data,build,index,meta,data,builder,builder,index,meta,data,builder,index,meta,data,settings,settings,index,meta,data,get,settings,set,string,key,filters,new,hash,set,list,string,simple,match,patterns,new,array,list,for,string,ignored,setting,ignore,settings,if,regex,is,simple,match,pattern,ignored,setting,if,contains,ignored,setting,throw,new,snapshot,restore,exception,snapshot,cannot,remove,setting,ignored,setting,on,restore,else,key,filters,add,ignored,setting,else,simple,match,patterns,add,ignored,setting,predicate,string,settings,filter,k,if,contains,k,false,for,string,filter,key,key,filters,if,k,equals,filter,key,return,false,for,string,pattern,simple,match,patterns,if,regex,simple,match,pattern,k,return,false,return,true,settings,builder,settings,builder,settings,builder,put,settings,filter,settings,filter,put,normalized,change,settings,filter,k,if,contains,k,throw,new,snapshot,restore,exception,snapshot,cannot,modify,setting,k,on,restore,else,return,true,return,builder,settings,settings,builder,build,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,restore,snapshot,snapshot,id,e,listener,on,failure,e,override,public,time,value,timeout,return,request,master,node,timeout,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,listener,on,response,new,restore,completion,response,restore,uuid,snapshot,restore,info,catch,exception,e,logger,warn,new,parameterized,message,failed,to,restore,snapshot,request,repository,request,snapshot,e,listener,on,failure,e
RestoreService -> public void restoreSnapshot(final RestoreSnapshotRequest request, final ActionListener<RestoreCompletionResponse> listener);1549033151;Restores snapshot specified in the restore request.__@param request  restore request_@param listener restore listener;public void restoreSnapshot(final RestoreSnapshotRequest request, final ActionListener<RestoreCompletionResponse> listener) {_        try {_            _            final String repositoryName = request.repository()__            Repository repository = repositoriesService.repository(repositoryName)__            final RepositoryData repositoryData = repository.getRepositoryData()__            final String snapshotName = request.snapshot()__            final Optional<SnapshotId> incompatibleSnapshotId =_                repositoryData.getIncompatibleSnapshotIds().stream().filter(s -> snapshotName.equals(s.getName())).findFirst()__            if (incompatibleSnapshotId.isPresent()) {_                throw new SnapshotRestoreException(repositoryName, snapshotName, "cannot restore incompatible snapshot")__            }_            final Optional<SnapshotId> matchingSnapshotId = repositoryData.getSnapshotIds().stream()_                .filter(s -> snapshotName.equals(s.getName())).findFirst()__            if (matchingSnapshotId.isPresent() == false) {_                throw new SnapshotRestoreException(repositoryName, snapshotName, "snapshot does not exist")__            }__            final SnapshotId snapshotId = matchingSnapshotId.get()__            final SnapshotInfo snapshotInfo = repository.getSnapshotInfo(snapshotId)__            final Snapshot snapshot = new Snapshot(repositoryName, snapshotId)___            _            validateSnapshotRestorable(repositoryName, snapshotInfo)___            _            final List<String> indicesInSnapshot = filterIndices(snapshotInfo.indices(), request.indices(), request.indicesOptions())___            final MetaData.Builder metaDataBuilder__            if (request.includeGlobalState()) {_                metaDataBuilder = MetaData.builder(repository.getSnapshotGlobalMetaData(snapshotId))__            } else {_                metaDataBuilder = MetaData.builder()__            }__            final List<IndexId> indexIdsInSnapshot = repositoryData.resolveIndices(indicesInSnapshot)__            for (IndexId indexId : indexIdsInSnapshot) {_                metaDataBuilder.put(repository.getSnapshotIndexMetaData(snapshotId, indexId), false)__            }__            final MetaData metaData = metaDataBuilder.build()___            _            _            final Map<String, String> indices = renamedIndices(request, indicesInSnapshot)___            _            _            clusterService.submitStateUpdateTask("restore_snapshot[" + snapshotName + ']', new ClusterStateUpdateTask() {_                String restoreUUID = UUIDs.randomBase64UUID()__                RestoreInfo restoreInfo = null___                @Override_                public ClusterState execute(ClusterState currentState) {_                    RestoreInProgress restoreInProgress = currentState.custom(RestoreInProgress.TYPE)__                    if (currentState.getNodes().getMinNodeVersion().before(Version.V_7_0_0)) {_                        _                        _                        if (restoreInProgress != null && restoreInProgress.isEmpty() == false) {_                            throw new ConcurrentSnapshotExecutionException(snapshot, "Restore process is already running in this cluster")__                        }_                    }_                    _                    SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                    if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                        throw new ConcurrentSnapshotExecutionException(snapshot,_                            "cannot restore a snapshot while a snapshot deletion is in-progress [" +_                                deletionsInProgress.getEntries().get(0).getSnapshot() + "]")__                    }__                    _                    ClusterState.Builder builder = ClusterState.builder(currentState)__                    MetaData.Builder mdBuilder = MetaData.builder(currentState.metaData())__                    ClusterBlocks.Builder blocks = ClusterBlocks.builder().blocks(currentState.blocks())__                    RoutingTable.Builder rtBuilder = RoutingTable.builder(currentState.routingTable())__                    ImmutableOpenMap<ShardId, RestoreInProgress.ShardRestoreStatus> shards__                    Set<String> aliases = new HashSet<>()___                    if (indices.isEmpty() == false) {_                        _                        ImmutableOpenMap.Builder<ShardId, RestoreInProgress.ShardRestoreStatus> shardsBuilder = ImmutableOpenMap.builder()__                        final Version minIndexCompatibilityVersion = currentState.getNodes().getMaxNodeVersion()_                            .minimumIndexCompatibilityVersion()__                        for (Map.Entry<String, String> indexEntry : indices.entrySet()) {_                            String index = indexEntry.getValue()__                            boolean partial = checkPartial(index)__                            SnapshotRecoverySource recoverySource =_                                new SnapshotRecoverySource(restoreUUID, snapshot, snapshotInfo.version(), index)__                            String renamedIndexName = indexEntry.getKey()__                            IndexMetaData snapshotIndexMetaData = metaData.index(index)__                            snapshotIndexMetaData = updateIndexSettings(snapshotIndexMetaData,_                                                                        request.indexSettings(), request.ignoreIndexSettings())__                            try {_                                snapshotIndexMetaData = metaDataIndexUpgradeService.upgradeIndexMetaData(snapshotIndexMetaData,_                                    minIndexCompatibilityVersion)__                            } catch (Exception ex) {_                                throw new SnapshotRestoreException(snapshot, "cannot restore index [" + index + "] because it cannot be " +_                                    "upgraded", ex)__                            }_                            _                            IndexMetaData currentIndexMetaData = currentState.metaData().index(renamedIndexName)__                            IntSet ignoreShards = new IntHashSet()__                            final Index renamedIndex__                            if (currentIndexMetaData == null) {_                                _                                _                                MetaDataCreateIndexService.validateIndexName(renamedIndexName, currentState)__                                createIndexService.validateIndexSettings(renamedIndexName,_                                                                        snapshotIndexMetaData.getSettings(),_                                                                        currentState,_                                                                        false)__                                IndexMetaData.Builder indexMdBuilder = IndexMetaData.builder(snapshotIndexMetaData)_                                                                                    .state(IndexMetaData.State.OPEN)_                                                                                    .index(renamedIndexName)__                                indexMdBuilder.settings(Settings.builder()_                                                                .put(snapshotIndexMetaData.getSettings())_                                                                .put(IndexMetaData.SETTING_INDEX_UUID, UUIDs.randomBase64UUID()))__                                if (!request.includeAliases() && !snapshotIndexMetaData.getAliases().isEmpty()) {_                                    _                                    indexMdBuilder.removeAllAliases()__                                } else {_                                    for (ObjectCursor<String> alias : snapshotIndexMetaData.getAliases().keys()) {_                                        aliases.add(alias.value)__                                    }_                                }_                                IndexMetaData updatedIndexMetaData = indexMdBuilder.build()__                                if (partial) {_                                    populateIgnoredShards(index, ignoreShards)__                                }_                                rtBuilder.addAsNewRestore(updatedIndexMetaData, recoverySource, ignoreShards)__                                blocks.addBlocks(updatedIndexMetaData)__                                mdBuilder.put(updatedIndexMetaData, true)__                                renamedIndex = updatedIndexMetaData.getIndex()__                            } else {_                                validateExistingIndex(currentIndexMetaData, snapshotIndexMetaData, renamedIndexName, partial)__                                _                                IndexMetaData.Builder indexMdBuilder = IndexMetaData.builder(snapshotIndexMetaData)_                                                                                    .state(IndexMetaData.State.OPEN)__                                indexMdBuilder.version(Math.max(snapshotIndexMetaData.getVersion(), currentIndexMetaData.getVersion() + 1))__                                indexMdBuilder.mappingVersion(Math.max(snapshotIndexMetaData.getMappingVersion(),_                                                                        currentIndexMetaData.getMappingVersion() + 1))__                                indexMdBuilder.settingsVersion(Math.max(snapshotIndexMetaData.getSettingsVersion(),_                                                                        currentIndexMetaData.getSettingsVersion() + 1))___                                for (int shard = 0_ shard < snapshotIndexMetaData.getNumberOfShards()_ shard++) {_                                    indexMdBuilder.primaryTerm(shard,_                                        Math.max(snapshotIndexMetaData.primaryTerm(shard), currentIndexMetaData.primaryTerm(shard)))__                                }__                                if (!request.includeAliases()) {_                                    _                                    if (!snapshotIndexMetaData.getAliases().isEmpty()) {_                                        indexMdBuilder.removeAllAliases()__                                    }_                                    _                                    for (ObjectCursor<AliasMetaData> alias : currentIndexMetaData.getAliases().values()) {_                                        indexMdBuilder.putAlias(alias.value)__                                    }_                                } else {_                                    for (ObjectCursor<String> alias : snapshotIndexMetaData.getAliases().keys()) {_                                        aliases.add(alias.value)__                                    }_                                }_                                indexMdBuilder.settings(Settings.builder()_                                                                .put(snapshotIndexMetaData.getSettings())_                                                                .put(IndexMetaData.SETTING_INDEX_UUID,_                                                                    currentIndexMetaData.getIndexUUID()))__                                IndexMetaData updatedIndexMetaData = indexMdBuilder.index(renamedIndexName).build()__                                rtBuilder.addAsRestore(updatedIndexMetaData, recoverySource)__                                blocks.updateBlocks(updatedIndexMetaData)__                                mdBuilder.put(updatedIndexMetaData, true)__                                renamedIndex = updatedIndexMetaData.getIndex()__                            }__                            for (int shard = 0_ shard < snapshotIndexMetaData.getNumberOfShards()_ shard++) {_                                if (!ignoreShards.contains(shard)) {_                                    shardsBuilder.put(new ShardId(renamedIndex, shard),_                                            new RestoreInProgress.ShardRestoreStatus(clusterService.state().nodes().getLocalNodeId()))__                                } else {_                                    shardsBuilder.put(new ShardId(renamedIndex, shard),_                                            new RestoreInProgress.ShardRestoreStatus(clusterService.state().nodes().getLocalNodeId(),_                                                RestoreInProgress.State.FAILURE))__                                }_                            }_                        }__                        shards = shardsBuilder.build()__                        RestoreInProgress.Entry restoreEntry = new RestoreInProgress.Entry(_                            restoreUUID, snapshot, overallState(RestoreInProgress.State.INIT, shards),_                            Collections.unmodifiableList(new ArrayList<>(indices.keySet())),_                            shards_                        )__                        RestoreInProgress.Builder restoreInProgressBuilder__                        if (restoreInProgress != null) {_                            restoreInProgressBuilder = new RestoreInProgress.Builder(restoreInProgress)__                        } else {_                            restoreInProgressBuilder = new RestoreInProgress.Builder()__                        }_                        builder.putCustom(RestoreInProgress.TYPE, restoreInProgressBuilder.add(restoreEntry).build())__                    } else {_                        shards = ImmutableOpenMap.of()__                    }__                    checkAliasNameConflicts(indices, aliases)___                    _                    if (request.includeGlobalState()) {_                        if (metaData.persistentSettings() != null) {_                            Settings settings = metaData.persistentSettings()__                            clusterSettings.validateUpdate(settings)__                            mdBuilder.persistentSettings(settings)__                        }_                        if (metaData.templates() != null) {_                            _                            for (ObjectCursor<IndexTemplateMetaData> cursor : metaData.templates().values()) {_                                mdBuilder.put(cursor.value)__                            }_                        }_                        if (metaData.customs() != null) {_                            for (ObjectObjectCursor<String, MetaData.Custom> cursor : metaData.customs()) {_                                if (!RepositoriesMetaData.TYPE.equals(cursor.key)) {_                                    _                                    _                                    mdBuilder.putCustom(cursor.key, cursor.value)__                                }_                            }_                        }_                    }__                    if (completed(shards)) {_                        _                        restoreInfo = new RestoreInfo(snapshotId.getName(),_                                                      Collections.unmodifiableList(new ArrayList<>(indices.keySet())),_                                                      shards.size(),_                                                      shards.size() - failedShards(shards))__                    }__                    RoutingTable rt = rtBuilder.build()__                    ClusterState updatedState = builder.metaData(mdBuilder).blocks(blocks).routingTable(rt).build()__                    return allocationService.reroute(updatedState, "restored snapshot [" + snapshot + "]")__                }__                private void checkAliasNameConflicts(Map<String, String> renamedIndices, Set<String> aliases) {_                    for (Map.Entry<String, String> renamedIndex : renamedIndices.entrySet()) {_                        if (aliases.contains(renamedIndex.getKey())) {_                            throw new SnapshotRestoreException(snapshot,_                                "cannot rename index [" + renamedIndex.getValue() + "] into [" + renamedIndex.getKey() + "] because of " +_                                    "conflict with an alias with the same name")__                        }_                    }_                }__                private void populateIgnoredShards(String index, IntSet ignoreShards) {_                    for (SnapshotShardFailure failure : snapshotInfo.shardFailures()) {_                        if (index.equals(failure.index())) {_                            ignoreShards.add(failure.shardId())__                        }_                    }_                }__                private boolean checkPartial(String index) {_                    _                    if (failed(snapshotInfo, index)) {_                        if (request.partial()) {_                            return true__                        } else {_                            throw new SnapshotRestoreException(snapshot, "index [" + index + "] wasn't fully snapshotted - cannot " +_                                "restore")__                        }_                    } else {_                        return false__                    }_                }__                private void validateExistingIndex(IndexMetaData currentIndexMetaData, IndexMetaData snapshotIndexMetaData,_                                                   String renamedIndex, boolean partial) {_                    _                    if (currentIndexMetaData.getState() != IndexMetaData.State.CLOSE) {_                        _                        throw new SnapshotRestoreException(snapshot, "cannot restore index [" + renamedIndex + "] because an open index " +_                            "with same name already exists in the cluster. Either close or delete the existing index or restore the " +_                            "index under a different name by providing a rename pattern and replacement name")__                    }_                    _                    if (partial) {_                        throw new SnapshotRestoreException(snapshot, "cannot restore partial index [" + renamedIndex + "] because such " +_                            "index already exists")__                    }_                    _                    if (currentIndexMetaData.getNumberOfShards() != snapshotIndexMetaData.getNumberOfShards()) {_                        throw new SnapshotRestoreException(snapshot,_                            "cannot restore index [" + renamedIndex + "] with [" + currentIndexMetaData.getNumberOfShards() + "] shards " +_                                "from a snapshot of index [" + snapshotIndexMetaData.getIndex().getName() + "] with [" +_                                snapshotIndexMetaData.getNumberOfShards() + "] shards")__                    }_                }__                _                private IndexMetaData updateIndexSettings(IndexMetaData indexMetaData, Settings changeSettings, String[] ignoreSettings) {_                    if (changeSettings.names().isEmpty() && ignoreSettings.length == 0) {_                        return indexMetaData__                    }_                    Settings normalizedChangeSettings = Settings.builder()_                                                                .put(changeSettings)_                                                                .normalizePrefix(IndexMetaData.INDEX_SETTING_PREFIX)_                                                                .build()__                    IndexMetaData.Builder builder = IndexMetaData.builder(indexMetaData)__                    Settings settings = indexMetaData.getSettings()__                    Set<String> keyFilters = new HashSet<>()__                    List<String> simpleMatchPatterns = new ArrayList<>()__                    for (String ignoredSetting : ignoreSettings) {_                        if (!Regex.isSimpleMatchPattern(ignoredSetting)) {_                            if (UNREMOVABLE_SETTINGS.contains(ignoredSetting)) {_                                throw new SnapshotRestoreException(snapshot, "cannot remove setting [" + ignoredSetting + "] on restore")__                            } else {_                                keyFilters.add(ignoredSetting)__                            }_                        } else {_                            simpleMatchPatterns.add(ignoredSetting)__                        }_                    }_                    Predicate<String> settingsFilter = k -> {_                        if (UNREMOVABLE_SETTINGS.contains(k) == false) {_                            for (String filterKey : keyFilters) {_                                if (k.equals(filterKey)) {_                                    return false__                                }_                            }_                            for (String pattern : simpleMatchPatterns) {_                                if (Regex.simpleMatch(pattern, k)) {_                                    return false__                                }_                            }_                        }_                        return true__                    }__                    Settings.Builder settingsBuilder = Settings.builder()_                        .put(settings.filter(settingsFilter))_                        .put(normalizedChangeSettings.filter(k -> {_                            if (UNMODIFIABLE_SETTINGS.contains(k)) {_                                throw new SnapshotRestoreException(snapshot, "cannot modify setting [" + k + "] on restore")__                            } else {_                                return true__                            }_                        }))__                    return builder.settings(settingsBuilder).build()__                }__                @Override_                public void onFailure(String source, Exception e) {_                    logger.warn(() -> new ParameterizedMessage("[{}] failed to restore snapshot", snapshotId), e)__                    listener.onFailure(e)__                }__                @Override_                public TimeValue timeout() {_                    return request.masterNodeTimeout()__                }__                @Override_                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                    listener.onResponse(new RestoreCompletionResponse(restoreUUID, snapshot, restoreInfo))__                }_            })____        } catch (Exception e) {_            logger.warn(() -> new ParameterizedMessage("[{}] failed to restore snapshot",_                request.repository() + ":" + request.snapshot()), e)__            listener.onFailure(e)__        }_    };restores,snapshot,specified,in,the,restore,request,param,request,restore,request,param,listener,restore,listener;public,void,restore,snapshot,final,restore,snapshot,request,request,final,action,listener,restore,completion,response,listener,try,final,string,repository,name,request,repository,repository,repository,repositories,service,repository,repository,name,final,repository,data,repository,data,repository,get,repository,data,final,string,snapshot,name,request,snapshot,final,optional,snapshot,id,incompatible,snapshot,id,repository,data,get,incompatible,snapshot,ids,stream,filter,s,snapshot,name,equals,s,get,name,find,first,if,incompatible,snapshot,id,is,present,throw,new,snapshot,restore,exception,repository,name,snapshot,name,cannot,restore,incompatible,snapshot,final,optional,snapshot,id,matching,snapshot,id,repository,data,get,snapshot,ids,stream,filter,s,snapshot,name,equals,s,get,name,find,first,if,matching,snapshot,id,is,present,false,throw,new,snapshot,restore,exception,repository,name,snapshot,name,snapshot,does,not,exist,final,snapshot,id,snapshot,id,matching,snapshot,id,get,final,snapshot,info,snapshot,info,repository,get,snapshot,info,snapshot,id,final,snapshot,snapshot,new,snapshot,repository,name,snapshot,id,validate,snapshot,restorable,repository,name,snapshot,info,final,list,string,indices,in,snapshot,filter,indices,snapshot,info,indices,request,indices,request,indices,options,final,meta,data,builder,meta,data,builder,if,request,include,global,state,meta,data,builder,meta,data,builder,repository,get,snapshot,global,meta,data,snapshot,id,else,meta,data,builder,meta,data,builder,final,list,index,id,index,ids,in,snapshot,repository,data,resolve,indices,indices,in,snapshot,for,index,id,index,id,index,ids,in,snapshot,meta,data,builder,put,repository,get,snapshot,index,meta,data,snapshot,id,index,id,false,final,meta,data,meta,data,meta,data,builder,build,final,map,string,string,indices,renamed,indices,request,indices,in,snapshot,cluster,service,submit,state,update,task,snapshot,name,new,cluster,state,update,task,string,restore,uuid,uuids,random,base64uuid,restore,info,restore,info,null,override,public,cluster,state,execute,cluster,state,current,state,restore,in,progress,restore,in,progress,current,state,custom,restore,in,progress,type,if,current,state,get,nodes,get,min,node,version,before,version,if,restore,in,progress,null,restore,in,progress,is,empty,false,throw,new,concurrent,snapshot,execution,exception,snapshot,restore,process,is,already,running,in,this,cluster,snapshot,deletions,in,progress,deletions,in,progress,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,throw,new,concurrent,snapshot,execution,exception,snapshot,cannot,restore,a,snapshot,while,a,snapshot,deletion,is,in,progress,deletions,in,progress,get,entries,get,0,get,snapshot,cluster,state,builder,builder,cluster,state,builder,current,state,meta,data,builder,md,builder,meta,data,builder,current,state,meta,data,cluster,blocks,builder,blocks,cluster,blocks,builder,blocks,current,state,blocks,routing,table,builder,rt,builder,routing,table,builder,current,state,routing,table,immutable,open,map,shard,id,restore,in,progress,shard,restore,status,shards,set,string,aliases,new,hash,set,if,indices,is,empty,false,immutable,open,map,builder,shard,id,restore,in,progress,shard,restore,status,shards,builder,immutable,open,map,builder,final,version,min,index,compatibility,version,current,state,get,nodes,get,max,node,version,minimum,index,compatibility,version,for,map,entry,string,string,index,entry,indices,entry,set,string,index,index,entry,get,value,boolean,partial,check,partial,index,snapshot,recovery,source,recovery,source,new,snapshot,recovery,source,restore,uuid,snapshot,snapshot,info,version,index,string,renamed,index,name,index,entry,get,key,index,meta,data,snapshot,index,meta,data,meta,data,index,index,snapshot,index,meta,data,update,index,settings,snapshot,index,meta,data,request,index,settings,request,ignore,index,settings,try,snapshot,index,meta,data,meta,data,index,upgrade,service,upgrade,index,meta,data,snapshot,index,meta,data,min,index,compatibility,version,catch,exception,ex,throw,new,snapshot,restore,exception,snapshot,cannot,restore,index,index,because,it,cannot,be,upgraded,ex,index,meta,data,current,index,meta,data,current,state,meta,data,index,renamed,index,name,int,set,ignore,shards,new,int,hash,set,final,index,renamed,index,if,current,index,meta,data,null,meta,data,create,index,service,validate,index,name,renamed,index,name,current,state,create,index,service,validate,index,settings,renamed,index,name,snapshot,index,meta,data,get,settings,current,state,false,index,meta,data,builder,index,md,builder,index,meta,data,builder,snapshot,index,meta,data,state,index,meta,data,state,open,index,renamed,index,name,index,md,builder,settings,settings,builder,put,snapshot,index,meta,data,get,settings,put,index,meta,data,uuids,random,base64uuid,if,request,include,aliases,snapshot,index,meta,data,get,aliases,is,empty,index,md,builder,remove,all,aliases,else,for,object,cursor,string,alias,snapshot,index,meta,data,get,aliases,keys,aliases,add,alias,value,index,meta,data,updated,index,meta,data,index,md,builder,build,if,partial,populate,ignored,shards,index,ignore,shards,rt,builder,add,as,new,restore,updated,index,meta,data,recovery,source,ignore,shards,blocks,add,blocks,updated,index,meta,data,md,builder,put,updated,index,meta,data,true,renamed,index,updated,index,meta,data,get,index,else,validate,existing,index,current,index,meta,data,snapshot,index,meta,data,renamed,index,name,partial,index,meta,data,builder,index,md,builder,index,meta,data,builder,snapshot,index,meta,data,state,index,meta,data,state,open,index,md,builder,version,math,max,snapshot,index,meta,data,get,version,current,index,meta,data,get,version,1,index,md,builder,mapping,version,math,max,snapshot,index,meta,data,get,mapping,version,current,index,meta,data,get,mapping,version,1,index,md,builder,settings,version,math,max,snapshot,index,meta,data,get,settings,version,current,index,meta,data,get,settings,version,1,for,int,shard,0,shard,snapshot,index,meta,data,get,number,of,shards,shard,index,md,builder,primary,term,shard,math,max,snapshot,index,meta,data,primary,term,shard,current,index,meta,data,primary,term,shard,if,request,include,aliases,if,snapshot,index,meta,data,get,aliases,is,empty,index,md,builder,remove,all,aliases,for,object,cursor,alias,meta,data,alias,current,index,meta,data,get,aliases,values,index,md,builder,put,alias,alias,value,else,for,object,cursor,string,alias,snapshot,index,meta,data,get,aliases,keys,aliases,add,alias,value,index,md,builder,settings,settings,builder,put,snapshot,index,meta,data,get,settings,put,index,meta,data,current,index,meta,data,get,index,uuid,index,meta,data,updated,index,meta,data,index,md,builder,index,renamed,index,name,build,rt,builder,add,as,restore,updated,index,meta,data,recovery,source,blocks,update,blocks,updated,index,meta,data,md,builder,put,updated,index,meta,data,true,renamed,index,updated,index,meta,data,get,index,for,int,shard,0,shard,snapshot,index,meta,data,get,number,of,shards,shard,if,ignore,shards,contains,shard,shards,builder,put,new,shard,id,renamed,index,shard,new,restore,in,progress,shard,restore,status,cluster,service,state,nodes,get,local,node,id,else,shards,builder,put,new,shard,id,renamed,index,shard,new,restore,in,progress,shard,restore,status,cluster,service,state,nodes,get,local,node,id,restore,in,progress,state,failure,shards,shards,builder,build,restore,in,progress,entry,restore,entry,new,restore,in,progress,entry,restore,uuid,snapshot,overall,state,restore,in,progress,state,init,shards,collections,unmodifiable,list,new,array,list,indices,key,set,shards,restore,in,progress,builder,restore,in,progress,builder,if,restore,in,progress,null,restore,in,progress,builder,new,restore,in,progress,builder,restore,in,progress,else,restore,in,progress,builder,new,restore,in,progress,builder,builder,put,custom,restore,in,progress,type,restore,in,progress,builder,add,restore,entry,build,else,shards,immutable,open,map,of,check,alias,name,conflicts,indices,aliases,if,request,include,global,state,if,meta,data,persistent,settings,null,settings,settings,meta,data,persistent,settings,cluster,settings,validate,update,settings,md,builder,persistent,settings,settings,if,meta,data,templates,null,for,object,cursor,index,template,meta,data,cursor,meta,data,templates,values,md,builder,put,cursor,value,if,meta,data,customs,null,for,object,object,cursor,string,meta,data,custom,cursor,meta,data,customs,if,repositories,meta,data,type,equals,cursor,key,md,builder,put,custom,cursor,key,cursor,value,if,completed,shards,restore,info,new,restore,info,snapshot,id,get,name,collections,unmodifiable,list,new,array,list,indices,key,set,shards,size,shards,size,failed,shards,shards,routing,table,rt,rt,builder,build,cluster,state,updated,state,builder,meta,data,md,builder,blocks,blocks,routing,table,rt,build,return,allocation,service,reroute,updated,state,restored,snapshot,snapshot,private,void,check,alias,name,conflicts,map,string,string,renamed,indices,set,string,aliases,for,map,entry,string,string,renamed,index,renamed,indices,entry,set,if,aliases,contains,renamed,index,get,key,throw,new,snapshot,restore,exception,snapshot,cannot,rename,index,renamed,index,get,value,into,renamed,index,get,key,because,of,conflict,with,an,alias,with,the,same,name,private,void,populate,ignored,shards,string,index,int,set,ignore,shards,for,snapshot,shard,failure,failure,snapshot,info,shard,failures,if,index,equals,failure,index,ignore,shards,add,failure,shard,id,private,boolean,check,partial,string,index,if,failed,snapshot,info,index,if,request,partial,return,true,else,throw,new,snapshot,restore,exception,snapshot,index,index,wasn,t,fully,snapshotted,cannot,restore,else,return,false,private,void,validate,existing,index,index,meta,data,current,index,meta,data,index,meta,data,snapshot,index,meta,data,string,renamed,index,boolean,partial,if,current,index,meta,data,get,state,index,meta,data,state,close,throw,new,snapshot,restore,exception,snapshot,cannot,restore,index,renamed,index,because,an,open,index,with,same,name,already,exists,in,the,cluster,either,close,or,delete,the,existing,index,or,restore,the,index,under,a,different,name,by,providing,a,rename,pattern,and,replacement,name,if,partial,throw,new,snapshot,restore,exception,snapshot,cannot,restore,partial,index,renamed,index,because,such,index,already,exists,if,current,index,meta,data,get,number,of,shards,snapshot,index,meta,data,get,number,of,shards,throw,new,snapshot,restore,exception,snapshot,cannot,restore,index,renamed,index,with,current,index,meta,data,get,number,of,shards,shards,from,a,snapshot,of,index,snapshot,index,meta,data,get,index,get,name,with,snapshot,index,meta,data,get,number,of,shards,shards,private,index,meta,data,update,index,settings,index,meta,data,index,meta,data,settings,change,settings,string,ignore,settings,if,change,settings,names,is,empty,ignore,settings,length,0,return,index,meta,data,settings,normalized,change,settings,settings,builder,put,change,settings,normalize,prefix,index,meta,data,build,index,meta,data,builder,builder,index,meta,data,builder,index,meta,data,settings,settings,index,meta,data,get,settings,set,string,key,filters,new,hash,set,list,string,simple,match,patterns,new,array,list,for,string,ignored,setting,ignore,settings,if,regex,is,simple,match,pattern,ignored,setting,if,contains,ignored,setting,throw,new,snapshot,restore,exception,snapshot,cannot,remove,setting,ignored,setting,on,restore,else,key,filters,add,ignored,setting,else,simple,match,patterns,add,ignored,setting,predicate,string,settings,filter,k,if,contains,k,false,for,string,filter,key,key,filters,if,k,equals,filter,key,return,false,for,string,pattern,simple,match,patterns,if,regex,simple,match,pattern,k,return,false,return,true,settings,builder,settings,builder,settings,builder,put,settings,filter,settings,filter,put,normalized,change,settings,filter,k,if,contains,k,throw,new,snapshot,restore,exception,snapshot,cannot,modify,setting,k,on,restore,else,return,true,return,builder,settings,settings,builder,build,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,restore,snapshot,snapshot,id,e,listener,on,failure,e,override,public,time,value,timeout,return,request,master,node,timeout,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,listener,on,response,new,restore,completion,response,restore,uuid,snapshot,restore,info,catch,exception,e,logger,warn,new,parameterized,message,failed,to,restore,snapshot,request,repository,request,snapshot,e,listener,on,failure,e
RestoreService -> RestoreInProgressUpdater -> private Updates changes(RecoverySource recoverySource);1544783963;Helper method that creates update entry for the given recovery source's restore uuid_if such an entry does not exist yet.;private Updates changes(RecoverySource recoverySource) {_            assert recoverySource.getType() == RecoverySource.Type.SNAPSHOT__            return shardChanges.computeIfAbsent(((SnapshotRecoverySource) recoverySource).restoreUUID(), k -> new Updates())__        };helper,method,that,creates,update,entry,for,the,given,recovery,source,s,restore,uuid,if,such,an,entry,does,not,exist,yet;private,updates,changes,recovery,source,recovery,source,assert,recovery,source,get,type,recovery,source,type,snapshot,return,shard,changes,compute,if,absent,snapshot,recovery,source,recovery,source,restore,uuid,k,new,updates
RestoreService -> RestoreInProgressUpdater -> private Updates changes(RecoverySource recoverySource);1545215361;Helper method that creates update entry for the given recovery source's restore uuid_if such an entry does not exist yet.;private Updates changes(RecoverySource recoverySource) {_            assert recoverySource.getType() == RecoverySource.Type.SNAPSHOT__            return shardChanges.computeIfAbsent(((SnapshotRecoverySource) recoverySource).restoreUUID(), k -> new Updates())__        };helper,method,that,creates,update,entry,for,the,given,recovery,source,s,restore,uuid,if,such,an,entry,does,not,exist,yet;private,updates,changes,recovery,source,recovery,source,assert,recovery,source,get,type,recovery,source,type,snapshot,return,shard,changes,compute,if,absent,snapshot,recovery,source,recovery,source,restore,uuid,k,new,updates
RestoreService -> RestoreInProgressUpdater -> private Updates changes(RecoverySource recoverySource);1547760203;Helper method that creates update entry for the given recovery source's restore uuid_if such an entry does not exist yet.;private Updates changes(RecoverySource recoverySource) {_            assert recoverySource.getType() == RecoverySource.Type.SNAPSHOT__            return shardChanges.computeIfAbsent(((SnapshotRecoverySource) recoverySource).restoreUUID(), k -> new Updates())__        };helper,method,that,creates,update,entry,for,the,given,recovery,source,s,restore,uuid,if,such,an,entry,does,not,exist,yet;private,updates,changes,recovery,source,recovery,source,assert,recovery,source,get,type,recovery,source,type,snapshot,return,shard,changes,compute,if,absent,snapshot,recovery,source,recovery,source,restore,uuid,k,new,updates
RestoreService -> RestoreInProgressUpdater -> private Updates changes(RecoverySource recoverySource);1549033151;Helper method that creates update entry for the given recovery source's restore uuid_if such an entry does not exist yet.;private Updates changes(RecoverySource recoverySource) {_            assert recoverySource.getType() == RecoverySource.Type.SNAPSHOT__            return shardChanges.computeIfAbsent(((SnapshotRecoverySource) recoverySource).restoreUUID(), k -> new Updates())__        };helper,method,that,creates,update,entry,for,the,given,recovery,source,s,restore,uuid,if,such,an,entry,does,not,exist,yet;private,updates,changes,recovery,source,recovery,source,assert,recovery,source,get,type,recovery,source,type,snapshot,return,shard,changes,compute,if,absent,snapshot,recovery,source,recovery,source,restore,uuid,k,new,updates
RestoreService -> public void restoreSnapshot(final RestoreSnapshotRequest request, final ActionListener<RestoreCompletionResponse> listener) -> null -> private IndexMetaData updateIndexSettings(IndexMetaData indexMetaData, Settings changeSettings, String[] ignoreSettings);1547760203;Optionally updates index settings in indexMetaData by removing settings listed in ignoreSettings and_merging them with settings in changeSettings.;private IndexMetaData updateIndexSettings(IndexMetaData indexMetaData, Settings changeSettings, String[] ignoreSettings) {_                    if (changeSettings.names().isEmpty() && ignoreSettings.length == 0) {_                        return indexMetaData__                    }_                    Settings normalizedChangeSettings = Settings.builder()_                                                                .put(changeSettings)_                                                                .normalizePrefix(IndexMetaData.INDEX_SETTING_PREFIX)_                                                                .build()__                    IndexMetaData.Builder builder = IndexMetaData.builder(indexMetaData)__                    Settings settings = indexMetaData.getSettings()__                    Set<String> keyFilters = new HashSet<>()__                    List<String> simpleMatchPatterns = new ArrayList<>()__                    for (String ignoredSetting : ignoreSettings) {_                        if (!Regex.isSimpleMatchPattern(ignoredSetting)) {_                            if (UNREMOVABLE_SETTINGS.contains(ignoredSetting)) {_                                throw new SnapshotRestoreException(snapshot, "cannot remove setting [" + ignoredSetting + "] on restore")__                            } else {_                                keyFilters.add(ignoredSetting)__                            }_                        } else {_                            simpleMatchPatterns.add(ignoredSetting)__                        }_                    }_                    Predicate<String> settingsFilter = k -> {_                        if (UNREMOVABLE_SETTINGS.contains(k) == false) {_                            for (String filterKey : keyFilters) {_                                if (k.equals(filterKey)) {_                                    return false__                                }_                            }_                            for (String pattern : simpleMatchPatterns) {_                                if (Regex.simpleMatch(pattern, k)) {_                                    return false__                                }_                            }_                        }_                        return true__                    }__                    Settings.Builder settingsBuilder = Settings.builder()_                        .put(settings.filter(settingsFilter))_                        .put(normalizedChangeSettings.filter(k -> {_                            if (UNMODIFIABLE_SETTINGS.contains(k)) {_                                throw new SnapshotRestoreException(snapshot, "cannot modify setting [" + k + "] on restore")__                            } else {_                                return true__                            }_                        }))__                    return builder.settings(settingsBuilder).build()__                };optionally,updates,index,settings,in,index,meta,data,by,removing,settings,listed,in,ignore,settings,and,merging,them,with,settings,in,change,settings;private,index,meta,data,update,index,settings,index,meta,data,index,meta,data,settings,change,settings,string,ignore,settings,if,change,settings,names,is,empty,ignore,settings,length,0,return,index,meta,data,settings,normalized,change,settings,settings,builder,put,change,settings,normalize,prefix,index,meta,data,build,index,meta,data,builder,builder,index,meta,data,builder,index,meta,data,settings,settings,index,meta,data,get,settings,set,string,key,filters,new,hash,set,list,string,simple,match,patterns,new,array,list,for,string,ignored,setting,ignore,settings,if,regex,is,simple,match,pattern,ignored,setting,if,contains,ignored,setting,throw,new,snapshot,restore,exception,snapshot,cannot,remove,setting,ignored,setting,on,restore,else,key,filters,add,ignored,setting,else,simple,match,patterns,add,ignored,setting,predicate,string,settings,filter,k,if,contains,k,false,for,string,filter,key,key,filters,if,k,equals,filter,key,return,false,for,string,pattern,simple,match,patterns,if,regex,simple,match,pattern,k,return,false,return,true,settings,builder,settings,builder,settings,builder,put,settings,filter,settings,filter,put,normalized,change,settings,filter,k,if,contains,k,throw,new,snapshot,restore,exception,snapshot,cannot,modify,setting,k,on,restore,else,return,true,return,builder,settings,settings,builder,build
RestoreService -> public void restoreSnapshot(final RestoreSnapshotRequest request, final ActionListener<RestoreCompletionResponse> listener) -> null -> private IndexMetaData updateIndexSettings(IndexMetaData indexMetaData, Settings changeSettings, String[] ignoreSettings);1549033151;Optionally updates index settings in indexMetaData by removing settings listed in ignoreSettings and_merging them with settings in changeSettings.;private IndexMetaData updateIndexSettings(IndexMetaData indexMetaData, Settings changeSettings, String[] ignoreSettings) {_                    if (changeSettings.names().isEmpty() && ignoreSettings.length == 0) {_                        return indexMetaData__                    }_                    Settings normalizedChangeSettings = Settings.builder()_                                                                .put(changeSettings)_                                                                .normalizePrefix(IndexMetaData.INDEX_SETTING_PREFIX)_                                                                .build()__                    IndexMetaData.Builder builder = IndexMetaData.builder(indexMetaData)__                    Settings settings = indexMetaData.getSettings()__                    Set<String> keyFilters = new HashSet<>()__                    List<String> simpleMatchPatterns = new ArrayList<>()__                    for (String ignoredSetting : ignoreSettings) {_                        if (!Regex.isSimpleMatchPattern(ignoredSetting)) {_                            if (UNREMOVABLE_SETTINGS.contains(ignoredSetting)) {_                                throw new SnapshotRestoreException(snapshot, "cannot remove setting [" + ignoredSetting + "] on restore")__                            } else {_                                keyFilters.add(ignoredSetting)__                            }_                        } else {_                            simpleMatchPatterns.add(ignoredSetting)__                        }_                    }_                    Predicate<String> settingsFilter = k -> {_                        if (UNREMOVABLE_SETTINGS.contains(k) == false) {_                            for (String filterKey : keyFilters) {_                                if (k.equals(filterKey)) {_                                    return false__                                }_                            }_                            for (String pattern : simpleMatchPatterns) {_                                if (Regex.simpleMatch(pattern, k)) {_                                    return false__                                }_                            }_                        }_                        return true__                    }__                    Settings.Builder settingsBuilder = Settings.builder()_                        .put(settings.filter(settingsFilter))_                        .put(normalizedChangeSettings.filter(k -> {_                            if (UNMODIFIABLE_SETTINGS.contains(k)) {_                                throw new SnapshotRestoreException(snapshot, "cannot modify setting [" + k + "] on restore")__                            } else {_                                return true__                            }_                        }))__                    return builder.settings(settingsBuilder).build()__                };optionally,updates,index,settings,in,index,meta,data,by,removing,settings,listed,in,ignore,settings,and,merging,them,with,settings,in,change,settings;private,index,meta,data,update,index,settings,index,meta,data,index,meta,data,settings,change,settings,string,ignore,settings,if,change,settings,names,is,empty,ignore,settings,length,0,return,index,meta,data,settings,normalized,change,settings,settings,builder,put,change,settings,normalize,prefix,index,meta,data,build,index,meta,data,builder,builder,index,meta,data,builder,index,meta,data,settings,settings,index,meta,data,get,settings,set,string,key,filters,new,hash,set,list,string,simple,match,patterns,new,array,list,for,string,ignored,setting,ignore,settings,if,regex,is,simple,match,pattern,ignored,setting,if,contains,ignored,setting,throw,new,snapshot,restore,exception,snapshot,cannot,remove,setting,ignored,setting,on,restore,else,key,filters,add,ignored,setting,else,simple,match,patterns,add,ignored,setting,predicate,string,settings,filter,k,if,contains,k,false,for,string,filter,key,key,filters,if,k,equals,filter,key,return,false,for,string,pattern,simple,match,patterns,if,regex,simple,match,pattern,k,return,false,return,true,settings,builder,settings,builder,settings,builder,put,settings,filter,settings,filter,put,normalized,change,settings,filter,k,if,contains,k,throw,new,snapshot,restore,exception,snapshot,cannot,modify,setting,k,on,restore,else,return,true,return,builder,settings,settings,builder,build
RestoreService -> public void restoreSnapshot(final RestoreRequest request, final ActionListener<RestoreCompletionResponse> listener);1524684173;Restores snapshot specified in the restore request.__@param request  restore request_@param listener restore listener;public void restoreSnapshot(final RestoreRequest request, final ActionListener<RestoreCompletionResponse> listener) {_        try {_            _            Repository repository = repositoriesService.repository(request.repositoryName)__            final RepositoryData repositoryData = repository.getRepositoryData()__            final Optional<SnapshotId> incompatibleSnapshotId =_                repositoryData.getIncompatibleSnapshotIds().stream().filter(s -> request.snapshotName.equals(s.getName())).findFirst()__            if (incompatibleSnapshotId.isPresent()) {_                throw new SnapshotRestoreException(request.repositoryName, request.snapshotName, "cannot restore incompatible snapshot")__            }_            final Optional<SnapshotId> matchingSnapshotId = repositoryData.getSnapshotIds().stream()_                .filter(s -> request.snapshotName.equals(s.getName())).findFirst()__            if (matchingSnapshotId.isPresent() == false) {_                throw new SnapshotRestoreException(request.repositoryName, request.snapshotName, "snapshot does not exist")__            }__            final SnapshotId snapshotId = matchingSnapshotId.get()__            final SnapshotInfo snapshotInfo = repository.getSnapshotInfo(snapshotId)__            final Snapshot snapshot = new Snapshot(request.repositoryName, snapshotId)___            _            validateSnapshotRestorable(request.repositoryName, snapshotInfo)___            _            final List<String> indicesInSnapshot = filterIndices(snapshotInfo.indices(), request.indices(), request.indicesOptions())___            final MetaData.Builder metaDataBuilder__            if (request.includeGlobalState()) {_                metaDataBuilder = MetaData.builder(repository.getSnapshotGlobalMetaData(snapshotId))__            } else {_                metaDataBuilder = MetaData.builder()__            }__            final List<IndexId> indexIdsInSnapshot = repositoryData.resolveIndices(indicesInSnapshot)__            for (IndexId indexId : indexIdsInSnapshot) {_                metaDataBuilder.put(repository.getSnapshotIndexMetaData(snapshotId, indexId), false)__            }__            final MetaData metaData = metaDataBuilder.build()___            _            _            final Map<String, String> indices = renamedIndices(request, indicesInSnapshot)___            _            _            clusterService.submitStateUpdateTask(request.cause(), new ClusterStateUpdateTask() {_                RestoreInfo restoreInfo = null___                @Override_                public ClusterState execute(ClusterState currentState) {_                    _                    _                    RestoreInProgress restoreInProgress = currentState.custom(RestoreInProgress.TYPE)__                    if (restoreInProgress != null && !restoreInProgress.entries().isEmpty()) {_                        throw new ConcurrentSnapshotExecutionException(snapshot, "Restore process is already running in this cluster")__                    }_                    _                    SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                    if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                        throw new ConcurrentSnapshotExecutionException(snapshot,_                            "cannot restore a snapshot while a snapshot deletion is in-progress [" +_                                deletionsInProgress.getEntries().get(0).getSnapshot() + "]")__                    }__                    _                    ClusterState.Builder builder = ClusterState.builder(currentState)__                    MetaData.Builder mdBuilder = MetaData.builder(currentState.metaData())__                    ClusterBlocks.Builder blocks = ClusterBlocks.builder().blocks(currentState.blocks())__                    RoutingTable.Builder rtBuilder = RoutingTable.builder(currentState.routingTable())__                    ImmutableOpenMap<ShardId, RestoreInProgress.ShardRestoreStatus> shards__                    Set<String> aliases = new HashSet<>()___                    if (indices.isEmpty() == false) {_                        _                        ImmutableOpenMap.Builder<ShardId, RestoreInProgress.ShardRestoreStatus> shardsBuilder = ImmutableOpenMap.builder()__                        final Version minIndexCompatibilityVersion = currentState.getNodes().getMaxNodeVersion()_                            .minimumIndexCompatibilityVersion()__                        for (Map.Entry<String, String> indexEntry : indices.entrySet()) {_                            String index = indexEntry.getValue()__                            boolean partial = checkPartial(index)__                            SnapshotRecoverySource recoverySource = new SnapshotRecoverySource(snapshot, snapshotInfo.version(), index)__                            String renamedIndexName = indexEntry.getKey()__                            IndexMetaData snapshotIndexMetaData = metaData.index(index)__                            snapshotIndexMetaData = updateIndexSettings(snapshotIndexMetaData, request.indexSettings, request.ignoreIndexSettings)__                            try {_                                snapshotIndexMetaData = metaDataIndexUpgradeService.upgradeIndexMetaData(snapshotIndexMetaData,_                                    minIndexCompatibilityVersion)__                            } catch (Exception ex) {_                                throw new SnapshotRestoreException(snapshot, "cannot restore index [" + index + "] because it cannot be upgraded", ex)__                            }_                            _                            IndexMetaData currentIndexMetaData = currentState.metaData().index(renamedIndexName)__                            IntSet ignoreShards = new IntHashSet()__                            final Index renamedIndex__                            if (currentIndexMetaData == null) {_                                _                                _                                MetaDataCreateIndexService.validateIndexName(renamedIndexName, currentState)__                                createIndexService.validateIndexSettings(renamedIndexName, snapshotIndexMetaData.getSettings())__                                IndexMetaData.Builder indexMdBuilder = IndexMetaData.builder(snapshotIndexMetaData).state(IndexMetaData.State.OPEN).index(renamedIndexName)__                                indexMdBuilder.settings(Settings.builder().put(snapshotIndexMetaData.getSettings()).put(IndexMetaData.SETTING_INDEX_UUID, UUIDs.randomBase64UUID()))__                                if (!request.includeAliases() && !snapshotIndexMetaData.getAliases().isEmpty()) {_                                    _                                    indexMdBuilder.removeAllAliases()__                                } else {_                                    for (ObjectCursor<String> alias : snapshotIndexMetaData.getAliases().keys()) {_                                        aliases.add(alias.value)__                                    }_                                }_                                IndexMetaData updatedIndexMetaData = indexMdBuilder.build()__                                if (partial) {_                                    populateIgnoredShards(index, ignoreShards)__                                }_                                rtBuilder.addAsNewRestore(updatedIndexMetaData, recoverySource, ignoreShards)__                                blocks.addBlocks(updatedIndexMetaData)__                                mdBuilder.put(updatedIndexMetaData, true)__                                renamedIndex = updatedIndexMetaData.getIndex()__                            } else {_                                validateExistingIndex(currentIndexMetaData, snapshotIndexMetaData, renamedIndexName, partial)__                                _                                IndexMetaData.Builder indexMdBuilder = IndexMetaData.builder(snapshotIndexMetaData).state(IndexMetaData.State.OPEN)__                                indexMdBuilder.version(Math.max(snapshotIndexMetaData.getVersion(), currentIndexMetaData.getVersion() + 1))__                                if (!request.includeAliases()) {_                                    _                                    if (!snapshotIndexMetaData.getAliases().isEmpty()) {_                                        indexMdBuilder.removeAllAliases()__                                    }_                                    _                                    for (ObjectCursor<AliasMetaData> alias : currentIndexMetaData.getAliases().values()) {_                                        indexMdBuilder.putAlias(alias.value)__                                    }_                                } else {_                                    for (ObjectCursor<String> alias : snapshotIndexMetaData.getAliases().keys()) {_                                        aliases.add(alias.value)__                                    }_                                }_                                indexMdBuilder.settings(Settings.builder().put(snapshotIndexMetaData.getSettings()).put(IndexMetaData.SETTING_INDEX_UUID, currentIndexMetaData.getIndexUUID()))__                                IndexMetaData updatedIndexMetaData = indexMdBuilder.index(renamedIndexName).build()__                                rtBuilder.addAsRestore(updatedIndexMetaData, recoverySource)__                                blocks.updateBlocks(updatedIndexMetaData)__                                mdBuilder.put(updatedIndexMetaData, true)__                                renamedIndex = updatedIndexMetaData.getIndex()__                            }__                            for (int shard = 0_ shard < snapshotIndexMetaData.getNumberOfShards()_ shard++) {_                                if (!ignoreShards.contains(shard)) {_                                    shardsBuilder.put(new ShardId(renamedIndex, shard), new RestoreInProgress.ShardRestoreStatus(clusterService.state().nodes().getLocalNodeId()))__                                } else {_                                    shardsBuilder.put(new ShardId(renamedIndex, shard), new RestoreInProgress.ShardRestoreStatus(clusterService.state().nodes().getLocalNodeId(), RestoreInProgress.State.FAILURE))__                                }_                            }_                        }__                        shards = shardsBuilder.build()__                        RestoreInProgress.Entry restoreEntry = new RestoreInProgress.Entry(snapshot, overallState(RestoreInProgress.State.INIT, shards), Collections.unmodifiableList(new ArrayList<>(indices.keySet())), shards)__                        builder.putCustom(RestoreInProgress.TYPE, new RestoreInProgress(restoreEntry))__                    } else {_                        shards = ImmutableOpenMap.of()__                    }__                    checkAliasNameConflicts(indices, aliases)___                    _                    if (request.includeGlobalState()) {_                        if (metaData.persistentSettings() != null) {_                            Settings settings = metaData.persistentSettings()__                            clusterSettings.validateUpdate(settings)__                            mdBuilder.persistentSettings(settings)__                        }_                        if (metaData.templates() != null) {_                            _                            for (ObjectCursor<IndexTemplateMetaData> cursor : metaData.templates().values()) {_                                mdBuilder.put(cursor.value)__                            }_                        }_                        if (metaData.customs() != null) {_                            for (ObjectObjectCursor<String, MetaData.Custom> cursor : metaData.customs()) {_                                if (!RepositoriesMetaData.TYPE.equals(cursor.key)) {_                                    _                                    _                                    mdBuilder.putCustom(cursor.key, cursor.value)__                                }_                            }_                        }_                    }__                    if (completed(shards)) {_                        _                        restoreInfo = new RestoreInfo(snapshotId.getName(),_                                                      Collections.unmodifiableList(new ArrayList<>(indices.keySet())),_                                                      shards.size(),_                                                      shards.size() - failedShards(shards))__                    }__                    RoutingTable rt = rtBuilder.build()__                    ClusterState updatedState = builder.metaData(mdBuilder).blocks(blocks).routingTable(rt).build()__                    return allocationService.reroute(updatedState, "restored snapshot [" + snapshot + "]")__                }__                private void checkAliasNameConflicts(Map<String, String> renamedIndices, Set<String> aliases) {_                    for (Map.Entry<String, String> renamedIndex : renamedIndices.entrySet()) {_                        if (aliases.contains(renamedIndex.getKey())) {_                            throw new SnapshotRestoreException(snapshot, "cannot rename index [" + renamedIndex.getValue() + "] into [" + renamedIndex.getKey() + "] because of conflict with an alias with the same name")__                        }_                    }_                }__                private void populateIgnoredShards(String index, IntSet ignoreShards) {_                    for (SnapshotShardFailure failure : snapshotInfo.shardFailures()) {_                        if (index.equals(failure.index())) {_                            ignoreShards.add(failure.shardId())__                        }_                    }_                }__                private boolean checkPartial(String index) {_                    _                    if (failed(snapshotInfo, index)) {_                        if (request.partial()) {_                            return true__                        } else {_                            throw new SnapshotRestoreException(snapshot, "index [" + index + "] wasn't fully snapshotted - cannot restore")__                        }_                    } else {_                        return false__                    }_                }__                private void validateExistingIndex(IndexMetaData currentIndexMetaData, IndexMetaData snapshotIndexMetaData, String renamedIndex, boolean partial) {_                    _                    if (currentIndexMetaData.getState() != IndexMetaData.State.CLOSE) {_                        _                        throw new SnapshotRestoreException(snapshot, "cannot restore index [" + renamedIndex + "] because an open index with same name already exists in the cluster. " +_                            "Either close or delete the existing index or restore the index under a different name by providing a rename pattern and replacement name")__                    }_                    _                    if (partial) {_                        throw new SnapshotRestoreException(snapshot, "cannot restore partial index [" + renamedIndex + "] because such index already exists")__                    }_                    _                    if (currentIndexMetaData.getNumberOfShards() != snapshotIndexMetaData.getNumberOfShards()) {_                        throw new SnapshotRestoreException(snapshot, "cannot restore index [" + renamedIndex + "] with [" + currentIndexMetaData.getNumberOfShards() +_                                "] shard from snapshot with [" + snapshotIndexMetaData.getNumberOfShards() + "] shards")__                    }_                }__                _                private IndexMetaData updateIndexSettings(IndexMetaData indexMetaData, Settings changeSettings, String[] ignoreSettings) {_                    if (changeSettings.names().isEmpty() && ignoreSettings.length == 0) {_                        return indexMetaData__                    }_                    Settings normalizedChangeSettings = Settings.builder().put(changeSettings).normalizePrefix(IndexMetaData.INDEX_SETTING_PREFIX).build()__                    IndexMetaData.Builder builder = IndexMetaData.builder(indexMetaData)__                    Settings settings = indexMetaData.getSettings()__                    Set<String> keyFilters = new HashSet<>()__                    List<String> simpleMatchPatterns = new ArrayList<>()__                    for (String ignoredSetting : ignoreSettings) {_                        if (!Regex.isSimpleMatchPattern(ignoredSetting)) {_                            if (UNREMOVABLE_SETTINGS.contains(ignoredSetting)) {_                                throw new SnapshotRestoreException(snapshot, "cannot remove setting [" + ignoredSetting + "] on restore")__                            } else {_                                keyFilters.add(ignoredSetting)__                            }_                        } else {_                            simpleMatchPatterns.add(ignoredSetting)__                        }_                    }_                    Predicate<String> settingsFilter = k -> {_                        if (UNREMOVABLE_SETTINGS.contains(k) == false) {_                            for (String filterKey : keyFilters) {_                                if (k.equals(filterKey)) {_                                    return false__                                }_                            }_                            for (String pattern : simpleMatchPatterns) {_                                if (Regex.simpleMatch(pattern, k)) {_                                    return false__                                }_                            }_                        }_                        return true__                    }__                    Settings.Builder settingsBuilder = Settings.builder()_                        .put(settings.filter(settingsFilter))_                        .put(normalizedChangeSettings.filter(k -> {_                            if (UNMODIFIABLE_SETTINGS.contains(k)) {_                                throw new SnapshotRestoreException(snapshot, "cannot modify setting [" + k + "] on restore")__                            } else {_                                return true__                            }_                        }))__                    return builder.settings(settingsBuilder).build()__                }__                @Override_                public void onFailure(String source, Exception e) {_                    logger.warn(() -> new ParameterizedMessage("[{}] failed to restore snapshot", snapshotId), e)__                    listener.onFailure(e)__                }__                @Override_                public TimeValue timeout() {_                    return request.masterNodeTimeout()__                }__                @Override_                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                    listener.onResponse(new RestoreCompletionResponse(snapshot, restoreInfo))__                }_            })____        } catch (Exception e) {_            logger.warn(() -> new ParameterizedMessage("[{}] failed to restore snapshot", request.repositoryName + ":" + request.snapshotName), e)__            listener.onFailure(e)__        }_    };restores,snapshot,specified,in,the,restore,request,param,request,restore,request,param,listener,restore,listener;public,void,restore,snapshot,final,restore,request,request,final,action,listener,restore,completion,response,listener,try,repository,repository,repositories,service,repository,request,repository,name,final,repository,data,repository,data,repository,get,repository,data,final,optional,snapshot,id,incompatible,snapshot,id,repository,data,get,incompatible,snapshot,ids,stream,filter,s,request,snapshot,name,equals,s,get,name,find,first,if,incompatible,snapshot,id,is,present,throw,new,snapshot,restore,exception,request,repository,name,request,snapshot,name,cannot,restore,incompatible,snapshot,final,optional,snapshot,id,matching,snapshot,id,repository,data,get,snapshot,ids,stream,filter,s,request,snapshot,name,equals,s,get,name,find,first,if,matching,snapshot,id,is,present,false,throw,new,snapshot,restore,exception,request,repository,name,request,snapshot,name,snapshot,does,not,exist,final,snapshot,id,snapshot,id,matching,snapshot,id,get,final,snapshot,info,snapshot,info,repository,get,snapshot,info,snapshot,id,final,snapshot,snapshot,new,snapshot,request,repository,name,snapshot,id,validate,snapshot,restorable,request,repository,name,snapshot,info,final,list,string,indices,in,snapshot,filter,indices,snapshot,info,indices,request,indices,request,indices,options,final,meta,data,builder,meta,data,builder,if,request,include,global,state,meta,data,builder,meta,data,builder,repository,get,snapshot,global,meta,data,snapshot,id,else,meta,data,builder,meta,data,builder,final,list,index,id,index,ids,in,snapshot,repository,data,resolve,indices,indices,in,snapshot,for,index,id,index,id,index,ids,in,snapshot,meta,data,builder,put,repository,get,snapshot,index,meta,data,snapshot,id,index,id,false,final,meta,data,meta,data,meta,data,builder,build,final,map,string,string,indices,renamed,indices,request,indices,in,snapshot,cluster,service,submit,state,update,task,request,cause,new,cluster,state,update,task,restore,info,restore,info,null,override,public,cluster,state,execute,cluster,state,current,state,restore,in,progress,restore,in,progress,current,state,custom,restore,in,progress,type,if,restore,in,progress,null,restore,in,progress,entries,is,empty,throw,new,concurrent,snapshot,execution,exception,snapshot,restore,process,is,already,running,in,this,cluster,snapshot,deletions,in,progress,deletions,in,progress,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,throw,new,concurrent,snapshot,execution,exception,snapshot,cannot,restore,a,snapshot,while,a,snapshot,deletion,is,in,progress,deletions,in,progress,get,entries,get,0,get,snapshot,cluster,state,builder,builder,cluster,state,builder,current,state,meta,data,builder,md,builder,meta,data,builder,current,state,meta,data,cluster,blocks,builder,blocks,cluster,blocks,builder,blocks,current,state,blocks,routing,table,builder,rt,builder,routing,table,builder,current,state,routing,table,immutable,open,map,shard,id,restore,in,progress,shard,restore,status,shards,set,string,aliases,new,hash,set,if,indices,is,empty,false,immutable,open,map,builder,shard,id,restore,in,progress,shard,restore,status,shards,builder,immutable,open,map,builder,final,version,min,index,compatibility,version,current,state,get,nodes,get,max,node,version,minimum,index,compatibility,version,for,map,entry,string,string,index,entry,indices,entry,set,string,index,index,entry,get,value,boolean,partial,check,partial,index,snapshot,recovery,source,recovery,source,new,snapshot,recovery,source,snapshot,snapshot,info,version,index,string,renamed,index,name,index,entry,get,key,index,meta,data,snapshot,index,meta,data,meta,data,index,index,snapshot,index,meta,data,update,index,settings,snapshot,index,meta,data,request,index,settings,request,ignore,index,settings,try,snapshot,index,meta,data,meta,data,index,upgrade,service,upgrade,index,meta,data,snapshot,index,meta,data,min,index,compatibility,version,catch,exception,ex,throw,new,snapshot,restore,exception,snapshot,cannot,restore,index,index,because,it,cannot,be,upgraded,ex,index,meta,data,current,index,meta,data,current,state,meta,data,index,renamed,index,name,int,set,ignore,shards,new,int,hash,set,final,index,renamed,index,if,current,index,meta,data,null,meta,data,create,index,service,validate,index,name,renamed,index,name,current,state,create,index,service,validate,index,settings,renamed,index,name,snapshot,index,meta,data,get,settings,index,meta,data,builder,index,md,builder,index,meta,data,builder,snapshot,index,meta,data,state,index,meta,data,state,open,index,renamed,index,name,index,md,builder,settings,settings,builder,put,snapshot,index,meta,data,get,settings,put,index,meta,data,uuids,random,base64uuid,if,request,include,aliases,snapshot,index,meta,data,get,aliases,is,empty,index,md,builder,remove,all,aliases,else,for,object,cursor,string,alias,snapshot,index,meta,data,get,aliases,keys,aliases,add,alias,value,index,meta,data,updated,index,meta,data,index,md,builder,build,if,partial,populate,ignored,shards,index,ignore,shards,rt,builder,add,as,new,restore,updated,index,meta,data,recovery,source,ignore,shards,blocks,add,blocks,updated,index,meta,data,md,builder,put,updated,index,meta,data,true,renamed,index,updated,index,meta,data,get,index,else,validate,existing,index,current,index,meta,data,snapshot,index,meta,data,renamed,index,name,partial,index,meta,data,builder,index,md,builder,index,meta,data,builder,snapshot,index,meta,data,state,index,meta,data,state,open,index,md,builder,version,math,max,snapshot,index,meta,data,get,version,current,index,meta,data,get,version,1,if,request,include,aliases,if,snapshot,index,meta,data,get,aliases,is,empty,index,md,builder,remove,all,aliases,for,object,cursor,alias,meta,data,alias,current,index,meta,data,get,aliases,values,index,md,builder,put,alias,alias,value,else,for,object,cursor,string,alias,snapshot,index,meta,data,get,aliases,keys,aliases,add,alias,value,index,md,builder,settings,settings,builder,put,snapshot,index,meta,data,get,settings,put,index,meta,data,current,index,meta,data,get,index,uuid,index,meta,data,updated,index,meta,data,index,md,builder,index,renamed,index,name,build,rt,builder,add,as,restore,updated,index,meta,data,recovery,source,blocks,update,blocks,updated,index,meta,data,md,builder,put,updated,index,meta,data,true,renamed,index,updated,index,meta,data,get,index,for,int,shard,0,shard,snapshot,index,meta,data,get,number,of,shards,shard,if,ignore,shards,contains,shard,shards,builder,put,new,shard,id,renamed,index,shard,new,restore,in,progress,shard,restore,status,cluster,service,state,nodes,get,local,node,id,else,shards,builder,put,new,shard,id,renamed,index,shard,new,restore,in,progress,shard,restore,status,cluster,service,state,nodes,get,local,node,id,restore,in,progress,state,failure,shards,shards,builder,build,restore,in,progress,entry,restore,entry,new,restore,in,progress,entry,snapshot,overall,state,restore,in,progress,state,init,shards,collections,unmodifiable,list,new,array,list,indices,key,set,shards,builder,put,custom,restore,in,progress,type,new,restore,in,progress,restore,entry,else,shards,immutable,open,map,of,check,alias,name,conflicts,indices,aliases,if,request,include,global,state,if,meta,data,persistent,settings,null,settings,settings,meta,data,persistent,settings,cluster,settings,validate,update,settings,md,builder,persistent,settings,settings,if,meta,data,templates,null,for,object,cursor,index,template,meta,data,cursor,meta,data,templates,values,md,builder,put,cursor,value,if,meta,data,customs,null,for,object,object,cursor,string,meta,data,custom,cursor,meta,data,customs,if,repositories,meta,data,type,equals,cursor,key,md,builder,put,custom,cursor,key,cursor,value,if,completed,shards,restore,info,new,restore,info,snapshot,id,get,name,collections,unmodifiable,list,new,array,list,indices,key,set,shards,size,shards,size,failed,shards,shards,routing,table,rt,rt,builder,build,cluster,state,updated,state,builder,meta,data,md,builder,blocks,blocks,routing,table,rt,build,return,allocation,service,reroute,updated,state,restored,snapshot,snapshot,private,void,check,alias,name,conflicts,map,string,string,renamed,indices,set,string,aliases,for,map,entry,string,string,renamed,index,renamed,indices,entry,set,if,aliases,contains,renamed,index,get,key,throw,new,snapshot,restore,exception,snapshot,cannot,rename,index,renamed,index,get,value,into,renamed,index,get,key,because,of,conflict,with,an,alias,with,the,same,name,private,void,populate,ignored,shards,string,index,int,set,ignore,shards,for,snapshot,shard,failure,failure,snapshot,info,shard,failures,if,index,equals,failure,index,ignore,shards,add,failure,shard,id,private,boolean,check,partial,string,index,if,failed,snapshot,info,index,if,request,partial,return,true,else,throw,new,snapshot,restore,exception,snapshot,index,index,wasn,t,fully,snapshotted,cannot,restore,else,return,false,private,void,validate,existing,index,index,meta,data,current,index,meta,data,index,meta,data,snapshot,index,meta,data,string,renamed,index,boolean,partial,if,current,index,meta,data,get,state,index,meta,data,state,close,throw,new,snapshot,restore,exception,snapshot,cannot,restore,index,renamed,index,because,an,open,index,with,same,name,already,exists,in,the,cluster,either,close,or,delete,the,existing,index,or,restore,the,index,under,a,different,name,by,providing,a,rename,pattern,and,replacement,name,if,partial,throw,new,snapshot,restore,exception,snapshot,cannot,restore,partial,index,renamed,index,because,such,index,already,exists,if,current,index,meta,data,get,number,of,shards,snapshot,index,meta,data,get,number,of,shards,throw,new,snapshot,restore,exception,snapshot,cannot,restore,index,renamed,index,with,current,index,meta,data,get,number,of,shards,shard,from,snapshot,with,snapshot,index,meta,data,get,number,of,shards,shards,private,index,meta,data,update,index,settings,index,meta,data,index,meta,data,settings,change,settings,string,ignore,settings,if,change,settings,names,is,empty,ignore,settings,length,0,return,index,meta,data,settings,normalized,change,settings,settings,builder,put,change,settings,normalize,prefix,index,meta,data,build,index,meta,data,builder,builder,index,meta,data,builder,index,meta,data,settings,settings,index,meta,data,get,settings,set,string,key,filters,new,hash,set,list,string,simple,match,patterns,new,array,list,for,string,ignored,setting,ignore,settings,if,regex,is,simple,match,pattern,ignored,setting,if,contains,ignored,setting,throw,new,snapshot,restore,exception,snapshot,cannot,remove,setting,ignored,setting,on,restore,else,key,filters,add,ignored,setting,else,simple,match,patterns,add,ignored,setting,predicate,string,settings,filter,k,if,contains,k,false,for,string,filter,key,key,filters,if,k,equals,filter,key,return,false,for,string,pattern,simple,match,patterns,if,regex,simple,match,pattern,k,return,false,return,true,settings,builder,settings,builder,settings,builder,put,settings,filter,settings,filter,put,normalized,change,settings,filter,k,if,contains,k,throw,new,snapshot,restore,exception,snapshot,cannot,modify,setting,k,on,restore,else,return,true,return,builder,settings,settings,builder,build,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,restore,snapshot,snapshot,id,e,listener,on,failure,e,override,public,time,value,timeout,return,request,master,node,timeout,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,listener,on,response,new,restore,completion,response,snapshot,restore,info,catch,exception,e,logger,warn,new,parameterized,message,failed,to,restore,snapshot,request,repository,name,request,snapshot,name,e,listener,on,failure,e
RestoreService -> public void restoreSnapshot(final RestoreRequest request, final ActionListener<RestoreCompletionResponse> listener);1525248068;Restores snapshot specified in the restore request.__@param request  restore request_@param listener restore listener;public void restoreSnapshot(final RestoreRequest request, final ActionListener<RestoreCompletionResponse> listener) {_        try {_            _            Repository repository = repositoriesService.repository(request.repositoryName)__            final RepositoryData repositoryData = repository.getRepositoryData()__            final Optional<SnapshotId> incompatibleSnapshotId =_                repositoryData.getIncompatibleSnapshotIds().stream().filter(s -> request.snapshotName.equals(s.getName())).findFirst()__            if (incompatibleSnapshotId.isPresent()) {_                throw new SnapshotRestoreException(request.repositoryName, request.snapshotName, "cannot restore incompatible snapshot")__            }_            final Optional<SnapshotId> matchingSnapshotId = repositoryData.getSnapshotIds().stream()_                .filter(s -> request.snapshotName.equals(s.getName())).findFirst()__            if (matchingSnapshotId.isPresent() == false) {_                throw new SnapshotRestoreException(request.repositoryName, request.snapshotName, "snapshot does not exist")__            }__            final SnapshotId snapshotId = matchingSnapshotId.get()__            final SnapshotInfo snapshotInfo = repository.getSnapshotInfo(snapshotId)__            final Snapshot snapshot = new Snapshot(request.repositoryName, snapshotId)___            _            validateSnapshotRestorable(request.repositoryName, snapshotInfo)___            _            final List<String> indicesInSnapshot = filterIndices(snapshotInfo.indices(), request.indices(), request.indicesOptions())___            final MetaData.Builder metaDataBuilder__            if (request.includeGlobalState()) {_                metaDataBuilder = MetaData.builder(repository.getSnapshotGlobalMetaData(snapshotId))__            } else {_                metaDataBuilder = MetaData.builder()__            }__            final List<IndexId> indexIdsInSnapshot = repositoryData.resolveIndices(indicesInSnapshot)__            for (IndexId indexId : indexIdsInSnapshot) {_                metaDataBuilder.put(repository.getSnapshotIndexMetaData(snapshotId, indexId), false)__            }__            final MetaData metaData = metaDataBuilder.build()___            _            _            final Map<String, String> indices = renamedIndices(request, indicesInSnapshot)___            _            _            clusterService.submitStateUpdateTask(request.cause(), new ClusterStateUpdateTask() {_                RestoreInfo restoreInfo = null___                @Override_                public ClusterState execute(ClusterState currentState) {_                    _                    _                    RestoreInProgress restoreInProgress = currentState.custom(RestoreInProgress.TYPE)__                    if (restoreInProgress != null && !restoreInProgress.entries().isEmpty()) {_                        throw new ConcurrentSnapshotExecutionException(snapshot, "Restore process is already running in this cluster")__                    }_                    _                    SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                    if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                        throw new ConcurrentSnapshotExecutionException(snapshot,_                            "cannot restore a snapshot while a snapshot deletion is in-progress [" +_                                deletionsInProgress.getEntries().get(0).getSnapshot() + "]")__                    }__                    _                    ClusterState.Builder builder = ClusterState.builder(currentState)__                    MetaData.Builder mdBuilder = MetaData.builder(currentState.metaData())__                    ClusterBlocks.Builder blocks = ClusterBlocks.builder().blocks(currentState.blocks())__                    RoutingTable.Builder rtBuilder = RoutingTable.builder(currentState.routingTable())__                    ImmutableOpenMap<ShardId, RestoreInProgress.ShardRestoreStatus> shards__                    Set<String> aliases = new HashSet<>()___                    if (indices.isEmpty() == false) {_                        _                        ImmutableOpenMap.Builder<ShardId, RestoreInProgress.ShardRestoreStatus> shardsBuilder = ImmutableOpenMap.builder()__                        final Version minIndexCompatibilityVersion = currentState.getNodes().getMaxNodeVersion()_                            .minimumIndexCompatibilityVersion()__                        for (Map.Entry<String, String> indexEntry : indices.entrySet()) {_                            String index = indexEntry.getValue()__                            boolean partial = checkPartial(index)__                            SnapshotRecoverySource recoverySource = new SnapshotRecoverySource(snapshot, snapshotInfo.version(), index)__                            String renamedIndexName = indexEntry.getKey()__                            IndexMetaData snapshotIndexMetaData = metaData.index(index)__                            snapshotIndexMetaData = updateIndexSettings(snapshotIndexMetaData, request.indexSettings, request.ignoreIndexSettings)__                            try {_                                snapshotIndexMetaData = metaDataIndexUpgradeService.upgradeIndexMetaData(snapshotIndexMetaData,_                                    minIndexCompatibilityVersion)__                            } catch (Exception ex) {_                                throw new SnapshotRestoreException(snapshot, "cannot restore index [" + index + "] because it cannot be upgraded", ex)__                            }_                            _                            IndexMetaData currentIndexMetaData = currentState.metaData().index(renamedIndexName)__                            IntSet ignoreShards = new IntHashSet()__                            final Index renamedIndex__                            if (currentIndexMetaData == null) {_                                _                                _                                MetaDataCreateIndexService.validateIndexName(renamedIndexName, currentState)__                                createIndexService.validateIndexSettings(renamedIndexName, snapshotIndexMetaData.getSettings())__                                IndexMetaData.Builder indexMdBuilder = IndexMetaData.builder(snapshotIndexMetaData).state(IndexMetaData.State.OPEN).index(renamedIndexName)__                                indexMdBuilder.settings(Settings.builder().put(snapshotIndexMetaData.getSettings()).put(IndexMetaData.SETTING_INDEX_UUID, UUIDs.randomBase64UUID()))__                                if (!request.includeAliases() && !snapshotIndexMetaData.getAliases().isEmpty()) {_                                    _                                    indexMdBuilder.removeAllAliases()__                                } else {_                                    for (ObjectCursor<String> alias : snapshotIndexMetaData.getAliases().keys()) {_                                        aliases.add(alias.value)__                                    }_                                }_                                IndexMetaData updatedIndexMetaData = indexMdBuilder.build()__                                if (partial) {_                                    populateIgnoredShards(index, ignoreShards)__                                }_                                rtBuilder.addAsNewRestore(updatedIndexMetaData, recoverySource, ignoreShards)__                                blocks.addBlocks(updatedIndexMetaData)__                                mdBuilder.put(updatedIndexMetaData, true)__                                renamedIndex = updatedIndexMetaData.getIndex()__                            } else {_                                validateExistingIndex(currentIndexMetaData, snapshotIndexMetaData, renamedIndexName, partial)__                                _                                IndexMetaData.Builder indexMdBuilder = IndexMetaData.builder(snapshotIndexMetaData).state(IndexMetaData.State.OPEN)__                                indexMdBuilder.version(Math.max(snapshotIndexMetaData.getVersion(), currentIndexMetaData.getVersion() + 1))__                                if (!request.includeAliases()) {_                                    _                                    if (!snapshotIndexMetaData.getAliases().isEmpty()) {_                                        indexMdBuilder.removeAllAliases()__                                    }_                                    _                                    for (ObjectCursor<AliasMetaData> alias : currentIndexMetaData.getAliases().values()) {_                                        indexMdBuilder.putAlias(alias.value)__                                    }_                                } else {_                                    for (ObjectCursor<String> alias : snapshotIndexMetaData.getAliases().keys()) {_                                        aliases.add(alias.value)__                                    }_                                }_                                indexMdBuilder.settings(Settings.builder().put(snapshotIndexMetaData.getSettings()).put(IndexMetaData.SETTING_INDEX_UUID, currentIndexMetaData.getIndexUUID()))__                                IndexMetaData updatedIndexMetaData = indexMdBuilder.index(renamedIndexName).build()__                                rtBuilder.addAsRestore(updatedIndexMetaData, recoverySource)__                                blocks.updateBlocks(updatedIndexMetaData)__                                mdBuilder.put(updatedIndexMetaData, true)__                                renamedIndex = updatedIndexMetaData.getIndex()__                            }__                            for (int shard = 0_ shard < snapshotIndexMetaData.getNumberOfShards()_ shard++) {_                                if (!ignoreShards.contains(shard)) {_                                    shardsBuilder.put(new ShardId(renamedIndex, shard), new RestoreInProgress.ShardRestoreStatus(clusterService.state().nodes().getLocalNodeId()))__                                } else {_                                    shardsBuilder.put(new ShardId(renamedIndex, shard), new RestoreInProgress.ShardRestoreStatus(clusterService.state().nodes().getLocalNodeId(), RestoreInProgress.State.FAILURE))__                                }_                            }_                        }__                        shards = shardsBuilder.build()__                        RestoreInProgress.Entry restoreEntry = new RestoreInProgress.Entry(snapshot, overallState(RestoreInProgress.State.INIT, shards), Collections.unmodifiableList(new ArrayList<>(indices.keySet())), shards)__                        builder.putCustom(RestoreInProgress.TYPE, new RestoreInProgress(restoreEntry))__                    } else {_                        shards = ImmutableOpenMap.of()__                    }__                    checkAliasNameConflicts(indices, aliases)___                    _                    if (request.includeGlobalState()) {_                        if (metaData.persistentSettings() != null) {_                            Settings settings = metaData.persistentSettings()__                            clusterSettings.validateUpdate(settings)__                            mdBuilder.persistentSettings(settings)__                        }_                        if (metaData.templates() != null) {_                            _                            for (ObjectCursor<IndexTemplateMetaData> cursor : metaData.templates().values()) {_                                mdBuilder.put(cursor.value)__                            }_                        }_                        if (metaData.customs() != null) {_                            for (ObjectObjectCursor<String, MetaData.Custom> cursor : metaData.customs()) {_                                if (!RepositoriesMetaData.TYPE.equals(cursor.key)) {_                                    _                                    _                                    mdBuilder.putCustom(cursor.key, cursor.value)__                                }_                            }_                        }_                    }__                    if (completed(shards)) {_                        _                        restoreInfo = new RestoreInfo(snapshotId.getName(),_                                                      Collections.unmodifiableList(new ArrayList<>(indices.keySet())),_                                                      shards.size(),_                                                      shards.size() - failedShards(shards))__                    }__                    RoutingTable rt = rtBuilder.build()__                    ClusterState updatedState = builder.metaData(mdBuilder).blocks(blocks).routingTable(rt).build()__                    return allocationService.reroute(updatedState, "restored snapshot [" + snapshot + "]")__                }__                private void checkAliasNameConflicts(Map<String, String> renamedIndices, Set<String> aliases) {_                    for (Map.Entry<String, String> renamedIndex : renamedIndices.entrySet()) {_                        if (aliases.contains(renamedIndex.getKey())) {_                            throw new SnapshotRestoreException(snapshot, "cannot rename index [" + renamedIndex.getValue() + "] into [" + renamedIndex.getKey() + "] because of conflict with an alias with the same name")__                        }_                    }_                }__                private void populateIgnoredShards(String index, IntSet ignoreShards) {_                    for (SnapshotShardFailure failure : snapshotInfo.shardFailures()) {_                        if (index.equals(failure.index())) {_                            ignoreShards.add(failure.shardId())__                        }_                    }_                }__                private boolean checkPartial(String index) {_                    _                    if (failed(snapshotInfo, index)) {_                        if (request.partial()) {_                            return true__                        } else {_                            throw new SnapshotRestoreException(snapshot, "index [" + index + "] wasn't fully snapshotted - cannot restore")__                        }_                    } else {_                        return false__                    }_                }__                private void validateExistingIndex(IndexMetaData currentIndexMetaData, IndexMetaData snapshotIndexMetaData, String renamedIndex, boolean partial) {_                    _                    if (currentIndexMetaData.getState() != IndexMetaData.State.CLOSE) {_                        _                        throw new SnapshotRestoreException(snapshot, "cannot restore index [" + renamedIndex + "] because an open index with same name already exists in the cluster. " +_                            "Either close or delete the existing index or restore the index under a different name by providing a rename pattern and replacement name")__                    }_                    _                    if (partial) {_                        throw new SnapshotRestoreException(snapshot, "cannot restore partial index [" + renamedIndex + "] because such index already exists")__                    }_                    _                    if (currentIndexMetaData.getNumberOfShards() != snapshotIndexMetaData.getNumberOfShards()) {_                        throw new SnapshotRestoreException(snapshot, "cannot restore index [" + renamedIndex + "] with [" + currentIndexMetaData.getNumberOfShards() +_                                "] shards from a snapshot of index [" + snapshotIndexMetaData.getIndex().getName() + "] with [" + snapshotIndexMetaData.getNumberOfShards() + "] shards")__                    }_                }__                _                private IndexMetaData updateIndexSettings(IndexMetaData indexMetaData, Settings changeSettings, String[] ignoreSettings) {_                    if (changeSettings.names().isEmpty() && ignoreSettings.length == 0) {_                        return indexMetaData__                    }_                    Settings normalizedChangeSettings = Settings.builder().put(changeSettings).normalizePrefix(IndexMetaData.INDEX_SETTING_PREFIX).build()__                    IndexMetaData.Builder builder = IndexMetaData.builder(indexMetaData)__                    Settings settings = indexMetaData.getSettings()__                    Set<String> keyFilters = new HashSet<>()__                    List<String> simpleMatchPatterns = new ArrayList<>()__                    for (String ignoredSetting : ignoreSettings) {_                        if (!Regex.isSimpleMatchPattern(ignoredSetting)) {_                            if (UNREMOVABLE_SETTINGS.contains(ignoredSetting)) {_                                throw new SnapshotRestoreException(snapshot, "cannot remove setting [" + ignoredSetting + "] on restore")__                            } else {_                                keyFilters.add(ignoredSetting)__                            }_                        } else {_                            simpleMatchPatterns.add(ignoredSetting)__                        }_                    }_                    Predicate<String> settingsFilter = k -> {_                        if (UNREMOVABLE_SETTINGS.contains(k) == false) {_                            for (String filterKey : keyFilters) {_                                if (k.equals(filterKey)) {_                                    return false__                                }_                            }_                            for (String pattern : simpleMatchPatterns) {_                                if (Regex.simpleMatch(pattern, k)) {_                                    return false__                                }_                            }_                        }_                        return true__                    }__                    Settings.Builder settingsBuilder = Settings.builder()_                        .put(settings.filter(settingsFilter))_                        .put(normalizedChangeSettings.filter(k -> {_                            if (UNMODIFIABLE_SETTINGS.contains(k)) {_                                throw new SnapshotRestoreException(snapshot, "cannot modify setting [" + k + "] on restore")__                            } else {_                                return true__                            }_                        }))__                    return builder.settings(settingsBuilder).build()__                }__                @Override_                public void onFailure(String source, Exception e) {_                    logger.warn(() -> new ParameterizedMessage("[{}] failed to restore snapshot", snapshotId), e)__                    listener.onFailure(e)__                }__                @Override_                public TimeValue timeout() {_                    return request.masterNodeTimeout()__                }__                @Override_                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                    listener.onResponse(new RestoreCompletionResponse(snapshot, restoreInfo))__                }_            })____        } catch (Exception e) {_            logger.warn(() -> new ParameterizedMessage("[{}] failed to restore snapshot", request.repositoryName + ":" + request.snapshotName), e)__            listener.onFailure(e)__        }_    };restores,snapshot,specified,in,the,restore,request,param,request,restore,request,param,listener,restore,listener;public,void,restore,snapshot,final,restore,request,request,final,action,listener,restore,completion,response,listener,try,repository,repository,repositories,service,repository,request,repository,name,final,repository,data,repository,data,repository,get,repository,data,final,optional,snapshot,id,incompatible,snapshot,id,repository,data,get,incompatible,snapshot,ids,stream,filter,s,request,snapshot,name,equals,s,get,name,find,first,if,incompatible,snapshot,id,is,present,throw,new,snapshot,restore,exception,request,repository,name,request,snapshot,name,cannot,restore,incompatible,snapshot,final,optional,snapshot,id,matching,snapshot,id,repository,data,get,snapshot,ids,stream,filter,s,request,snapshot,name,equals,s,get,name,find,first,if,matching,snapshot,id,is,present,false,throw,new,snapshot,restore,exception,request,repository,name,request,snapshot,name,snapshot,does,not,exist,final,snapshot,id,snapshot,id,matching,snapshot,id,get,final,snapshot,info,snapshot,info,repository,get,snapshot,info,snapshot,id,final,snapshot,snapshot,new,snapshot,request,repository,name,snapshot,id,validate,snapshot,restorable,request,repository,name,snapshot,info,final,list,string,indices,in,snapshot,filter,indices,snapshot,info,indices,request,indices,request,indices,options,final,meta,data,builder,meta,data,builder,if,request,include,global,state,meta,data,builder,meta,data,builder,repository,get,snapshot,global,meta,data,snapshot,id,else,meta,data,builder,meta,data,builder,final,list,index,id,index,ids,in,snapshot,repository,data,resolve,indices,indices,in,snapshot,for,index,id,index,id,index,ids,in,snapshot,meta,data,builder,put,repository,get,snapshot,index,meta,data,snapshot,id,index,id,false,final,meta,data,meta,data,meta,data,builder,build,final,map,string,string,indices,renamed,indices,request,indices,in,snapshot,cluster,service,submit,state,update,task,request,cause,new,cluster,state,update,task,restore,info,restore,info,null,override,public,cluster,state,execute,cluster,state,current,state,restore,in,progress,restore,in,progress,current,state,custom,restore,in,progress,type,if,restore,in,progress,null,restore,in,progress,entries,is,empty,throw,new,concurrent,snapshot,execution,exception,snapshot,restore,process,is,already,running,in,this,cluster,snapshot,deletions,in,progress,deletions,in,progress,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,throw,new,concurrent,snapshot,execution,exception,snapshot,cannot,restore,a,snapshot,while,a,snapshot,deletion,is,in,progress,deletions,in,progress,get,entries,get,0,get,snapshot,cluster,state,builder,builder,cluster,state,builder,current,state,meta,data,builder,md,builder,meta,data,builder,current,state,meta,data,cluster,blocks,builder,blocks,cluster,blocks,builder,blocks,current,state,blocks,routing,table,builder,rt,builder,routing,table,builder,current,state,routing,table,immutable,open,map,shard,id,restore,in,progress,shard,restore,status,shards,set,string,aliases,new,hash,set,if,indices,is,empty,false,immutable,open,map,builder,shard,id,restore,in,progress,shard,restore,status,shards,builder,immutable,open,map,builder,final,version,min,index,compatibility,version,current,state,get,nodes,get,max,node,version,minimum,index,compatibility,version,for,map,entry,string,string,index,entry,indices,entry,set,string,index,index,entry,get,value,boolean,partial,check,partial,index,snapshot,recovery,source,recovery,source,new,snapshot,recovery,source,snapshot,snapshot,info,version,index,string,renamed,index,name,index,entry,get,key,index,meta,data,snapshot,index,meta,data,meta,data,index,index,snapshot,index,meta,data,update,index,settings,snapshot,index,meta,data,request,index,settings,request,ignore,index,settings,try,snapshot,index,meta,data,meta,data,index,upgrade,service,upgrade,index,meta,data,snapshot,index,meta,data,min,index,compatibility,version,catch,exception,ex,throw,new,snapshot,restore,exception,snapshot,cannot,restore,index,index,because,it,cannot,be,upgraded,ex,index,meta,data,current,index,meta,data,current,state,meta,data,index,renamed,index,name,int,set,ignore,shards,new,int,hash,set,final,index,renamed,index,if,current,index,meta,data,null,meta,data,create,index,service,validate,index,name,renamed,index,name,current,state,create,index,service,validate,index,settings,renamed,index,name,snapshot,index,meta,data,get,settings,index,meta,data,builder,index,md,builder,index,meta,data,builder,snapshot,index,meta,data,state,index,meta,data,state,open,index,renamed,index,name,index,md,builder,settings,settings,builder,put,snapshot,index,meta,data,get,settings,put,index,meta,data,uuids,random,base64uuid,if,request,include,aliases,snapshot,index,meta,data,get,aliases,is,empty,index,md,builder,remove,all,aliases,else,for,object,cursor,string,alias,snapshot,index,meta,data,get,aliases,keys,aliases,add,alias,value,index,meta,data,updated,index,meta,data,index,md,builder,build,if,partial,populate,ignored,shards,index,ignore,shards,rt,builder,add,as,new,restore,updated,index,meta,data,recovery,source,ignore,shards,blocks,add,blocks,updated,index,meta,data,md,builder,put,updated,index,meta,data,true,renamed,index,updated,index,meta,data,get,index,else,validate,existing,index,current,index,meta,data,snapshot,index,meta,data,renamed,index,name,partial,index,meta,data,builder,index,md,builder,index,meta,data,builder,snapshot,index,meta,data,state,index,meta,data,state,open,index,md,builder,version,math,max,snapshot,index,meta,data,get,version,current,index,meta,data,get,version,1,if,request,include,aliases,if,snapshot,index,meta,data,get,aliases,is,empty,index,md,builder,remove,all,aliases,for,object,cursor,alias,meta,data,alias,current,index,meta,data,get,aliases,values,index,md,builder,put,alias,alias,value,else,for,object,cursor,string,alias,snapshot,index,meta,data,get,aliases,keys,aliases,add,alias,value,index,md,builder,settings,settings,builder,put,snapshot,index,meta,data,get,settings,put,index,meta,data,current,index,meta,data,get,index,uuid,index,meta,data,updated,index,meta,data,index,md,builder,index,renamed,index,name,build,rt,builder,add,as,restore,updated,index,meta,data,recovery,source,blocks,update,blocks,updated,index,meta,data,md,builder,put,updated,index,meta,data,true,renamed,index,updated,index,meta,data,get,index,for,int,shard,0,shard,snapshot,index,meta,data,get,number,of,shards,shard,if,ignore,shards,contains,shard,shards,builder,put,new,shard,id,renamed,index,shard,new,restore,in,progress,shard,restore,status,cluster,service,state,nodes,get,local,node,id,else,shards,builder,put,new,shard,id,renamed,index,shard,new,restore,in,progress,shard,restore,status,cluster,service,state,nodes,get,local,node,id,restore,in,progress,state,failure,shards,shards,builder,build,restore,in,progress,entry,restore,entry,new,restore,in,progress,entry,snapshot,overall,state,restore,in,progress,state,init,shards,collections,unmodifiable,list,new,array,list,indices,key,set,shards,builder,put,custom,restore,in,progress,type,new,restore,in,progress,restore,entry,else,shards,immutable,open,map,of,check,alias,name,conflicts,indices,aliases,if,request,include,global,state,if,meta,data,persistent,settings,null,settings,settings,meta,data,persistent,settings,cluster,settings,validate,update,settings,md,builder,persistent,settings,settings,if,meta,data,templates,null,for,object,cursor,index,template,meta,data,cursor,meta,data,templates,values,md,builder,put,cursor,value,if,meta,data,customs,null,for,object,object,cursor,string,meta,data,custom,cursor,meta,data,customs,if,repositories,meta,data,type,equals,cursor,key,md,builder,put,custom,cursor,key,cursor,value,if,completed,shards,restore,info,new,restore,info,snapshot,id,get,name,collections,unmodifiable,list,new,array,list,indices,key,set,shards,size,shards,size,failed,shards,shards,routing,table,rt,rt,builder,build,cluster,state,updated,state,builder,meta,data,md,builder,blocks,blocks,routing,table,rt,build,return,allocation,service,reroute,updated,state,restored,snapshot,snapshot,private,void,check,alias,name,conflicts,map,string,string,renamed,indices,set,string,aliases,for,map,entry,string,string,renamed,index,renamed,indices,entry,set,if,aliases,contains,renamed,index,get,key,throw,new,snapshot,restore,exception,snapshot,cannot,rename,index,renamed,index,get,value,into,renamed,index,get,key,because,of,conflict,with,an,alias,with,the,same,name,private,void,populate,ignored,shards,string,index,int,set,ignore,shards,for,snapshot,shard,failure,failure,snapshot,info,shard,failures,if,index,equals,failure,index,ignore,shards,add,failure,shard,id,private,boolean,check,partial,string,index,if,failed,snapshot,info,index,if,request,partial,return,true,else,throw,new,snapshot,restore,exception,snapshot,index,index,wasn,t,fully,snapshotted,cannot,restore,else,return,false,private,void,validate,existing,index,index,meta,data,current,index,meta,data,index,meta,data,snapshot,index,meta,data,string,renamed,index,boolean,partial,if,current,index,meta,data,get,state,index,meta,data,state,close,throw,new,snapshot,restore,exception,snapshot,cannot,restore,index,renamed,index,because,an,open,index,with,same,name,already,exists,in,the,cluster,either,close,or,delete,the,existing,index,or,restore,the,index,under,a,different,name,by,providing,a,rename,pattern,and,replacement,name,if,partial,throw,new,snapshot,restore,exception,snapshot,cannot,restore,partial,index,renamed,index,because,such,index,already,exists,if,current,index,meta,data,get,number,of,shards,snapshot,index,meta,data,get,number,of,shards,throw,new,snapshot,restore,exception,snapshot,cannot,restore,index,renamed,index,with,current,index,meta,data,get,number,of,shards,shards,from,a,snapshot,of,index,snapshot,index,meta,data,get,index,get,name,with,snapshot,index,meta,data,get,number,of,shards,shards,private,index,meta,data,update,index,settings,index,meta,data,index,meta,data,settings,change,settings,string,ignore,settings,if,change,settings,names,is,empty,ignore,settings,length,0,return,index,meta,data,settings,normalized,change,settings,settings,builder,put,change,settings,normalize,prefix,index,meta,data,build,index,meta,data,builder,builder,index,meta,data,builder,index,meta,data,settings,settings,index,meta,data,get,settings,set,string,key,filters,new,hash,set,list,string,simple,match,patterns,new,array,list,for,string,ignored,setting,ignore,settings,if,regex,is,simple,match,pattern,ignored,setting,if,contains,ignored,setting,throw,new,snapshot,restore,exception,snapshot,cannot,remove,setting,ignored,setting,on,restore,else,key,filters,add,ignored,setting,else,simple,match,patterns,add,ignored,setting,predicate,string,settings,filter,k,if,contains,k,false,for,string,filter,key,key,filters,if,k,equals,filter,key,return,false,for,string,pattern,simple,match,patterns,if,regex,simple,match,pattern,k,return,false,return,true,settings,builder,settings,builder,settings,builder,put,settings,filter,settings,filter,put,normalized,change,settings,filter,k,if,contains,k,throw,new,snapshot,restore,exception,snapshot,cannot,modify,setting,k,on,restore,else,return,true,return,builder,settings,settings,builder,build,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,restore,snapshot,snapshot,id,e,listener,on,failure,e,override,public,time,value,timeout,return,request,master,node,timeout,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,listener,on,response,new,restore,completion,response,snapshot,restore,info,catch,exception,e,logger,warn,new,parameterized,message,failed,to,restore,snapshot,request,repository,name,request,snapshot,name,e,listener,on,failure,e
RestoreService -> public void restoreSnapshot(final RestoreRequest request, final ActionListener<RestoreCompletionResponse> listener);1535405719;Restores snapshot specified in the restore request.__@param request  restore request_@param listener restore listener;public void restoreSnapshot(final RestoreRequest request, final ActionListener<RestoreCompletionResponse> listener) {_        try {_            _            Repository repository = repositoriesService.repository(request.repositoryName)__            final RepositoryData repositoryData = repository.getRepositoryData()__            final Optional<SnapshotId> incompatibleSnapshotId =_                repositoryData.getIncompatibleSnapshotIds().stream().filter(s -> request.snapshotName.equals(s.getName())).findFirst()__            if (incompatibleSnapshotId.isPresent()) {_                throw new SnapshotRestoreException(request.repositoryName, request.snapshotName, "cannot restore incompatible snapshot")__            }_            final Optional<SnapshotId> matchingSnapshotId = repositoryData.getSnapshotIds().stream()_                .filter(s -> request.snapshotName.equals(s.getName())).findFirst()__            if (matchingSnapshotId.isPresent() == false) {_                throw new SnapshotRestoreException(request.repositoryName, request.snapshotName, "snapshot does not exist")__            }__            final SnapshotId snapshotId = matchingSnapshotId.get()__            final SnapshotInfo snapshotInfo = repository.getSnapshotInfo(snapshotId)__            final Snapshot snapshot = new Snapshot(request.repositoryName, snapshotId)___            _            validateSnapshotRestorable(request.repositoryName, snapshotInfo)___            _            final List<String> indicesInSnapshot = filterIndices(snapshotInfo.indices(), request.indices(), request.indicesOptions())___            final MetaData.Builder metaDataBuilder__            if (request.includeGlobalState()) {_                metaDataBuilder = MetaData.builder(repository.getSnapshotGlobalMetaData(snapshotId))__            } else {_                metaDataBuilder = MetaData.builder()__            }__            final List<IndexId> indexIdsInSnapshot = repositoryData.resolveIndices(indicesInSnapshot)__            for (IndexId indexId : indexIdsInSnapshot) {_                metaDataBuilder.put(repository.getSnapshotIndexMetaData(snapshotId, indexId), false)__            }__            final MetaData metaData = metaDataBuilder.build()___            _            _            final Map<String, String> indices = renamedIndices(request, indicesInSnapshot)___            _            _            clusterService.submitStateUpdateTask(request.cause(), new ClusterStateUpdateTask() {_                RestoreInfo restoreInfo = null___                @Override_                public ClusterState execute(ClusterState currentState) {_                    _                    _                    RestoreInProgress restoreInProgress = currentState.custom(RestoreInProgress.TYPE)__                    if (restoreInProgress != null && !restoreInProgress.entries().isEmpty()) {_                        throw new ConcurrentSnapshotExecutionException(snapshot, "Restore process is already running in this cluster")__                    }_                    _                    SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                    if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                        throw new ConcurrentSnapshotExecutionException(snapshot,_                            "cannot restore a snapshot while a snapshot deletion is in-progress [" +_                                deletionsInProgress.getEntries().get(0).getSnapshot() + "]")__                    }__                    _                    ClusterState.Builder builder = ClusterState.builder(currentState)__                    MetaData.Builder mdBuilder = MetaData.builder(currentState.metaData())__                    ClusterBlocks.Builder blocks = ClusterBlocks.builder().blocks(currentState.blocks())__                    RoutingTable.Builder rtBuilder = RoutingTable.builder(currentState.routingTable())__                    ImmutableOpenMap<ShardId, RestoreInProgress.ShardRestoreStatus> shards__                    Set<String> aliases = new HashSet<>()___                    if (indices.isEmpty() == false) {_                        _                        ImmutableOpenMap.Builder<ShardId, RestoreInProgress.ShardRestoreStatus> shardsBuilder = ImmutableOpenMap.builder()__                        final Version minIndexCompatibilityVersion = currentState.getNodes().getMaxNodeVersion()_                            .minimumIndexCompatibilityVersion()__                        for (Map.Entry<String, String> indexEntry : indices.entrySet()) {_                            String index = indexEntry.getValue()__                            boolean partial = checkPartial(index)__                            SnapshotRecoverySource recoverySource = new SnapshotRecoverySource(snapshot, snapshotInfo.version(), index)__                            String renamedIndexName = indexEntry.getKey()__                            IndexMetaData snapshotIndexMetaData = metaData.index(index)__                            snapshotIndexMetaData = updateIndexSettings(snapshotIndexMetaData, request.indexSettings, request.ignoreIndexSettings)__                            try {_                                snapshotIndexMetaData = metaDataIndexUpgradeService.upgradeIndexMetaData(snapshotIndexMetaData,_                                    minIndexCompatibilityVersion)__                            } catch (Exception ex) {_                                throw new SnapshotRestoreException(snapshot, "cannot restore index [" + index + "] because it cannot be upgraded", ex)__                            }_                            _                            IndexMetaData currentIndexMetaData = currentState.metaData().index(renamedIndexName)__                            IntSet ignoreShards = new IntHashSet()__                            final Index renamedIndex__                            if (currentIndexMetaData == null) {_                                _                                _                                MetaDataCreateIndexService.validateIndexName(renamedIndexName, currentState)__                                createIndexService.validateIndexSettings(renamedIndexName, snapshotIndexMetaData.getSettings())__                                IndexMetaData.Builder indexMdBuilder = IndexMetaData.builder(snapshotIndexMetaData).state(IndexMetaData.State.OPEN).index(renamedIndexName)__                                indexMdBuilder.settings(Settings.builder().put(snapshotIndexMetaData.getSettings()).put(IndexMetaData.SETTING_INDEX_UUID, UUIDs.randomBase64UUID()))__                                if (!request.includeAliases() && !snapshotIndexMetaData.getAliases().isEmpty()) {_                                    _                                    indexMdBuilder.removeAllAliases()__                                } else {_                                    for (ObjectCursor<String> alias : snapshotIndexMetaData.getAliases().keys()) {_                                        aliases.add(alias.value)__                                    }_                                }_                                IndexMetaData updatedIndexMetaData = indexMdBuilder.build()__                                if (partial) {_                                    populateIgnoredShards(index, ignoreShards)__                                }_                                rtBuilder.addAsNewRestore(updatedIndexMetaData, recoverySource, ignoreShards)__                                blocks.addBlocks(updatedIndexMetaData)__                                mdBuilder.put(updatedIndexMetaData, true)__                                renamedIndex = updatedIndexMetaData.getIndex()__                            } else {_                                validateExistingIndex(currentIndexMetaData, snapshotIndexMetaData, renamedIndexName, partial)__                                _                                IndexMetaData.Builder indexMdBuilder = IndexMetaData.builder(snapshotIndexMetaData).state(IndexMetaData.State.OPEN)__                                indexMdBuilder.version(Math.max(snapshotIndexMetaData.getVersion(), currentIndexMetaData.getVersion() + 1))__                                indexMdBuilder.mappingVersion(Math.max(snapshotIndexMetaData.getMappingVersion(), currentIndexMetaData.getMappingVersion() + 1))__                                if (!request.includeAliases()) {_                                    _                                    if (!snapshotIndexMetaData.getAliases().isEmpty()) {_                                        indexMdBuilder.removeAllAliases()__                                    }_                                    _                                    for (ObjectCursor<AliasMetaData> alias : currentIndexMetaData.getAliases().values()) {_                                        indexMdBuilder.putAlias(alias.value)__                                    }_                                } else {_                                    for (ObjectCursor<String> alias : snapshotIndexMetaData.getAliases().keys()) {_                                        aliases.add(alias.value)__                                    }_                                }_                                indexMdBuilder.settings(Settings.builder().put(snapshotIndexMetaData.getSettings()).put(IndexMetaData.SETTING_INDEX_UUID, currentIndexMetaData.getIndexUUID()))__                                IndexMetaData updatedIndexMetaData = indexMdBuilder.index(renamedIndexName).build()__                                rtBuilder.addAsRestore(updatedIndexMetaData, recoverySource)__                                blocks.updateBlocks(updatedIndexMetaData)__                                mdBuilder.put(updatedIndexMetaData, true)__                                renamedIndex = updatedIndexMetaData.getIndex()__                            }__                            for (int shard = 0_ shard < snapshotIndexMetaData.getNumberOfShards()_ shard++) {_                                if (!ignoreShards.contains(shard)) {_                                    shardsBuilder.put(new ShardId(renamedIndex, shard), new RestoreInProgress.ShardRestoreStatus(clusterService.state().nodes().getLocalNodeId()))__                                } else {_                                    shardsBuilder.put(new ShardId(renamedIndex, shard), new RestoreInProgress.ShardRestoreStatus(clusterService.state().nodes().getLocalNodeId(), RestoreInProgress.State.FAILURE))__                                }_                            }_                        }__                        shards = shardsBuilder.build()__                        RestoreInProgress.Entry restoreEntry = new RestoreInProgress.Entry(snapshot, overallState(RestoreInProgress.State.INIT, shards), Collections.unmodifiableList(new ArrayList<>(indices.keySet())), shards)__                        builder.putCustom(RestoreInProgress.TYPE, new RestoreInProgress(restoreEntry))__                    } else {_                        shards = ImmutableOpenMap.of()__                    }__                    checkAliasNameConflicts(indices, aliases)___                    _                    if (request.includeGlobalState()) {_                        if (metaData.persistentSettings() != null) {_                            Settings settings = metaData.persistentSettings()__                            clusterSettings.validateUpdate(settings)__                            mdBuilder.persistentSettings(settings)__                        }_                        if (metaData.templates() != null) {_                            _                            for (ObjectCursor<IndexTemplateMetaData> cursor : metaData.templates().values()) {_                                mdBuilder.put(cursor.value)__                            }_                        }_                        if (metaData.customs() != null) {_                            for (ObjectObjectCursor<String, MetaData.Custom> cursor : metaData.customs()) {_                                if (!RepositoriesMetaData.TYPE.equals(cursor.key)) {_                                    _                                    _                                    mdBuilder.putCustom(cursor.key, cursor.value)__                                }_                            }_                        }_                    }__                    if (completed(shards)) {_                        _                        restoreInfo = new RestoreInfo(snapshotId.getName(),_                                                      Collections.unmodifiableList(new ArrayList<>(indices.keySet())),_                                                      shards.size(),_                                                      shards.size() - failedShards(shards))__                    }__                    RoutingTable rt = rtBuilder.build()__                    ClusterState updatedState = builder.metaData(mdBuilder).blocks(blocks).routingTable(rt).build()__                    return allocationService.reroute(updatedState, "restored snapshot [" + snapshot + "]")__                }__                private void checkAliasNameConflicts(Map<String, String> renamedIndices, Set<String> aliases) {_                    for (Map.Entry<String, String> renamedIndex : renamedIndices.entrySet()) {_                        if (aliases.contains(renamedIndex.getKey())) {_                            throw new SnapshotRestoreException(snapshot, "cannot rename index [" + renamedIndex.getValue() + "] into [" + renamedIndex.getKey() + "] because of conflict with an alias with the same name")__                        }_                    }_                }__                private void populateIgnoredShards(String index, IntSet ignoreShards) {_                    for (SnapshotShardFailure failure : snapshotInfo.shardFailures()) {_                        if (index.equals(failure.index())) {_                            ignoreShards.add(failure.shardId())__                        }_                    }_                }__                private boolean checkPartial(String index) {_                    _                    if (failed(snapshotInfo, index)) {_                        if (request.partial()) {_                            return true__                        } else {_                            throw new SnapshotRestoreException(snapshot, "index [" + index + "] wasn't fully snapshotted - cannot restore")__                        }_                    } else {_                        return false__                    }_                }__                private void validateExistingIndex(IndexMetaData currentIndexMetaData, IndexMetaData snapshotIndexMetaData, String renamedIndex, boolean partial) {_                    _                    if (currentIndexMetaData.getState() != IndexMetaData.State.CLOSE) {_                        _                        throw new SnapshotRestoreException(snapshot, "cannot restore index [" + renamedIndex + "] because an open index with same name already exists in the cluster. " +_                            "Either close or delete the existing index or restore the index under a different name by providing a rename pattern and replacement name")__                    }_                    _                    if (partial) {_                        throw new SnapshotRestoreException(snapshot, "cannot restore partial index [" + renamedIndex + "] because such index already exists")__                    }_                    _                    if (currentIndexMetaData.getNumberOfShards() != snapshotIndexMetaData.getNumberOfShards()) {_                        throw new SnapshotRestoreException(snapshot, "cannot restore index [" + renamedIndex + "] with [" + currentIndexMetaData.getNumberOfShards() +_                                "] shards from a snapshot of index [" + snapshotIndexMetaData.getIndex().getName() + "] with [" + snapshotIndexMetaData.getNumberOfShards() + "] shards")__                    }_                }__                _                private IndexMetaData updateIndexSettings(IndexMetaData indexMetaData, Settings changeSettings, String[] ignoreSettings) {_                    if (changeSettings.names().isEmpty() && ignoreSettings.length == 0) {_                        return indexMetaData__                    }_                    Settings normalizedChangeSettings = Settings.builder().put(changeSettings).normalizePrefix(IndexMetaData.INDEX_SETTING_PREFIX).build()__                    IndexMetaData.Builder builder = IndexMetaData.builder(indexMetaData)__                    Settings settings = indexMetaData.getSettings()__                    Set<String> keyFilters = new HashSet<>()__                    List<String> simpleMatchPatterns = new ArrayList<>()__                    for (String ignoredSetting : ignoreSettings) {_                        if (!Regex.isSimpleMatchPattern(ignoredSetting)) {_                            if (UNREMOVABLE_SETTINGS.contains(ignoredSetting)) {_                                throw new SnapshotRestoreException(snapshot, "cannot remove setting [" + ignoredSetting + "] on restore")__                            } else {_                                keyFilters.add(ignoredSetting)__                            }_                        } else {_                            simpleMatchPatterns.add(ignoredSetting)__                        }_                    }_                    Predicate<String> settingsFilter = k -> {_                        if (UNREMOVABLE_SETTINGS.contains(k) == false) {_                            for (String filterKey : keyFilters) {_                                if (k.equals(filterKey)) {_                                    return false__                                }_                            }_                            for (String pattern : simpleMatchPatterns) {_                                if (Regex.simpleMatch(pattern, k)) {_                                    return false__                                }_                            }_                        }_                        return true__                    }__                    Settings.Builder settingsBuilder = Settings.builder()_                        .put(settings.filter(settingsFilter))_                        .put(normalizedChangeSettings.filter(k -> {_                            if (UNMODIFIABLE_SETTINGS.contains(k)) {_                                throw new SnapshotRestoreException(snapshot, "cannot modify setting [" + k + "] on restore")__                            } else {_                                return true__                            }_                        }))__                    return builder.settings(settingsBuilder).build()__                }__                @Override_                public void onFailure(String source, Exception e) {_                    logger.warn(() -> new ParameterizedMessage("[{}] failed to restore snapshot", snapshotId), e)__                    listener.onFailure(e)__                }__                @Override_                public TimeValue timeout() {_                    return request.masterNodeTimeout()__                }__                @Override_                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                    listener.onResponse(new RestoreCompletionResponse(snapshot, restoreInfo))__                }_            })____        } catch (Exception e) {_            logger.warn(() -> new ParameterizedMessage("[{}] failed to restore snapshot", request.repositoryName + ":" + request.snapshotName), e)__            listener.onFailure(e)__        }_    };restores,snapshot,specified,in,the,restore,request,param,request,restore,request,param,listener,restore,listener;public,void,restore,snapshot,final,restore,request,request,final,action,listener,restore,completion,response,listener,try,repository,repository,repositories,service,repository,request,repository,name,final,repository,data,repository,data,repository,get,repository,data,final,optional,snapshot,id,incompatible,snapshot,id,repository,data,get,incompatible,snapshot,ids,stream,filter,s,request,snapshot,name,equals,s,get,name,find,first,if,incompatible,snapshot,id,is,present,throw,new,snapshot,restore,exception,request,repository,name,request,snapshot,name,cannot,restore,incompatible,snapshot,final,optional,snapshot,id,matching,snapshot,id,repository,data,get,snapshot,ids,stream,filter,s,request,snapshot,name,equals,s,get,name,find,first,if,matching,snapshot,id,is,present,false,throw,new,snapshot,restore,exception,request,repository,name,request,snapshot,name,snapshot,does,not,exist,final,snapshot,id,snapshot,id,matching,snapshot,id,get,final,snapshot,info,snapshot,info,repository,get,snapshot,info,snapshot,id,final,snapshot,snapshot,new,snapshot,request,repository,name,snapshot,id,validate,snapshot,restorable,request,repository,name,snapshot,info,final,list,string,indices,in,snapshot,filter,indices,snapshot,info,indices,request,indices,request,indices,options,final,meta,data,builder,meta,data,builder,if,request,include,global,state,meta,data,builder,meta,data,builder,repository,get,snapshot,global,meta,data,snapshot,id,else,meta,data,builder,meta,data,builder,final,list,index,id,index,ids,in,snapshot,repository,data,resolve,indices,indices,in,snapshot,for,index,id,index,id,index,ids,in,snapshot,meta,data,builder,put,repository,get,snapshot,index,meta,data,snapshot,id,index,id,false,final,meta,data,meta,data,meta,data,builder,build,final,map,string,string,indices,renamed,indices,request,indices,in,snapshot,cluster,service,submit,state,update,task,request,cause,new,cluster,state,update,task,restore,info,restore,info,null,override,public,cluster,state,execute,cluster,state,current,state,restore,in,progress,restore,in,progress,current,state,custom,restore,in,progress,type,if,restore,in,progress,null,restore,in,progress,entries,is,empty,throw,new,concurrent,snapshot,execution,exception,snapshot,restore,process,is,already,running,in,this,cluster,snapshot,deletions,in,progress,deletions,in,progress,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,throw,new,concurrent,snapshot,execution,exception,snapshot,cannot,restore,a,snapshot,while,a,snapshot,deletion,is,in,progress,deletions,in,progress,get,entries,get,0,get,snapshot,cluster,state,builder,builder,cluster,state,builder,current,state,meta,data,builder,md,builder,meta,data,builder,current,state,meta,data,cluster,blocks,builder,blocks,cluster,blocks,builder,blocks,current,state,blocks,routing,table,builder,rt,builder,routing,table,builder,current,state,routing,table,immutable,open,map,shard,id,restore,in,progress,shard,restore,status,shards,set,string,aliases,new,hash,set,if,indices,is,empty,false,immutable,open,map,builder,shard,id,restore,in,progress,shard,restore,status,shards,builder,immutable,open,map,builder,final,version,min,index,compatibility,version,current,state,get,nodes,get,max,node,version,minimum,index,compatibility,version,for,map,entry,string,string,index,entry,indices,entry,set,string,index,index,entry,get,value,boolean,partial,check,partial,index,snapshot,recovery,source,recovery,source,new,snapshot,recovery,source,snapshot,snapshot,info,version,index,string,renamed,index,name,index,entry,get,key,index,meta,data,snapshot,index,meta,data,meta,data,index,index,snapshot,index,meta,data,update,index,settings,snapshot,index,meta,data,request,index,settings,request,ignore,index,settings,try,snapshot,index,meta,data,meta,data,index,upgrade,service,upgrade,index,meta,data,snapshot,index,meta,data,min,index,compatibility,version,catch,exception,ex,throw,new,snapshot,restore,exception,snapshot,cannot,restore,index,index,because,it,cannot,be,upgraded,ex,index,meta,data,current,index,meta,data,current,state,meta,data,index,renamed,index,name,int,set,ignore,shards,new,int,hash,set,final,index,renamed,index,if,current,index,meta,data,null,meta,data,create,index,service,validate,index,name,renamed,index,name,current,state,create,index,service,validate,index,settings,renamed,index,name,snapshot,index,meta,data,get,settings,index,meta,data,builder,index,md,builder,index,meta,data,builder,snapshot,index,meta,data,state,index,meta,data,state,open,index,renamed,index,name,index,md,builder,settings,settings,builder,put,snapshot,index,meta,data,get,settings,put,index,meta,data,uuids,random,base64uuid,if,request,include,aliases,snapshot,index,meta,data,get,aliases,is,empty,index,md,builder,remove,all,aliases,else,for,object,cursor,string,alias,snapshot,index,meta,data,get,aliases,keys,aliases,add,alias,value,index,meta,data,updated,index,meta,data,index,md,builder,build,if,partial,populate,ignored,shards,index,ignore,shards,rt,builder,add,as,new,restore,updated,index,meta,data,recovery,source,ignore,shards,blocks,add,blocks,updated,index,meta,data,md,builder,put,updated,index,meta,data,true,renamed,index,updated,index,meta,data,get,index,else,validate,existing,index,current,index,meta,data,snapshot,index,meta,data,renamed,index,name,partial,index,meta,data,builder,index,md,builder,index,meta,data,builder,snapshot,index,meta,data,state,index,meta,data,state,open,index,md,builder,version,math,max,snapshot,index,meta,data,get,version,current,index,meta,data,get,version,1,index,md,builder,mapping,version,math,max,snapshot,index,meta,data,get,mapping,version,current,index,meta,data,get,mapping,version,1,if,request,include,aliases,if,snapshot,index,meta,data,get,aliases,is,empty,index,md,builder,remove,all,aliases,for,object,cursor,alias,meta,data,alias,current,index,meta,data,get,aliases,values,index,md,builder,put,alias,alias,value,else,for,object,cursor,string,alias,snapshot,index,meta,data,get,aliases,keys,aliases,add,alias,value,index,md,builder,settings,settings,builder,put,snapshot,index,meta,data,get,settings,put,index,meta,data,current,index,meta,data,get,index,uuid,index,meta,data,updated,index,meta,data,index,md,builder,index,renamed,index,name,build,rt,builder,add,as,restore,updated,index,meta,data,recovery,source,blocks,update,blocks,updated,index,meta,data,md,builder,put,updated,index,meta,data,true,renamed,index,updated,index,meta,data,get,index,for,int,shard,0,shard,snapshot,index,meta,data,get,number,of,shards,shard,if,ignore,shards,contains,shard,shards,builder,put,new,shard,id,renamed,index,shard,new,restore,in,progress,shard,restore,status,cluster,service,state,nodes,get,local,node,id,else,shards,builder,put,new,shard,id,renamed,index,shard,new,restore,in,progress,shard,restore,status,cluster,service,state,nodes,get,local,node,id,restore,in,progress,state,failure,shards,shards,builder,build,restore,in,progress,entry,restore,entry,new,restore,in,progress,entry,snapshot,overall,state,restore,in,progress,state,init,shards,collections,unmodifiable,list,new,array,list,indices,key,set,shards,builder,put,custom,restore,in,progress,type,new,restore,in,progress,restore,entry,else,shards,immutable,open,map,of,check,alias,name,conflicts,indices,aliases,if,request,include,global,state,if,meta,data,persistent,settings,null,settings,settings,meta,data,persistent,settings,cluster,settings,validate,update,settings,md,builder,persistent,settings,settings,if,meta,data,templates,null,for,object,cursor,index,template,meta,data,cursor,meta,data,templates,values,md,builder,put,cursor,value,if,meta,data,customs,null,for,object,object,cursor,string,meta,data,custom,cursor,meta,data,customs,if,repositories,meta,data,type,equals,cursor,key,md,builder,put,custom,cursor,key,cursor,value,if,completed,shards,restore,info,new,restore,info,snapshot,id,get,name,collections,unmodifiable,list,new,array,list,indices,key,set,shards,size,shards,size,failed,shards,shards,routing,table,rt,rt,builder,build,cluster,state,updated,state,builder,meta,data,md,builder,blocks,blocks,routing,table,rt,build,return,allocation,service,reroute,updated,state,restored,snapshot,snapshot,private,void,check,alias,name,conflicts,map,string,string,renamed,indices,set,string,aliases,for,map,entry,string,string,renamed,index,renamed,indices,entry,set,if,aliases,contains,renamed,index,get,key,throw,new,snapshot,restore,exception,snapshot,cannot,rename,index,renamed,index,get,value,into,renamed,index,get,key,because,of,conflict,with,an,alias,with,the,same,name,private,void,populate,ignored,shards,string,index,int,set,ignore,shards,for,snapshot,shard,failure,failure,snapshot,info,shard,failures,if,index,equals,failure,index,ignore,shards,add,failure,shard,id,private,boolean,check,partial,string,index,if,failed,snapshot,info,index,if,request,partial,return,true,else,throw,new,snapshot,restore,exception,snapshot,index,index,wasn,t,fully,snapshotted,cannot,restore,else,return,false,private,void,validate,existing,index,index,meta,data,current,index,meta,data,index,meta,data,snapshot,index,meta,data,string,renamed,index,boolean,partial,if,current,index,meta,data,get,state,index,meta,data,state,close,throw,new,snapshot,restore,exception,snapshot,cannot,restore,index,renamed,index,because,an,open,index,with,same,name,already,exists,in,the,cluster,either,close,or,delete,the,existing,index,or,restore,the,index,under,a,different,name,by,providing,a,rename,pattern,and,replacement,name,if,partial,throw,new,snapshot,restore,exception,snapshot,cannot,restore,partial,index,renamed,index,because,such,index,already,exists,if,current,index,meta,data,get,number,of,shards,snapshot,index,meta,data,get,number,of,shards,throw,new,snapshot,restore,exception,snapshot,cannot,restore,index,renamed,index,with,current,index,meta,data,get,number,of,shards,shards,from,a,snapshot,of,index,snapshot,index,meta,data,get,index,get,name,with,snapshot,index,meta,data,get,number,of,shards,shards,private,index,meta,data,update,index,settings,index,meta,data,index,meta,data,settings,change,settings,string,ignore,settings,if,change,settings,names,is,empty,ignore,settings,length,0,return,index,meta,data,settings,normalized,change,settings,settings,builder,put,change,settings,normalize,prefix,index,meta,data,build,index,meta,data,builder,builder,index,meta,data,builder,index,meta,data,settings,settings,index,meta,data,get,settings,set,string,key,filters,new,hash,set,list,string,simple,match,patterns,new,array,list,for,string,ignored,setting,ignore,settings,if,regex,is,simple,match,pattern,ignored,setting,if,contains,ignored,setting,throw,new,snapshot,restore,exception,snapshot,cannot,remove,setting,ignored,setting,on,restore,else,key,filters,add,ignored,setting,else,simple,match,patterns,add,ignored,setting,predicate,string,settings,filter,k,if,contains,k,false,for,string,filter,key,key,filters,if,k,equals,filter,key,return,false,for,string,pattern,simple,match,patterns,if,regex,simple,match,pattern,k,return,false,return,true,settings,builder,settings,builder,settings,builder,put,settings,filter,settings,filter,put,normalized,change,settings,filter,k,if,contains,k,throw,new,snapshot,restore,exception,snapshot,cannot,modify,setting,k,on,restore,else,return,true,return,builder,settings,settings,builder,build,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,restore,snapshot,snapshot,id,e,listener,on,failure,e,override,public,time,value,timeout,return,request,master,node,timeout,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,listener,on,response,new,restore,completion,response,snapshot,restore,info,catch,exception,e,logger,warn,new,parameterized,message,failed,to,restore,snapshot,request,repository,name,request,snapshot,name,e,listener,on,failure,e
RestoreService -> public void restoreSnapshot(final RestoreRequest request, final ActionListener<RestoreCompletionResponse> listener);1535723122;Restores snapshot specified in the restore request.__@param request  restore request_@param listener restore listener;public void restoreSnapshot(final RestoreRequest request, final ActionListener<RestoreCompletionResponse> listener) {_        try {_            _            Repository repository = repositoriesService.repository(request.repositoryName)__            final RepositoryData repositoryData = repository.getRepositoryData()__            final Optional<SnapshotId> incompatibleSnapshotId =_                repositoryData.getIncompatibleSnapshotIds().stream().filter(s -> request.snapshotName.equals(s.getName())).findFirst()__            if (incompatibleSnapshotId.isPresent()) {_                throw new SnapshotRestoreException(request.repositoryName, request.snapshotName, "cannot restore incompatible snapshot")__            }_            final Optional<SnapshotId> matchingSnapshotId = repositoryData.getSnapshotIds().stream()_                .filter(s -> request.snapshotName.equals(s.getName())).findFirst()__            if (matchingSnapshotId.isPresent() == false) {_                throw new SnapshotRestoreException(request.repositoryName, request.snapshotName, "snapshot does not exist")__            }__            final SnapshotId snapshotId = matchingSnapshotId.get()__            final SnapshotInfo snapshotInfo = repository.getSnapshotInfo(snapshotId)__            final Snapshot snapshot = new Snapshot(request.repositoryName, snapshotId)___            _            validateSnapshotRestorable(request.repositoryName, snapshotInfo)___            _            final List<String> indicesInSnapshot = filterIndices(snapshotInfo.indices(), request.indices(), request.indicesOptions())___            final MetaData.Builder metaDataBuilder__            if (request.includeGlobalState()) {_                metaDataBuilder = MetaData.builder(repository.getSnapshotGlobalMetaData(snapshotId))__            } else {_                metaDataBuilder = MetaData.builder()__            }__            final List<IndexId> indexIdsInSnapshot = repositoryData.resolveIndices(indicesInSnapshot)__            for (IndexId indexId : indexIdsInSnapshot) {_                metaDataBuilder.put(repository.getSnapshotIndexMetaData(snapshotId, indexId), false)__            }__            final MetaData metaData = metaDataBuilder.build()___            _            _            final Map<String, String> indices = renamedIndices(request, indicesInSnapshot)___            _            _            clusterService.submitStateUpdateTask(request.cause(), new ClusterStateUpdateTask() {_                RestoreInfo restoreInfo = null___                @Override_                public ClusterState execute(ClusterState currentState) {_                    _                    _                    RestoreInProgress restoreInProgress = currentState.custom(RestoreInProgress.TYPE)__                    if (restoreInProgress != null && !restoreInProgress.entries().isEmpty()) {_                        throw new ConcurrentSnapshotExecutionException(snapshot, "Restore process is already running in this cluster")__                    }_                    _                    SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                    if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                        throw new ConcurrentSnapshotExecutionException(snapshot,_                            "cannot restore a snapshot while a snapshot deletion is in-progress [" +_                                deletionsInProgress.getEntries().get(0).getSnapshot() + "]")__                    }__                    _                    ClusterState.Builder builder = ClusterState.builder(currentState)__                    MetaData.Builder mdBuilder = MetaData.builder(currentState.metaData())__                    ClusterBlocks.Builder blocks = ClusterBlocks.builder().blocks(currentState.blocks())__                    RoutingTable.Builder rtBuilder = RoutingTable.builder(currentState.routingTable())__                    ImmutableOpenMap<ShardId, RestoreInProgress.ShardRestoreStatus> shards__                    Set<String> aliases = new HashSet<>()___                    if (indices.isEmpty() == false) {_                        _                        ImmutableOpenMap.Builder<ShardId, RestoreInProgress.ShardRestoreStatus> shardsBuilder = ImmutableOpenMap.builder()__                        final Version minIndexCompatibilityVersion = currentState.getNodes().getMaxNodeVersion()_                            .minimumIndexCompatibilityVersion()__                        for (Map.Entry<String, String> indexEntry : indices.entrySet()) {_                            String index = indexEntry.getValue()__                            boolean partial = checkPartial(index)__                            SnapshotRecoverySource recoverySource = new SnapshotRecoverySource(snapshot, snapshotInfo.version(), index)__                            String renamedIndexName = indexEntry.getKey()__                            IndexMetaData snapshotIndexMetaData = metaData.index(index)__                            snapshotIndexMetaData = updateIndexSettings(snapshotIndexMetaData, request.indexSettings, request.ignoreIndexSettings)__                            try {_                                snapshotIndexMetaData = metaDataIndexUpgradeService.upgradeIndexMetaData(snapshotIndexMetaData,_                                    minIndexCompatibilityVersion)__                            } catch (Exception ex) {_                                throw new SnapshotRestoreException(snapshot, "cannot restore index [" + index + "] because it cannot be upgraded", ex)__                            }_                            _                            IndexMetaData currentIndexMetaData = currentState.metaData().index(renamedIndexName)__                            IntSet ignoreShards = new IntHashSet()__                            final Index renamedIndex__                            if (currentIndexMetaData == null) {_                                _                                _                                MetaDataCreateIndexService.validateIndexName(renamedIndexName, currentState)__                                createIndexService.validateIndexSettings(renamedIndexName, snapshotIndexMetaData.getSettings())__                                IndexMetaData.Builder indexMdBuilder = IndexMetaData.builder(snapshotIndexMetaData).state(IndexMetaData.State.OPEN).index(renamedIndexName)__                                indexMdBuilder.settings(Settings.builder().put(snapshotIndexMetaData.getSettings()).put(IndexMetaData.SETTING_INDEX_UUID, UUIDs.randomBase64UUID()))__                                if (!request.includeAliases() && !snapshotIndexMetaData.getAliases().isEmpty()) {_                                    _                                    indexMdBuilder.removeAllAliases()__                                } else {_                                    for (ObjectCursor<String> alias : snapshotIndexMetaData.getAliases().keys()) {_                                        aliases.add(alias.value)__                                    }_                                }_                                IndexMetaData updatedIndexMetaData = indexMdBuilder.build()__                                if (partial) {_                                    populateIgnoredShards(index, ignoreShards)__                                }_                                rtBuilder.addAsNewRestore(updatedIndexMetaData, recoverySource, ignoreShards)__                                blocks.addBlocks(updatedIndexMetaData)__                                mdBuilder.put(updatedIndexMetaData, true)__                                renamedIndex = updatedIndexMetaData.getIndex()__                            } else {_                                validateExistingIndex(currentIndexMetaData, snapshotIndexMetaData, renamedIndexName, partial)__                                _                                IndexMetaData.Builder indexMdBuilder = IndexMetaData.builder(snapshotIndexMetaData).state(IndexMetaData.State.OPEN)__                                indexMdBuilder.version(Math.max(snapshotIndexMetaData.getVersion(), currentIndexMetaData.getVersion() + 1))__                                indexMdBuilder.mappingVersion(Math.max(snapshotIndexMetaData.getMappingVersion(), currentIndexMetaData.getMappingVersion() + 1))__                                if (!request.includeAliases()) {_                                    _                                    if (!snapshotIndexMetaData.getAliases().isEmpty()) {_                                        indexMdBuilder.removeAllAliases()__                                    }_                                    _                                    for (ObjectCursor<AliasMetaData> alias : currentIndexMetaData.getAliases().values()) {_                                        indexMdBuilder.putAlias(alias.value)__                                    }_                                } else {_                                    for (ObjectCursor<String> alias : snapshotIndexMetaData.getAliases().keys()) {_                                        aliases.add(alias.value)__                                    }_                                }_                                indexMdBuilder.settings(Settings.builder().put(snapshotIndexMetaData.getSettings()).put(IndexMetaData.SETTING_INDEX_UUID, currentIndexMetaData.getIndexUUID()))__                                IndexMetaData updatedIndexMetaData = indexMdBuilder.index(renamedIndexName).build()__                                rtBuilder.addAsRestore(updatedIndexMetaData, recoverySource)__                                blocks.updateBlocks(updatedIndexMetaData)__                                mdBuilder.put(updatedIndexMetaData, true)__                                renamedIndex = updatedIndexMetaData.getIndex()__                            }__                            for (int shard = 0_ shard < snapshotIndexMetaData.getNumberOfShards()_ shard++) {_                                if (!ignoreShards.contains(shard)) {_                                    shardsBuilder.put(new ShardId(renamedIndex, shard), new RestoreInProgress.ShardRestoreStatus(clusterService.state().nodes().getLocalNodeId()))__                                } else {_                                    shardsBuilder.put(new ShardId(renamedIndex, shard), new RestoreInProgress.ShardRestoreStatus(clusterService.state().nodes().getLocalNodeId(), RestoreInProgress.State.FAILURE))__                                }_                            }_                        }__                        shards = shardsBuilder.build()__                        RestoreInProgress.Entry restoreEntry = new RestoreInProgress.Entry(snapshot, overallState(RestoreInProgress.State.INIT, shards), Collections.unmodifiableList(new ArrayList<>(indices.keySet())), shards)__                        builder.putCustom(RestoreInProgress.TYPE, new RestoreInProgress(restoreEntry))__                    } else {_                        shards = ImmutableOpenMap.of()__                    }__                    checkAliasNameConflicts(indices, aliases)___                    _                    if (request.includeGlobalState()) {_                        if (metaData.persistentSettings() != null) {_                            Settings settings = metaData.persistentSettings()__                            clusterSettings.validateUpdate(settings)__                            mdBuilder.persistentSettings(settings)__                        }_                        if (metaData.templates() != null) {_                            _                            for (ObjectCursor<IndexTemplateMetaData> cursor : metaData.templates().values()) {_                                mdBuilder.put(cursor.value)__                            }_                        }_                        if (metaData.customs() != null) {_                            for (ObjectObjectCursor<String, MetaData.Custom> cursor : metaData.customs()) {_                                if (!RepositoriesMetaData.TYPE.equals(cursor.key)) {_                                    _                                    _                                    mdBuilder.putCustom(cursor.key, cursor.value)__                                }_                            }_                        }_                    }__                    if (completed(shards)) {_                        _                        restoreInfo = new RestoreInfo(snapshotId.getName(),_                                                      Collections.unmodifiableList(new ArrayList<>(indices.keySet())),_                                                      shards.size(),_                                                      shards.size() - failedShards(shards))__                    }__                    RoutingTable rt = rtBuilder.build()__                    ClusterState updatedState = builder.metaData(mdBuilder).blocks(blocks).routingTable(rt).build()__                    return allocationService.reroute(updatedState, "restored snapshot [" + snapshot + "]")__                }__                private void checkAliasNameConflicts(Map<String, String> renamedIndices, Set<String> aliases) {_                    for (Map.Entry<String, String> renamedIndex : renamedIndices.entrySet()) {_                        if (aliases.contains(renamedIndex.getKey())) {_                            throw new SnapshotRestoreException(snapshot, "cannot rename index [" + renamedIndex.getValue() + "] into [" + renamedIndex.getKey() + "] because of conflict with an alias with the same name")__                        }_                    }_                }__                private void populateIgnoredShards(String index, IntSet ignoreShards) {_                    for (SnapshotShardFailure failure : snapshotInfo.shardFailures()) {_                        if (index.equals(failure.index())) {_                            ignoreShards.add(failure.shardId())__                        }_                    }_                }__                private boolean checkPartial(String index) {_                    _                    if (failed(snapshotInfo, index)) {_                        if (request.partial()) {_                            return true__                        } else {_                            throw new SnapshotRestoreException(snapshot, "index [" + index + "] wasn't fully snapshotted - cannot restore")__                        }_                    } else {_                        return false__                    }_                }__                private void validateExistingIndex(IndexMetaData currentIndexMetaData, IndexMetaData snapshotIndexMetaData, String renamedIndex, boolean partial) {_                    _                    if (currentIndexMetaData.getState() != IndexMetaData.State.CLOSE) {_                        _                        throw new SnapshotRestoreException(snapshot, "cannot restore index [" + renamedIndex + "] because an open index with same name already exists in the cluster. " +_                            "Either close or delete the existing index or restore the index under a different name by providing a rename pattern and replacement name")__                    }_                    _                    if (partial) {_                        throw new SnapshotRestoreException(snapshot, "cannot restore partial index [" + renamedIndex + "] because such index already exists")__                    }_                    _                    if (currentIndexMetaData.getNumberOfShards() != snapshotIndexMetaData.getNumberOfShards()) {_                        throw new SnapshotRestoreException(snapshot, "cannot restore index [" + renamedIndex + "] with [" + currentIndexMetaData.getNumberOfShards() +_                                "] shards from a snapshot of index [" + snapshotIndexMetaData.getIndex().getName() + "] with [" + snapshotIndexMetaData.getNumberOfShards() + "] shards")__                    }_                }__                _                private IndexMetaData updateIndexSettings(IndexMetaData indexMetaData, Settings changeSettings, String[] ignoreSettings) {_                    if (changeSettings.names().isEmpty() && ignoreSettings.length == 0) {_                        return indexMetaData__                    }_                    Settings normalizedChangeSettings = Settings.builder().put(changeSettings).normalizePrefix(IndexMetaData.INDEX_SETTING_PREFIX).build()__                    IndexMetaData.Builder builder = IndexMetaData.builder(indexMetaData)__                    Settings settings = indexMetaData.getSettings()__                    Set<String> keyFilters = new HashSet<>()__                    List<String> simpleMatchPatterns = new ArrayList<>()__                    for (String ignoredSetting : ignoreSettings) {_                        if (!Regex.isSimpleMatchPattern(ignoredSetting)) {_                            if (UNREMOVABLE_SETTINGS.contains(ignoredSetting)) {_                                throw new SnapshotRestoreException(snapshot, "cannot remove setting [" + ignoredSetting + "] on restore")__                            } else {_                                keyFilters.add(ignoredSetting)__                            }_                        } else {_                            simpleMatchPatterns.add(ignoredSetting)__                        }_                    }_                    Predicate<String> settingsFilter = k -> {_                        if (UNREMOVABLE_SETTINGS.contains(k) == false) {_                            for (String filterKey : keyFilters) {_                                if (k.equals(filterKey)) {_                                    return false__                                }_                            }_                            for (String pattern : simpleMatchPatterns) {_                                if (Regex.simpleMatch(pattern, k)) {_                                    return false__                                }_                            }_                        }_                        return true__                    }__                    Settings.Builder settingsBuilder = Settings.builder()_                        .put(settings.filter(settingsFilter))_                        .put(normalizedChangeSettings.filter(k -> {_                            if (UNMODIFIABLE_SETTINGS.contains(k)) {_                                throw new SnapshotRestoreException(snapshot, "cannot modify setting [" + k + "] on restore")__                            } else {_                                return true__                            }_                        }))__                    return builder.settings(settingsBuilder).build()__                }__                @Override_                public void onFailure(String source, Exception e) {_                    logger.warn(() -> new ParameterizedMessage("[{}] failed to restore snapshot", snapshotId), e)__                    listener.onFailure(e)__                }__                @Override_                public TimeValue timeout() {_                    return request.masterNodeTimeout()__                }__                @Override_                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                    listener.onResponse(new RestoreCompletionResponse(snapshot, restoreInfo))__                }_            })____        } catch (Exception e) {_            logger.warn(() -> new ParameterizedMessage("[{}] failed to restore snapshot", request.repositoryName + ":" + request.snapshotName), e)__            listener.onFailure(e)__        }_    };restores,snapshot,specified,in,the,restore,request,param,request,restore,request,param,listener,restore,listener;public,void,restore,snapshot,final,restore,request,request,final,action,listener,restore,completion,response,listener,try,repository,repository,repositories,service,repository,request,repository,name,final,repository,data,repository,data,repository,get,repository,data,final,optional,snapshot,id,incompatible,snapshot,id,repository,data,get,incompatible,snapshot,ids,stream,filter,s,request,snapshot,name,equals,s,get,name,find,first,if,incompatible,snapshot,id,is,present,throw,new,snapshot,restore,exception,request,repository,name,request,snapshot,name,cannot,restore,incompatible,snapshot,final,optional,snapshot,id,matching,snapshot,id,repository,data,get,snapshot,ids,stream,filter,s,request,snapshot,name,equals,s,get,name,find,first,if,matching,snapshot,id,is,present,false,throw,new,snapshot,restore,exception,request,repository,name,request,snapshot,name,snapshot,does,not,exist,final,snapshot,id,snapshot,id,matching,snapshot,id,get,final,snapshot,info,snapshot,info,repository,get,snapshot,info,snapshot,id,final,snapshot,snapshot,new,snapshot,request,repository,name,snapshot,id,validate,snapshot,restorable,request,repository,name,snapshot,info,final,list,string,indices,in,snapshot,filter,indices,snapshot,info,indices,request,indices,request,indices,options,final,meta,data,builder,meta,data,builder,if,request,include,global,state,meta,data,builder,meta,data,builder,repository,get,snapshot,global,meta,data,snapshot,id,else,meta,data,builder,meta,data,builder,final,list,index,id,index,ids,in,snapshot,repository,data,resolve,indices,indices,in,snapshot,for,index,id,index,id,index,ids,in,snapshot,meta,data,builder,put,repository,get,snapshot,index,meta,data,snapshot,id,index,id,false,final,meta,data,meta,data,meta,data,builder,build,final,map,string,string,indices,renamed,indices,request,indices,in,snapshot,cluster,service,submit,state,update,task,request,cause,new,cluster,state,update,task,restore,info,restore,info,null,override,public,cluster,state,execute,cluster,state,current,state,restore,in,progress,restore,in,progress,current,state,custom,restore,in,progress,type,if,restore,in,progress,null,restore,in,progress,entries,is,empty,throw,new,concurrent,snapshot,execution,exception,snapshot,restore,process,is,already,running,in,this,cluster,snapshot,deletions,in,progress,deletions,in,progress,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,throw,new,concurrent,snapshot,execution,exception,snapshot,cannot,restore,a,snapshot,while,a,snapshot,deletion,is,in,progress,deletions,in,progress,get,entries,get,0,get,snapshot,cluster,state,builder,builder,cluster,state,builder,current,state,meta,data,builder,md,builder,meta,data,builder,current,state,meta,data,cluster,blocks,builder,blocks,cluster,blocks,builder,blocks,current,state,blocks,routing,table,builder,rt,builder,routing,table,builder,current,state,routing,table,immutable,open,map,shard,id,restore,in,progress,shard,restore,status,shards,set,string,aliases,new,hash,set,if,indices,is,empty,false,immutable,open,map,builder,shard,id,restore,in,progress,shard,restore,status,shards,builder,immutable,open,map,builder,final,version,min,index,compatibility,version,current,state,get,nodes,get,max,node,version,minimum,index,compatibility,version,for,map,entry,string,string,index,entry,indices,entry,set,string,index,index,entry,get,value,boolean,partial,check,partial,index,snapshot,recovery,source,recovery,source,new,snapshot,recovery,source,snapshot,snapshot,info,version,index,string,renamed,index,name,index,entry,get,key,index,meta,data,snapshot,index,meta,data,meta,data,index,index,snapshot,index,meta,data,update,index,settings,snapshot,index,meta,data,request,index,settings,request,ignore,index,settings,try,snapshot,index,meta,data,meta,data,index,upgrade,service,upgrade,index,meta,data,snapshot,index,meta,data,min,index,compatibility,version,catch,exception,ex,throw,new,snapshot,restore,exception,snapshot,cannot,restore,index,index,because,it,cannot,be,upgraded,ex,index,meta,data,current,index,meta,data,current,state,meta,data,index,renamed,index,name,int,set,ignore,shards,new,int,hash,set,final,index,renamed,index,if,current,index,meta,data,null,meta,data,create,index,service,validate,index,name,renamed,index,name,current,state,create,index,service,validate,index,settings,renamed,index,name,snapshot,index,meta,data,get,settings,index,meta,data,builder,index,md,builder,index,meta,data,builder,snapshot,index,meta,data,state,index,meta,data,state,open,index,renamed,index,name,index,md,builder,settings,settings,builder,put,snapshot,index,meta,data,get,settings,put,index,meta,data,uuids,random,base64uuid,if,request,include,aliases,snapshot,index,meta,data,get,aliases,is,empty,index,md,builder,remove,all,aliases,else,for,object,cursor,string,alias,snapshot,index,meta,data,get,aliases,keys,aliases,add,alias,value,index,meta,data,updated,index,meta,data,index,md,builder,build,if,partial,populate,ignored,shards,index,ignore,shards,rt,builder,add,as,new,restore,updated,index,meta,data,recovery,source,ignore,shards,blocks,add,blocks,updated,index,meta,data,md,builder,put,updated,index,meta,data,true,renamed,index,updated,index,meta,data,get,index,else,validate,existing,index,current,index,meta,data,snapshot,index,meta,data,renamed,index,name,partial,index,meta,data,builder,index,md,builder,index,meta,data,builder,snapshot,index,meta,data,state,index,meta,data,state,open,index,md,builder,version,math,max,snapshot,index,meta,data,get,version,current,index,meta,data,get,version,1,index,md,builder,mapping,version,math,max,snapshot,index,meta,data,get,mapping,version,current,index,meta,data,get,mapping,version,1,if,request,include,aliases,if,snapshot,index,meta,data,get,aliases,is,empty,index,md,builder,remove,all,aliases,for,object,cursor,alias,meta,data,alias,current,index,meta,data,get,aliases,values,index,md,builder,put,alias,alias,value,else,for,object,cursor,string,alias,snapshot,index,meta,data,get,aliases,keys,aliases,add,alias,value,index,md,builder,settings,settings,builder,put,snapshot,index,meta,data,get,settings,put,index,meta,data,current,index,meta,data,get,index,uuid,index,meta,data,updated,index,meta,data,index,md,builder,index,renamed,index,name,build,rt,builder,add,as,restore,updated,index,meta,data,recovery,source,blocks,update,blocks,updated,index,meta,data,md,builder,put,updated,index,meta,data,true,renamed,index,updated,index,meta,data,get,index,for,int,shard,0,shard,snapshot,index,meta,data,get,number,of,shards,shard,if,ignore,shards,contains,shard,shards,builder,put,new,shard,id,renamed,index,shard,new,restore,in,progress,shard,restore,status,cluster,service,state,nodes,get,local,node,id,else,shards,builder,put,new,shard,id,renamed,index,shard,new,restore,in,progress,shard,restore,status,cluster,service,state,nodes,get,local,node,id,restore,in,progress,state,failure,shards,shards,builder,build,restore,in,progress,entry,restore,entry,new,restore,in,progress,entry,snapshot,overall,state,restore,in,progress,state,init,shards,collections,unmodifiable,list,new,array,list,indices,key,set,shards,builder,put,custom,restore,in,progress,type,new,restore,in,progress,restore,entry,else,shards,immutable,open,map,of,check,alias,name,conflicts,indices,aliases,if,request,include,global,state,if,meta,data,persistent,settings,null,settings,settings,meta,data,persistent,settings,cluster,settings,validate,update,settings,md,builder,persistent,settings,settings,if,meta,data,templates,null,for,object,cursor,index,template,meta,data,cursor,meta,data,templates,values,md,builder,put,cursor,value,if,meta,data,customs,null,for,object,object,cursor,string,meta,data,custom,cursor,meta,data,customs,if,repositories,meta,data,type,equals,cursor,key,md,builder,put,custom,cursor,key,cursor,value,if,completed,shards,restore,info,new,restore,info,snapshot,id,get,name,collections,unmodifiable,list,new,array,list,indices,key,set,shards,size,shards,size,failed,shards,shards,routing,table,rt,rt,builder,build,cluster,state,updated,state,builder,meta,data,md,builder,blocks,blocks,routing,table,rt,build,return,allocation,service,reroute,updated,state,restored,snapshot,snapshot,private,void,check,alias,name,conflicts,map,string,string,renamed,indices,set,string,aliases,for,map,entry,string,string,renamed,index,renamed,indices,entry,set,if,aliases,contains,renamed,index,get,key,throw,new,snapshot,restore,exception,snapshot,cannot,rename,index,renamed,index,get,value,into,renamed,index,get,key,because,of,conflict,with,an,alias,with,the,same,name,private,void,populate,ignored,shards,string,index,int,set,ignore,shards,for,snapshot,shard,failure,failure,snapshot,info,shard,failures,if,index,equals,failure,index,ignore,shards,add,failure,shard,id,private,boolean,check,partial,string,index,if,failed,snapshot,info,index,if,request,partial,return,true,else,throw,new,snapshot,restore,exception,snapshot,index,index,wasn,t,fully,snapshotted,cannot,restore,else,return,false,private,void,validate,existing,index,index,meta,data,current,index,meta,data,index,meta,data,snapshot,index,meta,data,string,renamed,index,boolean,partial,if,current,index,meta,data,get,state,index,meta,data,state,close,throw,new,snapshot,restore,exception,snapshot,cannot,restore,index,renamed,index,because,an,open,index,with,same,name,already,exists,in,the,cluster,either,close,or,delete,the,existing,index,or,restore,the,index,under,a,different,name,by,providing,a,rename,pattern,and,replacement,name,if,partial,throw,new,snapshot,restore,exception,snapshot,cannot,restore,partial,index,renamed,index,because,such,index,already,exists,if,current,index,meta,data,get,number,of,shards,snapshot,index,meta,data,get,number,of,shards,throw,new,snapshot,restore,exception,snapshot,cannot,restore,index,renamed,index,with,current,index,meta,data,get,number,of,shards,shards,from,a,snapshot,of,index,snapshot,index,meta,data,get,index,get,name,with,snapshot,index,meta,data,get,number,of,shards,shards,private,index,meta,data,update,index,settings,index,meta,data,index,meta,data,settings,change,settings,string,ignore,settings,if,change,settings,names,is,empty,ignore,settings,length,0,return,index,meta,data,settings,normalized,change,settings,settings,builder,put,change,settings,normalize,prefix,index,meta,data,build,index,meta,data,builder,builder,index,meta,data,builder,index,meta,data,settings,settings,index,meta,data,get,settings,set,string,key,filters,new,hash,set,list,string,simple,match,patterns,new,array,list,for,string,ignored,setting,ignore,settings,if,regex,is,simple,match,pattern,ignored,setting,if,contains,ignored,setting,throw,new,snapshot,restore,exception,snapshot,cannot,remove,setting,ignored,setting,on,restore,else,key,filters,add,ignored,setting,else,simple,match,patterns,add,ignored,setting,predicate,string,settings,filter,k,if,contains,k,false,for,string,filter,key,key,filters,if,k,equals,filter,key,return,false,for,string,pattern,simple,match,patterns,if,regex,simple,match,pattern,k,return,false,return,true,settings,builder,settings,builder,settings,builder,put,settings,filter,settings,filter,put,normalized,change,settings,filter,k,if,contains,k,throw,new,snapshot,restore,exception,snapshot,cannot,modify,setting,k,on,restore,else,return,true,return,builder,settings,settings,builder,build,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,restore,snapshot,snapshot,id,e,listener,on,failure,e,override,public,time,value,timeout,return,request,master,node,timeout,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,listener,on,response,new,restore,completion,response,snapshot,restore,info,catch,exception,e,logger,warn,new,parameterized,message,failed,to,restore,snapshot,request,repository,name,request,snapshot,name,e,listener,on,failure,e
RestoreService -> public void restoreSnapshot(final RestoreRequest request, final ActionListener<RestoreCompletionResponse> listener);1536137328;Restores snapshot specified in the restore request.__@param request  restore request_@param listener restore listener;public void restoreSnapshot(final RestoreRequest request, final ActionListener<RestoreCompletionResponse> listener) {_        try {_            _            Repository repository = repositoriesService.repository(request.repositoryName)__            final RepositoryData repositoryData = repository.getRepositoryData()__            final Optional<SnapshotId> incompatibleSnapshotId =_                repositoryData.getIncompatibleSnapshotIds().stream().filter(s -> request.snapshotName.equals(s.getName())).findFirst()__            if (incompatibleSnapshotId.isPresent()) {_                throw new SnapshotRestoreException(request.repositoryName, request.snapshotName, "cannot restore incompatible snapshot")__            }_            final Optional<SnapshotId> matchingSnapshotId = repositoryData.getSnapshotIds().stream()_                .filter(s -> request.snapshotName.equals(s.getName())).findFirst()__            if (matchingSnapshotId.isPresent() == false) {_                throw new SnapshotRestoreException(request.repositoryName, request.snapshotName, "snapshot does not exist")__            }__            final SnapshotId snapshotId = matchingSnapshotId.get()__            final SnapshotInfo snapshotInfo = repository.getSnapshotInfo(snapshotId)__            final Snapshot snapshot = new Snapshot(request.repositoryName, snapshotId)___            _            validateSnapshotRestorable(request.repositoryName, snapshotInfo)___            _            final List<String> indicesInSnapshot = filterIndices(snapshotInfo.indices(), request.indices(), request.indicesOptions())___            final MetaData.Builder metaDataBuilder__            if (request.includeGlobalState()) {_                metaDataBuilder = MetaData.builder(repository.getSnapshotGlobalMetaData(snapshotId))__            } else {_                metaDataBuilder = MetaData.builder()__            }__            final List<IndexId> indexIdsInSnapshot = repositoryData.resolveIndices(indicesInSnapshot)__            for (IndexId indexId : indexIdsInSnapshot) {_                metaDataBuilder.put(repository.getSnapshotIndexMetaData(snapshotId, indexId), false)__            }__            final MetaData metaData = metaDataBuilder.build()___            _            _            final Map<String, String> indices = renamedIndices(request, indicesInSnapshot)___            _            _            clusterService.submitStateUpdateTask(request.cause(), new ClusterStateUpdateTask() {_                RestoreInfo restoreInfo = null___                @Override_                public ClusterState execute(ClusterState currentState) {_                    _                    _                    RestoreInProgress restoreInProgress = currentState.custom(RestoreInProgress.TYPE)__                    if (restoreInProgress != null && !restoreInProgress.entries().isEmpty()) {_                        throw new ConcurrentSnapshotExecutionException(snapshot, "Restore process is already running in this cluster")__                    }_                    _                    SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                    if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                        throw new ConcurrentSnapshotExecutionException(snapshot,_                            "cannot restore a snapshot while a snapshot deletion is in-progress [" +_                                deletionsInProgress.getEntries().get(0).getSnapshot() + "]")__                    }__                    _                    ClusterState.Builder builder = ClusterState.builder(currentState)__                    MetaData.Builder mdBuilder = MetaData.builder(currentState.metaData())__                    ClusterBlocks.Builder blocks = ClusterBlocks.builder().blocks(currentState.blocks())__                    RoutingTable.Builder rtBuilder = RoutingTable.builder(currentState.routingTable())__                    ImmutableOpenMap<ShardId, RestoreInProgress.ShardRestoreStatus> shards__                    Set<String> aliases = new HashSet<>()___                    if (indices.isEmpty() == false) {_                        _                        ImmutableOpenMap.Builder<ShardId, RestoreInProgress.ShardRestoreStatus> shardsBuilder = ImmutableOpenMap.builder()__                        final Version minIndexCompatibilityVersion = currentState.getNodes().getMaxNodeVersion()_                            .minimumIndexCompatibilityVersion()__                        for (Map.Entry<String, String> indexEntry : indices.entrySet()) {_                            String index = indexEntry.getValue()__                            boolean partial = checkPartial(index)__                            SnapshotRecoverySource recoverySource = new SnapshotRecoverySource(snapshot, snapshotInfo.version(), index)__                            String renamedIndexName = indexEntry.getKey()__                            IndexMetaData snapshotIndexMetaData = metaData.index(index)__                            snapshotIndexMetaData = updateIndexSettings(snapshotIndexMetaData, request.indexSettings, request.ignoreIndexSettings)__                            try {_                                snapshotIndexMetaData = metaDataIndexUpgradeService.upgradeIndexMetaData(snapshotIndexMetaData,_                                    minIndexCompatibilityVersion)__                            } catch (Exception ex) {_                                throw new SnapshotRestoreException(snapshot, "cannot restore index [" + index + "] because it cannot be upgraded", ex)__                            }_                            _                            IndexMetaData currentIndexMetaData = currentState.metaData().index(renamedIndexName)__                            IntSet ignoreShards = new IntHashSet()__                            final Index renamedIndex__                            if (currentIndexMetaData == null) {_                                _                                _                                MetaDataCreateIndexService.validateIndexName(renamedIndexName, currentState)__                                createIndexService.validateIndexSettings(renamedIndexName, snapshotIndexMetaData.getSettings(), false)__                                IndexMetaData.Builder indexMdBuilder = IndexMetaData.builder(snapshotIndexMetaData).state(IndexMetaData.State.OPEN).index(renamedIndexName)__                                indexMdBuilder.settings(Settings.builder().put(snapshotIndexMetaData.getSettings()).put(IndexMetaData.SETTING_INDEX_UUID, UUIDs.randomBase64UUID()))__                                if (!request.includeAliases() && !snapshotIndexMetaData.getAliases().isEmpty()) {_                                    _                                    indexMdBuilder.removeAllAliases()__                                } else {_                                    for (ObjectCursor<String> alias : snapshotIndexMetaData.getAliases().keys()) {_                                        aliases.add(alias.value)__                                    }_                                }_                                IndexMetaData updatedIndexMetaData = indexMdBuilder.build()__                                if (partial) {_                                    populateIgnoredShards(index, ignoreShards)__                                }_                                rtBuilder.addAsNewRestore(updatedIndexMetaData, recoverySource, ignoreShards)__                                blocks.addBlocks(updatedIndexMetaData)__                                mdBuilder.put(updatedIndexMetaData, true)__                                renamedIndex = updatedIndexMetaData.getIndex()__                            } else {_                                validateExistingIndex(currentIndexMetaData, snapshotIndexMetaData, renamedIndexName, partial)__                                _                                IndexMetaData.Builder indexMdBuilder = IndexMetaData.builder(snapshotIndexMetaData).state(IndexMetaData.State.OPEN)__                                indexMdBuilder.version(Math.max(snapshotIndexMetaData.getVersion(), currentIndexMetaData.getVersion() + 1))__                                indexMdBuilder.mappingVersion(Math.max(snapshotIndexMetaData.getMappingVersion(), currentIndexMetaData.getMappingVersion() + 1))__                                if (!request.includeAliases()) {_                                    _                                    if (!snapshotIndexMetaData.getAliases().isEmpty()) {_                                        indexMdBuilder.removeAllAliases()__                                    }_                                    _                                    for (ObjectCursor<AliasMetaData> alias : currentIndexMetaData.getAliases().values()) {_                                        indexMdBuilder.putAlias(alias.value)__                                    }_                                } else {_                                    for (ObjectCursor<String> alias : snapshotIndexMetaData.getAliases().keys()) {_                                        aliases.add(alias.value)__                                    }_                                }_                                indexMdBuilder.settings(Settings.builder().put(snapshotIndexMetaData.getSettings()).put(IndexMetaData.SETTING_INDEX_UUID, currentIndexMetaData.getIndexUUID()))__                                IndexMetaData updatedIndexMetaData = indexMdBuilder.index(renamedIndexName).build()__                                rtBuilder.addAsRestore(updatedIndexMetaData, recoverySource)__                                blocks.updateBlocks(updatedIndexMetaData)__                                mdBuilder.put(updatedIndexMetaData, true)__                                renamedIndex = updatedIndexMetaData.getIndex()__                            }__                            for (int shard = 0_ shard < snapshotIndexMetaData.getNumberOfShards()_ shard++) {_                                if (!ignoreShards.contains(shard)) {_                                    shardsBuilder.put(new ShardId(renamedIndex, shard), new RestoreInProgress.ShardRestoreStatus(clusterService.state().nodes().getLocalNodeId()))__                                } else {_                                    shardsBuilder.put(new ShardId(renamedIndex, shard), new RestoreInProgress.ShardRestoreStatus(clusterService.state().nodes().getLocalNodeId(), RestoreInProgress.State.FAILURE))__                                }_                            }_                        }__                        shards = shardsBuilder.build()__                        RestoreInProgress.Entry restoreEntry = new RestoreInProgress.Entry(snapshot, overallState(RestoreInProgress.State.INIT, shards), Collections.unmodifiableList(new ArrayList<>(indices.keySet())), shards)__                        builder.putCustom(RestoreInProgress.TYPE, new RestoreInProgress(restoreEntry))__                    } else {_                        shards = ImmutableOpenMap.of()__                    }__                    checkAliasNameConflicts(indices, aliases)___                    _                    if (request.includeGlobalState()) {_                        if (metaData.persistentSettings() != null) {_                            Settings settings = metaData.persistentSettings()__                            clusterSettings.validateUpdate(settings)__                            mdBuilder.persistentSettings(settings)__                        }_                        if (metaData.templates() != null) {_                            _                            for (ObjectCursor<IndexTemplateMetaData> cursor : metaData.templates().values()) {_                                mdBuilder.put(cursor.value)__                            }_                        }_                        if (metaData.customs() != null) {_                            for (ObjectObjectCursor<String, MetaData.Custom> cursor : metaData.customs()) {_                                if (!RepositoriesMetaData.TYPE.equals(cursor.key)) {_                                    _                                    _                                    mdBuilder.putCustom(cursor.key, cursor.value)__                                }_                            }_                        }_                    }__                    if (completed(shards)) {_                        _                        restoreInfo = new RestoreInfo(snapshotId.getName(),_                                                      Collections.unmodifiableList(new ArrayList<>(indices.keySet())),_                                                      shards.size(),_                                                      shards.size() - failedShards(shards))__                    }__                    RoutingTable rt = rtBuilder.build()__                    ClusterState updatedState = builder.metaData(mdBuilder).blocks(blocks).routingTable(rt).build()__                    return allocationService.reroute(updatedState, "restored snapshot [" + snapshot + "]")__                }__                private void checkAliasNameConflicts(Map<String, String> renamedIndices, Set<String> aliases) {_                    for (Map.Entry<String, String> renamedIndex : renamedIndices.entrySet()) {_                        if (aliases.contains(renamedIndex.getKey())) {_                            throw new SnapshotRestoreException(snapshot, "cannot rename index [" + renamedIndex.getValue() + "] into [" + renamedIndex.getKey() + "] because of conflict with an alias with the same name")__                        }_                    }_                }__                private void populateIgnoredShards(String index, IntSet ignoreShards) {_                    for (SnapshotShardFailure failure : snapshotInfo.shardFailures()) {_                        if (index.equals(failure.index())) {_                            ignoreShards.add(failure.shardId())__                        }_                    }_                }__                private boolean checkPartial(String index) {_                    _                    if (failed(snapshotInfo, index)) {_                        if (request.partial()) {_                            return true__                        } else {_                            throw new SnapshotRestoreException(snapshot, "index [" + index + "] wasn't fully snapshotted - cannot restore")__                        }_                    } else {_                        return false__                    }_                }__                private void validateExistingIndex(IndexMetaData currentIndexMetaData, IndexMetaData snapshotIndexMetaData, String renamedIndex, boolean partial) {_                    _                    if (currentIndexMetaData.getState() != IndexMetaData.State.CLOSE) {_                        _                        throw new SnapshotRestoreException(snapshot, "cannot restore index [" + renamedIndex + "] because an open index with same name already exists in the cluster. " +_                            "Either close or delete the existing index or restore the index under a different name by providing a rename pattern and replacement name")__                    }_                    _                    if (partial) {_                        throw new SnapshotRestoreException(snapshot, "cannot restore partial index [" + renamedIndex + "] because such index already exists")__                    }_                    _                    if (currentIndexMetaData.getNumberOfShards() != snapshotIndexMetaData.getNumberOfShards()) {_                        throw new SnapshotRestoreException(snapshot, "cannot restore index [" + renamedIndex + "] with [" + currentIndexMetaData.getNumberOfShards() +_                                "] shards from a snapshot of index [" + snapshotIndexMetaData.getIndex().getName() + "] with [" + snapshotIndexMetaData.getNumberOfShards() + "] shards")__                    }_                }__                _                private IndexMetaData updateIndexSettings(IndexMetaData indexMetaData, Settings changeSettings, String[] ignoreSettings) {_                    if (changeSettings.names().isEmpty() && ignoreSettings.length == 0) {_                        return indexMetaData__                    }_                    Settings normalizedChangeSettings = Settings.builder().put(changeSettings).normalizePrefix(IndexMetaData.INDEX_SETTING_PREFIX).build()__                    IndexMetaData.Builder builder = IndexMetaData.builder(indexMetaData)__                    Settings settings = indexMetaData.getSettings()__                    Set<String> keyFilters = new HashSet<>()__                    List<String> simpleMatchPatterns = new ArrayList<>()__                    for (String ignoredSetting : ignoreSettings) {_                        if (!Regex.isSimpleMatchPattern(ignoredSetting)) {_                            if (UNREMOVABLE_SETTINGS.contains(ignoredSetting)) {_                                throw new SnapshotRestoreException(snapshot, "cannot remove setting [" + ignoredSetting + "] on restore")__                            } else {_                                keyFilters.add(ignoredSetting)__                            }_                        } else {_                            simpleMatchPatterns.add(ignoredSetting)__                        }_                    }_                    Predicate<String> settingsFilter = k -> {_                        if (UNREMOVABLE_SETTINGS.contains(k) == false) {_                            for (String filterKey : keyFilters) {_                                if (k.equals(filterKey)) {_                                    return false__                                }_                            }_                            for (String pattern : simpleMatchPatterns) {_                                if (Regex.simpleMatch(pattern, k)) {_                                    return false__                                }_                            }_                        }_                        return true__                    }__                    Settings.Builder settingsBuilder = Settings.builder()_                        .put(settings.filter(settingsFilter))_                        .put(normalizedChangeSettings.filter(k -> {_                            if (UNMODIFIABLE_SETTINGS.contains(k)) {_                                throw new SnapshotRestoreException(snapshot, "cannot modify setting [" + k + "] on restore")__                            } else {_                                return true__                            }_                        }))__                    return builder.settings(settingsBuilder).build()__                }__                @Override_                public void onFailure(String source, Exception e) {_                    logger.warn(() -> new ParameterizedMessage("[{}] failed to restore snapshot", snapshotId), e)__                    listener.onFailure(e)__                }__                @Override_                public TimeValue timeout() {_                    return request.masterNodeTimeout()__                }__                @Override_                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                    listener.onResponse(new RestoreCompletionResponse(snapshot, restoreInfo))__                }_            })____        } catch (Exception e) {_            logger.warn(() -> new ParameterizedMessage("[{}] failed to restore snapshot", request.repositoryName + ":" + request.snapshotName), e)__            listener.onFailure(e)__        }_    };restores,snapshot,specified,in,the,restore,request,param,request,restore,request,param,listener,restore,listener;public,void,restore,snapshot,final,restore,request,request,final,action,listener,restore,completion,response,listener,try,repository,repository,repositories,service,repository,request,repository,name,final,repository,data,repository,data,repository,get,repository,data,final,optional,snapshot,id,incompatible,snapshot,id,repository,data,get,incompatible,snapshot,ids,stream,filter,s,request,snapshot,name,equals,s,get,name,find,first,if,incompatible,snapshot,id,is,present,throw,new,snapshot,restore,exception,request,repository,name,request,snapshot,name,cannot,restore,incompatible,snapshot,final,optional,snapshot,id,matching,snapshot,id,repository,data,get,snapshot,ids,stream,filter,s,request,snapshot,name,equals,s,get,name,find,first,if,matching,snapshot,id,is,present,false,throw,new,snapshot,restore,exception,request,repository,name,request,snapshot,name,snapshot,does,not,exist,final,snapshot,id,snapshot,id,matching,snapshot,id,get,final,snapshot,info,snapshot,info,repository,get,snapshot,info,snapshot,id,final,snapshot,snapshot,new,snapshot,request,repository,name,snapshot,id,validate,snapshot,restorable,request,repository,name,snapshot,info,final,list,string,indices,in,snapshot,filter,indices,snapshot,info,indices,request,indices,request,indices,options,final,meta,data,builder,meta,data,builder,if,request,include,global,state,meta,data,builder,meta,data,builder,repository,get,snapshot,global,meta,data,snapshot,id,else,meta,data,builder,meta,data,builder,final,list,index,id,index,ids,in,snapshot,repository,data,resolve,indices,indices,in,snapshot,for,index,id,index,id,index,ids,in,snapshot,meta,data,builder,put,repository,get,snapshot,index,meta,data,snapshot,id,index,id,false,final,meta,data,meta,data,meta,data,builder,build,final,map,string,string,indices,renamed,indices,request,indices,in,snapshot,cluster,service,submit,state,update,task,request,cause,new,cluster,state,update,task,restore,info,restore,info,null,override,public,cluster,state,execute,cluster,state,current,state,restore,in,progress,restore,in,progress,current,state,custom,restore,in,progress,type,if,restore,in,progress,null,restore,in,progress,entries,is,empty,throw,new,concurrent,snapshot,execution,exception,snapshot,restore,process,is,already,running,in,this,cluster,snapshot,deletions,in,progress,deletions,in,progress,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,throw,new,concurrent,snapshot,execution,exception,snapshot,cannot,restore,a,snapshot,while,a,snapshot,deletion,is,in,progress,deletions,in,progress,get,entries,get,0,get,snapshot,cluster,state,builder,builder,cluster,state,builder,current,state,meta,data,builder,md,builder,meta,data,builder,current,state,meta,data,cluster,blocks,builder,blocks,cluster,blocks,builder,blocks,current,state,blocks,routing,table,builder,rt,builder,routing,table,builder,current,state,routing,table,immutable,open,map,shard,id,restore,in,progress,shard,restore,status,shards,set,string,aliases,new,hash,set,if,indices,is,empty,false,immutable,open,map,builder,shard,id,restore,in,progress,shard,restore,status,shards,builder,immutable,open,map,builder,final,version,min,index,compatibility,version,current,state,get,nodes,get,max,node,version,minimum,index,compatibility,version,for,map,entry,string,string,index,entry,indices,entry,set,string,index,index,entry,get,value,boolean,partial,check,partial,index,snapshot,recovery,source,recovery,source,new,snapshot,recovery,source,snapshot,snapshot,info,version,index,string,renamed,index,name,index,entry,get,key,index,meta,data,snapshot,index,meta,data,meta,data,index,index,snapshot,index,meta,data,update,index,settings,snapshot,index,meta,data,request,index,settings,request,ignore,index,settings,try,snapshot,index,meta,data,meta,data,index,upgrade,service,upgrade,index,meta,data,snapshot,index,meta,data,min,index,compatibility,version,catch,exception,ex,throw,new,snapshot,restore,exception,snapshot,cannot,restore,index,index,because,it,cannot,be,upgraded,ex,index,meta,data,current,index,meta,data,current,state,meta,data,index,renamed,index,name,int,set,ignore,shards,new,int,hash,set,final,index,renamed,index,if,current,index,meta,data,null,meta,data,create,index,service,validate,index,name,renamed,index,name,current,state,create,index,service,validate,index,settings,renamed,index,name,snapshot,index,meta,data,get,settings,false,index,meta,data,builder,index,md,builder,index,meta,data,builder,snapshot,index,meta,data,state,index,meta,data,state,open,index,renamed,index,name,index,md,builder,settings,settings,builder,put,snapshot,index,meta,data,get,settings,put,index,meta,data,uuids,random,base64uuid,if,request,include,aliases,snapshot,index,meta,data,get,aliases,is,empty,index,md,builder,remove,all,aliases,else,for,object,cursor,string,alias,snapshot,index,meta,data,get,aliases,keys,aliases,add,alias,value,index,meta,data,updated,index,meta,data,index,md,builder,build,if,partial,populate,ignored,shards,index,ignore,shards,rt,builder,add,as,new,restore,updated,index,meta,data,recovery,source,ignore,shards,blocks,add,blocks,updated,index,meta,data,md,builder,put,updated,index,meta,data,true,renamed,index,updated,index,meta,data,get,index,else,validate,existing,index,current,index,meta,data,snapshot,index,meta,data,renamed,index,name,partial,index,meta,data,builder,index,md,builder,index,meta,data,builder,snapshot,index,meta,data,state,index,meta,data,state,open,index,md,builder,version,math,max,snapshot,index,meta,data,get,version,current,index,meta,data,get,version,1,index,md,builder,mapping,version,math,max,snapshot,index,meta,data,get,mapping,version,current,index,meta,data,get,mapping,version,1,if,request,include,aliases,if,snapshot,index,meta,data,get,aliases,is,empty,index,md,builder,remove,all,aliases,for,object,cursor,alias,meta,data,alias,current,index,meta,data,get,aliases,values,index,md,builder,put,alias,alias,value,else,for,object,cursor,string,alias,snapshot,index,meta,data,get,aliases,keys,aliases,add,alias,value,index,md,builder,settings,settings,builder,put,snapshot,index,meta,data,get,settings,put,index,meta,data,current,index,meta,data,get,index,uuid,index,meta,data,updated,index,meta,data,index,md,builder,index,renamed,index,name,build,rt,builder,add,as,restore,updated,index,meta,data,recovery,source,blocks,update,blocks,updated,index,meta,data,md,builder,put,updated,index,meta,data,true,renamed,index,updated,index,meta,data,get,index,for,int,shard,0,shard,snapshot,index,meta,data,get,number,of,shards,shard,if,ignore,shards,contains,shard,shards,builder,put,new,shard,id,renamed,index,shard,new,restore,in,progress,shard,restore,status,cluster,service,state,nodes,get,local,node,id,else,shards,builder,put,new,shard,id,renamed,index,shard,new,restore,in,progress,shard,restore,status,cluster,service,state,nodes,get,local,node,id,restore,in,progress,state,failure,shards,shards,builder,build,restore,in,progress,entry,restore,entry,new,restore,in,progress,entry,snapshot,overall,state,restore,in,progress,state,init,shards,collections,unmodifiable,list,new,array,list,indices,key,set,shards,builder,put,custom,restore,in,progress,type,new,restore,in,progress,restore,entry,else,shards,immutable,open,map,of,check,alias,name,conflicts,indices,aliases,if,request,include,global,state,if,meta,data,persistent,settings,null,settings,settings,meta,data,persistent,settings,cluster,settings,validate,update,settings,md,builder,persistent,settings,settings,if,meta,data,templates,null,for,object,cursor,index,template,meta,data,cursor,meta,data,templates,values,md,builder,put,cursor,value,if,meta,data,customs,null,for,object,object,cursor,string,meta,data,custom,cursor,meta,data,customs,if,repositories,meta,data,type,equals,cursor,key,md,builder,put,custom,cursor,key,cursor,value,if,completed,shards,restore,info,new,restore,info,snapshot,id,get,name,collections,unmodifiable,list,new,array,list,indices,key,set,shards,size,shards,size,failed,shards,shards,routing,table,rt,rt,builder,build,cluster,state,updated,state,builder,meta,data,md,builder,blocks,blocks,routing,table,rt,build,return,allocation,service,reroute,updated,state,restored,snapshot,snapshot,private,void,check,alias,name,conflicts,map,string,string,renamed,indices,set,string,aliases,for,map,entry,string,string,renamed,index,renamed,indices,entry,set,if,aliases,contains,renamed,index,get,key,throw,new,snapshot,restore,exception,snapshot,cannot,rename,index,renamed,index,get,value,into,renamed,index,get,key,because,of,conflict,with,an,alias,with,the,same,name,private,void,populate,ignored,shards,string,index,int,set,ignore,shards,for,snapshot,shard,failure,failure,snapshot,info,shard,failures,if,index,equals,failure,index,ignore,shards,add,failure,shard,id,private,boolean,check,partial,string,index,if,failed,snapshot,info,index,if,request,partial,return,true,else,throw,new,snapshot,restore,exception,snapshot,index,index,wasn,t,fully,snapshotted,cannot,restore,else,return,false,private,void,validate,existing,index,index,meta,data,current,index,meta,data,index,meta,data,snapshot,index,meta,data,string,renamed,index,boolean,partial,if,current,index,meta,data,get,state,index,meta,data,state,close,throw,new,snapshot,restore,exception,snapshot,cannot,restore,index,renamed,index,because,an,open,index,with,same,name,already,exists,in,the,cluster,either,close,or,delete,the,existing,index,or,restore,the,index,under,a,different,name,by,providing,a,rename,pattern,and,replacement,name,if,partial,throw,new,snapshot,restore,exception,snapshot,cannot,restore,partial,index,renamed,index,because,such,index,already,exists,if,current,index,meta,data,get,number,of,shards,snapshot,index,meta,data,get,number,of,shards,throw,new,snapshot,restore,exception,snapshot,cannot,restore,index,renamed,index,with,current,index,meta,data,get,number,of,shards,shards,from,a,snapshot,of,index,snapshot,index,meta,data,get,index,get,name,with,snapshot,index,meta,data,get,number,of,shards,shards,private,index,meta,data,update,index,settings,index,meta,data,index,meta,data,settings,change,settings,string,ignore,settings,if,change,settings,names,is,empty,ignore,settings,length,0,return,index,meta,data,settings,normalized,change,settings,settings,builder,put,change,settings,normalize,prefix,index,meta,data,build,index,meta,data,builder,builder,index,meta,data,builder,index,meta,data,settings,settings,index,meta,data,get,settings,set,string,key,filters,new,hash,set,list,string,simple,match,patterns,new,array,list,for,string,ignored,setting,ignore,settings,if,regex,is,simple,match,pattern,ignored,setting,if,contains,ignored,setting,throw,new,snapshot,restore,exception,snapshot,cannot,remove,setting,ignored,setting,on,restore,else,key,filters,add,ignored,setting,else,simple,match,patterns,add,ignored,setting,predicate,string,settings,filter,k,if,contains,k,false,for,string,filter,key,key,filters,if,k,equals,filter,key,return,false,for,string,pattern,simple,match,patterns,if,regex,simple,match,pattern,k,return,false,return,true,settings,builder,settings,builder,settings,builder,put,settings,filter,settings,filter,put,normalized,change,settings,filter,k,if,contains,k,throw,new,snapshot,restore,exception,snapshot,cannot,modify,setting,k,on,restore,else,return,true,return,builder,settings,settings,builder,build,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,restore,snapshot,snapshot,id,e,listener,on,failure,e,override,public,time,value,timeout,return,request,master,node,timeout,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,listener,on,response,new,restore,completion,response,snapshot,restore,info,catch,exception,e,logger,warn,new,parameterized,message,failed,to,restore,snapshot,request,repository,name,request,snapshot,name,e,listener,on,failure,e
RestoreService -> public void restoreSnapshot(final RestoreRequest request, final ActionListener<RestoreCompletionResponse> listener);1539723533;Restores snapshot specified in the restore request.__@param request  restore request_@param listener restore listener;public void restoreSnapshot(final RestoreRequest request, final ActionListener<RestoreCompletionResponse> listener) {_        try {_            _            Repository repository = repositoriesService.repository(request.repositoryName)__            final RepositoryData repositoryData = repository.getRepositoryData()__            final Optional<SnapshotId> incompatibleSnapshotId =_                repositoryData.getIncompatibleSnapshotIds().stream().filter(s -> request.snapshotName.equals(s.getName())).findFirst()__            if (incompatibleSnapshotId.isPresent()) {_                throw new SnapshotRestoreException(request.repositoryName, request.snapshotName, "cannot restore incompatible snapshot")__            }_            final Optional<SnapshotId> matchingSnapshotId = repositoryData.getSnapshotIds().stream()_                .filter(s -> request.snapshotName.equals(s.getName())).findFirst()__            if (matchingSnapshotId.isPresent() == false) {_                throw new SnapshotRestoreException(request.repositoryName, request.snapshotName, "snapshot does not exist")__            }__            final SnapshotId snapshotId = matchingSnapshotId.get()__            final SnapshotInfo snapshotInfo = repository.getSnapshotInfo(snapshotId)__            final Snapshot snapshot = new Snapshot(request.repositoryName, snapshotId)___            _            validateSnapshotRestorable(request.repositoryName, snapshotInfo)___            _            final List<String> indicesInSnapshot = filterIndices(snapshotInfo.indices(), request.indices(), request.indicesOptions())___            final MetaData.Builder metaDataBuilder__            if (request.includeGlobalState()) {_                metaDataBuilder = MetaData.builder(repository.getSnapshotGlobalMetaData(snapshotId))__            } else {_                metaDataBuilder = MetaData.builder()__            }__            final List<IndexId> indexIdsInSnapshot = repositoryData.resolveIndices(indicesInSnapshot)__            for (IndexId indexId : indexIdsInSnapshot) {_                metaDataBuilder.put(repository.getSnapshotIndexMetaData(snapshotId, indexId), false)__            }__            final MetaData metaData = metaDataBuilder.build()___            _            _            final Map<String, String> indices = renamedIndices(request, indicesInSnapshot)___            _            _            clusterService.submitStateUpdateTask(request.cause(), new ClusterStateUpdateTask() {_                RestoreInfo restoreInfo = null___                @Override_                public ClusterState execute(ClusterState currentState) {_                    _                    _                    RestoreInProgress restoreInProgress = currentState.custom(RestoreInProgress.TYPE)__                    if (restoreInProgress != null && !restoreInProgress.entries().isEmpty()) {_                        throw new ConcurrentSnapshotExecutionException(snapshot, "Restore process is already running in this cluster")__                    }_                    _                    SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                    if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                        throw new ConcurrentSnapshotExecutionException(snapshot,_                            "cannot restore a snapshot while a snapshot deletion is in-progress [" +_                                deletionsInProgress.getEntries().get(0).getSnapshot() + "]")__                    }__                    _                    ClusterState.Builder builder = ClusterState.builder(currentState)__                    MetaData.Builder mdBuilder = MetaData.builder(currentState.metaData())__                    ClusterBlocks.Builder blocks = ClusterBlocks.builder().blocks(currentState.blocks())__                    RoutingTable.Builder rtBuilder = RoutingTable.builder(currentState.routingTable())__                    ImmutableOpenMap<ShardId, RestoreInProgress.ShardRestoreStatus> shards__                    Set<String> aliases = new HashSet<>()___                    if (indices.isEmpty() == false) {_                        _                        ImmutableOpenMap.Builder<ShardId, RestoreInProgress.ShardRestoreStatus> shardsBuilder = ImmutableOpenMap.builder()__                        final Version minIndexCompatibilityVersion = currentState.getNodes().getMaxNodeVersion()_                            .minimumIndexCompatibilityVersion()__                        for (Map.Entry<String, String> indexEntry : indices.entrySet()) {_                            String index = indexEntry.getValue()__                            boolean partial = checkPartial(index)__                            SnapshotRecoverySource recoverySource = new SnapshotRecoverySource(snapshot, snapshotInfo.version(), index)__                            String renamedIndexName = indexEntry.getKey()__                            IndexMetaData snapshotIndexMetaData = metaData.index(index)__                            snapshotIndexMetaData = updateIndexSettings(snapshotIndexMetaData, request.indexSettings, request.ignoreIndexSettings)__                            try {_                                snapshotIndexMetaData = metaDataIndexUpgradeService.upgradeIndexMetaData(snapshotIndexMetaData,_                                    minIndexCompatibilityVersion)__                            } catch (Exception ex) {_                                throw new SnapshotRestoreException(snapshot, "cannot restore index [" + index + "] because it cannot be upgraded", ex)__                            }_                            _                            IndexMetaData currentIndexMetaData = currentState.metaData().index(renamedIndexName)__                            IntSet ignoreShards = new IntHashSet()__                            final Index renamedIndex__                            if (currentIndexMetaData == null) {_                                _                                _                                MetaDataCreateIndexService.validateIndexName(renamedIndexName, currentState)__                                createIndexService.validateIndexSettings(renamedIndexName, snapshotIndexMetaData.getSettings(), false)__                                IndexMetaData.Builder indexMdBuilder = IndexMetaData.builder(snapshotIndexMetaData).state(IndexMetaData.State.OPEN).index(renamedIndexName)__                                indexMdBuilder.settings(Settings.builder().put(snapshotIndexMetaData.getSettings()).put(IndexMetaData.SETTING_INDEX_UUID, UUIDs.randomBase64UUID()))__                                if (!request.includeAliases() && !snapshotIndexMetaData.getAliases().isEmpty()) {_                                    _                                    indexMdBuilder.removeAllAliases()__                                } else {_                                    for (ObjectCursor<String> alias : snapshotIndexMetaData.getAliases().keys()) {_                                        aliases.add(alias.value)__                                    }_                                }_                                IndexMetaData updatedIndexMetaData = indexMdBuilder.build()__                                if (partial) {_                                    populateIgnoredShards(index, ignoreShards)__                                }_                                rtBuilder.addAsNewRestore(updatedIndexMetaData, recoverySource, ignoreShards)__                                blocks.addBlocks(updatedIndexMetaData)__                                mdBuilder.put(updatedIndexMetaData, true)__                                renamedIndex = updatedIndexMetaData.getIndex()__                            } else {_                                validateExistingIndex(currentIndexMetaData, snapshotIndexMetaData, renamedIndexName, partial)__                                _                                IndexMetaData.Builder indexMdBuilder = IndexMetaData.builder(snapshotIndexMetaData).state(IndexMetaData.State.OPEN)__                                indexMdBuilder.version(Math.max(snapshotIndexMetaData.getVersion(), currentIndexMetaData.getVersion() + 1))__                                indexMdBuilder.mappingVersion(Math.max(snapshotIndexMetaData.getMappingVersion(), currentIndexMetaData.getMappingVersion() + 1))__                                indexMdBuilder.settingsVersion(Math.max(snapshotIndexMetaData.getSettingsVersion(), currentIndexMetaData.getSettingsVersion() + 1))__                                if (!request.includeAliases()) {_                                    _                                    if (!snapshotIndexMetaData.getAliases().isEmpty()) {_                                        indexMdBuilder.removeAllAliases()__                                    }_                                    _                                    for (ObjectCursor<AliasMetaData> alias : currentIndexMetaData.getAliases().values()) {_                                        indexMdBuilder.putAlias(alias.value)__                                    }_                                } else {_                                    for (ObjectCursor<String> alias : snapshotIndexMetaData.getAliases().keys()) {_                                        aliases.add(alias.value)__                                    }_                                }_                                indexMdBuilder.settings(Settings.builder().put(snapshotIndexMetaData.getSettings()).put(IndexMetaData.SETTING_INDEX_UUID, currentIndexMetaData.getIndexUUID()))__                                IndexMetaData updatedIndexMetaData = indexMdBuilder.index(renamedIndexName).build()__                                rtBuilder.addAsRestore(updatedIndexMetaData, recoverySource)__                                blocks.updateBlocks(updatedIndexMetaData)__                                mdBuilder.put(updatedIndexMetaData, true)__                                renamedIndex = updatedIndexMetaData.getIndex()__                            }__                            for (int shard = 0_ shard < snapshotIndexMetaData.getNumberOfShards()_ shard++) {_                                if (!ignoreShards.contains(shard)) {_                                    shardsBuilder.put(new ShardId(renamedIndex, shard), new RestoreInProgress.ShardRestoreStatus(clusterService.state().nodes().getLocalNodeId()))__                                } else {_                                    shardsBuilder.put(new ShardId(renamedIndex, shard), new RestoreInProgress.ShardRestoreStatus(clusterService.state().nodes().getLocalNodeId(), RestoreInProgress.State.FAILURE))__                                }_                            }_                        }__                        shards = shardsBuilder.build()__                        RestoreInProgress.Entry restoreEntry = new RestoreInProgress.Entry(snapshot, overallState(RestoreInProgress.State.INIT, shards), Collections.unmodifiableList(new ArrayList<>(indices.keySet())), shards)__                        builder.putCustom(RestoreInProgress.TYPE, new RestoreInProgress(restoreEntry))__                    } else {_                        shards = ImmutableOpenMap.of()__                    }__                    checkAliasNameConflicts(indices, aliases)___                    _                    if (request.includeGlobalState()) {_                        if (metaData.persistentSettings() != null) {_                            Settings settings = metaData.persistentSettings()__                            clusterSettings.validateUpdate(settings)__                            mdBuilder.persistentSettings(settings)__                        }_                        if (metaData.templates() != null) {_                            _                            for (ObjectCursor<IndexTemplateMetaData> cursor : metaData.templates().values()) {_                                mdBuilder.put(cursor.value)__                            }_                        }_                        if (metaData.customs() != null) {_                            for (ObjectObjectCursor<String, MetaData.Custom> cursor : metaData.customs()) {_                                if (!RepositoriesMetaData.TYPE.equals(cursor.key)) {_                                    _                                    _                                    mdBuilder.putCustom(cursor.key, cursor.value)__                                }_                            }_                        }_                    }__                    if (completed(shards)) {_                        _                        restoreInfo = new RestoreInfo(snapshotId.getName(),_                                                      Collections.unmodifiableList(new ArrayList<>(indices.keySet())),_                                                      shards.size(),_                                                      shards.size() - failedShards(shards))__                    }__                    RoutingTable rt = rtBuilder.build()__                    ClusterState updatedState = builder.metaData(mdBuilder).blocks(blocks).routingTable(rt).build()__                    return allocationService.reroute(updatedState, "restored snapshot [" + snapshot + "]")__                }__                private void checkAliasNameConflicts(Map<String, String> renamedIndices, Set<String> aliases) {_                    for (Map.Entry<String, String> renamedIndex : renamedIndices.entrySet()) {_                        if (aliases.contains(renamedIndex.getKey())) {_                            throw new SnapshotRestoreException(snapshot, "cannot rename index [" + renamedIndex.getValue() + "] into [" + renamedIndex.getKey() + "] because of conflict with an alias with the same name")__                        }_                    }_                }__                private void populateIgnoredShards(String index, IntSet ignoreShards) {_                    for (SnapshotShardFailure failure : snapshotInfo.shardFailures()) {_                        if (index.equals(failure.index())) {_                            ignoreShards.add(failure.shardId())__                        }_                    }_                }__                private boolean checkPartial(String index) {_                    _                    if (failed(snapshotInfo, index)) {_                        if (request.partial()) {_                            return true__                        } else {_                            throw new SnapshotRestoreException(snapshot, "index [" + index + "] wasn't fully snapshotted - cannot restore")__                        }_                    } else {_                        return false__                    }_                }__                private void validateExistingIndex(IndexMetaData currentIndexMetaData, IndexMetaData snapshotIndexMetaData, String renamedIndex, boolean partial) {_                    _                    if (currentIndexMetaData.getState() != IndexMetaData.State.CLOSE) {_                        _                        throw new SnapshotRestoreException(snapshot, "cannot restore index [" + renamedIndex + "] because an open index with same name already exists in the cluster. " +_                            "Either close or delete the existing index or restore the index under a different name by providing a rename pattern and replacement name")__                    }_                    _                    if (partial) {_                        throw new SnapshotRestoreException(snapshot, "cannot restore partial index [" + renamedIndex + "] because such index already exists")__                    }_                    _                    if (currentIndexMetaData.getNumberOfShards() != snapshotIndexMetaData.getNumberOfShards()) {_                        throw new SnapshotRestoreException(snapshot, "cannot restore index [" + renamedIndex + "] with [" + currentIndexMetaData.getNumberOfShards() +_                                "] shards from a snapshot of index [" + snapshotIndexMetaData.getIndex().getName() + "] with [" + snapshotIndexMetaData.getNumberOfShards() + "] shards")__                    }_                }__                _                private IndexMetaData updateIndexSettings(IndexMetaData indexMetaData, Settings changeSettings, String[] ignoreSettings) {_                    if (changeSettings.names().isEmpty() && ignoreSettings.length == 0) {_                        return indexMetaData__                    }_                    Settings normalizedChangeSettings = Settings.builder().put(changeSettings).normalizePrefix(IndexMetaData.INDEX_SETTING_PREFIX).build()__                    IndexMetaData.Builder builder = IndexMetaData.builder(indexMetaData)__                    Settings settings = indexMetaData.getSettings()__                    Set<String> keyFilters = new HashSet<>()__                    List<String> simpleMatchPatterns = new ArrayList<>()__                    for (String ignoredSetting : ignoreSettings) {_                        if (!Regex.isSimpleMatchPattern(ignoredSetting)) {_                            if (UNREMOVABLE_SETTINGS.contains(ignoredSetting)) {_                                throw new SnapshotRestoreException(snapshot, "cannot remove setting [" + ignoredSetting + "] on restore")__                            } else {_                                keyFilters.add(ignoredSetting)__                            }_                        } else {_                            simpleMatchPatterns.add(ignoredSetting)__                        }_                    }_                    Predicate<String> settingsFilter = k -> {_                        if (UNREMOVABLE_SETTINGS.contains(k) == false) {_                            for (String filterKey : keyFilters) {_                                if (k.equals(filterKey)) {_                                    return false__                                }_                            }_                            for (String pattern : simpleMatchPatterns) {_                                if (Regex.simpleMatch(pattern, k)) {_                                    return false__                                }_                            }_                        }_                        return true__                    }__                    Settings.Builder settingsBuilder = Settings.builder()_                        .put(settings.filter(settingsFilter))_                        .put(normalizedChangeSettings.filter(k -> {_                            if (UNMODIFIABLE_SETTINGS.contains(k)) {_                                throw new SnapshotRestoreException(snapshot, "cannot modify setting [" + k + "] on restore")__                            } else {_                                return true__                            }_                        }))__                    return builder.settings(settingsBuilder).build()__                }__                @Override_                public void onFailure(String source, Exception e) {_                    logger.warn(() -> new ParameterizedMessage("[{}] failed to restore snapshot", snapshotId), e)__                    listener.onFailure(e)__                }__                @Override_                public TimeValue timeout() {_                    return request.masterNodeTimeout()__                }__                @Override_                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                    listener.onResponse(new RestoreCompletionResponse(snapshot, restoreInfo))__                }_            })____        } catch (Exception e) {_            logger.warn(() -> new ParameterizedMessage("[{}] failed to restore snapshot", request.repositoryName + ":" + request.snapshotName), e)__            listener.onFailure(e)__        }_    };restores,snapshot,specified,in,the,restore,request,param,request,restore,request,param,listener,restore,listener;public,void,restore,snapshot,final,restore,request,request,final,action,listener,restore,completion,response,listener,try,repository,repository,repositories,service,repository,request,repository,name,final,repository,data,repository,data,repository,get,repository,data,final,optional,snapshot,id,incompatible,snapshot,id,repository,data,get,incompatible,snapshot,ids,stream,filter,s,request,snapshot,name,equals,s,get,name,find,first,if,incompatible,snapshot,id,is,present,throw,new,snapshot,restore,exception,request,repository,name,request,snapshot,name,cannot,restore,incompatible,snapshot,final,optional,snapshot,id,matching,snapshot,id,repository,data,get,snapshot,ids,stream,filter,s,request,snapshot,name,equals,s,get,name,find,first,if,matching,snapshot,id,is,present,false,throw,new,snapshot,restore,exception,request,repository,name,request,snapshot,name,snapshot,does,not,exist,final,snapshot,id,snapshot,id,matching,snapshot,id,get,final,snapshot,info,snapshot,info,repository,get,snapshot,info,snapshot,id,final,snapshot,snapshot,new,snapshot,request,repository,name,snapshot,id,validate,snapshot,restorable,request,repository,name,snapshot,info,final,list,string,indices,in,snapshot,filter,indices,snapshot,info,indices,request,indices,request,indices,options,final,meta,data,builder,meta,data,builder,if,request,include,global,state,meta,data,builder,meta,data,builder,repository,get,snapshot,global,meta,data,snapshot,id,else,meta,data,builder,meta,data,builder,final,list,index,id,index,ids,in,snapshot,repository,data,resolve,indices,indices,in,snapshot,for,index,id,index,id,index,ids,in,snapshot,meta,data,builder,put,repository,get,snapshot,index,meta,data,snapshot,id,index,id,false,final,meta,data,meta,data,meta,data,builder,build,final,map,string,string,indices,renamed,indices,request,indices,in,snapshot,cluster,service,submit,state,update,task,request,cause,new,cluster,state,update,task,restore,info,restore,info,null,override,public,cluster,state,execute,cluster,state,current,state,restore,in,progress,restore,in,progress,current,state,custom,restore,in,progress,type,if,restore,in,progress,null,restore,in,progress,entries,is,empty,throw,new,concurrent,snapshot,execution,exception,snapshot,restore,process,is,already,running,in,this,cluster,snapshot,deletions,in,progress,deletions,in,progress,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,throw,new,concurrent,snapshot,execution,exception,snapshot,cannot,restore,a,snapshot,while,a,snapshot,deletion,is,in,progress,deletions,in,progress,get,entries,get,0,get,snapshot,cluster,state,builder,builder,cluster,state,builder,current,state,meta,data,builder,md,builder,meta,data,builder,current,state,meta,data,cluster,blocks,builder,blocks,cluster,blocks,builder,blocks,current,state,blocks,routing,table,builder,rt,builder,routing,table,builder,current,state,routing,table,immutable,open,map,shard,id,restore,in,progress,shard,restore,status,shards,set,string,aliases,new,hash,set,if,indices,is,empty,false,immutable,open,map,builder,shard,id,restore,in,progress,shard,restore,status,shards,builder,immutable,open,map,builder,final,version,min,index,compatibility,version,current,state,get,nodes,get,max,node,version,minimum,index,compatibility,version,for,map,entry,string,string,index,entry,indices,entry,set,string,index,index,entry,get,value,boolean,partial,check,partial,index,snapshot,recovery,source,recovery,source,new,snapshot,recovery,source,snapshot,snapshot,info,version,index,string,renamed,index,name,index,entry,get,key,index,meta,data,snapshot,index,meta,data,meta,data,index,index,snapshot,index,meta,data,update,index,settings,snapshot,index,meta,data,request,index,settings,request,ignore,index,settings,try,snapshot,index,meta,data,meta,data,index,upgrade,service,upgrade,index,meta,data,snapshot,index,meta,data,min,index,compatibility,version,catch,exception,ex,throw,new,snapshot,restore,exception,snapshot,cannot,restore,index,index,because,it,cannot,be,upgraded,ex,index,meta,data,current,index,meta,data,current,state,meta,data,index,renamed,index,name,int,set,ignore,shards,new,int,hash,set,final,index,renamed,index,if,current,index,meta,data,null,meta,data,create,index,service,validate,index,name,renamed,index,name,current,state,create,index,service,validate,index,settings,renamed,index,name,snapshot,index,meta,data,get,settings,false,index,meta,data,builder,index,md,builder,index,meta,data,builder,snapshot,index,meta,data,state,index,meta,data,state,open,index,renamed,index,name,index,md,builder,settings,settings,builder,put,snapshot,index,meta,data,get,settings,put,index,meta,data,uuids,random,base64uuid,if,request,include,aliases,snapshot,index,meta,data,get,aliases,is,empty,index,md,builder,remove,all,aliases,else,for,object,cursor,string,alias,snapshot,index,meta,data,get,aliases,keys,aliases,add,alias,value,index,meta,data,updated,index,meta,data,index,md,builder,build,if,partial,populate,ignored,shards,index,ignore,shards,rt,builder,add,as,new,restore,updated,index,meta,data,recovery,source,ignore,shards,blocks,add,blocks,updated,index,meta,data,md,builder,put,updated,index,meta,data,true,renamed,index,updated,index,meta,data,get,index,else,validate,existing,index,current,index,meta,data,snapshot,index,meta,data,renamed,index,name,partial,index,meta,data,builder,index,md,builder,index,meta,data,builder,snapshot,index,meta,data,state,index,meta,data,state,open,index,md,builder,version,math,max,snapshot,index,meta,data,get,version,current,index,meta,data,get,version,1,index,md,builder,mapping,version,math,max,snapshot,index,meta,data,get,mapping,version,current,index,meta,data,get,mapping,version,1,index,md,builder,settings,version,math,max,snapshot,index,meta,data,get,settings,version,current,index,meta,data,get,settings,version,1,if,request,include,aliases,if,snapshot,index,meta,data,get,aliases,is,empty,index,md,builder,remove,all,aliases,for,object,cursor,alias,meta,data,alias,current,index,meta,data,get,aliases,values,index,md,builder,put,alias,alias,value,else,for,object,cursor,string,alias,snapshot,index,meta,data,get,aliases,keys,aliases,add,alias,value,index,md,builder,settings,settings,builder,put,snapshot,index,meta,data,get,settings,put,index,meta,data,current,index,meta,data,get,index,uuid,index,meta,data,updated,index,meta,data,index,md,builder,index,renamed,index,name,build,rt,builder,add,as,restore,updated,index,meta,data,recovery,source,blocks,update,blocks,updated,index,meta,data,md,builder,put,updated,index,meta,data,true,renamed,index,updated,index,meta,data,get,index,for,int,shard,0,shard,snapshot,index,meta,data,get,number,of,shards,shard,if,ignore,shards,contains,shard,shards,builder,put,new,shard,id,renamed,index,shard,new,restore,in,progress,shard,restore,status,cluster,service,state,nodes,get,local,node,id,else,shards,builder,put,new,shard,id,renamed,index,shard,new,restore,in,progress,shard,restore,status,cluster,service,state,nodes,get,local,node,id,restore,in,progress,state,failure,shards,shards,builder,build,restore,in,progress,entry,restore,entry,new,restore,in,progress,entry,snapshot,overall,state,restore,in,progress,state,init,shards,collections,unmodifiable,list,new,array,list,indices,key,set,shards,builder,put,custom,restore,in,progress,type,new,restore,in,progress,restore,entry,else,shards,immutable,open,map,of,check,alias,name,conflicts,indices,aliases,if,request,include,global,state,if,meta,data,persistent,settings,null,settings,settings,meta,data,persistent,settings,cluster,settings,validate,update,settings,md,builder,persistent,settings,settings,if,meta,data,templates,null,for,object,cursor,index,template,meta,data,cursor,meta,data,templates,values,md,builder,put,cursor,value,if,meta,data,customs,null,for,object,object,cursor,string,meta,data,custom,cursor,meta,data,customs,if,repositories,meta,data,type,equals,cursor,key,md,builder,put,custom,cursor,key,cursor,value,if,completed,shards,restore,info,new,restore,info,snapshot,id,get,name,collections,unmodifiable,list,new,array,list,indices,key,set,shards,size,shards,size,failed,shards,shards,routing,table,rt,rt,builder,build,cluster,state,updated,state,builder,meta,data,md,builder,blocks,blocks,routing,table,rt,build,return,allocation,service,reroute,updated,state,restored,snapshot,snapshot,private,void,check,alias,name,conflicts,map,string,string,renamed,indices,set,string,aliases,for,map,entry,string,string,renamed,index,renamed,indices,entry,set,if,aliases,contains,renamed,index,get,key,throw,new,snapshot,restore,exception,snapshot,cannot,rename,index,renamed,index,get,value,into,renamed,index,get,key,because,of,conflict,with,an,alias,with,the,same,name,private,void,populate,ignored,shards,string,index,int,set,ignore,shards,for,snapshot,shard,failure,failure,snapshot,info,shard,failures,if,index,equals,failure,index,ignore,shards,add,failure,shard,id,private,boolean,check,partial,string,index,if,failed,snapshot,info,index,if,request,partial,return,true,else,throw,new,snapshot,restore,exception,snapshot,index,index,wasn,t,fully,snapshotted,cannot,restore,else,return,false,private,void,validate,existing,index,index,meta,data,current,index,meta,data,index,meta,data,snapshot,index,meta,data,string,renamed,index,boolean,partial,if,current,index,meta,data,get,state,index,meta,data,state,close,throw,new,snapshot,restore,exception,snapshot,cannot,restore,index,renamed,index,because,an,open,index,with,same,name,already,exists,in,the,cluster,either,close,or,delete,the,existing,index,or,restore,the,index,under,a,different,name,by,providing,a,rename,pattern,and,replacement,name,if,partial,throw,new,snapshot,restore,exception,snapshot,cannot,restore,partial,index,renamed,index,because,such,index,already,exists,if,current,index,meta,data,get,number,of,shards,snapshot,index,meta,data,get,number,of,shards,throw,new,snapshot,restore,exception,snapshot,cannot,restore,index,renamed,index,with,current,index,meta,data,get,number,of,shards,shards,from,a,snapshot,of,index,snapshot,index,meta,data,get,index,get,name,with,snapshot,index,meta,data,get,number,of,shards,shards,private,index,meta,data,update,index,settings,index,meta,data,index,meta,data,settings,change,settings,string,ignore,settings,if,change,settings,names,is,empty,ignore,settings,length,0,return,index,meta,data,settings,normalized,change,settings,settings,builder,put,change,settings,normalize,prefix,index,meta,data,build,index,meta,data,builder,builder,index,meta,data,builder,index,meta,data,settings,settings,index,meta,data,get,settings,set,string,key,filters,new,hash,set,list,string,simple,match,patterns,new,array,list,for,string,ignored,setting,ignore,settings,if,regex,is,simple,match,pattern,ignored,setting,if,contains,ignored,setting,throw,new,snapshot,restore,exception,snapshot,cannot,remove,setting,ignored,setting,on,restore,else,key,filters,add,ignored,setting,else,simple,match,patterns,add,ignored,setting,predicate,string,settings,filter,k,if,contains,k,false,for,string,filter,key,key,filters,if,k,equals,filter,key,return,false,for,string,pattern,simple,match,patterns,if,regex,simple,match,pattern,k,return,false,return,true,settings,builder,settings,builder,settings,builder,put,settings,filter,settings,filter,put,normalized,change,settings,filter,k,if,contains,k,throw,new,snapshot,restore,exception,snapshot,cannot,modify,setting,k,on,restore,else,return,true,return,builder,settings,settings,builder,build,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,restore,snapshot,snapshot,id,e,listener,on,failure,e,override,public,time,value,timeout,return,request,master,node,timeout,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,listener,on,response,new,restore,completion,response,snapshot,restore,info,catch,exception,e,logger,warn,new,parameterized,message,failed,to,restore,snapshot,request,repository,name,request,snapshot,name,e,listener,on,failure,e
RestoreService -> public void restoreSnapshot(final RestoreRequest request, final ActionListener<RestoreCompletionResponse> listener);1540486836;Restores snapshot specified in the restore request.__@param request  restore request_@param listener restore listener;public void restoreSnapshot(final RestoreRequest request, final ActionListener<RestoreCompletionResponse> listener) {_        try {_            _            Repository repository = repositoriesService.repository(request.repositoryName)__            final RepositoryData repositoryData = repository.getRepositoryData()__            final Optional<SnapshotId> incompatibleSnapshotId =_                repositoryData.getIncompatibleSnapshotIds().stream().filter(s -> request.snapshotName.equals(s.getName())).findFirst()__            if (incompatibleSnapshotId.isPresent()) {_                throw new SnapshotRestoreException(request.repositoryName, request.snapshotName, "cannot restore incompatible snapshot")__            }_            final Optional<SnapshotId> matchingSnapshotId = repositoryData.getSnapshotIds().stream()_                .filter(s -> request.snapshotName.equals(s.getName())).findFirst()__            if (matchingSnapshotId.isPresent() == false) {_                throw new SnapshotRestoreException(request.repositoryName, request.snapshotName, "snapshot does not exist")__            }__            final SnapshotId snapshotId = matchingSnapshotId.get()__            final SnapshotInfo snapshotInfo = repository.getSnapshotInfo(snapshotId)__            final Snapshot snapshot = new Snapshot(request.repositoryName, snapshotId)___            _            validateSnapshotRestorable(request.repositoryName, snapshotInfo)___            _            final List<String> indicesInSnapshot = filterIndices(snapshotInfo.indices(), request.indices(), request.indicesOptions())___            final MetaData.Builder metaDataBuilder__            if (request.includeGlobalState()) {_                metaDataBuilder = MetaData.builder(repository.getSnapshotGlobalMetaData(snapshotId))__            } else {_                metaDataBuilder = MetaData.builder()__            }__            final List<IndexId> indexIdsInSnapshot = repositoryData.resolveIndices(indicesInSnapshot)__            for (IndexId indexId : indexIdsInSnapshot) {_                metaDataBuilder.put(repository.getSnapshotIndexMetaData(snapshotId, indexId), false)__            }__            final MetaData metaData = metaDataBuilder.build()___            _            _            final Map<String, String> indices = renamedIndices(request, indicesInSnapshot)___            _            _            clusterService.submitStateUpdateTask(request.cause(), new ClusterStateUpdateTask() {_                RestoreInfo restoreInfo = null___                @Override_                public ClusterState execute(ClusterState currentState) {_                    _                    _                    RestoreInProgress restoreInProgress = currentState.custom(RestoreInProgress.TYPE)__                    if (restoreInProgress != null && !restoreInProgress.entries().isEmpty()) {_                        throw new ConcurrentSnapshotExecutionException(snapshot, "Restore process is already running in this cluster")__                    }_                    _                    SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                    if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                        throw new ConcurrentSnapshotExecutionException(snapshot,_                            "cannot restore a snapshot while a snapshot deletion is in-progress [" +_                                deletionsInProgress.getEntries().get(0).getSnapshot() + "]")__                    }__                    _                    ClusterState.Builder builder = ClusterState.builder(currentState)__                    MetaData.Builder mdBuilder = MetaData.builder(currentState.metaData())__                    ClusterBlocks.Builder blocks = ClusterBlocks.builder().blocks(currentState.blocks())__                    RoutingTable.Builder rtBuilder = RoutingTable.builder(currentState.routingTable())__                    ImmutableOpenMap<ShardId, RestoreInProgress.ShardRestoreStatus> shards__                    Set<String> aliases = new HashSet<>()___                    if (indices.isEmpty() == false) {_                        _                        ImmutableOpenMap.Builder<ShardId, RestoreInProgress.ShardRestoreStatus> shardsBuilder = ImmutableOpenMap.builder()__                        final Version minIndexCompatibilityVersion = currentState.getNodes().getMaxNodeVersion()_                            .minimumIndexCompatibilityVersion()__                        for (Map.Entry<String, String> indexEntry : indices.entrySet()) {_                            String index = indexEntry.getValue()__                            boolean partial = checkPartial(index)__                            SnapshotRecoverySource recoverySource = new SnapshotRecoverySource(snapshot, snapshotInfo.version(), index)__                            String renamedIndexName = indexEntry.getKey()__                            IndexMetaData snapshotIndexMetaData = metaData.index(index)__                            snapshotIndexMetaData = updateIndexSettings(snapshotIndexMetaData, request.indexSettings, request.ignoreIndexSettings)__                            try {_                                snapshotIndexMetaData = metaDataIndexUpgradeService.upgradeIndexMetaData(snapshotIndexMetaData,_                                    minIndexCompatibilityVersion)__                            } catch (Exception ex) {_                                throw new SnapshotRestoreException(snapshot, "cannot restore index [" + index + "] because it cannot be upgraded", ex)__                            }_                            _                            IndexMetaData currentIndexMetaData = currentState.metaData().index(renamedIndexName)__                            IntSet ignoreShards = new IntHashSet()__                            final Index renamedIndex__                            if (currentIndexMetaData == null) {_                                _                                _                                MetaDataCreateIndexService.validateIndexName(renamedIndexName, currentState)__                                createIndexService.validateIndexSettings(renamedIndexName, snapshotIndexMetaData.getSettings(), currentState, false)__                                IndexMetaData.Builder indexMdBuilder = IndexMetaData.builder(snapshotIndexMetaData).state(IndexMetaData.State.OPEN).index(renamedIndexName)__                                indexMdBuilder.settings(Settings.builder().put(snapshotIndexMetaData.getSettings()).put(IndexMetaData.SETTING_INDEX_UUID, UUIDs.randomBase64UUID()))__                                if (!request.includeAliases() && !snapshotIndexMetaData.getAliases().isEmpty()) {_                                    _                                    indexMdBuilder.removeAllAliases()__                                } else {_                                    for (ObjectCursor<String> alias : snapshotIndexMetaData.getAliases().keys()) {_                                        aliases.add(alias.value)__                                    }_                                }_                                IndexMetaData updatedIndexMetaData = indexMdBuilder.build()__                                if (partial) {_                                    populateIgnoredShards(index, ignoreShards)__                                }_                                rtBuilder.addAsNewRestore(updatedIndexMetaData, recoverySource, ignoreShards)__                                blocks.addBlocks(updatedIndexMetaData)__                                mdBuilder.put(updatedIndexMetaData, true)__                                renamedIndex = updatedIndexMetaData.getIndex()__                            } else {_                                validateExistingIndex(currentIndexMetaData, snapshotIndexMetaData, renamedIndexName, partial)__                                _                                IndexMetaData.Builder indexMdBuilder = IndexMetaData.builder(snapshotIndexMetaData).state(IndexMetaData.State.OPEN)__                                indexMdBuilder.version(Math.max(snapshotIndexMetaData.getVersion(), currentIndexMetaData.getVersion() + 1))__                                indexMdBuilder.mappingVersion(Math.max(snapshotIndexMetaData.getMappingVersion(), currentIndexMetaData.getMappingVersion() + 1))__                                indexMdBuilder.settingsVersion(Math.max(snapshotIndexMetaData.getSettingsVersion(), currentIndexMetaData.getSettingsVersion() + 1))__                                if (!request.includeAliases()) {_                                    _                                    if (!snapshotIndexMetaData.getAliases().isEmpty()) {_                                        indexMdBuilder.removeAllAliases()__                                    }_                                    _                                    for (ObjectCursor<AliasMetaData> alias : currentIndexMetaData.getAliases().values()) {_                                        indexMdBuilder.putAlias(alias.value)__                                    }_                                } else {_                                    for (ObjectCursor<String> alias : snapshotIndexMetaData.getAliases().keys()) {_                                        aliases.add(alias.value)__                                    }_                                }_                                indexMdBuilder.settings(Settings.builder().put(snapshotIndexMetaData.getSettings()).put(IndexMetaData.SETTING_INDEX_UUID, currentIndexMetaData.getIndexUUID()))__                                IndexMetaData updatedIndexMetaData = indexMdBuilder.index(renamedIndexName).build()__                                rtBuilder.addAsRestore(updatedIndexMetaData, recoverySource)__                                blocks.updateBlocks(updatedIndexMetaData)__                                mdBuilder.put(updatedIndexMetaData, true)__                                renamedIndex = updatedIndexMetaData.getIndex()__                            }__                            for (int shard = 0_ shard < snapshotIndexMetaData.getNumberOfShards()_ shard++) {_                                if (!ignoreShards.contains(shard)) {_                                    shardsBuilder.put(new ShardId(renamedIndex, shard), new RestoreInProgress.ShardRestoreStatus(clusterService.state().nodes().getLocalNodeId()))__                                } else {_                                    shardsBuilder.put(new ShardId(renamedIndex, shard), new RestoreInProgress.ShardRestoreStatus(clusterService.state().nodes().getLocalNodeId(), RestoreInProgress.State.FAILURE))__                                }_                            }_                        }__                        shards = shardsBuilder.build()__                        RestoreInProgress.Entry restoreEntry = new RestoreInProgress.Entry(snapshot, overallState(RestoreInProgress.State.INIT, shards), Collections.unmodifiableList(new ArrayList<>(indices.keySet())), shards)__                        builder.putCustom(RestoreInProgress.TYPE, new RestoreInProgress(restoreEntry))__                    } else {_                        shards = ImmutableOpenMap.of()__                    }__                    checkAliasNameConflicts(indices, aliases)___                    _                    if (request.includeGlobalState()) {_                        if (metaData.persistentSettings() != null) {_                            Settings settings = metaData.persistentSettings()__                            clusterSettings.validateUpdate(settings)__                            mdBuilder.persistentSettings(settings)__                        }_                        if (metaData.templates() != null) {_                            _                            for (ObjectCursor<IndexTemplateMetaData> cursor : metaData.templates().values()) {_                                mdBuilder.put(cursor.value)__                            }_                        }_                        if (metaData.customs() != null) {_                            for (ObjectObjectCursor<String, MetaData.Custom> cursor : metaData.customs()) {_                                if (!RepositoriesMetaData.TYPE.equals(cursor.key)) {_                                    _                                    _                                    mdBuilder.putCustom(cursor.key, cursor.value)__                                }_                            }_                        }_                    }__                    if (completed(shards)) {_                        _                        restoreInfo = new RestoreInfo(snapshotId.getName(),_                                                      Collections.unmodifiableList(new ArrayList<>(indices.keySet())),_                                                      shards.size(),_                                                      shards.size() - failedShards(shards))__                    }__                    RoutingTable rt = rtBuilder.build()__                    ClusterState updatedState = builder.metaData(mdBuilder).blocks(blocks).routingTable(rt).build()__                    return allocationService.reroute(updatedState, "restored snapshot [" + snapshot + "]")__                }__                private void checkAliasNameConflicts(Map<String, String> renamedIndices, Set<String> aliases) {_                    for (Map.Entry<String, String> renamedIndex : renamedIndices.entrySet()) {_                        if (aliases.contains(renamedIndex.getKey())) {_                            throw new SnapshotRestoreException(snapshot, "cannot rename index [" + renamedIndex.getValue() + "] into [" + renamedIndex.getKey() + "] because of conflict with an alias with the same name")__                        }_                    }_                }__                private void populateIgnoredShards(String index, IntSet ignoreShards) {_                    for (SnapshotShardFailure failure : snapshotInfo.shardFailures()) {_                        if (index.equals(failure.index())) {_                            ignoreShards.add(failure.shardId())__                        }_                    }_                }__                private boolean checkPartial(String index) {_                    _                    if (failed(snapshotInfo, index)) {_                        if (request.partial()) {_                            return true__                        } else {_                            throw new SnapshotRestoreException(snapshot, "index [" + index + "] wasn't fully snapshotted - cannot restore")__                        }_                    } else {_                        return false__                    }_                }__                private void validateExistingIndex(IndexMetaData currentIndexMetaData, IndexMetaData snapshotIndexMetaData, String renamedIndex, boolean partial) {_                    _                    if (currentIndexMetaData.getState() != IndexMetaData.State.CLOSE) {_                        _                        throw new SnapshotRestoreException(snapshot, "cannot restore index [" + renamedIndex + "] because an open index with same name already exists in the cluster. " +_                            "Either close or delete the existing index or restore the index under a different name by providing a rename pattern and replacement name")__                    }_                    _                    if (partial) {_                        throw new SnapshotRestoreException(snapshot, "cannot restore partial index [" + renamedIndex + "] because such index already exists")__                    }_                    _                    if (currentIndexMetaData.getNumberOfShards() != snapshotIndexMetaData.getNumberOfShards()) {_                        throw new SnapshotRestoreException(snapshot, "cannot restore index [" + renamedIndex + "] with [" + currentIndexMetaData.getNumberOfShards() +_                                "] shards from a snapshot of index [" + snapshotIndexMetaData.getIndex().getName() + "] with [" + snapshotIndexMetaData.getNumberOfShards() + "] shards")__                    }_                }__                _                private IndexMetaData updateIndexSettings(IndexMetaData indexMetaData, Settings changeSettings, String[] ignoreSettings) {_                    if (changeSettings.names().isEmpty() && ignoreSettings.length == 0) {_                        return indexMetaData__                    }_                    Settings normalizedChangeSettings = Settings.builder().put(changeSettings).normalizePrefix(IndexMetaData.INDEX_SETTING_PREFIX).build()__                    IndexMetaData.Builder builder = IndexMetaData.builder(indexMetaData)__                    Settings settings = indexMetaData.getSettings()__                    Set<String> keyFilters = new HashSet<>()__                    List<String> simpleMatchPatterns = new ArrayList<>()__                    for (String ignoredSetting : ignoreSettings) {_                        if (!Regex.isSimpleMatchPattern(ignoredSetting)) {_                            if (UNREMOVABLE_SETTINGS.contains(ignoredSetting)) {_                                throw new SnapshotRestoreException(snapshot, "cannot remove setting [" + ignoredSetting + "] on restore")__                            } else {_                                keyFilters.add(ignoredSetting)__                            }_                        } else {_                            simpleMatchPatterns.add(ignoredSetting)__                        }_                    }_                    Predicate<String> settingsFilter = k -> {_                        if (UNREMOVABLE_SETTINGS.contains(k) == false) {_                            for (String filterKey : keyFilters) {_                                if (k.equals(filterKey)) {_                                    return false__                                }_                            }_                            for (String pattern : simpleMatchPatterns) {_                                if (Regex.simpleMatch(pattern, k)) {_                                    return false__                                }_                            }_                        }_                        return true__                    }__                    Settings.Builder settingsBuilder = Settings.builder()_                        .put(settings.filter(settingsFilter))_                        .put(normalizedChangeSettings.filter(k -> {_                            if (UNMODIFIABLE_SETTINGS.contains(k)) {_                                throw new SnapshotRestoreException(snapshot, "cannot modify setting [" + k + "] on restore")__                            } else {_                                return true__                            }_                        }))__                    return builder.settings(settingsBuilder).build()__                }__                @Override_                public void onFailure(String source, Exception e) {_                    logger.warn(() -> new ParameterizedMessage("[{}] failed to restore snapshot", snapshotId), e)__                    listener.onFailure(e)__                }__                @Override_                public TimeValue timeout() {_                    return request.masterNodeTimeout()__                }__                @Override_                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                    listener.onResponse(new RestoreCompletionResponse(snapshot, restoreInfo))__                }_            })____        } catch (Exception e) {_            logger.warn(() -> new ParameterizedMessage("[{}] failed to restore snapshot", request.repositoryName + ":" + request.snapshotName), e)__            listener.onFailure(e)__        }_    };restores,snapshot,specified,in,the,restore,request,param,request,restore,request,param,listener,restore,listener;public,void,restore,snapshot,final,restore,request,request,final,action,listener,restore,completion,response,listener,try,repository,repository,repositories,service,repository,request,repository,name,final,repository,data,repository,data,repository,get,repository,data,final,optional,snapshot,id,incompatible,snapshot,id,repository,data,get,incompatible,snapshot,ids,stream,filter,s,request,snapshot,name,equals,s,get,name,find,first,if,incompatible,snapshot,id,is,present,throw,new,snapshot,restore,exception,request,repository,name,request,snapshot,name,cannot,restore,incompatible,snapshot,final,optional,snapshot,id,matching,snapshot,id,repository,data,get,snapshot,ids,stream,filter,s,request,snapshot,name,equals,s,get,name,find,first,if,matching,snapshot,id,is,present,false,throw,new,snapshot,restore,exception,request,repository,name,request,snapshot,name,snapshot,does,not,exist,final,snapshot,id,snapshot,id,matching,snapshot,id,get,final,snapshot,info,snapshot,info,repository,get,snapshot,info,snapshot,id,final,snapshot,snapshot,new,snapshot,request,repository,name,snapshot,id,validate,snapshot,restorable,request,repository,name,snapshot,info,final,list,string,indices,in,snapshot,filter,indices,snapshot,info,indices,request,indices,request,indices,options,final,meta,data,builder,meta,data,builder,if,request,include,global,state,meta,data,builder,meta,data,builder,repository,get,snapshot,global,meta,data,snapshot,id,else,meta,data,builder,meta,data,builder,final,list,index,id,index,ids,in,snapshot,repository,data,resolve,indices,indices,in,snapshot,for,index,id,index,id,index,ids,in,snapshot,meta,data,builder,put,repository,get,snapshot,index,meta,data,snapshot,id,index,id,false,final,meta,data,meta,data,meta,data,builder,build,final,map,string,string,indices,renamed,indices,request,indices,in,snapshot,cluster,service,submit,state,update,task,request,cause,new,cluster,state,update,task,restore,info,restore,info,null,override,public,cluster,state,execute,cluster,state,current,state,restore,in,progress,restore,in,progress,current,state,custom,restore,in,progress,type,if,restore,in,progress,null,restore,in,progress,entries,is,empty,throw,new,concurrent,snapshot,execution,exception,snapshot,restore,process,is,already,running,in,this,cluster,snapshot,deletions,in,progress,deletions,in,progress,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,throw,new,concurrent,snapshot,execution,exception,snapshot,cannot,restore,a,snapshot,while,a,snapshot,deletion,is,in,progress,deletions,in,progress,get,entries,get,0,get,snapshot,cluster,state,builder,builder,cluster,state,builder,current,state,meta,data,builder,md,builder,meta,data,builder,current,state,meta,data,cluster,blocks,builder,blocks,cluster,blocks,builder,blocks,current,state,blocks,routing,table,builder,rt,builder,routing,table,builder,current,state,routing,table,immutable,open,map,shard,id,restore,in,progress,shard,restore,status,shards,set,string,aliases,new,hash,set,if,indices,is,empty,false,immutable,open,map,builder,shard,id,restore,in,progress,shard,restore,status,shards,builder,immutable,open,map,builder,final,version,min,index,compatibility,version,current,state,get,nodes,get,max,node,version,minimum,index,compatibility,version,for,map,entry,string,string,index,entry,indices,entry,set,string,index,index,entry,get,value,boolean,partial,check,partial,index,snapshot,recovery,source,recovery,source,new,snapshot,recovery,source,snapshot,snapshot,info,version,index,string,renamed,index,name,index,entry,get,key,index,meta,data,snapshot,index,meta,data,meta,data,index,index,snapshot,index,meta,data,update,index,settings,snapshot,index,meta,data,request,index,settings,request,ignore,index,settings,try,snapshot,index,meta,data,meta,data,index,upgrade,service,upgrade,index,meta,data,snapshot,index,meta,data,min,index,compatibility,version,catch,exception,ex,throw,new,snapshot,restore,exception,snapshot,cannot,restore,index,index,because,it,cannot,be,upgraded,ex,index,meta,data,current,index,meta,data,current,state,meta,data,index,renamed,index,name,int,set,ignore,shards,new,int,hash,set,final,index,renamed,index,if,current,index,meta,data,null,meta,data,create,index,service,validate,index,name,renamed,index,name,current,state,create,index,service,validate,index,settings,renamed,index,name,snapshot,index,meta,data,get,settings,current,state,false,index,meta,data,builder,index,md,builder,index,meta,data,builder,snapshot,index,meta,data,state,index,meta,data,state,open,index,renamed,index,name,index,md,builder,settings,settings,builder,put,snapshot,index,meta,data,get,settings,put,index,meta,data,uuids,random,base64uuid,if,request,include,aliases,snapshot,index,meta,data,get,aliases,is,empty,index,md,builder,remove,all,aliases,else,for,object,cursor,string,alias,snapshot,index,meta,data,get,aliases,keys,aliases,add,alias,value,index,meta,data,updated,index,meta,data,index,md,builder,build,if,partial,populate,ignored,shards,index,ignore,shards,rt,builder,add,as,new,restore,updated,index,meta,data,recovery,source,ignore,shards,blocks,add,blocks,updated,index,meta,data,md,builder,put,updated,index,meta,data,true,renamed,index,updated,index,meta,data,get,index,else,validate,existing,index,current,index,meta,data,snapshot,index,meta,data,renamed,index,name,partial,index,meta,data,builder,index,md,builder,index,meta,data,builder,snapshot,index,meta,data,state,index,meta,data,state,open,index,md,builder,version,math,max,snapshot,index,meta,data,get,version,current,index,meta,data,get,version,1,index,md,builder,mapping,version,math,max,snapshot,index,meta,data,get,mapping,version,current,index,meta,data,get,mapping,version,1,index,md,builder,settings,version,math,max,snapshot,index,meta,data,get,settings,version,current,index,meta,data,get,settings,version,1,if,request,include,aliases,if,snapshot,index,meta,data,get,aliases,is,empty,index,md,builder,remove,all,aliases,for,object,cursor,alias,meta,data,alias,current,index,meta,data,get,aliases,values,index,md,builder,put,alias,alias,value,else,for,object,cursor,string,alias,snapshot,index,meta,data,get,aliases,keys,aliases,add,alias,value,index,md,builder,settings,settings,builder,put,snapshot,index,meta,data,get,settings,put,index,meta,data,current,index,meta,data,get,index,uuid,index,meta,data,updated,index,meta,data,index,md,builder,index,renamed,index,name,build,rt,builder,add,as,restore,updated,index,meta,data,recovery,source,blocks,update,blocks,updated,index,meta,data,md,builder,put,updated,index,meta,data,true,renamed,index,updated,index,meta,data,get,index,for,int,shard,0,shard,snapshot,index,meta,data,get,number,of,shards,shard,if,ignore,shards,contains,shard,shards,builder,put,new,shard,id,renamed,index,shard,new,restore,in,progress,shard,restore,status,cluster,service,state,nodes,get,local,node,id,else,shards,builder,put,new,shard,id,renamed,index,shard,new,restore,in,progress,shard,restore,status,cluster,service,state,nodes,get,local,node,id,restore,in,progress,state,failure,shards,shards,builder,build,restore,in,progress,entry,restore,entry,new,restore,in,progress,entry,snapshot,overall,state,restore,in,progress,state,init,shards,collections,unmodifiable,list,new,array,list,indices,key,set,shards,builder,put,custom,restore,in,progress,type,new,restore,in,progress,restore,entry,else,shards,immutable,open,map,of,check,alias,name,conflicts,indices,aliases,if,request,include,global,state,if,meta,data,persistent,settings,null,settings,settings,meta,data,persistent,settings,cluster,settings,validate,update,settings,md,builder,persistent,settings,settings,if,meta,data,templates,null,for,object,cursor,index,template,meta,data,cursor,meta,data,templates,values,md,builder,put,cursor,value,if,meta,data,customs,null,for,object,object,cursor,string,meta,data,custom,cursor,meta,data,customs,if,repositories,meta,data,type,equals,cursor,key,md,builder,put,custom,cursor,key,cursor,value,if,completed,shards,restore,info,new,restore,info,snapshot,id,get,name,collections,unmodifiable,list,new,array,list,indices,key,set,shards,size,shards,size,failed,shards,shards,routing,table,rt,rt,builder,build,cluster,state,updated,state,builder,meta,data,md,builder,blocks,blocks,routing,table,rt,build,return,allocation,service,reroute,updated,state,restored,snapshot,snapshot,private,void,check,alias,name,conflicts,map,string,string,renamed,indices,set,string,aliases,for,map,entry,string,string,renamed,index,renamed,indices,entry,set,if,aliases,contains,renamed,index,get,key,throw,new,snapshot,restore,exception,snapshot,cannot,rename,index,renamed,index,get,value,into,renamed,index,get,key,because,of,conflict,with,an,alias,with,the,same,name,private,void,populate,ignored,shards,string,index,int,set,ignore,shards,for,snapshot,shard,failure,failure,snapshot,info,shard,failures,if,index,equals,failure,index,ignore,shards,add,failure,shard,id,private,boolean,check,partial,string,index,if,failed,snapshot,info,index,if,request,partial,return,true,else,throw,new,snapshot,restore,exception,snapshot,index,index,wasn,t,fully,snapshotted,cannot,restore,else,return,false,private,void,validate,existing,index,index,meta,data,current,index,meta,data,index,meta,data,snapshot,index,meta,data,string,renamed,index,boolean,partial,if,current,index,meta,data,get,state,index,meta,data,state,close,throw,new,snapshot,restore,exception,snapshot,cannot,restore,index,renamed,index,because,an,open,index,with,same,name,already,exists,in,the,cluster,either,close,or,delete,the,existing,index,or,restore,the,index,under,a,different,name,by,providing,a,rename,pattern,and,replacement,name,if,partial,throw,new,snapshot,restore,exception,snapshot,cannot,restore,partial,index,renamed,index,because,such,index,already,exists,if,current,index,meta,data,get,number,of,shards,snapshot,index,meta,data,get,number,of,shards,throw,new,snapshot,restore,exception,snapshot,cannot,restore,index,renamed,index,with,current,index,meta,data,get,number,of,shards,shards,from,a,snapshot,of,index,snapshot,index,meta,data,get,index,get,name,with,snapshot,index,meta,data,get,number,of,shards,shards,private,index,meta,data,update,index,settings,index,meta,data,index,meta,data,settings,change,settings,string,ignore,settings,if,change,settings,names,is,empty,ignore,settings,length,0,return,index,meta,data,settings,normalized,change,settings,settings,builder,put,change,settings,normalize,prefix,index,meta,data,build,index,meta,data,builder,builder,index,meta,data,builder,index,meta,data,settings,settings,index,meta,data,get,settings,set,string,key,filters,new,hash,set,list,string,simple,match,patterns,new,array,list,for,string,ignored,setting,ignore,settings,if,regex,is,simple,match,pattern,ignored,setting,if,contains,ignored,setting,throw,new,snapshot,restore,exception,snapshot,cannot,remove,setting,ignored,setting,on,restore,else,key,filters,add,ignored,setting,else,simple,match,patterns,add,ignored,setting,predicate,string,settings,filter,k,if,contains,k,false,for,string,filter,key,key,filters,if,k,equals,filter,key,return,false,for,string,pattern,simple,match,patterns,if,regex,simple,match,pattern,k,return,false,return,true,settings,builder,settings,builder,settings,builder,put,settings,filter,settings,filter,put,normalized,change,settings,filter,k,if,contains,k,throw,new,snapshot,restore,exception,snapshot,cannot,modify,setting,k,on,restore,else,return,true,return,builder,settings,settings,builder,build,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,restore,snapshot,snapshot,id,e,listener,on,failure,e,override,public,time,value,timeout,return,request,master,node,timeout,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,listener,on,response,new,restore,completion,response,snapshot,restore,info,catch,exception,e,logger,warn,new,parameterized,message,failed,to,restore,snapshot,request,repository,name,request,snapshot,name,e,listener,on,failure,e
RestoreService -> public void restoreSnapshot(final RestoreRequest request, final ActionListener<RestoreCompletionResponse> listener);1541092382;Restores snapshot specified in the restore request.__@param request  restore request_@param listener restore listener;public void restoreSnapshot(final RestoreRequest request, final ActionListener<RestoreCompletionResponse> listener) {_        try {_            _            Repository repository = repositoriesService.repository(request.repositoryName)__            final RepositoryData repositoryData = repository.getRepositoryData()__            final Optional<SnapshotId> incompatibleSnapshotId =_                repositoryData.getIncompatibleSnapshotIds().stream().filter(s -> request.snapshotName.equals(s.getName())).findFirst()__            if (incompatibleSnapshotId.isPresent()) {_                throw new SnapshotRestoreException(request.repositoryName, request.snapshotName, "cannot restore incompatible snapshot")__            }_            final Optional<SnapshotId> matchingSnapshotId = repositoryData.getSnapshotIds().stream()_                .filter(s -> request.snapshotName.equals(s.getName())).findFirst()__            if (matchingSnapshotId.isPresent() == false) {_                throw new SnapshotRestoreException(request.repositoryName, request.snapshotName, "snapshot does not exist")__            }__            final SnapshotId snapshotId = matchingSnapshotId.get()__            final SnapshotInfo snapshotInfo = repository.getSnapshotInfo(snapshotId)__            final Snapshot snapshot = new Snapshot(request.repositoryName, snapshotId)___            _            validateSnapshotRestorable(request.repositoryName, snapshotInfo)___            _            final List<String> indicesInSnapshot = filterIndices(snapshotInfo.indices(), request.indices(), request.indicesOptions())___            final MetaData.Builder metaDataBuilder__            if (request.includeGlobalState()) {_                metaDataBuilder = MetaData.builder(repository.getSnapshotGlobalMetaData(snapshotId))__            } else {_                metaDataBuilder = MetaData.builder()__            }__            final List<IndexId> indexIdsInSnapshot = repositoryData.resolveIndices(indicesInSnapshot)__            for (IndexId indexId : indexIdsInSnapshot) {_                metaDataBuilder.put(repository.getSnapshotIndexMetaData(snapshotId, indexId), false)__            }__            final MetaData metaData = metaDataBuilder.build()___            _            _            final Map<String, String> indices = renamedIndices(request, indicesInSnapshot)___            _            _            clusterService.submitStateUpdateTask(request.cause(), new ClusterStateUpdateTask() {_                RestoreInfo restoreInfo = null___                @Override_                public ClusterState execute(ClusterState currentState) {_                    _                    _                    RestoreInProgress restoreInProgress = currentState.custom(RestoreInProgress.TYPE)__                    if (restoreInProgress != null && !restoreInProgress.entries().isEmpty()) {_                        throw new ConcurrentSnapshotExecutionException(snapshot, "Restore process is already running in this cluster")__                    }_                    _                    SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                    if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                        throw new ConcurrentSnapshotExecutionException(snapshot,_                            "cannot restore a snapshot while a snapshot deletion is in-progress [" +_                                deletionsInProgress.getEntries().get(0).getSnapshot() + "]")__                    }__                    _                    ClusterState.Builder builder = ClusterState.builder(currentState)__                    MetaData.Builder mdBuilder = MetaData.builder(currentState.metaData())__                    ClusterBlocks.Builder blocks = ClusterBlocks.builder().blocks(currentState.blocks())__                    RoutingTable.Builder rtBuilder = RoutingTable.builder(currentState.routingTable())__                    ImmutableOpenMap<ShardId, RestoreInProgress.ShardRestoreStatus> shards__                    Set<String> aliases = new HashSet<>()___                    if (indices.isEmpty() == false) {_                        _                        ImmutableOpenMap.Builder<ShardId, RestoreInProgress.ShardRestoreStatus> shardsBuilder = ImmutableOpenMap.builder()__                        final Version minIndexCompatibilityVersion = currentState.getNodes().getMaxNodeVersion()_                            .minimumIndexCompatibilityVersion()__                        for (Map.Entry<String, String> indexEntry : indices.entrySet()) {_                            String index = indexEntry.getValue()__                            boolean partial = checkPartial(index)__                            SnapshotRecoverySource recoverySource = new SnapshotRecoverySource(snapshot, snapshotInfo.version(), index)__                            String renamedIndexName = indexEntry.getKey()__                            IndexMetaData snapshotIndexMetaData = metaData.index(index)__                            snapshotIndexMetaData = updateIndexSettings(snapshotIndexMetaData, request.indexSettings, request.ignoreIndexSettings)__                            try {_                                snapshotIndexMetaData = metaDataIndexUpgradeService.upgradeIndexMetaData(snapshotIndexMetaData,_                                    minIndexCompatibilityVersion)__                            } catch (Exception ex) {_                                throw new SnapshotRestoreException(snapshot, "cannot restore index [" + index + "] because it cannot be upgraded", ex)__                            }_                            _                            IndexMetaData currentIndexMetaData = currentState.metaData().index(renamedIndexName)__                            IntSet ignoreShards = new IntHashSet()__                            final Index renamedIndex__                            if (currentIndexMetaData == null) {_                                _                                _                                MetaDataCreateIndexService.validateIndexName(renamedIndexName, currentState)__                                createIndexService.validateIndexSettings(renamedIndexName, snapshotIndexMetaData.getSettings(), currentState, false)__                                IndexMetaData.Builder indexMdBuilder = IndexMetaData.builder(snapshotIndexMetaData).state(IndexMetaData.State.OPEN).index(renamedIndexName)__                                indexMdBuilder.settings(Settings.builder().put(snapshotIndexMetaData.getSettings()).put(IndexMetaData.SETTING_INDEX_UUID, UUIDs.randomBase64UUID()))__                                if (!request.includeAliases() && !snapshotIndexMetaData.getAliases().isEmpty()) {_                                    _                                    indexMdBuilder.removeAllAliases()__                                } else {_                                    for (ObjectCursor<String> alias : snapshotIndexMetaData.getAliases().keys()) {_                                        aliases.add(alias.value)__                                    }_                                }_                                IndexMetaData updatedIndexMetaData = indexMdBuilder.build()__                                if (partial) {_                                    populateIgnoredShards(index, ignoreShards)__                                }_                                rtBuilder.addAsNewRestore(updatedIndexMetaData, recoverySource, ignoreShards)__                                blocks.addBlocks(updatedIndexMetaData)__                                mdBuilder.put(updatedIndexMetaData, true)__                                renamedIndex = updatedIndexMetaData.getIndex()__                            } else {_                                validateExistingIndex(currentIndexMetaData, snapshotIndexMetaData, renamedIndexName, partial)__                                _                                IndexMetaData.Builder indexMdBuilder = IndexMetaData.builder(snapshotIndexMetaData).state(IndexMetaData.State.OPEN)__                                indexMdBuilder.version(Math.max(snapshotIndexMetaData.getVersion(), currentIndexMetaData.getVersion() + 1))__                                indexMdBuilder.mappingVersion(Math.max(snapshotIndexMetaData.getMappingVersion(), currentIndexMetaData.getMappingVersion() + 1))__                                indexMdBuilder.settingsVersion(Math.max(snapshotIndexMetaData.getSettingsVersion(), currentIndexMetaData.getSettingsVersion() + 1))__                                if (!request.includeAliases()) {_                                    _                                    if (!snapshotIndexMetaData.getAliases().isEmpty()) {_                                        indexMdBuilder.removeAllAliases()__                                    }_                                    _                                    for (ObjectCursor<AliasMetaData> alias : currentIndexMetaData.getAliases().values()) {_                                        indexMdBuilder.putAlias(alias.value)__                                    }_                                } else {_                                    for (ObjectCursor<String> alias : snapshotIndexMetaData.getAliases().keys()) {_                                        aliases.add(alias.value)__                                    }_                                }_                                indexMdBuilder.settings(Settings.builder().put(snapshotIndexMetaData.getSettings()).put(IndexMetaData.SETTING_INDEX_UUID, currentIndexMetaData.getIndexUUID()))__                                IndexMetaData updatedIndexMetaData = indexMdBuilder.index(renamedIndexName).build()__                                rtBuilder.addAsRestore(updatedIndexMetaData, recoverySource)__                                blocks.updateBlocks(updatedIndexMetaData)__                                mdBuilder.put(updatedIndexMetaData, true)__                                renamedIndex = updatedIndexMetaData.getIndex()__                            }__                            for (int shard = 0_ shard < snapshotIndexMetaData.getNumberOfShards()_ shard++) {_                                if (!ignoreShards.contains(shard)) {_                                    shardsBuilder.put(new ShardId(renamedIndex, shard), new RestoreInProgress.ShardRestoreStatus(clusterService.state().nodes().getLocalNodeId()))__                                } else {_                                    shardsBuilder.put(new ShardId(renamedIndex, shard), new RestoreInProgress.ShardRestoreStatus(clusterService.state().nodes().getLocalNodeId(), RestoreInProgress.State.FAILURE))__                                }_                            }_                        }__                        shards = shardsBuilder.build()__                        RestoreInProgress.Entry restoreEntry = new RestoreInProgress.Entry(snapshot, overallState(RestoreInProgress.State.INIT, shards), Collections.unmodifiableList(new ArrayList<>(indices.keySet())), shards)__                        builder.putCustom(RestoreInProgress.TYPE, new RestoreInProgress(restoreEntry))__                    } else {_                        shards = ImmutableOpenMap.of()__                    }__                    checkAliasNameConflicts(indices, aliases)___                    _                    if (request.includeGlobalState()) {_                        if (metaData.persistentSettings() != null) {_                            Settings settings = metaData.persistentSettings()__                            clusterSettings.validateUpdate(settings)__                            mdBuilder.persistentSettings(settings)__                        }_                        if (metaData.templates() != null) {_                            _                            for (ObjectCursor<IndexTemplateMetaData> cursor : metaData.templates().values()) {_                                mdBuilder.put(cursor.value)__                            }_                        }_                        if (metaData.customs() != null) {_                            for (ObjectObjectCursor<String, MetaData.Custom> cursor : metaData.customs()) {_                                if (!RepositoriesMetaData.TYPE.equals(cursor.key)) {_                                    _                                    _                                    mdBuilder.putCustom(cursor.key, cursor.value)__                                }_                            }_                        }_                    }__                    if (completed(shards)) {_                        _                        restoreInfo = new RestoreInfo(snapshotId.getName(),_                                                      Collections.unmodifiableList(new ArrayList<>(indices.keySet())),_                                                      shards.size(),_                                                      shards.size() - failedShards(shards))__                    }__                    RoutingTable rt = rtBuilder.build()__                    ClusterState updatedState = builder.metaData(mdBuilder).blocks(blocks).routingTable(rt).build()__                    return allocationService.reroute(updatedState, "restored snapshot [" + snapshot + "]")__                }__                private void checkAliasNameConflicts(Map<String, String> renamedIndices, Set<String> aliases) {_                    for (Map.Entry<String, String> renamedIndex : renamedIndices.entrySet()) {_                        if (aliases.contains(renamedIndex.getKey())) {_                            throw new SnapshotRestoreException(snapshot, "cannot rename index [" + renamedIndex.getValue() + "] into [" + renamedIndex.getKey() + "] because of conflict with an alias with the same name")__                        }_                    }_                }__                private void populateIgnoredShards(String index, IntSet ignoreShards) {_                    for (SnapshotShardFailure failure : snapshotInfo.shardFailures()) {_                        if (index.equals(failure.index())) {_                            ignoreShards.add(failure.shardId())__                        }_                    }_                }__                private boolean checkPartial(String index) {_                    _                    if (failed(snapshotInfo, index)) {_                        if (request.partial()) {_                            return true__                        } else {_                            throw new SnapshotRestoreException(snapshot, "index [" + index + "] wasn't fully snapshotted - cannot restore")__                        }_                    } else {_                        return false__                    }_                }__                private void validateExistingIndex(IndexMetaData currentIndexMetaData, IndexMetaData snapshotIndexMetaData, String renamedIndex, boolean partial) {_                    _                    if (currentIndexMetaData.getState() != IndexMetaData.State.CLOSE) {_                        _                        throw new SnapshotRestoreException(snapshot, "cannot restore index [" + renamedIndex + "] because an open index with same name already exists in the cluster. " +_                            "Either close or delete the existing index or restore the index under a different name by providing a rename pattern and replacement name")__                    }_                    _                    if (partial) {_                        throw new SnapshotRestoreException(snapshot, "cannot restore partial index [" + renamedIndex + "] because such index already exists")__                    }_                    _                    if (currentIndexMetaData.getNumberOfShards() != snapshotIndexMetaData.getNumberOfShards()) {_                        throw new SnapshotRestoreException(snapshot, "cannot restore index [" + renamedIndex + "] with [" + currentIndexMetaData.getNumberOfShards() +_                                "] shards from a snapshot of index [" + snapshotIndexMetaData.getIndex().getName() + "] with [" + snapshotIndexMetaData.getNumberOfShards() + "] shards")__                    }_                }__                _                private IndexMetaData updateIndexSettings(IndexMetaData indexMetaData, Settings changeSettings, String[] ignoreSettings) {_                    if (changeSettings.names().isEmpty() && ignoreSettings.length == 0) {_                        return indexMetaData__                    }_                    Settings normalizedChangeSettings = Settings.builder().put(changeSettings).normalizePrefix(IndexMetaData.INDEX_SETTING_PREFIX).build()__                    IndexMetaData.Builder builder = IndexMetaData.builder(indexMetaData)__                    Settings settings = indexMetaData.getSettings()__                    Set<String> keyFilters = new HashSet<>()__                    List<String> simpleMatchPatterns = new ArrayList<>()__                    for (String ignoredSetting : ignoreSettings) {_                        if (!Regex.isSimpleMatchPattern(ignoredSetting)) {_                            if (UNREMOVABLE_SETTINGS.contains(ignoredSetting)) {_                                throw new SnapshotRestoreException(snapshot, "cannot remove setting [" + ignoredSetting + "] on restore")__                            } else {_                                keyFilters.add(ignoredSetting)__                            }_                        } else {_                            simpleMatchPatterns.add(ignoredSetting)__                        }_                    }_                    Predicate<String> settingsFilter = k -> {_                        if (UNREMOVABLE_SETTINGS.contains(k) == false) {_                            for (String filterKey : keyFilters) {_                                if (k.equals(filterKey)) {_                                    return false__                                }_                            }_                            for (String pattern : simpleMatchPatterns) {_                                if (Regex.simpleMatch(pattern, k)) {_                                    return false__                                }_                            }_                        }_                        return true__                    }__                    Settings.Builder settingsBuilder = Settings.builder()_                        .put(settings.filter(settingsFilter))_                        .put(normalizedChangeSettings.filter(k -> {_                            if (UNMODIFIABLE_SETTINGS.contains(k)) {_                                throw new SnapshotRestoreException(snapshot, "cannot modify setting [" + k + "] on restore")__                            } else {_                                return true__                            }_                        }))__                    return builder.settings(settingsBuilder).build()__                }__                @Override_                public void onFailure(String source, Exception e) {_                    logger.warn(() -> new ParameterizedMessage("[{}] failed to restore snapshot", snapshotId), e)__                    listener.onFailure(e)__                }__                @Override_                public TimeValue timeout() {_                    return request.masterNodeTimeout()__                }__                @Override_                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                    listener.onResponse(new RestoreCompletionResponse(snapshot, restoreInfo))__                }_            })____        } catch (Exception e) {_            logger.warn(() -> new ParameterizedMessage("[{}] failed to restore snapshot", request.repositoryName + ":" + request.snapshotName), e)__            listener.onFailure(e)__        }_    };restores,snapshot,specified,in,the,restore,request,param,request,restore,request,param,listener,restore,listener;public,void,restore,snapshot,final,restore,request,request,final,action,listener,restore,completion,response,listener,try,repository,repository,repositories,service,repository,request,repository,name,final,repository,data,repository,data,repository,get,repository,data,final,optional,snapshot,id,incompatible,snapshot,id,repository,data,get,incompatible,snapshot,ids,stream,filter,s,request,snapshot,name,equals,s,get,name,find,first,if,incompatible,snapshot,id,is,present,throw,new,snapshot,restore,exception,request,repository,name,request,snapshot,name,cannot,restore,incompatible,snapshot,final,optional,snapshot,id,matching,snapshot,id,repository,data,get,snapshot,ids,stream,filter,s,request,snapshot,name,equals,s,get,name,find,first,if,matching,snapshot,id,is,present,false,throw,new,snapshot,restore,exception,request,repository,name,request,snapshot,name,snapshot,does,not,exist,final,snapshot,id,snapshot,id,matching,snapshot,id,get,final,snapshot,info,snapshot,info,repository,get,snapshot,info,snapshot,id,final,snapshot,snapshot,new,snapshot,request,repository,name,snapshot,id,validate,snapshot,restorable,request,repository,name,snapshot,info,final,list,string,indices,in,snapshot,filter,indices,snapshot,info,indices,request,indices,request,indices,options,final,meta,data,builder,meta,data,builder,if,request,include,global,state,meta,data,builder,meta,data,builder,repository,get,snapshot,global,meta,data,snapshot,id,else,meta,data,builder,meta,data,builder,final,list,index,id,index,ids,in,snapshot,repository,data,resolve,indices,indices,in,snapshot,for,index,id,index,id,index,ids,in,snapshot,meta,data,builder,put,repository,get,snapshot,index,meta,data,snapshot,id,index,id,false,final,meta,data,meta,data,meta,data,builder,build,final,map,string,string,indices,renamed,indices,request,indices,in,snapshot,cluster,service,submit,state,update,task,request,cause,new,cluster,state,update,task,restore,info,restore,info,null,override,public,cluster,state,execute,cluster,state,current,state,restore,in,progress,restore,in,progress,current,state,custom,restore,in,progress,type,if,restore,in,progress,null,restore,in,progress,entries,is,empty,throw,new,concurrent,snapshot,execution,exception,snapshot,restore,process,is,already,running,in,this,cluster,snapshot,deletions,in,progress,deletions,in,progress,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,throw,new,concurrent,snapshot,execution,exception,snapshot,cannot,restore,a,snapshot,while,a,snapshot,deletion,is,in,progress,deletions,in,progress,get,entries,get,0,get,snapshot,cluster,state,builder,builder,cluster,state,builder,current,state,meta,data,builder,md,builder,meta,data,builder,current,state,meta,data,cluster,blocks,builder,blocks,cluster,blocks,builder,blocks,current,state,blocks,routing,table,builder,rt,builder,routing,table,builder,current,state,routing,table,immutable,open,map,shard,id,restore,in,progress,shard,restore,status,shards,set,string,aliases,new,hash,set,if,indices,is,empty,false,immutable,open,map,builder,shard,id,restore,in,progress,shard,restore,status,shards,builder,immutable,open,map,builder,final,version,min,index,compatibility,version,current,state,get,nodes,get,max,node,version,minimum,index,compatibility,version,for,map,entry,string,string,index,entry,indices,entry,set,string,index,index,entry,get,value,boolean,partial,check,partial,index,snapshot,recovery,source,recovery,source,new,snapshot,recovery,source,snapshot,snapshot,info,version,index,string,renamed,index,name,index,entry,get,key,index,meta,data,snapshot,index,meta,data,meta,data,index,index,snapshot,index,meta,data,update,index,settings,snapshot,index,meta,data,request,index,settings,request,ignore,index,settings,try,snapshot,index,meta,data,meta,data,index,upgrade,service,upgrade,index,meta,data,snapshot,index,meta,data,min,index,compatibility,version,catch,exception,ex,throw,new,snapshot,restore,exception,snapshot,cannot,restore,index,index,because,it,cannot,be,upgraded,ex,index,meta,data,current,index,meta,data,current,state,meta,data,index,renamed,index,name,int,set,ignore,shards,new,int,hash,set,final,index,renamed,index,if,current,index,meta,data,null,meta,data,create,index,service,validate,index,name,renamed,index,name,current,state,create,index,service,validate,index,settings,renamed,index,name,snapshot,index,meta,data,get,settings,current,state,false,index,meta,data,builder,index,md,builder,index,meta,data,builder,snapshot,index,meta,data,state,index,meta,data,state,open,index,renamed,index,name,index,md,builder,settings,settings,builder,put,snapshot,index,meta,data,get,settings,put,index,meta,data,uuids,random,base64uuid,if,request,include,aliases,snapshot,index,meta,data,get,aliases,is,empty,index,md,builder,remove,all,aliases,else,for,object,cursor,string,alias,snapshot,index,meta,data,get,aliases,keys,aliases,add,alias,value,index,meta,data,updated,index,meta,data,index,md,builder,build,if,partial,populate,ignored,shards,index,ignore,shards,rt,builder,add,as,new,restore,updated,index,meta,data,recovery,source,ignore,shards,blocks,add,blocks,updated,index,meta,data,md,builder,put,updated,index,meta,data,true,renamed,index,updated,index,meta,data,get,index,else,validate,existing,index,current,index,meta,data,snapshot,index,meta,data,renamed,index,name,partial,index,meta,data,builder,index,md,builder,index,meta,data,builder,snapshot,index,meta,data,state,index,meta,data,state,open,index,md,builder,version,math,max,snapshot,index,meta,data,get,version,current,index,meta,data,get,version,1,index,md,builder,mapping,version,math,max,snapshot,index,meta,data,get,mapping,version,current,index,meta,data,get,mapping,version,1,index,md,builder,settings,version,math,max,snapshot,index,meta,data,get,settings,version,current,index,meta,data,get,settings,version,1,if,request,include,aliases,if,snapshot,index,meta,data,get,aliases,is,empty,index,md,builder,remove,all,aliases,for,object,cursor,alias,meta,data,alias,current,index,meta,data,get,aliases,values,index,md,builder,put,alias,alias,value,else,for,object,cursor,string,alias,snapshot,index,meta,data,get,aliases,keys,aliases,add,alias,value,index,md,builder,settings,settings,builder,put,snapshot,index,meta,data,get,settings,put,index,meta,data,current,index,meta,data,get,index,uuid,index,meta,data,updated,index,meta,data,index,md,builder,index,renamed,index,name,build,rt,builder,add,as,restore,updated,index,meta,data,recovery,source,blocks,update,blocks,updated,index,meta,data,md,builder,put,updated,index,meta,data,true,renamed,index,updated,index,meta,data,get,index,for,int,shard,0,shard,snapshot,index,meta,data,get,number,of,shards,shard,if,ignore,shards,contains,shard,shards,builder,put,new,shard,id,renamed,index,shard,new,restore,in,progress,shard,restore,status,cluster,service,state,nodes,get,local,node,id,else,shards,builder,put,new,shard,id,renamed,index,shard,new,restore,in,progress,shard,restore,status,cluster,service,state,nodes,get,local,node,id,restore,in,progress,state,failure,shards,shards,builder,build,restore,in,progress,entry,restore,entry,new,restore,in,progress,entry,snapshot,overall,state,restore,in,progress,state,init,shards,collections,unmodifiable,list,new,array,list,indices,key,set,shards,builder,put,custom,restore,in,progress,type,new,restore,in,progress,restore,entry,else,shards,immutable,open,map,of,check,alias,name,conflicts,indices,aliases,if,request,include,global,state,if,meta,data,persistent,settings,null,settings,settings,meta,data,persistent,settings,cluster,settings,validate,update,settings,md,builder,persistent,settings,settings,if,meta,data,templates,null,for,object,cursor,index,template,meta,data,cursor,meta,data,templates,values,md,builder,put,cursor,value,if,meta,data,customs,null,for,object,object,cursor,string,meta,data,custom,cursor,meta,data,customs,if,repositories,meta,data,type,equals,cursor,key,md,builder,put,custom,cursor,key,cursor,value,if,completed,shards,restore,info,new,restore,info,snapshot,id,get,name,collections,unmodifiable,list,new,array,list,indices,key,set,shards,size,shards,size,failed,shards,shards,routing,table,rt,rt,builder,build,cluster,state,updated,state,builder,meta,data,md,builder,blocks,blocks,routing,table,rt,build,return,allocation,service,reroute,updated,state,restored,snapshot,snapshot,private,void,check,alias,name,conflicts,map,string,string,renamed,indices,set,string,aliases,for,map,entry,string,string,renamed,index,renamed,indices,entry,set,if,aliases,contains,renamed,index,get,key,throw,new,snapshot,restore,exception,snapshot,cannot,rename,index,renamed,index,get,value,into,renamed,index,get,key,because,of,conflict,with,an,alias,with,the,same,name,private,void,populate,ignored,shards,string,index,int,set,ignore,shards,for,snapshot,shard,failure,failure,snapshot,info,shard,failures,if,index,equals,failure,index,ignore,shards,add,failure,shard,id,private,boolean,check,partial,string,index,if,failed,snapshot,info,index,if,request,partial,return,true,else,throw,new,snapshot,restore,exception,snapshot,index,index,wasn,t,fully,snapshotted,cannot,restore,else,return,false,private,void,validate,existing,index,index,meta,data,current,index,meta,data,index,meta,data,snapshot,index,meta,data,string,renamed,index,boolean,partial,if,current,index,meta,data,get,state,index,meta,data,state,close,throw,new,snapshot,restore,exception,snapshot,cannot,restore,index,renamed,index,because,an,open,index,with,same,name,already,exists,in,the,cluster,either,close,or,delete,the,existing,index,or,restore,the,index,under,a,different,name,by,providing,a,rename,pattern,and,replacement,name,if,partial,throw,new,snapshot,restore,exception,snapshot,cannot,restore,partial,index,renamed,index,because,such,index,already,exists,if,current,index,meta,data,get,number,of,shards,snapshot,index,meta,data,get,number,of,shards,throw,new,snapshot,restore,exception,snapshot,cannot,restore,index,renamed,index,with,current,index,meta,data,get,number,of,shards,shards,from,a,snapshot,of,index,snapshot,index,meta,data,get,index,get,name,with,snapshot,index,meta,data,get,number,of,shards,shards,private,index,meta,data,update,index,settings,index,meta,data,index,meta,data,settings,change,settings,string,ignore,settings,if,change,settings,names,is,empty,ignore,settings,length,0,return,index,meta,data,settings,normalized,change,settings,settings,builder,put,change,settings,normalize,prefix,index,meta,data,build,index,meta,data,builder,builder,index,meta,data,builder,index,meta,data,settings,settings,index,meta,data,get,settings,set,string,key,filters,new,hash,set,list,string,simple,match,patterns,new,array,list,for,string,ignored,setting,ignore,settings,if,regex,is,simple,match,pattern,ignored,setting,if,contains,ignored,setting,throw,new,snapshot,restore,exception,snapshot,cannot,remove,setting,ignored,setting,on,restore,else,key,filters,add,ignored,setting,else,simple,match,patterns,add,ignored,setting,predicate,string,settings,filter,k,if,contains,k,false,for,string,filter,key,key,filters,if,k,equals,filter,key,return,false,for,string,pattern,simple,match,patterns,if,regex,simple,match,pattern,k,return,false,return,true,settings,builder,settings,builder,settings,builder,put,settings,filter,settings,filter,put,normalized,change,settings,filter,k,if,contains,k,throw,new,snapshot,restore,exception,snapshot,cannot,modify,setting,k,on,restore,else,return,true,return,builder,settings,settings,builder,build,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,restore,snapshot,snapshot,id,e,listener,on,failure,e,override,public,time,value,timeout,return,request,master,node,timeout,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,listener,on,response,new,restore,completion,response,snapshot,restore,info,catch,exception,e,logger,warn,new,parameterized,message,failed,to,restore,snapshot,request,repository,name,request,snapshot,name,e,listener,on,failure,e
RestoreService -> public void restoreSnapshot(final RestoreRequest request, final ActionListener<RestoreCompletionResponse> listener);1542402632;Restores snapshot specified in the restore request.__@param request  restore request_@param listener restore listener;public void restoreSnapshot(final RestoreRequest request, final ActionListener<RestoreCompletionResponse> listener) {_        try {_            _            Repository repository = repositoriesService.repository(request.repositoryName)__            final RepositoryData repositoryData = repository.getRepositoryData()__            final Optional<SnapshotId> incompatibleSnapshotId =_                repositoryData.getIncompatibleSnapshotIds().stream().filter(s -> request.snapshotName.equals(s.getName())).findFirst()__            if (incompatibleSnapshotId.isPresent()) {_                throw new SnapshotRestoreException(request.repositoryName, request.snapshotName, "cannot restore incompatible snapshot")__            }_            final Optional<SnapshotId> matchingSnapshotId = repositoryData.getSnapshotIds().stream()_                .filter(s -> request.snapshotName.equals(s.getName())).findFirst()__            if (matchingSnapshotId.isPresent() == false) {_                throw new SnapshotRestoreException(request.repositoryName, request.snapshotName, "snapshot does not exist")__            }__            final SnapshotId snapshotId = matchingSnapshotId.get()__            final SnapshotInfo snapshotInfo = repository.getSnapshotInfo(snapshotId)__            final Snapshot snapshot = new Snapshot(request.repositoryName, snapshotId)___            _            validateSnapshotRestorable(request.repositoryName, snapshotInfo)___            _            final List<String> indicesInSnapshot = filterIndices(snapshotInfo.indices(), request.indices(), request.indicesOptions())___            final MetaData.Builder metaDataBuilder__            if (request.includeGlobalState()) {_                metaDataBuilder = MetaData.builder(repository.getSnapshotGlobalMetaData(snapshotId))__            } else {_                metaDataBuilder = MetaData.builder()__            }__            final List<IndexId> indexIdsInSnapshot = repositoryData.resolveIndices(indicesInSnapshot)__            for (IndexId indexId : indexIdsInSnapshot) {_                metaDataBuilder.put(repository.getSnapshotIndexMetaData(snapshotId, indexId), false)__            }__            final MetaData metaData = metaDataBuilder.build()___            _            _            final Map<String, String> indices = renamedIndices(request, indicesInSnapshot)___            _            _            clusterService.submitStateUpdateTask(request.cause(), new ClusterStateUpdateTask() {_                RestoreInfo restoreInfo = null___                @Override_                public ClusterState execute(ClusterState currentState) {_                    _                    _                    RestoreInProgress restoreInProgress = currentState.custom(RestoreInProgress.TYPE)__                    if (restoreInProgress != null && !restoreInProgress.entries().isEmpty()) {_                        throw new ConcurrentSnapshotExecutionException(snapshot, "Restore process is already running in this cluster")__                    }_                    _                    SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                    if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                        throw new ConcurrentSnapshotExecutionException(snapshot,_                            "cannot restore a snapshot while a snapshot deletion is in-progress [" +_                                deletionsInProgress.getEntries().get(0).getSnapshot() + "]")__                    }__                    _                    ClusterState.Builder builder = ClusterState.builder(currentState)__                    MetaData.Builder mdBuilder = MetaData.builder(currentState.metaData())__                    ClusterBlocks.Builder blocks = ClusterBlocks.builder().blocks(currentState.blocks())__                    RoutingTable.Builder rtBuilder = RoutingTable.builder(currentState.routingTable())__                    ImmutableOpenMap<ShardId, RestoreInProgress.ShardRestoreStatus> shards__                    Set<String> aliases = new HashSet<>()___                    if (indices.isEmpty() == false) {_                        _                        ImmutableOpenMap.Builder<ShardId, RestoreInProgress.ShardRestoreStatus> shardsBuilder = ImmutableOpenMap.builder()__                        final Version minIndexCompatibilityVersion = currentState.getNodes().getMaxNodeVersion()_                            .minimumIndexCompatibilityVersion()__                        for (Map.Entry<String, String> indexEntry : indices.entrySet()) {_                            String index = indexEntry.getValue()__                            boolean partial = checkPartial(index)__                            SnapshotRecoverySource recoverySource = new SnapshotRecoverySource(snapshot, snapshotInfo.version(), index)__                            String renamedIndexName = indexEntry.getKey()__                            IndexMetaData snapshotIndexMetaData = metaData.index(index)__                            snapshotIndexMetaData = updateIndexSettings(snapshotIndexMetaData, request.indexSettings, request.ignoreIndexSettings)__                            try {_                                snapshotIndexMetaData = metaDataIndexUpgradeService.upgradeIndexMetaData(snapshotIndexMetaData,_                                    minIndexCompatibilityVersion)__                            } catch (Exception ex) {_                                throw new SnapshotRestoreException(snapshot, "cannot restore index [" + index + "] because it cannot be upgraded", ex)__                            }_                            _                            IndexMetaData currentIndexMetaData = currentState.metaData().index(renamedIndexName)__                            IntSet ignoreShards = new IntHashSet()__                            final Index renamedIndex__                            if (currentIndexMetaData == null) {_                                _                                _                                MetaDataCreateIndexService.validateIndexName(renamedIndexName, currentState)__                                createIndexService.validateIndexSettings(renamedIndexName, snapshotIndexMetaData.getSettings(), currentState, false)__                                IndexMetaData.Builder indexMdBuilder = IndexMetaData.builder(snapshotIndexMetaData).state(IndexMetaData.State.OPEN).index(renamedIndexName)__                                indexMdBuilder.settings(Settings.builder().put(snapshotIndexMetaData.getSettings()).put(IndexMetaData.SETTING_INDEX_UUID, UUIDs.randomBase64UUID()))__                                if (!request.includeAliases() && !snapshotIndexMetaData.getAliases().isEmpty()) {_                                    _                                    indexMdBuilder.removeAllAliases()__                                } else {_                                    for (ObjectCursor<String> alias : snapshotIndexMetaData.getAliases().keys()) {_                                        aliases.add(alias.value)__                                    }_                                }_                                IndexMetaData updatedIndexMetaData = indexMdBuilder.build()__                                if (partial) {_                                    populateIgnoredShards(index, ignoreShards)__                                }_                                rtBuilder.addAsNewRestore(updatedIndexMetaData, recoverySource, ignoreShards)__                                blocks.addBlocks(updatedIndexMetaData)__                                mdBuilder.put(updatedIndexMetaData, true)__                                renamedIndex = updatedIndexMetaData.getIndex()__                            } else {_                                validateExistingIndex(currentIndexMetaData, snapshotIndexMetaData, renamedIndexName, partial)__                                _                                IndexMetaData.Builder indexMdBuilder = IndexMetaData.builder(snapshotIndexMetaData).state(IndexMetaData.State.OPEN)__                                indexMdBuilder.version(Math.max(snapshotIndexMetaData.getVersion(), currentIndexMetaData.getVersion() + 1))__                                indexMdBuilder.mappingVersion(Math.max(snapshotIndexMetaData.getMappingVersion(), currentIndexMetaData.getMappingVersion() + 1))__                                indexMdBuilder.settingsVersion(Math.max(snapshotIndexMetaData.getSettingsVersion(), currentIndexMetaData.getSettingsVersion() + 1))__                                if (!request.includeAliases()) {_                                    _                                    if (!snapshotIndexMetaData.getAliases().isEmpty()) {_                                        indexMdBuilder.removeAllAliases()__                                    }_                                    _                                    for (ObjectCursor<AliasMetaData> alias : currentIndexMetaData.getAliases().values()) {_                                        indexMdBuilder.putAlias(alias.value)__                                    }_                                } else {_                                    for (ObjectCursor<String> alias : snapshotIndexMetaData.getAliases().keys()) {_                                        aliases.add(alias.value)__                                    }_                                }_                                indexMdBuilder.settings(Settings.builder().put(snapshotIndexMetaData.getSettings()).put(IndexMetaData.SETTING_INDEX_UUID, currentIndexMetaData.getIndexUUID()))__                                IndexMetaData updatedIndexMetaData = indexMdBuilder.index(renamedIndexName).build()__                                rtBuilder.addAsRestore(updatedIndexMetaData, recoverySource)__                                blocks.updateBlocks(updatedIndexMetaData)__                                mdBuilder.put(updatedIndexMetaData, true)__                                renamedIndex = updatedIndexMetaData.getIndex()__                            }__                            for (int shard = 0_ shard < snapshotIndexMetaData.getNumberOfShards()_ shard++) {_                                if (!ignoreShards.contains(shard)) {_                                    shardsBuilder.put(new ShardId(renamedIndex, shard), new RestoreInProgress.ShardRestoreStatus(clusterService.state().nodes().getLocalNodeId()))__                                } else {_                                    shardsBuilder.put(new ShardId(renamedIndex, shard), new RestoreInProgress.ShardRestoreStatus(clusterService.state().nodes().getLocalNodeId(), RestoreInProgress.State.FAILURE))__                                }_                            }_                        }__                        shards = shardsBuilder.build()__                        RestoreInProgress.Entry restoreEntry = new RestoreInProgress.Entry(snapshot, overallState(RestoreInProgress.State.INIT, shards), Collections.unmodifiableList(new ArrayList<>(indices.keySet())), shards)__                        builder.putCustom(RestoreInProgress.TYPE, new RestoreInProgress(restoreEntry))__                    } else {_                        shards = ImmutableOpenMap.of()__                    }__                    checkAliasNameConflicts(indices, aliases)___                    _                    if (request.includeGlobalState()) {_                        if (metaData.persistentSettings() != null) {_                            Settings settings = metaData.persistentSettings()__                            clusterSettings.validateUpdate(settings)__                            mdBuilder.persistentSettings(settings)__                        }_                        if (metaData.templates() != null) {_                            _                            for (ObjectCursor<IndexTemplateMetaData> cursor : metaData.templates().values()) {_                                mdBuilder.put(cursor.value)__                            }_                        }_                        if (metaData.customs() != null) {_                            for (ObjectObjectCursor<String, MetaData.Custom> cursor : metaData.customs()) {_                                if (!RepositoriesMetaData.TYPE.equals(cursor.key)) {_                                    _                                    _                                    mdBuilder.putCustom(cursor.key, cursor.value)__                                }_                            }_                        }_                    }__                    if (completed(shards)) {_                        _                        restoreInfo = new RestoreInfo(snapshotId.getName(),_                                                      Collections.unmodifiableList(new ArrayList<>(indices.keySet())),_                                                      shards.size(),_                                                      shards.size() - failedShards(shards))__                    }__                    RoutingTable rt = rtBuilder.build()__                    ClusterState updatedState = builder.metaData(mdBuilder).blocks(blocks).routingTable(rt).build()__                    return allocationService.reroute(updatedState, "restored snapshot [" + snapshot + "]")__                }__                private void checkAliasNameConflicts(Map<String, String> renamedIndices, Set<String> aliases) {_                    for (Map.Entry<String, String> renamedIndex : renamedIndices.entrySet()) {_                        if (aliases.contains(renamedIndex.getKey())) {_                            throw new SnapshotRestoreException(snapshot, "cannot rename index [" + renamedIndex.getValue() + "] into [" + renamedIndex.getKey() + "] because of conflict with an alias with the same name")__                        }_                    }_                }__                private void populateIgnoredShards(String index, IntSet ignoreShards) {_                    for (SnapshotShardFailure failure : snapshotInfo.shardFailures()) {_                        if (index.equals(failure.index())) {_                            ignoreShards.add(failure.shardId())__                        }_                    }_                }__                private boolean checkPartial(String index) {_                    _                    if (failed(snapshotInfo, index)) {_                        if (request.partial()) {_                            return true__                        } else {_                            throw new SnapshotRestoreException(snapshot, "index [" + index + "] wasn't fully snapshotted - cannot restore")__                        }_                    } else {_                        return false__                    }_                }__                private void validateExistingIndex(IndexMetaData currentIndexMetaData, IndexMetaData snapshotIndexMetaData, String renamedIndex, boolean partial) {_                    _                    if (currentIndexMetaData.getState() != IndexMetaData.State.CLOSE) {_                        _                        throw new SnapshotRestoreException(snapshot, "cannot restore index [" + renamedIndex + "] because an open index with same name already exists in the cluster. " +_                            "Either close or delete the existing index or restore the index under a different name by providing a rename pattern and replacement name")__                    }_                    _                    if (partial) {_                        throw new SnapshotRestoreException(snapshot, "cannot restore partial index [" + renamedIndex + "] because such index already exists")__                    }_                    _                    if (currentIndexMetaData.getNumberOfShards() != snapshotIndexMetaData.getNumberOfShards()) {_                        throw new SnapshotRestoreException(snapshot, "cannot restore index [" + renamedIndex + "] with [" + currentIndexMetaData.getNumberOfShards() +_                                "] shards from a snapshot of index [" + snapshotIndexMetaData.getIndex().getName() + "] with [" + snapshotIndexMetaData.getNumberOfShards() + "] shards")__                    }_                }__                _                private IndexMetaData updateIndexSettings(IndexMetaData indexMetaData, Settings changeSettings, String[] ignoreSettings) {_                    if (changeSettings.names().isEmpty() && ignoreSettings.length == 0) {_                        return indexMetaData__                    }_                    Settings normalizedChangeSettings = Settings.builder().put(changeSettings).normalizePrefix(IndexMetaData.INDEX_SETTING_PREFIX).build()__                    IndexMetaData.Builder builder = IndexMetaData.builder(indexMetaData)__                    Settings settings = indexMetaData.getSettings()__                    Set<String> keyFilters = new HashSet<>()__                    List<String> simpleMatchPatterns = new ArrayList<>()__                    for (String ignoredSetting : ignoreSettings) {_                        if (!Regex.isSimpleMatchPattern(ignoredSetting)) {_                            if (UNREMOVABLE_SETTINGS.contains(ignoredSetting)) {_                                throw new SnapshotRestoreException(snapshot, "cannot remove setting [" + ignoredSetting + "] on restore")__                            } else {_                                keyFilters.add(ignoredSetting)__                            }_                        } else {_                            simpleMatchPatterns.add(ignoredSetting)__                        }_                    }_                    Predicate<String> settingsFilter = k -> {_                        if (UNREMOVABLE_SETTINGS.contains(k) == false) {_                            for (String filterKey : keyFilters) {_                                if (k.equals(filterKey)) {_                                    return false__                                }_                            }_                            for (String pattern : simpleMatchPatterns) {_                                if (Regex.simpleMatch(pattern, k)) {_                                    return false__                                }_                            }_                        }_                        return true__                    }__                    Settings.Builder settingsBuilder = Settings.builder()_                        .put(settings.filter(settingsFilter))_                        .put(normalizedChangeSettings.filter(k -> {_                            if (UNMODIFIABLE_SETTINGS.contains(k)) {_                                throw new SnapshotRestoreException(snapshot, "cannot modify setting [" + k + "] on restore")__                            } else {_                                return true__                            }_                        }))__                    return builder.settings(settingsBuilder).build()__                }__                @Override_                public void onFailure(String source, Exception e) {_                    logger.warn(() -> new ParameterizedMessage("[{}] failed to restore snapshot", snapshotId), e)__                    listener.onFailure(e)__                }__                @Override_                public TimeValue timeout() {_                    return request.masterNodeTimeout()__                }__                @Override_                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                    listener.onResponse(new RestoreCompletionResponse(snapshot, restoreInfo))__                }_            })____        } catch (Exception e) {_            logger.warn(() -> new ParameterizedMessage("[{}] failed to restore snapshot", request.repositoryName + ":" + request.snapshotName), e)__            listener.onFailure(e)__        }_    };restores,snapshot,specified,in,the,restore,request,param,request,restore,request,param,listener,restore,listener;public,void,restore,snapshot,final,restore,request,request,final,action,listener,restore,completion,response,listener,try,repository,repository,repositories,service,repository,request,repository,name,final,repository,data,repository,data,repository,get,repository,data,final,optional,snapshot,id,incompatible,snapshot,id,repository,data,get,incompatible,snapshot,ids,stream,filter,s,request,snapshot,name,equals,s,get,name,find,first,if,incompatible,snapshot,id,is,present,throw,new,snapshot,restore,exception,request,repository,name,request,snapshot,name,cannot,restore,incompatible,snapshot,final,optional,snapshot,id,matching,snapshot,id,repository,data,get,snapshot,ids,stream,filter,s,request,snapshot,name,equals,s,get,name,find,first,if,matching,snapshot,id,is,present,false,throw,new,snapshot,restore,exception,request,repository,name,request,snapshot,name,snapshot,does,not,exist,final,snapshot,id,snapshot,id,matching,snapshot,id,get,final,snapshot,info,snapshot,info,repository,get,snapshot,info,snapshot,id,final,snapshot,snapshot,new,snapshot,request,repository,name,snapshot,id,validate,snapshot,restorable,request,repository,name,snapshot,info,final,list,string,indices,in,snapshot,filter,indices,snapshot,info,indices,request,indices,request,indices,options,final,meta,data,builder,meta,data,builder,if,request,include,global,state,meta,data,builder,meta,data,builder,repository,get,snapshot,global,meta,data,snapshot,id,else,meta,data,builder,meta,data,builder,final,list,index,id,index,ids,in,snapshot,repository,data,resolve,indices,indices,in,snapshot,for,index,id,index,id,index,ids,in,snapshot,meta,data,builder,put,repository,get,snapshot,index,meta,data,snapshot,id,index,id,false,final,meta,data,meta,data,meta,data,builder,build,final,map,string,string,indices,renamed,indices,request,indices,in,snapshot,cluster,service,submit,state,update,task,request,cause,new,cluster,state,update,task,restore,info,restore,info,null,override,public,cluster,state,execute,cluster,state,current,state,restore,in,progress,restore,in,progress,current,state,custom,restore,in,progress,type,if,restore,in,progress,null,restore,in,progress,entries,is,empty,throw,new,concurrent,snapshot,execution,exception,snapshot,restore,process,is,already,running,in,this,cluster,snapshot,deletions,in,progress,deletions,in,progress,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,throw,new,concurrent,snapshot,execution,exception,snapshot,cannot,restore,a,snapshot,while,a,snapshot,deletion,is,in,progress,deletions,in,progress,get,entries,get,0,get,snapshot,cluster,state,builder,builder,cluster,state,builder,current,state,meta,data,builder,md,builder,meta,data,builder,current,state,meta,data,cluster,blocks,builder,blocks,cluster,blocks,builder,blocks,current,state,blocks,routing,table,builder,rt,builder,routing,table,builder,current,state,routing,table,immutable,open,map,shard,id,restore,in,progress,shard,restore,status,shards,set,string,aliases,new,hash,set,if,indices,is,empty,false,immutable,open,map,builder,shard,id,restore,in,progress,shard,restore,status,shards,builder,immutable,open,map,builder,final,version,min,index,compatibility,version,current,state,get,nodes,get,max,node,version,minimum,index,compatibility,version,for,map,entry,string,string,index,entry,indices,entry,set,string,index,index,entry,get,value,boolean,partial,check,partial,index,snapshot,recovery,source,recovery,source,new,snapshot,recovery,source,snapshot,snapshot,info,version,index,string,renamed,index,name,index,entry,get,key,index,meta,data,snapshot,index,meta,data,meta,data,index,index,snapshot,index,meta,data,update,index,settings,snapshot,index,meta,data,request,index,settings,request,ignore,index,settings,try,snapshot,index,meta,data,meta,data,index,upgrade,service,upgrade,index,meta,data,snapshot,index,meta,data,min,index,compatibility,version,catch,exception,ex,throw,new,snapshot,restore,exception,snapshot,cannot,restore,index,index,because,it,cannot,be,upgraded,ex,index,meta,data,current,index,meta,data,current,state,meta,data,index,renamed,index,name,int,set,ignore,shards,new,int,hash,set,final,index,renamed,index,if,current,index,meta,data,null,meta,data,create,index,service,validate,index,name,renamed,index,name,current,state,create,index,service,validate,index,settings,renamed,index,name,snapshot,index,meta,data,get,settings,current,state,false,index,meta,data,builder,index,md,builder,index,meta,data,builder,snapshot,index,meta,data,state,index,meta,data,state,open,index,renamed,index,name,index,md,builder,settings,settings,builder,put,snapshot,index,meta,data,get,settings,put,index,meta,data,uuids,random,base64uuid,if,request,include,aliases,snapshot,index,meta,data,get,aliases,is,empty,index,md,builder,remove,all,aliases,else,for,object,cursor,string,alias,snapshot,index,meta,data,get,aliases,keys,aliases,add,alias,value,index,meta,data,updated,index,meta,data,index,md,builder,build,if,partial,populate,ignored,shards,index,ignore,shards,rt,builder,add,as,new,restore,updated,index,meta,data,recovery,source,ignore,shards,blocks,add,blocks,updated,index,meta,data,md,builder,put,updated,index,meta,data,true,renamed,index,updated,index,meta,data,get,index,else,validate,existing,index,current,index,meta,data,snapshot,index,meta,data,renamed,index,name,partial,index,meta,data,builder,index,md,builder,index,meta,data,builder,snapshot,index,meta,data,state,index,meta,data,state,open,index,md,builder,version,math,max,snapshot,index,meta,data,get,version,current,index,meta,data,get,version,1,index,md,builder,mapping,version,math,max,snapshot,index,meta,data,get,mapping,version,current,index,meta,data,get,mapping,version,1,index,md,builder,settings,version,math,max,snapshot,index,meta,data,get,settings,version,current,index,meta,data,get,settings,version,1,if,request,include,aliases,if,snapshot,index,meta,data,get,aliases,is,empty,index,md,builder,remove,all,aliases,for,object,cursor,alias,meta,data,alias,current,index,meta,data,get,aliases,values,index,md,builder,put,alias,alias,value,else,for,object,cursor,string,alias,snapshot,index,meta,data,get,aliases,keys,aliases,add,alias,value,index,md,builder,settings,settings,builder,put,snapshot,index,meta,data,get,settings,put,index,meta,data,current,index,meta,data,get,index,uuid,index,meta,data,updated,index,meta,data,index,md,builder,index,renamed,index,name,build,rt,builder,add,as,restore,updated,index,meta,data,recovery,source,blocks,update,blocks,updated,index,meta,data,md,builder,put,updated,index,meta,data,true,renamed,index,updated,index,meta,data,get,index,for,int,shard,0,shard,snapshot,index,meta,data,get,number,of,shards,shard,if,ignore,shards,contains,shard,shards,builder,put,new,shard,id,renamed,index,shard,new,restore,in,progress,shard,restore,status,cluster,service,state,nodes,get,local,node,id,else,shards,builder,put,new,shard,id,renamed,index,shard,new,restore,in,progress,shard,restore,status,cluster,service,state,nodes,get,local,node,id,restore,in,progress,state,failure,shards,shards,builder,build,restore,in,progress,entry,restore,entry,new,restore,in,progress,entry,snapshot,overall,state,restore,in,progress,state,init,shards,collections,unmodifiable,list,new,array,list,indices,key,set,shards,builder,put,custom,restore,in,progress,type,new,restore,in,progress,restore,entry,else,shards,immutable,open,map,of,check,alias,name,conflicts,indices,aliases,if,request,include,global,state,if,meta,data,persistent,settings,null,settings,settings,meta,data,persistent,settings,cluster,settings,validate,update,settings,md,builder,persistent,settings,settings,if,meta,data,templates,null,for,object,cursor,index,template,meta,data,cursor,meta,data,templates,values,md,builder,put,cursor,value,if,meta,data,customs,null,for,object,object,cursor,string,meta,data,custom,cursor,meta,data,customs,if,repositories,meta,data,type,equals,cursor,key,md,builder,put,custom,cursor,key,cursor,value,if,completed,shards,restore,info,new,restore,info,snapshot,id,get,name,collections,unmodifiable,list,new,array,list,indices,key,set,shards,size,shards,size,failed,shards,shards,routing,table,rt,rt,builder,build,cluster,state,updated,state,builder,meta,data,md,builder,blocks,blocks,routing,table,rt,build,return,allocation,service,reroute,updated,state,restored,snapshot,snapshot,private,void,check,alias,name,conflicts,map,string,string,renamed,indices,set,string,aliases,for,map,entry,string,string,renamed,index,renamed,indices,entry,set,if,aliases,contains,renamed,index,get,key,throw,new,snapshot,restore,exception,snapshot,cannot,rename,index,renamed,index,get,value,into,renamed,index,get,key,because,of,conflict,with,an,alias,with,the,same,name,private,void,populate,ignored,shards,string,index,int,set,ignore,shards,for,snapshot,shard,failure,failure,snapshot,info,shard,failures,if,index,equals,failure,index,ignore,shards,add,failure,shard,id,private,boolean,check,partial,string,index,if,failed,snapshot,info,index,if,request,partial,return,true,else,throw,new,snapshot,restore,exception,snapshot,index,index,wasn,t,fully,snapshotted,cannot,restore,else,return,false,private,void,validate,existing,index,index,meta,data,current,index,meta,data,index,meta,data,snapshot,index,meta,data,string,renamed,index,boolean,partial,if,current,index,meta,data,get,state,index,meta,data,state,close,throw,new,snapshot,restore,exception,snapshot,cannot,restore,index,renamed,index,because,an,open,index,with,same,name,already,exists,in,the,cluster,either,close,or,delete,the,existing,index,or,restore,the,index,under,a,different,name,by,providing,a,rename,pattern,and,replacement,name,if,partial,throw,new,snapshot,restore,exception,snapshot,cannot,restore,partial,index,renamed,index,because,such,index,already,exists,if,current,index,meta,data,get,number,of,shards,snapshot,index,meta,data,get,number,of,shards,throw,new,snapshot,restore,exception,snapshot,cannot,restore,index,renamed,index,with,current,index,meta,data,get,number,of,shards,shards,from,a,snapshot,of,index,snapshot,index,meta,data,get,index,get,name,with,snapshot,index,meta,data,get,number,of,shards,shards,private,index,meta,data,update,index,settings,index,meta,data,index,meta,data,settings,change,settings,string,ignore,settings,if,change,settings,names,is,empty,ignore,settings,length,0,return,index,meta,data,settings,normalized,change,settings,settings,builder,put,change,settings,normalize,prefix,index,meta,data,build,index,meta,data,builder,builder,index,meta,data,builder,index,meta,data,settings,settings,index,meta,data,get,settings,set,string,key,filters,new,hash,set,list,string,simple,match,patterns,new,array,list,for,string,ignored,setting,ignore,settings,if,regex,is,simple,match,pattern,ignored,setting,if,contains,ignored,setting,throw,new,snapshot,restore,exception,snapshot,cannot,remove,setting,ignored,setting,on,restore,else,key,filters,add,ignored,setting,else,simple,match,patterns,add,ignored,setting,predicate,string,settings,filter,k,if,contains,k,false,for,string,filter,key,key,filters,if,k,equals,filter,key,return,false,for,string,pattern,simple,match,patterns,if,regex,simple,match,pattern,k,return,false,return,true,settings,builder,settings,builder,settings,builder,put,settings,filter,settings,filter,put,normalized,change,settings,filter,k,if,contains,k,throw,new,snapshot,restore,exception,snapshot,cannot,modify,setting,k,on,restore,else,return,true,return,builder,settings,settings,builder,build,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,restore,snapshot,snapshot,id,e,listener,on,failure,e,override,public,time,value,timeout,return,request,master,node,timeout,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,listener,on,response,new,restore,completion,response,snapshot,restore,info,catch,exception,e,logger,warn,new,parameterized,message,failed,to,restore,snapshot,request,repository,name,request,snapshot,name,e,listener,on,failure,e
RestoreService -> public void restoreSnapshot(final RestoreRequest request, final ActionListener<RestoreCompletionResponse> listener);1544783963;Restores snapshot specified in the restore request.__@param request  restore request_@param listener restore listener;public void restoreSnapshot(final RestoreRequest request, final ActionListener<RestoreCompletionResponse> listener) {_        try {_            _            Repository repository = repositoriesService.repository(request.repositoryName)__            final RepositoryData repositoryData = repository.getRepositoryData()__            final Optional<SnapshotId> incompatibleSnapshotId =_                repositoryData.getIncompatibleSnapshotIds().stream().filter(s -> request.snapshotName.equals(s.getName())).findFirst()__            if (incompatibleSnapshotId.isPresent()) {_                throw new SnapshotRestoreException(request.repositoryName, request.snapshotName, "cannot restore incompatible snapshot")__            }_            final Optional<SnapshotId> matchingSnapshotId = repositoryData.getSnapshotIds().stream()_                .filter(s -> request.snapshotName.equals(s.getName())).findFirst()__            if (matchingSnapshotId.isPresent() == false) {_                throw new SnapshotRestoreException(request.repositoryName, request.snapshotName, "snapshot does not exist")__            }__            final SnapshotId snapshotId = matchingSnapshotId.get()__            final SnapshotInfo snapshotInfo = repository.getSnapshotInfo(snapshotId)__            final Snapshot snapshot = new Snapshot(request.repositoryName, snapshotId)___            _            validateSnapshotRestorable(request.repositoryName, snapshotInfo)___            _            final List<String> indicesInSnapshot = filterIndices(snapshotInfo.indices(), request.indices(), request.indicesOptions())___            final MetaData.Builder metaDataBuilder__            if (request.includeGlobalState()) {_                metaDataBuilder = MetaData.builder(repository.getSnapshotGlobalMetaData(snapshotId))__            } else {_                metaDataBuilder = MetaData.builder()__            }__            final List<IndexId> indexIdsInSnapshot = repositoryData.resolveIndices(indicesInSnapshot)__            for (IndexId indexId : indexIdsInSnapshot) {_                metaDataBuilder.put(repository.getSnapshotIndexMetaData(snapshotId, indexId), false)__            }__            final MetaData metaData = metaDataBuilder.build()___            _            _            final Map<String, String> indices = renamedIndices(request, indicesInSnapshot)___            _            _            clusterService.submitStateUpdateTask(request.cause(), new ClusterStateUpdateTask() {_                String restoreUUID = UUIDs.randomBase64UUID()__                RestoreInfo restoreInfo = null___                @Override_                public ClusterState execute(ClusterState currentState) {_                    RestoreInProgress restoreInProgress = currentState.custom(RestoreInProgress.TYPE)__                    if (currentState.getNodes().getMinNodeVersion().before(Version.V_7_0_0)) {_                        _                        _                        if (restoreInProgress != null && restoreInProgress.isEmpty() == false) {_                            throw new ConcurrentSnapshotExecutionException(snapshot, "Restore process is already running in this cluster")__                        }_                    }_                    _                    SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                    if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                        throw new ConcurrentSnapshotExecutionException(snapshot,_                            "cannot restore a snapshot while a snapshot deletion is in-progress [" +_                                deletionsInProgress.getEntries().get(0).getSnapshot() + "]")__                    }__                    _                    ClusterState.Builder builder = ClusterState.builder(currentState)__                    MetaData.Builder mdBuilder = MetaData.builder(currentState.metaData())__                    ClusterBlocks.Builder blocks = ClusterBlocks.builder().blocks(currentState.blocks())__                    RoutingTable.Builder rtBuilder = RoutingTable.builder(currentState.routingTable())__                    ImmutableOpenMap<ShardId, RestoreInProgress.ShardRestoreStatus> shards__                    Set<String> aliases = new HashSet<>()___                    if (indices.isEmpty() == false) {_                        _                        ImmutableOpenMap.Builder<ShardId, RestoreInProgress.ShardRestoreStatus> shardsBuilder = ImmutableOpenMap.builder()__                        final Version minIndexCompatibilityVersion = currentState.getNodes().getMaxNodeVersion()_                            .minimumIndexCompatibilityVersion()__                        for (Map.Entry<String, String> indexEntry : indices.entrySet()) {_                            String index = indexEntry.getValue()__                            boolean partial = checkPartial(index)__                            SnapshotRecoverySource recoverySource = new SnapshotRecoverySource(restoreUUID, snapshot, snapshotInfo.version(), index)__                            String renamedIndexName = indexEntry.getKey()__                            IndexMetaData snapshotIndexMetaData = metaData.index(index)__                            snapshotIndexMetaData = updateIndexSettings(snapshotIndexMetaData, request.indexSettings, request.ignoreIndexSettings)__                            try {_                                snapshotIndexMetaData = metaDataIndexUpgradeService.upgradeIndexMetaData(snapshotIndexMetaData,_                                    minIndexCompatibilityVersion)__                            } catch (Exception ex) {_                                throw new SnapshotRestoreException(snapshot, "cannot restore index [" + index + "] because it cannot be upgraded", ex)__                            }_                            _                            IndexMetaData currentIndexMetaData = currentState.metaData().index(renamedIndexName)__                            IntSet ignoreShards = new IntHashSet()__                            final Index renamedIndex__                            if (currentIndexMetaData == null) {_                                _                                _                                MetaDataCreateIndexService.validateIndexName(renamedIndexName, currentState)__                                createIndexService.validateIndexSettings(renamedIndexName, snapshotIndexMetaData.getSettings(), currentState, false)__                                IndexMetaData.Builder indexMdBuilder = IndexMetaData.builder(snapshotIndexMetaData).state(IndexMetaData.State.OPEN).index(renamedIndexName)__                                indexMdBuilder.settings(Settings.builder().put(snapshotIndexMetaData.getSettings()).put(IndexMetaData.SETTING_INDEX_UUID, UUIDs.randomBase64UUID()))__                                if (!request.includeAliases() && !snapshotIndexMetaData.getAliases().isEmpty()) {_                                    _                                    indexMdBuilder.removeAllAliases()__                                } else {_                                    for (ObjectCursor<String> alias : snapshotIndexMetaData.getAliases().keys()) {_                                        aliases.add(alias.value)__                                    }_                                }_                                IndexMetaData updatedIndexMetaData = indexMdBuilder.build()__                                if (partial) {_                                    populateIgnoredShards(index, ignoreShards)__                                }_                                rtBuilder.addAsNewRestore(updatedIndexMetaData, recoverySource, ignoreShards)__                                blocks.addBlocks(updatedIndexMetaData)__                                mdBuilder.put(updatedIndexMetaData, true)__                                renamedIndex = updatedIndexMetaData.getIndex()__                            } else {_                                validateExistingIndex(currentIndexMetaData, snapshotIndexMetaData, renamedIndexName, partial)__                                _                                IndexMetaData.Builder indexMdBuilder = IndexMetaData.builder(snapshotIndexMetaData).state(IndexMetaData.State.OPEN)__                                indexMdBuilder.version(Math.max(snapshotIndexMetaData.getVersion(), currentIndexMetaData.getVersion() + 1))__                                indexMdBuilder.mappingVersion(Math.max(snapshotIndexMetaData.getMappingVersion(), currentIndexMetaData.getMappingVersion() + 1))__                                indexMdBuilder.settingsVersion(Math.max(snapshotIndexMetaData.getSettingsVersion(), currentIndexMetaData.getSettingsVersion() + 1))__                                if (!request.includeAliases()) {_                                    _                                    if (!snapshotIndexMetaData.getAliases().isEmpty()) {_                                        indexMdBuilder.removeAllAliases()__                                    }_                                    _                                    for (ObjectCursor<AliasMetaData> alias : currentIndexMetaData.getAliases().values()) {_                                        indexMdBuilder.putAlias(alias.value)__                                    }_                                } else {_                                    for (ObjectCursor<String> alias : snapshotIndexMetaData.getAliases().keys()) {_                                        aliases.add(alias.value)__                                    }_                                }_                                indexMdBuilder.settings(Settings.builder().put(snapshotIndexMetaData.getSettings()).put(IndexMetaData.SETTING_INDEX_UUID, currentIndexMetaData.getIndexUUID()))__                                IndexMetaData updatedIndexMetaData = indexMdBuilder.index(renamedIndexName).build()__                                rtBuilder.addAsRestore(updatedIndexMetaData, recoverySource)__                                blocks.updateBlocks(updatedIndexMetaData)__                                mdBuilder.put(updatedIndexMetaData, true)__                                renamedIndex = updatedIndexMetaData.getIndex()__                            }__                            for (int shard = 0_ shard < snapshotIndexMetaData.getNumberOfShards()_ shard++) {_                                if (!ignoreShards.contains(shard)) {_                                    shardsBuilder.put(new ShardId(renamedIndex, shard), new RestoreInProgress.ShardRestoreStatus(clusterService.state().nodes().getLocalNodeId()))__                                } else {_                                    shardsBuilder.put(new ShardId(renamedIndex, shard), new RestoreInProgress.ShardRestoreStatus(clusterService.state().nodes().getLocalNodeId(), RestoreInProgress.State.FAILURE))__                                }_                            }_                        }__                        shards = shardsBuilder.build()__                        RestoreInProgress.Entry restoreEntry = new RestoreInProgress.Entry(_                            restoreUUID, snapshot, overallState(RestoreInProgress.State.INIT, shards),_                            Collections.unmodifiableList(new ArrayList<>(indices.keySet())),_                            shards_                        )__                        RestoreInProgress.Builder restoreInProgressBuilder__                        if (restoreInProgress != null) {_                            restoreInProgressBuilder = new RestoreInProgress.Builder(restoreInProgress)__                        } else {_                            restoreInProgressBuilder = new RestoreInProgress.Builder()__                        }_                        builder.putCustom(RestoreInProgress.TYPE, restoreInProgressBuilder.add(restoreEntry).build())__                    } else {_                        shards = ImmutableOpenMap.of()__                    }__                    checkAliasNameConflicts(indices, aliases)___                    _                    if (request.includeGlobalState()) {_                        if (metaData.persistentSettings() != null) {_                            Settings settings = metaData.persistentSettings()__                            clusterSettings.validateUpdate(settings)__                            mdBuilder.persistentSettings(settings)__                        }_                        if (metaData.templates() != null) {_                            _                            for (ObjectCursor<IndexTemplateMetaData> cursor : metaData.templates().values()) {_                                mdBuilder.put(cursor.value)__                            }_                        }_                        if (metaData.customs() != null) {_                            for (ObjectObjectCursor<String, MetaData.Custom> cursor : metaData.customs()) {_                                if (!RepositoriesMetaData.TYPE.equals(cursor.key)) {_                                    _                                    _                                    mdBuilder.putCustom(cursor.key, cursor.value)__                                }_                            }_                        }_                    }__                    if (completed(shards)) {_                        _                        restoreInfo = new RestoreInfo(snapshotId.getName(),_                                                      Collections.unmodifiableList(new ArrayList<>(indices.keySet())),_                                                      shards.size(),_                                                      shards.size() - failedShards(shards))__                    }__                    RoutingTable rt = rtBuilder.build()__                    ClusterState updatedState = builder.metaData(mdBuilder).blocks(blocks).routingTable(rt).build()__                    return allocationService.reroute(updatedState, "restored snapshot [" + snapshot + "]")__                }__                private void checkAliasNameConflicts(Map<String, String> renamedIndices, Set<String> aliases) {_                    for (Map.Entry<String, String> renamedIndex : renamedIndices.entrySet()) {_                        if (aliases.contains(renamedIndex.getKey())) {_                            throw new SnapshotRestoreException(snapshot, "cannot rename index [" + renamedIndex.getValue() + "] into [" + renamedIndex.getKey() + "] because of conflict with an alias with the same name")__                        }_                    }_                }__                private void populateIgnoredShards(String index, IntSet ignoreShards) {_                    for (SnapshotShardFailure failure : snapshotInfo.shardFailures()) {_                        if (index.equals(failure.index())) {_                            ignoreShards.add(failure.shardId())__                        }_                    }_                }__                private boolean checkPartial(String index) {_                    _                    if (failed(snapshotInfo, index)) {_                        if (request.partial()) {_                            return true__                        } else {_                            throw new SnapshotRestoreException(snapshot, "index [" + index + "] wasn't fully snapshotted - cannot restore")__                        }_                    } else {_                        return false__                    }_                }__                private void validateExistingIndex(IndexMetaData currentIndexMetaData, IndexMetaData snapshotIndexMetaData, String renamedIndex, boolean partial) {_                    _                    if (currentIndexMetaData.getState() != IndexMetaData.State.CLOSE) {_                        _                        throw new SnapshotRestoreException(snapshot, "cannot restore index [" + renamedIndex + "] because an open index with same name already exists in the cluster. " +_                            "Either close or delete the existing index or restore the index under a different name by providing a rename pattern and replacement name")__                    }_                    _                    if (partial) {_                        throw new SnapshotRestoreException(snapshot, "cannot restore partial index [" + renamedIndex + "] because such index already exists")__                    }_                    _                    if (currentIndexMetaData.getNumberOfShards() != snapshotIndexMetaData.getNumberOfShards()) {_                        throw new SnapshotRestoreException(snapshot, "cannot restore index [" + renamedIndex + "] with [" + currentIndexMetaData.getNumberOfShards() +_                                "] shards from a snapshot of index [" + snapshotIndexMetaData.getIndex().getName() + "] with [" + snapshotIndexMetaData.getNumberOfShards() + "] shards")__                    }_                }__                _                private IndexMetaData updateIndexSettings(IndexMetaData indexMetaData, Settings changeSettings, String[] ignoreSettings) {_                    if (changeSettings.names().isEmpty() && ignoreSettings.length == 0) {_                        return indexMetaData__                    }_                    Settings normalizedChangeSettings = Settings.builder().put(changeSettings).normalizePrefix(IndexMetaData.INDEX_SETTING_PREFIX).build()__                    IndexMetaData.Builder builder = IndexMetaData.builder(indexMetaData)__                    Settings settings = indexMetaData.getSettings()__                    Set<String> keyFilters = new HashSet<>()__                    List<String> simpleMatchPatterns = new ArrayList<>()__                    for (String ignoredSetting : ignoreSettings) {_                        if (!Regex.isSimpleMatchPattern(ignoredSetting)) {_                            if (UNREMOVABLE_SETTINGS.contains(ignoredSetting)) {_                                throw new SnapshotRestoreException(snapshot, "cannot remove setting [" + ignoredSetting + "] on restore")__                            } else {_                                keyFilters.add(ignoredSetting)__                            }_                        } else {_                            simpleMatchPatterns.add(ignoredSetting)__                        }_                    }_                    Predicate<String> settingsFilter = k -> {_                        if (UNREMOVABLE_SETTINGS.contains(k) == false) {_                            for (String filterKey : keyFilters) {_                                if (k.equals(filterKey)) {_                                    return false__                                }_                            }_                            for (String pattern : simpleMatchPatterns) {_                                if (Regex.simpleMatch(pattern, k)) {_                                    return false__                                }_                            }_                        }_                        return true__                    }__                    Settings.Builder settingsBuilder = Settings.builder()_                        .put(settings.filter(settingsFilter))_                        .put(normalizedChangeSettings.filter(k -> {_                            if (UNMODIFIABLE_SETTINGS.contains(k)) {_                                throw new SnapshotRestoreException(snapshot, "cannot modify setting [" + k + "] on restore")__                            } else {_                                return true__                            }_                        }))__                    return builder.settings(settingsBuilder).build()__                }__                @Override_                public void onFailure(String source, Exception e) {_                    logger.warn(() -> new ParameterizedMessage("[{}] failed to restore snapshot", snapshotId), e)__                    listener.onFailure(e)__                }__                @Override_                public TimeValue timeout() {_                    return request.masterNodeTimeout()__                }__                @Override_                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                    listener.onResponse(new RestoreCompletionResponse(restoreUUID, snapshot, restoreInfo))__                }_            })____        } catch (Exception e) {_            logger.warn(() -> new ParameterizedMessage("[{}] failed to restore snapshot", request.repositoryName + ":" + request.snapshotName), e)__            listener.onFailure(e)__        }_    };restores,snapshot,specified,in,the,restore,request,param,request,restore,request,param,listener,restore,listener;public,void,restore,snapshot,final,restore,request,request,final,action,listener,restore,completion,response,listener,try,repository,repository,repositories,service,repository,request,repository,name,final,repository,data,repository,data,repository,get,repository,data,final,optional,snapshot,id,incompatible,snapshot,id,repository,data,get,incompatible,snapshot,ids,stream,filter,s,request,snapshot,name,equals,s,get,name,find,first,if,incompatible,snapshot,id,is,present,throw,new,snapshot,restore,exception,request,repository,name,request,snapshot,name,cannot,restore,incompatible,snapshot,final,optional,snapshot,id,matching,snapshot,id,repository,data,get,snapshot,ids,stream,filter,s,request,snapshot,name,equals,s,get,name,find,first,if,matching,snapshot,id,is,present,false,throw,new,snapshot,restore,exception,request,repository,name,request,snapshot,name,snapshot,does,not,exist,final,snapshot,id,snapshot,id,matching,snapshot,id,get,final,snapshot,info,snapshot,info,repository,get,snapshot,info,snapshot,id,final,snapshot,snapshot,new,snapshot,request,repository,name,snapshot,id,validate,snapshot,restorable,request,repository,name,snapshot,info,final,list,string,indices,in,snapshot,filter,indices,snapshot,info,indices,request,indices,request,indices,options,final,meta,data,builder,meta,data,builder,if,request,include,global,state,meta,data,builder,meta,data,builder,repository,get,snapshot,global,meta,data,snapshot,id,else,meta,data,builder,meta,data,builder,final,list,index,id,index,ids,in,snapshot,repository,data,resolve,indices,indices,in,snapshot,for,index,id,index,id,index,ids,in,snapshot,meta,data,builder,put,repository,get,snapshot,index,meta,data,snapshot,id,index,id,false,final,meta,data,meta,data,meta,data,builder,build,final,map,string,string,indices,renamed,indices,request,indices,in,snapshot,cluster,service,submit,state,update,task,request,cause,new,cluster,state,update,task,string,restore,uuid,uuids,random,base64uuid,restore,info,restore,info,null,override,public,cluster,state,execute,cluster,state,current,state,restore,in,progress,restore,in,progress,current,state,custom,restore,in,progress,type,if,current,state,get,nodes,get,min,node,version,before,version,if,restore,in,progress,null,restore,in,progress,is,empty,false,throw,new,concurrent,snapshot,execution,exception,snapshot,restore,process,is,already,running,in,this,cluster,snapshot,deletions,in,progress,deletions,in,progress,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,throw,new,concurrent,snapshot,execution,exception,snapshot,cannot,restore,a,snapshot,while,a,snapshot,deletion,is,in,progress,deletions,in,progress,get,entries,get,0,get,snapshot,cluster,state,builder,builder,cluster,state,builder,current,state,meta,data,builder,md,builder,meta,data,builder,current,state,meta,data,cluster,blocks,builder,blocks,cluster,blocks,builder,blocks,current,state,blocks,routing,table,builder,rt,builder,routing,table,builder,current,state,routing,table,immutable,open,map,shard,id,restore,in,progress,shard,restore,status,shards,set,string,aliases,new,hash,set,if,indices,is,empty,false,immutable,open,map,builder,shard,id,restore,in,progress,shard,restore,status,shards,builder,immutable,open,map,builder,final,version,min,index,compatibility,version,current,state,get,nodes,get,max,node,version,minimum,index,compatibility,version,for,map,entry,string,string,index,entry,indices,entry,set,string,index,index,entry,get,value,boolean,partial,check,partial,index,snapshot,recovery,source,recovery,source,new,snapshot,recovery,source,restore,uuid,snapshot,snapshot,info,version,index,string,renamed,index,name,index,entry,get,key,index,meta,data,snapshot,index,meta,data,meta,data,index,index,snapshot,index,meta,data,update,index,settings,snapshot,index,meta,data,request,index,settings,request,ignore,index,settings,try,snapshot,index,meta,data,meta,data,index,upgrade,service,upgrade,index,meta,data,snapshot,index,meta,data,min,index,compatibility,version,catch,exception,ex,throw,new,snapshot,restore,exception,snapshot,cannot,restore,index,index,because,it,cannot,be,upgraded,ex,index,meta,data,current,index,meta,data,current,state,meta,data,index,renamed,index,name,int,set,ignore,shards,new,int,hash,set,final,index,renamed,index,if,current,index,meta,data,null,meta,data,create,index,service,validate,index,name,renamed,index,name,current,state,create,index,service,validate,index,settings,renamed,index,name,snapshot,index,meta,data,get,settings,current,state,false,index,meta,data,builder,index,md,builder,index,meta,data,builder,snapshot,index,meta,data,state,index,meta,data,state,open,index,renamed,index,name,index,md,builder,settings,settings,builder,put,snapshot,index,meta,data,get,settings,put,index,meta,data,uuids,random,base64uuid,if,request,include,aliases,snapshot,index,meta,data,get,aliases,is,empty,index,md,builder,remove,all,aliases,else,for,object,cursor,string,alias,snapshot,index,meta,data,get,aliases,keys,aliases,add,alias,value,index,meta,data,updated,index,meta,data,index,md,builder,build,if,partial,populate,ignored,shards,index,ignore,shards,rt,builder,add,as,new,restore,updated,index,meta,data,recovery,source,ignore,shards,blocks,add,blocks,updated,index,meta,data,md,builder,put,updated,index,meta,data,true,renamed,index,updated,index,meta,data,get,index,else,validate,existing,index,current,index,meta,data,snapshot,index,meta,data,renamed,index,name,partial,index,meta,data,builder,index,md,builder,index,meta,data,builder,snapshot,index,meta,data,state,index,meta,data,state,open,index,md,builder,version,math,max,snapshot,index,meta,data,get,version,current,index,meta,data,get,version,1,index,md,builder,mapping,version,math,max,snapshot,index,meta,data,get,mapping,version,current,index,meta,data,get,mapping,version,1,index,md,builder,settings,version,math,max,snapshot,index,meta,data,get,settings,version,current,index,meta,data,get,settings,version,1,if,request,include,aliases,if,snapshot,index,meta,data,get,aliases,is,empty,index,md,builder,remove,all,aliases,for,object,cursor,alias,meta,data,alias,current,index,meta,data,get,aliases,values,index,md,builder,put,alias,alias,value,else,for,object,cursor,string,alias,snapshot,index,meta,data,get,aliases,keys,aliases,add,alias,value,index,md,builder,settings,settings,builder,put,snapshot,index,meta,data,get,settings,put,index,meta,data,current,index,meta,data,get,index,uuid,index,meta,data,updated,index,meta,data,index,md,builder,index,renamed,index,name,build,rt,builder,add,as,restore,updated,index,meta,data,recovery,source,blocks,update,blocks,updated,index,meta,data,md,builder,put,updated,index,meta,data,true,renamed,index,updated,index,meta,data,get,index,for,int,shard,0,shard,snapshot,index,meta,data,get,number,of,shards,shard,if,ignore,shards,contains,shard,shards,builder,put,new,shard,id,renamed,index,shard,new,restore,in,progress,shard,restore,status,cluster,service,state,nodes,get,local,node,id,else,shards,builder,put,new,shard,id,renamed,index,shard,new,restore,in,progress,shard,restore,status,cluster,service,state,nodes,get,local,node,id,restore,in,progress,state,failure,shards,shards,builder,build,restore,in,progress,entry,restore,entry,new,restore,in,progress,entry,restore,uuid,snapshot,overall,state,restore,in,progress,state,init,shards,collections,unmodifiable,list,new,array,list,indices,key,set,shards,restore,in,progress,builder,restore,in,progress,builder,if,restore,in,progress,null,restore,in,progress,builder,new,restore,in,progress,builder,restore,in,progress,else,restore,in,progress,builder,new,restore,in,progress,builder,builder,put,custom,restore,in,progress,type,restore,in,progress,builder,add,restore,entry,build,else,shards,immutable,open,map,of,check,alias,name,conflicts,indices,aliases,if,request,include,global,state,if,meta,data,persistent,settings,null,settings,settings,meta,data,persistent,settings,cluster,settings,validate,update,settings,md,builder,persistent,settings,settings,if,meta,data,templates,null,for,object,cursor,index,template,meta,data,cursor,meta,data,templates,values,md,builder,put,cursor,value,if,meta,data,customs,null,for,object,object,cursor,string,meta,data,custom,cursor,meta,data,customs,if,repositories,meta,data,type,equals,cursor,key,md,builder,put,custom,cursor,key,cursor,value,if,completed,shards,restore,info,new,restore,info,snapshot,id,get,name,collections,unmodifiable,list,new,array,list,indices,key,set,shards,size,shards,size,failed,shards,shards,routing,table,rt,rt,builder,build,cluster,state,updated,state,builder,meta,data,md,builder,blocks,blocks,routing,table,rt,build,return,allocation,service,reroute,updated,state,restored,snapshot,snapshot,private,void,check,alias,name,conflicts,map,string,string,renamed,indices,set,string,aliases,for,map,entry,string,string,renamed,index,renamed,indices,entry,set,if,aliases,contains,renamed,index,get,key,throw,new,snapshot,restore,exception,snapshot,cannot,rename,index,renamed,index,get,value,into,renamed,index,get,key,because,of,conflict,with,an,alias,with,the,same,name,private,void,populate,ignored,shards,string,index,int,set,ignore,shards,for,snapshot,shard,failure,failure,snapshot,info,shard,failures,if,index,equals,failure,index,ignore,shards,add,failure,shard,id,private,boolean,check,partial,string,index,if,failed,snapshot,info,index,if,request,partial,return,true,else,throw,new,snapshot,restore,exception,snapshot,index,index,wasn,t,fully,snapshotted,cannot,restore,else,return,false,private,void,validate,existing,index,index,meta,data,current,index,meta,data,index,meta,data,snapshot,index,meta,data,string,renamed,index,boolean,partial,if,current,index,meta,data,get,state,index,meta,data,state,close,throw,new,snapshot,restore,exception,snapshot,cannot,restore,index,renamed,index,because,an,open,index,with,same,name,already,exists,in,the,cluster,either,close,or,delete,the,existing,index,or,restore,the,index,under,a,different,name,by,providing,a,rename,pattern,and,replacement,name,if,partial,throw,new,snapshot,restore,exception,snapshot,cannot,restore,partial,index,renamed,index,because,such,index,already,exists,if,current,index,meta,data,get,number,of,shards,snapshot,index,meta,data,get,number,of,shards,throw,new,snapshot,restore,exception,snapshot,cannot,restore,index,renamed,index,with,current,index,meta,data,get,number,of,shards,shards,from,a,snapshot,of,index,snapshot,index,meta,data,get,index,get,name,with,snapshot,index,meta,data,get,number,of,shards,shards,private,index,meta,data,update,index,settings,index,meta,data,index,meta,data,settings,change,settings,string,ignore,settings,if,change,settings,names,is,empty,ignore,settings,length,0,return,index,meta,data,settings,normalized,change,settings,settings,builder,put,change,settings,normalize,prefix,index,meta,data,build,index,meta,data,builder,builder,index,meta,data,builder,index,meta,data,settings,settings,index,meta,data,get,settings,set,string,key,filters,new,hash,set,list,string,simple,match,patterns,new,array,list,for,string,ignored,setting,ignore,settings,if,regex,is,simple,match,pattern,ignored,setting,if,contains,ignored,setting,throw,new,snapshot,restore,exception,snapshot,cannot,remove,setting,ignored,setting,on,restore,else,key,filters,add,ignored,setting,else,simple,match,patterns,add,ignored,setting,predicate,string,settings,filter,k,if,contains,k,false,for,string,filter,key,key,filters,if,k,equals,filter,key,return,false,for,string,pattern,simple,match,patterns,if,regex,simple,match,pattern,k,return,false,return,true,settings,builder,settings,builder,settings,builder,put,settings,filter,settings,filter,put,normalized,change,settings,filter,k,if,contains,k,throw,new,snapshot,restore,exception,snapshot,cannot,modify,setting,k,on,restore,else,return,true,return,builder,settings,settings,builder,build,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,restore,snapshot,snapshot,id,e,listener,on,failure,e,override,public,time,value,timeout,return,request,master,node,timeout,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,listener,on,response,new,restore,completion,response,restore,uuid,snapshot,restore,info,catch,exception,e,logger,warn,new,parameterized,message,failed,to,restore,snapshot,request,repository,name,request,snapshot,name,e,listener,on,failure,e
RestoreService -> public void restoreSnapshot(final RestoreRequest request, final ActionListener<RestoreCompletionResponse> listener);1545215361;Restores snapshot specified in the restore request.__@param request  restore request_@param listener restore listener;public void restoreSnapshot(final RestoreRequest request, final ActionListener<RestoreCompletionResponse> listener) {_        try {_            _            Repository repository = repositoriesService.repository(request.repositoryName)__            final RepositoryData repositoryData = repository.getRepositoryData()__            final Optional<SnapshotId> incompatibleSnapshotId =_                repositoryData.getIncompatibleSnapshotIds().stream().filter(s -> request.snapshotName.equals(s.getName())).findFirst()__            if (incompatibleSnapshotId.isPresent()) {_                throw new SnapshotRestoreException(request.repositoryName, request.snapshotName, "cannot restore incompatible snapshot")__            }_            final Optional<SnapshotId> matchingSnapshotId = repositoryData.getSnapshotIds().stream()_                .filter(s -> request.snapshotName.equals(s.getName())).findFirst()__            if (matchingSnapshotId.isPresent() == false) {_                throw new SnapshotRestoreException(request.repositoryName, request.snapshotName, "snapshot does not exist")__            }__            final SnapshotId snapshotId = matchingSnapshotId.get()__            final SnapshotInfo snapshotInfo = repository.getSnapshotInfo(snapshotId)__            final Snapshot snapshot = new Snapshot(request.repositoryName, snapshotId)___            _            validateSnapshotRestorable(request.repositoryName, snapshotInfo)___            _            final List<String> indicesInSnapshot = filterIndices(snapshotInfo.indices(), request.indices(), request.indicesOptions())___            final MetaData.Builder metaDataBuilder__            if (request.includeGlobalState()) {_                metaDataBuilder = MetaData.builder(repository.getSnapshotGlobalMetaData(snapshotId))__            } else {_                metaDataBuilder = MetaData.builder()__            }__            final List<IndexId> indexIdsInSnapshot = repositoryData.resolveIndices(indicesInSnapshot)__            for (IndexId indexId : indexIdsInSnapshot) {_                metaDataBuilder.put(repository.getSnapshotIndexMetaData(snapshotId, indexId), false)__            }__            final MetaData metaData = metaDataBuilder.build()___            _            _            final Map<String, String> indices = renamedIndices(request, indicesInSnapshot)___            _            _            clusterService.submitStateUpdateTask(request.cause(), new ClusterStateUpdateTask() {_                String restoreUUID = UUIDs.randomBase64UUID()__                RestoreInfo restoreInfo = null___                @Override_                public ClusterState execute(ClusterState currentState) {_                    RestoreInProgress restoreInProgress = currentState.custom(RestoreInProgress.TYPE)__                    if (currentState.getNodes().getMinNodeVersion().before(Version.V_7_0_0)) {_                        _                        _                        if (restoreInProgress != null && restoreInProgress.isEmpty() == false) {_                            throw new ConcurrentSnapshotExecutionException(snapshot, "Restore process is already running in this cluster")__                        }_                    }_                    _                    SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                    if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                        throw new ConcurrentSnapshotExecutionException(snapshot,_                            "cannot restore a snapshot while a snapshot deletion is in-progress [" +_                                deletionsInProgress.getEntries().get(0).getSnapshot() + "]")__                    }__                    _                    ClusterState.Builder builder = ClusterState.builder(currentState)__                    MetaData.Builder mdBuilder = MetaData.builder(currentState.metaData())__                    ClusterBlocks.Builder blocks = ClusterBlocks.builder().blocks(currentState.blocks())__                    RoutingTable.Builder rtBuilder = RoutingTable.builder(currentState.routingTable())__                    ImmutableOpenMap<ShardId, RestoreInProgress.ShardRestoreStatus> shards__                    Set<String> aliases = new HashSet<>()___                    if (indices.isEmpty() == false) {_                        _                        ImmutableOpenMap.Builder<ShardId, RestoreInProgress.ShardRestoreStatus> shardsBuilder = ImmutableOpenMap.builder()__                        final Version minIndexCompatibilityVersion = currentState.getNodes().getMaxNodeVersion()_                            .minimumIndexCompatibilityVersion()__                        for (Map.Entry<String, String> indexEntry : indices.entrySet()) {_                            String index = indexEntry.getValue()__                            boolean partial = checkPartial(index)__                            SnapshotRecoverySource recoverySource =_                                new SnapshotRecoverySource(restoreUUID, snapshot, snapshotInfo.version(), index)__                            String renamedIndexName = indexEntry.getKey()__                            IndexMetaData snapshotIndexMetaData = metaData.index(index)__                            snapshotIndexMetaData = updateIndexSettings(snapshotIndexMetaData,_                                                                        request.indexSettings, request.ignoreIndexSettings)__                            try {_                                snapshotIndexMetaData = metaDataIndexUpgradeService.upgradeIndexMetaData(snapshotIndexMetaData,_                                    minIndexCompatibilityVersion)__                            } catch (Exception ex) {_                                throw new SnapshotRestoreException(snapshot, "cannot restore index [" + index + "] because it cannot be " +_                                    "upgraded", ex)__                            }_                            _                            IndexMetaData currentIndexMetaData = currentState.metaData().index(renamedIndexName)__                            IntSet ignoreShards = new IntHashSet()__                            final Index renamedIndex__                            if (currentIndexMetaData == null) {_                                _                                _                                MetaDataCreateIndexService.validateIndexName(renamedIndexName, currentState)__                                createIndexService.validateIndexSettings(renamedIndexName,_                                                                        snapshotIndexMetaData.getSettings(),_                                                                        currentState,_                                                                        false)__                                IndexMetaData.Builder indexMdBuilder = IndexMetaData.builder(snapshotIndexMetaData)_                                                                                    .state(IndexMetaData.State.OPEN)_                                                                                    .index(renamedIndexName)__                                indexMdBuilder.settings(Settings.builder()_                                                                .put(snapshotIndexMetaData.getSettings())_                                                                .put(IndexMetaData.SETTING_INDEX_UUID, UUIDs.randomBase64UUID()))__                                if (!request.includeAliases() && !snapshotIndexMetaData.getAliases().isEmpty()) {_                                    _                                    indexMdBuilder.removeAllAliases()__                                } else {_                                    for (ObjectCursor<String> alias : snapshotIndexMetaData.getAliases().keys()) {_                                        aliases.add(alias.value)__                                    }_                                }_                                IndexMetaData updatedIndexMetaData = indexMdBuilder.build()__                                if (partial) {_                                    populateIgnoredShards(index, ignoreShards)__                                }_                                rtBuilder.addAsNewRestore(updatedIndexMetaData, recoverySource, ignoreShards)__                                blocks.addBlocks(updatedIndexMetaData)__                                mdBuilder.put(updatedIndexMetaData, true)__                                renamedIndex = updatedIndexMetaData.getIndex()__                            } else {_                                validateExistingIndex(currentIndexMetaData, snapshotIndexMetaData, renamedIndexName, partial)__                                _                                IndexMetaData.Builder indexMdBuilder = IndexMetaData.builder(snapshotIndexMetaData)_                                                                                    .state(IndexMetaData.State.OPEN)__                                indexMdBuilder.version(Math.max(snapshotIndexMetaData.getVersion(), currentIndexMetaData.getVersion() + 1))__                                indexMdBuilder.mappingVersion(Math.max(snapshotIndexMetaData.getMappingVersion(),_                                                                        currentIndexMetaData.getMappingVersion() + 1))__                                indexMdBuilder.settingsVersion(Math.max(snapshotIndexMetaData.getSettingsVersion(),_                                                                        currentIndexMetaData.getSettingsVersion() + 1))__                                if (!request.includeAliases()) {_                                    _                                    if (!snapshotIndexMetaData.getAliases().isEmpty()) {_                                        indexMdBuilder.removeAllAliases()__                                    }_                                    _                                    for (ObjectCursor<AliasMetaData> alias : currentIndexMetaData.getAliases().values()) {_                                        indexMdBuilder.putAlias(alias.value)__                                    }_                                } else {_                                    for (ObjectCursor<String> alias : snapshotIndexMetaData.getAliases().keys()) {_                                        aliases.add(alias.value)__                                    }_                                }_                                indexMdBuilder.settings(Settings.builder()_                                                                .put(snapshotIndexMetaData.getSettings())_                                                                .put(IndexMetaData.SETTING_INDEX_UUID,_                                                                    currentIndexMetaData.getIndexUUID()))__                                IndexMetaData updatedIndexMetaData = indexMdBuilder.index(renamedIndexName).build()__                                rtBuilder.addAsRestore(updatedIndexMetaData, recoverySource)__                                blocks.updateBlocks(updatedIndexMetaData)__                                mdBuilder.put(updatedIndexMetaData, true)__                                renamedIndex = updatedIndexMetaData.getIndex()__                            }__                            for (int shard = 0_ shard < snapshotIndexMetaData.getNumberOfShards()_ shard++) {_                                if (!ignoreShards.contains(shard)) {_                                    shardsBuilder.put(new ShardId(renamedIndex, shard),_                                            new RestoreInProgress.ShardRestoreStatus(clusterService.state().nodes().getLocalNodeId()))__                                } else {_                                    shardsBuilder.put(new ShardId(renamedIndex, shard),_                                            new RestoreInProgress.ShardRestoreStatus(clusterService.state().nodes().getLocalNodeId(),_                                                RestoreInProgress.State.FAILURE))__                                }_                            }_                        }__                        shards = shardsBuilder.build()__                        RestoreInProgress.Entry restoreEntry = new RestoreInProgress.Entry(_                            restoreUUID, snapshot, overallState(RestoreInProgress.State.INIT, shards),_                            Collections.unmodifiableList(new ArrayList<>(indices.keySet())),_                            shards_                        )__                        RestoreInProgress.Builder restoreInProgressBuilder__                        if (restoreInProgress != null) {_                            restoreInProgressBuilder = new RestoreInProgress.Builder(restoreInProgress)__                        } else {_                            restoreInProgressBuilder = new RestoreInProgress.Builder()__                        }_                        builder.putCustom(RestoreInProgress.TYPE, restoreInProgressBuilder.add(restoreEntry).build())__                    } else {_                        shards = ImmutableOpenMap.of()__                    }__                    checkAliasNameConflicts(indices, aliases)___                    _                    if (request.includeGlobalState()) {_                        if (metaData.persistentSettings() != null) {_                            Settings settings = metaData.persistentSettings()__                            clusterSettings.validateUpdate(settings)__                            mdBuilder.persistentSettings(settings)__                        }_                        if (metaData.templates() != null) {_                            _                            for (ObjectCursor<IndexTemplateMetaData> cursor : metaData.templates().values()) {_                                mdBuilder.put(cursor.value)__                            }_                        }_                        if (metaData.customs() != null) {_                            for (ObjectObjectCursor<String, MetaData.Custom> cursor : metaData.customs()) {_                                if (!RepositoriesMetaData.TYPE.equals(cursor.key)) {_                                    _                                    _                                    mdBuilder.putCustom(cursor.key, cursor.value)__                                }_                            }_                        }_                    }__                    if (completed(shards)) {_                        _                        restoreInfo = new RestoreInfo(snapshotId.getName(),_                                                      Collections.unmodifiableList(new ArrayList<>(indices.keySet())),_                                                      shards.size(),_                                                      shards.size() - failedShards(shards))__                    }__                    RoutingTable rt = rtBuilder.build()__                    ClusterState updatedState = builder.metaData(mdBuilder).blocks(blocks).routingTable(rt).build()__                    return allocationService.reroute(updatedState, "restored snapshot [" + snapshot + "]")__                }__                private void checkAliasNameConflicts(Map<String, String> renamedIndices, Set<String> aliases) {_                    for (Map.Entry<String, String> renamedIndex : renamedIndices.entrySet()) {_                        if (aliases.contains(renamedIndex.getKey())) {_                            throw new SnapshotRestoreException(snapshot,_                                "cannot rename index [" + renamedIndex.getValue() + "] into [" + renamedIndex.getKey() + "] because of " +_                                    "conflict with an alias with the same name")__                        }_                    }_                }__                private void populateIgnoredShards(String index, IntSet ignoreShards) {_                    for (SnapshotShardFailure failure : snapshotInfo.shardFailures()) {_                        if (index.equals(failure.index())) {_                            ignoreShards.add(failure.shardId())__                        }_                    }_                }__                private boolean checkPartial(String index) {_                    _                    if (failed(snapshotInfo, index)) {_                        if (request.partial()) {_                            return true__                        } else {_                            throw new SnapshotRestoreException(snapshot, "index [" + index + "] wasn't fully snapshotted - cannot " +_                                "restore")__                        }_                    } else {_                        return false__                    }_                }__                private void validateExistingIndex(IndexMetaData currentIndexMetaData, IndexMetaData snapshotIndexMetaData,_                                                   String renamedIndex, boolean partial) {_                    _                    if (currentIndexMetaData.getState() != IndexMetaData.State.CLOSE) {_                        _                        throw new SnapshotRestoreException(snapshot, "cannot restore index [" + renamedIndex + "] because an open index " +_                            "with same name already exists in the cluster. Either close or delete the existing index or restore the " +_                            "index under a different name by providing a rename pattern and replacement name")__                    }_                    _                    if (partial) {_                        throw new SnapshotRestoreException(snapshot, "cannot restore partial index [" + renamedIndex + "] because such " +_                            "index already exists")__                    }_                    _                    if (currentIndexMetaData.getNumberOfShards() != snapshotIndexMetaData.getNumberOfShards()) {_                        throw new SnapshotRestoreException(snapshot,_                            "cannot restore index [" + renamedIndex + "] with [" + currentIndexMetaData.getNumberOfShards() + "] shards " +_                                "from a snapshot of index [" + snapshotIndexMetaData.getIndex().getName() + "] with [" +_                                snapshotIndexMetaData.getNumberOfShards() + "] shards")__                    }_                }__                _                private IndexMetaData updateIndexSettings(IndexMetaData indexMetaData, Settings changeSettings, String[] ignoreSettings) {_                    if (changeSettings.names().isEmpty() && ignoreSettings.length == 0) {_                        return indexMetaData__                    }_                    Settings normalizedChangeSettings = Settings.builder()_                                                                .put(changeSettings)_                                                                .normalizePrefix(IndexMetaData.INDEX_SETTING_PREFIX)_                                                                .build()__                    IndexMetaData.Builder builder = IndexMetaData.builder(indexMetaData)__                    Settings settings = indexMetaData.getSettings()__                    Set<String> keyFilters = new HashSet<>()__                    List<String> simpleMatchPatterns = new ArrayList<>()__                    for (String ignoredSetting : ignoreSettings) {_                        if (!Regex.isSimpleMatchPattern(ignoredSetting)) {_                            if (UNREMOVABLE_SETTINGS.contains(ignoredSetting)) {_                                throw new SnapshotRestoreException(snapshot, "cannot remove setting [" + ignoredSetting + "] on restore")__                            } else {_                                keyFilters.add(ignoredSetting)__                            }_                        } else {_                            simpleMatchPatterns.add(ignoredSetting)__                        }_                    }_                    Predicate<String> settingsFilter = k -> {_                        if (UNREMOVABLE_SETTINGS.contains(k) == false) {_                            for (String filterKey : keyFilters) {_                                if (k.equals(filterKey)) {_                                    return false__                                }_                            }_                            for (String pattern : simpleMatchPatterns) {_                                if (Regex.simpleMatch(pattern, k)) {_                                    return false__                                }_                            }_                        }_                        return true__                    }__                    Settings.Builder settingsBuilder = Settings.builder()_                        .put(settings.filter(settingsFilter))_                        .put(normalizedChangeSettings.filter(k -> {_                            if (UNMODIFIABLE_SETTINGS.contains(k)) {_                                throw new SnapshotRestoreException(snapshot, "cannot modify setting [" + k + "] on restore")__                            } else {_                                return true__                            }_                        }))__                    return builder.settings(settingsBuilder).build()__                }__                @Override_                public void onFailure(String source, Exception e) {_                    logger.warn(() -> new ParameterizedMessage("[{}] failed to restore snapshot", snapshotId), e)__                    listener.onFailure(e)__                }__                @Override_                public TimeValue timeout() {_                    return request.masterNodeTimeout()__                }__                @Override_                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                    listener.onResponse(new RestoreCompletionResponse(restoreUUID, snapshot, restoreInfo))__                }_            })____        } catch (Exception e) {_            logger.warn(() -> new ParameterizedMessage("[{}] failed to restore snapshot",_                request.repositoryName + ":" + request.snapshotName), e)__            listener.onFailure(e)__        }_    };restores,snapshot,specified,in,the,restore,request,param,request,restore,request,param,listener,restore,listener;public,void,restore,snapshot,final,restore,request,request,final,action,listener,restore,completion,response,listener,try,repository,repository,repositories,service,repository,request,repository,name,final,repository,data,repository,data,repository,get,repository,data,final,optional,snapshot,id,incompatible,snapshot,id,repository,data,get,incompatible,snapshot,ids,stream,filter,s,request,snapshot,name,equals,s,get,name,find,first,if,incompatible,snapshot,id,is,present,throw,new,snapshot,restore,exception,request,repository,name,request,snapshot,name,cannot,restore,incompatible,snapshot,final,optional,snapshot,id,matching,snapshot,id,repository,data,get,snapshot,ids,stream,filter,s,request,snapshot,name,equals,s,get,name,find,first,if,matching,snapshot,id,is,present,false,throw,new,snapshot,restore,exception,request,repository,name,request,snapshot,name,snapshot,does,not,exist,final,snapshot,id,snapshot,id,matching,snapshot,id,get,final,snapshot,info,snapshot,info,repository,get,snapshot,info,snapshot,id,final,snapshot,snapshot,new,snapshot,request,repository,name,snapshot,id,validate,snapshot,restorable,request,repository,name,snapshot,info,final,list,string,indices,in,snapshot,filter,indices,snapshot,info,indices,request,indices,request,indices,options,final,meta,data,builder,meta,data,builder,if,request,include,global,state,meta,data,builder,meta,data,builder,repository,get,snapshot,global,meta,data,snapshot,id,else,meta,data,builder,meta,data,builder,final,list,index,id,index,ids,in,snapshot,repository,data,resolve,indices,indices,in,snapshot,for,index,id,index,id,index,ids,in,snapshot,meta,data,builder,put,repository,get,snapshot,index,meta,data,snapshot,id,index,id,false,final,meta,data,meta,data,meta,data,builder,build,final,map,string,string,indices,renamed,indices,request,indices,in,snapshot,cluster,service,submit,state,update,task,request,cause,new,cluster,state,update,task,string,restore,uuid,uuids,random,base64uuid,restore,info,restore,info,null,override,public,cluster,state,execute,cluster,state,current,state,restore,in,progress,restore,in,progress,current,state,custom,restore,in,progress,type,if,current,state,get,nodes,get,min,node,version,before,version,if,restore,in,progress,null,restore,in,progress,is,empty,false,throw,new,concurrent,snapshot,execution,exception,snapshot,restore,process,is,already,running,in,this,cluster,snapshot,deletions,in,progress,deletions,in,progress,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,throw,new,concurrent,snapshot,execution,exception,snapshot,cannot,restore,a,snapshot,while,a,snapshot,deletion,is,in,progress,deletions,in,progress,get,entries,get,0,get,snapshot,cluster,state,builder,builder,cluster,state,builder,current,state,meta,data,builder,md,builder,meta,data,builder,current,state,meta,data,cluster,blocks,builder,blocks,cluster,blocks,builder,blocks,current,state,blocks,routing,table,builder,rt,builder,routing,table,builder,current,state,routing,table,immutable,open,map,shard,id,restore,in,progress,shard,restore,status,shards,set,string,aliases,new,hash,set,if,indices,is,empty,false,immutable,open,map,builder,shard,id,restore,in,progress,shard,restore,status,shards,builder,immutable,open,map,builder,final,version,min,index,compatibility,version,current,state,get,nodes,get,max,node,version,minimum,index,compatibility,version,for,map,entry,string,string,index,entry,indices,entry,set,string,index,index,entry,get,value,boolean,partial,check,partial,index,snapshot,recovery,source,recovery,source,new,snapshot,recovery,source,restore,uuid,snapshot,snapshot,info,version,index,string,renamed,index,name,index,entry,get,key,index,meta,data,snapshot,index,meta,data,meta,data,index,index,snapshot,index,meta,data,update,index,settings,snapshot,index,meta,data,request,index,settings,request,ignore,index,settings,try,snapshot,index,meta,data,meta,data,index,upgrade,service,upgrade,index,meta,data,snapshot,index,meta,data,min,index,compatibility,version,catch,exception,ex,throw,new,snapshot,restore,exception,snapshot,cannot,restore,index,index,because,it,cannot,be,upgraded,ex,index,meta,data,current,index,meta,data,current,state,meta,data,index,renamed,index,name,int,set,ignore,shards,new,int,hash,set,final,index,renamed,index,if,current,index,meta,data,null,meta,data,create,index,service,validate,index,name,renamed,index,name,current,state,create,index,service,validate,index,settings,renamed,index,name,snapshot,index,meta,data,get,settings,current,state,false,index,meta,data,builder,index,md,builder,index,meta,data,builder,snapshot,index,meta,data,state,index,meta,data,state,open,index,renamed,index,name,index,md,builder,settings,settings,builder,put,snapshot,index,meta,data,get,settings,put,index,meta,data,uuids,random,base64uuid,if,request,include,aliases,snapshot,index,meta,data,get,aliases,is,empty,index,md,builder,remove,all,aliases,else,for,object,cursor,string,alias,snapshot,index,meta,data,get,aliases,keys,aliases,add,alias,value,index,meta,data,updated,index,meta,data,index,md,builder,build,if,partial,populate,ignored,shards,index,ignore,shards,rt,builder,add,as,new,restore,updated,index,meta,data,recovery,source,ignore,shards,blocks,add,blocks,updated,index,meta,data,md,builder,put,updated,index,meta,data,true,renamed,index,updated,index,meta,data,get,index,else,validate,existing,index,current,index,meta,data,snapshot,index,meta,data,renamed,index,name,partial,index,meta,data,builder,index,md,builder,index,meta,data,builder,snapshot,index,meta,data,state,index,meta,data,state,open,index,md,builder,version,math,max,snapshot,index,meta,data,get,version,current,index,meta,data,get,version,1,index,md,builder,mapping,version,math,max,snapshot,index,meta,data,get,mapping,version,current,index,meta,data,get,mapping,version,1,index,md,builder,settings,version,math,max,snapshot,index,meta,data,get,settings,version,current,index,meta,data,get,settings,version,1,if,request,include,aliases,if,snapshot,index,meta,data,get,aliases,is,empty,index,md,builder,remove,all,aliases,for,object,cursor,alias,meta,data,alias,current,index,meta,data,get,aliases,values,index,md,builder,put,alias,alias,value,else,for,object,cursor,string,alias,snapshot,index,meta,data,get,aliases,keys,aliases,add,alias,value,index,md,builder,settings,settings,builder,put,snapshot,index,meta,data,get,settings,put,index,meta,data,current,index,meta,data,get,index,uuid,index,meta,data,updated,index,meta,data,index,md,builder,index,renamed,index,name,build,rt,builder,add,as,restore,updated,index,meta,data,recovery,source,blocks,update,blocks,updated,index,meta,data,md,builder,put,updated,index,meta,data,true,renamed,index,updated,index,meta,data,get,index,for,int,shard,0,shard,snapshot,index,meta,data,get,number,of,shards,shard,if,ignore,shards,contains,shard,shards,builder,put,new,shard,id,renamed,index,shard,new,restore,in,progress,shard,restore,status,cluster,service,state,nodes,get,local,node,id,else,shards,builder,put,new,shard,id,renamed,index,shard,new,restore,in,progress,shard,restore,status,cluster,service,state,nodes,get,local,node,id,restore,in,progress,state,failure,shards,shards,builder,build,restore,in,progress,entry,restore,entry,new,restore,in,progress,entry,restore,uuid,snapshot,overall,state,restore,in,progress,state,init,shards,collections,unmodifiable,list,new,array,list,indices,key,set,shards,restore,in,progress,builder,restore,in,progress,builder,if,restore,in,progress,null,restore,in,progress,builder,new,restore,in,progress,builder,restore,in,progress,else,restore,in,progress,builder,new,restore,in,progress,builder,builder,put,custom,restore,in,progress,type,restore,in,progress,builder,add,restore,entry,build,else,shards,immutable,open,map,of,check,alias,name,conflicts,indices,aliases,if,request,include,global,state,if,meta,data,persistent,settings,null,settings,settings,meta,data,persistent,settings,cluster,settings,validate,update,settings,md,builder,persistent,settings,settings,if,meta,data,templates,null,for,object,cursor,index,template,meta,data,cursor,meta,data,templates,values,md,builder,put,cursor,value,if,meta,data,customs,null,for,object,object,cursor,string,meta,data,custom,cursor,meta,data,customs,if,repositories,meta,data,type,equals,cursor,key,md,builder,put,custom,cursor,key,cursor,value,if,completed,shards,restore,info,new,restore,info,snapshot,id,get,name,collections,unmodifiable,list,new,array,list,indices,key,set,shards,size,shards,size,failed,shards,shards,routing,table,rt,rt,builder,build,cluster,state,updated,state,builder,meta,data,md,builder,blocks,blocks,routing,table,rt,build,return,allocation,service,reroute,updated,state,restored,snapshot,snapshot,private,void,check,alias,name,conflicts,map,string,string,renamed,indices,set,string,aliases,for,map,entry,string,string,renamed,index,renamed,indices,entry,set,if,aliases,contains,renamed,index,get,key,throw,new,snapshot,restore,exception,snapshot,cannot,rename,index,renamed,index,get,value,into,renamed,index,get,key,because,of,conflict,with,an,alias,with,the,same,name,private,void,populate,ignored,shards,string,index,int,set,ignore,shards,for,snapshot,shard,failure,failure,snapshot,info,shard,failures,if,index,equals,failure,index,ignore,shards,add,failure,shard,id,private,boolean,check,partial,string,index,if,failed,snapshot,info,index,if,request,partial,return,true,else,throw,new,snapshot,restore,exception,snapshot,index,index,wasn,t,fully,snapshotted,cannot,restore,else,return,false,private,void,validate,existing,index,index,meta,data,current,index,meta,data,index,meta,data,snapshot,index,meta,data,string,renamed,index,boolean,partial,if,current,index,meta,data,get,state,index,meta,data,state,close,throw,new,snapshot,restore,exception,snapshot,cannot,restore,index,renamed,index,because,an,open,index,with,same,name,already,exists,in,the,cluster,either,close,or,delete,the,existing,index,or,restore,the,index,under,a,different,name,by,providing,a,rename,pattern,and,replacement,name,if,partial,throw,new,snapshot,restore,exception,snapshot,cannot,restore,partial,index,renamed,index,because,such,index,already,exists,if,current,index,meta,data,get,number,of,shards,snapshot,index,meta,data,get,number,of,shards,throw,new,snapshot,restore,exception,snapshot,cannot,restore,index,renamed,index,with,current,index,meta,data,get,number,of,shards,shards,from,a,snapshot,of,index,snapshot,index,meta,data,get,index,get,name,with,snapshot,index,meta,data,get,number,of,shards,shards,private,index,meta,data,update,index,settings,index,meta,data,index,meta,data,settings,change,settings,string,ignore,settings,if,change,settings,names,is,empty,ignore,settings,length,0,return,index,meta,data,settings,normalized,change,settings,settings,builder,put,change,settings,normalize,prefix,index,meta,data,build,index,meta,data,builder,builder,index,meta,data,builder,index,meta,data,settings,settings,index,meta,data,get,settings,set,string,key,filters,new,hash,set,list,string,simple,match,patterns,new,array,list,for,string,ignored,setting,ignore,settings,if,regex,is,simple,match,pattern,ignored,setting,if,contains,ignored,setting,throw,new,snapshot,restore,exception,snapshot,cannot,remove,setting,ignored,setting,on,restore,else,key,filters,add,ignored,setting,else,simple,match,patterns,add,ignored,setting,predicate,string,settings,filter,k,if,contains,k,false,for,string,filter,key,key,filters,if,k,equals,filter,key,return,false,for,string,pattern,simple,match,patterns,if,regex,simple,match,pattern,k,return,false,return,true,settings,builder,settings,builder,settings,builder,put,settings,filter,settings,filter,put,normalized,change,settings,filter,k,if,contains,k,throw,new,snapshot,restore,exception,snapshot,cannot,modify,setting,k,on,restore,else,return,true,return,builder,settings,settings,builder,build,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,restore,snapshot,snapshot,id,e,listener,on,failure,e,override,public,time,value,timeout,return,request,master,node,timeout,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,listener,on,response,new,restore,completion,response,restore,uuid,snapshot,restore,info,catch,exception,e,logger,warn,new,parameterized,message,failed,to,restore,snapshot,request,repository,name,request,snapshot,name,e,listener,on,failure,e
RestoreService -> RestoreRequest -> public String snapshotName();1524684173;Returns snapshot name__@return snapshot name;public String snapshotName() {_            return snapshotName__        };returns,snapshot,name,return,snapshot,name;public,string,snapshot,name,return,snapshot,name
RestoreService -> RestoreRequest -> public String snapshotName();1525248068;Returns snapshot name__@return snapshot name;public String snapshotName() {_            return snapshotName__        };returns,snapshot,name,return,snapshot,name;public,string,snapshot,name,return,snapshot,name
RestoreService -> RestoreRequest -> public String snapshotName();1535405719;Returns snapshot name__@return snapshot name;public String snapshotName() {_            return snapshotName__        };returns,snapshot,name,return,snapshot,name;public,string,snapshot,name,return,snapshot,name
RestoreService -> RestoreRequest -> public String snapshotName();1535723122;Returns snapshot name__@return snapshot name;public String snapshotName() {_            return snapshotName__        };returns,snapshot,name,return,snapshot,name;public,string,snapshot,name,return,snapshot,name
RestoreService -> RestoreRequest -> public String snapshotName();1536137328;Returns snapshot name__@return snapshot name;public String snapshotName() {_            return snapshotName__        };returns,snapshot,name,return,snapshot,name;public,string,snapshot,name,return,snapshot,name
RestoreService -> RestoreRequest -> public String snapshotName();1539723533;Returns snapshot name__@return snapshot name;public String snapshotName() {_            return snapshotName__        };returns,snapshot,name,return,snapshot,name;public,string,snapshot,name,return,snapshot,name
RestoreService -> RestoreRequest -> public String snapshotName();1540486836;Returns snapshot name__@return snapshot name;public String snapshotName() {_            return snapshotName__        };returns,snapshot,name,return,snapshot,name;public,string,snapshot,name,return,snapshot,name
RestoreService -> RestoreRequest -> public String snapshotName();1541092382;Returns snapshot name__@return snapshot name;public String snapshotName() {_            return snapshotName__        };returns,snapshot,name,return,snapshot,name;public,string,snapshot,name,return,snapshot,name
RestoreService -> RestoreRequest -> public String snapshotName();1542402632;Returns snapshot name__@return snapshot name;public String snapshotName() {_            return snapshotName__        };returns,snapshot,name,return,snapshot,name;public,string,snapshot,name,return,snapshot,name
RestoreService -> RestoreRequest -> public String snapshotName();1544783963;Returns snapshot name__@return snapshot name;public String snapshotName() {_            return snapshotName__        };returns,snapshot,name,return,snapshot,name;public,string,snapshot,name,return,snapshot,name
RestoreService -> RestoreRequest -> public String snapshotName();1545215361;Returns snapshot name__@return snapshot name;public String snapshotName() {_            return snapshotName__        };returns,snapshot,name,return,snapshot,name;public,string,snapshot,name,return,snapshot,name
RestoreService -> RestoreRequest -> public String renameReplacement();1524684173;Returns replacement pattern__@return replacement pattern;public String renameReplacement() {_            return renameReplacement__        };returns,replacement,pattern,return,replacement,pattern;public,string,rename,replacement,return,rename,replacement
RestoreService -> RestoreRequest -> public String renameReplacement();1525248068;Returns replacement pattern__@return replacement pattern;public String renameReplacement() {_            return renameReplacement__        };returns,replacement,pattern,return,replacement,pattern;public,string,rename,replacement,return,rename,replacement
RestoreService -> RestoreRequest -> public String renameReplacement();1535405719;Returns replacement pattern__@return replacement pattern;public String renameReplacement() {_            return renameReplacement__        };returns,replacement,pattern,return,replacement,pattern;public,string,rename,replacement,return,rename,replacement
RestoreService -> RestoreRequest -> public String renameReplacement();1535723122;Returns replacement pattern__@return replacement pattern;public String renameReplacement() {_            return renameReplacement__        };returns,replacement,pattern,return,replacement,pattern;public,string,rename,replacement,return,rename,replacement
RestoreService -> RestoreRequest -> public String renameReplacement();1536137328;Returns replacement pattern__@return replacement pattern;public String renameReplacement() {_            return renameReplacement__        };returns,replacement,pattern,return,replacement,pattern;public,string,rename,replacement,return,rename,replacement
RestoreService -> RestoreRequest -> public String renameReplacement();1539723533;Returns replacement pattern__@return replacement pattern;public String renameReplacement() {_            return renameReplacement__        };returns,replacement,pattern,return,replacement,pattern;public,string,rename,replacement,return,rename,replacement
RestoreService -> RestoreRequest -> public String renameReplacement();1540486836;Returns replacement pattern__@return replacement pattern;public String renameReplacement() {_            return renameReplacement__        };returns,replacement,pattern,return,replacement,pattern;public,string,rename,replacement,return,rename,replacement
RestoreService -> RestoreRequest -> public String renameReplacement();1541092382;Returns replacement pattern__@return replacement pattern;public String renameReplacement() {_            return renameReplacement__        };returns,replacement,pattern,return,replacement,pattern;public,string,rename,replacement,return,rename,replacement
RestoreService -> RestoreRequest -> public String renameReplacement();1542402632;Returns replacement pattern__@return replacement pattern;public String renameReplacement() {_            return renameReplacement__        };returns,replacement,pattern,return,replacement,pattern;public,string,rename,replacement,return,rename,replacement
RestoreService -> RestoreRequest -> public String renameReplacement();1544783963;Returns replacement pattern__@return replacement pattern;public String renameReplacement() {_            return renameReplacement__        };returns,replacement,pattern,return,replacement,pattern;public,string,rename,replacement,return,rename,replacement
RestoreService -> RestoreRequest -> public String renameReplacement();1545215361;Returns replacement pattern__@return replacement pattern;public String renameReplacement() {_            return renameReplacement__        };returns,replacement,pattern,return,replacement,pattern;public,string,rename,replacement,return,rename,replacement
RestoreService -> RestoreRequest -> public boolean includeAliases();1524684173;Returns true if aliases should be restore during this restore operation__@return restore aliases state flag;public boolean includeAliases() {_            return includeAliases__        };returns,true,if,aliases,should,be,restore,during,this,restore,operation,return,restore,aliases,state,flag;public,boolean,include,aliases,return,include,aliases
RestoreService -> RestoreRequest -> public boolean includeAliases();1525248068;Returns true if aliases should be restore during this restore operation__@return restore aliases state flag;public boolean includeAliases() {_            return includeAliases__        };returns,true,if,aliases,should,be,restore,during,this,restore,operation,return,restore,aliases,state,flag;public,boolean,include,aliases,return,include,aliases
RestoreService -> RestoreRequest -> public boolean includeAliases();1535405719;Returns true if aliases should be restore during this restore operation__@return restore aliases state flag;public boolean includeAliases() {_            return includeAliases__        };returns,true,if,aliases,should,be,restore,during,this,restore,operation,return,restore,aliases,state,flag;public,boolean,include,aliases,return,include,aliases
RestoreService -> RestoreRequest -> public boolean includeAliases();1535723122;Returns true if aliases should be restore during this restore operation__@return restore aliases state flag;public boolean includeAliases() {_            return includeAliases__        };returns,true,if,aliases,should,be,restore,during,this,restore,operation,return,restore,aliases,state,flag;public,boolean,include,aliases,return,include,aliases
RestoreService -> RestoreRequest -> public boolean includeAliases();1536137328;Returns true if aliases should be restore during this restore operation__@return restore aliases state flag;public boolean includeAliases() {_            return includeAliases__        };returns,true,if,aliases,should,be,restore,during,this,restore,operation,return,restore,aliases,state,flag;public,boolean,include,aliases,return,include,aliases
RestoreService -> RestoreRequest -> public boolean includeAliases();1539723533;Returns true if aliases should be restore during this restore operation__@return restore aliases state flag;public boolean includeAliases() {_            return includeAliases__        };returns,true,if,aliases,should,be,restore,during,this,restore,operation,return,restore,aliases,state,flag;public,boolean,include,aliases,return,include,aliases
RestoreService -> RestoreRequest -> public boolean includeAliases();1540486836;Returns true if aliases should be restore during this restore operation__@return restore aliases state flag;public boolean includeAliases() {_            return includeAliases__        };returns,true,if,aliases,should,be,restore,during,this,restore,operation,return,restore,aliases,state,flag;public,boolean,include,aliases,return,include,aliases
RestoreService -> RestoreRequest -> public boolean includeAliases();1541092382;Returns true if aliases should be restore during this restore operation__@return restore aliases state flag;public boolean includeAliases() {_            return includeAliases__        };returns,true,if,aliases,should,be,restore,during,this,restore,operation,return,restore,aliases,state,flag;public,boolean,include,aliases,return,include,aliases
RestoreService -> RestoreRequest -> public boolean includeAliases();1542402632;Returns true if aliases should be restore during this restore operation__@return restore aliases state flag;public boolean includeAliases() {_            return includeAliases__        };returns,true,if,aliases,should,be,restore,during,this,restore,operation,return,restore,aliases,state,flag;public,boolean,include,aliases,return,include,aliases
RestoreService -> RestoreRequest -> public boolean includeAliases();1544783963;Returns true if aliases should be restore during this restore operation__@return restore aliases state flag;public boolean includeAliases() {_            return includeAliases__        };returns,true,if,aliases,should,be,restore,during,this,restore,operation,return,restore,aliases,state,flag;public,boolean,include,aliases,return,include,aliases
RestoreService -> RestoreRequest -> public boolean includeAliases();1545215361;Returns true if aliases should be restore during this restore operation__@return restore aliases state flag;public boolean includeAliases() {_            return includeAliases__        };returns,true,if,aliases,should,be,restore,during,this,restore,operation,return,restore,aliases,state,flag;public,boolean,include,aliases,return,include,aliases
RestoreService -> RestoreRequest -> public String[] ignoreIndexSettings();1524684173;Returns index settings that that shouldn't be restored__@return restore aliases state flag;public String[] ignoreIndexSettings() {_            return ignoreIndexSettings__        };returns,index,settings,that,that,shouldn,t,be,restored,return,restore,aliases,state,flag;public,string,ignore,index,settings,return,ignore,index,settings
RestoreService -> RestoreRequest -> public String[] ignoreIndexSettings();1525248068;Returns index settings that that shouldn't be restored__@return restore aliases state flag;public String[] ignoreIndexSettings() {_            return ignoreIndexSettings__        };returns,index,settings,that,that,shouldn,t,be,restored,return,restore,aliases,state,flag;public,string,ignore,index,settings,return,ignore,index,settings
RestoreService -> RestoreRequest -> public String[] ignoreIndexSettings();1535405719;Returns index settings that that shouldn't be restored__@return restore aliases state flag;public String[] ignoreIndexSettings() {_            return ignoreIndexSettings__        };returns,index,settings,that,that,shouldn,t,be,restored,return,restore,aliases,state,flag;public,string,ignore,index,settings,return,ignore,index,settings
RestoreService -> RestoreRequest -> public String[] ignoreIndexSettings();1535723122;Returns index settings that that shouldn't be restored__@return restore aliases state flag;public String[] ignoreIndexSettings() {_            return ignoreIndexSettings__        };returns,index,settings,that,that,shouldn,t,be,restored,return,restore,aliases,state,flag;public,string,ignore,index,settings,return,ignore,index,settings
RestoreService -> RestoreRequest -> public String[] ignoreIndexSettings();1536137328;Returns index settings that that shouldn't be restored__@return restore aliases state flag;public String[] ignoreIndexSettings() {_            return ignoreIndexSettings__        };returns,index,settings,that,that,shouldn,t,be,restored,return,restore,aliases,state,flag;public,string,ignore,index,settings,return,ignore,index,settings
RestoreService -> RestoreRequest -> public String[] ignoreIndexSettings();1539723533;Returns index settings that that shouldn't be restored__@return restore aliases state flag;public String[] ignoreIndexSettings() {_            return ignoreIndexSettings__        };returns,index,settings,that,that,shouldn,t,be,restored,return,restore,aliases,state,flag;public,string,ignore,index,settings,return,ignore,index,settings
RestoreService -> RestoreRequest -> public String[] ignoreIndexSettings();1540486836;Returns index settings that that shouldn't be restored__@return restore aliases state flag;public String[] ignoreIndexSettings() {_            return ignoreIndexSettings__        };returns,index,settings,that,that,shouldn,t,be,restored,return,restore,aliases,state,flag;public,string,ignore,index,settings,return,ignore,index,settings
RestoreService -> RestoreRequest -> public String[] ignoreIndexSettings();1541092382;Returns index settings that that shouldn't be restored__@return restore aliases state flag;public String[] ignoreIndexSettings() {_            return ignoreIndexSettings__        };returns,index,settings,that,that,shouldn,t,be,restored,return,restore,aliases,state,flag;public,string,ignore,index,settings,return,ignore,index,settings
RestoreService -> RestoreRequest -> public String[] ignoreIndexSettings();1542402632;Returns index settings that that shouldn't be restored__@return restore aliases state flag;public String[] ignoreIndexSettings() {_            return ignoreIndexSettings__        };returns,index,settings,that,that,shouldn,t,be,restored,return,restore,aliases,state,flag;public,string,ignore,index,settings,return,ignore,index,settings
RestoreService -> RestoreRequest -> public String[] ignoreIndexSettings();1544783963;Returns index settings that that shouldn't be restored__@return restore aliases state flag;public String[] ignoreIndexSettings() {_            return ignoreIndexSettings__        };returns,index,settings,that,that,shouldn,t,be,restored,return,restore,aliases,state,flag;public,string,ignore,index,settings,return,ignore,index,settings
RestoreService -> RestoreRequest -> public String[] ignoreIndexSettings();1545215361;Returns index settings that that shouldn't be restored__@return restore aliases state flag;public String[] ignoreIndexSettings() {_            return ignoreIndexSettings__        };returns,index,settings,that,that,shouldn,t,be,restored,return,restore,aliases,state,flag;public,string,ignore,index,settings,return,ignore,index,settings
RestoreService -> RestoreRequest -> public String renamePattern();1524684173;Returns rename pattern__@return rename pattern;public String renamePattern() {_            return renamePattern__        };returns,rename,pattern,return,rename,pattern;public,string,rename,pattern,return,rename,pattern
RestoreService -> RestoreRequest -> public String renamePattern();1525248068;Returns rename pattern__@return rename pattern;public String renamePattern() {_            return renamePattern__        };returns,rename,pattern,return,rename,pattern;public,string,rename,pattern,return,rename,pattern
RestoreService -> RestoreRequest -> public String renamePattern();1535405719;Returns rename pattern__@return rename pattern;public String renamePattern() {_            return renamePattern__        };returns,rename,pattern,return,rename,pattern;public,string,rename,pattern,return,rename,pattern
RestoreService -> RestoreRequest -> public String renamePattern();1535723122;Returns rename pattern__@return rename pattern;public String renamePattern() {_            return renamePattern__        };returns,rename,pattern,return,rename,pattern;public,string,rename,pattern,return,rename,pattern
RestoreService -> RestoreRequest -> public String renamePattern();1536137328;Returns rename pattern__@return rename pattern;public String renamePattern() {_            return renamePattern__        };returns,rename,pattern,return,rename,pattern;public,string,rename,pattern,return,rename,pattern
RestoreService -> RestoreRequest -> public String renamePattern();1539723533;Returns rename pattern__@return rename pattern;public String renamePattern() {_            return renamePattern__        };returns,rename,pattern,return,rename,pattern;public,string,rename,pattern,return,rename,pattern
RestoreService -> RestoreRequest -> public String renamePattern();1540486836;Returns rename pattern__@return rename pattern;public String renamePattern() {_            return renamePattern__        };returns,rename,pattern,return,rename,pattern;public,string,rename,pattern,return,rename,pattern
RestoreService -> RestoreRequest -> public String renamePattern();1541092382;Returns rename pattern__@return rename pattern;public String renamePattern() {_            return renamePattern__        };returns,rename,pattern,return,rename,pattern;public,string,rename,pattern,return,rename,pattern
RestoreService -> RestoreRequest -> public String renamePattern();1542402632;Returns rename pattern__@return rename pattern;public String renamePattern() {_            return renamePattern__        };returns,rename,pattern,return,rename,pattern;public,string,rename,pattern,return,rename,pattern
RestoreService -> RestoreRequest -> public String renamePattern();1544783963;Returns rename pattern__@return rename pattern;public String renamePattern() {_            return renamePattern__        };returns,rename,pattern,return,rename,pattern;public,string,rename,pattern,return,rename,pattern
RestoreService -> RestoreRequest -> public String renamePattern();1545215361;Returns rename pattern__@return rename pattern;public String renamePattern() {_            return renamePattern__        };returns,rename,pattern,return,rename,pattern;public,string,rename,pattern,return,rename,pattern
RestoreService -> RestoreRequest -> public Settings indexSettings();1524684173;Returns index settings that should be changed on restore__@return restore aliases state flag;public Settings indexSettings() {_            return indexSettings__        };returns,index,settings,that,should,be,changed,on,restore,return,restore,aliases,state,flag;public,settings,index,settings,return,index,settings
RestoreService -> RestoreRequest -> public Settings indexSettings();1525248068;Returns index settings that should be changed on restore__@return restore aliases state flag;public Settings indexSettings() {_            return indexSettings__        };returns,index,settings,that,should,be,changed,on,restore,return,restore,aliases,state,flag;public,settings,index,settings,return,index,settings
RestoreService -> RestoreRequest -> public Settings indexSettings();1535405719;Returns index settings that should be changed on restore__@return restore aliases state flag;public Settings indexSettings() {_            return indexSettings__        };returns,index,settings,that,should,be,changed,on,restore,return,restore,aliases,state,flag;public,settings,index,settings,return,index,settings
RestoreService -> RestoreRequest -> public Settings indexSettings();1535723122;Returns index settings that should be changed on restore__@return restore aliases state flag;public Settings indexSettings() {_            return indexSettings__        };returns,index,settings,that,should,be,changed,on,restore,return,restore,aliases,state,flag;public,settings,index,settings,return,index,settings
RestoreService -> RestoreRequest -> public Settings indexSettings();1536137328;Returns index settings that should be changed on restore__@return restore aliases state flag;public Settings indexSettings() {_            return indexSettings__        };returns,index,settings,that,should,be,changed,on,restore,return,restore,aliases,state,flag;public,settings,index,settings,return,index,settings
RestoreService -> RestoreRequest -> public Settings indexSettings();1539723533;Returns index settings that should be changed on restore__@return restore aliases state flag;public Settings indexSettings() {_            return indexSettings__        };returns,index,settings,that,should,be,changed,on,restore,return,restore,aliases,state,flag;public,settings,index,settings,return,index,settings
RestoreService -> RestoreRequest -> public Settings indexSettings();1540486836;Returns index settings that should be changed on restore__@return restore aliases state flag;public Settings indexSettings() {_            return indexSettings__        };returns,index,settings,that,should,be,changed,on,restore,return,restore,aliases,state,flag;public,settings,index,settings,return,index,settings
RestoreService -> RestoreRequest -> public Settings indexSettings();1541092382;Returns index settings that should be changed on restore__@return restore aliases state flag;public Settings indexSettings() {_            return indexSettings__        };returns,index,settings,that,should,be,changed,on,restore,return,restore,aliases,state,flag;public,settings,index,settings,return,index,settings
RestoreService -> RestoreRequest -> public Settings indexSettings();1542402632;Returns index settings that should be changed on restore__@return restore aliases state flag;public Settings indexSettings() {_            return indexSettings__        };returns,index,settings,that,should,be,changed,on,restore,return,restore,aliases,state,flag;public,settings,index,settings,return,index,settings
RestoreService -> RestoreRequest -> public Settings indexSettings();1544783963;Returns index settings that should be changed on restore__@return restore aliases state flag;public Settings indexSettings() {_            return indexSettings__        };returns,index,settings,that,should,be,changed,on,restore,return,restore,aliases,state,flag;public,settings,index,settings,return,index,settings
RestoreService -> RestoreRequest -> public Settings indexSettings();1545215361;Returns index settings that should be changed on restore__@return restore aliases state flag;public Settings indexSettings() {_            return indexSettings__        };returns,index,settings,that,should,be,changed,on,restore,return,restore,aliases,state,flag;public,settings,index,settings,return,index,settings
RestoreService -> public static boolean isRepositoryInUse(ClusterState clusterState, String repository);1524684173;Checks if a repository is currently in use by one of the snapshots__@param clusterState cluster state_@param repository   repository id_@return true if repository is currently in use by one of the running snapshots;public static boolean isRepositoryInUse(ClusterState clusterState, String repository) {_        RestoreInProgress snapshots = clusterState.custom(RestoreInProgress.TYPE)__        if (snapshots != null) {_            for (RestoreInProgress.Entry snapshot : snapshots.entries()) {_                if (repository.equals(snapshot.snapshot().getRepository())) {_                    return true__                }_            }_        }_        return false__    };checks,if,a,repository,is,currently,in,use,by,one,of,the,snapshots,param,cluster,state,cluster,state,param,repository,repository,id,return,true,if,repository,is,currently,in,use,by,one,of,the,running,snapshots;public,static,boolean,is,repository,in,use,cluster,state,cluster,state,string,repository,restore,in,progress,snapshots,cluster,state,custom,restore,in,progress,type,if,snapshots,null,for,restore,in,progress,entry,snapshot,snapshots,entries,if,repository,equals,snapshot,snapshot,get,repository,return,true,return,false
RestoreService -> public static boolean isRepositoryInUse(ClusterState clusterState, String repository);1525248068;Checks if a repository is currently in use by one of the snapshots__@param clusterState cluster state_@param repository   repository id_@return true if repository is currently in use by one of the running snapshots;public static boolean isRepositoryInUse(ClusterState clusterState, String repository) {_        RestoreInProgress snapshots = clusterState.custom(RestoreInProgress.TYPE)__        if (snapshots != null) {_            for (RestoreInProgress.Entry snapshot : snapshots.entries()) {_                if (repository.equals(snapshot.snapshot().getRepository())) {_                    return true__                }_            }_        }_        return false__    };checks,if,a,repository,is,currently,in,use,by,one,of,the,snapshots,param,cluster,state,cluster,state,param,repository,repository,id,return,true,if,repository,is,currently,in,use,by,one,of,the,running,snapshots;public,static,boolean,is,repository,in,use,cluster,state,cluster,state,string,repository,restore,in,progress,snapshots,cluster,state,custom,restore,in,progress,type,if,snapshots,null,for,restore,in,progress,entry,snapshot,snapshots,entries,if,repository,equals,snapshot,snapshot,get,repository,return,true,return,false
RestoreService -> public static boolean isRepositoryInUse(ClusterState clusterState, String repository);1535405719;Checks if a repository is currently in use by one of the snapshots__@param clusterState cluster state_@param repository   repository id_@return true if repository is currently in use by one of the running snapshots;public static boolean isRepositoryInUse(ClusterState clusterState, String repository) {_        RestoreInProgress snapshots = clusterState.custom(RestoreInProgress.TYPE)__        if (snapshots != null) {_            for (RestoreInProgress.Entry snapshot : snapshots.entries()) {_                if (repository.equals(snapshot.snapshot().getRepository())) {_                    return true__                }_            }_        }_        return false__    };checks,if,a,repository,is,currently,in,use,by,one,of,the,snapshots,param,cluster,state,cluster,state,param,repository,repository,id,return,true,if,repository,is,currently,in,use,by,one,of,the,running,snapshots;public,static,boolean,is,repository,in,use,cluster,state,cluster,state,string,repository,restore,in,progress,snapshots,cluster,state,custom,restore,in,progress,type,if,snapshots,null,for,restore,in,progress,entry,snapshot,snapshots,entries,if,repository,equals,snapshot,snapshot,get,repository,return,true,return,false
RestoreService -> public static boolean isRepositoryInUse(ClusterState clusterState, String repository);1535723122;Checks if a repository is currently in use by one of the snapshots__@param clusterState cluster state_@param repository   repository id_@return true if repository is currently in use by one of the running snapshots;public static boolean isRepositoryInUse(ClusterState clusterState, String repository) {_        RestoreInProgress snapshots = clusterState.custom(RestoreInProgress.TYPE)__        if (snapshots != null) {_            for (RestoreInProgress.Entry snapshot : snapshots.entries()) {_                if (repository.equals(snapshot.snapshot().getRepository())) {_                    return true__                }_            }_        }_        return false__    };checks,if,a,repository,is,currently,in,use,by,one,of,the,snapshots,param,cluster,state,cluster,state,param,repository,repository,id,return,true,if,repository,is,currently,in,use,by,one,of,the,running,snapshots;public,static,boolean,is,repository,in,use,cluster,state,cluster,state,string,repository,restore,in,progress,snapshots,cluster,state,custom,restore,in,progress,type,if,snapshots,null,for,restore,in,progress,entry,snapshot,snapshots,entries,if,repository,equals,snapshot,snapshot,get,repository,return,true,return,false
RestoreService -> public static boolean isRepositoryInUse(ClusterState clusterState, String repository);1536137328;Checks if a repository is currently in use by one of the snapshots__@param clusterState cluster state_@param repository   repository id_@return true if repository is currently in use by one of the running snapshots;public static boolean isRepositoryInUse(ClusterState clusterState, String repository) {_        RestoreInProgress snapshots = clusterState.custom(RestoreInProgress.TYPE)__        if (snapshots != null) {_            for (RestoreInProgress.Entry snapshot : snapshots.entries()) {_                if (repository.equals(snapshot.snapshot().getRepository())) {_                    return true__                }_            }_        }_        return false__    };checks,if,a,repository,is,currently,in,use,by,one,of,the,snapshots,param,cluster,state,cluster,state,param,repository,repository,id,return,true,if,repository,is,currently,in,use,by,one,of,the,running,snapshots;public,static,boolean,is,repository,in,use,cluster,state,cluster,state,string,repository,restore,in,progress,snapshots,cluster,state,custom,restore,in,progress,type,if,snapshots,null,for,restore,in,progress,entry,snapshot,snapshots,entries,if,repository,equals,snapshot,snapshot,get,repository,return,true,return,false
RestoreService -> public static boolean isRepositoryInUse(ClusterState clusterState, String repository);1539723533;Checks if a repository is currently in use by one of the snapshots__@param clusterState cluster state_@param repository   repository id_@return true if repository is currently in use by one of the running snapshots;public static boolean isRepositoryInUse(ClusterState clusterState, String repository) {_        RestoreInProgress snapshots = clusterState.custom(RestoreInProgress.TYPE)__        if (snapshots != null) {_            for (RestoreInProgress.Entry snapshot : snapshots.entries()) {_                if (repository.equals(snapshot.snapshot().getRepository())) {_                    return true__                }_            }_        }_        return false__    };checks,if,a,repository,is,currently,in,use,by,one,of,the,snapshots,param,cluster,state,cluster,state,param,repository,repository,id,return,true,if,repository,is,currently,in,use,by,one,of,the,running,snapshots;public,static,boolean,is,repository,in,use,cluster,state,cluster,state,string,repository,restore,in,progress,snapshots,cluster,state,custom,restore,in,progress,type,if,snapshots,null,for,restore,in,progress,entry,snapshot,snapshots,entries,if,repository,equals,snapshot,snapshot,get,repository,return,true,return,false
RestoreService -> public static boolean isRepositoryInUse(ClusterState clusterState, String repository);1540486836;Checks if a repository is currently in use by one of the snapshots__@param clusterState cluster state_@param repository   repository id_@return true if repository is currently in use by one of the running snapshots;public static boolean isRepositoryInUse(ClusterState clusterState, String repository) {_        RestoreInProgress snapshots = clusterState.custom(RestoreInProgress.TYPE)__        if (snapshots != null) {_            for (RestoreInProgress.Entry snapshot : snapshots.entries()) {_                if (repository.equals(snapshot.snapshot().getRepository())) {_                    return true__                }_            }_        }_        return false__    };checks,if,a,repository,is,currently,in,use,by,one,of,the,snapshots,param,cluster,state,cluster,state,param,repository,repository,id,return,true,if,repository,is,currently,in,use,by,one,of,the,running,snapshots;public,static,boolean,is,repository,in,use,cluster,state,cluster,state,string,repository,restore,in,progress,snapshots,cluster,state,custom,restore,in,progress,type,if,snapshots,null,for,restore,in,progress,entry,snapshot,snapshots,entries,if,repository,equals,snapshot,snapshot,get,repository,return,true,return,false
RestoreService -> public static boolean isRepositoryInUse(ClusterState clusterState, String repository);1541092382;Checks if a repository is currently in use by one of the snapshots__@param clusterState cluster state_@param repository   repository id_@return true if repository is currently in use by one of the running snapshots;public static boolean isRepositoryInUse(ClusterState clusterState, String repository) {_        RestoreInProgress snapshots = clusterState.custom(RestoreInProgress.TYPE)__        if (snapshots != null) {_            for (RestoreInProgress.Entry snapshot : snapshots.entries()) {_                if (repository.equals(snapshot.snapshot().getRepository())) {_                    return true__                }_            }_        }_        return false__    };checks,if,a,repository,is,currently,in,use,by,one,of,the,snapshots,param,cluster,state,cluster,state,param,repository,repository,id,return,true,if,repository,is,currently,in,use,by,one,of,the,running,snapshots;public,static,boolean,is,repository,in,use,cluster,state,cluster,state,string,repository,restore,in,progress,snapshots,cluster,state,custom,restore,in,progress,type,if,snapshots,null,for,restore,in,progress,entry,snapshot,snapshots,entries,if,repository,equals,snapshot,snapshot,get,repository,return,true,return,false
RestoreService -> public static boolean isRepositoryInUse(ClusterState clusterState, String repository);1542402632;Checks if a repository is currently in use by one of the snapshots__@param clusterState cluster state_@param repository   repository id_@return true if repository is currently in use by one of the running snapshots;public static boolean isRepositoryInUse(ClusterState clusterState, String repository) {_        RestoreInProgress snapshots = clusterState.custom(RestoreInProgress.TYPE)__        if (snapshots != null) {_            for (RestoreInProgress.Entry snapshot : snapshots.entries()) {_                if (repository.equals(snapshot.snapshot().getRepository())) {_                    return true__                }_            }_        }_        return false__    };checks,if,a,repository,is,currently,in,use,by,one,of,the,snapshots,param,cluster,state,cluster,state,param,repository,repository,id,return,true,if,repository,is,currently,in,use,by,one,of,the,running,snapshots;public,static,boolean,is,repository,in,use,cluster,state,cluster,state,string,repository,restore,in,progress,snapshots,cluster,state,custom,restore,in,progress,type,if,snapshots,null,for,restore,in,progress,entry,snapshot,snapshots,entries,if,repository,equals,snapshot,snapshot,get,repository,return,true,return,false
RestoreService -> public static boolean isRepositoryInUse(ClusterState clusterState, String repository);1544783963;Checks if a repository is currently in use by one of the snapshots__@param clusterState cluster state_@param repository   repository id_@return true if repository is currently in use by one of the running snapshots;public static boolean isRepositoryInUse(ClusterState clusterState, String repository) {_        RestoreInProgress restoreInProgress = clusterState.custom(RestoreInProgress.TYPE)__        if (restoreInProgress != null) {_            for (RestoreInProgress.Entry entry: restoreInProgress) {_                if (repository.equals(entry.snapshot().getRepository())) {_                    return true__                }_            }_        }_        return false__    };checks,if,a,repository,is,currently,in,use,by,one,of,the,snapshots,param,cluster,state,cluster,state,param,repository,repository,id,return,true,if,repository,is,currently,in,use,by,one,of,the,running,snapshots;public,static,boolean,is,repository,in,use,cluster,state,cluster,state,string,repository,restore,in,progress,restore,in,progress,cluster,state,custom,restore,in,progress,type,if,restore,in,progress,null,for,restore,in,progress,entry,entry,restore,in,progress,if,repository,equals,entry,snapshot,get,repository,return,true,return,false
RestoreService -> public static boolean isRepositoryInUse(ClusterState clusterState, String repository);1545215361;Checks if a repository is currently in use by one of the snapshots__@param clusterState cluster state_@param repository   repository id_@return true if repository is currently in use by one of the running snapshots;public static boolean isRepositoryInUse(ClusterState clusterState, String repository) {_        RestoreInProgress restoreInProgress = clusterState.custom(RestoreInProgress.TYPE)__        if (restoreInProgress != null) {_            for (RestoreInProgress.Entry entry: restoreInProgress) {_                if (repository.equals(entry.snapshot().getRepository())) {_                    return true__                }_            }_        }_        return false__    };checks,if,a,repository,is,currently,in,use,by,one,of,the,snapshots,param,cluster,state,cluster,state,param,repository,repository,id,return,true,if,repository,is,currently,in,use,by,one,of,the,running,snapshots;public,static,boolean,is,repository,in,use,cluster,state,cluster,state,string,repository,restore,in,progress,restore,in,progress,cluster,state,custom,restore,in,progress,type,if,restore,in,progress,null,for,restore,in,progress,entry,entry,restore,in,progress,if,repository,equals,entry,snapshot,get,repository,return,true,return,false
RestoreService -> public static boolean isRepositoryInUse(ClusterState clusterState, String repository);1547760203;Checks if a repository is currently in use by one of the snapshots__@param clusterState cluster state_@param repository   repository id_@return true if repository is currently in use by one of the running snapshots;public static boolean isRepositoryInUse(ClusterState clusterState, String repository) {_        RestoreInProgress restoreInProgress = clusterState.custom(RestoreInProgress.TYPE)__        if (restoreInProgress != null) {_            for (RestoreInProgress.Entry entry: restoreInProgress) {_                if (repository.equals(entry.snapshot().getRepository())) {_                    return true__                }_            }_        }_        return false__    };checks,if,a,repository,is,currently,in,use,by,one,of,the,snapshots,param,cluster,state,cluster,state,param,repository,repository,id,return,true,if,repository,is,currently,in,use,by,one,of,the,running,snapshots;public,static,boolean,is,repository,in,use,cluster,state,cluster,state,string,repository,restore,in,progress,restore,in,progress,cluster,state,custom,restore,in,progress,type,if,restore,in,progress,null,for,restore,in,progress,entry,entry,restore,in,progress,if,repository,equals,entry,snapshot,get,repository,return,true,return,false
RestoreService -> public static boolean isRepositoryInUse(ClusterState clusterState, String repository);1549033151;Checks if a repository is currently in use by one of the snapshots__@param clusterState cluster state_@param repository   repository id_@return true if repository is currently in use by one of the running snapshots;public static boolean isRepositoryInUse(ClusterState clusterState, String repository) {_        RestoreInProgress restoreInProgress = clusterState.custom(RestoreInProgress.TYPE)__        if (restoreInProgress != null) {_            for (RestoreInProgress.Entry entry: restoreInProgress) {_                if (repository.equals(entry.snapshot().getRepository())) {_                    return true__                }_            }_        }_        return false__    };checks,if,a,repository,is,currently,in,use,by,one,of,the,snapshots,param,cluster,state,cluster,state,param,repository,repository,id,return,true,if,repository,is,currently,in,use,by,one,of,the,running,snapshots;public,static,boolean,is,repository,in,use,cluster,state,cluster,state,string,repository,restore,in,progress,restore,in,progress,cluster,state,custom,restore,in,progress,type,if,restore,in,progress,null,for,restore,in,progress,entry,entry,restore,in,progress,if,repository,equals,entry,snapshot,get,repository,return,true,return,false
RestoreService -> RestoreRequest -> public String cause();1524684173;Returns restore operation cause__@return restore operation cause;public String cause() {_            return cause__        };returns,restore,operation,cause,return,restore,operation,cause;public,string,cause,return,cause
RestoreService -> RestoreRequest -> public String cause();1525248068;Returns restore operation cause__@return restore operation cause;public String cause() {_            return cause__        };returns,restore,operation,cause,return,restore,operation,cause;public,string,cause,return,cause
RestoreService -> RestoreRequest -> public String cause();1535405719;Returns restore operation cause__@return restore operation cause;public String cause() {_            return cause__        };returns,restore,operation,cause,return,restore,operation,cause;public,string,cause,return,cause
RestoreService -> RestoreRequest -> public String cause();1535723122;Returns restore operation cause__@return restore operation cause;public String cause() {_            return cause__        };returns,restore,operation,cause,return,restore,operation,cause;public,string,cause,return,cause
RestoreService -> RestoreRequest -> public String cause();1536137328;Returns restore operation cause__@return restore operation cause;public String cause() {_            return cause__        };returns,restore,operation,cause,return,restore,operation,cause;public,string,cause,return,cause
RestoreService -> RestoreRequest -> public String cause();1539723533;Returns restore operation cause__@return restore operation cause;public String cause() {_            return cause__        };returns,restore,operation,cause,return,restore,operation,cause;public,string,cause,return,cause
RestoreService -> RestoreRequest -> public String cause();1540486836;Returns restore operation cause__@return restore operation cause;public String cause() {_            return cause__        };returns,restore,operation,cause,return,restore,operation,cause;public,string,cause,return,cause
RestoreService -> RestoreRequest -> public String cause();1541092382;Returns restore operation cause__@return restore operation cause;public String cause() {_            return cause__        };returns,restore,operation,cause,return,restore,operation,cause;public,string,cause,return,cause
RestoreService -> RestoreRequest -> public String cause();1542402632;Returns restore operation cause__@return restore operation cause;public String cause() {_            return cause__        };returns,restore,operation,cause,return,restore,operation,cause;public,string,cause,return,cause
RestoreService -> RestoreRequest -> public String cause();1544783963;Returns restore operation cause__@return restore operation cause;public String cause() {_            return cause__        };returns,restore,operation,cause,return,restore,operation,cause;public,string,cause,return,cause
RestoreService -> RestoreRequest -> public String cause();1545215361;Returns restore operation cause__@return restore operation cause;public String cause() {_            return cause__        };returns,restore,operation,cause,return,restore,operation,cause;public,string,cause,return,cause
RestoreService -> RestoreRequest -> public boolean includeGlobalState();1524684173;Returns true if global state should be restore during this restore operation__@return restore global state flag;public boolean includeGlobalState() {_            return includeGlobalState__        };returns,true,if,global,state,should,be,restore,during,this,restore,operation,return,restore,global,state,flag;public,boolean,include,global,state,return,include,global,state
RestoreService -> RestoreRequest -> public boolean includeGlobalState();1525248068;Returns true if global state should be restore during this restore operation__@return restore global state flag;public boolean includeGlobalState() {_            return includeGlobalState__        };returns,true,if,global,state,should,be,restore,during,this,restore,operation,return,restore,global,state,flag;public,boolean,include,global,state,return,include,global,state
RestoreService -> RestoreRequest -> public boolean includeGlobalState();1535405719;Returns true if global state should be restore during this restore operation__@return restore global state flag;public boolean includeGlobalState() {_            return includeGlobalState__        };returns,true,if,global,state,should,be,restore,during,this,restore,operation,return,restore,global,state,flag;public,boolean,include,global,state,return,include,global,state
RestoreService -> RestoreRequest -> public boolean includeGlobalState();1535723122;Returns true if global state should be restore during this restore operation__@return restore global state flag;public boolean includeGlobalState() {_            return includeGlobalState__        };returns,true,if,global,state,should,be,restore,during,this,restore,operation,return,restore,global,state,flag;public,boolean,include,global,state,return,include,global,state
RestoreService -> RestoreRequest -> public boolean includeGlobalState();1536137328;Returns true if global state should be restore during this restore operation__@return restore global state flag;public boolean includeGlobalState() {_            return includeGlobalState__        };returns,true,if,global,state,should,be,restore,during,this,restore,operation,return,restore,global,state,flag;public,boolean,include,global,state,return,include,global,state
RestoreService -> RestoreRequest -> public boolean includeGlobalState();1539723533;Returns true if global state should be restore during this restore operation__@return restore global state flag;public boolean includeGlobalState() {_            return includeGlobalState__        };returns,true,if,global,state,should,be,restore,during,this,restore,operation,return,restore,global,state,flag;public,boolean,include,global,state,return,include,global,state
RestoreService -> RestoreRequest -> public boolean includeGlobalState();1540486836;Returns true if global state should be restore during this restore operation__@return restore global state flag;public boolean includeGlobalState() {_            return includeGlobalState__        };returns,true,if,global,state,should,be,restore,during,this,restore,operation,return,restore,global,state,flag;public,boolean,include,global,state,return,include,global,state
RestoreService -> RestoreRequest -> public boolean includeGlobalState();1541092382;Returns true if global state should be restore during this restore operation__@return restore global state flag;public boolean includeGlobalState() {_            return includeGlobalState__        };returns,true,if,global,state,should,be,restore,during,this,restore,operation,return,restore,global,state,flag;public,boolean,include,global,state,return,include,global,state
RestoreService -> RestoreRequest -> public boolean includeGlobalState();1542402632;Returns true if global state should be restore during this restore operation__@return restore global state flag;public boolean includeGlobalState() {_            return includeGlobalState__        };returns,true,if,global,state,should,be,restore,during,this,restore,operation,return,restore,global,state,flag;public,boolean,include,global,state,return,include,global,state
RestoreService -> RestoreRequest -> public boolean includeGlobalState();1544783963;Returns true if global state should be restore during this restore operation__@return restore global state flag;public boolean includeGlobalState() {_            return includeGlobalState__        };returns,true,if,global,state,should,be,restore,during,this,restore,operation,return,restore,global,state,flag;public,boolean,include,global,state,return,include,global,state
RestoreService -> RestoreRequest -> public boolean includeGlobalState();1545215361;Returns true if global state should be restore during this restore operation__@return restore global state flag;public boolean includeGlobalState() {_            return includeGlobalState__        };returns,true,if,global,state,should,be,restore,during,this,restore,operation,return,restore,global,state,flag;public,boolean,include,global,state,return,include,global,state
RestoreService -> RestoreRequest -> public Settings settings();1524684173;Returns repository-specific restore settings__@return restore settings;public Settings settings() {_            return settings__        };returns,repository,specific,restore,settings,return,restore,settings;public,settings,settings,return,settings
RestoreService -> RestoreRequest -> public Settings settings();1525248068;Returns repository-specific restore settings__@return restore settings;public Settings settings() {_            return settings__        };returns,repository,specific,restore,settings,return,restore,settings;public,settings,settings,return,settings
RestoreService -> RestoreRequest -> public Settings settings();1535405719;Returns repository-specific restore settings__@return restore settings;public Settings settings() {_            return settings__        };returns,repository,specific,restore,settings,return,restore,settings;public,settings,settings,return,settings
RestoreService -> RestoreRequest -> public Settings settings();1535723122;Returns repository-specific restore settings__@return restore settings;public Settings settings() {_            return settings__        };returns,repository,specific,restore,settings,return,restore,settings;public,settings,settings,return,settings
RestoreService -> RestoreRequest -> public Settings settings();1536137328;Returns repository-specific restore settings__@return restore settings;public Settings settings() {_            return settings__        };returns,repository,specific,restore,settings,return,restore,settings;public,settings,settings,return,settings
RestoreService -> RestoreRequest -> public Settings settings();1539723533;Returns repository-specific restore settings__@return restore settings;public Settings settings() {_            return settings__        };returns,repository,specific,restore,settings,return,restore,settings;public,settings,settings,return,settings
RestoreService -> RestoreRequest -> public Settings settings();1540486836;Returns repository-specific restore settings__@return restore settings;public Settings settings() {_            return settings__        };returns,repository,specific,restore,settings,return,restore,settings;public,settings,settings,return,settings
RestoreService -> RestoreRequest -> public Settings settings();1541092382;Returns repository-specific restore settings__@return restore settings;public Settings settings() {_            return settings__        };returns,repository,specific,restore,settings,return,restore,settings;public,settings,settings,return,settings
RestoreService -> RestoreRequest -> public Settings settings();1542402632;Returns repository-specific restore settings__@return restore settings;public Settings settings() {_            return settings__        };returns,repository,specific,restore,settings,return,restore,settings;public,settings,settings,return,settings
RestoreService -> RestoreRequest -> public Settings settings();1544783963;Returns repository-specific restore settings__@return restore settings;public Settings settings() {_            return settings__        };returns,repository,specific,restore,settings,return,restore,settings;public,settings,settings,return,settings
RestoreService -> RestoreRequest -> public Settings settings();1545215361;Returns repository-specific restore settings__@return restore settings;public Settings settings() {_            return settings__        };returns,repository,specific,restore,settings,return,restore,settings;public,settings,settings,return,settings
