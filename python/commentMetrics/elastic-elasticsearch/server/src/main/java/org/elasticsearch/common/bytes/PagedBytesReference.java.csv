commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public byte get(int index) {     return byteArray.get(offset + index). }
false;public;0;4;;@Override public int length() {     return length. }
false;public;2;8;;@Override public BytesReference slice(int from, int length) {     if (from < 0 || (from + length) > length()) {         throw new IllegalArgumentException("can't slice a buffer with length [" + length() + "], with slice parameters from [" + from + "], length [" + length + "]").     }     return new PagedBytesReference(byteArray, offset + from, length). }
false;public;0;7;;@Override public BytesRef toBytesRef() {     BytesRef bref = new BytesRef().     // if length <= pagesize this will dereference the page, or materialize the byte[]     byteArray.get(offset, length, bref).     return bref. }
false;public;0;14;;@Override public BytesRef next() throws IOException {     if (nextFragmentSize != 0) {         final boolean materialized = byteArray.get(offset + position, nextFragmentSize, slice).         assert materialized == false : "iteration should be page aligned but array got materialized".         position += nextFragmentSize.         final int remaining = length - position.         nextFragmentSize = Math.min(remaining, PAGE_SIZE).         return slice.     } else {         assert nextFragmentSize == 0 : "fragmentSize expected [0] but was: [" + nextFragmentSize + "]".         // we are done with this iteration         return null.     } }
false;public,final;0;31;;@Override public final BytesRefIterator iterator() {     final int offset = this.offset.     final int length = this.length.     // this iteration is page aligned to ensure we do NOT materialize the pages from the ByteArray     // we calculate the initial fragment size here to ensure that if this reference is a slice we are still page aligned     // across the entire iteration. The first page is smaller if our offset != 0 then we start in the middle of the page     // otherwise we iterate full pages until we reach the last chunk which also might end within a page.     final int initialFragmentSize = offset != 0 ? PAGE_SIZE - (offset % PAGE_SIZE) : PAGE_SIZE.     return new BytesRefIterator() {          int position = 0.          int nextFragmentSize = Math.min(length, initialFragmentSize).          // this BytesRef is reused across the iteration on purpose - BytesRefIterator interface was designed for this         final BytesRef slice = new BytesRef().          @Override         public BytesRef next() throws IOException {             if (nextFragmentSize != 0) {                 final boolean materialized = byteArray.get(offset + position, nextFragmentSize, slice).                 assert materialized == false : "iteration should be page aligned but array got materialized".                 position += nextFragmentSize.                 final int remaining = length - position.                 nextFragmentSize = Math.min(remaining, PAGE_SIZE).                 return slice.             } else {                 assert nextFragmentSize == 0 : "fragmentSize expected [0] but was: [" + nextFragmentSize + "]".                 // we are done with this iteration                 return null.             }         }     }. }
false;public;0;4;;@Override public long ramBytesUsed() {     return byteArray.ramBytesUsed(). }
