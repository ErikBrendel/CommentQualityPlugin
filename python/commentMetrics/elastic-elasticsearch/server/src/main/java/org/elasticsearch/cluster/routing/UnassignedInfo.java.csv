commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeByte(id). }
false;public,static;1;19;;public static AllocationStatus readFrom(StreamInput in) throws IOException {     byte id = in.readByte().     switch(id) {         case 0:             return DECIDERS_NO.         case 1:             return NO_VALID_SHARD_COPY.         case 2:             return DECIDERS_THROTTLED.         case 3:             return FETCHING_SHARD_DATA.         case 4:             return DELAYED_ALLOCATION.         case 5:             return NO_ATTEMPT.         default:             throw new IllegalArgumentException("Unknown AllocationStatus value [" + id + "]").     } }
false;public,static;1;11;;public static AllocationStatus fromDecision(Decision.Type decision) {     Objects.requireNonNull(decision).     switch(decision) {         case NO:             return DECIDERS_NO.         case THROTTLE:             return DECIDERS_THROTTLED.         default:             throw new IllegalArgumentException("no allocation attempt from decision[" + decision + "]").     } }
false;public;0;3;;public String value() {     return toString().toLowerCase(Locale.ROOT). }
false;public;1;16;;public void writeTo(StreamOutput out) throws IOException {     if (out.getVersion().before(Version.V_6_0_0_beta2) && reason == Reason.MANUAL_ALLOCATION) {         out.writeByte((byte) Reason.ALLOCATION_FAILED.ordinal()).     } else if (out.getVersion().before(Version.V_7_0_0) && reason == Reason.INDEX_CLOSED) {         out.writeByte((byte) Reason.REINITIALIZED.ordinal()).     } else {         out.writeByte((byte) reason.ordinal()).     }     out.writeLong(unassignedTimeMillis).     // Do not serialize unassignedTimeNanos as System.nanoTime() cannot be compared across different JVMs     out.writeBoolean(delayed).     out.writeOptionalString(message).     out.writeException(failure).     out.writeVInt(failedAllocations).     lastAllocationStatus.writeTo(out). }
true;public;0;3;/**  * Returns the number of previously failed allocations of this shard.  */ ;/**  * Returns the number of previously failed allocations of this shard.  */ public int getNumFailedAllocations() {     return failedAllocations. }
true;public;0;3;/**  * Returns true if allocation of this shard is delayed due to {@link #INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING}  */ ;/**  * Returns true if allocation of this shard is delayed due to {@link #INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING}  */ public boolean isDelayed() {     return delayed. }
true;public;0;3;/**  * The reason why the shard is unassigned.  */ ;/**  * The reason why the shard is unassigned.  */ public Reason getReason() {     return this.reason. }
true;public;0;3;/**  * The timestamp in milliseconds when the shard became unassigned, based on System.currentTimeMillis().  * Note, we use timestamp here since we want to make sure its preserved across node serializations.  */ ;/**  * The timestamp in milliseconds when the shard became unassigned, based on System.currentTimeMillis().  * Note, we use timestamp here since we want to make sure its preserved across node serializations.  */ public long getUnassignedTimeInMillis() {     return this.unassignedTimeMillis. }
true;public;0;3;/**  * The timestamp in nanoseconds when the shard became unassigned, based on System.nanoTime().  * Used to calculate the delay for delayed shard allocation.  * ONLY EXPOSED FOR TESTS!  */ ;/**  * The timestamp in nanoseconds when the shard became unassigned, based on System.nanoTime().  * Used to calculate the delay for delayed shard allocation.  * ONLY EXPOSED FOR TESTS!  */ public long getUnassignedTimeInNanos() {     return this.unassignedTimeNanos. }
true;public;0;4;/**  * Returns optional details explaining the reasons.  */ ;/**  * Returns optional details explaining the reasons.  */ @Nullable public String getMessage() {     return this.message. }
true;public;0;4;/**  * Returns additional failure exception details if exists.  */ ;/**  * Returns additional failure exception details if exists.  */ @Nullable public Exception getFailure() {     return failure. }
true;public;0;7;/**  * Builds a string representation of the message and the failure if exists.  */ ;/**  * Builds a string representation of the message and the failure if exists.  */ @Nullable public String getDetails() {     if (message == null) {         return null.     }     return message + (failure == null ? "" : ", failure " + ExceptionsHelper.detailedMessage(failure)). }
true;public;0;3;/**  * Get the status for the last allocation attempt for this shard.  */ ;/**  * Get the status for the last allocation attempt for this shard.  */ public AllocationStatus getLastAllocationStatus() {     return lastAllocationStatus. }
true;public;2;5;/**  * Calculates the delay left based on current time (in nanoseconds) and the delay defined by the index settings.  * Only relevant if shard is effectively delayed (see {@link #isDelayed()})  * Returns 0 if delay is negative  *  * @return calculated delay in nanoseconds  */ ;/**  * Calculates the delay left based on current time (in nanoseconds) and the delay defined by the index settings.  * Only relevant if shard is effectively delayed (see {@link #isDelayed()})  * Returns 0 if delay is negative  *  * @return calculated delay in nanoseconds  */ public long getRemainingDelay(final long nanoTimeNow, final Settings indexSettings) {     long delayTimeoutNanos = INDEX_DELAYED_NODE_LEFT_TIMEOUT_SETTING.get(indexSettings).nanos().     assert nanoTimeNow >= unassignedTimeNanos.     return Math.max(0L, delayTimeoutNanos - (nanoTimeNow - unassignedTimeNanos)). }
true;public,static;1;9;/**  * Returns the number of shards that are unassigned and currently being delayed.  */ ;/**  * Returns the number of shards that are unassigned and currently being delayed.  */ public static int getNumberOfDelayedUnassigned(ClusterState state) {     int count = 0.     for (ShardRouting shard : state.routingTable().shardsWithState(ShardRoutingState.UNASSIGNED)) {         if (shard.unassignedInfo().isDelayed()) {             count++.         }     }     return count. }
true;public,static;2;17;/**  * Finds the next (closest) delay expiration of an delayed shard in nanoseconds based on current time.  * Returns 0 if delay is negative.  * Returns -1 if no delayed shard is found.  */ ;/**  * Finds the next (closest) delay expiration of an delayed shard in nanoseconds based on current time.  * Returns 0 if delay is negative.  * Returns -1 if no delayed shard is found.  */ public static long findNextDelayedAllocation(long currentNanoTime, ClusterState state) {     MetaData metaData = state.metaData().     RoutingTable routingTable = state.routingTable().     long nextDelayNanos = Long.MAX_VALUE.     for (ShardRouting shard : routingTable.shardsWithState(ShardRoutingState.UNASSIGNED)) {         UnassignedInfo unassignedInfo = shard.unassignedInfo().         if (unassignedInfo.isDelayed()) {             Settings indexSettings = metaData.index(shard.index()).getSettings().             // calculate next time to schedule             final long newComputedLeftDelayNanos = unassignedInfo.getRemainingDelay(currentNanoTime, indexSettings).             if (newComputedLeftDelayNanos < nextDelayNanos) {                 nextDelayNanos = newComputedLeftDelayNanos.             }         }     }     return nextDelayNanos == Long.MAX_VALUE ? -1L : nextDelayNanos. }
false;public;0;16;;public String shortSummary() {     StringBuilder sb = new StringBuilder().     sb.append("[reason=").append(reason).append("]").     sb.append(", at[").append(DATE_TIME_FORMATTER.format(Instant.ofEpochMilli(unassignedTimeMillis))).append("]").     if (failedAllocations > 0) {         sb.append(", failed_attempts[").append(failedAllocations).append("]").     }     sb.append(", delayed=").append(delayed).     String details = getDetails().     if (details != null) {         sb.append(", details[").append(details).append("]").     }     sb.append(", allocation_status[").append(lastAllocationStatus.value()).append("]").     return sb.toString(). }
false;public;0;4;;@Override public String toString() {     return "unassigned_info[" + shortSummary() + "]". }
false;public;2;17;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject("unassigned_info").     builder.field("reason", reason).     builder.field("at", DATE_TIME_FORMATTER.format(Instant.ofEpochMilli(unassignedTimeMillis))).     if (failedAllocations > 0) {         builder.field("failed_attempts", failedAllocations).     }     builder.field("delayed", delayed).     String details = getDetails().     if (details != null) {         builder.field("details", details).     }     builder.field("allocation_status", lastAllocationStatus.value()).     builder.endObject().     return builder. }
false;public;1;31;;@Override public boolean equals(Object o) {     if (this == o) {         return true.     }     if (o == null || getClass() != o.getClass()) {         return false.     }     UnassignedInfo that = (UnassignedInfo) o.     if (unassignedTimeMillis != that.unassignedTimeMillis) {         return false.     }     if (delayed != that.delayed) {         return false.     }     if (failedAllocations != that.failedAllocations) {         return false.     }     if (reason != that.reason) {         return false.     }     if (message != null ? !message.equals(that.message) : that.message != null) {         return false.     }     if (lastAllocationStatus != that.lastAllocationStatus) {         return false.     }     return !(failure != null ? !failure.equals(that.failure) : that.failure != null). }
false;public;0;11;;@Override public int hashCode() {     int result = reason.hashCode().     result = 31 * result + Boolean.hashCode(delayed).     result = 31 * result + Integer.hashCode(failedAllocations).     result = 31 * result + Long.hashCode(unassignedTimeMillis).     result = 31 * result + (message != null ? message.hashCode() : 0).     result = 31 * result + (failure != null ? failure.hashCode() : 0).     result = 31 * result + lastAllocationStatus.hashCode().     return result. }
