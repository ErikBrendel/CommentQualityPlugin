commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;18;;@Override protected void doWriteTo(StreamOutput out) throws IOException {     out.writeVInt(size).     out.writeStringCollection(sourceNames).     if (out.getVersion().onOrAfter(Version.V_6_3_0)) {         for (DocValueFormat format : formats) {             out.writeNamedWriteable(format).         }     }     out.writeIntArray(reverseMuls).     out.writeList(buckets).     if (out.getVersion().onOrAfter(Version.V_6_3_0)) {         out.writeBoolean(afterKey != null).         if (afterKey != null) {             afterKey.writeTo(out).         }     } }
false;public;2;4;;@Override public XContentBuilder doXContentBody(XContentBuilder builder, Params params) throws IOException {     return CompositeAggregation.toXContentFragment(this, builder, params). }
false;public;0;4;;@Override public String getWriteableName() {     return CompositeAggregationBuilder.NAME. }
false;public;1;10;;@Override public InternalComposite create(List<InternalBucket> newBuckets) {     /**      * This is used by pipeline aggregations to filter/remove buckets so we      * keep the <code>afterKey</code> of the original aggregation in order      * to be able to retrieve the next page even if all buckets have been filtered.      */     return new InternalComposite(name, size, sourceNames, formats, newBuckets, afterKey, reverseMuls, pipelineAggregators(), getMetaData()). }
false;public;2;5;;@Override public InternalBucket createBucket(InternalAggregations aggregations, InternalBucket prototype) {     return new InternalBucket(prototype.sourceNames, prototype.formats, prototype.key, prototype.reverseMuls, prototype.docCount, aggregations). }
false;public;0;3;;public int getSize() {     return size. }
false;public;0;4;;@Override public List<InternalBucket> getBuckets() {     return buckets. }
false;public;0;7;;@Override public Map<String, Object> afterKey() {     if (afterKey != null) {         return new ArrayMap(sourceNames, formats, afterKey.values()).     }     return null. }
true;;0;3;// Visible for tests ;// Visible for tests int[] getReverseMuls() {     return reverseMuls. }
false;public;2;38;;@Override public InternalAggregation doReduce(List<InternalAggregation> aggregations, ReduceContext reduceContext) {     PriorityQueue<BucketIterator> pq = new PriorityQueue<>(aggregations.size()).     for (InternalAggregation agg : aggregations) {         InternalComposite sortedAgg = (InternalComposite) agg.         BucketIterator it = new BucketIterator(sortedAgg.buckets).         if (it.next() != null) {             pq.add(it).         }     }     InternalBucket lastBucket = null.     List<InternalBucket> buckets = new ArrayList<>().     List<InternalBucket> result = new ArrayList<>().     while (pq.size() > 0) {         BucketIterator bucketIt = pq.poll().         if (lastBucket != null && bucketIt.current.compareKey(lastBucket) != 0) {             InternalBucket reduceBucket = buckets.get(0).reduce(buckets, reduceContext).             buckets.clear().             reduceContext.consumeBucketsAndMaybeBreak(1).             result.add(reduceBucket).             if (result.size() >= size) {                 break.             }         }         lastBucket = bucketIt.current.         buckets.add(bucketIt.current).         if (bucketIt.next() != null) {             pq.add(bucketIt).         }     }     if (buckets.size() > 0) {         InternalBucket reduceBucket = buckets.get(0).reduce(buckets, reduceContext).         reduceContext.consumeBucketsAndMaybeBreak(1).         result.add(reduceBucket).     }     final CompositeKey lastKey = result.size() > 0 ? result.get(result.size() - 1).getRawKey() : null.     return new InternalComposite(name, size, sourceNames, formats, result, lastKey, reverseMuls, pipelineAggregators(), metaData). }
false;protected;1;8;;@Override protected boolean doEquals(Object obj) {     InternalComposite that = (InternalComposite) obj.     return Objects.equals(size, that.size) && Objects.equals(buckets, that.buckets) && Objects.equals(afterKey, that.afterKey) && Arrays.equals(reverseMuls, that.reverseMuls). }
false;protected;0;4;;@Override protected int doHashCode() {     return Objects.hash(size, buckets, afterKey, Arrays.hashCode(reverseMuls)). }
false;public;1;4;;@Override public int compareTo(BucketIterator other) {     return current.compareKey(other.current). }
false;;0;3;;InternalBucket next() {     return current = it.hasNext() ? it.next() : null. }
false;public;1;6;;@Override public void writeTo(StreamOutput out) throws IOException {     key.writeTo(out).     out.writeVLong(docCount).     aggregations.writeTo(out). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(getClass(), docCount, key, aggregations). }
false;public;1;10;;@Override public boolean equals(Object obj) {     if (obj == null || getClass() != obj.getClass()) {         return false.     }     InternalBucket that = (InternalBucket) obj.     return Objects.equals(docCount, that.docCount) && Objects.equals(key, that.key) && Objects.equals(aggregations, that.aggregations). }
false;public;0;5;;@Override public Map<String, Object> getKey() {     // returns the formatted key in a map     return new ArrayMap(sourceNames, formats, key.values()). }
true;;0;3;// visible for testing ;// get the raw key (without formatting to preserve the natural order). // visible for testing CompositeKey getRawKey() {     return key. }
false;public;0;15;;@Override public String getKeyAsString() {     StringBuilder builder = new StringBuilder().     builder.append('{').     for (int i = 0. i < key.size(). i++) {         if (i > 0) {             builder.append(", ").         }         builder.append(sourceNames.get(i)).         builder.append('=').         builder.append(formatObject(key.get(i), formats.get(i))).     }     builder.append('}').     return builder.toString(). }
false;public;0;4;;@Override public long getDocCount() {     return docCount. }
false;public;0;4;;@Override public Aggregations getAggregations() {     return aggregations. }
false;;2;10;;InternalBucket reduce(List<InternalBucket> buckets, ReduceContext reduceContext) {     List<InternalAggregations> aggregations = new ArrayList<>(buckets.size()).     long docCount = 0.     for (InternalBucket bucket : buckets) {         docCount += bucket.docCount.         aggregations.add(bucket.aggregations).     }     InternalAggregations aggs = InternalAggregations.reduce(aggregations, reduceContext).     return new InternalBucket(sourceNames, formats, key, reverseMuls, docCount, aggs). }
false;public;1;20;;@Override public int compareKey(InternalBucket other) {     for (int i = 0. i < key.size(). i++) {         if (key.get(i) == null) {             if (other.key.get(i) == null) {                 continue.             }             return -1 * reverseMuls[i].         } else if (other.key.get(i) == null) {             return reverseMuls[i].         }         assert key.get(i).getClass() == other.key.get(i).getClass().         @SuppressWarnings("unchecked")         int cmp = key.get(i).compareTo(other.key.get(i)) * reverseMuls[i].         if (cmp != 0) {             return cmp.         }     }     return 0. }
false;public;2;7;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     /**      * See {@link CompositeAggregation#bucketToXContent}      */     throw new UnsupportedOperationException("not implemented"). }
true;static;2;28;/**  * Format <code>obj</code> using the provided {@link DocValueFormat}.  * If the format is equals to {@link DocValueFormat#RAW}, the object is returned as is  * for numbers and a string for {@link BytesRef}s.  */ ;/**  * Format <code>obj</code> using the provided {@link DocValueFormat}.  * If the format is equals to {@link DocValueFormat#RAW}, the object is returned as is  * for numbers and a string for {@link BytesRef}s.  */ static Object formatObject(Object obj, DocValueFormat format) {     if (obj == null) {         return null.     }     if (obj.getClass() == BytesRef.class) {         BytesRef value = (BytesRef) obj.         if (format == DocValueFormat.RAW) {             return value.utf8ToString().         } else {             return format.format(value).         }     } else if (obj.getClass() == Long.class) {         long value = (long) obj.         if (format == DocValueFormat.RAW) {             return value.         } else {             return format.format(value).         }     } else if (obj.getClass() == Double.class) {         double value = (double) obj.         if (format == DocValueFormat.RAW) {             return value.         } else {             return format.format(value).         }     }     return obj. }
false;public;0;4;;@Override public int size() {     return values.length. }
false;public;1;9;;@Override public Object get(Object key) {     for (int i = 0. i < keys.size(). i++) {         if (key.equals(keys.get(i))) {             return formatObject(values[i], formats.get(i)).         }     }     return null. }
false;public;0;4;;@Override public boolean hasNext() {     return pos < values.length. }
false;public;0;7;;@Override public Entry<String, Object> next() {     SimpleEntry<String, Object> entry = new SimpleEntry<>(keys.get(pos), formatObject(values[pos], formats.get(pos))).     ++pos.     return entry. }
false;public;0;18;;@Override public Iterator<Entry<String, Object>> iterator() {     return new Iterator<Entry<String, Object>>() {          int pos = 0.          @Override         public boolean hasNext() {             return pos < values.length.         }          @Override         public Entry<String, Object> next() {             SimpleEntry<String, Object> entry = new SimpleEntry<>(keys.get(pos), formatObject(values[pos], formats.get(pos))).             ++pos.             return entry.         }     }. }
false;public;0;4;;@Override public int size() {     return keys.size(). }
false;public;0;28;;@Override public Set<Entry<String, Object>> entrySet() {     return new AbstractSet<Entry<String, Object>>() {          @Override         public Iterator<Entry<String, Object>> iterator() {             return new Iterator<Entry<String, Object>>() {                  int pos = 0.                  @Override                 public boolean hasNext() {                     return pos < values.length.                 }                  @Override                 public Entry<String, Object> next() {                     SimpleEntry<String, Object> entry = new SimpleEntry<>(keys.get(pos), formatObject(values[pos], formats.get(pos))).                     ++pos.                     return entry.                 }             }.         }          @Override         public int size() {             return keys.size().         }     }. }
false;public;1;26;;@Override public int compareTo(ArrayMap that) {     if (that == this) {         return 0.     }     int idx = 0.     int max = Math.min(this.keys.size(), that.keys.size()).     while (idx < max) {         int compare = compareNullables(keys.get(idx), that.keys.get(idx)).         if (compare == 0) {             compare = compareNullables(values[idx], that.values[idx]).         }         if (compare != 0) {             return compare.         }         idx++.     }     if (idx < keys.size()) {         return 1.     }     if (idx < that.keys.size()) {         return -1.     }     return 0. }
false;private,static;2;12;;private static int compareNullables(Comparable a, Comparable b) {     if (a == b) {         return 0.     }     if (a == null) {         return -1.     }     if (b == null) {         return 1.     }     return a.compareTo(b). }
