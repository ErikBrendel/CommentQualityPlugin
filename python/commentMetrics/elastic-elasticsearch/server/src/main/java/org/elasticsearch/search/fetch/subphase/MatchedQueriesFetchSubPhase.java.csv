commented;modifiers;parameterAmount;loc;comment;code
false;public;2;54;;@Override public void hitsExecute(SearchContext context, SearchHit[] hits) {     if (hits.length == 0 || // in case the request has only suggest, parsed query is null     context.parsedQuery() == null) {         return.     }     // don't modify the incoming hits     hits = hits.clone().     Arrays.sort(hits, (a, b) -> Integer.compare(a.docId(), b.docId())).     @SuppressWarnings("unchecked")     List<String>[] matchedQueries = new List[hits.length].     for (int i = 0. i < matchedQueries.length. ++i) {         matchedQueries[i] = new ArrayList<>().     }     Map<String, Query> namedQueries = new HashMap<>(context.parsedQuery().namedFilters()).     if (context.parsedPostFilter() != null) {         namedQueries.putAll(context.parsedPostFilter().namedFilters()).     }     try {         for (Map.Entry<String, Query> entry : namedQueries.entrySet()) {             String name = entry.getKey().             Query query = entry.getValue().             int readerIndex = -1.             int docBase = -1.             Weight weight = context.searcher().createWeight(context.searcher().rewrite(query), ScoreMode.COMPLETE_NO_SCORES, 1f).             Bits matchingDocs = null.             final IndexReader indexReader = context.searcher().getIndexReader().             for (int i = 0. i < hits.length. ++i) {                 SearchHit hit = hits[i].                 int hitReaderIndex = ReaderUtil.subIndex(hit.docId(), indexReader.leaves()).                 if (readerIndex != hitReaderIndex) {                     readerIndex = hitReaderIndex.                     LeafReaderContext ctx = indexReader.leaves().get(readerIndex).                     docBase = ctx.docBase.                     // scorers can be costly to create, so reuse them across docs of the same segment                     ScorerSupplier scorerSupplier = weight.scorerSupplier(ctx).                     matchingDocs = Lucene.asSequentialAccessBits(ctx.reader().maxDoc(), scorerSupplier).                 }                 if (matchingDocs.get(hit.docId() - docBase)) {                     matchedQueries[i].add(name).                 }             }         }         for (int i = 0. i < hits.length. ++i) {             hits[i].matchedQueries(matchedQueries[i].toArray(new String[matchedQueries[i].size()])).         }     } catch (IOException e) {         throw ExceptionsHelper.convertToElastic(e).     } finally {         context.clearReleasables(Lifetime.COLLECTION).     } }
