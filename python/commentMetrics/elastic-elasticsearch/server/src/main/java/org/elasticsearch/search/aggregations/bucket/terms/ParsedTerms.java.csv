commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public long getDocCountError() {     return docCountErrorUpperBound. }
false;public;0;4;;@Override public long getSumOfOtherDocCounts() {     return sumOtherDocCount. }
false;public;0;4;;@Override public List<? extends Terms.Bucket> getBuckets() {     return buckets. }
false;public;1;9;;@Override public Terms.Bucket getBucketByKey(String term) {     for (Terms.Bucket bucket : getBuckets()) {         if (bucket.getKeyAsString().equals(term)) {             return bucket.         }     }     return null. }
false;protected;2;11;;@Override protected XContentBuilder doXContentBody(XContentBuilder builder, Params params) throws IOException {     builder.field(DOC_COUNT_ERROR_UPPER_BOUND_FIELD_NAME.getPreferredName(), getDocCountError()).     builder.field(SUM_OF_OTHER_DOC_COUNTS.getPreferredName(), getSumOfOtherDocCounts()).     builder.startArray(CommonFields.BUCKETS.getPreferredName()).     for (Terms.Bucket bucket : getBuckets()) {         bucket.toXContent(builder, params).     }     builder.endArray().     return builder. }
false;static;2;8;;static void declareParsedTermsFields(final ObjectParser<? extends ParsedTerms, Void> objectParser, final CheckedFunction<XContentParser, ParsedBucket, IOException> bucketParser) {     declareMultiBucketAggregationFields(objectParser, bucketParser::apply, bucketParser::apply).     objectParser.declareLong((parsedTerms, value) -> parsedTerms.docCountErrorUpperBound = value, DOC_COUNT_ERROR_UPPER_BOUND_FIELD_NAME).     objectParser.declareLong((parsedTerms, value) -> parsedTerms.sumOtherDocCount = value, SUM_OF_OTHER_DOC_COUNTS). }
false;public;0;4;;@Override public long getDocCountError() {     return docCountError. }
false;public,final;2;12;;@Override public final XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     keyToXContent(builder).     builder.field(CommonFields.DOC_COUNT.getPreferredName(), getDocCount()).     if (showDocCountError) {         builder.field(DOC_COUNT_ERROR_UPPER_BOUND_FIELD_NAME.getPreferredName(), getDocCountError()).     }     getAggregations().toXContentInternal(builder, params).     builder.endObject().     return builder. }
false;static;3;31;;static <B extends ParsedBucket> B parseTermsBucketXContent(final XContentParser parser, final Supplier<B> bucketSupplier, final CheckedBiConsumer<XContentParser, B, IOException> keyConsumer) throws IOException {     final B bucket = bucketSupplier.get().     final List<Aggregation> aggregations = new ArrayList<>().     XContentParser.Token token.     String currentFieldName = parser.currentName().     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (token.isValue()) {             if (CommonFields.KEY_AS_STRING.getPreferredName().equals(currentFieldName)) {                 bucket.setKeyAsString(parser.text()).             } else if (CommonFields.KEY.getPreferredName().equals(currentFieldName)) {                 keyConsumer.accept(parser, bucket).             } else if (CommonFields.DOC_COUNT.getPreferredName().equals(currentFieldName)) {                 bucket.setDocCount(parser.longValue()).             } else if (DOC_COUNT_ERROR_UPPER_BOUND_FIELD_NAME.getPreferredName().equals(currentFieldName)) {                 bucket.docCountError = parser.longValue().                 bucket.showDocCountError = true.             }         } else if (token == XContentParser.Token.START_OBJECT) {             XContentParserUtils.parseTypedKeysObject(parser, Aggregation.TYPED_KEYS_DELIMITER, Aggregation.class, aggregations::add).         }     }     bucket.setAggregations(new Aggregations(aggregations)).     return bucket. }
