commented;modifiers;parameterAmount;loc;comment;code
false;public;2;35;;@Override public Snippet[] format(Passage[] passages, String content) {     Snippet[] snippets = new Snippet[passages.length].     int pos.     for (int j = 0. j < passages.length. j++) {         Passage passage = passages[j].         StringBuilder sb = new StringBuilder().         pos = passage.getStartOffset().         for (int i = 0. i < passage.getNumMatches(). i++) {             int start = passage.getMatchStarts()[i].             int end = passage.getMatchEnds()[i].             // its possible to have overlapping terms             if (start > pos) {                 append(sb, content, pos, start).             }             if (end > pos) {                 sb.append(preTag).                 append(sb, content, Math.max(pos, start), end).                 sb.append(postTag).                 pos = end.             }         }         // its possible a "term" from the analyzer could span a sentence boundary.         append(sb, content, pos, Math.max(pos, passage.getEndOffset())).         // we remove the paragraph separator if present at the end of the snippet (we used it as separator between values)         if (sb.charAt(sb.length() - 1) == HighlightUtils.PARAGRAPH_SEPARATOR) {             sb.deleteCharAt(sb.length() - 1).         } else if (sb.charAt(sb.length() - 1) == HighlightUtils.NULL_SEPARATOR) {             sb.deleteCharAt(sb.length() - 1).         }         // and we trim the snippets too         snippets[j] = new Snippet(sb.toString().trim(), passage.getScore(), passage.getNumMatches() > 0).     }     return snippets. }
false;private;4;3;;private void append(StringBuilder dest, String content, int start, int end) {     dest.append(encoder.encodeText(content.substring(start, end))). }
