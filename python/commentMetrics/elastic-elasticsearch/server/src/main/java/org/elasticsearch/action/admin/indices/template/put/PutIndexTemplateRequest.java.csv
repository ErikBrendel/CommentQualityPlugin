commented;modifiers;parameterAmount;loc;comment;code
false;public;0;11;;@Override public ActionRequestValidationException validate() {     ActionRequestValidationException validationException = null.     if (name == null) {         validationException = addValidationError("name is missing", validationException).     }     if (indexPatterns == null || indexPatterns.size() == 0) {         validationException = addValidationError("index patterns are missing", validationException).     }     return validationException. }
true;public;1;4;/**  * Sets the name of the index template.  */ ;/**  * Sets the name of the index template.  */ public PutIndexTemplateRequest name(String name) {     this.name = name.     return this. }
true;public;0;3;/**  * The name of the index template.  */ ;/**  * The name of the index template.  */ public String name() {     return this.name. }
false;public;1;4;;public PutIndexTemplateRequest patterns(List<String> indexPatterns) {     this.indexPatterns = indexPatterns.     return this. }
false;public;0;3;;public List<String> patterns() {     return this.indexPatterns. }
false;public;1;4;;public PutIndexTemplateRequest order(int order) {     this.order = order.     return this. }
false;public;0;3;;public int order() {     return this.order. }
false;public;1;4;;public PutIndexTemplateRequest version(Integer version) {     this.version = version.     return this. }
false;public;0;3;;public Integer version() {     return this.version. }
true;public;1;4;/**  * Set to {@code true} to force only creation, not an update of an index template. If it already  * exists, it will fail with an {@link IllegalArgumentException}.  */ ;/**  * Set to {@code true} to force only creation, not an update of an index template. If it already  * exists, it will fail with an {@link IllegalArgumentException}.  */ public PutIndexTemplateRequest create(boolean create) {     this.create = create.     return this. }
false;public;0;3;;public boolean create() {     return create. }
true;public;1;4;/**  * The settings to create the index template with.  */ ;/**  * The settings to create the index template with.  */ public PutIndexTemplateRequest settings(Settings settings) {     this.settings = settings.     return this. }
true;public;1;4;/**  * The settings to create the index template with.  */ ;/**  * The settings to create the index template with.  */ public PutIndexTemplateRequest settings(Settings.Builder settings) {     this.settings = settings.build().     return this. }
true;public;2;4;/**  * The settings to create the index template with (either json/yaml format).  */ ;/**  * The settings to create the index template with (either json/yaml format).  */ public PutIndexTemplateRequest settings(String source, XContentType xContentType) {     this.settings = Settings.builder().loadFromSource(source, xContentType).build().     return this. }
true;public;1;10;/**  * The settings to create the index template with (either json or yaml format).  */ ;/**  * The settings to create the index template with (either json or yaml format).  */ public PutIndexTemplateRequest settings(Map<String, Object> source) {     try {         XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON).         builder.map(source).         settings(Strings.toString(builder), XContentType.JSON).     } catch (IOException e) {         throw new ElasticsearchGenerationException("Failed to generate [" + source + "]", e).     }     return this. }
false;public;0;3;;public Settings settings() {     return this.settings. }
true;public;3;3;/**  * Adds mapping that will be added when the index gets created.  *  * @param type   The mapping type  * @param source The mapping source  * @param xContentType The type of content contained within the source  */ ;/**  * Adds mapping that will be added when the index gets created.  *  * @param type   The mapping type  * @param source The mapping source  * @param xContentType The type of content contained within the source  */ public PutIndexTemplateRequest mapping(String type, String source, XContentType xContentType) {     return mapping(type, new BytesArray(source), xContentType). }
true;public;1;4;/**  * The cause for this index template creation.  */ ;/**  * The cause for this index template creation.  */ public PutIndexTemplateRequest cause(String cause) {     this.cause = cause.     return this. }
false;public;0;3;;public String cause() {     return this.cause. }
true;public;2;3;/**  * Adds mapping that will be added when the index gets created.  *  * @param type   The mapping type  * @param source The mapping source  */ ;/**  * Adds mapping that will be added when the index gets created.  *  * @param type   The mapping type  * @param source The mapping source  */ public PutIndexTemplateRequest mapping(String type, XContentBuilder source) {     return mapping(type, BytesReference.bytes(source), source.contentType()). }
true;public;3;9;/**  * Adds mapping that will be added when the index gets created.  *  * @param type   The mapping type  * @param source The mapping source  * @param xContentType the source content type  */ ;/**  * Adds mapping that will be added when the index gets created.  *  * @param type   The mapping type  * @param source The mapping source  * @param xContentType the source content type  */ public PutIndexTemplateRequest mapping(String type, BytesReference source, XContentType xContentType) {     Objects.requireNonNull(xContentType).     try {         mappings.put(type, XContentHelper.convertToJson(source, false, false, xContentType)).         return this.     } catch (IOException e) {         throw new UncheckedIOException("failed to convert source to json", e).     } }
true;public;2;13;/**  * Adds mapping that will be added when the index gets created.  *  * @param type   The mapping type  * @param source The mapping source  */ ;/**  * Adds mapping that will be added when the index gets created.  *  * @param type   The mapping type  * @param source The mapping source  */ public PutIndexTemplateRequest mapping(String type, Map<String, Object> source) {     // wrap it in a type map if its not     if (source.size() != 1 || !source.containsKey(type)) {         source = MapBuilder.<String, Object>newMapBuilder().put(type, source).map().     }     try {         XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON).         builder.map(source).         return mapping(type, builder).     } catch (IOException e) {         throw new ElasticsearchGenerationException("Failed to generate [" + source + "]", e).     } }
true;public;2;4;/**  * A specialized simplified mapping source method, takes the form of simple properties definition:  * ("field1", "type=string,store=true").  */ ;/**  * A specialized simplified mapping source method, takes the form of simple properties definition:  * ("field1", "type=string,store=true").  */ public PutIndexTemplateRequest mapping(String type, Object... source) {     mapping(type, PutMappingRequest.buildFromSimplifiedDef(type, source)).     return this. }
false;public;0;3;;public Map<String, String> mappings() {     return this.mappings. }
true;public;1;7;/**  * The template source definition.  */ ;/**  * The template source definition.  */ public PutIndexTemplateRequest source(XContentBuilder templateBuilder) {     try {         return source(BytesReference.bytes(templateBuilder), templateBuilder.contentType()).     } catch (Exception e) {         throw new IllegalArgumentException("Failed to build json for template request", e).     } }
true;public;1;50;/**  * The template source definition.  */ ;/**  * The template source definition.  */ @SuppressWarnings("unchecked") public PutIndexTemplateRequest source(Map<String, Object> templateSource) {     Map<String, Object> source = templateSource.     for (Map.Entry<String, Object> entry : source.entrySet()) {         String name = entry.getKey().         if (name.equals("template")) {             // This is needed to allow for bwc (beats, logstash) with pre-5.0 templates (#21009)             if (entry.getValue() instanceof String) {                 deprecationLogger.deprecated("Deprecated field [template] used, replaced by [index_patterns]").                 patterns(Collections.singletonList((String) entry.getValue())).             }         } else if (name.equals("index_patterns")) {             if (entry.getValue() instanceof String) {                 patterns(Collections.singletonList((String) entry.getValue())).             } else if (entry.getValue() instanceof List) {                 List<String> elements = ((List<?>) entry.getValue()).stream().map(Object::toString).collect(Collectors.toList()).                 patterns(elements).             } else {                 throw new IllegalArgumentException("Malformed [template] value, should be a string or a list of strings").             }         } else if (name.equals("order")) {             order(XContentMapValues.nodeIntegerValue(entry.getValue(), order())).         } else if ("version".equals(name)) {             if ((entry.getValue() instanceof Integer) == false) {                 throw new IllegalArgumentException("Malformed [version] value, should be an integer").             }             version((Integer) entry.getValue()).         } else if (name.equals("settings")) {             if ((entry.getValue() instanceof Map) == false) {                 throw new IllegalArgumentException("Malformed [settings] section, should include an inner object").             }             settings((Map<String, Object>) entry.getValue()).         } else if (name.equals("mappings")) {             Map<String, Object> mappings = (Map<String, Object>) entry.getValue().             for (Map.Entry<String, Object> entry1 : mappings.entrySet()) {                 if (!(entry1.getValue() instanceof Map)) {                     throw new IllegalArgumentException("Malformed [mappings] section for type [" + entry1.getKey() + "], should include an inner object describing the mapping").                 }                 mapping(entry1.getKey(), (Map<String, Object>) entry1.getValue()).             }         } else if (name.equals("aliases")) {             aliases((Map<String, Object>) entry.getValue()).         } else {             throw new ElasticsearchParseException("unknown key [{}] in the template ", name).         }     }     return this. }
true;public;2;3;/**  * The template source definition.  */ ;/**  * The template source definition.  */ public PutIndexTemplateRequest source(String templateSource, XContentType xContentType) {     return source(XContentHelper.convertToMap(xContentType.xContent(), templateSource, true)). }
true;public;2;3;/**  * The template source definition.  */ ;/**  * The template source definition.  */ public PutIndexTemplateRequest source(byte[] source, XContentType xContentType) {     return source(source, 0, source.length, xContentType). }
true;public;4;3;/**  * The template source definition.  */ ;/**  * The template source definition.  */ public PutIndexTemplateRequest source(byte[] source, int offset, int length, XContentType xContentType) {     return source(new BytesArray(source, offset, length), xContentType). }
true;public;2;3;/**  * The template source definition.  */ ;/**  * The template source definition.  */ public PutIndexTemplateRequest source(BytesReference source, XContentType xContentType) {     return source(XContentHelper.convertToMap(source, true, xContentType).v2()). }
false;public;0;3;;public Set<Alias> aliases() {     return this.aliases. }
true;public;1;9;/**  * Sets the aliases that will be associated with the index when it gets created  */ ;/**  * Sets the aliases that will be associated with the index when it gets created  */ public PutIndexTemplateRequest aliases(Map<String, ?> source) {     try {         XContentBuilder builder = XContentFactory.jsonBuilder().         builder.map(source).         return aliases(BytesReference.bytes(builder)).     } catch (IOException e) {         throw new ElasticsearchGenerationException("Failed to generate [" + source + "]", e).     } }
true;public;1;3;/**  * Sets the aliases that will be associated with the index when it gets created  */ ;/**  * Sets the aliases that will be associated with the index when it gets created  */ public PutIndexTemplateRequest aliases(XContentBuilder source) {     return aliases(BytesReference.bytes(source)). }
true;public;1;3;/**  * Sets the aliases that will be associated with the index when it gets created  */ ;/**  * Sets the aliases that will be associated with the index when it gets created  */ public PutIndexTemplateRequest aliases(String source) {     return aliases(new BytesArray(source)). }
true;public;1;14;/**  * Sets the aliases that will be associated with the index when it gets created  */ ;/**  * Sets the aliases that will be associated with the index when it gets created  */ public PutIndexTemplateRequest aliases(BytesReference source) {     // EMPTY is safe here because we never call namedObject     try (XContentParser parser = XContentHelper.createParser(NamedXContentRegistry.EMPTY, LoggingDeprecationHandler.INSTANCE, source)) {         // move to the first alias         parser.nextToken().         while ((parser.nextToken()) != XContentParser.Token.END_OBJECT) {             alias(Alias.fromXContent(parser)).         }         return this.     } catch (IOException e) {         throw new ElasticsearchParseException("Failed to parse aliases", e).     } }
true;public;1;4;/**  * Adds an alias that will be added when the index gets created.  *  * @param alias   The metadata for the new alias  * @return  the index template creation request  */ ;/**  * Adds an alias that will be added when the index gets created.  *  * @param alias   The metadata for the new alias  * @return  the index template creation request  */ public PutIndexTemplateRequest alias(Alias alias) {     aliases.add(alias).     return this. }
false;public;0;4;;@Override public String[] indices() {     return indexPatterns.toArray(new String[indexPatterns.size()]). }
false;public;0;4;;@Override public IndicesOptions indicesOptions() {     return IndicesOptions.strictExpand(). }
false;public;1;34;;@Override public void readFrom(StreamInput in) throws IOException {     super.readFrom(in).     cause = in.readString().     name = in.readString().     if (in.getVersion().onOrAfter(Version.V_6_0_0_alpha1)) {         indexPatterns = in.readStringList().     } else {         indexPatterns = Collections.singletonList(in.readString()).     }     order = in.readInt().     create = in.readBoolean().     settings = readSettingsFromStream(in).     int size = in.readVInt().     for (int i = 0. i < size. i++) {         final String type = in.readString().         String mappingSource = in.readString().         mappings.put(type, mappingSource).     }     if (in.getVersion().before(Version.V_6_5_0)) {         // Used to be used for custom index metadata         int customSize = in.readVInt().         assert customSize == 0 : "expected not to have any custom metadata".         if (customSize > 0) {             throw new IllegalStateException("unexpected custom metadata when none is supported").         }     }     int aliasesSize = in.readVInt().     for (int i = 0. i < aliasesSize. i++) {         aliases.add(Alias.read(in)).     }     version = in.readOptionalVInt(). }
false;public;1;27;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeString(cause).     out.writeString(name).     if (out.getVersion().onOrAfter(Version.V_6_0_0_alpha1)) {         out.writeStringCollection(indexPatterns).     } else {         out.writeString(indexPatterns.size() > 0 ? indexPatterns.get(0) : "").     }     out.writeInt(order).     out.writeBoolean(create).     writeSettingsToStream(settings, out).     out.writeVInt(mappings.size()).     for (Map.Entry<String, String> entry : mappings.entrySet()) {         out.writeString(entry.getKey()).         out.writeString(entry.getValue()).     }     if (out.getVersion().before(Version.V_6_5_0)) {         out.writeVInt(0).     }     out.writeVInt(aliases.size()).     for (Alias alias : aliases) {         alias.writeTo(out).     }     out.writeOptionalVInt(version). }
false;public;2;30;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.field("index_patterns", indexPatterns).     builder.field("order", order).     if (version != null) {         builder.field("version", version).     }     builder.startObject("settings").     settings.toXContent(builder, params).     builder.endObject().     builder.startObject("mappings").     for (Map.Entry<String, String> entry : mappings.entrySet()) {         builder.field(entry.getKey()).         try (XContentParser parser = JsonXContent.jsonXContent.createParser(NamedXContentRegistry.EMPTY, DeprecationHandler.THROW_UNSUPPORTED_OPERATION, entry.getValue())) {             builder.copyCurrentStructure(parser).         }     }     builder.endObject().     builder.startObject("aliases").     for (Alias alias : aliases) {         alias.toXContent(builder, params).     }     builder.endObject().     return builder. }
