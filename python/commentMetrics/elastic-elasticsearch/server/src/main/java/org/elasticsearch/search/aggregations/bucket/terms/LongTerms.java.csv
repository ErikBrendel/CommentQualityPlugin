commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;4;;@Override protected void writeTermTo(StreamOutput out) throws IOException {     out.writeLong(term). }
false;public;0;4;;@Override public String getKeyAsString() {     return format.format(term).toString(). }
false;public;0;4;;@Override public Object getKey() {     return term. }
false;public;0;4;;@Override public Number getKeyAsNumber() {     return term. }
false;public;1;4;;@Override public int compareKey(Bucket other) {     return Long.compare(term, other.term). }
false;;3;4;;@Override Bucket newBucket(long docCount, InternalAggregations aggs, long docCountError) {     return new Bucket(term, docCount, aggs, showDocCountError, docCountError, format). }
false;protected,final;1;8;;@Override protected final XContentBuilder keyToXContent(XContentBuilder builder) throws IOException {     builder.field(CommonFields.KEY.getPreferredName(), term).     if (format != DocValueFormat.RAW) {         builder.field(CommonFields.KEY_AS_STRING.getPreferredName(), format.format(term).toString()).     }     return builder. }
false;public;1;4;;@Override public boolean equals(Object obj) {     return super.equals(obj) && Objects.equals(term, ((Bucket) obj).term). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(super.hashCode(), term). }
false;public;0;4;;@Override public String getWriteableName() {     return NAME. }
false;public;1;5;;@Override public LongTerms create(List<Bucket> buckets) {     return new LongTerms(name, order, requiredSize, minDocCount, pipelineAggregators(), metaData, format, shardSize, showTermDocCountError, otherDocCount, buckets, docCountError). }
false;public;2;5;;@Override public Bucket createBucket(InternalAggregations aggregations, Bucket prototype) {     return new Bucket(prototype.term, prototype.docCount, aggregations, prototype.showDocCountError, prototype.docCountError, prototype.format). }
false;protected;4;5;;@Override protected LongTerms create(String name, List<Bucket> buckets, long docCountError, long otherDocCount) {     return new LongTerms(name, order, requiredSize, minDocCount, pipelineAggregators(), getMetaData(), format, shardSize, showTermDocCountError, otherDocCount, buckets, docCountError). }
false;protected;1;4;;@Override protected Bucket[] createBucketsArray(int size) {     return new Bucket[size]. }
false;public;2;9;;@Override public InternalAggregation doReduce(List<InternalAggregation> aggregations, ReduceContext reduceContext) {     for (InternalAggregation agg : aggregations) {         if (agg instanceof DoubleTerms) {             return agg.doReduce(aggregations, reduceContext).         }     }     return super.doReduce(aggregations, reduceContext). }
true;static;2;14;/**  * Converts a {@link LongTerms} into a {@link DoubleTerms}, returning the value of the specified long terms as doubles.  */ ;/**  * Converts a {@link LongTerms} into a {@link DoubleTerms}, returning the value of the specified long terms as doubles.  */ static DoubleTerms convertLongTermsToDouble(LongTerms longTerms, DocValueFormat decimalFormat) {     List<LongTerms.Bucket> buckets = longTerms.getBuckets().     List<DoubleTerms.Bucket> newBuckets = new ArrayList<>().     for (Terms.Bucket bucket : buckets) {         newBuckets.add(new DoubleTerms.Bucket(bucket.getKeyAsNumber().doubleValue(), bucket.getDocCount(), (InternalAggregations) bucket.getAggregations(), longTerms.showTermDocCountError, longTerms.showTermDocCountError ? bucket.getDocCountError() : 0, decimalFormat)).     }     return new DoubleTerms(longTerms.getName(), longTerms.order, longTerms.requiredSize, longTerms.minDocCount, longTerms.pipelineAggregators(), longTerms.metaData, longTerms.format, longTerms.shardSize, longTerms.showTermDocCountError, longTerms.otherDocCount, newBuckets, longTerms.docCountError). }
