commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public String getClusterName() {     return clusterName. }
true;;0;3;// package private for testing ;// package private for testing ClusterStateHealth getClusterStateHealth() {     return clusterStateHealth. }
false;public;0;3;;public int getActiveShards() {     return clusterStateHealth.getActiveShards(). }
false;public;0;3;;public int getRelocatingShards() {     return clusterStateHealth.getRelocatingShards(). }
false;public;0;3;;public int getActivePrimaryShards() {     return clusterStateHealth.getActivePrimaryShards(). }
false;public;0;3;;public int getInitializingShards() {     return clusterStateHealth.getInitializingShards(). }
false;public;0;3;;public int getUnassignedShards() {     return clusterStateHealth.getUnassignedShards(). }
false;public;0;3;;public int getNumberOfNodes() {     return clusterStateHealth.getNumberOfNodes(). }
false;public;0;3;;public int getNumberOfDataNodes() {     return clusterStateHealth.getNumberOfDataNodes(). }
false;public;0;3;;public int getNumberOfPendingTasks() {     return this.numberOfPendingTasks. }
false;public;0;3;;public int getNumberOfInFlightFetch() {     return this.numberOfInFlightFetch. }
true;public;0;3;/**  * The number of unassigned shards that are currently being delayed (for example,  * due to node leaving the cluster and waiting for a timeout for the node to come  * back in order to allocate the shards back to it).  */ ;/**  * The number of unassigned shards that are currently being delayed (for example,  * due to node leaving the cluster and waiting for a timeout for the node to come  * back in order to allocate the shards back to it).  */ public int getDelayedUnassignedShards() {     return this.delayedUnassignedShards. }
true;public;0;3;/**  * {@code true} if the waitForXXX has timeout out and did not match.  */ ;/**  * {@code true} if the waitForXXX has timeout out and did not match.  */ public boolean isTimedOut() {     return this.timedOut. }
false;public;1;3;;public void setTimedOut(boolean timedOut) {     this.timedOut = timedOut. }
false;public;0;3;;public ClusterHealthStatus getStatus() {     return clusterHealthStatus. }
true;public;1;6;/**  * Allows to explicitly override the derived cluster health status.  *  * @param status The override status. Must not be null.  */ ;/**  * Allows to explicitly override the derived cluster health status.  *  * @param status The override status. Must not be null.  */ public void setStatus(ClusterHealthStatus status) {     if (status == null) {         throw new IllegalArgumentException("'status' must not be null").     }     this.clusterHealthStatus = status. }
false;public;0;3;;public Map<String, ClusterIndexHealth> getIndices() {     return clusterStateHealth.getIndices(). }
true;public;0;3;/**  * @return The maximum wait time of all tasks in the queue  */ ;/**  * @return The maximum wait time of all tasks in the queue  */ public TimeValue getTaskMaxWaitingTime() {     return taskMaxWaitingTime. }
true;public;0;3;/**  * The percentage of active shards, should be 100% in a green system  */ ;/**  * The percentage of active shards, should be 100% in a green system  */ public double getActiveShardsPercent() {     return clusterStateHealth.getActiveShardsPercent(). }
false;public,static;1;5;;public static ClusterHealthResponse readResponseFrom(StreamInput in) throws IOException {     ClusterHealthResponse response = new ClusterHealthResponse().     response.readFrom(in).     return response. }
false;public;1;12;;@Override public void readFrom(StreamInput in) throws IOException {     super.readFrom(in).     clusterName = in.readString().     clusterHealthStatus = ClusterHealthStatus.fromValue(in.readByte()).     clusterStateHealth = new ClusterStateHealth(in).     numberOfPendingTasks = in.readInt().     timedOut = in.readBoolean().     numberOfInFlightFetch = in.readInt().     delayedUnassignedShards = in.readInt().     taskMaxWaitingTime = in.readTimeValue(). }
false;public;1;12;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeString(clusterName).     out.writeByte(clusterHealthStatus.value()).     clusterStateHealth.writeTo(out).     out.writeInt(numberOfPendingTasks).     out.writeBoolean(timedOut).     out.writeInt(numberOfInFlightFetch).     out.writeInt(delayedUnassignedShards).     out.writeTimeValue(taskMaxWaitingTime). }
false;public;0;4;;@Override public String toString() {     return Strings.toString(this). }
false;public;0;4;;@Override public RestStatus status() {     return isTimedOut() ? RestStatus.REQUEST_TIMEOUT : RestStatus.OK. }
false;public;2;32;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     builder.field(CLUSTER_NAME, getClusterName()).     builder.field(STATUS, getStatus().name().toLowerCase(Locale.ROOT)).     builder.field(TIMED_OUT, isTimedOut()).     builder.field(NUMBER_OF_NODES, getNumberOfNodes()).     builder.field(NUMBER_OF_DATA_NODES, getNumberOfDataNodes()).     builder.field(ACTIVE_PRIMARY_SHARDS, getActivePrimaryShards()).     builder.field(ACTIVE_SHARDS, getActiveShards()).     builder.field(RELOCATING_SHARDS, getRelocatingShards()).     builder.field(INITIALIZING_SHARDS, getInitializingShards()).     builder.field(UNASSIGNED_SHARDS, getUnassignedShards()).     builder.field(DELAYED_UNASSIGNED_SHARDS, getDelayedUnassignedShards()).     builder.field(NUMBER_OF_PENDING_TASKS, getNumberOfPendingTasks()).     builder.field(NUMBER_OF_IN_FLIGHT_FETCH, getNumberOfInFlightFetch()).     builder.humanReadableField(TASK_MAX_WAIT_TIME_IN_QUEUE_IN_MILLIS, TASK_MAX_WAIT_TIME_IN_QUEUE, getTaskMaxWaitingTime()).     builder.percentageField(ACTIVE_SHARDS_PERCENT_AS_NUMBER, ACTIVE_SHARDS_PERCENT, getActiveShardsPercent()).     String level = params.param("level", "cluster").     boolean outputIndices = "indices".equals(level) || "shards".equals(level).     if (outputIndices) {         builder.startObject(INDICES).         for (ClusterIndexHealth indexHealth : clusterStateHealth.getIndices().values()) {             indexHealth.toXContent(builder, params).         }         builder.endObject().     }     builder.endObject().     return builder. }
false;public,static;1;3;;public static ClusterHealthResponse fromXContent(XContentParser parser) {     return PARSER.apply(parser, null). }
false;public;1;14;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     ClusterHealthResponse that = (ClusterHealthResponse) o.     return Objects.equals(clusterName, that.clusterName) && numberOfPendingTasks == that.numberOfPendingTasks && numberOfInFlightFetch == that.numberOfInFlightFetch && delayedUnassignedShards == that.delayedUnassignedShards && Objects.equals(taskMaxWaitingTime, that.taskMaxWaitingTime) && timedOut == that.timedOut && Objects.equals(clusterStateHealth, that.clusterStateHealth) && clusterHealthStatus == that.clusterHealthStatus. }
false;public;0;5;;@Override public int hashCode() {     return Objects.hash(clusterName, numberOfPendingTasks, numberOfInFlightFetch, delayedUnassignedShards, taskMaxWaitingTime, timedOut, clusterStateHealth, clusterHealthStatus). }
