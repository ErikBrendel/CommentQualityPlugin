commented;modifiers;parameterAmount;loc;comment;code
true;synchronized;1;3;/**  * Updates the number of soft-deleted documents prior to the global checkpoint to be retained  * See {@link org.elasticsearch.index.IndexSettings#INDEX_SOFT_DELETES_RETENTION_OPERATIONS_SETTING}  */ ;/**  * Updates the number of soft-deleted documents prior to the global checkpoint to be retained  * See {@link org.elasticsearch.index.IndexSettings#INDEX_SOFT_DELETES_RETENTION_OPERATIONS_SETTING}  */ synchronized void setRetentionOperations(long retentionOperations) {     this.retentionOperations = retentionOperations. }
true;synchronized;1;7;/**  * Sets the local checkpoint of the current safe commit  */ ;/**  * Sets the local checkpoint of the current safe commit  */ synchronized void setLocalCheckpointOfSafeCommit(long newCheckpoint) {     if (newCheckpoint < this.localCheckpointOfSafeCommit) {         throw new IllegalArgumentException("Local checkpoint can't go backwards. " + "new checkpoint [" + newCheckpoint + "]," + "current checkpoint [" + localCheckpointOfSafeCommit + "]").     }     this.localCheckpointOfSafeCommit = newCheckpoint. }
true;synchronized;0;10;/**  * Acquires a lock on soft-deleted documents to prevent them from cleaning up in merge processes. This is necessary to  * make sure that all operations that are being retained will be retained until the lock is released.  * This is a analogy to the translog's retention lock. see {@link Translog#acquireRetentionLock()}  */ ;/**  * Acquires a lock on soft-deleted documents to prevent them from cleaning up in merge processes. This is necessary to  * make sure that all operations that are being retained will be retained until the lock is released.  * This is a analogy to the translog's retention lock. see {@link Translog#acquireRetentionLock()}  */ synchronized Releasable acquireRetentionLock() {     assert retentionLockCount >= 0 : "Invalid number of retention locks [" + retentionLockCount + "]".     retentionLockCount++.     final AtomicBoolean released = new AtomicBoolean().     return () -> {         if (released.compareAndSet(false, true)) {             releaseRetentionLock().         }     }. }
false;private,synchronized;0;4;;private synchronized void releaseRetentionLock() {     assert retentionLockCount > 0 : "Invalid number of retention locks [" + retentionLockCount + "]".     retentionLockCount--. }
true;synchronized;0;43;/**  * Returns the min seqno that is retained in the Lucene index.  * Operations whose seq# is least this value should exist in the Lucene index.  */ ;/**  * Returns the min seqno that is retained in the Lucene index.  * Operations whose seq# is least this value should exist in the Lucene index.  */ synchronized long getMinRetainedSeqNo() {     /*          * When an engine is flushed, we need to provide it the latest collection of retention leases even when the soft deletes policy is          * locked for peer recovery.          */     final RetentionLeases retentionLeases = retentionLeasesSupplier.get().     // do not advance if the retention lock is held     if (retentionLockCount == 0) {         /*              * This policy retains operations for two purposes: peer-recovery and querying changes history.              *  - Peer-recovery is driven by the local checkpoint of the safe commit. In peer-recovery, the primary transfers a safe commit,              *    then sends operations after the local checkpoint of that commit. This requires keeping all ops after              *    localCheckpointOfSafeCommit.              *  - Changes APIs are driven by a combination of the global checkpoint, retention operations, and retention leases. Here we              *    prefer using the global checkpoint instead of the maximum sequence number because only operations up to the global              *    checkpoint are exposed in the the changes APIs.              */         // calculate the minimum sequence number to retain based on retention leases         final long minimumRetainingSequenceNumber = retentionLeases.leases().stream().mapToLong(RetentionLease::retainingSequenceNumber).min().orElse(Long.MAX_VALUE).         /*              * The minimum sequence number to retain is the minimum of the minimum based on retention leases, and the number of operations              * below the global checkpoint to retain (index.soft_deletes.retention.operations). The additional increments on the global              * checkpoint and the local checkpoint of the safe commit are due to the fact that we want to retain all operations above              * those checkpoints.              */         final long minSeqNoForQueryingChanges = Math.min(1 + globalCheckpointSupplier.getAsLong() - retentionOperations, minimumRetainingSequenceNumber).         final long minSeqNoToRetain = Math.min(minSeqNoForQueryingChanges, 1 + localCheckpointOfSafeCommit).         /*              * We take the maximum as minSeqNoToRetain can go backward as the retention operations value can be changed in settings, or from              * the addition of leases with a retaining sequence number lower than previous retaining sequence numbers.              */         minRetainedSeqNo = Math.max(minRetainedSeqNo, minSeqNoToRetain).     }     return minRetainedSeqNo. }
true;;0;3;/**  * Returns a soft-deletes retention query that will be used in {@link org.apache.lucene.index.SoftDeletesRetentionMergePolicy}  * Documents including tombstones are soft-deleted and matched this query will be retained and won't cleaned up by merges.  */ ;/**  * Returns a soft-deletes retention query that will be used in {@link org.apache.lucene.index.SoftDeletesRetentionMergePolicy}  * Documents including tombstones are soft-deleted and matched this query will be retained and won't cleaned up by merges.  */ Query getRetentionQuery() {     return LongPoint.newRangeQuery(SeqNoFieldMapper.NAME, getMinRetainedSeqNo(), Long.MAX_VALUE). }
