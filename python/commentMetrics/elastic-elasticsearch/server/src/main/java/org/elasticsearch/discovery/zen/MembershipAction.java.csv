# id;timestamp;commentText;codeText;commentWords;codeWords
MembershipAction -> static void ensureIndexCompatibility(final Version nodeVersion, MetaData metaData);1524684173;Ensures that all indices are compatible with the given node version. This will ensure that all indices in the given metadata_will not be created with a newer version of elasticsearch as well as that all indices are newer or equal to the minimum index_compatibility version._@see Version#minimumIndexCompatibilityVersion()_@throws IllegalStateException if any index is incompatible with the given version;static void ensureIndexCompatibility(final Version nodeVersion, MetaData metaData) {_        Version supportedIndexVersion = nodeVersion.minimumIndexCompatibilityVersion()__        _        _        for (IndexMetaData idxMetaData : metaData) {_            if (idxMetaData.getCreationVersion().after(nodeVersion)) {_                throw new IllegalStateException("index " + idxMetaData.getIndex() + " version not supported: "_                    + idxMetaData.getCreationVersion() + " the node version is: " + nodeVersion)__            }_            if (idxMetaData.getCreationVersion().before(supportedIndexVersion)) {_                throw new IllegalStateException("index " + idxMetaData.getIndex() + " version not supported: "_                    + idxMetaData.getCreationVersion() + " minimum compatible index version is: " + supportedIndexVersion)__            }_        }_    };ensures,that,all,indices,are,compatible,with,the,given,node,version,this,will,ensure,that,all,indices,in,the,given,metadata,will,not,be,created,with,a,newer,version,of,elasticsearch,as,well,as,that,all,indices,are,newer,or,equal,to,the,minimum,index,compatibility,version,see,version,minimum,index,compatibility,version,throws,illegal,state,exception,if,any,index,is,incompatible,with,the,given,version;static,void,ensure,index,compatibility,final,version,node,version,meta,data,meta,data,version,supported,index,version,node,version,minimum,index,compatibility,version,for,index,meta,data,idx,meta,data,meta,data,if,idx,meta,data,get,creation,version,after,node,version,throw,new,illegal,state,exception,index,idx,meta,data,get,index,version,not,supported,idx,meta,data,get,creation,version,the,node,version,is,node,version,if,idx,meta,data,get,creation,version,before,supported,index,version,throw,new,illegal,state,exception,index,idx,meta,data,get,index,version,not,supported,idx,meta,data,get,creation,version,minimum,compatible,index,version,is,supported,index,version
MembershipAction -> static void ensureIndexCompatibility(final Version nodeVersion, MetaData metaData);1529687475;Ensures that all indices are compatible with the given node version. This will ensure that all indices in the given metadata_will not be created with a newer version of elasticsearch as well as that all indices are newer or equal to the minimum index_compatibility version._@see Version#minimumIndexCompatibilityVersion()_@throws IllegalStateException if any index is incompatible with the given version;static void ensureIndexCompatibility(final Version nodeVersion, MetaData metaData) {_        Version supportedIndexVersion = nodeVersion.minimumIndexCompatibilityVersion()__        _        _        for (IndexMetaData idxMetaData : metaData) {_            if (idxMetaData.getCreationVersion().after(nodeVersion)) {_                throw new IllegalStateException("index " + idxMetaData.getIndex() + " version not supported: "_                    + idxMetaData.getCreationVersion() + " the node version is: " + nodeVersion)__            }_            if (idxMetaData.getCreationVersion().before(supportedIndexVersion)) {_                throw new IllegalStateException("index " + idxMetaData.getIndex() + " version not supported: "_                    + idxMetaData.getCreationVersion() + " minimum compatible index version is: " + supportedIndexVersion)__            }_        }_    };ensures,that,all,indices,are,compatible,with,the,given,node,version,this,will,ensure,that,all,indices,in,the,given,metadata,will,not,be,created,with,a,newer,version,of,elasticsearch,as,well,as,that,all,indices,are,newer,or,equal,to,the,minimum,index,compatibility,version,see,version,minimum,index,compatibility,version,throws,illegal,state,exception,if,any,index,is,incompatible,with,the,given,version;static,void,ensure,index,compatibility,final,version,node,version,meta,data,meta,data,version,supported,index,version,node,version,minimum,index,compatibility,version,for,index,meta,data,idx,meta,data,meta,data,if,idx,meta,data,get,creation,version,after,node,version,throw,new,illegal,state,exception,index,idx,meta,data,get,index,version,not,supported,idx,meta,data,get,creation,version,the,node,version,is,node,version,if,idx,meta,data,get,creation,version,before,supported,index,version,throw,new,illegal,state,exception,index,idx,meta,data,get,index,version,not,supported,idx,meta,data,get,creation,version,minimum,compatible,index,version,is,supported,index,version
MembershipAction -> static void ensureIndexCompatibility(final Version nodeVersion, MetaData metaData);1541092382;Ensures that all indices are compatible with the given node version. This will ensure that all indices in the given metadata_will not be created with a newer version of elasticsearch as well as that all indices are newer or equal to the minimum index_compatibility version._@see Version#minimumIndexCompatibilityVersion()_@throws IllegalStateException if any index is incompatible with the given version;static void ensureIndexCompatibility(final Version nodeVersion, MetaData metaData) {_        Version supportedIndexVersion = nodeVersion.minimumIndexCompatibilityVersion()__        _        _        for (IndexMetaData idxMetaData : metaData) {_            if (idxMetaData.getCreationVersion().after(nodeVersion)) {_                throw new IllegalStateException("index " + idxMetaData.getIndex() + " version not supported: "_                    + idxMetaData.getCreationVersion() + " the node version is: " + nodeVersion)__            }_            if (idxMetaData.getCreationVersion().before(supportedIndexVersion)) {_                throw new IllegalStateException("index " + idxMetaData.getIndex() + " version not supported: "_                    + idxMetaData.getCreationVersion() + " minimum compatible index version is: " + supportedIndexVersion)__            }_        }_    };ensures,that,all,indices,are,compatible,with,the,given,node,version,this,will,ensure,that,all,indices,in,the,given,metadata,will,not,be,created,with,a,newer,version,of,elasticsearch,as,well,as,that,all,indices,are,newer,or,equal,to,the,minimum,index,compatibility,version,see,version,minimum,index,compatibility,version,throws,illegal,state,exception,if,any,index,is,incompatible,with,the,given,version;static,void,ensure,index,compatibility,final,version,node,version,meta,data,meta,data,version,supported,index,version,node,version,minimum,index,compatibility,version,for,index,meta,data,idx,meta,data,meta,data,if,idx,meta,data,get,creation,version,after,node,version,throw,new,illegal,state,exception,index,idx,meta,data,get,index,version,not,supported,idx,meta,data,get,creation,version,the,node,version,is,node,version,if,idx,meta,data,get,creation,version,before,supported,index,version,throw,new,illegal,state,exception,index,idx,meta,data,get,index,version,not,supported,idx,meta,data,get,creation,version,minimum,compatible,index,version,is,supported,index,version
MembershipAction -> static void ensureIndexCompatibility(final Version nodeVersion, MetaData metaData);1542402632;Ensures that all indices are compatible with the given node version. This will ensure that all indices in the given metadata_will not be created with a newer version of elasticsearch as well as that all indices are newer or equal to the minimum index_compatibility version._@see Version#minimumIndexCompatibilityVersion()_@throws IllegalStateException if any index is incompatible with the given version;static void ensureIndexCompatibility(final Version nodeVersion, MetaData metaData) {_        Version supportedIndexVersion = nodeVersion.minimumIndexCompatibilityVersion()__        _        _        for (IndexMetaData idxMetaData : metaData) {_            if (idxMetaData.getCreationVersion().after(nodeVersion)) {_                throw new IllegalStateException("index " + idxMetaData.getIndex() + " version not supported: "_                    + idxMetaData.getCreationVersion() + " the node version is: " + nodeVersion)__            }_            if (idxMetaData.getCreationVersion().before(supportedIndexVersion)) {_                throw new IllegalStateException("index " + idxMetaData.getIndex() + " version not supported: "_                    + idxMetaData.getCreationVersion() + " minimum compatible index version is: " + supportedIndexVersion)__            }_        }_    };ensures,that,all,indices,are,compatible,with,the,given,node,version,this,will,ensure,that,all,indices,in,the,given,metadata,will,not,be,created,with,a,newer,version,of,elasticsearch,as,well,as,that,all,indices,are,newer,or,equal,to,the,minimum,index,compatibility,version,see,version,minimum,index,compatibility,version,throws,illegal,state,exception,if,any,index,is,incompatible,with,the,given,version;static,void,ensure,index,compatibility,final,version,node,version,meta,data,meta,data,version,supported,index,version,node,version,minimum,index,compatibility,version,for,index,meta,data,idx,meta,data,meta,data,if,idx,meta,data,get,creation,version,after,node,version,throw,new,illegal,state,exception,index,idx,meta,data,get,index,version,not,supported,idx,meta,data,get,creation,version,the,node,version,is,node,version,if,idx,meta,data,get,creation,version,before,supported,index,version,throw,new,illegal,state,exception,index,idx,meta,data,get,index,version,not,supported,idx,meta,data,get,creation,version,minimum,compatible,index,version,is,supported,index,version
MembershipAction -> static void ensureNodesCompatibility(final Version joiningNodeVersion, DiscoveryNodes currentNodes);1524684173;ensures that the joining node has a version that's compatible with all current nodes;static void ensureNodesCompatibility(final Version joiningNodeVersion, DiscoveryNodes currentNodes) {_        final Version minNodeVersion = currentNodes.getMinNodeVersion()__        final Version maxNodeVersion = currentNodes.getMaxNodeVersion()__        ensureNodesCompatibility(joiningNodeVersion, minNodeVersion, maxNodeVersion)__    };ensures,that,the,joining,node,has,a,version,that,s,compatible,with,all,current,nodes;static,void,ensure,nodes,compatibility,final,version,joining,node,version,discovery,nodes,current,nodes,final,version,min,node,version,current,nodes,get,min,node,version,final,version,max,node,version,current,nodes,get,max,node,version,ensure,nodes,compatibility,joining,node,version,min,node,version,max,node,version
MembershipAction -> static void ensureNodesCompatibility(final Version joiningNodeVersion, DiscoveryNodes currentNodes);1529687475;ensures that the joining node has a version that's compatible with all current nodes;static void ensureNodesCompatibility(final Version joiningNodeVersion, DiscoveryNodes currentNodes) {_        final Version minNodeVersion = currentNodes.getMinNodeVersion()__        final Version maxNodeVersion = currentNodes.getMaxNodeVersion()__        ensureNodesCompatibility(joiningNodeVersion, minNodeVersion, maxNodeVersion)__    };ensures,that,the,joining,node,has,a,version,that,s,compatible,with,all,current,nodes;static,void,ensure,nodes,compatibility,final,version,joining,node,version,discovery,nodes,current,nodes,final,version,min,node,version,current,nodes,get,min,node,version,final,version,max,node,version,current,nodes,get,max,node,version,ensure,nodes,compatibility,joining,node,version,min,node,version,max,node,version
MembershipAction -> static void ensureNodesCompatibility(final Version joiningNodeVersion, DiscoveryNodes currentNodes);1541092382;ensures that the joining node has a version that's compatible with all current nodes;static void ensureNodesCompatibility(final Version joiningNodeVersion, DiscoveryNodes currentNodes) {_        final Version minNodeVersion = currentNodes.getMinNodeVersion()__        final Version maxNodeVersion = currentNodes.getMaxNodeVersion()__        ensureNodesCompatibility(joiningNodeVersion, minNodeVersion, maxNodeVersion)__    };ensures,that,the,joining,node,has,a,version,that,s,compatible,with,all,current,nodes;static,void,ensure,nodes,compatibility,final,version,joining,node,version,discovery,nodes,current,nodes,final,version,min,node,version,current,nodes,get,min,node,version,final,version,max,node,version,current,nodes,get,max,node,version,ensure,nodes,compatibility,joining,node,version,min,node,version,max,node,version
MembershipAction -> static void ensureNodesCompatibility(final Version joiningNodeVersion, DiscoveryNodes currentNodes);1542402632;ensures that the joining node has a version that's compatible with all current nodes;static void ensureNodesCompatibility(final Version joiningNodeVersion, DiscoveryNodes currentNodes) {_        final Version minNodeVersion = currentNodes.getMinNodeVersion()__        final Version maxNodeVersion = currentNodes.getMaxNodeVersion()__        ensureNodesCompatibility(joiningNodeVersion, minNodeVersion, maxNodeVersion)__    };ensures,that,the,joining,node,has,a,version,that,s,compatible,with,all,current,nodes;static,void,ensure,nodes,compatibility,final,version,joining,node,version,discovery,nodes,current,nodes,final,version,min,node,version,current,nodes,get,min,node,version,final,version,max,node,version,current,nodes,get,max,node,version,ensure,nodes,compatibility,joining,node,version,min,node,version,max,node,version
MembershipAction -> static void ensureMajorVersionBarrier(Version joiningNodeVersion, Version minClusterNodeVersion);1524684173;ensures that the joining node's major version is equal or higher to the minClusterNodeVersion. This is needed_to ensure that if the master is already fully operating under the new major version, it doesn't go back to mixed_version mode;static void ensureMajorVersionBarrier(Version joiningNodeVersion, Version minClusterNodeVersion) {_        final byte clusterMajor = minClusterNodeVersion.major__        if (joiningNodeVersion.major < clusterMajor) {_            throw new IllegalStateException("node version [" + joiningNodeVersion + "] is not supported. " +_                "All nodes in the cluster are of a higher major [" + clusterMajor + "].")__        }_    };ensures,that,the,joining,node,s,major,version,is,equal,or,higher,to,the,min,cluster,node,version,this,is,needed,to,ensure,that,if,the,master,is,already,fully,operating,under,the,new,major,version,it,doesn,t,go,back,to,mixed,version,mode;static,void,ensure,major,version,barrier,version,joining,node,version,version,min,cluster,node,version,final,byte,cluster,major,min,cluster,node,version,major,if,joining,node,version,major,cluster,major,throw,new,illegal,state,exception,node,version,joining,node,version,is,not,supported,all,nodes,in,the,cluster,are,of,a,higher,major,cluster,major
MembershipAction -> static void ensureMajorVersionBarrier(Version joiningNodeVersion, Version minClusterNodeVersion);1529687475;ensures that the joining node's major version is equal or higher to the minClusterNodeVersion. This is needed_to ensure that if the master is already fully operating under the new major version, it doesn't go back to mixed_version mode;static void ensureMajorVersionBarrier(Version joiningNodeVersion, Version minClusterNodeVersion) {_        final byte clusterMajor = minClusterNodeVersion.major__        if (joiningNodeVersion.major < clusterMajor) {_            throw new IllegalStateException("node version [" + joiningNodeVersion + "] is not supported. " +_                "All nodes in the cluster are of a higher major [" + clusterMajor + "].")__        }_    };ensures,that,the,joining,node,s,major,version,is,equal,or,higher,to,the,min,cluster,node,version,this,is,needed,to,ensure,that,if,the,master,is,already,fully,operating,under,the,new,major,version,it,doesn,t,go,back,to,mixed,version,mode;static,void,ensure,major,version,barrier,version,joining,node,version,version,min,cluster,node,version,final,byte,cluster,major,min,cluster,node,version,major,if,joining,node,version,major,cluster,major,throw,new,illegal,state,exception,node,version,joining,node,version,is,not,supported,all,nodes,in,the,cluster,are,of,a,higher,major,cluster,major
MembershipAction -> static void ensureMajorVersionBarrier(Version joiningNodeVersion, Version minClusterNodeVersion);1541092382;ensures that the joining node's major version is equal or higher to the minClusterNodeVersion. This is needed_to ensure that if the master is already fully operating under the new major version, it doesn't go back to mixed_version mode;static void ensureMajorVersionBarrier(Version joiningNodeVersion, Version minClusterNodeVersion) {_        final byte clusterMajor = minClusterNodeVersion.major__        if (joiningNodeVersion.major < clusterMajor) {_            throw new IllegalStateException("node version [" + joiningNodeVersion + "] is not supported. " +_                "All nodes in the cluster are of a higher major [" + clusterMajor + "].")__        }_    };ensures,that,the,joining,node,s,major,version,is,equal,or,higher,to,the,min,cluster,node,version,this,is,needed,to,ensure,that,if,the,master,is,already,fully,operating,under,the,new,major,version,it,doesn,t,go,back,to,mixed,version,mode;static,void,ensure,major,version,barrier,version,joining,node,version,version,min,cluster,node,version,final,byte,cluster,major,min,cluster,node,version,major,if,joining,node,version,major,cluster,major,throw,new,illegal,state,exception,node,version,joining,node,version,is,not,supported,all,nodes,in,the,cluster,are,of,a,higher,major,cluster,major
MembershipAction -> static void ensureMajorVersionBarrier(Version joiningNodeVersion, Version minClusterNodeVersion);1542402632;ensures that the joining node's major version is equal or higher to the minClusterNodeVersion. This is needed_to ensure that if the master is already fully operating under the new major version, it doesn't go back to mixed_version mode;static void ensureMajorVersionBarrier(Version joiningNodeVersion, Version minClusterNodeVersion) {_        final byte clusterMajor = minClusterNodeVersion.major__        if (joiningNodeVersion.major < clusterMajor) {_            throw new IllegalStateException("node version [" + joiningNodeVersion + "] is not supported. " +_                "All nodes in the cluster are of a higher major [" + clusterMajor + "].")__        }_    };ensures,that,the,joining,node,s,major,version,is,equal,or,higher,to,the,min,cluster,node,version,this,is,needed,to,ensure,that,if,the,master,is,already,fully,operating,under,the,new,major,version,it,doesn,t,go,back,to,mixed,version,mode;static,void,ensure,major,version,barrier,version,joining,node,version,version,min,cluster,node,version,final,byte,cluster,major,min,cluster,node,version,major,if,joining,node,version,major,cluster,major,throw,new,illegal,state,exception,node,version,joining,node,version,is,not,supported,all,nodes,in,the,cluster,are,of,a,higher,major,cluster,major
MembershipAction -> static void ensureNodesCompatibility(Version joiningNodeVersion, Version minClusterNodeVersion, Version maxClusterNodeVersion);1524684173;ensures that the joining node has a version that's compatible with a given version range;static void ensureNodesCompatibility(Version joiningNodeVersion, Version minClusterNodeVersion, Version maxClusterNodeVersion) {_        assert minClusterNodeVersion.onOrBefore(maxClusterNodeVersion) : minClusterNodeVersion + " > " + maxClusterNodeVersion__        if (joiningNodeVersion.isCompatible(maxClusterNodeVersion) == false) {_            throw new IllegalStateException("node version [" + joiningNodeVersion + "] is not supported. " +_                "The cluster contains nodes with version [" + maxClusterNodeVersion + "], which is incompatible.")__        }_        if (joiningNodeVersion.isCompatible(minClusterNodeVersion) == false) {_            throw new IllegalStateException("node version [" + joiningNodeVersion + "] is not supported." +_                "The cluster contains nodes with version [" + minClusterNodeVersion + "], which is incompatible.")__        }_    };ensures,that,the,joining,node,has,a,version,that,s,compatible,with,a,given,version,range;static,void,ensure,nodes,compatibility,version,joining,node,version,version,min,cluster,node,version,version,max,cluster,node,version,assert,min,cluster,node,version,on,or,before,max,cluster,node,version,min,cluster,node,version,max,cluster,node,version,if,joining,node,version,is,compatible,max,cluster,node,version,false,throw,new,illegal,state,exception,node,version,joining,node,version,is,not,supported,the,cluster,contains,nodes,with,version,max,cluster,node,version,which,is,incompatible,if,joining,node,version,is,compatible,min,cluster,node,version,false,throw,new,illegal,state,exception,node,version,joining,node,version,is,not,supported,the,cluster,contains,nodes,with,version,min,cluster,node,version,which,is,incompatible
MembershipAction -> static void ensureNodesCompatibility(Version joiningNodeVersion, Version minClusterNodeVersion, Version maxClusterNodeVersion);1529687475;ensures that the joining node has a version that's compatible with a given version range;static void ensureNodesCompatibility(Version joiningNodeVersion, Version minClusterNodeVersion, Version maxClusterNodeVersion) {_        assert minClusterNodeVersion.onOrBefore(maxClusterNodeVersion) : minClusterNodeVersion + " > " + maxClusterNodeVersion__        if (joiningNodeVersion.isCompatible(maxClusterNodeVersion) == false) {_            throw new IllegalStateException("node version [" + joiningNodeVersion + "] is not supported. " +_                "The cluster contains nodes with version [" + maxClusterNodeVersion + "], which is incompatible.")__        }_        if (joiningNodeVersion.isCompatible(minClusterNodeVersion) == false) {_            throw new IllegalStateException("node version [" + joiningNodeVersion + "] is not supported." +_                "The cluster contains nodes with version [" + minClusterNodeVersion + "], which is incompatible.")__        }_    };ensures,that,the,joining,node,has,a,version,that,s,compatible,with,a,given,version,range;static,void,ensure,nodes,compatibility,version,joining,node,version,version,min,cluster,node,version,version,max,cluster,node,version,assert,min,cluster,node,version,on,or,before,max,cluster,node,version,min,cluster,node,version,max,cluster,node,version,if,joining,node,version,is,compatible,max,cluster,node,version,false,throw,new,illegal,state,exception,node,version,joining,node,version,is,not,supported,the,cluster,contains,nodes,with,version,max,cluster,node,version,which,is,incompatible,if,joining,node,version,is,compatible,min,cluster,node,version,false,throw,new,illegal,state,exception,node,version,joining,node,version,is,not,supported,the,cluster,contains,nodes,with,version,min,cluster,node,version,which,is,incompatible
MembershipAction -> static void ensureNodesCompatibility(Version joiningNodeVersion, Version minClusterNodeVersion, Version maxClusterNodeVersion);1541092382;ensures that the joining node has a version that's compatible with a given version range;static void ensureNodesCompatibility(Version joiningNodeVersion, Version minClusterNodeVersion, Version maxClusterNodeVersion) {_        assert minClusterNodeVersion.onOrBefore(maxClusterNodeVersion) : minClusterNodeVersion + " > " + maxClusterNodeVersion__        if (joiningNodeVersion.isCompatible(maxClusterNodeVersion) == false) {_            throw new IllegalStateException("node version [" + joiningNodeVersion + "] is not supported. " +_                "The cluster contains nodes with version [" + maxClusterNodeVersion + "], which is incompatible.")__        }_        if (joiningNodeVersion.isCompatible(minClusterNodeVersion) == false) {_            throw new IllegalStateException("node version [" + joiningNodeVersion + "] is not supported." +_                "The cluster contains nodes with version [" + minClusterNodeVersion + "], which is incompatible.")__        }_    };ensures,that,the,joining,node,has,a,version,that,s,compatible,with,a,given,version,range;static,void,ensure,nodes,compatibility,version,joining,node,version,version,min,cluster,node,version,version,max,cluster,node,version,assert,min,cluster,node,version,on,or,before,max,cluster,node,version,min,cluster,node,version,max,cluster,node,version,if,joining,node,version,is,compatible,max,cluster,node,version,false,throw,new,illegal,state,exception,node,version,joining,node,version,is,not,supported,the,cluster,contains,nodes,with,version,max,cluster,node,version,which,is,incompatible,if,joining,node,version,is,compatible,min,cluster,node,version,false,throw,new,illegal,state,exception,node,version,joining,node,version,is,not,supported,the,cluster,contains,nodes,with,version,min,cluster,node,version,which,is,incompatible
MembershipAction -> static void ensureNodesCompatibility(Version joiningNodeVersion, Version minClusterNodeVersion, Version maxClusterNodeVersion);1542402632;ensures that the joining node has a version that's compatible with a given version range;static void ensureNodesCompatibility(Version joiningNodeVersion, Version minClusterNodeVersion, Version maxClusterNodeVersion) {_        assert minClusterNodeVersion.onOrBefore(maxClusterNodeVersion) : minClusterNodeVersion + " > " + maxClusterNodeVersion__        if (joiningNodeVersion.isCompatible(maxClusterNodeVersion) == false) {_            throw new IllegalStateException("node version [" + joiningNodeVersion + "] is not supported. " +_                "The cluster contains nodes with version [" + maxClusterNodeVersion + "], which is incompatible.")__        }_        if (joiningNodeVersion.isCompatible(minClusterNodeVersion) == false) {_            throw new IllegalStateException("node version [" + joiningNodeVersion + "] is not supported." +_                "The cluster contains nodes with version [" + minClusterNodeVersion + "], which is incompatible.")__        }_    };ensures,that,the,joining,node,has,a,version,that,s,compatible,with,a,given,version,range;static,void,ensure,nodes,compatibility,version,joining,node,version,version,min,cluster,node,version,version,max,cluster,node,version,assert,min,cluster,node,version,on,or,before,max,cluster,node,version,min,cluster,node,version,max,cluster,node,version,if,joining,node,version,is,compatible,max,cluster,node,version,false,throw,new,illegal,state,exception,node,version,joining,node,version,is,not,supported,the,cluster,contains,nodes,with,version,max,cluster,node,version,which,is,incompatible,if,joining,node,version,is,compatible,min,cluster,node,version,false,throw,new,illegal,state,exception,node,version,joining,node,version,is,not,supported,the,cluster,contains,nodes,with,version,min,cluster,node,version,which,is,incompatible
MembershipAction -> public void sendValidateJoinRequestBlocking(DiscoveryNode node, ClusterState state, TimeValue timeout);1524684173;Validates the join request, throwing a failure if it failed.;public void sendValidateJoinRequestBlocking(DiscoveryNode node, ClusterState state, TimeValue timeout) {_        transportService.submitRequest(node, DISCOVERY_JOIN_VALIDATE_ACTION_NAME, new ValidateJoinRequest(state),_            EmptyTransportResponseHandler.INSTANCE_SAME).txGet(timeout.millis(), TimeUnit.MILLISECONDS)__    };validates,the,join,request,throwing,a,failure,if,it,failed;public,void,send,validate,join,request,blocking,discovery,node,node,cluster,state,state,time,value,timeout,transport,service,submit,request,node,new,validate,join,request,state,empty,transport,response,handler,tx,get,timeout,millis,time,unit,milliseconds
MembershipAction -> public void sendValidateJoinRequestBlocking(DiscoveryNode node, ClusterState state, TimeValue timeout);1529687475;Validates the join request, throwing a failure if it failed.;public void sendValidateJoinRequestBlocking(DiscoveryNode node, ClusterState state, TimeValue timeout) {_        transportService.submitRequest(node, DISCOVERY_JOIN_VALIDATE_ACTION_NAME, new ValidateJoinRequest(state),_            EmptyTransportResponseHandler.INSTANCE_SAME).txGet(timeout.millis(), TimeUnit.MILLISECONDS)__    };validates,the,join,request,throwing,a,failure,if,it,failed;public,void,send,validate,join,request,blocking,discovery,node,node,cluster,state,state,time,value,timeout,transport,service,submit,request,node,new,validate,join,request,state,empty,transport,response,handler,tx,get,timeout,millis,time,unit,milliseconds
MembershipAction -> public void sendValidateJoinRequestBlocking(DiscoveryNode node, ClusterState state, TimeValue timeout);1541092382;Validates the join request, throwing a failure if it failed.;public void sendValidateJoinRequestBlocking(DiscoveryNode node, ClusterState state, TimeValue timeout) {_        transportService.submitRequest(node, DISCOVERY_JOIN_VALIDATE_ACTION_NAME, new ValidateJoinRequest(state),_            EmptyTransportResponseHandler.INSTANCE_SAME).txGet(timeout.millis(), TimeUnit.MILLISECONDS)__    };validates,the,join,request,throwing,a,failure,if,it,failed;public,void,send,validate,join,request,blocking,discovery,node,node,cluster,state,state,time,value,timeout,transport,service,submit,request,node,new,validate,join,request,state,empty,transport,response,handler,tx,get,timeout,millis,time,unit,milliseconds
MembershipAction -> public void sendValidateJoinRequestBlocking(DiscoveryNode node, ClusterState state, TimeValue timeout);1542402632;Validates the join request, throwing a failure if it failed.;public void sendValidateJoinRequestBlocking(DiscoveryNode node, ClusterState state, TimeValue timeout) {_        transportService.submitRequest(node, DISCOVERY_JOIN_VALIDATE_ACTION_NAME, new ValidateJoinRequest(state),_            EmptyTransportResponseHandler.INSTANCE_SAME).txGet(timeout.millis(), TimeUnit.MILLISECONDS)__    };validates,the,join,request,throwing,a,failure,if,it,failed;public,void,send,validate,join,request,blocking,discovery,node,node,cluster,state,state,time,value,timeout,transport,service,submit,request,node,new,validate,join,request,state,empty,transport,response,handler,tx,get,timeout,millis,time,unit,milliseconds
MembershipAction -> public void sendValidateJoinRequestBlocking(DiscoveryNode node, ClusterState state, TimeValue timeout);1544081506;Validates the join request, throwing a failure if it failed.;public void sendValidateJoinRequestBlocking(DiscoveryNode node, ClusterState state, TimeValue timeout) {_        transportService.submitRequest(node, DISCOVERY_JOIN_VALIDATE_ACTION_NAME, new ValidateJoinRequest(state),_            EmptyTransportResponseHandler.INSTANCE_SAME).txGet(timeout.millis(), TimeUnit.MILLISECONDS)__    };validates,the,join,request,throwing,a,failure,if,it,failed;public,void,send,validate,join,request,blocking,discovery,node,node,cluster,state,state,time,value,timeout,transport,service,submit,request,node,new,validate,join,request,state,empty,transport,response,handler,tx,get,timeout,millis,time,unit,milliseconds
MembershipAction -> public void sendValidateJoinRequestBlocking(DiscoveryNode node, ClusterState state, TimeValue timeout);1544622621;Validates the join request, throwing a failure if it failed.;public void sendValidateJoinRequestBlocking(DiscoveryNode node, ClusterState state, TimeValue timeout) {_        transportService.submitRequest(node, DISCOVERY_JOIN_VALIDATE_ACTION_NAME, new ValidateJoinRequest(state),_            EmptyTransportResponseHandler.INSTANCE_SAME).txGet(timeout.millis(), TimeUnit.MILLISECONDS)__    };validates,the,join,request,throwing,a,failure,if,it,failed;public,void,send,validate,join,request,blocking,discovery,node,node,cluster,state,state,time,value,timeout,transport,service,submit,request,node,new,validate,join,request,state,empty,transport,response,handler,tx,get,timeout,millis,time,unit,milliseconds
MembershipAction -> public void sendValidateJoinRequestBlocking(DiscoveryNode node, ClusterState state, TimeValue timeout);1547121470;Validates the join request, throwing a failure if it failed.;public void sendValidateJoinRequestBlocking(DiscoveryNode node, ClusterState state, TimeValue timeout) {_        transportService.submitRequest(node, DISCOVERY_JOIN_VALIDATE_ACTION_NAME, new ValidateJoinRequest(state),_            EmptyTransportResponseHandler.INSTANCE_SAME).txGet(timeout.millis(), TimeUnit.MILLISECONDS)__    };validates,the,join,request,throwing,a,failure,if,it,failed;public,void,send,validate,join,request,blocking,discovery,node,node,cluster,state,state,time,value,timeout,transport,service,submit,request,node,new,validate,join,request,state,empty,transport,response,handler,tx,get,timeout,millis,time,unit,milliseconds
