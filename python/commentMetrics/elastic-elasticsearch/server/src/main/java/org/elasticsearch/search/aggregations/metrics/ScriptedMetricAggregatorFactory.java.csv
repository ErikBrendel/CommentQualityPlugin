commented;modifiers;parameterAmount;loc;comment;code
false;public;4;31;;@Override public Aggregator createInternal(Aggregator parent, boolean collectsFromSingleBucket, List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData) throws IOException {     if (collectsFromSingleBucket == false) {         return asMultiBucketAggregator(this, context, parent).     }     Map<String, Object> aggParams = this.aggParams.     if (aggParams != null) {         aggParams = deepCopyParams(aggParams, context).     } else {         aggParams = new HashMap<>().     }     Map<String, Object> aggState = new HashMap<String, Object>().     final ScriptedMetricAggContexts.InitScript initScript = this.initScript.newInstance(mergeParams(aggParams, initScriptParams), aggState).     final ScriptedMetricAggContexts.MapScript.LeafFactory mapScript = this.mapScript.newFactory(mergeParams(aggParams, mapScriptParams), aggState, lookup).     final ScriptedMetricAggContexts.CombineScript combineScript = this.combineScript.newInstance(mergeParams(aggParams, combineScriptParams), aggState).     final Script reduceScript = deepCopyScript(this.reduceScript, context).     if (initScript != null) {         initScript.execute().         CollectionUtils.ensureNoSelfReferences(aggState, "Scripted metric aggs init script").     }     return new ScriptedMetricAggregator(name, mapScript, combineScript, reduceScript, aggState, context, parent, pipelineAggregators, metaData). }
false;private,static;2;11;;private static Script deepCopyScript(Script script, SearchContext context) {     if (script != null) {         Map<String, Object> params = script.getParams().         if (params != null) {             params = deepCopyParams(params, context).         }         return new Script(script.getType(), script.getLang(), script.getIdOrCode(), params).     } else {         return null.     } }
false;private,static;2;27;;@SuppressWarnings({ "unchecked" }) private static <T> T deepCopyParams(T original, SearchContext context) {     T clone.     if (original instanceof Map) {         Map<?, ?> originalMap = (Map<?, ?>) original.         Map<Object, Object> clonedMap = new HashMap<>().         for (Map.Entry<?, ?> e : originalMap.entrySet()) {             clonedMap.put(deepCopyParams(e.getKey(), context), deepCopyParams(e.getValue(), context)).         }         clone = (T) clonedMap.     } else if (original instanceof List) {         List<?> originalList = (List<?>) original.         List<Object> clonedList = new ArrayList<>().         for (Object o : originalList) {             clonedList.add(deepCopyParams(o, context)).         }         clone = (T) clonedList.     } else if (original instanceof String || original instanceof Integer || original instanceof Long || original instanceof Short || original instanceof Byte || original instanceof Float || original instanceof Double || original instanceof Character || original instanceof Boolean) {         clone = original.     } else {         throw new SearchParseException(context, "Can only clone primitives, String, ArrayList, and HashMap. Found: " + original.getClass().getCanonicalName(), null).     }     return clone. }
false;private,static;2;14;;private static Map<String, Object> mergeParams(Map<String, Object> agg, Map<String, Object> script) {     // Start with script params     Map<String, Object> combined = new HashMap<>(script).     // Add in agg params, throwing an exception if any conflicts are detected     for (Map.Entry<String, Object> aggEntry : agg.entrySet()) {         if (combined.putIfAbsent(aggEntry.getKey(), aggEntry.getValue()) != null) {             throw new IllegalArgumentException("Parameter name \"" + aggEntry.getKey() + "\" used in both aggregation and script parameters").         }     }     return combined. }
