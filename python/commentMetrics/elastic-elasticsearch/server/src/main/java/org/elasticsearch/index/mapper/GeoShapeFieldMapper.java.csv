commented;modifiers;parameterAmount;loc;comment;code
false;public;1;6;;@Override public GeoShapeFieldMapper build(BuilderContext context) {     setupFieldType(context).     return new GeoShapeFieldMapper(name, fieldType, defaultFieldType, ignoreMalformed(context), coerce(context), ignoreZValue(), context.indexSettings(), multiFieldsBuilder.build(this, context), copyTo). }
false;public;0;4;;@Override public GeoShapeFieldType clone() {     return new GeoShapeFieldType(this). }
false;public;0;4;;@Override public GeoShapeFieldType fieldType() {     return (GeoShapeFieldType) super.fieldType(). }
true;public;1;20;/**  * parsing logic for {@link LatLonShape} indexing  */ ;/**  * parsing logic for {@link LatLonShape} indexing  */ @Override public void parse(ParseContext context) throws IOException {     try {         Object shape = context.parseExternalValue(Object.class).         if (shape == null) {             ShapeBuilder shapeBuilder = ShapeParser.parse(context.parser(), this).             if (shapeBuilder == null) {                 return.             }             shape = shapeBuilder.buildGeometry().         }         indexShape(context, shape).     } catch (Exception e) {         if (ignoreMalformed.value() == false) {             throw new MapperParsingException("failed to parse field [{}] of type [{}]", e, fieldType().name(), fieldType().typeName()).         }         context.addIgnoredField(fieldType().name()).     } }
false;private;2;7;;private void indexShape(ParseContext context, Object luceneShape) {     if (luceneShape instanceof Geometry) {         ((Geometry) luceneShape).visit(new LuceneGeometryIndexer(context)).     } else {         throw new IllegalArgumentException("invalid shape type found [" + luceneShape.getClass() + "] while indexing shape").     } }
false;public;1;4;;@Override public Void visit(Circle circle) {     throw new IllegalArgumentException("invalid shape type found [Circle] while indexing shape"). }
false;public;1;7;;@Override public Void visit(GeometryCollection<?> collection) {     for (Geometry geometry : collection) {         geometry.visit(this).     }     return null. }
false;public;1;5;;@Override public Void visit(org.elasticsearch.geo.geometry.Line line) {     indexFields(context, LatLonShape.createIndexableFields(name(), new Line(line.getLats(), line.getLons()))).     return null. }
false;public;1;4;;@Override public Void visit(LinearRing ring) {     throw new IllegalArgumentException("invalid shape type found [LinearRing] while indexing shape"). }
false;public;1;7;;@Override public Void visit(MultiLine multiLine) {     for (org.elasticsearch.geo.geometry.Line line : multiLine) {         visit(line).     }     return null. }
false;public;1;7;;@Override public Void visit(MultiPoint multiPoint) {     for (Point point : multiPoint) {         visit(point).     }     return null. }
false;public;1;7;;@Override public Void visit(MultiPolygon multiPolygon) {     for (org.elasticsearch.geo.geometry.Polygon polygon : multiPolygon) {         visit(polygon).     }     return null. }
false;public;1;5;;@Override public Void visit(Point point) {     indexFields(context, LatLonShape.createIndexableFields(name(), point.getLat(), point.getLon())).     return null. }
false;public;1;5;;@Override public Void visit(org.elasticsearch.geo.geometry.Polygon polygon) {     indexFields(context, LatLonShape.createIndexableFields(name(), toLucenePolygon(polygon))).     return null. }
false;public;1;7;;@Override public Void visit(org.elasticsearch.geo.geometry.Rectangle r) {     Polygon p = new Polygon(new double[] { r.getMinLat(), r.getMinLat(), r.getMaxLat(), r.getMaxLat(), r.getMinLat() }, new double[] { r.getMinLon(), r.getMaxLon(), r.getMaxLon(), r.getMinLon(), r.getMinLon() }).     indexFields(context, LatLonShape.createIndexableFields(name(), p)).     return null. }
false;public,static;1;7;;public static Polygon toLucenePolygon(org.elasticsearch.geo.geometry.Polygon polygon) {     Polygon[] holes = new Polygon[polygon.getNumberOfHoles()].     for (int i = 0. i < holes.length. i++) {         holes[i] = new Polygon(polygon.getHole(i).getLats(), polygon.getHole(i).getLons()).     }     return new Polygon(polygon.getPolygon().getLats(), polygon.getPolygon().getLons(), holes). }
false;private;2;7;;private void indexFields(ParseContext context, Field[] fields) {     ArrayList<IndexableField> flist = new ArrayList<>(Arrays.asList(fields)).     createFieldNamesField(context, flist).     for (IndexableField f : flist) {         context.doc().add(f).     } }
