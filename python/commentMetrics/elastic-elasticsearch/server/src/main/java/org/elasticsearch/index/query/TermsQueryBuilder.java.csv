commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;9;;@Override protected void doWriteTo(StreamOutput out) throws IOException {     if (supplier != null) {         throw new IllegalStateException("supplier must be null, can't serialize suppliers, missing a rewriteAndFetch?").     }     out.writeString(fieldName).     out.writeOptionalWriteable(termsLookup).     out.writeGenericValue(values). }
false;public;0;3;;public String fieldName() {     return this.fieldName. }
false;public;0;3;;public List<Object> values() {     return convertBack(this.values). }
false;public;0;3;;public TermsLookup termsLookup() {     return this.termsLookup. }
false;public;0;3;;public boolean isTypeless() {     return termsLookup == null || termsLookup.type() == null. }
true;private,static;1;13;/**  * Same as {@link #convert(List)} but on an {@link Iterable}.  */ ;/**  * Same as {@link #convert(List)} but on an {@link Iterable}.  */ private static List<?> convert(Iterable<?> values) {     List<?> list.     if (values instanceof List<?>) {         list = (List<?>) values.     } else {         ArrayList<Object> arrayList = new ArrayList<>().         for (Object o : values) {             arrayList.add(o).         }         list = arrayList.     }     return convert(list). }
false;public;1;4;;@Override public Object get(int index) {     return elements[index]. }
false;public;0;4;;@Override public int size() {     return elements.length. }
false;public;1;6;;@Override public Object get(int i) {     final int startOffset = i == 0 ? 0 : endOffsets[i - 1].     final int endOffset = endOffsets[i].     return bytes.slice(startOffset, endOffset - startOffset).toBytesRef(). }
false;public;0;4;;@Override public int size() {     return endOffsets.length. }
true;static;1;62;/**  * Convert the list in a way that optimizes storage in the case that all  * elements are either integers or {@link String}s/{@link BytesRef}/  * {@link CharBuffer}s. This is useful to help garbage collections for  * use-cases that involve sending very large terms queries to Elasticsearch.  * If the list does not only contain integers or {@link String}s, then a  * list is returned where all {@link String}/{@link CharBuffer}s have been  * replaced with {@link BytesRef}s.  */ ;/**  * Convert the list in a way that optimizes storage in the case that all  * elements are either integers or {@link String}s/{@link BytesRef}/  * {@link CharBuffer}s. This is useful to help garbage collections for  * use-cases that involve sending very large terms queries to Elasticsearch.  * If the list does not only contain integers or {@link String}s, then a  * list is returned where all {@link String}/{@link CharBuffer}s have been  * replaced with {@link BytesRef}s.  */ static List<?> convert(List<?> list) {     if (list.isEmpty()) {         return Collections.emptyList().     }     final boolean allNumbers = list.stream().allMatch(o -> o != null && INTEGER_TYPES.contains(o.getClass())).     if (allNumbers) {         final long[] elements = list.stream().mapToLong(o -> ((Number) o).longValue()).toArray().         return new AbstractList<Object>() {              @Override             public Object get(int index) {                 return elements[index].             }              @Override             public int size() {                 return elements.length.             }         }.     }     final boolean allStrings = list.stream().allMatch(o -> o != null && STRING_TYPES.contains(o.getClass())).     if (allStrings) {         final BytesRefBuilder builder = new BytesRefBuilder().         try (BytesStreamOutput bytesOut = new BytesStreamOutput()) {             final int[] endOffsets = new int[list.size()].             int i = 0.             for (Object o : list) {                 BytesRef b.                 if (o instanceof BytesRef) {                     b = (BytesRef) o.                 } else if (o instanceof CharBuffer) {                     b = new BytesRef((CharBuffer) o).                 } else {                     builder.copyChars(o.toString()).                     b = builder.get().                 }                 bytesOut.writeBytes(b.bytes, b.offset, b.length).                 if (i == 0) {                     endOffsets[0] = b.length.                 } else {                     endOffsets[i] = Math.addExact(endOffsets[i - 1], b.length).                 }                 ++i.             }             final BytesReference bytes = bytesOut.bytes().             return new AbstractList<Object>() {                  @Override                 public Object get(int i) {                     final int startOffset = i == 0 ? 0 : endOffsets[i - 1].                     final int endOffset = endOffsets[i].                     return bytes.slice(startOffset, endOffset - startOffset).toBytesRef().                 }                  @Override                 public int size() {                     return endOffsets.length.                 }             }.         }     }     return list.stream().map(o -> o instanceof String ? new BytesRef(o.toString()) : o).collect(Collectors.toList()). }
false;public;0;4;;@Override public int size() {     return list.size(). }
false;public;1;10;;@Override public Object get(int index) {     Object o = list.get(index).     if (o instanceof BytesRef) {         o = ((BytesRef) o).utf8ToString().     }     // as far as this query is concerned     return o. }
true;static;1;18;/**  * Convert the internal {@link List} of values back to a user-friendly list.  * Integers are kept as-is since the terms query does not make any difference  * between {@link Integer}s and {@link Long}s, but {@link BytesRef}s are  * converted back to {@link String}s.  */ ;/**  * Convert the internal {@link List} of values back to a user-friendly list.  * Integers are kept as-is since the terms query does not make any difference  * between {@link Integer}s and {@link Long}s, but {@link BytesRef}s are  * converted back to {@link String}s.  */ static List<Object> convertBack(List<?> list) {     return new AbstractList<Object>() {          @Override         public int size() {             return list.size().         }          @Override         public Object get(int index) {             Object o = list.get(index).             if (o instanceof BytesRef) {                 o = ((BytesRef) o).utf8ToString().             }             // as far as this query is concerned             return o.         }     }. }
false;protected;2;13;;@Override protected void doXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject(NAME).     if (this.termsLookup != null) {         builder.startObject(fieldName).         termsLookup.toXContent(builder, params).         builder.endObject().     } else {         builder.field(fieldName, convertBack(values)).     }     printBoostAndQueryName(builder).     builder.endObject(). }
false;public,static;1;58;;public static TermsQueryBuilder fromXContent(XContentParser parser) throws IOException {     String fieldName = null.     List<Object> values = null.     TermsLookup termsLookup = null.     String queryName = null.     float boost = AbstractQueryBuilder.DEFAULT_BOOST.     XContentParser.Token token.     String currentFieldName = null.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (token == XContentParser.Token.START_ARRAY) {             if (fieldName != null) {                 throw new ParsingException(parser.getTokenLocation(), "[" + TermsQueryBuilder.NAME + "] query does not support multiple fields").             }             fieldName = currentFieldName.             values = parseValues(parser).         } else if (token == XContentParser.Token.START_OBJECT) {             if (fieldName != null) {                 throw new ParsingException(parser.getTokenLocation(), "[" + TermsQueryBuilder.NAME + "] query does not support more than one field. " + "Already got: [" + fieldName + "] but also found [" + currentFieldName + "]").             }             fieldName = currentFieldName.             termsLookup = TermsLookup.parseTermsLookup(parser).         } else if (token.isValue()) {             if (AbstractQueryBuilder.BOOST_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 boost = parser.floatValue().             } else if (AbstractQueryBuilder.NAME_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 queryName = parser.text().             } else {                 throw new ParsingException(parser.getTokenLocation(), "[" + TermsQueryBuilder.NAME + "] query does not support [" + currentFieldName + "]").             }         } else {             throw new ParsingException(parser.getTokenLocation(), "[" + TermsQueryBuilder.NAME + "] unknown token [" + token + "] after [" + currentFieldName + "]").         }     }     if (fieldName == null) {         throw new ParsingException(parser.getTokenLocation(), "[" + TermsQueryBuilder.NAME + "] query requires a field name, " + "followed by array of terms or a document lookup specification").     }     TermsQueryBuilder builder = new TermsQueryBuilder(fieldName, values, termsLookup).boost(boost).queryName(queryName).     if (builder.isTypeless() == false) {         deprecationLogger.deprecatedAndMaybeLog("terms_lookup_with_types", TYPES_DEPRECATION_MESSAGE).     }     return builder. }
false;static;1;11;;static List<Object> parseValues(XContentParser parser) throws IOException {     List<Object> values = new ArrayList<>().     while (parser.nextToken() != XContentParser.Token.END_ARRAY) {         Object value = maybeConvertToBytesRef(parser.objectBytes()).         if (value == null) {             throw new ParsingException(parser.getTokenLocation(), "No value specified for terms query").         }         values.add(value).     }     return values. }
false;public;0;4;;@Override public String getWriteableName() {     return NAME. }
false;protected;1;27;;@Override protected Query doToQuery(QueryShardContext context) throws IOException {     if (termsLookup != null || supplier != null) {         throw new UnsupportedOperationException("query must be rewritten first").     }     if (values == null || values.isEmpty()) {         return Queries.newMatchNoDocsQuery("No terms supplied for \"" + getName() + "\" query.").     }     int maxTermsCount = context.getIndexSettings().getMaxTermsCount().     if (values.size() > maxTermsCount) {         throw new IllegalArgumentException("The number of terms [" + values.size() + "] used in the Terms Query request has exceeded " + "the allowed maximum of [" + maxTermsCount + "]. " + "This maximum can be set by changing the [" + IndexSettings.MAX_TERMS_COUNT_SETTING.getKey() + "] index level setting.").     }     MappedFieldType fieldType = context.fieldMapper(fieldName).     if (fieldType != null) {         return fieldType.termsQuery(values, context).     } else {         BytesRef[] filterValues = new BytesRef[values.size()].         for (int i = 0. i < filterValues.length. i++) {             filterValues[i] = BytesRefs.toBytesRef(values.get(i)).         }         return new TermInSetQuery(fieldName, filterValues).     } }
false;public;1;9;;@Override public void onResponse(GetResponse getResponse) {     List<Object> terms = new ArrayList<>().     if (getResponse.isSourceEmpty() == false) {         // extract terms only if the doc source exists         List<Object> extractedValues = XContentMapValues.extractRawValues(termsLookup.path(), getResponse.getSourceAsMap()).         terms.addAll(extractedValues).     }     actionListener.onResponse(terms). }
false;public;1;4;;@Override public void onFailure(Exception e) {     actionListener.onFailure(e). }
false;private;3;22;;private void fetch(TermsLookup termsLookup, Client client, ActionListener<List<Object>> actionListener) {     GetRequest getRequest = termsLookup.type() == null ? new GetRequest(termsLookup.index(), termsLookup.id()) : new GetRequest(termsLookup.index(), termsLookup.type(), termsLookup.id()).     getRequest.preference("_local").routing(termsLookup.routing()).     client.get(getRequest, new ActionListener<GetResponse>() {          @Override         public void onResponse(GetResponse getResponse) {             List<Object> terms = new ArrayList<>().             if (getResponse.isSourceEmpty() == false) {                 // extract terms only if the doc source exists                 List<Object> extractedValues = XContentMapValues.extractRawValues(termsLookup.path(), getResponse.getSourceAsMap()).                 terms.addAll(extractedValues).             }             actionListener.onResponse(terms).         }          @Override         public void onFailure(Exception e) {             actionListener.onFailure(e).         }     }). }
false;protected;0;4;;@Override protected int doHashCode() {     return Objects.hash(fieldName, values, termsLookup, supplier). }
false;protected;1;7;;@Override protected boolean doEquals(TermsQueryBuilder other) {     return Objects.equals(fieldName, other.fieldName) && Objects.equals(values, other.values) && Objects.equals(termsLookup, other.termsLookup) && Objects.equals(supplier, other.supplier). }
false;protected;1;17;;@Override protected QueryBuilder doRewrite(QueryRewriteContext queryRewriteContext) {     if (supplier != null) {         return supplier.get() == null ? this : new TermsQueryBuilder(this.fieldName, supplier.get()).     } else if (this.termsLookup != null) {         SetOnce<List<?>> supplier = new SetOnce<>().         queryRewriteContext.registerAsyncAction((client, listener) -> {             fetch(termsLookup, client, ActionListener.wrap(list -> {                 supplier.set(list).                 listener.onResponse(null).             }, listener::onFailure)).         }).         return new TermsQueryBuilder(this.fieldName, supplier::get).     }     return this. }
