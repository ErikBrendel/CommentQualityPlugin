commented;modifiers;parameterAmount;loc;comment;code
false;public;1;5;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeString(key).     out.writeNamedWriteable(filter). }
false;public;0;3;;public String key() {     return key. }
false;public;0;3;;public QueryBuilder filter() {     return filter. }
false;public;2;5;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.field(key, filter).     return builder. }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(key, filter). }
false;public;1;11;;@Override public boolean equals(Object obj) {     if (obj == null) {         return false.     }     if (getClass() != obj.getClass()) {         return false.     }     KeyedFilter other = (KeyedFilter) obj.     return Objects.equals(key, other.key) && Objects.equals(filter, other.filter). }
false;public;1;4;;@Override public boolean get(int index) {     return a.get(index) && b.get(index). }
false;public;0;4;;@Override public int length() {     return Math.min(a.length(), b.length()). }
false;public;2;8;;@Override public void collect(int doc, long bucket) throws IOException {     for (int i = 0. i < bits.length. i++) {         if (bits[i].get(doc)) {             collectBucket(sub, doc, bucketOrd(bucket, i)).         }     } }
false;public;2;26;;@Override public LeafBucketCollector getLeafCollector(LeafReaderContext ctx, final LeafBucketCollector sub) throws IOException {     // no need to provide deleted docs to the filter     final Bits[] bits = new Bits[filters.length + totalNumIntersections].     for (int i = 0. i < filters.length. ++i) {         bits[i] = Lucene.asSequentialAccessBits(ctx.reader().maxDoc(), filters[i].scorerSupplier(ctx)).     }     // Add extra Bits for intersections     int pos = filters.length.     for (int i = 0. i < filters.length. i++) {         for (int j = i + 1. j < filters.length. j++) {             bits[pos++] = new BitsIntersector(bits[i], bits[j]).         }     }     assert pos == bits.length.     return new LeafBucketCollectorBase(sub, null) {          @Override         public void collect(int doc, long bucket) throws IOException {             for (int i = 0. i < bits.length. i++) {                 if (bits[i].get(doc)) {                     collectBucket(sub, doc, bucketOrd(bucket, i)).                 }             }         }     }. }
false;public;1;37;;@Override public InternalAggregation buildAggregation(long owningBucketOrdinal) throws IOException {     // Buckets are ordered into groups - [keyed filters] [key1&key2 intersects]     List<InternalAdjacencyMatrix.InternalBucket> buckets = new ArrayList<>(filters.length).     for (int i = 0. i < keys.length. i++) {         long bucketOrd = bucketOrd(owningBucketOrdinal, i).         int docCount = bucketDocCount(bucketOrd).         // empty buckets.         if (docCount > 0) {             InternalAdjacencyMatrix.InternalBucket bucket = new InternalAdjacencyMatrix.InternalBucket(keys[i], docCount, bucketAggregations(bucketOrd)).             buckets.add(bucket).             consumeBucketsAndMaybeBreak(1).         }     }     int pos = keys.length.     for (int i = 0. i < keys.length. i++) {         for (int j = i + 1. j < keys.length. j++) {             long bucketOrd = bucketOrd(owningBucketOrdinal, pos).             int docCount = bucketDocCount(bucketOrd).             // Empty buckets are not returned due to potential for very sparse matrices             if (docCount > 0) {                 String intersectKey = keys[i] + separator + keys[j].                 InternalAdjacencyMatrix.InternalBucket bucket = new InternalAdjacencyMatrix.InternalBucket(intersectKey, docCount, bucketAggregations(bucketOrd)).                 buckets.add(bucket).                 consumeBucketsAndMaybeBreak(1).             }             pos++.         }     }     return new InternalAdjacencyMatrix(name, buckets, pipelineAggregators(), metaData()). }
false;public;0;5;;@Override public InternalAggregation buildEmptyAggregation() {     List<InternalAdjacencyMatrix.InternalBucket> buckets = new ArrayList<>(0).     return new InternalAdjacencyMatrix(name, buckets, pipelineAggregators(), metaData()). }
false;final;2;3;;final long bucketOrd(long owningBucketOrdinal, int filterOrd) {     return owningBucketOrdinal * totalNumKeys + filterOrd. }
