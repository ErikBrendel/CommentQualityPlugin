commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;4;;@Override protected ClusterStateUpdateResponse newResponse(boolean acknowledged) {     return new ClusterStateUpdateResponse(acknowledged). }
false;public;1;37;;@Override public ClusterState execute(ClusterState currentState) {     ensureRepositoryNotInUse(currentState, request.name).     MetaData metaData = currentState.metaData().     MetaData.Builder mdBuilder = MetaData.builder(currentState.metaData()).     RepositoriesMetaData repositories = metaData.custom(RepositoriesMetaData.TYPE).     if (repositories == null) {         logger.info("put repository [{}]", request.name).         repositories = new RepositoriesMetaData(Collections.singletonList(new RepositoryMetaData(request.name, request.type, request.settings))).     } else {         boolean found = false.         List<RepositoryMetaData> repositoriesMetaData = new ArrayList<>(repositories.repositories().size() + 1).         for (RepositoryMetaData repositoryMetaData : repositories.repositories()) {             if (repositoryMetaData.name().equals(newRepositoryMetaData.name())) {                 if (newRepositoryMetaData.equals(repositoryMetaData)) {                     // Previous version is the same as this one no update is needed.                     return currentState.                 }                 found = true.                 repositoriesMetaData.add(newRepositoryMetaData).             } else {                 repositoriesMetaData.add(repositoryMetaData).             }         }         if (!found) {             logger.info("put repository [{}]", request.name).             repositoriesMetaData.add(new RepositoryMetaData(request.name, request.type, request.settings)).         } else {             logger.info("update repository [{}]", request.name).         }         repositories = new RepositoriesMetaData(repositoriesMetaData).     }     mdBuilder.putCustom(RepositoriesMetaData.TYPE, repositories).     return ClusterState.builder(currentState).metaData(mdBuilder).build(). }
false;public;2;5;;@Override public void onFailure(String source, Exception e) {     logger.warn(() -> new ParameterizedMessage("failed to create repository [{}]", request.name), e).     super.onFailure(source, e). }
false;public;1;5;;@Override public boolean mustAck(DiscoveryNode discoveryNode) {     // repository is created on both master and data nodes     return discoveryNode.isMasterNode() || discoveryNode.isDataNode(). }
true;public;2;76;/**  * Registers new repository in the cluster  * <p>  * This method can be only called on the master node. It tries to create a new repository on the master  * and if it was successful it adds new repository to cluster metadata.  *  * @param request  register repository request  * @param listener register repository listener  */ ;/**  * Registers new repository in the cluster  * <p>  * This method can be only called on the master node. It tries to create a new repository on the master  * and if it was successful it adds new repository to cluster metadata.  *  * @param request  register repository request  * @param listener register repository listener  */ public void registerRepository(final RegisterRepositoryRequest request, final ActionListener<ClusterStateUpdateResponse> listener) {     final RepositoryMetaData newRepositoryMetaData = new RepositoryMetaData(request.name, request.type, request.settings).     final ActionListener<ClusterStateUpdateResponse> registrationListener.     if (request.verify) {         registrationListener = new VerifyingRegisterRepositoryListener(request.name, listener).     } else {         registrationListener = listener.     }     // Trying to create the new repository on master to make sure it works     try {         closeRepository(createRepository(newRepositoryMetaData, typesRegistry)).     } catch (Exception e) {         registrationListener.onFailure(e).         return.     }     clusterService.submitStateUpdateTask(request.cause, new AckedClusterStateUpdateTask<ClusterStateUpdateResponse>(request, registrationListener) {          @Override         protected ClusterStateUpdateResponse newResponse(boolean acknowledged) {             return new ClusterStateUpdateResponse(acknowledged).         }          @Override         public ClusterState execute(ClusterState currentState) {             ensureRepositoryNotInUse(currentState, request.name).             MetaData metaData = currentState.metaData().             MetaData.Builder mdBuilder = MetaData.builder(currentState.metaData()).             RepositoriesMetaData repositories = metaData.custom(RepositoriesMetaData.TYPE).             if (repositories == null) {                 logger.info("put repository [{}]", request.name).                 repositories = new RepositoriesMetaData(Collections.singletonList(new RepositoryMetaData(request.name, request.type, request.settings))).             } else {                 boolean found = false.                 List<RepositoryMetaData> repositoriesMetaData = new ArrayList<>(repositories.repositories().size() + 1).                 for (RepositoryMetaData repositoryMetaData : repositories.repositories()) {                     if (repositoryMetaData.name().equals(newRepositoryMetaData.name())) {                         if (newRepositoryMetaData.equals(repositoryMetaData)) {                             // Previous version is the same as this one no update is needed.                             return currentState.                         }                         found = true.                         repositoriesMetaData.add(newRepositoryMetaData).                     } else {                         repositoriesMetaData.add(repositoryMetaData).                     }                 }                 if (!found) {                     logger.info("put repository [{}]", request.name).                     repositoriesMetaData.add(new RepositoryMetaData(request.name, request.type, request.settings)).                 } else {                     logger.info("update repository [{}]", request.name).                 }                 repositories = new RepositoriesMetaData(repositoriesMetaData).             }             mdBuilder.putCustom(RepositoriesMetaData.TYPE, repositories).             return ClusterState.builder(currentState).metaData(mdBuilder).build().         }          @Override         public void onFailure(String source, Exception e) {             logger.warn(() -> new ParameterizedMessage("failed to create repository [{}]", request.name), e).             super.onFailure(source, e).         }          @Override         public boolean mustAck(DiscoveryNode discoveryNode) {             // repository is created on both master and data nodes             return discoveryNode.isMasterNode() || discoveryNode.isDataNode().         }     }). }
false;protected;1;4;;@Override protected ClusterStateUpdateResponse newResponse(boolean acknowledged) {     return new ClusterStateUpdateResponse(acknowledged). }
false;public;1;28;;@Override public ClusterState execute(ClusterState currentState) {     ensureRepositoryNotInUse(currentState, request.name).     MetaData metaData = currentState.metaData().     MetaData.Builder mdBuilder = MetaData.builder(currentState.metaData()).     RepositoriesMetaData repositories = metaData.custom(RepositoriesMetaData.TYPE).     if (repositories != null && repositories.repositories().size() > 0) {         List<RepositoryMetaData> repositoriesMetaData = new ArrayList<>(repositories.repositories().size()).         boolean changed = false.         for (RepositoryMetaData repositoryMetaData : repositories.repositories()) {             if (Regex.simpleMatch(request.name, repositoryMetaData.name())) {                 logger.info("delete repository [{}]", repositoryMetaData.name()).                 changed = true.             } else {                 repositoriesMetaData.add(repositoryMetaData).             }         }         if (changed) {             repositories = new RepositoriesMetaData(repositoriesMetaData).             mdBuilder.putCustom(RepositoriesMetaData.TYPE, repositories).             return ClusterState.builder(currentState).metaData(mdBuilder).build().         }     }     if (Regex.isMatchAllPattern(request.name)) {         // we use a wildcard so we don't barf if it's not present.         return currentState.     }     throw new RepositoryMissingException(request.name). }
false;public;1;5;;@Override public boolean mustAck(DiscoveryNode discoveryNode) {     // repository was created on both master and data nodes     return discoveryNode.isMasterNode() || discoveryNode.isDataNode(). }
true;public;2;43;/**  * Unregisters repository in the cluster  * <p>  * This method can be only called on the master node. It removes repository information from cluster metadata.  *  * @param request  unregister repository request  * @param listener unregister repository listener  */ ;/**  * Unregisters repository in the cluster  * <p>  * This method can be only called on the master node. It removes repository information from cluster metadata.  *  * @param request  unregister repository request  * @param listener unregister repository listener  */ public void unregisterRepository(final UnregisterRepositoryRequest request, final ActionListener<ClusterStateUpdateResponse> listener) {     clusterService.submitStateUpdateTask(request.cause, new AckedClusterStateUpdateTask<ClusterStateUpdateResponse>(request, listener) {          @Override         protected ClusterStateUpdateResponse newResponse(boolean acknowledged) {             return new ClusterStateUpdateResponse(acknowledged).         }          @Override         public ClusterState execute(ClusterState currentState) {             ensureRepositoryNotInUse(currentState, request.name).             MetaData metaData = currentState.metaData().             MetaData.Builder mdBuilder = MetaData.builder(currentState.metaData()).             RepositoriesMetaData repositories = metaData.custom(RepositoriesMetaData.TYPE).             if (repositories != null && repositories.repositories().size() > 0) {                 List<RepositoryMetaData> repositoriesMetaData = new ArrayList<>(repositories.repositories().size()).                 boolean changed = false.                 for (RepositoryMetaData repositoryMetaData : repositories.repositories()) {                     if (Regex.simpleMatch(request.name, repositoryMetaData.name())) {                         logger.info("delete repository [{}]", repositoryMetaData.name()).                         changed = true.                     } else {                         repositoriesMetaData.add(repositoryMetaData).                     }                 }                 if (changed) {                     repositories = new RepositoriesMetaData(repositoriesMetaData).                     mdBuilder.putCustom(RepositoriesMetaData.TYPE, repositories).                     return ClusterState.builder(currentState).metaData(mdBuilder).build().                 }             }             if (Regex.isMatchAllPattern(request.name)) {                 // we use a wildcard so we don't barf if it's not present.                 return currentState.             }             throw new RepositoryMissingException(request.name).         }          @Override         public boolean mustAck(DiscoveryNode discoveryNode) {             // repository was created on both master and data nodes             return discoveryNode.isMasterNode() || discoveryNode.isDataNode().         }     }). }
false;public;1;14;;@Override public void onResponse(VerifyResponse verifyResponse) {     threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {         try {             repository.endVerification(verificationToken).         } catch (Exception e) {             logger.warn(() -> new ParameterizedMessage("[{}] failed to finish repository verification", repositoryName), e).             listener.onFailure(e).             return.         }         listener.onResponse(verifyResponse).     }). }
false;public;1;4;;@Override public void onFailure(Exception e) {     listener.onFailure(e). }
false;public;2;52;;public void verifyRepository(final String repositoryName, final ActionListener<VerifyResponse> listener) {     final Repository repository = repository(repositoryName).     try {         threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {             try {                 final String verificationToken = repository.startVerification().                 if (verificationToken != null) {                     try {                         verifyAction.verify(repositoryName, verificationToken, new ActionListener<VerifyResponse>() {                              @Override                             public void onResponse(VerifyResponse verifyResponse) {                                 threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {                                     try {                                         repository.endVerification(verificationToken).                                     } catch (Exception e) {                                         logger.warn(() -> new ParameterizedMessage("[{}] failed to finish repository verification", repositoryName), e).                                         listener.onFailure(e).                                         return.                                     }                                     listener.onResponse(verifyResponse).                                 }).                             }                              @Override                             public void onFailure(Exception e) {                                 listener.onFailure(e).                             }                         }).                     } catch (Exception e) {                         threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {                             try {                                 repository.endVerification(verificationToken).                             } catch (Exception inner) {                                 inner.addSuppressed(e).                                 logger.warn(() -> new ParameterizedMessage("[{}] failed to finish repository verification", repositoryName), inner).                             }                             listener.onFailure(e).                         }).                     }                 } else {                     listener.onResponse(new VerifyResponse(new DiscoveryNode[0], new VerificationFailure[0])).                 }             } catch (Exception e) {                 listener.onFailure(e).             }         }).     } catch (Exception e) {         listener.onFailure(e).     } }
true;public;1;65;/**  * Checks if new repositories appeared in or disappeared from cluster metadata and updates current list of  * repositories accordingly.  *  * @param event cluster changed event  */ ;/**  * Checks if new repositories appeared in or disappeared from cluster metadata and updates current list of  * repositories accordingly.  *  * @param event cluster changed event  */ @Override public void applyClusterState(ClusterChangedEvent event) {     try {         RepositoriesMetaData oldMetaData = event.previousState().getMetaData().custom(RepositoriesMetaData.TYPE).         RepositoriesMetaData newMetaData = event.state().getMetaData().custom(RepositoriesMetaData.TYPE).         // Check if repositories got changed         if ((oldMetaData == null && newMetaData == null) || (oldMetaData != null && oldMetaData.equals(newMetaData))) {             return.         }         logger.trace("processing new index repositories for state version [{}]", event.state().version()).         Map<String, Repository> survivors = new HashMap<>().         // First, remove repositories that are no longer there         for (Map.Entry<String, Repository> entry : repositories.entrySet()) {             if (newMetaData == null || newMetaData.repository(entry.getKey()) == null) {                 logger.debug("unregistering repository [{}]", entry.getKey()).                 closeRepository(entry.getValue()).             } else {                 survivors.put(entry.getKey(), entry.getValue()).             }         }         Map<String, Repository> builder = new HashMap<>().         if (newMetaData != null) {             // Now go through all repositories and update existing or create missing             for (RepositoryMetaData repositoryMetaData : newMetaData.repositories()) {                 Repository repository = survivors.get(repositoryMetaData.name()).                 if (repository != null) {                     // Found previous version of this repository                     RepositoryMetaData previousMetadata = repository.getMetadata().                     if (previousMetadata.type().equals(repositoryMetaData.type()) == false || previousMetadata.settings().equals(repositoryMetaData.settings()) == false) {                         // Previous version is different from the version in settings                         logger.debug("updating repository [{}]", repositoryMetaData.name()).                         closeRepository(repository).                         repository = null.                         try {                             repository = createRepository(repositoryMetaData, typesRegistry).                         } catch (RepositoryException ex) {                             // TODO: this catch is bogus, it means the old repo is already closed,                             // but we have nothing to replace it                             logger.warn(() -> new ParameterizedMessage("failed to change repository [{}]", repositoryMetaData.name()), ex).                         }                     }                 } else {                     try {                         repository = createRepository(repositoryMetaData, typesRegistry).                     } catch (RepositoryException ex) {                         logger.warn(() -> new ParameterizedMessage("failed to create repository [{}]", repositoryMetaData.name()), ex).                     }                 }                 if (repository != null) {                     logger.debug("registering repository [{}]", repositoryMetaData.name()).                     builder.put(repositoryMetaData.name(), repository).                 }             }         }         repositories = Collections.unmodifiableMap(builder).     } catch (Exception ex) {         logger.warn("failure updating cluster state ", ex).     } }
true;public;1;11;/**  * Returns registered repository  * <p>  * This method is called only on the master node  *  * @param repositoryName repository name  * @return registered repository  * @throws RepositoryMissingException if repository with such name isn't registered  */ ;/**  * Returns registered repository  * <p>  * This method is called only on the master node  *  * @param repositoryName repository name  * @return registered repository  * @throws RepositoryMissingException if repository with such name isn't registered  */ public Repository repository(String repositoryName) {     Repository repository = repositories.get(repositoryName).     if (repository != null) {         return repository.     }     repository = internalRepositories.get(repositoryName).     if (repository != null) {         return repository.     }     throw new RepositoryMissingException(repositoryName). }
false;public;2;14;;public void registerInternalRepository(String name, String type) {     RepositoryMetaData metaData = new RepositoryMetaData(name, type, Settings.EMPTY).     Repository repository = internalRepositories.computeIfAbsent(name, (n) -> {         logger.debug("put internal repository [{}][{}]", name, type).         return createRepository(metaData, internalTypesRegistry).     }).     if (type.equals(repository.getMetadata().type()) == false) {         logger.warn(new ParameterizedMessage("internal repository [{}][{}] already registered. this prevented the registration of " + "internal repository [{}][{}].", name, repository.getMetadata().type(), name, type)).     } else if (repositories.containsKey(name)) {         logger.warn(new ParameterizedMessage("non-internal repository [{}] already registered. this repository will block the " + "usage of internal repository [{}][{}].", name, metaData.type(), name)).     } }
false;public;1;8;;public void unregisterInternalRepository(String name) {     Repository repository = internalRepositories.remove(name).     if (repository != null) {         RepositoryMetaData metadata = repository.getMetadata().         logger.debug(() -> new ParameterizedMessage("delete internal repository [{}][{}].", metadata.type(), name)).         closeRepository(repository).     } }
true;private;1;4;/**  * Closes the given repository.  */ ;/**  * Closes the given repository.  */ private void closeRepository(Repository repository) {     logger.debug("closing repository [{}][{}]", repository.getMetadata().type(), repository.getMetadata().name()).     repository.close(). }
true;private;2;17;/**  * Creates repository holder. This method starts the repository  */ ;/**  * Creates repository holder. This method starts the repository  */ private Repository createRepository(RepositoryMetaData repositoryMetaData, Map<String, Repository.Factory> factories) {     logger.debug("creating repository [{}][{}]", repositoryMetaData.type(), repositoryMetaData.name()).     Repository.Factory factory = factories.get(repositoryMetaData.type()).     if (factory == null) {         throw new RepositoryException(repositoryMetaData.name(), "repository type [" + repositoryMetaData.type() + "] does not exist").     }     try {         Repository repository = factory.create(repositoryMetaData, factories::get).         repository.start().         return repository.     } catch (Exception e) {         logger.warn(new ParameterizedMessage("failed to create repository [{}][{}]", repositoryMetaData.type(), repositoryMetaData.name()), e).         throw new RepositoryException(repositoryMetaData.name(), "failed to create repository", e).     } }
false;private;2;5;;private void ensureRepositoryNotInUse(ClusterState clusterState, String repository) {     if (SnapshotsService.isRepositoryInUse(clusterState, repository) || RestoreService.isRepositoryInUse(clusterState, repository)) {         throw new IllegalStateException("trying to modify or unregister repository that is currently used ").     } }
false;public;1;8;;@Override public void onResponse(VerifyResponse verifyResponse) {     if (verifyResponse.failed()) {         listener.onFailure(new RepositoryVerificationException(name, verifyResponse.failureDescription())).     } else {         listener.onResponse(clusterStateUpdateResponse).     } }
false;public;1;4;;@Override public void onFailure(Exception e) {     listener.onFailure(e). }
false;public;1;23;;@Override public void onResponse(final ClusterStateUpdateResponse clusterStateUpdateResponse) {     if (clusterStateUpdateResponse.isAcknowledged()) {         // The response was acknowledged - all nodes should know about the new repository, let's verify them         verifyRepository(name, new ActionListener<VerifyResponse>() {              @Override             public void onResponse(VerifyResponse verifyResponse) {                 if (verifyResponse.failed()) {                     listener.onFailure(new RepositoryVerificationException(name, verifyResponse.failureDescription())).                 } else {                     listener.onResponse(clusterStateUpdateResponse).                 }             }              @Override             public void onFailure(Exception e) {                 listener.onFailure(e).             }         }).     } else {         listener.onResponse(clusterStateUpdateResponse).     } }
false;public;1;4;;@Override public void onFailure(Exception e) {     listener.onFailure(e). }
true;public;1;4;/**  * Sets repository settings  *  * @param settings repository settings  * @return this request  */ ;/**  * Sets repository settings  *  * @param settings repository settings  * @return this request  */ public RegisterRepositoryRequest settings(Settings settings) {     this.settings = settings.     return this. }
false;public;0;3;;public VerificationFailure[] failures() {     return failures. }
false;public;0;3;;public DiscoveryNode[] nodes() {     return nodes. }
false;public;0;3;;public boolean failed() {     return failures.length > 0. }
false;public;0;6;;public String failureDescription() {     return Arrays.stream(failures).map(failure -> failure.toString()).collect(Collectors.joining(", ", "[", "]")). }
