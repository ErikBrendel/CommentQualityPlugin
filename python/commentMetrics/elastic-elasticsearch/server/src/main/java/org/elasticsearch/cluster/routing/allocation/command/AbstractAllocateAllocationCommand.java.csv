commented;modifiers;parameterAmount;loc;comment;code
false;protected,static;1;7;;protected static <T extends Builder<?>> ObjectParser<T, Void> createAllocateParser(String command) {     ObjectParser<T, Void> parser = new ObjectParser<>(command).     parser.declareString(Builder::setIndex, new ParseField(INDEX_FIELD)).     parser.declareInt(Builder::setShard, new ParseField(SHARD_FIELD)).     parser.declareString(Builder::setNode, new ParseField(NODE_FIELD)).     return parser. }
false;public;1;3;;public void setIndex(String index) {     this.index = index. }
false;public;1;3;;public void setShard(int shard) {     this.shard = shard. }
false;public;1;3;;public void setNode(String node) {     this.node = node. }
false;public,abstract;1;1;;public abstract Builder<T> parse(XContentParser parser) throws IOException.
false;public,abstract;0;1;;public abstract T build().
false;protected;0;11;;protected void validate() {     if (index == null) {         throw new IllegalArgumentException("Argument [index] must be defined").     }     if (shard < 0) {         throw new IllegalArgumentException("Argument [shard] must be defined and non-negative").     }     if (node == null) {         throw new IllegalArgumentException("Argument [node] must be defined").     } }
false;public;1;6;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeString(index).     out.writeVInt(shardId).     out.writeString(node). }
true;public;0;3;/**  * Get the index name  *  * @return name of the index  */ ;/**  * Get the index name  *  * @return name of the index  */ public String index() {     return this.index. }
true;public;0;3;/**  * Get the shard id  *  * @return id of the shard  */ ;/**  * Get the shard id  *  * @return id of the shard  */ public int shardId() {     return this.shardId. }
true;public;0;3;/**  * Get the id of the node  *  * @return id of the node  */ ;/**  * Get the id of the node  *  * @return id of the node  */ public String node() {     return this.node. }
true;protected;3;7;/**  * Handle case where a disco node cannot be found in the routing table. Usually means that it's not a data node.  */ ;/**  * Handle case where a disco node cannot be found in the routing table. Usually means that it's not a data node.  */ protected RerouteExplanation explainOrThrowMissingRoutingNode(RoutingAllocation allocation, boolean explain, DiscoveryNode discoNode) {     if (!discoNode.isDataNode()) {         return explainOrThrowRejectedCommand(explain, allocation, "allocation can only be done on data nodes, not [" + node + "]").     } else {         return explainOrThrowRejectedCommand(explain, allocation, "could not find [" + node + "] among the routing nodes").     } }
true;protected;3;6;/**  * Utility method for rejecting the current allocation command based on provided reason  */ ;/**  * Utility method for rejecting the current allocation command based on provided reason  */ protected RerouteExplanation explainOrThrowRejectedCommand(boolean explain, RoutingAllocation allocation, String reason) {     if (explain) {         return new RerouteExplanation(this, allocation.decision(Decision.NO, name() + " (allocation command)", reason)).     }     throw new IllegalArgumentException("[" + name() + "] " + reason). }
true;protected;3;6;/**  * Utility method for rejecting the current allocation command based on provided exception  */ ;/**  * Utility method for rejecting the current allocation command based on provided exception  */ protected RerouteExplanation explainOrThrowRejectedCommand(boolean explain, RoutingAllocation allocation, RuntimeException rte) {     if (explain) {         return new RerouteExplanation(this, allocation.decision(Decision.NO, name() + " (allocation command)", rte.getMessage())).     }     throw rte. }
true;protected;4;4;/**  * Initializes an unassigned shard on a node and removes it from the unassigned  *  * @param allocation the allocation  * @param routingNodes the routing nodes  * @param routingNode the node to initialize it to  * @param shardRouting the shard routing that is to be matched in unassigned shards  */ ;/**  * Initializes an unassigned shard on a node and removes it from the unassigned  *  * @param allocation the allocation  * @param routingNodes the routing nodes  * @param routingNode the node to initialize it to  * @param shardRouting the shard routing that is to be matched in unassigned shards  */ protected void initializeUnassignedShard(RoutingAllocation allocation, RoutingNodes routingNodes, RoutingNode routingNode, ShardRouting shardRouting) {     initializeUnassignedShard(allocation, routingNodes, routingNode, shardRouting, null, null). }
true;protected;6;18;/**  * Initializes an unassigned shard on a node and removes it from the unassigned  *  * @param allocation the allocation  * @param routingNodes the routing nodes  * @param routingNode the node to initialize it to  * @param shardRouting the shard routing that is to be matched in unassigned shards  * @param unassignedInfo unassigned info to override  * @param recoverySource recovery source to override  */ ;/**  * Initializes an unassigned shard on a node and removes it from the unassigned  *  * @param allocation the allocation  * @param routingNodes the routing nodes  * @param routingNode the node to initialize it to  * @param shardRouting the shard routing that is to be matched in unassigned shards  * @param unassignedInfo unassigned info to override  * @param recoverySource recovery source to override  */ protected void initializeUnassignedShard(RoutingAllocation allocation, RoutingNodes routingNodes, RoutingNode routingNode, ShardRouting shardRouting, @Nullable UnassignedInfo unassignedInfo, @Nullable RecoverySource recoverySource) {     for (RoutingNodes.UnassignedShards.UnassignedIterator it = routingNodes.unassigned().iterator(). it.hasNext(). ) {         ShardRouting unassigned = it.next().         if (!unassigned.equalsIgnoringMetaData(shardRouting)) {             continue.         }         if (unassignedInfo != null || recoverySource != null) {             unassigned = it.updateUnassigned(unassignedInfo != null ? unassignedInfo : unassigned.unassignedInfo(), recoverySource != null ? recoverySource : unassigned.recoverySource(), allocation.changes()).         }         it.initialize(routingNode.nodeId(), null, allocation.clusterInfo().getShardSize(unassigned, ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE), allocation.changes()).         return.     }     assert false : "shard to initialize not found in list of unassigned shards". }
false;public;2;9;;@Override public XContentBuilder toXContent(XContentBuilder builder, ToXContent.Params params) throws IOException {     builder.startObject().     builder.field(INDEX_FIELD, index()).     builder.field(SHARD_FIELD, shardId()).     builder.field(NODE_FIELD, node()).     extraXContent(builder).     return builder.endObject(). }
false;protected;1;2;;protected void extraXContent(XContentBuilder builder) throws IOException { }
false;public;1;11;;@Override public boolean equals(Object obj) {     if (obj == null || getClass() != obj.getClass()) {         return false.     }     AbstractAllocateAllocationCommand other = (AbstractAllocateAllocationCommand) obj.     // Override equals and hashCode for testing     return Objects.equals(index, other.index) && Objects.equals(shardId, other.shardId) && Objects.equals(node, other.node). }
false;public;0;5;;@Override public int hashCode() {     // Override equals and hashCode for testing     return Objects.hash(index, shardId, node). }
