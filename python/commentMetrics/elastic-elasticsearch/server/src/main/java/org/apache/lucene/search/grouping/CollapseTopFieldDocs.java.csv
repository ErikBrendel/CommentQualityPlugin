commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String toString() {     return "ShardRef(shardIndex=" + shardIndex + " hitIndex=" + hitIndex + ")". }
false;;1;12;;int getShardIndex(ScoreDoc scoreDoc) {     if (useScoreDocIndex) {         if (scoreDoc.shardIndex == -1) {             throw new IllegalArgumentException("setShardIndex is false but TopDocs[" + shardIndex + "].scoreDocs[" + hitIndex + "] is not set").         }         return scoreDoc.shardIndex.     } else {         // NOTE: we don't assert that shardIndex is -1 here, because caller could in fact have set it but asked us to ignore it now         return shardIndex.     } }
true;static;4;15;/**  * if we need to tie-break since score / sort value are the same we first compare shard index (lower shard wins)  * and then iff shard index is the same we use the hit index.  */ ;/**  * if we need to tie-break since score / sort value are the same we first compare shard index (lower shard wins)  * and then iff shard index is the same we use the hit index.  */ static boolean tieBreakLessThan(ShardRef first, ScoreDoc firstDoc, ShardRef second, ScoreDoc secondDoc) {     final int firstShardIndex = first.getShardIndex(firstDoc).     final int secondShardIndex = second.getShardIndex(secondDoc).     // Tie break: earlier shard wins     if (firstShardIndex < secondShardIndex) {         return true.     } else if (firstShardIndex > secondShardIndex) {         return false.     } else {         // shard had resolved it:         assert first.hitIndex != second.hitIndex.         return first.hitIndex < second.hitIndex.     } }
true;public;2;18;// Returns true if first is < second ;// Returns true if first is < second @Override public boolean lessThan(ShardRef first, ShardRef second) {     assert first != second.     final FieldDoc firstFD = (FieldDoc) shardHits[first.shardIndex][first.hitIndex].     final FieldDoc secondFD = (FieldDoc) shardHits[second.shardIndex][second.hitIndex].     for (int compIDX = 0. compIDX < comparators.length. compIDX++) {         final FieldComparator comp = comparators[compIDX].         final int cmp = reverseMul[compIDX] * comp.compareValues(firstFD.fields[compIDX], secondFD.fields[compIDX]).         if (cmp != 0) {             return cmp < 0.         }     }     return tieBreakLessThan(first, firstFD, second, secondFD). }
true;public,static;5;81;/**  * Returns a new CollapseTopDocs, containing topN collapsed results across  * the provided CollapseTopDocs, sorting by score. Each {@link CollapseTopFieldDocs} instance must be sorted.  */ ;/**  * Returns a new CollapseTopDocs, containing topN collapsed results across  * the provided CollapseTopDocs, sorting by score. Each {@link CollapseTopFieldDocs} instance must be sorted.  */ public static CollapseTopFieldDocs merge(Sort sort, int start, int size, CollapseTopFieldDocs[] shardHits, boolean setShardIndex) {     String collapseField = shardHits[0].field.     for (int i = 1. i < shardHits.length. i++) {         if (collapseField.equals(shardHits[i].field) == false) {             throw new IllegalArgumentException("collapse field differ across shards [" + collapseField + "] != [" + shardHits[i].field + "]").         }     }     final PriorityQueue<ShardRef> queue = new MergeSortQueue(sort, shardHits).     long totalHitCount = 0.     int availHitCount = 0.     TotalHits.Relation totalHitsRelation = TotalHits.Relation.EQUAL_TO.     for (int shardIDX = 0. shardIDX < shardHits.length. shardIDX++) {         final CollapseTopFieldDocs shard = shardHits[shardIDX].         // totalHits can be non-zero even if no hits were         // collected, when searchAfter was used:         totalHitCount += shard.totalHits.value.         // total hit count is a lower bound as well         if (shard.totalHits.relation == TotalHits.Relation.GREATER_THAN_OR_EQUAL_TO) {             totalHitsRelation = TotalHits.Relation.GREATER_THAN_OR_EQUAL_TO.         }         if (shard.scoreDocs != null && shard.scoreDocs.length > 0) {             availHitCount += shard.scoreDocs.length.             queue.add(new ShardRef(shardIDX, setShardIndex == false)).         }     }     final ScoreDoc[] hits.     final Object[] values.     if (availHitCount <= start) {         hits = new ScoreDoc[0].         values = new Object[0].     } else {         List<ScoreDoc> hitList = new ArrayList<>().         List<Object> collapseList = new ArrayList<>().         int requestedResultWindow = start + size.         int numIterOnHits = Math.min(availHitCount, requestedResultWindow).         int hitUpto = 0.         Set<Object> seen = new HashSet<>().         while (hitUpto < numIterOnHits) {             if (queue.size() == 0) {                 break.             }             ShardRef ref = queue.top().             final ScoreDoc hit = shardHits[ref.shardIndex].scoreDocs[ref.hitIndex].             final Object collapseValue = shardHits[ref.shardIndex].collapseValues[ref.hitIndex++].             if (seen.contains(collapseValue)) {                 if (ref.hitIndex < shardHits[ref.shardIndex].scoreDocs.length) {                     queue.updateTop().                 } else {                     queue.pop().                 }                 continue.             }             seen.add(collapseValue).             if (setShardIndex) {                 hit.shardIndex = ref.shardIndex.             }             if (hitUpto >= start) {                 hitList.add(hit).                 collapseList.add(collapseValue).             }             hitUpto++.             if (ref.hitIndex < shardHits[ref.shardIndex].scoreDocs.length) {                 // Not done with this these TopDocs yet:                 queue.updateTop().             } else {                 queue.pop().             }         }         hits = hitList.toArray(new ScoreDoc[0]).         values = collapseList.toArray(new Object[0]).     }     TotalHits totalHits = new TotalHits(totalHitCount, totalHitsRelation).     return new CollapseTopFieldDocs(collapseField, totalHits, hits, sort.getSort(), values). }
