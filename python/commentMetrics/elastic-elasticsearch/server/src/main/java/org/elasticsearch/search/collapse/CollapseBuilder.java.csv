commented;modifiers;parameterAmount;loc;comment;code
false;public;1;6;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeString(field).     out.writeVInt(maxConcurrentGroupRequests).     out.writeList(innerHits). }
false;public,static;1;3;;public static CollapseBuilder fromXContent(XContentParser parser) {     return PARSER.apply(parser, null). }
true;private;1;7;// for object parser only ;// for object parser only private CollapseBuilder setField(String field) {     if (Strings.isEmpty(field)) {         throw new IllegalArgumentException("field name is null or empty").     }     this.field = field.     return this. }
false;public;1;4;;public CollapseBuilder setInnerHits(InnerHitBuilder innerHit) {     this.innerHits = Collections.singletonList(innerHit).     return this. }
false;public;1;4;;public CollapseBuilder setInnerHits(List<InnerHitBuilder> innerHits) {     this.innerHits = innerHits.     return this. }
false;public;1;7;;public CollapseBuilder setMaxConcurrentGroupRequests(int num) {     if (num < 1) {         throw new IllegalArgumentException("maxConcurrentGroupRequests` must be positive").     }     this.maxConcurrentGroupRequests = num.     return this. }
true;public;0;3;/**  * The name of the field to collapse against  */ ;/**  * The name of the field to collapse against  */ public String getField() {     return this.field. }
true;public;0;3;/**  * The inner hit options to expand the collapsed results  */ ;/**  * The inner hit options to expand the collapsed results  */ public List<InnerHitBuilder> getInnerHits() {     return this.innerHits. }
true;public;0;3;/**  * Returns the amount of group requests that are allowed to be ran concurrently in the inner_hits phase.  */ ;/**  * Returns the amount of group requests that are allowed to be ran concurrently in the inner_hits phase.  */ public int getMaxConcurrentGroupRequests() {     return maxConcurrentGroupRequests. }
false;public;2;7;;@Override public XContentBuilder toXContent(XContentBuilder builder, ToXContent.Params params) throws IOException {     builder.startObject().     innerToXContent(builder).     builder.endObject().     return builder. }
false;private;1;17;;private void innerToXContent(XContentBuilder builder) throws IOException {     builder.field(FIELD_FIELD.getPreferredName(), field).     if (maxConcurrentGroupRequests > 0) {         builder.field(MAX_CONCURRENT_GROUP_REQUESTS_FIELD.getPreferredName(), maxConcurrentGroupRequests).     }     if (innerHits.isEmpty() == false) {         if (innerHits.size() == 1) {             builder.field(INNER_HITS_FIELD.getPreferredName(), innerHits.get(0)).         } else {             builder.startArray(INNER_HITS_FIELD.getPreferredName()).             for (InnerHitBuilder innerHit : innerHits) {                 innerHit.toXContent(builder, ToXContent.EMPTY_PARAMS).             }             builder.endArray().         }     } }
false;public;1;11;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     CollapseBuilder that = (CollapseBuilder) o.     if (maxConcurrentGroupRequests != that.maxConcurrentGroupRequests)         return false.     if (!field.equals(that.field))         return false.     return Objects.equals(innerHits, that.innerHits). }
false;public;0;6;;@Override public int hashCode() {     int result = Objects.hash(field, innerHits).     result = 31 * result + maxConcurrentGroupRequests.     return result. }
false;public;1;31;;public CollapseContext build(SearchContext context) {     if (context.scrollContext() != null) {         throw new SearchContextException(context, "cannot use `collapse` in a scroll context").     }     if (context.searchAfter() != null) {         throw new SearchContextException(context, "cannot use `collapse` in conjunction with `search_after`").     }     if (context.rescore() != null && context.rescore().isEmpty() == false) {         throw new SearchContextException(context, "cannot use `collapse` in conjunction with `rescore`").     }     MappedFieldType fieldType = context.getQueryShardContext().fieldMapper(field).     if (fieldType == null) {         throw new SearchContextException(context, "no mapping found for `" + field + "` in order to collapse on").     }     if (fieldType instanceof KeywordFieldMapper.KeywordFieldType == false && fieldType instanceof NumberFieldMapper.NumberFieldType == false) {         throw new SearchContextException(context, "unknown type for collapse field `" + field + "`, only keywords and numbers are accepted").     }     if (fieldType.hasDocValues() == false) {         throw new SearchContextException(context, "cannot collapse on field `" + field + "` without `doc_values`").     }     if (fieldType.indexOptions() == IndexOptions.NONE && (innerHits != null && !innerHits.isEmpty())) {         throw new SearchContextException(context, "cannot expand `inner_hits` for collapse field `" + field + "`, " + "only indexed field can retrieve `inner_hits`").     }     return new CollapseContext(field, fieldType, innerHits). }
