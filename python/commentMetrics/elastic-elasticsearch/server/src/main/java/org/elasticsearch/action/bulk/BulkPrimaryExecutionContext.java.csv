commented;modifiers;parameterAmount;loc;comment;code
false;private;1;7;;private int findNextNonAborted(int startIndex) {     final int length = request.items().length.     while (startIndex < length && isAborted(request.items()[startIndex].getPrimaryResponse())) {         startIndex++.     }     return startIndex. }
false;private,static;1;3;;private static boolean isAborted(BulkItemResponse response) {     return response != null && response.isFailed() && response.getFailure().isAborted(). }
true;private;0;10;/**  * move to the next item to execute  */ ;/**  * move to the next item to execute  */ private void advance() {     assert currentItemState == ItemProcessingState.COMPLETED || currentIndex == -1 : "moving to next but current item wasn't completed (state: " + currentItemState + ")".     currentItemState = ItemProcessingState.INITIAL.     currentIndex = findNextNonAborted(currentIndex + 1).     retryCounter = 0.     requestToExecute = null.     executionResult = null.     assert assertInvariants(ItemProcessingState.INITIAL). }
true;public;0;3;/**  * gets the current, untranslated item request  */ ;/**  * gets the current, untranslated item request  */ public DocWriteRequest<?> getCurrent() {     return getCurrentItem().request(). }
false;public;0;3;;public BulkShardRequest getBulkShardRequest() {     return request. }
true;public;0;4;/**  * returns the result of the request that has been executed on the shard  */ ;/**  * returns the result of the request that has been executed on the shard  */ public BulkItemResponse getExecutionResult() {     assert assertInvariants(ItemProcessingState.EXECUTED).     return executionResult. }
true;public;0;3;/**  * returns the number of times the current operation has been retried  */ ;/**  * returns the number of times the current operation has been retried  */ public int getRetryCounter() {     return retryCounter. }
true;public;0;3;/**  * returns true if the current request has been executed on the primary  */ ;/**  * returns true if the current request has been executed on the primary  */ public boolean isOperationExecuted() {     return currentItemState == ItemProcessingState.EXECUTED. }
true;public;0;3;/**  * returns true if the request needs to wait for a mapping update to arrive from the master  */ ;/**  * returns true if the request needs to wait for a mapping update to arrive from the master  */ public boolean requiresWaitingForMappingUpdate() {     return currentItemState == ItemProcessingState.WAIT_FOR_MAPPING_UPDATE. }
true;public;0;3;/**  * returns true if the current request should be retried without waiting for an external event  */ ;/**  * returns true if the current request should be retried without waiting for an external event  */ public boolean requiresImmediateRetry() {     return currentItemState == ItemProcessingState.IMMEDIATE_RETRY. }
true;public;0;3;/**  * returns true if the current request has been completed and it's result translated to a user  * facing response  */ ;/**  * returns true if the current request has been completed and it's result translated to a user  * facing response  */ public boolean isCompleted() {     return currentItemState == ItemProcessingState.COMPLETED. }
true;public;0;3;/**  * returns true if the current request is in INITIAL state  */ ;/**  * returns true if the current request is in INITIAL state  */ public boolean isInitial() {     return currentItemState == ItemProcessingState.INITIAL. }
true;public;0;3;/**  * returns true if {@link #advance()} has moved the current item beyond the  * end of the {@link BulkShardRequest#items()} array.  */ ;/**  * returns true if {@link #advance()} has moved the current item beyond the  * end of the {@link BulkShardRequest#items()} array.  */ public boolean hasMoreOperationsToExecute() {     return currentIndex < request.items().length. }
true;public;0;3;/**  * returns the name of the index the current request used  */ ;/**  * returns the name of the index the current request used  */ public String getConcreteIndex() {     return getCurrentItem().index(). }
true;public;0;6;/**  * returns a translog location that is needed to be synced in order to persist all operations executed so far  */ ;/**  * returns a translog location that is needed to be synced in order to persist all operations executed so far  */ public Translog.Location getLocationToSync() {     assert hasMoreOperationsToExecute() == false.     // we always get to the end of the list by using advance, which in turn sets the state to INITIAL     assert assertInvariants(ItemProcessingState.INITIAL).     return locationToSync. }
false;private;0;3;;private BulkItemRequest getCurrentItem() {     return request.items()[currentIndex]. }
true;public;0;3;/**  * returns the primary shard  */ ;/**  * returns the primary shard  */ public IndexShard getPrimary() {     return primary. }
true;public;1;6;/**  * sets the request that should actually be executed on the primary. This can be different then the request  * received from the user (specifically, an update request is translated to an indexing or delete request).  */ ;/**  * sets the request that should actually be executed on the primary. This can be different then the request  * received from the user (specifically, an update request is translated to an indexing or delete request).  */ public void setRequestToExecute(DocWriteRequest writeRequest) {     assert assertInvariants(ItemProcessingState.INITIAL).     requestToExecute = writeRequest.     currentItemState = ItemProcessingState.TRANSLATED.     assert assertInvariants(ItemProcessingState.TRANSLATED). }
true;public;0;4;/**  * returns the request that should be executed on the shard.  */ ;/**  * returns the request that should be executed on the shard.  */ public <T extends DocWriteRequest<T>> T getRequestToExecute() {     assert assertInvariants(ItemProcessingState.TRANSLATED).     return (T) requestToExecute. }
true;public;0;6;/**  * indicates that the current operation can not be completed and needs to wait for a new mapping from the master  */ ;/**  * indicates that the current operation can not be completed and needs to wait for a new mapping from the master  */ public void markAsRequiringMappingUpdate() {     assert assertInvariants(ItemProcessingState.TRANSLATED).     currentItemState = ItemProcessingState.WAIT_FOR_MAPPING_UPDATE.     requestToExecute = null.     assert assertInvariants(ItemProcessingState.WAIT_FOR_MAPPING_UPDATE). }
true;public;0;7;/**  * resets the current item state, prepare for a new execution  */ ;/**  * resets the current item state, prepare for a new execution  */ public void resetForExecutionForRetry() {     assertInvariants(ItemProcessingState.WAIT_FOR_MAPPING_UPDATE, ItemProcessingState.EXECUTED).     currentItemState = ItemProcessingState.INITIAL.     requestToExecute = null.     executionResult = null.     assertInvariants(ItemProcessingState.INITIAL). }
true;public;1;6;/**  * completes the operation without doing anything on the primary  */ ;/**  * completes the operation without doing anything on the primary  */ public void markOperationAsNoOp(DocWriteResponse response) {     assertInvariants(ItemProcessingState.INITIAL).     executionResult = new BulkItemResponse(getCurrentItem().id(), getCurrentItem().request().opType(), response).     currentItemState = ItemProcessingState.EXECUTED.     assertInvariants(ItemProcessingState.EXECUTED). }
true;public;1;10;/**  * indicates that the operation needs to be failed as the required mapping didn't arrive in time  */ ;/**  * indicates that the operation needs to be failed as the required mapping didn't arrive in time  */ public void failOnMappingUpdate(Exception cause) {     assert assertInvariants(ItemProcessingState.WAIT_FOR_MAPPING_UPDATE).     currentItemState = ItemProcessingState.EXECUTED.     final DocWriteRequest docWriteRequest = getCurrentItem().request().     executionResult = new BulkItemResponse(getCurrentItem().id(), docWriteRequest.opType(), // concrete index instead of an alias if used!     new BulkItemResponse.Failure(getCurrentItem().index(), docWriteRequest.type(), docWriteRequest.id(), cause)).     markAsCompleted(executionResult). }
true;public;1;37;/**  * the current operation has been executed on the primary with the specified result  */ ;/**  * the current operation has been executed on the primary with the specified result  */ public void markOperationAsExecuted(Engine.Result result) {     assertInvariants(ItemProcessingState.TRANSLATED).     final BulkItemRequest current = getCurrentItem().     DocWriteRequest docWriteRequest = getRequestToExecute().     switch(result.getResultType()) {         case SUCCESS:             final DocWriteResponse response.             if (result.getOperationType() == Engine.Operation.TYPE.INDEX) {                 Engine.IndexResult indexResult = (Engine.IndexResult) result.                 response = new IndexResponse(primary.shardId(), requestToExecute.type(), requestToExecute.id(), result.getSeqNo(), result.getTerm(), indexResult.getVersion(), indexResult.isCreated()).             } else if (result.getOperationType() == Engine.Operation.TYPE.DELETE) {                 Engine.DeleteResult deleteResult = (Engine.DeleteResult) result.                 response = new DeleteResponse(primary.shardId(), requestToExecute.type(), requestToExecute.id(), deleteResult.getSeqNo(), result.getTerm(), deleteResult.getVersion(), deleteResult.isFound()).             } else {                 throw new AssertionError("unknown result type :" + result.getResultType()).             }             executionResult = new BulkItemResponse(current.id(), current.request().opType(), response).             // set a blank ShardInfo so we can safely send it to the replicas. We won't use it in the real response though.             executionResult.getResponse().setShardInfo(new ReplicationResponse.ShardInfo()).             locationToSync = TransportWriteAction.locationToSync(locationToSync, result.getTranslogLocation()).             break.         case FAILURE:             executionResult = new BulkItemResponse(current.id(), docWriteRequest.opType(), // concrete index instead of an alias if used!             new BulkItemResponse.Failure(request.index(), docWriteRequest.type(), docWriteRequest.id(), result.getFailure(), result.getSeqNo())).             break.         default:             throw new AssertionError("unknown result type for " + getCurrentItem() + ": " + result.getResultType()).     }     currentItemState = ItemProcessingState.EXECUTED. }
true;public;1;12;/**  * finishes the execution of the current request, with the response that should be returned to the user  */ ;/**  * finishes the execution of the current request, with the response that should be returned to the user  */ public void markAsCompleted(BulkItemResponse translatedResponse) {     assertInvariants(ItemProcessingState.EXECUTED).     assert executionResult != null && translatedResponse.getItemId() == executionResult.getItemId().     assert translatedResponse.getItemId() == getCurrentItem().id().     if (translatedResponse.isFailed() == false && requestToExecute != null && requestToExecute != getCurrent()) {         request.items()[currentIndex] = new BulkItemRequest(request.items()[currentIndex].id(), requestToExecute).     }     getCurrentItem().setPrimaryResponse(translatedResponse).     currentItemState = ItemProcessingState.COMPLETED.     advance(). }
true;public;0;5;/**  * builds the bulk shard response to return to the user  */ ;/**  * builds the bulk shard response to return to the user  */ public BulkShardResponse buildShardResponse() {     assert hasMoreOperationsToExecute() == false.     return new BulkShardResponse(request.shardId(), Arrays.stream(request.items()).map(BulkItemRequest::getPrimaryResponse).toArray(BulkItemResponse[]::new)). }
false;private;1;34;;private boolean assertInvariants(ItemProcessingState... expectedCurrentState) {     assert Arrays.asList(expectedCurrentState).contains(currentItemState) : "expected current state [" + currentItemState + "] to be one of " + Arrays.toString(expectedCurrentState).     assert currentIndex >= 0 : currentIndex.     assert retryCounter >= 0 : retryCounter.     switch(currentItemState) {         case INITIAL:             assert requestToExecute == null : requestToExecute.             assert executionResult == null : executionResult.             break.         case TRANSLATED:             assert requestToExecute != null.             assert executionResult == null : executionResult.             break.         case WAIT_FOR_MAPPING_UPDATE:             assert requestToExecute == null.             assert executionResult == null : executionResult.             break.         case IMMEDIATE_RETRY:             assert requestToExecute != null.             assert executionResult == null : executionResult.             break.         case EXECUTED:             // requestToExecute can be null if the update ended up as NOOP             assert executionResult != null.             break.         case COMPLETED:             assert requestToExecute != null.             assert executionResult != null.             assert getCurrentItem().getPrimaryResponse() != null.             break.     }     return true. }
