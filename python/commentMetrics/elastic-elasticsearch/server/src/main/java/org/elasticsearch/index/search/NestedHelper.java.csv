commented;modifiers;parameterAmount;loc;comment;code
true;public;1;46;/**  * Returns true if the given query might match nested documents.  */ ;/**  * Returns true if the given query might match nested documents.  */ public boolean mightMatchNestedDocs(Query query) {     if (query instanceof ConstantScoreQuery) {         return mightMatchNestedDocs(((ConstantScoreQuery) query).getQuery()).     } else if (query instanceof BoostQuery) {         return mightMatchNestedDocs(((BoostQuery) query).getQuery()).     } else if (query instanceof MatchAllDocsQuery) {         return true.     } else if (query instanceof MatchNoDocsQuery) {         return false.     } else if (query instanceof TermQuery) {         // cover a high majority of use-cases         return mightMatchNestedDocs(((TermQuery) query).getTerm().field()).     } else if (query instanceof TermInSetQuery) {         PrefixCodedTerms terms = ((TermInSetQuery) query).getTermData().         if (terms.size() > 0) {             PrefixCodedTerms.TermIterator it = terms.iterator().             it.next().             return mightMatchNestedDocs(it.field()).         } else {             return false.         }     } else if (query instanceof PointRangeQuery) {         return mightMatchNestedDocs(((PointRangeQuery) query).getField()).     } else if (query instanceof IndexOrDocValuesQuery) {         return mightMatchNestedDocs(((IndexOrDocValuesQuery) query).getIndexQuery()).     } else if (query instanceof BooleanQuery) {         final BooleanQuery bq = (BooleanQuery) query.         final boolean hasRequiredClauses = bq.clauses().stream().anyMatch(BooleanClause::isRequired).         if (hasRequiredClauses) {             return bq.clauses().stream().filter(BooleanClause::isRequired).map(BooleanClause::getQuery).allMatch(this::mightMatchNestedDocs).         } else {             return bq.clauses().stream().filter(c -> c.getOccur() == Occur.SHOULD).map(BooleanClause::getQuery).anyMatch(this::mightMatchNestedDocs).         }     } else if (query instanceof ESToParentBlockJoinQuery) {         return ((ESToParentBlockJoinQuery) query).getPath() != null.     } else {         return true.     } }
true;;1;21;/**  * Returns true if a query on the given field might match nested documents.  */ ;/**  * Returns true if a query on the given field might match nested documents.  */ boolean mightMatchNestedDocs(String field) {     if (field.startsWith("_")) {         // we might add a nested filter when it is nor required.         return true.     }     if (mapperService.fullName(field) == null) {         // field does not exist         return false.     }     for (String parent = parentObject(field). parent != null. parent = parentObject(parent)) {         ObjectMapper mapper = mapperService.getObjectMapper(parent).         if (mapper != null && mapper.nested().isNested()) {             return true.         }     }     return false. }
true;public;2;42;/**  * Returns true if the given query might match parent documents or documents  *  that are nested under a different path.  */ ;/**  * Returns true if the given query might match parent documents or documents  *  that are nested under a different path.  */ public boolean mightMatchNonNestedDocs(Query query, String nestedPath) {     if (query instanceof ConstantScoreQuery) {         return mightMatchNonNestedDocs(((ConstantScoreQuery) query).getQuery(), nestedPath).     } else if (query instanceof BoostQuery) {         return mightMatchNonNestedDocs(((BoostQuery) query).getQuery(), nestedPath).     } else if (query instanceof MatchAllDocsQuery) {         return true.     } else if (query instanceof MatchNoDocsQuery) {         return false.     } else if (query instanceof TermQuery) {         return mightMatchNonNestedDocs(((TermQuery) query).getTerm().field(), nestedPath).     } else if (query instanceof TermInSetQuery) {         PrefixCodedTerms terms = ((TermInSetQuery) query).getTermData().         if (terms.size() > 0) {             PrefixCodedTerms.TermIterator it = terms.iterator().             it.next().             return mightMatchNonNestedDocs(it.field(), nestedPath).         } else {             return false.         }     } else if (query instanceof PointRangeQuery) {         return mightMatchNonNestedDocs(((PointRangeQuery) query).getField(), nestedPath).     } else if (query instanceof IndexOrDocValuesQuery) {         return mightMatchNonNestedDocs(((IndexOrDocValuesQuery) query).getIndexQuery(), nestedPath).     } else if (query instanceof BooleanQuery) {         final BooleanQuery bq = (BooleanQuery) query.         final boolean hasRequiredClauses = bq.clauses().stream().anyMatch(BooleanClause::isRequired).         if (hasRequiredClauses) {             return bq.clauses().stream().filter(BooleanClause::isRequired).map(BooleanClause::getQuery).allMatch(q -> mightMatchNonNestedDocs(q, nestedPath)).         } else {             return bq.clauses().stream().filter(c -> c.getOccur() == Occur.SHOULD).map(BooleanClause::getQuery).anyMatch(q -> mightMatchNonNestedDocs(q, nestedPath)).         }     } else {         return true.     } }
true;;2;28;/**  * Returns true if a query on the given field might match parent documents  *  or documents that are nested under a different path.  */ ;/**  * Returns true if a query on the given field might match parent documents  *  or documents that are nested under a different path.  */ boolean mightMatchNonNestedDocs(String field, String nestedPath) {     if (field.startsWith("_")) {         // we might add a nested filter when it is nor required.         return true.     }     if (mapperService.fullName(field) == null) {         return false.     }     for (String parent = parentObject(field). parent != null. parent = parentObject(parent)) {         ObjectMapper mapper = mapperService.getObjectMapper(parent).         if (mapper != null && mapper.nested().isNested()) {             if (mapper.fullPath().equals(nestedPath)) {                 // the query might only match nested documents with the given path                 return mapper.nested().isIncludeInParent() || mapper.nested().isIncludeInRoot().             } else {                 // It might be misconfiguration or a sub nested mapper                 return true.             }         }     }     // the field is not a sub field of the nested path     return true. }
false;private,static;1;7;;private static String parentObject(String field) {     int lastDot = field.lastIndexOf('.').     if (lastDot == -1) {         return null.     }     return field.substring(0, lastDot). }
