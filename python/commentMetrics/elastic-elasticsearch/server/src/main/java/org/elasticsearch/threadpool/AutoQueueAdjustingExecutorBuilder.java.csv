commented;modifiers;parameterAmount;loc;comment;code
false;public;1;3;;@Override public void validate(Integer value) { }
false;public;2;7;;@Override public void validate(Integer value, Map<Setting<Integer>, Integer> settings) {     if (value > settings.get(tempMaxQueueSizeSetting)) {         throw new IllegalArgumentException("Failed to parse value [" + value + "] for setting [" + minSizeKey + "] must be <= " + settings.get(tempMaxQueueSizeSetting)).     } }
false;public;0;4;;@Override public Iterator<Setting<Integer>> settings() {     return Arrays.asList(tempMaxQueueSizeSetting).iterator(). }
false;public;1;3;;@Override public void validate(Integer value) { }
false;public;2;7;;@Override public void validate(Integer value, Map<Setting<Integer>, Integer> settings) {     if (value < settings.get(tempMinQueueSizeSetting)) {         throw new IllegalArgumentException("Failed to parse value [" + value + "] for setting [" + minSizeKey + "] must be >= " + settings.get(tempMinQueueSizeSetting)).     } }
false;public;0;4;;@Override public Iterator<Setting<Integer>> settings() {     return Arrays.asList(tempMinQueueSizeSetting).iterator(). }
false;public;0;5;;@Override public List<Setting<?>> getRegisteredSettings() {     return Arrays.asList(sizeSetting, queueSizeSetting, minQueueSizeSetting, maxQueueSizeSetting, frameSizeSetting, targetedResponseTimeSetting). }
false;;1;11;;@Override AutoExecutorSettings getSettings(Settings settings) {     final String nodeName = Node.NODE_NAME_SETTING.get(settings).     final int size = sizeSetting.get(settings).     final int initialQueueSize = queueSizeSetting.get(settings).     final int minQueueSize = minQueueSizeSetting.get(settings).     final int maxQueueSize = maxQueueSizeSetting.get(settings).     final int frameSize = frameSizeSetting.get(settings).     final TimeValue targetedResponseTime = targetedResponseTimeSetting.get(settings).     return new AutoExecutorSettings(nodeName, size, initialQueueSize, minQueueSize, maxQueueSize, frameSize, targetedResponseTime). }
false;;2;27;;@Override ThreadPool.ExecutorHolder build(final AutoExecutorSettings settings, final ThreadContext threadContext) {     int size = settings.size.     int initialQueueSize = settings.initialQueueSize.     int minQueueSize = settings.minQueueSize.     int maxQueueSize = settings.maxQueueSize.     int frameSize = settings.frameSize.     TimeValue targetedResponseTime = settings.targetedResponseTime.     final ThreadFactory threadFactory = EsExecutors.daemonThreadFactory(EsExecutors.threadName(settings.nodeName, name())).     final ExecutorService executor = EsExecutors.newAutoQueueFixed(settings.nodeName + "/" + name(), size, initialQueueSize, minQueueSize, maxQueueSize, frameSize, targetedResponseTime, threadFactory, threadContext).     // TODO: in a subsequent change we hope to extend ThreadPool.Info to be more specific for the thread pool type     final ThreadPool.Info info = new ThreadPool.Info(name(), ThreadPool.ThreadPoolType.FIXED_AUTO_QUEUE_SIZE, size, size, null, new SizeValue(initialQueueSize)).     return new ThreadPool.ExecutorHolder(executor, info). }
false;;1;9;;@Override String formatInfo(ThreadPool.Info info) {     return String.format(Locale.ROOT, "name [%s], size [%d], queue size [%s]", info.getName(), info.getMax(), info.getQueueSize() == null ? "unbounded" : info.getQueueSize()). }
