commented;modifiers;parameterAmount;loc;comment;code
false;public;1;7;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeInt(requiredSize).     out.writeInt(shardSize).     out.writeLong(minDocCount).     out.writeLong(shardMinDocCount). }
false;public;0;22;;public void ensureValidity() {     // <size>     if (shardSize < requiredSize) {         setShardSize(requiredSize).     }     // the min_doc_count criteria     if (shardMinDocCount > minDocCount) {         setShardMinDocCount(minDocCount).     }     if (requiredSize <= 0 || shardSize <= 0) {         throw new ElasticsearchException("parameters [required_size] and [shard_size] must be >0 in terms aggregation.").     }     if (minDocCount < 0 || shardMinDocCount < 0) {         throw new ElasticsearchException("parameter [min_doc_count] and [shardMinDocCount] must be >=0 in terms aggregation.").     } }
false;public;0;3;;public long getShardMinDocCount() {     return shardMinDocCount. }
false;public;1;3;;public void setShardMinDocCount(long shardMinDocCount) {     this.shardMinDocCount = shardMinDocCount. }
false;public;0;3;;public long getMinDocCount() {     return minDocCount. }
false;public;1;3;;public void setMinDocCount(long minDocCount) {     this.minDocCount = minDocCount. }
false;public;0;3;;public int getRequiredSize() {     return requiredSize. }
false;public;1;3;;public void setRequiredSize(int requiredSize) {     this.requiredSize = requiredSize. }
false;public;0;3;;public int getShardSize() {     return shardSize. }
false;public;1;3;;public void setShardSize(int shardSize) {     this.shardSize = shardSize. }
false;public;2;10;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.field(TermsAggregationBuilder.REQUIRED_SIZE_FIELD_NAME.getPreferredName(), requiredSize).     if (shardSize != -1) {         builder.field(TermsAggregationBuilder.SHARD_SIZE_FIELD_NAME.getPreferredName(), shardSize).     }     builder.field(TermsAggregationBuilder.MIN_DOC_COUNT_FIELD_NAME.getPreferredName(), minDocCount).     builder.field(TermsAggregationBuilder.SHARD_MIN_DOC_COUNT_FIELD_NAME.getPreferredName(), shardMinDocCount).     return builder. }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(requiredSize, shardSize, minDocCount, shardMinDocCount). }
false;public;1;14;;@Override public boolean equals(Object obj) {     if (obj == null) {         return false.     }     if (getClass() != obj.getClass()) {         return false.     }     BucketCountThresholds other = (BucketCountThresholds) obj.     return Objects.equals(requiredSize, other.requiredSize) && Objects.equals(shardSize, other.shardSize) && Objects.equals(minDocCount, other.minDocCount) && Objects.equals(shardMinDocCount, other.shardMinDocCount). }
false;static;1;9;;static boolean descendsFromNestedAggregator(Aggregator parent) {     while (parent != null) {         if (parent.getClass() == NestedAggregator.class) {             return true.         }         parent = parent.parent().     }     return false. }
false;private;0;8;;private boolean subAggsNeedScore() {     for (Aggregator subAgg : subAggregators) {         if (subAgg.scoreMode().needsScores()) {             return true.         }     }     return false. }
true;public;2;38;/**  * Internal Optimization for ordering {@link InternalTerms.Bucket}s by a sub aggregation.  * <p>  * in this phase, if the order is based on sub-aggregations, we need to use a different comparator  * to avoid constructing buckets for ordering purposes (we can potentially have a lot of buckets and building  * them will cause loads of redundant object constructions). The "special" comparators here will fetch the  * sub aggregation values directly from the sub aggregators bypassing bucket creation. Note that the comparator  * attached to the order will still be used in the reduce phase of the Aggregation.  *  * @param path determines which sub aggregation to use for ordering.  * @param asc  {@code true} for ascending order, {@code false} for descending.  * @return {@code Comparator} to order {@link InternalTerms.Bucket}s in the desired order.  */ ;/**  * Internal Optimization for ordering {@link InternalTerms.Bucket}s by a sub aggregation.  * <p>  * in this phase, if the order is based on sub-aggregations, we need to use a different comparator  * to avoid constructing buckets for ordering purposes (we can potentially have a lot of buckets and building  * them will cause loads of redundant object constructions). The "special" comparators here will fetch the  * sub aggregation values directly from the sub aggregators bypassing bucket creation. Note that the comparator  * attached to the order will still be used in the reduce phase of the Aggregation.  *  * @param path determines which sub aggregation to use for ordering.  * @param asc  {@code true} for ascending order, {@code false} for descending.  * @return {@code Comparator} to order {@link InternalTerms.Bucket}s in the desired order.  */ public Comparator<Bucket> bucketComparator(AggregationPath path, boolean asc) {     final Aggregator aggregator = path.resolveAggregator(this).     final String key = path.lastPathElement().key.     if (aggregator instanceof SingleBucketAggregator) {         assert key == null : "this should be picked up before the aggregation is executed - on validate".         return (b1, b2) -> {             int mul = asc ? 1 : -1.             int v1 = ((SingleBucketAggregator) aggregator).bucketDocCount(((InternalTerms.Bucket) b1).bucketOrd).             int v2 = ((SingleBucketAggregator) aggregator).bucketDocCount(((InternalTerms.Bucket) b2).bucketOrd).             return mul * (v1 - v2).         }.     }     // with only support single-bucket aggregators     assert !(aggregator instanceof BucketsAggregator) : "this should be picked up before the aggregation is executed - on validate".     if (aggregator instanceof NumericMetricsAggregator.MultiValue) {         assert key != null : "this should be picked up before the aggregation is executed - on validate".         return (b1, b2) -> {             double v1 = ((NumericMetricsAggregator.MultiValue) aggregator).metric(key, ((InternalTerms.Bucket) b1).bucketOrd).             double v2 = ((NumericMetricsAggregator.MultiValue) aggregator).metric(key, ((InternalTerms.Bucket) b2).bucketOrd).             // the bottom             return Comparators.compareDiscardNaN(v1, v2, asc).         }.     }     // single-value metrics agg     return (b1, b2) -> {         double v1 = ((NumericMetricsAggregator.SingleValue) aggregator).metric(((InternalTerms.Bucket) b1).bucketOrd).         double v2 = ((NumericMetricsAggregator.SingleValue) aggregator).metric(((InternalTerms.Bucket) b2).bucketOrd).         // the bottom         return Comparators.compareDiscardNaN(v1, v2, asc).     }. }
false;protected;1;5;;@Override protected boolean shouldDefer(Aggregator aggregator) {     return collectMode == SubAggCollectionMode.BREADTH_FIRST && !aggsUsedForSorting.contains(aggregator). }
