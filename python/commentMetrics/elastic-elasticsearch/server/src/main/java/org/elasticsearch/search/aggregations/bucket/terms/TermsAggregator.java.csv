# id;timestamp;commentText;codeText;commentWords;codeWords
TermsAggregator -> public Comparator<Bucket> bucketComparator(AggregationPath path, boolean asc);1524684173;Internal Optimization for ordering {@link InternalTerms.Bucket}s by a sub aggregation._<p>_in this phase, if the order is based on sub-aggregations, we need to use a different comparator_to avoid constructing buckets for ordering purposes (we can potentially have a lot of buckets and building_them will cause loads of redundant object constructions). The "special" comparators here will fetch the_sub aggregation values directly from the sub aggregators bypassing bucket creation. Note that the comparator_attached to the order will still be used in the reduce phase of the Aggregation.__@param path determines which sub aggregation to use for ordering._@param asc  {@code true} for ascending order, {@code false} for descending._@return {@code Comparator} to order {@link InternalTerms.Bucket}s in the desired order.;public Comparator<Bucket> bucketComparator(AggregationPath path, boolean asc) {__        final Aggregator aggregator = path.resolveAggregator(this)__        final String key = path.lastPathElement().key___        if (aggregator instanceof SingleBucketAggregator) {_            assert key == null : "this should be picked up before the aggregation is executed - on validate"__            return (b1, b2) -> {_                int mul = asc ? 1 : -1__                int v1 = ((SingleBucketAggregator) aggregator).bucketDocCount(((InternalTerms.Bucket) b1).bucketOrd)__                int v2 = ((SingleBucketAggregator) aggregator).bucketDocCount(((InternalTerms.Bucket) b2).bucketOrd)__                return mul * (v1 - v2)__            }__        }__        _        assert !(aggregator instanceof BucketsAggregator) : "this should be picked up before the aggregation is executed - on validate"___        if (aggregator instanceof NumericMetricsAggregator.MultiValue) {_            assert key != null : "this should be picked up before the aggregation is executed - on validate"__            return (b1, b2) -> {_                double v1 = ((NumericMetricsAggregator.MultiValue) aggregator).metric(key, ((InternalTerms.Bucket) b1).bucketOrd)__                double v2 = ((NumericMetricsAggregator.MultiValue) aggregator).metric(key, ((InternalTerms.Bucket) b2).bucketOrd)__                _                _                return Comparators.compareDiscardNaN(v1, v2, asc)__            }__        }__        _        return (b1, b2) -> {_            double v1 = ((NumericMetricsAggregator.SingleValue) aggregator).metric(((InternalTerms.Bucket) b1).bucketOrd)__            double v2 = ((NumericMetricsAggregator.SingleValue) aggregator).metric(((InternalTerms.Bucket) b2).bucketOrd)__            _            _            return Comparators.compareDiscardNaN(v1, v2, asc)__        }__    };internal,optimization,for,ordering,link,internal,terms,bucket,s,by,a,sub,aggregation,p,in,this,phase,if,the,order,is,based,on,sub,aggregations,we,need,to,use,a,different,comparator,to,avoid,constructing,buckets,for,ordering,purposes,we,can,potentially,have,a,lot,of,buckets,and,building,them,will,cause,loads,of,redundant,object,constructions,the,special,comparators,here,will,fetch,the,sub,aggregation,values,directly,from,the,sub,aggregators,bypassing,bucket,creation,note,that,the,comparator,attached,to,the,order,will,still,be,used,in,the,reduce,phase,of,the,aggregation,param,path,determines,which,sub,aggregation,to,use,for,ordering,param,asc,code,true,for,ascending,order,code,false,for,descending,return,code,comparator,to,order,link,internal,terms,bucket,s,in,the,desired,order;public,comparator,bucket,bucket,comparator,aggregation,path,path,boolean,asc,final,aggregator,aggregator,path,resolve,aggregator,this,final,string,key,path,last,path,element,key,if,aggregator,instanceof,single,bucket,aggregator,assert,key,null,this,should,be,picked,up,before,the,aggregation,is,executed,on,validate,return,b1,b2,int,mul,asc,1,1,int,v1,single,bucket,aggregator,aggregator,bucket,doc,count,internal,terms,bucket,b1,bucket,ord,int,v2,single,bucket,aggregator,aggregator,bucket,doc,count,internal,terms,bucket,b2,bucket,ord,return,mul,v1,v2,assert,aggregator,instanceof,buckets,aggregator,this,should,be,picked,up,before,the,aggregation,is,executed,on,validate,if,aggregator,instanceof,numeric,metrics,aggregator,multi,value,assert,key,null,this,should,be,picked,up,before,the,aggregation,is,executed,on,validate,return,b1,b2,double,v1,numeric,metrics,aggregator,multi,value,aggregator,metric,key,internal,terms,bucket,b1,bucket,ord,double,v2,numeric,metrics,aggregator,multi,value,aggregator,metric,key,internal,terms,bucket,b2,bucket,ord,return,comparators,compare,discard,na,n,v1,v2,asc,return,b1,b2,double,v1,numeric,metrics,aggregator,single,value,aggregator,metric,internal,terms,bucket,b1,bucket,ord,double,v2,numeric,metrics,aggregator,single,value,aggregator,metric,internal,terms,bucket,b2,bucket,ord,return,comparators,compare,discard,na,n,v1,v2,asc
TermsAggregator -> public Comparator<Bucket> bucketComparator(AggregationPath path, boolean asc);1536314350;Internal Optimization for ordering {@link InternalTerms.Bucket}s by a sub aggregation._<p>_in this phase, if the order is based on sub-aggregations, we need to use a different comparator_to avoid constructing buckets for ordering purposes (we can potentially have a lot of buckets and building_them will cause loads of redundant object constructions). The "special" comparators here will fetch the_sub aggregation values directly from the sub aggregators bypassing bucket creation. Note that the comparator_attached to the order will still be used in the reduce phase of the Aggregation.__@param path determines which sub aggregation to use for ordering._@param asc  {@code true} for ascending order, {@code false} for descending._@return {@code Comparator} to order {@link InternalTerms.Bucket}s in the desired order.;public Comparator<Bucket> bucketComparator(AggregationPath path, boolean asc) {__        final Aggregator aggregator = path.resolveAggregator(this)__        final String key = path.lastPathElement().key___        if (aggregator instanceof SingleBucketAggregator) {_            assert key == null : "this should be picked up before the aggregation is executed - on validate"__            return (b1, b2) -> {_                int mul = asc ? 1 : -1__                int v1 = ((SingleBucketAggregator) aggregator).bucketDocCount(((InternalTerms.Bucket) b1).bucketOrd)__                int v2 = ((SingleBucketAggregator) aggregator).bucketDocCount(((InternalTerms.Bucket) b2).bucketOrd)__                return mul * (v1 - v2)__            }__        }__        _        assert !(aggregator instanceof BucketsAggregator) : "this should be picked up before the aggregation is executed - on validate"___        if (aggregator instanceof NumericMetricsAggregator.MultiValue) {_            assert key != null : "this should be picked up before the aggregation is executed - on validate"__            return (b1, b2) -> {_                double v1 = ((NumericMetricsAggregator.MultiValue) aggregator).metric(key, ((InternalTerms.Bucket) b1).bucketOrd)__                double v2 = ((NumericMetricsAggregator.MultiValue) aggregator).metric(key, ((InternalTerms.Bucket) b2).bucketOrd)__                _                _                return Comparators.compareDiscardNaN(v1, v2, asc)__            }__        }__        _        return (b1, b2) -> {_            double v1 = ((NumericMetricsAggregator.SingleValue) aggregator).metric(((InternalTerms.Bucket) b1).bucketOrd)__            double v2 = ((NumericMetricsAggregator.SingleValue) aggregator).metric(((InternalTerms.Bucket) b2).bucketOrd)__            _            _            return Comparators.compareDiscardNaN(v1, v2, asc)__        }__    };internal,optimization,for,ordering,link,internal,terms,bucket,s,by,a,sub,aggregation,p,in,this,phase,if,the,order,is,based,on,sub,aggregations,we,need,to,use,a,different,comparator,to,avoid,constructing,buckets,for,ordering,purposes,we,can,potentially,have,a,lot,of,buckets,and,building,them,will,cause,loads,of,redundant,object,constructions,the,special,comparators,here,will,fetch,the,sub,aggregation,values,directly,from,the,sub,aggregators,bypassing,bucket,creation,note,that,the,comparator,attached,to,the,order,will,still,be,used,in,the,reduce,phase,of,the,aggregation,param,path,determines,which,sub,aggregation,to,use,for,ordering,param,asc,code,true,for,ascending,order,code,false,for,descending,return,code,comparator,to,order,link,internal,terms,bucket,s,in,the,desired,order;public,comparator,bucket,bucket,comparator,aggregation,path,path,boolean,asc,final,aggregator,aggregator,path,resolve,aggregator,this,final,string,key,path,last,path,element,key,if,aggregator,instanceof,single,bucket,aggregator,assert,key,null,this,should,be,picked,up,before,the,aggregation,is,executed,on,validate,return,b1,b2,int,mul,asc,1,1,int,v1,single,bucket,aggregator,aggregator,bucket,doc,count,internal,terms,bucket,b1,bucket,ord,int,v2,single,bucket,aggregator,aggregator,bucket,doc,count,internal,terms,bucket,b2,bucket,ord,return,mul,v1,v2,assert,aggregator,instanceof,buckets,aggregator,this,should,be,picked,up,before,the,aggregation,is,executed,on,validate,if,aggregator,instanceof,numeric,metrics,aggregator,multi,value,assert,key,null,this,should,be,picked,up,before,the,aggregation,is,executed,on,validate,return,b1,b2,double,v1,numeric,metrics,aggregator,multi,value,aggregator,metric,key,internal,terms,bucket,b1,bucket,ord,double,v2,numeric,metrics,aggregator,multi,value,aggregator,metric,key,internal,terms,bucket,b2,bucket,ord,return,comparators,compare,discard,na,n,v1,v2,asc,return,b1,b2,double,v1,numeric,metrics,aggregator,single,value,aggregator,metric,internal,terms,bucket,b1,bucket,ord,double,v2,numeric,metrics,aggregator,single,value,aggregator,metric,internal,terms,bucket,b2,bucket,ord,return,comparators,compare,discard,na,n,v1,v2,asc
TermsAggregator -> public Comparator<Bucket> bucketComparator(AggregationPath path, boolean asc);1544110272;Internal Optimization for ordering {@link InternalTerms.Bucket}s by a sub aggregation._<p>_in this phase, if the order is based on sub-aggregations, we need to use a different comparator_to avoid constructing buckets for ordering purposes (we can potentially have a lot of buckets and building_them will cause loads of redundant object constructions). The "special" comparators here will fetch the_sub aggregation values directly from the sub aggregators bypassing bucket creation. Note that the comparator_attached to the order will still be used in the reduce phase of the Aggregation.__@param path determines which sub aggregation to use for ordering._@param asc  {@code true} for ascending order, {@code false} for descending._@return {@code Comparator} to order {@link InternalTerms.Bucket}s in the desired order.;public Comparator<Bucket> bucketComparator(AggregationPath path, boolean asc) {__        final Aggregator aggregator = path.resolveAggregator(this)__        final String key = path.lastPathElement().key___        if (aggregator instanceof SingleBucketAggregator) {_            assert key == null : "this should be picked up before the aggregation is executed - on validate"__            return (b1, b2) -> {_                int mul = asc ? 1 : -1__                int v1 = ((SingleBucketAggregator) aggregator).bucketDocCount(((InternalTerms.Bucket) b1).bucketOrd)__                int v2 = ((SingleBucketAggregator) aggregator).bucketDocCount(((InternalTerms.Bucket) b2).bucketOrd)__                return mul * (v1 - v2)__            }__        }__        _        assert !(aggregator instanceof BucketsAggregator) : "this should be picked up before the aggregation is executed - on validate"___        if (aggregator instanceof NumericMetricsAggregator.MultiValue) {_            assert key != null : "this should be picked up before the aggregation is executed - on validate"__            return (b1, b2) -> {_                double v1 = ((NumericMetricsAggregator.MultiValue) aggregator).metric(key, ((InternalTerms.Bucket) b1).bucketOrd)__                double v2 = ((NumericMetricsAggregator.MultiValue) aggregator).metric(key, ((InternalTerms.Bucket) b2).bucketOrd)__                _                _                return Comparators.compareDiscardNaN(v1, v2, asc)__            }__        }__        _        return (b1, b2) -> {_            double v1 = ((NumericMetricsAggregator.SingleValue) aggregator).metric(((InternalTerms.Bucket) b1).bucketOrd)__            double v2 = ((NumericMetricsAggregator.SingleValue) aggregator).metric(((InternalTerms.Bucket) b2).bucketOrd)__            _            _            return Comparators.compareDiscardNaN(v1, v2, asc)__        }__    };internal,optimization,for,ordering,link,internal,terms,bucket,s,by,a,sub,aggregation,p,in,this,phase,if,the,order,is,based,on,sub,aggregations,we,need,to,use,a,different,comparator,to,avoid,constructing,buckets,for,ordering,purposes,we,can,potentially,have,a,lot,of,buckets,and,building,them,will,cause,loads,of,redundant,object,constructions,the,special,comparators,here,will,fetch,the,sub,aggregation,values,directly,from,the,sub,aggregators,bypassing,bucket,creation,note,that,the,comparator,attached,to,the,order,will,still,be,used,in,the,reduce,phase,of,the,aggregation,param,path,determines,which,sub,aggregation,to,use,for,ordering,param,asc,code,true,for,ascending,order,code,false,for,descending,return,code,comparator,to,order,link,internal,terms,bucket,s,in,the,desired,order;public,comparator,bucket,bucket,comparator,aggregation,path,path,boolean,asc,final,aggregator,aggregator,path,resolve,aggregator,this,final,string,key,path,last,path,element,key,if,aggregator,instanceof,single,bucket,aggregator,assert,key,null,this,should,be,picked,up,before,the,aggregation,is,executed,on,validate,return,b1,b2,int,mul,asc,1,1,int,v1,single,bucket,aggregator,aggregator,bucket,doc,count,internal,terms,bucket,b1,bucket,ord,int,v2,single,bucket,aggregator,aggregator,bucket,doc,count,internal,terms,bucket,b2,bucket,ord,return,mul,v1,v2,assert,aggregator,instanceof,buckets,aggregator,this,should,be,picked,up,before,the,aggregation,is,executed,on,validate,if,aggregator,instanceof,numeric,metrics,aggregator,multi,value,assert,key,null,this,should,be,picked,up,before,the,aggregation,is,executed,on,validate,return,b1,b2,double,v1,numeric,metrics,aggregator,multi,value,aggregator,metric,key,internal,terms,bucket,b1,bucket,ord,double,v2,numeric,metrics,aggregator,multi,value,aggregator,metric,key,internal,terms,bucket,b2,bucket,ord,return,comparators,compare,discard,na,n,v1,v2,asc,return,b1,b2,double,v1,numeric,metrics,aggregator,single,value,aggregator,metric,internal,terms,bucket,b1,bucket,ord,double,v2,numeric,metrics,aggregator,single,value,aggregator,metric,internal,terms,bucket,b2,bucket,ord,return,comparators,compare,discard,na,n,v1,v2,asc
TermsAggregator -> BucketCountThresholds -> public BucketCountThresholds(StreamInput in) throws IOException;1524684173;Read from a stream.;public BucketCountThresholds(StreamInput in) throws IOException {_            requiredSize = in.readInt()__            shardSize = in.readInt()__            minDocCount = in.readLong()__            shardMinDocCount = in.readLong()__        };read,from,a,stream;public,bucket,count,thresholds,stream,input,in,throws,ioexception,required,size,in,read,int,shard,size,in,read,int,min,doc,count,in,read,long,shard,min,doc,count,in,read,long
TermsAggregator -> BucketCountThresholds -> public BucketCountThresholds(StreamInput in) throws IOException;1536314350;Read from a stream.;public BucketCountThresholds(StreamInput in) throws IOException {_            requiredSize = in.readInt()__            shardSize = in.readInt()__            minDocCount = in.readLong()__            shardMinDocCount = in.readLong()__        };read,from,a,stream;public,bucket,count,thresholds,stream,input,in,throws,ioexception,required,size,in,read,int,shard,size,in,read,int,min,doc,count,in,read,long,shard,min,doc,count,in,read,long
TermsAggregator -> BucketCountThresholds -> public BucketCountThresholds(StreamInput in) throws IOException;1544110272;Read from a stream.;public BucketCountThresholds(StreamInput in) throws IOException {_            requiredSize = in.readInt()__            shardSize = in.readInt()__            minDocCount = in.readLong()__            shardMinDocCount = in.readLong()__        };read,from,a,stream;public,bucket,count,thresholds,stream,input,in,throws,ioexception,required,size,in,read,int,shard,size,in,read,int,min,doc,count,in,read,long,shard,min,doc,count,in,read,long
