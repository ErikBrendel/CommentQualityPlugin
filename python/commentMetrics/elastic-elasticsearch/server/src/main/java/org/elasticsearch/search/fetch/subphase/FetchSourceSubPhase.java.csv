commented;modifiers;parameterAmount;loc;comment;code
false;public;2;45;;@Override public void hitExecute(SearchContext context, HitContext hitContext) {     if (context.sourceRequested() == false) {         return.     }     final boolean nestedHit = hitContext.hit().getNestedIdentity() != null.     SourceLookup source = context.lookup().source().     FetchSourceContext fetchSourceContext = context.fetchSourceContext().     assert fetchSourceContext.fetchSource().     if (nestedHit == false) {         if (fetchSourceContext.includes().length == 0 && fetchSourceContext.excludes().length == 0) {             hitContext.hit().sourceRef(source.internalSourceRef()).             return.         }         if (source.internalSourceRef() == null) {             throw new IllegalArgumentException("unable to fetch fields from _source field: _source is disabled in the mappings " + "for index [" + context.indexShard().shardId().getIndexName() + "]").         }     }     Object value = source.filter(fetchSourceContext).     if (nestedHit) {         value = getNestedSource((Map<String, Object>) value, hitContext).     }     try {         final int initialCapacity = nestedHit ? 1024 : Math.min(1024, source.internalSourceRef().length()).         BytesStreamOutput streamOutput = new BytesStreamOutput(initialCapacity).         XContentBuilder builder = new XContentBuilder(source.sourceContentType().xContent(), streamOutput).         if (value != null) {             builder.value(value).         } else {             // This happens if the source filtering could not find the specified in the _source.             // Just doing `builder.value(null)` is valid, but the xcontent validation can't detect what format             // it is. In certain cases, for example response serialization we fail if no xcontent type can't be             // detected. So instead we just return an empty top level object. Also this is in inline with what was             // being return in this situation in 5.x and earlier.             builder.startObject().             builder.endObject().         }         hitContext.hit().sourceRef(BytesReference.bytes(builder)).     } catch (IOException e) {         throw new ElasticsearchException("Error filtering source", e).     } }
false;private;2;9;;private Map<String, Object> getNestedSource(Map<String, Object> sourceAsMap, HitContext hitContext) {     for (SearchHit.NestedIdentity o = hitContext.hit().getNestedIdentity(). o != null. o = o.getChild()) {         sourceAsMap = (Map<String, Object>) sourceAsMap.get(o.getField().string()).         if (sourceAsMap == null) {             return null.         }     }     return sourceAsMap. }
