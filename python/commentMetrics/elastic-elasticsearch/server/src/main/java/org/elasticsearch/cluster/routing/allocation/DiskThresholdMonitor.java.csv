commented;modifiers;parameterAmount;loc;comment;code
true;private;1;25;/**  * Warn about the given disk usage if the low or high watermark has been passed  */ ;/**  * Warn about the given disk usage if the low or high watermark has been passed  */ private void warnAboutDiskIfNeeded(DiskUsage usage) {     // Check absolute disk values     if (usage.getFreeBytes() < diskThresholdSettings.getFreeBytesThresholdFloodStage().getBytes()) {         logger.warn("flood stage disk watermark [{}] exceeded on {}, all indices on this node will be marked read-only", diskThresholdSettings.getFreeBytesThresholdFloodStage(), usage).     } else if (usage.getFreeBytes() < diskThresholdSettings.getFreeBytesThresholdHigh().getBytes()) {         logger.warn("high disk watermark [{}] exceeded on {}, shards will be relocated away from this node", diskThresholdSettings.getFreeBytesThresholdHigh(), usage).     } else if (usage.getFreeBytes() < diskThresholdSettings.getFreeBytesThresholdLow().getBytes()) {         logger.info("low disk watermark [{}] exceeded on {}, replicas will not be assigned to this node", diskThresholdSettings.getFreeBytesThresholdLow(), usage).     }     // Check percentage disk values     if (usage.getFreeDiskAsPercentage() < diskThresholdSettings.getFreeDiskThresholdFloodStage()) {         logger.warn("flood stage disk watermark [{}] exceeded on {}, all indices on this node will be marked read-only", Strings.format1Decimals(100.0 - diskThresholdSettings.getFreeDiskThresholdFloodStage(), "%"), usage).     } else if (usage.getFreeDiskAsPercentage() < diskThresholdSettings.getFreeDiskThresholdHigh()) {         logger.warn("high disk watermark [{}] exceeded on {}, shards will be relocated away from this node", Strings.format1Decimals(100.0 - diskThresholdSettings.getFreeDiskThresholdHigh(), "%"), usage).     } else if (usage.getFreeDiskAsPercentage() < diskThresholdSettings.getFreeDiskThresholdLow()) {         logger.info("low disk watermark [{}] exceeded on {}, replicas will not be assigned to this node", Strings.format1Decimals(100.0 - diskThresholdSettings.getFreeDiskThresholdLow(), "%"), usage).     } }
false;public;1;72;;public void onNewInfo(ClusterInfo info) {     ImmutableOpenMap<String, DiskUsage> usages = info.getNodeLeastAvailableDiskUsages().     if (usages != null) {         boolean reroute = false.         String explanation = "".         // Garbage collect nodes that have been removed from the cluster         // from the map that tracks watermark crossing         ObjectLookupContainer<String> nodes = usages.keys().         for (String node : nodeHasPassedWatermark) {             if (nodes.contains(node) == false) {                 nodeHasPassedWatermark.remove(node).             }         }         ClusterState state = clusterStateSupplier.get().         Set<String> indicesToMarkReadOnly = new HashSet<>().         for (ObjectObjectCursor<String, DiskUsage> entry : usages) {             String node = entry.key.             DiskUsage usage = entry.value.             warnAboutDiskIfNeeded(usage).             if (usage.getFreeBytes() < diskThresholdSettings.getFreeBytesThresholdFloodStage().getBytes() || usage.getFreeDiskAsPercentage() < diskThresholdSettings.getFreeDiskThresholdFloodStage()) {                 RoutingNode routingNode = state.getRoutingNodes().node(node).                 if (routingNode != null) {                     // this might happen if we haven't got the full cluster-state yet?!                     for (ShardRouting routing : routingNode) {                         indicesToMarkReadOnly.add(routing.index().getName()).                     }                 }             } else if (usage.getFreeBytes() < diskThresholdSettings.getFreeBytesThresholdHigh().getBytes() || usage.getFreeDiskAsPercentage() < diskThresholdSettings.getFreeDiskThresholdHigh()) {                 if ((System.nanoTime() - lastRunNS) > diskThresholdSettings.getRerouteInterval().nanos()) {                     lastRunNS = System.nanoTime().                     reroute = true.                     explanation = "high disk watermark exceeded on one or more nodes".                 } else {                     logger.debug("high disk watermark exceeded on {} but an automatic reroute has occurred " + "in the last [{}], skipping reroute", node, diskThresholdSettings.getRerouteInterval()).                 }                 nodeHasPassedWatermark.add(node).             } else if (usage.getFreeBytes() < diskThresholdSettings.getFreeBytesThresholdLow().getBytes() || usage.getFreeDiskAsPercentage() < diskThresholdSettings.getFreeDiskThresholdLow()) {                 nodeHasPassedWatermark.add(node).             } else {                 if (nodeHasPassedWatermark.contains(node)) {                     // if they are able to be                     if ((System.nanoTime() - lastRunNS) > diskThresholdSettings.getRerouteInterval().nanos()) {                         lastRunNS = System.nanoTime().                         reroute = true.                         explanation = "one or more nodes has gone under the high or low watermark".                         nodeHasPassedWatermark.remove(node).                     } else {                         logger.debug("{} has gone below a disk threshold, but an automatic reroute has occurred " + "in the last [{}], skipping reroute", node, diskThresholdSettings.getRerouteInterval()).                     }                 }             }         }         if (reroute) {             logger.info("rerouting shards: [{}]", explanation).             reroute().         }         indicesToMarkReadOnly.removeIf(index -> state.getBlocks().indexBlocked(ClusterBlockLevel.WRITE, index)).         if (indicesToMarkReadOnly.isEmpty() == false) {             markIndicesReadOnly(indicesToMarkReadOnly).         }     } }
false;protected;1;5;;protected void markIndicesReadOnly(Set<String> indicesToMarkReadOnly) {     // set read-only block but don't block on the response     client.admin().indices().prepareUpdateSettings(indicesToMarkReadOnly.toArray(Strings.EMPTY_ARRAY)).setSettings(Settings.builder().put(IndexMetaData.SETTING_READ_ONLY_ALLOW_DELETE, true).build()).execute(). }
false;protected;0;4;;protected void reroute() {     // Execute an empty reroute, but don't block on the response     client.admin().cluster().prepareReroute().execute(). }
