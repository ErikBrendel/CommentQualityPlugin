commented;modifiers;parameterAmount;loc;comment;code
false;public;0;23;;public Map<String, IndexSegments> getIndices() {     if (indicesSegments != null) {         return indicesSegments.     }     Map<String, IndexSegments> indicesSegments = new HashMap<>().     Set<String> indices = new HashSet<>().     for (ShardSegments shard : shards) {         indices.add(shard.getShardRouting().getIndexName()).     }     for (String indexName : indices) {         List<ShardSegments> shards = new ArrayList<>().         for (ShardSegments shard : this.shards) {             if (shard.getShardRouting().getIndexName().equals(indexName)) {                 shards.add(shard).             }         }         indicesSegments.put(indexName, new IndexSegments(indexName, shards.toArray(new ShardSegments[shards.size()]))).     }     this.indicesSegments = indicesSegments.     return indicesSegments. }
false;public;1;8;;@Override public void readFrom(StreamInput in) throws IOException {     super.readFrom(in).     shards = new ShardSegments[in.readVInt()].     for (int i = 0. i < shards.length. i++) {         shards[i] = ShardSegments.readShardSegments(in).     } }
false;public;1;8;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeVInt(shards.length).     for (ShardSegments shard : shards) {         shard.writeTo(out).     } }
false;protected;2;72;;@Override protected void addCustomXContentFields(XContentBuilder builder, Params params) throws IOException {     builder.startObject(Fields.INDICES).     for (IndexSegments indexSegments : getIndices().values()) {         builder.startObject(indexSegments.getIndex()).         builder.startObject(Fields.SHARDS).         for (IndexShardSegments indexSegment : indexSegments) {             builder.startArray(Integer.toString(indexSegment.getShardId().id())).             for (ShardSegments shardSegments : indexSegment) {                 builder.startObject().                 builder.startObject(Fields.ROUTING).                 builder.field(Fields.STATE, shardSegments.getShardRouting().state()).                 builder.field(Fields.PRIMARY, shardSegments.getShardRouting().primary()).                 builder.field(Fields.NODE, shardSegments.getShardRouting().currentNodeId()).                 if (shardSegments.getShardRouting().relocatingNodeId() != null) {                     builder.field(Fields.RELOCATING_NODE, shardSegments.getShardRouting().relocatingNodeId()).                 }                 builder.endObject().                 builder.field(Fields.NUM_COMMITTED_SEGMENTS, shardSegments.getNumberOfCommitted()).                 builder.field(Fields.NUM_SEARCH_SEGMENTS, shardSegments.getNumberOfSearch()).                 builder.startObject(Fields.SEGMENTS).                 for (Segment segment : shardSegments) {                     builder.startObject(segment.getName()).                     builder.field(Fields.GENERATION, segment.getGeneration()).                     builder.field(Fields.NUM_DOCS, segment.getNumDocs()).                     builder.field(Fields.DELETED_DOCS, segment.getDeletedDocs()).                     builder.humanReadableField(Fields.SIZE_IN_BYTES, Fields.SIZE, segment.getSize()).                     builder.humanReadableField(Fields.MEMORY_IN_BYTES, Fields.MEMORY, new ByteSizeValue(segment.getMemoryInBytes())).                     builder.field(Fields.COMMITTED, segment.isCommitted()).                     builder.field(Fields.SEARCH, segment.isSearch()).                     if (segment.getVersion() != null) {                         builder.field(Fields.VERSION, segment.getVersion()).                     }                     if (segment.isCompound() != null) {                         builder.field(Fields.COMPOUND, segment.isCompound()).                     }                     if (segment.getMergeId() != null) {                         builder.field(Fields.MERGE_ID, segment.getMergeId()).                     }                     if (segment.getSegmentSort() != null) {                         toXContent(builder, segment.getSegmentSort()).                     }                     if (segment.ramTree != null) {                         builder.startArray(Fields.RAM_TREE).                         for (Accountable child : segment.ramTree.getChildResources()) {                             toXContent(builder, child).                         }                         builder.endArray().                     }                     if (segment.attributes != null && segment.attributes.isEmpty() == false) {                         builder.field("attributes", segment.attributes).                     }                     builder.endObject().                 }                 builder.endObject().                 builder.endObject().             }             builder.endArray().         }         builder.endObject().         builder.endObject().     }     builder.endObject(). }
false;private,static;2;20;;private static void toXContent(XContentBuilder builder, Sort sort) throws IOException {     builder.startArray("sort").     for (SortField field : sort.getSort()) {         builder.startObject().         builder.field("field", field.getField()).         if (field instanceof SortedNumericSortField) {             builder.field("mode", ((SortedNumericSortField) field).getSelector().toString().toLowerCase(Locale.ROOT)).         } else if (field instanceof SortedSetSortField) {             builder.field("mode", ((SortedSetSortField) field).getSelector().toString().toLowerCase(Locale.ROOT)).         }         if (field.getMissingValue() != null) {             builder.field("missing", field.getMissingValue().toString()).         }         builder.field("reverse", field.getReverse()).         builder.endObject().     }     builder.endArray(). }
false;private,static;2;14;;private static void toXContent(XContentBuilder builder, Accountable tree) throws IOException {     builder.startObject().     builder.field(Fields.DESCRIPTION, tree.toString()).     builder.humanReadableField(Fields.SIZE_IN_BYTES, Fields.SIZE, new ByteSizeValue(tree.ramBytesUsed())).     Collection<Accountable> children = tree.getChildResources().     if (children.isEmpty() == false) {         builder.startArray(Fields.CHILDREN).         for (Accountable child : children) {             toXContent(builder, child).         }         builder.endArray().     }     builder.endObject(). }
