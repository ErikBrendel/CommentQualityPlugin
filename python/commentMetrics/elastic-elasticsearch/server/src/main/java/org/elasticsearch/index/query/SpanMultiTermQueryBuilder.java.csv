commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;4;;@Override protected void doWriteTo(StreamOutput out) throws IOException {     out.writeNamedWriteable(multiTermQueryBuilder). }
false;public;0;3;;public MultiTermQueryBuilder innerQuery() {     return this.multiTermQueryBuilder. }
false;protected;2;9;;@Override protected void doXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject(NAME).     builder.field(MATCH_FIELD.getPreferredName()).     multiTermQueryBuilder.toXContent(builder, params).     printBoostAndQueryName(builder).     builder.endObject(). }
false;public,static;1;38;;public static SpanMultiTermQueryBuilder fromXContent(XContentParser parser) throws IOException {     String currentFieldName = null.     MultiTermQueryBuilder subQuery = null.     String queryName = null.     float boost = AbstractQueryBuilder.DEFAULT_BOOST.     XContentParser.Token token.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (token == XContentParser.Token.START_OBJECT) {             if (MATCH_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 QueryBuilder query = parseInnerQueryBuilder(parser).                 if (query instanceof MultiTermQueryBuilder == false) {                     throw new ParsingException(parser.getTokenLocation(), "[span_multi] [" + MATCH_FIELD.getPreferredName() + "] must be of type multi term query").                 }                 subQuery = (MultiTermQueryBuilder) query.             } else {                 throw new ParsingException(parser.getTokenLocation(), "[span_multi] query does not support [" + currentFieldName + "]").             }         } else if (token.isValue()) {             if (AbstractQueryBuilder.NAME_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 queryName = parser.text().             } else if (AbstractQueryBuilder.BOOST_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 boost = parser.floatValue().             } else {                 throw new ParsingException(parser.getTokenLocation(), "[span_multi] query does not support [" + currentFieldName + "]").             }         }     }     if (subQuery == null) {         throw new ParsingException(parser.getTokenLocation(), "[span_multi] must have [" + MATCH_FIELD.getPreferredName() + "] multi term query clause").     }     return new SpanMultiTermQueryBuilder(subQuery).queryName(queryName).boost(boost). }
false;protected;1;48;;@Override protected Query doToQuery(QueryShardContext context) throws IOException {     if (multiTermQueryBuilder instanceof PrefixQueryBuilder) {         PrefixQueryBuilder prefixBuilder = (PrefixQueryBuilder) multiTermQueryBuilder.         MappedFieldType fieldType = context.fieldMapper(multiTermQueryBuilder.fieldName()).         if (fieldType == null) {             return new SpanMatchNoDocsQuery(multiTermQueryBuilder.fieldName(), "unknown field").         }         final SpanMultiTermQueryWrapper.SpanRewriteMethod spanRewriteMethod.         if (prefixBuilder.rewrite() != null) {             MultiTermQuery.RewriteMethod rewriteMethod = QueryParsers.parseRewriteMethod(prefixBuilder.rewrite(), null, LoggingDeprecationHandler.INSTANCE).             if (rewriteMethod instanceof TopTermsRewrite) {                 TopTermsRewrite<?> innerRewrite = (TopTermsRewrite<?>) rewriteMethod.                 spanRewriteMethod = new SpanMultiTermQueryWrapper.TopTermsSpanBooleanQueryRewrite(innerRewrite.getSize()).             } else {                 spanRewriteMethod = new SpanBooleanQueryRewriteWithMaxClause().             }         } else {             spanRewriteMethod = new SpanBooleanQueryRewriteWithMaxClause().         }         return fieldType.spanPrefixQuery(prefixBuilder.value(), spanRewriteMethod, context).     } else {         Query subQuery = multiTermQueryBuilder.toQuery(context).         while (true) {             if (subQuery instanceof ConstantScoreQuery) {                 subQuery = ((ConstantScoreQuery) subQuery).getQuery().             } else if (subQuery instanceof BoostQuery) {                 BoostQuery boostQuery = (BoostQuery) subQuery.                 subQuery = boostQuery.getQuery().             } else {                 break.             }         }         if (subQuery instanceof MatchNoDocsQuery) {             return new SpanMatchNoDocsQuery(multiTermQueryBuilder.fieldName(), subQuery.toString()).         } else if (subQuery instanceof MultiTermQuery == false) {             throw new UnsupportedOperationException("unsupported inner query, should be " + MultiTermQuery.class.getName() + " but was " + subQuery.getClass().getName()).         }         MultiTermQuery multiTermQuery = (MultiTermQuery) subQuery.         SpanMultiTermQueryWrapper<?> wrapper = new SpanMultiTermQueryWrapper<>(multiTermQuery).         if (multiTermQuery.getRewriteMethod() instanceof TopTermsRewrite == false) {             wrapper.setRewriteMethod(new SpanBooleanQueryRewriteWithMaxClause()).         }         return wrapper.     } }
false;protected;0;4;;@Override protected int doHashCode() {     return Objects.hash(multiTermQueryBuilder). }
false;protected;1;4;;@Override protected boolean doEquals(SpanMultiTermQueryBuilder other) {     return Objects.equals(multiTermQueryBuilder, other.multiTermQueryBuilder). }
false;public;0;4;;@Override public String getWriteableName() {     return NAME. }
