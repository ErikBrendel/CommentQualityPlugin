commented;modifiers;parameterAmount;loc;comment;code
false;public;1;12;;@Override public Void visit(InstanceBinding<? extends T> binding) {     Set<InjectionPoint> injectionPoints = binding.getInjectionPoints().     T instance = binding.getInstance().     Initializable<T> ref = initializer.requestInjection(injector, instance, source, injectionPoints).     ConstantFactory<? extends T> factory = new ConstantFactory<>(ref).     InternalFactory<? extends T> scopedFactory = Scopes.scope(key, injector, factory, scoping).     putBinding(new InstanceBindingImpl<>(injector, key, source, scopedFactory, injectionPoints, instance)).     return null. }
false;public;1;12;;@Override public Void visit(ProviderInstanceBinding<? extends T> binding) {     Provider<? extends T> provider = binding.getProviderInstance().     Set<InjectionPoint> injectionPoints = binding.getInjectionPoints().     Initializable<Provider<? extends T>> initializable = initializer.<Provider<? extends T>>requestInjection(injector, provider, source, injectionPoints).     InternalFactory<T> factory = new InternalFactoryToProviderAdapter<>(initializable, source).     InternalFactory<? extends T> scopedFactory = Scopes.scope(key, injector, factory, scoping).     putBinding(new ProviderInstanceBindingImpl<>(injector, key, source, scopedFactory, scoping, provider, injectionPoints)).     return null. }
false;public;1;12;;@Override public Void visit(ProviderKeyBinding<? extends T> binding) {     Key<? extends Provider<? extends T>> providerKey = binding.getProviderKey().     BoundProviderFactory<T> boundProviderFactory = new BoundProviderFactory<>(injector, providerKey, source).     creationListeners.add(boundProviderFactory).     InternalFactory<? extends T> scopedFactory = Scopes.scope(key, injector, (InternalFactory<? extends T>) boundProviderFactory, scoping).     putBinding(new LinkedProviderBindingImpl<>(injector, key, source, scopedFactory, scoping, providerKey)).     return null. }
false;public;1;14;;@Override public Void visit(LinkedKeyBinding<? extends T> binding) {     Key<? extends T> linkedKey = binding.getLinkedKey().     if (key.equals(linkedKey)) {         errors.recursiveBinding().     }     FactoryProxy<T> factory = new FactoryProxy<>(injector, key, linkedKey, source).     creationListeners.add(factory).     InternalFactory<? extends T> scopedFactory = Scopes.scope(key, injector, factory, scoping).     putBinding(new LinkedBindingImpl<>(injector, key, source, scopedFactory, scoping, linkedKey)).     return null. }
false;public;0;9;;@Override public void run() {     try {         ((InjectorImpl) binding.getInjector()).initializeBinding(binding, errors.withSource(source)).     } catch (ErrorsException e) {         errors.merge(e.getErrors()).     } }
false;public;1;37;;@Override public Void visit(UntargettedBinding<? extends T> untargetted) {     // @ImplementedBy annotation or something.     if (key.hasAnnotationType()) {         errors.missingImplementation(key).         putBinding(invalidBinding(injector, key, source)).         return null.     }     // This cast is safe after the preceding check.     final BindingImpl<T> binding.     try {         binding = injector.createUnitializedBinding(key, scoping, source, errors).         putBinding(binding).     } catch (ErrorsException e) {         errors.merge(e.getErrors()).         putBinding(invalidBinding(injector, key, source)).         return null.     }     uninitializedBindings.add(new Runnable() {          @Override         public void run() {             try {                 ((InjectorImpl) binding.getInjector()).initializeBinding(binding, errors.withSource(source)).             } catch (ErrorsException e) {                 errors.merge(e.getErrors()).             }         }     }).     return null. }
false;public;1;4;;@Override public Void visit(ExposedBinding<? extends T> binding) {     throw new IllegalArgumentException("Cannot apply a non-module element"). }
false;public;1;4;;@Override public Void visit(ConvertedConstantBinding<? extends T> binding) {     throw new IllegalArgumentException("Cannot apply a non-module element"). }
false;public;1;4;;@Override public Void visit(ConstructorBinding<? extends T> binding) {     throw new IllegalArgumentException("Cannot apply a non-module element"). }
false;public;1;4;;@Override public Void visit(ProviderBinding<? extends T> binding) {     throw new IllegalArgumentException("Cannot apply a non-module element"). }
false;public;1;144;;@Override public <T> Boolean visit(Binding<T> command) {     final Object source = command.getSource().     if (Void.class.equals(command.getKey().getRawType())) {         if (command instanceof ProviderInstanceBinding && ((ProviderInstanceBinding<?>) command).getProviderInstance() instanceof ProviderMethod) {             errors.voidProviderMethod().         } else {             errors.missingConstantValues().         }         return true.     }     final Key<T> key = command.getKey().     Class<? super T> rawType = key.getTypeLiteral().getRawType().     if (rawType == Provider.class) {         errors.bindingToProvider().         return true.     }     validateKey(command.getSource(), command.getKey()).     final Scoping scoping = Scopes.makeInjectable(((BindingImpl<?>) command).getScoping(), injector, errors).     command.acceptTargetVisitor(new BindingTargetVisitor<T, Void>() {          @Override         public Void visit(InstanceBinding<? extends T> binding) {             Set<InjectionPoint> injectionPoints = binding.getInjectionPoints().             T instance = binding.getInstance().             Initializable<T> ref = initializer.requestInjection(injector, instance, source, injectionPoints).             ConstantFactory<? extends T> factory = new ConstantFactory<>(ref).             InternalFactory<? extends T> scopedFactory = Scopes.scope(key, injector, factory, scoping).             putBinding(new InstanceBindingImpl<>(injector, key, source, scopedFactory, injectionPoints, instance)).             return null.         }          @Override         public Void visit(ProviderInstanceBinding<? extends T> binding) {             Provider<? extends T> provider = binding.getProviderInstance().             Set<InjectionPoint> injectionPoints = binding.getInjectionPoints().             Initializable<Provider<? extends T>> initializable = initializer.<Provider<? extends T>>requestInjection(injector, provider, source, injectionPoints).             InternalFactory<T> factory = new InternalFactoryToProviderAdapter<>(initializable, source).             InternalFactory<? extends T> scopedFactory = Scopes.scope(key, injector, factory, scoping).             putBinding(new ProviderInstanceBindingImpl<>(injector, key, source, scopedFactory, scoping, provider, injectionPoints)).             return null.         }          @Override         public Void visit(ProviderKeyBinding<? extends T> binding) {             Key<? extends Provider<? extends T>> providerKey = binding.getProviderKey().             BoundProviderFactory<T> boundProviderFactory = new BoundProviderFactory<>(injector, providerKey, source).             creationListeners.add(boundProviderFactory).             InternalFactory<? extends T> scopedFactory = Scopes.scope(key, injector, (InternalFactory<? extends T>) boundProviderFactory, scoping).             putBinding(new LinkedProviderBindingImpl<>(injector, key, source, scopedFactory, scoping, providerKey)).             return null.         }          @Override         public Void visit(LinkedKeyBinding<? extends T> binding) {             Key<? extends T> linkedKey = binding.getLinkedKey().             if (key.equals(linkedKey)) {                 errors.recursiveBinding().             }             FactoryProxy<T> factory = new FactoryProxy<>(injector, key, linkedKey, source).             creationListeners.add(factory).             InternalFactory<? extends T> scopedFactory = Scopes.scope(key, injector, factory, scoping).             putBinding(new LinkedBindingImpl<>(injector, key, source, scopedFactory, scoping, linkedKey)).             return null.         }          @Override         public Void visit(UntargettedBinding<? extends T> untargetted) {             // @ImplementedBy annotation or something.             if (key.hasAnnotationType()) {                 errors.missingImplementation(key).                 putBinding(invalidBinding(injector, key, source)).                 return null.             }             // This cast is safe after the preceding check.             final BindingImpl<T> binding.             try {                 binding = injector.createUnitializedBinding(key, scoping, source, errors).                 putBinding(binding).             } catch (ErrorsException e) {                 errors.merge(e.getErrors()).                 putBinding(invalidBinding(injector, key, source)).                 return null.             }             uninitializedBindings.add(new Runnable() {                  @Override                 public void run() {                     try {                         ((InjectorImpl) binding.getInjector()).initializeBinding(binding, errors.withSource(source)).                     } catch (ErrorsException e) {                         errors.merge(e.getErrors()).                     }                 }             }).             return null.         }          @Override         public Void visit(ExposedBinding<? extends T> binding) {             throw new IllegalArgumentException("Cannot apply a non-module element").         }          @Override         public Void visit(ConvertedConstantBinding<? extends T> binding) {             throw new IllegalArgumentException("Cannot apply a non-module element").         }          @Override         public Void visit(ConstructorBinding<? extends T> binding) {             throw new IllegalArgumentException("Cannot apply a non-module element").         }          @Override         public Void visit(ProviderBinding<? extends T> binding) {             throw new IllegalArgumentException("Cannot apply a non-module element").         }     }).     return true. }
false;public;1;7;;@Override public Boolean visit(PrivateElements privateElements) {     for (Key<?> key : privateElements.getExposedKeys()) {         bindExposed(privateElements, key).     }     // leave the private elements for the PrivateElementsProcessor to handle     return false. }
false;private;2;6;;private <T> void bindExposed(PrivateElements privateElements, Key<T> key) {     ExposedKeyFactory<T> exposedKeyFactory = new ExposedKeyFactory<>(key, privateElements).     creationListeners.add(exposedKeyFactory).     putBinding(new ExposedBindingImpl<>(injector, privateElements.getExposedSource(key), key, exposedKeyFactory, privateElements)). }
false;private;2;3;;private <T> void validateKey(Object source, Key<T> key) {     Annotations.checkForMisplacedScopeAnnotations(key.getRawType(), source, errors). }
false;;3;3;;<T> UntargettedBindingImpl<T> invalidBinding(InjectorImpl injector, Key<T> key, Object source) {     return new UntargettedBindingImpl<>(injector, key, source). }
false;public;0;5;;public void initializeBindings() {     for (Runnable initializer : uninitializedBindings) {         initializer.run().     } }
false;public;0;5;;public void runCreationListeners() {     for (CreationListener creationListener : creationListeners) {         creationListener.notify(errors).     } }
false;private;1;19;;private void putBinding(BindingImpl<?> binding) {     Key<?> key = binding.getKey().     Class<?> rawType = key.getRawType().     if (FORBIDDEN_TYPES.contains(rawType)) {         errors.cannotBindToGuiceType(rawType.getSimpleName()).         return.     }     Binding<?> original = injector.state.getExplicitBinding(key).     if (original != null && !isOkayDuplicate(original, binding)) {         errors.bindingAlreadySet(key, original.getSource()).         return.     }     // prevent the parent from creating a JIT binding for this key     injector.state.parent().blacklist(key).     injector.state.putBinding(key, binding). }
true;private;2;8;/**  * We tolerate duplicate bindings only if one exposes the other.  *  * @param original the binding in the parent injector (candidate for an exposing binding)  * @param binding  the binding to check (candidate for the exposed binding)  */ ;/**  * We tolerate duplicate bindings only if one exposes the other.  *  * @param original the binding in the parent injector (candidate for an exposing binding)  * @param binding  the binding to check (candidate for the exposed binding)  */ private boolean isOkayDuplicate(Binding<?> original, BindingImpl<?> binding) {     if (original instanceof ExposedBindingImpl) {         ExposedBindingImpl<?> exposed = (ExposedBindingImpl<?>) original.         InjectorImpl exposedFrom = (InjectorImpl) exposed.getPrivateElements().getInjector().         return (exposedFrom == binding.getInjector()).     }     return false. }
false;;1;1;;void notify(Errors errors).
