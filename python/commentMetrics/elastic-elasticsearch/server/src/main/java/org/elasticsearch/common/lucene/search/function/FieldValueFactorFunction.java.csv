commented;modifiers;parameterAmount;loc;comment;code
false;public;2;20;;@Override public double score(int docId, float subQueryScore) throws IOException {     double value.     if (values.advanceExact(docId)) {         value = values.nextValue().     } else {         if (missing != null) {             value = missing.         } else {             throw new ElasticsearchException("Missing value for field [" + field + "]").         }     }     double val = value * boostFactor.     double result = modifier.apply(val).     if (result < 0f) {         throw new IllegalArgumentException("field value function must not produce negative scores, but got: [" + result + "] for field value: [" + value + "]").     }     return result. }
false;public;2;10;;@Override public Explanation explainScore(int docId, Explanation subQueryScore) throws IOException {     String modifierStr = modifier != null ? modifier.toString() : "".     String defaultStr = missing != null ? "?:" + missing : "".     double score = score(docId, subQueryScore.getValue().floatValue()).     return Explanation.match((float) score, String.format(Locale.ROOT, "field value function: %s(doc['%s'].value%s * factor=%s)", modifierStr, field, defaultStr, boostFactor)). }
false;public;1;44;;@Override public LeafScoreFunction getLeafScoreFunction(LeafReaderContext ctx) {     final SortedNumericDoubleValues values.     if (indexFieldData == null) {         values = FieldData.emptySortedNumericDoubles().     } else {         values = this.indexFieldData.load(ctx).getDoubleValues().     }     return new LeafScoreFunction() {          @Override         public double score(int docId, float subQueryScore) throws IOException {             double value.             if (values.advanceExact(docId)) {                 value = values.nextValue().             } else {                 if (missing != null) {                     value = missing.                 } else {                     throw new ElasticsearchException("Missing value for field [" + field + "]").                 }             }             double val = value * boostFactor.             double result = modifier.apply(val).             if (result < 0f) {                 throw new IllegalArgumentException("field value function must not produce negative scores, but got: [" + result + "] for field value: [" + value + "]").             }             return result.         }          @Override         public Explanation explainScore(int docId, Explanation subQueryScore) throws IOException {             String modifierStr = modifier != null ? modifier.toString() : "".             String defaultStr = missing != null ? "?:" + missing : "".             double score = score(docId, subQueryScore.getValue().floatValue()).             return Explanation.match((float) score, String.format(Locale.ROOT, "field value function: %s(doc['%s'].value%s * factor=%s)", modifierStr, field, defaultStr, boostFactor)).         }     }. }
false;public;0;4;;@Override public boolean needsScores() {     return false. }
false;protected;1;7;;@Override protected boolean doEquals(ScoreFunction other) {     FieldValueFactorFunction fieldValueFactorFunction = (FieldValueFactorFunction) other.     return this.boostFactor == fieldValueFactorFunction.boostFactor && Objects.equals(this.field, fieldValueFactorFunction.field) && Objects.equals(this.modifier, fieldValueFactorFunction.modifier). }
false;protected;0;4;;@Override protected int doHashCode() {     return Objects.hash(boostFactor, field, modifier). }
false;public;1;4;;@Override public double apply(double n) {     return n. }
false;public;1;4;;@Override public double apply(double n) {     return Math.log10(n). }
false;public;1;4;;@Override public double apply(double n) {     return Math.log10(n + 1). }
false;public;1;4;;@Override public double apply(double n) {     return Math.log10(n + 2). }
false;public;1;4;;@Override public double apply(double n) {     return Math.log(n). }
false;public;1;4;;@Override public double apply(double n) {     return Math.log1p(n). }
false;public;1;4;;@Override public double apply(double n) {     return Math.log1p(n + 1). }
false;public;1;4;;@Override public double apply(double n) {     return Math.pow(n, 2). }
false;public;1;4;;@Override public double apply(double n) {     return Math.sqrt(n). }
false;public;1;4;;@Override public double apply(double n) {     return 1.0 / n. }
false;public,abstract;1;1;;public abstract double apply(double n).
false;public;1;4;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeEnum(this). }
false;public,static;1;3;;public static Modifier readFromStream(StreamInput in) throws IOException {     return in.readEnum(Modifier.class). }
false;public;0;4;;@Override public String toString() {     return super.toString().toLowerCase(Locale.ROOT). }
false;public,static;1;3;;public static Modifier fromString(String modifier) {     return valueOf(modifier.toUpperCase(Locale.ROOT)). }
