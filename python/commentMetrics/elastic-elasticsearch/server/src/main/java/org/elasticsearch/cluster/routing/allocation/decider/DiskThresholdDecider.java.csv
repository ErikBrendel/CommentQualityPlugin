# id;timestamp;commentText;codeText;commentWords;codeWords
DiskThresholdDecider -> DiskUsage averageUsage(RoutingNode node, ImmutableOpenMap<String, DiskUsage> usages);1524684173;Returns a {@link DiskUsage} for the {@link RoutingNode} using the_average usage of other nodes in the disk usage map._@param node Node to return an averaged DiskUsage object for_@param usages Map of nodeId to DiskUsage for all known nodes_@return DiskUsage representing given node using the average disk usage;DiskUsage averageUsage(RoutingNode node, ImmutableOpenMap<String, DiskUsage> usages) {_        if (usages.size() == 0) {_            return new DiskUsage(node.nodeId(), node.node().getName(), "_na_", 0, 0)__        }_        long totalBytes = 0__        long freeBytes = 0__        for (ObjectCursor<DiskUsage> du : usages.values()) {_            totalBytes += du.value.getTotalBytes()__            freeBytes += du.value.getFreeBytes()__        }_        return new DiskUsage(node.nodeId(), node.node().getName(), "_na_", totalBytes / usages.size(), freeBytes / usages.size())__    };returns,a,link,disk,usage,for,the,link,routing,node,using,the,average,usage,of,other,nodes,in,the,disk,usage,map,param,node,node,to,return,an,averaged,disk,usage,object,for,param,usages,map,of,node,id,to,disk,usage,for,all,known,nodes,return,disk,usage,representing,given,node,using,the,average,disk,usage;disk,usage,average,usage,routing,node,node,immutable,open,map,string,disk,usage,usages,if,usages,size,0,return,new,disk,usage,node,node,id,node,node,get,name,0,0,long,total,bytes,0,long,free,bytes,0,for,object,cursor,disk,usage,du,usages,values,total,bytes,du,value,get,total,bytes,free,bytes,du,value,get,free,bytes,return,new,disk,usage,node,node,id,node,node,get,name,total,bytes,usages,size,free,bytes,usages,size
DiskThresholdDecider -> DiskUsage averageUsage(RoutingNode node, ImmutableOpenMap<String, DiskUsage> usages);1537202470;Returns a {@link DiskUsage} for the {@link RoutingNode} using the_average usage of other nodes in the disk usage map._@param node Node to return an averaged DiskUsage object for_@param usages Map of nodeId to DiskUsage for all known nodes_@return DiskUsage representing given node using the average disk usage;DiskUsage averageUsage(RoutingNode node, ImmutableOpenMap<String, DiskUsage> usages) {_        if (usages.size() == 0) {_            return new DiskUsage(node.nodeId(), node.node().getName(), "_na_", 0, 0)__        }_        long totalBytes = 0__        long freeBytes = 0__        for (ObjectCursor<DiskUsage> du : usages.values()) {_            totalBytes += du.value.getTotalBytes()__            freeBytes += du.value.getFreeBytes()__        }_        return new DiskUsage(node.nodeId(), node.node().getName(), "_na_", totalBytes / usages.size(), freeBytes / usages.size())__    };returns,a,link,disk,usage,for,the,link,routing,node,using,the,average,usage,of,other,nodes,in,the,disk,usage,map,param,node,node,to,return,an,averaged,disk,usage,object,for,param,usages,map,of,node,id,to,disk,usage,for,all,known,nodes,return,disk,usage,representing,given,node,using,the,average,disk,usage;disk,usage,average,usage,routing,node,node,immutable,open,map,string,disk,usage,usages,if,usages,size,0,return,new,disk,usage,node,node,id,node,node,get,name,0,0,long,total,bytes,0,long,free,bytes,0,for,object,cursor,disk,usage,du,usages,values,total,bytes,du,value,get,total,bytes,free,bytes,du,value,get,free,bytes,return,new,disk,usage,node,node,id,node,node,get,name,total,bytes,usages,size,free,bytes,usages,size
DiskThresholdDecider -> DiskUsage averageUsage(RoutingNode node, ImmutableOpenMap<String, DiskUsage> usages);1541092382;Returns a {@link DiskUsage} for the {@link RoutingNode} using the_average usage of other nodes in the disk usage map._@param node Node to return an averaged DiskUsage object for_@param usages Map of nodeId to DiskUsage for all known nodes_@return DiskUsage representing given node using the average disk usage;DiskUsage averageUsage(RoutingNode node, ImmutableOpenMap<String, DiskUsage> usages) {_        if (usages.size() == 0) {_            return new DiskUsage(node.nodeId(), node.node().getName(), "_na_", 0, 0)__        }_        long totalBytes = 0__        long freeBytes = 0__        for (ObjectCursor<DiskUsage> du : usages.values()) {_            totalBytes += du.value.getTotalBytes()__            freeBytes += du.value.getFreeBytes()__        }_        return new DiskUsage(node.nodeId(), node.node().getName(), "_na_", totalBytes / usages.size(), freeBytes / usages.size())__    };returns,a,link,disk,usage,for,the,link,routing,node,using,the,average,usage,of,other,nodes,in,the,disk,usage,map,param,node,node,to,return,an,averaged,disk,usage,object,for,param,usages,map,of,node,id,to,disk,usage,for,all,known,nodes,return,disk,usage,representing,given,node,using,the,average,disk,usage;disk,usage,average,usage,routing,node,node,immutable,open,map,string,disk,usage,usages,if,usages,size,0,return,new,disk,usage,node,node,id,node,node,get,name,0,0,long,total,bytes,0,long,free,bytes,0,for,object,cursor,disk,usage,du,usages,values,total,bytes,du,value,get,total,bytes,free,bytes,du,value,get,free,bytes,return,new,disk,usage,node,node,id,node,node,get,name,total,bytes,usages,size,free,bytes,usages,size
DiskThresholdDecider -> DiskUsage averageUsage(RoutingNode node, ImmutableOpenMap<String, DiskUsage> usages);1542402632;Returns a {@link DiskUsage} for the {@link RoutingNode} using the_average usage of other nodes in the disk usage map._@param node Node to return an averaged DiskUsage object for_@param usages Map of nodeId to DiskUsage for all known nodes_@return DiskUsage representing given node using the average disk usage;DiskUsage averageUsage(RoutingNode node, ImmutableOpenMap<String, DiskUsage> usages) {_        if (usages.size() == 0) {_            return new DiskUsage(node.nodeId(), node.node().getName(), "_na_", 0, 0)__        }_        long totalBytes = 0__        long freeBytes = 0__        for (ObjectCursor<DiskUsage> du : usages.values()) {_            totalBytes += du.value.getTotalBytes()__            freeBytes += du.value.getFreeBytes()__        }_        return new DiskUsage(node.nodeId(), node.node().getName(), "_na_", totalBytes / usages.size(), freeBytes / usages.size())__    };returns,a,link,disk,usage,for,the,link,routing,node,using,the,average,usage,of,other,nodes,in,the,disk,usage,map,param,node,node,to,return,an,averaged,disk,usage,object,for,param,usages,map,of,node,id,to,disk,usage,for,all,known,nodes,return,disk,usage,representing,given,node,using,the,average,disk,usage;disk,usage,average,usage,routing,node,node,immutable,open,map,string,disk,usage,usages,if,usages,size,0,return,new,disk,usage,node,node,id,node,node,get,name,0,0,long,total,bytes,0,long,free,bytes,0,for,object,cursor,disk,usage,du,usages,values,total,bytes,du,value,get,total,bytes,free,bytes,du,value,get,free,bytes,return,new,disk,usage,node,node,id,node,node,get,name,total,bytes,usages,size,free,bytes,usages,size
DiskThresholdDecider -> double freeDiskPercentageAfterShardAssigned(DiskUsage usage, Long shardSize);1524684173;Given the DiskUsage for a node and the size of the shard, return the_percentage of free disk if the shard were to be allocated to the node._@param usage A DiskUsage for the node to have space computed for_@param shardSize Size in bytes of the shard_@return Percentage of free space after the shard is assigned to the node;double freeDiskPercentageAfterShardAssigned(DiskUsage usage, Long shardSize) {_        shardSize = (shardSize == null) ? 0 : shardSize__        DiskUsage newUsage = new DiskUsage(usage.getNodeId(), usage.getNodeName(), usage.getPath(),_                usage.getTotalBytes(),  usage.getFreeBytes() - shardSize)__        return newUsage.getFreeDiskAsPercentage()__    };given,the,disk,usage,for,a,node,and,the,size,of,the,shard,return,the,percentage,of,free,disk,if,the,shard,were,to,be,allocated,to,the,node,param,usage,a,disk,usage,for,the,node,to,have,space,computed,for,param,shard,size,size,in,bytes,of,the,shard,return,percentage,of,free,space,after,the,shard,is,assigned,to,the,node;double,free,disk,percentage,after,shard,assigned,disk,usage,usage,long,shard,size,shard,size,shard,size,null,0,shard,size,disk,usage,new,usage,new,disk,usage,usage,get,node,id,usage,get,node,name,usage,get,path,usage,get,total,bytes,usage,get,free,bytes,shard,size,return,new,usage,get,free,disk,as,percentage
DiskThresholdDecider -> double freeDiskPercentageAfterShardAssigned(DiskUsage usage, Long shardSize);1537202470;Given the DiskUsage for a node and the size of the shard, return the_percentage of free disk if the shard were to be allocated to the node._@param usage A DiskUsage for the node to have space computed for_@param shardSize Size in bytes of the shard_@return Percentage of free space after the shard is assigned to the node;double freeDiskPercentageAfterShardAssigned(DiskUsage usage, Long shardSize) {_        shardSize = (shardSize == null) ? 0 : shardSize__        DiskUsage newUsage = new DiskUsage(usage.getNodeId(), usage.getNodeName(), usage.getPath(),_                usage.getTotalBytes(),  usage.getFreeBytes() - shardSize)__        return newUsage.getFreeDiskAsPercentage()__    };given,the,disk,usage,for,a,node,and,the,size,of,the,shard,return,the,percentage,of,free,disk,if,the,shard,were,to,be,allocated,to,the,node,param,usage,a,disk,usage,for,the,node,to,have,space,computed,for,param,shard,size,size,in,bytes,of,the,shard,return,percentage,of,free,space,after,the,shard,is,assigned,to,the,node;double,free,disk,percentage,after,shard,assigned,disk,usage,usage,long,shard,size,shard,size,shard,size,null,0,shard,size,disk,usage,new,usage,new,disk,usage,usage,get,node,id,usage,get,node,name,usage,get,path,usage,get,total,bytes,usage,get,free,bytes,shard,size,return,new,usage,get,free,disk,as,percentage
DiskThresholdDecider -> double freeDiskPercentageAfterShardAssigned(DiskUsage usage, Long shardSize);1541092382;Given the DiskUsage for a node and the size of the shard, return the_percentage of free disk if the shard were to be allocated to the node._@param usage A DiskUsage for the node to have space computed for_@param shardSize Size in bytes of the shard_@return Percentage of free space after the shard is assigned to the node;double freeDiskPercentageAfterShardAssigned(DiskUsage usage, Long shardSize) {_        shardSize = (shardSize == null) ? 0 : shardSize__        DiskUsage newUsage = new DiskUsage(usage.getNodeId(), usage.getNodeName(), usage.getPath(),_                usage.getTotalBytes(),  usage.getFreeBytes() - shardSize)__        return newUsage.getFreeDiskAsPercentage()__    };given,the,disk,usage,for,a,node,and,the,size,of,the,shard,return,the,percentage,of,free,disk,if,the,shard,were,to,be,allocated,to,the,node,param,usage,a,disk,usage,for,the,node,to,have,space,computed,for,param,shard,size,size,in,bytes,of,the,shard,return,percentage,of,free,space,after,the,shard,is,assigned,to,the,node;double,free,disk,percentage,after,shard,assigned,disk,usage,usage,long,shard,size,shard,size,shard,size,null,0,shard,size,disk,usage,new,usage,new,disk,usage,usage,get,node,id,usage,get,node,name,usage,get,path,usage,get,total,bytes,usage,get,free,bytes,shard,size,return,new,usage,get,free,disk,as,percentage
DiskThresholdDecider -> double freeDiskPercentageAfterShardAssigned(DiskUsage usage, Long shardSize);1542402632;Given the DiskUsage for a node and the size of the shard, return the_percentage of free disk if the shard were to be allocated to the node._@param usage A DiskUsage for the node to have space computed for_@param shardSize Size in bytes of the shard_@return Percentage of free space after the shard is assigned to the node;double freeDiskPercentageAfterShardAssigned(DiskUsage usage, Long shardSize) {_        shardSize = (shardSize == null) ? 0 : shardSize__        DiskUsage newUsage = new DiskUsage(usage.getNodeId(), usage.getNodeName(), usage.getPath(),_                usage.getTotalBytes(),  usage.getFreeBytes() - shardSize)__        return newUsage.getFreeDiskAsPercentage()__    };given,the,disk,usage,for,a,node,and,the,size,of,the,shard,return,the,percentage,of,free,disk,if,the,shard,were,to,be,allocated,to,the,node,param,usage,a,disk,usage,for,the,node,to,have,space,computed,for,param,shard,size,size,in,bytes,of,the,shard,return,percentage,of,free,space,after,the,shard,is,assigned,to,the,node;double,free,disk,percentage,after,shard,assigned,disk,usage,usage,long,shard,size,shard,size,shard,size,null,0,shard,size,disk,usage,new,usage,new,disk,usage,usage,get,node,id,usage,get,node,name,usage,get,path,usage,get,total,bytes,usage,get,free,bytes,shard,size,return,new,usage,get,free,disk,as,percentage
DiskThresholdDecider -> static long sizeOfRelocatingShards(RoutingNode node, RoutingAllocation allocation,                                        boolean subtractShardsMovingAway, String dataPath);1524684173;Returns the size of all shards that are currently being relocated to_the node, but may not be finished transferring yet.__If subtractShardsMovingAway is true then the size of shards moving away is subtracted from the total size of all shards;static long sizeOfRelocatingShards(RoutingNode node, RoutingAllocation allocation,_                                       boolean subtractShardsMovingAway, String dataPath) {_        ClusterInfo clusterInfo = allocation.clusterInfo()__        long totalSize = 0__        for (ShardRouting routing : node.shardsWithState(ShardRoutingState.RELOCATING, ShardRoutingState.INITIALIZING)) {_            String actualPath = clusterInfo.getDataPath(routing)__            if (dataPath.equals(actualPath)) {_                if (routing.initializing() && routing.relocatingNodeId() != null) {_                    totalSize += getExpectedShardSize(routing, allocation, 0)__                } else if (subtractShardsMovingAway && routing.relocating()) {_                    totalSize -= getExpectedShardSize(routing, allocation, 0)__                }_            }_        }_        return totalSize__    };returns,the,size,of,all,shards,that,are,currently,being,relocated,to,the,node,but,may,not,be,finished,transferring,yet,if,subtract,shards,moving,away,is,true,then,the,size,of,shards,moving,away,is,subtracted,from,the,total,size,of,all,shards;static,long,size,of,relocating,shards,routing,node,node,routing,allocation,allocation,boolean,subtract,shards,moving,away,string,data,path,cluster,info,cluster,info,allocation,cluster,info,long,total,size,0,for,shard,routing,routing,node,shards,with,state,shard,routing,state,relocating,shard,routing,state,initializing,string,actual,path,cluster,info,get,data,path,routing,if,data,path,equals,actual,path,if,routing,initializing,routing,relocating,node,id,null,total,size,get,expected,shard,size,routing,allocation,0,else,if,subtract,shards,moving,away,routing,relocating,total,size,get,expected,shard,size,routing,allocation,0,return,total,size
DiskThresholdDecider -> static long sizeOfRelocatingShards(RoutingNode node, RoutingAllocation allocation,                                        boolean subtractShardsMovingAway, String dataPath);1537202470;Returns the size of all shards that are currently being relocated to_the node, but may not be finished transferring yet.__If subtractShardsMovingAway is true then the size of shards moving away is subtracted from the total size of all shards;static long sizeOfRelocatingShards(RoutingNode node, RoutingAllocation allocation,_                                       boolean subtractShardsMovingAway, String dataPath) {_        ClusterInfo clusterInfo = allocation.clusterInfo()__        long totalSize = 0__        for (ShardRouting routing : node.shardsWithState(ShardRoutingState.RELOCATING, ShardRoutingState.INITIALIZING)) {_            String actualPath = clusterInfo.getDataPath(routing)__            if (dataPath.equals(actualPath)) {_                if (routing.initializing() && routing.relocatingNodeId() != null) {_                    totalSize += getExpectedShardSize(routing, allocation, 0)__                } else if (subtractShardsMovingAway && routing.relocating()) {_                    totalSize -= getExpectedShardSize(routing, allocation, 0)__                }_            }_        }_        return totalSize__    };returns,the,size,of,all,shards,that,are,currently,being,relocated,to,the,node,but,may,not,be,finished,transferring,yet,if,subtract,shards,moving,away,is,true,then,the,size,of,shards,moving,away,is,subtracted,from,the,total,size,of,all,shards;static,long,size,of,relocating,shards,routing,node,node,routing,allocation,allocation,boolean,subtract,shards,moving,away,string,data,path,cluster,info,cluster,info,allocation,cluster,info,long,total,size,0,for,shard,routing,routing,node,shards,with,state,shard,routing,state,relocating,shard,routing,state,initializing,string,actual,path,cluster,info,get,data,path,routing,if,data,path,equals,actual,path,if,routing,initializing,routing,relocating,node,id,null,total,size,get,expected,shard,size,routing,allocation,0,else,if,subtract,shards,moving,away,routing,relocating,total,size,get,expected,shard,size,routing,allocation,0,return,total,size
DiskThresholdDecider -> static long sizeOfRelocatingShards(RoutingNode node, RoutingAllocation allocation,                                        boolean subtractShardsMovingAway, String dataPath);1541092382;Returns the size of all shards that are currently being relocated to_the node, but may not be finished transferring yet.__If subtractShardsMovingAway is true then the size of shards moving away is subtracted from the total size of all shards;static long sizeOfRelocatingShards(RoutingNode node, RoutingAllocation allocation,_                                       boolean subtractShardsMovingAway, String dataPath) {_        ClusterInfo clusterInfo = allocation.clusterInfo()__        long totalSize = 0__        for (ShardRouting routing : node.shardsWithState(ShardRoutingState.RELOCATING, ShardRoutingState.INITIALIZING)) {_            String actualPath = clusterInfo.getDataPath(routing)__            if (dataPath.equals(actualPath)) {_                if (routing.initializing() && routing.relocatingNodeId() != null) {_                    totalSize += getExpectedShardSize(routing, allocation, 0)__                } else if (subtractShardsMovingAway && routing.relocating()) {_                    totalSize -= getExpectedShardSize(routing, allocation, 0)__                }_            }_        }_        return totalSize__    };returns,the,size,of,all,shards,that,are,currently,being,relocated,to,the,node,but,may,not,be,finished,transferring,yet,if,subtract,shards,moving,away,is,true,then,the,size,of,shards,moving,away,is,subtracted,from,the,total,size,of,all,shards;static,long,size,of,relocating,shards,routing,node,node,routing,allocation,allocation,boolean,subtract,shards,moving,away,string,data,path,cluster,info,cluster,info,allocation,cluster,info,long,total,size,0,for,shard,routing,routing,node,shards,with,state,shard,routing,state,relocating,shard,routing,state,initializing,string,actual,path,cluster,info,get,data,path,routing,if,data,path,equals,actual,path,if,routing,initializing,routing,relocating,node,id,null,total,size,get,expected,shard,size,routing,allocation,0,else,if,subtract,shards,moving,away,routing,relocating,total,size,get,expected,shard,size,routing,allocation,0,return,total,size
DiskThresholdDecider -> static long sizeOfRelocatingShards(RoutingNode node, RoutingAllocation allocation,                                        boolean subtractShardsMovingAway, String dataPath);1542402632;Returns the size of all shards that are currently being relocated to_the node, but may not be finished transferring yet.__If subtractShardsMovingAway is true then the size of shards moving away is subtracted from the total size of all shards;static long sizeOfRelocatingShards(RoutingNode node, RoutingAllocation allocation,_                                       boolean subtractShardsMovingAway, String dataPath) {_        ClusterInfo clusterInfo = allocation.clusterInfo()__        long totalSize = 0__        for (ShardRouting routing : node.shardsWithState(ShardRoutingState.RELOCATING, ShardRoutingState.INITIALIZING)) {_            String actualPath = clusterInfo.getDataPath(routing)__            if (dataPath.equals(actualPath)) {_                if (routing.initializing() && routing.relocatingNodeId() != null) {_                    totalSize += getExpectedShardSize(routing, allocation, 0)__                } else if (subtractShardsMovingAway && routing.relocating()) {_                    totalSize -= getExpectedShardSize(routing, allocation, 0)__                }_            }_        }_        return totalSize__    };returns,the,size,of,all,shards,that,are,currently,being,relocated,to,the,node,but,may,not,be,finished,transferring,yet,if,subtract,shards,moving,away,is,true,then,the,size,of,shards,moving,away,is,subtracted,from,the,total,size,of,all,shards;static,long,size,of,relocating,shards,routing,node,node,routing,allocation,allocation,boolean,subtract,shards,moving,away,string,data,path,cluster,info,cluster,info,allocation,cluster,info,long,total,size,0,for,shard,routing,routing,node,shards,with,state,shard,routing,state,relocating,shard,routing,state,initializing,string,actual,path,cluster,info,get,data,path,routing,if,data,path,equals,actual,path,if,routing,initializing,routing,relocating,node,id,null,total,size,get,expected,shard,size,routing,allocation,0,else,if,subtract,shards,moving,away,routing,relocating,total,size,get,expected,shard,size,routing,allocation,0,return,total,size
DiskThresholdDecider -> public static long getExpectedShardSize(ShardRouting shard, RoutingAllocation allocation, long defaultValue);1524684173;Returns the expected shard size for the given shard or the default value provided if not enough information are available_to estimate the shards size.;public static long getExpectedShardSize(ShardRouting shard, RoutingAllocation allocation, long defaultValue) {_        final IndexMetaData metaData = allocation.metaData().getIndexSafe(shard.index())__        final ClusterInfo info = allocation.clusterInfo()__        if (metaData.getResizeSourceIndex() != null && shard.active() == false &&_            shard.recoverySource().getType() == RecoverySource.Type.LOCAL_SHARDS) {_            _            _            long targetShardSize = 0__            final Index mergeSourceIndex = metaData.getResizeSourceIndex()__            final IndexMetaData sourceIndexMeta = allocation.metaData().index(mergeSourceIndex)__            if (sourceIndexMeta != null) {_                final Set<ShardId> shardIds = IndexMetaData.selectRecoverFromShards(shard.id(),_                    sourceIndexMeta, metaData.getNumberOfShards())__                for (IndexShardRoutingTable shardRoutingTable : allocation.routingTable().index(mergeSourceIndex.getName())) {_                    if (shardIds.contains(shardRoutingTable.shardId())) {_                        targetShardSize += info.getShardSize(shardRoutingTable.primaryShard(), 0)__                    }_                }_            }_            return targetShardSize == 0 ? defaultValue : targetShardSize__        } else {_            return info.getShardSize(shard, defaultValue)__        }__    };returns,the,expected,shard,size,for,the,given,shard,or,the,default,value,provided,if,not,enough,information,are,available,to,estimate,the,shards,size;public,static,long,get,expected,shard,size,shard,routing,shard,routing,allocation,allocation,long,default,value,final,index,meta,data,meta,data,allocation,meta,data,get,index,safe,shard,index,final,cluster,info,info,allocation,cluster,info,if,meta,data,get,resize,source,index,null,shard,active,false,shard,recovery,source,get,type,recovery,source,type,long,target,shard,size,0,final,index,merge,source,index,meta,data,get,resize,source,index,final,index,meta,data,source,index,meta,allocation,meta,data,index,merge,source,index,if,source,index,meta,null,final,set,shard,id,shard,ids,index,meta,data,select,recover,from,shards,shard,id,source,index,meta,meta,data,get,number,of,shards,for,index,shard,routing,table,shard,routing,table,allocation,routing,table,index,merge,source,index,get,name,if,shard,ids,contains,shard,routing,table,shard,id,target,shard,size,info,get,shard,size,shard,routing,table,primary,shard,0,return,target,shard,size,0,default,value,target,shard,size,else,return,info,get,shard,size,shard,default,value
DiskThresholdDecider -> public static long getExpectedShardSize(ShardRouting shard, RoutingAllocation allocation, long defaultValue);1537202470;Returns the expected shard size for the given shard or the default value provided if not enough information are available_to estimate the shards size.;public static long getExpectedShardSize(ShardRouting shard, RoutingAllocation allocation, long defaultValue) {_        final IndexMetaData metaData = allocation.metaData().getIndexSafe(shard.index())__        final ClusterInfo info = allocation.clusterInfo()__        if (metaData.getResizeSourceIndex() != null && shard.active() == false &&_            shard.recoverySource().getType() == RecoverySource.Type.LOCAL_SHARDS) {_            _            _            long targetShardSize = 0__            final Index mergeSourceIndex = metaData.getResizeSourceIndex()__            final IndexMetaData sourceIndexMeta = allocation.metaData().index(mergeSourceIndex)__            if (sourceIndexMeta != null) {_                final Set<ShardId> shardIds = IndexMetaData.selectRecoverFromShards(shard.id(),_                    sourceIndexMeta, metaData.getNumberOfShards())__                for (IndexShardRoutingTable shardRoutingTable : allocation.routingTable().index(mergeSourceIndex.getName())) {_                    if (shardIds.contains(shardRoutingTable.shardId())) {_                        targetShardSize += info.getShardSize(shardRoutingTable.primaryShard(), 0)__                    }_                }_            }_            return targetShardSize == 0 ? defaultValue : targetShardSize__        } else {_            return info.getShardSize(shard, defaultValue)__        }__    };returns,the,expected,shard,size,for,the,given,shard,or,the,default,value,provided,if,not,enough,information,are,available,to,estimate,the,shards,size;public,static,long,get,expected,shard,size,shard,routing,shard,routing,allocation,allocation,long,default,value,final,index,meta,data,meta,data,allocation,meta,data,get,index,safe,shard,index,final,cluster,info,info,allocation,cluster,info,if,meta,data,get,resize,source,index,null,shard,active,false,shard,recovery,source,get,type,recovery,source,type,long,target,shard,size,0,final,index,merge,source,index,meta,data,get,resize,source,index,final,index,meta,data,source,index,meta,allocation,meta,data,index,merge,source,index,if,source,index,meta,null,final,set,shard,id,shard,ids,index,meta,data,select,recover,from,shards,shard,id,source,index,meta,meta,data,get,number,of,shards,for,index,shard,routing,table,shard,routing,table,allocation,routing,table,index,merge,source,index,get,name,if,shard,ids,contains,shard,routing,table,shard,id,target,shard,size,info,get,shard,size,shard,routing,table,primary,shard,0,return,target,shard,size,0,default,value,target,shard,size,else,return,info,get,shard,size,shard,default,value
DiskThresholdDecider -> public static long getExpectedShardSize(ShardRouting shard, RoutingAllocation allocation, long defaultValue);1541092382;Returns the expected shard size for the given shard or the default value provided if not enough information are available_to estimate the shards size.;public static long getExpectedShardSize(ShardRouting shard, RoutingAllocation allocation, long defaultValue) {_        final IndexMetaData metaData = allocation.metaData().getIndexSafe(shard.index())__        final ClusterInfo info = allocation.clusterInfo()__        if (metaData.getResizeSourceIndex() != null && shard.active() == false &&_            shard.recoverySource().getType() == RecoverySource.Type.LOCAL_SHARDS) {_            _            _            long targetShardSize = 0__            final Index mergeSourceIndex = metaData.getResizeSourceIndex()__            final IndexMetaData sourceIndexMeta = allocation.metaData().index(mergeSourceIndex)__            if (sourceIndexMeta != null) {_                final Set<ShardId> shardIds = IndexMetaData.selectRecoverFromShards(shard.id(),_                    sourceIndexMeta, metaData.getNumberOfShards())__                for (IndexShardRoutingTable shardRoutingTable : allocation.routingTable().index(mergeSourceIndex.getName())) {_                    if (shardIds.contains(shardRoutingTable.shardId())) {_                        targetShardSize += info.getShardSize(shardRoutingTable.primaryShard(), 0)__                    }_                }_            }_            return targetShardSize == 0 ? defaultValue : targetShardSize__        } else {_            return info.getShardSize(shard, defaultValue)__        }__    };returns,the,expected,shard,size,for,the,given,shard,or,the,default,value,provided,if,not,enough,information,are,available,to,estimate,the,shards,size;public,static,long,get,expected,shard,size,shard,routing,shard,routing,allocation,allocation,long,default,value,final,index,meta,data,meta,data,allocation,meta,data,get,index,safe,shard,index,final,cluster,info,info,allocation,cluster,info,if,meta,data,get,resize,source,index,null,shard,active,false,shard,recovery,source,get,type,recovery,source,type,long,target,shard,size,0,final,index,merge,source,index,meta,data,get,resize,source,index,final,index,meta,data,source,index,meta,allocation,meta,data,index,merge,source,index,if,source,index,meta,null,final,set,shard,id,shard,ids,index,meta,data,select,recover,from,shards,shard,id,source,index,meta,meta,data,get,number,of,shards,for,index,shard,routing,table,shard,routing,table,allocation,routing,table,index,merge,source,index,get,name,if,shard,ids,contains,shard,routing,table,shard,id,target,shard,size,info,get,shard,size,shard,routing,table,primary,shard,0,return,target,shard,size,0,default,value,target,shard,size,else,return,info,get,shard,size,shard,default,value
DiskThresholdDecider -> public static long getExpectedShardSize(ShardRouting shard, RoutingAllocation allocation, long defaultValue);1542402632;Returns the expected shard size for the given shard or the default value provided if not enough information are available_to estimate the shards size.;public static long getExpectedShardSize(ShardRouting shard, RoutingAllocation allocation, long defaultValue) {_        final IndexMetaData metaData = allocation.metaData().getIndexSafe(shard.index())__        final ClusterInfo info = allocation.clusterInfo()__        if (metaData.getResizeSourceIndex() != null && shard.active() == false &&_            shard.recoverySource().getType() == RecoverySource.Type.LOCAL_SHARDS) {_            _            _            long targetShardSize = 0__            final Index mergeSourceIndex = metaData.getResizeSourceIndex()__            final IndexMetaData sourceIndexMeta = allocation.metaData().index(mergeSourceIndex)__            if (sourceIndexMeta != null) {_                final Set<ShardId> shardIds = IndexMetaData.selectRecoverFromShards(shard.id(),_                    sourceIndexMeta, metaData.getNumberOfShards())__                for (IndexShardRoutingTable shardRoutingTable : allocation.routingTable().index(mergeSourceIndex.getName())) {_                    if (shardIds.contains(shardRoutingTable.shardId())) {_                        targetShardSize += info.getShardSize(shardRoutingTable.primaryShard(), 0)__                    }_                }_            }_            return targetShardSize == 0 ? defaultValue : targetShardSize__        } else {_            return info.getShardSize(shard, defaultValue)__        }__    };returns,the,expected,shard,size,for,the,given,shard,or,the,default,value,provided,if,not,enough,information,are,available,to,estimate,the,shards,size;public,static,long,get,expected,shard,size,shard,routing,shard,routing,allocation,allocation,long,default,value,final,index,meta,data,meta,data,allocation,meta,data,get,index,safe,shard,index,final,cluster,info,info,allocation,cluster,info,if,meta,data,get,resize,source,index,null,shard,active,false,shard,recovery,source,get,type,recovery,source,type,long,target,shard,size,0,final,index,merge,source,index,meta,data,get,resize,source,index,final,index,meta,data,source,index,meta,allocation,meta,data,index,merge,source,index,if,source,index,meta,null,final,set,shard,id,shard,ids,index,meta,data,select,recover,from,shards,shard,id,source,index,meta,meta,data,get,number,of,shards,for,index,shard,routing,table,shard,routing,table,allocation,routing,table,index,merge,source,index,get,name,if,shard,ids,contains,shard,routing,table,shard,id,target,shard,size,info,get,shard,size,shard,routing,table,primary,shard,0,return,target,shard,size,0,default,value,target,shard,size,else,return,info,get,shard,size,shard,default,value
