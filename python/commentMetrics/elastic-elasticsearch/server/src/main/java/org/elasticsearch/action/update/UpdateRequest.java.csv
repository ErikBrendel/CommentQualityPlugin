commented;modifiers;parameterAmount;loc;comment;code
false;public;0;40;;@Override public ActionRequestValidationException validate() {     ActionRequestValidationException validationException = super.validate().     if (upsertRequest != null && upsertRequest.version() != Versions.MATCH_ANY) {         validationException = addValidationError("can't provide version in upsert request", validationException).     }     if (Strings.isEmpty(type())) {         validationException = addValidationError("type is missing", validationException).     }     if (Strings.isEmpty(id)) {         validationException = addValidationError("id is missing", validationException).     }     validationException = DocWriteRequest.validateSeqNoBasedCASParams(this, validationException).     if (ifSeqNo != UNASSIGNED_SEQ_NO) {         if (retryOnConflict > 0) {             validationException = addValidationError("compare and write operations can not be retried", validationException).         }         if (docAsUpsert) {             validationException = addValidationError("compare and write operations can not be used with upsert", validationException).         }         if (upsertRequest != null) {             validationException = addValidationError("upsert requests don't support `if_seq_no` and `if_primary_term`", validationException).         }     }     if (script == null && doc == null) {         validationException = addValidationError("script or doc is missing", validationException).     }     if (script != null && doc != null) {         validationException = addValidationError("can't provide both script and doc", validationException).     }     if (doc == null && docAsUpsert) {         validationException = addValidationError("doc must be specified if doc_as_upsert is enabled", validationException).     }     return validationException. }
true;public;0;8;/**  * The type of the indexed document.  *  * @deprecated Types are in the process of being removed.  */ ;/**  * The type of the indexed document.  *  * @deprecated Types are in the process of being removed.  */ @Deprecated @Override public String type() {     if (type == null) {         return MapperService.SINGLE_MAPPING_NAME.     }     return type. }
true;public;1;5;/**  * Sets the type of the indexed document.  *  * @deprecated Types are in the process of being removed.  */ ;/**  * Sets the type of the indexed document.  *  * @deprecated Types are in the process of being removed.  */ @Deprecated public UpdateRequest type(String type) {     this.type = type.     return this. }
true;public;1;8;/**  * Set the default type supplied to a bulk  * request if this individual request's type is null  * or empty  * @deprecated Types are in the process of being removed.  */ ;/**  * Set the default type supplied to a bulk  * request if this individual request's type is null  * or empty  * @deprecated Types are in the process of being removed.  */ @Deprecated @Override public UpdateRequest defaultTypeIfNull(String defaultType) {     if (Strings.isNullOrEmpty(type)) {         type = defaultType.     }     return this. }
true;public;0;4;/**  * The id of the indexed document.  */ ;/**  * The id of the indexed document.  */ @Override public String id() {     return id. }
true;public;1;4;/**  * Sets the id of the indexed document.  */ ;/**  * Sets the id of the indexed document.  */ public UpdateRequest id(String id) {     this.id = id.     return this. }
true;public;1;9;/**  * Controls the shard routing of the request. Using this value to hash the shard  * and not the id.  */ ;/**  * Controls the shard routing of the request. Using this value to hash the shard  * and not the id.  */ @Override public UpdateRequest routing(String routing) {     if (routing != null && routing.length() == 0) {         this.routing = null.     } else {         this.routing = routing.     }     return this. }
true;public;0;4;/**  * Controls the shard routing of the request. Using this value to hash the shard  * and not the id.  */ ;/**  * Controls the shard routing of the request. Using this value to hash the shard  * and not the id.  */ @Override public String routing() {     return this.routing. }
false;public;0;3;;public ShardId getShardId() {     return this.shardId. }
false;public;0;3;;public Script script() {     return this.script. }
true;public;1;4;/**  * The script to execute. Note, make sure not to send different script each times and instead  * use script params if possible with the same (automatically compiled) script.  */ ;/**  * The script to execute. Note, make sure not to send different script each times and instead  * use script params if possible with the same (automatically compiled) script.  */ public UpdateRequest script(Script script) {     this.script = script.     return this. }
true;public;0;4;/**  * @deprecated Use {@link #script()} instead  */ ;/**  * @deprecated Use {@link #script()} instead  */ @Deprecated public String scriptString() {     return this.script == null ? null : this.script.getIdOrCode(). }
true;public;0;4;/**  * @deprecated Use {@link #script()} instead  */ ;/**  * @deprecated Use {@link #script()} instead  */ @Deprecated public ScriptType scriptType() {     return this.script == null ? null : this.script.getType(). }
true;public;0;4;/**  * @deprecated Use {@link #script()} instead  */ ;/**  * @deprecated Use {@link #script()} instead  */ @Deprecated public Map<String, Object> scriptParams() {     return this.script == null ? null : this.script.getParams(). }
true;public;2;5;/**  * The script to execute. Note, make sure not to send different script each  * times and instead use script params if possible with the same  * (automatically compiled) script.  *  * @deprecated Use {@link #script(Script)} instead  */ ;/**  * The script to execute. Note, make sure not to send different script each  * times and instead use script params if possible with the same  * (automatically compiled) script.  *  * @deprecated Use {@link #script(Script)} instead  */ @Deprecated public UpdateRequest script(String script, ScriptType scriptType) {     updateOrCreateScript(script, scriptType, null, null).     return this. }
true;public;1;5;/**  * The script to execute. Note, make sure not to send different script each  * times and instead use script params if possible with the same  * (automatically compiled) script.  *  * @deprecated Use {@link #script(Script)} instead  */ ;/**  * The script to execute. Note, make sure not to send different script each  * times and instead use script params if possible with the same  * (automatically compiled) script.  *  * @deprecated Use {@link #script(Script)} instead  */ @Deprecated public UpdateRequest script(String script) {     updateOrCreateScript(script, ScriptType.INLINE, null, null).     return this. }
true;public;1;5;/**  * The language of the script to execute.  *  * @deprecated Use {@link #script(Script)} instead  */ ;/**  * The language of the script to execute.  *  * @deprecated Use {@link #script(Script)} instead  */ @Deprecated public UpdateRequest scriptLang(String scriptLang) {     updateOrCreateScript(null, null, scriptLang, null).     return this. }
true;public;0;4;/**  * @deprecated Use {@link #script()} instead  */ ;/**  * @deprecated Use {@link #script()} instead  */ @Deprecated public String scriptLang() {     return script == null ? null : script.getLang(). }
true;public;2;19;/**  * Add a script parameter.  *  * @deprecated Use {@link #script(Script)} instead  */ ;/**  * Add a script parameter.  *  * @deprecated Use {@link #script(Script)} instead  */ @Deprecated public UpdateRequest addScriptParam(String name, Object value) {     Script script = script().     if (script == null) {         HashMap<String, Object> scriptParams = new HashMap<>().         scriptParams.put(name, value).         updateOrCreateScript(null, null, null, scriptParams).     } else {         Map<String, Object> scriptParams = script.getParams().         if (scriptParams == null) {             scriptParams = new HashMap<>().             scriptParams.put(name, value).             updateOrCreateScript(null, null, null, scriptParams).         } else {             scriptParams.put(name, value).         }     }     return this. }
true;public;1;5;/**  * Sets the script parameters to use with the script.  *  * @deprecated Use {@link #script(Script)} instead  */ ;/**  * Sets the script parameters to use with the script.  *  * @deprecated Use {@link #script(Script)} instead  */ @Deprecated public UpdateRequest scriptParams(Map<String, Object> scriptParams) {     updateOrCreateScript(null, null, null, scriptParams).     return this. }
false;private;4;13;;private void updateOrCreateScript(String scriptContent, ScriptType type, String lang, Map<String, Object> params) {     Script script = script().     if (script == null) {         script = new Script(type == null ? ScriptType.INLINE : type, lang, scriptContent == null ? "" : scriptContent, params).     } else {         String newScriptContent = scriptContent == null ? script.getIdOrCode() : scriptContent.         ScriptType newScriptType = type == null ? script.getType() : type.         String newScriptLang = lang == null ? script.getLang() : lang.         Map<String, Object> newScriptParams = params == null ? script.getParams() : params.         script = new Script(newScriptType, newScriptLang, newScriptContent, newScriptParams).     }     script(script). }
true;public;3;5;/**  * The script to execute. Note, make sure not to send different script each  * times and instead use script params if possible with the same  * (automatically compiled) script.  *  * @deprecated Use {@link #script(Script)} instead  */ ;/**  * The script to execute. Note, make sure not to send different script each  * times and instead use script params if possible with the same  * (automatically compiled) script.  *  * @deprecated Use {@link #script(Script)} instead  */ @Deprecated public UpdateRequest script(String script, ScriptType scriptType, @Nullable Map<String, Object> scriptParams) {     this.script = new Script(scriptType, Script.DEFAULT_SCRIPT_LANG, script, scriptParams).     return this. }
true;public;4;6;/**  * The script to execute. Note, make sure not to send different script each  * times and instead use script params if possible with the same  * (automatically compiled) script.  *  * @param script  *            The script to execute  * @param scriptLang  *            The script language  * @param scriptType  *            The script type  * @param scriptParams  *            The script parameters  *  * @deprecated Use {@link #script(Script)} instead  */ ;/**  * The script to execute. Note, make sure not to send different script each  * times and instead use script params if possible with the same  * (automatically compiled) script.  *  * @param script  *            The script to execute  * @param scriptLang  *            The script language  * @param scriptType  *            The script type  * @param scriptParams  *            The script parameters  *  * @deprecated Use {@link #script(Script)} instead  */ @Deprecated public UpdateRequest script(String script, @Nullable String scriptLang, ScriptType scriptType, @Nullable Map<String, Object> scriptParams) {     this.script = new Script(scriptType, scriptLang, script, scriptParams).     return this. }
true;public;2;7;/**  * Indicate that _source should be returned with every hit, with an  * "include" and/or "exclude" set which can include simple wildcard  * elements.  *  * @param include  *            An optional include (optionally wildcarded) pattern to filter  *            the returned _source  * @param exclude  *            An optional exclude (optionally wildcarded) pattern to filter  *            the returned _source  */ ;/**  * Indicate that _source should be returned with every hit, with an  * "include" and/or "exclude" set which can include simple wildcard  * elements.  *  * @param include  *            An optional include (optionally wildcarded) pattern to filter  *            the returned _source  * @param exclude  *            An optional exclude (optionally wildcarded) pattern to filter  *            the returned _source  */ public UpdateRequest fetchSource(@Nullable String include, @Nullable String exclude) {     FetchSourceContext context = this.fetchSourceContext == null ? FetchSourceContext.FETCH_SOURCE : this.fetchSourceContext.     String[] includes = include == null ? Strings.EMPTY_ARRAY : new String[] { include }.     String[] excludes = exclude == null ? Strings.EMPTY_ARRAY : new String[] { exclude }.     this.fetchSourceContext = new FetchSourceContext(context.fetchSource(), includes, excludes).     return this. }
true;public;2;5;/**  * Indicate that _source should be returned, with an  * "include" and/or "exclude" set which can include simple wildcard  * elements.  *  * @param includes  *            An optional list of include (optionally wildcarded) pattern to  *            filter the returned _source  * @param excludes  *            An optional list of exclude (optionally wildcarded) pattern to  *            filter the returned _source  */ ;/**  * Indicate that _source should be returned, with an  * "include" and/or "exclude" set which can include simple wildcard  * elements.  *  * @param includes  *            An optional list of include (optionally wildcarded) pattern to  *            filter the returned _source  * @param excludes  *            An optional list of exclude (optionally wildcarded) pattern to  *            filter the returned _source  */ public UpdateRequest fetchSource(@Nullable String[] includes, @Nullable String[] excludes) {     FetchSourceContext context = this.fetchSourceContext == null ? FetchSourceContext.FETCH_SOURCE : this.fetchSourceContext.     this.fetchSourceContext = new FetchSourceContext(context.fetchSource(), includes, excludes).     return this. }
true;public;1;5;/**  * Indicates whether the response should contain the updated _source.  */ ;/**  * Indicates whether the response should contain the updated _source.  */ public UpdateRequest fetchSource(boolean fetchSource) {     FetchSourceContext context = this.fetchSourceContext == null ? FetchSourceContext.FETCH_SOURCE : this.fetchSourceContext.     this.fetchSourceContext = new FetchSourceContext(fetchSource, context.includes(), context.excludes()).     return this. }
true;public;1;4;/**  * Explicitly set the fetch source context for this request  */ ;/**  * Explicitly set the fetch source context for this request  */ public UpdateRequest fetchSource(FetchSourceContext context) {     this.fetchSourceContext = context.     return this. }
true;public;0;3;/**  * Gets the {@link FetchSourceContext} which defines how the _source should  * be fetched.  */ ;/**  * Gets the {@link FetchSourceContext} which defines how the _source should  * be fetched.  */ public FetchSourceContext fetchSource() {     return fetchSourceContext. }
true;public;1;4;/**  * Sets the number of retries of a version conflict occurs because the document was updated between  * getting it and updating it. Defaults to 0.  */ ;/**  * Sets the number of retries of a version conflict occurs because the document was updated between  * getting it and updating it. Defaults to 0.  */ public UpdateRequest retryOnConflict(int retryOnConflict) {     this.retryOnConflict = retryOnConflict.     return this. }
false;public;0;3;;public int retryOnConflict() {     return this.retryOnConflict. }
false;public;1;4;;@Override public UpdateRequest version(long version) {     throw new UnsupportedOperationException("update requests do not support versioning"). }
false;public;0;4;;@Override public long version() {     return Versions.MATCH_ANY. }
false;public;1;4;;@Override public UpdateRequest versionType(VersionType versionType) {     throw new UnsupportedOperationException("update requests do not support versioning"). }
false;public;0;4;;@Override public VersionType versionType() {     return VersionType.INTERNAL. }
true;public;1;7;/**  * only perform this update request if the document's modification was assigned the given  * sequence number. Must be used in combination with {@link #setIfPrimaryTerm(long)}  *  * If the document last modification was assigned a different sequence number a  * {@link org.elasticsearch.index.engine.VersionConflictEngineException} will be thrown.  */ ;/**  * only perform this update request if the document's modification was assigned the given  * sequence number. Must be used in combination with {@link #setIfPrimaryTerm(long)}  *  * If the document last modification was assigned a different sequence number a  * {@link org.elasticsearch.index.engine.VersionConflictEngineException} will be thrown.  */ public UpdateRequest setIfSeqNo(long seqNo) {     if (seqNo < 0 && seqNo != UNASSIGNED_SEQ_NO) {         throw new IllegalArgumentException("sequence numbers must be non negative. got [" + seqNo + "].").     }     ifSeqNo = seqNo.     return this. }
true;public;1;7;/**  * only performs this update request if the document's last modification was assigned the given  * primary term. Must be used in combination with {@link #setIfSeqNo(long)}  *  * If the document last modification was assigned a different term a  * {@link org.elasticsearch.index.engine.VersionConflictEngineException} will be thrown.  */ ;/**  * only performs this update request if the document's last modification was assigned the given  * primary term. Must be used in combination with {@link #setIfSeqNo(long)}  *  * If the document last modification was assigned a different term a  * {@link org.elasticsearch.index.engine.VersionConflictEngineException} will be thrown.  */ public UpdateRequest setIfPrimaryTerm(long term) {     if (term < 0) {         throw new IllegalArgumentException("primary term must be non negative. got [" + term + "]").     }     ifPrimaryTerm = term.     return this. }
true;public;0;3;/**  * If set, only perform this update request if the document was last modification was assigned this sequence number.  * If the document last modification was assigned a different sequence number a  * {@link org.elasticsearch.index.engine.VersionConflictEngineException} will be thrown.  */ ;/**  * If set, only perform this update request if the document was last modification was assigned this sequence number.  * If the document last modification was assigned a different sequence number a  * {@link org.elasticsearch.index.engine.VersionConflictEngineException} will be thrown.  */ public long ifSeqNo() {     return ifSeqNo. }
true;public;0;3;/**  * If set, only perform this update request if the document was last modification was assigned this primary term.  *  * If the document last modification was assigned a different term a  * {@link org.elasticsearch.index.engine.VersionConflictEngineException} will be thrown.  */ ;/**  * If set, only perform this update request if the document was last modification was assigned this primary term.  *  * If the document last modification was assigned a different term a  * {@link org.elasticsearch.index.engine.VersionConflictEngineException} will be thrown.  */ public long ifPrimaryTerm() {     return ifPrimaryTerm. }
false;public;0;4;;@Override public OpType opType() {     return OpType.UPDATE. }
false;public;1;5;;@Override public UpdateRequest setRefreshPolicy(RefreshPolicy refreshPolicy) {     this.refreshPolicy = refreshPolicy.     return this. }
false;public;0;4;;@Override public RefreshPolicy getRefreshPolicy() {     return refreshPolicy. }
false;public;0;3;;public ActiveShardCount waitForActiveShards() {     return this.waitForActiveShards. }
true;public;1;4;/**  * Sets the number of shard copies that must be active before proceeding with the write.  * See {@link ReplicationRequest#waitForActiveShards(ActiveShardCount)} for details.  */ ;/**  * Sets the number of shard copies that must be active before proceeding with the write.  * See {@link ReplicationRequest#waitForActiveShards(ActiveShardCount)} for details.  */ public UpdateRequest waitForActiveShards(ActiveShardCount waitForActiveShards) {     this.waitForActiveShards = waitForActiveShards.     return this. }
true;public;1;3;/**  * A shortcut for {@link #waitForActiveShards(ActiveShardCount)} where the numerical  * shard count is passed in, instead of having to first call {@link ActiveShardCount#from(int)}  * to get the ActiveShardCount.  */ ;/**  * A shortcut for {@link #waitForActiveShards(ActiveShardCount)} where the numerical  * shard count is passed in, instead of having to first call {@link ActiveShardCount#from(int)}  * to get the ActiveShardCount.  */ public UpdateRequest waitForActiveShards(final int waitForActiveShards) {     return waitForActiveShards(ActiveShardCount.from(waitForActiveShards)). }
true;public;1;4;/**  * Sets the doc to use for updates when a script is not specified.  */ ;/**  * Sets the doc to use for updates when a script is not specified.  */ public UpdateRequest doc(IndexRequest doc) {     this.doc = doc.     return this. }
true;public;1;4;/**  * Sets the doc to use for updates when a script is not specified.  */ ;/**  * Sets the doc to use for updates when a script is not specified.  */ public UpdateRequest doc(XContentBuilder source) {     safeDoc().source(source).     return this. }
true;public;1;4;/**  * Sets the doc to use for updates when a script is not specified.  */ ;/**  * Sets the doc to use for updates when a script is not specified.  */ public UpdateRequest doc(Map<String, Object> source) {     safeDoc().source(source).     return this. }
true;public;2;4;/**  * Sets the doc to use for updates when a script is not specified.  */ ;/**  * Sets the doc to use for updates when a script is not specified.  */ public UpdateRequest doc(Map<String, Object> source, XContentType contentType) {     safeDoc().source(source, contentType).     return this. }
true;public;2;4;/**  * Sets the doc to use for updates when a script is not specified.  */ ;/**  * Sets the doc to use for updates when a script is not specified.  */ public UpdateRequest doc(String source, XContentType xContentType) {     safeDoc().source(source, xContentType).     return this. }
true;public;2;4;/**  * Sets the doc to use for updates when a script is not specified.  */ ;/**  * Sets the doc to use for updates when a script is not specified.  */ public UpdateRequest doc(byte[] source, XContentType xContentType) {     safeDoc().source(source, xContentType).     return this. }
true;public;4;4;/**  * Sets the doc to use for updates when a script is not specified.  */ ;/**  * Sets the doc to use for updates when a script is not specified.  */ public UpdateRequest doc(byte[] source, int offset, int length, XContentType xContentType) {     safeDoc().source(source, offset, length, xContentType).     return this. }
true;public;1;4;/**  * Sets the doc to use for updates when a script is not specified, the doc provided  * is a field and value pairs.  */ ;/**  * Sets the doc to use for updates when a script is not specified, the doc provided  * is a field and value pairs.  */ public UpdateRequest doc(Object... source) {     safeDoc().source(source).     return this. }
true;public;2;4;/**  * Sets the doc to use for updates when a script is not specified, the doc provided  * is a field and value pairs.  */ ;/**  * Sets the doc to use for updates when a script is not specified, the doc provided  * is a field and value pairs.  */ public UpdateRequest doc(XContentType xContentType, Object... source) {     safeDoc().source(xContentType, source).     return this. }
false;public;0;3;;public IndexRequest doc() {     return this.doc. }
false;private;0;6;;private IndexRequest safeDoc() {     if (doc == null) {         doc = new IndexRequest().     }     return doc. }
true;public;1;4;/**  * Sets the index request to be used if the document does not exists. Otherwise, a  * {@link org.elasticsearch.index.engine.DocumentMissingException} is thrown.  */ ;/**  * Sets the index request to be used if the document does not exists. Otherwise, a  * {@link org.elasticsearch.index.engine.DocumentMissingException} is thrown.  */ public UpdateRequest upsert(IndexRequest upsertRequest) {     this.upsertRequest = upsertRequest.     return this. }
true;public;1;4;/**  * Sets the doc source of the update request to be used when the document does not exists.  */ ;/**  * Sets the doc source of the update request to be used when the document does not exists.  */ public UpdateRequest upsert(XContentBuilder source) {     safeUpsertRequest().source(source).     return this. }
true;public;1;4;/**  * Sets the doc source of the update request to be used when the document does not exists.  */ ;/**  * Sets the doc source of the update request to be used when the document does not exists.  */ public UpdateRequest upsert(Map<String, Object> source) {     safeUpsertRequest().source(source).     return this. }
true;public;2;4;/**  * Sets the doc source of the update request to be used when the document does not exists.  */ ;/**  * Sets the doc source of the update request to be used when the document does not exists.  */ public UpdateRequest upsert(Map<String, Object> source, XContentType contentType) {     safeUpsertRequest().source(source, contentType).     return this. }
true;public;2;4;/**  * Sets the doc source of the update request to be used when the document does not exists.  */ ;/**  * Sets the doc source of the update request to be used when the document does not exists.  */ public UpdateRequest upsert(String source, XContentType xContentType) {     safeUpsertRequest().source(source, xContentType).     return this. }
true;public;2;4;/**  * Sets the doc source of the update request to be used when the document does not exists.  */ ;/**  * Sets the doc source of the update request to be used when the document does not exists.  */ public UpdateRequest upsert(byte[] source, XContentType xContentType) {     safeUpsertRequest().source(source, xContentType).     return this. }
true;public;4;4;/**  * Sets the doc source of the update request to be used when the document does not exists.  */ ;/**  * Sets the doc source of the update request to be used when the document does not exists.  */ public UpdateRequest upsert(byte[] source, int offset, int length, XContentType xContentType) {     safeUpsertRequest().source(source, offset, length, xContentType).     return this. }
true;public;1;4;/**  * Sets the doc source of the update request to be used when the document does not exists. The doc  * includes field and value pairs.  */ ;/**  * Sets the doc source of the update request to be used when the document does not exists. The doc  * includes field and value pairs.  */ public UpdateRequest upsert(Object... source) {     safeUpsertRequest().source(source).     return this. }
true;public;2;4;/**  * Sets the doc source of the update request to be used when the document does not exists. The doc  * includes field and value pairs.  */ ;/**  * Sets the doc source of the update request to be used when the document does not exists. The doc  * includes field and value pairs.  */ public UpdateRequest upsert(XContentType xContentType, Object... source) {     safeUpsertRequest().source(xContentType, source).     return this. }
false;public;0;3;;public IndexRequest upsertRequest() {     return this.upsertRequest. }
false;private;0;6;;private IndexRequest safeUpsertRequest() {     if (upsertRequest == null) {         upsertRequest = new IndexRequest().     }     return upsertRequest. }
true;public;1;4;/**  * Should this update attempt to detect if it is a noop? Defaults to true.  * @return this for chaining  */ ;/**  * Should this update attempt to detect if it is a noop? Defaults to true.  * @return this for chaining  */ public UpdateRequest detectNoop(boolean detectNoop) {     this.detectNoop = detectNoop.     return this. }
true;public;0;3;/**  * Should this update attempt to detect if it is a noop? Defaults to true.  */ ;/**  * Should this update attempt to detect if it is a noop? Defaults to true.  */ public boolean detectNoop() {     return detectNoop. }
false;public;1;3;;public UpdateRequest fromXContent(XContentParser parser) throws IOException {     return PARSER.parse(parser, this, null). }
false;public;0;3;;public boolean docAsUpsert() {     return this.docAsUpsert. }
false;public;1;4;;public UpdateRequest docAsUpsert(boolean shouldUpsertDoc) {     this.docAsUpsert = shouldUpsertDoc.     return this. }
false;public;0;3;;public boolean scriptedUpsert() {     return this.scriptedUpsert. }
false;public;1;4;;public UpdateRequest scriptedUpsert(boolean scriptedUpsert) {     this.scriptedUpsert = scriptedUpsert.     return this. }
false;public;1;44;;@Override public void readFrom(StreamInput in) throws IOException {     super.readFrom(in).     waitForActiveShards = ActiveShardCount.readFrom(in).     type = in.readString().     id = in.readString().     routing = in.readOptionalString().     if (in.getVersion().before(Version.V_7_0_0)) {         // _parent         in.readOptionalString().     }     if (in.readBoolean()) {         script = new Script(in).     }     retryOnConflict = in.readVInt().     refreshPolicy = RefreshPolicy.readFrom(in).     if (in.readBoolean()) {         doc = new IndexRequest().         doc.readFrom(in).     }     if (in.getVersion().before(Version.V_7_0_0)) {         String[] fields = in.readOptionalStringArray().         if (fields != null) {             throw new IllegalArgumentException("[fields] is no longer supported").         }     }     fetchSourceContext = in.readOptionalWriteable(FetchSourceContext::new).     if (in.readBoolean()) {         upsertRequest = new IndexRequest().         upsertRequest.readFrom(in).     }     docAsUpsert = in.readBoolean().     if (in.getVersion().before(Version.V_7_0_0)) {         long version = in.readLong().         VersionType versionType = VersionType.readFromStream(in).         if (version != Versions.MATCH_ANY || versionType != VersionType.INTERNAL) {             throw new UnsupportedOperationException("versioned update requests have been removed in 7.0. Use if_seq_no and if_primary_term").         }     }     ifSeqNo = in.readZLong().     ifPrimaryTerm = in.readVLong().     detectNoop = in.readBoolean().     scriptedUpsert = in.readBoolean(). }
false;public;1;54;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     waitForActiveShards.writeTo(out).     // A 7.x request allows null types but if deserialized in a 6.x node will cause nullpointer exceptions.     // So we use the type accessor method here to make the type non-null (will default it to "_doc").     out.writeString(type()).     out.writeString(id).     out.writeOptionalString(routing).     if (out.getVersion().before(Version.V_7_0_0)) {         // _parent         out.writeOptionalString(null).     }     boolean hasScript = script != null.     out.writeBoolean(hasScript).     if (hasScript) {         script.writeTo(out).     }     out.writeVInt(retryOnConflict).     refreshPolicy.writeTo(out).     if (doc == null) {         out.writeBoolean(false).     } else {         out.writeBoolean(true).         // make sure the basics are set         doc.index(index).         doc.type(type).         doc.id(id).         doc.writeTo(out).     }     if (out.getVersion().before(Version.V_7_0_0)) {         out.writeOptionalStringArray(null).     }     out.writeOptionalWriteable(fetchSourceContext).     if (upsertRequest == null) {         out.writeBoolean(false).     } else {         out.writeBoolean(true).         // make sure the basics are set         upsertRequest.index(index).         upsertRequest.type(type).         upsertRequest.id(id).         upsertRequest.writeTo(out).     }     out.writeBoolean(docAsUpsert).     if (out.getVersion().before(Version.V_7_0_0)) {         out.writeLong(Versions.MATCH_ANY).         out.writeByte(VersionType.INTERNAL.getValue()).     }     out.writeZLong(ifSeqNo).     out.writeVLong(ifPrimaryTerm).     out.writeBoolean(detectNoop).     out.writeBoolean(scriptedUpsert). }
false;public;2;43;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     if (docAsUpsert) {         builder.field("doc_as_upsert", docAsUpsert).     }     if (doc != null) {         XContentType xContentType = doc.getContentType().         try (XContentParser parser = XContentHelper.createParser(NamedXContentRegistry.EMPTY, LoggingDeprecationHandler.INSTANCE, doc.source(), xContentType)) {             builder.field("doc").             builder.copyCurrentStructure(parser).         }     }     if (ifSeqNo != UNASSIGNED_SEQ_NO) {         builder.field(IF_SEQ_NO.getPreferredName(), ifSeqNo).         builder.field(IF_PRIMARY_TERM.getPreferredName(), ifPrimaryTerm).     }     if (script != null) {         builder.field("script", script).     }     if (upsertRequest != null) {         XContentType xContentType = upsertRequest.getContentType().         try (XContentParser parser = XContentHelper.createParser(NamedXContentRegistry.EMPTY, LoggingDeprecationHandler.INSTANCE, upsertRequest.source(), xContentType)) {             builder.field("upsert").             builder.copyCurrentStructure(parser).         }     }     if (scriptedUpsert) {         builder.field("scripted_upsert", scriptedUpsert).     }     if (detectNoop == false) {         builder.field("detect_noop", detectNoop).     }     if (fetchSourceContext != null) {         builder.field("_source", fetchSourceContext).     }     builder.endObject().     return builder. }
false;public;0;20;;@Override public String toString() {     StringBuilder res = new StringBuilder().append("update {[").append(index).append("][").append(type()).append("][").append(id).append("]").     res.append(", doc_as_upsert[").append(docAsUpsert).append("]").     if (doc != null) {         res.append(", doc[").append(doc).append("]").     }     if (script != null) {         res.append(", script[").append(script).append("]").     }     if (upsertRequest != null) {         res.append(", upsert[").append(upsertRequest).append("]").     }     res.append(", scripted_upsert[").append(scriptedUpsert).append("]").     res.append(", detect_noop[").append(detectNoop).append("]").     return res.append("}").toString(). }
