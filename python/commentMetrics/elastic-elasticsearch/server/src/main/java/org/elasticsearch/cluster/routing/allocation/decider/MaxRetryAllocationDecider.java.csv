commented;modifiers;parameterAmount;loc;comment;code
false;public;2;20;;@Override public Decision canAllocate(ShardRouting shardRouting, RoutingAllocation allocation) {     final UnassignedInfo unassignedInfo = shardRouting.unassignedInfo().     final Decision decision.     if (unassignedInfo != null && unassignedInfo.getNumFailedAllocations() > 0) {         final IndexMetaData indexMetaData = allocation.metaData().getIndexSafe(shardRouting.index()).         final int maxRetry = SETTING_ALLOCATION_MAX_RETRY.get(indexMetaData.getSettings()).         if (unassignedInfo.getNumFailedAllocations() >= maxRetry) {             decision = allocation.decision(Decision.NO, NAME, "shard has exceeded the maximum number of retries [%d] on " + "failed allocation attempts - manually call [/_cluster/reroute?retry_failed=true] to retry, [%s]", maxRetry, unassignedInfo.toString()).         } else {             decision = allocation.decision(Decision.YES, NAME, "shard has failed allocating [%d] times but [%d] retries are allowed", unassignedInfo.getNumFailedAllocations(), maxRetry).         }     } else {         decision = allocation.decision(Decision.YES, NAME, "shard has no previous failures").     }     return decision. }
false;public;3;4;;@Override public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {     return canAllocate(shardRouting, allocation). }
false;public;3;7;;@Override public Decision canForceAllocatePrimary(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {     assert shardRouting.primary() : "must not call canForceAllocatePrimary on a non-primary shard " + shardRouting.     // if so, we don't want to force the primary allocation here     return canAllocate(shardRouting, node, allocation). }
