# id;timestamp;commentText;codeText;commentWords;codeWords
SyncedFlushService -> public void attemptSyncedFlush(final String[] aliasesOrIndices,                                    IndicesOptions indicesOptions,                                    final ActionListener<SyncedFlushResponse> listener);1542609384;a utility method to perform a synced flush for all shards of multiple indices._see {@link #attemptSyncedFlush(ShardId, ActionListener)}_for more details.;public void attemptSyncedFlush(final String[] aliasesOrIndices,_                                   IndicesOptions indicesOptions,_                                   final ActionListener<SyncedFlushResponse> listener) {_        final ClusterState state = clusterService.state()__        final Index[] concreteIndices = indexNameExpressionResolver.concreteIndices(state, indicesOptions, aliasesOrIndices)__        final Map<String, List<ShardsSyncedFlushResult>> results = ConcurrentCollections.newConcurrentMap()__        int numberOfShards = 0__        for (Index index : concreteIndices) {_            final IndexMetaData indexMetaData = state.metaData().getIndexSafe(index)__            numberOfShards += indexMetaData.getNumberOfShards()__            results.put(index.getName(), Collections.synchronizedList(new ArrayList<>()))___        }_        if (numberOfShards == 0) {_            listener.onResponse(new SyncedFlushResponse(results))__            return__        }_        final CountDown countDown = new CountDown(numberOfShards)___        for (final Index concreteIndex : concreteIndices) {_            final String index = concreteIndex.getName()__            final IndexMetaData indexMetaData = state.metaData().getIndexSafe(concreteIndex)__            final int indexNumberOfShards = indexMetaData.getNumberOfShards()__            for (int shard = 0_ shard < indexNumberOfShards_ shard++) {_                final ShardId shardId = new ShardId(indexMetaData.getIndex(), shard)__                innerAttemptSyncedFlush(shardId, state, new ActionListener<ShardsSyncedFlushResult>() {_                    @Override_                    public void onResponse(ShardsSyncedFlushResult syncedFlushResult) {_                        results.get(index).add(syncedFlushResult)__                        if (countDown.countDown()) {_                            listener.onResponse(new SyncedFlushResponse(results))__                        }_                    }__                    @Override_                    public void onFailure(Exception e) {_                        logger.debug("{} unexpected error while executing synced flush", shardId)__                        final int totalShards = indexMetaData.getNumberOfReplicas() + 1__                        results.get(index).add(new ShardsSyncedFlushResult(shardId, totalShards, e.getMessage()))__                        if (countDown.countDown()) {_                            listener.onResponse(new SyncedFlushResponse(results))__                        }_                    }_                })__            }_        }_    };a,utility,method,to,perform,a,synced,flush,for,all,shards,of,multiple,indices,see,link,attempt,synced,flush,shard,id,action,listener,for,more,details;public,void,attempt,synced,flush,final,string,aliases,or,indices,indices,options,indices,options,final,action,listener,synced,flush,response,listener,final,cluster,state,state,cluster,service,state,final,index,concrete,indices,index,name,expression,resolver,concrete,indices,state,indices,options,aliases,or,indices,final,map,string,list,shards,synced,flush,result,results,concurrent,collections,new,concurrent,map,int,number,of,shards,0,for,index,index,concrete,indices,final,index,meta,data,index,meta,data,state,meta,data,get,index,safe,index,number,of,shards,index,meta,data,get,number,of,shards,results,put,index,get,name,collections,synchronized,list,new,array,list,if,number,of,shards,0,listener,on,response,new,synced,flush,response,results,return,final,count,down,count,down,new,count,down,number,of,shards,for,final,index,concrete,index,concrete,indices,final,string,index,concrete,index,get,name,final,index,meta,data,index,meta,data,state,meta,data,get,index,safe,concrete,index,final,int,index,number,of,shards,index,meta,data,get,number,of,shards,for,int,shard,0,shard,index,number,of,shards,shard,final,shard,id,shard,id,new,shard,id,index,meta,data,get,index,shard,inner,attempt,synced,flush,shard,id,state,new,action,listener,shards,synced,flush,result,override,public,void,on,response,shards,synced,flush,result,synced,flush,result,results,get,index,add,synced,flush,result,if,count,down,count,down,listener,on,response,new,synced,flush,response,results,override,public,void,on,failure,exception,e,logger,debug,unexpected,error,while,executing,synced,flush,shard,id,final,int,total,shards,index,meta,data,get,number,of,replicas,1,results,get,index,add,new,shards,synced,flush,result,shard,id,total,shards,e,get,message,if,count,down,count,down,listener,on,response,new,synced,flush,response,results
SyncedFlushService -> public void attemptSyncedFlush(final String[] aliasesOrIndices,                                    IndicesOptions indicesOptions,                                    final ActionListener<SyncedFlushResponse> listener);1547456074;a utility method to perform a synced flush for all shards of multiple indices._see {@link #attemptSyncedFlush(ShardId, ActionListener)}_for more details.;public void attemptSyncedFlush(final String[] aliasesOrIndices,_                                   IndicesOptions indicesOptions,_                                   final ActionListener<SyncedFlushResponse> listener) {_        final ClusterState state = clusterService.state()__        final Index[] concreteIndices = indexNameExpressionResolver.concreteIndices(state, indicesOptions, aliasesOrIndices)__        final Map<String, List<ShardsSyncedFlushResult>> results = ConcurrentCollections.newConcurrentMap()__        int numberOfShards = 0__        for (Index index : concreteIndices) {_            final IndexMetaData indexMetaData = state.metaData().getIndexSafe(index)__            numberOfShards += indexMetaData.getNumberOfShards()__            results.put(index.getName(), Collections.synchronizedList(new ArrayList<>()))___        }_        if (numberOfShards == 0) {_            listener.onResponse(new SyncedFlushResponse(results))__            return__        }_        final CountDown countDown = new CountDown(numberOfShards)___        for (final Index concreteIndex : concreteIndices) {_            final String index = concreteIndex.getName()__            final IndexMetaData indexMetaData = state.metaData().getIndexSafe(concreteIndex)__            final int indexNumberOfShards = indexMetaData.getNumberOfShards()__            for (int shard = 0_ shard < indexNumberOfShards_ shard++) {_                final ShardId shardId = new ShardId(indexMetaData.getIndex(), shard)__                innerAttemptSyncedFlush(shardId, state, new ActionListener<ShardsSyncedFlushResult>() {_                    @Override_                    public void onResponse(ShardsSyncedFlushResult syncedFlushResult) {_                        results.get(index).add(syncedFlushResult)__                        if (countDown.countDown()) {_                            listener.onResponse(new SyncedFlushResponse(results))__                        }_                    }__                    @Override_                    public void onFailure(Exception e) {_                        logger.debug("{} unexpected error while executing synced flush", shardId)__                        final int totalShards = indexMetaData.getNumberOfReplicas() + 1__                        results.get(index).add(new ShardsSyncedFlushResult(shardId, totalShards, e.getMessage()))__                        if (countDown.countDown()) {_                            listener.onResponse(new SyncedFlushResponse(results))__                        }_                    }_                })__            }_        }_    };a,utility,method,to,perform,a,synced,flush,for,all,shards,of,multiple,indices,see,link,attempt,synced,flush,shard,id,action,listener,for,more,details;public,void,attempt,synced,flush,final,string,aliases,or,indices,indices,options,indices,options,final,action,listener,synced,flush,response,listener,final,cluster,state,state,cluster,service,state,final,index,concrete,indices,index,name,expression,resolver,concrete,indices,state,indices,options,aliases,or,indices,final,map,string,list,shards,synced,flush,result,results,concurrent,collections,new,concurrent,map,int,number,of,shards,0,for,index,index,concrete,indices,final,index,meta,data,index,meta,data,state,meta,data,get,index,safe,index,number,of,shards,index,meta,data,get,number,of,shards,results,put,index,get,name,collections,synchronized,list,new,array,list,if,number,of,shards,0,listener,on,response,new,synced,flush,response,results,return,final,count,down,count,down,new,count,down,number,of,shards,for,final,index,concrete,index,concrete,indices,final,string,index,concrete,index,get,name,final,index,meta,data,index,meta,data,state,meta,data,get,index,safe,concrete,index,final,int,index,number,of,shards,index,meta,data,get,number,of,shards,for,int,shard,0,shard,index,number,of,shards,shard,final,shard,id,shard,id,new,shard,id,index,meta,data,get,index,shard,inner,attempt,synced,flush,shard,id,state,new,action,listener,shards,synced,flush,result,override,public,void,on,response,shards,synced,flush,result,synced,flush,result,results,get,index,add,synced,flush,result,if,count,down,count,down,listener,on,response,new,synced,flush,response,results,override,public,void,on,failure,exception,e,logger,debug,unexpected,error,while,executing,synced,flush,shard,id,final,int,total,shards,index,meta,data,get,number,of,replicas,1,results,get,index,add,new,shards,synced,flush,result,shard,id,total,shards,e,get,message,if,count,down,count,down,listener,on,response,new,synced,flush,response,results
SyncedFlushService -> public void attemptSyncedFlush(final String[] aliasesOrIndices,                                    IndicesOptions indicesOptions,                                    final ActionListener<SyncedFlushResponse> listener);1548238134;a utility method to perform a synced flush for all shards of multiple indices._see {@link #attemptSyncedFlush(ShardId, ActionListener)}_for more details.;public void attemptSyncedFlush(final String[] aliasesOrIndices,_                                   IndicesOptions indicesOptions,_                                   final ActionListener<SyncedFlushResponse> listener) {_        final ClusterState state = clusterService.state()__        final Index[] concreteIndices = indexNameExpressionResolver.concreteIndices(state, indicesOptions, aliasesOrIndices)__        final Map<String, List<ShardsSyncedFlushResult>> results = ConcurrentCollections.newConcurrentMap()__        int numberOfShards = 0__        for (Index index : concreteIndices) {_            final IndexMetaData indexMetaData = state.metaData().getIndexSafe(index)__            numberOfShards += indexMetaData.getNumberOfShards()__            results.put(index.getName(), Collections.synchronizedList(new ArrayList<>()))___        }_        if (numberOfShards == 0) {_            listener.onResponse(new SyncedFlushResponse(results))__            return__        }_        final CountDown countDown = new CountDown(numberOfShards)___        for (final Index concreteIndex : concreteIndices) {_            final String index = concreteIndex.getName()__            final IndexMetaData indexMetaData = state.metaData().getIndexSafe(concreteIndex)__            final int indexNumberOfShards = indexMetaData.getNumberOfShards()__            for (int shard = 0_ shard < indexNumberOfShards_ shard++) {_                final ShardId shardId = new ShardId(indexMetaData.getIndex(), shard)__                innerAttemptSyncedFlush(shardId, state, new ActionListener<ShardsSyncedFlushResult>() {_                    @Override_                    public void onResponse(ShardsSyncedFlushResult syncedFlushResult) {_                        results.get(index).add(syncedFlushResult)__                        if (countDown.countDown()) {_                            listener.onResponse(new SyncedFlushResponse(results))__                        }_                    }__                    @Override_                    public void onFailure(Exception e) {_                        logger.debug("{} unexpected error while executing synced flush", shardId)__                        final int totalShards = indexMetaData.getNumberOfReplicas() + 1__                        results.get(index).add(new ShardsSyncedFlushResult(shardId, totalShards, e.getMessage()))__                        if (countDown.countDown()) {_                            listener.onResponse(new SyncedFlushResponse(results))__                        }_                    }_                })__            }_        }_    };a,utility,method,to,perform,a,synced,flush,for,all,shards,of,multiple,indices,see,link,attempt,synced,flush,shard,id,action,listener,for,more,details;public,void,attempt,synced,flush,final,string,aliases,or,indices,indices,options,indices,options,final,action,listener,synced,flush,response,listener,final,cluster,state,state,cluster,service,state,final,index,concrete,indices,index,name,expression,resolver,concrete,indices,state,indices,options,aliases,or,indices,final,map,string,list,shards,synced,flush,result,results,concurrent,collections,new,concurrent,map,int,number,of,shards,0,for,index,index,concrete,indices,final,index,meta,data,index,meta,data,state,meta,data,get,index,safe,index,number,of,shards,index,meta,data,get,number,of,shards,results,put,index,get,name,collections,synchronized,list,new,array,list,if,number,of,shards,0,listener,on,response,new,synced,flush,response,results,return,final,count,down,count,down,new,count,down,number,of,shards,for,final,index,concrete,index,concrete,indices,final,string,index,concrete,index,get,name,final,index,meta,data,index,meta,data,state,meta,data,get,index,safe,concrete,index,final,int,index,number,of,shards,index,meta,data,get,number,of,shards,for,int,shard,0,shard,index,number,of,shards,shard,final,shard,id,shard,id,new,shard,id,index,meta,data,get,index,shard,inner,attempt,synced,flush,shard,id,state,new,action,listener,shards,synced,flush,result,override,public,void,on,response,shards,synced,flush,result,synced,flush,result,results,get,index,add,synced,flush,result,if,count,down,count,down,listener,on,response,new,synced,flush,response,results,override,public,void,on,failure,exception,e,logger,debug,unexpected,error,while,executing,synced,flush,shard,id,final,int,total,shards,index,meta,data,get,number,of,replicas,1,results,get,index,add,new,shards,synced,flush,result,shard,id,total,shards,e,get,message,if,count,down,count,down,listener,on,response,new,synced,flush,response,results
SyncedFlushService -> void sendPreSyncRequests(final List<ShardRouting> shards,                              final ClusterState state,                              final ShardId shardId,                              final ActionListener<Map<String, PreSyncedFlushResponse>> listener);1542609384;send presync requests to all started copies of the given shard;void sendPreSyncRequests(final List<ShardRouting> shards,_                             final ClusterState state,_                             final ShardId shardId,_                             final ActionListener<Map<String, PreSyncedFlushResponse>> listener) {_        final CountDown countDown = new CountDown(shards.size())__        final ConcurrentMap<String, PreSyncedFlushResponse> presyncResponses = ConcurrentCollections.newConcurrentMap()__        for (final ShardRouting shard : shards) {_            logger.trace("{} sending pre-synced flush request to {}", shardId, shard)__            final DiscoveryNode node = state.nodes().get(shard.currentNodeId())__            if (node == null) {_                logger.trace("{} shard routing {} refers to an unknown node. skipping.", shardId, shard)__                if (countDown.countDown()) {_                    listener.onResponse(presyncResponses)__                }_                continue__            }_            transportService.sendRequest(node, PRE_SYNCED_FLUSH_ACTION_NAME, new PreShardSyncedFlushRequest(shard.shardId()),_                new TransportResponseHandler<PreSyncedFlushResponse>() {_                @Override_                public PreSyncedFlushResponse read(StreamInput in) throws IOException {_                    PreSyncedFlushResponse response = new PreSyncedFlushResponse()__                    response.readFrom(in)__                    return response__                }__                @Override_                public void handleResponse(PreSyncedFlushResponse response) {_                    PreSyncedFlushResponse existing = presyncResponses.putIfAbsent(node.getId(), response)__                    assert existing == null : "got two answers for node [" + node + "]"__                    _                    if (countDown.countDown()) {_                        listener.onResponse(presyncResponses)__                    }_                }__                @Override_                public void handleException(TransportException exp) {_                    logger.trace(() -> new ParameterizedMessage("{} error while performing pre synced flush on [{}], skipping",_                        shardId, shard), exp)__                    if (countDown.countDown()) {_                        listener.onResponse(presyncResponses)__                    }_                }__                @Override_                public String executor() {_                    return ThreadPool.Names.SAME__                }_            })__        }_    };send,presync,requests,to,all,started,copies,of,the,given,shard;void,send,pre,sync,requests,final,list,shard,routing,shards,final,cluster,state,state,final,shard,id,shard,id,final,action,listener,map,string,pre,synced,flush,response,listener,final,count,down,count,down,new,count,down,shards,size,final,concurrent,map,string,pre,synced,flush,response,presync,responses,concurrent,collections,new,concurrent,map,for,final,shard,routing,shard,shards,logger,trace,sending,pre,synced,flush,request,to,shard,id,shard,final,discovery,node,node,state,nodes,get,shard,current,node,id,if,node,null,logger,trace,shard,routing,refers,to,an,unknown,node,skipping,shard,id,shard,if,count,down,count,down,listener,on,response,presync,responses,continue,transport,service,send,request,node,new,pre,shard,synced,flush,request,shard,shard,id,new,transport,response,handler,pre,synced,flush,response,override,public,pre,synced,flush,response,read,stream,input,in,throws,ioexception,pre,synced,flush,response,response,new,pre,synced,flush,response,response,read,from,in,return,response,override,public,void,handle,response,pre,synced,flush,response,response,pre,synced,flush,response,existing,presync,responses,put,if,absent,node,get,id,response,assert,existing,null,got,two,answers,for,node,node,if,count,down,count,down,listener,on,response,presync,responses,override,public,void,handle,exception,transport,exception,exp,logger,trace,new,parameterized,message,error,while,performing,pre,synced,flush,on,skipping,shard,id,shard,exp,if,count,down,count,down,listener,on,response,presync,responses,override,public,string,executor,return,thread,pool,names,same
SyncedFlushService -> void sendPreSyncRequests(final List<ShardRouting> shards,                              final ClusterState state,                              final ShardId shardId,                              final ActionListener<Map<String, PreSyncedFlushResponse>> listener);1547456074;send presync requests to all started copies of the given shard;void sendPreSyncRequests(final List<ShardRouting> shards,_                             final ClusterState state,_                             final ShardId shardId,_                             final ActionListener<Map<String, PreSyncedFlushResponse>> listener) {_        final CountDown countDown = new CountDown(shards.size())__        final ConcurrentMap<String, PreSyncedFlushResponse> presyncResponses = ConcurrentCollections.newConcurrentMap()__        for (final ShardRouting shard : shards) {_            logger.trace("{} sending pre-synced flush request to {}", shardId, shard)__            final DiscoveryNode node = state.nodes().get(shard.currentNodeId())__            if (node == null) {_                logger.trace("{} shard routing {} refers to an unknown node. skipping.", shardId, shard)__                if (countDown.countDown()) {_                    listener.onResponse(presyncResponses)__                }_                continue__            }_            transportService.sendRequest(node, PRE_SYNCED_FLUSH_ACTION_NAME, new PreShardSyncedFlushRequest(shard.shardId()),_                new TransportResponseHandler<PreSyncedFlushResponse>() {_                @Override_                public PreSyncedFlushResponse read(StreamInput in) throws IOException {_                    PreSyncedFlushResponse response = new PreSyncedFlushResponse()__                    response.readFrom(in)__                    return response__                }__                @Override_                public void handleResponse(PreSyncedFlushResponse response) {_                    PreSyncedFlushResponse existing = presyncResponses.putIfAbsent(node.getId(), response)__                    assert existing == null : "got two answers for node [" + node + "]"__                    _                    if (countDown.countDown()) {_                        listener.onResponse(presyncResponses)__                    }_                }__                @Override_                public void handleException(TransportException exp) {_                    logger.trace(() -> new ParameterizedMessage("{} error while performing pre synced flush on [{}], skipping",_                        shardId, shard), exp)__                    if (countDown.countDown()) {_                        listener.onResponse(presyncResponses)__                    }_                }__                @Override_                public String executor() {_                    return ThreadPool.Names.SAME__                }_            })__        }_    };send,presync,requests,to,all,started,copies,of,the,given,shard;void,send,pre,sync,requests,final,list,shard,routing,shards,final,cluster,state,state,final,shard,id,shard,id,final,action,listener,map,string,pre,synced,flush,response,listener,final,count,down,count,down,new,count,down,shards,size,final,concurrent,map,string,pre,synced,flush,response,presync,responses,concurrent,collections,new,concurrent,map,for,final,shard,routing,shard,shards,logger,trace,sending,pre,synced,flush,request,to,shard,id,shard,final,discovery,node,node,state,nodes,get,shard,current,node,id,if,node,null,logger,trace,shard,routing,refers,to,an,unknown,node,skipping,shard,id,shard,if,count,down,count,down,listener,on,response,presync,responses,continue,transport,service,send,request,node,new,pre,shard,synced,flush,request,shard,shard,id,new,transport,response,handler,pre,synced,flush,response,override,public,pre,synced,flush,response,read,stream,input,in,throws,ioexception,pre,synced,flush,response,response,new,pre,synced,flush,response,response,read,from,in,return,response,override,public,void,handle,response,pre,synced,flush,response,response,pre,synced,flush,response,existing,presync,responses,put,if,absent,node,get,id,response,assert,existing,null,got,two,answers,for,node,node,if,count,down,count,down,listener,on,response,presync,responses,override,public,void,handle,exception,transport,exception,exp,logger,trace,new,parameterized,message,error,while,performing,pre,synced,flush,on,skipping,shard,id,shard,exp,if,count,down,count,down,listener,on,response,presync,responses,override,public,string,executor,return,thread,pool,names,same
SyncedFlushService -> void sendPreSyncRequests(final List<ShardRouting> shards,                              final ClusterState state,                              final ShardId shardId,                              final ActionListener<Map<String, PreSyncedFlushResponse>> listener);1548238134;send presync requests to all started copies of the given shard;void sendPreSyncRequests(final List<ShardRouting> shards,_                             final ClusterState state,_                             final ShardId shardId,_                             final ActionListener<Map<String, PreSyncedFlushResponse>> listener) {_        final CountDown countDown = new CountDown(shards.size())__        final ConcurrentMap<String, PreSyncedFlushResponse> presyncResponses = ConcurrentCollections.newConcurrentMap()__        for (final ShardRouting shard : shards) {_            logger.trace("{} sending pre-synced flush request to {}", shardId, shard)__            final DiscoveryNode node = state.nodes().get(shard.currentNodeId())__            if (node == null) {_                logger.trace("{} shard routing {} refers to an unknown node. skipping.", shardId, shard)__                if (countDown.countDown()) {_                    listener.onResponse(presyncResponses)__                }_                continue__            }_            transportService.sendRequest(node, PRE_SYNCED_FLUSH_ACTION_NAME, new PreShardSyncedFlushRequest(shard.shardId()),_                new TransportResponseHandler<PreSyncedFlushResponse>() {_                @Override_                public PreSyncedFlushResponse read(StreamInput in) throws IOException {_                    PreSyncedFlushResponse response = new PreSyncedFlushResponse()__                    response.readFrom(in)__                    return response__                }__                @Override_                public void handleResponse(PreSyncedFlushResponse response) {_                    PreSyncedFlushResponse existing = presyncResponses.putIfAbsent(node.getId(), response)__                    assert existing == null : "got two answers for node [" + node + "]"__                    _                    if (countDown.countDown()) {_                        listener.onResponse(presyncResponses)__                    }_                }__                @Override_                public void handleException(TransportException exp) {_                    logger.trace(() -> new ParameterizedMessage("{} error while performing pre synced flush on [{}], skipping",_                        shardId, shard), exp)__                    if (countDown.countDown()) {_                        listener.onResponse(presyncResponses)__                    }_                }__                @Override_                public String executor() {_                    return ThreadPool.Names.SAME__                }_            })__        }_    };send,presync,requests,to,all,started,copies,of,the,given,shard;void,send,pre,sync,requests,final,list,shard,routing,shards,final,cluster,state,state,final,shard,id,shard,id,final,action,listener,map,string,pre,synced,flush,response,listener,final,count,down,count,down,new,count,down,shards,size,final,concurrent,map,string,pre,synced,flush,response,presync,responses,concurrent,collections,new,concurrent,map,for,final,shard,routing,shard,shards,logger,trace,sending,pre,synced,flush,request,to,shard,id,shard,final,discovery,node,node,state,nodes,get,shard,current,node,id,if,node,null,logger,trace,shard,routing,refers,to,an,unknown,node,skipping,shard,id,shard,if,count,down,count,down,listener,on,response,presync,responses,continue,transport,service,send,request,node,new,pre,shard,synced,flush,request,shard,shard,id,new,transport,response,handler,pre,synced,flush,response,override,public,pre,synced,flush,response,read,stream,input,in,throws,ioexception,pre,synced,flush,response,response,new,pre,synced,flush,response,response,read,from,in,return,response,override,public,void,handle,response,pre,synced,flush,response,response,pre,synced,flush,response,existing,presync,responses,put,if,absent,node,get,id,response,assert,existing,null,got,two,answers,for,node,node,if,count,down,count,down,listener,on,response,presync,responses,override,public,void,handle,exception,transport,exception,exp,logger,trace,new,parameterized,message,error,while,performing,pre,synced,flush,on,skipping,shard,id,shard,exp,if,count,down,count,down,listener,on,response,presync,responses,override,public,string,executor,return,thread,pool,names,same
SyncedFlushService -> public void attemptSyncedFlush(final String[] aliasesOrIndices, IndicesOptions indicesOptions, final ActionListener<SyncedFlushResponse> listener);1524684173;a utility method to perform a synced flush for all shards of multiple indices. see {@link #attemptSyncedFlush(ShardId, ActionListener)}_for more details.;public void attemptSyncedFlush(final String[] aliasesOrIndices, IndicesOptions indicesOptions, final ActionListener<SyncedFlushResponse> listener) {_        final ClusterState state = clusterService.state()__        final Index[] concreteIndices = indexNameExpressionResolver.concreteIndices(state, indicesOptions, aliasesOrIndices)__        final Map<String, List<ShardsSyncedFlushResult>> results = ConcurrentCollections.newConcurrentMap()__        int numberOfShards = 0__        for (Index index : concreteIndices) {_            final IndexMetaData indexMetaData = state.metaData().getIndexSafe(index)__            numberOfShards += indexMetaData.getNumberOfShards()__            results.put(index.getName(), Collections.synchronizedList(new ArrayList<>()))___        }_        if (numberOfShards == 0) {_            listener.onResponse(new SyncedFlushResponse(results))__            return__        }_        final CountDown countDown = new CountDown(numberOfShards)___        for (final Index concreteIndex : concreteIndices) {_            final String index = concreteIndex.getName()__            final IndexMetaData indexMetaData = state.metaData().getIndexSafe(concreteIndex)__            final int indexNumberOfShards = indexMetaData.getNumberOfShards()__            for (int shard = 0_ shard < indexNumberOfShards_ shard++) {_                final ShardId shardId = new ShardId(indexMetaData.getIndex(), shard)__                innerAttemptSyncedFlush(shardId, state, new ActionListener<ShardsSyncedFlushResult>() {_                    @Override_                    public void onResponse(ShardsSyncedFlushResult syncedFlushResult) {_                        results.get(index).add(syncedFlushResult)__                        if (countDown.countDown()) {_                            listener.onResponse(new SyncedFlushResponse(results))__                        }_                    }__                    @Override_                    public void onFailure(Exception e) {_                        logger.debug("{} unexpected error while executing synced flush", shardId)__                        final int totalShards = indexMetaData.getNumberOfReplicas() + 1__                        results.get(index).add(new ShardsSyncedFlushResult(shardId, totalShards, e.getMessage()))__                        if (countDown.countDown()) {_                            listener.onResponse(new SyncedFlushResponse(results))__                        }_                    }_                })__            }_        }_    };a,utility,method,to,perform,a,synced,flush,for,all,shards,of,multiple,indices,see,link,attempt,synced,flush,shard,id,action,listener,for,more,details;public,void,attempt,synced,flush,final,string,aliases,or,indices,indices,options,indices,options,final,action,listener,synced,flush,response,listener,final,cluster,state,state,cluster,service,state,final,index,concrete,indices,index,name,expression,resolver,concrete,indices,state,indices,options,aliases,or,indices,final,map,string,list,shards,synced,flush,result,results,concurrent,collections,new,concurrent,map,int,number,of,shards,0,for,index,index,concrete,indices,final,index,meta,data,index,meta,data,state,meta,data,get,index,safe,index,number,of,shards,index,meta,data,get,number,of,shards,results,put,index,get,name,collections,synchronized,list,new,array,list,if,number,of,shards,0,listener,on,response,new,synced,flush,response,results,return,final,count,down,count,down,new,count,down,number,of,shards,for,final,index,concrete,index,concrete,indices,final,string,index,concrete,index,get,name,final,index,meta,data,index,meta,data,state,meta,data,get,index,safe,concrete,index,final,int,index,number,of,shards,index,meta,data,get,number,of,shards,for,int,shard,0,shard,index,number,of,shards,shard,final,shard,id,shard,id,new,shard,id,index,meta,data,get,index,shard,inner,attempt,synced,flush,shard,id,state,new,action,listener,shards,synced,flush,result,override,public,void,on,response,shards,synced,flush,result,synced,flush,result,results,get,index,add,synced,flush,result,if,count,down,count,down,listener,on,response,new,synced,flush,response,results,override,public,void,on,failure,exception,e,logger,debug,unexpected,error,while,executing,synced,flush,shard,id,final,int,total,shards,index,meta,data,get,number,of,replicas,1,results,get,index,add,new,shards,synced,flush,result,shard,id,total,shards,e,get,message,if,count,down,count,down,listener,on,response,new,synced,flush,response,results
SyncedFlushService -> public void attemptSyncedFlush(final String[] aliasesOrIndices, IndicesOptions indicesOptions, final ActionListener<SyncedFlushResponse> listener);1526289033;a utility method to perform a synced flush for all shards of multiple indices. see {@link #attemptSyncedFlush(ShardId, ActionListener)}_for more details.;public void attemptSyncedFlush(final String[] aliasesOrIndices, IndicesOptions indicesOptions, final ActionListener<SyncedFlushResponse> listener) {_        final ClusterState state = clusterService.state()__        final Index[] concreteIndices = indexNameExpressionResolver.concreteIndices(state, indicesOptions, aliasesOrIndices)__        final Map<String, List<ShardsSyncedFlushResult>> results = ConcurrentCollections.newConcurrentMap()__        int numberOfShards = 0__        for (Index index : concreteIndices) {_            final IndexMetaData indexMetaData = state.metaData().getIndexSafe(index)__            numberOfShards += indexMetaData.getNumberOfShards()__            results.put(index.getName(), Collections.synchronizedList(new ArrayList<>()))___        }_        if (numberOfShards == 0) {_            listener.onResponse(new SyncedFlushResponse(results))__            return__        }_        final CountDown countDown = new CountDown(numberOfShards)___        for (final Index concreteIndex : concreteIndices) {_            final String index = concreteIndex.getName()__            final IndexMetaData indexMetaData = state.metaData().getIndexSafe(concreteIndex)__            final int indexNumberOfShards = indexMetaData.getNumberOfShards()__            for (int shard = 0_ shard < indexNumberOfShards_ shard++) {_                final ShardId shardId = new ShardId(indexMetaData.getIndex(), shard)__                innerAttemptSyncedFlush(shardId, state, new ActionListener<ShardsSyncedFlushResult>() {_                    @Override_                    public void onResponse(ShardsSyncedFlushResult syncedFlushResult) {_                        results.get(index).add(syncedFlushResult)__                        if (countDown.countDown()) {_                            listener.onResponse(new SyncedFlushResponse(results))__                        }_                    }__                    @Override_                    public void onFailure(Exception e) {_                        logger.debug("{} unexpected error while executing synced flush", shardId)__                        final int totalShards = indexMetaData.getNumberOfReplicas() + 1__                        results.get(index).add(new ShardsSyncedFlushResult(shardId, totalShards, e.getMessage()))__                        if (countDown.countDown()) {_                            listener.onResponse(new SyncedFlushResponse(results))__                        }_                    }_                })__            }_        }_    };a,utility,method,to,perform,a,synced,flush,for,all,shards,of,multiple,indices,see,link,attempt,synced,flush,shard,id,action,listener,for,more,details;public,void,attempt,synced,flush,final,string,aliases,or,indices,indices,options,indices,options,final,action,listener,synced,flush,response,listener,final,cluster,state,state,cluster,service,state,final,index,concrete,indices,index,name,expression,resolver,concrete,indices,state,indices,options,aliases,or,indices,final,map,string,list,shards,synced,flush,result,results,concurrent,collections,new,concurrent,map,int,number,of,shards,0,for,index,index,concrete,indices,final,index,meta,data,index,meta,data,state,meta,data,get,index,safe,index,number,of,shards,index,meta,data,get,number,of,shards,results,put,index,get,name,collections,synchronized,list,new,array,list,if,number,of,shards,0,listener,on,response,new,synced,flush,response,results,return,final,count,down,count,down,new,count,down,number,of,shards,for,final,index,concrete,index,concrete,indices,final,string,index,concrete,index,get,name,final,index,meta,data,index,meta,data,state,meta,data,get,index,safe,concrete,index,final,int,index,number,of,shards,index,meta,data,get,number,of,shards,for,int,shard,0,shard,index,number,of,shards,shard,final,shard,id,shard,id,new,shard,id,index,meta,data,get,index,shard,inner,attempt,synced,flush,shard,id,state,new,action,listener,shards,synced,flush,result,override,public,void,on,response,shards,synced,flush,result,synced,flush,result,results,get,index,add,synced,flush,result,if,count,down,count,down,listener,on,response,new,synced,flush,response,results,override,public,void,on,failure,exception,e,logger,debug,unexpected,error,while,executing,synced,flush,shard,id,final,int,total,shards,index,meta,data,get,number,of,replicas,1,results,get,index,add,new,shards,synced,flush,result,shard,id,total,shards,e,get,message,if,count,down,count,down,listener,on,response,new,synced,flush,response,results
SyncedFlushService -> public void attemptSyncedFlush(final String[] aliasesOrIndices, IndicesOptions indicesOptions, final ActionListener<SyncedFlushResponse> listener);1528211342;a utility method to perform a synced flush for all shards of multiple indices. see {@link #attemptSyncedFlush(ShardId, ActionListener)}_for more details.;public void attemptSyncedFlush(final String[] aliasesOrIndices, IndicesOptions indicesOptions, final ActionListener<SyncedFlushResponse> listener) {_        final ClusterState state = clusterService.state()__        final Index[] concreteIndices = indexNameExpressionResolver.concreteIndices(state, indicesOptions, aliasesOrIndices)__        final Map<String, List<ShardsSyncedFlushResult>> results = ConcurrentCollections.newConcurrentMap()__        int numberOfShards = 0__        for (Index index : concreteIndices) {_            final IndexMetaData indexMetaData = state.metaData().getIndexSafe(index)__            numberOfShards += indexMetaData.getNumberOfShards()__            results.put(index.getName(), Collections.synchronizedList(new ArrayList<>()))___        }_        if (numberOfShards == 0) {_            listener.onResponse(new SyncedFlushResponse(results))__            return__        }_        final CountDown countDown = new CountDown(numberOfShards)___        for (final Index concreteIndex : concreteIndices) {_            final String index = concreteIndex.getName()__            final IndexMetaData indexMetaData = state.metaData().getIndexSafe(concreteIndex)__            final int indexNumberOfShards = indexMetaData.getNumberOfShards()__            for (int shard = 0_ shard < indexNumberOfShards_ shard++) {_                final ShardId shardId = new ShardId(indexMetaData.getIndex(), shard)__                innerAttemptSyncedFlush(shardId, state, new ActionListener<ShardsSyncedFlushResult>() {_                    @Override_                    public void onResponse(ShardsSyncedFlushResult syncedFlushResult) {_                        results.get(index).add(syncedFlushResult)__                        if (countDown.countDown()) {_                            listener.onResponse(new SyncedFlushResponse(results))__                        }_                    }__                    @Override_                    public void onFailure(Exception e) {_                        logger.debug("{} unexpected error while executing synced flush", shardId)__                        final int totalShards = indexMetaData.getNumberOfReplicas() + 1__                        results.get(index).add(new ShardsSyncedFlushResult(shardId, totalShards, e.getMessage()))__                        if (countDown.countDown()) {_                            listener.onResponse(new SyncedFlushResponse(results))__                        }_                    }_                })__            }_        }_    };a,utility,method,to,perform,a,synced,flush,for,all,shards,of,multiple,indices,see,link,attempt,synced,flush,shard,id,action,listener,for,more,details;public,void,attempt,synced,flush,final,string,aliases,or,indices,indices,options,indices,options,final,action,listener,synced,flush,response,listener,final,cluster,state,state,cluster,service,state,final,index,concrete,indices,index,name,expression,resolver,concrete,indices,state,indices,options,aliases,or,indices,final,map,string,list,shards,synced,flush,result,results,concurrent,collections,new,concurrent,map,int,number,of,shards,0,for,index,index,concrete,indices,final,index,meta,data,index,meta,data,state,meta,data,get,index,safe,index,number,of,shards,index,meta,data,get,number,of,shards,results,put,index,get,name,collections,synchronized,list,new,array,list,if,number,of,shards,0,listener,on,response,new,synced,flush,response,results,return,final,count,down,count,down,new,count,down,number,of,shards,for,final,index,concrete,index,concrete,indices,final,string,index,concrete,index,get,name,final,index,meta,data,index,meta,data,state,meta,data,get,index,safe,concrete,index,final,int,index,number,of,shards,index,meta,data,get,number,of,shards,for,int,shard,0,shard,index,number,of,shards,shard,final,shard,id,shard,id,new,shard,id,index,meta,data,get,index,shard,inner,attempt,synced,flush,shard,id,state,new,action,listener,shards,synced,flush,result,override,public,void,on,response,shards,synced,flush,result,synced,flush,result,results,get,index,add,synced,flush,result,if,count,down,count,down,listener,on,response,new,synced,flush,response,results,override,public,void,on,failure,exception,e,logger,debug,unexpected,error,while,executing,synced,flush,shard,id,final,int,total,shards,index,meta,data,get,number,of,replicas,1,results,get,index,add,new,shards,synced,flush,result,shard,id,total,shards,e,get,message,if,count,down,count,down,listener,on,response,new,synced,flush,response,results
SyncedFlushService -> public void attemptSyncedFlush(final String[] aliasesOrIndices, IndicesOptions indicesOptions, final ActionListener<SyncedFlushResponse> listener);1529687475;a utility method to perform a synced flush for all shards of multiple indices. see {@link #attemptSyncedFlush(ShardId, ActionListener)}_for more details.;public void attemptSyncedFlush(final String[] aliasesOrIndices, IndicesOptions indicesOptions, final ActionListener<SyncedFlushResponse> listener) {_        final ClusterState state = clusterService.state()__        final Index[] concreteIndices = indexNameExpressionResolver.concreteIndices(state, indicesOptions, aliasesOrIndices)__        final Map<String, List<ShardsSyncedFlushResult>> results = ConcurrentCollections.newConcurrentMap()__        int numberOfShards = 0__        for (Index index : concreteIndices) {_            final IndexMetaData indexMetaData = state.metaData().getIndexSafe(index)__            numberOfShards += indexMetaData.getNumberOfShards()__            results.put(index.getName(), Collections.synchronizedList(new ArrayList<>()))___        }_        if (numberOfShards == 0) {_            listener.onResponse(new SyncedFlushResponse(results))__            return__        }_        final CountDown countDown = new CountDown(numberOfShards)___        for (final Index concreteIndex : concreteIndices) {_            final String index = concreteIndex.getName()__            final IndexMetaData indexMetaData = state.metaData().getIndexSafe(concreteIndex)__            final int indexNumberOfShards = indexMetaData.getNumberOfShards()__            for (int shard = 0_ shard < indexNumberOfShards_ shard++) {_                final ShardId shardId = new ShardId(indexMetaData.getIndex(), shard)__                innerAttemptSyncedFlush(shardId, state, new ActionListener<ShardsSyncedFlushResult>() {_                    @Override_                    public void onResponse(ShardsSyncedFlushResult syncedFlushResult) {_                        results.get(index).add(syncedFlushResult)__                        if (countDown.countDown()) {_                            listener.onResponse(new SyncedFlushResponse(results))__                        }_                    }__                    @Override_                    public void onFailure(Exception e) {_                        logger.debug("{} unexpected error while executing synced flush", shardId)__                        final int totalShards = indexMetaData.getNumberOfReplicas() + 1__                        results.get(index).add(new ShardsSyncedFlushResult(shardId, totalShards, e.getMessage()))__                        if (countDown.countDown()) {_                            listener.onResponse(new SyncedFlushResponse(results))__                        }_                    }_                })__            }_        }_    };a,utility,method,to,perform,a,synced,flush,for,all,shards,of,multiple,indices,see,link,attempt,synced,flush,shard,id,action,listener,for,more,details;public,void,attempt,synced,flush,final,string,aliases,or,indices,indices,options,indices,options,final,action,listener,synced,flush,response,listener,final,cluster,state,state,cluster,service,state,final,index,concrete,indices,index,name,expression,resolver,concrete,indices,state,indices,options,aliases,or,indices,final,map,string,list,shards,synced,flush,result,results,concurrent,collections,new,concurrent,map,int,number,of,shards,0,for,index,index,concrete,indices,final,index,meta,data,index,meta,data,state,meta,data,get,index,safe,index,number,of,shards,index,meta,data,get,number,of,shards,results,put,index,get,name,collections,synchronized,list,new,array,list,if,number,of,shards,0,listener,on,response,new,synced,flush,response,results,return,final,count,down,count,down,new,count,down,number,of,shards,for,final,index,concrete,index,concrete,indices,final,string,index,concrete,index,get,name,final,index,meta,data,index,meta,data,state,meta,data,get,index,safe,concrete,index,final,int,index,number,of,shards,index,meta,data,get,number,of,shards,for,int,shard,0,shard,index,number,of,shards,shard,final,shard,id,shard,id,new,shard,id,index,meta,data,get,index,shard,inner,attempt,synced,flush,shard,id,state,new,action,listener,shards,synced,flush,result,override,public,void,on,response,shards,synced,flush,result,synced,flush,result,results,get,index,add,synced,flush,result,if,count,down,count,down,listener,on,response,new,synced,flush,response,results,override,public,void,on,failure,exception,e,logger,debug,unexpected,error,while,executing,synced,flush,shard,id,final,int,total,shards,index,meta,data,get,number,of,replicas,1,results,get,index,add,new,shards,synced,flush,result,shard,id,total,shards,e,get,message,if,count,down,count,down,listener,on,response,new,synced,flush,response,results
SyncedFlushService -> public void attemptSyncedFlush(final String[] aliasesOrIndices, IndicesOptions indicesOptions, final ActionListener<SyncedFlushResponse> listener);1535139672;a utility method to perform a synced flush for all shards of multiple indices. see {@link #attemptSyncedFlush(ShardId, ActionListener)}_for more details.;public void attemptSyncedFlush(final String[] aliasesOrIndices, IndicesOptions indicesOptions, final ActionListener<SyncedFlushResponse> listener) {_        final ClusterState state = clusterService.state()__        final Index[] concreteIndices = indexNameExpressionResolver.concreteIndices(state, indicesOptions, aliasesOrIndices)__        final Map<String, List<ShardsSyncedFlushResult>> results = ConcurrentCollections.newConcurrentMap()__        int numberOfShards = 0__        for (Index index : concreteIndices) {_            final IndexMetaData indexMetaData = state.metaData().getIndexSafe(index)__            numberOfShards += indexMetaData.getNumberOfShards()__            results.put(index.getName(), Collections.synchronizedList(new ArrayList<>()))___        }_        if (numberOfShards == 0) {_            listener.onResponse(new SyncedFlushResponse(results))__            return__        }_        final CountDown countDown = new CountDown(numberOfShards)___        for (final Index concreteIndex : concreteIndices) {_            final String index = concreteIndex.getName()__            final IndexMetaData indexMetaData = state.metaData().getIndexSafe(concreteIndex)__            final int indexNumberOfShards = indexMetaData.getNumberOfShards()__            for (int shard = 0_ shard < indexNumberOfShards_ shard++) {_                final ShardId shardId = new ShardId(indexMetaData.getIndex(), shard)__                innerAttemptSyncedFlush(shardId, state, new ActionListener<ShardsSyncedFlushResult>() {_                    @Override_                    public void onResponse(ShardsSyncedFlushResult syncedFlushResult) {_                        results.get(index).add(syncedFlushResult)__                        if (countDown.countDown()) {_                            listener.onResponse(new SyncedFlushResponse(results))__                        }_                    }__                    @Override_                    public void onFailure(Exception e) {_                        logger.debug("{} unexpected error while executing synced flush", shardId)__                        final int totalShards = indexMetaData.getNumberOfReplicas() + 1__                        results.get(index).add(new ShardsSyncedFlushResult(shardId, totalShards, e.getMessage()))__                        if (countDown.countDown()) {_                            listener.onResponse(new SyncedFlushResponse(results))__                        }_                    }_                })__            }_        }_    };a,utility,method,to,perform,a,synced,flush,for,all,shards,of,multiple,indices,see,link,attempt,synced,flush,shard,id,action,listener,for,more,details;public,void,attempt,synced,flush,final,string,aliases,or,indices,indices,options,indices,options,final,action,listener,synced,flush,response,listener,final,cluster,state,state,cluster,service,state,final,index,concrete,indices,index,name,expression,resolver,concrete,indices,state,indices,options,aliases,or,indices,final,map,string,list,shards,synced,flush,result,results,concurrent,collections,new,concurrent,map,int,number,of,shards,0,for,index,index,concrete,indices,final,index,meta,data,index,meta,data,state,meta,data,get,index,safe,index,number,of,shards,index,meta,data,get,number,of,shards,results,put,index,get,name,collections,synchronized,list,new,array,list,if,number,of,shards,0,listener,on,response,new,synced,flush,response,results,return,final,count,down,count,down,new,count,down,number,of,shards,for,final,index,concrete,index,concrete,indices,final,string,index,concrete,index,get,name,final,index,meta,data,index,meta,data,state,meta,data,get,index,safe,concrete,index,final,int,index,number,of,shards,index,meta,data,get,number,of,shards,for,int,shard,0,shard,index,number,of,shards,shard,final,shard,id,shard,id,new,shard,id,index,meta,data,get,index,shard,inner,attempt,synced,flush,shard,id,state,new,action,listener,shards,synced,flush,result,override,public,void,on,response,shards,synced,flush,result,synced,flush,result,results,get,index,add,synced,flush,result,if,count,down,count,down,listener,on,response,new,synced,flush,response,results,override,public,void,on,failure,exception,e,logger,debug,unexpected,error,while,executing,synced,flush,shard,id,final,int,total,shards,index,meta,data,get,number,of,replicas,1,results,get,index,add,new,shards,synced,flush,result,shard,id,total,shards,e,get,message,if,count,down,count,down,listener,on,response,new,synced,flush,response,results
SyncedFlushService -> public void attemptSyncedFlush(final String[] aliasesOrIndices, IndicesOptions indicesOptions, final ActionListener<SyncedFlushResponse> listener);1540583181;a utility method to perform a synced flush for all shards of multiple indices. see {@link #attemptSyncedFlush(ShardId, ActionListener)}_for more details.;public void attemptSyncedFlush(final String[] aliasesOrIndices, IndicesOptions indicesOptions, final ActionListener<SyncedFlushResponse> listener) {_        final ClusterState state = clusterService.state()__        final Index[] concreteIndices = indexNameExpressionResolver.concreteIndices(state, indicesOptions, aliasesOrIndices)__        final Map<String, List<ShardsSyncedFlushResult>> results = ConcurrentCollections.newConcurrentMap()__        int numberOfShards = 0__        for (Index index : concreteIndices) {_            final IndexMetaData indexMetaData = state.metaData().getIndexSafe(index)__            numberOfShards += indexMetaData.getNumberOfShards()__            results.put(index.getName(), Collections.synchronizedList(new ArrayList<>()))___        }_        if (numberOfShards == 0) {_            listener.onResponse(new SyncedFlushResponse(results))__            return__        }_        final CountDown countDown = new CountDown(numberOfShards)___        for (final Index concreteIndex : concreteIndices) {_            final String index = concreteIndex.getName()__            final IndexMetaData indexMetaData = state.metaData().getIndexSafe(concreteIndex)__            final int indexNumberOfShards = indexMetaData.getNumberOfShards()__            for (int shard = 0_ shard < indexNumberOfShards_ shard++) {_                final ShardId shardId = new ShardId(indexMetaData.getIndex(), shard)__                innerAttemptSyncedFlush(shardId, state, new ActionListener<ShardsSyncedFlushResult>() {_                    @Override_                    public void onResponse(ShardsSyncedFlushResult syncedFlushResult) {_                        results.get(index).add(syncedFlushResult)__                        if (countDown.countDown()) {_                            listener.onResponse(new SyncedFlushResponse(results))__                        }_                    }__                    @Override_                    public void onFailure(Exception e) {_                        logger.debug("{} unexpected error while executing synced flush", shardId)__                        final int totalShards = indexMetaData.getNumberOfReplicas() + 1__                        results.get(index).add(new ShardsSyncedFlushResult(shardId, totalShards, e.getMessage()))__                        if (countDown.countDown()) {_                            listener.onResponse(new SyncedFlushResponse(results))__                        }_                    }_                })__            }_        }_    };a,utility,method,to,perform,a,synced,flush,for,all,shards,of,multiple,indices,see,link,attempt,synced,flush,shard,id,action,listener,for,more,details;public,void,attempt,synced,flush,final,string,aliases,or,indices,indices,options,indices,options,final,action,listener,synced,flush,response,listener,final,cluster,state,state,cluster,service,state,final,index,concrete,indices,index,name,expression,resolver,concrete,indices,state,indices,options,aliases,or,indices,final,map,string,list,shards,synced,flush,result,results,concurrent,collections,new,concurrent,map,int,number,of,shards,0,for,index,index,concrete,indices,final,index,meta,data,index,meta,data,state,meta,data,get,index,safe,index,number,of,shards,index,meta,data,get,number,of,shards,results,put,index,get,name,collections,synchronized,list,new,array,list,if,number,of,shards,0,listener,on,response,new,synced,flush,response,results,return,final,count,down,count,down,new,count,down,number,of,shards,for,final,index,concrete,index,concrete,indices,final,string,index,concrete,index,get,name,final,index,meta,data,index,meta,data,state,meta,data,get,index,safe,concrete,index,final,int,index,number,of,shards,index,meta,data,get,number,of,shards,for,int,shard,0,shard,index,number,of,shards,shard,final,shard,id,shard,id,new,shard,id,index,meta,data,get,index,shard,inner,attempt,synced,flush,shard,id,state,new,action,listener,shards,synced,flush,result,override,public,void,on,response,shards,synced,flush,result,synced,flush,result,results,get,index,add,synced,flush,result,if,count,down,count,down,listener,on,response,new,synced,flush,response,results,override,public,void,on,failure,exception,e,logger,debug,unexpected,error,while,executing,synced,flush,shard,id,final,int,total,shards,index,meta,data,get,number,of,replicas,1,results,get,index,add,new,shards,synced,flush,result,shard,id,total,shards,e,get,message,if,count,down,count,down,listener,on,response,new,synced,flush,response,results
SyncedFlushService -> public void attemptSyncedFlush(final String[] aliasesOrIndices, IndicesOptions indicesOptions, final ActionListener<SyncedFlushResponse> listener);1541092382;a utility method to perform a synced flush for all shards of multiple indices. see {@link #attemptSyncedFlush(ShardId, ActionListener)}_for more details.;public void attemptSyncedFlush(final String[] aliasesOrIndices, IndicesOptions indicesOptions, final ActionListener<SyncedFlushResponse> listener) {_        final ClusterState state = clusterService.state()__        final Index[] concreteIndices = indexNameExpressionResolver.concreteIndices(state, indicesOptions, aliasesOrIndices)__        final Map<String, List<ShardsSyncedFlushResult>> results = ConcurrentCollections.newConcurrentMap()__        int numberOfShards = 0__        for (Index index : concreteIndices) {_            final IndexMetaData indexMetaData = state.metaData().getIndexSafe(index)__            numberOfShards += indexMetaData.getNumberOfShards()__            results.put(index.getName(), Collections.synchronizedList(new ArrayList<>()))___        }_        if (numberOfShards == 0) {_            listener.onResponse(new SyncedFlushResponse(results))__            return__        }_        final CountDown countDown = new CountDown(numberOfShards)___        for (final Index concreteIndex : concreteIndices) {_            final String index = concreteIndex.getName()__            final IndexMetaData indexMetaData = state.metaData().getIndexSafe(concreteIndex)__            final int indexNumberOfShards = indexMetaData.getNumberOfShards()__            for (int shard = 0_ shard < indexNumberOfShards_ shard++) {_                final ShardId shardId = new ShardId(indexMetaData.getIndex(), shard)__                innerAttemptSyncedFlush(shardId, state, new ActionListener<ShardsSyncedFlushResult>() {_                    @Override_                    public void onResponse(ShardsSyncedFlushResult syncedFlushResult) {_                        results.get(index).add(syncedFlushResult)__                        if (countDown.countDown()) {_                            listener.onResponse(new SyncedFlushResponse(results))__                        }_                    }__                    @Override_                    public void onFailure(Exception e) {_                        logger.debug("{} unexpected error while executing synced flush", shardId)__                        final int totalShards = indexMetaData.getNumberOfReplicas() + 1__                        results.get(index).add(new ShardsSyncedFlushResult(shardId, totalShards, e.getMessage()))__                        if (countDown.countDown()) {_                            listener.onResponse(new SyncedFlushResponse(results))__                        }_                    }_                })__            }_        }_    };a,utility,method,to,perform,a,synced,flush,for,all,shards,of,multiple,indices,see,link,attempt,synced,flush,shard,id,action,listener,for,more,details;public,void,attempt,synced,flush,final,string,aliases,or,indices,indices,options,indices,options,final,action,listener,synced,flush,response,listener,final,cluster,state,state,cluster,service,state,final,index,concrete,indices,index,name,expression,resolver,concrete,indices,state,indices,options,aliases,or,indices,final,map,string,list,shards,synced,flush,result,results,concurrent,collections,new,concurrent,map,int,number,of,shards,0,for,index,index,concrete,indices,final,index,meta,data,index,meta,data,state,meta,data,get,index,safe,index,number,of,shards,index,meta,data,get,number,of,shards,results,put,index,get,name,collections,synchronized,list,new,array,list,if,number,of,shards,0,listener,on,response,new,synced,flush,response,results,return,final,count,down,count,down,new,count,down,number,of,shards,for,final,index,concrete,index,concrete,indices,final,string,index,concrete,index,get,name,final,index,meta,data,index,meta,data,state,meta,data,get,index,safe,concrete,index,final,int,index,number,of,shards,index,meta,data,get,number,of,shards,for,int,shard,0,shard,index,number,of,shards,shard,final,shard,id,shard,id,new,shard,id,index,meta,data,get,index,shard,inner,attempt,synced,flush,shard,id,state,new,action,listener,shards,synced,flush,result,override,public,void,on,response,shards,synced,flush,result,synced,flush,result,results,get,index,add,synced,flush,result,if,count,down,count,down,listener,on,response,new,synced,flush,response,results,override,public,void,on,failure,exception,e,logger,debug,unexpected,error,while,executing,synced,flush,shard,id,final,int,total,shards,index,meta,data,get,number,of,replicas,1,results,get,index,add,new,shards,synced,flush,result,shard,id,total,shards,e,get,message,if,count,down,count,down,listener,on,response,new,synced,flush,response,results
SyncedFlushService -> public void attemptSyncedFlush(final String[] aliasesOrIndices, IndicesOptions indicesOptions, final ActionListener<SyncedFlushResponse> listener);1542402632;a utility method to perform a synced flush for all shards of multiple indices. see {@link #attemptSyncedFlush(ShardId, ActionListener)}_for more details.;public void attemptSyncedFlush(final String[] aliasesOrIndices, IndicesOptions indicesOptions, final ActionListener<SyncedFlushResponse> listener) {_        final ClusterState state = clusterService.state()__        final Index[] concreteIndices = indexNameExpressionResolver.concreteIndices(state, indicesOptions, aliasesOrIndices)__        final Map<String, List<ShardsSyncedFlushResult>> results = ConcurrentCollections.newConcurrentMap()__        int numberOfShards = 0__        for (Index index : concreteIndices) {_            final IndexMetaData indexMetaData = state.metaData().getIndexSafe(index)__            numberOfShards += indexMetaData.getNumberOfShards()__            results.put(index.getName(), Collections.synchronizedList(new ArrayList<>()))___        }_        if (numberOfShards == 0) {_            listener.onResponse(new SyncedFlushResponse(results))__            return__        }_        final CountDown countDown = new CountDown(numberOfShards)___        for (final Index concreteIndex : concreteIndices) {_            final String index = concreteIndex.getName()__            final IndexMetaData indexMetaData = state.metaData().getIndexSafe(concreteIndex)__            final int indexNumberOfShards = indexMetaData.getNumberOfShards()__            for (int shard = 0_ shard < indexNumberOfShards_ shard++) {_                final ShardId shardId = new ShardId(indexMetaData.getIndex(), shard)__                innerAttemptSyncedFlush(shardId, state, new ActionListener<ShardsSyncedFlushResult>() {_                    @Override_                    public void onResponse(ShardsSyncedFlushResult syncedFlushResult) {_                        results.get(index).add(syncedFlushResult)__                        if (countDown.countDown()) {_                            listener.onResponse(new SyncedFlushResponse(results))__                        }_                    }__                    @Override_                    public void onFailure(Exception e) {_                        logger.debug("{} unexpected error while executing synced flush", shardId)__                        final int totalShards = indexMetaData.getNumberOfReplicas() + 1__                        results.get(index).add(new ShardsSyncedFlushResult(shardId, totalShards, e.getMessage()))__                        if (countDown.countDown()) {_                            listener.onResponse(new SyncedFlushResponse(results))__                        }_                    }_                })__            }_        }_    };a,utility,method,to,perform,a,synced,flush,for,all,shards,of,multiple,indices,see,link,attempt,synced,flush,shard,id,action,listener,for,more,details;public,void,attempt,synced,flush,final,string,aliases,or,indices,indices,options,indices,options,final,action,listener,synced,flush,response,listener,final,cluster,state,state,cluster,service,state,final,index,concrete,indices,index,name,expression,resolver,concrete,indices,state,indices,options,aliases,or,indices,final,map,string,list,shards,synced,flush,result,results,concurrent,collections,new,concurrent,map,int,number,of,shards,0,for,index,index,concrete,indices,final,index,meta,data,index,meta,data,state,meta,data,get,index,safe,index,number,of,shards,index,meta,data,get,number,of,shards,results,put,index,get,name,collections,synchronized,list,new,array,list,if,number,of,shards,0,listener,on,response,new,synced,flush,response,results,return,final,count,down,count,down,new,count,down,number,of,shards,for,final,index,concrete,index,concrete,indices,final,string,index,concrete,index,get,name,final,index,meta,data,index,meta,data,state,meta,data,get,index,safe,concrete,index,final,int,index,number,of,shards,index,meta,data,get,number,of,shards,for,int,shard,0,shard,index,number,of,shards,shard,final,shard,id,shard,id,new,shard,id,index,meta,data,get,index,shard,inner,attempt,synced,flush,shard,id,state,new,action,listener,shards,synced,flush,result,override,public,void,on,response,shards,synced,flush,result,synced,flush,result,results,get,index,add,synced,flush,result,if,count,down,count,down,listener,on,response,new,synced,flush,response,results,override,public,void,on,failure,exception,e,logger,debug,unexpected,error,while,executing,synced,flush,shard,id,final,int,total,shards,index,meta,data,get,number,of,replicas,1,results,get,index,add,new,shards,synced,flush,result,shard,id,total,shards,e,get,message,if,count,down,count,down,listener,on,response,new,synced,flush,response,results
SyncedFlushService -> protected void getInflightOpsCount(final ShardId shardId,                                        ClusterState state,                                        IndexShardRoutingTable shardRoutingTable,                                        final ActionListener<InFlightOpsResponse> listener);1542609384;returns the number of in flight operations on primary. -1 upon error.;protected void getInflightOpsCount(final ShardId shardId,_                                       ClusterState state,_                                       IndexShardRoutingTable shardRoutingTable,_                                       final ActionListener<InFlightOpsResponse> listener) {_        try {_            final ShardRouting primaryShard = shardRoutingTable.primaryShard()__            final DiscoveryNode primaryNode = state.nodes().get(primaryShard.currentNodeId())__            if (primaryNode == null) {_                logger.trace("{} failed to resolve node for primary shard {}, skipping sync", shardId, primaryShard)__                listener.onResponse(new InFlightOpsResponse(-1))__                return__            }_            logger.trace("{} retrieving in flight operation count", shardId)__            transportService.sendRequest(primaryNode, IN_FLIGHT_OPS_ACTION_NAME, new InFlightOpsRequest(shardId),_                    new TransportResponseHandler<InFlightOpsResponse>() {_                        @Override_                        public InFlightOpsResponse read(StreamInput in) throws IOException {_                            InFlightOpsResponse response = new InFlightOpsResponse()__                            response.readFrom(in)__                            return response__                        }__                        @Override_                        public void handleResponse(InFlightOpsResponse response) {_                            listener.onResponse(response)__                        }__                        @Override_                        public void handleException(TransportException exp) {_                            logger.debug("{} unexpected error while retrieving in flight op count", shardId)__                            listener.onFailure(exp)__                        }__                        @Override_                        public String executor() {_                            return ThreadPool.Names.SAME__                        }_                    })__        } catch (Exception e) {_            listener.onFailure(e)__        }_    };returns,the,number,of,in,flight,operations,on,primary,1,upon,error;protected,void,get,inflight,ops,count,final,shard,id,shard,id,cluster,state,state,index,shard,routing,table,shard,routing,table,final,action,listener,in,flight,ops,response,listener,try,final,shard,routing,primary,shard,shard,routing,table,primary,shard,final,discovery,node,primary,node,state,nodes,get,primary,shard,current,node,id,if,primary,node,null,logger,trace,failed,to,resolve,node,for,primary,shard,skipping,sync,shard,id,primary,shard,listener,on,response,new,in,flight,ops,response,1,return,logger,trace,retrieving,in,flight,operation,count,shard,id,transport,service,send,request,primary,node,new,in,flight,ops,request,shard,id,new,transport,response,handler,in,flight,ops,response,override,public,in,flight,ops,response,read,stream,input,in,throws,ioexception,in,flight,ops,response,response,new,in,flight,ops,response,response,read,from,in,return,response,override,public,void,handle,response,in,flight,ops,response,response,listener,on,response,response,override,public,void,handle,exception,transport,exception,exp,logger,debug,unexpected,error,while,retrieving,in,flight,op,count,shard,id,listener,on,failure,exp,override,public,string,executor,return,thread,pool,names,same,catch,exception,e,listener,on,failure,e
SyncedFlushService -> protected void getInflightOpsCount(final ShardId shardId,                                        ClusterState state,                                        IndexShardRoutingTable shardRoutingTable,                                        final ActionListener<InFlightOpsResponse> listener);1547456074;returns the number of in flight operations on primary. -1 upon error.;protected void getInflightOpsCount(final ShardId shardId,_                                       ClusterState state,_                                       IndexShardRoutingTable shardRoutingTable,_                                       final ActionListener<InFlightOpsResponse> listener) {_        try {_            final ShardRouting primaryShard = shardRoutingTable.primaryShard()__            final DiscoveryNode primaryNode = state.nodes().get(primaryShard.currentNodeId())__            if (primaryNode == null) {_                logger.trace("{} failed to resolve node for primary shard {}, skipping sync", shardId, primaryShard)__                listener.onResponse(new InFlightOpsResponse(-1))__                return__            }_            logger.trace("{} retrieving in flight operation count", shardId)__            transportService.sendRequest(primaryNode, IN_FLIGHT_OPS_ACTION_NAME, new InFlightOpsRequest(shardId),_                    new TransportResponseHandler<InFlightOpsResponse>() {_                        @Override_                        public InFlightOpsResponse read(StreamInput in) throws IOException {_                            InFlightOpsResponse response = new InFlightOpsResponse()__                            response.readFrom(in)__                            return response__                        }__                        @Override_                        public void handleResponse(InFlightOpsResponse response) {_                            listener.onResponse(response)__                        }__                        @Override_                        public void handleException(TransportException exp) {_                            logger.debug("{} unexpected error while retrieving in flight op count", shardId)__                            listener.onFailure(exp)__                        }__                        @Override_                        public String executor() {_                            return ThreadPool.Names.SAME__                        }_                    })__        } catch (Exception e) {_            listener.onFailure(e)__        }_    };returns,the,number,of,in,flight,operations,on,primary,1,upon,error;protected,void,get,inflight,ops,count,final,shard,id,shard,id,cluster,state,state,index,shard,routing,table,shard,routing,table,final,action,listener,in,flight,ops,response,listener,try,final,shard,routing,primary,shard,shard,routing,table,primary,shard,final,discovery,node,primary,node,state,nodes,get,primary,shard,current,node,id,if,primary,node,null,logger,trace,failed,to,resolve,node,for,primary,shard,skipping,sync,shard,id,primary,shard,listener,on,response,new,in,flight,ops,response,1,return,logger,trace,retrieving,in,flight,operation,count,shard,id,transport,service,send,request,primary,node,new,in,flight,ops,request,shard,id,new,transport,response,handler,in,flight,ops,response,override,public,in,flight,ops,response,read,stream,input,in,throws,ioexception,in,flight,ops,response,response,new,in,flight,ops,response,response,read,from,in,return,response,override,public,void,handle,response,in,flight,ops,response,response,listener,on,response,response,override,public,void,handle,exception,transport,exception,exp,logger,debug,unexpected,error,while,retrieving,in,flight,op,count,shard,id,listener,on,failure,exp,override,public,string,executor,return,thread,pool,names,same,catch,exception,e,listener,on,failure,e
SyncedFlushService -> protected void getInflightOpsCount(final ShardId shardId,                                        ClusterState state,                                        IndexShardRoutingTable shardRoutingTable,                                        final ActionListener<InFlightOpsResponse> listener);1548238134;returns the number of in flight operations on primary. -1 upon error.;protected void getInflightOpsCount(final ShardId shardId,_                                       ClusterState state,_                                       IndexShardRoutingTable shardRoutingTable,_                                       final ActionListener<InFlightOpsResponse> listener) {_        try {_            final ShardRouting primaryShard = shardRoutingTable.primaryShard()__            final DiscoveryNode primaryNode = state.nodes().get(primaryShard.currentNodeId())__            if (primaryNode == null) {_                logger.trace("{} failed to resolve node for primary shard {}, skipping sync", shardId, primaryShard)__                listener.onResponse(new InFlightOpsResponse(-1))__                return__            }_            logger.trace("{} retrieving in flight operation count", shardId)__            transportService.sendRequest(primaryNode, IN_FLIGHT_OPS_ACTION_NAME, new InFlightOpsRequest(shardId),_                    new TransportResponseHandler<InFlightOpsResponse>() {_                        @Override_                        public InFlightOpsResponse read(StreamInput in) throws IOException {_                            InFlightOpsResponse response = new InFlightOpsResponse()__                            response.readFrom(in)__                            return response__                        }__                        @Override_                        public void handleResponse(InFlightOpsResponse response) {_                            listener.onResponse(response)__                        }__                        @Override_                        public void handleException(TransportException exp) {_                            logger.debug("{} unexpected error while retrieving in flight op count", shardId)__                            listener.onFailure(exp)__                        }__                        @Override_                        public String executor() {_                            return ThreadPool.Names.SAME__                        }_                    })__        } catch (Exception e) {_            listener.onFailure(e)__        }_    };returns,the,number,of,in,flight,operations,on,primary,1,upon,error;protected,void,get,inflight,ops,count,final,shard,id,shard,id,cluster,state,state,index,shard,routing,table,shard,routing,table,final,action,listener,in,flight,ops,response,listener,try,final,shard,routing,primary,shard,shard,routing,table,primary,shard,final,discovery,node,primary,node,state,nodes,get,primary,shard,current,node,id,if,primary,node,null,logger,trace,failed,to,resolve,node,for,primary,shard,skipping,sync,shard,id,primary,shard,listener,on,response,new,in,flight,ops,response,1,return,logger,trace,retrieving,in,flight,operation,count,shard,id,transport,service,send,request,primary,node,new,in,flight,ops,request,shard,id,new,transport,response,handler,in,flight,ops,response,override,public,in,flight,ops,response,read,stream,input,in,throws,ioexception,in,flight,ops,response,response,new,in,flight,ops,response,response,read,from,in,return,response,override,public,void,handle,response,in,flight,ops,response,response,listener,on,response,response,override,public,void,handle,exception,transport,exception,exp,logger,debug,unexpected,error,while,retrieving,in,flight,op,count,shard,id,listener,on,failure,exp,override,public,string,executor,return,thread,pool,names,same,catch,exception,e,listener,on,failure,e
SyncedFlushService -> protected void getInflightOpsCount(final ShardId shardId, ClusterState state, IndexShardRoutingTable shardRoutingTable, final ActionListener<InFlightOpsResponse> listener);1524684173;returns the number of in flight operations on primary. -1 upon error.;protected void getInflightOpsCount(final ShardId shardId, ClusterState state, IndexShardRoutingTable shardRoutingTable, final ActionListener<InFlightOpsResponse> listener) {_        try {_            final ShardRouting primaryShard = shardRoutingTable.primaryShard()__            final DiscoveryNode primaryNode = state.nodes().get(primaryShard.currentNodeId())__            if (primaryNode == null) {_                logger.trace("{} failed to resolve node for primary shard {}, skipping sync", shardId, primaryShard)__                listener.onResponse(new InFlightOpsResponse(-1))__                return__            }_            logger.trace("{} retrieving in flight operation count", shardId)__            transportService.sendRequest(primaryNode, IN_FLIGHT_OPS_ACTION_NAME, new InFlightOpsRequest(shardId),_                    new TransportResponseHandler<InFlightOpsResponse>() {_                        @Override_                        public InFlightOpsResponse newInstance() {_                            return new InFlightOpsResponse()__                        }__                        @Override_                        public void handleResponse(InFlightOpsResponse response) {_                            listener.onResponse(response)__                        }__                        @Override_                        public void handleException(TransportException exp) {_                            logger.debug("{} unexpected error while retrieving in flight op count", shardId)__                            listener.onFailure(exp)__                        }__                        @Override_                        public String executor() {_                            return ThreadPool.Names.SAME__                        }_                    })__        } catch (Exception e) {_            listener.onFailure(e)__        }_    };returns,the,number,of,in,flight,operations,on,primary,1,upon,error;protected,void,get,inflight,ops,count,final,shard,id,shard,id,cluster,state,state,index,shard,routing,table,shard,routing,table,final,action,listener,in,flight,ops,response,listener,try,final,shard,routing,primary,shard,shard,routing,table,primary,shard,final,discovery,node,primary,node,state,nodes,get,primary,shard,current,node,id,if,primary,node,null,logger,trace,failed,to,resolve,node,for,primary,shard,skipping,sync,shard,id,primary,shard,listener,on,response,new,in,flight,ops,response,1,return,logger,trace,retrieving,in,flight,operation,count,shard,id,transport,service,send,request,primary,node,new,in,flight,ops,request,shard,id,new,transport,response,handler,in,flight,ops,response,override,public,in,flight,ops,response,new,instance,return,new,in,flight,ops,response,override,public,void,handle,response,in,flight,ops,response,response,listener,on,response,response,override,public,void,handle,exception,transport,exception,exp,logger,debug,unexpected,error,while,retrieving,in,flight,op,count,shard,id,listener,on,failure,exp,override,public,string,executor,return,thread,pool,names,same,catch,exception,e,listener,on,failure,e
SyncedFlushService -> protected void getInflightOpsCount(final ShardId shardId, ClusterState state, IndexShardRoutingTable shardRoutingTable, final ActionListener<InFlightOpsResponse> listener);1526289033;returns the number of in flight operations on primary. -1 upon error.;protected void getInflightOpsCount(final ShardId shardId, ClusterState state, IndexShardRoutingTable shardRoutingTable, final ActionListener<InFlightOpsResponse> listener) {_        try {_            final ShardRouting primaryShard = shardRoutingTable.primaryShard()__            final DiscoveryNode primaryNode = state.nodes().get(primaryShard.currentNodeId())__            if (primaryNode == null) {_                logger.trace("{} failed to resolve node for primary shard {}, skipping sync", shardId, primaryShard)__                listener.onResponse(new InFlightOpsResponse(-1))__                return__            }_            logger.trace("{} retrieving in flight operation count", shardId)__            transportService.sendRequest(primaryNode, IN_FLIGHT_OPS_ACTION_NAME, new InFlightOpsRequest(shardId),_                    new TransportResponseHandler<InFlightOpsResponse>() {_                        @Override_                        public InFlightOpsResponse newInstance() {_                            return new InFlightOpsResponse()__                        }__                        @Override_                        public void handleResponse(InFlightOpsResponse response) {_                            listener.onResponse(response)__                        }__                        @Override_                        public void handleException(TransportException exp) {_                            logger.debug("{} unexpected error while retrieving in flight op count", shardId)__                            listener.onFailure(exp)__                        }__                        @Override_                        public String executor() {_                            return ThreadPool.Names.SAME__                        }_                    })__        } catch (Exception e) {_            listener.onFailure(e)__        }_    };returns,the,number,of,in,flight,operations,on,primary,1,upon,error;protected,void,get,inflight,ops,count,final,shard,id,shard,id,cluster,state,state,index,shard,routing,table,shard,routing,table,final,action,listener,in,flight,ops,response,listener,try,final,shard,routing,primary,shard,shard,routing,table,primary,shard,final,discovery,node,primary,node,state,nodes,get,primary,shard,current,node,id,if,primary,node,null,logger,trace,failed,to,resolve,node,for,primary,shard,skipping,sync,shard,id,primary,shard,listener,on,response,new,in,flight,ops,response,1,return,logger,trace,retrieving,in,flight,operation,count,shard,id,transport,service,send,request,primary,node,new,in,flight,ops,request,shard,id,new,transport,response,handler,in,flight,ops,response,override,public,in,flight,ops,response,new,instance,return,new,in,flight,ops,response,override,public,void,handle,response,in,flight,ops,response,response,listener,on,response,response,override,public,void,handle,exception,transport,exception,exp,logger,debug,unexpected,error,while,retrieving,in,flight,op,count,shard,id,listener,on,failure,exp,override,public,string,executor,return,thread,pool,names,same,catch,exception,e,listener,on,failure,e
SyncedFlushService -> protected void getInflightOpsCount(final ShardId shardId, ClusterState state, IndexShardRoutingTable shardRoutingTable, final ActionListener<InFlightOpsResponse> listener);1528211342;returns the number of in flight operations on primary. -1 upon error.;protected void getInflightOpsCount(final ShardId shardId, ClusterState state, IndexShardRoutingTable shardRoutingTable, final ActionListener<InFlightOpsResponse> listener) {_        try {_            final ShardRouting primaryShard = shardRoutingTable.primaryShard()__            final DiscoveryNode primaryNode = state.nodes().get(primaryShard.currentNodeId())__            if (primaryNode == null) {_                logger.trace("{} failed to resolve node for primary shard {}, skipping sync", shardId, primaryShard)__                listener.onResponse(new InFlightOpsResponse(-1))__                return__            }_            logger.trace("{} retrieving in flight operation count", shardId)__            transportService.sendRequest(primaryNode, IN_FLIGHT_OPS_ACTION_NAME, new InFlightOpsRequest(shardId),_                    new TransportResponseHandler<InFlightOpsResponse>() {_                        @Override_                        public InFlightOpsResponse newInstance() {_                            return new InFlightOpsResponse()__                        }__                        @Override_                        public void handleResponse(InFlightOpsResponse response) {_                            listener.onResponse(response)__                        }__                        @Override_                        public void handleException(TransportException exp) {_                            logger.debug("{} unexpected error while retrieving in flight op count", shardId)__                            listener.onFailure(exp)__                        }__                        @Override_                        public String executor() {_                            return ThreadPool.Names.SAME__                        }_                    })__        } catch (Exception e) {_            listener.onFailure(e)__        }_    };returns,the,number,of,in,flight,operations,on,primary,1,upon,error;protected,void,get,inflight,ops,count,final,shard,id,shard,id,cluster,state,state,index,shard,routing,table,shard,routing,table,final,action,listener,in,flight,ops,response,listener,try,final,shard,routing,primary,shard,shard,routing,table,primary,shard,final,discovery,node,primary,node,state,nodes,get,primary,shard,current,node,id,if,primary,node,null,logger,trace,failed,to,resolve,node,for,primary,shard,skipping,sync,shard,id,primary,shard,listener,on,response,new,in,flight,ops,response,1,return,logger,trace,retrieving,in,flight,operation,count,shard,id,transport,service,send,request,primary,node,new,in,flight,ops,request,shard,id,new,transport,response,handler,in,flight,ops,response,override,public,in,flight,ops,response,new,instance,return,new,in,flight,ops,response,override,public,void,handle,response,in,flight,ops,response,response,listener,on,response,response,override,public,void,handle,exception,transport,exception,exp,logger,debug,unexpected,error,while,retrieving,in,flight,op,count,shard,id,listener,on,failure,exp,override,public,string,executor,return,thread,pool,names,same,catch,exception,e,listener,on,failure,e
SyncedFlushService -> protected void getInflightOpsCount(final ShardId shardId, ClusterState state, IndexShardRoutingTable shardRoutingTable, final ActionListener<InFlightOpsResponse> listener);1529687475;returns the number of in flight operations on primary. -1 upon error.;protected void getInflightOpsCount(final ShardId shardId, ClusterState state, IndexShardRoutingTable shardRoutingTable, final ActionListener<InFlightOpsResponse> listener) {_        try {_            final ShardRouting primaryShard = shardRoutingTable.primaryShard()__            final DiscoveryNode primaryNode = state.nodes().get(primaryShard.currentNodeId())__            if (primaryNode == null) {_                logger.trace("{} failed to resolve node for primary shard {}, skipping sync", shardId, primaryShard)__                listener.onResponse(new InFlightOpsResponse(-1))__                return__            }_            logger.trace("{} retrieving in flight operation count", shardId)__            transportService.sendRequest(primaryNode, IN_FLIGHT_OPS_ACTION_NAME, new InFlightOpsRequest(shardId),_                    new TransportResponseHandler<InFlightOpsResponse>() {_                        @Override_                        public InFlightOpsResponse newInstance() {_                            return new InFlightOpsResponse()__                        }__                        @Override_                        public void handleResponse(InFlightOpsResponse response) {_                            listener.onResponse(response)__                        }__                        @Override_                        public void handleException(TransportException exp) {_                            logger.debug("{} unexpected error while retrieving in flight op count", shardId)__                            listener.onFailure(exp)__                        }__                        @Override_                        public String executor() {_                            return ThreadPool.Names.SAME__                        }_                    })__        } catch (Exception e) {_            listener.onFailure(e)__        }_    };returns,the,number,of,in,flight,operations,on,primary,1,upon,error;protected,void,get,inflight,ops,count,final,shard,id,shard,id,cluster,state,state,index,shard,routing,table,shard,routing,table,final,action,listener,in,flight,ops,response,listener,try,final,shard,routing,primary,shard,shard,routing,table,primary,shard,final,discovery,node,primary,node,state,nodes,get,primary,shard,current,node,id,if,primary,node,null,logger,trace,failed,to,resolve,node,for,primary,shard,skipping,sync,shard,id,primary,shard,listener,on,response,new,in,flight,ops,response,1,return,logger,trace,retrieving,in,flight,operation,count,shard,id,transport,service,send,request,primary,node,new,in,flight,ops,request,shard,id,new,transport,response,handler,in,flight,ops,response,override,public,in,flight,ops,response,new,instance,return,new,in,flight,ops,response,override,public,void,handle,response,in,flight,ops,response,response,listener,on,response,response,override,public,void,handle,exception,transport,exception,exp,logger,debug,unexpected,error,while,retrieving,in,flight,op,count,shard,id,listener,on,failure,exp,override,public,string,executor,return,thread,pool,names,same,catch,exception,e,listener,on,failure,e
SyncedFlushService -> protected void getInflightOpsCount(final ShardId shardId, ClusterState state, IndexShardRoutingTable shardRoutingTable, final ActionListener<InFlightOpsResponse> listener);1535139672;returns the number of in flight operations on primary. -1 upon error.;protected void getInflightOpsCount(final ShardId shardId, ClusterState state, IndexShardRoutingTable shardRoutingTable, final ActionListener<InFlightOpsResponse> listener) {_        try {_            final ShardRouting primaryShard = shardRoutingTable.primaryShard()__            final DiscoveryNode primaryNode = state.nodes().get(primaryShard.currentNodeId())__            if (primaryNode == null) {_                logger.trace("{} failed to resolve node for primary shard {}, skipping sync", shardId, primaryShard)__                listener.onResponse(new InFlightOpsResponse(-1))__                return__            }_            logger.trace("{} retrieving in flight operation count", shardId)__            transportService.sendRequest(primaryNode, IN_FLIGHT_OPS_ACTION_NAME, new InFlightOpsRequest(shardId),_                    new TransportResponseHandler<InFlightOpsResponse>() {_                        @Override_                        public InFlightOpsResponse newInstance() {_                            return new InFlightOpsResponse()__                        }__                        @Override_                        public void handleResponse(InFlightOpsResponse response) {_                            listener.onResponse(response)__                        }__                        @Override_                        public void handleException(TransportException exp) {_                            logger.debug("{} unexpected error while retrieving in flight op count", shardId)__                            listener.onFailure(exp)__                        }__                        @Override_                        public String executor() {_                            return ThreadPool.Names.SAME__                        }_                    })__        } catch (Exception e) {_            listener.onFailure(e)__        }_    };returns,the,number,of,in,flight,operations,on,primary,1,upon,error;protected,void,get,inflight,ops,count,final,shard,id,shard,id,cluster,state,state,index,shard,routing,table,shard,routing,table,final,action,listener,in,flight,ops,response,listener,try,final,shard,routing,primary,shard,shard,routing,table,primary,shard,final,discovery,node,primary,node,state,nodes,get,primary,shard,current,node,id,if,primary,node,null,logger,trace,failed,to,resolve,node,for,primary,shard,skipping,sync,shard,id,primary,shard,listener,on,response,new,in,flight,ops,response,1,return,logger,trace,retrieving,in,flight,operation,count,shard,id,transport,service,send,request,primary,node,new,in,flight,ops,request,shard,id,new,transport,response,handler,in,flight,ops,response,override,public,in,flight,ops,response,new,instance,return,new,in,flight,ops,response,override,public,void,handle,response,in,flight,ops,response,response,listener,on,response,response,override,public,void,handle,exception,transport,exception,exp,logger,debug,unexpected,error,while,retrieving,in,flight,op,count,shard,id,listener,on,failure,exp,override,public,string,executor,return,thread,pool,names,same,catch,exception,e,listener,on,failure,e
SyncedFlushService -> protected void getInflightOpsCount(final ShardId shardId, ClusterState state, IndexShardRoutingTable shardRoutingTable, final ActionListener<InFlightOpsResponse> listener);1540583181;returns the number of in flight operations on primary. -1 upon error.;protected void getInflightOpsCount(final ShardId shardId, ClusterState state, IndexShardRoutingTable shardRoutingTable, final ActionListener<InFlightOpsResponse> listener) {_        try {_            final ShardRouting primaryShard = shardRoutingTable.primaryShard()__            final DiscoveryNode primaryNode = state.nodes().get(primaryShard.currentNodeId())__            if (primaryNode == null) {_                logger.trace("{} failed to resolve node for primary shard {}, skipping sync", shardId, primaryShard)__                listener.onResponse(new InFlightOpsResponse(-1))__                return__            }_            logger.trace("{} retrieving in flight operation count", shardId)__            transportService.sendRequest(primaryNode, IN_FLIGHT_OPS_ACTION_NAME, new InFlightOpsRequest(shardId),_                    new TransportResponseHandler<InFlightOpsResponse>() {_                        @Override_                        public InFlightOpsResponse read(StreamInput in) throws IOException {_                            InFlightOpsResponse response = new InFlightOpsResponse()__                            response.readFrom(in)__                            return response__                        }__                        @Override_                        public void handleResponse(InFlightOpsResponse response) {_                            listener.onResponse(response)__                        }__                        @Override_                        public void handleException(TransportException exp) {_                            logger.debug("{} unexpected error while retrieving in flight op count", shardId)__                            listener.onFailure(exp)__                        }__                        @Override_                        public String executor() {_                            return ThreadPool.Names.SAME__                        }_                    })__        } catch (Exception e) {_            listener.onFailure(e)__        }_    };returns,the,number,of,in,flight,operations,on,primary,1,upon,error;protected,void,get,inflight,ops,count,final,shard,id,shard,id,cluster,state,state,index,shard,routing,table,shard,routing,table,final,action,listener,in,flight,ops,response,listener,try,final,shard,routing,primary,shard,shard,routing,table,primary,shard,final,discovery,node,primary,node,state,nodes,get,primary,shard,current,node,id,if,primary,node,null,logger,trace,failed,to,resolve,node,for,primary,shard,skipping,sync,shard,id,primary,shard,listener,on,response,new,in,flight,ops,response,1,return,logger,trace,retrieving,in,flight,operation,count,shard,id,transport,service,send,request,primary,node,new,in,flight,ops,request,shard,id,new,transport,response,handler,in,flight,ops,response,override,public,in,flight,ops,response,read,stream,input,in,throws,ioexception,in,flight,ops,response,response,new,in,flight,ops,response,response,read,from,in,return,response,override,public,void,handle,response,in,flight,ops,response,response,listener,on,response,response,override,public,void,handle,exception,transport,exception,exp,logger,debug,unexpected,error,while,retrieving,in,flight,op,count,shard,id,listener,on,failure,exp,override,public,string,executor,return,thread,pool,names,same,catch,exception,e,listener,on,failure,e
SyncedFlushService -> protected void getInflightOpsCount(final ShardId shardId, ClusterState state, IndexShardRoutingTable shardRoutingTable, final ActionListener<InFlightOpsResponse> listener);1541092382;returns the number of in flight operations on primary. -1 upon error.;protected void getInflightOpsCount(final ShardId shardId, ClusterState state, IndexShardRoutingTable shardRoutingTable, final ActionListener<InFlightOpsResponse> listener) {_        try {_            final ShardRouting primaryShard = shardRoutingTable.primaryShard()__            final DiscoveryNode primaryNode = state.nodes().get(primaryShard.currentNodeId())__            if (primaryNode == null) {_                logger.trace("{} failed to resolve node for primary shard {}, skipping sync", shardId, primaryShard)__                listener.onResponse(new InFlightOpsResponse(-1))__                return__            }_            logger.trace("{} retrieving in flight operation count", shardId)__            transportService.sendRequest(primaryNode, IN_FLIGHT_OPS_ACTION_NAME, new InFlightOpsRequest(shardId),_                    new TransportResponseHandler<InFlightOpsResponse>() {_                        @Override_                        public InFlightOpsResponse read(StreamInput in) throws IOException {_                            InFlightOpsResponse response = new InFlightOpsResponse()__                            response.readFrom(in)__                            return response__                        }__                        @Override_                        public void handleResponse(InFlightOpsResponse response) {_                            listener.onResponse(response)__                        }__                        @Override_                        public void handleException(TransportException exp) {_                            logger.debug("{} unexpected error while retrieving in flight op count", shardId)__                            listener.onFailure(exp)__                        }__                        @Override_                        public String executor() {_                            return ThreadPool.Names.SAME__                        }_                    })__        } catch (Exception e) {_            listener.onFailure(e)__        }_    };returns,the,number,of,in,flight,operations,on,primary,1,upon,error;protected,void,get,inflight,ops,count,final,shard,id,shard,id,cluster,state,state,index,shard,routing,table,shard,routing,table,final,action,listener,in,flight,ops,response,listener,try,final,shard,routing,primary,shard,shard,routing,table,primary,shard,final,discovery,node,primary,node,state,nodes,get,primary,shard,current,node,id,if,primary,node,null,logger,trace,failed,to,resolve,node,for,primary,shard,skipping,sync,shard,id,primary,shard,listener,on,response,new,in,flight,ops,response,1,return,logger,trace,retrieving,in,flight,operation,count,shard,id,transport,service,send,request,primary,node,new,in,flight,ops,request,shard,id,new,transport,response,handler,in,flight,ops,response,override,public,in,flight,ops,response,read,stream,input,in,throws,ioexception,in,flight,ops,response,response,new,in,flight,ops,response,response,read,from,in,return,response,override,public,void,handle,response,in,flight,ops,response,response,listener,on,response,response,override,public,void,handle,exception,transport,exception,exp,logger,debug,unexpected,error,while,retrieving,in,flight,op,count,shard,id,listener,on,failure,exp,override,public,string,executor,return,thread,pool,names,same,catch,exception,e,listener,on,failure,e
SyncedFlushService -> protected void getInflightOpsCount(final ShardId shardId, ClusterState state, IndexShardRoutingTable shardRoutingTable, final ActionListener<InFlightOpsResponse> listener);1542402632;returns the number of in flight operations on primary. -1 upon error.;protected void getInflightOpsCount(final ShardId shardId, ClusterState state, IndexShardRoutingTable shardRoutingTable, final ActionListener<InFlightOpsResponse> listener) {_        try {_            final ShardRouting primaryShard = shardRoutingTable.primaryShard()__            final DiscoveryNode primaryNode = state.nodes().get(primaryShard.currentNodeId())__            if (primaryNode == null) {_                logger.trace("{} failed to resolve node for primary shard {}, skipping sync", shardId, primaryShard)__                listener.onResponse(new InFlightOpsResponse(-1))__                return__            }_            logger.trace("{} retrieving in flight operation count", shardId)__            transportService.sendRequest(primaryNode, IN_FLIGHT_OPS_ACTION_NAME, new InFlightOpsRequest(shardId),_                    new TransportResponseHandler<InFlightOpsResponse>() {_                        @Override_                        public InFlightOpsResponse read(StreamInput in) throws IOException {_                            InFlightOpsResponse response = new InFlightOpsResponse()__                            response.readFrom(in)__                            return response__                        }__                        @Override_                        public void handleResponse(InFlightOpsResponse response) {_                            listener.onResponse(response)__                        }__                        @Override_                        public void handleException(TransportException exp) {_                            logger.debug("{} unexpected error while retrieving in flight op count", shardId)__                            listener.onFailure(exp)__                        }__                        @Override_                        public String executor() {_                            return ThreadPool.Names.SAME__                        }_                    })__        } catch (Exception e) {_            listener.onFailure(e)__        }_    };returns,the,number,of,in,flight,operations,on,primary,1,upon,error;protected,void,get,inflight,ops,count,final,shard,id,shard,id,cluster,state,state,index,shard,routing,table,shard,routing,table,final,action,listener,in,flight,ops,response,listener,try,final,shard,routing,primary,shard,shard,routing,table,primary,shard,final,discovery,node,primary,node,state,nodes,get,primary,shard,current,node,id,if,primary,node,null,logger,trace,failed,to,resolve,node,for,primary,shard,skipping,sync,shard,id,primary,shard,listener,on,response,new,in,flight,ops,response,1,return,logger,trace,retrieving,in,flight,operation,count,shard,id,transport,service,send,request,primary,node,new,in,flight,ops,request,shard,id,new,transport,response,handler,in,flight,ops,response,override,public,in,flight,ops,response,read,stream,input,in,throws,ioexception,in,flight,ops,response,response,new,in,flight,ops,response,response,read,from,in,return,response,override,public,void,handle,response,in,flight,ops,response,response,listener,on,response,response,override,public,void,handle,exception,transport,exception,exp,logger,debug,unexpected,error,while,retrieving,in,flight,op,count,shard,id,listener,on,failure,exp,override,public,string,executor,return,thread,pool,names,same,catch,exception,e,listener,on,failure,e
SyncedFlushService -> void sendPreSyncRequests(final List<ShardRouting> shards, final ClusterState state, final ShardId shardId, final ActionListener<Map<String, PreSyncedFlushResponse>> listener);1524684173;send presync requests to all started copies of the given shard;void sendPreSyncRequests(final List<ShardRouting> shards, final ClusterState state, final ShardId shardId, final ActionListener<Map<String, PreSyncedFlushResponse>> listener) {_        final CountDown countDown = new CountDown(shards.size())__        final ConcurrentMap<String, PreSyncedFlushResponse> presyncResponses = ConcurrentCollections.newConcurrentMap()__        for (final ShardRouting shard : shards) {_            logger.trace("{} sending pre-synced flush request to {}", shardId, shard)__            final DiscoveryNode node = state.nodes().get(shard.currentNodeId())__            if (node == null) {_                logger.trace("{} shard routing {} refers to an unknown node. skipping.", shardId, shard)__                if (countDown.countDown()) {_                    listener.onResponse(presyncResponses)__                }_                continue__            }_            transportService.sendRequest(node, PRE_SYNCED_FLUSH_ACTION_NAME, new PreShardSyncedFlushRequest(shard.shardId()), new TransportResponseHandler<PreSyncedFlushResponse>() {_                @Override_                public PreSyncedFlushResponse newInstance() {_                    return new PreSyncedFlushResponse()__                }__                @Override_                public void handleResponse(PreSyncedFlushResponse response) {_                    PreSyncedFlushResponse existing = presyncResponses.putIfAbsent(node.getId(), response)__                    assert existing == null : "got two answers for node [" + node + "]"__                    _                    if (countDown.countDown()) {_                        listener.onResponse(presyncResponses)__                    }_                }__                @Override_                public void handleException(TransportException exp) {_                    logger.trace(() -> new ParameterizedMessage("{} error while performing pre synced flush on [{}], skipping", shardId, shard), exp)__                    if (countDown.countDown()) {_                        listener.onResponse(presyncResponses)__                    }_                }__                @Override_                public String executor() {_                    return ThreadPool.Names.SAME__                }_            })__        }_    };send,presync,requests,to,all,started,copies,of,the,given,shard;void,send,pre,sync,requests,final,list,shard,routing,shards,final,cluster,state,state,final,shard,id,shard,id,final,action,listener,map,string,pre,synced,flush,response,listener,final,count,down,count,down,new,count,down,shards,size,final,concurrent,map,string,pre,synced,flush,response,presync,responses,concurrent,collections,new,concurrent,map,for,final,shard,routing,shard,shards,logger,trace,sending,pre,synced,flush,request,to,shard,id,shard,final,discovery,node,node,state,nodes,get,shard,current,node,id,if,node,null,logger,trace,shard,routing,refers,to,an,unknown,node,skipping,shard,id,shard,if,count,down,count,down,listener,on,response,presync,responses,continue,transport,service,send,request,node,new,pre,shard,synced,flush,request,shard,shard,id,new,transport,response,handler,pre,synced,flush,response,override,public,pre,synced,flush,response,new,instance,return,new,pre,synced,flush,response,override,public,void,handle,response,pre,synced,flush,response,response,pre,synced,flush,response,existing,presync,responses,put,if,absent,node,get,id,response,assert,existing,null,got,two,answers,for,node,node,if,count,down,count,down,listener,on,response,presync,responses,override,public,void,handle,exception,transport,exception,exp,logger,trace,new,parameterized,message,error,while,performing,pre,synced,flush,on,skipping,shard,id,shard,exp,if,count,down,count,down,listener,on,response,presync,responses,override,public,string,executor,return,thread,pool,names,same
SyncedFlushService -> void sendPreSyncRequests(final List<ShardRouting> shards, final ClusterState state, final ShardId shardId, final ActionListener<Map<String, PreSyncedFlushResponse>> listener);1526289033;send presync requests to all started copies of the given shard;void sendPreSyncRequests(final List<ShardRouting> shards, final ClusterState state, final ShardId shardId, final ActionListener<Map<String, PreSyncedFlushResponse>> listener) {_        final CountDown countDown = new CountDown(shards.size())__        final ConcurrentMap<String, PreSyncedFlushResponse> presyncResponses = ConcurrentCollections.newConcurrentMap()__        for (final ShardRouting shard : shards) {_            logger.trace("{} sending pre-synced flush request to {}", shardId, shard)__            final DiscoveryNode node = state.nodes().get(shard.currentNodeId())__            if (node == null) {_                logger.trace("{} shard routing {} refers to an unknown node. skipping.", shardId, shard)__                if (countDown.countDown()) {_                    listener.onResponse(presyncResponses)__                }_                continue__            }_            transportService.sendRequest(node, PRE_SYNCED_FLUSH_ACTION_NAME, new PreShardSyncedFlushRequest(shard.shardId()), new TransportResponseHandler<PreSyncedFlushResponse>() {_                @Override_                public PreSyncedFlushResponse newInstance() {_                    return new PreSyncedFlushResponse()__                }__                @Override_                public void handleResponse(PreSyncedFlushResponse response) {_                    PreSyncedFlushResponse existing = presyncResponses.putIfAbsent(node.getId(), response)__                    assert existing == null : "got two answers for node [" + node + "]"__                    _                    if (countDown.countDown()) {_                        listener.onResponse(presyncResponses)__                    }_                }__                @Override_                public void handleException(TransportException exp) {_                    logger.trace(() -> new ParameterizedMessage("{} error while performing pre synced flush on [{}], skipping", shardId, shard), exp)__                    if (countDown.countDown()) {_                        listener.onResponse(presyncResponses)__                    }_                }__                @Override_                public String executor() {_                    return ThreadPool.Names.SAME__                }_            })__        }_    };send,presync,requests,to,all,started,copies,of,the,given,shard;void,send,pre,sync,requests,final,list,shard,routing,shards,final,cluster,state,state,final,shard,id,shard,id,final,action,listener,map,string,pre,synced,flush,response,listener,final,count,down,count,down,new,count,down,shards,size,final,concurrent,map,string,pre,synced,flush,response,presync,responses,concurrent,collections,new,concurrent,map,for,final,shard,routing,shard,shards,logger,trace,sending,pre,synced,flush,request,to,shard,id,shard,final,discovery,node,node,state,nodes,get,shard,current,node,id,if,node,null,logger,trace,shard,routing,refers,to,an,unknown,node,skipping,shard,id,shard,if,count,down,count,down,listener,on,response,presync,responses,continue,transport,service,send,request,node,new,pre,shard,synced,flush,request,shard,shard,id,new,transport,response,handler,pre,synced,flush,response,override,public,pre,synced,flush,response,new,instance,return,new,pre,synced,flush,response,override,public,void,handle,response,pre,synced,flush,response,response,pre,synced,flush,response,existing,presync,responses,put,if,absent,node,get,id,response,assert,existing,null,got,two,answers,for,node,node,if,count,down,count,down,listener,on,response,presync,responses,override,public,void,handle,exception,transport,exception,exp,logger,trace,new,parameterized,message,error,while,performing,pre,synced,flush,on,skipping,shard,id,shard,exp,if,count,down,count,down,listener,on,response,presync,responses,override,public,string,executor,return,thread,pool,names,same
SyncedFlushService -> void sendPreSyncRequests(final List<ShardRouting> shards, final ClusterState state, final ShardId shardId, final ActionListener<Map<String, PreSyncedFlushResponse>> listener);1528211342;send presync requests to all started copies of the given shard;void sendPreSyncRequests(final List<ShardRouting> shards, final ClusterState state, final ShardId shardId, final ActionListener<Map<String, PreSyncedFlushResponse>> listener) {_        final CountDown countDown = new CountDown(shards.size())__        final ConcurrentMap<String, PreSyncedFlushResponse> presyncResponses = ConcurrentCollections.newConcurrentMap()__        for (final ShardRouting shard : shards) {_            logger.trace("{} sending pre-synced flush request to {}", shardId, shard)__            final DiscoveryNode node = state.nodes().get(shard.currentNodeId())__            if (node == null) {_                logger.trace("{} shard routing {} refers to an unknown node. skipping.", shardId, shard)__                if (countDown.countDown()) {_                    listener.onResponse(presyncResponses)__                }_                continue__            }_            transportService.sendRequest(node, PRE_SYNCED_FLUSH_ACTION_NAME, new PreShardSyncedFlushRequest(shard.shardId()), new TransportResponseHandler<PreSyncedFlushResponse>() {_                @Override_                public PreSyncedFlushResponse newInstance() {_                    return new PreSyncedFlushResponse()__                }__                @Override_                public void handleResponse(PreSyncedFlushResponse response) {_                    PreSyncedFlushResponse existing = presyncResponses.putIfAbsent(node.getId(), response)__                    assert existing == null : "got two answers for node [" + node + "]"__                    _                    if (countDown.countDown()) {_                        listener.onResponse(presyncResponses)__                    }_                }__                @Override_                public void handleException(TransportException exp) {_                    logger.trace(() -> new ParameterizedMessage("{} error while performing pre synced flush on [{}], skipping", shardId, shard), exp)__                    if (countDown.countDown()) {_                        listener.onResponse(presyncResponses)__                    }_                }__                @Override_                public String executor() {_                    return ThreadPool.Names.SAME__                }_            })__        }_    };send,presync,requests,to,all,started,copies,of,the,given,shard;void,send,pre,sync,requests,final,list,shard,routing,shards,final,cluster,state,state,final,shard,id,shard,id,final,action,listener,map,string,pre,synced,flush,response,listener,final,count,down,count,down,new,count,down,shards,size,final,concurrent,map,string,pre,synced,flush,response,presync,responses,concurrent,collections,new,concurrent,map,for,final,shard,routing,shard,shards,logger,trace,sending,pre,synced,flush,request,to,shard,id,shard,final,discovery,node,node,state,nodes,get,shard,current,node,id,if,node,null,logger,trace,shard,routing,refers,to,an,unknown,node,skipping,shard,id,shard,if,count,down,count,down,listener,on,response,presync,responses,continue,transport,service,send,request,node,new,pre,shard,synced,flush,request,shard,shard,id,new,transport,response,handler,pre,synced,flush,response,override,public,pre,synced,flush,response,new,instance,return,new,pre,synced,flush,response,override,public,void,handle,response,pre,synced,flush,response,response,pre,synced,flush,response,existing,presync,responses,put,if,absent,node,get,id,response,assert,existing,null,got,two,answers,for,node,node,if,count,down,count,down,listener,on,response,presync,responses,override,public,void,handle,exception,transport,exception,exp,logger,trace,new,parameterized,message,error,while,performing,pre,synced,flush,on,skipping,shard,id,shard,exp,if,count,down,count,down,listener,on,response,presync,responses,override,public,string,executor,return,thread,pool,names,same
SyncedFlushService -> void sendPreSyncRequests(final List<ShardRouting> shards, final ClusterState state, final ShardId shardId, final ActionListener<Map<String, PreSyncedFlushResponse>> listener);1529687475;send presync requests to all started copies of the given shard;void sendPreSyncRequests(final List<ShardRouting> shards, final ClusterState state, final ShardId shardId, final ActionListener<Map<String, PreSyncedFlushResponse>> listener) {_        final CountDown countDown = new CountDown(shards.size())__        final ConcurrentMap<String, PreSyncedFlushResponse> presyncResponses = ConcurrentCollections.newConcurrentMap()__        for (final ShardRouting shard : shards) {_            logger.trace("{} sending pre-synced flush request to {}", shardId, shard)__            final DiscoveryNode node = state.nodes().get(shard.currentNodeId())__            if (node == null) {_                logger.trace("{} shard routing {} refers to an unknown node. skipping.", shardId, shard)__                if (countDown.countDown()) {_                    listener.onResponse(presyncResponses)__                }_                continue__            }_            transportService.sendRequest(node, PRE_SYNCED_FLUSH_ACTION_NAME, new PreShardSyncedFlushRequest(shard.shardId()), new TransportResponseHandler<PreSyncedFlushResponse>() {_                @Override_                public PreSyncedFlushResponse newInstance() {_                    return new PreSyncedFlushResponse()__                }__                @Override_                public void handleResponse(PreSyncedFlushResponse response) {_                    PreSyncedFlushResponse existing = presyncResponses.putIfAbsent(node.getId(), response)__                    assert existing == null : "got two answers for node [" + node + "]"__                    _                    if (countDown.countDown()) {_                        listener.onResponse(presyncResponses)__                    }_                }__                @Override_                public void handleException(TransportException exp) {_                    logger.trace(() -> new ParameterizedMessage("{} error while performing pre synced flush on [{}], skipping", shardId, shard), exp)__                    if (countDown.countDown()) {_                        listener.onResponse(presyncResponses)__                    }_                }__                @Override_                public String executor() {_                    return ThreadPool.Names.SAME__                }_            })__        }_    };send,presync,requests,to,all,started,copies,of,the,given,shard;void,send,pre,sync,requests,final,list,shard,routing,shards,final,cluster,state,state,final,shard,id,shard,id,final,action,listener,map,string,pre,synced,flush,response,listener,final,count,down,count,down,new,count,down,shards,size,final,concurrent,map,string,pre,synced,flush,response,presync,responses,concurrent,collections,new,concurrent,map,for,final,shard,routing,shard,shards,logger,trace,sending,pre,synced,flush,request,to,shard,id,shard,final,discovery,node,node,state,nodes,get,shard,current,node,id,if,node,null,logger,trace,shard,routing,refers,to,an,unknown,node,skipping,shard,id,shard,if,count,down,count,down,listener,on,response,presync,responses,continue,transport,service,send,request,node,new,pre,shard,synced,flush,request,shard,shard,id,new,transport,response,handler,pre,synced,flush,response,override,public,pre,synced,flush,response,new,instance,return,new,pre,synced,flush,response,override,public,void,handle,response,pre,synced,flush,response,response,pre,synced,flush,response,existing,presync,responses,put,if,absent,node,get,id,response,assert,existing,null,got,two,answers,for,node,node,if,count,down,count,down,listener,on,response,presync,responses,override,public,void,handle,exception,transport,exception,exp,logger,trace,new,parameterized,message,error,while,performing,pre,synced,flush,on,skipping,shard,id,shard,exp,if,count,down,count,down,listener,on,response,presync,responses,override,public,string,executor,return,thread,pool,names,same
SyncedFlushService -> void sendPreSyncRequests(final List<ShardRouting> shards, final ClusterState state, final ShardId shardId, final ActionListener<Map<String, PreSyncedFlushResponse>> listener);1535139672;send presync requests to all started copies of the given shard;void sendPreSyncRequests(final List<ShardRouting> shards, final ClusterState state, final ShardId shardId, final ActionListener<Map<String, PreSyncedFlushResponse>> listener) {_        final CountDown countDown = new CountDown(shards.size())__        final ConcurrentMap<String, PreSyncedFlushResponse> presyncResponses = ConcurrentCollections.newConcurrentMap()__        for (final ShardRouting shard : shards) {_            logger.trace("{} sending pre-synced flush request to {}", shardId, shard)__            final DiscoveryNode node = state.nodes().get(shard.currentNodeId())__            if (node == null) {_                logger.trace("{} shard routing {} refers to an unknown node. skipping.", shardId, shard)__                if (countDown.countDown()) {_                    listener.onResponse(presyncResponses)__                }_                continue__            }_            transportService.sendRequest(node, PRE_SYNCED_FLUSH_ACTION_NAME, new PreShardSyncedFlushRequest(shard.shardId()), new TransportResponseHandler<PreSyncedFlushResponse>() {_                @Override_                public PreSyncedFlushResponse newInstance() {_                    return new PreSyncedFlushResponse()__                }__                @Override_                public void handleResponse(PreSyncedFlushResponse response) {_                    PreSyncedFlushResponse existing = presyncResponses.putIfAbsent(node.getId(), response)__                    assert existing == null : "got two answers for node [" + node + "]"__                    _                    if (countDown.countDown()) {_                        listener.onResponse(presyncResponses)__                    }_                }__                @Override_                public void handleException(TransportException exp) {_                    logger.trace(() -> new ParameterizedMessage("{} error while performing pre synced flush on [{}], skipping", shardId, shard), exp)__                    if (countDown.countDown()) {_                        listener.onResponse(presyncResponses)__                    }_                }__                @Override_                public String executor() {_                    return ThreadPool.Names.SAME__                }_            })__        }_    };send,presync,requests,to,all,started,copies,of,the,given,shard;void,send,pre,sync,requests,final,list,shard,routing,shards,final,cluster,state,state,final,shard,id,shard,id,final,action,listener,map,string,pre,synced,flush,response,listener,final,count,down,count,down,new,count,down,shards,size,final,concurrent,map,string,pre,synced,flush,response,presync,responses,concurrent,collections,new,concurrent,map,for,final,shard,routing,shard,shards,logger,trace,sending,pre,synced,flush,request,to,shard,id,shard,final,discovery,node,node,state,nodes,get,shard,current,node,id,if,node,null,logger,trace,shard,routing,refers,to,an,unknown,node,skipping,shard,id,shard,if,count,down,count,down,listener,on,response,presync,responses,continue,transport,service,send,request,node,new,pre,shard,synced,flush,request,shard,shard,id,new,transport,response,handler,pre,synced,flush,response,override,public,pre,synced,flush,response,new,instance,return,new,pre,synced,flush,response,override,public,void,handle,response,pre,synced,flush,response,response,pre,synced,flush,response,existing,presync,responses,put,if,absent,node,get,id,response,assert,existing,null,got,two,answers,for,node,node,if,count,down,count,down,listener,on,response,presync,responses,override,public,void,handle,exception,transport,exception,exp,logger,trace,new,parameterized,message,error,while,performing,pre,synced,flush,on,skipping,shard,id,shard,exp,if,count,down,count,down,listener,on,response,presync,responses,override,public,string,executor,return,thread,pool,names,same
SyncedFlushService -> void sendPreSyncRequests(final List<ShardRouting> shards, final ClusterState state, final ShardId shardId, final ActionListener<Map<String, PreSyncedFlushResponse>> listener);1540583181;send presync requests to all started copies of the given shard;void sendPreSyncRequests(final List<ShardRouting> shards, final ClusterState state, final ShardId shardId, final ActionListener<Map<String, PreSyncedFlushResponse>> listener) {_        final CountDown countDown = new CountDown(shards.size())__        final ConcurrentMap<String, PreSyncedFlushResponse> presyncResponses = ConcurrentCollections.newConcurrentMap()__        for (final ShardRouting shard : shards) {_            logger.trace("{} sending pre-synced flush request to {}", shardId, shard)__            final DiscoveryNode node = state.nodes().get(shard.currentNodeId())__            if (node == null) {_                logger.trace("{} shard routing {} refers to an unknown node. skipping.", shardId, shard)__                if (countDown.countDown()) {_                    listener.onResponse(presyncResponses)__                }_                continue__            }_            transportService.sendRequest(node, PRE_SYNCED_FLUSH_ACTION_NAME, new PreShardSyncedFlushRequest(shard.shardId()), new TransportResponseHandler<PreSyncedFlushResponse>() {_                @Override_                public PreSyncedFlushResponse read(StreamInput in) throws IOException {_                    PreSyncedFlushResponse response = new PreSyncedFlushResponse()__                    response.readFrom(in)__                    return response__                }__                @Override_                public void handleResponse(PreSyncedFlushResponse response) {_                    PreSyncedFlushResponse existing = presyncResponses.putIfAbsent(node.getId(), response)__                    assert existing == null : "got two answers for node [" + node + "]"__                    _                    if (countDown.countDown()) {_                        listener.onResponse(presyncResponses)__                    }_                }__                @Override_                public void handleException(TransportException exp) {_                    logger.trace(() -> new ParameterizedMessage("{} error while performing pre synced flush on [{}], skipping", shardId, shard), exp)__                    if (countDown.countDown()) {_                        listener.onResponse(presyncResponses)__                    }_                }__                @Override_                public String executor() {_                    return ThreadPool.Names.SAME__                }_            })__        }_    };send,presync,requests,to,all,started,copies,of,the,given,shard;void,send,pre,sync,requests,final,list,shard,routing,shards,final,cluster,state,state,final,shard,id,shard,id,final,action,listener,map,string,pre,synced,flush,response,listener,final,count,down,count,down,new,count,down,shards,size,final,concurrent,map,string,pre,synced,flush,response,presync,responses,concurrent,collections,new,concurrent,map,for,final,shard,routing,shard,shards,logger,trace,sending,pre,synced,flush,request,to,shard,id,shard,final,discovery,node,node,state,nodes,get,shard,current,node,id,if,node,null,logger,trace,shard,routing,refers,to,an,unknown,node,skipping,shard,id,shard,if,count,down,count,down,listener,on,response,presync,responses,continue,transport,service,send,request,node,new,pre,shard,synced,flush,request,shard,shard,id,new,transport,response,handler,pre,synced,flush,response,override,public,pre,synced,flush,response,read,stream,input,in,throws,ioexception,pre,synced,flush,response,response,new,pre,synced,flush,response,response,read,from,in,return,response,override,public,void,handle,response,pre,synced,flush,response,response,pre,synced,flush,response,existing,presync,responses,put,if,absent,node,get,id,response,assert,existing,null,got,two,answers,for,node,node,if,count,down,count,down,listener,on,response,presync,responses,override,public,void,handle,exception,transport,exception,exp,logger,trace,new,parameterized,message,error,while,performing,pre,synced,flush,on,skipping,shard,id,shard,exp,if,count,down,count,down,listener,on,response,presync,responses,override,public,string,executor,return,thread,pool,names,same
SyncedFlushService -> void sendPreSyncRequests(final List<ShardRouting> shards, final ClusterState state, final ShardId shardId, final ActionListener<Map<String, PreSyncedFlushResponse>> listener);1541092382;send presync requests to all started copies of the given shard;void sendPreSyncRequests(final List<ShardRouting> shards, final ClusterState state, final ShardId shardId, final ActionListener<Map<String, PreSyncedFlushResponse>> listener) {_        final CountDown countDown = new CountDown(shards.size())__        final ConcurrentMap<String, PreSyncedFlushResponse> presyncResponses = ConcurrentCollections.newConcurrentMap()__        for (final ShardRouting shard : shards) {_            logger.trace("{} sending pre-synced flush request to {}", shardId, shard)__            final DiscoveryNode node = state.nodes().get(shard.currentNodeId())__            if (node == null) {_                logger.trace("{} shard routing {} refers to an unknown node. skipping.", shardId, shard)__                if (countDown.countDown()) {_                    listener.onResponse(presyncResponses)__                }_                continue__            }_            transportService.sendRequest(node, PRE_SYNCED_FLUSH_ACTION_NAME, new PreShardSyncedFlushRequest(shard.shardId()), new TransportResponseHandler<PreSyncedFlushResponse>() {_                @Override_                public PreSyncedFlushResponse read(StreamInput in) throws IOException {_                    PreSyncedFlushResponse response = new PreSyncedFlushResponse()__                    response.readFrom(in)__                    return response__                }__                @Override_                public void handleResponse(PreSyncedFlushResponse response) {_                    PreSyncedFlushResponse existing = presyncResponses.putIfAbsent(node.getId(), response)__                    assert existing == null : "got two answers for node [" + node + "]"__                    _                    if (countDown.countDown()) {_                        listener.onResponse(presyncResponses)__                    }_                }__                @Override_                public void handleException(TransportException exp) {_                    logger.trace(() -> new ParameterizedMessage("{} error while performing pre synced flush on [{}], skipping", shardId, shard), exp)__                    if (countDown.countDown()) {_                        listener.onResponse(presyncResponses)__                    }_                }__                @Override_                public String executor() {_                    return ThreadPool.Names.SAME__                }_            })__        }_    };send,presync,requests,to,all,started,copies,of,the,given,shard;void,send,pre,sync,requests,final,list,shard,routing,shards,final,cluster,state,state,final,shard,id,shard,id,final,action,listener,map,string,pre,synced,flush,response,listener,final,count,down,count,down,new,count,down,shards,size,final,concurrent,map,string,pre,synced,flush,response,presync,responses,concurrent,collections,new,concurrent,map,for,final,shard,routing,shard,shards,logger,trace,sending,pre,synced,flush,request,to,shard,id,shard,final,discovery,node,node,state,nodes,get,shard,current,node,id,if,node,null,logger,trace,shard,routing,refers,to,an,unknown,node,skipping,shard,id,shard,if,count,down,count,down,listener,on,response,presync,responses,continue,transport,service,send,request,node,new,pre,shard,synced,flush,request,shard,shard,id,new,transport,response,handler,pre,synced,flush,response,override,public,pre,synced,flush,response,read,stream,input,in,throws,ioexception,pre,synced,flush,response,response,new,pre,synced,flush,response,response,read,from,in,return,response,override,public,void,handle,response,pre,synced,flush,response,response,pre,synced,flush,response,existing,presync,responses,put,if,absent,node,get,id,response,assert,existing,null,got,two,answers,for,node,node,if,count,down,count,down,listener,on,response,presync,responses,override,public,void,handle,exception,transport,exception,exp,logger,trace,new,parameterized,message,error,while,performing,pre,synced,flush,on,skipping,shard,id,shard,exp,if,count,down,count,down,listener,on,response,presync,responses,override,public,string,executor,return,thread,pool,names,same
SyncedFlushService -> void sendPreSyncRequests(final List<ShardRouting> shards, final ClusterState state, final ShardId shardId, final ActionListener<Map<String, PreSyncedFlushResponse>> listener);1542402632;send presync requests to all started copies of the given shard;void sendPreSyncRequests(final List<ShardRouting> shards, final ClusterState state, final ShardId shardId, final ActionListener<Map<String, PreSyncedFlushResponse>> listener) {_        final CountDown countDown = new CountDown(shards.size())__        final ConcurrentMap<String, PreSyncedFlushResponse> presyncResponses = ConcurrentCollections.newConcurrentMap()__        for (final ShardRouting shard : shards) {_            logger.trace("{} sending pre-synced flush request to {}", shardId, shard)__            final DiscoveryNode node = state.nodes().get(shard.currentNodeId())__            if (node == null) {_                logger.trace("{} shard routing {} refers to an unknown node. skipping.", shardId, shard)__                if (countDown.countDown()) {_                    listener.onResponse(presyncResponses)__                }_                continue__            }_            transportService.sendRequest(node, PRE_SYNCED_FLUSH_ACTION_NAME, new PreShardSyncedFlushRequest(shard.shardId()), new TransportResponseHandler<PreSyncedFlushResponse>() {_                @Override_                public PreSyncedFlushResponse read(StreamInput in) throws IOException {_                    PreSyncedFlushResponse response = new PreSyncedFlushResponse()__                    response.readFrom(in)__                    return response__                }__                @Override_                public void handleResponse(PreSyncedFlushResponse response) {_                    PreSyncedFlushResponse existing = presyncResponses.putIfAbsent(node.getId(), response)__                    assert existing == null : "got two answers for node [" + node + "]"__                    _                    if (countDown.countDown()) {_                        listener.onResponse(presyncResponses)__                    }_                }__                @Override_                public void handleException(TransportException exp) {_                    logger.trace(() -> new ParameterizedMessage("{} error while performing pre synced flush on [{}], skipping", shardId, shard), exp)__                    if (countDown.countDown()) {_                        listener.onResponse(presyncResponses)__                    }_                }__                @Override_                public String executor() {_                    return ThreadPool.Names.SAME__                }_            })__        }_    };send,presync,requests,to,all,started,copies,of,the,given,shard;void,send,pre,sync,requests,final,list,shard,routing,shards,final,cluster,state,state,final,shard,id,shard,id,final,action,listener,map,string,pre,synced,flush,response,listener,final,count,down,count,down,new,count,down,shards,size,final,concurrent,map,string,pre,synced,flush,response,presync,responses,concurrent,collections,new,concurrent,map,for,final,shard,routing,shard,shards,logger,trace,sending,pre,synced,flush,request,to,shard,id,shard,final,discovery,node,node,state,nodes,get,shard,current,node,id,if,node,null,logger,trace,shard,routing,refers,to,an,unknown,node,skipping,shard,id,shard,if,count,down,count,down,listener,on,response,presync,responses,continue,transport,service,send,request,node,new,pre,shard,synced,flush,request,shard,shard,id,new,transport,response,handler,pre,synced,flush,response,override,public,pre,synced,flush,response,read,stream,input,in,throws,ioexception,pre,synced,flush,response,response,new,pre,synced,flush,response,response,read,from,in,return,response,override,public,void,handle,response,pre,synced,flush,response,response,pre,synced,flush,response,existing,presync,responses,put,if,absent,node,get,id,response,assert,existing,null,got,two,answers,for,node,node,if,count,down,count,down,listener,on,response,presync,responses,override,public,void,handle,exception,transport,exception,exp,logger,trace,new,parameterized,message,error,while,performing,pre,synced,flush,on,skipping,shard,id,shard,exp,if,count,down,count,down,listener,on,response,presync,responses,override,public,string,executor,return,thread,pool,names,same
