commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;3;;protected Logger getLogger() {     return LOGGER. }
true;public;2;20;/**  * Background sync the specified retention leases for the specified shard.  *  * @param shardId         the shard to sync  * @param retentionLeases the retention leases to sync  */ ;/**  * Background sync the specified retention leases for the specified shard.  *  * @param shardId         the shard to sync  * @param retentionLeases the retention leases to sync  */ public void backgroundSync(final ShardId shardId, final RetentionLeases retentionLeases) {     Objects.requireNonNull(shardId).     Objects.requireNonNull(retentionLeases).     final ThreadContext threadContext = threadPool.getThreadContext().     try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {         // we have to execute under the system context so that if security is enabled the sync is authorized         threadContext.markAsSystemContext().         execute(new Request(shardId, retentionLeases), ActionListener.wrap(r -> {         }, e -> {             if (ExceptionsHelper.unwrap(e, AlreadyClosedException.class, IndexShardClosedException.class) == null) {                 getLogger().warn(new ParameterizedMessage("{} retention lease background sync failed", shardId), e).             }         })).     } }
false;protected;2;10;;@Override protected PrimaryResult<Request, ReplicationResponse> shardOperationOnPrimary(final Request request, final IndexShard primary) throws WriteStateException {     assert request.waitForActiveShards().equals(ActiveShardCount.NONE) : request.waitForActiveShards().     Objects.requireNonNull(request).     Objects.requireNonNull(primary).     primary.persistRetentionLeases().     return new PrimaryResult<>(request, new ReplicationResponse()). }
false;protected;2;8;;@Override protected ReplicaResult shardOperationOnReplica(final Request request, final IndexShard replica) throws WriteStateException {     Objects.requireNonNull(request).     Objects.requireNonNull(replica).     replica.updateRetentionLeasesOnReplica(request.getRetentionLeases()).     replica.persistRetentionLeases().     return new ReplicaResult(). }
false;public;0;3;;public RetentionLeases getRetentionLeases() {     return retentionLeases. }
false;public;1;5;;@Override public void readFrom(final StreamInput in) throws IOException {     super.readFrom(in).     retentionLeases = new RetentionLeases(in). }
false;public;1;5;;@Override public void writeTo(final StreamOutput out) throws IOException {     super.writeTo(Objects.requireNonNull(out)).     retentionLeases.writeTo(out). }
false;public;0;10;;@Override public String toString() {     return "Request{" + "retentionLeases=" + retentionLeases + ", shardId=" + shardId + ", timeout=" + timeout + ", index='" + index + '\'' + ", waitForActiveShards=" + waitForActiveShards + '}'. }
false;protected;0;4;;@Override protected ReplicationResponse newResponseInstance() {     return new ReplicationResponse(). }
