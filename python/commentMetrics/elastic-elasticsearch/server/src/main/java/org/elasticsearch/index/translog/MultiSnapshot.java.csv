# id;timestamp;commentText;codeText;commentWords;codeWords
MultiSnapshot -> MultiSnapshot(TranslogSnapshot[] translogs, Closeable onClose);1524684173;Creates a new point in time snapshot of the given snapshots. Those snapshots are always iterated in-order.;MultiSnapshot(TranslogSnapshot[] translogs, Closeable onClose) {_        this.translogs = translogs__        this.totalOperations = Arrays.stream(translogs).mapToInt(TranslogSnapshot::totalOperations).sum()__        this.overriddenOperations = 0__        this.onClose = onClose__        this.seenSeqNo = new SeqNoSet()__        this.index = translogs.length - 1__    };creates,a,new,point,in,time,snapshot,of,the,given,snapshots,those,snapshots,are,always,iterated,in,order;multi,snapshot,translog,snapshot,translogs,closeable,on,close,this,translogs,translogs,this,total,operations,arrays,stream,translogs,map,to,int,translog,snapshot,total,operations,sum,this,overridden,operations,0,this,on,close,on,close,this,seen,seq,no,new,seq,no,set,this,index,translogs,length,1
MultiSnapshot -> MultiSnapshot(TranslogSnapshot[] translogs, Closeable onClose);1525334055;Creates a new point in time snapshot of the given snapshots. Those snapshots are always iterated in-order.;MultiSnapshot(TranslogSnapshot[] translogs, Closeable onClose) {_        this.translogs = translogs__        this.totalOperations = Arrays.stream(translogs).mapToInt(TranslogSnapshot::totalOperations).sum()__        this.overriddenOperations = 0__        this.onClose = onClose__        this.seenSeqNo = new SeqNoSet()__        this.index = translogs.length - 1__    };creates,a,new,point,in,time,snapshot,of,the,given,snapshots,those,snapshots,are,always,iterated,in,order;multi,snapshot,translog,snapshot,translogs,closeable,on,close,this,translogs,translogs,this,total,operations,arrays,stream,translogs,map,to,int,translog,snapshot,total,operations,sum,this,overridden,operations,0,this,on,close,on,close,this,seen,seq,no,new,seq,no,set,this,index,translogs,length,1
MultiSnapshot -> MultiSnapshot(TranslogSnapshot[] translogs, Closeable onClose);1528706846;Creates a new point in time snapshot of the given snapshots. Those snapshots are always iterated in-order.;MultiSnapshot(TranslogSnapshot[] translogs, Closeable onClose) {_        this.translogs = translogs__        this.totalOperations = Arrays.stream(translogs).mapToInt(TranslogSnapshot::totalOperations).sum()__        this.overriddenOperations = 0__        this.onClose = onClose__        this.seenSeqNo = new SeqNoSet()__        this.index = translogs.length - 1__    };creates,a,new,point,in,time,snapshot,of,the,given,snapshots,those,snapshots,are,always,iterated,in,order;multi,snapshot,translog,snapshot,translogs,closeable,on,close,this,translogs,translogs,this,total,operations,arrays,stream,translogs,map,to,int,translog,snapshot,total,operations,sum,this,overridden,operations,0,this,on,close,on,close,this,seen,seq,no,new,seq,no,set,this,index,translogs,length,1
MultiSnapshot -> SeqNoSet -> boolean getAndSet(long value);1524684173;Marks this sequence number and returns <tt>true</tt> if it is seen before.;boolean getAndSet(long value) {_            assert value >= 0__            final long key = value / BIT_SET_SIZE__            CountedBitSet bitset = bitSets.get(key)__            if (bitset == null) {_                bitset = new CountedBitSet(BIT_SET_SIZE)__                bitSets.put(key, bitset)__            }_            final int index = Math.toIntExact(value % BIT_SET_SIZE)__            final boolean wasOn = bitset.get(index)__            bitset.set(index)__            return wasOn__        };marks,this,sequence,number,and,returns,tt,true,tt,if,it,is,seen,before;boolean,get,and,set,long,value,assert,value,0,final,long,key,value,counted,bit,set,bitset,bit,sets,get,key,if,bitset,null,bitset,new,counted,bit,set,bit,sets,put,key,bitset,final,int,index,math,to,int,exact,value,final,boolean,was,on,bitset,get,index,bitset,set,index,return,was,on
MultiSnapshot -> SeqNoSet -> boolean getAndSet(long value);1525334055;Marks this sequence number and returns {@code true} if it is seen before.;boolean getAndSet(long value) {_            assert value >= 0__            final long key = value / BIT_SET_SIZE__            CountedBitSet bitset = bitSets.get(key)__            if (bitset == null) {_                bitset = new CountedBitSet(BIT_SET_SIZE)__                bitSets.put(key, bitset)__            }_            final int index = Math.toIntExact(value % BIT_SET_SIZE)__            final boolean wasOn = bitset.get(index)__            bitset.set(index)__            return wasOn__        };marks,this,sequence,number,and,returns,code,true,if,it,is,seen,before;boolean,get,and,set,long,value,assert,value,0,final,long,key,value,counted,bit,set,bitset,bit,sets,get,key,if,bitset,null,bitset,new,counted,bit,set,bit,sets,put,key,bitset,final,int,index,math,to,int,exact,value,final,boolean,was,on,bitset,get,index,bitset,set,index,return,was,on
MultiSnapshot -> SeqNoSet -> boolean getAndSet(long value);1528706846;Marks this sequence number and returns {@code true} if it is seen before.;boolean getAndSet(long value) {_            assert value >= 0__            final long key = value / BIT_SET_SIZE__            CountedBitSet bitset = bitSets.get(key)__            if (bitset == null) {_                bitset = new CountedBitSet(BIT_SET_SIZE)__                bitSets.put(key, bitset)__            }_            final int index = Math.toIntExact(value % BIT_SET_SIZE)__            final boolean wasOn = bitset.get(index)__            bitset.set(index)__            return wasOn__        };marks,this,sequence,number,and,returns,code,true,if,it,is,seen,before;boolean,get,and,set,long,value,assert,value,0,final,long,key,value,counted,bit,set,bitset,bit,sets,get,key,if,bitset,null,bitset,new,counted,bit,set,bit,sets,put,key,bitset,final,int,index,math,to,int,exact,value,final,boolean,was,on,bitset,get,index,bitset,set,index,return,was,on
