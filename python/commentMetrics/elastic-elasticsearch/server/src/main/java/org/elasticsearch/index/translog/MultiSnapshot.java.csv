commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public int totalOperations() {     return totalOperations. }
false;public;0;8;;@Override public int skippedOperations() {     int skippedOperations = overriddenOperations.     for (TranslogSnapshot translog : translogs) {         skippedOperations += translog.skippedOperations().     }     return skippedOperations. }
false;public;0;4;;@Override public int overriddenOperations() {     return overriddenOperations. }
false;public;0;15;;@Override public Translog.Operation next() throws IOException {     for (. index >= 0. index--) {         final TranslogSnapshot current = translogs[index].         Translog.Operation op.         while ((op = current.next()) != null) {             if (op.seqNo() == SequenceNumbers.UNASSIGNED_SEQ_NO || seenSeqNo.getAndSet(op.seqNo()) == false) {                 return op.             } else {                 overriddenOperations++.             }         }     }     return null. }
false;public;0;4;;@Override public void close() throws IOException {     onClose.close(). }
true;;1;13;/**  * Marks this sequence number and returns {@code true} if it is seen before.  */ ;/**  * Marks this sequence number and returns {@code true} if it is seen before.  */ boolean getAndSet(long value) {     assert value >= 0.     final long key = value / BIT_SET_SIZE.     CountedBitSet bitset = bitSets.get(key).     if (bitset == null) {         bitset = new CountedBitSet(BIT_SET_SIZE).         bitSets.put(key, bitset).     }     final int index = Math.toIntExact(value % BIT_SET_SIZE).     final boolean wasOn = bitset.get(index).     bitset.set(index).     return wasOn. }
