commented;modifiers;parameterAmount;loc;comment;code
false;public;1;44;;@Override public void clusterChanged(ClusterChangedEvent event) {     ClusterState state = event.state().     if (state.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)) {         // while they actually do exist         return.     }     if (upgradesInProgress.get() > 0) {         // we are already running some upgrades - skip this cluster state update         return.     }     ImmutableOpenMap<String, IndexTemplateMetaData> templates = state.getMetaData().getTemplates().     if (templates == lastTemplateMetaData) {         // if there were no changes         return.     }     if (state.nodes().isLocalNodeElectedMaster() == false) {         return.     }     lastTemplateMetaData = templates.     Optional<Tuple<Map<String, BytesReference>, Set<String>>> changes = calculateTemplateChanges(templates).     if (changes.isPresent()) {         if (upgradesInProgress.compareAndSet(0, changes.get().v1().size() + changes.get().v2().size() + 1)) {             logger.info("Starting template upgrade to version {}, {} templates will be updated and {} will be removed", Version.CURRENT, changes.get().v1().size(), changes.get().v2().size()).             final ThreadContext threadContext = threadPool.getThreadContext().             try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {                 threadContext.markAsSystemContext().                 threadPool.generic().execute(() -> upgradeTemplates(changes.get().v1(), changes.get().v2())).             }         }     } }
false;public;1;8;;@Override public void onResponse(AcknowledgedResponse response) {     if (response.isAcknowledged() == false) {         anyUpgradeFailed.set(true).         logger.warn("Error updating template [{}], request was not acknowledged", change.getKey()).     }     tryFinishUpgrade(anyUpgradeFailed). }
false;public;1;6;;@Override public void onFailure(Exception e) {     anyUpgradeFailed.set(true).     logger.warn(new ParameterizedMessage("Error updating template [{}]", change.getKey()), e).     tryFinishUpgrade(anyUpgradeFailed). }
false;public;1;8;;@Override public void onResponse(AcknowledgedResponse response) {     if (response.isAcknowledged() == false) {         anyUpgradeFailed.set(true).         logger.warn("Error deleting template [{}], request was not acknowledged", template).     }     tryFinishUpgrade(anyUpgradeFailed). }
false;public;1;10;;@Override public void onFailure(Exception e) {     anyUpgradeFailed.set(true).     if (e instanceof IndexTemplateMissingException == false) {         // we might attempt to delete the same template from different nodes - so that's ok if template doesn't exist         // otherwise we need to warn         logger.warn(new ParameterizedMessage("Error deleting template [{}]", template), e).     }     tryFinishUpgrade(anyUpgradeFailed). }
false;;2;55;;void upgradeTemplates(Map<String, BytesReference> changes, Set<String> deletions) {     final AtomicBoolean anyUpgradeFailed = new AtomicBoolean(false).     if (threadPool.getThreadContext().isSystemContext() == false) {         throw new IllegalStateException("template updates from the template upgrade service should always happen in a system context").     }     for (Map.Entry<String, BytesReference> change : changes.entrySet()) {         PutIndexTemplateRequest request = new PutIndexTemplateRequest(change.getKey()).source(change.getValue(), XContentType.JSON).         request.masterNodeTimeout(TimeValue.timeValueMinutes(1)).         client.admin().indices().putTemplate(request, new ActionListener<AcknowledgedResponse>() {              @Override             public void onResponse(AcknowledgedResponse response) {                 if (response.isAcknowledged() == false) {                     anyUpgradeFailed.set(true).                     logger.warn("Error updating template [{}], request was not acknowledged", change.getKey()).                 }                 tryFinishUpgrade(anyUpgradeFailed).             }              @Override             public void onFailure(Exception e) {                 anyUpgradeFailed.set(true).                 logger.warn(new ParameterizedMessage("Error updating template [{}]", change.getKey()), e).                 tryFinishUpgrade(anyUpgradeFailed).             }         }).     }     for (String template : deletions) {         DeleteIndexTemplateRequest request = new DeleteIndexTemplateRequest(template).         request.masterNodeTimeout(TimeValue.timeValueMinutes(1)).         client.admin().indices().deleteTemplate(request, new ActionListener<AcknowledgedResponse>() {              @Override             public void onResponse(AcknowledgedResponse response) {                 if (response.isAcknowledged() == false) {                     anyUpgradeFailed.set(true).                     logger.warn("Error deleting template [{}], request was not acknowledged", template).                 }                 tryFinishUpgrade(anyUpgradeFailed).             }              @Override             public void onFailure(Exception e) {                 anyUpgradeFailed.set(true).                 if (e instanceof IndexTemplateMissingException == false) {                     // we might attempt to delete the same template from different nodes - so that's ok if template doesn't exist                     // otherwise we need to warn                     logger.warn(new ParameterizedMessage("Error deleting template [{}]", template), e).                 }                 tryFinishUpgrade(anyUpgradeFailed).             }         }).     } }
false;;1;25;;void tryFinishUpgrade(AtomicBoolean anyUpgradeFailed) {     assert upgradesInProgress.get() > 0.     if (upgradesInProgress.decrementAndGet() == 1) {         try {             // this is the last upgrade, the templates should now be in the desired state             if (anyUpgradeFailed.get()) {                 logger.info("Templates were partially upgraded to version {}", Version.CURRENT).             } else {                 logger.info("Templates were upgraded successfully to version {}", Version.CURRENT).             }             // Check upgraders are satisfied after the update completed. If they still             // report that changes are required, this might indicate a bug or that something             // else tinkering with the templates during the upgrade.             final ImmutableOpenMap<String, IndexTemplateMetaData> upgradedTemplates = clusterService.state().getMetaData().getTemplates().             final boolean changesRequired = calculateTemplateChanges(upgradedTemplates).isPresent().             if (changesRequired) {                 logger.warn("Templates are still reported as out of date after the upgrade. The template upgrade will be retried.").             }         } finally {             final int noMoreUpgrades = upgradesInProgress.decrementAndGet().             assert noMoreUpgrades == 0.         }     } }
false;;1;27;;Optional<Tuple<Map<String, BytesReference>, Set<String>>> calculateTemplateChanges(ImmutableOpenMap<String, IndexTemplateMetaData> templates) {     // collect current templates     Map<String, IndexTemplateMetaData> existingMap = new HashMap<>().     for (ObjectObjectCursor<String, IndexTemplateMetaData> customCursor : templates) {         existingMap.put(customCursor.key, customCursor.value).     }     // upgrade global custom meta data     Map<String, IndexTemplateMetaData> upgradedMap = indexTemplateMetaDataUpgraders.apply(existingMap).     if (upgradedMap.equals(existingMap) == false) {         Set<String> deletes = new HashSet<>().         Map<String, BytesReference> changes = new HashMap<>().         // remove templates if needed         existingMap.keySet().forEach(s -> {             if (upgradedMap.containsKey(s) == false) {                 deletes.add(s).             }         }).         upgradedMap.forEach((key, value) -> {             if (value.equals(existingMap.get(key)) == false) {                 changes.put(key, toBytesReference(value)).             }         }).         return Optional.of(new Tuple<>(changes, deletes)).     }     return Optional.empty(). }
false;private;1;10;;private BytesReference toBytesReference(IndexTemplateMetaData templateMetaData) {     try {         return XContentHelper.toXContent((builder, params) -> {             IndexTemplateMetaData.Builder.toInnerXContentWithTypes(templateMetaData, builder, params).             return builder.         }, XContentType.JSON, PARAMS, false).     } catch (IOException ex) {         throw new IllegalStateException("Cannot serialize template [" + templateMetaData.getName() + "]", ex).     } }
