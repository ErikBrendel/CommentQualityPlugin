commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * The version of the node on the other side of this stream.  */ ;/**  * The version of the node on the other side of this stream.  */ public Version getVersion() {     return this.version. }
true;public;1;3;/**  * Set the version of the node on the other side of this stream.  */ ;/**  * Set the version of the node on the other side of this stream.  */ public void setVersion(Version version) {     this.version = version. }
true;public;1;3;/**  * Test if the stream has the specified feature. Features are used when serializing {@link ClusterState.Custom} or  * {@link MetaData.Custom}. see also {@link ClusterState.FeatureAware}.  *  * @param feature the feature to test  * @return true if the stream has the specified feature  */ ;/**  * Test if the stream has the specified feature. Features are used when serializing {@link ClusterState.Custom} or  * {@link MetaData.Custom}. see also {@link ClusterState.FeatureAware}.  *  * @param feature the feature to test  * @return true if the stream has the specified feature  */ public boolean hasFeature(final String feature) {     return this.features.contains(feature). }
true;public;1;4;/**  * Set the features on the stream. See {@link StreamOutput#hasFeature(String)}.  *  * @param features the features on the stream  */ ;/**  * Set the features on the stream. See {@link StreamOutput#hasFeature(String)}.  *  * @param features the features on the stream  */ public void setFeatures(final Set<String> features) {     assert this.features.isEmpty() : this.features.     this.features = Collections.unmodifiableSet(new HashSet<>(features)). }
false;public;0;3;;public long position() throws IOException {     throw new UnsupportedOperationException(). }
false;public;1;3;;public void seek(long position) throws IOException {     throw new UnsupportedOperationException(). }
true;public,abstract;1;1;/**  * Writes a single byte.  */ ;/**  * Writes a single byte.  */ public abstract void writeByte(byte b) throws IOException.
true;public;1;3;/**  * Writes an array of bytes.  *  * @param b the bytes to write  */ ;/**  * Writes an array of bytes.  *  * @param b the bytes to write  */ public void writeBytes(byte[] b) throws IOException {     writeBytes(b, 0, b.length). }
true;public;2;3;/**  * Writes an array of bytes.  *  * @param b      the bytes to write  * @param length the number of bytes to write  */ ;/**  * Writes an array of bytes.  *  * @param b      the bytes to write  * @param length the number of bytes to write  */ public void writeBytes(byte[] b, int length) throws IOException {     writeBytes(b, 0, length). }
true;public,abstract;3;1;/**  * Writes an array of bytes.  *  * @param b      the bytes to write  * @param offset the offset in the byte array  * @param length the number of bytes to write  */ ;/**  * Writes an array of bytes.  *  * @param b      the bytes to write  * @param offset the offset in the byte array  * @param length the number of bytes to write  */ public abstract void writeBytes(byte[] b, int offset, int length) throws IOException.
true;public;1;4;/**  * Writes an array of bytes.  *  * @param b the bytes to write  */ ;/**  * Writes an array of bytes.  *  * @param b the bytes to write  */ public void writeByteArray(byte[] b) throws IOException {     writeVInt(b.length).     writeBytes(b, 0, b.length). }
true;public;1;8;/**  * Writes the bytes reference, including a length header.  */ ;/**  * Writes the bytes reference, including a length header.  */ public void writeBytesReference(@Nullable BytesReference bytes) throws IOException {     if (bytes == null) {         writeVInt(0).         return.     }     writeVInt(bytes.length()).     bytes.writeTo(this). }
true;public;1;8;/**  * Writes an optional bytes reference including a length header. Use this if you need to differentiate between null and empty bytes  * references. Use {@link #writeBytesReference(BytesReference)} and {@link StreamInput#readBytesReference()} if you do not.  */ ;/**  * Writes an optional bytes reference including a length header. Use this if you need to differentiate between null and empty bytes  * references. Use {@link #writeBytesReference(BytesReference)} and {@link StreamInput#readBytesReference()} if you do not.  */ public void writeOptionalBytesReference(@Nullable BytesReference bytes) throws IOException {     if (bytes == null) {         writeVInt(0).         return.     }     writeVInt(bytes.length() + 1).     bytes.writeTo(this). }
false;public;1;8;;public void writeBytesRef(BytesRef bytes) throws IOException {     if (bytes == null) {         writeVInt(0).         return.     }     writeVInt(bytes.length).     write(bytes.bytes, bytes.offset, bytes.length). }
false;public,final;1;4;;public final void writeShort(short v) throws IOException {     writeByte((byte) (v >> 8)).     writeByte((byte) v). }
true;public;1;6;/**  * Writes an int as four bytes.  */ ;/**  * Writes an int as four bytes.  */ public void writeInt(int i) throws IOException {     writeByte((byte) (i >> 24)).     writeByte((byte) (i >> 16)).     writeByte((byte) (i >> 8)).     writeByte((byte) i). }
true;public;1;7;/**  * Writes an int in a variable-length format.  Writes between one and  * five bytes.  Smaller values take fewer bytes.  Negative numbers  * will always use all 5 bytes and are therefore better serialized  * using {@link #writeInt}  */ ;/**  * Writes an int in a variable-length format.  Writes between one and  * five bytes.  Smaller values take fewer bytes.  Negative numbers  * will always use all 5 bytes and are therefore better serialized  * using {@link #writeInt}  */ public void writeVInt(int i) throws IOException {     while ((i & ~0x7F) != 0) {         writeByte((byte) ((i & 0x7f) | 0x80)).         i >>>= 7.     }     writeByte((byte) i). }
true;public;1;4;/**  * Writes a long as eight bytes.  */ ;/**  * Writes a long as eight bytes.  */ public void writeLong(long i) throws IOException {     writeInt((int) (i >> 32)).     writeInt((int) i). }
true;public;1;6;/**  * Writes a non-negative long in a variable-length format. Writes between one and ten bytes. Smaller values take fewer bytes. Negative  * numbers use ten bytes and trip assertions (if running in tests) so prefer {@link #writeLong(long)} or {@link #writeZLong(long)} for  * negative numbers.  */ ;/**  * Writes a non-negative long in a variable-length format. Writes between one and ten bytes. Smaller values take fewer bytes. Negative  * numbers use ten bytes and trip assertions (if running in tests) so prefer {@link #writeLong(long)} or {@link #writeZLong(long)} for  * negative numbers.  */ public void writeVLong(long i) throws IOException {     if (i < 0) {         throw new IllegalStateException("Negative longs unsupported, use writeLong or writeZLong for negative numbers [" + i + "]").     }     writeVLongNoCheck(i). }
true;;1;7;/**  * Writes a long in a variable-length format without first checking if it is negative. Package private for testing. Use  * {@link #writeVLong(long)} instead.  */ ;/**  * Writes a long in a variable-length format without first checking if it is negative. Package private for testing. Use  * {@link #writeVLong(long)} instead.  */ void writeVLongNoCheck(long i) throws IOException {     while ((i & ~0x7F) != 0) {         writeByte((byte) ((i & 0x7f) | 0x80)).         i >>>= 7.     }     writeByte((byte) i). }
true;public;1;9;/**  * Writes a long in a variable-length format. Writes between one and ten bytes.  * Values are remapped by sliding the sign bit into the lsb and then encoded as an unsigned number  * e.g., 0 -.&gt. 0, -1 -.&gt. 1, 1 -.&gt. 2, ..., Long.MIN_VALUE -.&gt. -1, Long.MAX_VALUE -.&gt. -2  * Numbers with small absolute value will have a small encoding  * If the numbers are known to be non-negative, use {@link #writeVLong(long)}  */ ;/**  * Writes a long in a variable-length format. Writes between one and ten bytes.  * Values are remapped by sliding the sign bit into the lsb and then encoded as an unsigned number  * e.g., 0 -.&gt. 0, -1 -.&gt. 1, 1 -.&gt. 2, ..., Long.MIN_VALUE -.&gt. -1, Long.MAX_VALUE -.&gt. -2  * Numbers with small absolute value will have a small encoding  * If the numbers are known to be non-negative, use {@link #writeVLong(long)}  */ public void writeZLong(long i) throws IOException {     // zig-zag encoding cf. https://developers.google.com/protocol-buffers/docs/encoding?hl=en     long value = BitUtil.zigZagEncode(i).     while ((value & 0xFFFFFFFFFFFFFF80L) != 0L) {         writeByte((byte) ((value & 0x7F) | 0x80)).         value >>>= 7.     }     writeByte((byte) (value & 0x7F)). }
false;public;1;8;;public void writeOptionalLong(@Nullable Long l) throws IOException {     if (l == null) {         writeBoolean(false).     } else {         writeBoolean(true).         writeLong(l).     } }
false;public;1;8;;public void writeOptionalString(@Nullable String str) throws IOException {     if (str == null) {         writeBoolean(false).     } else {         writeBoolean(true).         writeString(str).     } }
true;public;1;8;/**  * Writes an optional {@link Integer}.  */ ;/**  * Writes an optional {@link Integer}.  */ public void writeOptionalInt(@Nullable Integer integer) throws IOException {     if (integer == null) {         writeBoolean(false).     } else {         writeBoolean(true).         writeInt(integer).     } }
false;public;1;8;;public void writeOptionalVInt(@Nullable Integer integer) throws IOException {     if (integer == null) {         writeBoolean(false).     } else {         writeBoolean(true).         writeVInt(integer).     } }
false;public;1;8;;public void writeOptionalFloat(@Nullable Float floatValue) throws IOException {     if (floatValue == null) {         writeBoolean(false).     } else {         writeBoolean(true).         writeFloat(floatValue).     } }
false;public;1;7;;public void writeOptionalText(@Nullable Text text) throws IOException {     if (text == null) {         writeInt(-1).     } else {         writeText(text).     } }
false;public;1;12;;public void writeText(Text text) throws IOException {     if (!text.hasBytes()) {         final String string = text.string().         spare.copyChars(string).         writeInt(spare.length()).         write(spare.bytes(), 0, spare.length()).     } else {         BytesReference bytes = text.bytes().         writeInt(bytes.length()).         bytes.writeTo(this).     } }
false;public;1;31;;public void writeString(String str) throws IOException {     final int charCount = str.length().     // at most 3 bytes per character is needed here     final int bufferSize = Math.min(3 * charCount, 1024).     if (convertStringBuffer.length < bufferSize) {         // we don't use ArrayUtils.grow since copying the bytes is unnecessary         convertStringBuffer = new byte[ArrayUtil.oversize(bufferSize, Byte.BYTES)].     }     byte[] buffer = convertStringBuffer.     int offset = 0.     writeVInt(charCount).     for (int i = 0. i < charCount. i++) {         final int c = str.charAt(i).         if (c <= 0x007F) {             buffer[offset++] = ((byte) c).         } else if (c > 0x07FF) {             buffer[offset++] = ((byte) (0xE0 | c >> 12 & 0x0F)).             buffer[offset++] = ((byte) (0x80 | c >> 6 & 0x3F)).             buffer[offset++] = ((byte) (0x80 | c >> 0 & 0x3F)).         } else {             buffer[offset++] = ((byte) (0xC0 | c >> 6 & 0x1F)).             buffer[offset++] = ((byte) (0x80 | c >> 0 & 0x3F)).         }         // left before we start another iteration         if (offset > buffer.length - 3) {             writeBytes(buffer, offset).             offset = 0.         }     }     writeBytes(buffer, offset). }
false;public;1;3;;public void writeFloat(float v) throws IOException {     writeInt(Float.floatToIntBits(v)). }
false;public;1;3;;public void writeDouble(double v) throws IOException {     writeLong(Double.doubleToLongBits(v)). }
false;public;1;8;;public void writeOptionalDouble(@Nullable Double v) throws IOException {     if (v == null) {         writeBoolean(false).     } else {         writeBoolean(true).         writeDouble(v).     } }
true;public;1;3;/**  * Writes a boolean.  */ ;/**  * Writes a boolean.  */ public void writeBoolean(boolean b) throws IOException {     writeByte(b ? ONE : ZERO). }
false;public;1;7;;public void writeOptionalBoolean(@Nullable Boolean b) throws IOException {     if (b == null) {         writeByte(TWO).     } else {         writeBoolean(b).     } }
true;public,abstract;0;2;/**  * Forces any buffered output to be written.  */ ;/**  * Forces any buffered output to be written.  */ @Override public abstract void flush() throws IOException.
true;public,abstract;0;2;/**  * Closes this stream to further operations.  */ ;/**  * Closes this stream to further operations.  */ @Override public abstract void close() throws IOException.
false;public,abstract;0;1;;public abstract void reset() throws IOException.
false;public;1;4;;@Override public void write(int b) throws IOException {     writeByte((byte) b). }
false;public;3;4;;@Override public void write(byte[] b, int off, int len) throws IOException {     writeBytes(b, off, len). }
false;public;1;6;;public void writeStringArray(String[] array) throws IOException {     writeVInt(array.length).     for (String s : array) {         writeString(s).     } }
true;public;1;10;/**  * Writes a string array, for nullable string, writes it as 0 (empty string).  */ ;/**  * Writes a string array, for nullable string, writes it as 0 (empty string).  */ public void writeStringArrayNullable(@Nullable String[] array) throws IOException {     if (array == null) {         writeVInt(0).     } else {         writeVInt(array.length).         for (String s : array) {             writeString(s).         }     } }
true;public;1;8;/**  * Writes a string array, for nullable string, writes false.  */ ;/**  * Writes a string array, for nullable string, writes false.  */ public void writeOptionalStringArray(@Nullable String[] array) throws IOException {     if (array == null) {         writeBoolean(false).     } else {         writeBoolean(true).         writeStringArray(array).     } }
false;public;1;3;;public void writeMap(@Nullable Map<String, Object> map) throws IOException {     writeGenericValue(map). }
true;public;1;17;/**  * write map to stream with consistent order  * to make sure every map generated bytes order are same.  * This method is compatible with {@code StreamInput.readMap} and {@code StreamInput.readGenericValue}  * This method only will handle the map keys order, not maps contained within the map  */ ;/**  * write map to stream with consistent order  * to make sure every map generated bytes order are same.  * This method is compatible with {@code StreamInput.readMap} and {@code StreamInput.readGenericValue}  * This method only will handle the map keys order, not maps contained within the map  */ public void writeMapWithConsistentOrder(@Nullable Map<String, ? extends Object> map) throws IOException {     if (map == null) {         writeByte((byte) -1).         return.     }     assert false == (map instanceof LinkedHashMap).     this.writeByte((byte) 10).     this.writeVInt(map.size()).     Iterator<? extends Map.Entry<String, ?>> iterator = map.entrySet().stream().sorted((a, b) -> a.getKey().compareTo(b.getKey())).iterator().     while (iterator.hasNext()) {         Map.Entry<String, ?> next = iterator.next().         this.writeString(next.getKey()).         this.writeGenericValue(next.getValue()).     } }
true;public,final;3;9;/**  * Write a {@link Map} of {@code K}-type keys to {@code V}-type {@link List}s.  * <pre><code>  * Map&lt.String, List&lt.String&gt.&gt. map = ....  * out.writeMapOfLists(map, StreamOutput::writeString, StreamOutput::writeString).  * </code></pre>  *  * @param keyWriter The key writer  * @param valueWriter The value writer  */ ;/**  * Write a {@link Map} of {@code K}-type keys to {@code V}-type {@link List}s.  * <pre><code>  * Map&lt.String, List&lt.String&gt.&gt. map = ....  * out.writeMapOfLists(map, StreamOutput::writeString, StreamOutput::writeString).  * </code></pre>  *  * @param keyWriter The key writer  * @param valueWriter The value writer  */ public final <K, V> void writeMapOfLists(final Map<K, List<V>> map, final Writer<K> keyWriter, final Writer<V> valueWriter) throws IOException {     writeMap(map, keyWriter, (stream, list) -> {         writeVInt(list.size()).         for (final V value : list) {             valueWriter.write(this, value).         }     }). }
true;public,final;3;8;/**  * Write a {@link Map} of {@code K}-type keys to {@code V}-type.  * <pre><code>  * Map&lt.String, String&gt. map = ....  * out.writeMap(map, StreamOutput::writeString, StreamOutput::writeString).  * </code></pre>  *  * @param keyWriter The key writer  * @param valueWriter The value writer  */ ;/**  * Write a {@link Map} of {@code K}-type keys to {@code V}-type.  * <pre><code>  * Map&lt.String, String&gt. map = ....  * out.writeMap(map, StreamOutput::writeString, StreamOutput::writeString).  * </code></pre>  *  * @param keyWriter The key writer  * @param valueWriter The value writer  */ public final <K, V> void writeMap(final Map<K, V> map, final Writer<K> keyWriter, final Writer<V> valueWriter) throws IOException {     writeVInt(map.size()).     for (final Map.Entry<K, V> entry : map.entrySet()) {         keyWriter.write(this, entry.getKey()).         valueWriter.write(this, entry.getValue()).     } }
true;public,final;1;4;/**  * Writes an {@link Instant} to the stream with nanosecond resolution  */ ;/**  * Writes an {@link Instant} to the stream with nanosecond resolution  */ public final void writeInstant(Instant instant) throws IOException {     writeLong(instant.getEpochSecond()).     writeInt(instant.getNano()). }
true;public,final;1;8;/**  * Writes an {@link Instant} to the stream, which could possibly be null  */ ;/**  * Writes an {@link Instant} to the stream, which could possibly be null  */ public final void writeOptionalInstant(@Nullable Instant instant) throws IOException {     if (instant == null) {         writeBoolean(false).     } else {         writeBoolean(true).         writeInstant(instant).     } }
true;public;1;26;/**  * Notice: when serialization a map, the stream out map with the stream in map maybe have the  * different key-value orders, they will maybe have different stream order.  * If want to keep stream out map and stream in map have the same stream order when stream,  * can use {@code writeMapWithConsistentOrder}  */ ;/**  * Notice: when serialization a map, the stream out map with the stream in map maybe have the  * different key-value orders, they will maybe have different stream order.  * If want to keep stream out map and stream in map have the same stream order when stream,  * can use {@code writeMapWithConsistentOrder}  */ public void writeGenericValue(@Nullable Object value) throws IOException {     if (value == null) {         writeByte((byte) -1).         return.     }     final Class type.     if (value instanceof List) {         type = List.class.     } else if (value instanceof Object[]) {         type = Object[].class.     } else if (value instanceof Map) {         type = Map.class.     } else if (value instanceof ReadableInstant) {         type = ReadableInstant.class.     } else if (value instanceof BytesReference) {         type = BytesReference.class.     } else {         type = value.getClass().     }     final Writer writer = WRITERS.get(type).     if (writer != null) {         writer.write(this, value).     } else {         throw new IOException("can not write type [" + type + "]").     } }
false;public;1;6;;public void writeIntArray(int[] values) throws IOException {     writeVInt(values.length).     for (int value : values) {         writeInt(value).     } }
false;public;1;6;;public void writeVIntArray(int[] values) throws IOException {     writeVInt(values.length).     for (int value : values) {         writeVInt(value).     } }
false;public;1;6;;public void writeLongArray(long[] values) throws IOException {     writeVInt(values.length).     for (long value : values) {         writeLong(value).     } }
false;public;1;6;;public void writeVLongArray(long[] values) throws IOException {     writeVInt(values.length).     for (long value : values) {         writeVLong(value).     } }
false;public;1;6;;public void writeFloatArray(float[] values) throws IOException {     writeVInt(values.length).     for (float value : values) {         writeFloat(value).     } }
false;public;1;6;;public void writeDoubleArray(double[] values) throws IOException {     writeVInt(values.length).     for (double value : values) {         writeDouble(value).     } }
true;public;2;6;/**  * Writes the specified array to the stream using the specified {@link Writer} for each element in the array. This method can be seen as  * writer version of {@link StreamInput#readArray(Writeable.Reader, IntFunction)}. The length of array encoded as a variable-length  * integer is first written to the stream, and then the elements of the array are written to the stream.  *  * @param writer the writer used to write individual elements  * @param array  the array  * @param <T>    the type of the elements of the array  * @throws IOException if an I/O exception occurs while writing the array  */ ;/**  * Writes the specified array to the stream using the specified {@link Writer} for each element in the array. This method can be seen as  * writer version of {@link StreamInput#readArray(Writeable.Reader, IntFunction)}. The length of array encoded as a variable-length  * integer is first written to the stream, and then the elements of the array are written to the stream.  *  * @param writer the writer used to write individual elements  * @param array  the array  * @param <T>    the type of the elements of the array  * @throws IOException if an I/O exception occurs while writing the array  */ public <T> void writeArray(final Writer<T> writer, final T[] array) throws IOException {     writeVInt(array.length).     for (T value : array) {         writer.write(this, value).     } }
true;public;2;8;/**  * Same as {@link #writeArray(Writer, Object[])} but the provided array may be null. An additional boolean value is  * serialized to indicate whether the array was null or not.  */ ;/**  * Same as {@link #writeArray(Writer, Object[])} but the provided array may be null. An additional boolean value is  * serialized to indicate whether the array was null or not.  */ public <T> void writeOptionalArray(final Writer<T> writer, @Nullable final T[] array) throws IOException {     if (array == null) {         writeBoolean(false).     } else {         writeBoolean(true).         writeArray(writer, array).     } }
true;public;1;3;/**  * Writes the specified array of {@link Writeable}s. This method can be seen as  * writer version of {@link StreamInput#readArray(Writeable.Reader, IntFunction)}. The length of array encoded as a variable-length  * integer is first written to the stream, and then the elements of the array are written to the stream.  */ ;/**  * Writes the specified array of {@link Writeable}s. This method can be seen as  * writer version of {@link StreamInput#readArray(Writeable.Reader, IntFunction)}. The length of array encoded as a variable-length  * integer is first written to the stream, and then the elements of the array are written to the stream.  */ public <T extends Writeable> void writeArray(T[] array) throws IOException {     writeArray((out, value) -> value.writeTo(out), array). }
true;public;1;3;/**  * Same as {@link #writeArray(Writeable[])} but the provided array may be null. An additional boolean value is  * serialized to indicate whether the array was null or not.  */ ;/**  * Same as {@link #writeArray(Writeable[])} but the provided array may be null. An additional boolean value is  * serialized to indicate whether the array was null or not.  */ public <T extends Writeable> void writeOptionalArray(@Nullable T[] array) throws IOException {     writeOptionalArray((out, value) -> value.writeTo(out), array). }
true;public;1;8;/**  * Serializes a potential null value.  */ ;/**  * Serializes a potential null value.  */ public void writeOptionalStreamable(@Nullable Streamable streamable) throws IOException {     if (streamable != null) {         writeBoolean(true).         streamable.writeTo(this).     } else {         writeBoolean(false).     } }
false;public;1;8;;public void writeOptionalWriteable(@Nullable Writeable writeable) throws IOException {     if (writeable != null) {         writeBoolean(true).         writeable.writeTo(this).     } else {         writeBoolean(false).     } }
false;public;1;116;;public void writeException(Throwable throwable) throws IOException {     if (throwable == null) {         writeBoolean(false).     } else {         writeBoolean(true).         boolean writeCause = true.         boolean writeMessage = true.         if (throwable instanceof CorruptIndexException) {             writeVInt(1).             writeOptionalString(((CorruptIndexException) throwable).getOriginalMessage()).             writeOptionalString(((CorruptIndexException) throwable).getResourceDescription()).             writeMessage = false.         } else if (throwable instanceof IndexFormatTooNewException) {             writeVInt(2).             writeOptionalString(((IndexFormatTooNewException) throwable).getResourceDescription()).             writeInt(((IndexFormatTooNewException) throwable).getVersion()).             writeInt(((IndexFormatTooNewException) throwable).getMinVersion()).             writeInt(((IndexFormatTooNewException) throwable).getMaxVersion()).             writeMessage = false.             writeCause = false.         } else if (throwable instanceof IndexFormatTooOldException) {             writeVInt(3).             IndexFormatTooOldException t = (IndexFormatTooOldException) throwable.             writeOptionalString(t.getResourceDescription()).             if (t.getVersion() == null) {                 writeBoolean(false).                 writeOptionalString(t.getReason()).             } else {                 writeBoolean(true).                 writeInt(t.getVersion()).                 writeInt(t.getMinVersion()).                 writeInt(t.getMaxVersion()).             }             writeMessage = false.             writeCause = false.         } else if (throwable instanceof NullPointerException) {             writeVInt(4).             writeCause = false.         } else if (throwable instanceof NumberFormatException) {             writeVInt(5).             writeCause = false.         } else if (throwable instanceof IllegalArgumentException) {             writeVInt(6).         } else if (throwable instanceof AlreadyClosedException) {             writeVInt(7).         } else if (throwable instanceof EOFException) {             writeVInt(8).             writeCause = false.         } else if (throwable instanceof SecurityException) {             writeVInt(9).         } else if (throwable instanceof StringIndexOutOfBoundsException) {             writeVInt(10).             writeCause = false.         } else if (throwable instanceof ArrayIndexOutOfBoundsException) {             writeVInt(11).             writeCause = false.         } else if (throwable instanceof FileNotFoundException) {             writeVInt(12).             writeCause = false.         } else if (throwable instanceof FileSystemException) {             writeVInt(13).             if (throwable instanceof NoSuchFileException) {                 writeVInt(0).             } else if (throwable instanceof NotDirectoryException) {                 writeVInt(1).             } else if (throwable instanceof DirectoryNotEmptyException) {                 writeVInt(2).             } else if (throwable instanceof AtomicMoveNotSupportedException) {                 writeVInt(3).             } else if (throwable instanceof FileAlreadyExistsException) {                 writeVInt(4).             } else if (throwable instanceof AccessDeniedException) {                 writeVInt(5).             } else if (throwable instanceof FileSystemLoopException) {                 writeVInt(6).             } else {                 writeVInt(7).             }             writeOptionalString(((FileSystemException) throwable).getFile()).             writeOptionalString(((FileSystemException) throwable).getOtherFile()).             writeOptionalString(((FileSystemException) throwable).getReason()).             writeCause = false.         } else if (throwable instanceof IllegalStateException) {             writeVInt(14).         } else if (throwable instanceof LockObtainFailedException) {             writeVInt(15).         } else if (throwable instanceof InterruptedException) {             writeVInt(16).             writeCause = false.         } else if (throwable instanceof IOException) {             writeVInt(17).         } else if (throwable instanceof EsRejectedExecutionException) {             writeVInt(18).             writeBoolean(((EsRejectedExecutionException) throwable).isExecutorShutdown()).             writeCause = false.         } else {             final ElasticsearchException ex.             if (throwable instanceof ElasticsearchException && ElasticsearchException.isRegistered(throwable.getClass(), version)) {                 ex = (ElasticsearchException) throwable.             } else {                 ex = new NotSerializableExceptionWrapper(throwable).             }             writeVInt(0).             writeVInt(ElasticsearchException.getId(ex.getClass())).             ex.writeTo(this).             return.         }         if (writeMessage) {             writeOptionalString(throwable.getMessage()).         }         if (writeCause) {             writeException(throwable.getCause()).         }         ElasticsearchException.writeStackTraces(throwable, this).     } }
true;public;1;4;/**  * Writes a {@link NamedWriteable} to the current stream, by first writing its name and then the object itself  */ ;/**  * Writes a {@link NamedWriteable} to the current stream, by first writing its name and then the object itself  */ public void writeNamedWriteable(NamedWriteable namedWriteable) throws IOException {     writeString(namedWriteable.getWriteableName()).     namedWriteable.writeTo(this). }
true;public;1;8;/**  * Write an optional {@link NamedWriteable} to the stream.  */ ;/**  * Write an optional {@link NamedWriteable} to the stream.  */ public void writeOptionalNamedWriteable(@Nullable NamedWriteable namedWriteable) throws IOException {     if (namedWriteable == null) {         writeBoolean(false).     } else {         writeBoolean(true).         writeNamedWriteable(namedWriteable).     } }
true;public;1;4;/**  * Writes the given {@link GeoPoint} to the stream  */ ;/**  * Writes the given {@link GeoPoint} to the stream  */ public void writeGeoPoint(GeoPoint geoPoint) throws IOException {     writeDouble(geoPoint.lat()).     writeDouble(geoPoint.lon()). }
true;public;1;3;/**  * Write a {@linkplain DateTimeZone} to the stream.  */ ;/**  * Write a {@linkplain DateTimeZone} to the stream.  */ public void writeTimeZone(DateTimeZone timeZone) throws IOException {     writeString(timeZone.getID()). }
true;public;1;3;/**  * Write a {@linkplain ZoneId} to the stream.  */ ;/**  * Write a {@linkplain ZoneId} to the stream.  */ public void writeZoneId(ZoneId timeZone) throws IOException {     writeString(timeZone.getId()). }
true;public;1;8;/**  * Write an optional {@linkplain DateTimeZone} to the stream.  */ ;/**  * Write an optional {@linkplain DateTimeZone} to the stream.  */ public void writeOptionalTimeZone(@Nullable DateTimeZone timeZone) throws IOException {     if (timeZone == null) {         writeBoolean(false).     } else {         writeBoolean(true).         writeTimeZone(timeZone).     } }
true;public;1;8;/**  * Write an optional {@linkplain ZoneId} to the stream.  */ ;/**  * Write an optional {@linkplain ZoneId} to the stream.  */ public void writeOptionalZoneId(@Nullable ZoneId timeZone) throws IOException {     if (timeZone == null) {         writeBoolean(false).     } else {         writeBoolean(true).         writeZoneId(timeZone).     } }
true;public;1;6;/**  * Writes a list of {@link Streamable} objects  */ ;/**  * Writes a list of {@link Streamable} objects  */ public void writeStreamableList(List<? extends Streamable> list) throws IOException {     writeVInt(list.size()).     for (Streamable obj : list) {         obj.writeTo(this).     } }
true;public;1;3;/**  * Writes a collection to this stream. The corresponding collection can be read from a stream input using  * {@link StreamInput#readList(Writeable.Reader)}.  *  * @param collection the collection to write to this stream  * @throws IOException if an I/O exception occurs writing the collection  */ ;/**  * Writes a collection to this stream. The corresponding collection can be read from a stream input using  * {@link StreamInput#readList(Writeable.Reader)}.  *  * @param collection the collection to write to this stream  * @throws IOException if an I/O exception occurs writing the collection  */ public void writeCollection(final Collection<? extends Writeable> collection) throws IOException {     writeCollection(collection, (o, v) -> v.writeTo(o)). }
true;public;1;3;/**  * Writes a list of {@link Writeable} objects  */ ;/**  * Writes a list of {@link Writeable} objects  */ public void writeList(List<? extends Writeable> list) throws IOException {     writeCollection(list). }
true;public;2;6;/**  * Writes a collection of objects via a {@link Writer}.  *  * @param collection the collection of objects  * @throws IOException if an I/O exception occurs writing the collection  */ ;/**  * Writes a collection of objects via a {@link Writer}.  *  * @param collection the collection of objects  * @throws IOException if an I/O exception occurs writing the collection  */ public <T> void writeCollection(final Collection<T> collection, final Writer<T> writer) throws IOException {     writeVInt(collection.size()).     for (final T val : collection) {         writer.write(this, val).     } }
true;public;1;3;/**  * Writes a collection of a strings. The corresponding collection can be read from a stream input using  * {@link StreamInput#readList(Writeable.Reader)}.  *  * @param collection the collection of strings  * @throws IOException if an I/O exception occurs writing the collection  */ ;/**  * Writes a collection of a strings. The corresponding collection can be read from a stream input using  * {@link StreamInput#readList(Writeable.Reader)}.  *  * @param collection the collection of strings  * @throws IOException if an I/O exception occurs writing the collection  */ public void writeStringCollection(final Collection<String> collection) throws IOException {     writeCollection(collection, StreamOutput::writeString). }
true;public;1;6;/**  * Writes a list of {@link NamedWriteable} objects.  */ ;/**  * Writes a list of {@link NamedWriteable} objects.  */ public void writeNamedWriteableList(List<? extends NamedWriteable> list) throws IOException {     writeVInt(list.size()).     for (NamedWriteable obj : list) {         writeNamedWriteable(obj).     } }
true;public;1;3;/**  * Writes an enum with type E based on its ordinal value  */ ;/**  * Writes an enum with type E based on its ordinal value  */ public <E extends Enum<E>> void writeEnum(E enumValue) throws IOException {     writeVInt(enumValue.ordinal()). }
true;public;1;6;/**  * Writes an EnumSet with type E that by serialized it based on it's ordinal value  */ ;/**  * Writes an EnumSet with type E that by serialized it based on it's ordinal value  */ public <E extends Enum<E>> void writeEnumSet(EnumSet<E> enumSet) throws IOException {     writeVInt(enumSet.size()).     for (E e : enumSet) {         writeEnum(e).     } }
true;public;1;4;/**  * Write a {@link TimeValue} to the stream  */ ;/**  * Write a {@link TimeValue} to the stream  */ public void writeTimeValue(TimeValue timeValue) throws IOException {     writeZLong(timeValue.duration()).     writeByte(TIME_UNIT_BYTE_MAP.get(timeValue.timeUnit())). }
true;public;1;8;/**  * Write an optional {@link TimeValue} to the stream.  */ ;/**  * Write an optional {@link TimeValue} to the stream.  */ public void writeOptionalTimeValue(@Nullable TimeValue timeValue) throws IOException {     if (timeValue == null) {         writeBoolean(false).     } else {         writeBoolean(true).         writeTimeValue(timeValue).     } }
