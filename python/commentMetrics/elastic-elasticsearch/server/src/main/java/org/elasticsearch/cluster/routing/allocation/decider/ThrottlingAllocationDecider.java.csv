commented;modifiers;parameterAmount;loc;comment;code
false;private;1;3;;private void setConcurrentIncomingRecoverries(int concurrentIncomingRecoveries) {     this.concurrentIncomingRecoveries = concurrentIncomingRecoveries. }
false;private;1;3;;private void setConcurrentOutgoingRecoverries(int concurrentOutgoingRecoveries) {     this.concurrentOutgoingRecoveries = concurrentOutgoingRecoveries. }
false;private;1;3;;private void setPrimariesInitialRecoveries(int primariesInitialRecoveries) {     this.primariesInitialRecoveries = primariesInitialRecoveries. }
false;public;3;61;;@Override public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {     if (shardRouting.primary() && shardRouting.unassigned()) {         assert initializingShard(shardRouting, node.nodeId()).recoverySource().getType() != RecoverySource.Type.PEER.         // primary is unassigned, means we are going to do recovery from store, snapshot or local shards         // count *just the primaries* currently doing recovery on the node and check against primariesInitialRecoveries         int primariesInRecovery = 0.         for (ShardRouting shard : node) {             // we only count initial recoveries here, so we need to make sure that relocating node is null             if (shard.initializing() && shard.primary() && shard.relocatingNodeId() == null) {                 primariesInRecovery++.             }         }         if (primariesInRecovery >= primariesInitialRecoveries) {             // TODO: Should index creation not be throttled for primary shards?             return allocation.decision(THROTTLE, NAME, "reached the limit of ongoing initial primary recoveries [%d], cluster setting [%s=%d]", primariesInRecovery, CLUSTER_ROUTING_ALLOCATION_NODE_INITIAL_PRIMARIES_RECOVERIES_SETTING.getKey(), primariesInitialRecoveries).         } else {             return allocation.decision(YES, NAME, "below primary recovery limit of [%d]", primariesInitialRecoveries).         }     } else {         // Peer recovery         assert initializingShard(shardRouting, node.nodeId()).recoverySource().getType() == RecoverySource.Type.PEER.         // Allocating a shard to this node will increase the incoming recoveries         int currentInRecoveries = allocation.routingNodes().getIncomingRecoveries(node.nodeId()).         if (currentInRecoveries >= concurrentIncomingRecoveries) {             return allocation.decision(THROTTLE, NAME, "reached the limit of incoming shard recoveries [%d], cluster setting [%s=%d] (can also be set via [%s])", currentInRecoveries, CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_INCOMING_RECOVERIES_SETTING.getKey(), concurrentIncomingRecoveries, CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_RECOVERIES_SETTING.getKey()).         } else {             // search for corresponding recovery source (= primary shard) and check number of outgoing recoveries on that node             ShardRouting primaryShard = allocation.routingNodes().activePrimary(shardRouting.shardId()).             if (primaryShard == null) {                 return allocation.decision(Decision.NO, NAME, "primary shard for this replica is not yet active").             }             int primaryNodeOutRecoveries = allocation.routingNodes().getOutgoingRecoveries(primaryShard.currentNodeId()).             if (primaryNodeOutRecoveries >= concurrentOutgoingRecoveries) {                 return allocation.decision(THROTTLE, NAME, "reached the limit of outgoing shard recoveries [%d] on the node [%s] which holds the primary, " + "cluster setting [%s=%d] (can also be set via [%s])", primaryNodeOutRecoveries, primaryShard.currentNodeId(), CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_OUTGOING_RECOVERIES_SETTING.getKey(), concurrentOutgoingRecoveries, CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_RECOVERIES_SETTING.getKey()).             } else {                 return allocation.decision(YES, NAME, "below shard recovery limit of outgoing: [%d < %d] incoming: [%d < %d]", primaryNodeOutRecoveries, concurrentOutgoingRecoveries, currentInRecoveries, concurrentIncomingRecoveries).             }         }     } }
true;private;2;24;/**  * The shard routing passed to {@link #canAllocate(ShardRouting, RoutingNode, RoutingAllocation)} is not the initializing shard to this  * node but:  * - the unassigned shard routing in case if we want to assign an unassigned shard to this node.  * - the initializing shard routing if we want to assign the initializing shard to this node instead  * - the started shard routing in case if we want to check if we can relocate to this node.  * - the relocating shard routing if we want to relocate to this node now instead.  *  * This method returns the corresponding initializing shard that would be allocated to this node.  */ ;/**  * The shard routing passed to {@link #canAllocate(ShardRouting, RoutingNode, RoutingAllocation)} is not the initializing shard to this  * node but:  * - the unassigned shard routing in case if we want to assign an unassigned shard to this node.  * - the initializing shard routing if we want to assign the initializing shard to this node instead  * - the started shard routing in case if we want to check if we can relocate to this node.  * - the relocating shard routing if we want to relocate to this node now instead.  *  * This method returns the corresponding initializing shard that would be allocated to this node.  */ private ShardRouting initializingShard(ShardRouting shardRouting, String currentNodeId) {     final ShardRouting initializingShard.     if (shardRouting.unassigned()) {         initializingShard = shardRouting.initialize(currentNodeId, null, ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE).     } else if (shardRouting.initializing()) {         UnassignedInfo unassignedInfo = shardRouting.unassignedInfo().         if (unassignedInfo == null) {             // unassigned shards must have unassignedInfo (initializing shards might not)             unassignedInfo = new UnassignedInfo(UnassignedInfo.Reason.ALLOCATION_FAILED, "fake").         }         initializingShard = shardRouting.moveToUnassigned(unassignedInfo).initialize(currentNodeId, null, ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE).     } else if (shardRouting.relocating()) {         initializingShard = shardRouting.cancelRelocation().relocate(currentNodeId, ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE).getTargetRelocatingShard().     } else {         assert shardRouting.started().         initializingShard = shardRouting.relocate(currentNodeId, ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE).getTargetRelocatingShard().     }     assert initializingShard.initializing().     return initializingShard. }
