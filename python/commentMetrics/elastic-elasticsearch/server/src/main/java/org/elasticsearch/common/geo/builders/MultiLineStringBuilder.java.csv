commented;modifiers;parameterAmount;loc;comment;code
false;public;1;7;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeVInt(lines.size()).     for (LineStringBuilder line : lines) {         line.writeTo(out).     } }
false;public;1;4;;public MultiLineStringBuilder linestring(LineStringBuilder line) {     this.lines.add(line).     return this. }
false;public;0;7;;public Coordinate[][] coordinates() {     Coordinate[][] result = new Coordinate[lines.size()][].     for (int i = 0. i < result.length. i++) {         result[i] = lines.get(i).coordinates(false).     }     return result. }
false;public;0;4;;@Override public GeoShapeType type() {     return TYPE. }
false;protected;0;18;;@Override protected StringBuilder contentToWKT() {     final StringBuilder sb = new StringBuilder().     if (lines.isEmpty()) {         sb.append(GeoWKTParser.EMPTY).     } else {         sb.append(GeoWKTParser.LPAREN).         if (lines.size() > 0) {             sb.append(ShapeBuilder.coordinateListToWKT(lines.get(0).coordinates)).         }         for (int i = 1. i < lines.size(). ++i) {             sb.append(GeoWKTParser.COMMA).             sb.append(ShapeBuilder.coordinateListToWKT(lines.get(i).coordinates)).         }         sb.append(GeoWKTParser.RPAREN).     }     return sb. }
false;public;0;7;;public int numDimensions() {     if (lines == null || lines.isEmpty()) {         throw new IllegalStateException("unable to get number of dimensions, " + "LineStrings have not yet been initialized").     }     return lines.get(0).numDimensions(). }
false;public;2;13;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     builder.field(ShapeParser.FIELD_TYPE.getPreferredName(), TYPE.shapeName()).     builder.field(ShapeParser.FIELD_COORDINATES.getPreferredName()).     builder.startArray().     for (LineStringBuilder line : lines) {         line.coordinatesToXcontent(builder, false).     }     builder.endArray().     builder.endObject().     return builder. }
false;public;0;24;;@Override public JtsGeometry buildS4J() {     final Geometry geometry.     if (wrapdateline) {         ArrayList<LineString> parts = new ArrayList<>().         for (LineStringBuilder line : lines) {             LineStringBuilder.decomposeS4J(FACTORY, line.coordinates(false), parts).         }         if (parts.size() == 1) {             geometry = parts.get(0).         } else {             LineString[] lineStrings = parts.toArray(new LineString[parts.size()]).             geometry = FACTORY.createMultiLineString(lineStrings).         }     } else {         LineString[] lineStrings = new LineString[lines.size()].         Iterator<LineStringBuilder> iterator = lines.iterator().         for (int i = 0. iterator.hasNext(). i++) {             lineStrings[i] = FACTORY.createLineString(iterator.next().coordinates(false)).         }         geometry = FACTORY.createMultiLineString(lineStrings).     }     return jtsGeometry(geometry). }
false;public;0;23;;@Override public org.elasticsearch.geo.geometry.Geometry buildGeometry() {     if (lines.isEmpty()) {         return MultiLine.EMPTY.     }     if (wrapdateline) {         List<org.elasticsearch.geo.geometry.Line> parts = new ArrayList<>().         for (LineStringBuilder line : lines) {             LineStringBuilder.decomposeGeometry(line.coordinates(false), parts).         }         if (parts.size() == 1) {             return parts.get(0).         }         return new MultiLine(parts).     }     List<org.elasticsearch.geo.geometry.Line> linestrings = new ArrayList<>(lines.size()).     for (int i = 0. i < lines.size(). ++i) {         LineStringBuilder lsb = lines.get(i).         linestrings.add(new org.elasticsearch.geo.geometry.Line(lsb.coordinates.stream().mapToDouble(c -> c.y).toArray(), lsb.coordinates.stream().mapToDouble(c -> c.x).toArray())).     }     return new MultiLine(linestrings). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(lines). }
false;public;1;11;;@Override public boolean equals(Object obj) {     if (this == obj) {         return true.     }     if (obj == null || getClass() != obj.getClass()) {         return false.     }     MultiLineStringBuilder other = (MultiLineStringBuilder) obj.     return Objects.equals(lines, other.lines). }
