commented;modifiers;parameterAmount;loc;comment;code
true;;2;1;/**  * Callback when the global checkpoint is updated or the shard is closed. If the shard is closed, the value of the global checkpoint  * will be set to {@link org.elasticsearch.index.seqno.SequenceNumbers#UNASSIGNED_SEQ_NO} and the exception will be non-null and an  * instance of {@link IndexShardClosedException }. If the listener timed out waiting for notification then the exception will be  * non-null and an instance of {@link TimeoutException}. If the global checkpoint is updated, the exception will be null.  *  * @param globalCheckpoint the updated global checkpoint  * @param e                if non-null, the shard is closed or the listener timed out  */ ;/**  * Callback when the global checkpoint is updated or the shard is closed. If the shard is closed, the value of the global checkpoint  * will be set to {@link org.elasticsearch.index.seqno.SequenceNumbers#UNASSIGNED_SEQ_NO} and the exception will be non-null and an  * instance of {@link IndexShardClosedException }. If the listener timed out waiting for notification then the exception will be  * non-null and an instance of {@link TimeoutException}. If the global checkpoint is updated, the exception will be null.  *  * @param globalCheckpoint the updated global checkpoint  * @param e                if non-null, the shard is closed or the listener timed out  */ void accept(long globalCheckpoint, Exception e).
true;synchronized;3;41;/**  * Add a global checkpoint listener. If the global checkpoint is equal to or above the global checkpoint the listener is waiting for,  * then the listener will be asynchronously notified on the executor used to construct this collection of global checkpoint listeners.  * If the shard is closed then the listener will be asynchronously notified on the executor used to construct this collection of global  * checkpoint listeners. The listener will only be notified of at most one event, either the global checkpoint is updated above the  * global checkpoint the listener is waiting for, or the shard is closed. A listener must re-register after one of these events to  * receive subsequent events. Callers may add a timeout to be notified after if the timeout elapses. In this case, the listener will be  * notified with a {@link TimeoutException}. Passing null fo the timeout means no timeout will be associated to the listener.  *  * @param waitingForGlobalCheckpoint the current global checkpoint known to the listener  * @param listener                   the listener  * @param timeout                    the listener timeout, or null if no timeout  */ ;/**  * Add a global checkpoint listener. If the global checkpoint is equal to or above the global checkpoint the listener is waiting for,  * then the listener will be asynchronously notified on the executor used to construct this collection of global checkpoint listeners.  * If the shard is closed then the listener will be asynchronously notified on the executor used to construct this collection of global  * checkpoint listeners. The listener will only be notified of at most one event, either the global checkpoint is updated above the  * global checkpoint the listener is waiting for, or the shard is closed. A listener must re-register after one of these events to  * receive subsequent events. Callers may add a timeout to be notified after if the timeout elapses. In this case, the listener will be  * notified with a {@link TimeoutException}. Passing null fo the timeout means no timeout will be associated to the listener.  *  * @param waitingForGlobalCheckpoint the current global checkpoint known to the listener  * @param listener                   the listener  * @param timeout                    the listener timeout, or null if no timeout  */ synchronized void add(final long waitingForGlobalCheckpoint, final GlobalCheckpointListener listener, final TimeValue timeout) {     if (closed) {         executor.execute(() -> notifyListener(listener, UNASSIGNED_SEQ_NO, new IndexShardClosedException(shardId))).         return.     }     if (lastKnownGlobalCheckpoint >= waitingForGlobalCheckpoint) {         // notify directly         executor.execute(() -> notifyListener(listener, lastKnownGlobalCheckpoint, null)).     } else {         if (timeout == null) {             listeners.put(listener, Tuple.tuple(waitingForGlobalCheckpoint, null)).         } else {             listeners.put(listener, Tuple.tuple(waitingForGlobalCheckpoint, scheduler.schedule(() -> {                 final boolean removed.                 synchronized (this) {                     /*                                                  * We know that this listener has a timeout associated with it (otherwise we would not be                                                  * here) so the future component of the return value from remove being null is an indication                                                  * that we are not in the map. This can happen if a notification collected us into listeners                                                  * to be notified and removed us from the map, and then our scheduled execution occurred                                                  * before we could be cancelled by the notification. In this case, our listener here would                                                  * not be in the map and we should not fire the timeout logic.                                                  */                     removed = listeners.remove(listener) != null.                 }                 if (removed) {                     final TimeoutException e = new TimeoutException(timeout.getStringRep()).                     logger.trace("global checkpoint listener timed out", e).                     executor.execute(() -> notifyListener(listener, UNASSIGNED_SEQ_NO, e)).                 }             }, timeout.nanos(), TimeUnit.NANOSECONDS))).         }     } }
false;public,synchronized;0;8;;@Override public synchronized void close() throws IOException {     if (closed) {         assert listeners.isEmpty() : listeners.     }     closed = true.     notifyListeners(UNASSIGNED_SEQ_NO, new IndexShardClosedException(shardId)). }
true;synchronized;0;3;/**  * The number of listeners currently pending for notification.  *  * @return the number of listeners pending notification  */ ;/**  * The number of listeners currently pending for notification.  *  * @return the number of listeners pending notification  */ synchronized int pendingListeners() {     return listeners.size(). }
true;synchronized;1;3;/**  * The scheduled future for a listener that has a timeout associated with it, otherwise null.  *  * @param listener the listener to get the scheduled future for  * @return a scheduled future representing the timeout future for the listener, otherwise null  */ ;/**  * The scheduled future for a listener that has a timeout associated with it, otherwise null.  *  * @param listener the listener to get the scheduled future for  * @return a scheduled future representing the timeout future for the listener, otherwise null  */ synchronized ScheduledFuture<?> getTimeoutFuture(final GlobalCheckpointListener listener) {     return listeners.get(listener).v2(). }
true;synchronized;1;8;/**  * Invoke to notify all registered listeners of an updated global checkpoint.  *  * @param globalCheckpoint the updated global checkpoint  */ ;/**  * Invoke to notify all registered listeners of an updated global checkpoint.  *  * @param globalCheckpoint the updated global checkpoint  */ synchronized void globalCheckpointUpdated(final long globalCheckpoint) {     assert globalCheckpoint >= NO_OPS_PERFORMED.     assert globalCheckpoint > lastKnownGlobalCheckpoint : "updated global checkpoint [" + globalCheckpoint + "]" + " is not more than the last known global checkpoint [" + lastKnownGlobalCheckpoint + "]".     lastKnownGlobalCheckpoint = globalCheckpoint.     notifyListeners(globalCheckpoint, null). }
false;private;2;30;;private void notifyListeners(final long globalCheckpoint, final IndexShardClosedException e) {     assert Thread.holdsLock(this) : Thread.currentThread().     assertNotification(globalCheckpoint, e).     final Map<GlobalCheckpointListener, Tuple<Long, ScheduledFuture<?>>> listenersToNotify.     if (globalCheckpoint != UNASSIGNED_SEQ_NO) {         listenersToNotify = listeners.entrySet().stream().filter(entry -> entry.getValue().v1() <= globalCheckpoint).collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue)).         listenersToNotify.keySet().forEach(listeners::remove).     } else {         listenersToNotify = new HashMap<>(listeners).         listeners.clear().     }     if (listenersToNotify.isEmpty() == false) {         executor.execute(() -> listenersToNotify.forEach((listener, t) -> {             /*                                  * We do not want to interrupt any timeouts that fired, these will detect that the listener has been                                  * notified and not trigger the timeout.                                  */             FutureUtils.cancel(t.v2()).             notifyListener(listener, globalCheckpoint, e).         })).     } }
false;private;3;19;;private void notifyListener(final GlobalCheckpointListener listener, final long globalCheckpoint, final Exception e) {     assertNotification(globalCheckpoint, e).     try {         listener.accept(globalCheckpoint, e).     } catch (final Exception caught) {         if (globalCheckpoint != UNASSIGNED_SEQ_NO) {             logger.warn(new ParameterizedMessage("error notifying global checkpoint listener of updated global checkpoint [{}]", globalCheckpoint), caught).         } else if (e instanceof IndexShardClosedException) {             logger.warn("error notifying global checkpoint listener of closed shard", caught).         } else {             logger.warn("error notifying global checkpoint listener of timeout", caught).         }     } }
false;private;2;11;;private void assertNotification(final long globalCheckpoint, final Exception e) {     if (Assertions.ENABLED) {         assert globalCheckpoint >= UNASSIGNED_SEQ_NO : globalCheckpoint.         if (globalCheckpoint != UNASSIGNED_SEQ_NO) {             assert e == null : e.         } else {             assert e != null.             assert e instanceof IndexShardClosedException || e instanceof TimeoutException : e.         }     } }
