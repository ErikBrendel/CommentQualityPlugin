commented;modifiers;parameterAmount;loc;comment;code
false;public;3;8;;@Override public void prepareForTranslogOperations(boolean fileBasedRecovery, int totalTranslogOps, ActionListener<Void> listener) {     transportService.submitRequest(targetNode, PeerRecoveryTargetService.Actions.PREPARE_TRANSLOG, new RecoveryPrepareForTranslogOperationsRequest(recoveryId, shardId, totalTranslogOps, fileBasedRecovery), TransportRequestOptions.builder().withTimeout(recoverySettings.internalActionTimeout()).build(), new ActionListenerResponseHandler<>(ActionListener.wrap(r -> listener.onResponse(null), listener::onFailure), in -> TransportResponse.Empty.INSTANCE, ThreadPool.Names.GENERIC)). }
false;public;2;8;;@Override public void finalizeRecovery(final long globalCheckpoint, final ActionListener<Void> listener) {     transportService.submitRequest(targetNode, PeerRecoveryTargetService.Actions.FINALIZE, new RecoveryFinalizeRecoveryRequest(recoveryId, shardId, globalCheckpoint), TransportRequestOptions.builder().withTimeout(recoverySettings.internalActionLongTimeout()).build(), new ActionListenerResponseHandler<>(ActionListener.wrap(r -> listener.onResponse(null), listener::onFailure), in -> TransportResponse.Empty.INSTANCE, ThreadPool.Names.GENERIC)). }
false;public;1;7;;@Override public void ensureClusterStateVersion(long clusterStateVersion) {     transportService.submitRequest(targetNode, PeerRecoveryTargetService.Actions.WAIT_CLUSTERSTATE, new RecoveryWaitForClusterStateRequest(recoveryId, shardId, clusterStateVersion), TransportRequestOptions.builder().withTimeout(recoverySettings.internalActionLongTimeout()).build(), EmptyTransportResponseHandler.INSTANCE_SAME).txGet(). }
false;public;1;9;;@Override public void handoffPrimaryContext(final ReplicationTracker.PrimaryContext primaryContext) {     transportService.submitRequest(targetNode, PeerRecoveryTargetService.Actions.HANDOFF_PRIMARY_CONTEXT, new RecoveryHandoffPrimaryContextRequest(recoveryId, shardId, primaryContext), TransportRequestOptions.builder().withTimeout(recoverySettings.internalActionTimeout()).build(), EmptyTransportResponseHandler.INSTANCE_SAME).txGet(). }
false;public;6;20;;@Override public void indexTranslogOperations(final List<Translog.Operation> operations, final int totalTranslogOps, final long maxSeenAutoIdTimestampOnPrimary, final long maxSeqNoOfDeletesOrUpdatesOnPrimary, final RetentionLeases retentionLeases, final ActionListener<Long> listener) {     final RecoveryTranslogOperationsRequest request = new RecoveryTranslogOperationsRequest(recoveryId, shardId, operations, totalTranslogOps, maxSeenAutoIdTimestampOnPrimary, maxSeqNoOfDeletesOrUpdatesOnPrimary, retentionLeases).     transportService.submitRequest(targetNode, PeerRecoveryTargetService.Actions.TRANSLOG_OPS, request, translogOpsRequestOptions, new ActionListenerResponseHandler<>(ActionListener.wrap(r -> listener.onResponse(r.localCheckpoint), listener::onFailure), RecoveryTranslogOperationsResponse::new, ThreadPool.Names.GENERIC)). }
false;public;5;11;;@Override public void receiveFileInfo(List<String> phase1FileNames, List<Long> phase1FileSizes, List<String> phase1ExistingFileNames, List<Long> phase1ExistingFileSizes, int totalTranslogOps) {     RecoveryFilesInfoRequest recoveryInfoFilesRequest = new RecoveryFilesInfoRequest(recoveryId, shardId, phase1FileNames, phase1FileSizes, phase1ExistingFileNames, phase1ExistingFileSizes, totalTranslogOps).     transportService.submitRequest(targetNode, PeerRecoveryTargetService.Actions.FILES_INFO, recoveryInfoFilesRequest, TransportRequestOptions.builder().withTimeout(recoverySettings.internalActionTimeout()).build(), EmptyTransportResponseHandler.INSTANCE_SAME).txGet(). }
false;public;2;7;;@Override public void cleanFiles(int totalTranslogOps, Store.MetadataSnapshot sourceMetaData) throws IOException {     transportService.submitRequest(targetNode, PeerRecoveryTargetService.Actions.CLEAN_FILES, new RecoveryCleanFilesRequest(recoveryId, shardId, sourceMetaData, totalTranslogOps), TransportRequestOptions.builder().withTimeout(recoverySettings.internalActionTimeout()).build(), EmptyTransportResponseHandler.INSTANCE_SAME).txGet(). }
false;public;6;35;;@Override public void writeFileChunk(StoreFileMetaData fileMetaData, long position, BytesReference content, boolean lastChunk, int totalTranslogOps, ActionListener<Void> listener) {     // Pause using the rate limiter, if desired, to throttle the recovery     final long throttleTimeInNanos.     // always fetch the ratelimiter - it might be updated in real-time on the recovery settings     final RateLimiter rl = recoverySettings.rateLimiter().     if (rl != null) {         long bytes = bytesSinceLastPause.addAndGet(content.length()).         if (bytes > rl.getMinPauseCheckBytes()) {             // Time to pause             bytesSinceLastPause.addAndGet(-bytes).             try {                 throttleTimeInNanos = rl.pause(bytes).                 onSourceThrottle.accept(throttleTimeInNanos).             } catch (IOException e) {                 throw new ElasticsearchException("failed to pause recovery", e).             }         } else {             throttleTimeInNanos = 0.         }     } else {         throttleTimeInNanos = 0.     }     transportService.submitRequest(targetNode, PeerRecoveryTargetService.Actions.FILE_CHUNK, new RecoveryFileChunkRequest(recoveryId, shardId, fileMetaData, position, content, lastChunk, totalTranslogOps, /* we send estimateTotalOperations with every request since we collect stats on the target and that way we can                  * see how many translog ops we accumulate while copying files across the network. A future optimization                  * would be in to restart file copy again (new deltas) if we have too many translog ops are piling up.                  */     throttleTimeInNanos), fileChunkRequestOptions, new ActionListenerResponseHandler<>(ActionListener.wrap(r -> listener.onResponse(null), listener::onFailure), in -> TransportResponse.Empty.INSTANCE)). }
