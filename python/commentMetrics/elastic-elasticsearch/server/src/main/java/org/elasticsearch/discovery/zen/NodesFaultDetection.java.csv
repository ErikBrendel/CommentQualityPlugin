commented;modifiers;parameterAmount;loc;comment;code
false;public;2;1;;public void onNodeFailure(DiscoveryNode node, String reason) { }
false;public;1;1;;public void onPingReceived(PingRequest pingRequest) { }
false;public;1;3;;public void setLocalNode(DiscoveryNode localNode) {     this.localNode = localNode. }
false;public;1;3;;public void addListener(Listener listener) {     listeners.add(listener). }
false;public;1;3;;public void removeListener(Listener listener) {     listeners.remove(listener). }
true;public;0;3;/**  * Gets the current set of nodes involved in node fault detection.  * NB: For testing purposes.  */ ;/**  * Gets the current set of nodes involved in node fault detection.  * NB: For testing purposes.  */ public Set<DiscoveryNode> getNodes() {     return Collections.unmodifiableSet(nodesFD.keySet()). }
true;public;1;23;/**  * make sure that nodes in clusterState are pinged. Any pinging to nodes which are not  * part of the cluster will be stopped  */ ;/**  * make sure that nodes in clusterState are pinged. Any pinging to nodes which are not  * part of the cluster will be stopped  */ public void updateNodesAndPing(ClusterState clusterState) {     // remove any nodes we don't need, this will cause their FD to stop     for (DiscoveryNode monitoredNode : nodesFD.keySet()) {         if (!clusterState.nodes().nodeExists(monitoredNode)) {             nodesFD.remove(monitoredNode).         }     }     for (DiscoveryNode node : clusterState.nodes()) {         if (node.equals(localNode)) {             // no need to monitor the local node             continue.         }         if (!nodesFD.containsKey(node)) {             NodeFD fd = new NodeFD(node).             // it's OK to overwrite an existing nodeFD - it will just stop and the new one will pick things up.             nodesFD.put(node, fd).             // we use schedule with a 0 time value to run the pinger on the pool as it will run on later             threadPool.schedule(fd, TimeValue.timeValueMillis(0), ThreadPool.Names.SAME).         }     } }
true;public;0;4;/**  * stops all pinging *  */ ;/**  * stops all pinging *  */ public NodesFaultDetection stop() {     nodesFD.clear().     return this. }
false;public;0;5;;@Override public void close() {     super.close().     stop(). }
false;protected;1;24;;@Override protected void handleTransportDisconnect(DiscoveryNode node) {     NodeFD nodeFD = nodesFD.remove(node).     if (nodeFD == null) {         return.     }     if (connectOnNetworkDisconnect) {         NodeFD fd = new NodeFD(node).         try {             transportService.connectToNode(node).             nodesFD.put(node, fd).             // we use schedule with a 0 time value to run the pinger on the pool as it will run on later             threadPool.schedule(fd, TimeValue.timeValueMillis(0), ThreadPool.Names.SAME).         } catch (Exception e) {             logger.trace("[node  ] [{}] transport disconnected (with verified connect)", node).             // clean up if needed, just to be safe..             nodesFD.remove(node, fd).             notifyNodeFailure(node, "transport disconnected (with verified connect)").         }     } else {         logger.trace("[node  ] [{}] transport disconnected", node).         notifyNodeFailure(node, "transport disconnected").     } }
false;public;0;6;;@Override public void run() {     for (Listener listener : listeners) {         listener.onNodeFailure(node, reason).     } }
false;private;2;15;;private void notifyNodeFailure(final DiscoveryNode node, final String reason) {     try {         threadPool.generic().execute(new Runnable() {              @Override             public void run() {                 for (Listener listener : listeners) {                     listener.onNodeFailure(node, reason).                 }             }         }).     } catch (EsRejectedExecutionException ex) {         logger.trace(() -> new ParameterizedMessage("[node  ] [{}] ignoring node failure (reason [{}]). Local node is shutting down", node, reason), ex).     } }
false;public;0;6;;@Override public void run() {     for (Listener listener : listeners) {         listener.onPingReceived(pingRequest).     } }
false;private;1;12;;private void notifyPingReceived(final PingRequest pingRequest) {     threadPool.generic().execute(new Runnable() {          @Override         public void run() {             for (Listener listener : listeners) {                 listener.onPingReceived(pingRequest).             }         }     }). }
false;private;0;3;;private boolean running() {     return NodeFD.this.equals(nodesFD.get(node)). }
false;private;0;3;;private PingRequest newPingRequest() {     return new PingRequest(node, clusterName, localNode, clusterStateSupplier.get().version()). }
false;public;1;4;;@Override public PingResponse read(StreamInput in) throws IOException {     return new PingResponse(in). }
false;public;1;8;;@Override public void handleResponse(PingResponse response) {     if (!running()) {         return.     }     retryCount = 0.     threadPool.schedule(NodeFD.this, pingInterval, ThreadPool.Names.SAME). }
false;public;1;26;;@Override public void handleException(TransportException exp) {     if (!running()) {         return.     }     if (exp instanceof ConnectTransportException || exp.getCause() instanceof ConnectTransportException) {         handleTransportDisconnect(node).         return.     }     retryCount++.     logger.trace(() -> new ParameterizedMessage("[node  ] failed to ping [{}], retry [{}] out of [{}]", node, retryCount, pingRetryCount), exp).     if (retryCount >= pingRetryCount) {         logger.debug("[node  ] failed to ping [{}], tried [{}] times, each with  maximum [{}] timeout", node, pingRetryCount, pingRetryTimeout).         // not good, failure         if (nodesFD.remove(node, NodeFD.this)) {             notifyNodeFailure(node, "failed to ping, tried [" + pingRetryCount + "] times, each with maximum [" + pingRetryTimeout + "] timeout").         }     } else {         // resend the request, not reschedule, rely on send timeout         transportService.sendRequest(node, PING_ACTION_NAME, newPingRequest(), options, this).     } }
false;public;0;4;;@Override public String executor() {     return ThreadPool.Names.SAME. }
false;public;0;56;;@Override public void run() {     if (!running()) {         return.     }     final TransportRequestOptions options = TransportRequestOptions.builder().withType(TransportRequestOptions.Type.PING).withTimeout(pingRetryTimeout).build().     transportService.sendRequest(node, PING_ACTION_NAME, newPingRequest(), options, new TransportResponseHandler<PingResponse>() {          @Override         public PingResponse read(StreamInput in) throws IOException {             return new PingResponse(in).         }          @Override         public void handleResponse(PingResponse response) {             if (!running()) {                 return.             }             retryCount = 0.             threadPool.schedule(NodeFD.this, pingInterval, ThreadPool.Names.SAME).         }          @Override         public void handleException(TransportException exp) {             if (!running()) {                 return.             }             if (exp instanceof ConnectTransportException || exp.getCause() instanceof ConnectTransportException) {                 handleTransportDisconnect(node).                 return.             }             retryCount++.             logger.trace(() -> new ParameterizedMessage("[node  ] failed to ping [{}], retry [{}] out of [{}]", node, retryCount, pingRetryCount), exp).             if (retryCount >= pingRetryCount) {                 logger.debug("[node  ] failed to ping [{}], tried [{}] times, each with  maximum [{}] timeout", node, pingRetryCount, pingRetryTimeout).                 // not good, failure                 if (nodesFD.remove(node, NodeFD.this)) {                     notifyNodeFailure(node, "failed to ping, tried [" + pingRetryCount + "] times, each with maximum [" + pingRetryTimeout + "] timeout").                 }             } else {                 // resend the request, not reschedule, rely on send timeout                 transportService.sendRequest(node, PING_ACTION_NAME, newPingRequest(), options, this).             }         }          @Override         public String executor() {             return ThreadPool.Names.SAME.         }     }). }
false;public;3;19;;@Override public void messageReceived(PingRequest request, TransportChannel channel, Task task) throws Exception {     // this can happen when a kill -9 is sent, and another node is started using the same port     if (!localNode.equals(request.targetNode())) {         throw new IllegalStateException("Got pinged as node " + request.targetNode() + "], but I am node " + localNode).     }     // PingRequest will have clusterName set to null if it came from a node of version <1.4.0     if (request.clusterName != null && !request.clusterName.equals(clusterName)) {         // Don't introduce new exception for bwc reasons         throw new IllegalStateException("Got pinged with cluster name [" + request.clusterName + "], but I'm part of cluster [" + clusterName + "]").     }     notifyPingReceived(request).     channel.sendResponse(new PingResponse()). }
false;public;0;3;;public DiscoveryNode targetNode() {     return targetNode. }
false;public;0;3;;public ClusterName clusterName() {     return clusterName. }
false;public;0;3;;public DiscoveryNode masterNode() {     return masterNode. }
false;public;0;3;;public long clusterStateVersion() {     return clusterStateVersion. }
false;public;1;8;;@Override public void readFrom(StreamInput in) throws IOException {     super.readFrom(in).     targetNode = new DiscoveryNode(in).     clusterName = new ClusterName(in).     masterNode = new DiscoveryNode(in).     clusterStateVersion = in.readLong(). }
false;public;1;8;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     targetNode.writeTo(out).     clusterName.writeTo(out).     masterNode.writeTo(out).     out.writeLong(clusterStateVersion). }
