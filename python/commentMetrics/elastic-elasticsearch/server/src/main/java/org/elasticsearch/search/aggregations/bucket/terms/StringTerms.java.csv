commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;4;;@Override protected void writeTermTo(StreamOutput out) throws IOException {     out.writeBytesRef(termBytes). }
false;public;0;4;;@Override public Object getKey() {     return getKeyAsString(). }
true;public;0;12;// this method is needed for scripted numeric aggs ;// this method is needed for scripted numeric aggs @Override public Number getKeyAsNumber() {     /*              * If the term is a long greater than 2^52 then parsing as a double would lose accuracy. Therefore, we first parse as a long and              * if this fails then we attempt to parse the term as a double.              */     try {         return Long.parseLong(termBytes.utf8ToString()).     } catch (final NumberFormatException ignored) {         return Double.parseDouble(termBytes.utf8ToString()).     } }
false;public;0;4;;@Override public String getKeyAsString() {     return format.format(termBytes).toString(). }
false;public;1;4;;@Override public int compareKey(Bucket other) {     return termBytes.compareTo(other.termBytes). }
false;;3;4;;@Override Bucket newBucket(long docCount, InternalAggregations aggs, long docCountError) {     return new Bucket(termBytes, docCount, aggs, showDocCountError, docCountError, format). }
false;protected,final;1;4;;@Override protected final XContentBuilder keyToXContent(XContentBuilder builder) throws IOException {     return builder.field(CommonFields.KEY.getPreferredName(), getKeyAsString()). }
false;public;1;4;;@Override public boolean equals(Object obj) {     return super.equals(obj) && Objects.equals(termBytes, ((Bucket) obj).termBytes). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(super.hashCode(), termBytes). }
false;public;0;4;;@Override public String getWriteableName() {     return NAME. }
false;public;1;5;;@Override public StringTerms create(List<Bucket> buckets) {     return new StringTerms(name, order, requiredSize, minDocCount, pipelineAggregators(), metaData, format, shardSize, showTermDocCountError, otherDocCount, buckets, docCountError). }
false;public;2;5;;@Override public Bucket createBucket(InternalAggregations aggregations, Bucket prototype) {     return new Bucket(prototype.termBytes, prototype.docCount, aggregations, prototype.showDocCountError, prototype.docCountError, prototype.format). }
false;protected;4;5;;@Override protected StringTerms create(String name, List<Bucket> buckets, long docCountError, long otherDocCount) {     return new StringTerms(name, order, requiredSize, minDocCount, pipelineAggregators(), getMetaData(), format, shardSize, showTermDocCountError, otherDocCount, buckets, docCountError). }
false;protected;1;4;;@Override protected Bucket[] createBucketsArray(int size) {     return new Bucket[size]. }
