commented;modifiers;parameterAmount;loc;comment;code
false;protected;5;30;;@Override protected Aggregator doCreateInternal(ValuesSource valuesSource, Aggregator parent, boolean collectsFromSingleBucket, List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData) throws IOException {     if (valuesSource instanceof ValuesSource.Numeric) {         return new DiversifiedNumericSamplerAggregator(name, shardSize, factories, context, parent, pipelineAggregators, metaData, (Numeric) valuesSource, maxDocsPerValue).     }     if (valuesSource instanceof ValuesSource.Bytes) {         ExecutionMode execution = null.         if (executionHint != null) {             execution = ExecutionMode.fromString(executionHint).         }         // it         if (execution == null) {             execution = ExecutionMode.GLOBAL_ORDINALS.         }         if ((execution.needsGlobalOrdinals()) && (!(valuesSource instanceof ValuesSource.Bytes.WithOrdinals))) {             execution = ExecutionMode.MAP.         }         return execution.create(name, factories, shardSize, maxDocsPerValue, valuesSource, context, parent, pipelineAggregators, metaData).     }     throw new AggregationExecutionException("Sampler aggregation cannot be applied to field [" + config.fieldContext().field() + "]. It can only be applied to numeric or string fields."). }
false;public;0;4;;@Override public InternalAggregation buildEmptyAggregation() {     return aggregation. }
false;protected;3;12;;@Override protected Aggregator createUnmapped(Aggregator parent, List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData) throws IOException {     final UnmappedSampler aggregation = new UnmappedSampler(name, pipelineAggregators, metaData).     return new NonCollectingAggregator(name, context, parent, factories, pipelineAggregators, metaData) {          @Override         public InternalAggregation buildEmptyAggregation() {             return aggregation.         }     }. }
