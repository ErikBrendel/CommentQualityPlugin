commented;modifiers;parameterAmount;loc;comment;code
false;private,static;2;10;;private static DiscoveryNode maybeAddProxyAddress(String proxyAddress, DiscoveryNode node) {     if (proxyAddress == null || proxyAddress.isEmpty()) {         return node.     } else {         // resovle proxy address lazy here         InetSocketAddress proxyInetAddress = RemoteClusterAware.parseSeedAddress(proxyAddress).         return new DiscoveryNode(node.getName(), node.getId(), node.getEphemeralId(), node.getHostName(), node.getHostAddress(), new TransportAddress(proxyInetAddress), node.getAttributes(), node.getRoles(), node.getVersion()).     } }
true;synchronized;3;8;/**  * Updates the list of seed nodes for this cluster connection  */ ;/**  * Updates the list of seed nodes for this cluster connection  */ synchronized void updateSeedNodes(final String proxyAddress, final List<Tuple<String, Supplier<DiscoveryNode>>> seedNodes, final ActionListener<Void> connectListener) {     this.seedNodes = Collections.unmodifiableList(new ArrayList<>(seedNodes)).     this.proxyAddress = proxyAddress.     connectHandler.connect(connectListener). }
true;;1;3;/**  * Updates the skipUnavailable flag that can be dynamically set for each remote cluster  */ ;/**  * Updates the skipUnavailable flag that can be dynamically set for each remote cluster  */ void updateSkipUnavailable(boolean skipUnavailable) {     this.skipUnavailable = skipUnavailable. }
true;;0;3;/**  * Returns whether this cluster is configured to be skipped when unavailable  */ ;/**  * Returns whether this cluster is configured to be skipped when unavailable  */ boolean isSkipUnavailable() {     return skipUnavailable. }
false;public;1;8;;@Override public void onNodeDisconnected(DiscoveryNode node) {     boolean remove = connectedNodes.remove(node).     if (remove && connectedNodes.size() < maxNumRemoteConnections) {         // try to reconnect and fill up the slot of the disconnected node         connectHandler.forceConnect().     } }
true;;1;7;/**  * Ensures that this cluster is connected. If the cluster is connected this operation  * will invoke the listener immediately.  */ ;/**  * Ensures that this cluster is connected. If the cluster is connected this operation  * will invoke the listener immediately.  */ void ensureConnected(ActionListener<Void> voidActionListener) {     if (connectedNodes.size() == 0) {         connectHandler.connect(voidActionListener).     } else {         voidActionListener.onResponse(null).     } }
false;public;1;6;;@Override public ClusterStateResponse read(StreamInput in) throws IOException {     ClusterStateResponse response = new ClusterStateResponse().     response.readFrom(in).     return response. }
false;public;1;5;;@Override public void handleResponse(ClusterStateResponse response) {     DiscoveryNodes nodes = response.getState().nodes().     listener.onResponse(nodes::get). }
false;public;1;4;;@Override public void handleException(TransportException exp) {     listener.onFailure(exp). }
false;public;0;4;;@Override public String executor() {     return ThreadPool.Names.SAME. }
true;;1;46;/**  * Collects all nodes on the connected cluster and returns / passes a nodeID to {@link DiscoveryNode} lookup function  * that returns <code>null</code> if the node ID is not found.  */ ;/**  * Collects all nodes on the connected cluster and returns / passes a nodeID to {@link DiscoveryNode} lookup function  * that returns <code>null</code> if the node ID is not found.  */ void collectNodes(ActionListener<Function<String, DiscoveryNode>> listener) {     Runnable runnable = () -> {         final ClusterStateRequest request = new ClusterStateRequest().         request.clear().         request.nodes(true).         // run this on the node that gets the request it's as good as any other         request.local(true).         final DiscoveryNode node = getAnyConnectedNode().         Transport.Connection connection = connectionManager.getConnection(node).         transportService.sendRequest(connection, ClusterStateAction.NAME, request, TransportRequestOptions.EMPTY, new TransportResponseHandler<ClusterStateResponse>() {              @Override             public ClusterStateResponse read(StreamInput in) throws IOException {                 ClusterStateResponse response = new ClusterStateResponse().                 response.readFrom(in).                 return response.             }              @Override             public void handleResponse(ClusterStateResponse response) {                 DiscoveryNodes nodes = response.getState().nodes().                 listener.onResponse(nodes::get).             }              @Override             public void handleException(TransportException exp) {                 listener.onFailure(exp).             }              @Override             public String executor() {                 return ThreadPool.Names.SAME.             }         }).     }.     try {         // just in case if we are not connected for some reason we try to connect and if we fail we have to notify the listener         // this will cause some back pressure on the search end and eventually will cause rejections but that's fine         // we can't proceed with a search on a cluster level.         // in the future we might want to just skip the remote nodes in such a case but that can already be implemented on the         // caller end since they provide the listener.         ensureConnected(ActionListener.wrap((x) -> runnable.run(), listener::onFailure)).     } catch (Exception ex) {         listener.onFailure(ex).     } }
true;;1;8;/**  * Returns a connection to the remote cluster, preferably a direct connection to the provided {@link DiscoveryNode}.  * If such node is not connected, the returned connection will be a proxy connection that redirects to it.  */ ;/**  * Returns a connection to the remote cluster, preferably a direct connection to the provided {@link DiscoveryNode}.  * If such node is not connected, the returned connection will be a proxy connection that redirects to it.  */ Transport.Connection getConnection(DiscoveryNode remoteClusterNode) {     if (connectionManager.nodeConnected(remoteClusterNode)) {         return connectionManager.getConnection(remoteClusterNode).     }     DiscoveryNode discoveryNode = getAnyConnectedNode().     Transport.Connection connection = connectionManager.getConnection(discoveryNode).     return new ProxyConnection(connection, remoteClusterNode). }
false;public;0;4;;@Override public DiscoveryNode getNode() {     return targetNode. }
false;public;4;6;;@Override public void sendRequest(long requestId, String action, TransportRequest request, TransportRequestOptions options) throws IOException, TransportException {     proxyConnection.sendRequest(requestId, TransportActionProxy.getProxyAction(action), TransportActionProxy.wrapRequest(targetNode, request), options). }
false;public;0;4;;@Override public void close() {     assert false : "proxy connections must not be closed". }
false;public;1;4;;@Override public void addCloseListener(ActionListener<Void> listener) {     proxyConnection.addCloseListener(listener). }
false;public;0;4;;@Override public boolean isClosed() {     return proxyConnection.isClosed(). }
false;public;0;4;;@Override public Version getVersion() {     return proxyConnection.getVersion(). }
false;;0;3;;Transport.Connection getConnection() {     return connectionManager.getConnection(getAnyConnectedNode()). }
false;public;0;6;;@Override public void close() throws IOException {     IOUtils.close(connectHandler).     // In the ConnectionManager we wait on connections being closed.     threadPool.generic().execute(connectionManager::close). }
false;public;0;3;;public boolean isClosed() {     return connectHandler.isClosed(). }
false;public;0;3;;public String getProxyAddress() {     return proxyAddress. }
false;public;0;3;;public List<Tuple<String, Supplier<DiscoveryNode>>> getSeedNodes() {     return seedNodes. }
true;;0;3;/**  * Triggers a connect round iff there are pending requests queued up and if there is no  * connect round currently running.  */ ;/**  * Triggers a connect round iff there are pending requests queued up and if there is no  * connect round currently running.  */ void maybeConnect() {     connect(null). }
true;;1;3;/**  * Triggers a connect round unless there is one running already. If there is a connect round running, the listener will either  * be queued or rejected and failed.  */ ;/**  * Triggers a connect round unless there is one running already. If there is a connect round running, the listener will either  * be queued or rejected and failed.  */ void connect(ActionListener<Void> connectListener) {     connect(connectListener, false). }
true;;0;3;/**  * Triggers a connect round unless there is one already running. In contrast to {@link #maybeConnect()} will this method also  * trigger a connect round if there is no listener queued up.  */ ;/**  * Triggers a connect round unless there is one already running. In contrast to {@link #maybeConnect()} will this method also  * trigger a connect round if there is no listener queued up.  */ void forceConnect() {     connect(null, true). }
false;private;2;30;;private void connect(ActionListener<Void> connectListener, boolean forceRun) {     final boolean runConnect.     final Collection<ActionListener<Void>> toNotify.     final ActionListener<Void> listener = connectListener == null ? null : ContextPreservingActionListener.wrapPreservingContext(connectListener, threadPool.getThreadContext()).     synchronized (queue) {         if (listener != null && queue.offer(listener) == false) {             listener.onFailure(new RejectedExecutionException("connect queue is full")).             return.         }         if (forceRun == false && queue.isEmpty()) {             return.         }         runConnect = running.tryAcquire().         if (runConnect) {             toNotify = new ArrayList<>().             queue.drainTo(toNotify).             if (closed.get()) {                 running.release().                 ActionListener.onFailure(toNotify, new AlreadyClosedException("connect handler is already closed")).                 return.             }         } else {             toNotify = Collections.emptyList().         }     }     if (runConnect) {         forkConnect(toNotify).     } }
false;public;1;11;;@Override public void onFailure(Exception e) {     synchronized (queue) {         running.release().     }     try {         ActionListener.onFailure(toNotify, e).     } finally {         maybeConnect().     } }
false;protected;0;24;;@Override protected void doRun() {     ActionListener<Void> listener = ActionListener.wrap((x) -> {         synchronized (queue) {             running.release().         }         try {             ActionListener.onResponse(toNotify, x).         } finally {             maybeConnect().         }     }, (e) -> {         synchronized (queue) {             running.release().         }         try {             ActionListener.onFailure(toNotify, e).         } finally {             maybeConnect().         }     }).     collectRemoteNodes(seedNodes.stream().map(Tuple::v2).iterator(), transportService, connectionManager, listener). }
false;private;1;41;;private void forkConnect(final Collection<ActionListener<Void>> toNotify) {     ExecutorService executor = threadPool.executor(ThreadPool.Names.MANAGEMENT).     executor.submit(new AbstractRunnable() {          @Override         public void onFailure(Exception e) {             synchronized (queue) {                 running.release().             }             try {                 ActionListener.onFailure(toNotify, e).             } finally {                 maybeConnect().             }         }          @Override         protected void doRun() {             ActionListener<Void> listener = ActionListener.wrap((x) -> {                 synchronized (queue) {                     running.release().                 }                 try {                     ActionListener.onResponse(toNotify, x).                 } finally {                     maybeConnect().                 }             }, (e) -> {                 synchronized (queue) {                     running.release().                 }                 try {                     ActionListener.onFailure(toNotify, e).                 } finally {                     maybeConnect().                 }             }).             collectRemoteNodes(seedNodes.stream().map(Tuple::v2).iterator(), transportService, connectionManager, listener).         }     }). }
false;private;4;79;;private void collectRemoteNodes(Iterator<Supplier<DiscoveryNode>> seedNodes, final TransportService transportService, final ConnectionManager manager, ActionListener<Void> listener) {     if (Thread.currentThread().isInterrupted()) {         listener.onFailure(new InterruptedException("remote connect thread got interrupted")).     }     try {         if (seedNodes.hasNext()) {             cancellableThreads.executeIO(() -> {                 final DiscoveryNode seedNode = maybeAddProxyAddress(proxyAddress, seedNodes.next().get()).                 logger.debug("[{}] opening connection to seed node: [{}] proxy address: [{}]", clusterAlias, seedNode, proxyAddress).                 final TransportService.HandshakeResponse handshakeResponse.                 ConnectionProfile profile = ConnectionProfile.buildSingleChannelProfile(TransportRequestOptions.Type.REG).                 Transport.Connection connection = manager.openConnection(seedNode, profile).                 boolean success = false.                 try {                     try {                         ConnectionProfile connectionProfile = connectionManager.getConnectionProfile().                         handshakeResponse = transportService.handshake(connection, connectionProfile.getHandshakeTimeout().millis(), (c) -> remoteClusterName.get() == null ? true : c.equals(remoteClusterName.get())).                     } catch (IllegalStateException ex) {                         logger.warn(() -> new ParameterizedMessage("seed node {} cluster name mismatch expected " + "cluster name {}", connection.getNode(), remoteClusterName.get()), ex).                         throw ex.                     }                     final DiscoveryNode handshakeNode = maybeAddProxyAddress(proxyAddress, handshakeResponse.getDiscoveryNode()).                     if (nodePredicate.test(handshakeNode) && connectedNodes.size() < maxNumRemoteConnections) {                         manager.connectToNode(handshakeNode, null, transportService.connectionValidator(handshakeNode)).                         if (remoteClusterName.get() == null) {                             assert handshakeResponse.getClusterName().value() != null.                             remoteClusterName.set(handshakeResponse.getClusterName()).                         }                         connectedNodes.add(handshakeNode).                     }                     ClusterStateRequest request = new ClusterStateRequest().                     request.clear().                     request.nodes(true).                     // here we pass on the connection since we can only close it once the sendRequest returns otherwise                     // due to the async nature (it will return before it's actually sent) this can cause the request to fail                     // due to an already closed connection.                     ThreadPool threadPool = transportService.getThreadPool().                     ThreadContext threadContext = threadPool.getThreadContext().                     TransportService.ContextRestoreResponseHandler<ClusterStateResponse> responseHandler = new TransportService.ContextRestoreResponseHandler<>(threadContext.newRestorableContext(false), new SniffClusterStateResponseHandler(connection, listener, seedNodes, cancellableThreads)).                     try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {                         // we stash any context here since this is an internal execution and should not leak any                         // existing context information.                         threadContext.markAsSystemContext().                         transportService.sendRequest(connection, ClusterStateAction.NAME, request, TransportRequestOptions.EMPTY, responseHandler).                     }                     success = true.                 } finally {                     if (success == false) {                         connection.close().                     }                 }             }).         } else {             listener.onFailure(new IllegalStateException("no seed node left")).         }     } catch (CancellableThreads.ExecutionCancelledException ex) {         logger.warn(() -> new ParameterizedMessage("fetching nodes from external cluster [{}] failed", clusterAlias), ex).         // we got canceled - fail the listener and step out         listener.onFailure(ex).     } catch (ConnectTransportException | IOException | IllegalStateException ex) {         // ISE if we fail the handshake with an version incompatible node         if (seedNodes.hasNext()) {             logger.debug(() -> new ParameterizedMessage("fetching nodes from external cluster [{}] failed moving to next node", clusterAlias), ex).             collectRemoteNodes(seedNodes, transportService, manager, listener).         } else {             logger.warn(() -> new ParameterizedMessage("fetching nodes from external cluster [{}] failed", clusterAlias), ex).             listener.onFailure(ex).         }     } }
false;public;0;13;;@Override public void close() throws IOException {     try {         if (closed.compareAndSet(false, true)) {             cancellableThreads.cancel("connect handler is closed").             // acquire the semaphore to ensure all connections are closed and all thread joined             running.acquire().             running.release().             // now go and notify pending listeners             maybeConnect().         }     } catch (InterruptedException e) {         Thread.currentThread().interrupt().     } }
false;final;0;3;;final boolean isClosed() {     return closed.get(). }
false;public;1;6;;@Override public ClusterStateResponse read(StreamInput in) throws IOException {     ClusterStateResponse response = new ClusterStateResponse().     response.readFrom(in).     return response. }
false;public;1;40;;@Override public void handleResponse(ClusterStateResponse response) {     try {         if (remoteClusterName.get() == null) {             assert response.getClusterName().value() != null.             remoteClusterName.set(response.getClusterName()).         }         try (Closeable theConnection = connection) {             // the connection is unused - see comment in #collectRemoteNodes             // we have to close this connection before we notify listeners - this is mainly needed for test correctness             // since if we do it afterwards we might fail assertions that check if all high level connections are closed.             // from a code correctness perspective we could also close it afterwards. This try/with block will             // maintain the possibly exceptions thrown from within the try block and suppress the ones that are possible thrown             // by closing the connection             cancellableThreads.executeIO(() -> {                 DiscoveryNodes nodes = response.getState().nodes().                 Iterable<DiscoveryNode> nodesIter = nodes.getNodes()::valuesIt.                 for (DiscoveryNode n : nodesIter) {                     DiscoveryNode node = maybeAddProxyAddress(proxyAddress, n).                     if (nodePredicate.test(node) && connectedNodes.size() < maxNumRemoteConnections) {                         try {                             connectionManager.connectToNode(node, null, // noop if node is connected                             transportService.connectionValidator(node)).                             connectedNodes.add(node).                         } catch (ConnectTransportException | IllegalStateException ex) {                             // ISE if we fail the handshake with an version incompatible node                             // fair enough we can't connect just move on                             logger.debug(() -> new ParameterizedMessage("failed to connect to node {}", node), ex).                         }                     }                 }             }).         }         listener.onResponse(null).     } catch (CancellableThreads.ExecutionCancelledException ex) {         // we got canceled - fail the listener and step out         listener.onFailure(ex).     } catch (Exception ex) {         logger.warn(() -> new ParameterizedMessage("fetching nodes from external cluster {} failed", clusterAlias), ex).         collectRemoteNodes(seedNodes, transportService, connectionManager, listener).     } }
false;public;1;10;;@Override public void handleException(TransportException exp) {     logger.warn(() -> new ParameterizedMessage("fetching nodes from external cluster {} failed", clusterAlias), exp).     try {         IOUtils.closeWhileHandlingException(connection).     } finally {         // once the connection is closed lets try the next node         collectRemoteNodes(seedNodes, transportService, connectionManager, listener).     } }
false;public;0;4;;@Override public String executor() {     return ThreadPool.Names.MANAGEMENT. }
false;;0;4;;boolean assertNoRunningConnections() {     // for testing only     assert connectHandler.running.availablePermits() == 1.     return true. }
false;;1;3;;boolean isNodeConnected(final DiscoveryNode node) {     return connectedNodes.contains(node). }
false;;0;3;;DiscoveryNode getAnyConnectedNode() {     return connectedNodes.getAny(). }
false;;1;3;;void addConnectedNode(DiscoveryNode node) {     connectedNodes.add(node). }
true;public;0;9;/**  * Get the information about remote nodes to be rendered on {@code _remote/info} requests.  */ ;/**  * Get the information about remote nodes to be rendered on {@code _remote/info} requests.  */ public RemoteConnectionInfo getConnectionInfo() {     return new RemoteConnectionInfo(clusterAlias, seedNodes.stream().map(Tuple::v1).collect(Collectors.toList()), maxNumRemoteConnections, connectedNodes.size(), initialConnectionTimeout, skipUnavailable). }
false;;0;3;;int getNumNodesConnected() {     return connectedNodes.size(). }
false;public,synchronized;0;8;;public synchronized DiscoveryNode getAny() {     ensureIteratorAvailable().     if (currentIterator.hasNext()) {         return currentIterator.next().     } else {         throw new NoSuchRemoteClusterException(clusterAlias).     } }
false;synchronized;1;7;;synchronized boolean remove(DiscoveryNode node) {     final boolean setRemoval = nodeSet.remove(node).     if (setRemoval) {         currentIterator = null.     }     return setRemoval. }
false;synchronized;1;7;;synchronized boolean add(DiscoveryNode node) {     final boolean added = nodeSet.add(node).     if (added) {         currentIterator = null.     }     return added. }
false;synchronized;0;3;;synchronized int size() {     return nodeSet.size(). }
false;synchronized;1;3;;synchronized boolean contains(DiscoveryNode node) {     return nodeSet.contains(node). }
false;private,synchronized;0;8;;private synchronized void ensureIteratorAvailable() {     if (currentIterator == null) {         currentIterator = nodeSet.iterator().     } else if (currentIterator.hasNext() == false && nodeSet.isEmpty() == false) {         // iterator rollover         currentIterator = nodeSet.iterator().     } }
false;private,static;2;3;;private static ConnectionManager createConnectionManager(ConnectionProfile connectionProfile, TransportService transportService) {     return new ConnectionManager(connectionProfile, transportService.transport). }
false;;0;3;;ConnectionManager getConnectionManager() {     return connectionManager. }
