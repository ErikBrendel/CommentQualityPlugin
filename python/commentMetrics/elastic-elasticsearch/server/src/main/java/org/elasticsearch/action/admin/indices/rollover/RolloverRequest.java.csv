commented;modifiers;parameterAmount;loc;comment;code
false;public;0;8;;@Override public ActionRequestValidationException validate() {     ActionRequestValidationException validationException = createIndexRequest.validate().     if (alias == null) {         validationException = addValidationError("index alias is missing", validationException).     }     return validationException. }
false;public;1;14;;@Override public void readFrom(StreamInput in) throws IOException {     super.readFrom(in).     alias = in.readString().     newIndexName = in.readOptionalString().     dryRun = in.readBoolean().     int size = in.readVInt().     for (int i = 0. i < size. i++) {         Condition<?> condition = in.readNamedWriteable(Condition.class).         this.conditions.put(condition.name, condition).     }     createIndexRequest = new CreateIndexRequest().     createIndexRequest.readFrom(in). }
false;public;1;14;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeString(alias).     out.writeOptionalString(newIndexName).     out.writeBoolean(dryRun).     out.writeVInt(conditions.size()).     for (Condition<?> condition : conditions.values()) {         if (condition.includedInVersion(out.getVersion())) {             out.writeNamedWriteable(condition).         }     }     createIndexRequest.writeTo(out). }
false;public;0;4;;@Override public String[] indices() {     return new String[] { alias }. }
false;public;0;4;;@Override public IndicesOptions indicesOptions() {     return IndicesOptions.strictSingleIndexNoExpandForbidClosed(). }
true;public;1;3;/**  * Sets the alias to rollover to another index  */ ;/**  * Sets the alias to rollover to another index  */ public void setAlias(String alias) {     this.alias = alias. }
true;public;1;3;/**  * Sets the alias to rollover to another index  */ ;/**  * Sets the alias to rollover to another index  */ public void setNewIndexName(String newIndexName) {     this.newIndexName = newIndexName. }
true;public;1;3;/**  * Sets if the rollover should not be executed when conditions are met  */ ;/**  * Sets if the rollover should not be executed when conditions are met  */ public void dryRun(boolean dryRun) {     this.dryRun = dryRun. }
true;public;1;7;/**  * Adds condition to check if the index is at least <code>age</code> old  */ ;/**  * Adds condition to check if the index is at least <code>age</code> old  */ public void addMaxIndexAgeCondition(TimeValue age) {     MaxAgeCondition maxAgeCondition = new MaxAgeCondition(age).     if (this.conditions.containsKey(maxAgeCondition.name)) {         throw new IllegalArgumentException(maxAgeCondition.name + " condition is already set").     }     this.conditions.put(maxAgeCondition.name, maxAgeCondition). }
true;public;1;7;/**  * Adds condition to check if the index has at least <code>numDocs</code>  */ ;/**  * Adds condition to check if the index has at least <code>numDocs</code>  */ public void addMaxIndexDocsCondition(long numDocs) {     MaxDocsCondition maxDocsCondition = new MaxDocsCondition(numDocs).     if (this.conditions.containsKey(maxDocsCondition.name)) {         throw new IllegalArgumentException(maxDocsCondition.name + " condition is already set").     }     this.conditions.put(maxDocsCondition.name, maxDocsCondition). }
true;public;1;7;/**  * Adds a size-based condition to check if the index size is at least <code>size</code>.  */ ;/**  * Adds a size-based condition to check if the index size is at least <code>size</code>.  */ public void addMaxIndexSizeCondition(ByteSizeValue size) {     MaxSizeCondition maxSizeCondition = new MaxSizeCondition(size).     if (this.conditions.containsKey(maxSizeCondition.name)) {         throw new IllegalArgumentException(maxSizeCondition + " condition is already set").     }     this.conditions.put(maxSizeCondition.name, maxSizeCondition). }
false;public;0;3;;public boolean isDryRun() {     return dryRun. }
false;public;0;3;;public Map<String, Condition<?>> getConditions() {     return conditions. }
false;public;0;3;;public String getAlias() {     return alias. }
false;public;0;3;;public String getNewIndexName() {     return newIndexName. }
true;public;0;3;/**  * Returns the inner {@link CreateIndexRequest}. Allows to configure mappings, settings and aliases for the new index.  */ ;/**  * Returns the inner {@link CreateIndexRequest}. Allows to configure mappings, settings and aliases for the new index.  */ public CreateIndexRequest getCreateIndexRequest() {     return createIndexRequest. }
false;public;2;14;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     createIndexRequest.innerToXContent(builder, params).     builder.startObject(CONDITIONS.getPreferredName()).     for (Condition<?> condition : conditions.values()) {         condition.toXContent(builder, params).     }     builder.endObject().     builder.endObject().     return builder. }
true;public;2;3;// param isTypeIncluded decides how mappings should be parsed from XContent ;// param isTypeIncluded decides how mappings should be parsed from XContent public void fromXContent(boolean isTypeIncluded, XContentParser parser) throws IOException {     PARSER.parse(parser, this, isTypeIncluded). }
