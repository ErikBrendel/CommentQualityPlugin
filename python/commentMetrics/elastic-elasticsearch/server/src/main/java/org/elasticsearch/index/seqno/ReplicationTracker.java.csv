commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Get all retention leases tracked on this shard.  *  * @return the retention leases  */ ;/**  * Get all retention leases tracked on this shard.  *  * @return the retention leases  */ public RetentionLeases getRetentionLeases() {     return getRetentionLeases(false).v2(). }
true;public,synchronized;1;21;/**  * If the expire leases parameter is false, gets all retention leases tracked on this shard and otherwise first calculates  * expiration of existing retention leases, and then gets all non-expired retention leases tracked on this shard. Note that only the  * primary shard calculates which leases are expired, and if any have expired, syncs the retention leases to any replicas. If the  * expire leases parameter is true, this replication tracker must be in primary mode.  *  * @return a tuple indicating whether or not any retention leases were expired, and the non-expired retention leases  */ ;/**  * If the expire leases parameter is false, gets all retention leases tracked on this shard and otherwise first calculates  * expiration of existing retention leases, and then gets all non-expired retention leases tracked on this shard. Note that only the  * primary shard calculates which leases are expired, and if any have expired, syncs the retention leases to any replicas. If the  * expire leases parameter is true, this replication tracker must be in primary mode.  *  * @return a tuple indicating whether or not any retention leases were expired, and the non-expired retention leases  */ public synchronized Tuple<Boolean, RetentionLeases> getRetentionLeases(final boolean expireLeases) {     if (expireLeases == false) {         return Tuple.tuple(false, retentionLeases).     }     assert primaryMode.     // the primary calculates the non-expired retention leases and syncs them to replicas     final long currentTimeMillis = currentTimeMillisSupplier.getAsLong().     final long retentionLeaseMillis = indexSettings.getRetentionLeaseMillis().     final Map<Boolean, List<RetentionLease>> partitionByExpiration = retentionLeases.leases().stream().collect(Collectors.groupingBy(lease -> currentTimeMillis - lease.timestamp() > retentionLeaseMillis)).     if (partitionByExpiration.get(true) == null) {         // early out as no retention leases have expired         return Tuple.tuple(false, retentionLeases).     }     final Collection<RetentionLease> nonExpiredLeases = partitionByExpiration.get(false) != null ? partitionByExpiration.get(false) : Collections.emptyList().     retentionLeases = new RetentionLeases(operationPrimaryTerm, retentionLeases.version() + 1, nonExpiredLeases).     return Tuple.tuple(true, retentionLeases). }
true;public;4;23;/**  * Adds a new retention lease.  *  * @param id                      the identifier of the retention lease  * @param retainingSequenceNumber the retaining sequence number  * @param source                  the source of the retention lease  * @param listener                the callback when the retention lease is successfully added and synced to replicas  * @return the new retention lease  * @throws IllegalArgumentException if the specified retention lease already exists  */ ;/**  * Adds a new retention lease.  *  * @param id                      the identifier of the retention lease  * @param retainingSequenceNumber the retaining sequence number  * @param source                  the source of the retention lease  * @param listener                the callback when the retention lease is successfully added and synced to replicas  * @return the new retention lease  * @throws IllegalArgumentException if the specified retention lease already exists  */ public RetentionLease addRetentionLease(final String id, final long retainingSequenceNumber, final String source, final ActionListener<ReplicationResponse> listener) {     Objects.requireNonNull(listener).     final RetentionLease retentionLease.     final RetentionLeases currentRetentionLeases.     synchronized (this) {         assert primaryMode.         if (retentionLeases.contains(id)) {             throw new RetentionLeaseAlreadyExistsException(id).         }         retentionLease = new RetentionLease(id, retainingSequenceNumber, currentTimeMillisSupplier.getAsLong(), source).         retentionLeases = new RetentionLeases(operationPrimaryTerm, retentionLeases.version() + 1, Stream.concat(retentionLeases.leases().stream(), Stream.of(retentionLease)).collect(Collectors.toList())).         currentRetentionLeases = retentionLeases.     }     onSyncRetentionLeases.accept(currentRetentionLeases, listener).     return retentionLease. }
true;public,synchronized;3;23;/**  * Renews an existing retention lease.  *  * @param id                      the identifier of the retention lease  * @param retainingSequenceNumber the retaining sequence number  * @param source                  the source of the retention lease  * @return the renewed retention lease  * @throws IllegalArgumentException if the specified retention lease does not exist  */ ;/**  * Renews an existing retention lease.  *  * @param id                      the identifier of the retention lease  * @param retainingSequenceNumber the retaining sequence number  * @param source                  the source of the retention lease  * @return the renewed retention lease  * @throws IllegalArgumentException if the specified retention lease does not exist  */ public synchronized RetentionLease renewRetentionLease(final String id, final long retainingSequenceNumber, final String source) {     assert primaryMode.     if (retentionLeases.contains(id) == false) {         throw new RetentionLeaseNotFoundException(id).     }     final RetentionLease retentionLease = new RetentionLease(id, retainingSequenceNumber, currentTimeMillisSupplier.getAsLong(), source).     final RetentionLease existingRetentionLease = retentionLeases.get(id).     assert existingRetentionLease != null.     assert existingRetentionLease.retainingSequenceNumber() <= retentionLease.retainingSequenceNumber() : "retention lease renewal for [" + id + "]" + " from [" + source + "]" + " renewed a lower retaining sequence number [" + retentionLease.retainingSequenceNumber() + "]" + " than the current lease retaining sequence number [" + existingRetentionLease.retainingSequenceNumber() + "]".     retentionLeases = new RetentionLeases(operationPrimaryTerm, retentionLeases.version() + 1, Stream.concat(retentionLeases.leases().stream().filter(lease -> lease.id().equals(id) == false), Stream.of(retentionLease)).collect(Collectors.toList())).     return retentionLease. }
true;public;2;16;/**  * Removes an existing retention lease.  *  * @param id       the identifier of the retention lease  * @param listener the callback when the retention lease is successfully removed and synced to replicas  */ ;/**  * Removes an existing retention lease.  *  * @param id       the identifier of the retention lease  * @param listener the callback when the retention lease is successfully removed and synced to replicas  */ public void removeRetentionLease(final String id, final ActionListener<ReplicationResponse> listener) {     Objects.requireNonNull(listener).     final RetentionLeases currentRetentionLeases.     synchronized (this) {         assert primaryMode.         if (retentionLeases.contains(id) == false) {             throw new RetentionLeaseNotFoundException(id).         }         retentionLeases = new RetentionLeases(operationPrimaryTerm, retentionLeases.version() + 1, retentionLeases.leases().stream().filter(lease -> lease.id().equals(id) == false).collect(Collectors.toList())).         currentRetentionLeases = retentionLeases.     }     onSyncRetentionLeases.accept(currentRetentionLeases, listener). }
true;public,synchronized;1;6;/**  * Updates retention leases on a replica.  *  * @param retentionLeases the retention leases  */ ;/**  * Updates retention leases on a replica.  *  * @param retentionLeases the retention leases  */ public synchronized void updateRetentionLeasesOnReplica(final RetentionLeases retentionLeases) {     assert primaryMode == false.     if (retentionLeases.supersedes(this.retentionLeases)) {         this.retentionLeases = retentionLeases.     } }
true;public;1;7;/**  * Loads the latest retention leases from their dedicated state file.  *  * @param path the path to the directory containing the state file  * @return the retention leases  * @throws IOException if an I/O exception occurs reading the retention leases  */ ;/**  * Loads the latest retention leases from their dedicated state file.  *  * @param path the path to the directory containing the state file  * @return the retention leases  * @throws IOException if an I/O exception occurs reading the retention leases  */ public RetentionLeases loadRetentionLeases(final Path path) throws IOException {     final RetentionLeases retentionLeases = RetentionLeases.FORMAT.loadLatestState(logger, NamedXContentRegistry.EMPTY, path).     if (retentionLeases == null) {         return RetentionLeases.EMPTY.     }     return retentionLeases. }
true;public;1;10;/**  * Persists the current retention leases to their dedicated state file.  *  * @param path the path to the directory containing the state file  * @throws WriteStateException if an exception occurs writing the state file  */ ;/**  * Persists the current retention leases to their dedicated state file.  *  * @param path the path to the directory containing the state file  * @throws WriteStateException if an exception occurs writing the state file  */ public void persistRetentionLeases(final Path path) throws WriteStateException {     synchronized (retentionLeasePersistenceLock) {         final RetentionLeases currentRetentionLeases.         synchronized (this) {             currentRetentionLeases = retentionLeases.         }         logger.trace("persisting retention leases [{}]", currentRetentionLeases).         RetentionLeases.FORMAT.writeAndCleanup(currentRetentionLeases, path).     } }
false;public;1;9;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeZLong(localCheckpoint).     out.writeZLong(globalCheckpoint).     out.writeBoolean(inSync).     if (out.getVersion().onOrAfter(Version.V_6_3_0)) {         out.writeBoolean(tracked).     } }
true;public;0;3;/**  * Returns a full copy of this object  */ ;/**  * Returns a full copy of this object  */ public CheckpointState copy() {     return new CheckpointState(localCheckpoint, globalCheckpoint, inSync, tracked). }
false;public;0;3;;public long getLocalCheckpoint() {     return localCheckpoint. }
false;public;0;3;;public long getGlobalCheckpoint() {     return globalCheckpoint. }
false;public;0;9;;@Override public String toString() {     return "LocalCheckpointState{" + "localCheckpoint=" + localCheckpoint + ", globalCheckpoint=" + globalCheckpoint + ", inSync=" + inSync + ", tracked=" + tracked + '}'. }
false;public;1;12;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     CheckpointState that = (CheckpointState) o.     if (localCheckpoint != that.localCheckpoint)         return false.     if (globalCheckpoint != that.globalCheckpoint)         return false.     if (inSync != that.inSync)         return false.     return tracked == that.tracked. }
false;public;0;8;;@Override public int hashCode() {     int result = Long.hashCode(localCheckpoint).     result = 31 * result + Long.hashCode(globalCheckpoint).     result = 31 * result + Boolean.hashCode(inSync).     result = 31 * result + Boolean.hashCode(tracked).     return result. }
true;public,synchronized;0;11;/**  * Get the local knowledge of the global checkpoints for all in-sync allocation IDs.  *  * @return a map from allocation ID to the local knowledge of the global checkpoint for that allocation ID  */ ;/**  * Get the local knowledge of the global checkpoints for all in-sync allocation IDs.  *  * @return a map from allocation ID to the local knowledge of the global checkpoint for that allocation ID  */ public synchronized ObjectLongMap<String> getInSyncGlobalCheckpoints() {     assert primaryMode.     assert handoffInProgress == false.     // upper bound on the size     final ObjectLongMap<String> globalCheckpoints = new ObjectLongHashMap<>(checkpoints.size()).     checkpoints.entrySet().stream().filter(e -> e.getValue().inSync).forEach(e -> globalCheckpoints.put(e.getKey(), e.getValue().globalCheckpoint)).     return globalCheckpoints. }
true;public;0;3;/**  * Returns whether the replication tracker is in primary mode, i.e., whether the current shard is acting as primary from the point of  * view of replication.  */ ;/**  * Returns whether the replication tracker is in primary mode, i.e., whether the current shard is acting as primary from the point of  * view of replication.  */ public boolean isPrimaryMode() {     return primaryMode. }
true;public;0;3;/**  * Returns the current operation primary term.  *  * @return the primary term  */ ;/**  * Returns the current operation primary term.  *  * @return the primary term  */ public long getOperationPrimaryTerm() {     return operationPrimaryTerm. }
true;public;1;3;/**  * Sets the current operation primary term. This method should be invoked only when no other operations are possible on the shard. That  * is, either from the constructor of {@link IndexShard} or while holding all permits on the {@link IndexShard} instance.  *  * @param operationPrimaryTerm the new operation primary term  */ ;/**  * Sets the current operation primary term. This method should be invoked only when no other operations are possible on the shard. That  * is, either from the constructor of {@link IndexShard} or while holding all permits on the {@link IndexShard} instance.  *  * @param operationPrimaryTerm the new operation primary term  */ public void setOperationPrimaryTerm(final long operationPrimaryTerm) {     this.operationPrimaryTerm = operationPrimaryTerm. }
true;public;0;3;/**  * Returns whether the replication tracker has relocated away to another shard copy.  */ ;/**  * Returns whether the replication tracker has relocated away to another shard copy.  */ public boolean isRelocated() {     return relocated. }
true;private;0;85;/**  * Class invariant that should hold before and after every invocation of public methods on this class. As Java lacks implication  * as a logical operator, many of the invariants are written under the form (!A || B), they should be read as (A implies B) however.  */ ;/**  * Class invariant that should hold before and after every invocation of public methods on this class. As Java lacks implication  * as a logical operator, many of the invariants are written under the form (!A || B), they should be read as (A implies B) however.  */ private boolean invariant() {     assert checkpoints.get(shardAllocationId) != null : "checkpoints map should always have an entry for the current shard".     // local checkpoints only set during primary mode     assert primaryMode || checkpoints.values().stream().allMatch(lcps -> lcps.localCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO || lcps.localCheckpoint == SequenceNumbers.PRE_60_NODE_CHECKPOINT).     // global checkpoints for other shards only set during primary mode     assert primaryMode || checkpoints.entrySet().stream().filter(e -> e.getKey().equals(shardAllocationId) == false).map(Map.Entry::getValue).allMatch(cps -> (cps.globalCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO || cps.globalCheckpoint == SequenceNumbers.PRE_60_NODE_CHECKPOINT)).     // relocation handoff can only occur in primary mode     assert !handoffInProgress || primaryMode.     // a relocated copy is not in primary mode     assert !relocated || !primaryMode.     // the current shard is marked as in-sync when the global checkpoint tracker operates in primary mode     assert !primaryMode || checkpoints.get(shardAllocationId).inSync.     // the routing table and replication group is set when the global checkpoint tracker operates in primary mode     assert !primaryMode || (routingTable != null && replicationGroup != null) : "primary mode but routing table is " + routingTable + " and replication group is " + replicationGroup.     // when in primary mode, the current allocation ID is the allocation ID of the primary or the relocation allocation ID     assert !primaryMode || (routingTable.primaryShard().allocationId().getId().equals(shardAllocationId) || routingTable.primaryShard().allocationId().getRelocationId().equals(shardAllocationId)).     // during relocation handoff there are no entries blocking global checkpoint advancement     assert !handoffInProgress || pendingInSync.isEmpty() : "entries blocking global checkpoint advancement during relocation handoff: " + pendingInSync.     // entries blocking global checkpoint advancement can only exist in primary mode and when not having a relocation handoff     assert pendingInSync.isEmpty() || (primaryMode && !handoffInProgress).     // the computed global checkpoint is always up-to-date     assert !primaryMode || getGlobalCheckpoint() == computeGlobalCheckpoint(pendingInSync, checkpoints.values(), getGlobalCheckpoint()) : "global checkpoint is not up-to-date, expected: " + computeGlobalCheckpoint(pendingInSync, checkpoints.values(), getGlobalCheckpoint()) + " but was: " + getGlobalCheckpoint().     // when in primary mode, the global checkpoint is at most the minimum local checkpoint on all in-sync shard copies     assert !primaryMode || getGlobalCheckpoint() <= inSyncCheckpointStates(checkpoints, CheckpointState::getLocalCheckpoint, LongStream::min) : "global checkpoint [" + getGlobalCheckpoint() + "] " + "for primary mode allocation ID [" + shardAllocationId + "] " + "more than in-sync local checkpoints [" + checkpoints + "]".     // we have a routing table iff we have a replication group     assert (routingTable == null) == (replicationGroup == null) : "routing table is " + routingTable + " but replication group is " + replicationGroup.     assert replicationGroup == null || replicationGroup.equals(calculateReplicationGroup()) : "cached replication group out of sync: expected: " + calculateReplicationGroup() + " but was: " + replicationGroup.     // all assigned shards from the routing table are tracked     assert routingTable == null || checkpoints.keySet().containsAll(routingTable.getAllAllocationIds()) : "local checkpoints " + checkpoints + " not in-sync with routing table " + routingTable.     for (Map.Entry<String, CheckpointState> entry : checkpoints.entrySet()) {         // blocking global checkpoint advancement only happens for shards that are not in-sync         assert !pendingInSync.contains(entry.getKey()) || !entry.getValue().inSync : "shard copy " + entry.getKey() + " blocks global checkpoint advancement but is in-sync".         // in-sync shard copies are tracked         assert !entry.getValue().inSync || entry.getValue().tracked : "shard copy " + entry.getKey() + " is in-sync but not tracked".     }     // all pending in sync shards are tracked     for (String aId : pendingInSync) {         assert checkpoints.get(aId) != null : "aId [" + aId + "] is pending in sync but isn't tracked".     }     return true. }
false;private,static;3;14;;private static long inSyncCheckpointStates(final Map<String, CheckpointState> checkpoints, ToLongFunction<CheckpointState> function, Function<LongStream, OptionalLong> reducer) {     final OptionalLong value = reducer.apply(checkpoints.values().stream().filter(cps -> cps.inSync).mapToLong(function).filter(v -> v != SequenceNumbers.PRE_60_NODE_CHECKPOINT && v != SequenceNumbers.UNASSIGNED_SEQ_NO)).     return value.isPresent() ? value.getAsLong() : SequenceNumbers.UNASSIGNED_SEQ_NO. }
true;public;0;4;/**  * Returns the current replication group for the shard.  *  * @return the replication group  */ ;/**  * Returns the current replication group for the shard.  *  * @return the replication group  */ public ReplicationGroup getReplicationGroup() {     assert primaryMode.     return replicationGroup. }
false;private;0;5;;private ReplicationGroup calculateReplicationGroup() {     return new ReplicationGroup(routingTable, checkpoints.entrySet().stream().filter(e -> e.getValue().inSync).map(Map.Entry::getKey).collect(Collectors.toSet()), checkpoints.entrySet().stream().filter(e -> e.getValue().tracked).map(Map.Entry::getKey).collect(Collectors.toSet())). }
true;public,synchronized;0;5;/**  * Returns the global checkpoint for the shard.  *  * @return the global checkpoint  */ ;/**  * Returns the global checkpoint for the shard.  *  * @return the global checkpoint  */ public synchronized long getGlobalCheckpoint() {     final CheckpointState cps = checkpoints.get(shardAllocationId).     assert cps != null.     return cps.globalCheckpoint. }
false;public;0;4;;@Override public long getAsLong() {     return getGlobalCheckpoint(). }
true;public,synchronized;2;18;/**  * Updates the global checkpoint on a replica shard after it has been updated by the primary.  *  * @param globalCheckpoint the global checkpoint  * @param reason           the reason the global checkpoint was updated  */ ;/**  * Updates the global checkpoint on a replica shard after it has been updated by the primary.  *  * @param globalCheckpoint the global checkpoint  * @param reason           the reason the global checkpoint was updated  */ public synchronized void updateGlobalCheckpointOnReplica(final long globalCheckpoint, final String reason) {     assert invariant().     assert primaryMode == false.     /*          * The global checkpoint here is a local knowledge which is updated under the mandate of the primary. It can happen that the primary          * information is lagging compared to a replica (e.g., if a replica is promoted to primary but has stale info relative to other          * replica shards). In these cases, the local knowledge of the global checkpoint could be higher than the sync from the lagging          * primary.          */     updateGlobalCheckpoint(shardAllocationId, globalCheckpoint, current -> {         logger.trace("updated global checkpoint from [{}] to [{}] due to [{}]", current, globalCheckpoint, reason).         onGlobalCheckpointUpdated.accept(globalCheckpoint).     }).     assert invariant(). }
true;public,synchronized;2;14;/**  * Update the local knowledge of the global checkpoint for the specified allocation ID.  *  * @param allocationId     the allocation ID to update the global checkpoint for  * @param globalCheckpoint the global checkpoint  */ ;/**  * Update the local knowledge of the global checkpoint for the specified allocation ID.  *  * @param allocationId     the allocation ID to update the global checkpoint for  * @param globalCheckpoint the global checkpoint  */ public synchronized void updateGlobalCheckpointForShard(final String allocationId, final long globalCheckpoint) {     assert primaryMode.     assert handoffInProgress == false.     assert invariant().     updateGlobalCheckpoint(allocationId, globalCheckpoint, current -> logger.trace("updated local knowledge for [{}] on the primary of the global checkpoint from [{}] to [{}]", allocationId, current, globalCheckpoint)).     assert invariant(). }
false;private;3;8;;private void updateGlobalCheckpoint(final String allocationId, final long globalCheckpoint, LongConsumer ifUpdated) {     final CheckpointState cps = checkpoints.get(allocationId).     assert !this.shardAllocationId.equals(allocationId) || cps != null.     if (cps != null && globalCheckpoint > cps.globalCheckpoint) {         cps.globalCheckpoint = globalCheckpoint.         ifUpdated.accept(cps.globalCheckpoint).     } }
true;public,synchronized;1;12;/**  * Initializes the global checkpoint tracker in primary mode (see {@link #primaryMode}. Called on primary activation or promotion.  */ ;/**  * Initializes the global checkpoint tracker in primary mode (see {@link #primaryMode}. Called on primary activation or promotion.  */ public synchronized void activatePrimaryMode(final long localCheckpoint) {     assert invariant().     assert primaryMode == false.     assert checkpoints.get(shardAllocationId) != null && checkpoints.get(shardAllocationId).inSync && checkpoints.get(shardAllocationId).localCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO : "expected " + shardAllocationId + " to have initialized entry in " + checkpoints + " when activating primary".     assert localCheckpoint >= SequenceNumbers.NO_OPS_PERFORMED.     primaryMode = true.     updateLocalCheckpoint(shardAllocationId, checkpoints.get(shardAllocationId), localCheckpoint).     updateGlobalCheckpointOnPrimary().     assert invariant(). }
true;public,synchronized;4;65;/**  * Notifies the tracker of the current allocation IDs in the cluster state.  *  * @param applyingClusterStateVersion the cluster state version being applied when updating the allocation IDs from the master  * @param inSyncAllocationIds         the allocation IDs of the currently in-sync shard copies  * @param routingTable                the shard routing table  * @param pre60AllocationIds          the allocation IDs of shards that are allocated to pre-6.0 nodes  */ ;/**  * Notifies the tracker of the current allocation IDs in the cluster state.  *  * @param applyingClusterStateVersion the cluster state version being applied when updating the allocation IDs from the master  * @param inSyncAllocationIds         the allocation IDs of the currently in-sync shard copies  * @param routingTable                the shard routing table  * @param pre60AllocationIds          the allocation IDs of shards that are allocated to pre-6.0 nodes  */ public synchronized void updateFromMaster(final long applyingClusterStateVersion, final Set<String> inSyncAllocationIds, final IndexShardRoutingTable routingTable, final Set<String> pre60AllocationIds) {     assert invariant().     if (applyingClusterStateVersion > appliedClusterStateVersion) {         // check that the master does not fabricate new in-sync entries out of thin air once we are in primary mode         assert !primaryMode || inSyncAllocationIds.stream().allMatch(inSyncId -> checkpoints.containsKey(inSyncId) && checkpoints.get(inSyncId).inSync) : "update from master in primary mode contains in-sync ids " + inSyncAllocationIds + " that have no matching entries in " + checkpoints.         // remove entries which don't exist on master         Set<String> initializingAllocationIds = routingTable.getAllInitializingShards().stream().map(ShardRouting::allocationId).map(AllocationId::getId).collect(Collectors.toSet()).         boolean removedEntries = checkpoints.keySet().removeIf(aid -> !inSyncAllocationIds.contains(aid) && !initializingAllocationIds.contains(aid)).         if (primaryMode) {             // add new initializingIds that are missing locally. These are fresh shard copies - and not in-sync             for (String initializingId : initializingAllocationIds) {                 if (checkpoints.containsKey(initializingId) == false) {                     final boolean inSync = inSyncAllocationIds.contains(initializingId).                     assert inSync == false : "update from master in primary mode has " + initializingId + " as in-sync but it does not exist locally".                     final long localCheckpoint = pre60AllocationIds.contains(initializingId) ? SequenceNumbers.PRE_60_NODE_CHECKPOINT : SequenceNumbers.UNASSIGNED_SEQ_NO.                     final long globalCheckpoint = localCheckpoint.                     checkpoints.put(initializingId, new CheckpointState(localCheckpoint, globalCheckpoint, inSync, inSync)).                 }             }             if (removedEntries) {                 pendingInSync.removeIf(aId -> checkpoints.containsKey(aId) == false).             }         } else {             for (String initializingId : initializingAllocationIds) {                 if (shardAllocationId.equals(initializingId) == false) {                     final long localCheckpoint = pre60AllocationIds.contains(initializingId) ? SequenceNumbers.PRE_60_NODE_CHECKPOINT : SequenceNumbers.UNASSIGNED_SEQ_NO.                     final long globalCheckpoint = localCheckpoint.                     checkpoints.put(initializingId, new CheckpointState(localCheckpoint, globalCheckpoint, false, false)).                 }             }             for (String inSyncId : inSyncAllocationIds) {                 if (shardAllocationId.equals(inSyncId)) {                     // current shard is initially marked as not in-sync because we don't know better at that point                     CheckpointState checkpointState = checkpoints.get(shardAllocationId).                     checkpointState.inSync = true.                     checkpointState.tracked = true.                 } else {                     final long localCheckpoint = pre60AllocationIds.contains(inSyncId) ? SequenceNumbers.PRE_60_NODE_CHECKPOINT : SequenceNumbers.UNASSIGNED_SEQ_NO.                     final long globalCheckpoint = localCheckpoint.                     checkpoints.put(inSyncId, new CheckpointState(localCheckpoint, globalCheckpoint, true, true)).                 }             }         }         appliedClusterStateVersion = applyingClusterStateVersion.         this.routingTable = routingTable.         replicationGroup = calculateReplicationGroup().         if (primaryMode && removedEntries) {             updateGlobalCheckpointOnPrimary().             // notify any waiter for local checkpoint advancement to recheck that their shard is still being tracked.             notifyAllWaiters().         }     }     assert invariant(). }
true;public,synchronized;1;13;/**  * Called when the recovery process for a shard has opened the engine on the target shard. Ensures that the right data structures  * have been set up locally to track local checkpoint information for the shard and that the shard is added to the replication group.  *  * @param allocationId  the allocation ID of the shard for which recovery was initiated  */ ;/**  * Called when the recovery process for a shard has opened the engine on the target shard. Ensures that the right data structures  * have been set up locally to track local checkpoint information for the shard and that the shard is added to the replication group.  *  * @param allocationId  the allocation ID of the shard for which recovery was initiated  */ public synchronized void initiateTracking(final String allocationId) {     assert invariant().     assert primaryMode.     assert handoffInProgress == false.     CheckpointState cps = checkpoints.get(allocationId).     if (cps == null) {         // can happen if replica was removed from cluster but recovery process is unaware of it yet         throw new IllegalStateException("no local checkpoint tracking information available").     }     cps.tracked = true.     replicationGroup = calculateReplicationGroup().     assert invariant(). }
true;public,synchronized;2;41;/**  * Marks the shard with the provided allocation ID as in-sync with the primary shard. This method will block until the local checkpoint  * on the specified shard advances above the current global checkpoint.  *  * @param allocationId    the allocation ID of the shard to mark as in-sync  * @param localCheckpoint the current local checkpoint on the shard  */ ;/**  * Marks the shard with the provided allocation ID as in-sync with the primary shard. This method will block until the local checkpoint  * on the specified shard advances above the current global checkpoint.  *  * @param allocationId    the allocation ID of the shard to mark as in-sync  * @param localCheckpoint the current local checkpoint on the shard  */ public synchronized void markAllocationIdAsInSync(final String allocationId, final long localCheckpoint) throws InterruptedException {     assert invariant().     assert primaryMode.     assert handoffInProgress == false.     CheckpointState cps = checkpoints.get(allocationId).     if (cps == null) {         // can happen if replica was removed from cluster but recovery process is unaware of it yet         throw new IllegalStateException("no local checkpoint tracking information available for " + allocationId).     }     assert localCheckpoint >= SequenceNumbers.NO_OPS_PERFORMED : "expected known local checkpoint for " + allocationId + " but was " + localCheckpoint.     assert pendingInSync.contains(allocationId) == false : "shard copy " + allocationId + " is already marked as pending in-sync".     assert cps.tracked : "shard copy " + allocationId + " cannot be marked as in-sync as it's not tracked".     updateLocalCheckpoint(allocationId, cps, localCheckpoint).     // stuck from advancing     assert !cps.inSync || (cps.localCheckpoint >= getGlobalCheckpoint()) : "shard copy " + allocationId + " that's already in-sync should have a local checkpoint " + cps.localCheckpoint + " that's above the global checkpoint " + getGlobalCheckpoint().     if (cps.localCheckpoint < getGlobalCheckpoint()) {         pendingInSync.add(allocationId).         try {             while (true) {                 if (pendingInSync.contains(allocationId)) {                     waitForLocalCheckpointToAdvance().                 } else {                     break.                 }             }         } finally {             pendingInSync.remove(allocationId).         }     } else {         cps.inSync = true.         replicationGroup = calculateReplicationGroup().         logger.trace("marked [{}] as in-sync", allocationId).         updateGlobalCheckpointOnPrimary().     }     assert invariant(). }
false;private;3;18;;private boolean updateLocalCheckpoint(String allocationId, CheckpointState cps, long localCheckpoint) {     // a local checkpoint of PRE_60_NODE_CHECKPOINT cannot be overridden     assert cps.localCheckpoint != SequenceNumbers.PRE_60_NODE_CHECKPOINT || localCheckpoint == SequenceNumbers.PRE_60_NODE_CHECKPOINT : "pre-6.0 shard copy " + allocationId + " unexpected to send valid local checkpoint " + localCheckpoint.     // a local checkpoint for a shard copy should be a valid sequence number or the pre-6.0 sequence number indicator     assert localCheckpoint != SequenceNumbers.UNASSIGNED_SEQ_NO : "invalid local checkpoint for shard copy [" + allocationId + "]".     if (localCheckpoint > cps.localCheckpoint) {         logger.trace("updated local checkpoint of [{}] from [{}] to [{}]", allocationId, cps.localCheckpoint, localCheckpoint).         cps.localCheckpoint = localCheckpoint.         return true.     } else {         logger.trace("skipped updating local checkpoint of [{}] from [{}] to [{}], current checkpoint is higher", allocationId, cps.localCheckpoint, localCheckpoint).         return false.     } }
true;public,synchronized;2;24;/**  * Notifies the service to update the local checkpoint for the shard with the provided allocation ID. If the checkpoint is lower than  * the currently known one, this is a no-op. If the allocation ID is not tracked, it is ignored.  *  * @param allocationId    the allocation ID of the shard to update the local checkpoint for  * @param localCheckpoint the local checkpoint for the shard  */ ;/**  * Notifies the service to update the local checkpoint for the shard with the provided allocation ID. If the checkpoint is lower than  * the currently known one, this is a no-op. If the allocation ID is not tracked, it is ignored.  *  * @param allocationId    the allocation ID of the shard to update the local checkpoint for  * @param localCheckpoint the local checkpoint for the shard  */ public synchronized void updateLocalCheckpoint(final String allocationId, final long localCheckpoint) {     assert invariant().     assert primaryMode.     assert handoffInProgress == false.     CheckpointState cps = checkpoints.get(allocationId).     if (cps == null) {         // can happen if replica was removed from cluster but replication process is unaware of it yet         return.     }     boolean increasedLocalCheckpoint = updateLocalCheckpoint(allocationId, cps, localCheckpoint).     boolean pending = pendingInSync.contains(allocationId).     if (pending && cps.localCheckpoint >= getGlobalCheckpoint()) {         pendingInSync.remove(allocationId).         pending = false.         cps.inSync = true.         replicationGroup = calculateReplicationGroup().         logger.trace("marked [{}] as in-sync", allocationId).         notifyAllWaiters().     }     if (increasedLocalCheckpoint && pending == false) {         updateGlobalCheckpointOnPrimary().     }     assert invariant(). }
true;private,static;3;21;/**  * Computes the global checkpoint based on the given local checkpoints. In case where there are entries preventing the  * computation to happen (for example due to blocking), it returns the fallback value.  */ ;/**  * Computes the global checkpoint based on the given local checkpoints. In case where there are entries preventing the  * computation to happen (for example due to blocking), it returns the fallback value.  */ private static long computeGlobalCheckpoint(final Set<String> pendingInSync, final Collection<CheckpointState> localCheckpoints, final long fallback) {     long minLocalCheckpoint = Long.MAX_VALUE.     if (pendingInSync.isEmpty() == false) {         return fallback.     }     for (final CheckpointState cps : localCheckpoints) {         if (cps.inSync) {             if (cps.localCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO) {                 // unassigned in-sync replica                 return fallback.             } else if (cps.localCheckpoint == SequenceNumbers.PRE_60_NODE_CHECKPOINT) {             // 5.x replica, ignore for global checkpoint calculation             } else {                 minLocalCheckpoint = Math.min(cps.localCheckpoint, minLocalCheckpoint).             }         }     }     assert minLocalCheckpoint != Long.MAX_VALUE.     return minLocalCheckpoint. }
true;private,synchronized;0;13;/**  * Scans through the currently known local checkpoint and updates the global checkpoint accordingly.  */ ;/**  * Scans through the currently known local checkpoint and updates the global checkpoint accordingly.  */ private synchronized void updateGlobalCheckpointOnPrimary() {     assert primaryMode.     final CheckpointState cps = checkpoints.get(shardAllocationId).     final long globalCheckpoint = cps.globalCheckpoint.     final long computedGlobalCheckpoint = computeGlobalCheckpoint(pendingInSync, checkpoints.values(), getGlobalCheckpoint()).     assert computedGlobalCheckpoint >= globalCheckpoint : "new global checkpoint [" + computedGlobalCheckpoint + "] is lower than previous one [" + globalCheckpoint + "]".     if (globalCheckpoint != computedGlobalCheckpoint) {         cps.globalCheckpoint = computedGlobalCheckpoint.         logger.trace("updated global checkpoint to [{}]", computedGlobalCheckpoint).         onGlobalCheckpointUpdated.accept(computedGlobalCheckpoint).     } }
true;public,synchronized;0;18;/**  * Initiates a relocation handoff and returns the corresponding primary context.  */ ;/**  * Initiates a relocation handoff and returns the corresponding primary context.  */ public synchronized PrimaryContext startRelocationHandoff() {     assert invariant().     assert primaryMode.     assert handoffInProgress == false.     assert pendingInSync.isEmpty() : "relocation handoff started while there are still shard copies pending in-sync: " + pendingInSync.     handoffInProgress = true.     // copy clusterStateVersion and checkpoints and return     // all the entries from checkpoints that are inSync: the reason we don't need to care about initializing non-insync entries     // is that they will have to undergo a recovery attempt on the relocation target, and will hence be supplied by the cluster state     // update on the relocation target once relocation completes). We could alternatively also copy the map as-is (it’s safe), and it     // would be cleaned up on the target by cluster state updates.     Map<String, CheckpointState> localCheckpointsCopy = new HashMap<>().     for (Map.Entry<String, CheckpointState> entry : checkpoints.entrySet()) {         localCheckpointsCopy.put(entry.getKey(), entry.getValue().copy()).     }     assert invariant().     return new PrimaryContext(appliedClusterStateVersion, localCheckpointsCopy, routingTable). }
true;public,synchronized;0;7;/**  * Fails a relocation handoff attempt.  */ ;/**  * Fails a relocation handoff attempt.  */ public synchronized void abortRelocationHandoff() {     assert invariant().     assert primaryMode.     assert handoffInProgress.     handoffInProgress = false.     assert invariant(). }
true;public,synchronized;0;25;/**  * Marks a relocation handoff attempt as successful. Moves the tracker into replica mode.  */ ;/**  * Marks a relocation handoff attempt as successful. Moves the tracker into replica mode.  */ public synchronized void completeRelocationHandoff() {     assert invariant().     assert primaryMode.     assert handoffInProgress.     assert relocated == false.     primaryMode = false.     handoffInProgress = false.     relocated = true.     // forget all checkpoint information except for global checkpoint of current shard     checkpoints.entrySet().stream().forEach(e -> {         final CheckpointState cps = e.getValue().         if (cps.localCheckpoint != SequenceNumbers.UNASSIGNED_SEQ_NO && cps.localCheckpoint != SequenceNumbers.PRE_60_NODE_CHECKPOINT) {             cps.localCheckpoint = SequenceNumbers.UNASSIGNED_SEQ_NO.         }         if (e.getKey().equals(shardAllocationId) == false) {             // don't throw global checkpoint information of current shard away             if (cps.globalCheckpoint != SequenceNumbers.UNASSIGNED_SEQ_NO && cps.globalCheckpoint != SequenceNumbers.PRE_60_NODE_CHECKPOINT) {                 cps.globalCheckpoint = SequenceNumbers.UNASSIGNED_SEQ_NO.             }         }     }).     assert invariant(). }
true;public,synchronized;1;20;/**  * Activates the global checkpoint tracker in primary mode (see {@link #primaryMode}. Called on primary relocation target during  * primary relocation handoff.  *  * @param primaryContext the primary context used to initialize the state  */ ;/**  * Activates the global checkpoint tracker in primary mode (see {@link #primaryMode}. Called on primary relocation target during  * primary relocation handoff.  *  * @param primaryContext the primary context used to initialize the state  */ public synchronized void activateWithPrimaryContext(PrimaryContext primaryContext) {     assert invariant().     assert primaryMode == false.     final Runnable runAfter = getMasterUpdateOperationFromCurrentState().     primaryMode = true.     // capture current state to possibly replay missed cluster state update     appliedClusterStateVersion = primaryContext.clusterStateVersion().     checkpoints.clear().     for (Map.Entry<String, CheckpointState> entry : primaryContext.checkpoints.entrySet()) {         checkpoints.put(entry.getKey(), entry.getValue().copy()).     }     routingTable = primaryContext.getRoutingTable().     replicationGroup = calculateReplicationGroup().     updateGlobalCheckpointOnPrimary().     // reapply missed cluster state update     // note that if there was no cluster state update between start of the engine of this shard and the call to     // initializeWithPrimaryContext, we might still have missed a cluster state update. This is best effort.     runAfter.run().     assert invariant(). }
false;private;0;16;;private Runnable getMasterUpdateOperationFromCurrentState() {     assert primaryMode == false.     final long lastAppliedClusterStateVersion = appliedClusterStateVersion.     final Set<String> inSyncAllocationIds = new HashSet<>().     final Set<String> pre60AllocationIds = new HashSet<>().     checkpoints.entrySet().forEach(entry -> {         if (entry.getValue().inSync) {             inSyncAllocationIds.add(entry.getKey()).         }         if (entry.getValue().getLocalCheckpoint() == SequenceNumbers.PRE_60_NODE_CHECKPOINT) {             pre60AllocationIds.add(entry.getKey()).         }     }).     final IndexShardRoutingTable lastAppliedRoutingTable = routingTable.     return () -> updateFromMaster(lastAppliedClusterStateVersion, inSyncAllocationIds, lastAppliedRoutingTable, pre60AllocationIds). }
true;public,synchronized;0;4;/**  * Whether the are shards blocking global checkpoint advancement. Used by tests.  */ ;/**  * Whether the are shards blocking global checkpoint advancement. Used by tests.  */ public synchronized boolean pendingInSync() {     assert primaryMode.     return pendingInSync.isEmpty() == false. }
true;public,synchronized;1;4;/**  * Returns the local checkpoint information tracked for a specific shard. Used by tests.  */ ;/**  * Returns the local checkpoint information tracked for a specific shard. Used by tests.  */ public synchronized CheckpointState getTrackedLocalCheckpointForShard(String allocationId) {     assert primaryMode.     return checkpoints.get(allocationId). }
true;private,synchronized;0;4;/**  * Notify all threads waiting on the monitor on this tracker. These threads should be waiting for the local checkpoint on a specific  * allocation ID to catch up to the global checkpoint.  */ ;/**  * Notify all threads waiting on the monitor on this tracker. These threads should be waiting for the local checkpoint on a specific  * allocation ID to catch up to the global checkpoint.  */ @SuppressForbidden(reason = "Object#notifyAll waiters for local checkpoint advancement") private synchronized void notifyAllWaiters() {     this.notifyAll(). }
true;private,synchronized;0;4;/**  * Wait for the local checkpoint to advance to the global checkpoint.  *  * @throws InterruptedException if this thread was interrupted before of during waiting  */ ;/**  * Wait for the local checkpoint to advance to the global checkpoint.  *  * @throws InterruptedException if this thread was interrupted before of during waiting  */ @SuppressForbidden(reason = "Object#wait for local checkpoint advancement") private synchronized void waitForLocalCheckpointToAdvance() throws InterruptedException {     this.wait(). }
false;public;0;3;;public long clusterStateVersion() {     return clusterStateVersion. }
false;public;0;3;;public Map<String, CheckpointState> getCheckpointStates() {     return checkpoints. }
false;public;0;3;;public IndexShardRoutingTable getRoutingTable() {     return routingTable. }
false;public;1;6;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeVLong(clusterStateVersion).     out.writeMap(checkpoints, (streamOutput, s) -> out.writeString(s), (streamOutput, cps) -> cps.writeTo(out)).     IndexShardRoutingTable.Builder.writeTo(routingTable, out). }
false;public;0;8;;@Override public String toString() {     return "PrimaryContext{" + "clusterStateVersion=" + clusterStateVersion + ", checkpoints=" + checkpoints + ", routingTable=" + routingTable + '}'. }
false;public;1;11;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     PrimaryContext that = (PrimaryContext) o.     if (clusterStateVersion != that.clusterStateVersion)         return false.     if (routingTable.equals(that.routingTable))         return false.     return routingTable.equals(that.routingTable). }
false;public;0;7;;@Override public int hashCode() {     int result = Long.hashCode(clusterStateVersion).     result = 31 * result + checkpoints.hashCode().     result = 31 * result + routingTable.hashCode().     return result. }
