# id;timestamp;commentText;codeText;commentWords;codeWords
ReplicationTracker -> public void setOperationPrimaryTerm(final long operationPrimaryTerm);1548944389;Sets the current operation primary term. This method should be invoked only when no other operations are possible on the shard. That_is, either from the constructor of {@link IndexShard} or while holding all permits on the {@link IndexShard} instance.__@param operationPrimaryTerm the new operation primary term;public void setOperationPrimaryTerm(final long operationPrimaryTerm) {_        this.operationPrimaryTerm = operationPrimaryTerm__    };sets,the,current,operation,primary,term,this,method,should,be,invoked,only,when,no,other,operations,are,possible,on,the,shard,that,is,either,from,the,constructor,of,link,index,shard,or,while,holding,all,permits,on,the,link,index,shard,instance,param,operation,primary,term,the,new,operation,primary,term;public,void,set,operation,primary,term,final,long,operation,primary,term,this,operation,primary,term,operation,primary,term
ReplicationTracker -> public void setOperationPrimaryTerm(final long operationPrimaryTerm);1549059559;Sets the current operation primary term. This method should be invoked only when no other operations are possible on the shard. That_is, either from the constructor of {@link IndexShard} or while holding all permits on the {@link IndexShard} instance.__@param operationPrimaryTerm the new operation primary term;public void setOperationPrimaryTerm(final long operationPrimaryTerm) {_        this.operationPrimaryTerm = operationPrimaryTerm__    };sets,the,current,operation,primary,term,this,method,should,be,invoked,only,when,no,other,operations,are,possible,on,the,shard,that,is,either,from,the,constructor,of,link,index,shard,or,while,holding,all,permits,on,the,link,index,shard,instance,param,operation,primary,term,the,new,operation,primary,term;public,void,set,operation,primary,term,final,long,operation,primary,term,this,operation,primary,term,operation,primary,term
ReplicationTracker -> public void setOperationPrimaryTerm(final long operationPrimaryTerm);1549294529;Sets the current operation primary term. This method should be invoked only when no other operations are possible on the shard. That_is, either from the constructor of {@link IndexShard} or while holding all permits on the {@link IndexShard} instance.__@param operationPrimaryTerm the new operation primary term;public void setOperationPrimaryTerm(final long operationPrimaryTerm) {_        this.operationPrimaryTerm = operationPrimaryTerm__    };sets,the,current,operation,primary,term,this,method,should,be,invoked,only,when,no,other,operations,are,possible,on,the,shard,that,is,either,from,the,constructor,of,link,index,shard,or,while,holding,all,permits,on,the,link,index,shard,instance,param,operation,primary,term,the,new,operation,primary,term;public,void,set,operation,primary,term,final,long,operation,primary,term,this,operation,primary,term,operation,primary,term
ReplicationTracker -> public void setOperationPrimaryTerm(final long operationPrimaryTerm);1549395737;Sets the current operation primary term. This method should be invoked only when no other operations are possible on the shard. That_is, either from the constructor of {@link IndexShard} or while holding all permits on the {@link IndexShard} instance.__@param operationPrimaryTerm the new operation primary term;public void setOperationPrimaryTerm(final long operationPrimaryTerm) {_        this.operationPrimaryTerm = operationPrimaryTerm__    };sets,the,current,operation,primary,term,this,method,should,be,invoked,only,when,no,other,operations,are,possible,on,the,shard,that,is,either,from,the,constructor,of,link,index,shard,or,while,holding,all,permits,on,the,link,index,shard,instance,param,operation,primary,term,the,new,operation,primary,term;public,void,set,operation,primary,term,final,long,operation,primary,term,this,operation,primary,term,operation,primary,term
ReplicationTracker -> public void setOperationPrimaryTerm(final long operationPrimaryTerm);1549937843;Sets the current operation primary term. This method should be invoked only when no other operations are possible on the shard. That_is, either from the constructor of {@link IndexShard} or while holding all permits on the {@link IndexShard} instance.__@param operationPrimaryTerm the new operation primary term;public void setOperationPrimaryTerm(final long operationPrimaryTerm) {_        this.operationPrimaryTerm = operationPrimaryTerm__    };sets,the,current,operation,primary,term,this,method,should,be,invoked,only,when,no,other,operations,are,possible,on,the,shard,that,is,either,from,the,constructor,of,link,index,shard,or,while,holding,all,permits,on,the,link,index,shard,instance,param,operation,primary,term,the,new,operation,primary,term;public,void,set,operation,primary,term,final,long,operation,primary,term,this,operation,primary,term,operation,primary,term
ReplicationTracker -> public void setOperationPrimaryTerm(final long operationPrimaryTerm);1549949489;Sets the current operation primary term. This method should be invoked only when no other operations are possible on the shard. That_is, either from the constructor of {@link IndexShard} or while holding all permits on the {@link IndexShard} instance.__@param operationPrimaryTerm the new operation primary term;public void setOperationPrimaryTerm(final long operationPrimaryTerm) {_        this.operationPrimaryTerm = operationPrimaryTerm__    };sets,the,current,operation,primary,term,this,method,should,be,invoked,only,when,no,other,operations,are,possible,on,the,shard,that,is,either,from,the,constructor,of,link,index,shard,or,while,holding,all,permits,on,the,link,index,shard,instance,param,operation,primary,term,the,new,operation,primary,term;public,void,set,operation,primary,term,final,long,operation,primary,term,this,operation,primary,term,operation,primary,term
ReplicationTracker -> public void setOperationPrimaryTerm(final long operationPrimaryTerm);1550526771;Sets the current operation primary term. This method should be invoked only when no other operations are possible on the shard. That_is, either from the constructor of {@link IndexShard} or while holding all permits on the {@link IndexShard} instance.__@param operationPrimaryTerm the new operation primary term;public void setOperationPrimaryTerm(final long operationPrimaryTerm) {_        this.operationPrimaryTerm = operationPrimaryTerm__    };sets,the,current,operation,primary,term,this,method,should,be,invoked,only,when,no,other,operations,are,possible,on,the,shard,that,is,either,from,the,constructor,of,link,index,shard,or,while,holding,all,permits,on,the,link,index,shard,instance,param,operation,primary,term,the,new,operation,primary,term;public,void,set,operation,primary,term,final,long,operation,primary,term,this,operation,primary,term,operation,primary,term
ReplicationTracker -> public ReplicationTracker(             final ShardId shardId,             final String allocationId,             final IndexSettings indexSettings,             final long operationPrimaryTerm,             final long globalCheckpoint,             final LongConsumer onGlobalCheckpointUpdated,             final LongSupplier currentTimeMillisSupplier,             final BiConsumer<RetentionLeases, ActionListener<ReplicationResponse>> onSyncRetentionLeases);1549059559;Initialize the global checkpoint service. The specified global checkpoint should be set to the last known global checkpoint, or_{@link SequenceNumbers#UNASSIGNED_SEQ_NO}.__@param shardId               the shard ID_@param allocationId          the allocation ID_@param indexSettings         the index settings_@param operationPrimaryTerm  the current primary term_@param globalCheckpoint      the last known global checkpoint for this shard, or {@link SequenceNumbers#UNASSIGNED_SEQ_NO}_@param onSyncRetentionLeases a callback when a new retention lease is created or an existing retention lease expires;public ReplicationTracker(_            final ShardId shardId,_            final String allocationId,_            final IndexSettings indexSettings,_            final long operationPrimaryTerm,_            final long globalCheckpoint,_            final LongConsumer onGlobalCheckpointUpdated,_            final LongSupplier currentTimeMillisSupplier,_            final BiConsumer<RetentionLeases, ActionListener<ReplicationResponse>> onSyncRetentionLeases) {_        super(shardId, indexSettings)__        assert globalCheckpoint >= SequenceNumbers.UNASSIGNED_SEQ_NO : "illegal initial global checkpoint: " + globalCheckpoint__        this.shardAllocationId = allocationId__        this.primaryMode = false__        this.operationPrimaryTerm = operationPrimaryTerm__        this.handoffInProgress = false__        this.appliedClusterStateVersion = -1L__        this.checkpoints = new HashMap<>(1 + indexSettings.getNumberOfReplicas())__        checkpoints.put(allocationId, new CheckpointState(SequenceNumbers.UNASSIGNED_SEQ_NO, globalCheckpoint, false, false))__        this.onGlobalCheckpointUpdated = Objects.requireNonNull(onGlobalCheckpointUpdated)__        this.currentTimeMillisSupplier = Objects.requireNonNull(currentTimeMillisSupplier)__        this.onSyncRetentionLeases = Objects.requireNonNull(onSyncRetentionLeases)__        this.pendingInSync = new HashSet<>()__        this.routingTable = null__        this.replicationGroup = null__        assert invariant()__    };initialize,the,global,checkpoint,service,the,specified,global,checkpoint,should,be,set,to,the,last,known,global,checkpoint,or,link,sequence,numbers,param,shard,id,the,shard,id,param,allocation,id,the,allocation,id,param,index,settings,the,index,settings,param,operation,primary,term,the,current,primary,term,param,global,checkpoint,the,last,known,global,checkpoint,for,this,shard,or,link,sequence,numbers,param,on,sync,retention,leases,a,callback,when,a,new,retention,lease,is,created,or,an,existing,retention,lease,expires;public,replication,tracker,final,shard,id,shard,id,final,string,allocation,id,final,index,settings,index,settings,final,long,operation,primary,term,final,long,global,checkpoint,final,long,consumer,on,global,checkpoint,updated,final,long,supplier,current,time,millis,supplier,final,bi,consumer,retention,leases,action,listener,replication,response,on,sync,retention,leases,super,shard,id,index,settings,assert,global,checkpoint,sequence,numbers,illegal,initial,global,checkpoint,global,checkpoint,this,shard,allocation,id,allocation,id,this,primary,mode,false,this,operation,primary,term,operation,primary,term,this,handoff,in,progress,false,this,applied,cluster,state,version,1l,this,checkpoints,new,hash,map,1,index,settings,get,number,of,replicas,checkpoints,put,allocation,id,new,checkpoint,state,sequence,numbers,global,checkpoint,false,false,this,on,global,checkpoint,updated,objects,require,non,null,on,global,checkpoint,updated,this,current,time,millis,supplier,objects,require,non,null,current,time,millis,supplier,this,on,sync,retention,leases,objects,require,non,null,on,sync,retention,leases,this,pending,in,sync,new,hash,set,this,routing,table,null,this,replication,group,null,assert,invariant
ReplicationTracker -> public ReplicationTracker(             final ShardId shardId,             final String allocationId,             final IndexSettings indexSettings,             final long operationPrimaryTerm,             final long globalCheckpoint,             final LongConsumer onGlobalCheckpointUpdated,             final LongSupplier currentTimeMillisSupplier,             final BiConsumer<RetentionLeases, ActionListener<ReplicationResponse>> onSyncRetentionLeases);1549294529;Initialize the global checkpoint service. The specified global checkpoint should be set to the last known global checkpoint, or_{@link SequenceNumbers#UNASSIGNED_SEQ_NO}.__@param shardId               the shard ID_@param allocationId          the allocation ID_@param indexSettings         the index settings_@param operationPrimaryTerm  the current primary term_@param globalCheckpoint      the last known global checkpoint for this shard, or {@link SequenceNumbers#UNASSIGNED_SEQ_NO}_@param onSyncRetentionLeases a callback when a new retention lease is created or an existing retention lease expires;public ReplicationTracker(_            final ShardId shardId,_            final String allocationId,_            final IndexSettings indexSettings,_            final long operationPrimaryTerm,_            final long globalCheckpoint,_            final LongConsumer onGlobalCheckpointUpdated,_            final LongSupplier currentTimeMillisSupplier,_            final BiConsumer<RetentionLeases, ActionListener<ReplicationResponse>> onSyncRetentionLeases) {_        super(shardId, indexSettings)__        assert globalCheckpoint >= SequenceNumbers.UNASSIGNED_SEQ_NO : "illegal initial global checkpoint: " + globalCheckpoint__        this.shardAllocationId = allocationId__        this.primaryMode = false__        this.operationPrimaryTerm = operationPrimaryTerm__        this.handoffInProgress = false__        this.appliedClusterStateVersion = -1L__        this.checkpoints = new HashMap<>(1 + indexSettings.getNumberOfReplicas())__        checkpoints.put(allocationId, new CheckpointState(SequenceNumbers.UNASSIGNED_SEQ_NO, globalCheckpoint, false, false))__        this.onGlobalCheckpointUpdated = Objects.requireNonNull(onGlobalCheckpointUpdated)__        this.currentTimeMillisSupplier = Objects.requireNonNull(currentTimeMillisSupplier)__        this.onSyncRetentionLeases = Objects.requireNonNull(onSyncRetentionLeases)__        this.pendingInSync = new HashSet<>()__        this.routingTable = null__        this.replicationGroup = null__        assert invariant()__    };initialize,the,global,checkpoint,service,the,specified,global,checkpoint,should,be,set,to,the,last,known,global,checkpoint,or,link,sequence,numbers,param,shard,id,the,shard,id,param,allocation,id,the,allocation,id,param,index,settings,the,index,settings,param,operation,primary,term,the,current,primary,term,param,global,checkpoint,the,last,known,global,checkpoint,for,this,shard,or,link,sequence,numbers,param,on,sync,retention,leases,a,callback,when,a,new,retention,lease,is,created,or,an,existing,retention,lease,expires;public,replication,tracker,final,shard,id,shard,id,final,string,allocation,id,final,index,settings,index,settings,final,long,operation,primary,term,final,long,global,checkpoint,final,long,consumer,on,global,checkpoint,updated,final,long,supplier,current,time,millis,supplier,final,bi,consumer,retention,leases,action,listener,replication,response,on,sync,retention,leases,super,shard,id,index,settings,assert,global,checkpoint,sequence,numbers,illegal,initial,global,checkpoint,global,checkpoint,this,shard,allocation,id,allocation,id,this,primary,mode,false,this,operation,primary,term,operation,primary,term,this,handoff,in,progress,false,this,applied,cluster,state,version,1l,this,checkpoints,new,hash,map,1,index,settings,get,number,of,replicas,checkpoints,put,allocation,id,new,checkpoint,state,sequence,numbers,global,checkpoint,false,false,this,on,global,checkpoint,updated,objects,require,non,null,on,global,checkpoint,updated,this,current,time,millis,supplier,objects,require,non,null,current,time,millis,supplier,this,on,sync,retention,leases,objects,require,non,null,on,sync,retention,leases,this,pending,in,sync,new,hash,set,this,routing,table,null,this,replication,group,null,assert,invariant
ReplicationTracker -> public ReplicationTracker(             final ShardId shardId,             final String allocationId,             final IndexSettings indexSettings,             final long operationPrimaryTerm,             final long globalCheckpoint,             final LongConsumer onGlobalCheckpointUpdated,             final LongSupplier currentTimeMillisSupplier,             final BiConsumer<RetentionLeases, ActionListener<ReplicationResponse>> onSyncRetentionLeases);1549937843;Initialize the global checkpoint service. The specified global checkpoint should be set to the last known global checkpoint, or_{@link SequenceNumbers#UNASSIGNED_SEQ_NO}.__@param shardId               the shard ID_@param allocationId          the allocation ID_@param indexSettings         the index settings_@param operationPrimaryTerm  the current primary term_@param globalCheckpoint      the last known global checkpoint for this shard, or {@link SequenceNumbers#UNASSIGNED_SEQ_NO}_@param onSyncRetentionLeases a callback when a new retention lease is created or an existing retention lease expires;public ReplicationTracker(_            final ShardId shardId,_            final String allocationId,_            final IndexSettings indexSettings,_            final long operationPrimaryTerm,_            final long globalCheckpoint,_            final LongConsumer onGlobalCheckpointUpdated,_            final LongSupplier currentTimeMillisSupplier,_            final BiConsumer<RetentionLeases, ActionListener<ReplicationResponse>> onSyncRetentionLeases) {_        super(shardId, indexSettings)__        assert globalCheckpoint >= SequenceNumbers.UNASSIGNED_SEQ_NO : "illegal initial global checkpoint: " + globalCheckpoint__        this.shardAllocationId = allocationId__        this.primaryMode = false__        this.operationPrimaryTerm = operationPrimaryTerm__        this.handoffInProgress = false__        this.appliedClusterStateVersion = -1L__        this.checkpoints = new HashMap<>(1 + indexSettings.getNumberOfReplicas())__        checkpoints.put(allocationId, new CheckpointState(SequenceNumbers.UNASSIGNED_SEQ_NO, globalCheckpoint, false, false))__        this.onGlobalCheckpointUpdated = Objects.requireNonNull(onGlobalCheckpointUpdated)__        this.currentTimeMillisSupplier = Objects.requireNonNull(currentTimeMillisSupplier)__        this.onSyncRetentionLeases = Objects.requireNonNull(onSyncRetentionLeases)__        this.pendingInSync = new HashSet<>()__        this.routingTable = null__        this.replicationGroup = null__        assert invariant()__    };initialize,the,global,checkpoint,service,the,specified,global,checkpoint,should,be,set,to,the,last,known,global,checkpoint,or,link,sequence,numbers,param,shard,id,the,shard,id,param,allocation,id,the,allocation,id,param,index,settings,the,index,settings,param,operation,primary,term,the,current,primary,term,param,global,checkpoint,the,last,known,global,checkpoint,for,this,shard,or,link,sequence,numbers,param,on,sync,retention,leases,a,callback,when,a,new,retention,lease,is,created,or,an,existing,retention,lease,expires;public,replication,tracker,final,shard,id,shard,id,final,string,allocation,id,final,index,settings,index,settings,final,long,operation,primary,term,final,long,global,checkpoint,final,long,consumer,on,global,checkpoint,updated,final,long,supplier,current,time,millis,supplier,final,bi,consumer,retention,leases,action,listener,replication,response,on,sync,retention,leases,super,shard,id,index,settings,assert,global,checkpoint,sequence,numbers,illegal,initial,global,checkpoint,global,checkpoint,this,shard,allocation,id,allocation,id,this,primary,mode,false,this,operation,primary,term,operation,primary,term,this,handoff,in,progress,false,this,applied,cluster,state,version,1l,this,checkpoints,new,hash,map,1,index,settings,get,number,of,replicas,checkpoints,put,allocation,id,new,checkpoint,state,sequence,numbers,global,checkpoint,false,false,this,on,global,checkpoint,updated,objects,require,non,null,on,global,checkpoint,updated,this,current,time,millis,supplier,objects,require,non,null,current,time,millis,supplier,this,on,sync,retention,leases,objects,require,non,null,on,sync,retention,leases,this,pending,in,sync,new,hash,set,this,routing,table,null,this,replication,group,null,assert,invariant
ReplicationTracker -> public ReplicationTracker(             final ShardId shardId,             final String allocationId,             final IndexSettings indexSettings,             final long operationPrimaryTerm,             final long globalCheckpoint,             final LongConsumer onGlobalCheckpointUpdated,             final LongSupplier currentTimeMillisSupplier,             final BiConsumer<RetentionLeases, ActionListener<ReplicationResponse>> onSyncRetentionLeases);1549949489;Initialize the global checkpoint service. The specified global checkpoint should be set to the last known global checkpoint, or_{@link SequenceNumbers#UNASSIGNED_SEQ_NO}.__@param shardId               the shard ID_@param allocationId          the allocation ID_@param indexSettings         the index settings_@param operationPrimaryTerm  the current primary term_@param globalCheckpoint      the last known global checkpoint for this shard, or {@link SequenceNumbers#UNASSIGNED_SEQ_NO}_@param onSyncRetentionLeases a callback when a new retention lease is created or an existing retention lease expires;public ReplicationTracker(_            final ShardId shardId,_            final String allocationId,_            final IndexSettings indexSettings,_            final long operationPrimaryTerm,_            final long globalCheckpoint,_            final LongConsumer onGlobalCheckpointUpdated,_            final LongSupplier currentTimeMillisSupplier,_            final BiConsumer<RetentionLeases, ActionListener<ReplicationResponse>> onSyncRetentionLeases) {_        super(shardId, indexSettings)__        assert globalCheckpoint >= SequenceNumbers.UNASSIGNED_SEQ_NO : "illegal initial global checkpoint: " + globalCheckpoint__        this.shardAllocationId = allocationId__        this.primaryMode = false__        this.operationPrimaryTerm = operationPrimaryTerm__        this.handoffInProgress = false__        this.appliedClusterStateVersion = -1L__        this.checkpoints = new HashMap<>(1 + indexSettings.getNumberOfReplicas())__        checkpoints.put(allocationId, new CheckpointState(SequenceNumbers.UNASSIGNED_SEQ_NO, globalCheckpoint, false, false))__        this.onGlobalCheckpointUpdated = Objects.requireNonNull(onGlobalCheckpointUpdated)__        this.currentTimeMillisSupplier = Objects.requireNonNull(currentTimeMillisSupplier)__        this.onSyncRetentionLeases = Objects.requireNonNull(onSyncRetentionLeases)__        this.pendingInSync = new HashSet<>()__        this.routingTable = null__        this.replicationGroup = null__        assert invariant()__    };initialize,the,global,checkpoint,service,the,specified,global,checkpoint,should,be,set,to,the,last,known,global,checkpoint,or,link,sequence,numbers,param,shard,id,the,shard,id,param,allocation,id,the,allocation,id,param,index,settings,the,index,settings,param,operation,primary,term,the,current,primary,term,param,global,checkpoint,the,last,known,global,checkpoint,for,this,shard,or,link,sequence,numbers,param,on,sync,retention,leases,a,callback,when,a,new,retention,lease,is,created,or,an,existing,retention,lease,expires;public,replication,tracker,final,shard,id,shard,id,final,string,allocation,id,final,index,settings,index,settings,final,long,operation,primary,term,final,long,global,checkpoint,final,long,consumer,on,global,checkpoint,updated,final,long,supplier,current,time,millis,supplier,final,bi,consumer,retention,leases,action,listener,replication,response,on,sync,retention,leases,super,shard,id,index,settings,assert,global,checkpoint,sequence,numbers,illegal,initial,global,checkpoint,global,checkpoint,this,shard,allocation,id,allocation,id,this,primary,mode,false,this,operation,primary,term,operation,primary,term,this,handoff,in,progress,false,this,applied,cluster,state,version,1l,this,checkpoints,new,hash,map,1,index,settings,get,number,of,replicas,checkpoints,put,allocation,id,new,checkpoint,state,sequence,numbers,global,checkpoint,false,false,this,on,global,checkpoint,updated,objects,require,non,null,on,global,checkpoint,updated,this,current,time,millis,supplier,objects,require,non,null,current,time,millis,supplier,this,on,sync,retention,leases,objects,require,non,null,on,sync,retention,leases,this,pending,in,sync,new,hash,set,this,routing,table,null,this,replication,group,null,assert,invariant
ReplicationTracker -> public ReplicationTracker(             final ShardId shardId,             final String allocationId,             final IndexSettings indexSettings,             final long operationPrimaryTerm,             final long globalCheckpoint,             final LongConsumer onGlobalCheckpointUpdated,             final LongSupplier currentTimeMillisSupplier,             final BiConsumer<RetentionLeases, ActionListener<ReplicationResponse>> onSyncRetentionLeases);1550526771;Initialize the global checkpoint service. The specified global checkpoint should be set to the last known global checkpoint, or_{@link SequenceNumbers#UNASSIGNED_SEQ_NO}.__@param shardId               the shard ID_@param allocationId          the allocation ID_@param indexSettings         the index settings_@param operationPrimaryTerm  the current primary term_@param globalCheckpoint      the last known global checkpoint for this shard, or {@link SequenceNumbers#UNASSIGNED_SEQ_NO}_@param onSyncRetentionLeases a callback when a new retention lease is created or an existing retention lease expires;public ReplicationTracker(_            final ShardId shardId,_            final String allocationId,_            final IndexSettings indexSettings,_            final long operationPrimaryTerm,_            final long globalCheckpoint,_            final LongConsumer onGlobalCheckpointUpdated,_            final LongSupplier currentTimeMillisSupplier,_            final BiConsumer<RetentionLeases, ActionListener<ReplicationResponse>> onSyncRetentionLeases) {_        super(shardId, indexSettings)__        assert globalCheckpoint >= SequenceNumbers.UNASSIGNED_SEQ_NO : "illegal initial global checkpoint: " + globalCheckpoint__        this.shardAllocationId = allocationId__        this.primaryMode = false__        this.operationPrimaryTerm = operationPrimaryTerm__        this.handoffInProgress = false__        this.appliedClusterStateVersion = -1L__        this.checkpoints = new HashMap<>(1 + indexSettings.getNumberOfReplicas())__        checkpoints.put(allocationId, new CheckpointState(SequenceNumbers.UNASSIGNED_SEQ_NO, globalCheckpoint, false, false))__        this.onGlobalCheckpointUpdated = Objects.requireNonNull(onGlobalCheckpointUpdated)__        this.currentTimeMillisSupplier = Objects.requireNonNull(currentTimeMillisSupplier)__        this.onSyncRetentionLeases = Objects.requireNonNull(onSyncRetentionLeases)__        this.pendingInSync = new HashSet<>()__        this.routingTable = null__        this.replicationGroup = null__        assert invariant()__    };initialize,the,global,checkpoint,service,the,specified,global,checkpoint,should,be,set,to,the,last,known,global,checkpoint,or,link,sequence,numbers,param,shard,id,the,shard,id,param,allocation,id,the,allocation,id,param,index,settings,the,index,settings,param,operation,primary,term,the,current,primary,term,param,global,checkpoint,the,last,known,global,checkpoint,for,this,shard,or,link,sequence,numbers,param,on,sync,retention,leases,a,callback,when,a,new,retention,lease,is,created,or,an,existing,retention,lease,expires;public,replication,tracker,final,shard,id,shard,id,final,string,allocation,id,final,index,settings,index,settings,final,long,operation,primary,term,final,long,global,checkpoint,final,long,consumer,on,global,checkpoint,updated,final,long,supplier,current,time,millis,supplier,final,bi,consumer,retention,leases,action,listener,replication,response,on,sync,retention,leases,super,shard,id,index,settings,assert,global,checkpoint,sequence,numbers,illegal,initial,global,checkpoint,global,checkpoint,this,shard,allocation,id,allocation,id,this,primary,mode,false,this,operation,primary,term,operation,primary,term,this,handoff,in,progress,false,this,applied,cluster,state,version,1l,this,checkpoints,new,hash,map,1,index,settings,get,number,of,replicas,checkpoints,put,allocation,id,new,checkpoint,state,sequence,numbers,global,checkpoint,false,false,this,on,global,checkpoint,updated,objects,require,non,null,on,global,checkpoint,updated,this,current,time,millis,supplier,objects,require,non,null,current,time,millis,supplier,this,on,sync,retention,leases,objects,require,non,null,on,sync,retention,leases,this,pending,in,sync,new,hash,set,this,routing,table,null,this,replication,group,null,assert,invariant
ReplicationTracker -> private static long computeGlobalCheckpoint(final Set<String> pendingInSync, final Collection<CheckpointState> localCheckpoints,                                                 final long fallback);1524684173;Computes the global checkpoint based on the given local checkpoints. In case where there are entries preventing the_computation to happen (for example due to blocking), it returns the fallback value.;private static long computeGlobalCheckpoint(final Set<String> pendingInSync, final Collection<CheckpointState> localCheckpoints,_                                                final long fallback) {_        long minLocalCheckpoint = Long.MAX_VALUE__        if (pendingInSync.isEmpty() == false) {_            return fallback__        }_        for (final CheckpointState cps : localCheckpoints) {_            if (cps.inSync) {_                if (cps.localCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO) {_                    _                    return fallback__                } else if (cps.localCheckpoint == SequenceNumbers.PRE_60_NODE_CHECKPOINT) {_                    _                } else {_                    minLocalCheckpoint = Math.min(cps.localCheckpoint, minLocalCheckpoint)__                }_            }_        }_        assert minLocalCheckpoint != Long.MAX_VALUE__        return minLocalCheckpoint__    };computes,the,global,checkpoint,based,on,the,given,local,checkpoints,in,case,where,there,are,entries,preventing,the,computation,to,happen,for,example,due,to,blocking,it,returns,the,fallback,value;private,static,long,compute,global,checkpoint,final,set,string,pending,in,sync,final,collection,checkpoint,state,local,checkpoints,final,long,fallback,long,min,local,checkpoint,long,if,pending,in,sync,is,empty,false,return,fallback,for,final,checkpoint,state,cps,local,checkpoints,if,cps,in,sync,if,cps,local,checkpoint,sequence,numbers,return,fallback,else,if,cps,local,checkpoint,sequence,numbers,else,min,local,checkpoint,math,min,cps,local,checkpoint,min,local,checkpoint,assert,min,local,checkpoint,long,return,min,local,checkpoint
ReplicationTracker -> private static long computeGlobalCheckpoint(final Set<String> pendingInSync, final Collection<CheckpointState> localCheckpoints,                                                 final long fallback);1525334055;Computes the global checkpoint based on the given local checkpoints. In case where there are entries preventing the_computation to happen (for example due to blocking), it returns the fallback value.;private static long computeGlobalCheckpoint(final Set<String> pendingInSync, final Collection<CheckpointState> localCheckpoints,_                                                final long fallback) {_        long minLocalCheckpoint = Long.MAX_VALUE__        if (pendingInSync.isEmpty() == false) {_            return fallback__        }_        for (final CheckpointState cps : localCheckpoints) {_            if (cps.inSync) {_                if (cps.localCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO) {_                    _                    return fallback__                } else if (cps.localCheckpoint == SequenceNumbers.PRE_60_NODE_CHECKPOINT) {_                    _                } else {_                    minLocalCheckpoint = Math.min(cps.localCheckpoint, minLocalCheckpoint)__                }_            }_        }_        assert minLocalCheckpoint != Long.MAX_VALUE__        return minLocalCheckpoint__    };computes,the,global,checkpoint,based,on,the,given,local,checkpoints,in,case,where,there,are,entries,preventing,the,computation,to,happen,for,example,due,to,blocking,it,returns,the,fallback,value;private,static,long,compute,global,checkpoint,final,set,string,pending,in,sync,final,collection,checkpoint,state,local,checkpoints,final,long,fallback,long,min,local,checkpoint,long,if,pending,in,sync,is,empty,false,return,fallback,for,final,checkpoint,state,cps,local,checkpoints,if,cps,in,sync,if,cps,local,checkpoint,sequence,numbers,return,fallback,else,if,cps,local,checkpoint,sequence,numbers,else,min,local,checkpoint,math,min,cps,local,checkpoint,min,local,checkpoint,assert,min,local,checkpoint,long,return,min,local,checkpoint
ReplicationTracker -> private static long computeGlobalCheckpoint(final Set<String> pendingInSync, final Collection<CheckpointState> localCheckpoints,                                                 final long fallback);1533295538;Computes the global checkpoint based on the given local checkpoints. In case where there are entries preventing the_computation to happen (for example due to blocking), it returns the fallback value.;private static long computeGlobalCheckpoint(final Set<String> pendingInSync, final Collection<CheckpointState> localCheckpoints,_                                                final long fallback) {_        long minLocalCheckpoint = Long.MAX_VALUE__        if (pendingInSync.isEmpty() == false) {_            return fallback__        }_        for (final CheckpointState cps : localCheckpoints) {_            if (cps.inSync) {_                if (cps.localCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO) {_                    _                    return fallback__                } else if (cps.localCheckpoint == SequenceNumbers.PRE_60_NODE_CHECKPOINT) {_                    _                } else {_                    minLocalCheckpoint = Math.min(cps.localCheckpoint, minLocalCheckpoint)__                }_            }_        }_        assert minLocalCheckpoint != Long.MAX_VALUE__        return minLocalCheckpoint__    };computes,the,global,checkpoint,based,on,the,given,local,checkpoints,in,case,where,there,are,entries,preventing,the,computation,to,happen,for,example,due,to,blocking,it,returns,the,fallback,value;private,static,long,compute,global,checkpoint,final,set,string,pending,in,sync,final,collection,checkpoint,state,local,checkpoints,final,long,fallback,long,min,local,checkpoint,long,if,pending,in,sync,is,empty,false,return,fallback,for,final,checkpoint,state,cps,local,checkpoints,if,cps,in,sync,if,cps,local,checkpoint,sequence,numbers,return,fallback,else,if,cps,local,checkpoint,sequence,numbers,else,min,local,checkpoint,math,min,cps,local,checkpoint,min,local,checkpoint,assert,min,local,checkpoint,long,return,min,local,checkpoint
ReplicationTracker -> private static long computeGlobalCheckpoint(final Set<String> pendingInSync, final Collection<CheckpointState> localCheckpoints,                                                 final long fallback);1533738061;Computes the global checkpoint based on the given local checkpoints. In case where there are entries preventing the_computation to happen (for example due to blocking), it returns the fallback value.;private static long computeGlobalCheckpoint(final Set<String> pendingInSync, final Collection<CheckpointState> localCheckpoints,_                                                final long fallback) {_        long minLocalCheckpoint = Long.MAX_VALUE__        if (pendingInSync.isEmpty() == false) {_            return fallback__        }_        for (final CheckpointState cps : localCheckpoints) {_            if (cps.inSync) {_                if (cps.localCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO) {_                    _                    return fallback__                } else if (cps.localCheckpoint == SequenceNumbers.PRE_60_NODE_CHECKPOINT) {_                    _                } else {_                    minLocalCheckpoint = Math.min(cps.localCheckpoint, minLocalCheckpoint)__                }_            }_        }_        assert minLocalCheckpoint != Long.MAX_VALUE__        return minLocalCheckpoint__    };computes,the,global,checkpoint,based,on,the,given,local,checkpoints,in,case,where,there,are,entries,preventing,the,computation,to,happen,for,example,due,to,blocking,it,returns,the,fallback,value;private,static,long,compute,global,checkpoint,final,set,string,pending,in,sync,final,collection,checkpoint,state,local,checkpoints,final,long,fallback,long,min,local,checkpoint,long,if,pending,in,sync,is,empty,false,return,fallback,for,final,checkpoint,state,cps,local,checkpoints,if,cps,in,sync,if,cps,local,checkpoint,sequence,numbers,return,fallback,else,if,cps,local,checkpoint,sequence,numbers,else,min,local,checkpoint,math,min,cps,local,checkpoint,min,local,checkpoint,assert,min,local,checkpoint,long,return,min,local,checkpoint
ReplicationTracker -> private static long computeGlobalCheckpoint(final Set<String> pendingInSync, final Collection<CheckpointState> localCheckpoints,                                                 final long fallback);1546875837;Computes the global checkpoint based on the given local checkpoints. In case where there are entries preventing the_computation to happen (for example due to blocking), it returns the fallback value.;private static long computeGlobalCheckpoint(final Set<String> pendingInSync, final Collection<CheckpointState> localCheckpoints,_                                                final long fallback) {_        long minLocalCheckpoint = Long.MAX_VALUE__        if (pendingInSync.isEmpty() == false) {_            return fallback__        }_        for (final CheckpointState cps : localCheckpoints) {_            if (cps.inSync) {_                if (cps.localCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO) {_                    _                    return fallback__                } else if (cps.localCheckpoint == SequenceNumbers.PRE_60_NODE_CHECKPOINT) {_                    _                } else {_                    minLocalCheckpoint = Math.min(cps.localCheckpoint, minLocalCheckpoint)__                }_            }_        }_        assert minLocalCheckpoint != Long.MAX_VALUE__        return minLocalCheckpoint__    };computes,the,global,checkpoint,based,on,the,given,local,checkpoints,in,case,where,there,are,entries,preventing,the,computation,to,happen,for,example,due,to,blocking,it,returns,the,fallback,value;private,static,long,compute,global,checkpoint,final,set,string,pending,in,sync,final,collection,checkpoint,state,local,checkpoints,final,long,fallback,long,min,local,checkpoint,long,if,pending,in,sync,is,empty,false,return,fallback,for,final,checkpoint,state,cps,local,checkpoints,if,cps,in,sync,if,cps,local,checkpoint,sequence,numbers,return,fallback,else,if,cps,local,checkpoint,sequence,numbers,else,min,local,checkpoint,math,min,cps,local,checkpoint,min,local,checkpoint,assert,min,local,checkpoint,long,return,min,local,checkpoint
ReplicationTracker -> private static long computeGlobalCheckpoint(final Set<String> pendingInSync, final Collection<CheckpointState> localCheckpoints,                                                 final long fallback);1546927432;Computes the global checkpoint based on the given local checkpoints. In case where there are entries preventing the_computation to happen (for example due to blocking), it returns the fallback value.;private static long computeGlobalCheckpoint(final Set<String> pendingInSync, final Collection<CheckpointState> localCheckpoints,_                                                final long fallback) {_        long minLocalCheckpoint = Long.MAX_VALUE__        if (pendingInSync.isEmpty() == false) {_            return fallback__        }_        for (final CheckpointState cps : localCheckpoints) {_            if (cps.inSync) {_                if (cps.localCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO) {_                    _                    return fallback__                } else if (cps.localCheckpoint == SequenceNumbers.PRE_60_NODE_CHECKPOINT) {_                    _                } else {_                    minLocalCheckpoint = Math.min(cps.localCheckpoint, minLocalCheckpoint)__                }_            }_        }_        assert minLocalCheckpoint != Long.MAX_VALUE__        return minLocalCheckpoint__    };computes,the,global,checkpoint,based,on,the,given,local,checkpoints,in,case,where,there,are,entries,preventing,the,computation,to,happen,for,example,due,to,blocking,it,returns,the,fallback,value;private,static,long,compute,global,checkpoint,final,set,string,pending,in,sync,final,collection,checkpoint,state,local,checkpoints,final,long,fallback,long,min,local,checkpoint,long,if,pending,in,sync,is,empty,false,return,fallback,for,final,checkpoint,state,cps,local,checkpoints,if,cps,in,sync,if,cps,local,checkpoint,sequence,numbers,return,fallback,else,if,cps,local,checkpoint,sequence,numbers,else,min,local,checkpoint,math,min,cps,local,checkpoint,min,local,checkpoint,assert,min,local,checkpoint,long,return,min,local,checkpoint
ReplicationTracker -> private static long computeGlobalCheckpoint(final Set<String> pendingInSync, final Collection<CheckpointState> localCheckpoints,                                                 final long fallback);1547332999;Computes the global checkpoint based on the given local checkpoints. In case where there are entries preventing the_computation to happen (for example due to blocking), it returns the fallback value.;private static long computeGlobalCheckpoint(final Set<String> pendingInSync, final Collection<CheckpointState> localCheckpoints,_                                                final long fallback) {_        long minLocalCheckpoint = Long.MAX_VALUE__        if (pendingInSync.isEmpty() == false) {_            return fallback__        }_        for (final CheckpointState cps : localCheckpoints) {_            if (cps.inSync) {_                if (cps.localCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO) {_                    _                    return fallback__                } else if (cps.localCheckpoint == SequenceNumbers.PRE_60_NODE_CHECKPOINT) {_                    _                } else {_                    minLocalCheckpoint = Math.min(cps.localCheckpoint, minLocalCheckpoint)__                }_            }_        }_        assert minLocalCheckpoint != Long.MAX_VALUE__        return minLocalCheckpoint__    };computes,the,global,checkpoint,based,on,the,given,local,checkpoints,in,case,where,there,are,entries,preventing,the,computation,to,happen,for,example,due,to,blocking,it,returns,the,fallback,value;private,static,long,compute,global,checkpoint,final,set,string,pending,in,sync,final,collection,checkpoint,state,local,checkpoints,final,long,fallback,long,min,local,checkpoint,long,if,pending,in,sync,is,empty,false,return,fallback,for,final,checkpoint,state,cps,local,checkpoints,if,cps,in,sync,if,cps,local,checkpoint,sequence,numbers,return,fallback,else,if,cps,local,checkpoint,sequence,numbers,else,min,local,checkpoint,math,min,cps,local,checkpoint,min,local,checkpoint,assert,min,local,checkpoint,long,return,min,local,checkpoint
ReplicationTracker -> private static long computeGlobalCheckpoint(final Set<String> pendingInSync, final Collection<CheckpointState> localCheckpoints,                                                 final long fallback);1548593396;Computes the global checkpoint based on the given local checkpoints. In case where there are entries preventing the_computation to happen (for example due to blocking), it returns the fallback value.;private static long computeGlobalCheckpoint(final Set<String> pendingInSync, final Collection<CheckpointState> localCheckpoints,_                                                final long fallback) {_        long minLocalCheckpoint = Long.MAX_VALUE__        if (pendingInSync.isEmpty() == false) {_            return fallback__        }_        for (final CheckpointState cps : localCheckpoints) {_            if (cps.inSync) {_                if (cps.localCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO) {_                    _                    return fallback__                } else if (cps.localCheckpoint == SequenceNumbers.PRE_60_NODE_CHECKPOINT) {_                    _                } else {_                    minLocalCheckpoint = Math.min(cps.localCheckpoint, minLocalCheckpoint)__                }_            }_        }_        assert minLocalCheckpoint != Long.MAX_VALUE__        return minLocalCheckpoint__    };computes,the,global,checkpoint,based,on,the,given,local,checkpoints,in,case,where,there,are,entries,preventing,the,computation,to,happen,for,example,due,to,blocking,it,returns,the,fallback,value;private,static,long,compute,global,checkpoint,final,set,string,pending,in,sync,final,collection,checkpoint,state,local,checkpoints,final,long,fallback,long,min,local,checkpoint,long,if,pending,in,sync,is,empty,false,return,fallback,for,final,checkpoint,state,cps,local,checkpoints,if,cps,in,sync,if,cps,local,checkpoint,sequence,numbers,return,fallback,else,if,cps,local,checkpoint,sequence,numbers,else,min,local,checkpoint,math,min,cps,local,checkpoint,min,local,checkpoint,assert,min,local,checkpoint,long,return,min,local,checkpoint
ReplicationTracker -> private static long computeGlobalCheckpoint(final Set<String> pendingInSync, final Collection<CheckpointState> localCheckpoints,                                                 final long fallback);1548594827;Computes the global checkpoint based on the given local checkpoints. In case where there are entries preventing the_computation to happen (for example due to blocking), it returns the fallback value.;private static long computeGlobalCheckpoint(final Set<String> pendingInSync, final Collection<CheckpointState> localCheckpoints,_                                                final long fallback) {_        long minLocalCheckpoint = Long.MAX_VALUE__        if (pendingInSync.isEmpty() == false) {_            return fallback__        }_        for (final CheckpointState cps : localCheckpoints) {_            if (cps.inSync) {_                if (cps.localCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO) {_                    _                    return fallback__                } else if (cps.localCheckpoint == SequenceNumbers.PRE_60_NODE_CHECKPOINT) {_                    _                } else {_                    minLocalCheckpoint = Math.min(cps.localCheckpoint, minLocalCheckpoint)__                }_            }_        }_        assert minLocalCheckpoint != Long.MAX_VALUE__        return minLocalCheckpoint__    };computes,the,global,checkpoint,based,on,the,given,local,checkpoints,in,case,where,there,are,entries,preventing,the,computation,to,happen,for,example,due,to,blocking,it,returns,the,fallback,value;private,static,long,compute,global,checkpoint,final,set,string,pending,in,sync,final,collection,checkpoint,state,local,checkpoints,final,long,fallback,long,min,local,checkpoint,long,if,pending,in,sync,is,empty,false,return,fallback,for,final,checkpoint,state,cps,local,checkpoints,if,cps,in,sync,if,cps,local,checkpoint,sequence,numbers,return,fallback,else,if,cps,local,checkpoint,sequence,numbers,else,min,local,checkpoint,math,min,cps,local,checkpoint,min,local,checkpoint,assert,min,local,checkpoint,long,return,min,local,checkpoint
ReplicationTracker -> private static long computeGlobalCheckpoint(final Set<String> pendingInSync, final Collection<CheckpointState> localCheckpoints,                                                 final long fallback);1548677511;Computes the global checkpoint based on the given local checkpoints. In case where there are entries preventing the_computation to happen (for example due to blocking), it returns the fallback value.;private static long computeGlobalCheckpoint(final Set<String> pendingInSync, final Collection<CheckpointState> localCheckpoints,_                                                final long fallback) {_        long minLocalCheckpoint = Long.MAX_VALUE__        if (pendingInSync.isEmpty() == false) {_            return fallback__        }_        for (final CheckpointState cps : localCheckpoints) {_            if (cps.inSync) {_                if (cps.localCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO) {_                    _                    return fallback__                } else if (cps.localCheckpoint == SequenceNumbers.PRE_60_NODE_CHECKPOINT) {_                    _                } else {_                    minLocalCheckpoint = Math.min(cps.localCheckpoint, minLocalCheckpoint)__                }_            }_        }_        assert minLocalCheckpoint != Long.MAX_VALUE__        return minLocalCheckpoint__    };computes,the,global,checkpoint,based,on,the,given,local,checkpoints,in,case,where,there,are,entries,preventing,the,computation,to,happen,for,example,due,to,blocking,it,returns,the,fallback,value;private,static,long,compute,global,checkpoint,final,set,string,pending,in,sync,final,collection,checkpoint,state,local,checkpoints,final,long,fallback,long,min,local,checkpoint,long,if,pending,in,sync,is,empty,false,return,fallback,for,final,checkpoint,state,cps,local,checkpoints,if,cps,in,sync,if,cps,local,checkpoint,sequence,numbers,return,fallback,else,if,cps,local,checkpoint,sequence,numbers,else,min,local,checkpoint,math,min,cps,local,checkpoint,min,local,checkpoint,assert,min,local,checkpoint,long,return,min,local,checkpoint
ReplicationTracker -> private static long computeGlobalCheckpoint(final Set<String> pendingInSync, final Collection<CheckpointState> localCheckpoints,                                                 final long fallback);1548944389;Computes the global checkpoint based on the given local checkpoints. In case where there are entries preventing the_computation to happen (for example due to blocking), it returns the fallback value.;private static long computeGlobalCheckpoint(final Set<String> pendingInSync, final Collection<CheckpointState> localCheckpoints,_                                                final long fallback) {_        long minLocalCheckpoint = Long.MAX_VALUE__        if (pendingInSync.isEmpty() == false) {_            return fallback__        }_        for (final CheckpointState cps : localCheckpoints) {_            if (cps.inSync) {_                if (cps.localCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO) {_                    _                    return fallback__                } else if (cps.localCheckpoint == SequenceNumbers.PRE_60_NODE_CHECKPOINT) {_                    _                } else {_                    minLocalCheckpoint = Math.min(cps.localCheckpoint, minLocalCheckpoint)__                }_            }_        }_        assert minLocalCheckpoint != Long.MAX_VALUE__        return minLocalCheckpoint__    };computes,the,global,checkpoint,based,on,the,given,local,checkpoints,in,case,where,there,are,entries,preventing,the,computation,to,happen,for,example,due,to,blocking,it,returns,the,fallback,value;private,static,long,compute,global,checkpoint,final,set,string,pending,in,sync,final,collection,checkpoint,state,local,checkpoints,final,long,fallback,long,min,local,checkpoint,long,if,pending,in,sync,is,empty,false,return,fallback,for,final,checkpoint,state,cps,local,checkpoints,if,cps,in,sync,if,cps,local,checkpoint,sequence,numbers,return,fallback,else,if,cps,local,checkpoint,sequence,numbers,else,min,local,checkpoint,math,min,cps,local,checkpoint,min,local,checkpoint,assert,min,local,checkpoint,long,return,min,local,checkpoint
ReplicationTracker -> private static long computeGlobalCheckpoint(final Set<String> pendingInSync, final Collection<CheckpointState> localCheckpoints,                                                 final long fallback);1549059559;Computes the global checkpoint based on the given local checkpoints. In case where there are entries preventing the_computation to happen (for example due to blocking), it returns the fallback value.;private static long computeGlobalCheckpoint(final Set<String> pendingInSync, final Collection<CheckpointState> localCheckpoints,_                                                final long fallback) {_        long minLocalCheckpoint = Long.MAX_VALUE__        if (pendingInSync.isEmpty() == false) {_            return fallback__        }_        for (final CheckpointState cps : localCheckpoints) {_            if (cps.inSync) {_                if (cps.localCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO) {_                    _                    return fallback__                } else if (cps.localCheckpoint == SequenceNumbers.PRE_60_NODE_CHECKPOINT) {_                    _                } else {_                    minLocalCheckpoint = Math.min(cps.localCheckpoint, minLocalCheckpoint)__                }_            }_        }_        assert minLocalCheckpoint != Long.MAX_VALUE__        return minLocalCheckpoint__    };computes,the,global,checkpoint,based,on,the,given,local,checkpoints,in,case,where,there,are,entries,preventing,the,computation,to,happen,for,example,due,to,blocking,it,returns,the,fallback,value;private,static,long,compute,global,checkpoint,final,set,string,pending,in,sync,final,collection,checkpoint,state,local,checkpoints,final,long,fallback,long,min,local,checkpoint,long,if,pending,in,sync,is,empty,false,return,fallback,for,final,checkpoint,state,cps,local,checkpoints,if,cps,in,sync,if,cps,local,checkpoint,sequence,numbers,return,fallback,else,if,cps,local,checkpoint,sequence,numbers,else,min,local,checkpoint,math,min,cps,local,checkpoint,min,local,checkpoint,assert,min,local,checkpoint,long,return,min,local,checkpoint
ReplicationTracker -> private static long computeGlobalCheckpoint(final Set<String> pendingInSync, final Collection<CheckpointState> localCheckpoints,                                                 final long fallback);1549294529;Computes the global checkpoint based on the given local checkpoints. In case where there are entries preventing the_computation to happen (for example due to blocking), it returns the fallback value.;private static long computeGlobalCheckpoint(final Set<String> pendingInSync, final Collection<CheckpointState> localCheckpoints,_                                                final long fallback) {_        long minLocalCheckpoint = Long.MAX_VALUE__        if (pendingInSync.isEmpty() == false) {_            return fallback__        }_        for (final CheckpointState cps : localCheckpoints) {_            if (cps.inSync) {_                if (cps.localCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO) {_                    _                    return fallback__                } else if (cps.localCheckpoint == SequenceNumbers.PRE_60_NODE_CHECKPOINT) {_                    _                } else {_                    minLocalCheckpoint = Math.min(cps.localCheckpoint, minLocalCheckpoint)__                }_            }_        }_        assert minLocalCheckpoint != Long.MAX_VALUE__        return minLocalCheckpoint__    };computes,the,global,checkpoint,based,on,the,given,local,checkpoints,in,case,where,there,are,entries,preventing,the,computation,to,happen,for,example,due,to,blocking,it,returns,the,fallback,value;private,static,long,compute,global,checkpoint,final,set,string,pending,in,sync,final,collection,checkpoint,state,local,checkpoints,final,long,fallback,long,min,local,checkpoint,long,if,pending,in,sync,is,empty,false,return,fallback,for,final,checkpoint,state,cps,local,checkpoints,if,cps,in,sync,if,cps,local,checkpoint,sequence,numbers,return,fallback,else,if,cps,local,checkpoint,sequence,numbers,else,min,local,checkpoint,math,min,cps,local,checkpoint,min,local,checkpoint,assert,min,local,checkpoint,long,return,min,local,checkpoint
ReplicationTracker -> private static long computeGlobalCheckpoint(final Set<String> pendingInSync, final Collection<CheckpointState> localCheckpoints,                                                 final long fallback);1549395737;Computes the global checkpoint based on the given local checkpoints. In case where there are entries preventing the_computation to happen (for example due to blocking), it returns the fallback value.;private static long computeGlobalCheckpoint(final Set<String> pendingInSync, final Collection<CheckpointState> localCheckpoints,_                                                final long fallback) {_        long minLocalCheckpoint = Long.MAX_VALUE__        if (pendingInSync.isEmpty() == false) {_            return fallback__        }_        for (final CheckpointState cps : localCheckpoints) {_            if (cps.inSync) {_                if (cps.localCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO) {_                    _                    return fallback__                } else if (cps.localCheckpoint == SequenceNumbers.PRE_60_NODE_CHECKPOINT) {_                    _                } else {_                    minLocalCheckpoint = Math.min(cps.localCheckpoint, minLocalCheckpoint)__                }_            }_        }_        assert minLocalCheckpoint != Long.MAX_VALUE__        return minLocalCheckpoint__    };computes,the,global,checkpoint,based,on,the,given,local,checkpoints,in,case,where,there,are,entries,preventing,the,computation,to,happen,for,example,due,to,blocking,it,returns,the,fallback,value;private,static,long,compute,global,checkpoint,final,set,string,pending,in,sync,final,collection,checkpoint,state,local,checkpoints,final,long,fallback,long,min,local,checkpoint,long,if,pending,in,sync,is,empty,false,return,fallback,for,final,checkpoint,state,cps,local,checkpoints,if,cps,in,sync,if,cps,local,checkpoint,sequence,numbers,return,fallback,else,if,cps,local,checkpoint,sequence,numbers,else,min,local,checkpoint,math,min,cps,local,checkpoint,min,local,checkpoint,assert,min,local,checkpoint,long,return,min,local,checkpoint
ReplicationTracker -> private static long computeGlobalCheckpoint(final Set<String> pendingInSync, final Collection<CheckpointState> localCheckpoints,                                                 final long fallback);1549937843;Computes the global checkpoint based on the given local checkpoints. In case where there are entries preventing the_computation to happen (for example due to blocking), it returns the fallback value.;private static long computeGlobalCheckpoint(final Set<String> pendingInSync, final Collection<CheckpointState> localCheckpoints,_                                                final long fallback) {_        long minLocalCheckpoint = Long.MAX_VALUE__        if (pendingInSync.isEmpty() == false) {_            return fallback__        }_        for (final CheckpointState cps : localCheckpoints) {_            if (cps.inSync) {_                if (cps.localCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO) {_                    _                    return fallback__                } else if (cps.localCheckpoint == SequenceNumbers.PRE_60_NODE_CHECKPOINT) {_                    _                } else {_                    minLocalCheckpoint = Math.min(cps.localCheckpoint, minLocalCheckpoint)__                }_            }_        }_        assert minLocalCheckpoint != Long.MAX_VALUE__        return minLocalCheckpoint__    };computes,the,global,checkpoint,based,on,the,given,local,checkpoints,in,case,where,there,are,entries,preventing,the,computation,to,happen,for,example,due,to,blocking,it,returns,the,fallback,value;private,static,long,compute,global,checkpoint,final,set,string,pending,in,sync,final,collection,checkpoint,state,local,checkpoints,final,long,fallback,long,min,local,checkpoint,long,if,pending,in,sync,is,empty,false,return,fallback,for,final,checkpoint,state,cps,local,checkpoints,if,cps,in,sync,if,cps,local,checkpoint,sequence,numbers,return,fallback,else,if,cps,local,checkpoint,sequence,numbers,else,min,local,checkpoint,math,min,cps,local,checkpoint,min,local,checkpoint,assert,min,local,checkpoint,long,return,min,local,checkpoint
ReplicationTracker -> private static long computeGlobalCheckpoint(final Set<String> pendingInSync, final Collection<CheckpointState> localCheckpoints,                                                 final long fallback);1549949489;Computes the global checkpoint based on the given local checkpoints. In case where there are entries preventing the_computation to happen (for example due to blocking), it returns the fallback value.;private static long computeGlobalCheckpoint(final Set<String> pendingInSync, final Collection<CheckpointState> localCheckpoints,_                                                final long fallback) {_        long minLocalCheckpoint = Long.MAX_VALUE__        if (pendingInSync.isEmpty() == false) {_            return fallback__        }_        for (final CheckpointState cps : localCheckpoints) {_            if (cps.inSync) {_                if (cps.localCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO) {_                    _                    return fallback__                } else if (cps.localCheckpoint == SequenceNumbers.PRE_60_NODE_CHECKPOINT) {_                    _                } else {_                    minLocalCheckpoint = Math.min(cps.localCheckpoint, minLocalCheckpoint)__                }_            }_        }_        assert minLocalCheckpoint != Long.MAX_VALUE__        return minLocalCheckpoint__    };computes,the,global,checkpoint,based,on,the,given,local,checkpoints,in,case,where,there,are,entries,preventing,the,computation,to,happen,for,example,due,to,blocking,it,returns,the,fallback,value;private,static,long,compute,global,checkpoint,final,set,string,pending,in,sync,final,collection,checkpoint,state,local,checkpoints,final,long,fallback,long,min,local,checkpoint,long,if,pending,in,sync,is,empty,false,return,fallback,for,final,checkpoint,state,cps,local,checkpoints,if,cps,in,sync,if,cps,local,checkpoint,sequence,numbers,return,fallback,else,if,cps,local,checkpoint,sequence,numbers,else,min,local,checkpoint,math,min,cps,local,checkpoint,min,local,checkpoint,assert,min,local,checkpoint,long,return,min,local,checkpoint
ReplicationTracker -> private static long computeGlobalCheckpoint(final Set<String> pendingInSync, final Collection<CheckpointState> localCheckpoints,                                                 final long fallback);1550526771;Computes the global checkpoint based on the given local checkpoints. In case where there are entries preventing the_computation to happen (for example due to blocking), it returns the fallback value.;private static long computeGlobalCheckpoint(final Set<String> pendingInSync, final Collection<CheckpointState> localCheckpoints,_                                                final long fallback) {_        long minLocalCheckpoint = Long.MAX_VALUE__        if (pendingInSync.isEmpty() == false) {_            return fallback__        }_        for (final CheckpointState cps : localCheckpoints) {_            if (cps.inSync) {_                if (cps.localCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO) {_                    _                    return fallback__                } else if (cps.localCheckpoint == SequenceNumbers.PRE_60_NODE_CHECKPOINT) {_                    _                } else {_                    minLocalCheckpoint = Math.min(cps.localCheckpoint, minLocalCheckpoint)__                }_            }_        }_        assert minLocalCheckpoint != Long.MAX_VALUE__        return minLocalCheckpoint__    };computes,the,global,checkpoint,based,on,the,given,local,checkpoints,in,case,where,there,are,entries,preventing,the,computation,to,happen,for,example,due,to,blocking,it,returns,the,fallback,value;private,static,long,compute,global,checkpoint,final,set,string,pending,in,sync,final,collection,checkpoint,state,local,checkpoints,final,long,fallback,long,min,local,checkpoint,long,if,pending,in,sync,is,empty,false,return,fallback,for,final,checkpoint,state,cps,local,checkpoints,if,cps,in,sync,if,cps,local,checkpoint,sequence,numbers,return,fallback,else,if,cps,local,checkpoint,sequence,numbers,else,min,local,checkpoint,math,min,cps,local,checkpoint,min,local,checkpoint,assert,min,local,checkpoint,long,return,min,local,checkpoint
ReplicationTracker -> public synchronized boolean pendingInSync();1524684173;Whether the are shards blocking global checkpoint advancement. Used by tests.;public synchronized boolean pendingInSync() {_        assert primaryMode__        return pendingInSync.isEmpty() == false__    };whether,the,are,shards,blocking,global,checkpoint,advancement,used,by,tests;public,synchronized,boolean,pending,in,sync,assert,primary,mode,return,pending,in,sync,is,empty,false
ReplicationTracker -> public synchronized boolean pendingInSync();1525334055;Whether the are shards blocking global checkpoint advancement. Used by tests.;public synchronized boolean pendingInSync() {_        assert primaryMode__        return pendingInSync.isEmpty() == false__    };whether,the,are,shards,blocking,global,checkpoint,advancement,used,by,tests;public,synchronized,boolean,pending,in,sync,assert,primary,mode,return,pending,in,sync,is,empty,false
ReplicationTracker -> public synchronized boolean pendingInSync();1533295538;Whether the are shards blocking global checkpoint advancement. Used by tests.;public synchronized boolean pendingInSync() {_        assert primaryMode__        return pendingInSync.isEmpty() == false__    };whether,the,are,shards,blocking,global,checkpoint,advancement,used,by,tests;public,synchronized,boolean,pending,in,sync,assert,primary,mode,return,pending,in,sync,is,empty,false
ReplicationTracker -> public synchronized boolean pendingInSync();1533738061;Whether the are shards blocking global checkpoint advancement. Used by tests.;public synchronized boolean pendingInSync() {_        assert primaryMode__        return pendingInSync.isEmpty() == false__    };whether,the,are,shards,blocking,global,checkpoint,advancement,used,by,tests;public,synchronized,boolean,pending,in,sync,assert,primary,mode,return,pending,in,sync,is,empty,false
ReplicationTracker -> public synchronized boolean pendingInSync();1546875837;Whether the are shards blocking global checkpoint advancement. Used by tests.;public synchronized boolean pendingInSync() {_        assert primaryMode__        return pendingInSync.isEmpty() == false__    };whether,the,are,shards,blocking,global,checkpoint,advancement,used,by,tests;public,synchronized,boolean,pending,in,sync,assert,primary,mode,return,pending,in,sync,is,empty,false
ReplicationTracker -> public synchronized boolean pendingInSync();1546927432;Whether the are shards blocking global checkpoint advancement. Used by tests.;public synchronized boolean pendingInSync() {_        assert primaryMode__        return pendingInSync.isEmpty() == false__    };whether,the,are,shards,blocking,global,checkpoint,advancement,used,by,tests;public,synchronized,boolean,pending,in,sync,assert,primary,mode,return,pending,in,sync,is,empty,false
ReplicationTracker -> public synchronized boolean pendingInSync();1547332999;Whether the are shards blocking global checkpoint advancement. Used by tests.;public synchronized boolean pendingInSync() {_        assert primaryMode__        return pendingInSync.isEmpty() == false__    };whether,the,are,shards,blocking,global,checkpoint,advancement,used,by,tests;public,synchronized,boolean,pending,in,sync,assert,primary,mode,return,pending,in,sync,is,empty,false
ReplicationTracker -> public synchronized boolean pendingInSync();1548593396;Whether the are shards blocking global checkpoint advancement. Used by tests.;public synchronized boolean pendingInSync() {_        assert primaryMode__        return pendingInSync.isEmpty() == false__    };whether,the,are,shards,blocking,global,checkpoint,advancement,used,by,tests;public,synchronized,boolean,pending,in,sync,assert,primary,mode,return,pending,in,sync,is,empty,false
ReplicationTracker -> public synchronized boolean pendingInSync();1548594827;Whether the are shards blocking global checkpoint advancement. Used by tests.;public synchronized boolean pendingInSync() {_        assert primaryMode__        return pendingInSync.isEmpty() == false__    };whether,the,are,shards,blocking,global,checkpoint,advancement,used,by,tests;public,synchronized,boolean,pending,in,sync,assert,primary,mode,return,pending,in,sync,is,empty,false
ReplicationTracker -> public synchronized boolean pendingInSync();1548677511;Whether the are shards blocking global checkpoint advancement. Used by tests.;public synchronized boolean pendingInSync() {_        assert primaryMode__        return pendingInSync.isEmpty() == false__    };whether,the,are,shards,blocking,global,checkpoint,advancement,used,by,tests;public,synchronized,boolean,pending,in,sync,assert,primary,mode,return,pending,in,sync,is,empty,false
ReplicationTracker -> public synchronized boolean pendingInSync();1548944389;Whether the are shards blocking global checkpoint advancement. Used by tests.;public synchronized boolean pendingInSync() {_        assert primaryMode__        return pendingInSync.isEmpty() == false__    };whether,the,are,shards,blocking,global,checkpoint,advancement,used,by,tests;public,synchronized,boolean,pending,in,sync,assert,primary,mode,return,pending,in,sync,is,empty,false
ReplicationTracker -> public synchronized boolean pendingInSync();1549059559;Whether the are shards blocking global checkpoint advancement. Used by tests.;public synchronized boolean pendingInSync() {_        assert primaryMode__        return pendingInSync.isEmpty() == false__    };whether,the,are,shards,blocking,global,checkpoint,advancement,used,by,tests;public,synchronized,boolean,pending,in,sync,assert,primary,mode,return,pending,in,sync,is,empty,false
ReplicationTracker -> public synchronized boolean pendingInSync();1549294529;Whether the are shards blocking global checkpoint advancement. Used by tests.;public synchronized boolean pendingInSync() {_        assert primaryMode__        return pendingInSync.isEmpty() == false__    };whether,the,are,shards,blocking,global,checkpoint,advancement,used,by,tests;public,synchronized,boolean,pending,in,sync,assert,primary,mode,return,pending,in,sync,is,empty,false
ReplicationTracker -> public synchronized boolean pendingInSync();1549395737;Whether the are shards blocking global checkpoint advancement. Used by tests.;public synchronized boolean pendingInSync() {_        assert primaryMode__        return pendingInSync.isEmpty() == false__    };whether,the,are,shards,blocking,global,checkpoint,advancement,used,by,tests;public,synchronized,boolean,pending,in,sync,assert,primary,mode,return,pending,in,sync,is,empty,false
ReplicationTracker -> public synchronized boolean pendingInSync();1549937843;Whether the are shards blocking global checkpoint advancement. Used by tests.;public synchronized boolean pendingInSync() {_        assert primaryMode__        return pendingInSync.isEmpty() == false__    };whether,the,are,shards,blocking,global,checkpoint,advancement,used,by,tests;public,synchronized,boolean,pending,in,sync,assert,primary,mode,return,pending,in,sync,is,empty,false
ReplicationTracker -> public synchronized boolean pendingInSync();1549949489;Whether the are shards blocking global checkpoint advancement. Used by tests.;public synchronized boolean pendingInSync() {_        assert primaryMode__        return pendingInSync.isEmpty() == false__    };whether,the,are,shards,blocking,global,checkpoint,advancement,used,by,tests;public,synchronized,boolean,pending,in,sync,assert,primary,mode,return,pending,in,sync,is,empty,false
ReplicationTracker -> public synchronized boolean pendingInSync();1550526771;Whether the are shards blocking global checkpoint advancement. Used by tests.;public synchronized boolean pendingInSync() {_        assert primaryMode__        return pendingInSync.isEmpty() == false__    };whether,the,are,shards,blocking,global,checkpoint,advancement,used,by,tests;public,synchronized,boolean,pending,in,sync,assert,primary,mode,return,pending,in,sync,is,empty,false
ReplicationTracker -> @SuppressForbidden(reason = "Object#wait for local checkpoint advancement")     private synchronized void waitForLocalCheckpointToAdvance() throws InterruptedException;1524684173;Wait for the local checkpoint to advance to the global checkpoint.__@throws InterruptedException if this thread was interrupted before of during waiting;@SuppressForbidden(reason = "Object#wait for local checkpoint advancement")_    private synchronized void waitForLocalCheckpointToAdvance() throws InterruptedException {_        this.wait()__    };wait,for,the,local,checkpoint,to,advance,to,the,global,checkpoint,throws,interrupted,exception,if,this,thread,was,interrupted,before,of,during,waiting;suppress,forbidden,reason,object,wait,for,local,checkpoint,advancement,private,synchronized,void,wait,for,local,checkpoint,to,advance,throws,interrupted,exception,this,wait
ReplicationTracker -> @SuppressForbidden(reason = "Object#wait for local checkpoint advancement")     private synchronized void waitForLocalCheckpointToAdvance() throws InterruptedException;1525334055;Wait for the local checkpoint to advance to the global checkpoint.__@throws InterruptedException if this thread was interrupted before of during waiting;@SuppressForbidden(reason = "Object#wait for local checkpoint advancement")_    private synchronized void waitForLocalCheckpointToAdvance() throws InterruptedException {_        this.wait()__    };wait,for,the,local,checkpoint,to,advance,to,the,global,checkpoint,throws,interrupted,exception,if,this,thread,was,interrupted,before,of,during,waiting;suppress,forbidden,reason,object,wait,for,local,checkpoint,advancement,private,synchronized,void,wait,for,local,checkpoint,to,advance,throws,interrupted,exception,this,wait
ReplicationTracker -> @SuppressForbidden(reason = "Object#wait for local checkpoint advancement")     private synchronized void waitForLocalCheckpointToAdvance() throws InterruptedException;1533295538;Wait for the local checkpoint to advance to the global checkpoint.__@throws InterruptedException if this thread was interrupted before of during waiting;@SuppressForbidden(reason = "Object#wait for local checkpoint advancement")_    private synchronized void waitForLocalCheckpointToAdvance() throws InterruptedException {_        this.wait()__    };wait,for,the,local,checkpoint,to,advance,to,the,global,checkpoint,throws,interrupted,exception,if,this,thread,was,interrupted,before,of,during,waiting;suppress,forbidden,reason,object,wait,for,local,checkpoint,advancement,private,synchronized,void,wait,for,local,checkpoint,to,advance,throws,interrupted,exception,this,wait
ReplicationTracker -> @SuppressForbidden(reason = "Object#wait for local checkpoint advancement")     private synchronized void waitForLocalCheckpointToAdvance() throws InterruptedException;1533738061;Wait for the local checkpoint to advance to the global checkpoint.__@throws InterruptedException if this thread was interrupted before of during waiting;@SuppressForbidden(reason = "Object#wait for local checkpoint advancement")_    private synchronized void waitForLocalCheckpointToAdvance() throws InterruptedException {_        this.wait()__    };wait,for,the,local,checkpoint,to,advance,to,the,global,checkpoint,throws,interrupted,exception,if,this,thread,was,interrupted,before,of,during,waiting;suppress,forbidden,reason,object,wait,for,local,checkpoint,advancement,private,synchronized,void,wait,for,local,checkpoint,to,advance,throws,interrupted,exception,this,wait
ReplicationTracker -> @SuppressForbidden(reason = "Object#wait for local checkpoint advancement")     private synchronized void waitForLocalCheckpointToAdvance() throws InterruptedException;1546875837;Wait for the local checkpoint to advance to the global checkpoint.__@throws InterruptedException if this thread was interrupted before of during waiting;@SuppressForbidden(reason = "Object#wait for local checkpoint advancement")_    private synchronized void waitForLocalCheckpointToAdvance() throws InterruptedException {_        this.wait()__    };wait,for,the,local,checkpoint,to,advance,to,the,global,checkpoint,throws,interrupted,exception,if,this,thread,was,interrupted,before,of,during,waiting;suppress,forbidden,reason,object,wait,for,local,checkpoint,advancement,private,synchronized,void,wait,for,local,checkpoint,to,advance,throws,interrupted,exception,this,wait
ReplicationTracker -> @SuppressForbidden(reason = "Object#wait for local checkpoint advancement")     private synchronized void waitForLocalCheckpointToAdvance() throws InterruptedException;1546927432;Wait for the local checkpoint to advance to the global checkpoint.__@throws InterruptedException if this thread was interrupted before of during waiting;@SuppressForbidden(reason = "Object#wait for local checkpoint advancement")_    private synchronized void waitForLocalCheckpointToAdvance() throws InterruptedException {_        this.wait()__    };wait,for,the,local,checkpoint,to,advance,to,the,global,checkpoint,throws,interrupted,exception,if,this,thread,was,interrupted,before,of,during,waiting;suppress,forbidden,reason,object,wait,for,local,checkpoint,advancement,private,synchronized,void,wait,for,local,checkpoint,to,advance,throws,interrupted,exception,this,wait
ReplicationTracker -> @SuppressForbidden(reason = "Object#wait for local checkpoint advancement")     private synchronized void waitForLocalCheckpointToAdvance() throws InterruptedException;1547332999;Wait for the local checkpoint to advance to the global checkpoint.__@throws InterruptedException if this thread was interrupted before of during waiting;@SuppressForbidden(reason = "Object#wait for local checkpoint advancement")_    private synchronized void waitForLocalCheckpointToAdvance() throws InterruptedException {_        this.wait()__    };wait,for,the,local,checkpoint,to,advance,to,the,global,checkpoint,throws,interrupted,exception,if,this,thread,was,interrupted,before,of,during,waiting;suppress,forbidden,reason,object,wait,for,local,checkpoint,advancement,private,synchronized,void,wait,for,local,checkpoint,to,advance,throws,interrupted,exception,this,wait
ReplicationTracker -> @SuppressForbidden(reason = "Object#wait for local checkpoint advancement")     private synchronized void waitForLocalCheckpointToAdvance() throws InterruptedException;1548593396;Wait for the local checkpoint to advance to the global checkpoint.__@throws InterruptedException if this thread was interrupted before of during waiting;@SuppressForbidden(reason = "Object#wait for local checkpoint advancement")_    private synchronized void waitForLocalCheckpointToAdvance() throws InterruptedException {_        this.wait()__    };wait,for,the,local,checkpoint,to,advance,to,the,global,checkpoint,throws,interrupted,exception,if,this,thread,was,interrupted,before,of,during,waiting;suppress,forbidden,reason,object,wait,for,local,checkpoint,advancement,private,synchronized,void,wait,for,local,checkpoint,to,advance,throws,interrupted,exception,this,wait
ReplicationTracker -> @SuppressForbidden(reason = "Object#wait for local checkpoint advancement")     private synchronized void waitForLocalCheckpointToAdvance() throws InterruptedException;1548594827;Wait for the local checkpoint to advance to the global checkpoint.__@throws InterruptedException if this thread was interrupted before of during waiting;@SuppressForbidden(reason = "Object#wait for local checkpoint advancement")_    private synchronized void waitForLocalCheckpointToAdvance() throws InterruptedException {_        this.wait()__    };wait,for,the,local,checkpoint,to,advance,to,the,global,checkpoint,throws,interrupted,exception,if,this,thread,was,interrupted,before,of,during,waiting;suppress,forbidden,reason,object,wait,for,local,checkpoint,advancement,private,synchronized,void,wait,for,local,checkpoint,to,advance,throws,interrupted,exception,this,wait
ReplicationTracker -> @SuppressForbidden(reason = "Object#wait for local checkpoint advancement")     private synchronized void waitForLocalCheckpointToAdvance() throws InterruptedException;1548677511;Wait for the local checkpoint to advance to the global checkpoint.__@throws InterruptedException if this thread was interrupted before of during waiting;@SuppressForbidden(reason = "Object#wait for local checkpoint advancement")_    private synchronized void waitForLocalCheckpointToAdvance() throws InterruptedException {_        this.wait()__    };wait,for,the,local,checkpoint,to,advance,to,the,global,checkpoint,throws,interrupted,exception,if,this,thread,was,interrupted,before,of,during,waiting;suppress,forbidden,reason,object,wait,for,local,checkpoint,advancement,private,synchronized,void,wait,for,local,checkpoint,to,advance,throws,interrupted,exception,this,wait
ReplicationTracker -> @SuppressForbidden(reason = "Object#wait for local checkpoint advancement")     private synchronized void waitForLocalCheckpointToAdvance() throws InterruptedException;1548944389;Wait for the local checkpoint to advance to the global checkpoint.__@throws InterruptedException if this thread was interrupted before of during waiting;@SuppressForbidden(reason = "Object#wait for local checkpoint advancement")_    private synchronized void waitForLocalCheckpointToAdvance() throws InterruptedException {_        this.wait()__    };wait,for,the,local,checkpoint,to,advance,to,the,global,checkpoint,throws,interrupted,exception,if,this,thread,was,interrupted,before,of,during,waiting;suppress,forbidden,reason,object,wait,for,local,checkpoint,advancement,private,synchronized,void,wait,for,local,checkpoint,to,advance,throws,interrupted,exception,this,wait
ReplicationTracker -> @SuppressForbidden(reason = "Object#wait for local checkpoint advancement")     private synchronized void waitForLocalCheckpointToAdvance() throws InterruptedException;1549059559;Wait for the local checkpoint to advance to the global checkpoint.__@throws InterruptedException if this thread was interrupted before of during waiting;@SuppressForbidden(reason = "Object#wait for local checkpoint advancement")_    private synchronized void waitForLocalCheckpointToAdvance() throws InterruptedException {_        this.wait()__    };wait,for,the,local,checkpoint,to,advance,to,the,global,checkpoint,throws,interrupted,exception,if,this,thread,was,interrupted,before,of,during,waiting;suppress,forbidden,reason,object,wait,for,local,checkpoint,advancement,private,synchronized,void,wait,for,local,checkpoint,to,advance,throws,interrupted,exception,this,wait
ReplicationTracker -> @SuppressForbidden(reason = "Object#wait for local checkpoint advancement")     private synchronized void waitForLocalCheckpointToAdvance() throws InterruptedException;1549294529;Wait for the local checkpoint to advance to the global checkpoint.__@throws InterruptedException if this thread was interrupted before of during waiting;@SuppressForbidden(reason = "Object#wait for local checkpoint advancement")_    private synchronized void waitForLocalCheckpointToAdvance() throws InterruptedException {_        this.wait()__    };wait,for,the,local,checkpoint,to,advance,to,the,global,checkpoint,throws,interrupted,exception,if,this,thread,was,interrupted,before,of,during,waiting;suppress,forbidden,reason,object,wait,for,local,checkpoint,advancement,private,synchronized,void,wait,for,local,checkpoint,to,advance,throws,interrupted,exception,this,wait
ReplicationTracker -> @SuppressForbidden(reason = "Object#wait for local checkpoint advancement")     private synchronized void waitForLocalCheckpointToAdvance() throws InterruptedException;1549395737;Wait for the local checkpoint to advance to the global checkpoint.__@throws InterruptedException if this thread was interrupted before of during waiting;@SuppressForbidden(reason = "Object#wait for local checkpoint advancement")_    private synchronized void waitForLocalCheckpointToAdvance() throws InterruptedException {_        this.wait()__    };wait,for,the,local,checkpoint,to,advance,to,the,global,checkpoint,throws,interrupted,exception,if,this,thread,was,interrupted,before,of,during,waiting;suppress,forbidden,reason,object,wait,for,local,checkpoint,advancement,private,synchronized,void,wait,for,local,checkpoint,to,advance,throws,interrupted,exception,this,wait
ReplicationTracker -> @SuppressForbidden(reason = "Object#wait for local checkpoint advancement")     private synchronized void waitForLocalCheckpointToAdvance() throws InterruptedException;1549937843;Wait for the local checkpoint to advance to the global checkpoint.__@throws InterruptedException if this thread was interrupted before of during waiting;@SuppressForbidden(reason = "Object#wait for local checkpoint advancement")_    private synchronized void waitForLocalCheckpointToAdvance() throws InterruptedException {_        this.wait()__    };wait,for,the,local,checkpoint,to,advance,to,the,global,checkpoint,throws,interrupted,exception,if,this,thread,was,interrupted,before,of,during,waiting;suppress,forbidden,reason,object,wait,for,local,checkpoint,advancement,private,synchronized,void,wait,for,local,checkpoint,to,advance,throws,interrupted,exception,this,wait
ReplicationTracker -> @SuppressForbidden(reason = "Object#wait for local checkpoint advancement")     private synchronized void waitForLocalCheckpointToAdvance() throws InterruptedException;1549949489;Wait for the local checkpoint to advance to the global checkpoint.__@throws InterruptedException if this thread was interrupted before of during waiting;@SuppressForbidden(reason = "Object#wait for local checkpoint advancement")_    private synchronized void waitForLocalCheckpointToAdvance() throws InterruptedException {_        this.wait()__    };wait,for,the,local,checkpoint,to,advance,to,the,global,checkpoint,throws,interrupted,exception,if,this,thread,was,interrupted,before,of,during,waiting;suppress,forbidden,reason,object,wait,for,local,checkpoint,advancement,private,synchronized,void,wait,for,local,checkpoint,to,advance,throws,interrupted,exception,this,wait
ReplicationTracker -> @SuppressForbidden(reason = "Object#wait for local checkpoint advancement")     private synchronized void waitForLocalCheckpointToAdvance() throws InterruptedException;1550526771;Wait for the local checkpoint to advance to the global checkpoint.__@throws InterruptedException if this thread was interrupted before of during waiting;@SuppressForbidden(reason = "Object#wait for local checkpoint advancement")_    private synchronized void waitForLocalCheckpointToAdvance() throws InterruptedException {_        this.wait()__    };wait,for,the,local,checkpoint,to,advance,to,the,global,checkpoint,throws,interrupted,exception,if,this,thread,was,interrupted,before,of,during,waiting;suppress,forbidden,reason,object,wait,for,local,checkpoint,advancement,private,synchronized,void,wait,for,local,checkpoint,to,advance,throws,interrupted,exception,this,wait
ReplicationTracker -> public ReplicationTracker(             final ShardId shardId,             final String allocationId,             final IndexSettings indexSettings,             final long globalCheckpoint,             final LongConsumer onGlobalCheckpointUpdated);1533738061;Initialize the global checkpoint service. The specified global checkpoint should be set to the last known global checkpoint, or_{@link SequenceNumbers#UNASSIGNED_SEQ_NO}.__@param shardId          the shard ID_@param allocationId     the allocation ID_@param indexSettings    the index settings_@param globalCheckpoint the last known global checkpoint for this shard, or {@link SequenceNumbers#UNASSIGNED_SEQ_NO};public ReplicationTracker(_            final ShardId shardId,_            final String allocationId,_            final IndexSettings indexSettings,_            final long globalCheckpoint,_            final LongConsumer onGlobalCheckpointUpdated) {_        super(shardId, indexSettings)__        assert globalCheckpoint >= SequenceNumbers.UNASSIGNED_SEQ_NO : "illegal initial global checkpoint: " + globalCheckpoint__        this.shardAllocationId = allocationId__        this.primaryMode = false__        this.handoffInProgress = false__        this.appliedClusterStateVersion = -1L__        this.checkpoints = new HashMap<>(1 + indexSettings.getNumberOfReplicas())__        checkpoints.put(allocationId, new CheckpointState(SequenceNumbers.UNASSIGNED_SEQ_NO, globalCheckpoint, false, false))__        this.onGlobalCheckpointUpdated = Objects.requireNonNull(onGlobalCheckpointUpdated)__        this.pendingInSync = new HashSet<>()__        this.routingTable = null__        this.replicationGroup = null__        assert invariant()__    };initialize,the,global,checkpoint,service,the,specified,global,checkpoint,should,be,set,to,the,last,known,global,checkpoint,or,link,sequence,numbers,param,shard,id,the,shard,id,param,allocation,id,the,allocation,id,param,index,settings,the,index,settings,param,global,checkpoint,the,last,known,global,checkpoint,for,this,shard,or,link,sequence,numbers;public,replication,tracker,final,shard,id,shard,id,final,string,allocation,id,final,index,settings,index,settings,final,long,global,checkpoint,final,long,consumer,on,global,checkpoint,updated,super,shard,id,index,settings,assert,global,checkpoint,sequence,numbers,illegal,initial,global,checkpoint,global,checkpoint,this,shard,allocation,id,allocation,id,this,primary,mode,false,this,handoff,in,progress,false,this,applied,cluster,state,version,1l,this,checkpoints,new,hash,map,1,index,settings,get,number,of,replicas,checkpoints,put,allocation,id,new,checkpoint,state,sequence,numbers,global,checkpoint,false,false,this,on,global,checkpoint,updated,objects,require,non,null,on,global,checkpoint,updated,this,pending,in,sync,new,hash,set,this,routing,table,null,this,replication,group,null,assert,invariant
ReplicationTracker -> public ReplicationTracker(             final ShardId shardId,             final String allocationId,             final IndexSettings indexSettings,             final long globalCheckpoint,             final LongConsumer onGlobalCheckpointUpdated);1546875837;Initialize the global checkpoint service. The specified global checkpoint should be set to the last known global checkpoint, or_{@link SequenceNumbers#UNASSIGNED_SEQ_NO}.__@param shardId          the shard ID_@param allocationId     the allocation ID_@param indexSettings    the index settings_@param globalCheckpoint the last known global checkpoint for this shard, or {@link SequenceNumbers#UNASSIGNED_SEQ_NO};public ReplicationTracker(_            final ShardId shardId,_            final String allocationId,_            final IndexSettings indexSettings,_            final long globalCheckpoint,_            final LongConsumer onGlobalCheckpointUpdated) {_        super(shardId, indexSettings)__        assert globalCheckpoint >= SequenceNumbers.UNASSIGNED_SEQ_NO : "illegal initial global checkpoint: " + globalCheckpoint__        this.shardAllocationId = allocationId__        this.primaryMode = false__        this.handoffInProgress = false__        this.appliedClusterStateVersion = -1L__        this.checkpoints = new HashMap<>(1 + indexSettings.getNumberOfReplicas())__        checkpoints.put(allocationId, new CheckpointState(SequenceNumbers.UNASSIGNED_SEQ_NO, globalCheckpoint, false, false))__        this.onGlobalCheckpointUpdated = Objects.requireNonNull(onGlobalCheckpointUpdated)__        this.pendingInSync = new HashSet<>()__        this.routingTable = null__        this.replicationGroup = null__        assert invariant()__    };initialize,the,global,checkpoint,service,the,specified,global,checkpoint,should,be,set,to,the,last,known,global,checkpoint,or,link,sequence,numbers,param,shard,id,the,shard,id,param,allocation,id,the,allocation,id,param,index,settings,the,index,settings,param,global,checkpoint,the,last,known,global,checkpoint,for,this,shard,or,link,sequence,numbers;public,replication,tracker,final,shard,id,shard,id,final,string,allocation,id,final,index,settings,index,settings,final,long,global,checkpoint,final,long,consumer,on,global,checkpoint,updated,super,shard,id,index,settings,assert,global,checkpoint,sequence,numbers,illegal,initial,global,checkpoint,global,checkpoint,this,shard,allocation,id,allocation,id,this,primary,mode,false,this,handoff,in,progress,false,this,applied,cluster,state,version,1l,this,checkpoints,new,hash,map,1,index,settings,get,number,of,replicas,checkpoints,put,allocation,id,new,checkpoint,state,sequence,numbers,global,checkpoint,false,false,this,on,global,checkpoint,updated,objects,require,non,null,on,global,checkpoint,updated,this,pending,in,sync,new,hash,set,this,routing,table,null,this,replication,group,null,assert,invariant
ReplicationTracker -> public synchronized void updateGlobalCheckpointOnReplica(final long globalCheckpoint, final String reason);1524684173;Updates the global checkpoint on a replica shard after it has been updated by the primary.__@param globalCheckpoint the global checkpoint_@param reason           the reason the global checkpoint was updated;public synchronized void updateGlobalCheckpointOnReplica(final long globalCheckpoint, final String reason) {_        assert invariant()__        assert primaryMode == false__        _        updateGlobalCheckpoint(_                shardAllocationId,_                globalCheckpoint,_                current -> logger.trace("updating global checkpoint from [{}] to [{}] due to [{}]", current, globalCheckpoint, reason))__        assert invariant()__    };updates,the,global,checkpoint,on,a,replica,shard,after,it,has,been,updated,by,the,primary,param,global,checkpoint,the,global,checkpoint,param,reason,the,reason,the,global,checkpoint,was,updated;public,synchronized,void,update,global,checkpoint,on,replica,final,long,global,checkpoint,final,string,reason,assert,invariant,assert,primary,mode,false,update,global,checkpoint,shard,allocation,id,global,checkpoint,current,logger,trace,updating,global,checkpoint,from,to,due,to,current,global,checkpoint,reason,assert,invariant
ReplicationTracker -> public synchronized void updateGlobalCheckpointOnReplica(final long globalCheckpoint, final String reason);1525334055;Updates the global checkpoint on a replica shard after it has been updated by the primary.__@param globalCheckpoint the global checkpoint_@param reason           the reason the global checkpoint was updated;public synchronized void updateGlobalCheckpointOnReplica(final long globalCheckpoint, final String reason) {_        assert invariant()__        assert primaryMode == false__        _        updateGlobalCheckpoint(_                shardAllocationId,_                globalCheckpoint,_                current -> logger.trace("updating global checkpoint from [{}] to [{}] due to [{}]", current, globalCheckpoint, reason))__        assert invariant()__    };updates,the,global,checkpoint,on,a,replica,shard,after,it,has,been,updated,by,the,primary,param,global,checkpoint,the,global,checkpoint,param,reason,the,reason,the,global,checkpoint,was,updated;public,synchronized,void,update,global,checkpoint,on,replica,final,long,global,checkpoint,final,string,reason,assert,invariant,assert,primary,mode,false,update,global,checkpoint,shard,allocation,id,global,checkpoint,current,logger,trace,updating,global,checkpoint,from,to,due,to,current,global,checkpoint,reason,assert,invariant
ReplicationTracker -> public synchronized void updateGlobalCheckpointOnReplica(final long globalCheckpoint, final String reason);1533295538;Updates the global checkpoint on a replica shard after it has been updated by the primary.__@param globalCheckpoint the global checkpoint_@param reason           the reason the global checkpoint was updated;public synchronized void updateGlobalCheckpointOnReplica(final long globalCheckpoint, final String reason) {_        assert invariant()__        assert primaryMode == false__        _        updateGlobalCheckpoint(_                shardAllocationId,_                globalCheckpoint,_                current -> logger.trace("updating global checkpoint from [{}] to [{}] due to [{}]", current, globalCheckpoint, reason))__        assert invariant()__    };updates,the,global,checkpoint,on,a,replica,shard,after,it,has,been,updated,by,the,primary,param,global,checkpoint,the,global,checkpoint,param,reason,the,reason,the,global,checkpoint,was,updated;public,synchronized,void,update,global,checkpoint,on,replica,final,long,global,checkpoint,final,string,reason,assert,invariant,assert,primary,mode,false,update,global,checkpoint,shard,allocation,id,global,checkpoint,current,logger,trace,updating,global,checkpoint,from,to,due,to,current,global,checkpoint,reason,assert,invariant
ReplicationTracker -> public synchronized void updateGlobalCheckpointOnReplica(final long globalCheckpoint, final String reason);1533738061;Updates the global checkpoint on a replica shard after it has been updated by the primary.__@param globalCheckpoint the global checkpoint_@param reason           the reason the global checkpoint was updated;public synchronized void updateGlobalCheckpointOnReplica(final long globalCheckpoint, final String reason) {_        assert invariant()__        assert primaryMode == false__        _        updateGlobalCheckpoint(_                shardAllocationId,_                globalCheckpoint,_                current -> {_                    logger.trace("updated global checkpoint from [{}] to [{}] due to [{}]", current, globalCheckpoint, reason)__                    onGlobalCheckpointUpdated.accept(globalCheckpoint)__                })__        assert invariant()__    };updates,the,global,checkpoint,on,a,replica,shard,after,it,has,been,updated,by,the,primary,param,global,checkpoint,the,global,checkpoint,param,reason,the,reason,the,global,checkpoint,was,updated;public,synchronized,void,update,global,checkpoint,on,replica,final,long,global,checkpoint,final,string,reason,assert,invariant,assert,primary,mode,false,update,global,checkpoint,shard,allocation,id,global,checkpoint,current,logger,trace,updated,global,checkpoint,from,to,due,to,current,global,checkpoint,reason,on,global,checkpoint,updated,accept,global,checkpoint,assert,invariant
ReplicationTracker -> public synchronized void updateGlobalCheckpointOnReplica(final long globalCheckpoint, final String reason);1546875837;Updates the global checkpoint on a replica shard after it has been updated by the primary.__@param globalCheckpoint the global checkpoint_@param reason           the reason the global checkpoint was updated;public synchronized void updateGlobalCheckpointOnReplica(final long globalCheckpoint, final String reason) {_        assert invariant()__        assert primaryMode == false__        _        updateGlobalCheckpoint(_                shardAllocationId,_                globalCheckpoint,_                current -> {_                    logger.trace("updated global checkpoint from [{}] to [{}] due to [{}]", current, globalCheckpoint, reason)__                    onGlobalCheckpointUpdated.accept(globalCheckpoint)__                })__        assert invariant()__    };updates,the,global,checkpoint,on,a,replica,shard,after,it,has,been,updated,by,the,primary,param,global,checkpoint,the,global,checkpoint,param,reason,the,reason,the,global,checkpoint,was,updated;public,synchronized,void,update,global,checkpoint,on,replica,final,long,global,checkpoint,final,string,reason,assert,invariant,assert,primary,mode,false,update,global,checkpoint,shard,allocation,id,global,checkpoint,current,logger,trace,updated,global,checkpoint,from,to,due,to,current,global,checkpoint,reason,on,global,checkpoint,updated,accept,global,checkpoint,assert,invariant
ReplicationTracker -> public synchronized void updateGlobalCheckpointOnReplica(final long globalCheckpoint, final String reason);1546927432;Updates the global checkpoint on a replica shard after it has been updated by the primary.__@param globalCheckpoint the global checkpoint_@param reason           the reason the global checkpoint was updated;public synchronized void updateGlobalCheckpointOnReplica(final long globalCheckpoint, final String reason) {_        assert invariant()__        assert primaryMode == false__        _        updateGlobalCheckpoint(_                shardAllocationId,_                globalCheckpoint,_                current -> {_                    logger.trace("updated global checkpoint from [{}] to [{}] due to [{}]", current, globalCheckpoint, reason)__                    onGlobalCheckpointUpdated.accept(globalCheckpoint)__                })__        assert invariant()__    };updates,the,global,checkpoint,on,a,replica,shard,after,it,has,been,updated,by,the,primary,param,global,checkpoint,the,global,checkpoint,param,reason,the,reason,the,global,checkpoint,was,updated;public,synchronized,void,update,global,checkpoint,on,replica,final,long,global,checkpoint,final,string,reason,assert,invariant,assert,primary,mode,false,update,global,checkpoint,shard,allocation,id,global,checkpoint,current,logger,trace,updated,global,checkpoint,from,to,due,to,current,global,checkpoint,reason,on,global,checkpoint,updated,accept,global,checkpoint,assert,invariant
ReplicationTracker -> public synchronized void updateGlobalCheckpointOnReplica(final long globalCheckpoint, final String reason);1547332999;Updates the global checkpoint on a replica shard after it has been updated by the primary.__@param globalCheckpoint the global checkpoint_@param reason           the reason the global checkpoint was updated;public synchronized void updateGlobalCheckpointOnReplica(final long globalCheckpoint, final String reason) {_        assert invariant()__        assert primaryMode == false__        _        updateGlobalCheckpoint(_                shardAllocationId,_                globalCheckpoint,_                current -> {_                    logger.trace("updated global checkpoint from [{}] to [{}] due to [{}]", current, globalCheckpoint, reason)__                    onGlobalCheckpointUpdated.accept(globalCheckpoint)__                })__        assert invariant()__    };updates,the,global,checkpoint,on,a,replica,shard,after,it,has,been,updated,by,the,primary,param,global,checkpoint,the,global,checkpoint,param,reason,the,reason,the,global,checkpoint,was,updated;public,synchronized,void,update,global,checkpoint,on,replica,final,long,global,checkpoint,final,string,reason,assert,invariant,assert,primary,mode,false,update,global,checkpoint,shard,allocation,id,global,checkpoint,current,logger,trace,updated,global,checkpoint,from,to,due,to,current,global,checkpoint,reason,on,global,checkpoint,updated,accept,global,checkpoint,assert,invariant
ReplicationTracker -> public synchronized void updateGlobalCheckpointOnReplica(final long globalCheckpoint, final String reason);1548593396;Updates the global checkpoint on a replica shard after it has been updated by the primary.__@param globalCheckpoint the global checkpoint_@param reason           the reason the global checkpoint was updated;public synchronized void updateGlobalCheckpointOnReplica(final long globalCheckpoint, final String reason) {_        assert invariant()__        assert primaryMode == false__        _        updateGlobalCheckpoint(_                shardAllocationId,_                globalCheckpoint,_                current -> {_                    logger.trace("updated global checkpoint from [{}] to [{}] due to [{}]", current, globalCheckpoint, reason)__                    onGlobalCheckpointUpdated.accept(globalCheckpoint)__                })__        assert invariant()__    };updates,the,global,checkpoint,on,a,replica,shard,after,it,has,been,updated,by,the,primary,param,global,checkpoint,the,global,checkpoint,param,reason,the,reason,the,global,checkpoint,was,updated;public,synchronized,void,update,global,checkpoint,on,replica,final,long,global,checkpoint,final,string,reason,assert,invariant,assert,primary,mode,false,update,global,checkpoint,shard,allocation,id,global,checkpoint,current,logger,trace,updated,global,checkpoint,from,to,due,to,current,global,checkpoint,reason,on,global,checkpoint,updated,accept,global,checkpoint,assert,invariant
ReplicationTracker -> public synchronized void updateGlobalCheckpointOnReplica(final long globalCheckpoint, final String reason);1548594827;Updates the global checkpoint on a replica shard after it has been updated by the primary.__@param globalCheckpoint the global checkpoint_@param reason           the reason the global checkpoint was updated;public synchronized void updateGlobalCheckpointOnReplica(final long globalCheckpoint, final String reason) {_        assert invariant()__        assert primaryMode == false__        _        updateGlobalCheckpoint(_                shardAllocationId,_                globalCheckpoint,_                current -> {_                    logger.trace("updated global checkpoint from [{}] to [{}] due to [{}]", current, globalCheckpoint, reason)__                    onGlobalCheckpointUpdated.accept(globalCheckpoint)__                })__        assert invariant()__    };updates,the,global,checkpoint,on,a,replica,shard,after,it,has,been,updated,by,the,primary,param,global,checkpoint,the,global,checkpoint,param,reason,the,reason,the,global,checkpoint,was,updated;public,synchronized,void,update,global,checkpoint,on,replica,final,long,global,checkpoint,final,string,reason,assert,invariant,assert,primary,mode,false,update,global,checkpoint,shard,allocation,id,global,checkpoint,current,logger,trace,updated,global,checkpoint,from,to,due,to,current,global,checkpoint,reason,on,global,checkpoint,updated,accept,global,checkpoint,assert,invariant
ReplicationTracker -> public synchronized void updateGlobalCheckpointOnReplica(final long globalCheckpoint, final String reason);1548677511;Updates the global checkpoint on a replica shard after it has been updated by the primary.__@param globalCheckpoint the global checkpoint_@param reason           the reason the global checkpoint was updated;public synchronized void updateGlobalCheckpointOnReplica(final long globalCheckpoint, final String reason) {_        assert invariant()__        assert primaryMode == false__        _        updateGlobalCheckpoint(_                shardAllocationId,_                globalCheckpoint,_                current -> {_                    logger.trace("updated global checkpoint from [{}] to [{}] due to [{}]", current, globalCheckpoint, reason)__                    onGlobalCheckpointUpdated.accept(globalCheckpoint)__                })__        assert invariant()__    };updates,the,global,checkpoint,on,a,replica,shard,after,it,has,been,updated,by,the,primary,param,global,checkpoint,the,global,checkpoint,param,reason,the,reason,the,global,checkpoint,was,updated;public,synchronized,void,update,global,checkpoint,on,replica,final,long,global,checkpoint,final,string,reason,assert,invariant,assert,primary,mode,false,update,global,checkpoint,shard,allocation,id,global,checkpoint,current,logger,trace,updated,global,checkpoint,from,to,due,to,current,global,checkpoint,reason,on,global,checkpoint,updated,accept,global,checkpoint,assert,invariant
ReplicationTracker -> public synchronized void updateGlobalCheckpointOnReplica(final long globalCheckpoint, final String reason);1548944389;Updates the global checkpoint on a replica shard after it has been updated by the primary.__@param globalCheckpoint the global checkpoint_@param reason           the reason the global checkpoint was updated;public synchronized void updateGlobalCheckpointOnReplica(final long globalCheckpoint, final String reason) {_        assert invariant()__        assert primaryMode == false__        _        updateGlobalCheckpoint(_                shardAllocationId,_                globalCheckpoint,_                current -> {_                    logger.trace("updated global checkpoint from [{}] to [{}] due to [{}]", current, globalCheckpoint, reason)__                    onGlobalCheckpointUpdated.accept(globalCheckpoint)__                })__        assert invariant()__    };updates,the,global,checkpoint,on,a,replica,shard,after,it,has,been,updated,by,the,primary,param,global,checkpoint,the,global,checkpoint,param,reason,the,reason,the,global,checkpoint,was,updated;public,synchronized,void,update,global,checkpoint,on,replica,final,long,global,checkpoint,final,string,reason,assert,invariant,assert,primary,mode,false,update,global,checkpoint,shard,allocation,id,global,checkpoint,current,logger,trace,updated,global,checkpoint,from,to,due,to,current,global,checkpoint,reason,on,global,checkpoint,updated,accept,global,checkpoint,assert,invariant
ReplicationTracker -> public synchronized void updateGlobalCheckpointOnReplica(final long globalCheckpoint, final String reason);1549059559;Updates the global checkpoint on a replica shard after it has been updated by the primary.__@param globalCheckpoint the global checkpoint_@param reason           the reason the global checkpoint was updated;public synchronized void updateGlobalCheckpointOnReplica(final long globalCheckpoint, final String reason) {_        assert invariant()__        assert primaryMode == false__        _        updateGlobalCheckpoint(_                shardAllocationId,_                globalCheckpoint,_                current -> {_                    logger.trace("updated global checkpoint from [{}] to [{}] due to [{}]", current, globalCheckpoint, reason)__                    onGlobalCheckpointUpdated.accept(globalCheckpoint)__                })__        assert invariant()__    };updates,the,global,checkpoint,on,a,replica,shard,after,it,has,been,updated,by,the,primary,param,global,checkpoint,the,global,checkpoint,param,reason,the,reason,the,global,checkpoint,was,updated;public,synchronized,void,update,global,checkpoint,on,replica,final,long,global,checkpoint,final,string,reason,assert,invariant,assert,primary,mode,false,update,global,checkpoint,shard,allocation,id,global,checkpoint,current,logger,trace,updated,global,checkpoint,from,to,due,to,current,global,checkpoint,reason,on,global,checkpoint,updated,accept,global,checkpoint,assert,invariant
ReplicationTracker -> public synchronized void updateGlobalCheckpointOnReplica(final long globalCheckpoint, final String reason);1549294529;Updates the global checkpoint on a replica shard after it has been updated by the primary.__@param globalCheckpoint the global checkpoint_@param reason           the reason the global checkpoint was updated;public synchronized void updateGlobalCheckpointOnReplica(final long globalCheckpoint, final String reason) {_        assert invariant()__        assert primaryMode == false__        _        updateGlobalCheckpoint(_                shardAllocationId,_                globalCheckpoint,_                current -> {_                    logger.trace("updated global checkpoint from [{}] to [{}] due to [{}]", current, globalCheckpoint, reason)__                    onGlobalCheckpointUpdated.accept(globalCheckpoint)__                })__        assert invariant()__    };updates,the,global,checkpoint,on,a,replica,shard,after,it,has,been,updated,by,the,primary,param,global,checkpoint,the,global,checkpoint,param,reason,the,reason,the,global,checkpoint,was,updated;public,synchronized,void,update,global,checkpoint,on,replica,final,long,global,checkpoint,final,string,reason,assert,invariant,assert,primary,mode,false,update,global,checkpoint,shard,allocation,id,global,checkpoint,current,logger,trace,updated,global,checkpoint,from,to,due,to,current,global,checkpoint,reason,on,global,checkpoint,updated,accept,global,checkpoint,assert,invariant
ReplicationTracker -> public synchronized void updateGlobalCheckpointOnReplica(final long globalCheckpoint, final String reason);1549395737;Updates the global checkpoint on a replica shard after it has been updated by the primary.__@param globalCheckpoint the global checkpoint_@param reason           the reason the global checkpoint was updated;public synchronized void updateGlobalCheckpointOnReplica(final long globalCheckpoint, final String reason) {_        assert invariant()__        assert primaryMode == false__        _        updateGlobalCheckpoint(_                shardAllocationId,_                globalCheckpoint,_                current -> {_                    logger.trace("updated global checkpoint from [{}] to [{}] due to [{}]", current, globalCheckpoint, reason)__                    onGlobalCheckpointUpdated.accept(globalCheckpoint)__                })__        assert invariant()__    };updates,the,global,checkpoint,on,a,replica,shard,after,it,has,been,updated,by,the,primary,param,global,checkpoint,the,global,checkpoint,param,reason,the,reason,the,global,checkpoint,was,updated;public,synchronized,void,update,global,checkpoint,on,replica,final,long,global,checkpoint,final,string,reason,assert,invariant,assert,primary,mode,false,update,global,checkpoint,shard,allocation,id,global,checkpoint,current,logger,trace,updated,global,checkpoint,from,to,due,to,current,global,checkpoint,reason,on,global,checkpoint,updated,accept,global,checkpoint,assert,invariant
ReplicationTracker -> public synchronized void updateGlobalCheckpointOnReplica(final long globalCheckpoint, final String reason);1549937843;Updates the global checkpoint on a replica shard after it has been updated by the primary.__@param globalCheckpoint the global checkpoint_@param reason           the reason the global checkpoint was updated;public synchronized void updateGlobalCheckpointOnReplica(final long globalCheckpoint, final String reason) {_        assert invariant()__        assert primaryMode == false__        _        updateGlobalCheckpoint(_                shardAllocationId,_                globalCheckpoint,_                current -> {_                    logger.trace("updated global checkpoint from [{}] to [{}] due to [{}]", current, globalCheckpoint, reason)__                    onGlobalCheckpointUpdated.accept(globalCheckpoint)__                })__        assert invariant()__    };updates,the,global,checkpoint,on,a,replica,shard,after,it,has,been,updated,by,the,primary,param,global,checkpoint,the,global,checkpoint,param,reason,the,reason,the,global,checkpoint,was,updated;public,synchronized,void,update,global,checkpoint,on,replica,final,long,global,checkpoint,final,string,reason,assert,invariant,assert,primary,mode,false,update,global,checkpoint,shard,allocation,id,global,checkpoint,current,logger,trace,updated,global,checkpoint,from,to,due,to,current,global,checkpoint,reason,on,global,checkpoint,updated,accept,global,checkpoint,assert,invariant
ReplicationTracker -> public synchronized void updateGlobalCheckpointOnReplica(final long globalCheckpoint, final String reason);1549949489;Updates the global checkpoint on a replica shard after it has been updated by the primary.__@param globalCheckpoint the global checkpoint_@param reason           the reason the global checkpoint was updated;public synchronized void updateGlobalCheckpointOnReplica(final long globalCheckpoint, final String reason) {_        assert invariant()__        assert primaryMode == false__        _        updateGlobalCheckpoint(_                shardAllocationId,_                globalCheckpoint,_                current -> {_                    logger.trace("updated global checkpoint from [{}] to [{}] due to [{}]", current, globalCheckpoint, reason)__                    onGlobalCheckpointUpdated.accept(globalCheckpoint)__                })__        assert invariant()__    };updates,the,global,checkpoint,on,a,replica,shard,after,it,has,been,updated,by,the,primary,param,global,checkpoint,the,global,checkpoint,param,reason,the,reason,the,global,checkpoint,was,updated;public,synchronized,void,update,global,checkpoint,on,replica,final,long,global,checkpoint,final,string,reason,assert,invariant,assert,primary,mode,false,update,global,checkpoint,shard,allocation,id,global,checkpoint,current,logger,trace,updated,global,checkpoint,from,to,due,to,current,global,checkpoint,reason,on,global,checkpoint,updated,accept,global,checkpoint,assert,invariant
ReplicationTracker -> public synchronized void updateGlobalCheckpointOnReplica(final long globalCheckpoint, final String reason);1550526771;Updates the global checkpoint on a replica shard after it has been updated by the primary.__@param globalCheckpoint the global checkpoint_@param reason           the reason the global checkpoint was updated;public synchronized void updateGlobalCheckpointOnReplica(final long globalCheckpoint, final String reason) {_        assert invariant()__        assert primaryMode == false__        _        updateGlobalCheckpoint(_                shardAllocationId,_                globalCheckpoint,_                current -> {_                    logger.trace("updated global checkpoint from [{}] to [{}] due to [{}]", current, globalCheckpoint, reason)__                    onGlobalCheckpointUpdated.accept(globalCheckpoint)__                })__        assert invariant()__    };updates,the,global,checkpoint,on,a,replica,shard,after,it,has,been,updated,by,the,primary,param,global,checkpoint,the,global,checkpoint,param,reason,the,reason,the,global,checkpoint,was,updated;public,synchronized,void,update,global,checkpoint,on,replica,final,long,global,checkpoint,final,string,reason,assert,invariant,assert,primary,mode,false,update,global,checkpoint,shard,allocation,id,global,checkpoint,current,logger,trace,updated,global,checkpoint,from,to,due,to,current,global,checkpoint,reason,on,global,checkpoint,updated,accept,global,checkpoint,assert,invariant
ReplicationTracker -> public boolean isPrimaryMode();1524684173;Returns whether the replication tracker is in primary mode, i.e., whether the current shard is acting as primary from the point of_view of replication.;public boolean isPrimaryMode() {_        return primaryMode__    };returns,whether,the,replication,tracker,is,in,primary,mode,i,e,whether,the,current,shard,is,acting,as,primary,from,the,point,of,view,of,replication;public,boolean,is,primary,mode,return,primary,mode
ReplicationTracker -> public boolean isPrimaryMode();1525334055;Returns whether the replication tracker is in primary mode, i.e., whether the current shard is acting as primary from the point of_view of replication.;public boolean isPrimaryMode() {_        return primaryMode__    };returns,whether,the,replication,tracker,is,in,primary,mode,i,e,whether,the,current,shard,is,acting,as,primary,from,the,point,of,view,of,replication;public,boolean,is,primary,mode,return,primary,mode
ReplicationTracker -> public boolean isPrimaryMode();1533295538;Returns whether the replication tracker is in primary mode, i.e., whether the current shard is acting as primary from the point of_view of replication.;public boolean isPrimaryMode() {_        return primaryMode__    };returns,whether,the,replication,tracker,is,in,primary,mode,i,e,whether,the,current,shard,is,acting,as,primary,from,the,point,of,view,of,replication;public,boolean,is,primary,mode,return,primary,mode
ReplicationTracker -> public boolean isPrimaryMode();1533738061;Returns whether the replication tracker is in primary mode, i.e., whether the current shard is acting as primary from the point of_view of replication.;public boolean isPrimaryMode() {_        return primaryMode__    };returns,whether,the,replication,tracker,is,in,primary,mode,i,e,whether,the,current,shard,is,acting,as,primary,from,the,point,of,view,of,replication;public,boolean,is,primary,mode,return,primary,mode
ReplicationTracker -> public boolean isPrimaryMode();1546875837;Returns whether the replication tracker is in primary mode, i.e., whether the current shard is acting as primary from the point of_view of replication.;public boolean isPrimaryMode() {_        return primaryMode__    };returns,whether,the,replication,tracker,is,in,primary,mode,i,e,whether,the,current,shard,is,acting,as,primary,from,the,point,of,view,of,replication;public,boolean,is,primary,mode,return,primary,mode
ReplicationTracker -> public boolean isPrimaryMode();1546927432;Returns whether the replication tracker is in primary mode, i.e., whether the current shard is acting as primary from the point of_view of replication.;public boolean isPrimaryMode() {_        return primaryMode__    };returns,whether,the,replication,tracker,is,in,primary,mode,i,e,whether,the,current,shard,is,acting,as,primary,from,the,point,of,view,of,replication;public,boolean,is,primary,mode,return,primary,mode
ReplicationTracker -> public boolean isPrimaryMode();1547332999;Returns whether the replication tracker is in primary mode, i.e., whether the current shard is acting as primary from the point of_view of replication.;public boolean isPrimaryMode() {_        return primaryMode__    };returns,whether,the,replication,tracker,is,in,primary,mode,i,e,whether,the,current,shard,is,acting,as,primary,from,the,point,of,view,of,replication;public,boolean,is,primary,mode,return,primary,mode
ReplicationTracker -> public boolean isPrimaryMode();1548593396;Returns whether the replication tracker is in primary mode, i.e., whether the current shard is acting as primary from the point of_view of replication.;public boolean isPrimaryMode() {_        return primaryMode__    };returns,whether,the,replication,tracker,is,in,primary,mode,i,e,whether,the,current,shard,is,acting,as,primary,from,the,point,of,view,of,replication;public,boolean,is,primary,mode,return,primary,mode
ReplicationTracker -> public boolean isPrimaryMode();1548594827;Returns whether the replication tracker is in primary mode, i.e., whether the current shard is acting as primary from the point of_view of replication.;public boolean isPrimaryMode() {_        return primaryMode__    };returns,whether,the,replication,tracker,is,in,primary,mode,i,e,whether,the,current,shard,is,acting,as,primary,from,the,point,of,view,of,replication;public,boolean,is,primary,mode,return,primary,mode
ReplicationTracker -> public boolean isPrimaryMode();1548677511;Returns whether the replication tracker is in primary mode, i.e., whether the current shard is acting as primary from the point of_view of replication.;public boolean isPrimaryMode() {_        return primaryMode__    };returns,whether,the,replication,tracker,is,in,primary,mode,i,e,whether,the,current,shard,is,acting,as,primary,from,the,point,of,view,of,replication;public,boolean,is,primary,mode,return,primary,mode
ReplicationTracker -> public boolean isPrimaryMode();1548944389;Returns whether the replication tracker is in primary mode, i.e., whether the current shard is acting as primary from the point of_view of replication.;public boolean isPrimaryMode() {_        return primaryMode__    };returns,whether,the,replication,tracker,is,in,primary,mode,i,e,whether,the,current,shard,is,acting,as,primary,from,the,point,of,view,of,replication;public,boolean,is,primary,mode,return,primary,mode
ReplicationTracker -> public boolean isPrimaryMode();1549059559;Returns whether the replication tracker is in primary mode, i.e., whether the current shard is acting as primary from the point of_view of replication.;public boolean isPrimaryMode() {_        return primaryMode__    };returns,whether,the,replication,tracker,is,in,primary,mode,i,e,whether,the,current,shard,is,acting,as,primary,from,the,point,of,view,of,replication;public,boolean,is,primary,mode,return,primary,mode
ReplicationTracker -> public boolean isPrimaryMode();1549294529;Returns whether the replication tracker is in primary mode, i.e., whether the current shard is acting as primary from the point of_view of replication.;public boolean isPrimaryMode() {_        return primaryMode__    };returns,whether,the,replication,tracker,is,in,primary,mode,i,e,whether,the,current,shard,is,acting,as,primary,from,the,point,of,view,of,replication;public,boolean,is,primary,mode,return,primary,mode
ReplicationTracker -> public boolean isPrimaryMode();1549395737;Returns whether the replication tracker is in primary mode, i.e., whether the current shard is acting as primary from the point of_view of replication.;public boolean isPrimaryMode() {_        return primaryMode__    };returns,whether,the,replication,tracker,is,in,primary,mode,i,e,whether,the,current,shard,is,acting,as,primary,from,the,point,of,view,of,replication;public,boolean,is,primary,mode,return,primary,mode
ReplicationTracker -> public boolean isPrimaryMode();1549937843;Returns whether the replication tracker is in primary mode, i.e., whether the current shard is acting as primary from the point of_view of replication.;public boolean isPrimaryMode() {_        return primaryMode__    };returns,whether,the,replication,tracker,is,in,primary,mode,i,e,whether,the,current,shard,is,acting,as,primary,from,the,point,of,view,of,replication;public,boolean,is,primary,mode,return,primary,mode
ReplicationTracker -> public boolean isPrimaryMode();1549949489;Returns whether the replication tracker is in primary mode, i.e., whether the current shard is acting as primary from the point of_view of replication.;public boolean isPrimaryMode() {_        return primaryMode__    };returns,whether,the,replication,tracker,is,in,primary,mode,i,e,whether,the,current,shard,is,acting,as,primary,from,the,point,of,view,of,replication;public,boolean,is,primary,mode,return,primary,mode
ReplicationTracker -> public boolean isPrimaryMode();1550526771;Returns whether the replication tracker is in primary mode, i.e., whether the current shard is acting as primary from the point of_view of replication.;public boolean isPrimaryMode() {_        return primaryMode__    };returns,whether,the,replication,tracker,is,in,primary,mode,i,e,whether,the,current,shard,is,acting,as,primary,from,the,point,of,view,of,replication;public,boolean,is,primary,mode,return,primary,mode
ReplicationTracker -> public ReplicationGroup getReplicationGroup();1524684173;Returns the current replication group for the shard.__@return the replication group;public ReplicationGroup getReplicationGroup() {_        assert primaryMode__        return replicationGroup__    };returns,the,current,replication,group,for,the,shard,return,the,replication,group;public,replication,group,get,replication,group,assert,primary,mode,return,replication,group
ReplicationTracker -> public ReplicationGroup getReplicationGroup();1525334055;Returns the current replication group for the shard.__@return the replication group;public ReplicationGroup getReplicationGroup() {_        assert primaryMode__        return replicationGroup__    };returns,the,current,replication,group,for,the,shard,return,the,replication,group;public,replication,group,get,replication,group,assert,primary,mode,return,replication,group
ReplicationTracker -> public ReplicationGroup getReplicationGroup();1533295538;Returns the current replication group for the shard.__@return the replication group;public ReplicationGroup getReplicationGroup() {_        assert primaryMode__        return replicationGroup__    };returns,the,current,replication,group,for,the,shard,return,the,replication,group;public,replication,group,get,replication,group,assert,primary,mode,return,replication,group
ReplicationTracker -> public ReplicationGroup getReplicationGroup();1533738061;Returns the current replication group for the shard.__@return the replication group;public ReplicationGroup getReplicationGroup() {_        assert primaryMode__        return replicationGroup__    };returns,the,current,replication,group,for,the,shard,return,the,replication,group;public,replication,group,get,replication,group,assert,primary,mode,return,replication,group
ReplicationTracker -> public ReplicationGroup getReplicationGroup();1546875837;Returns the current replication group for the shard.__@return the replication group;public ReplicationGroup getReplicationGroup() {_        assert primaryMode__        return replicationGroup__    };returns,the,current,replication,group,for,the,shard,return,the,replication,group;public,replication,group,get,replication,group,assert,primary,mode,return,replication,group
ReplicationTracker -> public ReplicationGroup getReplicationGroup();1546927432;Returns the current replication group for the shard.__@return the replication group;public ReplicationGroup getReplicationGroup() {_        assert primaryMode__        return replicationGroup__    };returns,the,current,replication,group,for,the,shard,return,the,replication,group;public,replication,group,get,replication,group,assert,primary,mode,return,replication,group
ReplicationTracker -> public ReplicationGroup getReplicationGroup();1547332999;Returns the current replication group for the shard.__@return the replication group;public ReplicationGroup getReplicationGroup() {_        assert primaryMode__        return replicationGroup__    };returns,the,current,replication,group,for,the,shard,return,the,replication,group;public,replication,group,get,replication,group,assert,primary,mode,return,replication,group
ReplicationTracker -> public ReplicationGroup getReplicationGroup();1548593396;Returns the current replication group for the shard.__@return the replication group;public ReplicationGroup getReplicationGroup() {_        assert primaryMode__        return replicationGroup__    };returns,the,current,replication,group,for,the,shard,return,the,replication,group;public,replication,group,get,replication,group,assert,primary,mode,return,replication,group
ReplicationTracker -> public ReplicationGroup getReplicationGroup();1548594827;Returns the current replication group for the shard.__@return the replication group;public ReplicationGroup getReplicationGroup() {_        assert primaryMode__        return replicationGroup__    };returns,the,current,replication,group,for,the,shard,return,the,replication,group;public,replication,group,get,replication,group,assert,primary,mode,return,replication,group
ReplicationTracker -> public ReplicationGroup getReplicationGroup();1548677511;Returns the current replication group for the shard.__@return the replication group;public ReplicationGroup getReplicationGroup() {_        assert primaryMode__        return replicationGroup__    };returns,the,current,replication,group,for,the,shard,return,the,replication,group;public,replication,group,get,replication,group,assert,primary,mode,return,replication,group
ReplicationTracker -> public ReplicationGroup getReplicationGroup();1548944389;Returns the current replication group for the shard.__@return the replication group;public ReplicationGroup getReplicationGroup() {_        assert primaryMode__        return replicationGroup__    };returns,the,current,replication,group,for,the,shard,return,the,replication,group;public,replication,group,get,replication,group,assert,primary,mode,return,replication,group
ReplicationTracker -> public ReplicationGroup getReplicationGroup();1549059559;Returns the current replication group for the shard.__@return the replication group;public ReplicationGroup getReplicationGroup() {_        assert primaryMode__        return replicationGroup__    };returns,the,current,replication,group,for,the,shard,return,the,replication,group;public,replication,group,get,replication,group,assert,primary,mode,return,replication,group
ReplicationTracker -> public ReplicationGroup getReplicationGroup();1549294529;Returns the current replication group for the shard.__@return the replication group;public ReplicationGroup getReplicationGroup() {_        assert primaryMode__        return replicationGroup__    };returns,the,current,replication,group,for,the,shard,return,the,replication,group;public,replication,group,get,replication,group,assert,primary,mode,return,replication,group
ReplicationTracker -> public ReplicationGroup getReplicationGroup();1549395737;Returns the current replication group for the shard.__@return the replication group;public ReplicationGroup getReplicationGroup() {_        assert primaryMode__        return replicationGroup__    };returns,the,current,replication,group,for,the,shard,return,the,replication,group;public,replication,group,get,replication,group,assert,primary,mode,return,replication,group
ReplicationTracker -> public ReplicationGroup getReplicationGroup();1549937843;Returns the current replication group for the shard.__@return the replication group;public ReplicationGroup getReplicationGroup() {_        assert primaryMode__        return replicationGroup__    };returns,the,current,replication,group,for,the,shard,return,the,replication,group;public,replication,group,get,replication,group,assert,primary,mode,return,replication,group
ReplicationTracker -> public ReplicationGroup getReplicationGroup();1549949489;Returns the current replication group for the shard.__@return the replication group;public ReplicationGroup getReplicationGroup() {_        assert primaryMode__        return replicationGroup__    };returns,the,current,replication,group,for,the,shard,return,the,replication,group;public,replication,group,get,replication,group,assert,primary,mode,return,replication,group
ReplicationTracker -> public ReplicationGroup getReplicationGroup();1550526771;Returns the current replication group for the shard.__@return the replication group;public ReplicationGroup getReplicationGroup() {_        assert primaryMode__        return replicationGroup__    };returns,the,current,replication,group,for,the,shard,return,the,replication,group;public,replication,group,get,replication,group,assert,primary,mode,return,replication,group
ReplicationTracker -> public synchronized Collection<RetentionLease> getRetentionLeases();1546875837;Get all retention leases tracker on this shard. An unmodifiable copy of the retention leases is returned.__@return the retention leases;public synchronized Collection<RetentionLease> getRetentionLeases() {_        return Collections.unmodifiableCollection(new ArrayList<>(retentionLeases.values()))__    };get,all,retention,leases,tracker,on,this,shard,an,unmodifiable,copy,of,the,retention,leases,is,returned,return,the,retention,leases;public,synchronized,collection,retention,lease,get,retention,leases,return,collections,unmodifiable,collection,new,array,list,retention,leases,values
ReplicationTracker -> public synchronized Collection<RetentionLease> getRetentionLeases();1546927432;Get all non-expired retention leases tracker on this shard. An unmodifiable copy of the retention leases is returned.__@return the retention leases;public synchronized Collection<RetentionLease> getRetentionLeases() {_        final long currentTimeMillis = currentTimeMillisSupplier.getAsLong()__        final long retentionLeaseMillis = indexSettings.getRetentionLeaseMillis()__        final Collection<RetentionLease> nonExpiredRetentionLeases = retentionLeases_                .values()_                .stream()_                .filter(retentionLease -> currentTimeMillis - retentionLease.timestamp() <= retentionLeaseMillis)_                .collect(Collectors.toList())__        retentionLeases.clear()__        retentionLeases.putAll(nonExpiredRetentionLeases.stream().collect(Collectors.toMap(RetentionLease::id, lease -> lease)))__        return Collections.unmodifiableCollection(nonExpiredRetentionLeases)__    };get,all,non,expired,retention,leases,tracker,on,this,shard,an,unmodifiable,copy,of,the,retention,leases,is,returned,return,the,retention,leases;public,synchronized,collection,retention,lease,get,retention,leases,final,long,current,time,millis,current,time,millis,supplier,get,as,long,final,long,retention,lease,millis,index,settings,get,retention,lease,millis,final,collection,retention,lease,non,expired,retention,leases,retention,leases,values,stream,filter,retention,lease,current,time,millis,retention,lease,timestamp,retention,lease,millis,collect,collectors,to,list,retention,leases,clear,retention,leases,put,all,non,expired,retention,leases,stream,collect,collectors,to,map,retention,lease,id,lease,lease,return,collections,unmodifiable,collection,non,expired,retention,leases
ReplicationTracker -> public synchronized Collection<RetentionLease> getRetentionLeases();1547332999;Get all non-expired retention leases tracker on this shard. An unmodifiable copy of the retention leases is returned.__@return the retention leases;public synchronized Collection<RetentionLease> getRetentionLeases() {_        final long currentTimeMillis = currentTimeMillisSupplier.getAsLong()__        final long retentionLeaseMillis = indexSettings.getRetentionLeaseMillis()__        final Collection<RetentionLease> nonExpiredRetentionLeases = retentionLeases_                .values()_                .stream()_                .filter(retentionLease -> currentTimeMillis - retentionLease.timestamp() <= retentionLeaseMillis)_                .collect(Collectors.toList())__        retentionLeases.clear()__        retentionLeases.putAll(nonExpiredRetentionLeases.stream().collect(Collectors.toMap(RetentionLease::id, lease -> lease)))__        return Collections.unmodifiableCollection(nonExpiredRetentionLeases)__    };get,all,non,expired,retention,leases,tracker,on,this,shard,an,unmodifiable,copy,of,the,retention,leases,is,returned,return,the,retention,leases;public,synchronized,collection,retention,lease,get,retention,leases,final,long,current,time,millis,current,time,millis,supplier,get,as,long,final,long,retention,lease,millis,index,settings,get,retention,lease,millis,final,collection,retention,lease,non,expired,retention,leases,retention,leases,values,stream,filter,retention,lease,current,time,millis,retention,lease,timestamp,retention,lease,millis,collect,collectors,to,list,retention,leases,clear,retention,leases,put,all,non,expired,retention,leases,stream,collect,collectors,to,map,retention,lease,id,lease,lease,return,collections,unmodifiable,collection,non,expired,retention,leases
ReplicationTracker -> public synchronized Collection<RetentionLease> getRetentionLeases();1548593396;Get all non-expired retention leases tracked on this shard. An unmodifiable copy of the retention leases is returned.__@return the retention leases;public synchronized Collection<RetentionLease> getRetentionLeases() {_        final long currentTimeMillis = currentTimeMillisSupplier.getAsLong()__        final long retentionLeaseMillis = indexSettings.getRetentionLeaseMillis()__        final Collection<RetentionLease> nonExpiredRetentionLeases = retentionLeases_                .values()_                .stream()_                .filter(retentionLease -> currentTimeMillis - retentionLease.timestamp() <= retentionLeaseMillis)_                .collect(Collectors.toList())__        retentionLeases.clear()__        retentionLeases.putAll(nonExpiredRetentionLeases.stream().collect(Collectors.toMap(RetentionLease::id, lease -> lease)))__        return Collections.unmodifiableCollection(nonExpiredRetentionLeases)__    };get,all,non,expired,retention,leases,tracked,on,this,shard,an,unmodifiable,copy,of,the,retention,leases,is,returned,return,the,retention,leases;public,synchronized,collection,retention,lease,get,retention,leases,final,long,current,time,millis,current,time,millis,supplier,get,as,long,final,long,retention,lease,millis,index,settings,get,retention,lease,millis,final,collection,retention,lease,non,expired,retention,leases,retention,leases,values,stream,filter,retention,lease,current,time,millis,retention,lease,timestamp,retention,lease,millis,collect,collectors,to,list,retention,leases,clear,retention,leases,put,all,non,expired,retention,leases,stream,collect,collectors,to,map,retention,lease,id,lease,lease,return,collections,unmodifiable,collection,non,expired,retention,leases
ReplicationTracker -> public synchronized Collection<RetentionLease> getRetentionLeases();1548594827;Get all non-expired retention leases tracked on this shard. An unmodifiable copy of the retention leases is returned.__@return the retention leases;public synchronized Collection<RetentionLease> getRetentionLeases() {_        final long currentTimeMillis = currentTimeMillisSupplier.getAsLong()__        final long retentionLeaseMillis = indexSettings.getRetentionLeaseMillis()__        final Collection<RetentionLease> nonExpiredRetentionLeases = retentionLeases_                .values()_                .stream()_                .filter(retentionLease -> currentTimeMillis - retentionLease.timestamp() <= retentionLeaseMillis)_                .collect(Collectors.toList())__        retentionLeases.clear()__        retentionLeases.putAll(nonExpiredRetentionLeases.stream().collect(Collectors.toMap(RetentionLease::id, lease -> lease)))__        return Collections.unmodifiableCollection(nonExpiredRetentionLeases)__    };get,all,non,expired,retention,leases,tracked,on,this,shard,an,unmodifiable,copy,of,the,retention,leases,is,returned,return,the,retention,leases;public,synchronized,collection,retention,lease,get,retention,leases,final,long,current,time,millis,current,time,millis,supplier,get,as,long,final,long,retention,lease,millis,index,settings,get,retention,lease,millis,final,collection,retention,lease,non,expired,retention,leases,retention,leases,values,stream,filter,retention,lease,current,time,millis,retention,lease,timestamp,retention,lease,millis,collect,collectors,to,list,retention,leases,clear,retention,leases,put,all,non,expired,retention,leases,stream,collect,collectors,to,map,retention,lease,id,lease,lease,return,collections,unmodifiable,collection,non,expired,retention,leases
ReplicationTracker -> public synchronized void activateWithPrimaryContext(PrimaryContext primaryContext);1524684173;Activates the global checkpoint tracker in primary mode (see {@link #primaryMode}. Called on primary relocation target during_primary relocation handoff.__@param primaryContext the primary context used to initialize the state;public synchronized void activateWithPrimaryContext(PrimaryContext primaryContext) {_        assert invariant()__        assert primaryMode == false__        final Runnable runAfter = getMasterUpdateOperationFromCurrentState()__        primaryMode = true__        _        appliedClusterStateVersion = primaryContext.clusterStateVersion()__        checkpoints.clear()__        for (Map.Entry<String, CheckpointState> entry : primaryContext.checkpoints.entrySet()) {_            checkpoints.put(entry.getKey(), entry.getValue().copy())__        }_        routingTable = primaryContext.getRoutingTable()__        replicationGroup = calculateReplicationGroup()__        updateGlobalCheckpointOnPrimary()__        _        _        _        runAfter.run()__        assert invariant()__    };activates,the,global,checkpoint,tracker,in,primary,mode,see,link,primary,mode,called,on,primary,relocation,target,during,primary,relocation,handoff,param,primary,context,the,primary,context,used,to,initialize,the,state;public,synchronized,void,activate,with,primary,context,primary,context,primary,context,assert,invariant,assert,primary,mode,false,final,runnable,run,after,get,master,update,operation,from,current,state,primary,mode,true,applied,cluster,state,version,primary,context,cluster,state,version,checkpoints,clear,for,map,entry,string,checkpoint,state,entry,primary,context,checkpoints,entry,set,checkpoints,put,entry,get,key,entry,get,value,copy,routing,table,primary,context,get,routing,table,replication,group,calculate,replication,group,update,global,checkpoint,on,primary,run,after,run,assert,invariant
ReplicationTracker -> public synchronized void activateWithPrimaryContext(PrimaryContext primaryContext);1525334055;Activates the global checkpoint tracker in primary mode (see {@link #primaryMode}. Called on primary relocation target during_primary relocation handoff.__@param primaryContext the primary context used to initialize the state;public synchronized void activateWithPrimaryContext(PrimaryContext primaryContext) {_        assert invariant()__        assert primaryMode == false__        final Runnable runAfter = getMasterUpdateOperationFromCurrentState()__        primaryMode = true__        _        appliedClusterStateVersion = primaryContext.clusterStateVersion()__        checkpoints.clear()__        for (Map.Entry<String, CheckpointState> entry : primaryContext.checkpoints.entrySet()) {_            checkpoints.put(entry.getKey(), entry.getValue().copy())__        }_        routingTable = primaryContext.getRoutingTable()__        replicationGroup = calculateReplicationGroup()__        updateGlobalCheckpointOnPrimary()__        _        _        _        runAfter.run()__        assert invariant()__    };activates,the,global,checkpoint,tracker,in,primary,mode,see,link,primary,mode,called,on,primary,relocation,target,during,primary,relocation,handoff,param,primary,context,the,primary,context,used,to,initialize,the,state;public,synchronized,void,activate,with,primary,context,primary,context,primary,context,assert,invariant,assert,primary,mode,false,final,runnable,run,after,get,master,update,operation,from,current,state,primary,mode,true,applied,cluster,state,version,primary,context,cluster,state,version,checkpoints,clear,for,map,entry,string,checkpoint,state,entry,primary,context,checkpoints,entry,set,checkpoints,put,entry,get,key,entry,get,value,copy,routing,table,primary,context,get,routing,table,replication,group,calculate,replication,group,update,global,checkpoint,on,primary,run,after,run,assert,invariant
ReplicationTracker -> public synchronized void activateWithPrimaryContext(PrimaryContext primaryContext);1533295538;Activates the global checkpoint tracker in primary mode (see {@link #primaryMode}. Called on primary relocation target during_primary relocation handoff.__@param primaryContext the primary context used to initialize the state;public synchronized void activateWithPrimaryContext(PrimaryContext primaryContext) {_        assert invariant()__        assert primaryMode == false__        final Runnable runAfter = getMasterUpdateOperationFromCurrentState()__        primaryMode = true__        _        appliedClusterStateVersion = primaryContext.clusterStateVersion()__        checkpoints.clear()__        for (Map.Entry<String, CheckpointState> entry : primaryContext.checkpoints.entrySet()) {_            checkpoints.put(entry.getKey(), entry.getValue().copy())__        }_        routingTable = primaryContext.getRoutingTable()__        replicationGroup = calculateReplicationGroup()__        updateGlobalCheckpointOnPrimary()__        _        _        _        runAfter.run()__        assert invariant()__    };activates,the,global,checkpoint,tracker,in,primary,mode,see,link,primary,mode,called,on,primary,relocation,target,during,primary,relocation,handoff,param,primary,context,the,primary,context,used,to,initialize,the,state;public,synchronized,void,activate,with,primary,context,primary,context,primary,context,assert,invariant,assert,primary,mode,false,final,runnable,run,after,get,master,update,operation,from,current,state,primary,mode,true,applied,cluster,state,version,primary,context,cluster,state,version,checkpoints,clear,for,map,entry,string,checkpoint,state,entry,primary,context,checkpoints,entry,set,checkpoints,put,entry,get,key,entry,get,value,copy,routing,table,primary,context,get,routing,table,replication,group,calculate,replication,group,update,global,checkpoint,on,primary,run,after,run,assert,invariant
ReplicationTracker -> public synchronized void activateWithPrimaryContext(PrimaryContext primaryContext);1533738061;Activates the global checkpoint tracker in primary mode (see {@link #primaryMode}. Called on primary relocation target during_primary relocation handoff.__@param primaryContext the primary context used to initialize the state;public synchronized void activateWithPrimaryContext(PrimaryContext primaryContext) {_        assert invariant()__        assert primaryMode == false__        final Runnable runAfter = getMasterUpdateOperationFromCurrentState()__        primaryMode = true__        _        appliedClusterStateVersion = primaryContext.clusterStateVersion()__        checkpoints.clear()__        for (Map.Entry<String, CheckpointState> entry : primaryContext.checkpoints.entrySet()) {_            checkpoints.put(entry.getKey(), entry.getValue().copy())__        }_        routingTable = primaryContext.getRoutingTable()__        replicationGroup = calculateReplicationGroup()__        updateGlobalCheckpointOnPrimary()__        _        _        _        runAfter.run()__        assert invariant()__    };activates,the,global,checkpoint,tracker,in,primary,mode,see,link,primary,mode,called,on,primary,relocation,target,during,primary,relocation,handoff,param,primary,context,the,primary,context,used,to,initialize,the,state;public,synchronized,void,activate,with,primary,context,primary,context,primary,context,assert,invariant,assert,primary,mode,false,final,runnable,run,after,get,master,update,operation,from,current,state,primary,mode,true,applied,cluster,state,version,primary,context,cluster,state,version,checkpoints,clear,for,map,entry,string,checkpoint,state,entry,primary,context,checkpoints,entry,set,checkpoints,put,entry,get,key,entry,get,value,copy,routing,table,primary,context,get,routing,table,replication,group,calculate,replication,group,update,global,checkpoint,on,primary,run,after,run,assert,invariant
ReplicationTracker -> public synchronized void activateWithPrimaryContext(PrimaryContext primaryContext);1546875837;Activates the global checkpoint tracker in primary mode (see {@link #primaryMode}. Called on primary relocation target during_primary relocation handoff.__@param primaryContext the primary context used to initialize the state;public synchronized void activateWithPrimaryContext(PrimaryContext primaryContext) {_        assert invariant()__        assert primaryMode == false__        final Runnable runAfter = getMasterUpdateOperationFromCurrentState()__        primaryMode = true__        _        appliedClusterStateVersion = primaryContext.clusterStateVersion()__        checkpoints.clear()__        for (Map.Entry<String, CheckpointState> entry : primaryContext.checkpoints.entrySet()) {_            checkpoints.put(entry.getKey(), entry.getValue().copy())__        }_        routingTable = primaryContext.getRoutingTable()__        replicationGroup = calculateReplicationGroup()__        updateGlobalCheckpointOnPrimary()__        _        _        _        runAfter.run()__        assert invariant()__    };activates,the,global,checkpoint,tracker,in,primary,mode,see,link,primary,mode,called,on,primary,relocation,target,during,primary,relocation,handoff,param,primary,context,the,primary,context,used,to,initialize,the,state;public,synchronized,void,activate,with,primary,context,primary,context,primary,context,assert,invariant,assert,primary,mode,false,final,runnable,run,after,get,master,update,operation,from,current,state,primary,mode,true,applied,cluster,state,version,primary,context,cluster,state,version,checkpoints,clear,for,map,entry,string,checkpoint,state,entry,primary,context,checkpoints,entry,set,checkpoints,put,entry,get,key,entry,get,value,copy,routing,table,primary,context,get,routing,table,replication,group,calculate,replication,group,update,global,checkpoint,on,primary,run,after,run,assert,invariant
ReplicationTracker -> public synchronized void activateWithPrimaryContext(PrimaryContext primaryContext);1546927432;Activates the global checkpoint tracker in primary mode (see {@link #primaryMode}. Called on primary relocation target during_primary relocation handoff.__@param primaryContext the primary context used to initialize the state;public synchronized void activateWithPrimaryContext(PrimaryContext primaryContext) {_        assert invariant()__        assert primaryMode == false__        final Runnable runAfter = getMasterUpdateOperationFromCurrentState()__        primaryMode = true__        _        appliedClusterStateVersion = primaryContext.clusterStateVersion()__        checkpoints.clear()__        for (Map.Entry<String, CheckpointState> entry : primaryContext.checkpoints.entrySet()) {_            checkpoints.put(entry.getKey(), entry.getValue().copy())__        }_        routingTable = primaryContext.getRoutingTable()__        replicationGroup = calculateReplicationGroup()__        updateGlobalCheckpointOnPrimary()__        _        _        _        runAfter.run()__        assert invariant()__    };activates,the,global,checkpoint,tracker,in,primary,mode,see,link,primary,mode,called,on,primary,relocation,target,during,primary,relocation,handoff,param,primary,context,the,primary,context,used,to,initialize,the,state;public,synchronized,void,activate,with,primary,context,primary,context,primary,context,assert,invariant,assert,primary,mode,false,final,runnable,run,after,get,master,update,operation,from,current,state,primary,mode,true,applied,cluster,state,version,primary,context,cluster,state,version,checkpoints,clear,for,map,entry,string,checkpoint,state,entry,primary,context,checkpoints,entry,set,checkpoints,put,entry,get,key,entry,get,value,copy,routing,table,primary,context,get,routing,table,replication,group,calculate,replication,group,update,global,checkpoint,on,primary,run,after,run,assert,invariant
ReplicationTracker -> public synchronized void activateWithPrimaryContext(PrimaryContext primaryContext);1547332999;Activates the global checkpoint tracker in primary mode (see {@link #primaryMode}. Called on primary relocation target during_primary relocation handoff.__@param primaryContext the primary context used to initialize the state;public synchronized void activateWithPrimaryContext(PrimaryContext primaryContext) {_        assert invariant()__        assert primaryMode == false__        final Runnable runAfter = getMasterUpdateOperationFromCurrentState()__        primaryMode = true__        _        appliedClusterStateVersion = primaryContext.clusterStateVersion()__        checkpoints.clear()__        for (Map.Entry<String, CheckpointState> entry : primaryContext.checkpoints.entrySet()) {_            checkpoints.put(entry.getKey(), entry.getValue().copy())__        }_        routingTable = primaryContext.getRoutingTable()__        replicationGroup = calculateReplicationGroup()__        updateGlobalCheckpointOnPrimary()__        _        _        _        runAfter.run()__        assert invariant()__    };activates,the,global,checkpoint,tracker,in,primary,mode,see,link,primary,mode,called,on,primary,relocation,target,during,primary,relocation,handoff,param,primary,context,the,primary,context,used,to,initialize,the,state;public,synchronized,void,activate,with,primary,context,primary,context,primary,context,assert,invariant,assert,primary,mode,false,final,runnable,run,after,get,master,update,operation,from,current,state,primary,mode,true,applied,cluster,state,version,primary,context,cluster,state,version,checkpoints,clear,for,map,entry,string,checkpoint,state,entry,primary,context,checkpoints,entry,set,checkpoints,put,entry,get,key,entry,get,value,copy,routing,table,primary,context,get,routing,table,replication,group,calculate,replication,group,update,global,checkpoint,on,primary,run,after,run,assert,invariant
ReplicationTracker -> public synchronized void activateWithPrimaryContext(PrimaryContext primaryContext);1548593396;Activates the global checkpoint tracker in primary mode (see {@link #primaryMode}. Called on primary relocation target during_primary relocation handoff.__@param primaryContext the primary context used to initialize the state;public synchronized void activateWithPrimaryContext(PrimaryContext primaryContext) {_        assert invariant()__        assert primaryMode == false__        final Runnable runAfter = getMasterUpdateOperationFromCurrentState()__        primaryMode = true__        _        appliedClusterStateVersion = primaryContext.clusterStateVersion()__        checkpoints.clear()__        for (Map.Entry<String, CheckpointState> entry : primaryContext.checkpoints.entrySet()) {_            checkpoints.put(entry.getKey(), entry.getValue().copy())__        }_        routingTable = primaryContext.getRoutingTable()__        replicationGroup = calculateReplicationGroup()__        updateGlobalCheckpointOnPrimary()__        _        _        _        runAfter.run()__        assert invariant()__    };activates,the,global,checkpoint,tracker,in,primary,mode,see,link,primary,mode,called,on,primary,relocation,target,during,primary,relocation,handoff,param,primary,context,the,primary,context,used,to,initialize,the,state;public,synchronized,void,activate,with,primary,context,primary,context,primary,context,assert,invariant,assert,primary,mode,false,final,runnable,run,after,get,master,update,operation,from,current,state,primary,mode,true,applied,cluster,state,version,primary,context,cluster,state,version,checkpoints,clear,for,map,entry,string,checkpoint,state,entry,primary,context,checkpoints,entry,set,checkpoints,put,entry,get,key,entry,get,value,copy,routing,table,primary,context,get,routing,table,replication,group,calculate,replication,group,update,global,checkpoint,on,primary,run,after,run,assert,invariant
ReplicationTracker -> public synchronized void activateWithPrimaryContext(PrimaryContext primaryContext);1548594827;Activates the global checkpoint tracker in primary mode (see {@link #primaryMode}. Called on primary relocation target during_primary relocation handoff.__@param primaryContext the primary context used to initialize the state;public synchronized void activateWithPrimaryContext(PrimaryContext primaryContext) {_        assert invariant()__        assert primaryMode == false__        final Runnable runAfter = getMasterUpdateOperationFromCurrentState()__        primaryMode = true__        _        appliedClusterStateVersion = primaryContext.clusterStateVersion()__        checkpoints.clear()__        for (Map.Entry<String, CheckpointState> entry : primaryContext.checkpoints.entrySet()) {_            checkpoints.put(entry.getKey(), entry.getValue().copy())__        }_        routingTable = primaryContext.getRoutingTable()__        replicationGroup = calculateReplicationGroup()__        updateGlobalCheckpointOnPrimary()__        _        _        _        runAfter.run()__        assert invariant()__    };activates,the,global,checkpoint,tracker,in,primary,mode,see,link,primary,mode,called,on,primary,relocation,target,during,primary,relocation,handoff,param,primary,context,the,primary,context,used,to,initialize,the,state;public,synchronized,void,activate,with,primary,context,primary,context,primary,context,assert,invariant,assert,primary,mode,false,final,runnable,run,after,get,master,update,operation,from,current,state,primary,mode,true,applied,cluster,state,version,primary,context,cluster,state,version,checkpoints,clear,for,map,entry,string,checkpoint,state,entry,primary,context,checkpoints,entry,set,checkpoints,put,entry,get,key,entry,get,value,copy,routing,table,primary,context,get,routing,table,replication,group,calculate,replication,group,update,global,checkpoint,on,primary,run,after,run,assert,invariant
ReplicationTracker -> public synchronized void activateWithPrimaryContext(PrimaryContext primaryContext);1548677511;Activates the global checkpoint tracker in primary mode (see {@link #primaryMode}. Called on primary relocation target during_primary relocation handoff.__@param primaryContext the primary context used to initialize the state;public synchronized void activateWithPrimaryContext(PrimaryContext primaryContext) {_        assert invariant()__        assert primaryMode == false__        final Runnable runAfter = getMasterUpdateOperationFromCurrentState()__        primaryMode = true__        _        appliedClusterStateVersion = primaryContext.clusterStateVersion()__        checkpoints.clear()__        for (Map.Entry<String, CheckpointState> entry : primaryContext.checkpoints.entrySet()) {_            checkpoints.put(entry.getKey(), entry.getValue().copy())__        }_        routingTable = primaryContext.getRoutingTable()__        replicationGroup = calculateReplicationGroup()__        updateGlobalCheckpointOnPrimary()__        _        _        _        runAfter.run()__        assert invariant()__    };activates,the,global,checkpoint,tracker,in,primary,mode,see,link,primary,mode,called,on,primary,relocation,target,during,primary,relocation,handoff,param,primary,context,the,primary,context,used,to,initialize,the,state;public,synchronized,void,activate,with,primary,context,primary,context,primary,context,assert,invariant,assert,primary,mode,false,final,runnable,run,after,get,master,update,operation,from,current,state,primary,mode,true,applied,cluster,state,version,primary,context,cluster,state,version,checkpoints,clear,for,map,entry,string,checkpoint,state,entry,primary,context,checkpoints,entry,set,checkpoints,put,entry,get,key,entry,get,value,copy,routing,table,primary,context,get,routing,table,replication,group,calculate,replication,group,update,global,checkpoint,on,primary,run,after,run,assert,invariant
ReplicationTracker -> public synchronized void activateWithPrimaryContext(PrimaryContext primaryContext);1548944389;Activates the global checkpoint tracker in primary mode (see {@link #primaryMode}. Called on primary relocation target during_primary relocation handoff.__@param primaryContext the primary context used to initialize the state;public synchronized void activateWithPrimaryContext(PrimaryContext primaryContext) {_        assert invariant()__        assert primaryMode == false__        final Runnable runAfter = getMasterUpdateOperationFromCurrentState()__        primaryMode = true__        _        appliedClusterStateVersion = primaryContext.clusterStateVersion()__        checkpoints.clear()__        for (Map.Entry<String, CheckpointState> entry : primaryContext.checkpoints.entrySet()) {_            checkpoints.put(entry.getKey(), entry.getValue().copy())__        }_        routingTable = primaryContext.getRoutingTable()__        replicationGroup = calculateReplicationGroup()__        updateGlobalCheckpointOnPrimary()__        _        _        _        runAfter.run()__        assert invariant()__    };activates,the,global,checkpoint,tracker,in,primary,mode,see,link,primary,mode,called,on,primary,relocation,target,during,primary,relocation,handoff,param,primary,context,the,primary,context,used,to,initialize,the,state;public,synchronized,void,activate,with,primary,context,primary,context,primary,context,assert,invariant,assert,primary,mode,false,final,runnable,run,after,get,master,update,operation,from,current,state,primary,mode,true,applied,cluster,state,version,primary,context,cluster,state,version,checkpoints,clear,for,map,entry,string,checkpoint,state,entry,primary,context,checkpoints,entry,set,checkpoints,put,entry,get,key,entry,get,value,copy,routing,table,primary,context,get,routing,table,replication,group,calculate,replication,group,update,global,checkpoint,on,primary,run,after,run,assert,invariant
ReplicationTracker -> public synchronized void activateWithPrimaryContext(PrimaryContext primaryContext);1549059559;Activates the global checkpoint tracker in primary mode (see {@link #primaryMode}. Called on primary relocation target during_primary relocation handoff.__@param primaryContext the primary context used to initialize the state;public synchronized void activateWithPrimaryContext(PrimaryContext primaryContext) {_        assert invariant()__        assert primaryMode == false__        final Runnable runAfter = getMasterUpdateOperationFromCurrentState()__        primaryMode = true__        _        appliedClusterStateVersion = primaryContext.clusterStateVersion()__        checkpoints.clear()__        for (Map.Entry<String, CheckpointState> entry : primaryContext.checkpoints.entrySet()) {_            checkpoints.put(entry.getKey(), entry.getValue().copy())__        }_        routingTable = primaryContext.getRoutingTable()__        replicationGroup = calculateReplicationGroup()__        updateGlobalCheckpointOnPrimary()__        _        _        _        runAfter.run()__        assert invariant()__    };activates,the,global,checkpoint,tracker,in,primary,mode,see,link,primary,mode,called,on,primary,relocation,target,during,primary,relocation,handoff,param,primary,context,the,primary,context,used,to,initialize,the,state;public,synchronized,void,activate,with,primary,context,primary,context,primary,context,assert,invariant,assert,primary,mode,false,final,runnable,run,after,get,master,update,operation,from,current,state,primary,mode,true,applied,cluster,state,version,primary,context,cluster,state,version,checkpoints,clear,for,map,entry,string,checkpoint,state,entry,primary,context,checkpoints,entry,set,checkpoints,put,entry,get,key,entry,get,value,copy,routing,table,primary,context,get,routing,table,replication,group,calculate,replication,group,update,global,checkpoint,on,primary,run,after,run,assert,invariant
ReplicationTracker -> public synchronized void activateWithPrimaryContext(PrimaryContext primaryContext);1549294529;Activates the global checkpoint tracker in primary mode (see {@link #primaryMode}. Called on primary relocation target during_primary relocation handoff.__@param primaryContext the primary context used to initialize the state;public synchronized void activateWithPrimaryContext(PrimaryContext primaryContext) {_        assert invariant()__        assert primaryMode == false__        final Runnable runAfter = getMasterUpdateOperationFromCurrentState()__        primaryMode = true__        _        appliedClusterStateVersion = primaryContext.clusterStateVersion()__        checkpoints.clear()__        for (Map.Entry<String, CheckpointState> entry : primaryContext.checkpoints.entrySet()) {_            checkpoints.put(entry.getKey(), entry.getValue().copy())__        }_        routingTable = primaryContext.getRoutingTable()__        replicationGroup = calculateReplicationGroup()__        updateGlobalCheckpointOnPrimary()__        _        _        _        runAfter.run()__        assert invariant()__    };activates,the,global,checkpoint,tracker,in,primary,mode,see,link,primary,mode,called,on,primary,relocation,target,during,primary,relocation,handoff,param,primary,context,the,primary,context,used,to,initialize,the,state;public,synchronized,void,activate,with,primary,context,primary,context,primary,context,assert,invariant,assert,primary,mode,false,final,runnable,run,after,get,master,update,operation,from,current,state,primary,mode,true,applied,cluster,state,version,primary,context,cluster,state,version,checkpoints,clear,for,map,entry,string,checkpoint,state,entry,primary,context,checkpoints,entry,set,checkpoints,put,entry,get,key,entry,get,value,copy,routing,table,primary,context,get,routing,table,replication,group,calculate,replication,group,update,global,checkpoint,on,primary,run,after,run,assert,invariant
ReplicationTracker -> public synchronized void activateWithPrimaryContext(PrimaryContext primaryContext);1549395737;Activates the global checkpoint tracker in primary mode (see {@link #primaryMode}. Called on primary relocation target during_primary relocation handoff.__@param primaryContext the primary context used to initialize the state;public synchronized void activateWithPrimaryContext(PrimaryContext primaryContext) {_        assert invariant()__        assert primaryMode == false__        final Runnable runAfter = getMasterUpdateOperationFromCurrentState()__        primaryMode = true__        _        appliedClusterStateVersion = primaryContext.clusterStateVersion()__        checkpoints.clear()__        for (Map.Entry<String, CheckpointState> entry : primaryContext.checkpoints.entrySet()) {_            checkpoints.put(entry.getKey(), entry.getValue().copy())__        }_        routingTable = primaryContext.getRoutingTable()__        replicationGroup = calculateReplicationGroup()__        updateGlobalCheckpointOnPrimary()__        _        _        _        runAfter.run()__        assert invariant()__    };activates,the,global,checkpoint,tracker,in,primary,mode,see,link,primary,mode,called,on,primary,relocation,target,during,primary,relocation,handoff,param,primary,context,the,primary,context,used,to,initialize,the,state;public,synchronized,void,activate,with,primary,context,primary,context,primary,context,assert,invariant,assert,primary,mode,false,final,runnable,run,after,get,master,update,operation,from,current,state,primary,mode,true,applied,cluster,state,version,primary,context,cluster,state,version,checkpoints,clear,for,map,entry,string,checkpoint,state,entry,primary,context,checkpoints,entry,set,checkpoints,put,entry,get,key,entry,get,value,copy,routing,table,primary,context,get,routing,table,replication,group,calculate,replication,group,update,global,checkpoint,on,primary,run,after,run,assert,invariant
ReplicationTracker -> public synchronized void activateWithPrimaryContext(PrimaryContext primaryContext);1549937843;Activates the global checkpoint tracker in primary mode (see {@link #primaryMode}. Called on primary relocation target during_primary relocation handoff.__@param primaryContext the primary context used to initialize the state;public synchronized void activateWithPrimaryContext(PrimaryContext primaryContext) {_        assert invariant()__        assert primaryMode == false__        final Runnable runAfter = getMasterUpdateOperationFromCurrentState()__        primaryMode = true__        _        appliedClusterStateVersion = primaryContext.clusterStateVersion()__        checkpoints.clear()__        for (Map.Entry<String, CheckpointState> entry : primaryContext.checkpoints.entrySet()) {_            checkpoints.put(entry.getKey(), entry.getValue().copy())__        }_        routingTable = primaryContext.getRoutingTable()__        replicationGroup = calculateReplicationGroup()__        updateGlobalCheckpointOnPrimary()__        _        _        _        runAfter.run()__        assert invariant()__    };activates,the,global,checkpoint,tracker,in,primary,mode,see,link,primary,mode,called,on,primary,relocation,target,during,primary,relocation,handoff,param,primary,context,the,primary,context,used,to,initialize,the,state;public,synchronized,void,activate,with,primary,context,primary,context,primary,context,assert,invariant,assert,primary,mode,false,final,runnable,run,after,get,master,update,operation,from,current,state,primary,mode,true,applied,cluster,state,version,primary,context,cluster,state,version,checkpoints,clear,for,map,entry,string,checkpoint,state,entry,primary,context,checkpoints,entry,set,checkpoints,put,entry,get,key,entry,get,value,copy,routing,table,primary,context,get,routing,table,replication,group,calculate,replication,group,update,global,checkpoint,on,primary,run,after,run,assert,invariant
ReplicationTracker -> public synchronized void activateWithPrimaryContext(PrimaryContext primaryContext);1549949489;Activates the global checkpoint tracker in primary mode (see {@link #primaryMode}. Called on primary relocation target during_primary relocation handoff.__@param primaryContext the primary context used to initialize the state;public synchronized void activateWithPrimaryContext(PrimaryContext primaryContext) {_        assert invariant()__        assert primaryMode == false__        final Runnable runAfter = getMasterUpdateOperationFromCurrentState()__        primaryMode = true__        _        appliedClusterStateVersion = primaryContext.clusterStateVersion()__        checkpoints.clear()__        for (Map.Entry<String, CheckpointState> entry : primaryContext.checkpoints.entrySet()) {_            checkpoints.put(entry.getKey(), entry.getValue().copy())__        }_        routingTable = primaryContext.getRoutingTable()__        replicationGroup = calculateReplicationGroup()__        updateGlobalCheckpointOnPrimary()__        _        _        _        runAfter.run()__        assert invariant()__    };activates,the,global,checkpoint,tracker,in,primary,mode,see,link,primary,mode,called,on,primary,relocation,target,during,primary,relocation,handoff,param,primary,context,the,primary,context,used,to,initialize,the,state;public,synchronized,void,activate,with,primary,context,primary,context,primary,context,assert,invariant,assert,primary,mode,false,final,runnable,run,after,get,master,update,operation,from,current,state,primary,mode,true,applied,cluster,state,version,primary,context,cluster,state,version,checkpoints,clear,for,map,entry,string,checkpoint,state,entry,primary,context,checkpoints,entry,set,checkpoints,put,entry,get,key,entry,get,value,copy,routing,table,primary,context,get,routing,table,replication,group,calculate,replication,group,update,global,checkpoint,on,primary,run,after,run,assert,invariant
ReplicationTracker -> public synchronized void activateWithPrimaryContext(PrimaryContext primaryContext);1550526771;Activates the global checkpoint tracker in primary mode (see {@link #primaryMode}. Called on primary relocation target during_primary relocation handoff.__@param primaryContext the primary context used to initialize the state;public synchronized void activateWithPrimaryContext(PrimaryContext primaryContext) {_        assert invariant()__        assert primaryMode == false__        final Runnable runAfter = getMasterUpdateOperationFromCurrentState()__        primaryMode = true__        _        appliedClusterStateVersion = primaryContext.clusterStateVersion()__        checkpoints.clear()__        for (Map.Entry<String, CheckpointState> entry : primaryContext.checkpoints.entrySet()) {_            checkpoints.put(entry.getKey(), entry.getValue().copy())__        }_        routingTable = primaryContext.getRoutingTable()__        replicationGroup = calculateReplicationGroup()__        updateGlobalCheckpointOnPrimary()__        _        _        _        runAfter.run()__        assert invariant()__    };activates,the,global,checkpoint,tracker,in,primary,mode,see,link,primary,mode,called,on,primary,relocation,target,during,primary,relocation,handoff,param,primary,context,the,primary,context,used,to,initialize,the,state;public,synchronized,void,activate,with,primary,context,primary,context,primary,context,assert,invariant,assert,primary,mode,false,final,runnable,run,after,get,master,update,operation,from,current,state,primary,mode,true,applied,cluster,state,version,primary,context,cluster,state,version,checkpoints,clear,for,map,entry,string,checkpoint,state,entry,primary,context,checkpoints,entry,set,checkpoints,put,entry,get,key,entry,get,value,copy,routing,table,primary,context,get,routing,table,replication,group,calculate,replication,group,update,global,checkpoint,on,primary,run,after,run,assert,invariant
ReplicationTracker -> public synchronized void updateRetentionLeasesOnReplica(final Collection<RetentionLease> retentionLeases);1547332999;Updates retention leases on a replica.__@param retentionLeases the retention leases;public synchronized void updateRetentionLeasesOnReplica(final Collection<RetentionLease> retentionLeases) {_        assert primaryMode == false__        this.retentionLeases.clear()__        this.retentionLeases.putAll(retentionLeases.stream().collect(Collectors.toMap(RetentionLease::id, Function.identity())))__    };updates,retention,leases,on,a,replica,param,retention,leases,the,retention,leases;public,synchronized,void,update,retention,leases,on,replica,final,collection,retention,lease,retention,leases,assert,primary,mode,false,this,retention,leases,clear,this,retention,leases,put,all,retention,leases,stream,collect,collectors,to,map,retention,lease,id,function,identity
ReplicationTracker -> public synchronized void updateRetentionLeasesOnReplica(final Collection<RetentionLease> retentionLeases);1548593396;Updates retention leases on a replica.__@param retentionLeases the retention leases;public synchronized void updateRetentionLeasesOnReplica(final Collection<RetentionLease> retentionLeases) {_        assert primaryMode == false__        this.retentionLeases.clear()__        this.retentionLeases.putAll(retentionLeases.stream().collect(Collectors.toMap(RetentionLease::id, Function.identity())))__    };updates,retention,leases,on,a,replica,param,retention,leases,the,retention,leases;public,synchronized,void,update,retention,leases,on,replica,final,collection,retention,lease,retention,leases,assert,primary,mode,false,this,retention,leases,clear,this,retention,leases,put,all,retention,leases,stream,collect,collectors,to,map,retention,lease,id,function,identity
ReplicationTracker -> public synchronized void updateRetentionLeasesOnReplica(final Collection<RetentionLease> retentionLeases);1548594827;Updates retention leases on a replica.__@param retentionLeases the retention leases;public synchronized void updateRetentionLeasesOnReplica(final Collection<RetentionLease> retentionLeases) {_        assert primaryMode == false__        this.retentionLeases.clear()__        this.retentionLeases.putAll(retentionLeases.stream().collect(Collectors.toMap(RetentionLease::id, Function.identity())))__    };updates,retention,leases,on,a,replica,param,retention,leases,the,retention,leases;public,synchronized,void,update,retention,leases,on,replica,final,collection,retention,lease,retention,leases,assert,primary,mode,false,this,retention,leases,clear,this,retention,leases,put,all,retention,leases,stream,collect,collectors,to,map,retention,lease,id,function,identity
ReplicationTracker -> public synchronized void updateRetentionLeasesOnReplica(final Collection<RetentionLease> retentionLeases);1548677511;Updates retention leases on a replica.__@param retentionLeases the retention leases;public synchronized void updateRetentionLeasesOnReplica(final Collection<RetentionLease> retentionLeases) {_        assert primaryMode == false__        this.retentionLeases.clear()__        this.retentionLeases.putAll(retentionLeases.stream().collect(Collectors.toMap(RetentionLease::id, Function.identity())))__    };updates,retention,leases,on,a,replica,param,retention,leases,the,retention,leases;public,synchronized,void,update,retention,leases,on,replica,final,collection,retention,lease,retention,leases,assert,primary,mode,false,this,retention,leases,clear,this,retention,leases,put,all,retention,leases,stream,collect,collectors,to,map,retention,lease,id,function,identity
ReplicationTracker -> public synchronized void updateRetentionLeasesOnReplica(final Collection<RetentionLease> retentionLeases);1548944389;Updates retention leases on a replica.__@param retentionLeases the retention leases;public synchronized void updateRetentionLeasesOnReplica(final Collection<RetentionLease> retentionLeases) {_        assert primaryMode == false__        this.retentionLeases.clear()__        this.retentionLeases.putAll(retentionLeases.stream().collect(Collectors.toMap(RetentionLease::id, Function.identity())))__    };updates,retention,leases,on,a,replica,param,retention,leases,the,retention,leases;public,synchronized,void,update,retention,leases,on,replica,final,collection,retention,lease,retention,leases,assert,primary,mode,false,this,retention,leases,clear,this,retention,leases,put,all,retention,leases,stream,collect,collectors,to,map,retention,lease,id,function,identity
ReplicationTracker -> public ReplicationTracker(             final ShardId shardId,             final String allocationId,             final IndexSettings indexSettings,             final long globalCheckpoint,             final LongConsumer onGlobalCheckpointUpdated,             final LongSupplier currentTimeMillisSupplier);1546927432;Initialize the global checkpoint service. The specified global checkpoint should be set to the last known global checkpoint, or_{@link SequenceNumbers#UNASSIGNED_SEQ_NO}.__@param shardId          the shard ID_@param allocationId     the allocation ID_@param indexSettings    the index settings_@param globalCheckpoint the last known global checkpoint for this shard, or {@link SequenceNumbers#UNASSIGNED_SEQ_NO};public ReplicationTracker(_            final ShardId shardId,_            final String allocationId,_            final IndexSettings indexSettings,_            final long globalCheckpoint,_            final LongConsumer onGlobalCheckpointUpdated,_            final LongSupplier currentTimeMillisSupplier) {_        super(shardId, indexSettings)__        assert globalCheckpoint >= SequenceNumbers.UNASSIGNED_SEQ_NO : "illegal initial global checkpoint: " + globalCheckpoint__        this.shardAllocationId = allocationId__        this.primaryMode = false__        this.handoffInProgress = false__        this.appliedClusterStateVersion = -1L__        this.checkpoints = new HashMap<>(1 + indexSettings.getNumberOfReplicas())__        checkpoints.put(allocationId, new CheckpointState(SequenceNumbers.UNASSIGNED_SEQ_NO, globalCheckpoint, false, false))__        this.onGlobalCheckpointUpdated = Objects.requireNonNull(onGlobalCheckpointUpdated)__        this.currentTimeMillisSupplier = Objects.requireNonNull(currentTimeMillisSupplier)__        this.pendingInSync = new HashSet<>()__        this.routingTable = null__        this.replicationGroup = null__        assert invariant()__    };initialize,the,global,checkpoint,service,the,specified,global,checkpoint,should,be,set,to,the,last,known,global,checkpoint,or,link,sequence,numbers,param,shard,id,the,shard,id,param,allocation,id,the,allocation,id,param,index,settings,the,index,settings,param,global,checkpoint,the,last,known,global,checkpoint,for,this,shard,or,link,sequence,numbers;public,replication,tracker,final,shard,id,shard,id,final,string,allocation,id,final,index,settings,index,settings,final,long,global,checkpoint,final,long,consumer,on,global,checkpoint,updated,final,long,supplier,current,time,millis,supplier,super,shard,id,index,settings,assert,global,checkpoint,sequence,numbers,illegal,initial,global,checkpoint,global,checkpoint,this,shard,allocation,id,allocation,id,this,primary,mode,false,this,handoff,in,progress,false,this,applied,cluster,state,version,1l,this,checkpoints,new,hash,map,1,index,settings,get,number,of,replicas,checkpoints,put,allocation,id,new,checkpoint,state,sequence,numbers,global,checkpoint,false,false,this,on,global,checkpoint,updated,objects,require,non,null,on,global,checkpoint,updated,this,current,time,millis,supplier,objects,require,non,null,current,time,millis,supplier,this,pending,in,sync,new,hash,set,this,routing,table,null,this,replication,group,null,assert,invariant
ReplicationTracker -> public ReplicationTracker(             final ShardId shardId,             final String allocationId,             final IndexSettings indexSettings,             final long globalCheckpoint,             final LongConsumer onGlobalCheckpointUpdated,             final LongSupplier currentTimeMillisSupplier);1547332999;Initialize the global checkpoint service. The specified global checkpoint should be set to the last known global checkpoint, or_{@link SequenceNumbers#UNASSIGNED_SEQ_NO}.__@param shardId          the shard ID_@param allocationId     the allocation ID_@param indexSettings    the index settings_@param globalCheckpoint the last known global checkpoint for this shard, or {@link SequenceNumbers#UNASSIGNED_SEQ_NO};public ReplicationTracker(_            final ShardId shardId,_            final String allocationId,_            final IndexSettings indexSettings,_            final long globalCheckpoint,_            final LongConsumer onGlobalCheckpointUpdated,_            final LongSupplier currentTimeMillisSupplier) {_        super(shardId, indexSettings)__        assert globalCheckpoint >= SequenceNumbers.UNASSIGNED_SEQ_NO : "illegal initial global checkpoint: " + globalCheckpoint__        this.shardAllocationId = allocationId__        this.primaryMode = false__        this.handoffInProgress = false__        this.appliedClusterStateVersion = -1L__        this.checkpoints = new HashMap<>(1 + indexSettings.getNumberOfReplicas())__        checkpoints.put(allocationId, new CheckpointState(SequenceNumbers.UNASSIGNED_SEQ_NO, globalCheckpoint, false, false))__        this.onGlobalCheckpointUpdated = Objects.requireNonNull(onGlobalCheckpointUpdated)__        this.currentTimeMillisSupplier = Objects.requireNonNull(currentTimeMillisSupplier)__        this.pendingInSync = new HashSet<>()__        this.routingTable = null__        this.replicationGroup = null__        assert invariant()__    };initialize,the,global,checkpoint,service,the,specified,global,checkpoint,should,be,set,to,the,last,known,global,checkpoint,or,link,sequence,numbers,param,shard,id,the,shard,id,param,allocation,id,the,allocation,id,param,index,settings,the,index,settings,param,global,checkpoint,the,last,known,global,checkpoint,for,this,shard,or,link,sequence,numbers;public,replication,tracker,final,shard,id,shard,id,final,string,allocation,id,final,index,settings,index,settings,final,long,global,checkpoint,final,long,consumer,on,global,checkpoint,updated,final,long,supplier,current,time,millis,supplier,super,shard,id,index,settings,assert,global,checkpoint,sequence,numbers,illegal,initial,global,checkpoint,global,checkpoint,this,shard,allocation,id,allocation,id,this,primary,mode,false,this,handoff,in,progress,false,this,applied,cluster,state,version,1l,this,checkpoints,new,hash,map,1,index,settings,get,number,of,replicas,checkpoints,put,allocation,id,new,checkpoint,state,sequence,numbers,global,checkpoint,false,false,this,on,global,checkpoint,updated,objects,require,non,null,on,global,checkpoint,updated,this,current,time,millis,supplier,objects,require,non,null,current,time,millis,supplier,this,pending,in,sync,new,hash,set,this,routing,table,null,this,replication,group,null,assert,invariant
ReplicationTracker -> public RetentionLease addRetentionLease(             final String id,             final long retainingSequenceNumber,             final String source,             final ActionListener<ReplicationResponse> listener);1548593396;Adds a new retention lease.__@param id                      the identifier of the retention lease_@param retainingSequenceNumber the retaining sequence number_@param source                  the source of the retention lease_@param listener                the callback when the retention lease is successfully added and synced to replicas_@return the new retention lease_@throws IllegalArgumentException if the specified retention lease already exists;public RetentionLease addRetentionLease(_            final String id,_            final long retainingSequenceNumber,_            final String source,_            final ActionListener<ReplicationResponse> listener) {_        Objects.requireNonNull(listener)__        final RetentionLease retentionLease__        final Collection<RetentionLease> currentRetentionLeases__        synchronized (this) {_            assert primaryMode__            if (retentionLeases.containsKey(id)) {_                throw new IllegalArgumentException("retention lease with ID [" + id + "] already exists")__            }_            retentionLease = new RetentionLease(id, retainingSequenceNumber, currentTimeMillisSupplier.getAsLong(), source)__            retentionLeases.put(id, retentionLease)__            currentRetentionLeases = retentionLeases.values()__        }_        onNewRetentionLease.accept(Collections.unmodifiableCollection(new ArrayList<>(currentRetentionLeases)), listener)__        return retentionLease__    };adds,a,new,retention,lease,param,id,the,identifier,of,the,retention,lease,param,retaining,sequence,number,the,retaining,sequence,number,param,source,the,source,of,the,retention,lease,param,listener,the,callback,when,the,retention,lease,is,successfully,added,and,synced,to,replicas,return,the,new,retention,lease,throws,illegal,argument,exception,if,the,specified,retention,lease,already,exists;public,retention,lease,add,retention,lease,final,string,id,final,long,retaining,sequence,number,final,string,source,final,action,listener,replication,response,listener,objects,require,non,null,listener,final,retention,lease,retention,lease,final,collection,retention,lease,current,retention,leases,synchronized,this,assert,primary,mode,if,retention,leases,contains,key,id,throw,new,illegal,argument,exception,retention,lease,with,id,id,already,exists,retention,lease,new,retention,lease,id,retaining,sequence,number,current,time,millis,supplier,get,as,long,source,retention,leases,put,id,retention,lease,current,retention,leases,retention,leases,values,on,new,retention,lease,accept,collections,unmodifiable,collection,new,array,list,current,retention,leases,listener,return,retention,lease
ReplicationTracker -> public RetentionLease addRetentionLease(             final String id,             final long retainingSequenceNumber,             final String source,             final ActionListener<ReplicationResponse> listener);1548594827;Adds a new retention lease.__@param id                      the identifier of the retention lease_@param retainingSequenceNumber the retaining sequence number_@param source                  the source of the retention lease_@param listener                the callback when the retention lease is successfully added and synced to replicas_@return the new retention lease_@throws IllegalArgumentException if the specified retention lease already exists;public RetentionLease addRetentionLease(_            final String id,_            final long retainingSequenceNumber,_            final String source,_            final ActionListener<ReplicationResponse> listener) {_        Objects.requireNonNull(listener)__        final RetentionLease retentionLease__        final Collection<RetentionLease> currentRetentionLeases__        synchronized (this) {_            assert primaryMode__            if (retentionLeases.containsKey(id)) {_                throw new IllegalArgumentException("retention lease with ID [" + id + "] already exists")__            }_            retentionLease = new RetentionLease(id, retainingSequenceNumber, currentTimeMillisSupplier.getAsLong(), source)__            retentionLeases.put(id, retentionLease)__            currentRetentionLeases = copyRetentionLeases()__        }_        onNewRetentionLease.accept(currentRetentionLeases, listener)__        return retentionLease__    };adds,a,new,retention,lease,param,id,the,identifier,of,the,retention,lease,param,retaining,sequence,number,the,retaining,sequence,number,param,source,the,source,of,the,retention,lease,param,listener,the,callback,when,the,retention,lease,is,successfully,added,and,synced,to,replicas,return,the,new,retention,lease,throws,illegal,argument,exception,if,the,specified,retention,lease,already,exists;public,retention,lease,add,retention,lease,final,string,id,final,long,retaining,sequence,number,final,string,source,final,action,listener,replication,response,listener,objects,require,non,null,listener,final,retention,lease,retention,lease,final,collection,retention,lease,current,retention,leases,synchronized,this,assert,primary,mode,if,retention,leases,contains,key,id,throw,new,illegal,argument,exception,retention,lease,with,id,id,already,exists,retention,lease,new,retention,lease,id,retaining,sequence,number,current,time,millis,supplier,get,as,long,source,retention,leases,put,id,retention,lease,current,retention,leases,copy,retention,leases,on,new,retention,lease,accept,current,retention,leases,listener,return,retention,lease
ReplicationTracker -> public RetentionLease addRetentionLease(             final String id,             final long retainingSequenceNumber,             final String source,             final ActionListener<ReplicationResponse> listener);1548677511;Adds a new retention lease.__@param id                      the identifier of the retention lease_@param retainingSequenceNumber the retaining sequence number_@param source                  the source of the retention lease_@param listener                the callback when the retention lease is successfully added and synced to replicas_@return the new retention lease_@throws IllegalArgumentException if the specified retention lease already exists;public RetentionLease addRetentionLease(_            final String id,_            final long retainingSequenceNumber,_            final String source,_            final ActionListener<ReplicationResponse> listener) {_        Objects.requireNonNull(listener)__        final RetentionLease retentionLease__        final Collection<RetentionLease> currentRetentionLeases__        synchronized (this) {_            assert primaryMode__            if (retentionLeases.containsKey(id)) {_                throw new IllegalArgumentException("retention lease with ID [" + id + "] already exists")__            }_            retentionLease = new RetentionLease(id, retainingSequenceNumber, currentTimeMillisSupplier.getAsLong(), source)__            retentionLeases.put(id, retentionLease)__            currentRetentionLeases = copyRetentionLeases()__        }_        onSyncRetentionLeases.accept(currentRetentionLeases, listener)__        return retentionLease__    };adds,a,new,retention,lease,param,id,the,identifier,of,the,retention,lease,param,retaining,sequence,number,the,retaining,sequence,number,param,source,the,source,of,the,retention,lease,param,listener,the,callback,when,the,retention,lease,is,successfully,added,and,synced,to,replicas,return,the,new,retention,lease,throws,illegal,argument,exception,if,the,specified,retention,lease,already,exists;public,retention,lease,add,retention,lease,final,string,id,final,long,retaining,sequence,number,final,string,source,final,action,listener,replication,response,listener,objects,require,non,null,listener,final,retention,lease,retention,lease,final,collection,retention,lease,current,retention,leases,synchronized,this,assert,primary,mode,if,retention,leases,contains,key,id,throw,new,illegal,argument,exception,retention,lease,with,id,id,already,exists,retention,lease,new,retention,lease,id,retaining,sequence,number,current,time,millis,supplier,get,as,long,source,retention,leases,put,id,retention,lease,current,retention,leases,copy,retention,leases,on,sync,retention,leases,accept,current,retention,leases,listener,return,retention,lease
ReplicationTracker -> public RetentionLease addRetentionLease(             final String id,             final long retainingSequenceNumber,             final String source,             final ActionListener<ReplicationResponse> listener);1548944389;Adds a new retention lease.__@param id                      the identifier of the retention lease_@param retainingSequenceNumber the retaining sequence number_@param source                  the source of the retention lease_@param listener                the callback when the retention lease is successfully added and synced to replicas_@return the new retention lease_@throws IllegalArgumentException if the specified retention lease already exists;public RetentionLease addRetentionLease(_            final String id,_            final long retainingSequenceNumber,_            final String source,_            final ActionListener<ReplicationResponse> listener) {_        Objects.requireNonNull(listener)__        final RetentionLease retentionLease__        final Collection<RetentionLease> currentRetentionLeases__        synchronized (this) {_            assert primaryMode__            if (retentionLeases.containsKey(id)) {_                throw new IllegalArgumentException("retention lease with ID [" + id + "] already exists")__            }_            retentionLease = new RetentionLease(id, retainingSequenceNumber, currentTimeMillisSupplier.getAsLong(), source)__            retentionLeases.put(id, retentionLease)__            currentRetentionLeases = copyRetentionLeases()__        }_        onSyncRetentionLeases.accept(currentRetentionLeases, listener)__        return retentionLease__    };adds,a,new,retention,lease,param,id,the,identifier,of,the,retention,lease,param,retaining,sequence,number,the,retaining,sequence,number,param,source,the,source,of,the,retention,lease,param,listener,the,callback,when,the,retention,lease,is,successfully,added,and,synced,to,replicas,return,the,new,retention,lease,throws,illegal,argument,exception,if,the,specified,retention,lease,already,exists;public,retention,lease,add,retention,lease,final,string,id,final,long,retaining,sequence,number,final,string,source,final,action,listener,replication,response,listener,objects,require,non,null,listener,final,retention,lease,retention,lease,final,collection,retention,lease,current,retention,leases,synchronized,this,assert,primary,mode,if,retention,leases,contains,key,id,throw,new,illegal,argument,exception,retention,lease,with,id,id,already,exists,retention,lease,new,retention,lease,id,retaining,sequence,number,current,time,millis,supplier,get,as,long,source,retention,leases,put,id,retention,lease,current,retention,leases,copy,retention,leases,on,sync,retention,leases,accept,current,retention,leases,listener,return,retention,lease
ReplicationTracker -> public RetentionLease addRetentionLease(             final String id,             final long retainingSequenceNumber,             final String source,             final ActionListener<ReplicationResponse> listener);1549059559;Adds a new retention lease.__@param id                      the identifier of the retention lease_@param retainingSequenceNumber the retaining sequence number_@param source                  the source of the retention lease_@param listener                the callback when the retention lease is successfully added and synced to replicas_@return the new retention lease_@throws IllegalArgumentException if the specified retention lease already exists;public RetentionLease addRetentionLease(_            final String id,_            final long retainingSequenceNumber,_            final String source,_            final ActionListener<ReplicationResponse> listener) {_        Objects.requireNonNull(listener)__        final RetentionLease retentionLease__        final RetentionLeases currentRetentionLeases__        synchronized (this) {_            assert primaryMode__            if (retentionLeases.contains(id)) {_                throw new IllegalArgumentException("retention lease with ID [" + id + "] already exists")__            }_            retentionLease = new RetentionLease(id, retainingSequenceNumber, currentTimeMillisSupplier.getAsLong(), source)__            retentionLeases = new RetentionLeases(_                    operationPrimaryTerm,_                    retentionLeases.version() + 1,_                    Stream.concat(retentionLeases.leases().stream(), Stream.of(retentionLease)).collect(Collectors.toList()))__            currentRetentionLeases = retentionLeases__        }_        onSyncRetentionLeases.accept(currentRetentionLeases, listener)__        return retentionLease__    };adds,a,new,retention,lease,param,id,the,identifier,of,the,retention,lease,param,retaining,sequence,number,the,retaining,sequence,number,param,source,the,source,of,the,retention,lease,param,listener,the,callback,when,the,retention,lease,is,successfully,added,and,synced,to,replicas,return,the,new,retention,lease,throws,illegal,argument,exception,if,the,specified,retention,lease,already,exists;public,retention,lease,add,retention,lease,final,string,id,final,long,retaining,sequence,number,final,string,source,final,action,listener,replication,response,listener,objects,require,non,null,listener,final,retention,lease,retention,lease,final,retention,leases,current,retention,leases,synchronized,this,assert,primary,mode,if,retention,leases,contains,id,throw,new,illegal,argument,exception,retention,lease,with,id,id,already,exists,retention,lease,new,retention,lease,id,retaining,sequence,number,current,time,millis,supplier,get,as,long,source,retention,leases,new,retention,leases,operation,primary,term,retention,leases,version,1,stream,concat,retention,leases,leases,stream,stream,of,retention,lease,collect,collectors,to,list,current,retention,leases,retention,leases,on,sync,retention,leases,accept,current,retention,leases,listener,return,retention,lease
ReplicationTracker -> public RetentionLease addRetentionLease(             final String id,             final long retainingSequenceNumber,             final String source,             final ActionListener<ReplicationResponse> listener);1549294529;Adds a new retention lease.__@param id                      the identifier of the retention lease_@param retainingSequenceNumber the retaining sequence number_@param source                  the source of the retention lease_@param listener                the callback when the retention lease is successfully added and synced to replicas_@return the new retention lease_@throws IllegalArgumentException if the specified retention lease already exists;public RetentionLease addRetentionLease(_            final String id,_            final long retainingSequenceNumber,_            final String source,_            final ActionListener<ReplicationResponse> listener) {_        Objects.requireNonNull(listener)__        final RetentionLease retentionLease__        final RetentionLeases currentRetentionLeases__        synchronized (this) {_            assert primaryMode__            if (retentionLeases.contains(id)) {_                throw new IllegalArgumentException("retention lease with ID [" + id + "] already exists")__            }_            retentionLease = new RetentionLease(id, retainingSequenceNumber, currentTimeMillisSupplier.getAsLong(), source)__            retentionLeases = new RetentionLeases(_                    operationPrimaryTerm,_                    retentionLeases.version() + 1,_                    Stream.concat(retentionLeases.leases().stream(), Stream.of(retentionLease)).collect(Collectors.toList()))__            currentRetentionLeases = retentionLeases__        }_        onSyncRetentionLeases.accept(currentRetentionLeases, listener)__        return retentionLease__    };adds,a,new,retention,lease,param,id,the,identifier,of,the,retention,lease,param,retaining,sequence,number,the,retaining,sequence,number,param,source,the,source,of,the,retention,lease,param,listener,the,callback,when,the,retention,lease,is,successfully,added,and,synced,to,replicas,return,the,new,retention,lease,throws,illegal,argument,exception,if,the,specified,retention,lease,already,exists;public,retention,lease,add,retention,lease,final,string,id,final,long,retaining,sequence,number,final,string,source,final,action,listener,replication,response,listener,objects,require,non,null,listener,final,retention,lease,retention,lease,final,retention,leases,current,retention,leases,synchronized,this,assert,primary,mode,if,retention,leases,contains,id,throw,new,illegal,argument,exception,retention,lease,with,id,id,already,exists,retention,lease,new,retention,lease,id,retaining,sequence,number,current,time,millis,supplier,get,as,long,source,retention,leases,new,retention,leases,operation,primary,term,retention,leases,version,1,stream,concat,retention,leases,leases,stream,stream,of,retention,lease,collect,collectors,to,list,current,retention,leases,retention,leases,on,sync,retention,leases,accept,current,retention,leases,listener,return,retention,lease
ReplicationTracker -> public RetentionLease addRetentionLease(             final String id,             final long retainingSequenceNumber,             final String source,             final ActionListener<ReplicationResponse> listener);1549395737;Adds a new retention lease.__@param id                      the identifier of the retention lease_@param retainingSequenceNumber the retaining sequence number_@param source                  the source of the retention lease_@param listener                the callback when the retention lease is successfully added and synced to replicas_@return the new retention lease_@throws IllegalArgumentException if the specified retention lease already exists;public RetentionLease addRetentionLease(_            final String id,_            final long retainingSequenceNumber,_            final String source,_            final ActionListener<ReplicationResponse> listener) {_        Objects.requireNonNull(listener)__        final RetentionLease retentionLease__        final RetentionLeases currentRetentionLeases__        synchronized (this) {_            assert primaryMode__            if (retentionLeases.contains(id)) {_                throw new IllegalArgumentException("retention lease with ID [" + id + "] already exists")__            }_            retentionLease = new RetentionLease(id, retainingSequenceNumber, currentTimeMillisSupplier.getAsLong(), source)__            retentionLeases = new RetentionLeases(_                    operationPrimaryTerm,_                    retentionLeases.version() + 1,_                    Stream.concat(retentionLeases.leases().stream(), Stream.of(retentionLease)).collect(Collectors.toList()))__            currentRetentionLeases = retentionLeases__        }_        onAddRetentionLease.accept(currentRetentionLeases, listener)__        return retentionLease__    };adds,a,new,retention,lease,param,id,the,identifier,of,the,retention,lease,param,retaining,sequence,number,the,retaining,sequence,number,param,source,the,source,of,the,retention,lease,param,listener,the,callback,when,the,retention,lease,is,successfully,added,and,synced,to,replicas,return,the,new,retention,lease,throws,illegal,argument,exception,if,the,specified,retention,lease,already,exists;public,retention,lease,add,retention,lease,final,string,id,final,long,retaining,sequence,number,final,string,source,final,action,listener,replication,response,listener,objects,require,non,null,listener,final,retention,lease,retention,lease,final,retention,leases,current,retention,leases,synchronized,this,assert,primary,mode,if,retention,leases,contains,id,throw,new,illegal,argument,exception,retention,lease,with,id,id,already,exists,retention,lease,new,retention,lease,id,retaining,sequence,number,current,time,millis,supplier,get,as,long,source,retention,leases,new,retention,leases,operation,primary,term,retention,leases,version,1,stream,concat,retention,leases,leases,stream,stream,of,retention,lease,collect,collectors,to,list,current,retention,leases,retention,leases,on,add,retention,lease,accept,current,retention,leases,listener,return,retention,lease
ReplicationTracker -> public RetentionLease addRetentionLease(             final String id,             final long retainingSequenceNumber,             final String source,             final ActionListener<ReplicationResponse> listener);1549937843;Adds a new retention lease.__@param id                      the identifier of the retention lease_@param retainingSequenceNumber the retaining sequence number_@param source                  the source of the retention lease_@param listener                the callback when the retention lease is successfully added and synced to replicas_@return the new retention lease_@throws IllegalArgumentException if the specified retention lease already exists;public RetentionLease addRetentionLease(_            final String id,_            final long retainingSequenceNumber,_            final String source,_            final ActionListener<ReplicationResponse> listener) {_        Objects.requireNonNull(listener)__        final RetentionLease retentionLease__        final RetentionLeases currentRetentionLeases__        synchronized (this) {_            assert primaryMode__            if (retentionLeases.contains(id)) {_                throw new IllegalArgumentException("retention lease with ID [" + id + "] already exists")__            }_            retentionLease = new RetentionLease(id, retainingSequenceNumber, currentTimeMillisSupplier.getAsLong(), source)__            retentionLeases = new RetentionLeases(_                    operationPrimaryTerm,_                    retentionLeases.version() + 1,_                    Stream.concat(retentionLeases.leases().stream(), Stream.of(retentionLease)).collect(Collectors.toList()))__            currentRetentionLeases = retentionLeases__        }_        onSyncRetentionLeases.accept(currentRetentionLeases, listener)__        return retentionLease__    };adds,a,new,retention,lease,param,id,the,identifier,of,the,retention,lease,param,retaining,sequence,number,the,retaining,sequence,number,param,source,the,source,of,the,retention,lease,param,listener,the,callback,when,the,retention,lease,is,successfully,added,and,synced,to,replicas,return,the,new,retention,lease,throws,illegal,argument,exception,if,the,specified,retention,lease,already,exists;public,retention,lease,add,retention,lease,final,string,id,final,long,retaining,sequence,number,final,string,source,final,action,listener,replication,response,listener,objects,require,non,null,listener,final,retention,lease,retention,lease,final,retention,leases,current,retention,leases,synchronized,this,assert,primary,mode,if,retention,leases,contains,id,throw,new,illegal,argument,exception,retention,lease,with,id,id,already,exists,retention,lease,new,retention,lease,id,retaining,sequence,number,current,time,millis,supplier,get,as,long,source,retention,leases,new,retention,leases,operation,primary,term,retention,leases,version,1,stream,concat,retention,leases,leases,stream,stream,of,retention,lease,collect,collectors,to,list,current,retention,leases,retention,leases,on,sync,retention,leases,accept,current,retention,leases,listener,return,retention,lease
ReplicationTracker -> public RetentionLease addRetentionLease(             final String id,             final long retainingSequenceNumber,             final String source,             final ActionListener<ReplicationResponse> listener);1549949489;Adds a new retention lease.__@param id                      the identifier of the retention lease_@param retainingSequenceNumber the retaining sequence number_@param source                  the source of the retention lease_@param listener                the callback when the retention lease is successfully added and synced to replicas_@return the new retention lease_@throws IllegalArgumentException if the specified retention lease already exists;public RetentionLease addRetentionLease(_            final String id,_            final long retainingSequenceNumber,_            final String source,_            final ActionListener<ReplicationResponse> listener) {_        Objects.requireNonNull(listener)__        final RetentionLease retentionLease__        final RetentionLeases currentRetentionLeases__        synchronized (this) {_            assert primaryMode__            if (retentionLeases.contains(id)) {_                throw new RetentionLeaseAlreadyExistsException(id)__            }_            retentionLease = new RetentionLease(id, retainingSequenceNumber, currentTimeMillisSupplier.getAsLong(), source)__            retentionLeases = new RetentionLeases(_                    operationPrimaryTerm,_                    retentionLeases.version() + 1,_                    Stream.concat(retentionLeases.leases().stream(), Stream.of(retentionLease)).collect(Collectors.toList()))__            currentRetentionLeases = retentionLeases__        }_        onSyncRetentionLeases.accept(currentRetentionLeases, listener)__        return retentionLease__    };adds,a,new,retention,lease,param,id,the,identifier,of,the,retention,lease,param,retaining,sequence,number,the,retaining,sequence,number,param,source,the,source,of,the,retention,lease,param,listener,the,callback,when,the,retention,lease,is,successfully,added,and,synced,to,replicas,return,the,new,retention,lease,throws,illegal,argument,exception,if,the,specified,retention,lease,already,exists;public,retention,lease,add,retention,lease,final,string,id,final,long,retaining,sequence,number,final,string,source,final,action,listener,replication,response,listener,objects,require,non,null,listener,final,retention,lease,retention,lease,final,retention,leases,current,retention,leases,synchronized,this,assert,primary,mode,if,retention,leases,contains,id,throw,new,retention,lease,already,exists,exception,id,retention,lease,new,retention,lease,id,retaining,sequence,number,current,time,millis,supplier,get,as,long,source,retention,leases,new,retention,leases,operation,primary,term,retention,leases,version,1,stream,concat,retention,leases,leases,stream,stream,of,retention,lease,collect,collectors,to,list,current,retention,leases,retention,leases,on,sync,retention,leases,accept,current,retention,leases,listener,return,retention,lease
ReplicationTracker -> public RetentionLease addRetentionLease(             final String id,             final long retainingSequenceNumber,             final String source,             final ActionListener<ReplicationResponse> listener);1550526771;Adds a new retention lease.__@param id                      the identifier of the retention lease_@param retainingSequenceNumber the retaining sequence number_@param source                  the source of the retention lease_@param listener                the callback when the retention lease is successfully added and synced to replicas_@return the new retention lease_@throws IllegalArgumentException if the specified retention lease already exists;public RetentionLease addRetentionLease(_            final String id,_            final long retainingSequenceNumber,_            final String source,_            final ActionListener<ReplicationResponse> listener) {_        Objects.requireNonNull(listener)__        final RetentionLease retentionLease__        final RetentionLeases currentRetentionLeases__        synchronized (this) {_            assert primaryMode__            if (retentionLeases.contains(id)) {_                throw new RetentionLeaseAlreadyExistsException(id)__            }_            retentionLease = new RetentionLease(id, retainingSequenceNumber, currentTimeMillisSupplier.getAsLong(), source)__            retentionLeases = new RetentionLeases(_                    operationPrimaryTerm,_                    retentionLeases.version() + 1,_                    Stream.concat(retentionLeases.leases().stream(), Stream.of(retentionLease)).collect(Collectors.toList()))__            currentRetentionLeases = retentionLeases__        }_        onSyncRetentionLeases.accept(currentRetentionLeases, listener)__        return retentionLease__    };adds,a,new,retention,lease,param,id,the,identifier,of,the,retention,lease,param,retaining,sequence,number,the,retaining,sequence,number,param,source,the,source,of,the,retention,lease,param,listener,the,callback,when,the,retention,lease,is,successfully,added,and,synced,to,replicas,return,the,new,retention,lease,throws,illegal,argument,exception,if,the,specified,retention,lease,already,exists;public,retention,lease,add,retention,lease,final,string,id,final,long,retaining,sequence,number,final,string,source,final,action,listener,replication,response,listener,objects,require,non,null,listener,final,retention,lease,retention,lease,final,retention,leases,current,retention,leases,synchronized,this,assert,primary,mode,if,retention,leases,contains,id,throw,new,retention,lease,already,exists,exception,id,retention,lease,new,retention,lease,id,retaining,sequence,number,current,time,millis,supplier,get,as,long,source,retention,leases,new,retention,leases,operation,primary,term,retention,leases,version,1,stream,concat,retention,leases,leases,stream,stream,of,retention,lease,collect,collectors,to,list,current,retention,leases,retention,leases,on,sync,retention,leases,accept,current,retention,leases,listener,return,retention,lease
ReplicationTracker -> private boolean invariant();1524684173;Class invariant that should hold before and after every invocation of public methods on this class. As Java lacks implication_as a logical operator, many of the invariants are written under the form (!A || B), they should be read as (A implies B) however.;private boolean invariant() {_        assert checkpoints.get(shardAllocationId) != null :_            "checkpoints map should always have an entry for the current shard"___        _        assert primaryMode || checkpoints.values().stream()_            .allMatch(lcps -> lcps.localCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO ||_                lcps.localCheckpoint == SequenceNumbers.PRE_60_NODE_CHECKPOINT)___        _        assert primaryMode_                || checkpoints_                .entrySet()_                .stream()_                .filter(e -> e.getKey().equals(shardAllocationId) == false)_                .map(Map.Entry::getValue)_                .allMatch(cps ->_                        (cps.globalCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO_                                || cps.globalCheckpoint == SequenceNumbers.PRE_60_NODE_CHECKPOINT))___        _        assert !handoffInProgress || primaryMode___        _        assert !primaryMode || checkpoints.get(shardAllocationId).inSync___        _        assert !primaryMode || (routingTable != null && replicationGroup != null) :_            "primary mode but routing table is " + routingTable + " and replication group is " + replicationGroup___        _        assert !primaryMode_                || (routingTable.primaryShard().allocationId().getId().equals(shardAllocationId)_                || routingTable.primaryShard().allocationId().getRelocationId().equals(shardAllocationId))___        _        assert !handoffInProgress || pendingInSync.isEmpty() :_            "entries blocking global checkpoint advancement during relocation handoff: " + pendingInSync___        _        assert pendingInSync.isEmpty() || (primaryMode && !handoffInProgress)___        _        assert !primaryMode_                || getGlobalCheckpoint() == computeGlobalCheckpoint(pendingInSync, checkpoints.values(), getGlobalCheckpoint())_                : "global checkpoint is not up-to-date, expected: " +_                computeGlobalCheckpoint(pendingInSync, checkpoints.values(), getGlobalCheckpoint()) + " but was: " + getGlobalCheckpoint()___        _        assert !primaryMode_                || getGlobalCheckpoint() <= inSyncCheckpointStates(checkpoints, CheckpointState::getLocalCheckpoint, LongStream::min)_                : "global checkpoint [" + getGlobalCheckpoint() + "] "_                + "for primary mode allocation ID [" + shardAllocationId + "] "_                + "more than in-sync local checkpoints [" + checkpoints + "]"___        _        assert (routingTable == null) == (replicationGroup == null) :_            "routing table is " + routingTable + " but replication group is " + replicationGroup___        assert replicationGroup == null || replicationGroup.equals(calculateReplicationGroup()) :_            "cached replication group out of sync: expected: " + calculateReplicationGroup() + " but was: " + replicationGroup___        _        assert routingTable == null || checkpoints.keySet().containsAll(routingTable.getAllAllocationIds()) :_            "local checkpoints " + checkpoints + " not in-sync with routing table " + routingTable___        for (Map.Entry<String, CheckpointState> entry : checkpoints.entrySet()) {_            _            assert !pendingInSync.contains(entry.getKey()) || !entry.getValue().inSync :_                "shard copy " + entry.getKey() + " blocks global checkpoint advancement but is in-sync"__            _            assert !entry.getValue().inSync || entry.getValue().tracked :_                "shard copy " + entry.getKey() + " is in-sync but not tracked"__        }__        return true__    };class,invariant,that,should,hold,before,and,after,every,invocation,of,public,methods,on,this,class,as,java,lacks,implication,as,a,logical,operator,many,of,the,invariants,are,written,under,the,form,a,b,they,should,be,read,as,a,implies,b,however;private,boolean,invariant,assert,checkpoints,get,shard,allocation,id,null,checkpoints,map,should,always,have,an,entry,for,the,current,shard,assert,primary,mode,checkpoints,values,stream,all,match,lcps,lcps,local,checkpoint,sequence,numbers,lcps,local,checkpoint,sequence,numbers,assert,primary,mode,checkpoints,entry,set,stream,filter,e,e,get,key,equals,shard,allocation,id,false,map,map,entry,get,value,all,match,cps,cps,global,checkpoint,sequence,numbers,cps,global,checkpoint,sequence,numbers,assert,handoff,in,progress,primary,mode,assert,primary,mode,checkpoints,get,shard,allocation,id,in,sync,assert,primary,mode,routing,table,null,replication,group,null,primary,mode,but,routing,table,is,routing,table,and,replication,group,is,replication,group,assert,primary,mode,routing,table,primary,shard,allocation,id,get,id,equals,shard,allocation,id,routing,table,primary,shard,allocation,id,get,relocation,id,equals,shard,allocation,id,assert,handoff,in,progress,pending,in,sync,is,empty,entries,blocking,global,checkpoint,advancement,during,relocation,handoff,pending,in,sync,assert,pending,in,sync,is,empty,primary,mode,handoff,in,progress,assert,primary,mode,get,global,checkpoint,compute,global,checkpoint,pending,in,sync,checkpoints,values,get,global,checkpoint,global,checkpoint,is,not,up,to,date,expected,compute,global,checkpoint,pending,in,sync,checkpoints,values,get,global,checkpoint,but,was,get,global,checkpoint,assert,primary,mode,get,global,checkpoint,in,sync,checkpoint,states,checkpoints,checkpoint,state,get,local,checkpoint,long,stream,min,global,checkpoint,get,global,checkpoint,for,primary,mode,allocation,id,shard,allocation,id,more,than,in,sync,local,checkpoints,checkpoints,assert,routing,table,null,replication,group,null,routing,table,is,routing,table,but,replication,group,is,replication,group,assert,replication,group,null,replication,group,equals,calculate,replication,group,cached,replication,group,out,of,sync,expected,calculate,replication,group,but,was,replication,group,assert,routing,table,null,checkpoints,key,set,contains,all,routing,table,get,all,allocation,ids,local,checkpoints,checkpoints,not,in,sync,with,routing,table,routing,table,for,map,entry,string,checkpoint,state,entry,checkpoints,entry,set,assert,pending,in,sync,contains,entry,get,key,entry,get,value,in,sync,shard,copy,entry,get,key,blocks,global,checkpoint,advancement,but,is,in,sync,assert,entry,get,value,in,sync,entry,get,value,tracked,shard,copy,entry,get,key,is,in,sync,but,not,tracked,return,true
ReplicationTracker -> private boolean invariant();1525334055;Class invariant that should hold before and after every invocation of public methods on this class. As Java lacks implication_as a logical operator, many of the invariants are written under the form (!A || B), they should be read as (A implies B) however.;private boolean invariant() {_        assert checkpoints.get(shardAllocationId) != null :_            "checkpoints map should always have an entry for the current shard"___        _        assert primaryMode || checkpoints.values().stream()_            .allMatch(lcps -> lcps.localCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO ||_                lcps.localCheckpoint == SequenceNumbers.PRE_60_NODE_CHECKPOINT)___        _        assert primaryMode_                || checkpoints_                .entrySet()_                .stream()_                .filter(e -> e.getKey().equals(shardAllocationId) == false)_                .map(Map.Entry::getValue)_                .allMatch(cps ->_                        (cps.globalCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO_                                || cps.globalCheckpoint == SequenceNumbers.PRE_60_NODE_CHECKPOINT))___        _        assert !handoffInProgress || primaryMode___        _        assert !primaryMode || checkpoints.get(shardAllocationId).inSync___        _        assert !primaryMode || (routingTable != null && replicationGroup != null) :_            "primary mode but routing table is " + routingTable + " and replication group is " + replicationGroup___        _        assert !primaryMode_                || (routingTable.primaryShard().allocationId().getId().equals(shardAllocationId)_                || routingTable.primaryShard().allocationId().getRelocationId().equals(shardAllocationId))___        _        assert !handoffInProgress || pendingInSync.isEmpty() :_            "entries blocking global checkpoint advancement during relocation handoff: " + pendingInSync___        _        assert pendingInSync.isEmpty() || (primaryMode && !handoffInProgress)___        _        assert !primaryMode_                || getGlobalCheckpoint() == computeGlobalCheckpoint(pendingInSync, checkpoints.values(), getGlobalCheckpoint())_                : "global checkpoint is not up-to-date, expected: " +_                computeGlobalCheckpoint(pendingInSync, checkpoints.values(), getGlobalCheckpoint()) + " but was: " + getGlobalCheckpoint()___        _        assert !primaryMode_                || getGlobalCheckpoint() <= inSyncCheckpointStates(checkpoints, CheckpointState::getLocalCheckpoint, LongStream::min)_                : "global checkpoint [" + getGlobalCheckpoint() + "] "_                + "for primary mode allocation ID [" + shardAllocationId + "] "_                + "more than in-sync local checkpoints [" + checkpoints + "]"___        _        assert (routingTable == null) == (replicationGroup == null) :_            "routing table is " + routingTable + " but replication group is " + replicationGroup___        assert replicationGroup == null || replicationGroup.equals(calculateReplicationGroup()) :_            "cached replication group out of sync: expected: " + calculateReplicationGroup() + " but was: " + replicationGroup___        _        assert routingTable == null || checkpoints.keySet().containsAll(routingTable.getAllAllocationIds()) :_            "local checkpoints " + checkpoints + " not in-sync with routing table " + routingTable___        for (Map.Entry<String, CheckpointState> entry : checkpoints.entrySet()) {_            _            assert !pendingInSync.contains(entry.getKey()) || !entry.getValue().inSync :_                "shard copy " + entry.getKey() + " blocks global checkpoint advancement but is in-sync"__            _            assert !entry.getValue().inSync || entry.getValue().tracked :_                "shard copy " + entry.getKey() + " is in-sync but not tracked"__        }__        _        for (String aId : pendingInSync) {_            assert checkpoints.get(aId) != null : "aId [" + aId + "] is pending in sync but isn't tracked"__        }__        return true__    };class,invariant,that,should,hold,before,and,after,every,invocation,of,public,methods,on,this,class,as,java,lacks,implication,as,a,logical,operator,many,of,the,invariants,are,written,under,the,form,a,b,they,should,be,read,as,a,implies,b,however;private,boolean,invariant,assert,checkpoints,get,shard,allocation,id,null,checkpoints,map,should,always,have,an,entry,for,the,current,shard,assert,primary,mode,checkpoints,values,stream,all,match,lcps,lcps,local,checkpoint,sequence,numbers,lcps,local,checkpoint,sequence,numbers,assert,primary,mode,checkpoints,entry,set,stream,filter,e,e,get,key,equals,shard,allocation,id,false,map,map,entry,get,value,all,match,cps,cps,global,checkpoint,sequence,numbers,cps,global,checkpoint,sequence,numbers,assert,handoff,in,progress,primary,mode,assert,primary,mode,checkpoints,get,shard,allocation,id,in,sync,assert,primary,mode,routing,table,null,replication,group,null,primary,mode,but,routing,table,is,routing,table,and,replication,group,is,replication,group,assert,primary,mode,routing,table,primary,shard,allocation,id,get,id,equals,shard,allocation,id,routing,table,primary,shard,allocation,id,get,relocation,id,equals,shard,allocation,id,assert,handoff,in,progress,pending,in,sync,is,empty,entries,blocking,global,checkpoint,advancement,during,relocation,handoff,pending,in,sync,assert,pending,in,sync,is,empty,primary,mode,handoff,in,progress,assert,primary,mode,get,global,checkpoint,compute,global,checkpoint,pending,in,sync,checkpoints,values,get,global,checkpoint,global,checkpoint,is,not,up,to,date,expected,compute,global,checkpoint,pending,in,sync,checkpoints,values,get,global,checkpoint,but,was,get,global,checkpoint,assert,primary,mode,get,global,checkpoint,in,sync,checkpoint,states,checkpoints,checkpoint,state,get,local,checkpoint,long,stream,min,global,checkpoint,get,global,checkpoint,for,primary,mode,allocation,id,shard,allocation,id,more,than,in,sync,local,checkpoints,checkpoints,assert,routing,table,null,replication,group,null,routing,table,is,routing,table,but,replication,group,is,replication,group,assert,replication,group,null,replication,group,equals,calculate,replication,group,cached,replication,group,out,of,sync,expected,calculate,replication,group,but,was,replication,group,assert,routing,table,null,checkpoints,key,set,contains,all,routing,table,get,all,allocation,ids,local,checkpoints,checkpoints,not,in,sync,with,routing,table,routing,table,for,map,entry,string,checkpoint,state,entry,checkpoints,entry,set,assert,pending,in,sync,contains,entry,get,key,entry,get,value,in,sync,shard,copy,entry,get,key,blocks,global,checkpoint,advancement,but,is,in,sync,assert,entry,get,value,in,sync,entry,get,value,tracked,shard,copy,entry,get,key,is,in,sync,but,not,tracked,for,string,a,id,pending,in,sync,assert,checkpoints,get,a,id,null,a,id,a,id,is,pending,in,sync,but,isn,t,tracked,return,true
ReplicationTracker -> private boolean invariant();1533295538;Class invariant that should hold before and after every invocation of public methods on this class. As Java lacks implication_as a logical operator, many of the invariants are written under the form (!A || B), they should be read as (A implies B) however.;private boolean invariant() {_        assert checkpoints.get(shardAllocationId) != null :_            "checkpoints map should always have an entry for the current shard"___        _        assert primaryMode || checkpoints.values().stream()_            .allMatch(lcps -> lcps.localCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO ||_                lcps.localCheckpoint == SequenceNumbers.PRE_60_NODE_CHECKPOINT)___        _        assert primaryMode_                || checkpoints_                .entrySet()_                .stream()_                .filter(e -> e.getKey().equals(shardAllocationId) == false)_                .map(Map.Entry::getValue)_                .allMatch(cps ->_                        (cps.globalCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO_                                || cps.globalCheckpoint == SequenceNumbers.PRE_60_NODE_CHECKPOINT))___        _        assert !handoffInProgress || primaryMode___        _        assert !relocated || !primaryMode___        _        assert !primaryMode || checkpoints.get(shardAllocationId).inSync___        _        assert !primaryMode || (routingTable != null && replicationGroup != null) :_            "primary mode but routing table is " + routingTable + " and replication group is " + replicationGroup___        _        assert !primaryMode_                || (routingTable.primaryShard().allocationId().getId().equals(shardAllocationId)_                || routingTable.primaryShard().allocationId().getRelocationId().equals(shardAllocationId))___        _        assert !handoffInProgress || pendingInSync.isEmpty() :_            "entries blocking global checkpoint advancement during relocation handoff: " + pendingInSync___        _        assert pendingInSync.isEmpty() || (primaryMode && !handoffInProgress)___        _        assert !primaryMode_                || getGlobalCheckpoint() == computeGlobalCheckpoint(pendingInSync, checkpoints.values(), getGlobalCheckpoint())_                : "global checkpoint is not up-to-date, expected: " +_                computeGlobalCheckpoint(pendingInSync, checkpoints.values(), getGlobalCheckpoint()) + " but was: " + getGlobalCheckpoint()___        _        assert !primaryMode_                || getGlobalCheckpoint() <= inSyncCheckpointStates(checkpoints, CheckpointState::getLocalCheckpoint, LongStream::min)_                : "global checkpoint [" + getGlobalCheckpoint() + "] "_                + "for primary mode allocation ID [" + shardAllocationId + "] "_                + "more than in-sync local checkpoints [" + checkpoints + "]"___        _        assert (routingTable == null) == (replicationGroup == null) :_            "routing table is " + routingTable + " but replication group is " + replicationGroup___        assert replicationGroup == null || replicationGroup.equals(calculateReplicationGroup()) :_            "cached replication group out of sync: expected: " + calculateReplicationGroup() + " but was: " + replicationGroup___        _        assert routingTable == null || checkpoints.keySet().containsAll(routingTable.getAllAllocationIds()) :_            "local checkpoints " + checkpoints + " not in-sync with routing table " + routingTable___        for (Map.Entry<String, CheckpointState> entry : checkpoints.entrySet()) {_            _            assert !pendingInSync.contains(entry.getKey()) || !entry.getValue().inSync :_                "shard copy " + entry.getKey() + " blocks global checkpoint advancement but is in-sync"__            _            assert !entry.getValue().inSync || entry.getValue().tracked :_                "shard copy " + entry.getKey() + " is in-sync but not tracked"__        }__        _        for (String aId : pendingInSync) {_            assert checkpoints.get(aId) != null : "aId [" + aId + "] is pending in sync but isn't tracked"__        }__        return true__    };class,invariant,that,should,hold,before,and,after,every,invocation,of,public,methods,on,this,class,as,java,lacks,implication,as,a,logical,operator,many,of,the,invariants,are,written,under,the,form,a,b,they,should,be,read,as,a,implies,b,however;private,boolean,invariant,assert,checkpoints,get,shard,allocation,id,null,checkpoints,map,should,always,have,an,entry,for,the,current,shard,assert,primary,mode,checkpoints,values,stream,all,match,lcps,lcps,local,checkpoint,sequence,numbers,lcps,local,checkpoint,sequence,numbers,assert,primary,mode,checkpoints,entry,set,stream,filter,e,e,get,key,equals,shard,allocation,id,false,map,map,entry,get,value,all,match,cps,cps,global,checkpoint,sequence,numbers,cps,global,checkpoint,sequence,numbers,assert,handoff,in,progress,primary,mode,assert,relocated,primary,mode,assert,primary,mode,checkpoints,get,shard,allocation,id,in,sync,assert,primary,mode,routing,table,null,replication,group,null,primary,mode,but,routing,table,is,routing,table,and,replication,group,is,replication,group,assert,primary,mode,routing,table,primary,shard,allocation,id,get,id,equals,shard,allocation,id,routing,table,primary,shard,allocation,id,get,relocation,id,equals,shard,allocation,id,assert,handoff,in,progress,pending,in,sync,is,empty,entries,blocking,global,checkpoint,advancement,during,relocation,handoff,pending,in,sync,assert,pending,in,sync,is,empty,primary,mode,handoff,in,progress,assert,primary,mode,get,global,checkpoint,compute,global,checkpoint,pending,in,sync,checkpoints,values,get,global,checkpoint,global,checkpoint,is,not,up,to,date,expected,compute,global,checkpoint,pending,in,sync,checkpoints,values,get,global,checkpoint,but,was,get,global,checkpoint,assert,primary,mode,get,global,checkpoint,in,sync,checkpoint,states,checkpoints,checkpoint,state,get,local,checkpoint,long,stream,min,global,checkpoint,get,global,checkpoint,for,primary,mode,allocation,id,shard,allocation,id,more,than,in,sync,local,checkpoints,checkpoints,assert,routing,table,null,replication,group,null,routing,table,is,routing,table,but,replication,group,is,replication,group,assert,replication,group,null,replication,group,equals,calculate,replication,group,cached,replication,group,out,of,sync,expected,calculate,replication,group,but,was,replication,group,assert,routing,table,null,checkpoints,key,set,contains,all,routing,table,get,all,allocation,ids,local,checkpoints,checkpoints,not,in,sync,with,routing,table,routing,table,for,map,entry,string,checkpoint,state,entry,checkpoints,entry,set,assert,pending,in,sync,contains,entry,get,key,entry,get,value,in,sync,shard,copy,entry,get,key,blocks,global,checkpoint,advancement,but,is,in,sync,assert,entry,get,value,in,sync,entry,get,value,tracked,shard,copy,entry,get,key,is,in,sync,but,not,tracked,for,string,a,id,pending,in,sync,assert,checkpoints,get,a,id,null,a,id,a,id,is,pending,in,sync,but,isn,t,tracked,return,true
ReplicationTracker -> private boolean invariant();1533738061;Class invariant that should hold before and after every invocation of public methods on this class. As Java lacks implication_as a logical operator, many of the invariants are written under the form (!A || B), they should be read as (A implies B) however.;private boolean invariant() {_        assert checkpoints.get(shardAllocationId) != null :_            "checkpoints map should always have an entry for the current shard"___        _        assert primaryMode || checkpoints.values().stream()_            .allMatch(lcps -> lcps.localCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO ||_                lcps.localCheckpoint == SequenceNumbers.PRE_60_NODE_CHECKPOINT)___        _        assert primaryMode_                || checkpoints_                .entrySet()_                .stream()_                .filter(e -> e.getKey().equals(shardAllocationId) == false)_                .map(Map.Entry::getValue)_                .allMatch(cps ->_                        (cps.globalCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO_                                || cps.globalCheckpoint == SequenceNumbers.PRE_60_NODE_CHECKPOINT))___        _        assert !handoffInProgress || primaryMode___        _        assert !relocated || !primaryMode___        _        assert !primaryMode || checkpoints.get(shardAllocationId).inSync___        _        assert !primaryMode || (routingTable != null && replicationGroup != null) :_            "primary mode but routing table is " + routingTable + " and replication group is " + replicationGroup___        _        assert !primaryMode_                || (routingTable.primaryShard().allocationId().getId().equals(shardAllocationId)_                || routingTable.primaryShard().allocationId().getRelocationId().equals(shardAllocationId))___        _        assert !handoffInProgress || pendingInSync.isEmpty() :_            "entries blocking global checkpoint advancement during relocation handoff: " + pendingInSync___        _        assert pendingInSync.isEmpty() || (primaryMode && !handoffInProgress)___        _        assert !primaryMode_                || getGlobalCheckpoint() == computeGlobalCheckpoint(pendingInSync, checkpoints.values(), getGlobalCheckpoint())_                : "global checkpoint is not up-to-date, expected: " +_                computeGlobalCheckpoint(pendingInSync, checkpoints.values(), getGlobalCheckpoint()) + " but was: " + getGlobalCheckpoint()___        _        assert !primaryMode_                || getGlobalCheckpoint() <= inSyncCheckpointStates(checkpoints, CheckpointState::getLocalCheckpoint, LongStream::min)_                : "global checkpoint [" + getGlobalCheckpoint() + "] "_                + "for primary mode allocation ID [" + shardAllocationId + "] "_                + "more than in-sync local checkpoints [" + checkpoints + "]"___        _        assert (routingTable == null) == (replicationGroup == null) :_            "routing table is " + routingTable + " but replication group is " + replicationGroup___        assert replicationGroup == null || replicationGroup.equals(calculateReplicationGroup()) :_            "cached replication group out of sync: expected: " + calculateReplicationGroup() + " but was: " + replicationGroup___        _        assert routingTable == null || checkpoints.keySet().containsAll(routingTable.getAllAllocationIds()) :_            "local checkpoints " + checkpoints + " not in-sync with routing table " + routingTable___        for (Map.Entry<String, CheckpointState> entry : checkpoints.entrySet()) {_            _            assert !pendingInSync.contains(entry.getKey()) || !entry.getValue().inSync :_                "shard copy " + entry.getKey() + " blocks global checkpoint advancement but is in-sync"__            _            assert !entry.getValue().inSync || entry.getValue().tracked :_                "shard copy " + entry.getKey() + " is in-sync but not tracked"__        }__        _        for (String aId : pendingInSync) {_            assert checkpoints.get(aId) != null : "aId [" + aId + "] is pending in sync but isn't tracked"__        }__        return true__    };class,invariant,that,should,hold,before,and,after,every,invocation,of,public,methods,on,this,class,as,java,lacks,implication,as,a,logical,operator,many,of,the,invariants,are,written,under,the,form,a,b,they,should,be,read,as,a,implies,b,however;private,boolean,invariant,assert,checkpoints,get,shard,allocation,id,null,checkpoints,map,should,always,have,an,entry,for,the,current,shard,assert,primary,mode,checkpoints,values,stream,all,match,lcps,lcps,local,checkpoint,sequence,numbers,lcps,local,checkpoint,sequence,numbers,assert,primary,mode,checkpoints,entry,set,stream,filter,e,e,get,key,equals,shard,allocation,id,false,map,map,entry,get,value,all,match,cps,cps,global,checkpoint,sequence,numbers,cps,global,checkpoint,sequence,numbers,assert,handoff,in,progress,primary,mode,assert,relocated,primary,mode,assert,primary,mode,checkpoints,get,shard,allocation,id,in,sync,assert,primary,mode,routing,table,null,replication,group,null,primary,mode,but,routing,table,is,routing,table,and,replication,group,is,replication,group,assert,primary,mode,routing,table,primary,shard,allocation,id,get,id,equals,shard,allocation,id,routing,table,primary,shard,allocation,id,get,relocation,id,equals,shard,allocation,id,assert,handoff,in,progress,pending,in,sync,is,empty,entries,blocking,global,checkpoint,advancement,during,relocation,handoff,pending,in,sync,assert,pending,in,sync,is,empty,primary,mode,handoff,in,progress,assert,primary,mode,get,global,checkpoint,compute,global,checkpoint,pending,in,sync,checkpoints,values,get,global,checkpoint,global,checkpoint,is,not,up,to,date,expected,compute,global,checkpoint,pending,in,sync,checkpoints,values,get,global,checkpoint,but,was,get,global,checkpoint,assert,primary,mode,get,global,checkpoint,in,sync,checkpoint,states,checkpoints,checkpoint,state,get,local,checkpoint,long,stream,min,global,checkpoint,get,global,checkpoint,for,primary,mode,allocation,id,shard,allocation,id,more,than,in,sync,local,checkpoints,checkpoints,assert,routing,table,null,replication,group,null,routing,table,is,routing,table,but,replication,group,is,replication,group,assert,replication,group,null,replication,group,equals,calculate,replication,group,cached,replication,group,out,of,sync,expected,calculate,replication,group,but,was,replication,group,assert,routing,table,null,checkpoints,key,set,contains,all,routing,table,get,all,allocation,ids,local,checkpoints,checkpoints,not,in,sync,with,routing,table,routing,table,for,map,entry,string,checkpoint,state,entry,checkpoints,entry,set,assert,pending,in,sync,contains,entry,get,key,entry,get,value,in,sync,shard,copy,entry,get,key,blocks,global,checkpoint,advancement,but,is,in,sync,assert,entry,get,value,in,sync,entry,get,value,tracked,shard,copy,entry,get,key,is,in,sync,but,not,tracked,for,string,a,id,pending,in,sync,assert,checkpoints,get,a,id,null,a,id,a,id,is,pending,in,sync,but,isn,t,tracked,return,true
ReplicationTracker -> private boolean invariant();1546875837;Class invariant that should hold before and after every invocation of public methods on this class. As Java lacks implication_as a logical operator, many of the invariants are written under the form (!A || B), they should be read as (A implies B) however.;private boolean invariant() {_        assert checkpoints.get(shardAllocationId) != null :_            "checkpoints map should always have an entry for the current shard"___        _        assert primaryMode || checkpoints.values().stream()_            .allMatch(lcps -> lcps.localCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO ||_                lcps.localCheckpoint == SequenceNumbers.PRE_60_NODE_CHECKPOINT)___        _        assert primaryMode_                || checkpoints_                .entrySet()_                .stream()_                .filter(e -> e.getKey().equals(shardAllocationId) == false)_                .map(Map.Entry::getValue)_                .allMatch(cps ->_                        (cps.globalCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO_                                || cps.globalCheckpoint == SequenceNumbers.PRE_60_NODE_CHECKPOINT))___        _        assert !handoffInProgress || primaryMode___        _        assert !relocated || !primaryMode___        _        assert !primaryMode || checkpoints.get(shardAllocationId).inSync___        _        assert !primaryMode || (routingTable != null && replicationGroup != null) :_            "primary mode but routing table is " + routingTable + " and replication group is " + replicationGroup___        _        assert !primaryMode_                || (routingTable.primaryShard().allocationId().getId().equals(shardAllocationId)_                || routingTable.primaryShard().allocationId().getRelocationId().equals(shardAllocationId))___        _        assert !handoffInProgress || pendingInSync.isEmpty() :_            "entries blocking global checkpoint advancement during relocation handoff: " + pendingInSync___        _        assert pendingInSync.isEmpty() || (primaryMode && !handoffInProgress)___        _        assert !primaryMode_                || getGlobalCheckpoint() == computeGlobalCheckpoint(pendingInSync, checkpoints.values(), getGlobalCheckpoint())_                : "global checkpoint is not up-to-date, expected: " +_                computeGlobalCheckpoint(pendingInSync, checkpoints.values(), getGlobalCheckpoint()) + " but was: " + getGlobalCheckpoint()___        _        assert !primaryMode_                || getGlobalCheckpoint() <= inSyncCheckpointStates(checkpoints, CheckpointState::getLocalCheckpoint, LongStream::min)_                : "global checkpoint [" + getGlobalCheckpoint() + "] "_                + "for primary mode allocation ID [" + shardAllocationId + "] "_                + "more than in-sync local checkpoints [" + checkpoints + "]"___        _        assert (routingTable == null) == (replicationGroup == null) :_            "routing table is " + routingTable + " but replication group is " + replicationGroup___        assert replicationGroup == null || replicationGroup.equals(calculateReplicationGroup()) :_            "cached replication group out of sync: expected: " + calculateReplicationGroup() + " but was: " + replicationGroup___        _        assert routingTable == null || checkpoints.keySet().containsAll(routingTable.getAllAllocationIds()) :_            "local checkpoints " + checkpoints + " not in-sync with routing table " + routingTable___        for (Map.Entry<String, CheckpointState> entry : checkpoints.entrySet()) {_            _            assert !pendingInSync.contains(entry.getKey()) || !entry.getValue().inSync :_                "shard copy " + entry.getKey() + " blocks global checkpoint advancement but is in-sync"__            _            assert !entry.getValue().inSync || entry.getValue().tracked :_                "shard copy " + entry.getKey() + " is in-sync but not tracked"__        }__        _        for (String aId : pendingInSync) {_            assert checkpoints.get(aId) != null : "aId [" + aId + "] is pending in sync but isn't tracked"__        }__        return true__    };class,invariant,that,should,hold,before,and,after,every,invocation,of,public,methods,on,this,class,as,java,lacks,implication,as,a,logical,operator,many,of,the,invariants,are,written,under,the,form,a,b,they,should,be,read,as,a,implies,b,however;private,boolean,invariant,assert,checkpoints,get,shard,allocation,id,null,checkpoints,map,should,always,have,an,entry,for,the,current,shard,assert,primary,mode,checkpoints,values,stream,all,match,lcps,lcps,local,checkpoint,sequence,numbers,lcps,local,checkpoint,sequence,numbers,assert,primary,mode,checkpoints,entry,set,stream,filter,e,e,get,key,equals,shard,allocation,id,false,map,map,entry,get,value,all,match,cps,cps,global,checkpoint,sequence,numbers,cps,global,checkpoint,sequence,numbers,assert,handoff,in,progress,primary,mode,assert,relocated,primary,mode,assert,primary,mode,checkpoints,get,shard,allocation,id,in,sync,assert,primary,mode,routing,table,null,replication,group,null,primary,mode,but,routing,table,is,routing,table,and,replication,group,is,replication,group,assert,primary,mode,routing,table,primary,shard,allocation,id,get,id,equals,shard,allocation,id,routing,table,primary,shard,allocation,id,get,relocation,id,equals,shard,allocation,id,assert,handoff,in,progress,pending,in,sync,is,empty,entries,blocking,global,checkpoint,advancement,during,relocation,handoff,pending,in,sync,assert,pending,in,sync,is,empty,primary,mode,handoff,in,progress,assert,primary,mode,get,global,checkpoint,compute,global,checkpoint,pending,in,sync,checkpoints,values,get,global,checkpoint,global,checkpoint,is,not,up,to,date,expected,compute,global,checkpoint,pending,in,sync,checkpoints,values,get,global,checkpoint,but,was,get,global,checkpoint,assert,primary,mode,get,global,checkpoint,in,sync,checkpoint,states,checkpoints,checkpoint,state,get,local,checkpoint,long,stream,min,global,checkpoint,get,global,checkpoint,for,primary,mode,allocation,id,shard,allocation,id,more,than,in,sync,local,checkpoints,checkpoints,assert,routing,table,null,replication,group,null,routing,table,is,routing,table,but,replication,group,is,replication,group,assert,replication,group,null,replication,group,equals,calculate,replication,group,cached,replication,group,out,of,sync,expected,calculate,replication,group,but,was,replication,group,assert,routing,table,null,checkpoints,key,set,contains,all,routing,table,get,all,allocation,ids,local,checkpoints,checkpoints,not,in,sync,with,routing,table,routing,table,for,map,entry,string,checkpoint,state,entry,checkpoints,entry,set,assert,pending,in,sync,contains,entry,get,key,entry,get,value,in,sync,shard,copy,entry,get,key,blocks,global,checkpoint,advancement,but,is,in,sync,assert,entry,get,value,in,sync,entry,get,value,tracked,shard,copy,entry,get,key,is,in,sync,but,not,tracked,for,string,a,id,pending,in,sync,assert,checkpoints,get,a,id,null,a,id,a,id,is,pending,in,sync,but,isn,t,tracked,return,true
ReplicationTracker -> private boolean invariant();1546927432;Class invariant that should hold before and after every invocation of public methods on this class. As Java lacks implication_as a logical operator, many of the invariants are written under the form (!A || B), they should be read as (A implies B) however.;private boolean invariant() {_        assert checkpoints.get(shardAllocationId) != null :_            "checkpoints map should always have an entry for the current shard"___        _        assert primaryMode || checkpoints.values().stream()_            .allMatch(lcps -> lcps.localCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO ||_                lcps.localCheckpoint == SequenceNumbers.PRE_60_NODE_CHECKPOINT)___        _        assert primaryMode_                || checkpoints_                .entrySet()_                .stream()_                .filter(e -> e.getKey().equals(shardAllocationId) == false)_                .map(Map.Entry::getValue)_                .allMatch(cps ->_                        (cps.globalCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO_                                || cps.globalCheckpoint == SequenceNumbers.PRE_60_NODE_CHECKPOINT))___        _        assert !handoffInProgress || primaryMode___        _        assert !relocated || !primaryMode___        _        assert !primaryMode || checkpoints.get(shardAllocationId).inSync___        _        assert !primaryMode || (routingTable != null && replicationGroup != null) :_            "primary mode but routing table is " + routingTable + " and replication group is " + replicationGroup___        _        assert !primaryMode_                || (routingTable.primaryShard().allocationId().getId().equals(shardAllocationId)_                || routingTable.primaryShard().allocationId().getRelocationId().equals(shardAllocationId))___        _        assert !handoffInProgress || pendingInSync.isEmpty() :_            "entries blocking global checkpoint advancement during relocation handoff: " + pendingInSync___        _        assert pendingInSync.isEmpty() || (primaryMode && !handoffInProgress)___        _        assert !primaryMode_                || getGlobalCheckpoint() == computeGlobalCheckpoint(pendingInSync, checkpoints.values(), getGlobalCheckpoint())_                : "global checkpoint is not up-to-date, expected: " +_                computeGlobalCheckpoint(pendingInSync, checkpoints.values(), getGlobalCheckpoint()) + " but was: " + getGlobalCheckpoint()___        _        assert !primaryMode_                || getGlobalCheckpoint() <= inSyncCheckpointStates(checkpoints, CheckpointState::getLocalCheckpoint, LongStream::min)_                : "global checkpoint [" + getGlobalCheckpoint() + "] "_                + "for primary mode allocation ID [" + shardAllocationId + "] "_                + "more than in-sync local checkpoints [" + checkpoints + "]"___        _        assert (routingTable == null) == (replicationGroup == null) :_            "routing table is " + routingTable + " but replication group is " + replicationGroup___        assert replicationGroup == null || replicationGroup.equals(calculateReplicationGroup()) :_            "cached replication group out of sync: expected: " + calculateReplicationGroup() + " but was: " + replicationGroup___        _        assert routingTable == null || checkpoints.keySet().containsAll(routingTable.getAllAllocationIds()) :_            "local checkpoints " + checkpoints + " not in-sync with routing table " + routingTable___        for (Map.Entry<String, CheckpointState> entry : checkpoints.entrySet()) {_            _            assert !pendingInSync.contains(entry.getKey()) || !entry.getValue().inSync :_                "shard copy " + entry.getKey() + " blocks global checkpoint advancement but is in-sync"__            _            assert !entry.getValue().inSync || entry.getValue().tracked :_                "shard copy " + entry.getKey() + " is in-sync but not tracked"__        }__        _        for (String aId : pendingInSync) {_            assert checkpoints.get(aId) != null : "aId [" + aId + "] is pending in sync but isn't tracked"__        }__        return true__    };class,invariant,that,should,hold,before,and,after,every,invocation,of,public,methods,on,this,class,as,java,lacks,implication,as,a,logical,operator,many,of,the,invariants,are,written,under,the,form,a,b,they,should,be,read,as,a,implies,b,however;private,boolean,invariant,assert,checkpoints,get,shard,allocation,id,null,checkpoints,map,should,always,have,an,entry,for,the,current,shard,assert,primary,mode,checkpoints,values,stream,all,match,lcps,lcps,local,checkpoint,sequence,numbers,lcps,local,checkpoint,sequence,numbers,assert,primary,mode,checkpoints,entry,set,stream,filter,e,e,get,key,equals,shard,allocation,id,false,map,map,entry,get,value,all,match,cps,cps,global,checkpoint,sequence,numbers,cps,global,checkpoint,sequence,numbers,assert,handoff,in,progress,primary,mode,assert,relocated,primary,mode,assert,primary,mode,checkpoints,get,shard,allocation,id,in,sync,assert,primary,mode,routing,table,null,replication,group,null,primary,mode,but,routing,table,is,routing,table,and,replication,group,is,replication,group,assert,primary,mode,routing,table,primary,shard,allocation,id,get,id,equals,shard,allocation,id,routing,table,primary,shard,allocation,id,get,relocation,id,equals,shard,allocation,id,assert,handoff,in,progress,pending,in,sync,is,empty,entries,blocking,global,checkpoint,advancement,during,relocation,handoff,pending,in,sync,assert,pending,in,sync,is,empty,primary,mode,handoff,in,progress,assert,primary,mode,get,global,checkpoint,compute,global,checkpoint,pending,in,sync,checkpoints,values,get,global,checkpoint,global,checkpoint,is,not,up,to,date,expected,compute,global,checkpoint,pending,in,sync,checkpoints,values,get,global,checkpoint,but,was,get,global,checkpoint,assert,primary,mode,get,global,checkpoint,in,sync,checkpoint,states,checkpoints,checkpoint,state,get,local,checkpoint,long,stream,min,global,checkpoint,get,global,checkpoint,for,primary,mode,allocation,id,shard,allocation,id,more,than,in,sync,local,checkpoints,checkpoints,assert,routing,table,null,replication,group,null,routing,table,is,routing,table,but,replication,group,is,replication,group,assert,replication,group,null,replication,group,equals,calculate,replication,group,cached,replication,group,out,of,sync,expected,calculate,replication,group,but,was,replication,group,assert,routing,table,null,checkpoints,key,set,contains,all,routing,table,get,all,allocation,ids,local,checkpoints,checkpoints,not,in,sync,with,routing,table,routing,table,for,map,entry,string,checkpoint,state,entry,checkpoints,entry,set,assert,pending,in,sync,contains,entry,get,key,entry,get,value,in,sync,shard,copy,entry,get,key,blocks,global,checkpoint,advancement,but,is,in,sync,assert,entry,get,value,in,sync,entry,get,value,tracked,shard,copy,entry,get,key,is,in,sync,but,not,tracked,for,string,a,id,pending,in,sync,assert,checkpoints,get,a,id,null,a,id,a,id,is,pending,in,sync,but,isn,t,tracked,return,true
ReplicationTracker -> private boolean invariant();1547332999;Class invariant that should hold before and after every invocation of public methods on this class. As Java lacks implication_as a logical operator, many of the invariants are written under the form (!A || B), they should be read as (A implies B) however.;private boolean invariant() {_        assert checkpoints.get(shardAllocationId) != null :_            "checkpoints map should always have an entry for the current shard"___        _        assert primaryMode || checkpoints.values().stream()_            .allMatch(lcps -> lcps.localCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO ||_                lcps.localCheckpoint == SequenceNumbers.PRE_60_NODE_CHECKPOINT)___        _        assert primaryMode_                || checkpoints_                .entrySet()_                .stream()_                .filter(e -> e.getKey().equals(shardAllocationId) == false)_                .map(Map.Entry::getValue)_                .allMatch(cps ->_                        (cps.globalCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO_                                || cps.globalCheckpoint == SequenceNumbers.PRE_60_NODE_CHECKPOINT))___        _        assert !handoffInProgress || primaryMode___        _        assert !relocated || !primaryMode___        _        assert !primaryMode || checkpoints.get(shardAllocationId).inSync___        _        assert !primaryMode || (routingTable != null && replicationGroup != null) :_            "primary mode but routing table is " + routingTable + " and replication group is " + replicationGroup___        _        assert !primaryMode_                || (routingTable.primaryShard().allocationId().getId().equals(shardAllocationId)_                || routingTable.primaryShard().allocationId().getRelocationId().equals(shardAllocationId))___        _        assert !handoffInProgress || pendingInSync.isEmpty() :_            "entries blocking global checkpoint advancement during relocation handoff: " + pendingInSync___        _        assert pendingInSync.isEmpty() || (primaryMode && !handoffInProgress)___        _        assert !primaryMode_                || getGlobalCheckpoint() == computeGlobalCheckpoint(pendingInSync, checkpoints.values(), getGlobalCheckpoint())_                : "global checkpoint is not up-to-date, expected: " +_                computeGlobalCheckpoint(pendingInSync, checkpoints.values(), getGlobalCheckpoint()) + " but was: " + getGlobalCheckpoint()___        _        assert !primaryMode_                || getGlobalCheckpoint() <= inSyncCheckpointStates(checkpoints, CheckpointState::getLocalCheckpoint, LongStream::min)_                : "global checkpoint [" + getGlobalCheckpoint() + "] "_                + "for primary mode allocation ID [" + shardAllocationId + "] "_                + "more than in-sync local checkpoints [" + checkpoints + "]"___        _        assert (routingTable == null) == (replicationGroup == null) :_            "routing table is " + routingTable + " but replication group is " + replicationGroup___        assert replicationGroup == null || replicationGroup.equals(calculateReplicationGroup()) :_            "cached replication group out of sync: expected: " + calculateReplicationGroup() + " but was: " + replicationGroup___        _        assert routingTable == null || checkpoints.keySet().containsAll(routingTable.getAllAllocationIds()) :_            "local checkpoints " + checkpoints + " not in-sync with routing table " + routingTable___        for (Map.Entry<String, CheckpointState> entry : checkpoints.entrySet()) {_            _            assert !pendingInSync.contains(entry.getKey()) || !entry.getValue().inSync :_                "shard copy " + entry.getKey() + " blocks global checkpoint advancement but is in-sync"__            _            assert !entry.getValue().inSync || entry.getValue().tracked :_                "shard copy " + entry.getKey() + " is in-sync but not tracked"__        }__        _        for (String aId : pendingInSync) {_            assert checkpoints.get(aId) != null : "aId [" + aId + "] is pending in sync but isn't tracked"__        }__        return true__    };class,invariant,that,should,hold,before,and,after,every,invocation,of,public,methods,on,this,class,as,java,lacks,implication,as,a,logical,operator,many,of,the,invariants,are,written,under,the,form,a,b,they,should,be,read,as,a,implies,b,however;private,boolean,invariant,assert,checkpoints,get,shard,allocation,id,null,checkpoints,map,should,always,have,an,entry,for,the,current,shard,assert,primary,mode,checkpoints,values,stream,all,match,lcps,lcps,local,checkpoint,sequence,numbers,lcps,local,checkpoint,sequence,numbers,assert,primary,mode,checkpoints,entry,set,stream,filter,e,e,get,key,equals,shard,allocation,id,false,map,map,entry,get,value,all,match,cps,cps,global,checkpoint,sequence,numbers,cps,global,checkpoint,sequence,numbers,assert,handoff,in,progress,primary,mode,assert,relocated,primary,mode,assert,primary,mode,checkpoints,get,shard,allocation,id,in,sync,assert,primary,mode,routing,table,null,replication,group,null,primary,mode,but,routing,table,is,routing,table,and,replication,group,is,replication,group,assert,primary,mode,routing,table,primary,shard,allocation,id,get,id,equals,shard,allocation,id,routing,table,primary,shard,allocation,id,get,relocation,id,equals,shard,allocation,id,assert,handoff,in,progress,pending,in,sync,is,empty,entries,blocking,global,checkpoint,advancement,during,relocation,handoff,pending,in,sync,assert,pending,in,sync,is,empty,primary,mode,handoff,in,progress,assert,primary,mode,get,global,checkpoint,compute,global,checkpoint,pending,in,sync,checkpoints,values,get,global,checkpoint,global,checkpoint,is,not,up,to,date,expected,compute,global,checkpoint,pending,in,sync,checkpoints,values,get,global,checkpoint,but,was,get,global,checkpoint,assert,primary,mode,get,global,checkpoint,in,sync,checkpoint,states,checkpoints,checkpoint,state,get,local,checkpoint,long,stream,min,global,checkpoint,get,global,checkpoint,for,primary,mode,allocation,id,shard,allocation,id,more,than,in,sync,local,checkpoints,checkpoints,assert,routing,table,null,replication,group,null,routing,table,is,routing,table,but,replication,group,is,replication,group,assert,replication,group,null,replication,group,equals,calculate,replication,group,cached,replication,group,out,of,sync,expected,calculate,replication,group,but,was,replication,group,assert,routing,table,null,checkpoints,key,set,contains,all,routing,table,get,all,allocation,ids,local,checkpoints,checkpoints,not,in,sync,with,routing,table,routing,table,for,map,entry,string,checkpoint,state,entry,checkpoints,entry,set,assert,pending,in,sync,contains,entry,get,key,entry,get,value,in,sync,shard,copy,entry,get,key,blocks,global,checkpoint,advancement,but,is,in,sync,assert,entry,get,value,in,sync,entry,get,value,tracked,shard,copy,entry,get,key,is,in,sync,but,not,tracked,for,string,a,id,pending,in,sync,assert,checkpoints,get,a,id,null,a,id,a,id,is,pending,in,sync,but,isn,t,tracked,return,true
ReplicationTracker -> private boolean invariant();1548593396;Class invariant that should hold before and after every invocation of public methods on this class. As Java lacks implication_as a logical operator, many of the invariants are written under the form (!A || B), they should be read as (A implies B) however.;private boolean invariant() {_        assert checkpoints.get(shardAllocationId) != null :_            "checkpoints map should always have an entry for the current shard"___        _        assert primaryMode || checkpoints.values().stream()_            .allMatch(lcps -> lcps.localCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO ||_                lcps.localCheckpoint == SequenceNumbers.PRE_60_NODE_CHECKPOINT)___        _        assert primaryMode_                || checkpoints_                .entrySet()_                .stream()_                .filter(e -> e.getKey().equals(shardAllocationId) == false)_                .map(Map.Entry::getValue)_                .allMatch(cps ->_                        (cps.globalCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO_                                || cps.globalCheckpoint == SequenceNumbers.PRE_60_NODE_CHECKPOINT))___        _        assert !handoffInProgress || primaryMode___        _        assert !relocated || !primaryMode___        _        assert !primaryMode || checkpoints.get(shardAllocationId).inSync___        _        assert !primaryMode || (routingTable != null && replicationGroup != null) :_            "primary mode but routing table is " + routingTable + " and replication group is " + replicationGroup___        _        assert !primaryMode_                || (routingTable.primaryShard().allocationId().getId().equals(shardAllocationId)_                || routingTable.primaryShard().allocationId().getRelocationId().equals(shardAllocationId))___        _        assert !handoffInProgress || pendingInSync.isEmpty() :_            "entries blocking global checkpoint advancement during relocation handoff: " + pendingInSync___        _        assert pendingInSync.isEmpty() || (primaryMode && !handoffInProgress)___        _        assert !primaryMode_                || getGlobalCheckpoint() == computeGlobalCheckpoint(pendingInSync, checkpoints.values(), getGlobalCheckpoint())_                : "global checkpoint is not up-to-date, expected: " +_                computeGlobalCheckpoint(pendingInSync, checkpoints.values(), getGlobalCheckpoint()) + " but was: " + getGlobalCheckpoint()___        _        assert !primaryMode_                || getGlobalCheckpoint() <= inSyncCheckpointStates(checkpoints, CheckpointState::getLocalCheckpoint, LongStream::min)_                : "global checkpoint [" + getGlobalCheckpoint() + "] "_                + "for primary mode allocation ID [" + shardAllocationId + "] "_                + "more than in-sync local checkpoints [" + checkpoints + "]"___        _        assert (routingTable == null) == (replicationGroup == null) :_            "routing table is " + routingTable + " but replication group is " + replicationGroup___        assert replicationGroup == null || replicationGroup.equals(calculateReplicationGroup()) :_            "cached replication group out of sync: expected: " + calculateReplicationGroup() + " but was: " + replicationGroup___        _        assert routingTable == null || checkpoints.keySet().containsAll(routingTable.getAllAllocationIds()) :_            "local checkpoints " + checkpoints + " not in-sync with routing table " + routingTable___        for (Map.Entry<String, CheckpointState> entry : checkpoints.entrySet()) {_            _            assert !pendingInSync.contains(entry.getKey()) || !entry.getValue().inSync :_                "shard copy " + entry.getKey() + " blocks global checkpoint advancement but is in-sync"__            _            assert !entry.getValue().inSync || entry.getValue().tracked :_                "shard copy " + entry.getKey() + " is in-sync but not tracked"__        }__        _        for (String aId : pendingInSync) {_            assert checkpoints.get(aId) != null : "aId [" + aId + "] is pending in sync but isn't tracked"__        }__        return true__    };class,invariant,that,should,hold,before,and,after,every,invocation,of,public,methods,on,this,class,as,java,lacks,implication,as,a,logical,operator,many,of,the,invariants,are,written,under,the,form,a,b,they,should,be,read,as,a,implies,b,however;private,boolean,invariant,assert,checkpoints,get,shard,allocation,id,null,checkpoints,map,should,always,have,an,entry,for,the,current,shard,assert,primary,mode,checkpoints,values,stream,all,match,lcps,lcps,local,checkpoint,sequence,numbers,lcps,local,checkpoint,sequence,numbers,assert,primary,mode,checkpoints,entry,set,stream,filter,e,e,get,key,equals,shard,allocation,id,false,map,map,entry,get,value,all,match,cps,cps,global,checkpoint,sequence,numbers,cps,global,checkpoint,sequence,numbers,assert,handoff,in,progress,primary,mode,assert,relocated,primary,mode,assert,primary,mode,checkpoints,get,shard,allocation,id,in,sync,assert,primary,mode,routing,table,null,replication,group,null,primary,mode,but,routing,table,is,routing,table,and,replication,group,is,replication,group,assert,primary,mode,routing,table,primary,shard,allocation,id,get,id,equals,shard,allocation,id,routing,table,primary,shard,allocation,id,get,relocation,id,equals,shard,allocation,id,assert,handoff,in,progress,pending,in,sync,is,empty,entries,blocking,global,checkpoint,advancement,during,relocation,handoff,pending,in,sync,assert,pending,in,sync,is,empty,primary,mode,handoff,in,progress,assert,primary,mode,get,global,checkpoint,compute,global,checkpoint,pending,in,sync,checkpoints,values,get,global,checkpoint,global,checkpoint,is,not,up,to,date,expected,compute,global,checkpoint,pending,in,sync,checkpoints,values,get,global,checkpoint,but,was,get,global,checkpoint,assert,primary,mode,get,global,checkpoint,in,sync,checkpoint,states,checkpoints,checkpoint,state,get,local,checkpoint,long,stream,min,global,checkpoint,get,global,checkpoint,for,primary,mode,allocation,id,shard,allocation,id,more,than,in,sync,local,checkpoints,checkpoints,assert,routing,table,null,replication,group,null,routing,table,is,routing,table,but,replication,group,is,replication,group,assert,replication,group,null,replication,group,equals,calculate,replication,group,cached,replication,group,out,of,sync,expected,calculate,replication,group,but,was,replication,group,assert,routing,table,null,checkpoints,key,set,contains,all,routing,table,get,all,allocation,ids,local,checkpoints,checkpoints,not,in,sync,with,routing,table,routing,table,for,map,entry,string,checkpoint,state,entry,checkpoints,entry,set,assert,pending,in,sync,contains,entry,get,key,entry,get,value,in,sync,shard,copy,entry,get,key,blocks,global,checkpoint,advancement,but,is,in,sync,assert,entry,get,value,in,sync,entry,get,value,tracked,shard,copy,entry,get,key,is,in,sync,but,not,tracked,for,string,a,id,pending,in,sync,assert,checkpoints,get,a,id,null,a,id,a,id,is,pending,in,sync,but,isn,t,tracked,return,true
ReplicationTracker -> private boolean invariant();1548594827;Class invariant that should hold before and after every invocation of public methods on this class. As Java lacks implication_as a logical operator, many of the invariants are written under the form (!A || B), they should be read as (A implies B) however.;private boolean invariant() {_        assert checkpoints.get(shardAllocationId) != null :_            "checkpoints map should always have an entry for the current shard"___        _        assert primaryMode || checkpoints.values().stream()_            .allMatch(lcps -> lcps.localCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO ||_                lcps.localCheckpoint == SequenceNumbers.PRE_60_NODE_CHECKPOINT)___        _        assert primaryMode_                || checkpoints_                .entrySet()_                .stream()_                .filter(e -> e.getKey().equals(shardAllocationId) == false)_                .map(Map.Entry::getValue)_                .allMatch(cps ->_                        (cps.globalCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO_                                || cps.globalCheckpoint == SequenceNumbers.PRE_60_NODE_CHECKPOINT))___        _        assert !handoffInProgress || primaryMode___        _        assert !relocated || !primaryMode___        _        assert !primaryMode || checkpoints.get(shardAllocationId).inSync___        _        assert !primaryMode || (routingTable != null && replicationGroup != null) :_            "primary mode but routing table is " + routingTable + " and replication group is " + replicationGroup___        _        assert !primaryMode_                || (routingTable.primaryShard().allocationId().getId().equals(shardAllocationId)_                || routingTable.primaryShard().allocationId().getRelocationId().equals(shardAllocationId))___        _        assert !handoffInProgress || pendingInSync.isEmpty() :_            "entries blocking global checkpoint advancement during relocation handoff: " + pendingInSync___        _        assert pendingInSync.isEmpty() || (primaryMode && !handoffInProgress)___        _        assert !primaryMode_                || getGlobalCheckpoint() == computeGlobalCheckpoint(pendingInSync, checkpoints.values(), getGlobalCheckpoint())_                : "global checkpoint is not up-to-date, expected: " +_                computeGlobalCheckpoint(pendingInSync, checkpoints.values(), getGlobalCheckpoint()) + " but was: " + getGlobalCheckpoint()___        _        assert !primaryMode_                || getGlobalCheckpoint() <= inSyncCheckpointStates(checkpoints, CheckpointState::getLocalCheckpoint, LongStream::min)_                : "global checkpoint [" + getGlobalCheckpoint() + "] "_                + "for primary mode allocation ID [" + shardAllocationId + "] "_                + "more than in-sync local checkpoints [" + checkpoints + "]"___        _        assert (routingTable == null) == (replicationGroup == null) :_            "routing table is " + routingTable + " but replication group is " + replicationGroup___        assert replicationGroup == null || replicationGroup.equals(calculateReplicationGroup()) :_            "cached replication group out of sync: expected: " + calculateReplicationGroup() + " but was: " + replicationGroup___        _        assert routingTable == null || checkpoints.keySet().containsAll(routingTable.getAllAllocationIds()) :_            "local checkpoints " + checkpoints + " not in-sync with routing table " + routingTable___        for (Map.Entry<String, CheckpointState> entry : checkpoints.entrySet()) {_            _            assert !pendingInSync.contains(entry.getKey()) || !entry.getValue().inSync :_                "shard copy " + entry.getKey() + " blocks global checkpoint advancement but is in-sync"__            _            assert !entry.getValue().inSync || entry.getValue().tracked :_                "shard copy " + entry.getKey() + " is in-sync but not tracked"__        }__        _        for (String aId : pendingInSync) {_            assert checkpoints.get(aId) != null : "aId [" + aId + "] is pending in sync but isn't tracked"__        }__        return true__    };class,invariant,that,should,hold,before,and,after,every,invocation,of,public,methods,on,this,class,as,java,lacks,implication,as,a,logical,operator,many,of,the,invariants,are,written,under,the,form,a,b,they,should,be,read,as,a,implies,b,however;private,boolean,invariant,assert,checkpoints,get,shard,allocation,id,null,checkpoints,map,should,always,have,an,entry,for,the,current,shard,assert,primary,mode,checkpoints,values,stream,all,match,lcps,lcps,local,checkpoint,sequence,numbers,lcps,local,checkpoint,sequence,numbers,assert,primary,mode,checkpoints,entry,set,stream,filter,e,e,get,key,equals,shard,allocation,id,false,map,map,entry,get,value,all,match,cps,cps,global,checkpoint,sequence,numbers,cps,global,checkpoint,sequence,numbers,assert,handoff,in,progress,primary,mode,assert,relocated,primary,mode,assert,primary,mode,checkpoints,get,shard,allocation,id,in,sync,assert,primary,mode,routing,table,null,replication,group,null,primary,mode,but,routing,table,is,routing,table,and,replication,group,is,replication,group,assert,primary,mode,routing,table,primary,shard,allocation,id,get,id,equals,shard,allocation,id,routing,table,primary,shard,allocation,id,get,relocation,id,equals,shard,allocation,id,assert,handoff,in,progress,pending,in,sync,is,empty,entries,blocking,global,checkpoint,advancement,during,relocation,handoff,pending,in,sync,assert,pending,in,sync,is,empty,primary,mode,handoff,in,progress,assert,primary,mode,get,global,checkpoint,compute,global,checkpoint,pending,in,sync,checkpoints,values,get,global,checkpoint,global,checkpoint,is,not,up,to,date,expected,compute,global,checkpoint,pending,in,sync,checkpoints,values,get,global,checkpoint,but,was,get,global,checkpoint,assert,primary,mode,get,global,checkpoint,in,sync,checkpoint,states,checkpoints,checkpoint,state,get,local,checkpoint,long,stream,min,global,checkpoint,get,global,checkpoint,for,primary,mode,allocation,id,shard,allocation,id,more,than,in,sync,local,checkpoints,checkpoints,assert,routing,table,null,replication,group,null,routing,table,is,routing,table,but,replication,group,is,replication,group,assert,replication,group,null,replication,group,equals,calculate,replication,group,cached,replication,group,out,of,sync,expected,calculate,replication,group,but,was,replication,group,assert,routing,table,null,checkpoints,key,set,contains,all,routing,table,get,all,allocation,ids,local,checkpoints,checkpoints,not,in,sync,with,routing,table,routing,table,for,map,entry,string,checkpoint,state,entry,checkpoints,entry,set,assert,pending,in,sync,contains,entry,get,key,entry,get,value,in,sync,shard,copy,entry,get,key,blocks,global,checkpoint,advancement,but,is,in,sync,assert,entry,get,value,in,sync,entry,get,value,tracked,shard,copy,entry,get,key,is,in,sync,but,not,tracked,for,string,a,id,pending,in,sync,assert,checkpoints,get,a,id,null,a,id,a,id,is,pending,in,sync,but,isn,t,tracked,return,true
ReplicationTracker -> private boolean invariant();1548677511;Class invariant that should hold before and after every invocation of public methods on this class. As Java lacks implication_as a logical operator, many of the invariants are written under the form (!A || B), they should be read as (A implies B) however.;private boolean invariant() {_        assert checkpoints.get(shardAllocationId) != null :_            "checkpoints map should always have an entry for the current shard"___        _        assert primaryMode || checkpoints.values().stream()_            .allMatch(lcps -> lcps.localCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO ||_                lcps.localCheckpoint == SequenceNumbers.PRE_60_NODE_CHECKPOINT)___        _        assert primaryMode_                || checkpoints_                .entrySet()_                .stream()_                .filter(e -> e.getKey().equals(shardAllocationId) == false)_                .map(Map.Entry::getValue)_                .allMatch(cps ->_                        (cps.globalCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO_                                || cps.globalCheckpoint == SequenceNumbers.PRE_60_NODE_CHECKPOINT))___        _        assert !handoffInProgress || primaryMode___        _        assert !relocated || !primaryMode___        _        assert !primaryMode || checkpoints.get(shardAllocationId).inSync___        _        assert !primaryMode || (routingTable != null && replicationGroup != null) :_            "primary mode but routing table is " + routingTable + " and replication group is " + replicationGroup___        _        assert !primaryMode_                || (routingTable.primaryShard().allocationId().getId().equals(shardAllocationId)_                || routingTable.primaryShard().allocationId().getRelocationId().equals(shardAllocationId))___        _        assert !handoffInProgress || pendingInSync.isEmpty() :_            "entries blocking global checkpoint advancement during relocation handoff: " + pendingInSync___        _        assert pendingInSync.isEmpty() || (primaryMode && !handoffInProgress)___        _        assert !primaryMode_                || getGlobalCheckpoint() == computeGlobalCheckpoint(pendingInSync, checkpoints.values(), getGlobalCheckpoint())_                : "global checkpoint is not up-to-date, expected: " +_                computeGlobalCheckpoint(pendingInSync, checkpoints.values(), getGlobalCheckpoint()) + " but was: " + getGlobalCheckpoint()___        _        assert !primaryMode_                || getGlobalCheckpoint() <= inSyncCheckpointStates(checkpoints, CheckpointState::getLocalCheckpoint, LongStream::min)_                : "global checkpoint [" + getGlobalCheckpoint() + "] "_                + "for primary mode allocation ID [" + shardAllocationId + "] "_                + "more than in-sync local checkpoints [" + checkpoints + "]"___        _        assert (routingTable == null) == (replicationGroup == null) :_            "routing table is " + routingTable + " but replication group is " + replicationGroup___        assert replicationGroup == null || replicationGroup.equals(calculateReplicationGroup()) :_            "cached replication group out of sync: expected: " + calculateReplicationGroup() + " but was: " + replicationGroup___        _        assert routingTable == null || checkpoints.keySet().containsAll(routingTable.getAllAllocationIds()) :_            "local checkpoints " + checkpoints + " not in-sync with routing table " + routingTable___        for (Map.Entry<String, CheckpointState> entry : checkpoints.entrySet()) {_            _            assert !pendingInSync.contains(entry.getKey()) || !entry.getValue().inSync :_                "shard copy " + entry.getKey() + " blocks global checkpoint advancement but is in-sync"__            _            assert !entry.getValue().inSync || entry.getValue().tracked :_                "shard copy " + entry.getKey() + " is in-sync but not tracked"__        }__        _        for (String aId : pendingInSync) {_            assert checkpoints.get(aId) != null : "aId [" + aId + "] is pending in sync but isn't tracked"__        }__        return true__    };class,invariant,that,should,hold,before,and,after,every,invocation,of,public,methods,on,this,class,as,java,lacks,implication,as,a,logical,operator,many,of,the,invariants,are,written,under,the,form,a,b,they,should,be,read,as,a,implies,b,however;private,boolean,invariant,assert,checkpoints,get,shard,allocation,id,null,checkpoints,map,should,always,have,an,entry,for,the,current,shard,assert,primary,mode,checkpoints,values,stream,all,match,lcps,lcps,local,checkpoint,sequence,numbers,lcps,local,checkpoint,sequence,numbers,assert,primary,mode,checkpoints,entry,set,stream,filter,e,e,get,key,equals,shard,allocation,id,false,map,map,entry,get,value,all,match,cps,cps,global,checkpoint,sequence,numbers,cps,global,checkpoint,sequence,numbers,assert,handoff,in,progress,primary,mode,assert,relocated,primary,mode,assert,primary,mode,checkpoints,get,shard,allocation,id,in,sync,assert,primary,mode,routing,table,null,replication,group,null,primary,mode,but,routing,table,is,routing,table,and,replication,group,is,replication,group,assert,primary,mode,routing,table,primary,shard,allocation,id,get,id,equals,shard,allocation,id,routing,table,primary,shard,allocation,id,get,relocation,id,equals,shard,allocation,id,assert,handoff,in,progress,pending,in,sync,is,empty,entries,blocking,global,checkpoint,advancement,during,relocation,handoff,pending,in,sync,assert,pending,in,sync,is,empty,primary,mode,handoff,in,progress,assert,primary,mode,get,global,checkpoint,compute,global,checkpoint,pending,in,sync,checkpoints,values,get,global,checkpoint,global,checkpoint,is,not,up,to,date,expected,compute,global,checkpoint,pending,in,sync,checkpoints,values,get,global,checkpoint,but,was,get,global,checkpoint,assert,primary,mode,get,global,checkpoint,in,sync,checkpoint,states,checkpoints,checkpoint,state,get,local,checkpoint,long,stream,min,global,checkpoint,get,global,checkpoint,for,primary,mode,allocation,id,shard,allocation,id,more,than,in,sync,local,checkpoints,checkpoints,assert,routing,table,null,replication,group,null,routing,table,is,routing,table,but,replication,group,is,replication,group,assert,replication,group,null,replication,group,equals,calculate,replication,group,cached,replication,group,out,of,sync,expected,calculate,replication,group,but,was,replication,group,assert,routing,table,null,checkpoints,key,set,contains,all,routing,table,get,all,allocation,ids,local,checkpoints,checkpoints,not,in,sync,with,routing,table,routing,table,for,map,entry,string,checkpoint,state,entry,checkpoints,entry,set,assert,pending,in,sync,contains,entry,get,key,entry,get,value,in,sync,shard,copy,entry,get,key,blocks,global,checkpoint,advancement,but,is,in,sync,assert,entry,get,value,in,sync,entry,get,value,tracked,shard,copy,entry,get,key,is,in,sync,but,not,tracked,for,string,a,id,pending,in,sync,assert,checkpoints,get,a,id,null,a,id,a,id,is,pending,in,sync,but,isn,t,tracked,return,true
ReplicationTracker -> private boolean invariant();1548944389;Class invariant that should hold before and after every invocation of public methods on this class. As Java lacks implication_as a logical operator, many of the invariants are written under the form (!A || B), they should be read as (A implies B) however.;private boolean invariant() {_        assert checkpoints.get(shardAllocationId) != null :_            "checkpoints map should always have an entry for the current shard"___        _        assert primaryMode || checkpoints.values().stream()_            .allMatch(lcps -> lcps.localCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO ||_                lcps.localCheckpoint == SequenceNumbers.PRE_60_NODE_CHECKPOINT)___        _        assert primaryMode_                || checkpoints_                .entrySet()_                .stream()_                .filter(e -> e.getKey().equals(shardAllocationId) == false)_                .map(Map.Entry::getValue)_                .allMatch(cps ->_                        (cps.globalCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO_                                || cps.globalCheckpoint == SequenceNumbers.PRE_60_NODE_CHECKPOINT))___        _        assert !handoffInProgress || primaryMode___        _        assert !relocated || !primaryMode___        _        assert !primaryMode || checkpoints.get(shardAllocationId).inSync___        _        assert !primaryMode || (routingTable != null && replicationGroup != null) :_            "primary mode but routing table is " + routingTable + " and replication group is " + replicationGroup___        _        assert !primaryMode_                || (routingTable.primaryShard().allocationId().getId().equals(shardAllocationId)_                || routingTable.primaryShard().allocationId().getRelocationId().equals(shardAllocationId))___        _        assert !handoffInProgress || pendingInSync.isEmpty() :_            "entries blocking global checkpoint advancement during relocation handoff: " + pendingInSync___        _        assert pendingInSync.isEmpty() || (primaryMode && !handoffInProgress)___        _        assert !primaryMode_                || getGlobalCheckpoint() == computeGlobalCheckpoint(pendingInSync, checkpoints.values(), getGlobalCheckpoint())_                : "global checkpoint is not up-to-date, expected: " +_                computeGlobalCheckpoint(pendingInSync, checkpoints.values(), getGlobalCheckpoint()) + " but was: " + getGlobalCheckpoint()___        _        assert !primaryMode_                || getGlobalCheckpoint() <= inSyncCheckpointStates(checkpoints, CheckpointState::getLocalCheckpoint, LongStream::min)_                : "global checkpoint [" + getGlobalCheckpoint() + "] "_                + "for primary mode allocation ID [" + shardAllocationId + "] "_                + "more than in-sync local checkpoints [" + checkpoints + "]"___        _        assert (routingTable == null) == (replicationGroup == null) :_            "routing table is " + routingTable + " but replication group is " + replicationGroup___        assert replicationGroup == null || replicationGroup.equals(calculateReplicationGroup()) :_            "cached replication group out of sync: expected: " + calculateReplicationGroup() + " but was: " + replicationGroup___        _        assert routingTable == null || checkpoints.keySet().containsAll(routingTable.getAllAllocationIds()) :_            "local checkpoints " + checkpoints + " not in-sync with routing table " + routingTable___        for (Map.Entry<String, CheckpointState> entry : checkpoints.entrySet()) {_            _            assert !pendingInSync.contains(entry.getKey()) || !entry.getValue().inSync :_                "shard copy " + entry.getKey() + " blocks global checkpoint advancement but is in-sync"__            _            assert !entry.getValue().inSync || entry.getValue().tracked :_                "shard copy " + entry.getKey() + " is in-sync but not tracked"__        }__        _        for (String aId : pendingInSync) {_            assert checkpoints.get(aId) != null : "aId [" + aId + "] is pending in sync but isn't tracked"__        }__        return true__    };class,invariant,that,should,hold,before,and,after,every,invocation,of,public,methods,on,this,class,as,java,lacks,implication,as,a,logical,operator,many,of,the,invariants,are,written,under,the,form,a,b,they,should,be,read,as,a,implies,b,however;private,boolean,invariant,assert,checkpoints,get,shard,allocation,id,null,checkpoints,map,should,always,have,an,entry,for,the,current,shard,assert,primary,mode,checkpoints,values,stream,all,match,lcps,lcps,local,checkpoint,sequence,numbers,lcps,local,checkpoint,sequence,numbers,assert,primary,mode,checkpoints,entry,set,stream,filter,e,e,get,key,equals,shard,allocation,id,false,map,map,entry,get,value,all,match,cps,cps,global,checkpoint,sequence,numbers,cps,global,checkpoint,sequence,numbers,assert,handoff,in,progress,primary,mode,assert,relocated,primary,mode,assert,primary,mode,checkpoints,get,shard,allocation,id,in,sync,assert,primary,mode,routing,table,null,replication,group,null,primary,mode,but,routing,table,is,routing,table,and,replication,group,is,replication,group,assert,primary,mode,routing,table,primary,shard,allocation,id,get,id,equals,shard,allocation,id,routing,table,primary,shard,allocation,id,get,relocation,id,equals,shard,allocation,id,assert,handoff,in,progress,pending,in,sync,is,empty,entries,blocking,global,checkpoint,advancement,during,relocation,handoff,pending,in,sync,assert,pending,in,sync,is,empty,primary,mode,handoff,in,progress,assert,primary,mode,get,global,checkpoint,compute,global,checkpoint,pending,in,sync,checkpoints,values,get,global,checkpoint,global,checkpoint,is,not,up,to,date,expected,compute,global,checkpoint,pending,in,sync,checkpoints,values,get,global,checkpoint,but,was,get,global,checkpoint,assert,primary,mode,get,global,checkpoint,in,sync,checkpoint,states,checkpoints,checkpoint,state,get,local,checkpoint,long,stream,min,global,checkpoint,get,global,checkpoint,for,primary,mode,allocation,id,shard,allocation,id,more,than,in,sync,local,checkpoints,checkpoints,assert,routing,table,null,replication,group,null,routing,table,is,routing,table,but,replication,group,is,replication,group,assert,replication,group,null,replication,group,equals,calculate,replication,group,cached,replication,group,out,of,sync,expected,calculate,replication,group,but,was,replication,group,assert,routing,table,null,checkpoints,key,set,contains,all,routing,table,get,all,allocation,ids,local,checkpoints,checkpoints,not,in,sync,with,routing,table,routing,table,for,map,entry,string,checkpoint,state,entry,checkpoints,entry,set,assert,pending,in,sync,contains,entry,get,key,entry,get,value,in,sync,shard,copy,entry,get,key,blocks,global,checkpoint,advancement,but,is,in,sync,assert,entry,get,value,in,sync,entry,get,value,tracked,shard,copy,entry,get,key,is,in,sync,but,not,tracked,for,string,a,id,pending,in,sync,assert,checkpoints,get,a,id,null,a,id,a,id,is,pending,in,sync,but,isn,t,tracked,return,true
ReplicationTracker -> private boolean invariant();1549059559;Class invariant that should hold before and after every invocation of public methods on this class. As Java lacks implication_as a logical operator, many of the invariants are written under the form (!A || B), they should be read as (A implies B) however.;private boolean invariant() {_        assert checkpoints.get(shardAllocationId) != null :_            "checkpoints map should always have an entry for the current shard"___        _        assert primaryMode || checkpoints.values().stream()_            .allMatch(lcps -> lcps.localCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO ||_                lcps.localCheckpoint == SequenceNumbers.PRE_60_NODE_CHECKPOINT)___        _        assert primaryMode_                || checkpoints_                .entrySet()_                .stream()_                .filter(e -> e.getKey().equals(shardAllocationId) == false)_                .map(Map.Entry::getValue)_                .allMatch(cps ->_                        (cps.globalCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO_                                || cps.globalCheckpoint == SequenceNumbers.PRE_60_NODE_CHECKPOINT))___        _        assert !handoffInProgress || primaryMode___        _        assert !relocated || !primaryMode___        _        assert !primaryMode || checkpoints.get(shardAllocationId).inSync___        _        assert !primaryMode || (routingTable != null && replicationGroup != null) :_            "primary mode but routing table is " + routingTable + " and replication group is " + replicationGroup___        _        assert !primaryMode_                || (routingTable.primaryShard().allocationId().getId().equals(shardAllocationId)_                || routingTable.primaryShard().allocationId().getRelocationId().equals(shardAllocationId))___        _        assert !handoffInProgress || pendingInSync.isEmpty() :_            "entries blocking global checkpoint advancement during relocation handoff: " + pendingInSync___        _        assert pendingInSync.isEmpty() || (primaryMode && !handoffInProgress)___        _        assert !primaryMode_                || getGlobalCheckpoint() == computeGlobalCheckpoint(pendingInSync, checkpoints.values(), getGlobalCheckpoint())_                : "global checkpoint is not up-to-date, expected: " +_                computeGlobalCheckpoint(pendingInSync, checkpoints.values(), getGlobalCheckpoint()) + " but was: " + getGlobalCheckpoint()___        _        assert !primaryMode_                || getGlobalCheckpoint() <= inSyncCheckpointStates(checkpoints, CheckpointState::getLocalCheckpoint, LongStream::min)_                : "global checkpoint [" + getGlobalCheckpoint() + "] "_                + "for primary mode allocation ID [" + shardAllocationId + "] "_                + "more than in-sync local checkpoints [" + checkpoints + "]"___        _        assert (routingTable == null) == (replicationGroup == null) :_            "routing table is " + routingTable + " but replication group is " + replicationGroup___        assert replicationGroup == null || replicationGroup.equals(calculateReplicationGroup()) :_            "cached replication group out of sync: expected: " + calculateReplicationGroup() + " but was: " + replicationGroup___        _        assert routingTable == null || checkpoints.keySet().containsAll(routingTable.getAllAllocationIds()) :_            "local checkpoints " + checkpoints + " not in-sync with routing table " + routingTable___        for (Map.Entry<String, CheckpointState> entry : checkpoints.entrySet()) {_            _            assert !pendingInSync.contains(entry.getKey()) || !entry.getValue().inSync :_                "shard copy " + entry.getKey() + " blocks global checkpoint advancement but is in-sync"__            _            assert !entry.getValue().inSync || entry.getValue().tracked :_                "shard copy " + entry.getKey() + " is in-sync but not tracked"__        }__        _        for (String aId : pendingInSync) {_            assert checkpoints.get(aId) != null : "aId [" + aId + "] is pending in sync but isn't tracked"__        }__        return true__    };class,invariant,that,should,hold,before,and,after,every,invocation,of,public,methods,on,this,class,as,java,lacks,implication,as,a,logical,operator,many,of,the,invariants,are,written,under,the,form,a,b,they,should,be,read,as,a,implies,b,however;private,boolean,invariant,assert,checkpoints,get,shard,allocation,id,null,checkpoints,map,should,always,have,an,entry,for,the,current,shard,assert,primary,mode,checkpoints,values,stream,all,match,lcps,lcps,local,checkpoint,sequence,numbers,lcps,local,checkpoint,sequence,numbers,assert,primary,mode,checkpoints,entry,set,stream,filter,e,e,get,key,equals,shard,allocation,id,false,map,map,entry,get,value,all,match,cps,cps,global,checkpoint,sequence,numbers,cps,global,checkpoint,sequence,numbers,assert,handoff,in,progress,primary,mode,assert,relocated,primary,mode,assert,primary,mode,checkpoints,get,shard,allocation,id,in,sync,assert,primary,mode,routing,table,null,replication,group,null,primary,mode,but,routing,table,is,routing,table,and,replication,group,is,replication,group,assert,primary,mode,routing,table,primary,shard,allocation,id,get,id,equals,shard,allocation,id,routing,table,primary,shard,allocation,id,get,relocation,id,equals,shard,allocation,id,assert,handoff,in,progress,pending,in,sync,is,empty,entries,blocking,global,checkpoint,advancement,during,relocation,handoff,pending,in,sync,assert,pending,in,sync,is,empty,primary,mode,handoff,in,progress,assert,primary,mode,get,global,checkpoint,compute,global,checkpoint,pending,in,sync,checkpoints,values,get,global,checkpoint,global,checkpoint,is,not,up,to,date,expected,compute,global,checkpoint,pending,in,sync,checkpoints,values,get,global,checkpoint,but,was,get,global,checkpoint,assert,primary,mode,get,global,checkpoint,in,sync,checkpoint,states,checkpoints,checkpoint,state,get,local,checkpoint,long,stream,min,global,checkpoint,get,global,checkpoint,for,primary,mode,allocation,id,shard,allocation,id,more,than,in,sync,local,checkpoints,checkpoints,assert,routing,table,null,replication,group,null,routing,table,is,routing,table,but,replication,group,is,replication,group,assert,replication,group,null,replication,group,equals,calculate,replication,group,cached,replication,group,out,of,sync,expected,calculate,replication,group,but,was,replication,group,assert,routing,table,null,checkpoints,key,set,contains,all,routing,table,get,all,allocation,ids,local,checkpoints,checkpoints,not,in,sync,with,routing,table,routing,table,for,map,entry,string,checkpoint,state,entry,checkpoints,entry,set,assert,pending,in,sync,contains,entry,get,key,entry,get,value,in,sync,shard,copy,entry,get,key,blocks,global,checkpoint,advancement,but,is,in,sync,assert,entry,get,value,in,sync,entry,get,value,tracked,shard,copy,entry,get,key,is,in,sync,but,not,tracked,for,string,a,id,pending,in,sync,assert,checkpoints,get,a,id,null,a,id,a,id,is,pending,in,sync,but,isn,t,tracked,return,true
ReplicationTracker -> private boolean invariant();1549294529;Class invariant that should hold before and after every invocation of public methods on this class. As Java lacks implication_as a logical operator, many of the invariants are written under the form (!A || B), they should be read as (A implies B) however.;private boolean invariant() {_        assert checkpoints.get(shardAllocationId) != null :_            "checkpoints map should always have an entry for the current shard"___        _        assert primaryMode || checkpoints.values().stream()_            .allMatch(lcps -> lcps.localCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO ||_                lcps.localCheckpoint == SequenceNumbers.PRE_60_NODE_CHECKPOINT)___        _        assert primaryMode_                || checkpoints_                .entrySet()_                .stream()_                .filter(e -> e.getKey().equals(shardAllocationId) == false)_                .map(Map.Entry::getValue)_                .allMatch(cps ->_                        (cps.globalCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO_                                || cps.globalCheckpoint == SequenceNumbers.PRE_60_NODE_CHECKPOINT))___        _        assert !handoffInProgress || primaryMode___        _        assert !relocated || !primaryMode___        _        assert !primaryMode || checkpoints.get(shardAllocationId).inSync___        _        assert !primaryMode || (routingTable != null && replicationGroup != null) :_            "primary mode but routing table is " + routingTable + " and replication group is " + replicationGroup___        _        assert !primaryMode_                || (routingTable.primaryShard().allocationId().getId().equals(shardAllocationId)_                || routingTable.primaryShard().allocationId().getRelocationId().equals(shardAllocationId))___        _        assert !handoffInProgress || pendingInSync.isEmpty() :_            "entries blocking global checkpoint advancement during relocation handoff: " + pendingInSync___        _        assert pendingInSync.isEmpty() || (primaryMode && !handoffInProgress)___        _        assert !primaryMode_                || getGlobalCheckpoint() == computeGlobalCheckpoint(pendingInSync, checkpoints.values(), getGlobalCheckpoint())_                : "global checkpoint is not up-to-date, expected: " +_                computeGlobalCheckpoint(pendingInSync, checkpoints.values(), getGlobalCheckpoint()) + " but was: " + getGlobalCheckpoint()___        _        assert !primaryMode_                || getGlobalCheckpoint() <= inSyncCheckpointStates(checkpoints, CheckpointState::getLocalCheckpoint, LongStream::min)_                : "global checkpoint [" + getGlobalCheckpoint() + "] "_                + "for primary mode allocation ID [" + shardAllocationId + "] "_                + "more than in-sync local checkpoints [" + checkpoints + "]"___        _        assert (routingTable == null) == (replicationGroup == null) :_            "routing table is " + routingTable + " but replication group is " + replicationGroup___        assert replicationGroup == null || replicationGroup.equals(calculateReplicationGroup()) :_            "cached replication group out of sync: expected: " + calculateReplicationGroup() + " but was: " + replicationGroup___        _        assert routingTable == null || checkpoints.keySet().containsAll(routingTable.getAllAllocationIds()) :_            "local checkpoints " + checkpoints + " not in-sync with routing table " + routingTable___        for (Map.Entry<String, CheckpointState> entry : checkpoints.entrySet()) {_            _            assert !pendingInSync.contains(entry.getKey()) || !entry.getValue().inSync :_                "shard copy " + entry.getKey() + " blocks global checkpoint advancement but is in-sync"__            _            assert !entry.getValue().inSync || entry.getValue().tracked :_                "shard copy " + entry.getKey() + " is in-sync but not tracked"__        }__        _        for (String aId : pendingInSync) {_            assert checkpoints.get(aId) != null : "aId [" + aId + "] is pending in sync but isn't tracked"__        }__        return true__    };class,invariant,that,should,hold,before,and,after,every,invocation,of,public,methods,on,this,class,as,java,lacks,implication,as,a,logical,operator,many,of,the,invariants,are,written,under,the,form,a,b,they,should,be,read,as,a,implies,b,however;private,boolean,invariant,assert,checkpoints,get,shard,allocation,id,null,checkpoints,map,should,always,have,an,entry,for,the,current,shard,assert,primary,mode,checkpoints,values,stream,all,match,lcps,lcps,local,checkpoint,sequence,numbers,lcps,local,checkpoint,sequence,numbers,assert,primary,mode,checkpoints,entry,set,stream,filter,e,e,get,key,equals,shard,allocation,id,false,map,map,entry,get,value,all,match,cps,cps,global,checkpoint,sequence,numbers,cps,global,checkpoint,sequence,numbers,assert,handoff,in,progress,primary,mode,assert,relocated,primary,mode,assert,primary,mode,checkpoints,get,shard,allocation,id,in,sync,assert,primary,mode,routing,table,null,replication,group,null,primary,mode,but,routing,table,is,routing,table,and,replication,group,is,replication,group,assert,primary,mode,routing,table,primary,shard,allocation,id,get,id,equals,shard,allocation,id,routing,table,primary,shard,allocation,id,get,relocation,id,equals,shard,allocation,id,assert,handoff,in,progress,pending,in,sync,is,empty,entries,blocking,global,checkpoint,advancement,during,relocation,handoff,pending,in,sync,assert,pending,in,sync,is,empty,primary,mode,handoff,in,progress,assert,primary,mode,get,global,checkpoint,compute,global,checkpoint,pending,in,sync,checkpoints,values,get,global,checkpoint,global,checkpoint,is,not,up,to,date,expected,compute,global,checkpoint,pending,in,sync,checkpoints,values,get,global,checkpoint,but,was,get,global,checkpoint,assert,primary,mode,get,global,checkpoint,in,sync,checkpoint,states,checkpoints,checkpoint,state,get,local,checkpoint,long,stream,min,global,checkpoint,get,global,checkpoint,for,primary,mode,allocation,id,shard,allocation,id,more,than,in,sync,local,checkpoints,checkpoints,assert,routing,table,null,replication,group,null,routing,table,is,routing,table,but,replication,group,is,replication,group,assert,replication,group,null,replication,group,equals,calculate,replication,group,cached,replication,group,out,of,sync,expected,calculate,replication,group,but,was,replication,group,assert,routing,table,null,checkpoints,key,set,contains,all,routing,table,get,all,allocation,ids,local,checkpoints,checkpoints,not,in,sync,with,routing,table,routing,table,for,map,entry,string,checkpoint,state,entry,checkpoints,entry,set,assert,pending,in,sync,contains,entry,get,key,entry,get,value,in,sync,shard,copy,entry,get,key,blocks,global,checkpoint,advancement,but,is,in,sync,assert,entry,get,value,in,sync,entry,get,value,tracked,shard,copy,entry,get,key,is,in,sync,but,not,tracked,for,string,a,id,pending,in,sync,assert,checkpoints,get,a,id,null,a,id,a,id,is,pending,in,sync,but,isn,t,tracked,return,true
ReplicationTracker -> private boolean invariant();1549395737;Class invariant that should hold before and after every invocation of public methods on this class. As Java lacks implication_as a logical operator, many of the invariants are written under the form (!A || B), they should be read as (A implies B) however.;private boolean invariant() {_        assert checkpoints.get(shardAllocationId) != null :_            "checkpoints map should always have an entry for the current shard"___        _        assert primaryMode || checkpoints.values().stream()_            .allMatch(lcps -> lcps.localCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO ||_                lcps.localCheckpoint == SequenceNumbers.PRE_60_NODE_CHECKPOINT)___        _        assert primaryMode_                || checkpoints_                .entrySet()_                .stream()_                .filter(e -> e.getKey().equals(shardAllocationId) == false)_                .map(Map.Entry::getValue)_                .allMatch(cps ->_                        (cps.globalCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO_                                || cps.globalCheckpoint == SequenceNumbers.PRE_60_NODE_CHECKPOINT))___        _        assert !handoffInProgress || primaryMode___        _        assert !relocated || !primaryMode___        _        assert !primaryMode || checkpoints.get(shardAllocationId).inSync___        _        assert !primaryMode || (routingTable != null && replicationGroup != null) :_            "primary mode but routing table is " + routingTable + " and replication group is " + replicationGroup___        _        assert !primaryMode_                || (routingTable.primaryShard().allocationId().getId().equals(shardAllocationId)_                || routingTable.primaryShard().allocationId().getRelocationId().equals(shardAllocationId))___        _        assert !handoffInProgress || pendingInSync.isEmpty() :_            "entries blocking global checkpoint advancement during relocation handoff: " + pendingInSync___        _        assert pendingInSync.isEmpty() || (primaryMode && !handoffInProgress)___        _        assert !primaryMode_                || getGlobalCheckpoint() == computeGlobalCheckpoint(pendingInSync, checkpoints.values(), getGlobalCheckpoint())_                : "global checkpoint is not up-to-date, expected: " +_                computeGlobalCheckpoint(pendingInSync, checkpoints.values(), getGlobalCheckpoint()) + " but was: " + getGlobalCheckpoint()___        _        assert !primaryMode_                || getGlobalCheckpoint() <= inSyncCheckpointStates(checkpoints, CheckpointState::getLocalCheckpoint, LongStream::min)_                : "global checkpoint [" + getGlobalCheckpoint() + "] "_                + "for primary mode allocation ID [" + shardAllocationId + "] "_                + "more than in-sync local checkpoints [" + checkpoints + "]"___        _        assert (routingTable == null) == (replicationGroup == null) :_            "routing table is " + routingTable + " but replication group is " + replicationGroup___        assert replicationGroup == null || replicationGroup.equals(calculateReplicationGroup()) :_            "cached replication group out of sync: expected: " + calculateReplicationGroup() + " but was: " + replicationGroup___        _        assert routingTable == null || checkpoints.keySet().containsAll(routingTable.getAllAllocationIds()) :_            "local checkpoints " + checkpoints + " not in-sync with routing table " + routingTable___        for (Map.Entry<String, CheckpointState> entry : checkpoints.entrySet()) {_            _            assert !pendingInSync.contains(entry.getKey()) || !entry.getValue().inSync :_                "shard copy " + entry.getKey() + " blocks global checkpoint advancement but is in-sync"__            _            assert !entry.getValue().inSync || entry.getValue().tracked :_                "shard copy " + entry.getKey() + " is in-sync but not tracked"__        }__        _        for (String aId : pendingInSync) {_            assert checkpoints.get(aId) != null : "aId [" + aId + "] is pending in sync but isn't tracked"__        }__        return true__    };class,invariant,that,should,hold,before,and,after,every,invocation,of,public,methods,on,this,class,as,java,lacks,implication,as,a,logical,operator,many,of,the,invariants,are,written,under,the,form,a,b,they,should,be,read,as,a,implies,b,however;private,boolean,invariant,assert,checkpoints,get,shard,allocation,id,null,checkpoints,map,should,always,have,an,entry,for,the,current,shard,assert,primary,mode,checkpoints,values,stream,all,match,lcps,lcps,local,checkpoint,sequence,numbers,lcps,local,checkpoint,sequence,numbers,assert,primary,mode,checkpoints,entry,set,stream,filter,e,e,get,key,equals,shard,allocation,id,false,map,map,entry,get,value,all,match,cps,cps,global,checkpoint,sequence,numbers,cps,global,checkpoint,sequence,numbers,assert,handoff,in,progress,primary,mode,assert,relocated,primary,mode,assert,primary,mode,checkpoints,get,shard,allocation,id,in,sync,assert,primary,mode,routing,table,null,replication,group,null,primary,mode,but,routing,table,is,routing,table,and,replication,group,is,replication,group,assert,primary,mode,routing,table,primary,shard,allocation,id,get,id,equals,shard,allocation,id,routing,table,primary,shard,allocation,id,get,relocation,id,equals,shard,allocation,id,assert,handoff,in,progress,pending,in,sync,is,empty,entries,blocking,global,checkpoint,advancement,during,relocation,handoff,pending,in,sync,assert,pending,in,sync,is,empty,primary,mode,handoff,in,progress,assert,primary,mode,get,global,checkpoint,compute,global,checkpoint,pending,in,sync,checkpoints,values,get,global,checkpoint,global,checkpoint,is,not,up,to,date,expected,compute,global,checkpoint,pending,in,sync,checkpoints,values,get,global,checkpoint,but,was,get,global,checkpoint,assert,primary,mode,get,global,checkpoint,in,sync,checkpoint,states,checkpoints,checkpoint,state,get,local,checkpoint,long,stream,min,global,checkpoint,get,global,checkpoint,for,primary,mode,allocation,id,shard,allocation,id,more,than,in,sync,local,checkpoints,checkpoints,assert,routing,table,null,replication,group,null,routing,table,is,routing,table,but,replication,group,is,replication,group,assert,replication,group,null,replication,group,equals,calculate,replication,group,cached,replication,group,out,of,sync,expected,calculate,replication,group,but,was,replication,group,assert,routing,table,null,checkpoints,key,set,contains,all,routing,table,get,all,allocation,ids,local,checkpoints,checkpoints,not,in,sync,with,routing,table,routing,table,for,map,entry,string,checkpoint,state,entry,checkpoints,entry,set,assert,pending,in,sync,contains,entry,get,key,entry,get,value,in,sync,shard,copy,entry,get,key,blocks,global,checkpoint,advancement,but,is,in,sync,assert,entry,get,value,in,sync,entry,get,value,tracked,shard,copy,entry,get,key,is,in,sync,but,not,tracked,for,string,a,id,pending,in,sync,assert,checkpoints,get,a,id,null,a,id,a,id,is,pending,in,sync,but,isn,t,tracked,return,true
ReplicationTracker -> private boolean invariant();1549937843;Class invariant that should hold before and after every invocation of public methods on this class. As Java lacks implication_as a logical operator, many of the invariants are written under the form (!A || B), they should be read as (A implies B) however.;private boolean invariant() {_        assert checkpoints.get(shardAllocationId) != null :_            "checkpoints map should always have an entry for the current shard"___        _        assert primaryMode || checkpoints.values().stream()_            .allMatch(lcps -> lcps.localCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO ||_                lcps.localCheckpoint == SequenceNumbers.PRE_60_NODE_CHECKPOINT)___        _        assert primaryMode_                || checkpoints_                .entrySet()_                .stream()_                .filter(e -> e.getKey().equals(shardAllocationId) == false)_                .map(Map.Entry::getValue)_                .allMatch(cps ->_                        (cps.globalCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO_                                || cps.globalCheckpoint == SequenceNumbers.PRE_60_NODE_CHECKPOINT))___        _        assert !handoffInProgress || primaryMode___        _        assert !relocated || !primaryMode___        _        assert !primaryMode || checkpoints.get(shardAllocationId).inSync___        _        assert !primaryMode || (routingTable != null && replicationGroup != null) :_            "primary mode but routing table is " + routingTable + " and replication group is " + replicationGroup___        _        assert !primaryMode_                || (routingTable.primaryShard().allocationId().getId().equals(shardAllocationId)_                || routingTable.primaryShard().allocationId().getRelocationId().equals(shardAllocationId))___        _        assert !handoffInProgress || pendingInSync.isEmpty() :_            "entries blocking global checkpoint advancement during relocation handoff: " + pendingInSync___        _        assert pendingInSync.isEmpty() || (primaryMode && !handoffInProgress)___        _        assert !primaryMode_                || getGlobalCheckpoint() == computeGlobalCheckpoint(pendingInSync, checkpoints.values(), getGlobalCheckpoint())_                : "global checkpoint is not up-to-date, expected: " +_                computeGlobalCheckpoint(pendingInSync, checkpoints.values(), getGlobalCheckpoint()) + " but was: " + getGlobalCheckpoint()___        _        assert !primaryMode_                || getGlobalCheckpoint() <= inSyncCheckpointStates(checkpoints, CheckpointState::getLocalCheckpoint, LongStream::min)_                : "global checkpoint [" + getGlobalCheckpoint() + "] "_                + "for primary mode allocation ID [" + shardAllocationId + "] "_                + "more than in-sync local checkpoints [" + checkpoints + "]"___        _        assert (routingTable == null) == (replicationGroup == null) :_            "routing table is " + routingTable + " but replication group is " + replicationGroup___        assert replicationGroup == null || replicationGroup.equals(calculateReplicationGroup()) :_            "cached replication group out of sync: expected: " + calculateReplicationGroup() + " but was: " + replicationGroup___        _        assert routingTable == null || checkpoints.keySet().containsAll(routingTable.getAllAllocationIds()) :_            "local checkpoints " + checkpoints + " not in-sync with routing table " + routingTable___        for (Map.Entry<String, CheckpointState> entry : checkpoints.entrySet()) {_            _            assert !pendingInSync.contains(entry.getKey()) || !entry.getValue().inSync :_                "shard copy " + entry.getKey() + " blocks global checkpoint advancement but is in-sync"__            _            assert !entry.getValue().inSync || entry.getValue().tracked :_                "shard copy " + entry.getKey() + " is in-sync but not tracked"__        }__        _        for (String aId : pendingInSync) {_            assert checkpoints.get(aId) != null : "aId [" + aId + "] is pending in sync but isn't tracked"__        }__        return true__    };class,invariant,that,should,hold,before,and,after,every,invocation,of,public,methods,on,this,class,as,java,lacks,implication,as,a,logical,operator,many,of,the,invariants,are,written,under,the,form,a,b,they,should,be,read,as,a,implies,b,however;private,boolean,invariant,assert,checkpoints,get,shard,allocation,id,null,checkpoints,map,should,always,have,an,entry,for,the,current,shard,assert,primary,mode,checkpoints,values,stream,all,match,lcps,lcps,local,checkpoint,sequence,numbers,lcps,local,checkpoint,sequence,numbers,assert,primary,mode,checkpoints,entry,set,stream,filter,e,e,get,key,equals,shard,allocation,id,false,map,map,entry,get,value,all,match,cps,cps,global,checkpoint,sequence,numbers,cps,global,checkpoint,sequence,numbers,assert,handoff,in,progress,primary,mode,assert,relocated,primary,mode,assert,primary,mode,checkpoints,get,shard,allocation,id,in,sync,assert,primary,mode,routing,table,null,replication,group,null,primary,mode,but,routing,table,is,routing,table,and,replication,group,is,replication,group,assert,primary,mode,routing,table,primary,shard,allocation,id,get,id,equals,shard,allocation,id,routing,table,primary,shard,allocation,id,get,relocation,id,equals,shard,allocation,id,assert,handoff,in,progress,pending,in,sync,is,empty,entries,blocking,global,checkpoint,advancement,during,relocation,handoff,pending,in,sync,assert,pending,in,sync,is,empty,primary,mode,handoff,in,progress,assert,primary,mode,get,global,checkpoint,compute,global,checkpoint,pending,in,sync,checkpoints,values,get,global,checkpoint,global,checkpoint,is,not,up,to,date,expected,compute,global,checkpoint,pending,in,sync,checkpoints,values,get,global,checkpoint,but,was,get,global,checkpoint,assert,primary,mode,get,global,checkpoint,in,sync,checkpoint,states,checkpoints,checkpoint,state,get,local,checkpoint,long,stream,min,global,checkpoint,get,global,checkpoint,for,primary,mode,allocation,id,shard,allocation,id,more,than,in,sync,local,checkpoints,checkpoints,assert,routing,table,null,replication,group,null,routing,table,is,routing,table,but,replication,group,is,replication,group,assert,replication,group,null,replication,group,equals,calculate,replication,group,cached,replication,group,out,of,sync,expected,calculate,replication,group,but,was,replication,group,assert,routing,table,null,checkpoints,key,set,contains,all,routing,table,get,all,allocation,ids,local,checkpoints,checkpoints,not,in,sync,with,routing,table,routing,table,for,map,entry,string,checkpoint,state,entry,checkpoints,entry,set,assert,pending,in,sync,contains,entry,get,key,entry,get,value,in,sync,shard,copy,entry,get,key,blocks,global,checkpoint,advancement,but,is,in,sync,assert,entry,get,value,in,sync,entry,get,value,tracked,shard,copy,entry,get,key,is,in,sync,but,not,tracked,for,string,a,id,pending,in,sync,assert,checkpoints,get,a,id,null,a,id,a,id,is,pending,in,sync,but,isn,t,tracked,return,true
ReplicationTracker -> private boolean invariant();1549949489;Class invariant that should hold before and after every invocation of public methods on this class. As Java lacks implication_as a logical operator, many of the invariants are written under the form (!A || B), they should be read as (A implies B) however.;private boolean invariant() {_        assert checkpoints.get(shardAllocationId) != null :_            "checkpoints map should always have an entry for the current shard"___        _        assert primaryMode || checkpoints.values().stream()_            .allMatch(lcps -> lcps.localCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO ||_                lcps.localCheckpoint == SequenceNumbers.PRE_60_NODE_CHECKPOINT)___        _        assert primaryMode_                || checkpoints_                .entrySet()_                .stream()_                .filter(e -> e.getKey().equals(shardAllocationId) == false)_                .map(Map.Entry::getValue)_                .allMatch(cps ->_                        (cps.globalCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO_                                || cps.globalCheckpoint == SequenceNumbers.PRE_60_NODE_CHECKPOINT))___        _        assert !handoffInProgress || primaryMode___        _        assert !relocated || !primaryMode___        _        assert !primaryMode || checkpoints.get(shardAllocationId).inSync___        _        assert !primaryMode || (routingTable != null && replicationGroup != null) :_            "primary mode but routing table is " + routingTable + " and replication group is " + replicationGroup___        _        assert !primaryMode_                || (routingTable.primaryShard().allocationId().getId().equals(shardAllocationId)_                || routingTable.primaryShard().allocationId().getRelocationId().equals(shardAllocationId))___        _        assert !handoffInProgress || pendingInSync.isEmpty() :_            "entries blocking global checkpoint advancement during relocation handoff: " + pendingInSync___        _        assert pendingInSync.isEmpty() || (primaryMode && !handoffInProgress)___        _        assert !primaryMode_                || getGlobalCheckpoint() == computeGlobalCheckpoint(pendingInSync, checkpoints.values(), getGlobalCheckpoint())_                : "global checkpoint is not up-to-date, expected: " +_                computeGlobalCheckpoint(pendingInSync, checkpoints.values(), getGlobalCheckpoint()) + " but was: " + getGlobalCheckpoint()___        _        assert !primaryMode_                || getGlobalCheckpoint() <= inSyncCheckpointStates(checkpoints, CheckpointState::getLocalCheckpoint, LongStream::min)_                : "global checkpoint [" + getGlobalCheckpoint() + "] "_                + "for primary mode allocation ID [" + shardAllocationId + "] "_                + "more than in-sync local checkpoints [" + checkpoints + "]"___        _        assert (routingTable == null) == (replicationGroup == null) :_            "routing table is " + routingTable + " but replication group is " + replicationGroup___        assert replicationGroup == null || replicationGroup.equals(calculateReplicationGroup()) :_            "cached replication group out of sync: expected: " + calculateReplicationGroup() + " but was: " + replicationGroup___        _        assert routingTable == null || checkpoints.keySet().containsAll(routingTable.getAllAllocationIds()) :_            "local checkpoints " + checkpoints + " not in-sync with routing table " + routingTable___        for (Map.Entry<String, CheckpointState> entry : checkpoints.entrySet()) {_            _            assert !pendingInSync.contains(entry.getKey()) || !entry.getValue().inSync :_                "shard copy " + entry.getKey() + " blocks global checkpoint advancement but is in-sync"__            _            assert !entry.getValue().inSync || entry.getValue().tracked :_                "shard copy " + entry.getKey() + " is in-sync but not tracked"__        }__        _        for (String aId : pendingInSync) {_            assert checkpoints.get(aId) != null : "aId [" + aId + "] is pending in sync but isn't tracked"__        }__        return true__    };class,invariant,that,should,hold,before,and,after,every,invocation,of,public,methods,on,this,class,as,java,lacks,implication,as,a,logical,operator,many,of,the,invariants,are,written,under,the,form,a,b,they,should,be,read,as,a,implies,b,however;private,boolean,invariant,assert,checkpoints,get,shard,allocation,id,null,checkpoints,map,should,always,have,an,entry,for,the,current,shard,assert,primary,mode,checkpoints,values,stream,all,match,lcps,lcps,local,checkpoint,sequence,numbers,lcps,local,checkpoint,sequence,numbers,assert,primary,mode,checkpoints,entry,set,stream,filter,e,e,get,key,equals,shard,allocation,id,false,map,map,entry,get,value,all,match,cps,cps,global,checkpoint,sequence,numbers,cps,global,checkpoint,sequence,numbers,assert,handoff,in,progress,primary,mode,assert,relocated,primary,mode,assert,primary,mode,checkpoints,get,shard,allocation,id,in,sync,assert,primary,mode,routing,table,null,replication,group,null,primary,mode,but,routing,table,is,routing,table,and,replication,group,is,replication,group,assert,primary,mode,routing,table,primary,shard,allocation,id,get,id,equals,shard,allocation,id,routing,table,primary,shard,allocation,id,get,relocation,id,equals,shard,allocation,id,assert,handoff,in,progress,pending,in,sync,is,empty,entries,blocking,global,checkpoint,advancement,during,relocation,handoff,pending,in,sync,assert,pending,in,sync,is,empty,primary,mode,handoff,in,progress,assert,primary,mode,get,global,checkpoint,compute,global,checkpoint,pending,in,sync,checkpoints,values,get,global,checkpoint,global,checkpoint,is,not,up,to,date,expected,compute,global,checkpoint,pending,in,sync,checkpoints,values,get,global,checkpoint,but,was,get,global,checkpoint,assert,primary,mode,get,global,checkpoint,in,sync,checkpoint,states,checkpoints,checkpoint,state,get,local,checkpoint,long,stream,min,global,checkpoint,get,global,checkpoint,for,primary,mode,allocation,id,shard,allocation,id,more,than,in,sync,local,checkpoints,checkpoints,assert,routing,table,null,replication,group,null,routing,table,is,routing,table,but,replication,group,is,replication,group,assert,replication,group,null,replication,group,equals,calculate,replication,group,cached,replication,group,out,of,sync,expected,calculate,replication,group,but,was,replication,group,assert,routing,table,null,checkpoints,key,set,contains,all,routing,table,get,all,allocation,ids,local,checkpoints,checkpoints,not,in,sync,with,routing,table,routing,table,for,map,entry,string,checkpoint,state,entry,checkpoints,entry,set,assert,pending,in,sync,contains,entry,get,key,entry,get,value,in,sync,shard,copy,entry,get,key,blocks,global,checkpoint,advancement,but,is,in,sync,assert,entry,get,value,in,sync,entry,get,value,tracked,shard,copy,entry,get,key,is,in,sync,but,not,tracked,for,string,a,id,pending,in,sync,assert,checkpoints,get,a,id,null,a,id,a,id,is,pending,in,sync,but,isn,t,tracked,return,true
ReplicationTracker -> private boolean invariant();1550526771;Class invariant that should hold before and after every invocation of public methods on this class. As Java lacks implication_as a logical operator, many of the invariants are written under the form (!A || B), they should be read as (A implies B) however.;private boolean invariant() {_        assert checkpoints.get(shardAllocationId) != null :_            "checkpoints map should always have an entry for the current shard"___        _        assert primaryMode || checkpoints.values().stream()_            .allMatch(lcps -> lcps.localCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO ||_                lcps.localCheckpoint == SequenceNumbers.PRE_60_NODE_CHECKPOINT)___        _        assert primaryMode_                || checkpoints_                .entrySet()_                .stream()_                .filter(e -> e.getKey().equals(shardAllocationId) == false)_                .map(Map.Entry::getValue)_                .allMatch(cps ->_                        (cps.globalCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO_                                || cps.globalCheckpoint == SequenceNumbers.PRE_60_NODE_CHECKPOINT))___        _        assert !handoffInProgress || primaryMode___        _        assert !relocated || !primaryMode___        _        assert !primaryMode || checkpoints.get(shardAllocationId).inSync___        _        assert !primaryMode || (routingTable != null && replicationGroup != null) :_            "primary mode but routing table is " + routingTable + " and replication group is " + replicationGroup___        _        assert !primaryMode_                || (routingTable.primaryShard().allocationId().getId().equals(shardAllocationId)_                || routingTable.primaryShard().allocationId().getRelocationId().equals(shardAllocationId))___        _        assert !handoffInProgress || pendingInSync.isEmpty() :_            "entries blocking global checkpoint advancement during relocation handoff: " + pendingInSync___        _        assert pendingInSync.isEmpty() || (primaryMode && !handoffInProgress)___        _        assert !primaryMode_                || getGlobalCheckpoint() == computeGlobalCheckpoint(pendingInSync, checkpoints.values(), getGlobalCheckpoint())_                : "global checkpoint is not up-to-date, expected: " +_                computeGlobalCheckpoint(pendingInSync, checkpoints.values(), getGlobalCheckpoint()) + " but was: " + getGlobalCheckpoint()___        _        assert !primaryMode_                || getGlobalCheckpoint() <= inSyncCheckpointStates(checkpoints, CheckpointState::getLocalCheckpoint, LongStream::min)_                : "global checkpoint [" + getGlobalCheckpoint() + "] "_                + "for primary mode allocation ID [" + shardAllocationId + "] "_                + "more than in-sync local checkpoints [" + checkpoints + "]"___        _        assert (routingTable == null) == (replicationGroup == null) :_            "routing table is " + routingTable + " but replication group is " + replicationGroup___        assert replicationGroup == null || replicationGroup.equals(calculateReplicationGroup()) :_            "cached replication group out of sync: expected: " + calculateReplicationGroup() + " but was: " + replicationGroup___        _        assert routingTable == null || checkpoints.keySet().containsAll(routingTable.getAllAllocationIds()) :_            "local checkpoints " + checkpoints + " not in-sync with routing table " + routingTable___        for (Map.Entry<String, CheckpointState> entry : checkpoints.entrySet()) {_            _            assert !pendingInSync.contains(entry.getKey()) || !entry.getValue().inSync :_                "shard copy " + entry.getKey() + " blocks global checkpoint advancement but is in-sync"__            _            assert !entry.getValue().inSync || entry.getValue().tracked :_                "shard copy " + entry.getKey() + " is in-sync but not tracked"__        }__        _        for (String aId : pendingInSync) {_            assert checkpoints.get(aId) != null : "aId [" + aId + "] is pending in sync but isn't tracked"__        }__        return true__    };class,invariant,that,should,hold,before,and,after,every,invocation,of,public,methods,on,this,class,as,java,lacks,implication,as,a,logical,operator,many,of,the,invariants,are,written,under,the,form,a,b,they,should,be,read,as,a,implies,b,however;private,boolean,invariant,assert,checkpoints,get,shard,allocation,id,null,checkpoints,map,should,always,have,an,entry,for,the,current,shard,assert,primary,mode,checkpoints,values,stream,all,match,lcps,lcps,local,checkpoint,sequence,numbers,lcps,local,checkpoint,sequence,numbers,assert,primary,mode,checkpoints,entry,set,stream,filter,e,e,get,key,equals,shard,allocation,id,false,map,map,entry,get,value,all,match,cps,cps,global,checkpoint,sequence,numbers,cps,global,checkpoint,sequence,numbers,assert,handoff,in,progress,primary,mode,assert,relocated,primary,mode,assert,primary,mode,checkpoints,get,shard,allocation,id,in,sync,assert,primary,mode,routing,table,null,replication,group,null,primary,mode,but,routing,table,is,routing,table,and,replication,group,is,replication,group,assert,primary,mode,routing,table,primary,shard,allocation,id,get,id,equals,shard,allocation,id,routing,table,primary,shard,allocation,id,get,relocation,id,equals,shard,allocation,id,assert,handoff,in,progress,pending,in,sync,is,empty,entries,blocking,global,checkpoint,advancement,during,relocation,handoff,pending,in,sync,assert,pending,in,sync,is,empty,primary,mode,handoff,in,progress,assert,primary,mode,get,global,checkpoint,compute,global,checkpoint,pending,in,sync,checkpoints,values,get,global,checkpoint,global,checkpoint,is,not,up,to,date,expected,compute,global,checkpoint,pending,in,sync,checkpoints,values,get,global,checkpoint,but,was,get,global,checkpoint,assert,primary,mode,get,global,checkpoint,in,sync,checkpoint,states,checkpoints,checkpoint,state,get,local,checkpoint,long,stream,min,global,checkpoint,get,global,checkpoint,for,primary,mode,allocation,id,shard,allocation,id,more,than,in,sync,local,checkpoints,checkpoints,assert,routing,table,null,replication,group,null,routing,table,is,routing,table,but,replication,group,is,replication,group,assert,replication,group,null,replication,group,equals,calculate,replication,group,cached,replication,group,out,of,sync,expected,calculate,replication,group,but,was,replication,group,assert,routing,table,null,checkpoints,key,set,contains,all,routing,table,get,all,allocation,ids,local,checkpoints,checkpoints,not,in,sync,with,routing,table,routing,table,for,map,entry,string,checkpoint,state,entry,checkpoints,entry,set,assert,pending,in,sync,contains,entry,get,key,entry,get,value,in,sync,shard,copy,entry,get,key,blocks,global,checkpoint,advancement,but,is,in,sync,assert,entry,get,value,in,sync,entry,get,value,tracked,shard,copy,entry,get,key,is,in,sync,but,not,tracked,for,string,a,id,pending,in,sync,assert,checkpoints,get,a,id,null,a,id,a,id,is,pending,in,sync,but,isn,t,tracked,return,true
ReplicationTracker -> public synchronized void initiateTracking(final String allocationId);1524684173;Called when the recovery process for a shard has opened the engine on the target shard. Ensures that the right data structures_have been set up locally to track local checkpoint information for the shard and that the shard is added to the replication group.__@param allocationId  the allocation ID of the shard for which recovery was initiated;public synchronized void initiateTracking(final String allocationId) {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        CheckpointState cps = checkpoints.get(allocationId)__        if (cps == null) {_            _            throw new IllegalStateException("no local checkpoint tracking information available")__        }_        cps.tracked = true__        replicationGroup = calculateReplicationGroup()__        assert invariant()__    };called,when,the,recovery,process,for,a,shard,has,opened,the,engine,on,the,target,shard,ensures,that,the,right,data,structures,have,been,set,up,locally,to,track,local,checkpoint,information,for,the,shard,and,that,the,shard,is,added,to,the,replication,group,param,allocation,id,the,allocation,id,of,the,shard,for,which,recovery,was,initiated;public,synchronized,void,initiate,tracking,final,string,allocation,id,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,checkpoint,state,cps,checkpoints,get,allocation,id,if,cps,null,throw,new,illegal,state,exception,no,local,checkpoint,tracking,information,available,cps,tracked,true,replication,group,calculate,replication,group,assert,invariant
ReplicationTracker -> public synchronized void initiateTracking(final String allocationId);1525334055;Called when the recovery process for a shard has opened the engine on the target shard. Ensures that the right data structures_have been set up locally to track local checkpoint information for the shard and that the shard is added to the replication group.__@param allocationId  the allocation ID of the shard for which recovery was initiated;public synchronized void initiateTracking(final String allocationId) {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        CheckpointState cps = checkpoints.get(allocationId)__        if (cps == null) {_            _            throw new IllegalStateException("no local checkpoint tracking information available")__        }_        cps.tracked = true__        replicationGroup = calculateReplicationGroup()__        assert invariant()__    };called,when,the,recovery,process,for,a,shard,has,opened,the,engine,on,the,target,shard,ensures,that,the,right,data,structures,have,been,set,up,locally,to,track,local,checkpoint,information,for,the,shard,and,that,the,shard,is,added,to,the,replication,group,param,allocation,id,the,allocation,id,of,the,shard,for,which,recovery,was,initiated;public,synchronized,void,initiate,tracking,final,string,allocation,id,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,checkpoint,state,cps,checkpoints,get,allocation,id,if,cps,null,throw,new,illegal,state,exception,no,local,checkpoint,tracking,information,available,cps,tracked,true,replication,group,calculate,replication,group,assert,invariant
ReplicationTracker -> public synchronized void initiateTracking(final String allocationId);1533295538;Called when the recovery process for a shard has opened the engine on the target shard. Ensures that the right data structures_have been set up locally to track local checkpoint information for the shard and that the shard is added to the replication group.__@param allocationId  the allocation ID of the shard for which recovery was initiated;public synchronized void initiateTracking(final String allocationId) {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        CheckpointState cps = checkpoints.get(allocationId)__        if (cps == null) {_            _            throw new IllegalStateException("no local checkpoint tracking information available")__        }_        cps.tracked = true__        replicationGroup = calculateReplicationGroup()__        assert invariant()__    };called,when,the,recovery,process,for,a,shard,has,opened,the,engine,on,the,target,shard,ensures,that,the,right,data,structures,have,been,set,up,locally,to,track,local,checkpoint,information,for,the,shard,and,that,the,shard,is,added,to,the,replication,group,param,allocation,id,the,allocation,id,of,the,shard,for,which,recovery,was,initiated;public,synchronized,void,initiate,tracking,final,string,allocation,id,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,checkpoint,state,cps,checkpoints,get,allocation,id,if,cps,null,throw,new,illegal,state,exception,no,local,checkpoint,tracking,information,available,cps,tracked,true,replication,group,calculate,replication,group,assert,invariant
ReplicationTracker -> public synchronized void initiateTracking(final String allocationId);1533738061;Called when the recovery process for a shard has opened the engine on the target shard. Ensures that the right data structures_have been set up locally to track local checkpoint information for the shard and that the shard is added to the replication group.__@param allocationId  the allocation ID of the shard for which recovery was initiated;public synchronized void initiateTracking(final String allocationId) {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        CheckpointState cps = checkpoints.get(allocationId)__        if (cps == null) {_            _            throw new IllegalStateException("no local checkpoint tracking information available")__        }_        cps.tracked = true__        replicationGroup = calculateReplicationGroup()__        assert invariant()__    };called,when,the,recovery,process,for,a,shard,has,opened,the,engine,on,the,target,shard,ensures,that,the,right,data,structures,have,been,set,up,locally,to,track,local,checkpoint,information,for,the,shard,and,that,the,shard,is,added,to,the,replication,group,param,allocation,id,the,allocation,id,of,the,shard,for,which,recovery,was,initiated;public,synchronized,void,initiate,tracking,final,string,allocation,id,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,checkpoint,state,cps,checkpoints,get,allocation,id,if,cps,null,throw,new,illegal,state,exception,no,local,checkpoint,tracking,information,available,cps,tracked,true,replication,group,calculate,replication,group,assert,invariant
ReplicationTracker -> public synchronized void initiateTracking(final String allocationId);1546875837;Called when the recovery process for a shard has opened the engine on the target shard. Ensures that the right data structures_have been set up locally to track local checkpoint information for the shard and that the shard is added to the replication group.__@param allocationId  the allocation ID of the shard for which recovery was initiated;public synchronized void initiateTracking(final String allocationId) {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        CheckpointState cps = checkpoints.get(allocationId)__        if (cps == null) {_            _            throw new IllegalStateException("no local checkpoint tracking information available")__        }_        cps.tracked = true__        replicationGroup = calculateReplicationGroup()__        assert invariant()__    };called,when,the,recovery,process,for,a,shard,has,opened,the,engine,on,the,target,shard,ensures,that,the,right,data,structures,have,been,set,up,locally,to,track,local,checkpoint,information,for,the,shard,and,that,the,shard,is,added,to,the,replication,group,param,allocation,id,the,allocation,id,of,the,shard,for,which,recovery,was,initiated;public,synchronized,void,initiate,tracking,final,string,allocation,id,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,checkpoint,state,cps,checkpoints,get,allocation,id,if,cps,null,throw,new,illegal,state,exception,no,local,checkpoint,tracking,information,available,cps,tracked,true,replication,group,calculate,replication,group,assert,invariant
ReplicationTracker -> public synchronized void initiateTracking(final String allocationId);1546927432;Called when the recovery process for a shard has opened the engine on the target shard. Ensures that the right data structures_have been set up locally to track local checkpoint information for the shard and that the shard is added to the replication group.__@param allocationId  the allocation ID of the shard for which recovery was initiated;public synchronized void initiateTracking(final String allocationId) {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        CheckpointState cps = checkpoints.get(allocationId)__        if (cps == null) {_            _            throw new IllegalStateException("no local checkpoint tracking information available")__        }_        cps.tracked = true__        replicationGroup = calculateReplicationGroup()__        assert invariant()__    };called,when,the,recovery,process,for,a,shard,has,opened,the,engine,on,the,target,shard,ensures,that,the,right,data,structures,have,been,set,up,locally,to,track,local,checkpoint,information,for,the,shard,and,that,the,shard,is,added,to,the,replication,group,param,allocation,id,the,allocation,id,of,the,shard,for,which,recovery,was,initiated;public,synchronized,void,initiate,tracking,final,string,allocation,id,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,checkpoint,state,cps,checkpoints,get,allocation,id,if,cps,null,throw,new,illegal,state,exception,no,local,checkpoint,tracking,information,available,cps,tracked,true,replication,group,calculate,replication,group,assert,invariant
ReplicationTracker -> public synchronized void initiateTracking(final String allocationId);1547332999;Called when the recovery process for a shard has opened the engine on the target shard. Ensures that the right data structures_have been set up locally to track local checkpoint information for the shard and that the shard is added to the replication group.__@param allocationId  the allocation ID of the shard for which recovery was initiated;public synchronized void initiateTracking(final String allocationId) {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        CheckpointState cps = checkpoints.get(allocationId)__        if (cps == null) {_            _            throw new IllegalStateException("no local checkpoint tracking information available")__        }_        cps.tracked = true__        replicationGroup = calculateReplicationGroup()__        assert invariant()__    };called,when,the,recovery,process,for,a,shard,has,opened,the,engine,on,the,target,shard,ensures,that,the,right,data,structures,have,been,set,up,locally,to,track,local,checkpoint,information,for,the,shard,and,that,the,shard,is,added,to,the,replication,group,param,allocation,id,the,allocation,id,of,the,shard,for,which,recovery,was,initiated;public,synchronized,void,initiate,tracking,final,string,allocation,id,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,checkpoint,state,cps,checkpoints,get,allocation,id,if,cps,null,throw,new,illegal,state,exception,no,local,checkpoint,tracking,information,available,cps,tracked,true,replication,group,calculate,replication,group,assert,invariant
ReplicationTracker -> public synchronized void initiateTracking(final String allocationId);1548593396;Called when the recovery process for a shard has opened the engine on the target shard. Ensures that the right data structures_have been set up locally to track local checkpoint information for the shard and that the shard is added to the replication group.__@param allocationId  the allocation ID of the shard for which recovery was initiated;public synchronized void initiateTracking(final String allocationId) {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        CheckpointState cps = checkpoints.get(allocationId)__        if (cps == null) {_            _            throw new IllegalStateException("no local checkpoint tracking information available")__        }_        cps.tracked = true__        replicationGroup = calculateReplicationGroup()__        assert invariant()__    };called,when,the,recovery,process,for,a,shard,has,opened,the,engine,on,the,target,shard,ensures,that,the,right,data,structures,have,been,set,up,locally,to,track,local,checkpoint,information,for,the,shard,and,that,the,shard,is,added,to,the,replication,group,param,allocation,id,the,allocation,id,of,the,shard,for,which,recovery,was,initiated;public,synchronized,void,initiate,tracking,final,string,allocation,id,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,checkpoint,state,cps,checkpoints,get,allocation,id,if,cps,null,throw,new,illegal,state,exception,no,local,checkpoint,tracking,information,available,cps,tracked,true,replication,group,calculate,replication,group,assert,invariant
ReplicationTracker -> public synchronized void initiateTracking(final String allocationId);1548594827;Called when the recovery process for a shard has opened the engine on the target shard. Ensures that the right data structures_have been set up locally to track local checkpoint information for the shard and that the shard is added to the replication group.__@param allocationId  the allocation ID of the shard for which recovery was initiated;public synchronized void initiateTracking(final String allocationId) {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        CheckpointState cps = checkpoints.get(allocationId)__        if (cps == null) {_            _            throw new IllegalStateException("no local checkpoint tracking information available")__        }_        cps.tracked = true__        replicationGroup = calculateReplicationGroup()__        assert invariant()__    };called,when,the,recovery,process,for,a,shard,has,opened,the,engine,on,the,target,shard,ensures,that,the,right,data,structures,have,been,set,up,locally,to,track,local,checkpoint,information,for,the,shard,and,that,the,shard,is,added,to,the,replication,group,param,allocation,id,the,allocation,id,of,the,shard,for,which,recovery,was,initiated;public,synchronized,void,initiate,tracking,final,string,allocation,id,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,checkpoint,state,cps,checkpoints,get,allocation,id,if,cps,null,throw,new,illegal,state,exception,no,local,checkpoint,tracking,information,available,cps,tracked,true,replication,group,calculate,replication,group,assert,invariant
ReplicationTracker -> public synchronized void initiateTracking(final String allocationId);1548677511;Called when the recovery process for a shard has opened the engine on the target shard. Ensures that the right data structures_have been set up locally to track local checkpoint information for the shard and that the shard is added to the replication group.__@param allocationId  the allocation ID of the shard for which recovery was initiated;public synchronized void initiateTracking(final String allocationId) {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        CheckpointState cps = checkpoints.get(allocationId)__        if (cps == null) {_            _            throw new IllegalStateException("no local checkpoint tracking information available")__        }_        cps.tracked = true__        replicationGroup = calculateReplicationGroup()__        assert invariant()__    };called,when,the,recovery,process,for,a,shard,has,opened,the,engine,on,the,target,shard,ensures,that,the,right,data,structures,have,been,set,up,locally,to,track,local,checkpoint,information,for,the,shard,and,that,the,shard,is,added,to,the,replication,group,param,allocation,id,the,allocation,id,of,the,shard,for,which,recovery,was,initiated;public,synchronized,void,initiate,tracking,final,string,allocation,id,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,checkpoint,state,cps,checkpoints,get,allocation,id,if,cps,null,throw,new,illegal,state,exception,no,local,checkpoint,tracking,information,available,cps,tracked,true,replication,group,calculate,replication,group,assert,invariant
ReplicationTracker -> public synchronized void initiateTracking(final String allocationId);1548944389;Called when the recovery process for a shard has opened the engine on the target shard. Ensures that the right data structures_have been set up locally to track local checkpoint information for the shard and that the shard is added to the replication group.__@param allocationId  the allocation ID of the shard for which recovery was initiated;public synchronized void initiateTracking(final String allocationId) {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        CheckpointState cps = checkpoints.get(allocationId)__        if (cps == null) {_            _            throw new IllegalStateException("no local checkpoint tracking information available")__        }_        cps.tracked = true__        replicationGroup = calculateReplicationGroup()__        assert invariant()__    };called,when,the,recovery,process,for,a,shard,has,opened,the,engine,on,the,target,shard,ensures,that,the,right,data,structures,have,been,set,up,locally,to,track,local,checkpoint,information,for,the,shard,and,that,the,shard,is,added,to,the,replication,group,param,allocation,id,the,allocation,id,of,the,shard,for,which,recovery,was,initiated;public,synchronized,void,initiate,tracking,final,string,allocation,id,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,checkpoint,state,cps,checkpoints,get,allocation,id,if,cps,null,throw,new,illegal,state,exception,no,local,checkpoint,tracking,information,available,cps,tracked,true,replication,group,calculate,replication,group,assert,invariant
ReplicationTracker -> public synchronized void initiateTracking(final String allocationId);1549059559;Called when the recovery process for a shard has opened the engine on the target shard. Ensures that the right data structures_have been set up locally to track local checkpoint information for the shard and that the shard is added to the replication group.__@param allocationId  the allocation ID of the shard for which recovery was initiated;public synchronized void initiateTracking(final String allocationId) {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        CheckpointState cps = checkpoints.get(allocationId)__        if (cps == null) {_            _            throw new IllegalStateException("no local checkpoint tracking information available")__        }_        cps.tracked = true__        replicationGroup = calculateReplicationGroup()__        assert invariant()__    };called,when,the,recovery,process,for,a,shard,has,opened,the,engine,on,the,target,shard,ensures,that,the,right,data,structures,have,been,set,up,locally,to,track,local,checkpoint,information,for,the,shard,and,that,the,shard,is,added,to,the,replication,group,param,allocation,id,the,allocation,id,of,the,shard,for,which,recovery,was,initiated;public,synchronized,void,initiate,tracking,final,string,allocation,id,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,checkpoint,state,cps,checkpoints,get,allocation,id,if,cps,null,throw,new,illegal,state,exception,no,local,checkpoint,tracking,information,available,cps,tracked,true,replication,group,calculate,replication,group,assert,invariant
ReplicationTracker -> public synchronized void initiateTracking(final String allocationId);1549294529;Called when the recovery process for a shard has opened the engine on the target shard. Ensures that the right data structures_have been set up locally to track local checkpoint information for the shard and that the shard is added to the replication group.__@param allocationId  the allocation ID of the shard for which recovery was initiated;public synchronized void initiateTracking(final String allocationId) {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        CheckpointState cps = checkpoints.get(allocationId)__        if (cps == null) {_            _            throw new IllegalStateException("no local checkpoint tracking information available")__        }_        cps.tracked = true__        replicationGroup = calculateReplicationGroup()__        assert invariant()__    };called,when,the,recovery,process,for,a,shard,has,opened,the,engine,on,the,target,shard,ensures,that,the,right,data,structures,have,been,set,up,locally,to,track,local,checkpoint,information,for,the,shard,and,that,the,shard,is,added,to,the,replication,group,param,allocation,id,the,allocation,id,of,the,shard,for,which,recovery,was,initiated;public,synchronized,void,initiate,tracking,final,string,allocation,id,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,checkpoint,state,cps,checkpoints,get,allocation,id,if,cps,null,throw,new,illegal,state,exception,no,local,checkpoint,tracking,information,available,cps,tracked,true,replication,group,calculate,replication,group,assert,invariant
ReplicationTracker -> public synchronized void initiateTracking(final String allocationId);1549395737;Called when the recovery process for a shard has opened the engine on the target shard. Ensures that the right data structures_have been set up locally to track local checkpoint information for the shard and that the shard is added to the replication group.__@param allocationId  the allocation ID of the shard for which recovery was initiated;public synchronized void initiateTracking(final String allocationId) {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        CheckpointState cps = checkpoints.get(allocationId)__        if (cps == null) {_            _            throw new IllegalStateException("no local checkpoint tracking information available")__        }_        cps.tracked = true__        replicationGroup = calculateReplicationGroup()__        assert invariant()__    };called,when,the,recovery,process,for,a,shard,has,opened,the,engine,on,the,target,shard,ensures,that,the,right,data,structures,have,been,set,up,locally,to,track,local,checkpoint,information,for,the,shard,and,that,the,shard,is,added,to,the,replication,group,param,allocation,id,the,allocation,id,of,the,shard,for,which,recovery,was,initiated;public,synchronized,void,initiate,tracking,final,string,allocation,id,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,checkpoint,state,cps,checkpoints,get,allocation,id,if,cps,null,throw,new,illegal,state,exception,no,local,checkpoint,tracking,information,available,cps,tracked,true,replication,group,calculate,replication,group,assert,invariant
ReplicationTracker -> public synchronized void initiateTracking(final String allocationId);1549937843;Called when the recovery process for a shard has opened the engine on the target shard. Ensures that the right data structures_have been set up locally to track local checkpoint information for the shard and that the shard is added to the replication group.__@param allocationId  the allocation ID of the shard for which recovery was initiated;public synchronized void initiateTracking(final String allocationId) {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        CheckpointState cps = checkpoints.get(allocationId)__        if (cps == null) {_            _            throw new IllegalStateException("no local checkpoint tracking information available")__        }_        cps.tracked = true__        replicationGroup = calculateReplicationGroup()__        assert invariant()__    };called,when,the,recovery,process,for,a,shard,has,opened,the,engine,on,the,target,shard,ensures,that,the,right,data,structures,have,been,set,up,locally,to,track,local,checkpoint,information,for,the,shard,and,that,the,shard,is,added,to,the,replication,group,param,allocation,id,the,allocation,id,of,the,shard,for,which,recovery,was,initiated;public,synchronized,void,initiate,tracking,final,string,allocation,id,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,checkpoint,state,cps,checkpoints,get,allocation,id,if,cps,null,throw,new,illegal,state,exception,no,local,checkpoint,tracking,information,available,cps,tracked,true,replication,group,calculate,replication,group,assert,invariant
ReplicationTracker -> public synchronized void initiateTracking(final String allocationId);1549949489;Called when the recovery process for a shard has opened the engine on the target shard. Ensures that the right data structures_have been set up locally to track local checkpoint information for the shard and that the shard is added to the replication group.__@param allocationId  the allocation ID of the shard for which recovery was initiated;public synchronized void initiateTracking(final String allocationId) {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        CheckpointState cps = checkpoints.get(allocationId)__        if (cps == null) {_            _            throw new IllegalStateException("no local checkpoint tracking information available")__        }_        cps.tracked = true__        replicationGroup = calculateReplicationGroup()__        assert invariant()__    };called,when,the,recovery,process,for,a,shard,has,opened,the,engine,on,the,target,shard,ensures,that,the,right,data,structures,have,been,set,up,locally,to,track,local,checkpoint,information,for,the,shard,and,that,the,shard,is,added,to,the,replication,group,param,allocation,id,the,allocation,id,of,the,shard,for,which,recovery,was,initiated;public,synchronized,void,initiate,tracking,final,string,allocation,id,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,checkpoint,state,cps,checkpoints,get,allocation,id,if,cps,null,throw,new,illegal,state,exception,no,local,checkpoint,tracking,information,available,cps,tracked,true,replication,group,calculate,replication,group,assert,invariant
ReplicationTracker -> public synchronized void initiateTracking(final String allocationId);1550526771;Called when the recovery process for a shard has opened the engine on the target shard. Ensures that the right data structures_have been set up locally to track local checkpoint information for the shard and that the shard is added to the replication group.__@param allocationId  the allocation ID of the shard for which recovery was initiated;public synchronized void initiateTracking(final String allocationId) {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        CheckpointState cps = checkpoints.get(allocationId)__        if (cps == null) {_            _            throw new IllegalStateException("no local checkpoint tracking information available")__        }_        cps.tracked = true__        replicationGroup = calculateReplicationGroup()__        assert invariant()__    };called,when,the,recovery,process,for,a,shard,has,opened,the,engine,on,the,target,shard,ensures,that,the,right,data,structures,have,been,set,up,locally,to,track,local,checkpoint,information,for,the,shard,and,that,the,shard,is,added,to,the,replication,group,param,allocation,id,the,allocation,id,of,the,shard,for,which,recovery,was,initiated;public,synchronized,void,initiate,tracking,final,string,allocation,id,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,checkpoint,state,cps,checkpoints,get,allocation,id,if,cps,null,throw,new,illegal,state,exception,no,local,checkpoint,tracking,information,available,cps,tracked,true,replication,group,calculate,replication,group,assert,invariant
ReplicationTracker -> public synchronized ObjectLongMap<String> getInSyncGlobalCheckpoints();1524684173;Get the local knowledge of the global checkpoints for all in-sync allocation IDs.__@return a map from allocation ID to the local knowledge of the global checkpoint for that allocation ID;public synchronized ObjectLongMap<String> getInSyncGlobalCheckpoints() {_        assert primaryMode__        assert handoffInProgress == false__        final ObjectLongMap<String> globalCheckpoints = new ObjectLongHashMap<>(checkpoints.size())_ _        checkpoints_                .entrySet()_                .stream()_                .filter(e -> e.getValue().inSync)_                .forEach(e -> globalCheckpoints.put(e.getKey(), e.getValue().globalCheckpoint))__        return globalCheckpoints__    };get,the,local,knowledge,of,the,global,checkpoints,for,all,in,sync,allocation,ids,return,a,map,from,allocation,id,to,the,local,knowledge,of,the,global,checkpoint,for,that,allocation,id;public,synchronized,object,long,map,string,get,in,sync,global,checkpoints,assert,primary,mode,assert,handoff,in,progress,false,final,object,long,map,string,global,checkpoints,new,object,long,hash,map,checkpoints,size,checkpoints,entry,set,stream,filter,e,e,get,value,in,sync,for,each,e,global,checkpoints,put,e,get,key,e,get,value,global,checkpoint,return,global,checkpoints
ReplicationTracker -> public synchronized ObjectLongMap<String> getInSyncGlobalCheckpoints();1525334055;Get the local knowledge of the global checkpoints for all in-sync allocation IDs.__@return a map from allocation ID to the local knowledge of the global checkpoint for that allocation ID;public synchronized ObjectLongMap<String> getInSyncGlobalCheckpoints() {_        assert primaryMode__        assert handoffInProgress == false__        final ObjectLongMap<String> globalCheckpoints = new ObjectLongHashMap<>(checkpoints.size())_ _        checkpoints_                .entrySet()_                .stream()_                .filter(e -> e.getValue().inSync)_                .forEach(e -> globalCheckpoints.put(e.getKey(), e.getValue().globalCheckpoint))__        return globalCheckpoints__    };get,the,local,knowledge,of,the,global,checkpoints,for,all,in,sync,allocation,ids,return,a,map,from,allocation,id,to,the,local,knowledge,of,the,global,checkpoint,for,that,allocation,id;public,synchronized,object,long,map,string,get,in,sync,global,checkpoints,assert,primary,mode,assert,handoff,in,progress,false,final,object,long,map,string,global,checkpoints,new,object,long,hash,map,checkpoints,size,checkpoints,entry,set,stream,filter,e,e,get,value,in,sync,for,each,e,global,checkpoints,put,e,get,key,e,get,value,global,checkpoint,return,global,checkpoints
ReplicationTracker -> public synchronized ObjectLongMap<String> getInSyncGlobalCheckpoints();1533295538;Get the local knowledge of the global checkpoints for all in-sync allocation IDs.__@return a map from allocation ID to the local knowledge of the global checkpoint for that allocation ID;public synchronized ObjectLongMap<String> getInSyncGlobalCheckpoints() {_        assert primaryMode__        assert handoffInProgress == false__        final ObjectLongMap<String> globalCheckpoints = new ObjectLongHashMap<>(checkpoints.size())_ _        checkpoints_                .entrySet()_                .stream()_                .filter(e -> e.getValue().inSync)_                .forEach(e -> globalCheckpoints.put(e.getKey(), e.getValue().globalCheckpoint))__        return globalCheckpoints__    };get,the,local,knowledge,of,the,global,checkpoints,for,all,in,sync,allocation,ids,return,a,map,from,allocation,id,to,the,local,knowledge,of,the,global,checkpoint,for,that,allocation,id;public,synchronized,object,long,map,string,get,in,sync,global,checkpoints,assert,primary,mode,assert,handoff,in,progress,false,final,object,long,map,string,global,checkpoints,new,object,long,hash,map,checkpoints,size,checkpoints,entry,set,stream,filter,e,e,get,value,in,sync,for,each,e,global,checkpoints,put,e,get,key,e,get,value,global,checkpoint,return,global,checkpoints
ReplicationTracker -> public synchronized ObjectLongMap<String> getInSyncGlobalCheckpoints();1533738061;Get the local knowledge of the global checkpoints for all in-sync allocation IDs.__@return a map from allocation ID to the local knowledge of the global checkpoint for that allocation ID;public synchronized ObjectLongMap<String> getInSyncGlobalCheckpoints() {_        assert primaryMode__        assert handoffInProgress == false__        final ObjectLongMap<String> globalCheckpoints = new ObjectLongHashMap<>(checkpoints.size())_ _        checkpoints_                .entrySet()_                .stream()_                .filter(e -> e.getValue().inSync)_                .forEach(e -> globalCheckpoints.put(e.getKey(), e.getValue().globalCheckpoint))__        return globalCheckpoints__    };get,the,local,knowledge,of,the,global,checkpoints,for,all,in,sync,allocation,ids,return,a,map,from,allocation,id,to,the,local,knowledge,of,the,global,checkpoint,for,that,allocation,id;public,synchronized,object,long,map,string,get,in,sync,global,checkpoints,assert,primary,mode,assert,handoff,in,progress,false,final,object,long,map,string,global,checkpoints,new,object,long,hash,map,checkpoints,size,checkpoints,entry,set,stream,filter,e,e,get,value,in,sync,for,each,e,global,checkpoints,put,e,get,key,e,get,value,global,checkpoint,return,global,checkpoints
ReplicationTracker -> public synchronized ObjectLongMap<String> getInSyncGlobalCheckpoints();1546875837;Get the local knowledge of the global checkpoints for all in-sync allocation IDs.__@return a map from allocation ID to the local knowledge of the global checkpoint for that allocation ID;public synchronized ObjectLongMap<String> getInSyncGlobalCheckpoints() {_        assert primaryMode__        assert handoffInProgress == false__        final ObjectLongMap<String> globalCheckpoints = new ObjectLongHashMap<>(checkpoints.size())_ _        checkpoints_                .entrySet()_                .stream()_                .filter(e -> e.getValue().inSync)_                .forEach(e -> globalCheckpoints.put(e.getKey(), e.getValue().globalCheckpoint))__        return globalCheckpoints__    };get,the,local,knowledge,of,the,global,checkpoints,for,all,in,sync,allocation,ids,return,a,map,from,allocation,id,to,the,local,knowledge,of,the,global,checkpoint,for,that,allocation,id;public,synchronized,object,long,map,string,get,in,sync,global,checkpoints,assert,primary,mode,assert,handoff,in,progress,false,final,object,long,map,string,global,checkpoints,new,object,long,hash,map,checkpoints,size,checkpoints,entry,set,stream,filter,e,e,get,value,in,sync,for,each,e,global,checkpoints,put,e,get,key,e,get,value,global,checkpoint,return,global,checkpoints
ReplicationTracker -> public synchronized ObjectLongMap<String> getInSyncGlobalCheckpoints();1546927432;Get the local knowledge of the global checkpoints for all in-sync allocation IDs.__@return a map from allocation ID to the local knowledge of the global checkpoint for that allocation ID;public synchronized ObjectLongMap<String> getInSyncGlobalCheckpoints() {_        assert primaryMode__        assert handoffInProgress == false__        final ObjectLongMap<String> globalCheckpoints = new ObjectLongHashMap<>(checkpoints.size())_ _        checkpoints_                .entrySet()_                .stream()_                .filter(e -> e.getValue().inSync)_                .forEach(e -> globalCheckpoints.put(e.getKey(), e.getValue().globalCheckpoint))__        return globalCheckpoints__    };get,the,local,knowledge,of,the,global,checkpoints,for,all,in,sync,allocation,ids,return,a,map,from,allocation,id,to,the,local,knowledge,of,the,global,checkpoint,for,that,allocation,id;public,synchronized,object,long,map,string,get,in,sync,global,checkpoints,assert,primary,mode,assert,handoff,in,progress,false,final,object,long,map,string,global,checkpoints,new,object,long,hash,map,checkpoints,size,checkpoints,entry,set,stream,filter,e,e,get,value,in,sync,for,each,e,global,checkpoints,put,e,get,key,e,get,value,global,checkpoint,return,global,checkpoints
ReplicationTracker -> public synchronized ObjectLongMap<String> getInSyncGlobalCheckpoints();1547332999;Get the local knowledge of the global checkpoints for all in-sync allocation IDs.__@return a map from allocation ID to the local knowledge of the global checkpoint for that allocation ID;public synchronized ObjectLongMap<String> getInSyncGlobalCheckpoints() {_        assert primaryMode__        assert handoffInProgress == false__        final ObjectLongMap<String> globalCheckpoints = new ObjectLongHashMap<>(checkpoints.size())_ _        checkpoints_                .entrySet()_                .stream()_                .filter(e -> e.getValue().inSync)_                .forEach(e -> globalCheckpoints.put(e.getKey(), e.getValue().globalCheckpoint))__        return globalCheckpoints__    };get,the,local,knowledge,of,the,global,checkpoints,for,all,in,sync,allocation,ids,return,a,map,from,allocation,id,to,the,local,knowledge,of,the,global,checkpoint,for,that,allocation,id;public,synchronized,object,long,map,string,get,in,sync,global,checkpoints,assert,primary,mode,assert,handoff,in,progress,false,final,object,long,map,string,global,checkpoints,new,object,long,hash,map,checkpoints,size,checkpoints,entry,set,stream,filter,e,e,get,value,in,sync,for,each,e,global,checkpoints,put,e,get,key,e,get,value,global,checkpoint,return,global,checkpoints
ReplicationTracker -> public synchronized ObjectLongMap<String> getInSyncGlobalCheckpoints();1548593396;Get the local knowledge of the global checkpoints for all in-sync allocation IDs.__@return a map from allocation ID to the local knowledge of the global checkpoint for that allocation ID;public synchronized ObjectLongMap<String> getInSyncGlobalCheckpoints() {_        assert primaryMode__        assert handoffInProgress == false__        final ObjectLongMap<String> globalCheckpoints = new ObjectLongHashMap<>(checkpoints.size())_ _        checkpoints_                .entrySet()_                .stream()_                .filter(e -> e.getValue().inSync)_                .forEach(e -> globalCheckpoints.put(e.getKey(), e.getValue().globalCheckpoint))__        return globalCheckpoints__    };get,the,local,knowledge,of,the,global,checkpoints,for,all,in,sync,allocation,ids,return,a,map,from,allocation,id,to,the,local,knowledge,of,the,global,checkpoint,for,that,allocation,id;public,synchronized,object,long,map,string,get,in,sync,global,checkpoints,assert,primary,mode,assert,handoff,in,progress,false,final,object,long,map,string,global,checkpoints,new,object,long,hash,map,checkpoints,size,checkpoints,entry,set,stream,filter,e,e,get,value,in,sync,for,each,e,global,checkpoints,put,e,get,key,e,get,value,global,checkpoint,return,global,checkpoints
ReplicationTracker -> public synchronized ObjectLongMap<String> getInSyncGlobalCheckpoints();1548594827;Get the local knowledge of the global checkpoints for all in-sync allocation IDs.__@return a map from allocation ID to the local knowledge of the global checkpoint for that allocation ID;public synchronized ObjectLongMap<String> getInSyncGlobalCheckpoints() {_        assert primaryMode__        assert handoffInProgress == false__        final ObjectLongMap<String> globalCheckpoints = new ObjectLongHashMap<>(checkpoints.size())_ _        checkpoints_                .entrySet()_                .stream()_                .filter(e -> e.getValue().inSync)_                .forEach(e -> globalCheckpoints.put(e.getKey(), e.getValue().globalCheckpoint))__        return globalCheckpoints__    };get,the,local,knowledge,of,the,global,checkpoints,for,all,in,sync,allocation,ids,return,a,map,from,allocation,id,to,the,local,knowledge,of,the,global,checkpoint,for,that,allocation,id;public,synchronized,object,long,map,string,get,in,sync,global,checkpoints,assert,primary,mode,assert,handoff,in,progress,false,final,object,long,map,string,global,checkpoints,new,object,long,hash,map,checkpoints,size,checkpoints,entry,set,stream,filter,e,e,get,value,in,sync,for,each,e,global,checkpoints,put,e,get,key,e,get,value,global,checkpoint,return,global,checkpoints
ReplicationTracker -> public synchronized ObjectLongMap<String> getInSyncGlobalCheckpoints();1548677511;Get the local knowledge of the global checkpoints for all in-sync allocation IDs.__@return a map from allocation ID to the local knowledge of the global checkpoint for that allocation ID;public synchronized ObjectLongMap<String> getInSyncGlobalCheckpoints() {_        assert primaryMode__        assert handoffInProgress == false__        final ObjectLongMap<String> globalCheckpoints = new ObjectLongHashMap<>(checkpoints.size())_ _        checkpoints_                .entrySet()_                .stream()_                .filter(e -> e.getValue().inSync)_                .forEach(e -> globalCheckpoints.put(e.getKey(), e.getValue().globalCheckpoint))__        return globalCheckpoints__    };get,the,local,knowledge,of,the,global,checkpoints,for,all,in,sync,allocation,ids,return,a,map,from,allocation,id,to,the,local,knowledge,of,the,global,checkpoint,for,that,allocation,id;public,synchronized,object,long,map,string,get,in,sync,global,checkpoints,assert,primary,mode,assert,handoff,in,progress,false,final,object,long,map,string,global,checkpoints,new,object,long,hash,map,checkpoints,size,checkpoints,entry,set,stream,filter,e,e,get,value,in,sync,for,each,e,global,checkpoints,put,e,get,key,e,get,value,global,checkpoint,return,global,checkpoints
ReplicationTracker -> public synchronized ObjectLongMap<String> getInSyncGlobalCheckpoints();1548944389;Get the local knowledge of the global checkpoints for all in-sync allocation IDs.__@return a map from allocation ID to the local knowledge of the global checkpoint for that allocation ID;public synchronized ObjectLongMap<String> getInSyncGlobalCheckpoints() {_        assert primaryMode__        assert handoffInProgress == false__        final ObjectLongMap<String> globalCheckpoints = new ObjectLongHashMap<>(checkpoints.size())_ _        checkpoints_                .entrySet()_                .stream()_                .filter(e -> e.getValue().inSync)_                .forEach(e -> globalCheckpoints.put(e.getKey(), e.getValue().globalCheckpoint))__        return globalCheckpoints__    };get,the,local,knowledge,of,the,global,checkpoints,for,all,in,sync,allocation,ids,return,a,map,from,allocation,id,to,the,local,knowledge,of,the,global,checkpoint,for,that,allocation,id;public,synchronized,object,long,map,string,get,in,sync,global,checkpoints,assert,primary,mode,assert,handoff,in,progress,false,final,object,long,map,string,global,checkpoints,new,object,long,hash,map,checkpoints,size,checkpoints,entry,set,stream,filter,e,e,get,value,in,sync,for,each,e,global,checkpoints,put,e,get,key,e,get,value,global,checkpoint,return,global,checkpoints
ReplicationTracker -> public synchronized ObjectLongMap<String> getInSyncGlobalCheckpoints();1549059559;Get the local knowledge of the global checkpoints for all in-sync allocation IDs.__@return a map from allocation ID to the local knowledge of the global checkpoint for that allocation ID;public synchronized ObjectLongMap<String> getInSyncGlobalCheckpoints() {_        assert primaryMode__        assert handoffInProgress == false__        final ObjectLongMap<String> globalCheckpoints = new ObjectLongHashMap<>(checkpoints.size())_ _        checkpoints_                .entrySet()_                .stream()_                .filter(e -> e.getValue().inSync)_                .forEach(e -> globalCheckpoints.put(e.getKey(), e.getValue().globalCheckpoint))__        return globalCheckpoints__    };get,the,local,knowledge,of,the,global,checkpoints,for,all,in,sync,allocation,ids,return,a,map,from,allocation,id,to,the,local,knowledge,of,the,global,checkpoint,for,that,allocation,id;public,synchronized,object,long,map,string,get,in,sync,global,checkpoints,assert,primary,mode,assert,handoff,in,progress,false,final,object,long,map,string,global,checkpoints,new,object,long,hash,map,checkpoints,size,checkpoints,entry,set,stream,filter,e,e,get,value,in,sync,for,each,e,global,checkpoints,put,e,get,key,e,get,value,global,checkpoint,return,global,checkpoints
ReplicationTracker -> public synchronized ObjectLongMap<String> getInSyncGlobalCheckpoints();1549294529;Get the local knowledge of the global checkpoints for all in-sync allocation IDs.__@return a map from allocation ID to the local knowledge of the global checkpoint for that allocation ID;public synchronized ObjectLongMap<String> getInSyncGlobalCheckpoints() {_        assert primaryMode__        assert handoffInProgress == false__        final ObjectLongMap<String> globalCheckpoints = new ObjectLongHashMap<>(checkpoints.size())_ _        checkpoints_                .entrySet()_                .stream()_                .filter(e -> e.getValue().inSync)_                .forEach(e -> globalCheckpoints.put(e.getKey(), e.getValue().globalCheckpoint))__        return globalCheckpoints__    };get,the,local,knowledge,of,the,global,checkpoints,for,all,in,sync,allocation,ids,return,a,map,from,allocation,id,to,the,local,knowledge,of,the,global,checkpoint,for,that,allocation,id;public,synchronized,object,long,map,string,get,in,sync,global,checkpoints,assert,primary,mode,assert,handoff,in,progress,false,final,object,long,map,string,global,checkpoints,new,object,long,hash,map,checkpoints,size,checkpoints,entry,set,stream,filter,e,e,get,value,in,sync,for,each,e,global,checkpoints,put,e,get,key,e,get,value,global,checkpoint,return,global,checkpoints
ReplicationTracker -> public synchronized ObjectLongMap<String> getInSyncGlobalCheckpoints();1549395737;Get the local knowledge of the global checkpoints for all in-sync allocation IDs.__@return a map from allocation ID to the local knowledge of the global checkpoint for that allocation ID;public synchronized ObjectLongMap<String> getInSyncGlobalCheckpoints() {_        assert primaryMode__        assert handoffInProgress == false__        final ObjectLongMap<String> globalCheckpoints = new ObjectLongHashMap<>(checkpoints.size())_ _        checkpoints_                .entrySet()_                .stream()_                .filter(e -> e.getValue().inSync)_                .forEach(e -> globalCheckpoints.put(e.getKey(), e.getValue().globalCheckpoint))__        return globalCheckpoints__    };get,the,local,knowledge,of,the,global,checkpoints,for,all,in,sync,allocation,ids,return,a,map,from,allocation,id,to,the,local,knowledge,of,the,global,checkpoint,for,that,allocation,id;public,synchronized,object,long,map,string,get,in,sync,global,checkpoints,assert,primary,mode,assert,handoff,in,progress,false,final,object,long,map,string,global,checkpoints,new,object,long,hash,map,checkpoints,size,checkpoints,entry,set,stream,filter,e,e,get,value,in,sync,for,each,e,global,checkpoints,put,e,get,key,e,get,value,global,checkpoint,return,global,checkpoints
ReplicationTracker -> public synchronized ObjectLongMap<String> getInSyncGlobalCheckpoints();1549937843;Get the local knowledge of the global checkpoints for all in-sync allocation IDs.__@return a map from allocation ID to the local knowledge of the global checkpoint for that allocation ID;public synchronized ObjectLongMap<String> getInSyncGlobalCheckpoints() {_        assert primaryMode__        assert handoffInProgress == false__        final ObjectLongMap<String> globalCheckpoints = new ObjectLongHashMap<>(checkpoints.size())_ _        checkpoints_                .entrySet()_                .stream()_                .filter(e -> e.getValue().inSync)_                .forEach(e -> globalCheckpoints.put(e.getKey(), e.getValue().globalCheckpoint))__        return globalCheckpoints__    };get,the,local,knowledge,of,the,global,checkpoints,for,all,in,sync,allocation,ids,return,a,map,from,allocation,id,to,the,local,knowledge,of,the,global,checkpoint,for,that,allocation,id;public,synchronized,object,long,map,string,get,in,sync,global,checkpoints,assert,primary,mode,assert,handoff,in,progress,false,final,object,long,map,string,global,checkpoints,new,object,long,hash,map,checkpoints,size,checkpoints,entry,set,stream,filter,e,e,get,value,in,sync,for,each,e,global,checkpoints,put,e,get,key,e,get,value,global,checkpoint,return,global,checkpoints
ReplicationTracker -> public synchronized ObjectLongMap<String> getInSyncGlobalCheckpoints();1549949489;Get the local knowledge of the global checkpoints for all in-sync allocation IDs.__@return a map from allocation ID to the local knowledge of the global checkpoint for that allocation ID;public synchronized ObjectLongMap<String> getInSyncGlobalCheckpoints() {_        assert primaryMode__        assert handoffInProgress == false__        final ObjectLongMap<String> globalCheckpoints = new ObjectLongHashMap<>(checkpoints.size())_ _        checkpoints_                .entrySet()_                .stream()_                .filter(e -> e.getValue().inSync)_                .forEach(e -> globalCheckpoints.put(e.getKey(), e.getValue().globalCheckpoint))__        return globalCheckpoints__    };get,the,local,knowledge,of,the,global,checkpoints,for,all,in,sync,allocation,ids,return,a,map,from,allocation,id,to,the,local,knowledge,of,the,global,checkpoint,for,that,allocation,id;public,synchronized,object,long,map,string,get,in,sync,global,checkpoints,assert,primary,mode,assert,handoff,in,progress,false,final,object,long,map,string,global,checkpoints,new,object,long,hash,map,checkpoints,size,checkpoints,entry,set,stream,filter,e,e,get,value,in,sync,for,each,e,global,checkpoints,put,e,get,key,e,get,value,global,checkpoint,return,global,checkpoints
ReplicationTracker -> public synchronized ObjectLongMap<String> getInSyncGlobalCheckpoints();1550526771;Get the local knowledge of the global checkpoints for all in-sync allocation IDs.__@return a map from allocation ID to the local knowledge of the global checkpoint for that allocation ID;public synchronized ObjectLongMap<String> getInSyncGlobalCheckpoints() {_        assert primaryMode__        assert handoffInProgress == false__        final ObjectLongMap<String> globalCheckpoints = new ObjectLongHashMap<>(checkpoints.size())_ _        checkpoints_                .entrySet()_                .stream()_                .filter(e -> e.getValue().inSync)_                .forEach(e -> globalCheckpoints.put(e.getKey(), e.getValue().globalCheckpoint))__        return globalCheckpoints__    };get,the,local,knowledge,of,the,global,checkpoints,for,all,in,sync,allocation,ids,return,a,map,from,allocation,id,to,the,local,knowledge,of,the,global,checkpoint,for,that,allocation,id;public,synchronized,object,long,map,string,get,in,sync,global,checkpoints,assert,primary,mode,assert,handoff,in,progress,false,final,object,long,map,string,global,checkpoints,new,object,long,hash,map,checkpoints,size,checkpoints,entry,set,stream,filter,e,e,get,value,in,sync,for,each,e,global,checkpoints,put,e,get,key,e,get,value,global,checkpoint,return,global,checkpoints
ReplicationTracker -> public synchronized void addOrUpdateRetentionLease(final String id, final long retainingSequenceNumber, final String source);1546875837;Adds a new or updates an existing retention lease.__@param id                      the identifier of the retention lease_@param retainingSequenceNumber the retaining sequence number_@param source                  the source of the retention lease;public synchronized void addOrUpdateRetentionLease(final String id, final long retainingSequenceNumber, final String source) {_        assert primaryMode__        retentionLeases.put(id, new RetentionLease(id, retainingSequenceNumber, source))__    };adds,a,new,or,updates,an,existing,retention,lease,param,id,the,identifier,of,the,retention,lease,param,retaining,sequence,number,the,retaining,sequence,number,param,source,the,source,of,the,retention,lease;public,synchronized,void,add,or,update,retention,lease,final,string,id,final,long,retaining,sequence,number,final,string,source,assert,primary,mode,retention,leases,put,id,new,retention,lease,id,retaining,sequence,number,source
ReplicationTracker -> public synchronized void addOrUpdateRetentionLease(final String id, final long retainingSequenceNumber, final String source);1546927432;Adds a new or updates an existing retention lease.__@param id                      the identifier of the retention lease_@param retainingSequenceNumber the retaining sequence number_@param source                  the source of the retention lease;public synchronized void addOrUpdateRetentionLease(final String id, final long retainingSequenceNumber, final String source) {_        assert primaryMode__        retentionLeases.put(id, new RetentionLease(id, retainingSequenceNumber, currentTimeMillisSupplier.getAsLong(), source))__    };adds,a,new,or,updates,an,existing,retention,lease,param,id,the,identifier,of,the,retention,lease,param,retaining,sequence,number,the,retaining,sequence,number,param,source,the,source,of,the,retention,lease;public,synchronized,void,add,or,update,retention,lease,final,string,id,final,long,retaining,sequence,number,final,string,source,assert,primary,mode,retention,leases,put,id,new,retention,lease,id,retaining,sequence,number,current,time,millis,supplier,get,as,long,source
ReplicationTracker -> public synchronized void addOrUpdateRetentionLease(final String id, final long retainingSequenceNumber, final String source);1547332999;Adds a new or updates an existing retention lease.__@param id                      the identifier of the retention lease_@param retainingSequenceNumber the retaining sequence number_@param source                  the source of the retention lease;public synchronized void addOrUpdateRetentionLease(final String id, final long retainingSequenceNumber, final String source) {_        assert primaryMode__        retentionLeases.put(id, new RetentionLease(id, retainingSequenceNumber, currentTimeMillisSupplier.getAsLong(), source))__    };adds,a,new,or,updates,an,existing,retention,lease,param,id,the,identifier,of,the,retention,lease,param,retaining,sequence,number,the,retaining,sequence,number,param,source,the,source,of,the,retention,lease;public,synchronized,void,add,or,update,retention,lease,final,string,id,final,long,retaining,sequence,number,final,string,source,assert,primary,mode,retention,leases,put,id,new,retention,lease,id,retaining,sequence,number,current,time,millis,supplier,get,as,long,source
ReplicationTracker -> public synchronized Tuple<Boolean, RetentionLeases> getRetentionLeases(final boolean expireLeases);1549395737;If the expire leases parameter is false, gets all retention leases tracked on this shard and otherwise first calculates_expiration of existing retention leases, and then gets all non-expired retention leases tracked on this shard. Note that only the_primary shard calculates which leases are expired, and if any have expired, syncs the retention leases to any replicas. If the_expire leases parameter is true, this replication tracker must be in primary mode.__@return a tuple indicating whether or not any retention leases were expired, and the non-expired retention leases;public synchronized Tuple<Boolean, RetentionLeases> getRetentionLeases(final boolean expireLeases) {_        if (expireLeases == false) {_            return Tuple.tuple(false, retentionLeases)__        }_        assert primaryMode__        _        final long currentTimeMillis = currentTimeMillisSupplier.getAsLong()__        final long retentionLeaseMillis = indexSettings.getRetentionLeaseMillis()__        final Map<Boolean, List<RetentionLease>> partitionByExpiration = retentionLeases_                .leases()_                .stream()_                .collect(Collectors.groupingBy(lease -> currentTimeMillis - lease.timestamp() > retentionLeaseMillis))__        if (partitionByExpiration.get(true) == null) {_            _            return Tuple.tuple(false, retentionLeases)__        }_        final Collection<RetentionLease> nonExpiredLeases =_                partitionByExpiration.get(false) != null ? partitionByExpiration.get(false) : Collections.emptyList()__        retentionLeases = new RetentionLeases(operationPrimaryTerm, retentionLeases.version() + 1, nonExpiredLeases)__        return Tuple.tuple(true, retentionLeases)__    };if,the,expire,leases,parameter,is,false,gets,all,retention,leases,tracked,on,this,shard,and,otherwise,first,calculates,expiration,of,existing,retention,leases,and,then,gets,all,non,expired,retention,leases,tracked,on,this,shard,note,that,only,the,primary,shard,calculates,which,leases,are,expired,and,if,any,have,expired,syncs,the,retention,leases,to,any,replicas,if,the,expire,leases,parameter,is,true,this,replication,tracker,must,be,in,primary,mode,return,a,tuple,indicating,whether,or,not,any,retention,leases,were,expired,and,the,non,expired,retention,leases;public,synchronized,tuple,boolean,retention,leases,get,retention,leases,final,boolean,expire,leases,if,expire,leases,false,return,tuple,tuple,false,retention,leases,assert,primary,mode,final,long,current,time,millis,current,time,millis,supplier,get,as,long,final,long,retention,lease,millis,index,settings,get,retention,lease,millis,final,map,boolean,list,retention,lease,partition,by,expiration,retention,leases,leases,stream,collect,collectors,grouping,by,lease,current,time,millis,lease,timestamp,retention,lease,millis,if,partition,by,expiration,get,true,null,return,tuple,tuple,false,retention,leases,final,collection,retention,lease,non,expired,leases,partition,by,expiration,get,false,null,partition,by,expiration,get,false,collections,empty,list,retention,leases,new,retention,leases,operation,primary,term,retention,leases,version,1,non,expired,leases,return,tuple,tuple,true,retention,leases
ReplicationTracker -> public synchronized Tuple<Boolean, RetentionLeases> getRetentionLeases(final boolean expireLeases);1549937843;If the expire leases parameter is false, gets all retention leases tracked on this shard and otherwise first calculates_expiration of existing retention leases, and then gets all non-expired retention leases tracked on this shard. Note that only the_primary shard calculates which leases are expired, and if any have expired, syncs the retention leases to any replicas. If the_expire leases parameter is true, this replication tracker must be in primary mode.__@return a tuple indicating whether or not any retention leases were expired, and the non-expired retention leases;public synchronized Tuple<Boolean, RetentionLeases> getRetentionLeases(final boolean expireLeases) {_        if (expireLeases == false) {_            return Tuple.tuple(false, retentionLeases)__        }_        assert primaryMode__        _        final long currentTimeMillis = currentTimeMillisSupplier.getAsLong()__        final long retentionLeaseMillis = indexSettings.getRetentionLeaseMillis()__        final Map<Boolean, List<RetentionLease>> partitionByExpiration = retentionLeases_                .leases()_                .stream()_                .collect(Collectors.groupingBy(lease -> currentTimeMillis - lease.timestamp() > retentionLeaseMillis))__        if (partitionByExpiration.get(true) == null) {_            _            return Tuple.tuple(false, retentionLeases)__        }_        final Collection<RetentionLease> nonExpiredLeases =_                partitionByExpiration.get(false) != null ? partitionByExpiration.get(false) : Collections.emptyList()__        retentionLeases = new RetentionLeases(operationPrimaryTerm, retentionLeases.version() + 1, nonExpiredLeases)__        return Tuple.tuple(true, retentionLeases)__    };if,the,expire,leases,parameter,is,false,gets,all,retention,leases,tracked,on,this,shard,and,otherwise,first,calculates,expiration,of,existing,retention,leases,and,then,gets,all,non,expired,retention,leases,tracked,on,this,shard,note,that,only,the,primary,shard,calculates,which,leases,are,expired,and,if,any,have,expired,syncs,the,retention,leases,to,any,replicas,if,the,expire,leases,parameter,is,true,this,replication,tracker,must,be,in,primary,mode,return,a,tuple,indicating,whether,or,not,any,retention,leases,were,expired,and,the,non,expired,retention,leases;public,synchronized,tuple,boolean,retention,leases,get,retention,leases,final,boolean,expire,leases,if,expire,leases,false,return,tuple,tuple,false,retention,leases,assert,primary,mode,final,long,current,time,millis,current,time,millis,supplier,get,as,long,final,long,retention,lease,millis,index,settings,get,retention,lease,millis,final,map,boolean,list,retention,lease,partition,by,expiration,retention,leases,leases,stream,collect,collectors,grouping,by,lease,current,time,millis,lease,timestamp,retention,lease,millis,if,partition,by,expiration,get,true,null,return,tuple,tuple,false,retention,leases,final,collection,retention,lease,non,expired,leases,partition,by,expiration,get,false,null,partition,by,expiration,get,false,collections,empty,list,retention,leases,new,retention,leases,operation,primary,term,retention,leases,version,1,non,expired,leases,return,tuple,tuple,true,retention,leases
ReplicationTracker -> public synchronized Tuple<Boolean, RetentionLeases> getRetentionLeases(final boolean expireLeases);1549949489;If the expire leases parameter is false, gets all retention leases tracked on this shard and otherwise first calculates_expiration of existing retention leases, and then gets all non-expired retention leases tracked on this shard. Note that only the_primary shard calculates which leases are expired, and if any have expired, syncs the retention leases to any replicas. If the_expire leases parameter is true, this replication tracker must be in primary mode.__@return a tuple indicating whether or not any retention leases were expired, and the non-expired retention leases;public synchronized Tuple<Boolean, RetentionLeases> getRetentionLeases(final boolean expireLeases) {_        if (expireLeases == false) {_            return Tuple.tuple(false, retentionLeases)__        }_        assert primaryMode__        _        final long currentTimeMillis = currentTimeMillisSupplier.getAsLong()__        final long retentionLeaseMillis = indexSettings.getRetentionLeaseMillis()__        final Map<Boolean, List<RetentionLease>> partitionByExpiration = retentionLeases_                .leases()_                .stream()_                .collect(Collectors.groupingBy(lease -> currentTimeMillis - lease.timestamp() > retentionLeaseMillis))__        if (partitionByExpiration.get(true) == null) {_            _            return Tuple.tuple(false, retentionLeases)__        }_        final Collection<RetentionLease> nonExpiredLeases =_                partitionByExpiration.get(false) != null ? partitionByExpiration.get(false) : Collections.emptyList()__        retentionLeases = new RetentionLeases(operationPrimaryTerm, retentionLeases.version() + 1, nonExpiredLeases)__        return Tuple.tuple(true, retentionLeases)__    };if,the,expire,leases,parameter,is,false,gets,all,retention,leases,tracked,on,this,shard,and,otherwise,first,calculates,expiration,of,existing,retention,leases,and,then,gets,all,non,expired,retention,leases,tracked,on,this,shard,note,that,only,the,primary,shard,calculates,which,leases,are,expired,and,if,any,have,expired,syncs,the,retention,leases,to,any,replicas,if,the,expire,leases,parameter,is,true,this,replication,tracker,must,be,in,primary,mode,return,a,tuple,indicating,whether,or,not,any,retention,leases,were,expired,and,the,non,expired,retention,leases;public,synchronized,tuple,boolean,retention,leases,get,retention,leases,final,boolean,expire,leases,if,expire,leases,false,return,tuple,tuple,false,retention,leases,assert,primary,mode,final,long,current,time,millis,current,time,millis,supplier,get,as,long,final,long,retention,lease,millis,index,settings,get,retention,lease,millis,final,map,boolean,list,retention,lease,partition,by,expiration,retention,leases,leases,stream,collect,collectors,grouping,by,lease,current,time,millis,lease,timestamp,retention,lease,millis,if,partition,by,expiration,get,true,null,return,tuple,tuple,false,retention,leases,final,collection,retention,lease,non,expired,leases,partition,by,expiration,get,false,null,partition,by,expiration,get,false,collections,empty,list,retention,leases,new,retention,leases,operation,primary,term,retention,leases,version,1,non,expired,leases,return,tuple,tuple,true,retention,leases
ReplicationTracker -> public synchronized Tuple<Boolean, RetentionLeases> getRetentionLeases(final boolean expireLeases);1550526771;If the expire leases parameter is false, gets all retention leases tracked on this shard and otherwise first calculates_expiration of existing retention leases, and then gets all non-expired retention leases tracked on this shard. Note that only the_primary shard calculates which leases are expired, and if any have expired, syncs the retention leases to any replicas. If the_expire leases parameter is true, this replication tracker must be in primary mode.__@return a tuple indicating whether or not any retention leases were expired, and the non-expired retention leases;public synchronized Tuple<Boolean, RetentionLeases> getRetentionLeases(final boolean expireLeases) {_        if (expireLeases == false) {_            return Tuple.tuple(false, retentionLeases)__        }_        assert primaryMode__        _        final long currentTimeMillis = currentTimeMillisSupplier.getAsLong()__        final long retentionLeaseMillis = indexSettings.getRetentionLeaseMillis()__        final Map<Boolean, List<RetentionLease>> partitionByExpiration = retentionLeases_                .leases()_                .stream()_                .collect(Collectors.groupingBy(lease -> currentTimeMillis - lease.timestamp() > retentionLeaseMillis))__        if (partitionByExpiration.get(true) == null) {_            _            return Tuple.tuple(false, retentionLeases)__        }_        final Collection<RetentionLease> nonExpiredLeases =_                partitionByExpiration.get(false) != null ? partitionByExpiration.get(false) : Collections.emptyList()__        retentionLeases = new RetentionLeases(operationPrimaryTerm, retentionLeases.version() + 1, nonExpiredLeases)__        return Tuple.tuple(true, retentionLeases)__    };if,the,expire,leases,parameter,is,false,gets,all,retention,leases,tracked,on,this,shard,and,otherwise,first,calculates,expiration,of,existing,retention,leases,and,then,gets,all,non,expired,retention,leases,tracked,on,this,shard,note,that,only,the,primary,shard,calculates,which,leases,are,expired,and,if,any,have,expired,syncs,the,retention,leases,to,any,replicas,if,the,expire,leases,parameter,is,true,this,replication,tracker,must,be,in,primary,mode,return,a,tuple,indicating,whether,or,not,any,retention,leases,were,expired,and,the,non,expired,retention,leases;public,synchronized,tuple,boolean,retention,leases,get,retention,leases,final,boolean,expire,leases,if,expire,leases,false,return,tuple,tuple,false,retention,leases,assert,primary,mode,final,long,current,time,millis,current,time,millis,supplier,get,as,long,final,long,retention,lease,millis,index,settings,get,retention,lease,millis,final,map,boolean,list,retention,lease,partition,by,expiration,retention,leases,leases,stream,collect,collectors,grouping,by,lease,current,time,millis,lease,timestamp,retention,lease,millis,if,partition,by,expiration,get,true,null,return,tuple,tuple,false,retention,leases,final,collection,retention,lease,non,expired,leases,partition,by,expiration,get,false,null,partition,by,expiration,get,false,collections,empty,list,retention,leases,new,retention,leases,operation,primary,term,retention,leases,version,1,non,expired,leases,return,tuple,tuple,true,retention,leases
ReplicationTracker -> public synchronized void activatePrimaryMode(final long localCheckpoint);1524684173;Initializes the global checkpoint tracker in primary mode (see {@link #primaryMode}. Called on primary activation or promotion.;public synchronized void activatePrimaryMode(final long localCheckpoint) {_        assert invariant()__        assert primaryMode == false__        assert checkpoints.get(shardAllocationId) != null && checkpoints.get(shardAllocationId).inSync &&_            checkpoints.get(shardAllocationId).localCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO :_            "expected " + shardAllocationId + " to have initialized entry in " + checkpoints + " when activating primary"__        assert localCheckpoint >= SequenceNumbers.NO_OPS_PERFORMED__        primaryMode = true__        updateLocalCheckpoint(shardAllocationId, checkpoints.get(shardAllocationId), localCheckpoint)__        updateGlobalCheckpointOnPrimary()__        assert invariant()__    };initializes,the,global,checkpoint,tracker,in,primary,mode,see,link,primary,mode,called,on,primary,activation,or,promotion;public,synchronized,void,activate,primary,mode,final,long,local,checkpoint,assert,invariant,assert,primary,mode,false,assert,checkpoints,get,shard,allocation,id,null,checkpoints,get,shard,allocation,id,in,sync,checkpoints,get,shard,allocation,id,local,checkpoint,sequence,numbers,expected,shard,allocation,id,to,have,initialized,entry,in,checkpoints,when,activating,primary,assert,local,checkpoint,sequence,numbers,primary,mode,true,update,local,checkpoint,shard,allocation,id,checkpoints,get,shard,allocation,id,local,checkpoint,update,global,checkpoint,on,primary,assert,invariant
ReplicationTracker -> public synchronized void activatePrimaryMode(final long localCheckpoint);1525334055;Initializes the global checkpoint tracker in primary mode (see {@link #primaryMode}. Called on primary activation or promotion.;public synchronized void activatePrimaryMode(final long localCheckpoint) {_        assert invariant()__        assert primaryMode == false__        assert checkpoints.get(shardAllocationId) != null && checkpoints.get(shardAllocationId).inSync &&_            checkpoints.get(shardAllocationId).localCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO :_            "expected " + shardAllocationId + " to have initialized entry in " + checkpoints + " when activating primary"__        assert localCheckpoint >= SequenceNumbers.NO_OPS_PERFORMED__        primaryMode = true__        updateLocalCheckpoint(shardAllocationId, checkpoints.get(shardAllocationId), localCheckpoint)__        updateGlobalCheckpointOnPrimary()__        assert invariant()__    };initializes,the,global,checkpoint,tracker,in,primary,mode,see,link,primary,mode,called,on,primary,activation,or,promotion;public,synchronized,void,activate,primary,mode,final,long,local,checkpoint,assert,invariant,assert,primary,mode,false,assert,checkpoints,get,shard,allocation,id,null,checkpoints,get,shard,allocation,id,in,sync,checkpoints,get,shard,allocation,id,local,checkpoint,sequence,numbers,expected,shard,allocation,id,to,have,initialized,entry,in,checkpoints,when,activating,primary,assert,local,checkpoint,sequence,numbers,primary,mode,true,update,local,checkpoint,shard,allocation,id,checkpoints,get,shard,allocation,id,local,checkpoint,update,global,checkpoint,on,primary,assert,invariant
ReplicationTracker -> public synchronized void activatePrimaryMode(final long localCheckpoint);1533295538;Initializes the global checkpoint tracker in primary mode (see {@link #primaryMode}. Called on primary activation or promotion.;public synchronized void activatePrimaryMode(final long localCheckpoint) {_        assert invariant()__        assert primaryMode == false__        assert checkpoints.get(shardAllocationId) != null && checkpoints.get(shardAllocationId).inSync &&_            checkpoints.get(shardAllocationId).localCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO :_            "expected " + shardAllocationId + " to have initialized entry in " + checkpoints + " when activating primary"__        assert localCheckpoint >= SequenceNumbers.NO_OPS_PERFORMED__        primaryMode = true__        updateLocalCheckpoint(shardAllocationId, checkpoints.get(shardAllocationId), localCheckpoint)__        updateGlobalCheckpointOnPrimary()__        assert invariant()__    };initializes,the,global,checkpoint,tracker,in,primary,mode,see,link,primary,mode,called,on,primary,activation,or,promotion;public,synchronized,void,activate,primary,mode,final,long,local,checkpoint,assert,invariant,assert,primary,mode,false,assert,checkpoints,get,shard,allocation,id,null,checkpoints,get,shard,allocation,id,in,sync,checkpoints,get,shard,allocation,id,local,checkpoint,sequence,numbers,expected,shard,allocation,id,to,have,initialized,entry,in,checkpoints,when,activating,primary,assert,local,checkpoint,sequence,numbers,primary,mode,true,update,local,checkpoint,shard,allocation,id,checkpoints,get,shard,allocation,id,local,checkpoint,update,global,checkpoint,on,primary,assert,invariant
ReplicationTracker -> public synchronized void activatePrimaryMode(final long localCheckpoint);1533738061;Initializes the global checkpoint tracker in primary mode (see {@link #primaryMode}. Called on primary activation or promotion.;public synchronized void activatePrimaryMode(final long localCheckpoint) {_        assert invariant()__        assert primaryMode == false__        assert checkpoints.get(shardAllocationId) != null && checkpoints.get(shardAllocationId).inSync &&_            checkpoints.get(shardAllocationId).localCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO :_            "expected " + shardAllocationId + " to have initialized entry in " + checkpoints + " when activating primary"__        assert localCheckpoint >= SequenceNumbers.NO_OPS_PERFORMED__        primaryMode = true__        updateLocalCheckpoint(shardAllocationId, checkpoints.get(shardAllocationId), localCheckpoint)__        updateGlobalCheckpointOnPrimary()__        assert invariant()__    };initializes,the,global,checkpoint,tracker,in,primary,mode,see,link,primary,mode,called,on,primary,activation,or,promotion;public,synchronized,void,activate,primary,mode,final,long,local,checkpoint,assert,invariant,assert,primary,mode,false,assert,checkpoints,get,shard,allocation,id,null,checkpoints,get,shard,allocation,id,in,sync,checkpoints,get,shard,allocation,id,local,checkpoint,sequence,numbers,expected,shard,allocation,id,to,have,initialized,entry,in,checkpoints,when,activating,primary,assert,local,checkpoint,sequence,numbers,primary,mode,true,update,local,checkpoint,shard,allocation,id,checkpoints,get,shard,allocation,id,local,checkpoint,update,global,checkpoint,on,primary,assert,invariant
ReplicationTracker -> public synchronized void activatePrimaryMode(final long localCheckpoint);1546875837;Initializes the global checkpoint tracker in primary mode (see {@link #primaryMode}. Called on primary activation or promotion.;public synchronized void activatePrimaryMode(final long localCheckpoint) {_        assert invariant()__        assert primaryMode == false__        assert checkpoints.get(shardAllocationId) != null && checkpoints.get(shardAllocationId).inSync &&_            checkpoints.get(shardAllocationId).localCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO :_            "expected " + shardAllocationId + " to have initialized entry in " + checkpoints + " when activating primary"__        assert localCheckpoint >= SequenceNumbers.NO_OPS_PERFORMED__        primaryMode = true__        updateLocalCheckpoint(shardAllocationId, checkpoints.get(shardAllocationId), localCheckpoint)__        updateGlobalCheckpointOnPrimary()__        assert invariant()__    };initializes,the,global,checkpoint,tracker,in,primary,mode,see,link,primary,mode,called,on,primary,activation,or,promotion;public,synchronized,void,activate,primary,mode,final,long,local,checkpoint,assert,invariant,assert,primary,mode,false,assert,checkpoints,get,shard,allocation,id,null,checkpoints,get,shard,allocation,id,in,sync,checkpoints,get,shard,allocation,id,local,checkpoint,sequence,numbers,expected,shard,allocation,id,to,have,initialized,entry,in,checkpoints,when,activating,primary,assert,local,checkpoint,sequence,numbers,primary,mode,true,update,local,checkpoint,shard,allocation,id,checkpoints,get,shard,allocation,id,local,checkpoint,update,global,checkpoint,on,primary,assert,invariant
ReplicationTracker -> public synchronized void activatePrimaryMode(final long localCheckpoint);1546927432;Initializes the global checkpoint tracker in primary mode (see {@link #primaryMode}. Called on primary activation or promotion.;public synchronized void activatePrimaryMode(final long localCheckpoint) {_        assert invariant()__        assert primaryMode == false__        assert checkpoints.get(shardAllocationId) != null && checkpoints.get(shardAllocationId).inSync &&_            checkpoints.get(shardAllocationId).localCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO :_            "expected " + shardAllocationId + " to have initialized entry in " + checkpoints + " when activating primary"__        assert localCheckpoint >= SequenceNumbers.NO_OPS_PERFORMED__        primaryMode = true__        updateLocalCheckpoint(shardAllocationId, checkpoints.get(shardAllocationId), localCheckpoint)__        updateGlobalCheckpointOnPrimary()__        assert invariant()__    };initializes,the,global,checkpoint,tracker,in,primary,mode,see,link,primary,mode,called,on,primary,activation,or,promotion;public,synchronized,void,activate,primary,mode,final,long,local,checkpoint,assert,invariant,assert,primary,mode,false,assert,checkpoints,get,shard,allocation,id,null,checkpoints,get,shard,allocation,id,in,sync,checkpoints,get,shard,allocation,id,local,checkpoint,sequence,numbers,expected,shard,allocation,id,to,have,initialized,entry,in,checkpoints,when,activating,primary,assert,local,checkpoint,sequence,numbers,primary,mode,true,update,local,checkpoint,shard,allocation,id,checkpoints,get,shard,allocation,id,local,checkpoint,update,global,checkpoint,on,primary,assert,invariant
ReplicationTracker -> public synchronized void activatePrimaryMode(final long localCheckpoint);1547332999;Initializes the global checkpoint tracker in primary mode (see {@link #primaryMode}. Called on primary activation or promotion.;public synchronized void activatePrimaryMode(final long localCheckpoint) {_        assert invariant()__        assert primaryMode == false__        assert checkpoints.get(shardAllocationId) != null && checkpoints.get(shardAllocationId).inSync &&_            checkpoints.get(shardAllocationId).localCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO :_            "expected " + shardAllocationId + " to have initialized entry in " + checkpoints + " when activating primary"__        assert localCheckpoint >= SequenceNumbers.NO_OPS_PERFORMED__        primaryMode = true__        updateLocalCheckpoint(shardAllocationId, checkpoints.get(shardAllocationId), localCheckpoint)__        updateGlobalCheckpointOnPrimary()__        assert invariant()__    };initializes,the,global,checkpoint,tracker,in,primary,mode,see,link,primary,mode,called,on,primary,activation,or,promotion;public,synchronized,void,activate,primary,mode,final,long,local,checkpoint,assert,invariant,assert,primary,mode,false,assert,checkpoints,get,shard,allocation,id,null,checkpoints,get,shard,allocation,id,in,sync,checkpoints,get,shard,allocation,id,local,checkpoint,sequence,numbers,expected,shard,allocation,id,to,have,initialized,entry,in,checkpoints,when,activating,primary,assert,local,checkpoint,sequence,numbers,primary,mode,true,update,local,checkpoint,shard,allocation,id,checkpoints,get,shard,allocation,id,local,checkpoint,update,global,checkpoint,on,primary,assert,invariant
ReplicationTracker -> public synchronized void activatePrimaryMode(final long localCheckpoint);1548593396;Initializes the global checkpoint tracker in primary mode (see {@link #primaryMode}. Called on primary activation or promotion.;public synchronized void activatePrimaryMode(final long localCheckpoint) {_        assert invariant()__        assert primaryMode == false__        assert checkpoints.get(shardAllocationId) != null && checkpoints.get(shardAllocationId).inSync &&_            checkpoints.get(shardAllocationId).localCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO :_            "expected " + shardAllocationId + " to have initialized entry in " + checkpoints + " when activating primary"__        assert localCheckpoint >= SequenceNumbers.NO_OPS_PERFORMED__        primaryMode = true__        updateLocalCheckpoint(shardAllocationId, checkpoints.get(shardAllocationId), localCheckpoint)__        updateGlobalCheckpointOnPrimary()__        assert invariant()__    };initializes,the,global,checkpoint,tracker,in,primary,mode,see,link,primary,mode,called,on,primary,activation,or,promotion;public,synchronized,void,activate,primary,mode,final,long,local,checkpoint,assert,invariant,assert,primary,mode,false,assert,checkpoints,get,shard,allocation,id,null,checkpoints,get,shard,allocation,id,in,sync,checkpoints,get,shard,allocation,id,local,checkpoint,sequence,numbers,expected,shard,allocation,id,to,have,initialized,entry,in,checkpoints,when,activating,primary,assert,local,checkpoint,sequence,numbers,primary,mode,true,update,local,checkpoint,shard,allocation,id,checkpoints,get,shard,allocation,id,local,checkpoint,update,global,checkpoint,on,primary,assert,invariant
ReplicationTracker -> public synchronized void activatePrimaryMode(final long localCheckpoint);1548594827;Initializes the global checkpoint tracker in primary mode (see {@link #primaryMode}. Called on primary activation or promotion.;public synchronized void activatePrimaryMode(final long localCheckpoint) {_        assert invariant()__        assert primaryMode == false__        assert checkpoints.get(shardAllocationId) != null && checkpoints.get(shardAllocationId).inSync &&_            checkpoints.get(shardAllocationId).localCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO :_            "expected " + shardAllocationId + " to have initialized entry in " + checkpoints + " when activating primary"__        assert localCheckpoint >= SequenceNumbers.NO_OPS_PERFORMED__        primaryMode = true__        updateLocalCheckpoint(shardAllocationId, checkpoints.get(shardAllocationId), localCheckpoint)__        updateGlobalCheckpointOnPrimary()__        assert invariant()__    };initializes,the,global,checkpoint,tracker,in,primary,mode,see,link,primary,mode,called,on,primary,activation,or,promotion;public,synchronized,void,activate,primary,mode,final,long,local,checkpoint,assert,invariant,assert,primary,mode,false,assert,checkpoints,get,shard,allocation,id,null,checkpoints,get,shard,allocation,id,in,sync,checkpoints,get,shard,allocation,id,local,checkpoint,sequence,numbers,expected,shard,allocation,id,to,have,initialized,entry,in,checkpoints,when,activating,primary,assert,local,checkpoint,sequence,numbers,primary,mode,true,update,local,checkpoint,shard,allocation,id,checkpoints,get,shard,allocation,id,local,checkpoint,update,global,checkpoint,on,primary,assert,invariant
ReplicationTracker -> public synchronized void activatePrimaryMode(final long localCheckpoint);1548677511;Initializes the global checkpoint tracker in primary mode (see {@link #primaryMode}. Called on primary activation or promotion.;public synchronized void activatePrimaryMode(final long localCheckpoint) {_        assert invariant()__        assert primaryMode == false__        assert checkpoints.get(shardAllocationId) != null && checkpoints.get(shardAllocationId).inSync &&_            checkpoints.get(shardAllocationId).localCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO :_            "expected " + shardAllocationId + " to have initialized entry in " + checkpoints + " when activating primary"__        assert localCheckpoint >= SequenceNumbers.NO_OPS_PERFORMED__        primaryMode = true__        updateLocalCheckpoint(shardAllocationId, checkpoints.get(shardAllocationId), localCheckpoint)__        updateGlobalCheckpointOnPrimary()__        assert invariant()__    };initializes,the,global,checkpoint,tracker,in,primary,mode,see,link,primary,mode,called,on,primary,activation,or,promotion;public,synchronized,void,activate,primary,mode,final,long,local,checkpoint,assert,invariant,assert,primary,mode,false,assert,checkpoints,get,shard,allocation,id,null,checkpoints,get,shard,allocation,id,in,sync,checkpoints,get,shard,allocation,id,local,checkpoint,sequence,numbers,expected,shard,allocation,id,to,have,initialized,entry,in,checkpoints,when,activating,primary,assert,local,checkpoint,sequence,numbers,primary,mode,true,update,local,checkpoint,shard,allocation,id,checkpoints,get,shard,allocation,id,local,checkpoint,update,global,checkpoint,on,primary,assert,invariant
ReplicationTracker -> public synchronized void activatePrimaryMode(final long localCheckpoint);1548944389;Initializes the global checkpoint tracker in primary mode (see {@link #primaryMode}. Called on primary activation or promotion.;public synchronized void activatePrimaryMode(final long localCheckpoint) {_        assert invariant()__        assert primaryMode == false__        assert checkpoints.get(shardAllocationId) != null && checkpoints.get(shardAllocationId).inSync &&_            checkpoints.get(shardAllocationId).localCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO :_            "expected " + shardAllocationId + " to have initialized entry in " + checkpoints + " when activating primary"__        assert localCheckpoint >= SequenceNumbers.NO_OPS_PERFORMED__        primaryMode = true__        updateLocalCheckpoint(shardAllocationId, checkpoints.get(shardAllocationId), localCheckpoint)__        updateGlobalCheckpointOnPrimary()__        assert invariant()__    };initializes,the,global,checkpoint,tracker,in,primary,mode,see,link,primary,mode,called,on,primary,activation,or,promotion;public,synchronized,void,activate,primary,mode,final,long,local,checkpoint,assert,invariant,assert,primary,mode,false,assert,checkpoints,get,shard,allocation,id,null,checkpoints,get,shard,allocation,id,in,sync,checkpoints,get,shard,allocation,id,local,checkpoint,sequence,numbers,expected,shard,allocation,id,to,have,initialized,entry,in,checkpoints,when,activating,primary,assert,local,checkpoint,sequence,numbers,primary,mode,true,update,local,checkpoint,shard,allocation,id,checkpoints,get,shard,allocation,id,local,checkpoint,update,global,checkpoint,on,primary,assert,invariant
ReplicationTracker -> public synchronized void activatePrimaryMode(final long localCheckpoint);1549059559;Initializes the global checkpoint tracker in primary mode (see {@link #primaryMode}. Called on primary activation or promotion.;public synchronized void activatePrimaryMode(final long localCheckpoint) {_        assert invariant()__        assert primaryMode == false__        assert checkpoints.get(shardAllocationId) != null && checkpoints.get(shardAllocationId).inSync &&_            checkpoints.get(shardAllocationId).localCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO :_            "expected " + shardAllocationId + " to have initialized entry in " + checkpoints + " when activating primary"__        assert localCheckpoint >= SequenceNumbers.NO_OPS_PERFORMED__        primaryMode = true__        updateLocalCheckpoint(shardAllocationId, checkpoints.get(shardAllocationId), localCheckpoint)__        updateGlobalCheckpointOnPrimary()__        assert invariant()__    };initializes,the,global,checkpoint,tracker,in,primary,mode,see,link,primary,mode,called,on,primary,activation,or,promotion;public,synchronized,void,activate,primary,mode,final,long,local,checkpoint,assert,invariant,assert,primary,mode,false,assert,checkpoints,get,shard,allocation,id,null,checkpoints,get,shard,allocation,id,in,sync,checkpoints,get,shard,allocation,id,local,checkpoint,sequence,numbers,expected,shard,allocation,id,to,have,initialized,entry,in,checkpoints,when,activating,primary,assert,local,checkpoint,sequence,numbers,primary,mode,true,update,local,checkpoint,shard,allocation,id,checkpoints,get,shard,allocation,id,local,checkpoint,update,global,checkpoint,on,primary,assert,invariant
ReplicationTracker -> public synchronized void activatePrimaryMode(final long localCheckpoint);1549294529;Initializes the global checkpoint tracker in primary mode (see {@link #primaryMode}. Called on primary activation or promotion.;public synchronized void activatePrimaryMode(final long localCheckpoint) {_        assert invariant()__        assert primaryMode == false__        assert checkpoints.get(shardAllocationId) != null && checkpoints.get(shardAllocationId).inSync &&_            checkpoints.get(shardAllocationId).localCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO :_            "expected " + shardAllocationId + " to have initialized entry in " + checkpoints + " when activating primary"__        assert localCheckpoint >= SequenceNumbers.NO_OPS_PERFORMED__        primaryMode = true__        updateLocalCheckpoint(shardAllocationId, checkpoints.get(shardAllocationId), localCheckpoint)__        updateGlobalCheckpointOnPrimary()__        assert invariant()__    };initializes,the,global,checkpoint,tracker,in,primary,mode,see,link,primary,mode,called,on,primary,activation,or,promotion;public,synchronized,void,activate,primary,mode,final,long,local,checkpoint,assert,invariant,assert,primary,mode,false,assert,checkpoints,get,shard,allocation,id,null,checkpoints,get,shard,allocation,id,in,sync,checkpoints,get,shard,allocation,id,local,checkpoint,sequence,numbers,expected,shard,allocation,id,to,have,initialized,entry,in,checkpoints,when,activating,primary,assert,local,checkpoint,sequence,numbers,primary,mode,true,update,local,checkpoint,shard,allocation,id,checkpoints,get,shard,allocation,id,local,checkpoint,update,global,checkpoint,on,primary,assert,invariant
ReplicationTracker -> public synchronized void activatePrimaryMode(final long localCheckpoint);1549395737;Initializes the global checkpoint tracker in primary mode (see {@link #primaryMode}. Called on primary activation or promotion.;public synchronized void activatePrimaryMode(final long localCheckpoint) {_        assert invariant()__        assert primaryMode == false__        assert checkpoints.get(shardAllocationId) != null && checkpoints.get(shardAllocationId).inSync &&_            checkpoints.get(shardAllocationId).localCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO :_            "expected " + shardAllocationId + " to have initialized entry in " + checkpoints + " when activating primary"__        assert localCheckpoint >= SequenceNumbers.NO_OPS_PERFORMED__        primaryMode = true__        updateLocalCheckpoint(shardAllocationId, checkpoints.get(shardAllocationId), localCheckpoint)__        updateGlobalCheckpointOnPrimary()__        assert invariant()__    };initializes,the,global,checkpoint,tracker,in,primary,mode,see,link,primary,mode,called,on,primary,activation,or,promotion;public,synchronized,void,activate,primary,mode,final,long,local,checkpoint,assert,invariant,assert,primary,mode,false,assert,checkpoints,get,shard,allocation,id,null,checkpoints,get,shard,allocation,id,in,sync,checkpoints,get,shard,allocation,id,local,checkpoint,sequence,numbers,expected,shard,allocation,id,to,have,initialized,entry,in,checkpoints,when,activating,primary,assert,local,checkpoint,sequence,numbers,primary,mode,true,update,local,checkpoint,shard,allocation,id,checkpoints,get,shard,allocation,id,local,checkpoint,update,global,checkpoint,on,primary,assert,invariant
ReplicationTracker -> public synchronized void activatePrimaryMode(final long localCheckpoint);1549937843;Initializes the global checkpoint tracker in primary mode (see {@link #primaryMode}. Called on primary activation or promotion.;public synchronized void activatePrimaryMode(final long localCheckpoint) {_        assert invariant()__        assert primaryMode == false__        assert checkpoints.get(shardAllocationId) != null && checkpoints.get(shardAllocationId).inSync &&_            checkpoints.get(shardAllocationId).localCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO :_            "expected " + shardAllocationId + " to have initialized entry in " + checkpoints + " when activating primary"__        assert localCheckpoint >= SequenceNumbers.NO_OPS_PERFORMED__        primaryMode = true__        updateLocalCheckpoint(shardAllocationId, checkpoints.get(shardAllocationId), localCheckpoint)__        updateGlobalCheckpointOnPrimary()__        assert invariant()__    };initializes,the,global,checkpoint,tracker,in,primary,mode,see,link,primary,mode,called,on,primary,activation,or,promotion;public,synchronized,void,activate,primary,mode,final,long,local,checkpoint,assert,invariant,assert,primary,mode,false,assert,checkpoints,get,shard,allocation,id,null,checkpoints,get,shard,allocation,id,in,sync,checkpoints,get,shard,allocation,id,local,checkpoint,sequence,numbers,expected,shard,allocation,id,to,have,initialized,entry,in,checkpoints,when,activating,primary,assert,local,checkpoint,sequence,numbers,primary,mode,true,update,local,checkpoint,shard,allocation,id,checkpoints,get,shard,allocation,id,local,checkpoint,update,global,checkpoint,on,primary,assert,invariant
ReplicationTracker -> public synchronized void activatePrimaryMode(final long localCheckpoint);1549949489;Initializes the global checkpoint tracker in primary mode (see {@link #primaryMode}. Called on primary activation or promotion.;public synchronized void activatePrimaryMode(final long localCheckpoint) {_        assert invariant()__        assert primaryMode == false__        assert checkpoints.get(shardAllocationId) != null && checkpoints.get(shardAllocationId).inSync &&_            checkpoints.get(shardAllocationId).localCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO :_            "expected " + shardAllocationId + " to have initialized entry in " + checkpoints + " when activating primary"__        assert localCheckpoint >= SequenceNumbers.NO_OPS_PERFORMED__        primaryMode = true__        updateLocalCheckpoint(shardAllocationId, checkpoints.get(shardAllocationId), localCheckpoint)__        updateGlobalCheckpointOnPrimary()__        assert invariant()__    };initializes,the,global,checkpoint,tracker,in,primary,mode,see,link,primary,mode,called,on,primary,activation,or,promotion;public,synchronized,void,activate,primary,mode,final,long,local,checkpoint,assert,invariant,assert,primary,mode,false,assert,checkpoints,get,shard,allocation,id,null,checkpoints,get,shard,allocation,id,in,sync,checkpoints,get,shard,allocation,id,local,checkpoint,sequence,numbers,expected,shard,allocation,id,to,have,initialized,entry,in,checkpoints,when,activating,primary,assert,local,checkpoint,sequence,numbers,primary,mode,true,update,local,checkpoint,shard,allocation,id,checkpoints,get,shard,allocation,id,local,checkpoint,update,global,checkpoint,on,primary,assert,invariant
ReplicationTracker -> public synchronized void activatePrimaryMode(final long localCheckpoint);1550526771;Initializes the global checkpoint tracker in primary mode (see {@link #primaryMode}. Called on primary activation or promotion.;public synchronized void activatePrimaryMode(final long localCheckpoint) {_        assert invariant()__        assert primaryMode == false__        assert checkpoints.get(shardAllocationId) != null && checkpoints.get(shardAllocationId).inSync &&_            checkpoints.get(shardAllocationId).localCheckpoint == SequenceNumbers.UNASSIGNED_SEQ_NO :_            "expected " + shardAllocationId + " to have initialized entry in " + checkpoints + " when activating primary"__        assert localCheckpoint >= SequenceNumbers.NO_OPS_PERFORMED__        primaryMode = true__        updateLocalCheckpoint(shardAllocationId, checkpoints.get(shardAllocationId), localCheckpoint)__        updateGlobalCheckpointOnPrimary()__        assert invariant()__    };initializes,the,global,checkpoint,tracker,in,primary,mode,see,link,primary,mode,called,on,primary,activation,or,promotion;public,synchronized,void,activate,primary,mode,final,long,local,checkpoint,assert,invariant,assert,primary,mode,false,assert,checkpoints,get,shard,allocation,id,null,checkpoints,get,shard,allocation,id,in,sync,checkpoints,get,shard,allocation,id,local,checkpoint,sequence,numbers,expected,shard,allocation,id,to,have,initialized,entry,in,checkpoints,when,activating,primary,assert,local,checkpoint,sequence,numbers,primary,mode,true,update,local,checkpoint,shard,allocation,id,checkpoints,get,shard,allocation,id,local,checkpoint,update,global,checkpoint,on,primary,assert,invariant
ReplicationTracker -> public synchronized void markAllocationIdAsInSync(final String allocationId, final long localCheckpoint) throws InterruptedException;1524684173;Marks the shard with the provided allocation ID as in-sync with the primary shard. This method will block until the local checkpoint_on the specified shard advances above the current global checkpoint.__@param allocationId    the allocation ID of the shard to mark as in-sync_@param localCheckpoint the current local checkpoint on the shard;public synchronized void markAllocationIdAsInSync(final String allocationId, final long localCheckpoint) throws InterruptedException {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        CheckpointState cps = checkpoints.get(allocationId)__        if (cps == null) {_            _            throw new IllegalStateException("no local checkpoint tracking information available for " + allocationId)__        }_        assert localCheckpoint >= SequenceNumbers.NO_OPS_PERFORMED :_            "expected known local checkpoint for " + allocationId + " but was " + localCheckpoint__        assert pendingInSync.contains(allocationId) == false : "shard copy " + allocationId + " is already marked as pending in-sync"__        assert cps.tracked : "shard copy " + allocationId + " cannot be marked as in-sync as it's not tracked"__        updateLocalCheckpoint(allocationId, cps, localCheckpoint)__        _        _        assert !cps.inSync || (cps.localCheckpoint >= getGlobalCheckpoint()) :_            "shard copy " + allocationId + " that's already in-sync should have a local checkpoint " + cps.localCheckpoint +_                " that's above the global checkpoint " + getGlobalCheckpoint()__        if (cps.localCheckpoint < getGlobalCheckpoint()) {_            pendingInSync.add(allocationId)__            try {_                while (true) {_                    if (pendingInSync.contains(allocationId)) {_                        waitForLocalCheckpointToAdvance()__                    } else {_                        break__                    }_                }_            } finally {_                pendingInSync.remove(allocationId)__            }_        } else {_            cps.inSync = true__            replicationGroup = calculateReplicationGroup()__            logger.trace("marked [{}] as in-sync", allocationId)__            updateGlobalCheckpointOnPrimary()__        }__        assert invariant()__    };marks,the,shard,with,the,provided,allocation,id,as,in,sync,with,the,primary,shard,this,method,will,block,until,the,local,checkpoint,on,the,specified,shard,advances,above,the,current,global,checkpoint,param,allocation,id,the,allocation,id,of,the,shard,to,mark,as,in,sync,param,local,checkpoint,the,current,local,checkpoint,on,the,shard;public,synchronized,void,mark,allocation,id,as,in,sync,final,string,allocation,id,final,long,local,checkpoint,throws,interrupted,exception,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,checkpoint,state,cps,checkpoints,get,allocation,id,if,cps,null,throw,new,illegal,state,exception,no,local,checkpoint,tracking,information,available,for,allocation,id,assert,local,checkpoint,sequence,numbers,expected,known,local,checkpoint,for,allocation,id,but,was,local,checkpoint,assert,pending,in,sync,contains,allocation,id,false,shard,copy,allocation,id,is,already,marked,as,pending,in,sync,assert,cps,tracked,shard,copy,allocation,id,cannot,be,marked,as,in,sync,as,it,s,not,tracked,update,local,checkpoint,allocation,id,cps,local,checkpoint,assert,cps,in,sync,cps,local,checkpoint,get,global,checkpoint,shard,copy,allocation,id,that,s,already,in,sync,should,have,a,local,checkpoint,cps,local,checkpoint,that,s,above,the,global,checkpoint,get,global,checkpoint,if,cps,local,checkpoint,get,global,checkpoint,pending,in,sync,add,allocation,id,try,while,true,if,pending,in,sync,contains,allocation,id,wait,for,local,checkpoint,to,advance,else,break,finally,pending,in,sync,remove,allocation,id,else,cps,in,sync,true,replication,group,calculate,replication,group,logger,trace,marked,as,in,sync,allocation,id,update,global,checkpoint,on,primary,assert,invariant
ReplicationTracker -> public synchronized void markAllocationIdAsInSync(final String allocationId, final long localCheckpoint) throws InterruptedException;1525334055;Marks the shard with the provided allocation ID as in-sync with the primary shard. This method will block until the local checkpoint_on the specified shard advances above the current global checkpoint.__@param allocationId    the allocation ID of the shard to mark as in-sync_@param localCheckpoint the current local checkpoint on the shard;public synchronized void markAllocationIdAsInSync(final String allocationId, final long localCheckpoint) throws InterruptedException {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        CheckpointState cps = checkpoints.get(allocationId)__        if (cps == null) {_            _            throw new IllegalStateException("no local checkpoint tracking information available for " + allocationId)__        }_        assert localCheckpoint >= SequenceNumbers.NO_OPS_PERFORMED :_            "expected known local checkpoint for " + allocationId + " but was " + localCheckpoint__        assert pendingInSync.contains(allocationId) == false : "shard copy " + allocationId + " is already marked as pending in-sync"__        assert cps.tracked : "shard copy " + allocationId + " cannot be marked as in-sync as it's not tracked"__        updateLocalCheckpoint(allocationId, cps, localCheckpoint)__        _        _        assert !cps.inSync || (cps.localCheckpoint >= getGlobalCheckpoint()) :_            "shard copy " + allocationId + " that's already in-sync should have a local checkpoint " + cps.localCheckpoint +_                " that's above the global checkpoint " + getGlobalCheckpoint()__        if (cps.localCheckpoint < getGlobalCheckpoint()) {_            pendingInSync.add(allocationId)__            try {_                while (true) {_                    if (pendingInSync.contains(allocationId)) {_                        waitForLocalCheckpointToAdvance()__                    } else {_                        break__                    }_                }_            } finally {_                pendingInSync.remove(allocationId)__            }_        } else {_            cps.inSync = true__            replicationGroup = calculateReplicationGroup()__            logger.trace("marked [{}] as in-sync", allocationId)__            updateGlobalCheckpointOnPrimary()__        }__        assert invariant()__    };marks,the,shard,with,the,provided,allocation,id,as,in,sync,with,the,primary,shard,this,method,will,block,until,the,local,checkpoint,on,the,specified,shard,advances,above,the,current,global,checkpoint,param,allocation,id,the,allocation,id,of,the,shard,to,mark,as,in,sync,param,local,checkpoint,the,current,local,checkpoint,on,the,shard;public,synchronized,void,mark,allocation,id,as,in,sync,final,string,allocation,id,final,long,local,checkpoint,throws,interrupted,exception,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,checkpoint,state,cps,checkpoints,get,allocation,id,if,cps,null,throw,new,illegal,state,exception,no,local,checkpoint,tracking,information,available,for,allocation,id,assert,local,checkpoint,sequence,numbers,expected,known,local,checkpoint,for,allocation,id,but,was,local,checkpoint,assert,pending,in,sync,contains,allocation,id,false,shard,copy,allocation,id,is,already,marked,as,pending,in,sync,assert,cps,tracked,shard,copy,allocation,id,cannot,be,marked,as,in,sync,as,it,s,not,tracked,update,local,checkpoint,allocation,id,cps,local,checkpoint,assert,cps,in,sync,cps,local,checkpoint,get,global,checkpoint,shard,copy,allocation,id,that,s,already,in,sync,should,have,a,local,checkpoint,cps,local,checkpoint,that,s,above,the,global,checkpoint,get,global,checkpoint,if,cps,local,checkpoint,get,global,checkpoint,pending,in,sync,add,allocation,id,try,while,true,if,pending,in,sync,contains,allocation,id,wait,for,local,checkpoint,to,advance,else,break,finally,pending,in,sync,remove,allocation,id,else,cps,in,sync,true,replication,group,calculate,replication,group,logger,trace,marked,as,in,sync,allocation,id,update,global,checkpoint,on,primary,assert,invariant
ReplicationTracker -> public synchronized void markAllocationIdAsInSync(final String allocationId, final long localCheckpoint) throws InterruptedException;1533295538;Marks the shard with the provided allocation ID as in-sync with the primary shard. This method will block until the local checkpoint_on the specified shard advances above the current global checkpoint.__@param allocationId    the allocation ID of the shard to mark as in-sync_@param localCheckpoint the current local checkpoint on the shard;public synchronized void markAllocationIdAsInSync(final String allocationId, final long localCheckpoint) throws InterruptedException {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        CheckpointState cps = checkpoints.get(allocationId)__        if (cps == null) {_            _            throw new IllegalStateException("no local checkpoint tracking information available for " + allocationId)__        }_        assert localCheckpoint >= SequenceNumbers.NO_OPS_PERFORMED :_            "expected known local checkpoint for " + allocationId + " but was " + localCheckpoint__        assert pendingInSync.contains(allocationId) == false : "shard copy " + allocationId + " is already marked as pending in-sync"__        assert cps.tracked : "shard copy " + allocationId + " cannot be marked as in-sync as it's not tracked"__        updateLocalCheckpoint(allocationId, cps, localCheckpoint)__        _        _        assert !cps.inSync || (cps.localCheckpoint >= getGlobalCheckpoint()) :_            "shard copy " + allocationId + " that's already in-sync should have a local checkpoint " + cps.localCheckpoint +_                " that's above the global checkpoint " + getGlobalCheckpoint()__        if (cps.localCheckpoint < getGlobalCheckpoint()) {_            pendingInSync.add(allocationId)__            try {_                while (true) {_                    if (pendingInSync.contains(allocationId)) {_                        waitForLocalCheckpointToAdvance()__                    } else {_                        break__                    }_                }_            } finally {_                pendingInSync.remove(allocationId)__            }_        } else {_            cps.inSync = true__            replicationGroup = calculateReplicationGroup()__            logger.trace("marked [{}] as in-sync", allocationId)__            updateGlobalCheckpointOnPrimary()__        }__        assert invariant()__    };marks,the,shard,with,the,provided,allocation,id,as,in,sync,with,the,primary,shard,this,method,will,block,until,the,local,checkpoint,on,the,specified,shard,advances,above,the,current,global,checkpoint,param,allocation,id,the,allocation,id,of,the,shard,to,mark,as,in,sync,param,local,checkpoint,the,current,local,checkpoint,on,the,shard;public,synchronized,void,mark,allocation,id,as,in,sync,final,string,allocation,id,final,long,local,checkpoint,throws,interrupted,exception,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,checkpoint,state,cps,checkpoints,get,allocation,id,if,cps,null,throw,new,illegal,state,exception,no,local,checkpoint,tracking,information,available,for,allocation,id,assert,local,checkpoint,sequence,numbers,expected,known,local,checkpoint,for,allocation,id,but,was,local,checkpoint,assert,pending,in,sync,contains,allocation,id,false,shard,copy,allocation,id,is,already,marked,as,pending,in,sync,assert,cps,tracked,shard,copy,allocation,id,cannot,be,marked,as,in,sync,as,it,s,not,tracked,update,local,checkpoint,allocation,id,cps,local,checkpoint,assert,cps,in,sync,cps,local,checkpoint,get,global,checkpoint,shard,copy,allocation,id,that,s,already,in,sync,should,have,a,local,checkpoint,cps,local,checkpoint,that,s,above,the,global,checkpoint,get,global,checkpoint,if,cps,local,checkpoint,get,global,checkpoint,pending,in,sync,add,allocation,id,try,while,true,if,pending,in,sync,contains,allocation,id,wait,for,local,checkpoint,to,advance,else,break,finally,pending,in,sync,remove,allocation,id,else,cps,in,sync,true,replication,group,calculate,replication,group,logger,trace,marked,as,in,sync,allocation,id,update,global,checkpoint,on,primary,assert,invariant
ReplicationTracker -> public synchronized void markAllocationIdAsInSync(final String allocationId, final long localCheckpoint) throws InterruptedException;1533738061;Marks the shard with the provided allocation ID as in-sync with the primary shard. This method will block until the local checkpoint_on the specified shard advances above the current global checkpoint.__@param allocationId    the allocation ID of the shard to mark as in-sync_@param localCheckpoint the current local checkpoint on the shard;public synchronized void markAllocationIdAsInSync(final String allocationId, final long localCheckpoint) throws InterruptedException {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        CheckpointState cps = checkpoints.get(allocationId)__        if (cps == null) {_            _            throw new IllegalStateException("no local checkpoint tracking information available for " + allocationId)__        }_        assert localCheckpoint >= SequenceNumbers.NO_OPS_PERFORMED :_            "expected known local checkpoint for " + allocationId + " but was " + localCheckpoint__        assert pendingInSync.contains(allocationId) == false : "shard copy " + allocationId + " is already marked as pending in-sync"__        assert cps.tracked : "shard copy " + allocationId + " cannot be marked as in-sync as it's not tracked"__        updateLocalCheckpoint(allocationId, cps, localCheckpoint)__        _        _        assert !cps.inSync || (cps.localCheckpoint >= getGlobalCheckpoint()) :_            "shard copy " + allocationId + " that's already in-sync should have a local checkpoint " + cps.localCheckpoint +_                " that's above the global checkpoint " + getGlobalCheckpoint()__        if (cps.localCheckpoint < getGlobalCheckpoint()) {_            pendingInSync.add(allocationId)__            try {_                while (true) {_                    if (pendingInSync.contains(allocationId)) {_                        waitForLocalCheckpointToAdvance()__                    } else {_                        break__                    }_                }_            } finally {_                pendingInSync.remove(allocationId)__            }_        } else {_            cps.inSync = true__            replicationGroup = calculateReplicationGroup()__            logger.trace("marked [{}] as in-sync", allocationId)__            updateGlobalCheckpointOnPrimary()__        }__        assert invariant()__    };marks,the,shard,with,the,provided,allocation,id,as,in,sync,with,the,primary,shard,this,method,will,block,until,the,local,checkpoint,on,the,specified,shard,advances,above,the,current,global,checkpoint,param,allocation,id,the,allocation,id,of,the,shard,to,mark,as,in,sync,param,local,checkpoint,the,current,local,checkpoint,on,the,shard;public,synchronized,void,mark,allocation,id,as,in,sync,final,string,allocation,id,final,long,local,checkpoint,throws,interrupted,exception,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,checkpoint,state,cps,checkpoints,get,allocation,id,if,cps,null,throw,new,illegal,state,exception,no,local,checkpoint,tracking,information,available,for,allocation,id,assert,local,checkpoint,sequence,numbers,expected,known,local,checkpoint,for,allocation,id,but,was,local,checkpoint,assert,pending,in,sync,contains,allocation,id,false,shard,copy,allocation,id,is,already,marked,as,pending,in,sync,assert,cps,tracked,shard,copy,allocation,id,cannot,be,marked,as,in,sync,as,it,s,not,tracked,update,local,checkpoint,allocation,id,cps,local,checkpoint,assert,cps,in,sync,cps,local,checkpoint,get,global,checkpoint,shard,copy,allocation,id,that,s,already,in,sync,should,have,a,local,checkpoint,cps,local,checkpoint,that,s,above,the,global,checkpoint,get,global,checkpoint,if,cps,local,checkpoint,get,global,checkpoint,pending,in,sync,add,allocation,id,try,while,true,if,pending,in,sync,contains,allocation,id,wait,for,local,checkpoint,to,advance,else,break,finally,pending,in,sync,remove,allocation,id,else,cps,in,sync,true,replication,group,calculate,replication,group,logger,trace,marked,as,in,sync,allocation,id,update,global,checkpoint,on,primary,assert,invariant
ReplicationTracker -> public synchronized void markAllocationIdAsInSync(final String allocationId, final long localCheckpoint) throws InterruptedException;1546875837;Marks the shard with the provided allocation ID as in-sync with the primary shard. This method will block until the local checkpoint_on the specified shard advances above the current global checkpoint.__@param allocationId    the allocation ID of the shard to mark as in-sync_@param localCheckpoint the current local checkpoint on the shard;public synchronized void markAllocationIdAsInSync(final String allocationId, final long localCheckpoint) throws InterruptedException {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        CheckpointState cps = checkpoints.get(allocationId)__        if (cps == null) {_            _            throw new IllegalStateException("no local checkpoint tracking information available for " + allocationId)__        }_        assert localCheckpoint >= SequenceNumbers.NO_OPS_PERFORMED :_            "expected known local checkpoint for " + allocationId + " but was " + localCheckpoint__        assert pendingInSync.contains(allocationId) == false : "shard copy " + allocationId + " is already marked as pending in-sync"__        assert cps.tracked : "shard copy " + allocationId + " cannot be marked as in-sync as it's not tracked"__        updateLocalCheckpoint(allocationId, cps, localCheckpoint)__        _        _        assert !cps.inSync || (cps.localCheckpoint >= getGlobalCheckpoint()) :_            "shard copy " + allocationId + " that's already in-sync should have a local checkpoint " + cps.localCheckpoint +_                " that's above the global checkpoint " + getGlobalCheckpoint()__        if (cps.localCheckpoint < getGlobalCheckpoint()) {_            pendingInSync.add(allocationId)__            try {_                while (true) {_                    if (pendingInSync.contains(allocationId)) {_                        waitForLocalCheckpointToAdvance()__                    } else {_                        break__                    }_                }_            } finally {_                pendingInSync.remove(allocationId)__            }_        } else {_            cps.inSync = true__            replicationGroup = calculateReplicationGroup()__            logger.trace("marked [{}] as in-sync", allocationId)__            updateGlobalCheckpointOnPrimary()__        }__        assert invariant()__    };marks,the,shard,with,the,provided,allocation,id,as,in,sync,with,the,primary,shard,this,method,will,block,until,the,local,checkpoint,on,the,specified,shard,advances,above,the,current,global,checkpoint,param,allocation,id,the,allocation,id,of,the,shard,to,mark,as,in,sync,param,local,checkpoint,the,current,local,checkpoint,on,the,shard;public,synchronized,void,mark,allocation,id,as,in,sync,final,string,allocation,id,final,long,local,checkpoint,throws,interrupted,exception,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,checkpoint,state,cps,checkpoints,get,allocation,id,if,cps,null,throw,new,illegal,state,exception,no,local,checkpoint,tracking,information,available,for,allocation,id,assert,local,checkpoint,sequence,numbers,expected,known,local,checkpoint,for,allocation,id,but,was,local,checkpoint,assert,pending,in,sync,contains,allocation,id,false,shard,copy,allocation,id,is,already,marked,as,pending,in,sync,assert,cps,tracked,shard,copy,allocation,id,cannot,be,marked,as,in,sync,as,it,s,not,tracked,update,local,checkpoint,allocation,id,cps,local,checkpoint,assert,cps,in,sync,cps,local,checkpoint,get,global,checkpoint,shard,copy,allocation,id,that,s,already,in,sync,should,have,a,local,checkpoint,cps,local,checkpoint,that,s,above,the,global,checkpoint,get,global,checkpoint,if,cps,local,checkpoint,get,global,checkpoint,pending,in,sync,add,allocation,id,try,while,true,if,pending,in,sync,contains,allocation,id,wait,for,local,checkpoint,to,advance,else,break,finally,pending,in,sync,remove,allocation,id,else,cps,in,sync,true,replication,group,calculate,replication,group,logger,trace,marked,as,in,sync,allocation,id,update,global,checkpoint,on,primary,assert,invariant
ReplicationTracker -> public synchronized void markAllocationIdAsInSync(final String allocationId, final long localCheckpoint) throws InterruptedException;1546927432;Marks the shard with the provided allocation ID as in-sync with the primary shard. This method will block until the local checkpoint_on the specified shard advances above the current global checkpoint.__@param allocationId    the allocation ID of the shard to mark as in-sync_@param localCheckpoint the current local checkpoint on the shard;public synchronized void markAllocationIdAsInSync(final String allocationId, final long localCheckpoint) throws InterruptedException {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        CheckpointState cps = checkpoints.get(allocationId)__        if (cps == null) {_            _            throw new IllegalStateException("no local checkpoint tracking information available for " + allocationId)__        }_        assert localCheckpoint >= SequenceNumbers.NO_OPS_PERFORMED :_            "expected known local checkpoint for " + allocationId + " but was " + localCheckpoint__        assert pendingInSync.contains(allocationId) == false : "shard copy " + allocationId + " is already marked as pending in-sync"__        assert cps.tracked : "shard copy " + allocationId + " cannot be marked as in-sync as it's not tracked"__        updateLocalCheckpoint(allocationId, cps, localCheckpoint)__        _        _        assert !cps.inSync || (cps.localCheckpoint >= getGlobalCheckpoint()) :_            "shard copy " + allocationId + " that's already in-sync should have a local checkpoint " + cps.localCheckpoint +_                " that's above the global checkpoint " + getGlobalCheckpoint()__        if (cps.localCheckpoint < getGlobalCheckpoint()) {_            pendingInSync.add(allocationId)__            try {_                while (true) {_                    if (pendingInSync.contains(allocationId)) {_                        waitForLocalCheckpointToAdvance()__                    } else {_                        break__                    }_                }_            } finally {_                pendingInSync.remove(allocationId)__            }_        } else {_            cps.inSync = true__            replicationGroup = calculateReplicationGroup()__            logger.trace("marked [{}] as in-sync", allocationId)__            updateGlobalCheckpointOnPrimary()__        }__        assert invariant()__    };marks,the,shard,with,the,provided,allocation,id,as,in,sync,with,the,primary,shard,this,method,will,block,until,the,local,checkpoint,on,the,specified,shard,advances,above,the,current,global,checkpoint,param,allocation,id,the,allocation,id,of,the,shard,to,mark,as,in,sync,param,local,checkpoint,the,current,local,checkpoint,on,the,shard;public,synchronized,void,mark,allocation,id,as,in,sync,final,string,allocation,id,final,long,local,checkpoint,throws,interrupted,exception,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,checkpoint,state,cps,checkpoints,get,allocation,id,if,cps,null,throw,new,illegal,state,exception,no,local,checkpoint,tracking,information,available,for,allocation,id,assert,local,checkpoint,sequence,numbers,expected,known,local,checkpoint,for,allocation,id,but,was,local,checkpoint,assert,pending,in,sync,contains,allocation,id,false,shard,copy,allocation,id,is,already,marked,as,pending,in,sync,assert,cps,tracked,shard,copy,allocation,id,cannot,be,marked,as,in,sync,as,it,s,not,tracked,update,local,checkpoint,allocation,id,cps,local,checkpoint,assert,cps,in,sync,cps,local,checkpoint,get,global,checkpoint,shard,copy,allocation,id,that,s,already,in,sync,should,have,a,local,checkpoint,cps,local,checkpoint,that,s,above,the,global,checkpoint,get,global,checkpoint,if,cps,local,checkpoint,get,global,checkpoint,pending,in,sync,add,allocation,id,try,while,true,if,pending,in,sync,contains,allocation,id,wait,for,local,checkpoint,to,advance,else,break,finally,pending,in,sync,remove,allocation,id,else,cps,in,sync,true,replication,group,calculate,replication,group,logger,trace,marked,as,in,sync,allocation,id,update,global,checkpoint,on,primary,assert,invariant
ReplicationTracker -> public synchronized void markAllocationIdAsInSync(final String allocationId, final long localCheckpoint) throws InterruptedException;1547332999;Marks the shard with the provided allocation ID as in-sync with the primary shard. This method will block until the local checkpoint_on the specified shard advances above the current global checkpoint.__@param allocationId    the allocation ID of the shard to mark as in-sync_@param localCheckpoint the current local checkpoint on the shard;public synchronized void markAllocationIdAsInSync(final String allocationId, final long localCheckpoint) throws InterruptedException {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        CheckpointState cps = checkpoints.get(allocationId)__        if (cps == null) {_            _            throw new IllegalStateException("no local checkpoint tracking information available for " + allocationId)__        }_        assert localCheckpoint >= SequenceNumbers.NO_OPS_PERFORMED :_            "expected known local checkpoint for " + allocationId + " but was " + localCheckpoint__        assert pendingInSync.contains(allocationId) == false : "shard copy " + allocationId + " is already marked as pending in-sync"__        assert cps.tracked : "shard copy " + allocationId + " cannot be marked as in-sync as it's not tracked"__        updateLocalCheckpoint(allocationId, cps, localCheckpoint)__        _        _        assert !cps.inSync || (cps.localCheckpoint >= getGlobalCheckpoint()) :_            "shard copy " + allocationId + " that's already in-sync should have a local checkpoint " + cps.localCheckpoint +_                " that's above the global checkpoint " + getGlobalCheckpoint()__        if (cps.localCheckpoint < getGlobalCheckpoint()) {_            pendingInSync.add(allocationId)__            try {_                while (true) {_                    if (pendingInSync.contains(allocationId)) {_                        waitForLocalCheckpointToAdvance()__                    } else {_                        break__                    }_                }_            } finally {_                pendingInSync.remove(allocationId)__            }_        } else {_            cps.inSync = true__            replicationGroup = calculateReplicationGroup()__            logger.trace("marked [{}] as in-sync", allocationId)__            updateGlobalCheckpointOnPrimary()__        }__        assert invariant()__    };marks,the,shard,with,the,provided,allocation,id,as,in,sync,with,the,primary,shard,this,method,will,block,until,the,local,checkpoint,on,the,specified,shard,advances,above,the,current,global,checkpoint,param,allocation,id,the,allocation,id,of,the,shard,to,mark,as,in,sync,param,local,checkpoint,the,current,local,checkpoint,on,the,shard;public,synchronized,void,mark,allocation,id,as,in,sync,final,string,allocation,id,final,long,local,checkpoint,throws,interrupted,exception,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,checkpoint,state,cps,checkpoints,get,allocation,id,if,cps,null,throw,new,illegal,state,exception,no,local,checkpoint,tracking,information,available,for,allocation,id,assert,local,checkpoint,sequence,numbers,expected,known,local,checkpoint,for,allocation,id,but,was,local,checkpoint,assert,pending,in,sync,contains,allocation,id,false,shard,copy,allocation,id,is,already,marked,as,pending,in,sync,assert,cps,tracked,shard,copy,allocation,id,cannot,be,marked,as,in,sync,as,it,s,not,tracked,update,local,checkpoint,allocation,id,cps,local,checkpoint,assert,cps,in,sync,cps,local,checkpoint,get,global,checkpoint,shard,copy,allocation,id,that,s,already,in,sync,should,have,a,local,checkpoint,cps,local,checkpoint,that,s,above,the,global,checkpoint,get,global,checkpoint,if,cps,local,checkpoint,get,global,checkpoint,pending,in,sync,add,allocation,id,try,while,true,if,pending,in,sync,contains,allocation,id,wait,for,local,checkpoint,to,advance,else,break,finally,pending,in,sync,remove,allocation,id,else,cps,in,sync,true,replication,group,calculate,replication,group,logger,trace,marked,as,in,sync,allocation,id,update,global,checkpoint,on,primary,assert,invariant
ReplicationTracker -> public synchronized void markAllocationIdAsInSync(final String allocationId, final long localCheckpoint) throws InterruptedException;1548593396;Marks the shard with the provided allocation ID as in-sync with the primary shard. This method will block until the local checkpoint_on the specified shard advances above the current global checkpoint.__@param allocationId    the allocation ID of the shard to mark as in-sync_@param localCheckpoint the current local checkpoint on the shard;public synchronized void markAllocationIdAsInSync(final String allocationId, final long localCheckpoint) throws InterruptedException {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        CheckpointState cps = checkpoints.get(allocationId)__        if (cps == null) {_            _            throw new IllegalStateException("no local checkpoint tracking information available for " + allocationId)__        }_        assert localCheckpoint >= SequenceNumbers.NO_OPS_PERFORMED :_            "expected known local checkpoint for " + allocationId + " but was " + localCheckpoint__        assert pendingInSync.contains(allocationId) == false : "shard copy " + allocationId + " is already marked as pending in-sync"__        assert cps.tracked : "shard copy " + allocationId + " cannot be marked as in-sync as it's not tracked"__        updateLocalCheckpoint(allocationId, cps, localCheckpoint)__        _        _        assert !cps.inSync || (cps.localCheckpoint >= getGlobalCheckpoint()) :_            "shard copy " + allocationId + " that's already in-sync should have a local checkpoint " + cps.localCheckpoint +_                " that's above the global checkpoint " + getGlobalCheckpoint()__        if (cps.localCheckpoint < getGlobalCheckpoint()) {_            pendingInSync.add(allocationId)__            try {_                while (true) {_                    if (pendingInSync.contains(allocationId)) {_                        waitForLocalCheckpointToAdvance()__                    } else {_                        break__                    }_                }_            } finally {_                pendingInSync.remove(allocationId)__            }_        } else {_            cps.inSync = true__            replicationGroup = calculateReplicationGroup()__            logger.trace("marked [{}] as in-sync", allocationId)__            updateGlobalCheckpointOnPrimary()__        }__        assert invariant()__    };marks,the,shard,with,the,provided,allocation,id,as,in,sync,with,the,primary,shard,this,method,will,block,until,the,local,checkpoint,on,the,specified,shard,advances,above,the,current,global,checkpoint,param,allocation,id,the,allocation,id,of,the,shard,to,mark,as,in,sync,param,local,checkpoint,the,current,local,checkpoint,on,the,shard;public,synchronized,void,mark,allocation,id,as,in,sync,final,string,allocation,id,final,long,local,checkpoint,throws,interrupted,exception,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,checkpoint,state,cps,checkpoints,get,allocation,id,if,cps,null,throw,new,illegal,state,exception,no,local,checkpoint,tracking,information,available,for,allocation,id,assert,local,checkpoint,sequence,numbers,expected,known,local,checkpoint,for,allocation,id,but,was,local,checkpoint,assert,pending,in,sync,contains,allocation,id,false,shard,copy,allocation,id,is,already,marked,as,pending,in,sync,assert,cps,tracked,shard,copy,allocation,id,cannot,be,marked,as,in,sync,as,it,s,not,tracked,update,local,checkpoint,allocation,id,cps,local,checkpoint,assert,cps,in,sync,cps,local,checkpoint,get,global,checkpoint,shard,copy,allocation,id,that,s,already,in,sync,should,have,a,local,checkpoint,cps,local,checkpoint,that,s,above,the,global,checkpoint,get,global,checkpoint,if,cps,local,checkpoint,get,global,checkpoint,pending,in,sync,add,allocation,id,try,while,true,if,pending,in,sync,contains,allocation,id,wait,for,local,checkpoint,to,advance,else,break,finally,pending,in,sync,remove,allocation,id,else,cps,in,sync,true,replication,group,calculate,replication,group,logger,trace,marked,as,in,sync,allocation,id,update,global,checkpoint,on,primary,assert,invariant
ReplicationTracker -> public synchronized void markAllocationIdAsInSync(final String allocationId, final long localCheckpoint) throws InterruptedException;1548594827;Marks the shard with the provided allocation ID as in-sync with the primary shard. This method will block until the local checkpoint_on the specified shard advances above the current global checkpoint.__@param allocationId    the allocation ID of the shard to mark as in-sync_@param localCheckpoint the current local checkpoint on the shard;public synchronized void markAllocationIdAsInSync(final String allocationId, final long localCheckpoint) throws InterruptedException {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        CheckpointState cps = checkpoints.get(allocationId)__        if (cps == null) {_            _            throw new IllegalStateException("no local checkpoint tracking information available for " + allocationId)__        }_        assert localCheckpoint >= SequenceNumbers.NO_OPS_PERFORMED :_            "expected known local checkpoint for " + allocationId + " but was " + localCheckpoint__        assert pendingInSync.contains(allocationId) == false : "shard copy " + allocationId + " is already marked as pending in-sync"__        assert cps.tracked : "shard copy " + allocationId + " cannot be marked as in-sync as it's not tracked"__        updateLocalCheckpoint(allocationId, cps, localCheckpoint)__        _        _        assert !cps.inSync || (cps.localCheckpoint >= getGlobalCheckpoint()) :_            "shard copy " + allocationId + " that's already in-sync should have a local checkpoint " + cps.localCheckpoint +_                " that's above the global checkpoint " + getGlobalCheckpoint()__        if (cps.localCheckpoint < getGlobalCheckpoint()) {_            pendingInSync.add(allocationId)__            try {_                while (true) {_                    if (pendingInSync.contains(allocationId)) {_                        waitForLocalCheckpointToAdvance()__                    } else {_                        break__                    }_                }_            } finally {_                pendingInSync.remove(allocationId)__            }_        } else {_            cps.inSync = true__            replicationGroup = calculateReplicationGroup()__            logger.trace("marked [{}] as in-sync", allocationId)__            updateGlobalCheckpointOnPrimary()__        }__        assert invariant()__    };marks,the,shard,with,the,provided,allocation,id,as,in,sync,with,the,primary,shard,this,method,will,block,until,the,local,checkpoint,on,the,specified,shard,advances,above,the,current,global,checkpoint,param,allocation,id,the,allocation,id,of,the,shard,to,mark,as,in,sync,param,local,checkpoint,the,current,local,checkpoint,on,the,shard;public,synchronized,void,mark,allocation,id,as,in,sync,final,string,allocation,id,final,long,local,checkpoint,throws,interrupted,exception,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,checkpoint,state,cps,checkpoints,get,allocation,id,if,cps,null,throw,new,illegal,state,exception,no,local,checkpoint,tracking,information,available,for,allocation,id,assert,local,checkpoint,sequence,numbers,expected,known,local,checkpoint,for,allocation,id,but,was,local,checkpoint,assert,pending,in,sync,contains,allocation,id,false,shard,copy,allocation,id,is,already,marked,as,pending,in,sync,assert,cps,tracked,shard,copy,allocation,id,cannot,be,marked,as,in,sync,as,it,s,not,tracked,update,local,checkpoint,allocation,id,cps,local,checkpoint,assert,cps,in,sync,cps,local,checkpoint,get,global,checkpoint,shard,copy,allocation,id,that,s,already,in,sync,should,have,a,local,checkpoint,cps,local,checkpoint,that,s,above,the,global,checkpoint,get,global,checkpoint,if,cps,local,checkpoint,get,global,checkpoint,pending,in,sync,add,allocation,id,try,while,true,if,pending,in,sync,contains,allocation,id,wait,for,local,checkpoint,to,advance,else,break,finally,pending,in,sync,remove,allocation,id,else,cps,in,sync,true,replication,group,calculate,replication,group,logger,trace,marked,as,in,sync,allocation,id,update,global,checkpoint,on,primary,assert,invariant
ReplicationTracker -> public synchronized void markAllocationIdAsInSync(final String allocationId, final long localCheckpoint) throws InterruptedException;1548677511;Marks the shard with the provided allocation ID as in-sync with the primary shard. This method will block until the local checkpoint_on the specified shard advances above the current global checkpoint.__@param allocationId    the allocation ID of the shard to mark as in-sync_@param localCheckpoint the current local checkpoint on the shard;public synchronized void markAllocationIdAsInSync(final String allocationId, final long localCheckpoint) throws InterruptedException {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        CheckpointState cps = checkpoints.get(allocationId)__        if (cps == null) {_            _            throw new IllegalStateException("no local checkpoint tracking information available for " + allocationId)__        }_        assert localCheckpoint >= SequenceNumbers.NO_OPS_PERFORMED :_            "expected known local checkpoint for " + allocationId + " but was " + localCheckpoint__        assert pendingInSync.contains(allocationId) == false : "shard copy " + allocationId + " is already marked as pending in-sync"__        assert cps.tracked : "shard copy " + allocationId + " cannot be marked as in-sync as it's not tracked"__        updateLocalCheckpoint(allocationId, cps, localCheckpoint)__        _        _        assert !cps.inSync || (cps.localCheckpoint >= getGlobalCheckpoint()) :_            "shard copy " + allocationId + " that's already in-sync should have a local checkpoint " + cps.localCheckpoint +_                " that's above the global checkpoint " + getGlobalCheckpoint()__        if (cps.localCheckpoint < getGlobalCheckpoint()) {_            pendingInSync.add(allocationId)__            try {_                while (true) {_                    if (pendingInSync.contains(allocationId)) {_                        waitForLocalCheckpointToAdvance()__                    } else {_                        break__                    }_                }_            } finally {_                pendingInSync.remove(allocationId)__            }_        } else {_            cps.inSync = true__            replicationGroup = calculateReplicationGroup()__            logger.trace("marked [{}] as in-sync", allocationId)__            updateGlobalCheckpointOnPrimary()__        }__        assert invariant()__    };marks,the,shard,with,the,provided,allocation,id,as,in,sync,with,the,primary,shard,this,method,will,block,until,the,local,checkpoint,on,the,specified,shard,advances,above,the,current,global,checkpoint,param,allocation,id,the,allocation,id,of,the,shard,to,mark,as,in,sync,param,local,checkpoint,the,current,local,checkpoint,on,the,shard;public,synchronized,void,mark,allocation,id,as,in,sync,final,string,allocation,id,final,long,local,checkpoint,throws,interrupted,exception,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,checkpoint,state,cps,checkpoints,get,allocation,id,if,cps,null,throw,new,illegal,state,exception,no,local,checkpoint,tracking,information,available,for,allocation,id,assert,local,checkpoint,sequence,numbers,expected,known,local,checkpoint,for,allocation,id,but,was,local,checkpoint,assert,pending,in,sync,contains,allocation,id,false,shard,copy,allocation,id,is,already,marked,as,pending,in,sync,assert,cps,tracked,shard,copy,allocation,id,cannot,be,marked,as,in,sync,as,it,s,not,tracked,update,local,checkpoint,allocation,id,cps,local,checkpoint,assert,cps,in,sync,cps,local,checkpoint,get,global,checkpoint,shard,copy,allocation,id,that,s,already,in,sync,should,have,a,local,checkpoint,cps,local,checkpoint,that,s,above,the,global,checkpoint,get,global,checkpoint,if,cps,local,checkpoint,get,global,checkpoint,pending,in,sync,add,allocation,id,try,while,true,if,pending,in,sync,contains,allocation,id,wait,for,local,checkpoint,to,advance,else,break,finally,pending,in,sync,remove,allocation,id,else,cps,in,sync,true,replication,group,calculate,replication,group,logger,trace,marked,as,in,sync,allocation,id,update,global,checkpoint,on,primary,assert,invariant
ReplicationTracker -> public synchronized void markAllocationIdAsInSync(final String allocationId, final long localCheckpoint) throws InterruptedException;1548944389;Marks the shard with the provided allocation ID as in-sync with the primary shard. This method will block until the local checkpoint_on the specified shard advances above the current global checkpoint.__@param allocationId    the allocation ID of the shard to mark as in-sync_@param localCheckpoint the current local checkpoint on the shard;public synchronized void markAllocationIdAsInSync(final String allocationId, final long localCheckpoint) throws InterruptedException {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        CheckpointState cps = checkpoints.get(allocationId)__        if (cps == null) {_            _            throw new IllegalStateException("no local checkpoint tracking information available for " + allocationId)__        }_        assert localCheckpoint >= SequenceNumbers.NO_OPS_PERFORMED :_            "expected known local checkpoint for " + allocationId + " but was " + localCheckpoint__        assert pendingInSync.contains(allocationId) == false : "shard copy " + allocationId + " is already marked as pending in-sync"__        assert cps.tracked : "shard copy " + allocationId + " cannot be marked as in-sync as it's not tracked"__        updateLocalCheckpoint(allocationId, cps, localCheckpoint)__        _        _        assert !cps.inSync || (cps.localCheckpoint >= getGlobalCheckpoint()) :_            "shard copy " + allocationId + " that's already in-sync should have a local checkpoint " + cps.localCheckpoint +_                " that's above the global checkpoint " + getGlobalCheckpoint()__        if (cps.localCheckpoint < getGlobalCheckpoint()) {_            pendingInSync.add(allocationId)__            try {_                while (true) {_                    if (pendingInSync.contains(allocationId)) {_                        waitForLocalCheckpointToAdvance()__                    } else {_                        break__                    }_                }_            } finally {_                pendingInSync.remove(allocationId)__            }_        } else {_            cps.inSync = true__            replicationGroup = calculateReplicationGroup()__            logger.trace("marked [{}] as in-sync", allocationId)__            updateGlobalCheckpointOnPrimary()__        }__        assert invariant()__    };marks,the,shard,with,the,provided,allocation,id,as,in,sync,with,the,primary,shard,this,method,will,block,until,the,local,checkpoint,on,the,specified,shard,advances,above,the,current,global,checkpoint,param,allocation,id,the,allocation,id,of,the,shard,to,mark,as,in,sync,param,local,checkpoint,the,current,local,checkpoint,on,the,shard;public,synchronized,void,mark,allocation,id,as,in,sync,final,string,allocation,id,final,long,local,checkpoint,throws,interrupted,exception,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,checkpoint,state,cps,checkpoints,get,allocation,id,if,cps,null,throw,new,illegal,state,exception,no,local,checkpoint,tracking,information,available,for,allocation,id,assert,local,checkpoint,sequence,numbers,expected,known,local,checkpoint,for,allocation,id,but,was,local,checkpoint,assert,pending,in,sync,contains,allocation,id,false,shard,copy,allocation,id,is,already,marked,as,pending,in,sync,assert,cps,tracked,shard,copy,allocation,id,cannot,be,marked,as,in,sync,as,it,s,not,tracked,update,local,checkpoint,allocation,id,cps,local,checkpoint,assert,cps,in,sync,cps,local,checkpoint,get,global,checkpoint,shard,copy,allocation,id,that,s,already,in,sync,should,have,a,local,checkpoint,cps,local,checkpoint,that,s,above,the,global,checkpoint,get,global,checkpoint,if,cps,local,checkpoint,get,global,checkpoint,pending,in,sync,add,allocation,id,try,while,true,if,pending,in,sync,contains,allocation,id,wait,for,local,checkpoint,to,advance,else,break,finally,pending,in,sync,remove,allocation,id,else,cps,in,sync,true,replication,group,calculate,replication,group,logger,trace,marked,as,in,sync,allocation,id,update,global,checkpoint,on,primary,assert,invariant
ReplicationTracker -> public synchronized void markAllocationIdAsInSync(final String allocationId, final long localCheckpoint) throws InterruptedException;1549059559;Marks the shard with the provided allocation ID as in-sync with the primary shard. This method will block until the local checkpoint_on the specified shard advances above the current global checkpoint.__@param allocationId    the allocation ID of the shard to mark as in-sync_@param localCheckpoint the current local checkpoint on the shard;public synchronized void markAllocationIdAsInSync(final String allocationId, final long localCheckpoint) throws InterruptedException {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        CheckpointState cps = checkpoints.get(allocationId)__        if (cps == null) {_            _            throw new IllegalStateException("no local checkpoint tracking information available for " + allocationId)__        }_        assert localCheckpoint >= SequenceNumbers.NO_OPS_PERFORMED :_            "expected known local checkpoint for " + allocationId + " but was " + localCheckpoint__        assert pendingInSync.contains(allocationId) == false : "shard copy " + allocationId + " is already marked as pending in-sync"__        assert cps.tracked : "shard copy " + allocationId + " cannot be marked as in-sync as it's not tracked"__        updateLocalCheckpoint(allocationId, cps, localCheckpoint)__        _        _        assert !cps.inSync || (cps.localCheckpoint >= getGlobalCheckpoint()) :_            "shard copy " + allocationId + " that's already in-sync should have a local checkpoint " + cps.localCheckpoint +_                " that's above the global checkpoint " + getGlobalCheckpoint()__        if (cps.localCheckpoint < getGlobalCheckpoint()) {_            pendingInSync.add(allocationId)__            try {_                while (true) {_                    if (pendingInSync.contains(allocationId)) {_                        waitForLocalCheckpointToAdvance()__                    } else {_                        break__                    }_                }_            } finally {_                pendingInSync.remove(allocationId)__            }_        } else {_            cps.inSync = true__            replicationGroup = calculateReplicationGroup()__            logger.trace("marked [{}] as in-sync", allocationId)__            updateGlobalCheckpointOnPrimary()__        }__        assert invariant()__    };marks,the,shard,with,the,provided,allocation,id,as,in,sync,with,the,primary,shard,this,method,will,block,until,the,local,checkpoint,on,the,specified,shard,advances,above,the,current,global,checkpoint,param,allocation,id,the,allocation,id,of,the,shard,to,mark,as,in,sync,param,local,checkpoint,the,current,local,checkpoint,on,the,shard;public,synchronized,void,mark,allocation,id,as,in,sync,final,string,allocation,id,final,long,local,checkpoint,throws,interrupted,exception,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,checkpoint,state,cps,checkpoints,get,allocation,id,if,cps,null,throw,new,illegal,state,exception,no,local,checkpoint,tracking,information,available,for,allocation,id,assert,local,checkpoint,sequence,numbers,expected,known,local,checkpoint,for,allocation,id,but,was,local,checkpoint,assert,pending,in,sync,contains,allocation,id,false,shard,copy,allocation,id,is,already,marked,as,pending,in,sync,assert,cps,tracked,shard,copy,allocation,id,cannot,be,marked,as,in,sync,as,it,s,not,tracked,update,local,checkpoint,allocation,id,cps,local,checkpoint,assert,cps,in,sync,cps,local,checkpoint,get,global,checkpoint,shard,copy,allocation,id,that,s,already,in,sync,should,have,a,local,checkpoint,cps,local,checkpoint,that,s,above,the,global,checkpoint,get,global,checkpoint,if,cps,local,checkpoint,get,global,checkpoint,pending,in,sync,add,allocation,id,try,while,true,if,pending,in,sync,contains,allocation,id,wait,for,local,checkpoint,to,advance,else,break,finally,pending,in,sync,remove,allocation,id,else,cps,in,sync,true,replication,group,calculate,replication,group,logger,trace,marked,as,in,sync,allocation,id,update,global,checkpoint,on,primary,assert,invariant
ReplicationTracker -> public synchronized void markAllocationIdAsInSync(final String allocationId, final long localCheckpoint) throws InterruptedException;1549294529;Marks the shard with the provided allocation ID as in-sync with the primary shard. This method will block until the local checkpoint_on the specified shard advances above the current global checkpoint.__@param allocationId    the allocation ID of the shard to mark as in-sync_@param localCheckpoint the current local checkpoint on the shard;public synchronized void markAllocationIdAsInSync(final String allocationId, final long localCheckpoint) throws InterruptedException {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        CheckpointState cps = checkpoints.get(allocationId)__        if (cps == null) {_            _            throw new IllegalStateException("no local checkpoint tracking information available for " + allocationId)__        }_        assert localCheckpoint >= SequenceNumbers.NO_OPS_PERFORMED :_            "expected known local checkpoint for " + allocationId + " but was " + localCheckpoint__        assert pendingInSync.contains(allocationId) == false : "shard copy " + allocationId + " is already marked as pending in-sync"__        assert cps.tracked : "shard copy " + allocationId + " cannot be marked as in-sync as it's not tracked"__        updateLocalCheckpoint(allocationId, cps, localCheckpoint)__        _        _        assert !cps.inSync || (cps.localCheckpoint >= getGlobalCheckpoint()) :_            "shard copy " + allocationId + " that's already in-sync should have a local checkpoint " + cps.localCheckpoint +_                " that's above the global checkpoint " + getGlobalCheckpoint()__        if (cps.localCheckpoint < getGlobalCheckpoint()) {_            pendingInSync.add(allocationId)__            try {_                while (true) {_                    if (pendingInSync.contains(allocationId)) {_                        waitForLocalCheckpointToAdvance()__                    } else {_                        break__                    }_                }_            } finally {_                pendingInSync.remove(allocationId)__            }_        } else {_            cps.inSync = true__            replicationGroup = calculateReplicationGroup()__            logger.trace("marked [{}] as in-sync", allocationId)__            updateGlobalCheckpointOnPrimary()__        }__        assert invariant()__    };marks,the,shard,with,the,provided,allocation,id,as,in,sync,with,the,primary,shard,this,method,will,block,until,the,local,checkpoint,on,the,specified,shard,advances,above,the,current,global,checkpoint,param,allocation,id,the,allocation,id,of,the,shard,to,mark,as,in,sync,param,local,checkpoint,the,current,local,checkpoint,on,the,shard;public,synchronized,void,mark,allocation,id,as,in,sync,final,string,allocation,id,final,long,local,checkpoint,throws,interrupted,exception,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,checkpoint,state,cps,checkpoints,get,allocation,id,if,cps,null,throw,new,illegal,state,exception,no,local,checkpoint,tracking,information,available,for,allocation,id,assert,local,checkpoint,sequence,numbers,expected,known,local,checkpoint,for,allocation,id,but,was,local,checkpoint,assert,pending,in,sync,contains,allocation,id,false,shard,copy,allocation,id,is,already,marked,as,pending,in,sync,assert,cps,tracked,shard,copy,allocation,id,cannot,be,marked,as,in,sync,as,it,s,not,tracked,update,local,checkpoint,allocation,id,cps,local,checkpoint,assert,cps,in,sync,cps,local,checkpoint,get,global,checkpoint,shard,copy,allocation,id,that,s,already,in,sync,should,have,a,local,checkpoint,cps,local,checkpoint,that,s,above,the,global,checkpoint,get,global,checkpoint,if,cps,local,checkpoint,get,global,checkpoint,pending,in,sync,add,allocation,id,try,while,true,if,pending,in,sync,contains,allocation,id,wait,for,local,checkpoint,to,advance,else,break,finally,pending,in,sync,remove,allocation,id,else,cps,in,sync,true,replication,group,calculate,replication,group,logger,trace,marked,as,in,sync,allocation,id,update,global,checkpoint,on,primary,assert,invariant
ReplicationTracker -> public synchronized void markAllocationIdAsInSync(final String allocationId, final long localCheckpoint) throws InterruptedException;1549395737;Marks the shard with the provided allocation ID as in-sync with the primary shard. This method will block until the local checkpoint_on the specified shard advances above the current global checkpoint.__@param allocationId    the allocation ID of the shard to mark as in-sync_@param localCheckpoint the current local checkpoint on the shard;public synchronized void markAllocationIdAsInSync(final String allocationId, final long localCheckpoint) throws InterruptedException {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        CheckpointState cps = checkpoints.get(allocationId)__        if (cps == null) {_            _            throw new IllegalStateException("no local checkpoint tracking information available for " + allocationId)__        }_        assert localCheckpoint >= SequenceNumbers.NO_OPS_PERFORMED :_            "expected known local checkpoint for " + allocationId + " but was " + localCheckpoint__        assert pendingInSync.contains(allocationId) == false : "shard copy " + allocationId + " is already marked as pending in-sync"__        assert cps.tracked : "shard copy " + allocationId + " cannot be marked as in-sync as it's not tracked"__        updateLocalCheckpoint(allocationId, cps, localCheckpoint)__        _        _        assert !cps.inSync || (cps.localCheckpoint >= getGlobalCheckpoint()) :_            "shard copy " + allocationId + " that's already in-sync should have a local checkpoint " + cps.localCheckpoint +_                " that's above the global checkpoint " + getGlobalCheckpoint()__        if (cps.localCheckpoint < getGlobalCheckpoint()) {_            pendingInSync.add(allocationId)__            try {_                while (true) {_                    if (pendingInSync.contains(allocationId)) {_                        waitForLocalCheckpointToAdvance()__                    } else {_                        break__                    }_                }_            } finally {_                pendingInSync.remove(allocationId)__            }_        } else {_            cps.inSync = true__            replicationGroup = calculateReplicationGroup()__            logger.trace("marked [{}] as in-sync", allocationId)__            updateGlobalCheckpointOnPrimary()__        }__        assert invariant()__    };marks,the,shard,with,the,provided,allocation,id,as,in,sync,with,the,primary,shard,this,method,will,block,until,the,local,checkpoint,on,the,specified,shard,advances,above,the,current,global,checkpoint,param,allocation,id,the,allocation,id,of,the,shard,to,mark,as,in,sync,param,local,checkpoint,the,current,local,checkpoint,on,the,shard;public,synchronized,void,mark,allocation,id,as,in,sync,final,string,allocation,id,final,long,local,checkpoint,throws,interrupted,exception,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,checkpoint,state,cps,checkpoints,get,allocation,id,if,cps,null,throw,new,illegal,state,exception,no,local,checkpoint,tracking,information,available,for,allocation,id,assert,local,checkpoint,sequence,numbers,expected,known,local,checkpoint,for,allocation,id,but,was,local,checkpoint,assert,pending,in,sync,contains,allocation,id,false,shard,copy,allocation,id,is,already,marked,as,pending,in,sync,assert,cps,tracked,shard,copy,allocation,id,cannot,be,marked,as,in,sync,as,it,s,not,tracked,update,local,checkpoint,allocation,id,cps,local,checkpoint,assert,cps,in,sync,cps,local,checkpoint,get,global,checkpoint,shard,copy,allocation,id,that,s,already,in,sync,should,have,a,local,checkpoint,cps,local,checkpoint,that,s,above,the,global,checkpoint,get,global,checkpoint,if,cps,local,checkpoint,get,global,checkpoint,pending,in,sync,add,allocation,id,try,while,true,if,pending,in,sync,contains,allocation,id,wait,for,local,checkpoint,to,advance,else,break,finally,pending,in,sync,remove,allocation,id,else,cps,in,sync,true,replication,group,calculate,replication,group,logger,trace,marked,as,in,sync,allocation,id,update,global,checkpoint,on,primary,assert,invariant
ReplicationTracker -> public synchronized void markAllocationIdAsInSync(final String allocationId, final long localCheckpoint) throws InterruptedException;1549937843;Marks the shard with the provided allocation ID as in-sync with the primary shard. This method will block until the local checkpoint_on the specified shard advances above the current global checkpoint.__@param allocationId    the allocation ID of the shard to mark as in-sync_@param localCheckpoint the current local checkpoint on the shard;public synchronized void markAllocationIdAsInSync(final String allocationId, final long localCheckpoint) throws InterruptedException {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        CheckpointState cps = checkpoints.get(allocationId)__        if (cps == null) {_            _            throw new IllegalStateException("no local checkpoint tracking information available for " + allocationId)__        }_        assert localCheckpoint >= SequenceNumbers.NO_OPS_PERFORMED :_            "expected known local checkpoint for " + allocationId + " but was " + localCheckpoint__        assert pendingInSync.contains(allocationId) == false : "shard copy " + allocationId + " is already marked as pending in-sync"__        assert cps.tracked : "shard copy " + allocationId + " cannot be marked as in-sync as it's not tracked"__        updateLocalCheckpoint(allocationId, cps, localCheckpoint)__        _        _        assert !cps.inSync || (cps.localCheckpoint >= getGlobalCheckpoint()) :_            "shard copy " + allocationId + " that's already in-sync should have a local checkpoint " + cps.localCheckpoint +_                " that's above the global checkpoint " + getGlobalCheckpoint()__        if (cps.localCheckpoint < getGlobalCheckpoint()) {_            pendingInSync.add(allocationId)__            try {_                while (true) {_                    if (pendingInSync.contains(allocationId)) {_                        waitForLocalCheckpointToAdvance()__                    } else {_                        break__                    }_                }_            } finally {_                pendingInSync.remove(allocationId)__            }_        } else {_            cps.inSync = true__            replicationGroup = calculateReplicationGroup()__            logger.trace("marked [{}] as in-sync", allocationId)__            updateGlobalCheckpointOnPrimary()__        }__        assert invariant()__    };marks,the,shard,with,the,provided,allocation,id,as,in,sync,with,the,primary,shard,this,method,will,block,until,the,local,checkpoint,on,the,specified,shard,advances,above,the,current,global,checkpoint,param,allocation,id,the,allocation,id,of,the,shard,to,mark,as,in,sync,param,local,checkpoint,the,current,local,checkpoint,on,the,shard;public,synchronized,void,mark,allocation,id,as,in,sync,final,string,allocation,id,final,long,local,checkpoint,throws,interrupted,exception,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,checkpoint,state,cps,checkpoints,get,allocation,id,if,cps,null,throw,new,illegal,state,exception,no,local,checkpoint,tracking,information,available,for,allocation,id,assert,local,checkpoint,sequence,numbers,expected,known,local,checkpoint,for,allocation,id,but,was,local,checkpoint,assert,pending,in,sync,contains,allocation,id,false,shard,copy,allocation,id,is,already,marked,as,pending,in,sync,assert,cps,tracked,shard,copy,allocation,id,cannot,be,marked,as,in,sync,as,it,s,not,tracked,update,local,checkpoint,allocation,id,cps,local,checkpoint,assert,cps,in,sync,cps,local,checkpoint,get,global,checkpoint,shard,copy,allocation,id,that,s,already,in,sync,should,have,a,local,checkpoint,cps,local,checkpoint,that,s,above,the,global,checkpoint,get,global,checkpoint,if,cps,local,checkpoint,get,global,checkpoint,pending,in,sync,add,allocation,id,try,while,true,if,pending,in,sync,contains,allocation,id,wait,for,local,checkpoint,to,advance,else,break,finally,pending,in,sync,remove,allocation,id,else,cps,in,sync,true,replication,group,calculate,replication,group,logger,trace,marked,as,in,sync,allocation,id,update,global,checkpoint,on,primary,assert,invariant
ReplicationTracker -> public synchronized void markAllocationIdAsInSync(final String allocationId, final long localCheckpoint) throws InterruptedException;1549949489;Marks the shard with the provided allocation ID as in-sync with the primary shard. This method will block until the local checkpoint_on the specified shard advances above the current global checkpoint.__@param allocationId    the allocation ID of the shard to mark as in-sync_@param localCheckpoint the current local checkpoint on the shard;public synchronized void markAllocationIdAsInSync(final String allocationId, final long localCheckpoint) throws InterruptedException {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        CheckpointState cps = checkpoints.get(allocationId)__        if (cps == null) {_            _            throw new IllegalStateException("no local checkpoint tracking information available for " + allocationId)__        }_        assert localCheckpoint >= SequenceNumbers.NO_OPS_PERFORMED :_            "expected known local checkpoint for " + allocationId + " but was " + localCheckpoint__        assert pendingInSync.contains(allocationId) == false : "shard copy " + allocationId + " is already marked as pending in-sync"__        assert cps.tracked : "shard copy " + allocationId + " cannot be marked as in-sync as it's not tracked"__        updateLocalCheckpoint(allocationId, cps, localCheckpoint)__        _        _        assert !cps.inSync || (cps.localCheckpoint >= getGlobalCheckpoint()) :_            "shard copy " + allocationId + " that's already in-sync should have a local checkpoint " + cps.localCheckpoint +_                " that's above the global checkpoint " + getGlobalCheckpoint()__        if (cps.localCheckpoint < getGlobalCheckpoint()) {_            pendingInSync.add(allocationId)__            try {_                while (true) {_                    if (pendingInSync.contains(allocationId)) {_                        waitForLocalCheckpointToAdvance()__                    } else {_                        break__                    }_                }_            } finally {_                pendingInSync.remove(allocationId)__            }_        } else {_            cps.inSync = true__            replicationGroup = calculateReplicationGroup()__            logger.trace("marked [{}] as in-sync", allocationId)__            updateGlobalCheckpointOnPrimary()__        }__        assert invariant()__    };marks,the,shard,with,the,provided,allocation,id,as,in,sync,with,the,primary,shard,this,method,will,block,until,the,local,checkpoint,on,the,specified,shard,advances,above,the,current,global,checkpoint,param,allocation,id,the,allocation,id,of,the,shard,to,mark,as,in,sync,param,local,checkpoint,the,current,local,checkpoint,on,the,shard;public,synchronized,void,mark,allocation,id,as,in,sync,final,string,allocation,id,final,long,local,checkpoint,throws,interrupted,exception,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,checkpoint,state,cps,checkpoints,get,allocation,id,if,cps,null,throw,new,illegal,state,exception,no,local,checkpoint,tracking,information,available,for,allocation,id,assert,local,checkpoint,sequence,numbers,expected,known,local,checkpoint,for,allocation,id,but,was,local,checkpoint,assert,pending,in,sync,contains,allocation,id,false,shard,copy,allocation,id,is,already,marked,as,pending,in,sync,assert,cps,tracked,shard,copy,allocation,id,cannot,be,marked,as,in,sync,as,it,s,not,tracked,update,local,checkpoint,allocation,id,cps,local,checkpoint,assert,cps,in,sync,cps,local,checkpoint,get,global,checkpoint,shard,copy,allocation,id,that,s,already,in,sync,should,have,a,local,checkpoint,cps,local,checkpoint,that,s,above,the,global,checkpoint,get,global,checkpoint,if,cps,local,checkpoint,get,global,checkpoint,pending,in,sync,add,allocation,id,try,while,true,if,pending,in,sync,contains,allocation,id,wait,for,local,checkpoint,to,advance,else,break,finally,pending,in,sync,remove,allocation,id,else,cps,in,sync,true,replication,group,calculate,replication,group,logger,trace,marked,as,in,sync,allocation,id,update,global,checkpoint,on,primary,assert,invariant
ReplicationTracker -> public synchronized void markAllocationIdAsInSync(final String allocationId, final long localCheckpoint) throws InterruptedException;1550526771;Marks the shard with the provided allocation ID as in-sync with the primary shard. This method will block until the local checkpoint_on the specified shard advances above the current global checkpoint.__@param allocationId    the allocation ID of the shard to mark as in-sync_@param localCheckpoint the current local checkpoint on the shard;public synchronized void markAllocationIdAsInSync(final String allocationId, final long localCheckpoint) throws InterruptedException {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        CheckpointState cps = checkpoints.get(allocationId)__        if (cps == null) {_            _            throw new IllegalStateException("no local checkpoint tracking information available for " + allocationId)__        }_        assert localCheckpoint >= SequenceNumbers.NO_OPS_PERFORMED :_            "expected known local checkpoint for " + allocationId + " but was " + localCheckpoint__        assert pendingInSync.contains(allocationId) == false : "shard copy " + allocationId + " is already marked as pending in-sync"__        assert cps.tracked : "shard copy " + allocationId + " cannot be marked as in-sync as it's not tracked"__        updateLocalCheckpoint(allocationId, cps, localCheckpoint)__        _        _        assert !cps.inSync || (cps.localCheckpoint >= getGlobalCheckpoint()) :_            "shard copy " + allocationId + " that's already in-sync should have a local checkpoint " + cps.localCheckpoint +_                " that's above the global checkpoint " + getGlobalCheckpoint()__        if (cps.localCheckpoint < getGlobalCheckpoint()) {_            pendingInSync.add(allocationId)__            try {_                while (true) {_                    if (pendingInSync.contains(allocationId)) {_                        waitForLocalCheckpointToAdvance()__                    } else {_                        break__                    }_                }_            } finally {_                pendingInSync.remove(allocationId)__            }_        } else {_            cps.inSync = true__            replicationGroup = calculateReplicationGroup()__            logger.trace("marked [{}] as in-sync", allocationId)__            updateGlobalCheckpointOnPrimary()__        }__        assert invariant()__    };marks,the,shard,with,the,provided,allocation,id,as,in,sync,with,the,primary,shard,this,method,will,block,until,the,local,checkpoint,on,the,specified,shard,advances,above,the,current,global,checkpoint,param,allocation,id,the,allocation,id,of,the,shard,to,mark,as,in,sync,param,local,checkpoint,the,current,local,checkpoint,on,the,shard;public,synchronized,void,mark,allocation,id,as,in,sync,final,string,allocation,id,final,long,local,checkpoint,throws,interrupted,exception,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,checkpoint,state,cps,checkpoints,get,allocation,id,if,cps,null,throw,new,illegal,state,exception,no,local,checkpoint,tracking,information,available,for,allocation,id,assert,local,checkpoint,sequence,numbers,expected,known,local,checkpoint,for,allocation,id,but,was,local,checkpoint,assert,pending,in,sync,contains,allocation,id,false,shard,copy,allocation,id,is,already,marked,as,pending,in,sync,assert,cps,tracked,shard,copy,allocation,id,cannot,be,marked,as,in,sync,as,it,s,not,tracked,update,local,checkpoint,allocation,id,cps,local,checkpoint,assert,cps,in,sync,cps,local,checkpoint,get,global,checkpoint,shard,copy,allocation,id,that,s,already,in,sync,should,have,a,local,checkpoint,cps,local,checkpoint,that,s,above,the,global,checkpoint,get,global,checkpoint,if,cps,local,checkpoint,get,global,checkpoint,pending,in,sync,add,allocation,id,try,while,true,if,pending,in,sync,contains,allocation,id,wait,for,local,checkpoint,to,advance,else,break,finally,pending,in,sync,remove,allocation,id,else,cps,in,sync,true,replication,group,calculate,replication,group,logger,trace,marked,as,in,sync,allocation,id,update,global,checkpoint,on,primary,assert,invariant
ReplicationTracker -> public synchronized void updateFromMaster(final long applyingClusterStateVersion, final Set<String> inSyncAllocationIds,                                               final IndexShardRoutingTable routingTable, final Set<String> pre60AllocationIds);1524684173;Notifies the tracker of the current allocation IDs in the cluster state.__@param applyingClusterStateVersion the cluster state version being applied when updating the allocation IDs from the master_@param inSyncAllocationIds         the allocation IDs of the currently in-sync shard copies_@param routingTable                the shard routing table_@param pre60AllocationIds          the allocation IDs of shards that are allocated to pre-6.0 nodes;public synchronized void updateFromMaster(final long applyingClusterStateVersion, final Set<String> inSyncAllocationIds,_                                              final IndexShardRoutingTable routingTable, final Set<String> pre60AllocationIds) {_        assert invariant()__        if (applyingClusterStateVersion > appliedClusterStateVersion) {_            _            assert !primaryMode || inSyncAllocationIds.stream().allMatch(_                inSyncId -> checkpoints.containsKey(inSyncId) && checkpoints.get(inSyncId).inSync) :_                "update from master in primary mode contains in-sync ids " + inSyncAllocationIds +_                    " that have no matching entries in " + checkpoints__            _            Set<String> initializingAllocationIds = routingTable.getAllInitializingShards().stream()_                .map(ShardRouting::allocationId).map(AllocationId::getId).collect(Collectors.toSet())__            boolean removedEntries = checkpoints.keySet().removeIf(_                aid -> !inSyncAllocationIds.contains(aid) && !initializingAllocationIds.contains(aid))___            if (primaryMode) {_                _                for (String initializingId : initializingAllocationIds) {_                    if (checkpoints.containsKey(initializingId) == false) {_                        final boolean inSync = inSyncAllocationIds.contains(initializingId)__                        assert inSync == false : "update from master in primary mode has " + initializingId +_                            " as in-sync but it does not exist locally"__                        final long localCheckpoint = pre60AllocationIds.contains(initializingId) ?_                            SequenceNumbers.PRE_60_NODE_CHECKPOINT : SequenceNumbers.UNASSIGNED_SEQ_NO__                        final long globalCheckpoint = localCheckpoint__                        checkpoints.put(initializingId, new CheckpointState(localCheckpoint, globalCheckpoint, inSync, inSync))__                    }_                }_            } else {_                for (String initializingId : initializingAllocationIds) {_                    if (shardAllocationId.equals(initializingId) == false) {_                        final long localCheckpoint = pre60AllocationIds.contains(initializingId) ?_                            SequenceNumbers.PRE_60_NODE_CHECKPOINT : SequenceNumbers.UNASSIGNED_SEQ_NO__                        final long globalCheckpoint = localCheckpoint__                        checkpoints.put(initializingId, new CheckpointState(localCheckpoint, globalCheckpoint, false, false))__                    }_                }_                for (String inSyncId : inSyncAllocationIds) {_                    if (shardAllocationId.equals(inSyncId)) {_                        _                        CheckpointState checkpointState = checkpoints.get(shardAllocationId)__                        checkpointState.inSync = true__                        checkpointState.tracked = true__                    } else {_                        final long localCheckpoint = pre60AllocationIds.contains(inSyncId) ?_                            SequenceNumbers.PRE_60_NODE_CHECKPOINT : SequenceNumbers.UNASSIGNED_SEQ_NO__                        final long globalCheckpoint = localCheckpoint__                        checkpoints.put(inSyncId, new CheckpointState(localCheckpoint, globalCheckpoint, true, true))__                    }_                }_            }_            appliedClusterStateVersion = applyingClusterStateVersion__            this.routingTable = routingTable__            replicationGroup = calculateReplicationGroup()__            if (primaryMode && removedEntries) {_                updateGlobalCheckpointOnPrimary()__            }_        }_        assert invariant()__    };notifies,the,tracker,of,the,current,allocation,ids,in,the,cluster,state,param,applying,cluster,state,version,the,cluster,state,version,being,applied,when,updating,the,allocation,ids,from,the,master,param,in,sync,allocation,ids,the,allocation,ids,of,the,currently,in,sync,shard,copies,param,routing,table,the,shard,routing,table,param,pre60allocation,ids,the,allocation,ids,of,shards,that,are,allocated,to,pre,6,0,nodes;public,synchronized,void,update,from,master,final,long,applying,cluster,state,version,final,set,string,in,sync,allocation,ids,final,index,shard,routing,table,routing,table,final,set,string,pre60allocation,ids,assert,invariant,if,applying,cluster,state,version,applied,cluster,state,version,assert,primary,mode,in,sync,allocation,ids,stream,all,match,in,sync,id,checkpoints,contains,key,in,sync,id,checkpoints,get,in,sync,id,in,sync,update,from,master,in,primary,mode,contains,in,sync,ids,in,sync,allocation,ids,that,have,no,matching,entries,in,checkpoints,set,string,initializing,allocation,ids,routing,table,get,all,initializing,shards,stream,map,shard,routing,allocation,id,map,allocation,id,get,id,collect,collectors,to,set,boolean,removed,entries,checkpoints,key,set,remove,if,aid,in,sync,allocation,ids,contains,aid,initializing,allocation,ids,contains,aid,if,primary,mode,for,string,initializing,id,initializing,allocation,ids,if,checkpoints,contains,key,initializing,id,false,final,boolean,in,sync,in,sync,allocation,ids,contains,initializing,id,assert,in,sync,false,update,from,master,in,primary,mode,has,initializing,id,as,in,sync,but,it,does,not,exist,locally,final,long,local,checkpoint,pre60allocation,ids,contains,initializing,id,sequence,numbers,sequence,numbers,final,long,global,checkpoint,local,checkpoint,checkpoints,put,initializing,id,new,checkpoint,state,local,checkpoint,global,checkpoint,in,sync,in,sync,else,for,string,initializing,id,initializing,allocation,ids,if,shard,allocation,id,equals,initializing,id,false,final,long,local,checkpoint,pre60allocation,ids,contains,initializing,id,sequence,numbers,sequence,numbers,final,long,global,checkpoint,local,checkpoint,checkpoints,put,initializing,id,new,checkpoint,state,local,checkpoint,global,checkpoint,false,false,for,string,in,sync,id,in,sync,allocation,ids,if,shard,allocation,id,equals,in,sync,id,checkpoint,state,checkpoint,state,checkpoints,get,shard,allocation,id,checkpoint,state,in,sync,true,checkpoint,state,tracked,true,else,final,long,local,checkpoint,pre60allocation,ids,contains,in,sync,id,sequence,numbers,sequence,numbers,final,long,global,checkpoint,local,checkpoint,checkpoints,put,in,sync,id,new,checkpoint,state,local,checkpoint,global,checkpoint,true,true,applied,cluster,state,version,applying,cluster,state,version,this,routing,table,routing,table,replication,group,calculate,replication,group,if,primary,mode,removed,entries,update,global,checkpoint,on,primary,assert,invariant
ReplicationTracker -> public synchronized void updateFromMaster(final long applyingClusterStateVersion, final Set<String> inSyncAllocationIds,                                               final IndexShardRoutingTable routingTable, final Set<String> pre60AllocationIds);1525334055;Notifies the tracker of the current allocation IDs in the cluster state.__@param applyingClusterStateVersion the cluster state version being applied when updating the allocation IDs from the master_@param inSyncAllocationIds         the allocation IDs of the currently in-sync shard copies_@param routingTable                the shard routing table_@param pre60AllocationIds          the allocation IDs of shards that are allocated to pre-6.0 nodes;public synchronized void updateFromMaster(final long applyingClusterStateVersion, final Set<String> inSyncAllocationIds,_                                              final IndexShardRoutingTable routingTable, final Set<String> pre60AllocationIds) {_        assert invariant()__        if (applyingClusterStateVersion > appliedClusterStateVersion) {_            _            assert !primaryMode || inSyncAllocationIds.stream().allMatch(_                inSyncId -> checkpoints.containsKey(inSyncId) && checkpoints.get(inSyncId).inSync) :_                "update from master in primary mode contains in-sync ids " + inSyncAllocationIds +_                    " that have no matching entries in " + checkpoints__            _            Set<String> initializingAllocationIds = routingTable.getAllInitializingShards().stream()_                .map(ShardRouting::allocationId).map(AllocationId::getId).collect(Collectors.toSet())__            boolean removedEntries = checkpoints.keySet().removeIf(_                aid -> !inSyncAllocationIds.contains(aid) && !initializingAllocationIds.contains(aid))___            if (primaryMode) {_                _                for (String initializingId : initializingAllocationIds) {_                    if (checkpoints.containsKey(initializingId) == false) {_                        final boolean inSync = inSyncAllocationIds.contains(initializingId)__                        assert inSync == false : "update from master in primary mode has " + initializingId +_                            " as in-sync but it does not exist locally"__                        final long localCheckpoint = pre60AllocationIds.contains(initializingId) ?_                            SequenceNumbers.PRE_60_NODE_CHECKPOINT : SequenceNumbers.UNASSIGNED_SEQ_NO__                        final long globalCheckpoint = localCheckpoint__                        checkpoints.put(initializingId, new CheckpointState(localCheckpoint, globalCheckpoint, inSync, inSync))__                    }_                }_                if (removedEntries) {_                    pendingInSync.removeIf(aId -> checkpoints.containsKey(aId) == false)__                }_            } else {_                for (String initializingId : initializingAllocationIds) {_                    if (shardAllocationId.equals(initializingId) == false) {_                        final long localCheckpoint = pre60AllocationIds.contains(initializingId) ?_                            SequenceNumbers.PRE_60_NODE_CHECKPOINT : SequenceNumbers.UNASSIGNED_SEQ_NO__                        final long globalCheckpoint = localCheckpoint__                        checkpoints.put(initializingId, new CheckpointState(localCheckpoint, globalCheckpoint, false, false))__                    }_                }_                for (String inSyncId : inSyncAllocationIds) {_                    if (shardAllocationId.equals(inSyncId)) {_                        _                        CheckpointState checkpointState = checkpoints.get(shardAllocationId)__                        checkpointState.inSync = true__                        checkpointState.tracked = true__                    } else {_                        final long localCheckpoint = pre60AllocationIds.contains(inSyncId) ?_                            SequenceNumbers.PRE_60_NODE_CHECKPOINT : SequenceNumbers.UNASSIGNED_SEQ_NO__                        final long globalCheckpoint = localCheckpoint__                        checkpoints.put(inSyncId, new CheckpointState(localCheckpoint, globalCheckpoint, true, true))__                    }_                }_            }_            appliedClusterStateVersion = applyingClusterStateVersion__            this.routingTable = routingTable__            replicationGroup = calculateReplicationGroup()__            if (primaryMode && removedEntries) {_                updateGlobalCheckpointOnPrimary()__                _                notifyAllWaiters()__            }_        }_        assert invariant()__    };notifies,the,tracker,of,the,current,allocation,ids,in,the,cluster,state,param,applying,cluster,state,version,the,cluster,state,version,being,applied,when,updating,the,allocation,ids,from,the,master,param,in,sync,allocation,ids,the,allocation,ids,of,the,currently,in,sync,shard,copies,param,routing,table,the,shard,routing,table,param,pre60allocation,ids,the,allocation,ids,of,shards,that,are,allocated,to,pre,6,0,nodes;public,synchronized,void,update,from,master,final,long,applying,cluster,state,version,final,set,string,in,sync,allocation,ids,final,index,shard,routing,table,routing,table,final,set,string,pre60allocation,ids,assert,invariant,if,applying,cluster,state,version,applied,cluster,state,version,assert,primary,mode,in,sync,allocation,ids,stream,all,match,in,sync,id,checkpoints,contains,key,in,sync,id,checkpoints,get,in,sync,id,in,sync,update,from,master,in,primary,mode,contains,in,sync,ids,in,sync,allocation,ids,that,have,no,matching,entries,in,checkpoints,set,string,initializing,allocation,ids,routing,table,get,all,initializing,shards,stream,map,shard,routing,allocation,id,map,allocation,id,get,id,collect,collectors,to,set,boolean,removed,entries,checkpoints,key,set,remove,if,aid,in,sync,allocation,ids,contains,aid,initializing,allocation,ids,contains,aid,if,primary,mode,for,string,initializing,id,initializing,allocation,ids,if,checkpoints,contains,key,initializing,id,false,final,boolean,in,sync,in,sync,allocation,ids,contains,initializing,id,assert,in,sync,false,update,from,master,in,primary,mode,has,initializing,id,as,in,sync,but,it,does,not,exist,locally,final,long,local,checkpoint,pre60allocation,ids,contains,initializing,id,sequence,numbers,sequence,numbers,final,long,global,checkpoint,local,checkpoint,checkpoints,put,initializing,id,new,checkpoint,state,local,checkpoint,global,checkpoint,in,sync,in,sync,if,removed,entries,pending,in,sync,remove,if,a,id,checkpoints,contains,key,a,id,false,else,for,string,initializing,id,initializing,allocation,ids,if,shard,allocation,id,equals,initializing,id,false,final,long,local,checkpoint,pre60allocation,ids,contains,initializing,id,sequence,numbers,sequence,numbers,final,long,global,checkpoint,local,checkpoint,checkpoints,put,initializing,id,new,checkpoint,state,local,checkpoint,global,checkpoint,false,false,for,string,in,sync,id,in,sync,allocation,ids,if,shard,allocation,id,equals,in,sync,id,checkpoint,state,checkpoint,state,checkpoints,get,shard,allocation,id,checkpoint,state,in,sync,true,checkpoint,state,tracked,true,else,final,long,local,checkpoint,pre60allocation,ids,contains,in,sync,id,sequence,numbers,sequence,numbers,final,long,global,checkpoint,local,checkpoint,checkpoints,put,in,sync,id,new,checkpoint,state,local,checkpoint,global,checkpoint,true,true,applied,cluster,state,version,applying,cluster,state,version,this,routing,table,routing,table,replication,group,calculate,replication,group,if,primary,mode,removed,entries,update,global,checkpoint,on,primary,notify,all,waiters,assert,invariant
ReplicationTracker -> public synchronized void updateFromMaster(final long applyingClusterStateVersion, final Set<String> inSyncAllocationIds,                                               final IndexShardRoutingTable routingTable, final Set<String> pre60AllocationIds);1533295538;Notifies the tracker of the current allocation IDs in the cluster state.__@param applyingClusterStateVersion the cluster state version being applied when updating the allocation IDs from the master_@param inSyncAllocationIds         the allocation IDs of the currently in-sync shard copies_@param routingTable                the shard routing table_@param pre60AllocationIds          the allocation IDs of shards that are allocated to pre-6.0 nodes;public synchronized void updateFromMaster(final long applyingClusterStateVersion, final Set<String> inSyncAllocationIds,_                                              final IndexShardRoutingTable routingTable, final Set<String> pre60AllocationIds) {_        assert invariant()__        if (applyingClusterStateVersion > appliedClusterStateVersion) {_            _            assert !primaryMode || inSyncAllocationIds.stream().allMatch(_                inSyncId -> checkpoints.containsKey(inSyncId) && checkpoints.get(inSyncId).inSync) :_                "update from master in primary mode contains in-sync ids " + inSyncAllocationIds +_                    " that have no matching entries in " + checkpoints__            _            Set<String> initializingAllocationIds = routingTable.getAllInitializingShards().stream()_                .map(ShardRouting::allocationId).map(AllocationId::getId).collect(Collectors.toSet())__            boolean removedEntries = checkpoints.keySet().removeIf(_                aid -> !inSyncAllocationIds.contains(aid) && !initializingAllocationIds.contains(aid))___            if (primaryMode) {_                _                for (String initializingId : initializingAllocationIds) {_                    if (checkpoints.containsKey(initializingId) == false) {_                        final boolean inSync = inSyncAllocationIds.contains(initializingId)__                        assert inSync == false : "update from master in primary mode has " + initializingId +_                            " as in-sync but it does not exist locally"__                        final long localCheckpoint = pre60AllocationIds.contains(initializingId) ?_                            SequenceNumbers.PRE_60_NODE_CHECKPOINT : SequenceNumbers.UNASSIGNED_SEQ_NO__                        final long globalCheckpoint = localCheckpoint__                        checkpoints.put(initializingId, new CheckpointState(localCheckpoint, globalCheckpoint, inSync, inSync))__                    }_                }_                if (removedEntries) {_                    pendingInSync.removeIf(aId -> checkpoints.containsKey(aId) == false)__                }_            } else {_                for (String initializingId : initializingAllocationIds) {_                    if (shardAllocationId.equals(initializingId) == false) {_                        final long localCheckpoint = pre60AllocationIds.contains(initializingId) ?_                            SequenceNumbers.PRE_60_NODE_CHECKPOINT : SequenceNumbers.UNASSIGNED_SEQ_NO__                        final long globalCheckpoint = localCheckpoint__                        checkpoints.put(initializingId, new CheckpointState(localCheckpoint, globalCheckpoint, false, false))__                    }_                }_                for (String inSyncId : inSyncAllocationIds) {_                    if (shardAllocationId.equals(inSyncId)) {_                        _                        CheckpointState checkpointState = checkpoints.get(shardAllocationId)__                        checkpointState.inSync = true__                        checkpointState.tracked = true__                    } else {_                        final long localCheckpoint = pre60AllocationIds.contains(inSyncId) ?_                            SequenceNumbers.PRE_60_NODE_CHECKPOINT : SequenceNumbers.UNASSIGNED_SEQ_NO__                        final long globalCheckpoint = localCheckpoint__                        checkpoints.put(inSyncId, new CheckpointState(localCheckpoint, globalCheckpoint, true, true))__                    }_                }_            }_            appliedClusterStateVersion = applyingClusterStateVersion__            this.routingTable = routingTable__            replicationGroup = calculateReplicationGroup()__            if (primaryMode && removedEntries) {_                updateGlobalCheckpointOnPrimary()__                _                notifyAllWaiters()__            }_        }_        assert invariant()__    };notifies,the,tracker,of,the,current,allocation,ids,in,the,cluster,state,param,applying,cluster,state,version,the,cluster,state,version,being,applied,when,updating,the,allocation,ids,from,the,master,param,in,sync,allocation,ids,the,allocation,ids,of,the,currently,in,sync,shard,copies,param,routing,table,the,shard,routing,table,param,pre60allocation,ids,the,allocation,ids,of,shards,that,are,allocated,to,pre,6,0,nodes;public,synchronized,void,update,from,master,final,long,applying,cluster,state,version,final,set,string,in,sync,allocation,ids,final,index,shard,routing,table,routing,table,final,set,string,pre60allocation,ids,assert,invariant,if,applying,cluster,state,version,applied,cluster,state,version,assert,primary,mode,in,sync,allocation,ids,stream,all,match,in,sync,id,checkpoints,contains,key,in,sync,id,checkpoints,get,in,sync,id,in,sync,update,from,master,in,primary,mode,contains,in,sync,ids,in,sync,allocation,ids,that,have,no,matching,entries,in,checkpoints,set,string,initializing,allocation,ids,routing,table,get,all,initializing,shards,stream,map,shard,routing,allocation,id,map,allocation,id,get,id,collect,collectors,to,set,boolean,removed,entries,checkpoints,key,set,remove,if,aid,in,sync,allocation,ids,contains,aid,initializing,allocation,ids,contains,aid,if,primary,mode,for,string,initializing,id,initializing,allocation,ids,if,checkpoints,contains,key,initializing,id,false,final,boolean,in,sync,in,sync,allocation,ids,contains,initializing,id,assert,in,sync,false,update,from,master,in,primary,mode,has,initializing,id,as,in,sync,but,it,does,not,exist,locally,final,long,local,checkpoint,pre60allocation,ids,contains,initializing,id,sequence,numbers,sequence,numbers,final,long,global,checkpoint,local,checkpoint,checkpoints,put,initializing,id,new,checkpoint,state,local,checkpoint,global,checkpoint,in,sync,in,sync,if,removed,entries,pending,in,sync,remove,if,a,id,checkpoints,contains,key,a,id,false,else,for,string,initializing,id,initializing,allocation,ids,if,shard,allocation,id,equals,initializing,id,false,final,long,local,checkpoint,pre60allocation,ids,contains,initializing,id,sequence,numbers,sequence,numbers,final,long,global,checkpoint,local,checkpoint,checkpoints,put,initializing,id,new,checkpoint,state,local,checkpoint,global,checkpoint,false,false,for,string,in,sync,id,in,sync,allocation,ids,if,shard,allocation,id,equals,in,sync,id,checkpoint,state,checkpoint,state,checkpoints,get,shard,allocation,id,checkpoint,state,in,sync,true,checkpoint,state,tracked,true,else,final,long,local,checkpoint,pre60allocation,ids,contains,in,sync,id,sequence,numbers,sequence,numbers,final,long,global,checkpoint,local,checkpoint,checkpoints,put,in,sync,id,new,checkpoint,state,local,checkpoint,global,checkpoint,true,true,applied,cluster,state,version,applying,cluster,state,version,this,routing,table,routing,table,replication,group,calculate,replication,group,if,primary,mode,removed,entries,update,global,checkpoint,on,primary,notify,all,waiters,assert,invariant
ReplicationTracker -> public synchronized void updateFromMaster(final long applyingClusterStateVersion, final Set<String> inSyncAllocationIds,                                               final IndexShardRoutingTable routingTable, final Set<String> pre60AllocationIds);1533738061;Notifies the tracker of the current allocation IDs in the cluster state.__@param applyingClusterStateVersion the cluster state version being applied when updating the allocation IDs from the master_@param inSyncAllocationIds         the allocation IDs of the currently in-sync shard copies_@param routingTable                the shard routing table_@param pre60AllocationIds          the allocation IDs of shards that are allocated to pre-6.0 nodes;public synchronized void updateFromMaster(final long applyingClusterStateVersion, final Set<String> inSyncAllocationIds,_                                              final IndexShardRoutingTable routingTable, final Set<String> pre60AllocationIds) {_        assert invariant()__        if (applyingClusterStateVersion > appliedClusterStateVersion) {_            _            assert !primaryMode || inSyncAllocationIds.stream().allMatch(_                inSyncId -> checkpoints.containsKey(inSyncId) && checkpoints.get(inSyncId).inSync) :_                "update from master in primary mode contains in-sync ids " + inSyncAllocationIds +_                    " that have no matching entries in " + checkpoints__            _            Set<String> initializingAllocationIds = routingTable.getAllInitializingShards().stream()_                .map(ShardRouting::allocationId).map(AllocationId::getId).collect(Collectors.toSet())__            boolean removedEntries = checkpoints.keySet().removeIf(_                aid -> !inSyncAllocationIds.contains(aid) && !initializingAllocationIds.contains(aid))___            if (primaryMode) {_                _                for (String initializingId : initializingAllocationIds) {_                    if (checkpoints.containsKey(initializingId) == false) {_                        final boolean inSync = inSyncAllocationIds.contains(initializingId)__                        assert inSync == false : "update from master in primary mode has " + initializingId +_                            " as in-sync but it does not exist locally"__                        final long localCheckpoint = pre60AllocationIds.contains(initializingId) ?_                            SequenceNumbers.PRE_60_NODE_CHECKPOINT : SequenceNumbers.UNASSIGNED_SEQ_NO__                        final long globalCheckpoint = localCheckpoint__                        checkpoints.put(initializingId, new CheckpointState(localCheckpoint, globalCheckpoint, inSync, inSync))__                    }_                }_                if (removedEntries) {_                    pendingInSync.removeIf(aId -> checkpoints.containsKey(aId) == false)__                }_            } else {_                for (String initializingId : initializingAllocationIds) {_                    if (shardAllocationId.equals(initializingId) == false) {_                        final long localCheckpoint = pre60AllocationIds.contains(initializingId) ?_                            SequenceNumbers.PRE_60_NODE_CHECKPOINT : SequenceNumbers.UNASSIGNED_SEQ_NO__                        final long globalCheckpoint = localCheckpoint__                        checkpoints.put(initializingId, new CheckpointState(localCheckpoint, globalCheckpoint, false, false))__                    }_                }_                for (String inSyncId : inSyncAllocationIds) {_                    if (shardAllocationId.equals(inSyncId)) {_                        _                        CheckpointState checkpointState = checkpoints.get(shardAllocationId)__                        checkpointState.inSync = true__                        checkpointState.tracked = true__                    } else {_                        final long localCheckpoint = pre60AllocationIds.contains(inSyncId) ?_                            SequenceNumbers.PRE_60_NODE_CHECKPOINT : SequenceNumbers.UNASSIGNED_SEQ_NO__                        final long globalCheckpoint = localCheckpoint__                        checkpoints.put(inSyncId, new CheckpointState(localCheckpoint, globalCheckpoint, true, true))__                    }_                }_            }_            appliedClusterStateVersion = applyingClusterStateVersion__            this.routingTable = routingTable__            replicationGroup = calculateReplicationGroup()__            if (primaryMode && removedEntries) {_                updateGlobalCheckpointOnPrimary()__                _                notifyAllWaiters()__            }_        }_        assert invariant()__    };notifies,the,tracker,of,the,current,allocation,ids,in,the,cluster,state,param,applying,cluster,state,version,the,cluster,state,version,being,applied,when,updating,the,allocation,ids,from,the,master,param,in,sync,allocation,ids,the,allocation,ids,of,the,currently,in,sync,shard,copies,param,routing,table,the,shard,routing,table,param,pre60allocation,ids,the,allocation,ids,of,shards,that,are,allocated,to,pre,6,0,nodes;public,synchronized,void,update,from,master,final,long,applying,cluster,state,version,final,set,string,in,sync,allocation,ids,final,index,shard,routing,table,routing,table,final,set,string,pre60allocation,ids,assert,invariant,if,applying,cluster,state,version,applied,cluster,state,version,assert,primary,mode,in,sync,allocation,ids,stream,all,match,in,sync,id,checkpoints,contains,key,in,sync,id,checkpoints,get,in,sync,id,in,sync,update,from,master,in,primary,mode,contains,in,sync,ids,in,sync,allocation,ids,that,have,no,matching,entries,in,checkpoints,set,string,initializing,allocation,ids,routing,table,get,all,initializing,shards,stream,map,shard,routing,allocation,id,map,allocation,id,get,id,collect,collectors,to,set,boolean,removed,entries,checkpoints,key,set,remove,if,aid,in,sync,allocation,ids,contains,aid,initializing,allocation,ids,contains,aid,if,primary,mode,for,string,initializing,id,initializing,allocation,ids,if,checkpoints,contains,key,initializing,id,false,final,boolean,in,sync,in,sync,allocation,ids,contains,initializing,id,assert,in,sync,false,update,from,master,in,primary,mode,has,initializing,id,as,in,sync,but,it,does,not,exist,locally,final,long,local,checkpoint,pre60allocation,ids,contains,initializing,id,sequence,numbers,sequence,numbers,final,long,global,checkpoint,local,checkpoint,checkpoints,put,initializing,id,new,checkpoint,state,local,checkpoint,global,checkpoint,in,sync,in,sync,if,removed,entries,pending,in,sync,remove,if,a,id,checkpoints,contains,key,a,id,false,else,for,string,initializing,id,initializing,allocation,ids,if,shard,allocation,id,equals,initializing,id,false,final,long,local,checkpoint,pre60allocation,ids,contains,initializing,id,sequence,numbers,sequence,numbers,final,long,global,checkpoint,local,checkpoint,checkpoints,put,initializing,id,new,checkpoint,state,local,checkpoint,global,checkpoint,false,false,for,string,in,sync,id,in,sync,allocation,ids,if,shard,allocation,id,equals,in,sync,id,checkpoint,state,checkpoint,state,checkpoints,get,shard,allocation,id,checkpoint,state,in,sync,true,checkpoint,state,tracked,true,else,final,long,local,checkpoint,pre60allocation,ids,contains,in,sync,id,sequence,numbers,sequence,numbers,final,long,global,checkpoint,local,checkpoint,checkpoints,put,in,sync,id,new,checkpoint,state,local,checkpoint,global,checkpoint,true,true,applied,cluster,state,version,applying,cluster,state,version,this,routing,table,routing,table,replication,group,calculate,replication,group,if,primary,mode,removed,entries,update,global,checkpoint,on,primary,notify,all,waiters,assert,invariant
ReplicationTracker -> public synchronized void updateFromMaster(final long applyingClusterStateVersion, final Set<String> inSyncAllocationIds,                                               final IndexShardRoutingTable routingTable, final Set<String> pre60AllocationIds);1546875837;Notifies the tracker of the current allocation IDs in the cluster state.__@param applyingClusterStateVersion the cluster state version being applied when updating the allocation IDs from the master_@param inSyncAllocationIds         the allocation IDs of the currently in-sync shard copies_@param routingTable                the shard routing table_@param pre60AllocationIds          the allocation IDs of shards that are allocated to pre-6.0 nodes;public synchronized void updateFromMaster(final long applyingClusterStateVersion, final Set<String> inSyncAllocationIds,_                                              final IndexShardRoutingTable routingTable, final Set<String> pre60AllocationIds) {_        assert invariant()__        if (applyingClusterStateVersion > appliedClusterStateVersion) {_            _            assert !primaryMode || inSyncAllocationIds.stream().allMatch(_                inSyncId -> checkpoints.containsKey(inSyncId) && checkpoints.get(inSyncId).inSync) :_                "update from master in primary mode contains in-sync ids " + inSyncAllocationIds +_                    " that have no matching entries in " + checkpoints__            _            Set<String> initializingAllocationIds = routingTable.getAllInitializingShards().stream()_                .map(ShardRouting::allocationId).map(AllocationId::getId).collect(Collectors.toSet())__            boolean removedEntries = checkpoints.keySet().removeIf(_                aid -> !inSyncAllocationIds.contains(aid) && !initializingAllocationIds.contains(aid))___            if (primaryMode) {_                _                for (String initializingId : initializingAllocationIds) {_                    if (checkpoints.containsKey(initializingId) == false) {_                        final boolean inSync = inSyncAllocationIds.contains(initializingId)__                        assert inSync == false : "update from master in primary mode has " + initializingId +_                            " as in-sync but it does not exist locally"__                        final long localCheckpoint = pre60AllocationIds.contains(initializingId) ?_                            SequenceNumbers.PRE_60_NODE_CHECKPOINT : SequenceNumbers.UNASSIGNED_SEQ_NO__                        final long globalCheckpoint = localCheckpoint__                        checkpoints.put(initializingId, new CheckpointState(localCheckpoint, globalCheckpoint, inSync, inSync))__                    }_                }_                if (removedEntries) {_                    pendingInSync.removeIf(aId -> checkpoints.containsKey(aId) == false)__                }_            } else {_                for (String initializingId : initializingAllocationIds) {_                    if (shardAllocationId.equals(initializingId) == false) {_                        final long localCheckpoint = pre60AllocationIds.contains(initializingId) ?_                            SequenceNumbers.PRE_60_NODE_CHECKPOINT : SequenceNumbers.UNASSIGNED_SEQ_NO__                        final long globalCheckpoint = localCheckpoint__                        checkpoints.put(initializingId, new CheckpointState(localCheckpoint, globalCheckpoint, false, false))__                    }_                }_                for (String inSyncId : inSyncAllocationIds) {_                    if (shardAllocationId.equals(inSyncId)) {_                        _                        CheckpointState checkpointState = checkpoints.get(shardAllocationId)__                        checkpointState.inSync = true__                        checkpointState.tracked = true__                    } else {_                        final long localCheckpoint = pre60AllocationIds.contains(inSyncId) ?_                            SequenceNumbers.PRE_60_NODE_CHECKPOINT : SequenceNumbers.UNASSIGNED_SEQ_NO__                        final long globalCheckpoint = localCheckpoint__                        checkpoints.put(inSyncId, new CheckpointState(localCheckpoint, globalCheckpoint, true, true))__                    }_                }_            }_            appliedClusterStateVersion = applyingClusterStateVersion__            this.routingTable = routingTable__            replicationGroup = calculateReplicationGroup()__            if (primaryMode && removedEntries) {_                updateGlobalCheckpointOnPrimary()__                _                notifyAllWaiters()__            }_        }_        assert invariant()__    };notifies,the,tracker,of,the,current,allocation,ids,in,the,cluster,state,param,applying,cluster,state,version,the,cluster,state,version,being,applied,when,updating,the,allocation,ids,from,the,master,param,in,sync,allocation,ids,the,allocation,ids,of,the,currently,in,sync,shard,copies,param,routing,table,the,shard,routing,table,param,pre60allocation,ids,the,allocation,ids,of,shards,that,are,allocated,to,pre,6,0,nodes;public,synchronized,void,update,from,master,final,long,applying,cluster,state,version,final,set,string,in,sync,allocation,ids,final,index,shard,routing,table,routing,table,final,set,string,pre60allocation,ids,assert,invariant,if,applying,cluster,state,version,applied,cluster,state,version,assert,primary,mode,in,sync,allocation,ids,stream,all,match,in,sync,id,checkpoints,contains,key,in,sync,id,checkpoints,get,in,sync,id,in,sync,update,from,master,in,primary,mode,contains,in,sync,ids,in,sync,allocation,ids,that,have,no,matching,entries,in,checkpoints,set,string,initializing,allocation,ids,routing,table,get,all,initializing,shards,stream,map,shard,routing,allocation,id,map,allocation,id,get,id,collect,collectors,to,set,boolean,removed,entries,checkpoints,key,set,remove,if,aid,in,sync,allocation,ids,contains,aid,initializing,allocation,ids,contains,aid,if,primary,mode,for,string,initializing,id,initializing,allocation,ids,if,checkpoints,contains,key,initializing,id,false,final,boolean,in,sync,in,sync,allocation,ids,contains,initializing,id,assert,in,sync,false,update,from,master,in,primary,mode,has,initializing,id,as,in,sync,but,it,does,not,exist,locally,final,long,local,checkpoint,pre60allocation,ids,contains,initializing,id,sequence,numbers,sequence,numbers,final,long,global,checkpoint,local,checkpoint,checkpoints,put,initializing,id,new,checkpoint,state,local,checkpoint,global,checkpoint,in,sync,in,sync,if,removed,entries,pending,in,sync,remove,if,a,id,checkpoints,contains,key,a,id,false,else,for,string,initializing,id,initializing,allocation,ids,if,shard,allocation,id,equals,initializing,id,false,final,long,local,checkpoint,pre60allocation,ids,contains,initializing,id,sequence,numbers,sequence,numbers,final,long,global,checkpoint,local,checkpoint,checkpoints,put,initializing,id,new,checkpoint,state,local,checkpoint,global,checkpoint,false,false,for,string,in,sync,id,in,sync,allocation,ids,if,shard,allocation,id,equals,in,sync,id,checkpoint,state,checkpoint,state,checkpoints,get,shard,allocation,id,checkpoint,state,in,sync,true,checkpoint,state,tracked,true,else,final,long,local,checkpoint,pre60allocation,ids,contains,in,sync,id,sequence,numbers,sequence,numbers,final,long,global,checkpoint,local,checkpoint,checkpoints,put,in,sync,id,new,checkpoint,state,local,checkpoint,global,checkpoint,true,true,applied,cluster,state,version,applying,cluster,state,version,this,routing,table,routing,table,replication,group,calculate,replication,group,if,primary,mode,removed,entries,update,global,checkpoint,on,primary,notify,all,waiters,assert,invariant
ReplicationTracker -> public synchronized void updateFromMaster(final long applyingClusterStateVersion, final Set<String> inSyncAllocationIds,                                               final IndexShardRoutingTable routingTable, final Set<String> pre60AllocationIds);1546927432;Notifies the tracker of the current allocation IDs in the cluster state.__@param applyingClusterStateVersion the cluster state version being applied when updating the allocation IDs from the master_@param inSyncAllocationIds         the allocation IDs of the currently in-sync shard copies_@param routingTable                the shard routing table_@param pre60AllocationIds          the allocation IDs of shards that are allocated to pre-6.0 nodes;public synchronized void updateFromMaster(final long applyingClusterStateVersion, final Set<String> inSyncAllocationIds,_                                              final IndexShardRoutingTable routingTable, final Set<String> pre60AllocationIds) {_        assert invariant()__        if (applyingClusterStateVersion > appliedClusterStateVersion) {_            _            assert !primaryMode || inSyncAllocationIds.stream().allMatch(_                inSyncId -> checkpoints.containsKey(inSyncId) && checkpoints.get(inSyncId).inSync) :_                "update from master in primary mode contains in-sync ids " + inSyncAllocationIds +_                    " that have no matching entries in " + checkpoints__            _            Set<String> initializingAllocationIds = routingTable.getAllInitializingShards().stream()_                .map(ShardRouting::allocationId).map(AllocationId::getId).collect(Collectors.toSet())__            boolean removedEntries = checkpoints.keySet().removeIf(_                aid -> !inSyncAllocationIds.contains(aid) && !initializingAllocationIds.contains(aid))___            if (primaryMode) {_                _                for (String initializingId : initializingAllocationIds) {_                    if (checkpoints.containsKey(initializingId) == false) {_                        final boolean inSync = inSyncAllocationIds.contains(initializingId)__                        assert inSync == false : "update from master in primary mode has " + initializingId +_                            " as in-sync but it does not exist locally"__                        final long localCheckpoint = pre60AllocationIds.contains(initializingId) ?_                            SequenceNumbers.PRE_60_NODE_CHECKPOINT : SequenceNumbers.UNASSIGNED_SEQ_NO__                        final long globalCheckpoint = localCheckpoint__                        checkpoints.put(initializingId, new CheckpointState(localCheckpoint, globalCheckpoint, inSync, inSync))__                    }_                }_                if (removedEntries) {_                    pendingInSync.removeIf(aId -> checkpoints.containsKey(aId) == false)__                }_            } else {_                for (String initializingId : initializingAllocationIds) {_                    if (shardAllocationId.equals(initializingId) == false) {_                        final long localCheckpoint = pre60AllocationIds.contains(initializingId) ?_                            SequenceNumbers.PRE_60_NODE_CHECKPOINT : SequenceNumbers.UNASSIGNED_SEQ_NO__                        final long globalCheckpoint = localCheckpoint__                        checkpoints.put(initializingId, new CheckpointState(localCheckpoint, globalCheckpoint, false, false))__                    }_                }_                for (String inSyncId : inSyncAllocationIds) {_                    if (shardAllocationId.equals(inSyncId)) {_                        _                        CheckpointState checkpointState = checkpoints.get(shardAllocationId)__                        checkpointState.inSync = true__                        checkpointState.tracked = true__                    } else {_                        final long localCheckpoint = pre60AllocationIds.contains(inSyncId) ?_                            SequenceNumbers.PRE_60_NODE_CHECKPOINT : SequenceNumbers.UNASSIGNED_SEQ_NO__                        final long globalCheckpoint = localCheckpoint__                        checkpoints.put(inSyncId, new CheckpointState(localCheckpoint, globalCheckpoint, true, true))__                    }_                }_            }_            appliedClusterStateVersion = applyingClusterStateVersion__            this.routingTable = routingTable__            replicationGroup = calculateReplicationGroup()__            if (primaryMode && removedEntries) {_                updateGlobalCheckpointOnPrimary()__                _                notifyAllWaiters()__            }_        }_        assert invariant()__    };notifies,the,tracker,of,the,current,allocation,ids,in,the,cluster,state,param,applying,cluster,state,version,the,cluster,state,version,being,applied,when,updating,the,allocation,ids,from,the,master,param,in,sync,allocation,ids,the,allocation,ids,of,the,currently,in,sync,shard,copies,param,routing,table,the,shard,routing,table,param,pre60allocation,ids,the,allocation,ids,of,shards,that,are,allocated,to,pre,6,0,nodes;public,synchronized,void,update,from,master,final,long,applying,cluster,state,version,final,set,string,in,sync,allocation,ids,final,index,shard,routing,table,routing,table,final,set,string,pre60allocation,ids,assert,invariant,if,applying,cluster,state,version,applied,cluster,state,version,assert,primary,mode,in,sync,allocation,ids,stream,all,match,in,sync,id,checkpoints,contains,key,in,sync,id,checkpoints,get,in,sync,id,in,sync,update,from,master,in,primary,mode,contains,in,sync,ids,in,sync,allocation,ids,that,have,no,matching,entries,in,checkpoints,set,string,initializing,allocation,ids,routing,table,get,all,initializing,shards,stream,map,shard,routing,allocation,id,map,allocation,id,get,id,collect,collectors,to,set,boolean,removed,entries,checkpoints,key,set,remove,if,aid,in,sync,allocation,ids,contains,aid,initializing,allocation,ids,contains,aid,if,primary,mode,for,string,initializing,id,initializing,allocation,ids,if,checkpoints,contains,key,initializing,id,false,final,boolean,in,sync,in,sync,allocation,ids,contains,initializing,id,assert,in,sync,false,update,from,master,in,primary,mode,has,initializing,id,as,in,sync,but,it,does,not,exist,locally,final,long,local,checkpoint,pre60allocation,ids,contains,initializing,id,sequence,numbers,sequence,numbers,final,long,global,checkpoint,local,checkpoint,checkpoints,put,initializing,id,new,checkpoint,state,local,checkpoint,global,checkpoint,in,sync,in,sync,if,removed,entries,pending,in,sync,remove,if,a,id,checkpoints,contains,key,a,id,false,else,for,string,initializing,id,initializing,allocation,ids,if,shard,allocation,id,equals,initializing,id,false,final,long,local,checkpoint,pre60allocation,ids,contains,initializing,id,sequence,numbers,sequence,numbers,final,long,global,checkpoint,local,checkpoint,checkpoints,put,initializing,id,new,checkpoint,state,local,checkpoint,global,checkpoint,false,false,for,string,in,sync,id,in,sync,allocation,ids,if,shard,allocation,id,equals,in,sync,id,checkpoint,state,checkpoint,state,checkpoints,get,shard,allocation,id,checkpoint,state,in,sync,true,checkpoint,state,tracked,true,else,final,long,local,checkpoint,pre60allocation,ids,contains,in,sync,id,sequence,numbers,sequence,numbers,final,long,global,checkpoint,local,checkpoint,checkpoints,put,in,sync,id,new,checkpoint,state,local,checkpoint,global,checkpoint,true,true,applied,cluster,state,version,applying,cluster,state,version,this,routing,table,routing,table,replication,group,calculate,replication,group,if,primary,mode,removed,entries,update,global,checkpoint,on,primary,notify,all,waiters,assert,invariant
ReplicationTracker -> public synchronized void updateFromMaster(final long applyingClusterStateVersion, final Set<String> inSyncAllocationIds,                                               final IndexShardRoutingTable routingTable, final Set<String> pre60AllocationIds);1547332999;Notifies the tracker of the current allocation IDs in the cluster state.__@param applyingClusterStateVersion the cluster state version being applied when updating the allocation IDs from the master_@param inSyncAllocationIds         the allocation IDs of the currently in-sync shard copies_@param routingTable                the shard routing table_@param pre60AllocationIds          the allocation IDs of shards that are allocated to pre-6.0 nodes;public synchronized void updateFromMaster(final long applyingClusterStateVersion, final Set<String> inSyncAllocationIds,_                                              final IndexShardRoutingTable routingTable, final Set<String> pre60AllocationIds) {_        assert invariant()__        if (applyingClusterStateVersion > appliedClusterStateVersion) {_            _            assert !primaryMode || inSyncAllocationIds.stream().allMatch(_                inSyncId -> checkpoints.containsKey(inSyncId) && checkpoints.get(inSyncId).inSync) :_                "update from master in primary mode contains in-sync ids " + inSyncAllocationIds +_                    " that have no matching entries in " + checkpoints__            _            Set<String> initializingAllocationIds = routingTable.getAllInitializingShards().stream()_                .map(ShardRouting::allocationId).map(AllocationId::getId).collect(Collectors.toSet())__            boolean removedEntries = checkpoints.keySet().removeIf(_                aid -> !inSyncAllocationIds.contains(aid) && !initializingAllocationIds.contains(aid))___            if (primaryMode) {_                _                for (String initializingId : initializingAllocationIds) {_                    if (checkpoints.containsKey(initializingId) == false) {_                        final boolean inSync = inSyncAllocationIds.contains(initializingId)__                        assert inSync == false : "update from master in primary mode has " + initializingId +_                            " as in-sync but it does not exist locally"__                        final long localCheckpoint = pre60AllocationIds.contains(initializingId) ?_                            SequenceNumbers.PRE_60_NODE_CHECKPOINT : SequenceNumbers.UNASSIGNED_SEQ_NO__                        final long globalCheckpoint = localCheckpoint__                        checkpoints.put(initializingId, new CheckpointState(localCheckpoint, globalCheckpoint, inSync, inSync))__                    }_                }_                if (removedEntries) {_                    pendingInSync.removeIf(aId -> checkpoints.containsKey(aId) == false)__                }_            } else {_                for (String initializingId : initializingAllocationIds) {_                    if (shardAllocationId.equals(initializingId) == false) {_                        final long localCheckpoint = pre60AllocationIds.contains(initializingId) ?_                            SequenceNumbers.PRE_60_NODE_CHECKPOINT : SequenceNumbers.UNASSIGNED_SEQ_NO__                        final long globalCheckpoint = localCheckpoint__                        checkpoints.put(initializingId, new CheckpointState(localCheckpoint, globalCheckpoint, false, false))__                    }_                }_                for (String inSyncId : inSyncAllocationIds) {_                    if (shardAllocationId.equals(inSyncId)) {_                        _                        CheckpointState checkpointState = checkpoints.get(shardAllocationId)__                        checkpointState.inSync = true__                        checkpointState.tracked = true__                    } else {_                        final long localCheckpoint = pre60AllocationIds.contains(inSyncId) ?_                            SequenceNumbers.PRE_60_NODE_CHECKPOINT : SequenceNumbers.UNASSIGNED_SEQ_NO__                        final long globalCheckpoint = localCheckpoint__                        checkpoints.put(inSyncId, new CheckpointState(localCheckpoint, globalCheckpoint, true, true))__                    }_                }_            }_            appliedClusterStateVersion = applyingClusterStateVersion__            this.routingTable = routingTable__            replicationGroup = calculateReplicationGroup()__            if (primaryMode && removedEntries) {_                updateGlobalCheckpointOnPrimary()__                _                notifyAllWaiters()__            }_        }_        assert invariant()__    };notifies,the,tracker,of,the,current,allocation,ids,in,the,cluster,state,param,applying,cluster,state,version,the,cluster,state,version,being,applied,when,updating,the,allocation,ids,from,the,master,param,in,sync,allocation,ids,the,allocation,ids,of,the,currently,in,sync,shard,copies,param,routing,table,the,shard,routing,table,param,pre60allocation,ids,the,allocation,ids,of,shards,that,are,allocated,to,pre,6,0,nodes;public,synchronized,void,update,from,master,final,long,applying,cluster,state,version,final,set,string,in,sync,allocation,ids,final,index,shard,routing,table,routing,table,final,set,string,pre60allocation,ids,assert,invariant,if,applying,cluster,state,version,applied,cluster,state,version,assert,primary,mode,in,sync,allocation,ids,stream,all,match,in,sync,id,checkpoints,contains,key,in,sync,id,checkpoints,get,in,sync,id,in,sync,update,from,master,in,primary,mode,contains,in,sync,ids,in,sync,allocation,ids,that,have,no,matching,entries,in,checkpoints,set,string,initializing,allocation,ids,routing,table,get,all,initializing,shards,stream,map,shard,routing,allocation,id,map,allocation,id,get,id,collect,collectors,to,set,boolean,removed,entries,checkpoints,key,set,remove,if,aid,in,sync,allocation,ids,contains,aid,initializing,allocation,ids,contains,aid,if,primary,mode,for,string,initializing,id,initializing,allocation,ids,if,checkpoints,contains,key,initializing,id,false,final,boolean,in,sync,in,sync,allocation,ids,contains,initializing,id,assert,in,sync,false,update,from,master,in,primary,mode,has,initializing,id,as,in,sync,but,it,does,not,exist,locally,final,long,local,checkpoint,pre60allocation,ids,contains,initializing,id,sequence,numbers,sequence,numbers,final,long,global,checkpoint,local,checkpoint,checkpoints,put,initializing,id,new,checkpoint,state,local,checkpoint,global,checkpoint,in,sync,in,sync,if,removed,entries,pending,in,sync,remove,if,a,id,checkpoints,contains,key,a,id,false,else,for,string,initializing,id,initializing,allocation,ids,if,shard,allocation,id,equals,initializing,id,false,final,long,local,checkpoint,pre60allocation,ids,contains,initializing,id,sequence,numbers,sequence,numbers,final,long,global,checkpoint,local,checkpoint,checkpoints,put,initializing,id,new,checkpoint,state,local,checkpoint,global,checkpoint,false,false,for,string,in,sync,id,in,sync,allocation,ids,if,shard,allocation,id,equals,in,sync,id,checkpoint,state,checkpoint,state,checkpoints,get,shard,allocation,id,checkpoint,state,in,sync,true,checkpoint,state,tracked,true,else,final,long,local,checkpoint,pre60allocation,ids,contains,in,sync,id,sequence,numbers,sequence,numbers,final,long,global,checkpoint,local,checkpoint,checkpoints,put,in,sync,id,new,checkpoint,state,local,checkpoint,global,checkpoint,true,true,applied,cluster,state,version,applying,cluster,state,version,this,routing,table,routing,table,replication,group,calculate,replication,group,if,primary,mode,removed,entries,update,global,checkpoint,on,primary,notify,all,waiters,assert,invariant
ReplicationTracker -> public synchronized void updateFromMaster(final long applyingClusterStateVersion, final Set<String> inSyncAllocationIds,                                               final IndexShardRoutingTable routingTable, final Set<String> pre60AllocationIds);1548593396;Notifies the tracker of the current allocation IDs in the cluster state.__@param applyingClusterStateVersion the cluster state version being applied when updating the allocation IDs from the master_@param inSyncAllocationIds         the allocation IDs of the currently in-sync shard copies_@param routingTable                the shard routing table_@param pre60AllocationIds          the allocation IDs of shards that are allocated to pre-6.0 nodes;public synchronized void updateFromMaster(final long applyingClusterStateVersion, final Set<String> inSyncAllocationIds,_                                              final IndexShardRoutingTable routingTable, final Set<String> pre60AllocationIds) {_        assert invariant()__        if (applyingClusterStateVersion > appliedClusterStateVersion) {_            _            assert !primaryMode || inSyncAllocationIds.stream().allMatch(_                inSyncId -> checkpoints.containsKey(inSyncId) && checkpoints.get(inSyncId).inSync) :_                "update from master in primary mode contains in-sync ids " + inSyncAllocationIds +_                    " that have no matching entries in " + checkpoints__            _            Set<String> initializingAllocationIds = routingTable.getAllInitializingShards().stream()_                .map(ShardRouting::allocationId).map(AllocationId::getId).collect(Collectors.toSet())__            boolean removedEntries = checkpoints.keySet().removeIf(_                aid -> !inSyncAllocationIds.contains(aid) && !initializingAllocationIds.contains(aid))___            if (primaryMode) {_                _                for (String initializingId : initializingAllocationIds) {_                    if (checkpoints.containsKey(initializingId) == false) {_                        final boolean inSync = inSyncAllocationIds.contains(initializingId)__                        assert inSync == false : "update from master in primary mode has " + initializingId +_                            " as in-sync but it does not exist locally"__                        final long localCheckpoint = pre60AllocationIds.contains(initializingId) ?_                            SequenceNumbers.PRE_60_NODE_CHECKPOINT : SequenceNumbers.UNASSIGNED_SEQ_NO__                        final long globalCheckpoint = localCheckpoint__                        checkpoints.put(initializingId, new CheckpointState(localCheckpoint, globalCheckpoint, inSync, inSync))__                    }_                }_                if (removedEntries) {_                    pendingInSync.removeIf(aId -> checkpoints.containsKey(aId) == false)__                }_            } else {_                for (String initializingId : initializingAllocationIds) {_                    if (shardAllocationId.equals(initializingId) == false) {_                        final long localCheckpoint = pre60AllocationIds.contains(initializingId) ?_                            SequenceNumbers.PRE_60_NODE_CHECKPOINT : SequenceNumbers.UNASSIGNED_SEQ_NO__                        final long globalCheckpoint = localCheckpoint__                        checkpoints.put(initializingId, new CheckpointState(localCheckpoint, globalCheckpoint, false, false))__                    }_                }_                for (String inSyncId : inSyncAllocationIds) {_                    if (shardAllocationId.equals(inSyncId)) {_                        _                        CheckpointState checkpointState = checkpoints.get(shardAllocationId)__                        checkpointState.inSync = true__                        checkpointState.tracked = true__                    } else {_                        final long localCheckpoint = pre60AllocationIds.contains(inSyncId) ?_                            SequenceNumbers.PRE_60_NODE_CHECKPOINT : SequenceNumbers.UNASSIGNED_SEQ_NO__                        final long globalCheckpoint = localCheckpoint__                        checkpoints.put(inSyncId, new CheckpointState(localCheckpoint, globalCheckpoint, true, true))__                    }_                }_            }_            appliedClusterStateVersion = applyingClusterStateVersion__            this.routingTable = routingTable__            replicationGroup = calculateReplicationGroup()__            if (primaryMode && removedEntries) {_                updateGlobalCheckpointOnPrimary()__                _                notifyAllWaiters()__            }_        }_        assert invariant()__    };notifies,the,tracker,of,the,current,allocation,ids,in,the,cluster,state,param,applying,cluster,state,version,the,cluster,state,version,being,applied,when,updating,the,allocation,ids,from,the,master,param,in,sync,allocation,ids,the,allocation,ids,of,the,currently,in,sync,shard,copies,param,routing,table,the,shard,routing,table,param,pre60allocation,ids,the,allocation,ids,of,shards,that,are,allocated,to,pre,6,0,nodes;public,synchronized,void,update,from,master,final,long,applying,cluster,state,version,final,set,string,in,sync,allocation,ids,final,index,shard,routing,table,routing,table,final,set,string,pre60allocation,ids,assert,invariant,if,applying,cluster,state,version,applied,cluster,state,version,assert,primary,mode,in,sync,allocation,ids,stream,all,match,in,sync,id,checkpoints,contains,key,in,sync,id,checkpoints,get,in,sync,id,in,sync,update,from,master,in,primary,mode,contains,in,sync,ids,in,sync,allocation,ids,that,have,no,matching,entries,in,checkpoints,set,string,initializing,allocation,ids,routing,table,get,all,initializing,shards,stream,map,shard,routing,allocation,id,map,allocation,id,get,id,collect,collectors,to,set,boolean,removed,entries,checkpoints,key,set,remove,if,aid,in,sync,allocation,ids,contains,aid,initializing,allocation,ids,contains,aid,if,primary,mode,for,string,initializing,id,initializing,allocation,ids,if,checkpoints,contains,key,initializing,id,false,final,boolean,in,sync,in,sync,allocation,ids,contains,initializing,id,assert,in,sync,false,update,from,master,in,primary,mode,has,initializing,id,as,in,sync,but,it,does,not,exist,locally,final,long,local,checkpoint,pre60allocation,ids,contains,initializing,id,sequence,numbers,sequence,numbers,final,long,global,checkpoint,local,checkpoint,checkpoints,put,initializing,id,new,checkpoint,state,local,checkpoint,global,checkpoint,in,sync,in,sync,if,removed,entries,pending,in,sync,remove,if,a,id,checkpoints,contains,key,a,id,false,else,for,string,initializing,id,initializing,allocation,ids,if,shard,allocation,id,equals,initializing,id,false,final,long,local,checkpoint,pre60allocation,ids,contains,initializing,id,sequence,numbers,sequence,numbers,final,long,global,checkpoint,local,checkpoint,checkpoints,put,initializing,id,new,checkpoint,state,local,checkpoint,global,checkpoint,false,false,for,string,in,sync,id,in,sync,allocation,ids,if,shard,allocation,id,equals,in,sync,id,checkpoint,state,checkpoint,state,checkpoints,get,shard,allocation,id,checkpoint,state,in,sync,true,checkpoint,state,tracked,true,else,final,long,local,checkpoint,pre60allocation,ids,contains,in,sync,id,sequence,numbers,sequence,numbers,final,long,global,checkpoint,local,checkpoint,checkpoints,put,in,sync,id,new,checkpoint,state,local,checkpoint,global,checkpoint,true,true,applied,cluster,state,version,applying,cluster,state,version,this,routing,table,routing,table,replication,group,calculate,replication,group,if,primary,mode,removed,entries,update,global,checkpoint,on,primary,notify,all,waiters,assert,invariant
ReplicationTracker -> public synchronized void updateFromMaster(final long applyingClusterStateVersion, final Set<String> inSyncAllocationIds,                                               final IndexShardRoutingTable routingTable, final Set<String> pre60AllocationIds);1548594827;Notifies the tracker of the current allocation IDs in the cluster state.__@param applyingClusterStateVersion the cluster state version being applied when updating the allocation IDs from the master_@param inSyncAllocationIds         the allocation IDs of the currently in-sync shard copies_@param routingTable                the shard routing table_@param pre60AllocationIds          the allocation IDs of shards that are allocated to pre-6.0 nodes;public synchronized void updateFromMaster(final long applyingClusterStateVersion, final Set<String> inSyncAllocationIds,_                                              final IndexShardRoutingTable routingTable, final Set<String> pre60AllocationIds) {_        assert invariant()__        if (applyingClusterStateVersion > appliedClusterStateVersion) {_            _            assert !primaryMode || inSyncAllocationIds.stream().allMatch(_                inSyncId -> checkpoints.containsKey(inSyncId) && checkpoints.get(inSyncId).inSync) :_                "update from master in primary mode contains in-sync ids " + inSyncAllocationIds +_                    " that have no matching entries in " + checkpoints__            _            Set<String> initializingAllocationIds = routingTable.getAllInitializingShards().stream()_                .map(ShardRouting::allocationId).map(AllocationId::getId).collect(Collectors.toSet())__            boolean removedEntries = checkpoints.keySet().removeIf(_                aid -> !inSyncAllocationIds.contains(aid) && !initializingAllocationIds.contains(aid))___            if (primaryMode) {_                _                for (String initializingId : initializingAllocationIds) {_                    if (checkpoints.containsKey(initializingId) == false) {_                        final boolean inSync = inSyncAllocationIds.contains(initializingId)__                        assert inSync == false : "update from master in primary mode has " + initializingId +_                            " as in-sync but it does not exist locally"__                        final long localCheckpoint = pre60AllocationIds.contains(initializingId) ?_                            SequenceNumbers.PRE_60_NODE_CHECKPOINT : SequenceNumbers.UNASSIGNED_SEQ_NO__                        final long globalCheckpoint = localCheckpoint__                        checkpoints.put(initializingId, new CheckpointState(localCheckpoint, globalCheckpoint, inSync, inSync))__                    }_                }_                if (removedEntries) {_                    pendingInSync.removeIf(aId -> checkpoints.containsKey(aId) == false)__                }_            } else {_                for (String initializingId : initializingAllocationIds) {_                    if (shardAllocationId.equals(initializingId) == false) {_                        final long localCheckpoint = pre60AllocationIds.contains(initializingId) ?_                            SequenceNumbers.PRE_60_NODE_CHECKPOINT : SequenceNumbers.UNASSIGNED_SEQ_NO__                        final long globalCheckpoint = localCheckpoint__                        checkpoints.put(initializingId, new CheckpointState(localCheckpoint, globalCheckpoint, false, false))__                    }_                }_                for (String inSyncId : inSyncAllocationIds) {_                    if (shardAllocationId.equals(inSyncId)) {_                        _                        CheckpointState checkpointState = checkpoints.get(shardAllocationId)__                        checkpointState.inSync = true__                        checkpointState.tracked = true__                    } else {_                        final long localCheckpoint = pre60AllocationIds.contains(inSyncId) ?_                            SequenceNumbers.PRE_60_NODE_CHECKPOINT : SequenceNumbers.UNASSIGNED_SEQ_NO__                        final long globalCheckpoint = localCheckpoint__                        checkpoints.put(inSyncId, new CheckpointState(localCheckpoint, globalCheckpoint, true, true))__                    }_                }_            }_            appliedClusterStateVersion = applyingClusterStateVersion__            this.routingTable = routingTable__            replicationGroup = calculateReplicationGroup()__            if (primaryMode && removedEntries) {_                updateGlobalCheckpointOnPrimary()__                _                notifyAllWaiters()__            }_        }_        assert invariant()__    };notifies,the,tracker,of,the,current,allocation,ids,in,the,cluster,state,param,applying,cluster,state,version,the,cluster,state,version,being,applied,when,updating,the,allocation,ids,from,the,master,param,in,sync,allocation,ids,the,allocation,ids,of,the,currently,in,sync,shard,copies,param,routing,table,the,shard,routing,table,param,pre60allocation,ids,the,allocation,ids,of,shards,that,are,allocated,to,pre,6,0,nodes;public,synchronized,void,update,from,master,final,long,applying,cluster,state,version,final,set,string,in,sync,allocation,ids,final,index,shard,routing,table,routing,table,final,set,string,pre60allocation,ids,assert,invariant,if,applying,cluster,state,version,applied,cluster,state,version,assert,primary,mode,in,sync,allocation,ids,stream,all,match,in,sync,id,checkpoints,contains,key,in,sync,id,checkpoints,get,in,sync,id,in,sync,update,from,master,in,primary,mode,contains,in,sync,ids,in,sync,allocation,ids,that,have,no,matching,entries,in,checkpoints,set,string,initializing,allocation,ids,routing,table,get,all,initializing,shards,stream,map,shard,routing,allocation,id,map,allocation,id,get,id,collect,collectors,to,set,boolean,removed,entries,checkpoints,key,set,remove,if,aid,in,sync,allocation,ids,contains,aid,initializing,allocation,ids,contains,aid,if,primary,mode,for,string,initializing,id,initializing,allocation,ids,if,checkpoints,contains,key,initializing,id,false,final,boolean,in,sync,in,sync,allocation,ids,contains,initializing,id,assert,in,sync,false,update,from,master,in,primary,mode,has,initializing,id,as,in,sync,but,it,does,not,exist,locally,final,long,local,checkpoint,pre60allocation,ids,contains,initializing,id,sequence,numbers,sequence,numbers,final,long,global,checkpoint,local,checkpoint,checkpoints,put,initializing,id,new,checkpoint,state,local,checkpoint,global,checkpoint,in,sync,in,sync,if,removed,entries,pending,in,sync,remove,if,a,id,checkpoints,contains,key,a,id,false,else,for,string,initializing,id,initializing,allocation,ids,if,shard,allocation,id,equals,initializing,id,false,final,long,local,checkpoint,pre60allocation,ids,contains,initializing,id,sequence,numbers,sequence,numbers,final,long,global,checkpoint,local,checkpoint,checkpoints,put,initializing,id,new,checkpoint,state,local,checkpoint,global,checkpoint,false,false,for,string,in,sync,id,in,sync,allocation,ids,if,shard,allocation,id,equals,in,sync,id,checkpoint,state,checkpoint,state,checkpoints,get,shard,allocation,id,checkpoint,state,in,sync,true,checkpoint,state,tracked,true,else,final,long,local,checkpoint,pre60allocation,ids,contains,in,sync,id,sequence,numbers,sequence,numbers,final,long,global,checkpoint,local,checkpoint,checkpoints,put,in,sync,id,new,checkpoint,state,local,checkpoint,global,checkpoint,true,true,applied,cluster,state,version,applying,cluster,state,version,this,routing,table,routing,table,replication,group,calculate,replication,group,if,primary,mode,removed,entries,update,global,checkpoint,on,primary,notify,all,waiters,assert,invariant
ReplicationTracker -> public synchronized void updateFromMaster(final long applyingClusterStateVersion, final Set<String> inSyncAllocationIds,                                               final IndexShardRoutingTable routingTable, final Set<String> pre60AllocationIds);1548677511;Notifies the tracker of the current allocation IDs in the cluster state.__@param applyingClusterStateVersion the cluster state version being applied when updating the allocation IDs from the master_@param inSyncAllocationIds         the allocation IDs of the currently in-sync shard copies_@param routingTable                the shard routing table_@param pre60AllocationIds          the allocation IDs of shards that are allocated to pre-6.0 nodes;public synchronized void updateFromMaster(final long applyingClusterStateVersion, final Set<String> inSyncAllocationIds,_                                              final IndexShardRoutingTable routingTable, final Set<String> pre60AllocationIds) {_        assert invariant()__        if (applyingClusterStateVersion > appliedClusterStateVersion) {_            _            assert !primaryMode || inSyncAllocationIds.stream().allMatch(_                inSyncId -> checkpoints.containsKey(inSyncId) && checkpoints.get(inSyncId).inSync) :_                "update from master in primary mode contains in-sync ids " + inSyncAllocationIds +_                    " that have no matching entries in " + checkpoints__            _            Set<String> initializingAllocationIds = routingTable.getAllInitializingShards().stream()_                .map(ShardRouting::allocationId).map(AllocationId::getId).collect(Collectors.toSet())__            boolean removedEntries = checkpoints.keySet().removeIf(_                aid -> !inSyncAllocationIds.contains(aid) && !initializingAllocationIds.contains(aid))___            if (primaryMode) {_                _                for (String initializingId : initializingAllocationIds) {_                    if (checkpoints.containsKey(initializingId) == false) {_                        final boolean inSync = inSyncAllocationIds.contains(initializingId)__                        assert inSync == false : "update from master in primary mode has " + initializingId +_                            " as in-sync but it does not exist locally"__                        final long localCheckpoint = pre60AllocationIds.contains(initializingId) ?_                            SequenceNumbers.PRE_60_NODE_CHECKPOINT : SequenceNumbers.UNASSIGNED_SEQ_NO__                        final long globalCheckpoint = localCheckpoint__                        checkpoints.put(initializingId, new CheckpointState(localCheckpoint, globalCheckpoint, inSync, inSync))__                    }_                }_                if (removedEntries) {_                    pendingInSync.removeIf(aId -> checkpoints.containsKey(aId) == false)__                }_            } else {_                for (String initializingId : initializingAllocationIds) {_                    if (shardAllocationId.equals(initializingId) == false) {_                        final long localCheckpoint = pre60AllocationIds.contains(initializingId) ?_                            SequenceNumbers.PRE_60_NODE_CHECKPOINT : SequenceNumbers.UNASSIGNED_SEQ_NO__                        final long globalCheckpoint = localCheckpoint__                        checkpoints.put(initializingId, new CheckpointState(localCheckpoint, globalCheckpoint, false, false))__                    }_                }_                for (String inSyncId : inSyncAllocationIds) {_                    if (shardAllocationId.equals(inSyncId)) {_                        _                        CheckpointState checkpointState = checkpoints.get(shardAllocationId)__                        checkpointState.inSync = true__                        checkpointState.tracked = true__                    } else {_                        final long localCheckpoint = pre60AllocationIds.contains(inSyncId) ?_                            SequenceNumbers.PRE_60_NODE_CHECKPOINT : SequenceNumbers.UNASSIGNED_SEQ_NO__                        final long globalCheckpoint = localCheckpoint__                        checkpoints.put(inSyncId, new CheckpointState(localCheckpoint, globalCheckpoint, true, true))__                    }_                }_            }_            appliedClusterStateVersion = applyingClusterStateVersion__            this.routingTable = routingTable__            replicationGroup = calculateReplicationGroup()__            if (primaryMode && removedEntries) {_                updateGlobalCheckpointOnPrimary()__                _                notifyAllWaiters()__            }_        }_        assert invariant()__    };notifies,the,tracker,of,the,current,allocation,ids,in,the,cluster,state,param,applying,cluster,state,version,the,cluster,state,version,being,applied,when,updating,the,allocation,ids,from,the,master,param,in,sync,allocation,ids,the,allocation,ids,of,the,currently,in,sync,shard,copies,param,routing,table,the,shard,routing,table,param,pre60allocation,ids,the,allocation,ids,of,shards,that,are,allocated,to,pre,6,0,nodes;public,synchronized,void,update,from,master,final,long,applying,cluster,state,version,final,set,string,in,sync,allocation,ids,final,index,shard,routing,table,routing,table,final,set,string,pre60allocation,ids,assert,invariant,if,applying,cluster,state,version,applied,cluster,state,version,assert,primary,mode,in,sync,allocation,ids,stream,all,match,in,sync,id,checkpoints,contains,key,in,sync,id,checkpoints,get,in,sync,id,in,sync,update,from,master,in,primary,mode,contains,in,sync,ids,in,sync,allocation,ids,that,have,no,matching,entries,in,checkpoints,set,string,initializing,allocation,ids,routing,table,get,all,initializing,shards,stream,map,shard,routing,allocation,id,map,allocation,id,get,id,collect,collectors,to,set,boolean,removed,entries,checkpoints,key,set,remove,if,aid,in,sync,allocation,ids,contains,aid,initializing,allocation,ids,contains,aid,if,primary,mode,for,string,initializing,id,initializing,allocation,ids,if,checkpoints,contains,key,initializing,id,false,final,boolean,in,sync,in,sync,allocation,ids,contains,initializing,id,assert,in,sync,false,update,from,master,in,primary,mode,has,initializing,id,as,in,sync,but,it,does,not,exist,locally,final,long,local,checkpoint,pre60allocation,ids,contains,initializing,id,sequence,numbers,sequence,numbers,final,long,global,checkpoint,local,checkpoint,checkpoints,put,initializing,id,new,checkpoint,state,local,checkpoint,global,checkpoint,in,sync,in,sync,if,removed,entries,pending,in,sync,remove,if,a,id,checkpoints,contains,key,a,id,false,else,for,string,initializing,id,initializing,allocation,ids,if,shard,allocation,id,equals,initializing,id,false,final,long,local,checkpoint,pre60allocation,ids,contains,initializing,id,sequence,numbers,sequence,numbers,final,long,global,checkpoint,local,checkpoint,checkpoints,put,initializing,id,new,checkpoint,state,local,checkpoint,global,checkpoint,false,false,for,string,in,sync,id,in,sync,allocation,ids,if,shard,allocation,id,equals,in,sync,id,checkpoint,state,checkpoint,state,checkpoints,get,shard,allocation,id,checkpoint,state,in,sync,true,checkpoint,state,tracked,true,else,final,long,local,checkpoint,pre60allocation,ids,contains,in,sync,id,sequence,numbers,sequence,numbers,final,long,global,checkpoint,local,checkpoint,checkpoints,put,in,sync,id,new,checkpoint,state,local,checkpoint,global,checkpoint,true,true,applied,cluster,state,version,applying,cluster,state,version,this,routing,table,routing,table,replication,group,calculate,replication,group,if,primary,mode,removed,entries,update,global,checkpoint,on,primary,notify,all,waiters,assert,invariant
ReplicationTracker -> public synchronized void updateFromMaster(final long applyingClusterStateVersion, final Set<String> inSyncAllocationIds,                                               final IndexShardRoutingTable routingTable, final Set<String> pre60AllocationIds);1548944389;Notifies the tracker of the current allocation IDs in the cluster state.__@param applyingClusterStateVersion the cluster state version being applied when updating the allocation IDs from the master_@param inSyncAllocationIds         the allocation IDs of the currently in-sync shard copies_@param routingTable                the shard routing table_@param pre60AllocationIds          the allocation IDs of shards that are allocated to pre-6.0 nodes;public synchronized void updateFromMaster(final long applyingClusterStateVersion, final Set<String> inSyncAllocationIds,_                                              final IndexShardRoutingTable routingTable, final Set<String> pre60AllocationIds) {_        assert invariant()__        if (applyingClusterStateVersion > appliedClusterStateVersion) {_            _            assert !primaryMode || inSyncAllocationIds.stream().allMatch(_                inSyncId -> checkpoints.containsKey(inSyncId) && checkpoints.get(inSyncId).inSync) :_                "update from master in primary mode contains in-sync ids " + inSyncAllocationIds +_                    " that have no matching entries in " + checkpoints__            _            Set<String> initializingAllocationIds = routingTable.getAllInitializingShards().stream()_                .map(ShardRouting::allocationId).map(AllocationId::getId).collect(Collectors.toSet())__            boolean removedEntries = checkpoints.keySet().removeIf(_                aid -> !inSyncAllocationIds.contains(aid) && !initializingAllocationIds.contains(aid))___            if (primaryMode) {_                _                for (String initializingId : initializingAllocationIds) {_                    if (checkpoints.containsKey(initializingId) == false) {_                        final boolean inSync = inSyncAllocationIds.contains(initializingId)__                        assert inSync == false : "update from master in primary mode has " + initializingId +_                            " as in-sync but it does not exist locally"__                        final long localCheckpoint = pre60AllocationIds.contains(initializingId) ?_                            SequenceNumbers.PRE_60_NODE_CHECKPOINT : SequenceNumbers.UNASSIGNED_SEQ_NO__                        final long globalCheckpoint = localCheckpoint__                        checkpoints.put(initializingId, new CheckpointState(localCheckpoint, globalCheckpoint, inSync, inSync))__                    }_                }_                if (removedEntries) {_                    pendingInSync.removeIf(aId -> checkpoints.containsKey(aId) == false)__                }_            } else {_                for (String initializingId : initializingAllocationIds) {_                    if (shardAllocationId.equals(initializingId) == false) {_                        final long localCheckpoint = pre60AllocationIds.contains(initializingId) ?_                            SequenceNumbers.PRE_60_NODE_CHECKPOINT : SequenceNumbers.UNASSIGNED_SEQ_NO__                        final long globalCheckpoint = localCheckpoint__                        checkpoints.put(initializingId, new CheckpointState(localCheckpoint, globalCheckpoint, false, false))__                    }_                }_                for (String inSyncId : inSyncAllocationIds) {_                    if (shardAllocationId.equals(inSyncId)) {_                        _                        CheckpointState checkpointState = checkpoints.get(shardAllocationId)__                        checkpointState.inSync = true__                        checkpointState.tracked = true__                    } else {_                        final long localCheckpoint = pre60AllocationIds.contains(inSyncId) ?_                            SequenceNumbers.PRE_60_NODE_CHECKPOINT : SequenceNumbers.UNASSIGNED_SEQ_NO__                        final long globalCheckpoint = localCheckpoint__                        checkpoints.put(inSyncId, new CheckpointState(localCheckpoint, globalCheckpoint, true, true))__                    }_                }_            }_            appliedClusterStateVersion = applyingClusterStateVersion__            this.routingTable = routingTable__            replicationGroup = calculateReplicationGroup()__            if (primaryMode && removedEntries) {_                updateGlobalCheckpointOnPrimary()__                _                notifyAllWaiters()__            }_        }_        assert invariant()__    };notifies,the,tracker,of,the,current,allocation,ids,in,the,cluster,state,param,applying,cluster,state,version,the,cluster,state,version,being,applied,when,updating,the,allocation,ids,from,the,master,param,in,sync,allocation,ids,the,allocation,ids,of,the,currently,in,sync,shard,copies,param,routing,table,the,shard,routing,table,param,pre60allocation,ids,the,allocation,ids,of,shards,that,are,allocated,to,pre,6,0,nodes;public,synchronized,void,update,from,master,final,long,applying,cluster,state,version,final,set,string,in,sync,allocation,ids,final,index,shard,routing,table,routing,table,final,set,string,pre60allocation,ids,assert,invariant,if,applying,cluster,state,version,applied,cluster,state,version,assert,primary,mode,in,sync,allocation,ids,stream,all,match,in,sync,id,checkpoints,contains,key,in,sync,id,checkpoints,get,in,sync,id,in,sync,update,from,master,in,primary,mode,contains,in,sync,ids,in,sync,allocation,ids,that,have,no,matching,entries,in,checkpoints,set,string,initializing,allocation,ids,routing,table,get,all,initializing,shards,stream,map,shard,routing,allocation,id,map,allocation,id,get,id,collect,collectors,to,set,boolean,removed,entries,checkpoints,key,set,remove,if,aid,in,sync,allocation,ids,contains,aid,initializing,allocation,ids,contains,aid,if,primary,mode,for,string,initializing,id,initializing,allocation,ids,if,checkpoints,contains,key,initializing,id,false,final,boolean,in,sync,in,sync,allocation,ids,contains,initializing,id,assert,in,sync,false,update,from,master,in,primary,mode,has,initializing,id,as,in,sync,but,it,does,not,exist,locally,final,long,local,checkpoint,pre60allocation,ids,contains,initializing,id,sequence,numbers,sequence,numbers,final,long,global,checkpoint,local,checkpoint,checkpoints,put,initializing,id,new,checkpoint,state,local,checkpoint,global,checkpoint,in,sync,in,sync,if,removed,entries,pending,in,sync,remove,if,a,id,checkpoints,contains,key,a,id,false,else,for,string,initializing,id,initializing,allocation,ids,if,shard,allocation,id,equals,initializing,id,false,final,long,local,checkpoint,pre60allocation,ids,contains,initializing,id,sequence,numbers,sequence,numbers,final,long,global,checkpoint,local,checkpoint,checkpoints,put,initializing,id,new,checkpoint,state,local,checkpoint,global,checkpoint,false,false,for,string,in,sync,id,in,sync,allocation,ids,if,shard,allocation,id,equals,in,sync,id,checkpoint,state,checkpoint,state,checkpoints,get,shard,allocation,id,checkpoint,state,in,sync,true,checkpoint,state,tracked,true,else,final,long,local,checkpoint,pre60allocation,ids,contains,in,sync,id,sequence,numbers,sequence,numbers,final,long,global,checkpoint,local,checkpoint,checkpoints,put,in,sync,id,new,checkpoint,state,local,checkpoint,global,checkpoint,true,true,applied,cluster,state,version,applying,cluster,state,version,this,routing,table,routing,table,replication,group,calculate,replication,group,if,primary,mode,removed,entries,update,global,checkpoint,on,primary,notify,all,waiters,assert,invariant
ReplicationTracker -> public synchronized void updateFromMaster(final long applyingClusterStateVersion, final Set<String> inSyncAllocationIds,                                               final IndexShardRoutingTable routingTable, final Set<String> pre60AllocationIds);1549059559;Notifies the tracker of the current allocation IDs in the cluster state.__@param applyingClusterStateVersion the cluster state version being applied when updating the allocation IDs from the master_@param inSyncAllocationIds         the allocation IDs of the currently in-sync shard copies_@param routingTable                the shard routing table_@param pre60AllocationIds          the allocation IDs of shards that are allocated to pre-6.0 nodes;public synchronized void updateFromMaster(final long applyingClusterStateVersion, final Set<String> inSyncAllocationIds,_                                              final IndexShardRoutingTable routingTable, final Set<String> pre60AllocationIds) {_        assert invariant()__        if (applyingClusterStateVersion > appliedClusterStateVersion) {_            _            assert !primaryMode || inSyncAllocationIds.stream().allMatch(_                inSyncId -> checkpoints.containsKey(inSyncId) && checkpoints.get(inSyncId).inSync) :_                "update from master in primary mode contains in-sync ids " + inSyncAllocationIds +_                    " that have no matching entries in " + checkpoints__            _            Set<String> initializingAllocationIds = routingTable.getAllInitializingShards().stream()_                .map(ShardRouting::allocationId).map(AllocationId::getId).collect(Collectors.toSet())__            boolean removedEntries = checkpoints.keySet().removeIf(_                aid -> !inSyncAllocationIds.contains(aid) && !initializingAllocationIds.contains(aid))___            if (primaryMode) {_                _                for (String initializingId : initializingAllocationIds) {_                    if (checkpoints.containsKey(initializingId) == false) {_                        final boolean inSync = inSyncAllocationIds.contains(initializingId)__                        assert inSync == false : "update from master in primary mode has " + initializingId +_                            " as in-sync but it does not exist locally"__                        final long localCheckpoint = pre60AllocationIds.contains(initializingId) ?_                            SequenceNumbers.PRE_60_NODE_CHECKPOINT : SequenceNumbers.UNASSIGNED_SEQ_NO__                        final long globalCheckpoint = localCheckpoint__                        checkpoints.put(initializingId, new CheckpointState(localCheckpoint, globalCheckpoint, inSync, inSync))__                    }_                }_                if (removedEntries) {_                    pendingInSync.removeIf(aId -> checkpoints.containsKey(aId) == false)__                }_            } else {_                for (String initializingId : initializingAllocationIds) {_                    if (shardAllocationId.equals(initializingId) == false) {_                        final long localCheckpoint = pre60AllocationIds.contains(initializingId) ?_                            SequenceNumbers.PRE_60_NODE_CHECKPOINT : SequenceNumbers.UNASSIGNED_SEQ_NO__                        final long globalCheckpoint = localCheckpoint__                        checkpoints.put(initializingId, new CheckpointState(localCheckpoint, globalCheckpoint, false, false))__                    }_                }_                for (String inSyncId : inSyncAllocationIds) {_                    if (shardAllocationId.equals(inSyncId)) {_                        _                        CheckpointState checkpointState = checkpoints.get(shardAllocationId)__                        checkpointState.inSync = true__                        checkpointState.tracked = true__                    } else {_                        final long localCheckpoint = pre60AllocationIds.contains(inSyncId) ?_                            SequenceNumbers.PRE_60_NODE_CHECKPOINT : SequenceNumbers.UNASSIGNED_SEQ_NO__                        final long globalCheckpoint = localCheckpoint__                        checkpoints.put(inSyncId, new CheckpointState(localCheckpoint, globalCheckpoint, true, true))__                    }_                }_            }_            appliedClusterStateVersion = applyingClusterStateVersion__            this.routingTable = routingTable__            replicationGroup = calculateReplicationGroup()__            if (primaryMode && removedEntries) {_                updateGlobalCheckpointOnPrimary()__                _                notifyAllWaiters()__            }_        }_        assert invariant()__    };notifies,the,tracker,of,the,current,allocation,ids,in,the,cluster,state,param,applying,cluster,state,version,the,cluster,state,version,being,applied,when,updating,the,allocation,ids,from,the,master,param,in,sync,allocation,ids,the,allocation,ids,of,the,currently,in,sync,shard,copies,param,routing,table,the,shard,routing,table,param,pre60allocation,ids,the,allocation,ids,of,shards,that,are,allocated,to,pre,6,0,nodes;public,synchronized,void,update,from,master,final,long,applying,cluster,state,version,final,set,string,in,sync,allocation,ids,final,index,shard,routing,table,routing,table,final,set,string,pre60allocation,ids,assert,invariant,if,applying,cluster,state,version,applied,cluster,state,version,assert,primary,mode,in,sync,allocation,ids,stream,all,match,in,sync,id,checkpoints,contains,key,in,sync,id,checkpoints,get,in,sync,id,in,sync,update,from,master,in,primary,mode,contains,in,sync,ids,in,sync,allocation,ids,that,have,no,matching,entries,in,checkpoints,set,string,initializing,allocation,ids,routing,table,get,all,initializing,shards,stream,map,shard,routing,allocation,id,map,allocation,id,get,id,collect,collectors,to,set,boolean,removed,entries,checkpoints,key,set,remove,if,aid,in,sync,allocation,ids,contains,aid,initializing,allocation,ids,contains,aid,if,primary,mode,for,string,initializing,id,initializing,allocation,ids,if,checkpoints,contains,key,initializing,id,false,final,boolean,in,sync,in,sync,allocation,ids,contains,initializing,id,assert,in,sync,false,update,from,master,in,primary,mode,has,initializing,id,as,in,sync,but,it,does,not,exist,locally,final,long,local,checkpoint,pre60allocation,ids,contains,initializing,id,sequence,numbers,sequence,numbers,final,long,global,checkpoint,local,checkpoint,checkpoints,put,initializing,id,new,checkpoint,state,local,checkpoint,global,checkpoint,in,sync,in,sync,if,removed,entries,pending,in,sync,remove,if,a,id,checkpoints,contains,key,a,id,false,else,for,string,initializing,id,initializing,allocation,ids,if,shard,allocation,id,equals,initializing,id,false,final,long,local,checkpoint,pre60allocation,ids,contains,initializing,id,sequence,numbers,sequence,numbers,final,long,global,checkpoint,local,checkpoint,checkpoints,put,initializing,id,new,checkpoint,state,local,checkpoint,global,checkpoint,false,false,for,string,in,sync,id,in,sync,allocation,ids,if,shard,allocation,id,equals,in,sync,id,checkpoint,state,checkpoint,state,checkpoints,get,shard,allocation,id,checkpoint,state,in,sync,true,checkpoint,state,tracked,true,else,final,long,local,checkpoint,pre60allocation,ids,contains,in,sync,id,sequence,numbers,sequence,numbers,final,long,global,checkpoint,local,checkpoint,checkpoints,put,in,sync,id,new,checkpoint,state,local,checkpoint,global,checkpoint,true,true,applied,cluster,state,version,applying,cluster,state,version,this,routing,table,routing,table,replication,group,calculate,replication,group,if,primary,mode,removed,entries,update,global,checkpoint,on,primary,notify,all,waiters,assert,invariant
ReplicationTracker -> public synchronized void updateFromMaster(final long applyingClusterStateVersion, final Set<String> inSyncAllocationIds,                                               final IndexShardRoutingTable routingTable, final Set<String> pre60AllocationIds);1549294529;Notifies the tracker of the current allocation IDs in the cluster state.__@param applyingClusterStateVersion the cluster state version being applied when updating the allocation IDs from the master_@param inSyncAllocationIds         the allocation IDs of the currently in-sync shard copies_@param routingTable                the shard routing table_@param pre60AllocationIds          the allocation IDs of shards that are allocated to pre-6.0 nodes;public synchronized void updateFromMaster(final long applyingClusterStateVersion, final Set<String> inSyncAllocationIds,_                                              final IndexShardRoutingTable routingTable, final Set<String> pre60AllocationIds) {_        assert invariant()__        if (applyingClusterStateVersion > appliedClusterStateVersion) {_            _            assert !primaryMode || inSyncAllocationIds.stream().allMatch(_                inSyncId -> checkpoints.containsKey(inSyncId) && checkpoints.get(inSyncId).inSync) :_                "update from master in primary mode contains in-sync ids " + inSyncAllocationIds +_                    " that have no matching entries in " + checkpoints__            _            Set<String> initializingAllocationIds = routingTable.getAllInitializingShards().stream()_                .map(ShardRouting::allocationId).map(AllocationId::getId).collect(Collectors.toSet())__            boolean removedEntries = checkpoints.keySet().removeIf(_                aid -> !inSyncAllocationIds.contains(aid) && !initializingAllocationIds.contains(aid))___            if (primaryMode) {_                _                for (String initializingId : initializingAllocationIds) {_                    if (checkpoints.containsKey(initializingId) == false) {_                        final boolean inSync = inSyncAllocationIds.contains(initializingId)__                        assert inSync == false : "update from master in primary mode has " + initializingId +_                            " as in-sync but it does not exist locally"__                        final long localCheckpoint = pre60AllocationIds.contains(initializingId) ?_                            SequenceNumbers.PRE_60_NODE_CHECKPOINT : SequenceNumbers.UNASSIGNED_SEQ_NO__                        final long globalCheckpoint = localCheckpoint__                        checkpoints.put(initializingId, new CheckpointState(localCheckpoint, globalCheckpoint, inSync, inSync))__                    }_                }_                if (removedEntries) {_                    pendingInSync.removeIf(aId -> checkpoints.containsKey(aId) == false)__                }_            } else {_                for (String initializingId : initializingAllocationIds) {_                    if (shardAllocationId.equals(initializingId) == false) {_                        final long localCheckpoint = pre60AllocationIds.contains(initializingId) ?_                            SequenceNumbers.PRE_60_NODE_CHECKPOINT : SequenceNumbers.UNASSIGNED_SEQ_NO__                        final long globalCheckpoint = localCheckpoint__                        checkpoints.put(initializingId, new CheckpointState(localCheckpoint, globalCheckpoint, false, false))__                    }_                }_                for (String inSyncId : inSyncAllocationIds) {_                    if (shardAllocationId.equals(inSyncId)) {_                        _                        CheckpointState checkpointState = checkpoints.get(shardAllocationId)__                        checkpointState.inSync = true__                        checkpointState.tracked = true__                    } else {_                        final long localCheckpoint = pre60AllocationIds.contains(inSyncId) ?_                            SequenceNumbers.PRE_60_NODE_CHECKPOINT : SequenceNumbers.UNASSIGNED_SEQ_NO__                        final long globalCheckpoint = localCheckpoint__                        checkpoints.put(inSyncId, new CheckpointState(localCheckpoint, globalCheckpoint, true, true))__                    }_                }_            }_            appliedClusterStateVersion = applyingClusterStateVersion__            this.routingTable = routingTable__            replicationGroup = calculateReplicationGroup()__            if (primaryMode && removedEntries) {_                updateGlobalCheckpointOnPrimary()__                _                notifyAllWaiters()__            }_        }_        assert invariant()__    };notifies,the,tracker,of,the,current,allocation,ids,in,the,cluster,state,param,applying,cluster,state,version,the,cluster,state,version,being,applied,when,updating,the,allocation,ids,from,the,master,param,in,sync,allocation,ids,the,allocation,ids,of,the,currently,in,sync,shard,copies,param,routing,table,the,shard,routing,table,param,pre60allocation,ids,the,allocation,ids,of,shards,that,are,allocated,to,pre,6,0,nodes;public,synchronized,void,update,from,master,final,long,applying,cluster,state,version,final,set,string,in,sync,allocation,ids,final,index,shard,routing,table,routing,table,final,set,string,pre60allocation,ids,assert,invariant,if,applying,cluster,state,version,applied,cluster,state,version,assert,primary,mode,in,sync,allocation,ids,stream,all,match,in,sync,id,checkpoints,contains,key,in,sync,id,checkpoints,get,in,sync,id,in,sync,update,from,master,in,primary,mode,contains,in,sync,ids,in,sync,allocation,ids,that,have,no,matching,entries,in,checkpoints,set,string,initializing,allocation,ids,routing,table,get,all,initializing,shards,stream,map,shard,routing,allocation,id,map,allocation,id,get,id,collect,collectors,to,set,boolean,removed,entries,checkpoints,key,set,remove,if,aid,in,sync,allocation,ids,contains,aid,initializing,allocation,ids,contains,aid,if,primary,mode,for,string,initializing,id,initializing,allocation,ids,if,checkpoints,contains,key,initializing,id,false,final,boolean,in,sync,in,sync,allocation,ids,contains,initializing,id,assert,in,sync,false,update,from,master,in,primary,mode,has,initializing,id,as,in,sync,but,it,does,not,exist,locally,final,long,local,checkpoint,pre60allocation,ids,contains,initializing,id,sequence,numbers,sequence,numbers,final,long,global,checkpoint,local,checkpoint,checkpoints,put,initializing,id,new,checkpoint,state,local,checkpoint,global,checkpoint,in,sync,in,sync,if,removed,entries,pending,in,sync,remove,if,a,id,checkpoints,contains,key,a,id,false,else,for,string,initializing,id,initializing,allocation,ids,if,shard,allocation,id,equals,initializing,id,false,final,long,local,checkpoint,pre60allocation,ids,contains,initializing,id,sequence,numbers,sequence,numbers,final,long,global,checkpoint,local,checkpoint,checkpoints,put,initializing,id,new,checkpoint,state,local,checkpoint,global,checkpoint,false,false,for,string,in,sync,id,in,sync,allocation,ids,if,shard,allocation,id,equals,in,sync,id,checkpoint,state,checkpoint,state,checkpoints,get,shard,allocation,id,checkpoint,state,in,sync,true,checkpoint,state,tracked,true,else,final,long,local,checkpoint,pre60allocation,ids,contains,in,sync,id,sequence,numbers,sequence,numbers,final,long,global,checkpoint,local,checkpoint,checkpoints,put,in,sync,id,new,checkpoint,state,local,checkpoint,global,checkpoint,true,true,applied,cluster,state,version,applying,cluster,state,version,this,routing,table,routing,table,replication,group,calculate,replication,group,if,primary,mode,removed,entries,update,global,checkpoint,on,primary,notify,all,waiters,assert,invariant
ReplicationTracker -> public synchronized void updateFromMaster(final long applyingClusterStateVersion, final Set<String> inSyncAllocationIds,                                               final IndexShardRoutingTable routingTable, final Set<String> pre60AllocationIds);1549395737;Notifies the tracker of the current allocation IDs in the cluster state.__@param applyingClusterStateVersion the cluster state version being applied when updating the allocation IDs from the master_@param inSyncAllocationIds         the allocation IDs of the currently in-sync shard copies_@param routingTable                the shard routing table_@param pre60AllocationIds          the allocation IDs of shards that are allocated to pre-6.0 nodes;public synchronized void updateFromMaster(final long applyingClusterStateVersion, final Set<String> inSyncAllocationIds,_                                              final IndexShardRoutingTable routingTable, final Set<String> pre60AllocationIds) {_        assert invariant()__        if (applyingClusterStateVersion > appliedClusterStateVersion) {_            _            assert !primaryMode || inSyncAllocationIds.stream().allMatch(_                inSyncId -> checkpoints.containsKey(inSyncId) && checkpoints.get(inSyncId).inSync) :_                "update from master in primary mode contains in-sync ids " + inSyncAllocationIds +_                    " that have no matching entries in " + checkpoints__            _            Set<String> initializingAllocationIds = routingTable.getAllInitializingShards().stream()_                .map(ShardRouting::allocationId).map(AllocationId::getId).collect(Collectors.toSet())__            boolean removedEntries = checkpoints.keySet().removeIf(_                aid -> !inSyncAllocationIds.contains(aid) && !initializingAllocationIds.contains(aid))___            if (primaryMode) {_                _                for (String initializingId : initializingAllocationIds) {_                    if (checkpoints.containsKey(initializingId) == false) {_                        final boolean inSync = inSyncAllocationIds.contains(initializingId)__                        assert inSync == false : "update from master in primary mode has " + initializingId +_                            " as in-sync but it does not exist locally"__                        final long localCheckpoint = pre60AllocationIds.contains(initializingId) ?_                            SequenceNumbers.PRE_60_NODE_CHECKPOINT : SequenceNumbers.UNASSIGNED_SEQ_NO__                        final long globalCheckpoint = localCheckpoint__                        checkpoints.put(initializingId, new CheckpointState(localCheckpoint, globalCheckpoint, inSync, inSync))__                    }_                }_                if (removedEntries) {_                    pendingInSync.removeIf(aId -> checkpoints.containsKey(aId) == false)__                }_            } else {_                for (String initializingId : initializingAllocationIds) {_                    if (shardAllocationId.equals(initializingId) == false) {_                        final long localCheckpoint = pre60AllocationIds.contains(initializingId) ?_                            SequenceNumbers.PRE_60_NODE_CHECKPOINT : SequenceNumbers.UNASSIGNED_SEQ_NO__                        final long globalCheckpoint = localCheckpoint__                        checkpoints.put(initializingId, new CheckpointState(localCheckpoint, globalCheckpoint, false, false))__                    }_                }_                for (String inSyncId : inSyncAllocationIds) {_                    if (shardAllocationId.equals(inSyncId)) {_                        _                        CheckpointState checkpointState = checkpoints.get(shardAllocationId)__                        checkpointState.inSync = true__                        checkpointState.tracked = true__                    } else {_                        final long localCheckpoint = pre60AllocationIds.contains(inSyncId) ?_                            SequenceNumbers.PRE_60_NODE_CHECKPOINT : SequenceNumbers.UNASSIGNED_SEQ_NO__                        final long globalCheckpoint = localCheckpoint__                        checkpoints.put(inSyncId, new CheckpointState(localCheckpoint, globalCheckpoint, true, true))__                    }_                }_            }_            appliedClusterStateVersion = applyingClusterStateVersion__            this.routingTable = routingTable__            replicationGroup = calculateReplicationGroup()__            if (primaryMode && removedEntries) {_                updateGlobalCheckpointOnPrimary()__                _                notifyAllWaiters()__            }_        }_        assert invariant()__    };notifies,the,tracker,of,the,current,allocation,ids,in,the,cluster,state,param,applying,cluster,state,version,the,cluster,state,version,being,applied,when,updating,the,allocation,ids,from,the,master,param,in,sync,allocation,ids,the,allocation,ids,of,the,currently,in,sync,shard,copies,param,routing,table,the,shard,routing,table,param,pre60allocation,ids,the,allocation,ids,of,shards,that,are,allocated,to,pre,6,0,nodes;public,synchronized,void,update,from,master,final,long,applying,cluster,state,version,final,set,string,in,sync,allocation,ids,final,index,shard,routing,table,routing,table,final,set,string,pre60allocation,ids,assert,invariant,if,applying,cluster,state,version,applied,cluster,state,version,assert,primary,mode,in,sync,allocation,ids,stream,all,match,in,sync,id,checkpoints,contains,key,in,sync,id,checkpoints,get,in,sync,id,in,sync,update,from,master,in,primary,mode,contains,in,sync,ids,in,sync,allocation,ids,that,have,no,matching,entries,in,checkpoints,set,string,initializing,allocation,ids,routing,table,get,all,initializing,shards,stream,map,shard,routing,allocation,id,map,allocation,id,get,id,collect,collectors,to,set,boolean,removed,entries,checkpoints,key,set,remove,if,aid,in,sync,allocation,ids,contains,aid,initializing,allocation,ids,contains,aid,if,primary,mode,for,string,initializing,id,initializing,allocation,ids,if,checkpoints,contains,key,initializing,id,false,final,boolean,in,sync,in,sync,allocation,ids,contains,initializing,id,assert,in,sync,false,update,from,master,in,primary,mode,has,initializing,id,as,in,sync,but,it,does,not,exist,locally,final,long,local,checkpoint,pre60allocation,ids,contains,initializing,id,sequence,numbers,sequence,numbers,final,long,global,checkpoint,local,checkpoint,checkpoints,put,initializing,id,new,checkpoint,state,local,checkpoint,global,checkpoint,in,sync,in,sync,if,removed,entries,pending,in,sync,remove,if,a,id,checkpoints,contains,key,a,id,false,else,for,string,initializing,id,initializing,allocation,ids,if,shard,allocation,id,equals,initializing,id,false,final,long,local,checkpoint,pre60allocation,ids,contains,initializing,id,sequence,numbers,sequence,numbers,final,long,global,checkpoint,local,checkpoint,checkpoints,put,initializing,id,new,checkpoint,state,local,checkpoint,global,checkpoint,false,false,for,string,in,sync,id,in,sync,allocation,ids,if,shard,allocation,id,equals,in,sync,id,checkpoint,state,checkpoint,state,checkpoints,get,shard,allocation,id,checkpoint,state,in,sync,true,checkpoint,state,tracked,true,else,final,long,local,checkpoint,pre60allocation,ids,contains,in,sync,id,sequence,numbers,sequence,numbers,final,long,global,checkpoint,local,checkpoint,checkpoints,put,in,sync,id,new,checkpoint,state,local,checkpoint,global,checkpoint,true,true,applied,cluster,state,version,applying,cluster,state,version,this,routing,table,routing,table,replication,group,calculate,replication,group,if,primary,mode,removed,entries,update,global,checkpoint,on,primary,notify,all,waiters,assert,invariant
ReplicationTracker -> public synchronized void updateFromMaster(final long applyingClusterStateVersion, final Set<String> inSyncAllocationIds,                                               final IndexShardRoutingTable routingTable, final Set<String> pre60AllocationIds);1549937843;Notifies the tracker of the current allocation IDs in the cluster state.__@param applyingClusterStateVersion the cluster state version being applied when updating the allocation IDs from the master_@param inSyncAllocationIds         the allocation IDs of the currently in-sync shard copies_@param routingTable                the shard routing table_@param pre60AllocationIds          the allocation IDs of shards that are allocated to pre-6.0 nodes;public synchronized void updateFromMaster(final long applyingClusterStateVersion, final Set<String> inSyncAllocationIds,_                                              final IndexShardRoutingTable routingTable, final Set<String> pre60AllocationIds) {_        assert invariant()__        if (applyingClusterStateVersion > appliedClusterStateVersion) {_            _            assert !primaryMode || inSyncAllocationIds.stream().allMatch(_                inSyncId -> checkpoints.containsKey(inSyncId) && checkpoints.get(inSyncId).inSync) :_                "update from master in primary mode contains in-sync ids " + inSyncAllocationIds +_                    " that have no matching entries in " + checkpoints__            _            Set<String> initializingAllocationIds = routingTable.getAllInitializingShards().stream()_                .map(ShardRouting::allocationId).map(AllocationId::getId).collect(Collectors.toSet())__            boolean removedEntries = checkpoints.keySet().removeIf(_                aid -> !inSyncAllocationIds.contains(aid) && !initializingAllocationIds.contains(aid))___            if (primaryMode) {_                _                for (String initializingId : initializingAllocationIds) {_                    if (checkpoints.containsKey(initializingId) == false) {_                        final boolean inSync = inSyncAllocationIds.contains(initializingId)__                        assert inSync == false : "update from master in primary mode has " + initializingId +_                            " as in-sync but it does not exist locally"__                        final long localCheckpoint = pre60AllocationIds.contains(initializingId) ?_                            SequenceNumbers.PRE_60_NODE_CHECKPOINT : SequenceNumbers.UNASSIGNED_SEQ_NO__                        final long globalCheckpoint = localCheckpoint__                        checkpoints.put(initializingId, new CheckpointState(localCheckpoint, globalCheckpoint, inSync, inSync))__                    }_                }_                if (removedEntries) {_                    pendingInSync.removeIf(aId -> checkpoints.containsKey(aId) == false)__                }_            } else {_                for (String initializingId : initializingAllocationIds) {_                    if (shardAllocationId.equals(initializingId) == false) {_                        final long localCheckpoint = pre60AllocationIds.contains(initializingId) ?_                            SequenceNumbers.PRE_60_NODE_CHECKPOINT : SequenceNumbers.UNASSIGNED_SEQ_NO__                        final long globalCheckpoint = localCheckpoint__                        checkpoints.put(initializingId, new CheckpointState(localCheckpoint, globalCheckpoint, false, false))__                    }_                }_                for (String inSyncId : inSyncAllocationIds) {_                    if (shardAllocationId.equals(inSyncId)) {_                        _                        CheckpointState checkpointState = checkpoints.get(shardAllocationId)__                        checkpointState.inSync = true__                        checkpointState.tracked = true__                    } else {_                        final long localCheckpoint = pre60AllocationIds.contains(inSyncId) ?_                            SequenceNumbers.PRE_60_NODE_CHECKPOINT : SequenceNumbers.UNASSIGNED_SEQ_NO__                        final long globalCheckpoint = localCheckpoint__                        checkpoints.put(inSyncId, new CheckpointState(localCheckpoint, globalCheckpoint, true, true))__                    }_                }_            }_            appliedClusterStateVersion = applyingClusterStateVersion__            this.routingTable = routingTable__            replicationGroup = calculateReplicationGroup()__            if (primaryMode && removedEntries) {_                updateGlobalCheckpointOnPrimary()__                _                notifyAllWaiters()__            }_        }_        assert invariant()__    };notifies,the,tracker,of,the,current,allocation,ids,in,the,cluster,state,param,applying,cluster,state,version,the,cluster,state,version,being,applied,when,updating,the,allocation,ids,from,the,master,param,in,sync,allocation,ids,the,allocation,ids,of,the,currently,in,sync,shard,copies,param,routing,table,the,shard,routing,table,param,pre60allocation,ids,the,allocation,ids,of,shards,that,are,allocated,to,pre,6,0,nodes;public,synchronized,void,update,from,master,final,long,applying,cluster,state,version,final,set,string,in,sync,allocation,ids,final,index,shard,routing,table,routing,table,final,set,string,pre60allocation,ids,assert,invariant,if,applying,cluster,state,version,applied,cluster,state,version,assert,primary,mode,in,sync,allocation,ids,stream,all,match,in,sync,id,checkpoints,contains,key,in,sync,id,checkpoints,get,in,sync,id,in,sync,update,from,master,in,primary,mode,contains,in,sync,ids,in,sync,allocation,ids,that,have,no,matching,entries,in,checkpoints,set,string,initializing,allocation,ids,routing,table,get,all,initializing,shards,stream,map,shard,routing,allocation,id,map,allocation,id,get,id,collect,collectors,to,set,boolean,removed,entries,checkpoints,key,set,remove,if,aid,in,sync,allocation,ids,contains,aid,initializing,allocation,ids,contains,aid,if,primary,mode,for,string,initializing,id,initializing,allocation,ids,if,checkpoints,contains,key,initializing,id,false,final,boolean,in,sync,in,sync,allocation,ids,contains,initializing,id,assert,in,sync,false,update,from,master,in,primary,mode,has,initializing,id,as,in,sync,but,it,does,not,exist,locally,final,long,local,checkpoint,pre60allocation,ids,contains,initializing,id,sequence,numbers,sequence,numbers,final,long,global,checkpoint,local,checkpoint,checkpoints,put,initializing,id,new,checkpoint,state,local,checkpoint,global,checkpoint,in,sync,in,sync,if,removed,entries,pending,in,sync,remove,if,a,id,checkpoints,contains,key,a,id,false,else,for,string,initializing,id,initializing,allocation,ids,if,shard,allocation,id,equals,initializing,id,false,final,long,local,checkpoint,pre60allocation,ids,contains,initializing,id,sequence,numbers,sequence,numbers,final,long,global,checkpoint,local,checkpoint,checkpoints,put,initializing,id,new,checkpoint,state,local,checkpoint,global,checkpoint,false,false,for,string,in,sync,id,in,sync,allocation,ids,if,shard,allocation,id,equals,in,sync,id,checkpoint,state,checkpoint,state,checkpoints,get,shard,allocation,id,checkpoint,state,in,sync,true,checkpoint,state,tracked,true,else,final,long,local,checkpoint,pre60allocation,ids,contains,in,sync,id,sequence,numbers,sequence,numbers,final,long,global,checkpoint,local,checkpoint,checkpoints,put,in,sync,id,new,checkpoint,state,local,checkpoint,global,checkpoint,true,true,applied,cluster,state,version,applying,cluster,state,version,this,routing,table,routing,table,replication,group,calculate,replication,group,if,primary,mode,removed,entries,update,global,checkpoint,on,primary,notify,all,waiters,assert,invariant
ReplicationTracker -> public synchronized void updateFromMaster(final long applyingClusterStateVersion, final Set<String> inSyncAllocationIds,                                               final IndexShardRoutingTable routingTable, final Set<String> pre60AllocationIds);1549949489;Notifies the tracker of the current allocation IDs in the cluster state.__@param applyingClusterStateVersion the cluster state version being applied when updating the allocation IDs from the master_@param inSyncAllocationIds         the allocation IDs of the currently in-sync shard copies_@param routingTable                the shard routing table_@param pre60AllocationIds          the allocation IDs of shards that are allocated to pre-6.0 nodes;public synchronized void updateFromMaster(final long applyingClusterStateVersion, final Set<String> inSyncAllocationIds,_                                              final IndexShardRoutingTable routingTable, final Set<String> pre60AllocationIds) {_        assert invariant()__        if (applyingClusterStateVersion > appliedClusterStateVersion) {_            _            assert !primaryMode || inSyncAllocationIds.stream().allMatch(_                inSyncId -> checkpoints.containsKey(inSyncId) && checkpoints.get(inSyncId).inSync) :_                "update from master in primary mode contains in-sync ids " + inSyncAllocationIds +_                    " that have no matching entries in " + checkpoints__            _            Set<String> initializingAllocationIds = routingTable.getAllInitializingShards().stream()_                .map(ShardRouting::allocationId).map(AllocationId::getId).collect(Collectors.toSet())__            boolean removedEntries = checkpoints.keySet().removeIf(_                aid -> !inSyncAllocationIds.contains(aid) && !initializingAllocationIds.contains(aid))___            if (primaryMode) {_                _                for (String initializingId : initializingAllocationIds) {_                    if (checkpoints.containsKey(initializingId) == false) {_                        final boolean inSync = inSyncAllocationIds.contains(initializingId)__                        assert inSync == false : "update from master in primary mode has " + initializingId +_                            " as in-sync but it does not exist locally"__                        final long localCheckpoint = pre60AllocationIds.contains(initializingId) ?_                            SequenceNumbers.PRE_60_NODE_CHECKPOINT : SequenceNumbers.UNASSIGNED_SEQ_NO__                        final long globalCheckpoint = localCheckpoint__                        checkpoints.put(initializingId, new CheckpointState(localCheckpoint, globalCheckpoint, inSync, inSync))__                    }_                }_                if (removedEntries) {_                    pendingInSync.removeIf(aId -> checkpoints.containsKey(aId) == false)__                }_            } else {_                for (String initializingId : initializingAllocationIds) {_                    if (shardAllocationId.equals(initializingId) == false) {_                        final long localCheckpoint = pre60AllocationIds.contains(initializingId) ?_                            SequenceNumbers.PRE_60_NODE_CHECKPOINT : SequenceNumbers.UNASSIGNED_SEQ_NO__                        final long globalCheckpoint = localCheckpoint__                        checkpoints.put(initializingId, new CheckpointState(localCheckpoint, globalCheckpoint, false, false))__                    }_                }_                for (String inSyncId : inSyncAllocationIds) {_                    if (shardAllocationId.equals(inSyncId)) {_                        _                        CheckpointState checkpointState = checkpoints.get(shardAllocationId)__                        checkpointState.inSync = true__                        checkpointState.tracked = true__                    } else {_                        final long localCheckpoint = pre60AllocationIds.contains(inSyncId) ?_                            SequenceNumbers.PRE_60_NODE_CHECKPOINT : SequenceNumbers.UNASSIGNED_SEQ_NO__                        final long globalCheckpoint = localCheckpoint__                        checkpoints.put(inSyncId, new CheckpointState(localCheckpoint, globalCheckpoint, true, true))__                    }_                }_            }_            appliedClusterStateVersion = applyingClusterStateVersion__            this.routingTable = routingTable__            replicationGroup = calculateReplicationGroup()__            if (primaryMode && removedEntries) {_                updateGlobalCheckpointOnPrimary()__                _                notifyAllWaiters()__            }_        }_        assert invariant()__    };notifies,the,tracker,of,the,current,allocation,ids,in,the,cluster,state,param,applying,cluster,state,version,the,cluster,state,version,being,applied,when,updating,the,allocation,ids,from,the,master,param,in,sync,allocation,ids,the,allocation,ids,of,the,currently,in,sync,shard,copies,param,routing,table,the,shard,routing,table,param,pre60allocation,ids,the,allocation,ids,of,shards,that,are,allocated,to,pre,6,0,nodes;public,synchronized,void,update,from,master,final,long,applying,cluster,state,version,final,set,string,in,sync,allocation,ids,final,index,shard,routing,table,routing,table,final,set,string,pre60allocation,ids,assert,invariant,if,applying,cluster,state,version,applied,cluster,state,version,assert,primary,mode,in,sync,allocation,ids,stream,all,match,in,sync,id,checkpoints,contains,key,in,sync,id,checkpoints,get,in,sync,id,in,sync,update,from,master,in,primary,mode,contains,in,sync,ids,in,sync,allocation,ids,that,have,no,matching,entries,in,checkpoints,set,string,initializing,allocation,ids,routing,table,get,all,initializing,shards,stream,map,shard,routing,allocation,id,map,allocation,id,get,id,collect,collectors,to,set,boolean,removed,entries,checkpoints,key,set,remove,if,aid,in,sync,allocation,ids,contains,aid,initializing,allocation,ids,contains,aid,if,primary,mode,for,string,initializing,id,initializing,allocation,ids,if,checkpoints,contains,key,initializing,id,false,final,boolean,in,sync,in,sync,allocation,ids,contains,initializing,id,assert,in,sync,false,update,from,master,in,primary,mode,has,initializing,id,as,in,sync,but,it,does,not,exist,locally,final,long,local,checkpoint,pre60allocation,ids,contains,initializing,id,sequence,numbers,sequence,numbers,final,long,global,checkpoint,local,checkpoint,checkpoints,put,initializing,id,new,checkpoint,state,local,checkpoint,global,checkpoint,in,sync,in,sync,if,removed,entries,pending,in,sync,remove,if,a,id,checkpoints,contains,key,a,id,false,else,for,string,initializing,id,initializing,allocation,ids,if,shard,allocation,id,equals,initializing,id,false,final,long,local,checkpoint,pre60allocation,ids,contains,initializing,id,sequence,numbers,sequence,numbers,final,long,global,checkpoint,local,checkpoint,checkpoints,put,initializing,id,new,checkpoint,state,local,checkpoint,global,checkpoint,false,false,for,string,in,sync,id,in,sync,allocation,ids,if,shard,allocation,id,equals,in,sync,id,checkpoint,state,checkpoint,state,checkpoints,get,shard,allocation,id,checkpoint,state,in,sync,true,checkpoint,state,tracked,true,else,final,long,local,checkpoint,pre60allocation,ids,contains,in,sync,id,sequence,numbers,sequence,numbers,final,long,global,checkpoint,local,checkpoint,checkpoints,put,in,sync,id,new,checkpoint,state,local,checkpoint,global,checkpoint,true,true,applied,cluster,state,version,applying,cluster,state,version,this,routing,table,routing,table,replication,group,calculate,replication,group,if,primary,mode,removed,entries,update,global,checkpoint,on,primary,notify,all,waiters,assert,invariant
ReplicationTracker -> public synchronized void updateFromMaster(final long applyingClusterStateVersion, final Set<String> inSyncAllocationIds,                                               final IndexShardRoutingTable routingTable, final Set<String> pre60AllocationIds);1550526771;Notifies the tracker of the current allocation IDs in the cluster state.__@param applyingClusterStateVersion the cluster state version being applied when updating the allocation IDs from the master_@param inSyncAllocationIds         the allocation IDs of the currently in-sync shard copies_@param routingTable                the shard routing table_@param pre60AllocationIds          the allocation IDs of shards that are allocated to pre-6.0 nodes;public synchronized void updateFromMaster(final long applyingClusterStateVersion, final Set<String> inSyncAllocationIds,_                                              final IndexShardRoutingTable routingTable, final Set<String> pre60AllocationIds) {_        assert invariant()__        if (applyingClusterStateVersion > appliedClusterStateVersion) {_            _            assert !primaryMode || inSyncAllocationIds.stream().allMatch(_                inSyncId -> checkpoints.containsKey(inSyncId) && checkpoints.get(inSyncId).inSync) :_                "update from master in primary mode contains in-sync ids " + inSyncAllocationIds +_                    " that have no matching entries in " + checkpoints__            _            Set<String> initializingAllocationIds = routingTable.getAllInitializingShards().stream()_                .map(ShardRouting::allocationId).map(AllocationId::getId).collect(Collectors.toSet())__            boolean removedEntries = checkpoints.keySet().removeIf(_                aid -> !inSyncAllocationIds.contains(aid) && !initializingAllocationIds.contains(aid))___            if (primaryMode) {_                _                for (String initializingId : initializingAllocationIds) {_                    if (checkpoints.containsKey(initializingId) == false) {_                        final boolean inSync = inSyncAllocationIds.contains(initializingId)__                        assert inSync == false : "update from master in primary mode has " + initializingId +_                            " as in-sync but it does not exist locally"__                        final long localCheckpoint = pre60AllocationIds.contains(initializingId) ?_                            SequenceNumbers.PRE_60_NODE_CHECKPOINT : SequenceNumbers.UNASSIGNED_SEQ_NO__                        final long globalCheckpoint = localCheckpoint__                        checkpoints.put(initializingId, new CheckpointState(localCheckpoint, globalCheckpoint, inSync, inSync))__                    }_                }_                if (removedEntries) {_                    pendingInSync.removeIf(aId -> checkpoints.containsKey(aId) == false)__                }_            } else {_                for (String initializingId : initializingAllocationIds) {_                    if (shardAllocationId.equals(initializingId) == false) {_                        final long localCheckpoint = pre60AllocationIds.contains(initializingId) ?_                            SequenceNumbers.PRE_60_NODE_CHECKPOINT : SequenceNumbers.UNASSIGNED_SEQ_NO__                        final long globalCheckpoint = localCheckpoint__                        checkpoints.put(initializingId, new CheckpointState(localCheckpoint, globalCheckpoint, false, false))__                    }_                }_                for (String inSyncId : inSyncAllocationIds) {_                    if (shardAllocationId.equals(inSyncId)) {_                        _                        CheckpointState checkpointState = checkpoints.get(shardAllocationId)__                        checkpointState.inSync = true__                        checkpointState.tracked = true__                    } else {_                        final long localCheckpoint = pre60AllocationIds.contains(inSyncId) ?_                            SequenceNumbers.PRE_60_NODE_CHECKPOINT : SequenceNumbers.UNASSIGNED_SEQ_NO__                        final long globalCheckpoint = localCheckpoint__                        checkpoints.put(inSyncId, new CheckpointState(localCheckpoint, globalCheckpoint, true, true))__                    }_                }_            }_            appliedClusterStateVersion = applyingClusterStateVersion__            this.routingTable = routingTable__            replicationGroup = calculateReplicationGroup()__            if (primaryMode && removedEntries) {_                updateGlobalCheckpointOnPrimary()__                _                notifyAllWaiters()__            }_        }_        assert invariant()__    };notifies,the,tracker,of,the,current,allocation,ids,in,the,cluster,state,param,applying,cluster,state,version,the,cluster,state,version,being,applied,when,updating,the,allocation,ids,from,the,master,param,in,sync,allocation,ids,the,allocation,ids,of,the,currently,in,sync,shard,copies,param,routing,table,the,shard,routing,table,param,pre60allocation,ids,the,allocation,ids,of,shards,that,are,allocated,to,pre,6,0,nodes;public,synchronized,void,update,from,master,final,long,applying,cluster,state,version,final,set,string,in,sync,allocation,ids,final,index,shard,routing,table,routing,table,final,set,string,pre60allocation,ids,assert,invariant,if,applying,cluster,state,version,applied,cluster,state,version,assert,primary,mode,in,sync,allocation,ids,stream,all,match,in,sync,id,checkpoints,contains,key,in,sync,id,checkpoints,get,in,sync,id,in,sync,update,from,master,in,primary,mode,contains,in,sync,ids,in,sync,allocation,ids,that,have,no,matching,entries,in,checkpoints,set,string,initializing,allocation,ids,routing,table,get,all,initializing,shards,stream,map,shard,routing,allocation,id,map,allocation,id,get,id,collect,collectors,to,set,boolean,removed,entries,checkpoints,key,set,remove,if,aid,in,sync,allocation,ids,contains,aid,initializing,allocation,ids,contains,aid,if,primary,mode,for,string,initializing,id,initializing,allocation,ids,if,checkpoints,contains,key,initializing,id,false,final,boolean,in,sync,in,sync,allocation,ids,contains,initializing,id,assert,in,sync,false,update,from,master,in,primary,mode,has,initializing,id,as,in,sync,but,it,does,not,exist,locally,final,long,local,checkpoint,pre60allocation,ids,contains,initializing,id,sequence,numbers,sequence,numbers,final,long,global,checkpoint,local,checkpoint,checkpoints,put,initializing,id,new,checkpoint,state,local,checkpoint,global,checkpoint,in,sync,in,sync,if,removed,entries,pending,in,sync,remove,if,a,id,checkpoints,contains,key,a,id,false,else,for,string,initializing,id,initializing,allocation,ids,if,shard,allocation,id,equals,initializing,id,false,final,long,local,checkpoint,pre60allocation,ids,contains,initializing,id,sequence,numbers,sequence,numbers,final,long,global,checkpoint,local,checkpoint,checkpoints,put,initializing,id,new,checkpoint,state,local,checkpoint,global,checkpoint,false,false,for,string,in,sync,id,in,sync,allocation,ids,if,shard,allocation,id,equals,in,sync,id,checkpoint,state,checkpoint,state,checkpoints,get,shard,allocation,id,checkpoint,state,in,sync,true,checkpoint,state,tracked,true,else,final,long,local,checkpoint,pre60allocation,ids,contains,in,sync,id,sequence,numbers,sequence,numbers,final,long,global,checkpoint,local,checkpoint,checkpoints,put,in,sync,id,new,checkpoint,state,local,checkpoint,global,checkpoint,true,true,applied,cluster,state,version,applying,cluster,state,version,this,routing,table,routing,table,replication,group,calculate,replication,group,if,primary,mode,removed,entries,update,global,checkpoint,on,primary,notify,all,waiters,assert,invariant
ReplicationTracker -> public ReplicationTracker(             final ShardId shardId,             final String allocationId,             final IndexSettings indexSettings,             final long globalCheckpoint,             final LongConsumer onGlobalCheckpointUpdated,             final LongSupplier currentTimeMillisSupplier,             final BiConsumer<Collection<RetentionLease>, ActionListener<ReplicationResponse>> onNewRetentionLease);1548593396;Initialize the global checkpoint service. The specified global checkpoint should be set to the last known global checkpoint, or_{@link SequenceNumbers#UNASSIGNED_SEQ_NO}.__@param shardId             the shard ID_@param allocationId        the allocation ID_@param indexSettings       the index settings_@param globalCheckpoint    the last known global checkpoint for this shard, or {@link SequenceNumbers#UNASSIGNED_SEQ_NO}_@param onNewRetentionLease a callback when a new retention lease is created;public ReplicationTracker(_            final ShardId shardId,_            final String allocationId,_            final IndexSettings indexSettings,_            final long globalCheckpoint,_            final LongConsumer onGlobalCheckpointUpdated,_            final LongSupplier currentTimeMillisSupplier,_            final BiConsumer<Collection<RetentionLease>, ActionListener<ReplicationResponse>> onNewRetentionLease) {_        super(shardId, indexSettings)__        assert globalCheckpoint >= SequenceNumbers.UNASSIGNED_SEQ_NO : "illegal initial global checkpoint: " + globalCheckpoint__        this.shardAllocationId = allocationId__        this.primaryMode = false__        this.handoffInProgress = false__        this.appliedClusterStateVersion = -1L__        this.checkpoints = new HashMap<>(1 + indexSettings.getNumberOfReplicas())__        checkpoints.put(allocationId, new CheckpointState(SequenceNumbers.UNASSIGNED_SEQ_NO, globalCheckpoint, false, false))__        this.onGlobalCheckpointUpdated = Objects.requireNonNull(onGlobalCheckpointUpdated)__        this.currentTimeMillisSupplier = Objects.requireNonNull(currentTimeMillisSupplier)__        this.onNewRetentionLease = Objects.requireNonNull(onNewRetentionLease)__        this.pendingInSync = new HashSet<>()__        this.routingTable = null__        this.replicationGroup = null__        assert invariant()__    };initialize,the,global,checkpoint,service,the,specified,global,checkpoint,should,be,set,to,the,last,known,global,checkpoint,or,link,sequence,numbers,param,shard,id,the,shard,id,param,allocation,id,the,allocation,id,param,index,settings,the,index,settings,param,global,checkpoint,the,last,known,global,checkpoint,for,this,shard,or,link,sequence,numbers,param,on,new,retention,lease,a,callback,when,a,new,retention,lease,is,created;public,replication,tracker,final,shard,id,shard,id,final,string,allocation,id,final,index,settings,index,settings,final,long,global,checkpoint,final,long,consumer,on,global,checkpoint,updated,final,long,supplier,current,time,millis,supplier,final,bi,consumer,collection,retention,lease,action,listener,replication,response,on,new,retention,lease,super,shard,id,index,settings,assert,global,checkpoint,sequence,numbers,illegal,initial,global,checkpoint,global,checkpoint,this,shard,allocation,id,allocation,id,this,primary,mode,false,this,handoff,in,progress,false,this,applied,cluster,state,version,1l,this,checkpoints,new,hash,map,1,index,settings,get,number,of,replicas,checkpoints,put,allocation,id,new,checkpoint,state,sequence,numbers,global,checkpoint,false,false,this,on,global,checkpoint,updated,objects,require,non,null,on,global,checkpoint,updated,this,current,time,millis,supplier,objects,require,non,null,current,time,millis,supplier,this,on,new,retention,lease,objects,require,non,null,on,new,retention,lease,this,pending,in,sync,new,hash,set,this,routing,table,null,this,replication,group,null,assert,invariant
ReplicationTracker -> public ReplicationTracker(             final ShardId shardId,             final String allocationId,             final IndexSettings indexSettings,             final long globalCheckpoint,             final LongConsumer onGlobalCheckpointUpdated,             final LongSupplier currentTimeMillisSupplier,             final BiConsumer<Collection<RetentionLease>, ActionListener<ReplicationResponse>> onNewRetentionLease);1548594827;Initialize the global checkpoint service. The specified global checkpoint should be set to the last known global checkpoint, or_{@link SequenceNumbers#UNASSIGNED_SEQ_NO}.__@param shardId             the shard ID_@param allocationId        the allocation ID_@param indexSettings       the index settings_@param globalCheckpoint    the last known global checkpoint for this shard, or {@link SequenceNumbers#UNASSIGNED_SEQ_NO}_@param onNewRetentionLease a callback when a new retention lease is created;public ReplicationTracker(_            final ShardId shardId,_            final String allocationId,_            final IndexSettings indexSettings,_            final long globalCheckpoint,_            final LongConsumer onGlobalCheckpointUpdated,_            final LongSupplier currentTimeMillisSupplier,_            final BiConsumer<Collection<RetentionLease>, ActionListener<ReplicationResponse>> onNewRetentionLease) {_        super(shardId, indexSettings)__        assert globalCheckpoint >= SequenceNumbers.UNASSIGNED_SEQ_NO : "illegal initial global checkpoint: " + globalCheckpoint__        this.shardAllocationId = allocationId__        this.primaryMode = false__        this.handoffInProgress = false__        this.appliedClusterStateVersion = -1L__        this.checkpoints = new HashMap<>(1 + indexSettings.getNumberOfReplicas())__        checkpoints.put(allocationId, new CheckpointState(SequenceNumbers.UNASSIGNED_SEQ_NO, globalCheckpoint, false, false))__        this.onGlobalCheckpointUpdated = Objects.requireNonNull(onGlobalCheckpointUpdated)__        this.currentTimeMillisSupplier = Objects.requireNonNull(currentTimeMillisSupplier)__        this.onNewRetentionLease = Objects.requireNonNull(onNewRetentionLease)__        this.pendingInSync = new HashSet<>()__        this.routingTable = null__        this.replicationGroup = null__        assert invariant()__    };initialize,the,global,checkpoint,service,the,specified,global,checkpoint,should,be,set,to,the,last,known,global,checkpoint,or,link,sequence,numbers,param,shard,id,the,shard,id,param,allocation,id,the,allocation,id,param,index,settings,the,index,settings,param,global,checkpoint,the,last,known,global,checkpoint,for,this,shard,or,link,sequence,numbers,param,on,new,retention,lease,a,callback,when,a,new,retention,lease,is,created;public,replication,tracker,final,shard,id,shard,id,final,string,allocation,id,final,index,settings,index,settings,final,long,global,checkpoint,final,long,consumer,on,global,checkpoint,updated,final,long,supplier,current,time,millis,supplier,final,bi,consumer,collection,retention,lease,action,listener,replication,response,on,new,retention,lease,super,shard,id,index,settings,assert,global,checkpoint,sequence,numbers,illegal,initial,global,checkpoint,global,checkpoint,this,shard,allocation,id,allocation,id,this,primary,mode,false,this,handoff,in,progress,false,this,applied,cluster,state,version,1l,this,checkpoints,new,hash,map,1,index,settings,get,number,of,replicas,checkpoints,put,allocation,id,new,checkpoint,state,sequence,numbers,global,checkpoint,false,false,this,on,global,checkpoint,updated,objects,require,non,null,on,global,checkpoint,updated,this,current,time,millis,supplier,objects,require,non,null,current,time,millis,supplier,this,on,new,retention,lease,objects,require,non,null,on,new,retention,lease,this,pending,in,sync,new,hash,set,this,routing,table,null,this,replication,group,null,assert,invariant
ReplicationTracker -> public synchronized void updateGlobalCheckpointForShard(final String allocationId, final long globalCheckpoint);1524684173;Update the local knowledge of the global checkpoint for the specified allocation ID.__@param allocationId     the allocation ID to update the global checkpoint for_@param globalCheckpoint the global checkpoint;public synchronized void updateGlobalCheckpointForShard(final String allocationId, final long globalCheckpoint) {_        assert primaryMode__        assert handoffInProgress == false__        assert invariant()__        updateGlobalCheckpoint(_                allocationId,_                globalCheckpoint,_                current -> logger.trace(_                        "updating local knowledge for [{}] on the primary of the global checkpoint from [{}] to [{}]",_                        allocationId,_                        current,_                        globalCheckpoint))__        assert invariant()__    };update,the,local,knowledge,of,the,global,checkpoint,for,the,specified,allocation,id,param,allocation,id,the,allocation,id,to,update,the,global,checkpoint,for,param,global,checkpoint,the,global,checkpoint;public,synchronized,void,update,global,checkpoint,for,shard,final,string,allocation,id,final,long,global,checkpoint,assert,primary,mode,assert,handoff,in,progress,false,assert,invariant,update,global,checkpoint,allocation,id,global,checkpoint,current,logger,trace,updating,local,knowledge,for,on,the,primary,of,the,global,checkpoint,from,to,allocation,id,current,global,checkpoint,assert,invariant
ReplicationTracker -> public synchronized void updateGlobalCheckpointForShard(final String allocationId, final long globalCheckpoint);1525334055;Update the local knowledge of the global checkpoint for the specified allocation ID.__@param allocationId     the allocation ID to update the global checkpoint for_@param globalCheckpoint the global checkpoint;public synchronized void updateGlobalCheckpointForShard(final String allocationId, final long globalCheckpoint) {_        assert primaryMode__        assert handoffInProgress == false__        assert invariant()__        updateGlobalCheckpoint(_                allocationId,_                globalCheckpoint,_                current -> logger.trace(_                        "updating local knowledge for [{}] on the primary of the global checkpoint from [{}] to [{}]",_                        allocationId,_                        current,_                        globalCheckpoint))__        assert invariant()__    };update,the,local,knowledge,of,the,global,checkpoint,for,the,specified,allocation,id,param,allocation,id,the,allocation,id,to,update,the,global,checkpoint,for,param,global,checkpoint,the,global,checkpoint;public,synchronized,void,update,global,checkpoint,for,shard,final,string,allocation,id,final,long,global,checkpoint,assert,primary,mode,assert,handoff,in,progress,false,assert,invariant,update,global,checkpoint,allocation,id,global,checkpoint,current,logger,trace,updating,local,knowledge,for,on,the,primary,of,the,global,checkpoint,from,to,allocation,id,current,global,checkpoint,assert,invariant
ReplicationTracker -> public synchronized void updateGlobalCheckpointForShard(final String allocationId, final long globalCheckpoint);1533295538;Update the local knowledge of the global checkpoint for the specified allocation ID.__@param allocationId     the allocation ID to update the global checkpoint for_@param globalCheckpoint the global checkpoint;public synchronized void updateGlobalCheckpointForShard(final String allocationId, final long globalCheckpoint) {_        assert primaryMode__        assert handoffInProgress == false__        assert invariant()__        updateGlobalCheckpoint(_                allocationId,_                globalCheckpoint,_                current -> logger.trace(_                        "updating local knowledge for [{}] on the primary of the global checkpoint from [{}] to [{}]",_                        allocationId,_                        current,_                        globalCheckpoint))__        assert invariant()__    };update,the,local,knowledge,of,the,global,checkpoint,for,the,specified,allocation,id,param,allocation,id,the,allocation,id,to,update,the,global,checkpoint,for,param,global,checkpoint,the,global,checkpoint;public,synchronized,void,update,global,checkpoint,for,shard,final,string,allocation,id,final,long,global,checkpoint,assert,primary,mode,assert,handoff,in,progress,false,assert,invariant,update,global,checkpoint,allocation,id,global,checkpoint,current,logger,trace,updating,local,knowledge,for,on,the,primary,of,the,global,checkpoint,from,to,allocation,id,current,global,checkpoint,assert,invariant
ReplicationTracker -> public synchronized void updateGlobalCheckpointForShard(final String allocationId, final long globalCheckpoint);1533738061;Update the local knowledge of the global checkpoint for the specified allocation ID.__@param allocationId     the allocation ID to update the global checkpoint for_@param globalCheckpoint the global checkpoint;public synchronized void updateGlobalCheckpointForShard(final String allocationId, final long globalCheckpoint) {_        assert primaryMode__        assert handoffInProgress == false__        assert invariant()__        updateGlobalCheckpoint(_                allocationId,_                globalCheckpoint,_                current -> logger.trace(_                        "updated local knowledge for [{}] on the primary of the global checkpoint from [{}] to [{}]",_                        allocationId,_                        current,_                        globalCheckpoint))__        assert invariant()__    };update,the,local,knowledge,of,the,global,checkpoint,for,the,specified,allocation,id,param,allocation,id,the,allocation,id,to,update,the,global,checkpoint,for,param,global,checkpoint,the,global,checkpoint;public,synchronized,void,update,global,checkpoint,for,shard,final,string,allocation,id,final,long,global,checkpoint,assert,primary,mode,assert,handoff,in,progress,false,assert,invariant,update,global,checkpoint,allocation,id,global,checkpoint,current,logger,trace,updated,local,knowledge,for,on,the,primary,of,the,global,checkpoint,from,to,allocation,id,current,global,checkpoint,assert,invariant
ReplicationTracker -> public synchronized void updateGlobalCheckpointForShard(final String allocationId, final long globalCheckpoint);1546875837;Update the local knowledge of the global checkpoint for the specified allocation ID.__@param allocationId     the allocation ID to update the global checkpoint for_@param globalCheckpoint the global checkpoint;public synchronized void updateGlobalCheckpointForShard(final String allocationId, final long globalCheckpoint) {_        assert primaryMode__        assert handoffInProgress == false__        assert invariant()__        updateGlobalCheckpoint(_                allocationId,_                globalCheckpoint,_                current -> logger.trace(_                        "updated local knowledge for [{}] on the primary of the global checkpoint from [{}] to [{}]",_                        allocationId,_                        current,_                        globalCheckpoint))__        assert invariant()__    };update,the,local,knowledge,of,the,global,checkpoint,for,the,specified,allocation,id,param,allocation,id,the,allocation,id,to,update,the,global,checkpoint,for,param,global,checkpoint,the,global,checkpoint;public,synchronized,void,update,global,checkpoint,for,shard,final,string,allocation,id,final,long,global,checkpoint,assert,primary,mode,assert,handoff,in,progress,false,assert,invariant,update,global,checkpoint,allocation,id,global,checkpoint,current,logger,trace,updated,local,knowledge,for,on,the,primary,of,the,global,checkpoint,from,to,allocation,id,current,global,checkpoint,assert,invariant
ReplicationTracker -> public synchronized void updateGlobalCheckpointForShard(final String allocationId, final long globalCheckpoint);1546927432;Update the local knowledge of the global checkpoint for the specified allocation ID.__@param allocationId     the allocation ID to update the global checkpoint for_@param globalCheckpoint the global checkpoint;public synchronized void updateGlobalCheckpointForShard(final String allocationId, final long globalCheckpoint) {_        assert primaryMode__        assert handoffInProgress == false__        assert invariant()__        updateGlobalCheckpoint(_                allocationId,_                globalCheckpoint,_                current -> logger.trace(_                        "updated local knowledge for [{}] on the primary of the global checkpoint from [{}] to [{}]",_                        allocationId,_                        current,_                        globalCheckpoint))__        assert invariant()__    };update,the,local,knowledge,of,the,global,checkpoint,for,the,specified,allocation,id,param,allocation,id,the,allocation,id,to,update,the,global,checkpoint,for,param,global,checkpoint,the,global,checkpoint;public,synchronized,void,update,global,checkpoint,for,shard,final,string,allocation,id,final,long,global,checkpoint,assert,primary,mode,assert,handoff,in,progress,false,assert,invariant,update,global,checkpoint,allocation,id,global,checkpoint,current,logger,trace,updated,local,knowledge,for,on,the,primary,of,the,global,checkpoint,from,to,allocation,id,current,global,checkpoint,assert,invariant
ReplicationTracker -> public synchronized void updateGlobalCheckpointForShard(final String allocationId, final long globalCheckpoint);1547332999;Update the local knowledge of the global checkpoint for the specified allocation ID.__@param allocationId     the allocation ID to update the global checkpoint for_@param globalCheckpoint the global checkpoint;public synchronized void updateGlobalCheckpointForShard(final String allocationId, final long globalCheckpoint) {_        assert primaryMode__        assert handoffInProgress == false__        assert invariant()__        updateGlobalCheckpoint(_                allocationId,_                globalCheckpoint,_                current -> logger.trace(_                        "updated local knowledge for [{}] on the primary of the global checkpoint from [{}] to [{}]",_                        allocationId,_                        current,_                        globalCheckpoint))__        assert invariant()__    };update,the,local,knowledge,of,the,global,checkpoint,for,the,specified,allocation,id,param,allocation,id,the,allocation,id,to,update,the,global,checkpoint,for,param,global,checkpoint,the,global,checkpoint;public,synchronized,void,update,global,checkpoint,for,shard,final,string,allocation,id,final,long,global,checkpoint,assert,primary,mode,assert,handoff,in,progress,false,assert,invariant,update,global,checkpoint,allocation,id,global,checkpoint,current,logger,trace,updated,local,knowledge,for,on,the,primary,of,the,global,checkpoint,from,to,allocation,id,current,global,checkpoint,assert,invariant
ReplicationTracker -> public synchronized void updateGlobalCheckpointForShard(final String allocationId, final long globalCheckpoint);1548593396;Update the local knowledge of the global checkpoint for the specified allocation ID.__@param allocationId     the allocation ID to update the global checkpoint for_@param globalCheckpoint the global checkpoint;public synchronized void updateGlobalCheckpointForShard(final String allocationId, final long globalCheckpoint) {_        assert primaryMode__        assert handoffInProgress == false__        assert invariant()__        updateGlobalCheckpoint(_                allocationId,_                globalCheckpoint,_                current -> logger.trace(_                        "updated local knowledge for [{}] on the primary of the global checkpoint from [{}] to [{}]",_                        allocationId,_                        current,_                        globalCheckpoint))__        assert invariant()__    };update,the,local,knowledge,of,the,global,checkpoint,for,the,specified,allocation,id,param,allocation,id,the,allocation,id,to,update,the,global,checkpoint,for,param,global,checkpoint,the,global,checkpoint;public,synchronized,void,update,global,checkpoint,for,shard,final,string,allocation,id,final,long,global,checkpoint,assert,primary,mode,assert,handoff,in,progress,false,assert,invariant,update,global,checkpoint,allocation,id,global,checkpoint,current,logger,trace,updated,local,knowledge,for,on,the,primary,of,the,global,checkpoint,from,to,allocation,id,current,global,checkpoint,assert,invariant
ReplicationTracker -> public synchronized void updateGlobalCheckpointForShard(final String allocationId, final long globalCheckpoint);1548594827;Update the local knowledge of the global checkpoint for the specified allocation ID.__@param allocationId     the allocation ID to update the global checkpoint for_@param globalCheckpoint the global checkpoint;public synchronized void updateGlobalCheckpointForShard(final String allocationId, final long globalCheckpoint) {_        assert primaryMode__        assert handoffInProgress == false__        assert invariant()__        updateGlobalCheckpoint(_                allocationId,_                globalCheckpoint,_                current -> logger.trace(_                        "updated local knowledge for [{}] on the primary of the global checkpoint from [{}] to [{}]",_                        allocationId,_                        current,_                        globalCheckpoint))__        assert invariant()__    };update,the,local,knowledge,of,the,global,checkpoint,for,the,specified,allocation,id,param,allocation,id,the,allocation,id,to,update,the,global,checkpoint,for,param,global,checkpoint,the,global,checkpoint;public,synchronized,void,update,global,checkpoint,for,shard,final,string,allocation,id,final,long,global,checkpoint,assert,primary,mode,assert,handoff,in,progress,false,assert,invariant,update,global,checkpoint,allocation,id,global,checkpoint,current,logger,trace,updated,local,knowledge,for,on,the,primary,of,the,global,checkpoint,from,to,allocation,id,current,global,checkpoint,assert,invariant
ReplicationTracker -> public synchronized void updateGlobalCheckpointForShard(final String allocationId, final long globalCheckpoint);1548677511;Update the local knowledge of the global checkpoint for the specified allocation ID.__@param allocationId     the allocation ID to update the global checkpoint for_@param globalCheckpoint the global checkpoint;public synchronized void updateGlobalCheckpointForShard(final String allocationId, final long globalCheckpoint) {_        assert primaryMode__        assert handoffInProgress == false__        assert invariant()__        updateGlobalCheckpoint(_                allocationId,_                globalCheckpoint,_                current -> logger.trace(_                        "updated local knowledge for [{}] on the primary of the global checkpoint from [{}] to [{}]",_                        allocationId,_                        current,_                        globalCheckpoint))__        assert invariant()__    };update,the,local,knowledge,of,the,global,checkpoint,for,the,specified,allocation,id,param,allocation,id,the,allocation,id,to,update,the,global,checkpoint,for,param,global,checkpoint,the,global,checkpoint;public,synchronized,void,update,global,checkpoint,for,shard,final,string,allocation,id,final,long,global,checkpoint,assert,primary,mode,assert,handoff,in,progress,false,assert,invariant,update,global,checkpoint,allocation,id,global,checkpoint,current,logger,trace,updated,local,knowledge,for,on,the,primary,of,the,global,checkpoint,from,to,allocation,id,current,global,checkpoint,assert,invariant
ReplicationTracker -> public synchronized void updateGlobalCheckpointForShard(final String allocationId, final long globalCheckpoint);1548944389;Update the local knowledge of the global checkpoint for the specified allocation ID.__@param allocationId     the allocation ID to update the global checkpoint for_@param globalCheckpoint the global checkpoint;public synchronized void updateGlobalCheckpointForShard(final String allocationId, final long globalCheckpoint) {_        assert primaryMode__        assert handoffInProgress == false__        assert invariant()__        updateGlobalCheckpoint(_                allocationId,_                globalCheckpoint,_                current -> logger.trace(_                        "updated local knowledge for [{}] on the primary of the global checkpoint from [{}] to [{}]",_                        allocationId,_                        current,_                        globalCheckpoint))__        assert invariant()__    };update,the,local,knowledge,of,the,global,checkpoint,for,the,specified,allocation,id,param,allocation,id,the,allocation,id,to,update,the,global,checkpoint,for,param,global,checkpoint,the,global,checkpoint;public,synchronized,void,update,global,checkpoint,for,shard,final,string,allocation,id,final,long,global,checkpoint,assert,primary,mode,assert,handoff,in,progress,false,assert,invariant,update,global,checkpoint,allocation,id,global,checkpoint,current,logger,trace,updated,local,knowledge,for,on,the,primary,of,the,global,checkpoint,from,to,allocation,id,current,global,checkpoint,assert,invariant
ReplicationTracker -> public synchronized void updateGlobalCheckpointForShard(final String allocationId, final long globalCheckpoint);1549059559;Update the local knowledge of the global checkpoint for the specified allocation ID.__@param allocationId     the allocation ID to update the global checkpoint for_@param globalCheckpoint the global checkpoint;public synchronized void updateGlobalCheckpointForShard(final String allocationId, final long globalCheckpoint) {_        assert primaryMode__        assert handoffInProgress == false__        assert invariant()__        updateGlobalCheckpoint(_                allocationId,_                globalCheckpoint,_                current -> logger.trace(_                        "updated local knowledge for [{}] on the primary of the global checkpoint from [{}] to [{}]",_                        allocationId,_                        current,_                        globalCheckpoint))__        assert invariant()__    };update,the,local,knowledge,of,the,global,checkpoint,for,the,specified,allocation,id,param,allocation,id,the,allocation,id,to,update,the,global,checkpoint,for,param,global,checkpoint,the,global,checkpoint;public,synchronized,void,update,global,checkpoint,for,shard,final,string,allocation,id,final,long,global,checkpoint,assert,primary,mode,assert,handoff,in,progress,false,assert,invariant,update,global,checkpoint,allocation,id,global,checkpoint,current,logger,trace,updated,local,knowledge,for,on,the,primary,of,the,global,checkpoint,from,to,allocation,id,current,global,checkpoint,assert,invariant
ReplicationTracker -> public synchronized void updateGlobalCheckpointForShard(final String allocationId, final long globalCheckpoint);1549294529;Update the local knowledge of the global checkpoint for the specified allocation ID.__@param allocationId     the allocation ID to update the global checkpoint for_@param globalCheckpoint the global checkpoint;public synchronized void updateGlobalCheckpointForShard(final String allocationId, final long globalCheckpoint) {_        assert primaryMode__        assert handoffInProgress == false__        assert invariant()__        updateGlobalCheckpoint(_                allocationId,_                globalCheckpoint,_                current -> logger.trace(_                        "updated local knowledge for [{}] on the primary of the global checkpoint from [{}] to [{}]",_                        allocationId,_                        current,_                        globalCheckpoint))__        assert invariant()__    };update,the,local,knowledge,of,the,global,checkpoint,for,the,specified,allocation,id,param,allocation,id,the,allocation,id,to,update,the,global,checkpoint,for,param,global,checkpoint,the,global,checkpoint;public,synchronized,void,update,global,checkpoint,for,shard,final,string,allocation,id,final,long,global,checkpoint,assert,primary,mode,assert,handoff,in,progress,false,assert,invariant,update,global,checkpoint,allocation,id,global,checkpoint,current,logger,trace,updated,local,knowledge,for,on,the,primary,of,the,global,checkpoint,from,to,allocation,id,current,global,checkpoint,assert,invariant
ReplicationTracker -> public synchronized void updateGlobalCheckpointForShard(final String allocationId, final long globalCheckpoint);1549395737;Update the local knowledge of the global checkpoint for the specified allocation ID.__@param allocationId     the allocation ID to update the global checkpoint for_@param globalCheckpoint the global checkpoint;public synchronized void updateGlobalCheckpointForShard(final String allocationId, final long globalCheckpoint) {_        assert primaryMode__        assert handoffInProgress == false__        assert invariant()__        updateGlobalCheckpoint(_                allocationId,_                globalCheckpoint,_                current -> logger.trace(_                        "updated local knowledge for [{}] on the primary of the global checkpoint from [{}] to [{}]",_                        allocationId,_                        current,_                        globalCheckpoint))__        assert invariant()__    };update,the,local,knowledge,of,the,global,checkpoint,for,the,specified,allocation,id,param,allocation,id,the,allocation,id,to,update,the,global,checkpoint,for,param,global,checkpoint,the,global,checkpoint;public,synchronized,void,update,global,checkpoint,for,shard,final,string,allocation,id,final,long,global,checkpoint,assert,primary,mode,assert,handoff,in,progress,false,assert,invariant,update,global,checkpoint,allocation,id,global,checkpoint,current,logger,trace,updated,local,knowledge,for,on,the,primary,of,the,global,checkpoint,from,to,allocation,id,current,global,checkpoint,assert,invariant
ReplicationTracker -> public synchronized void updateGlobalCheckpointForShard(final String allocationId, final long globalCheckpoint);1549937843;Update the local knowledge of the global checkpoint for the specified allocation ID.__@param allocationId     the allocation ID to update the global checkpoint for_@param globalCheckpoint the global checkpoint;public synchronized void updateGlobalCheckpointForShard(final String allocationId, final long globalCheckpoint) {_        assert primaryMode__        assert handoffInProgress == false__        assert invariant()__        updateGlobalCheckpoint(_                allocationId,_                globalCheckpoint,_                current -> logger.trace(_                        "updated local knowledge for [{}] on the primary of the global checkpoint from [{}] to [{}]",_                        allocationId,_                        current,_                        globalCheckpoint))__        assert invariant()__    };update,the,local,knowledge,of,the,global,checkpoint,for,the,specified,allocation,id,param,allocation,id,the,allocation,id,to,update,the,global,checkpoint,for,param,global,checkpoint,the,global,checkpoint;public,synchronized,void,update,global,checkpoint,for,shard,final,string,allocation,id,final,long,global,checkpoint,assert,primary,mode,assert,handoff,in,progress,false,assert,invariant,update,global,checkpoint,allocation,id,global,checkpoint,current,logger,trace,updated,local,knowledge,for,on,the,primary,of,the,global,checkpoint,from,to,allocation,id,current,global,checkpoint,assert,invariant
ReplicationTracker -> public synchronized void updateGlobalCheckpointForShard(final String allocationId, final long globalCheckpoint);1549949489;Update the local knowledge of the global checkpoint for the specified allocation ID.__@param allocationId     the allocation ID to update the global checkpoint for_@param globalCheckpoint the global checkpoint;public synchronized void updateGlobalCheckpointForShard(final String allocationId, final long globalCheckpoint) {_        assert primaryMode__        assert handoffInProgress == false__        assert invariant()__        updateGlobalCheckpoint(_                allocationId,_                globalCheckpoint,_                current -> logger.trace(_                        "updated local knowledge for [{}] on the primary of the global checkpoint from [{}] to [{}]",_                        allocationId,_                        current,_                        globalCheckpoint))__        assert invariant()__    };update,the,local,knowledge,of,the,global,checkpoint,for,the,specified,allocation,id,param,allocation,id,the,allocation,id,to,update,the,global,checkpoint,for,param,global,checkpoint,the,global,checkpoint;public,synchronized,void,update,global,checkpoint,for,shard,final,string,allocation,id,final,long,global,checkpoint,assert,primary,mode,assert,handoff,in,progress,false,assert,invariant,update,global,checkpoint,allocation,id,global,checkpoint,current,logger,trace,updated,local,knowledge,for,on,the,primary,of,the,global,checkpoint,from,to,allocation,id,current,global,checkpoint,assert,invariant
ReplicationTracker -> public synchronized void updateGlobalCheckpointForShard(final String allocationId, final long globalCheckpoint);1550526771;Update the local knowledge of the global checkpoint for the specified allocation ID.__@param allocationId     the allocation ID to update the global checkpoint for_@param globalCheckpoint the global checkpoint;public synchronized void updateGlobalCheckpointForShard(final String allocationId, final long globalCheckpoint) {_        assert primaryMode__        assert handoffInProgress == false__        assert invariant()__        updateGlobalCheckpoint(_                allocationId,_                globalCheckpoint,_                current -> logger.trace(_                        "updated local knowledge for [{}] on the primary of the global checkpoint from [{}] to [{}]",_                        allocationId,_                        current,_                        globalCheckpoint))__        assert invariant()__    };update,the,local,knowledge,of,the,global,checkpoint,for,the,specified,allocation,id,param,allocation,id,the,allocation,id,to,update,the,global,checkpoint,for,param,global,checkpoint,the,global,checkpoint;public,synchronized,void,update,global,checkpoint,for,shard,final,string,allocation,id,final,long,global,checkpoint,assert,primary,mode,assert,handoff,in,progress,false,assert,invariant,update,global,checkpoint,allocation,id,global,checkpoint,current,logger,trace,updated,local,knowledge,for,on,the,primary,of,the,global,checkpoint,from,to,allocation,id,current,global,checkpoint,assert,invariant
ReplicationTracker -> public RetentionLeases getRetentionLeases();1549059559;Get all non-expired retention leases tracked on this shard. An unmodifiable copy of the retention leases is returned. Note that only_the primary shard calculates which leases are expired, and if any have expired, syncs the retention leases to any replicas.__@return the retention leases;public RetentionLeases getRetentionLeases() {_        final boolean wasPrimaryMode__        final RetentionLeases nonExpiredRetentionLeases__        synchronized (this) {_            if (primaryMode) {_                _                final long currentTimeMillis = currentTimeMillisSupplier.getAsLong()__                final long retentionLeaseMillis = indexSettings.getRetentionLeaseMillis()__                final Map<Boolean, List<RetentionLease>> partitionByExpiration = retentionLeases_                        .leases()_                        .stream()_                        .collect(Collectors.groupingBy(lease -> currentTimeMillis - lease.timestamp() > retentionLeaseMillis))__                if (partitionByExpiration.get(true) == null) {_                    _                    return retentionLeases__                }_                final Collection<RetentionLease> nonExpiredLeases =_                        partitionByExpiration.get(false) != null ? partitionByExpiration.get(false) : Collections.emptyList()__                retentionLeases = new RetentionLeases(operationPrimaryTerm, retentionLeases.version() + 1, nonExpiredLeases)__            }_            _            wasPrimaryMode = primaryMode__            nonExpiredRetentionLeases = retentionLeases__        }_        if (wasPrimaryMode) {_            onSyncRetentionLeases.accept(nonExpiredRetentionLeases, ActionListener.wrap(() -> {}))__        }_        return nonExpiredRetentionLeases__    };get,all,non,expired,retention,leases,tracked,on,this,shard,an,unmodifiable,copy,of,the,retention,leases,is,returned,note,that,only,the,primary,shard,calculates,which,leases,are,expired,and,if,any,have,expired,syncs,the,retention,leases,to,any,replicas,return,the,retention,leases;public,retention,leases,get,retention,leases,final,boolean,was,primary,mode,final,retention,leases,non,expired,retention,leases,synchronized,this,if,primary,mode,final,long,current,time,millis,current,time,millis,supplier,get,as,long,final,long,retention,lease,millis,index,settings,get,retention,lease,millis,final,map,boolean,list,retention,lease,partition,by,expiration,retention,leases,leases,stream,collect,collectors,grouping,by,lease,current,time,millis,lease,timestamp,retention,lease,millis,if,partition,by,expiration,get,true,null,return,retention,leases,final,collection,retention,lease,non,expired,leases,partition,by,expiration,get,false,null,partition,by,expiration,get,false,collections,empty,list,retention,leases,new,retention,leases,operation,primary,term,retention,leases,version,1,non,expired,leases,was,primary,mode,primary,mode,non,expired,retention,leases,retention,leases,if,was,primary,mode,on,sync,retention,leases,accept,non,expired,retention,leases,action,listener,wrap,return,non,expired,retention,leases
ReplicationTracker -> public RetentionLeases getRetentionLeases();1549294529;Get all non-expired retention leases tracked on this shard. Note that only the primary shard calculates which leases are expired,_and if any have expired, syncs the retention leases to any replicas.__@return the retention leases;public RetentionLeases getRetentionLeases() {_        final boolean wasPrimaryMode__        final RetentionLeases nonExpiredRetentionLeases__        synchronized (this) {_            if (primaryMode) {_                _                final long currentTimeMillis = currentTimeMillisSupplier.getAsLong()__                final long retentionLeaseMillis = indexSettings.getRetentionLeaseMillis()__                final Map<Boolean, List<RetentionLease>> partitionByExpiration = retentionLeases_                        .leases()_                        .stream()_                        .collect(Collectors.groupingBy(lease -> currentTimeMillis - lease.timestamp() > retentionLeaseMillis))__                if (partitionByExpiration.get(true) == null) {_                    _                    return retentionLeases__                }_                final Collection<RetentionLease> nonExpiredLeases =_                        partitionByExpiration.get(false) != null ? partitionByExpiration.get(false) : Collections.emptyList()__                retentionLeases = new RetentionLeases(operationPrimaryTerm, retentionLeases.version() + 1, nonExpiredLeases)__            }_            _            wasPrimaryMode = primaryMode__            nonExpiredRetentionLeases = retentionLeases__        }_        if (wasPrimaryMode) {_            onSyncRetentionLeases.accept(nonExpiredRetentionLeases, ActionListener.wrap(() -> {}))__        }_        return nonExpiredRetentionLeases__    };get,all,non,expired,retention,leases,tracked,on,this,shard,note,that,only,the,primary,shard,calculates,which,leases,are,expired,and,if,any,have,expired,syncs,the,retention,leases,to,any,replicas,return,the,retention,leases;public,retention,leases,get,retention,leases,final,boolean,was,primary,mode,final,retention,leases,non,expired,retention,leases,synchronized,this,if,primary,mode,final,long,current,time,millis,current,time,millis,supplier,get,as,long,final,long,retention,lease,millis,index,settings,get,retention,lease,millis,final,map,boolean,list,retention,lease,partition,by,expiration,retention,leases,leases,stream,collect,collectors,grouping,by,lease,current,time,millis,lease,timestamp,retention,lease,millis,if,partition,by,expiration,get,true,null,return,retention,leases,final,collection,retention,lease,non,expired,leases,partition,by,expiration,get,false,null,partition,by,expiration,get,false,collections,empty,list,retention,leases,new,retention,leases,operation,primary,term,retention,leases,version,1,non,expired,leases,was,primary,mode,primary,mode,non,expired,retention,leases,retention,leases,if,was,primary,mode,on,sync,retention,leases,accept,non,expired,retention,leases,action,listener,wrap,return,non,expired,retention,leases
ReplicationTracker -> public RetentionLeases getRetentionLeases();1549395737;Get all retention leases tracked on this shard.__@return the retention leases;public RetentionLeases getRetentionLeases() {_        return getRetentionLeases(false).v2()__    };get,all,retention,leases,tracked,on,this,shard,return,the,retention,leases;public,retention,leases,get,retention,leases,return,get,retention,leases,false,v2
ReplicationTracker -> public RetentionLeases getRetentionLeases();1549937843;Get all retention leases tracked on this shard.__@return the retention leases;public RetentionLeases getRetentionLeases() {_        return getRetentionLeases(false).v2()__    };get,all,retention,leases,tracked,on,this,shard,return,the,retention,leases;public,retention,leases,get,retention,leases,return,get,retention,leases,false,v2
ReplicationTracker -> public RetentionLeases getRetentionLeases();1549949489;Get all retention leases tracked on this shard.__@return the retention leases;public RetentionLeases getRetentionLeases() {_        return getRetentionLeases(false).v2()__    };get,all,retention,leases,tracked,on,this,shard,return,the,retention,leases;public,retention,leases,get,retention,leases,return,get,retention,leases,false,v2
ReplicationTracker -> public RetentionLeases getRetentionLeases();1550526771;Get all retention leases tracked on this shard.__@return the retention leases;public RetentionLeases getRetentionLeases() {_        return getRetentionLeases(false).v2()__    };get,all,retention,leases,tracked,on,this,shard,return,the,retention,leases;public,retention,leases,get,retention,leases,return,get,retention,leases,false,v2
ReplicationTracker -> public void removeRetentionLease(final String id, final ActionListener<ReplicationResponse> listener);1549937843;Removes an existing retention lease.__@param id       the identifier of the retention lease_@param listener the callback when the retention lease is successfully removed and synced to replicas;public void removeRetentionLease(final String id, final ActionListener<ReplicationResponse> listener) {_        Objects.requireNonNull(listener)__        final RetentionLeases currentRetentionLeases__        synchronized (this) {_            assert primaryMode__            if (retentionLeases.contains(id) == false) {_                throw new IllegalArgumentException("retention lease with ID [" + id + "] does not exist")__            }_            retentionLeases = new RetentionLeases(_                    operationPrimaryTerm,_                    retentionLeases.version() + 1,_                    retentionLeases.leases().stream().filter(lease -> lease.id().equals(id) == false).collect(Collectors.toList()))__            currentRetentionLeases = retentionLeases__        }_        onSyncRetentionLeases.accept(currentRetentionLeases, listener)__    };removes,an,existing,retention,lease,param,id,the,identifier,of,the,retention,lease,param,listener,the,callback,when,the,retention,lease,is,successfully,removed,and,synced,to,replicas;public,void,remove,retention,lease,final,string,id,final,action,listener,replication,response,listener,objects,require,non,null,listener,final,retention,leases,current,retention,leases,synchronized,this,assert,primary,mode,if,retention,leases,contains,id,false,throw,new,illegal,argument,exception,retention,lease,with,id,id,does,not,exist,retention,leases,new,retention,leases,operation,primary,term,retention,leases,version,1,retention,leases,leases,stream,filter,lease,lease,id,equals,id,false,collect,collectors,to,list,current,retention,leases,retention,leases,on,sync,retention,leases,accept,current,retention,leases,listener
ReplicationTracker -> public void removeRetentionLease(final String id, final ActionListener<ReplicationResponse> listener);1549949489;Removes an existing retention lease.__@param id       the identifier of the retention lease_@param listener the callback when the retention lease is successfully removed and synced to replicas;public void removeRetentionLease(final String id, final ActionListener<ReplicationResponse> listener) {_        Objects.requireNonNull(listener)__        final RetentionLeases currentRetentionLeases__        synchronized (this) {_            assert primaryMode__            if (retentionLeases.contains(id) == false) {_                throw new RetentionLeaseNotFoundException(id)__            }_            retentionLeases = new RetentionLeases(_                    operationPrimaryTerm,_                    retentionLeases.version() + 1,_                    retentionLeases.leases().stream().filter(lease -> lease.id().equals(id) == false).collect(Collectors.toList()))__            currentRetentionLeases = retentionLeases__        }_        onSyncRetentionLeases.accept(currentRetentionLeases, listener)__    };removes,an,existing,retention,lease,param,id,the,identifier,of,the,retention,lease,param,listener,the,callback,when,the,retention,lease,is,successfully,removed,and,synced,to,replicas;public,void,remove,retention,lease,final,string,id,final,action,listener,replication,response,listener,objects,require,non,null,listener,final,retention,leases,current,retention,leases,synchronized,this,assert,primary,mode,if,retention,leases,contains,id,false,throw,new,retention,lease,not,found,exception,id,retention,leases,new,retention,leases,operation,primary,term,retention,leases,version,1,retention,leases,leases,stream,filter,lease,lease,id,equals,id,false,collect,collectors,to,list,current,retention,leases,retention,leases,on,sync,retention,leases,accept,current,retention,leases,listener
ReplicationTracker -> public void removeRetentionLease(final String id, final ActionListener<ReplicationResponse> listener);1550526771;Removes an existing retention lease.__@param id       the identifier of the retention lease_@param listener the callback when the retention lease is successfully removed and synced to replicas;public void removeRetentionLease(final String id, final ActionListener<ReplicationResponse> listener) {_        Objects.requireNonNull(listener)__        final RetentionLeases currentRetentionLeases__        synchronized (this) {_            assert primaryMode__            if (retentionLeases.contains(id) == false) {_                throw new RetentionLeaseNotFoundException(id)__            }_            retentionLeases = new RetentionLeases(_                    operationPrimaryTerm,_                    retentionLeases.version() + 1,_                    retentionLeases.leases().stream().filter(lease -> lease.id().equals(id) == false).collect(Collectors.toList()))__            currentRetentionLeases = retentionLeases__        }_        onSyncRetentionLeases.accept(currentRetentionLeases, listener)__    };removes,an,existing,retention,lease,param,id,the,identifier,of,the,retention,lease,param,listener,the,callback,when,the,retention,lease,is,successfully,removed,and,synced,to,replicas;public,void,remove,retention,lease,final,string,id,final,action,listener,replication,response,listener,objects,require,non,null,listener,final,retention,leases,current,retention,leases,synchronized,this,assert,primary,mode,if,retention,leases,contains,id,false,throw,new,retention,lease,not,found,exception,id,retention,leases,new,retention,leases,operation,primary,term,retention,leases,version,1,retention,leases,leases,stream,filter,lease,lease,id,equals,id,false,collect,collectors,to,list,current,retention,leases,retention,leases,on,sync,retention,leases,accept,current,retention,leases,listener
ReplicationTracker -> public synchronized long getGlobalCheckpoint();1524684173;Returns the global checkpoint for the shard.__@return the global checkpoint;public synchronized long getGlobalCheckpoint() {_        final CheckpointState cps = checkpoints.get(shardAllocationId)__        assert cps != null__        return cps.globalCheckpoint__    };returns,the,global,checkpoint,for,the,shard,return,the,global,checkpoint;public,synchronized,long,get,global,checkpoint,final,checkpoint,state,cps,checkpoints,get,shard,allocation,id,assert,cps,null,return,cps,global,checkpoint
ReplicationTracker -> public synchronized long getGlobalCheckpoint();1525334055;Returns the global checkpoint for the shard.__@return the global checkpoint;public synchronized long getGlobalCheckpoint() {_        final CheckpointState cps = checkpoints.get(shardAllocationId)__        assert cps != null__        return cps.globalCheckpoint__    };returns,the,global,checkpoint,for,the,shard,return,the,global,checkpoint;public,synchronized,long,get,global,checkpoint,final,checkpoint,state,cps,checkpoints,get,shard,allocation,id,assert,cps,null,return,cps,global,checkpoint
ReplicationTracker -> public synchronized long getGlobalCheckpoint();1533295538;Returns the global checkpoint for the shard.__@return the global checkpoint;public synchronized long getGlobalCheckpoint() {_        final CheckpointState cps = checkpoints.get(shardAllocationId)__        assert cps != null__        return cps.globalCheckpoint__    };returns,the,global,checkpoint,for,the,shard,return,the,global,checkpoint;public,synchronized,long,get,global,checkpoint,final,checkpoint,state,cps,checkpoints,get,shard,allocation,id,assert,cps,null,return,cps,global,checkpoint
ReplicationTracker -> public synchronized long getGlobalCheckpoint();1533738061;Returns the global checkpoint for the shard.__@return the global checkpoint;public synchronized long getGlobalCheckpoint() {_        final CheckpointState cps = checkpoints.get(shardAllocationId)__        assert cps != null__        return cps.globalCheckpoint__    };returns,the,global,checkpoint,for,the,shard,return,the,global,checkpoint;public,synchronized,long,get,global,checkpoint,final,checkpoint,state,cps,checkpoints,get,shard,allocation,id,assert,cps,null,return,cps,global,checkpoint
ReplicationTracker -> public synchronized long getGlobalCheckpoint();1546875837;Returns the global checkpoint for the shard.__@return the global checkpoint;public synchronized long getGlobalCheckpoint() {_        final CheckpointState cps = checkpoints.get(shardAllocationId)__        assert cps != null__        return cps.globalCheckpoint__    };returns,the,global,checkpoint,for,the,shard,return,the,global,checkpoint;public,synchronized,long,get,global,checkpoint,final,checkpoint,state,cps,checkpoints,get,shard,allocation,id,assert,cps,null,return,cps,global,checkpoint
ReplicationTracker -> public synchronized long getGlobalCheckpoint();1546927432;Returns the global checkpoint for the shard.__@return the global checkpoint;public synchronized long getGlobalCheckpoint() {_        final CheckpointState cps = checkpoints.get(shardAllocationId)__        assert cps != null__        return cps.globalCheckpoint__    };returns,the,global,checkpoint,for,the,shard,return,the,global,checkpoint;public,synchronized,long,get,global,checkpoint,final,checkpoint,state,cps,checkpoints,get,shard,allocation,id,assert,cps,null,return,cps,global,checkpoint
ReplicationTracker -> public synchronized long getGlobalCheckpoint();1547332999;Returns the global checkpoint for the shard.__@return the global checkpoint;public synchronized long getGlobalCheckpoint() {_        final CheckpointState cps = checkpoints.get(shardAllocationId)__        assert cps != null__        return cps.globalCheckpoint__    };returns,the,global,checkpoint,for,the,shard,return,the,global,checkpoint;public,synchronized,long,get,global,checkpoint,final,checkpoint,state,cps,checkpoints,get,shard,allocation,id,assert,cps,null,return,cps,global,checkpoint
ReplicationTracker -> public synchronized long getGlobalCheckpoint();1548593396;Returns the global checkpoint for the shard.__@return the global checkpoint;public synchronized long getGlobalCheckpoint() {_        final CheckpointState cps = checkpoints.get(shardAllocationId)__        assert cps != null__        return cps.globalCheckpoint__    };returns,the,global,checkpoint,for,the,shard,return,the,global,checkpoint;public,synchronized,long,get,global,checkpoint,final,checkpoint,state,cps,checkpoints,get,shard,allocation,id,assert,cps,null,return,cps,global,checkpoint
ReplicationTracker -> public synchronized long getGlobalCheckpoint();1548594827;Returns the global checkpoint for the shard.__@return the global checkpoint;public synchronized long getGlobalCheckpoint() {_        final CheckpointState cps = checkpoints.get(shardAllocationId)__        assert cps != null__        return cps.globalCheckpoint__    };returns,the,global,checkpoint,for,the,shard,return,the,global,checkpoint;public,synchronized,long,get,global,checkpoint,final,checkpoint,state,cps,checkpoints,get,shard,allocation,id,assert,cps,null,return,cps,global,checkpoint
ReplicationTracker -> public synchronized long getGlobalCheckpoint();1548677511;Returns the global checkpoint for the shard.__@return the global checkpoint;public synchronized long getGlobalCheckpoint() {_        final CheckpointState cps = checkpoints.get(shardAllocationId)__        assert cps != null__        return cps.globalCheckpoint__    };returns,the,global,checkpoint,for,the,shard,return,the,global,checkpoint;public,synchronized,long,get,global,checkpoint,final,checkpoint,state,cps,checkpoints,get,shard,allocation,id,assert,cps,null,return,cps,global,checkpoint
ReplicationTracker -> public synchronized long getGlobalCheckpoint();1548944389;Returns the global checkpoint for the shard.__@return the global checkpoint;public synchronized long getGlobalCheckpoint() {_        final CheckpointState cps = checkpoints.get(shardAllocationId)__        assert cps != null__        return cps.globalCheckpoint__    };returns,the,global,checkpoint,for,the,shard,return,the,global,checkpoint;public,synchronized,long,get,global,checkpoint,final,checkpoint,state,cps,checkpoints,get,shard,allocation,id,assert,cps,null,return,cps,global,checkpoint
ReplicationTracker -> public synchronized long getGlobalCheckpoint();1549059559;Returns the global checkpoint for the shard.__@return the global checkpoint;public synchronized long getGlobalCheckpoint() {_        final CheckpointState cps = checkpoints.get(shardAllocationId)__        assert cps != null__        return cps.globalCheckpoint__    };returns,the,global,checkpoint,for,the,shard,return,the,global,checkpoint;public,synchronized,long,get,global,checkpoint,final,checkpoint,state,cps,checkpoints,get,shard,allocation,id,assert,cps,null,return,cps,global,checkpoint
ReplicationTracker -> public synchronized long getGlobalCheckpoint();1549294529;Returns the global checkpoint for the shard.__@return the global checkpoint;public synchronized long getGlobalCheckpoint() {_        final CheckpointState cps = checkpoints.get(shardAllocationId)__        assert cps != null__        return cps.globalCheckpoint__    };returns,the,global,checkpoint,for,the,shard,return,the,global,checkpoint;public,synchronized,long,get,global,checkpoint,final,checkpoint,state,cps,checkpoints,get,shard,allocation,id,assert,cps,null,return,cps,global,checkpoint
ReplicationTracker -> public synchronized long getGlobalCheckpoint();1549395737;Returns the global checkpoint for the shard.__@return the global checkpoint;public synchronized long getGlobalCheckpoint() {_        final CheckpointState cps = checkpoints.get(shardAllocationId)__        assert cps != null__        return cps.globalCheckpoint__    };returns,the,global,checkpoint,for,the,shard,return,the,global,checkpoint;public,synchronized,long,get,global,checkpoint,final,checkpoint,state,cps,checkpoints,get,shard,allocation,id,assert,cps,null,return,cps,global,checkpoint
ReplicationTracker -> public synchronized long getGlobalCheckpoint();1549937843;Returns the global checkpoint for the shard.__@return the global checkpoint;public synchronized long getGlobalCheckpoint() {_        final CheckpointState cps = checkpoints.get(shardAllocationId)__        assert cps != null__        return cps.globalCheckpoint__    };returns,the,global,checkpoint,for,the,shard,return,the,global,checkpoint;public,synchronized,long,get,global,checkpoint,final,checkpoint,state,cps,checkpoints,get,shard,allocation,id,assert,cps,null,return,cps,global,checkpoint
ReplicationTracker -> public synchronized long getGlobalCheckpoint();1549949489;Returns the global checkpoint for the shard.__@return the global checkpoint;public synchronized long getGlobalCheckpoint() {_        final CheckpointState cps = checkpoints.get(shardAllocationId)__        assert cps != null__        return cps.globalCheckpoint__    };returns,the,global,checkpoint,for,the,shard,return,the,global,checkpoint;public,synchronized,long,get,global,checkpoint,final,checkpoint,state,cps,checkpoints,get,shard,allocation,id,assert,cps,null,return,cps,global,checkpoint
ReplicationTracker -> public synchronized long getGlobalCheckpoint();1550526771;Returns the global checkpoint for the shard.__@return the global checkpoint;public synchronized long getGlobalCheckpoint() {_        final CheckpointState cps = checkpoints.get(shardAllocationId)__        assert cps != null__        return cps.globalCheckpoint__    };returns,the,global,checkpoint,for,the,shard,return,the,global,checkpoint;public,synchronized,long,get,global,checkpoint,final,checkpoint,state,cps,checkpoints,get,shard,allocation,id,assert,cps,null,return,cps,global,checkpoint
ReplicationTracker -> public synchronized void abortRelocationHandoff();1524684173;Fails a relocation handoff attempt.;public synchronized void abortRelocationHandoff() {_        assert invariant()__        assert primaryMode__        assert handoffInProgress__        handoffInProgress = false__        assert invariant()__    };fails,a,relocation,handoff,attempt;public,synchronized,void,abort,relocation,handoff,assert,invariant,assert,primary,mode,assert,handoff,in,progress,handoff,in,progress,false,assert,invariant
ReplicationTracker -> public synchronized void abortRelocationHandoff();1525334055;Fails a relocation handoff attempt.;public synchronized void abortRelocationHandoff() {_        assert invariant()__        assert primaryMode__        assert handoffInProgress__        handoffInProgress = false__        assert invariant()__    };fails,a,relocation,handoff,attempt;public,synchronized,void,abort,relocation,handoff,assert,invariant,assert,primary,mode,assert,handoff,in,progress,handoff,in,progress,false,assert,invariant
ReplicationTracker -> public synchronized void abortRelocationHandoff();1533295538;Fails a relocation handoff attempt.;public synchronized void abortRelocationHandoff() {_        assert invariant()__        assert primaryMode__        assert handoffInProgress__        handoffInProgress = false__        assert invariant()__    };fails,a,relocation,handoff,attempt;public,synchronized,void,abort,relocation,handoff,assert,invariant,assert,primary,mode,assert,handoff,in,progress,handoff,in,progress,false,assert,invariant
ReplicationTracker -> public synchronized void abortRelocationHandoff();1533738061;Fails a relocation handoff attempt.;public synchronized void abortRelocationHandoff() {_        assert invariant()__        assert primaryMode__        assert handoffInProgress__        handoffInProgress = false__        assert invariant()__    };fails,a,relocation,handoff,attempt;public,synchronized,void,abort,relocation,handoff,assert,invariant,assert,primary,mode,assert,handoff,in,progress,handoff,in,progress,false,assert,invariant
ReplicationTracker -> public synchronized void abortRelocationHandoff();1546875837;Fails a relocation handoff attempt.;public synchronized void abortRelocationHandoff() {_        assert invariant()__        assert primaryMode__        assert handoffInProgress__        handoffInProgress = false__        assert invariant()__    };fails,a,relocation,handoff,attempt;public,synchronized,void,abort,relocation,handoff,assert,invariant,assert,primary,mode,assert,handoff,in,progress,handoff,in,progress,false,assert,invariant
ReplicationTracker -> public synchronized void abortRelocationHandoff();1546927432;Fails a relocation handoff attempt.;public synchronized void abortRelocationHandoff() {_        assert invariant()__        assert primaryMode__        assert handoffInProgress__        handoffInProgress = false__        assert invariant()__    };fails,a,relocation,handoff,attempt;public,synchronized,void,abort,relocation,handoff,assert,invariant,assert,primary,mode,assert,handoff,in,progress,handoff,in,progress,false,assert,invariant
ReplicationTracker -> public synchronized void abortRelocationHandoff();1547332999;Fails a relocation handoff attempt.;public synchronized void abortRelocationHandoff() {_        assert invariant()__        assert primaryMode__        assert handoffInProgress__        handoffInProgress = false__        assert invariant()__    };fails,a,relocation,handoff,attempt;public,synchronized,void,abort,relocation,handoff,assert,invariant,assert,primary,mode,assert,handoff,in,progress,handoff,in,progress,false,assert,invariant
ReplicationTracker -> public synchronized void abortRelocationHandoff();1548593396;Fails a relocation handoff attempt.;public synchronized void abortRelocationHandoff() {_        assert invariant()__        assert primaryMode__        assert handoffInProgress__        handoffInProgress = false__        assert invariant()__    };fails,a,relocation,handoff,attempt;public,synchronized,void,abort,relocation,handoff,assert,invariant,assert,primary,mode,assert,handoff,in,progress,handoff,in,progress,false,assert,invariant
ReplicationTracker -> public synchronized void abortRelocationHandoff();1548594827;Fails a relocation handoff attempt.;public synchronized void abortRelocationHandoff() {_        assert invariant()__        assert primaryMode__        assert handoffInProgress__        handoffInProgress = false__        assert invariant()__    };fails,a,relocation,handoff,attempt;public,synchronized,void,abort,relocation,handoff,assert,invariant,assert,primary,mode,assert,handoff,in,progress,handoff,in,progress,false,assert,invariant
ReplicationTracker -> public synchronized void abortRelocationHandoff();1548677511;Fails a relocation handoff attempt.;public synchronized void abortRelocationHandoff() {_        assert invariant()__        assert primaryMode__        assert handoffInProgress__        handoffInProgress = false__        assert invariant()__    };fails,a,relocation,handoff,attempt;public,synchronized,void,abort,relocation,handoff,assert,invariant,assert,primary,mode,assert,handoff,in,progress,handoff,in,progress,false,assert,invariant
ReplicationTracker -> public synchronized void abortRelocationHandoff();1548944389;Fails a relocation handoff attempt.;public synchronized void abortRelocationHandoff() {_        assert invariant()__        assert primaryMode__        assert handoffInProgress__        handoffInProgress = false__        assert invariant()__    };fails,a,relocation,handoff,attempt;public,synchronized,void,abort,relocation,handoff,assert,invariant,assert,primary,mode,assert,handoff,in,progress,handoff,in,progress,false,assert,invariant
ReplicationTracker -> public synchronized void abortRelocationHandoff();1549059559;Fails a relocation handoff attempt.;public synchronized void abortRelocationHandoff() {_        assert invariant()__        assert primaryMode__        assert handoffInProgress__        handoffInProgress = false__        assert invariant()__    };fails,a,relocation,handoff,attempt;public,synchronized,void,abort,relocation,handoff,assert,invariant,assert,primary,mode,assert,handoff,in,progress,handoff,in,progress,false,assert,invariant
ReplicationTracker -> public synchronized void abortRelocationHandoff();1549294529;Fails a relocation handoff attempt.;public synchronized void abortRelocationHandoff() {_        assert invariant()__        assert primaryMode__        assert handoffInProgress__        handoffInProgress = false__        assert invariant()__    };fails,a,relocation,handoff,attempt;public,synchronized,void,abort,relocation,handoff,assert,invariant,assert,primary,mode,assert,handoff,in,progress,handoff,in,progress,false,assert,invariant
ReplicationTracker -> public synchronized void abortRelocationHandoff();1549395737;Fails a relocation handoff attempt.;public synchronized void abortRelocationHandoff() {_        assert invariant()__        assert primaryMode__        assert handoffInProgress__        handoffInProgress = false__        assert invariant()__    };fails,a,relocation,handoff,attempt;public,synchronized,void,abort,relocation,handoff,assert,invariant,assert,primary,mode,assert,handoff,in,progress,handoff,in,progress,false,assert,invariant
ReplicationTracker -> public synchronized void abortRelocationHandoff();1549937843;Fails a relocation handoff attempt.;public synchronized void abortRelocationHandoff() {_        assert invariant()__        assert primaryMode__        assert handoffInProgress__        handoffInProgress = false__        assert invariant()__    };fails,a,relocation,handoff,attempt;public,synchronized,void,abort,relocation,handoff,assert,invariant,assert,primary,mode,assert,handoff,in,progress,handoff,in,progress,false,assert,invariant
ReplicationTracker -> public synchronized void abortRelocationHandoff();1549949489;Fails a relocation handoff attempt.;public synchronized void abortRelocationHandoff() {_        assert invariant()__        assert primaryMode__        assert handoffInProgress__        handoffInProgress = false__        assert invariant()__    };fails,a,relocation,handoff,attempt;public,synchronized,void,abort,relocation,handoff,assert,invariant,assert,primary,mode,assert,handoff,in,progress,handoff,in,progress,false,assert,invariant
ReplicationTracker -> public synchronized void abortRelocationHandoff();1550526771;Fails a relocation handoff attempt.;public synchronized void abortRelocationHandoff() {_        assert invariant()__        assert primaryMode__        assert handoffInProgress__        handoffInProgress = false__        assert invariant()__    };fails,a,relocation,handoff,attempt;public,synchronized,void,abort,relocation,handoff,assert,invariant,assert,primary,mode,assert,handoff,in,progress,handoff,in,progress,false,assert,invariant
ReplicationTracker -> public synchronized void updateLocalCheckpoint(final String allocationId, final long localCheckpoint);1524684173;Notifies the service to update the local checkpoint for the shard with the provided allocation ID. If the checkpoint is lower than_the currently known one, this is a no-op. If the allocation ID is not tracked, it is ignored.__@param allocationId    the allocation ID of the shard to update the local checkpoint for_@param localCheckpoint the local checkpoint for the shard;public synchronized void updateLocalCheckpoint(final String allocationId, final long localCheckpoint) {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        CheckpointState cps = checkpoints.get(allocationId)__        if (cps == null) {_            _            return__        }_        boolean increasedLocalCheckpoint = updateLocalCheckpoint(allocationId, cps, localCheckpoint)__        boolean pending = pendingInSync.contains(allocationId)__        if (pending && cps.localCheckpoint >= getGlobalCheckpoint()) {_            pendingInSync.remove(allocationId)__            pending = false__            cps.inSync = true__            replicationGroup = calculateReplicationGroup()__            logger.trace("marked [{}] as in-sync", allocationId)__            notifyAllWaiters()__        }_        if (increasedLocalCheckpoint && pending == false) {_            updateGlobalCheckpointOnPrimary()__        }_        assert invariant()__    };notifies,the,service,to,update,the,local,checkpoint,for,the,shard,with,the,provided,allocation,id,if,the,checkpoint,is,lower,than,the,currently,known,one,this,is,a,no,op,if,the,allocation,id,is,not,tracked,it,is,ignored,param,allocation,id,the,allocation,id,of,the,shard,to,update,the,local,checkpoint,for,param,local,checkpoint,the,local,checkpoint,for,the,shard;public,synchronized,void,update,local,checkpoint,final,string,allocation,id,final,long,local,checkpoint,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,checkpoint,state,cps,checkpoints,get,allocation,id,if,cps,null,return,boolean,increased,local,checkpoint,update,local,checkpoint,allocation,id,cps,local,checkpoint,boolean,pending,pending,in,sync,contains,allocation,id,if,pending,cps,local,checkpoint,get,global,checkpoint,pending,in,sync,remove,allocation,id,pending,false,cps,in,sync,true,replication,group,calculate,replication,group,logger,trace,marked,as,in,sync,allocation,id,notify,all,waiters,if,increased,local,checkpoint,pending,false,update,global,checkpoint,on,primary,assert,invariant
ReplicationTracker -> public synchronized void updateLocalCheckpoint(final String allocationId, final long localCheckpoint);1525334055;Notifies the service to update the local checkpoint for the shard with the provided allocation ID. If the checkpoint is lower than_the currently known one, this is a no-op. If the allocation ID is not tracked, it is ignored.__@param allocationId    the allocation ID of the shard to update the local checkpoint for_@param localCheckpoint the local checkpoint for the shard;public synchronized void updateLocalCheckpoint(final String allocationId, final long localCheckpoint) {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        CheckpointState cps = checkpoints.get(allocationId)__        if (cps == null) {_            _            return__        }_        boolean increasedLocalCheckpoint = updateLocalCheckpoint(allocationId, cps, localCheckpoint)__        boolean pending = pendingInSync.contains(allocationId)__        if (pending && cps.localCheckpoint >= getGlobalCheckpoint()) {_            pendingInSync.remove(allocationId)__            pending = false__            cps.inSync = true__            replicationGroup = calculateReplicationGroup()__            logger.trace("marked [{}] as in-sync", allocationId)__            notifyAllWaiters()__        }_        if (increasedLocalCheckpoint && pending == false) {_            updateGlobalCheckpointOnPrimary()__        }_        assert invariant()__    };notifies,the,service,to,update,the,local,checkpoint,for,the,shard,with,the,provided,allocation,id,if,the,checkpoint,is,lower,than,the,currently,known,one,this,is,a,no,op,if,the,allocation,id,is,not,tracked,it,is,ignored,param,allocation,id,the,allocation,id,of,the,shard,to,update,the,local,checkpoint,for,param,local,checkpoint,the,local,checkpoint,for,the,shard;public,synchronized,void,update,local,checkpoint,final,string,allocation,id,final,long,local,checkpoint,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,checkpoint,state,cps,checkpoints,get,allocation,id,if,cps,null,return,boolean,increased,local,checkpoint,update,local,checkpoint,allocation,id,cps,local,checkpoint,boolean,pending,pending,in,sync,contains,allocation,id,if,pending,cps,local,checkpoint,get,global,checkpoint,pending,in,sync,remove,allocation,id,pending,false,cps,in,sync,true,replication,group,calculate,replication,group,logger,trace,marked,as,in,sync,allocation,id,notify,all,waiters,if,increased,local,checkpoint,pending,false,update,global,checkpoint,on,primary,assert,invariant
ReplicationTracker -> public synchronized void updateLocalCheckpoint(final String allocationId, final long localCheckpoint);1533295538;Notifies the service to update the local checkpoint for the shard with the provided allocation ID. If the checkpoint is lower than_the currently known one, this is a no-op. If the allocation ID is not tracked, it is ignored.__@param allocationId    the allocation ID of the shard to update the local checkpoint for_@param localCheckpoint the local checkpoint for the shard;public synchronized void updateLocalCheckpoint(final String allocationId, final long localCheckpoint) {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        CheckpointState cps = checkpoints.get(allocationId)__        if (cps == null) {_            _            return__        }_        boolean increasedLocalCheckpoint = updateLocalCheckpoint(allocationId, cps, localCheckpoint)__        boolean pending = pendingInSync.contains(allocationId)__        if (pending && cps.localCheckpoint >= getGlobalCheckpoint()) {_            pendingInSync.remove(allocationId)__            pending = false__            cps.inSync = true__            replicationGroup = calculateReplicationGroup()__            logger.trace("marked [{}] as in-sync", allocationId)__            notifyAllWaiters()__        }_        if (increasedLocalCheckpoint && pending == false) {_            updateGlobalCheckpointOnPrimary()__        }_        assert invariant()__    };notifies,the,service,to,update,the,local,checkpoint,for,the,shard,with,the,provided,allocation,id,if,the,checkpoint,is,lower,than,the,currently,known,one,this,is,a,no,op,if,the,allocation,id,is,not,tracked,it,is,ignored,param,allocation,id,the,allocation,id,of,the,shard,to,update,the,local,checkpoint,for,param,local,checkpoint,the,local,checkpoint,for,the,shard;public,synchronized,void,update,local,checkpoint,final,string,allocation,id,final,long,local,checkpoint,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,checkpoint,state,cps,checkpoints,get,allocation,id,if,cps,null,return,boolean,increased,local,checkpoint,update,local,checkpoint,allocation,id,cps,local,checkpoint,boolean,pending,pending,in,sync,contains,allocation,id,if,pending,cps,local,checkpoint,get,global,checkpoint,pending,in,sync,remove,allocation,id,pending,false,cps,in,sync,true,replication,group,calculate,replication,group,logger,trace,marked,as,in,sync,allocation,id,notify,all,waiters,if,increased,local,checkpoint,pending,false,update,global,checkpoint,on,primary,assert,invariant
ReplicationTracker -> public synchronized void updateLocalCheckpoint(final String allocationId, final long localCheckpoint);1533738061;Notifies the service to update the local checkpoint for the shard with the provided allocation ID. If the checkpoint is lower than_the currently known one, this is a no-op. If the allocation ID is not tracked, it is ignored.__@param allocationId    the allocation ID of the shard to update the local checkpoint for_@param localCheckpoint the local checkpoint for the shard;public synchronized void updateLocalCheckpoint(final String allocationId, final long localCheckpoint) {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        CheckpointState cps = checkpoints.get(allocationId)__        if (cps == null) {_            _            return__        }_        boolean increasedLocalCheckpoint = updateLocalCheckpoint(allocationId, cps, localCheckpoint)__        boolean pending = pendingInSync.contains(allocationId)__        if (pending && cps.localCheckpoint >= getGlobalCheckpoint()) {_            pendingInSync.remove(allocationId)__            pending = false__            cps.inSync = true__            replicationGroup = calculateReplicationGroup()__            logger.trace("marked [{}] as in-sync", allocationId)__            notifyAllWaiters()__        }_        if (increasedLocalCheckpoint && pending == false) {_            updateGlobalCheckpointOnPrimary()__        }_        assert invariant()__    };notifies,the,service,to,update,the,local,checkpoint,for,the,shard,with,the,provided,allocation,id,if,the,checkpoint,is,lower,than,the,currently,known,one,this,is,a,no,op,if,the,allocation,id,is,not,tracked,it,is,ignored,param,allocation,id,the,allocation,id,of,the,shard,to,update,the,local,checkpoint,for,param,local,checkpoint,the,local,checkpoint,for,the,shard;public,synchronized,void,update,local,checkpoint,final,string,allocation,id,final,long,local,checkpoint,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,checkpoint,state,cps,checkpoints,get,allocation,id,if,cps,null,return,boolean,increased,local,checkpoint,update,local,checkpoint,allocation,id,cps,local,checkpoint,boolean,pending,pending,in,sync,contains,allocation,id,if,pending,cps,local,checkpoint,get,global,checkpoint,pending,in,sync,remove,allocation,id,pending,false,cps,in,sync,true,replication,group,calculate,replication,group,logger,trace,marked,as,in,sync,allocation,id,notify,all,waiters,if,increased,local,checkpoint,pending,false,update,global,checkpoint,on,primary,assert,invariant
ReplicationTracker -> public synchronized void updateLocalCheckpoint(final String allocationId, final long localCheckpoint);1546875837;Notifies the service to update the local checkpoint for the shard with the provided allocation ID. If the checkpoint is lower than_the currently known one, this is a no-op. If the allocation ID is not tracked, it is ignored.__@param allocationId    the allocation ID of the shard to update the local checkpoint for_@param localCheckpoint the local checkpoint for the shard;public synchronized void updateLocalCheckpoint(final String allocationId, final long localCheckpoint) {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        CheckpointState cps = checkpoints.get(allocationId)__        if (cps == null) {_            _            return__        }_        boolean increasedLocalCheckpoint = updateLocalCheckpoint(allocationId, cps, localCheckpoint)__        boolean pending = pendingInSync.contains(allocationId)__        if (pending && cps.localCheckpoint >= getGlobalCheckpoint()) {_            pendingInSync.remove(allocationId)__            pending = false__            cps.inSync = true__            replicationGroup = calculateReplicationGroup()__            logger.trace("marked [{}] as in-sync", allocationId)__            notifyAllWaiters()__        }_        if (increasedLocalCheckpoint && pending == false) {_            updateGlobalCheckpointOnPrimary()__        }_        assert invariant()__    };notifies,the,service,to,update,the,local,checkpoint,for,the,shard,with,the,provided,allocation,id,if,the,checkpoint,is,lower,than,the,currently,known,one,this,is,a,no,op,if,the,allocation,id,is,not,tracked,it,is,ignored,param,allocation,id,the,allocation,id,of,the,shard,to,update,the,local,checkpoint,for,param,local,checkpoint,the,local,checkpoint,for,the,shard;public,synchronized,void,update,local,checkpoint,final,string,allocation,id,final,long,local,checkpoint,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,checkpoint,state,cps,checkpoints,get,allocation,id,if,cps,null,return,boolean,increased,local,checkpoint,update,local,checkpoint,allocation,id,cps,local,checkpoint,boolean,pending,pending,in,sync,contains,allocation,id,if,pending,cps,local,checkpoint,get,global,checkpoint,pending,in,sync,remove,allocation,id,pending,false,cps,in,sync,true,replication,group,calculate,replication,group,logger,trace,marked,as,in,sync,allocation,id,notify,all,waiters,if,increased,local,checkpoint,pending,false,update,global,checkpoint,on,primary,assert,invariant
ReplicationTracker -> public synchronized void updateLocalCheckpoint(final String allocationId, final long localCheckpoint);1546927432;Notifies the service to update the local checkpoint for the shard with the provided allocation ID. If the checkpoint is lower than_the currently known one, this is a no-op. If the allocation ID is not tracked, it is ignored.__@param allocationId    the allocation ID of the shard to update the local checkpoint for_@param localCheckpoint the local checkpoint for the shard;public synchronized void updateLocalCheckpoint(final String allocationId, final long localCheckpoint) {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        CheckpointState cps = checkpoints.get(allocationId)__        if (cps == null) {_            _            return__        }_        boolean increasedLocalCheckpoint = updateLocalCheckpoint(allocationId, cps, localCheckpoint)__        boolean pending = pendingInSync.contains(allocationId)__        if (pending && cps.localCheckpoint >= getGlobalCheckpoint()) {_            pendingInSync.remove(allocationId)__            pending = false__            cps.inSync = true__            replicationGroup = calculateReplicationGroup()__            logger.trace("marked [{}] as in-sync", allocationId)__            notifyAllWaiters()__        }_        if (increasedLocalCheckpoint && pending == false) {_            updateGlobalCheckpointOnPrimary()__        }_        assert invariant()__    };notifies,the,service,to,update,the,local,checkpoint,for,the,shard,with,the,provided,allocation,id,if,the,checkpoint,is,lower,than,the,currently,known,one,this,is,a,no,op,if,the,allocation,id,is,not,tracked,it,is,ignored,param,allocation,id,the,allocation,id,of,the,shard,to,update,the,local,checkpoint,for,param,local,checkpoint,the,local,checkpoint,for,the,shard;public,synchronized,void,update,local,checkpoint,final,string,allocation,id,final,long,local,checkpoint,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,checkpoint,state,cps,checkpoints,get,allocation,id,if,cps,null,return,boolean,increased,local,checkpoint,update,local,checkpoint,allocation,id,cps,local,checkpoint,boolean,pending,pending,in,sync,contains,allocation,id,if,pending,cps,local,checkpoint,get,global,checkpoint,pending,in,sync,remove,allocation,id,pending,false,cps,in,sync,true,replication,group,calculate,replication,group,logger,trace,marked,as,in,sync,allocation,id,notify,all,waiters,if,increased,local,checkpoint,pending,false,update,global,checkpoint,on,primary,assert,invariant
ReplicationTracker -> public synchronized void updateLocalCheckpoint(final String allocationId, final long localCheckpoint);1547332999;Notifies the service to update the local checkpoint for the shard with the provided allocation ID. If the checkpoint is lower than_the currently known one, this is a no-op. If the allocation ID is not tracked, it is ignored.__@param allocationId    the allocation ID of the shard to update the local checkpoint for_@param localCheckpoint the local checkpoint for the shard;public synchronized void updateLocalCheckpoint(final String allocationId, final long localCheckpoint) {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        CheckpointState cps = checkpoints.get(allocationId)__        if (cps == null) {_            _            return__        }_        boolean increasedLocalCheckpoint = updateLocalCheckpoint(allocationId, cps, localCheckpoint)__        boolean pending = pendingInSync.contains(allocationId)__        if (pending && cps.localCheckpoint >= getGlobalCheckpoint()) {_            pendingInSync.remove(allocationId)__            pending = false__            cps.inSync = true__            replicationGroup = calculateReplicationGroup()__            logger.trace("marked [{}] as in-sync", allocationId)__            notifyAllWaiters()__        }_        if (increasedLocalCheckpoint && pending == false) {_            updateGlobalCheckpointOnPrimary()__        }_        assert invariant()__    };notifies,the,service,to,update,the,local,checkpoint,for,the,shard,with,the,provided,allocation,id,if,the,checkpoint,is,lower,than,the,currently,known,one,this,is,a,no,op,if,the,allocation,id,is,not,tracked,it,is,ignored,param,allocation,id,the,allocation,id,of,the,shard,to,update,the,local,checkpoint,for,param,local,checkpoint,the,local,checkpoint,for,the,shard;public,synchronized,void,update,local,checkpoint,final,string,allocation,id,final,long,local,checkpoint,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,checkpoint,state,cps,checkpoints,get,allocation,id,if,cps,null,return,boolean,increased,local,checkpoint,update,local,checkpoint,allocation,id,cps,local,checkpoint,boolean,pending,pending,in,sync,contains,allocation,id,if,pending,cps,local,checkpoint,get,global,checkpoint,pending,in,sync,remove,allocation,id,pending,false,cps,in,sync,true,replication,group,calculate,replication,group,logger,trace,marked,as,in,sync,allocation,id,notify,all,waiters,if,increased,local,checkpoint,pending,false,update,global,checkpoint,on,primary,assert,invariant
ReplicationTracker -> public synchronized void updateLocalCheckpoint(final String allocationId, final long localCheckpoint);1548593396;Notifies the service to update the local checkpoint for the shard with the provided allocation ID. If the checkpoint is lower than_the currently known one, this is a no-op. If the allocation ID is not tracked, it is ignored.__@param allocationId    the allocation ID of the shard to update the local checkpoint for_@param localCheckpoint the local checkpoint for the shard;public synchronized void updateLocalCheckpoint(final String allocationId, final long localCheckpoint) {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        CheckpointState cps = checkpoints.get(allocationId)__        if (cps == null) {_            _            return__        }_        boolean increasedLocalCheckpoint = updateLocalCheckpoint(allocationId, cps, localCheckpoint)__        boolean pending = pendingInSync.contains(allocationId)__        if (pending && cps.localCheckpoint >= getGlobalCheckpoint()) {_            pendingInSync.remove(allocationId)__            pending = false__            cps.inSync = true__            replicationGroup = calculateReplicationGroup()__            logger.trace("marked [{}] as in-sync", allocationId)__            notifyAllWaiters()__        }_        if (increasedLocalCheckpoint && pending == false) {_            updateGlobalCheckpointOnPrimary()__        }_        assert invariant()__    };notifies,the,service,to,update,the,local,checkpoint,for,the,shard,with,the,provided,allocation,id,if,the,checkpoint,is,lower,than,the,currently,known,one,this,is,a,no,op,if,the,allocation,id,is,not,tracked,it,is,ignored,param,allocation,id,the,allocation,id,of,the,shard,to,update,the,local,checkpoint,for,param,local,checkpoint,the,local,checkpoint,for,the,shard;public,synchronized,void,update,local,checkpoint,final,string,allocation,id,final,long,local,checkpoint,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,checkpoint,state,cps,checkpoints,get,allocation,id,if,cps,null,return,boolean,increased,local,checkpoint,update,local,checkpoint,allocation,id,cps,local,checkpoint,boolean,pending,pending,in,sync,contains,allocation,id,if,pending,cps,local,checkpoint,get,global,checkpoint,pending,in,sync,remove,allocation,id,pending,false,cps,in,sync,true,replication,group,calculate,replication,group,logger,trace,marked,as,in,sync,allocation,id,notify,all,waiters,if,increased,local,checkpoint,pending,false,update,global,checkpoint,on,primary,assert,invariant
ReplicationTracker -> public synchronized void updateLocalCheckpoint(final String allocationId, final long localCheckpoint);1548594827;Notifies the service to update the local checkpoint for the shard with the provided allocation ID. If the checkpoint is lower than_the currently known one, this is a no-op. If the allocation ID is not tracked, it is ignored.__@param allocationId    the allocation ID of the shard to update the local checkpoint for_@param localCheckpoint the local checkpoint for the shard;public synchronized void updateLocalCheckpoint(final String allocationId, final long localCheckpoint) {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        CheckpointState cps = checkpoints.get(allocationId)__        if (cps == null) {_            _            return__        }_        boolean increasedLocalCheckpoint = updateLocalCheckpoint(allocationId, cps, localCheckpoint)__        boolean pending = pendingInSync.contains(allocationId)__        if (pending && cps.localCheckpoint >= getGlobalCheckpoint()) {_            pendingInSync.remove(allocationId)__            pending = false__            cps.inSync = true__            replicationGroup = calculateReplicationGroup()__            logger.trace("marked [{}] as in-sync", allocationId)__            notifyAllWaiters()__        }_        if (increasedLocalCheckpoint && pending == false) {_            updateGlobalCheckpointOnPrimary()__        }_        assert invariant()__    };notifies,the,service,to,update,the,local,checkpoint,for,the,shard,with,the,provided,allocation,id,if,the,checkpoint,is,lower,than,the,currently,known,one,this,is,a,no,op,if,the,allocation,id,is,not,tracked,it,is,ignored,param,allocation,id,the,allocation,id,of,the,shard,to,update,the,local,checkpoint,for,param,local,checkpoint,the,local,checkpoint,for,the,shard;public,synchronized,void,update,local,checkpoint,final,string,allocation,id,final,long,local,checkpoint,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,checkpoint,state,cps,checkpoints,get,allocation,id,if,cps,null,return,boolean,increased,local,checkpoint,update,local,checkpoint,allocation,id,cps,local,checkpoint,boolean,pending,pending,in,sync,contains,allocation,id,if,pending,cps,local,checkpoint,get,global,checkpoint,pending,in,sync,remove,allocation,id,pending,false,cps,in,sync,true,replication,group,calculate,replication,group,logger,trace,marked,as,in,sync,allocation,id,notify,all,waiters,if,increased,local,checkpoint,pending,false,update,global,checkpoint,on,primary,assert,invariant
ReplicationTracker -> public synchronized void updateLocalCheckpoint(final String allocationId, final long localCheckpoint);1548677511;Notifies the service to update the local checkpoint for the shard with the provided allocation ID. If the checkpoint is lower than_the currently known one, this is a no-op. If the allocation ID is not tracked, it is ignored.__@param allocationId    the allocation ID of the shard to update the local checkpoint for_@param localCheckpoint the local checkpoint for the shard;public synchronized void updateLocalCheckpoint(final String allocationId, final long localCheckpoint) {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        CheckpointState cps = checkpoints.get(allocationId)__        if (cps == null) {_            _            return__        }_        boolean increasedLocalCheckpoint = updateLocalCheckpoint(allocationId, cps, localCheckpoint)__        boolean pending = pendingInSync.contains(allocationId)__        if (pending && cps.localCheckpoint >= getGlobalCheckpoint()) {_            pendingInSync.remove(allocationId)__            pending = false__            cps.inSync = true__            replicationGroup = calculateReplicationGroup()__            logger.trace("marked [{}] as in-sync", allocationId)__            notifyAllWaiters()__        }_        if (increasedLocalCheckpoint && pending == false) {_            updateGlobalCheckpointOnPrimary()__        }_        assert invariant()__    };notifies,the,service,to,update,the,local,checkpoint,for,the,shard,with,the,provided,allocation,id,if,the,checkpoint,is,lower,than,the,currently,known,one,this,is,a,no,op,if,the,allocation,id,is,not,tracked,it,is,ignored,param,allocation,id,the,allocation,id,of,the,shard,to,update,the,local,checkpoint,for,param,local,checkpoint,the,local,checkpoint,for,the,shard;public,synchronized,void,update,local,checkpoint,final,string,allocation,id,final,long,local,checkpoint,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,checkpoint,state,cps,checkpoints,get,allocation,id,if,cps,null,return,boolean,increased,local,checkpoint,update,local,checkpoint,allocation,id,cps,local,checkpoint,boolean,pending,pending,in,sync,contains,allocation,id,if,pending,cps,local,checkpoint,get,global,checkpoint,pending,in,sync,remove,allocation,id,pending,false,cps,in,sync,true,replication,group,calculate,replication,group,logger,trace,marked,as,in,sync,allocation,id,notify,all,waiters,if,increased,local,checkpoint,pending,false,update,global,checkpoint,on,primary,assert,invariant
ReplicationTracker -> public synchronized void updateLocalCheckpoint(final String allocationId, final long localCheckpoint);1548944389;Notifies the service to update the local checkpoint for the shard with the provided allocation ID. If the checkpoint is lower than_the currently known one, this is a no-op. If the allocation ID is not tracked, it is ignored.__@param allocationId    the allocation ID of the shard to update the local checkpoint for_@param localCheckpoint the local checkpoint for the shard;public synchronized void updateLocalCheckpoint(final String allocationId, final long localCheckpoint) {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        CheckpointState cps = checkpoints.get(allocationId)__        if (cps == null) {_            _            return__        }_        boolean increasedLocalCheckpoint = updateLocalCheckpoint(allocationId, cps, localCheckpoint)__        boolean pending = pendingInSync.contains(allocationId)__        if (pending && cps.localCheckpoint >= getGlobalCheckpoint()) {_            pendingInSync.remove(allocationId)__            pending = false__            cps.inSync = true__            replicationGroup = calculateReplicationGroup()__            logger.trace("marked [{}] as in-sync", allocationId)__            notifyAllWaiters()__        }_        if (increasedLocalCheckpoint && pending == false) {_            updateGlobalCheckpointOnPrimary()__        }_        assert invariant()__    };notifies,the,service,to,update,the,local,checkpoint,for,the,shard,with,the,provided,allocation,id,if,the,checkpoint,is,lower,than,the,currently,known,one,this,is,a,no,op,if,the,allocation,id,is,not,tracked,it,is,ignored,param,allocation,id,the,allocation,id,of,the,shard,to,update,the,local,checkpoint,for,param,local,checkpoint,the,local,checkpoint,for,the,shard;public,synchronized,void,update,local,checkpoint,final,string,allocation,id,final,long,local,checkpoint,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,checkpoint,state,cps,checkpoints,get,allocation,id,if,cps,null,return,boolean,increased,local,checkpoint,update,local,checkpoint,allocation,id,cps,local,checkpoint,boolean,pending,pending,in,sync,contains,allocation,id,if,pending,cps,local,checkpoint,get,global,checkpoint,pending,in,sync,remove,allocation,id,pending,false,cps,in,sync,true,replication,group,calculate,replication,group,logger,trace,marked,as,in,sync,allocation,id,notify,all,waiters,if,increased,local,checkpoint,pending,false,update,global,checkpoint,on,primary,assert,invariant
ReplicationTracker -> public synchronized void updateLocalCheckpoint(final String allocationId, final long localCheckpoint);1549059559;Notifies the service to update the local checkpoint for the shard with the provided allocation ID. If the checkpoint is lower than_the currently known one, this is a no-op. If the allocation ID is not tracked, it is ignored.__@param allocationId    the allocation ID of the shard to update the local checkpoint for_@param localCheckpoint the local checkpoint for the shard;public synchronized void updateLocalCheckpoint(final String allocationId, final long localCheckpoint) {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        CheckpointState cps = checkpoints.get(allocationId)__        if (cps == null) {_            _            return__        }_        boolean increasedLocalCheckpoint = updateLocalCheckpoint(allocationId, cps, localCheckpoint)__        boolean pending = pendingInSync.contains(allocationId)__        if (pending && cps.localCheckpoint >= getGlobalCheckpoint()) {_            pendingInSync.remove(allocationId)__            pending = false__            cps.inSync = true__            replicationGroup = calculateReplicationGroup()__            logger.trace("marked [{}] as in-sync", allocationId)__            notifyAllWaiters()__        }_        if (increasedLocalCheckpoint && pending == false) {_            updateGlobalCheckpointOnPrimary()__        }_        assert invariant()__    };notifies,the,service,to,update,the,local,checkpoint,for,the,shard,with,the,provided,allocation,id,if,the,checkpoint,is,lower,than,the,currently,known,one,this,is,a,no,op,if,the,allocation,id,is,not,tracked,it,is,ignored,param,allocation,id,the,allocation,id,of,the,shard,to,update,the,local,checkpoint,for,param,local,checkpoint,the,local,checkpoint,for,the,shard;public,synchronized,void,update,local,checkpoint,final,string,allocation,id,final,long,local,checkpoint,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,checkpoint,state,cps,checkpoints,get,allocation,id,if,cps,null,return,boolean,increased,local,checkpoint,update,local,checkpoint,allocation,id,cps,local,checkpoint,boolean,pending,pending,in,sync,contains,allocation,id,if,pending,cps,local,checkpoint,get,global,checkpoint,pending,in,sync,remove,allocation,id,pending,false,cps,in,sync,true,replication,group,calculate,replication,group,logger,trace,marked,as,in,sync,allocation,id,notify,all,waiters,if,increased,local,checkpoint,pending,false,update,global,checkpoint,on,primary,assert,invariant
ReplicationTracker -> public synchronized void updateLocalCheckpoint(final String allocationId, final long localCheckpoint);1549294529;Notifies the service to update the local checkpoint for the shard with the provided allocation ID. If the checkpoint is lower than_the currently known one, this is a no-op. If the allocation ID is not tracked, it is ignored.__@param allocationId    the allocation ID of the shard to update the local checkpoint for_@param localCheckpoint the local checkpoint for the shard;public synchronized void updateLocalCheckpoint(final String allocationId, final long localCheckpoint) {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        CheckpointState cps = checkpoints.get(allocationId)__        if (cps == null) {_            _            return__        }_        boolean increasedLocalCheckpoint = updateLocalCheckpoint(allocationId, cps, localCheckpoint)__        boolean pending = pendingInSync.contains(allocationId)__        if (pending && cps.localCheckpoint >= getGlobalCheckpoint()) {_            pendingInSync.remove(allocationId)__            pending = false__            cps.inSync = true__            replicationGroup = calculateReplicationGroup()__            logger.trace("marked [{}] as in-sync", allocationId)__            notifyAllWaiters()__        }_        if (increasedLocalCheckpoint && pending == false) {_            updateGlobalCheckpointOnPrimary()__        }_        assert invariant()__    };notifies,the,service,to,update,the,local,checkpoint,for,the,shard,with,the,provided,allocation,id,if,the,checkpoint,is,lower,than,the,currently,known,one,this,is,a,no,op,if,the,allocation,id,is,not,tracked,it,is,ignored,param,allocation,id,the,allocation,id,of,the,shard,to,update,the,local,checkpoint,for,param,local,checkpoint,the,local,checkpoint,for,the,shard;public,synchronized,void,update,local,checkpoint,final,string,allocation,id,final,long,local,checkpoint,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,checkpoint,state,cps,checkpoints,get,allocation,id,if,cps,null,return,boolean,increased,local,checkpoint,update,local,checkpoint,allocation,id,cps,local,checkpoint,boolean,pending,pending,in,sync,contains,allocation,id,if,pending,cps,local,checkpoint,get,global,checkpoint,pending,in,sync,remove,allocation,id,pending,false,cps,in,sync,true,replication,group,calculate,replication,group,logger,trace,marked,as,in,sync,allocation,id,notify,all,waiters,if,increased,local,checkpoint,pending,false,update,global,checkpoint,on,primary,assert,invariant
ReplicationTracker -> public synchronized void updateLocalCheckpoint(final String allocationId, final long localCheckpoint);1549395737;Notifies the service to update the local checkpoint for the shard with the provided allocation ID. If the checkpoint is lower than_the currently known one, this is a no-op. If the allocation ID is not tracked, it is ignored.__@param allocationId    the allocation ID of the shard to update the local checkpoint for_@param localCheckpoint the local checkpoint for the shard;public synchronized void updateLocalCheckpoint(final String allocationId, final long localCheckpoint) {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        CheckpointState cps = checkpoints.get(allocationId)__        if (cps == null) {_            _            return__        }_        boolean increasedLocalCheckpoint = updateLocalCheckpoint(allocationId, cps, localCheckpoint)__        boolean pending = pendingInSync.contains(allocationId)__        if (pending && cps.localCheckpoint >= getGlobalCheckpoint()) {_            pendingInSync.remove(allocationId)__            pending = false__            cps.inSync = true__            replicationGroup = calculateReplicationGroup()__            logger.trace("marked [{}] as in-sync", allocationId)__            notifyAllWaiters()__        }_        if (increasedLocalCheckpoint && pending == false) {_            updateGlobalCheckpointOnPrimary()__        }_        assert invariant()__    };notifies,the,service,to,update,the,local,checkpoint,for,the,shard,with,the,provided,allocation,id,if,the,checkpoint,is,lower,than,the,currently,known,one,this,is,a,no,op,if,the,allocation,id,is,not,tracked,it,is,ignored,param,allocation,id,the,allocation,id,of,the,shard,to,update,the,local,checkpoint,for,param,local,checkpoint,the,local,checkpoint,for,the,shard;public,synchronized,void,update,local,checkpoint,final,string,allocation,id,final,long,local,checkpoint,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,checkpoint,state,cps,checkpoints,get,allocation,id,if,cps,null,return,boolean,increased,local,checkpoint,update,local,checkpoint,allocation,id,cps,local,checkpoint,boolean,pending,pending,in,sync,contains,allocation,id,if,pending,cps,local,checkpoint,get,global,checkpoint,pending,in,sync,remove,allocation,id,pending,false,cps,in,sync,true,replication,group,calculate,replication,group,logger,trace,marked,as,in,sync,allocation,id,notify,all,waiters,if,increased,local,checkpoint,pending,false,update,global,checkpoint,on,primary,assert,invariant
ReplicationTracker -> public synchronized void updateLocalCheckpoint(final String allocationId, final long localCheckpoint);1549937843;Notifies the service to update the local checkpoint for the shard with the provided allocation ID. If the checkpoint is lower than_the currently known one, this is a no-op. If the allocation ID is not tracked, it is ignored.__@param allocationId    the allocation ID of the shard to update the local checkpoint for_@param localCheckpoint the local checkpoint for the shard;public synchronized void updateLocalCheckpoint(final String allocationId, final long localCheckpoint) {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        CheckpointState cps = checkpoints.get(allocationId)__        if (cps == null) {_            _            return__        }_        boolean increasedLocalCheckpoint = updateLocalCheckpoint(allocationId, cps, localCheckpoint)__        boolean pending = pendingInSync.contains(allocationId)__        if (pending && cps.localCheckpoint >= getGlobalCheckpoint()) {_            pendingInSync.remove(allocationId)__            pending = false__            cps.inSync = true__            replicationGroup = calculateReplicationGroup()__            logger.trace("marked [{}] as in-sync", allocationId)__            notifyAllWaiters()__        }_        if (increasedLocalCheckpoint && pending == false) {_            updateGlobalCheckpointOnPrimary()__        }_        assert invariant()__    };notifies,the,service,to,update,the,local,checkpoint,for,the,shard,with,the,provided,allocation,id,if,the,checkpoint,is,lower,than,the,currently,known,one,this,is,a,no,op,if,the,allocation,id,is,not,tracked,it,is,ignored,param,allocation,id,the,allocation,id,of,the,shard,to,update,the,local,checkpoint,for,param,local,checkpoint,the,local,checkpoint,for,the,shard;public,synchronized,void,update,local,checkpoint,final,string,allocation,id,final,long,local,checkpoint,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,checkpoint,state,cps,checkpoints,get,allocation,id,if,cps,null,return,boolean,increased,local,checkpoint,update,local,checkpoint,allocation,id,cps,local,checkpoint,boolean,pending,pending,in,sync,contains,allocation,id,if,pending,cps,local,checkpoint,get,global,checkpoint,pending,in,sync,remove,allocation,id,pending,false,cps,in,sync,true,replication,group,calculate,replication,group,logger,trace,marked,as,in,sync,allocation,id,notify,all,waiters,if,increased,local,checkpoint,pending,false,update,global,checkpoint,on,primary,assert,invariant
ReplicationTracker -> public synchronized void updateLocalCheckpoint(final String allocationId, final long localCheckpoint);1549949489;Notifies the service to update the local checkpoint for the shard with the provided allocation ID. If the checkpoint is lower than_the currently known one, this is a no-op. If the allocation ID is not tracked, it is ignored.__@param allocationId    the allocation ID of the shard to update the local checkpoint for_@param localCheckpoint the local checkpoint for the shard;public synchronized void updateLocalCheckpoint(final String allocationId, final long localCheckpoint) {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        CheckpointState cps = checkpoints.get(allocationId)__        if (cps == null) {_            _            return__        }_        boolean increasedLocalCheckpoint = updateLocalCheckpoint(allocationId, cps, localCheckpoint)__        boolean pending = pendingInSync.contains(allocationId)__        if (pending && cps.localCheckpoint >= getGlobalCheckpoint()) {_            pendingInSync.remove(allocationId)__            pending = false__            cps.inSync = true__            replicationGroup = calculateReplicationGroup()__            logger.trace("marked [{}] as in-sync", allocationId)__            notifyAllWaiters()__        }_        if (increasedLocalCheckpoint && pending == false) {_            updateGlobalCheckpointOnPrimary()__        }_        assert invariant()__    };notifies,the,service,to,update,the,local,checkpoint,for,the,shard,with,the,provided,allocation,id,if,the,checkpoint,is,lower,than,the,currently,known,one,this,is,a,no,op,if,the,allocation,id,is,not,tracked,it,is,ignored,param,allocation,id,the,allocation,id,of,the,shard,to,update,the,local,checkpoint,for,param,local,checkpoint,the,local,checkpoint,for,the,shard;public,synchronized,void,update,local,checkpoint,final,string,allocation,id,final,long,local,checkpoint,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,checkpoint,state,cps,checkpoints,get,allocation,id,if,cps,null,return,boolean,increased,local,checkpoint,update,local,checkpoint,allocation,id,cps,local,checkpoint,boolean,pending,pending,in,sync,contains,allocation,id,if,pending,cps,local,checkpoint,get,global,checkpoint,pending,in,sync,remove,allocation,id,pending,false,cps,in,sync,true,replication,group,calculate,replication,group,logger,trace,marked,as,in,sync,allocation,id,notify,all,waiters,if,increased,local,checkpoint,pending,false,update,global,checkpoint,on,primary,assert,invariant
ReplicationTracker -> public synchronized void updateLocalCheckpoint(final String allocationId, final long localCheckpoint);1550526771;Notifies the service to update the local checkpoint for the shard with the provided allocation ID. If the checkpoint is lower than_the currently known one, this is a no-op. If the allocation ID is not tracked, it is ignored.__@param allocationId    the allocation ID of the shard to update the local checkpoint for_@param localCheckpoint the local checkpoint for the shard;public synchronized void updateLocalCheckpoint(final String allocationId, final long localCheckpoint) {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        CheckpointState cps = checkpoints.get(allocationId)__        if (cps == null) {_            _            return__        }_        boolean increasedLocalCheckpoint = updateLocalCheckpoint(allocationId, cps, localCheckpoint)__        boolean pending = pendingInSync.contains(allocationId)__        if (pending && cps.localCheckpoint >= getGlobalCheckpoint()) {_            pendingInSync.remove(allocationId)__            pending = false__            cps.inSync = true__            replicationGroup = calculateReplicationGroup()__            logger.trace("marked [{}] as in-sync", allocationId)__            notifyAllWaiters()__        }_        if (increasedLocalCheckpoint && pending == false) {_            updateGlobalCheckpointOnPrimary()__        }_        assert invariant()__    };notifies,the,service,to,update,the,local,checkpoint,for,the,shard,with,the,provided,allocation,id,if,the,checkpoint,is,lower,than,the,currently,known,one,this,is,a,no,op,if,the,allocation,id,is,not,tracked,it,is,ignored,param,allocation,id,the,allocation,id,of,the,shard,to,update,the,local,checkpoint,for,param,local,checkpoint,the,local,checkpoint,for,the,shard;public,synchronized,void,update,local,checkpoint,final,string,allocation,id,final,long,local,checkpoint,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,checkpoint,state,cps,checkpoints,get,allocation,id,if,cps,null,return,boolean,increased,local,checkpoint,update,local,checkpoint,allocation,id,cps,local,checkpoint,boolean,pending,pending,in,sync,contains,allocation,id,if,pending,cps,local,checkpoint,get,global,checkpoint,pending,in,sync,remove,allocation,id,pending,false,cps,in,sync,true,replication,group,calculate,replication,group,logger,trace,marked,as,in,sync,allocation,id,notify,all,waiters,if,increased,local,checkpoint,pending,false,update,global,checkpoint,on,primary,assert,invariant
ReplicationTracker -> @SuppressForbidden(reason = "Object#notifyAll waiters for local checkpoint advancement")     private synchronized void notifyAllWaiters();1524684173;Notify all threads waiting on the monitor on this tracker. These threads should be waiting for the local checkpoint on a specific_allocation ID to catch up to the global checkpoint.;@SuppressForbidden(reason = "Object#notifyAll waiters for local checkpoint advancement")_    private synchronized void notifyAllWaiters() {_        this.notifyAll()__    };notify,all,threads,waiting,on,the,monitor,on,this,tracker,these,threads,should,be,waiting,for,the,local,checkpoint,on,a,specific,allocation,id,to,catch,up,to,the,global,checkpoint;suppress,forbidden,reason,object,notify,all,waiters,for,local,checkpoint,advancement,private,synchronized,void,notify,all,waiters,this,notify,all
ReplicationTracker -> @SuppressForbidden(reason = "Object#notifyAll waiters for local checkpoint advancement")     private synchronized void notifyAllWaiters();1525334055;Notify all threads waiting on the monitor on this tracker. These threads should be waiting for the local checkpoint on a specific_allocation ID to catch up to the global checkpoint.;@SuppressForbidden(reason = "Object#notifyAll waiters for local checkpoint advancement")_    private synchronized void notifyAllWaiters() {_        this.notifyAll()__    };notify,all,threads,waiting,on,the,monitor,on,this,tracker,these,threads,should,be,waiting,for,the,local,checkpoint,on,a,specific,allocation,id,to,catch,up,to,the,global,checkpoint;suppress,forbidden,reason,object,notify,all,waiters,for,local,checkpoint,advancement,private,synchronized,void,notify,all,waiters,this,notify,all
ReplicationTracker -> @SuppressForbidden(reason = "Object#notifyAll waiters for local checkpoint advancement")     private synchronized void notifyAllWaiters();1533295538;Notify all threads waiting on the monitor on this tracker. These threads should be waiting for the local checkpoint on a specific_allocation ID to catch up to the global checkpoint.;@SuppressForbidden(reason = "Object#notifyAll waiters for local checkpoint advancement")_    private synchronized void notifyAllWaiters() {_        this.notifyAll()__    };notify,all,threads,waiting,on,the,monitor,on,this,tracker,these,threads,should,be,waiting,for,the,local,checkpoint,on,a,specific,allocation,id,to,catch,up,to,the,global,checkpoint;suppress,forbidden,reason,object,notify,all,waiters,for,local,checkpoint,advancement,private,synchronized,void,notify,all,waiters,this,notify,all
ReplicationTracker -> @SuppressForbidden(reason = "Object#notifyAll waiters for local checkpoint advancement")     private synchronized void notifyAllWaiters();1533738061;Notify all threads waiting on the monitor on this tracker. These threads should be waiting for the local checkpoint on a specific_allocation ID to catch up to the global checkpoint.;@SuppressForbidden(reason = "Object#notifyAll waiters for local checkpoint advancement")_    private synchronized void notifyAllWaiters() {_        this.notifyAll()__    };notify,all,threads,waiting,on,the,monitor,on,this,tracker,these,threads,should,be,waiting,for,the,local,checkpoint,on,a,specific,allocation,id,to,catch,up,to,the,global,checkpoint;suppress,forbidden,reason,object,notify,all,waiters,for,local,checkpoint,advancement,private,synchronized,void,notify,all,waiters,this,notify,all
ReplicationTracker -> @SuppressForbidden(reason = "Object#notifyAll waiters for local checkpoint advancement")     private synchronized void notifyAllWaiters();1546875837;Notify all threads waiting on the monitor on this tracker. These threads should be waiting for the local checkpoint on a specific_allocation ID to catch up to the global checkpoint.;@SuppressForbidden(reason = "Object#notifyAll waiters for local checkpoint advancement")_    private synchronized void notifyAllWaiters() {_        this.notifyAll()__    };notify,all,threads,waiting,on,the,monitor,on,this,tracker,these,threads,should,be,waiting,for,the,local,checkpoint,on,a,specific,allocation,id,to,catch,up,to,the,global,checkpoint;suppress,forbidden,reason,object,notify,all,waiters,for,local,checkpoint,advancement,private,synchronized,void,notify,all,waiters,this,notify,all
ReplicationTracker -> @SuppressForbidden(reason = "Object#notifyAll waiters for local checkpoint advancement")     private synchronized void notifyAllWaiters();1546927432;Notify all threads waiting on the monitor on this tracker. These threads should be waiting for the local checkpoint on a specific_allocation ID to catch up to the global checkpoint.;@SuppressForbidden(reason = "Object#notifyAll waiters for local checkpoint advancement")_    private synchronized void notifyAllWaiters() {_        this.notifyAll()__    };notify,all,threads,waiting,on,the,monitor,on,this,tracker,these,threads,should,be,waiting,for,the,local,checkpoint,on,a,specific,allocation,id,to,catch,up,to,the,global,checkpoint;suppress,forbidden,reason,object,notify,all,waiters,for,local,checkpoint,advancement,private,synchronized,void,notify,all,waiters,this,notify,all
ReplicationTracker -> @SuppressForbidden(reason = "Object#notifyAll waiters for local checkpoint advancement")     private synchronized void notifyAllWaiters();1547332999;Notify all threads waiting on the monitor on this tracker. These threads should be waiting for the local checkpoint on a specific_allocation ID to catch up to the global checkpoint.;@SuppressForbidden(reason = "Object#notifyAll waiters for local checkpoint advancement")_    private synchronized void notifyAllWaiters() {_        this.notifyAll()__    };notify,all,threads,waiting,on,the,monitor,on,this,tracker,these,threads,should,be,waiting,for,the,local,checkpoint,on,a,specific,allocation,id,to,catch,up,to,the,global,checkpoint;suppress,forbidden,reason,object,notify,all,waiters,for,local,checkpoint,advancement,private,synchronized,void,notify,all,waiters,this,notify,all
ReplicationTracker -> @SuppressForbidden(reason = "Object#notifyAll waiters for local checkpoint advancement")     private synchronized void notifyAllWaiters();1548593396;Notify all threads waiting on the monitor on this tracker. These threads should be waiting for the local checkpoint on a specific_allocation ID to catch up to the global checkpoint.;@SuppressForbidden(reason = "Object#notifyAll waiters for local checkpoint advancement")_    private synchronized void notifyAllWaiters() {_        this.notifyAll()__    };notify,all,threads,waiting,on,the,monitor,on,this,tracker,these,threads,should,be,waiting,for,the,local,checkpoint,on,a,specific,allocation,id,to,catch,up,to,the,global,checkpoint;suppress,forbidden,reason,object,notify,all,waiters,for,local,checkpoint,advancement,private,synchronized,void,notify,all,waiters,this,notify,all
ReplicationTracker -> @SuppressForbidden(reason = "Object#notifyAll waiters for local checkpoint advancement")     private synchronized void notifyAllWaiters();1548594827;Notify all threads waiting on the monitor on this tracker. These threads should be waiting for the local checkpoint on a specific_allocation ID to catch up to the global checkpoint.;@SuppressForbidden(reason = "Object#notifyAll waiters for local checkpoint advancement")_    private synchronized void notifyAllWaiters() {_        this.notifyAll()__    };notify,all,threads,waiting,on,the,monitor,on,this,tracker,these,threads,should,be,waiting,for,the,local,checkpoint,on,a,specific,allocation,id,to,catch,up,to,the,global,checkpoint;suppress,forbidden,reason,object,notify,all,waiters,for,local,checkpoint,advancement,private,synchronized,void,notify,all,waiters,this,notify,all
ReplicationTracker -> @SuppressForbidden(reason = "Object#notifyAll waiters for local checkpoint advancement")     private synchronized void notifyAllWaiters();1548677511;Notify all threads waiting on the monitor on this tracker. These threads should be waiting for the local checkpoint on a specific_allocation ID to catch up to the global checkpoint.;@SuppressForbidden(reason = "Object#notifyAll waiters for local checkpoint advancement")_    private synchronized void notifyAllWaiters() {_        this.notifyAll()__    };notify,all,threads,waiting,on,the,monitor,on,this,tracker,these,threads,should,be,waiting,for,the,local,checkpoint,on,a,specific,allocation,id,to,catch,up,to,the,global,checkpoint;suppress,forbidden,reason,object,notify,all,waiters,for,local,checkpoint,advancement,private,synchronized,void,notify,all,waiters,this,notify,all
ReplicationTracker -> @SuppressForbidden(reason = "Object#notifyAll waiters for local checkpoint advancement")     private synchronized void notifyAllWaiters();1548944389;Notify all threads waiting on the monitor on this tracker. These threads should be waiting for the local checkpoint on a specific_allocation ID to catch up to the global checkpoint.;@SuppressForbidden(reason = "Object#notifyAll waiters for local checkpoint advancement")_    private synchronized void notifyAllWaiters() {_        this.notifyAll()__    };notify,all,threads,waiting,on,the,monitor,on,this,tracker,these,threads,should,be,waiting,for,the,local,checkpoint,on,a,specific,allocation,id,to,catch,up,to,the,global,checkpoint;suppress,forbidden,reason,object,notify,all,waiters,for,local,checkpoint,advancement,private,synchronized,void,notify,all,waiters,this,notify,all
ReplicationTracker -> @SuppressForbidden(reason = "Object#notifyAll waiters for local checkpoint advancement")     private synchronized void notifyAllWaiters();1549059559;Notify all threads waiting on the monitor on this tracker. These threads should be waiting for the local checkpoint on a specific_allocation ID to catch up to the global checkpoint.;@SuppressForbidden(reason = "Object#notifyAll waiters for local checkpoint advancement")_    private synchronized void notifyAllWaiters() {_        this.notifyAll()__    };notify,all,threads,waiting,on,the,monitor,on,this,tracker,these,threads,should,be,waiting,for,the,local,checkpoint,on,a,specific,allocation,id,to,catch,up,to,the,global,checkpoint;suppress,forbidden,reason,object,notify,all,waiters,for,local,checkpoint,advancement,private,synchronized,void,notify,all,waiters,this,notify,all
ReplicationTracker -> @SuppressForbidden(reason = "Object#notifyAll waiters for local checkpoint advancement")     private synchronized void notifyAllWaiters();1549294529;Notify all threads waiting on the monitor on this tracker. These threads should be waiting for the local checkpoint on a specific_allocation ID to catch up to the global checkpoint.;@SuppressForbidden(reason = "Object#notifyAll waiters for local checkpoint advancement")_    private synchronized void notifyAllWaiters() {_        this.notifyAll()__    };notify,all,threads,waiting,on,the,monitor,on,this,tracker,these,threads,should,be,waiting,for,the,local,checkpoint,on,a,specific,allocation,id,to,catch,up,to,the,global,checkpoint;suppress,forbidden,reason,object,notify,all,waiters,for,local,checkpoint,advancement,private,synchronized,void,notify,all,waiters,this,notify,all
ReplicationTracker -> @SuppressForbidden(reason = "Object#notifyAll waiters for local checkpoint advancement")     private synchronized void notifyAllWaiters();1549395737;Notify all threads waiting on the monitor on this tracker. These threads should be waiting for the local checkpoint on a specific_allocation ID to catch up to the global checkpoint.;@SuppressForbidden(reason = "Object#notifyAll waiters for local checkpoint advancement")_    private synchronized void notifyAllWaiters() {_        this.notifyAll()__    };notify,all,threads,waiting,on,the,monitor,on,this,tracker,these,threads,should,be,waiting,for,the,local,checkpoint,on,a,specific,allocation,id,to,catch,up,to,the,global,checkpoint;suppress,forbidden,reason,object,notify,all,waiters,for,local,checkpoint,advancement,private,synchronized,void,notify,all,waiters,this,notify,all
ReplicationTracker -> @SuppressForbidden(reason = "Object#notifyAll waiters for local checkpoint advancement")     private synchronized void notifyAllWaiters();1549937843;Notify all threads waiting on the monitor on this tracker. These threads should be waiting for the local checkpoint on a specific_allocation ID to catch up to the global checkpoint.;@SuppressForbidden(reason = "Object#notifyAll waiters for local checkpoint advancement")_    private synchronized void notifyAllWaiters() {_        this.notifyAll()__    };notify,all,threads,waiting,on,the,monitor,on,this,tracker,these,threads,should,be,waiting,for,the,local,checkpoint,on,a,specific,allocation,id,to,catch,up,to,the,global,checkpoint;suppress,forbidden,reason,object,notify,all,waiters,for,local,checkpoint,advancement,private,synchronized,void,notify,all,waiters,this,notify,all
ReplicationTracker -> @SuppressForbidden(reason = "Object#notifyAll waiters for local checkpoint advancement")     private synchronized void notifyAllWaiters();1549949489;Notify all threads waiting on the monitor on this tracker. These threads should be waiting for the local checkpoint on a specific_allocation ID to catch up to the global checkpoint.;@SuppressForbidden(reason = "Object#notifyAll waiters for local checkpoint advancement")_    private synchronized void notifyAllWaiters() {_        this.notifyAll()__    };notify,all,threads,waiting,on,the,monitor,on,this,tracker,these,threads,should,be,waiting,for,the,local,checkpoint,on,a,specific,allocation,id,to,catch,up,to,the,global,checkpoint;suppress,forbidden,reason,object,notify,all,waiters,for,local,checkpoint,advancement,private,synchronized,void,notify,all,waiters,this,notify,all
ReplicationTracker -> @SuppressForbidden(reason = "Object#notifyAll waiters for local checkpoint advancement")     private synchronized void notifyAllWaiters();1550526771;Notify all threads waiting on the monitor on this tracker. These threads should be waiting for the local checkpoint on a specific_allocation ID to catch up to the global checkpoint.;@SuppressForbidden(reason = "Object#notifyAll waiters for local checkpoint advancement")_    private synchronized void notifyAllWaiters() {_        this.notifyAll()__    };notify,all,threads,waiting,on,the,monitor,on,this,tracker,these,threads,should,be,waiting,for,the,local,checkpoint,on,a,specific,allocation,id,to,catch,up,to,the,global,checkpoint;suppress,forbidden,reason,object,notify,all,waiters,for,local,checkpoint,advancement,private,synchronized,void,notify,all,waiters,this,notify,all
ReplicationTracker -> public ReplicationTracker(             final ShardId shardId,             final String allocationId,             final IndexSettings indexSettings,             final long globalCheckpoint);1524684173;Initialize the global checkpoint service. The specified global checkpoint should be set to the last known global checkpoint, or_{@link SequenceNumbers#UNASSIGNED_SEQ_NO}.__@param shardId          the shard ID_@param allocationId     the allocation ID_@param indexSettings    the index settings_@param globalCheckpoint the last known global checkpoint for this shard, or {@link SequenceNumbers#UNASSIGNED_SEQ_NO};public ReplicationTracker(_            final ShardId shardId,_            final String allocationId,_            final IndexSettings indexSettings,_            final long globalCheckpoint) {_        super(shardId, indexSettings)__        assert globalCheckpoint >= SequenceNumbers.UNASSIGNED_SEQ_NO : "illegal initial global checkpoint: " + globalCheckpoint__        this.shardAllocationId = allocationId__        this.primaryMode = false__        this.handoffInProgress = false__        this.appliedClusterStateVersion = -1L__        this.checkpoints = new HashMap<>(1 + indexSettings.getNumberOfReplicas())__        checkpoints.put(allocationId, new CheckpointState(SequenceNumbers.UNASSIGNED_SEQ_NO, globalCheckpoint, false, false))__        this.pendingInSync = new HashSet<>()__        this.routingTable = null__        this.replicationGroup = null__        assert invariant()__    };initialize,the,global,checkpoint,service,the,specified,global,checkpoint,should,be,set,to,the,last,known,global,checkpoint,or,link,sequence,numbers,param,shard,id,the,shard,id,param,allocation,id,the,allocation,id,param,index,settings,the,index,settings,param,global,checkpoint,the,last,known,global,checkpoint,for,this,shard,or,link,sequence,numbers;public,replication,tracker,final,shard,id,shard,id,final,string,allocation,id,final,index,settings,index,settings,final,long,global,checkpoint,super,shard,id,index,settings,assert,global,checkpoint,sequence,numbers,illegal,initial,global,checkpoint,global,checkpoint,this,shard,allocation,id,allocation,id,this,primary,mode,false,this,handoff,in,progress,false,this,applied,cluster,state,version,1l,this,checkpoints,new,hash,map,1,index,settings,get,number,of,replicas,checkpoints,put,allocation,id,new,checkpoint,state,sequence,numbers,global,checkpoint,false,false,this,pending,in,sync,new,hash,set,this,routing,table,null,this,replication,group,null,assert,invariant
ReplicationTracker -> public ReplicationTracker(             final ShardId shardId,             final String allocationId,             final IndexSettings indexSettings,             final long globalCheckpoint);1525334055;Initialize the global checkpoint service. The specified global checkpoint should be set to the last known global checkpoint, or_{@link SequenceNumbers#UNASSIGNED_SEQ_NO}.__@param shardId          the shard ID_@param allocationId     the allocation ID_@param indexSettings    the index settings_@param globalCheckpoint the last known global checkpoint for this shard, or {@link SequenceNumbers#UNASSIGNED_SEQ_NO};public ReplicationTracker(_            final ShardId shardId,_            final String allocationId,_            final IndexSettings indexSettings,_            final long globalCheckpoint) {_        super(shardId, indexSettings)__        assert globalCheckpoint >= SequenceNumbers.UNASSIGNED_SEQ_NO : "illegal initial global checkpoint: " + globalCheckpoint__        this.shardAllocationId = allocationId__        this.primaryMode = false__        this.handoffInProgress = false__        this.appliedClusterStateVersion = -1L__        this.checkpoints = new HashMap<>(1 + indexSettings.getNumberOfReplicas())__        checkpoints.put(allocationId, new CheckpointState(SequenceNumbers.UNASSIGNED_SEQ_NO, globalCheckpoint, false, false))__        this.pendingInSync = new HashSet<>()__        this.routingTable = null__        this.replicationGroup = null__        assert invariant()__    };initialize,the,global,checkpoint,service,the,specified,global,checkpoint,should,be,set,to,the,last,known,global,checkpoint,or,link,sequence,numbers,param,shard,id,the,shard,id,param,allocation,id,the,allocation,id,param,index,settings,the,index,settings,param,global,checkpoint,the,last,known,global,checkpoint,for,this,shard,or,link,sequence,numbers;public,replication,tracker,final,shard,id,shard,id,final,string,allocation,id,final,index,settings,index,settings,final,long,global,checkpoint,super,shard,id,index,settings,assert,global,checkpoint,sequence,numbers,illegal,initial,global,checkpoint,global,checkpoint,this,shard,allocation,id,allocation,id,this,primary,mode,false,this,handoff,in,progress,false,this,applied,cluster,state,version,1l,this,checkpoints,new,hash,map,1,index,settings,get,number,of,replicas,checkpoints,put,allocation,id,new,checkpoint,state,sequence,numbers,global,checkpoint,false,false,this,pending,in,sync,new,hash,set,this,routing,table,null,this,replication,group,null,assert,invariant
ReplicationTracker -> public ReplicationTracker(             final ShardId shardId,             final String allocationId,             final IndexSettings indexSettings,             final long globalCheckpoint);1533295538;Initialize the global checkpoint service. The specified global checkpoint should be set to the last known global checkpoint, or_{@link SequenceNumbers#UNASSIGNED_SEQ_NO}.__@param shardId          the shard ID_@param allocationId     the allocation ID_@param indexSettings    the index settings_@param globalCheckpoint the last known global checkpoint for this shard, or {@link SequenceNumbers#UNASSIGNED_SEQ_NO};public ReplicationTracker(_            final ShardId shardId,_            final String allocationId,_            final IndexSettings indexSettings,_            final long globalCheckpoint) {_        super(shardId, indexSettings)__        assert globalCheckpoint >= SequenceNumbers.UNASSIGNED_SEQ_NO : "illegal initial global checkpoint: " + globalCheckpoint__        this.shardAllocationId = allocationId__        this.primaryMode = false__        this.handoffInProgress = false__        this.appliedClusterStateVersion = -1L__        this.checkpoints = new HashMap<>(1 + indexSettings.getNumberOfReplicas())__        checkpoints.put(allocationId, new CheckpointState(SequenceNumbers.UNASSIGNED_SEQ_NO, globalCheckpoint, false, false))__        this.pendingInSync = new HashSet<>()__        this.routingTable = null__        this.replicationGroup = null__        assert invariant()__    };initialize,the,global,checkpoint,service,the,specified,global,checkpoint,should,be,set,to,the,last,known,global,checkpoint,or,link,sequence,numbers,param,shard,id,the,shard,id,param,allocation,id,the,allocation,id,param,index,settings,the,index,settings,param,global,checkpoint,the,last,known,global,checkpoint,for,this,shard,or,link,sequence,numbers;public,replication,tracker,final,shard,id,shard,id,final,string,allocation,id,final,index,settings,index,settings,final,long,global,checkpoint,super,shard,id,index,settings,assert,global,checkpoint,sequence,numbers,illegal,initial,global,checkpoint,global,checkpoint,this,shard,allocation,id,allocation,id,this,primary,mode,false,this,handoff,in,progress,false,this,applied,cluster,state,version,1l,this,checkpoints,new,hash,map,1,index,settings,get,number,of,replicas,checkpoints,put,allocation,id,new,checkpoint,state,sequence,numbers,global,checkpoint,false,false,this,pending,in,sync,new,hash,set,this,routing,table,null,this,replication,group,null,assert,invariant
ReplicationTracker -> private synchronized void updateGlobalCheckpointOnPrimary();1524684173;Scans through the currently known local checkpoint and updates the global checkpoint accordingly.;private synchronized void updateGlobalCheckpointOnPrimary() {_        assert primaryMode__        final CheckpointState cps = checkpoints.get(shardAllocationId)__        final long globalCheckpoint = cps.globalCheckpoint__        final long computedGlobalCheckpoint = computeGlobalCheckpoint(pendingInSync, checkpoints.values(), getGlobalCheckpoint())__        assert computedGlobalCheckpoint >= globalCheckpoint : "new global checkpoint [" + computedGlobalCheckpoint +_            "] is lower than previous one [" + globalCheckpoint + "]"__        if (globalCheckpoint != computedGlobalCheckpoint) {_            logger.trace("global checkpoint updated to [{}]", computedGlobalCheckpoint)__            cps.globalCheckpoint = computedGlobalCheckpoint__        }_    };scans,through,the,currently,known,local,checkpoint,and,updates,the,global,checkpoint,accordingly;private,synchronized,void,update,global,checkpoint,on,primary,assert,primary,mode,final,checkpoint,state,cps,checkpoints,get,shard,allocation,id,final,long,global,checkpoint,cps,global,checkpoint,final,long,computed,global,checkpoint,compute,global,checkpoint,pending,in,sync,checkpoints,values,get,global,checkpoint,assert,computed,global,checkpoint,global,checkpoint,new,global,checkpoint,computed,global,checkpoint,is,lower,than,previous,one,global,checkpoint,if,global,checkpoint,computed,global,checkpoint,logger,trace,global,checkpoint,updated,to,computed,global,checkpoint,cps,global,checkpoint,computed,global,checkpoint
ReplicationTracker -> private synchronized void updateGlobalCheckpointOnPrimary();1525334055;Scans through the currently known local checkpoint and updates the global checkpoint accordingly.;private synchronized void updateGlobalCheckpointOnPrimary() {_        assert primaryMode__        final CheckpointState cps = checkpoints.get(shardAllocationId)__        final long globalCheckpoint = cps.globalCheckpoint__        final long computedGlobalCheckpoint = computeGlobalCheckpoint(pendingInSync, checkpoints.values(), getGlobalCheckpoint())__        assert computedGlobalCheckpoint >= globalCheckpoint : "new global checkpoint [" + computedGlobalCheckpoint +_            "] is lower than previous one [" + globalCheckpoint + "]"__        if (globalCheckpoint != computedGlobalCheckpoint) {_            logger.trace("global checkpoint updated to [{}]", computedGlobalCheckpoint)__            cps.globalCheckpoint = computedGlobalCheckpoint__        }_    };scans,through,the,currently,known,local,checkpoint,and,updates,the,global,checkpoint,accordingly;private,synchronized,void,update,global,checkpoint,on,primary,assert,primary,mode,final,checkpoint,state,cps,checkpoints,get,shard,allocation,id,final,long,global,checkpoint,cps,global,checkpoint,final,long,computed,global,checkpoint,compute,global,checkpoint,pending,in,sync,checkpoints,values,get,global,checkpoint,assert,computed,global,checkpoint,global,checkpoint,new,global,checkpoint,computed,global,checkpoint,is,lower,than,previous,one,global,checkpoint,if,global,checkpoint,computed,global,checkpoint,logger,trace,global,checkpoint,updated,to,computed,global,checkpoint,cps,global,checkpoint,computed,global,checkpoint
ReplicationTracker -> private synchronized void updateGlobalCheckpointOnPrimary();1533295538;Scans through the currently known local checkpoint and updates the global checkpoint accordingly.;private synchronized void updateGlobalCheckpointOnPrimary() {_        assert primaryMode__        final CheckpointState cps = checkpoints.get(shardAllocationId)__        final long globalCheckpoint = cps.globalCheckpoint__        final long computedGlobalCheckpoint = computeGlobalCheckpoint(pendingInSync, checkpoints.values(), getGlobalCheckpoint())__        assert computedGlobalCheckpoint >= globalCheckpoint : "new global checkpoint [" + computedGlobalCheckpoint +_            "] is lower than previous one [" + globalCheckpoint + "]"__        if (globalCheckpoint != computedGlobalCheckpoint) {_            logger.trace("global checkpoint updated to [{}]", computedGlobalCheckpoint)__            cps.globalCheckpoint = computedGlobalCheckpoint__        }_    };scans,through,the,currently,known,local,checkpoint,and,updates,the,global,checkpoint,accordingly;private,synchronized,void,update,global,checkpoint,on,primary,assert,primary,mode,final,checkpoint,state,cps,checkpoints,get,shard,allocation,id,final,long,global,checkpoint,cps,global,checkpoint,final,long,computed,global,checkpoint,compute,global,checkpoint,pending,in,sync,checkpoints,values,get,global,checkpoint,assert,computed,global,checkpoint,global,checkpoint,new,global,checkpoint,computed,global,checkpoint,is,lower,than,previous,one,global,checkpoint,if,global,checkpoint,computed,global,checkpoint,logger,trace,global,checkpoint,updated,to,computed,global,checkpoint,cps,global,checkpoint,computed,global,checkpoint
ReplicationTracker -> private synchronized void updateGlobalCheckpointOnPrimary();1533738061;Scans through the currently known local checkpoint and updates the global checkpoint accordingly.;private synchronized void updateGlobalCheckpointOnPrimary() {_        assert primaryMode__        final CheckpointState cps = checkpoints.get(shardAllocationId)__        final long globalCheckpoint = cps.globalCheckpoint__        final long computedGlobalCheckpoint = computeGlobalCheckpoint(pendingInSync, checkpoints.values(), getGlobalCheckpoint())__        assert computedGlobalCheckpoint >= globalCheckpoint : "new global checkpoint [" + computedGlobalCheckpoint +_            "] is lower than previous one [" + globalCheckpoint + "]"__        if (globalCheckpoint != computedGlobalCheckpoint) {_            cps.globalCheckpoint = computedGlobalCheckpoint__            logger.trace("updated global checkpoint to [{}]", computedGlobalCheckpoint)__            onGlobalCheckpointUpdated.accept(computedGlobalCheckpoint)__        }_    };scans,through,the,currently,known,local,checkpoint,and,updates,the,global,checkpoint,accordingly;private,synchronized,void,update,global,checkpoint,on,primary,assert,primary,mode,final,checkpoint,state,cps,checkpoints,get,shard,allocation,id,final,long,global,checkpoint,cps,global,checkpoint,final,long,computed,global,checkpoint,compute,global,checkpoint,pending,in,sync,checkpoints,values,get,global,checkpoint,assert,computed,global,checkpoint,global,checkpoint,new,global,checkpoint,computed,global,checkpoint,is,lower,than,previous,one,global,checkpoint,if,global,checkpoint,computed,global,checkpoint,cps,global,checkpoint,computed,global,checkpoint,logger,trace,updated,global,checkpoint,to,computed,global,checkpoint,on,global,checkpoint,updated,accept,computed,global,checkpoint
ReplicationTracker -> private synchronized void updateGlobalCheckpointOnPrimary();1546875837;Scans through the currently known local checkpoint and updates the global checkpoint accordingly.;private synchronized void updateGlobalCheckpointOnPrimary() {_        assert primaryMode__        final CheckpointState cps = checkpoints.get(shardAllocationId)__        final long globalCheckpoint = cps.globalCheckpoint__        final long computedGlobalCheckpoint = computeGlobalCheckpoint(pendingInSync, checkpoints.values(), getGlobalCheckpoint())__        assert computedGlobalCheckpoint >= globalCheckpoint : "new global checkpoint [" + computedGlobalCheckpoint +_            "] is lower than previous one [" + globalCheckpoint + "]"__        if (globalCheckpoint != computedGlobalCheckpoint) {_            cps.globalCheckpoint = computedGlobalCheckpoint__            logger.trace("updated global checkpoint to [{}]", computedGlobalCheckpoint)__            onGlobalCheckpointUpdated.accept(computedGlobalCheckpoint)__        }_    };scans,through,the,currently,known,local,checkpoint,and,updates,the,global,checkpoint,accordingly;private,synchronized,void,update,global,checkpoint,on,primary,assert,primary,mode,final,checkpoint,state,cps,checkpoints,get,shard,allocation,id,final,long,global,checkpoint,cps,global,checkpoint,final,long,computed,global,checkpoint,compute,global,checkpoint,pending,in,sync,checkpoints,values,get,global,checkpoint,assert,computed,global,checkpoint,global,checkpoint,new,global,checkpoint,computed,global,checkpoint,is,lower,than,previous,one,global,checkpoint,if,global,checkpoint,computed,global,checkpoint,cps,global,checkpoint,computed,global,checkpoint,logger,trace,updated,global,checkpoint,to,computed,global,checkpoint,on,global,checkpoint,updated,accept,computed,global,checkpoint
ReplicationTracker -> private synchronized void updateGlobalCheckpointOnPrimary();1546927432;Scans through the currently known local checkpoint and updates the global checkpoint accordingly.;private synchronized void updateGlobalCheckpointOnPrimary() {_        assert primaryMode__        final CheckpointState cps = checkpoints.get(shardAllocationId)__        final long globalCheckpoint = cps.globalCheckpoint__        final long computedGlobalCheckpoint = computeGlobalCheckpoint(pendingInSync, checkpoints.values(), getGlobalCheckpoint())__        assert computedGlobalCheckpoint >= globalCheckpoint : "new global checkpoint [" + computedGlobalCheckpoint +_            "] is lower than previous one [" + globalCheckpoint + "]"__        if (globalCheckpoint != computedGlobalCheckpoint) {_            cps.globalCheckpoint = computedGlobalCheckpoint__            logger.trace("updated global checkpoint to [{}]", computedGlobalCheckpoint)__            onGlobalCheckpointUpdated.accept(computedGlobalCheckpoint)__        }_    };scans,through,the,currently,known,local,checkpoint,and,updates,the,global,checkpoint,accordingly;private,synchronized,void,update,global,checkpoint,on,primary,assert,primary,mode,final,checkpoint,state,cps,checkpoints,get,shard,allocation,id,final,long,global,checkpoint,cps,global,checkpoint,final,long,computed,global,checkpoint,compute,global,checkpoint,pending,in,sync,checkpoints,values,get,global,checkpoint,assert,computed,global,checkpoint,global,checkpoint,new,global,checkpoint,computed,global,checkpoint,is,lower,than,previous,one,global,checkpoint,if,global,checkpoint,computed,global,checkpoint,cps,global,checkpoint,computed,global,checkpoint,logger,trace,updated,global,checkpoint,to,computed,global,checkpoint,on,global,checkpoint,updated,accept,computed,global,checkpoint
ReplicationTracker -> private synchronized void updateGlobalCheckpointOnPrimary();1547332999;Scans through the currently known local checkpoint and updates the global checkpoint accordingly.;private synchronized void updateGlobalCheckpointOnPrimary() {_        assert primaryMode__        final CheckpointState cps = checkpoints.get(shardAllocationId)__        final long globalCheckpoint = cps.globalCheckpoint__        final long computedGlobalCheckpoint = computeGlobalCheckpoint(pendingInSync, checkpoints.values(), getGlobalCheckpoint())__        assert computedGlobalCheckpoint >= globalCheckpoint : "new global checkpoint [" + computedGlobalCheckpoint +_            "] is lower than previous one [" + globalCheckpoint + "]"__        if (globalCheckpoint != computedGlobalCheckpoint) {_            cps.globalCheckpoint = computedGlobalCheckpoint__            logger.trace("updated global checkpoint to [{}]", computedGlobalCheckpoint)__            onGlobalCheckpointUpdated.accept(computedGlobalCheckpoint)__        }_    };scans,through,the,currently,known,local,checkpoint,and,updates,the,global,checkpoint,accordingly;private,synchronized,void,update,global,checkpoint,on,primary,assert,primary,mode,final,checkpoint,state,cps,checkpoints,get,shard,allocation,id,final,long,global,checkpoint,cps,global,checkpoint,final,long,computed,global,checkpoint,compute,global,checkpoint,pending,in,sync,checkpoints,values,get,global,checkpoint,assert,computed,global,checkpoint,global,checkpoint,new,global,checkpoint,computed,global,checkpoint,is,lower,than,previous,one,global,checkpoint,if,global,checkpoint,computed,global,checkpoint,cps,global,checkpoint,computed,global,checkpoint,logger,trace,updated,global,checkpoint,to,computed,global,checkpoint,on,global,checkpoint,updated,accept,computed,global,checkpoint
ReplicationTracker -> private synchronized void updateGlobalCheckpointOnPrimary();1548593396;Scans through the currently known local checkpoint and updates the global checkpoint accordingly.;private synchronized void updateGlobalCheckpointOnPrimary() {_        assert primaryMode__        final CheckpointState cps = checkpoints.get(shardAllocationId)__        final long globalCheckpoint = cps.globalCheckpoint__        final long computedGlobalCheckpoint = computeGlobalCheckpoint(pendingInSync, checkpoints.values(), getGlobalCheckpoint())__        assert computedGlobalCheckpoint >= globalCheckpoint : "new global checkpoint [" + computedGlobalCheckpoint +_            "] is lower than previous one [" + globalCheckpoint + "]"__        if (globalCheckpoint != computedGlobalCheckpoint) {_            cps.globalCheckpoint = computedGlobalCheckpoint__            logger.trace("updated global checkpoint to [{}]", computedGlobalCheckpoint)__            onGlobalCheckpointUpdated.accept(computedGlobalCheckpoint)__        }_    };scans,through,the,currently,known,local,checkpoint,and,updates,the,global,checkpoint,accordingly;private,synchronized,void,update,global,checkpoint,on,primary,assert,primary,mode,final,checkpoint,state,cps,checkpoints,get,shard,allocation,id,final,long,global,checkpoint,cps,global,checkpoint,final,long,computed,global,checkpoint,compute,global,checkpoint,pending,in,sync,checkpoints,values,get,global,checkpoint,assert,computed,global,checkpoint,global,checkpoint,new,global,checkpoint,computed,global,checkpoint,is,lower,than,previous,one,global,checkpoint,if,global,checkpoint,computed,global,checkpoint,cps,global,checkpoint,computed,global,checkpoint,logger,trace,updated,global,checkpoint,to,computed,global,checkpoint,on,global,checkpoint,updated,accept,computed,global,checkpoint
ReplicationTracker -> private synchronized void updateGlobalCheckpointOnPrimary();1548594827;Scans through the currently known local checkpoint and updates the global checkpoint accordingly.;private synchronized void updateGlobalCheckpointOnPrimary() {_        assert primaryMode__        final CheckpointState cps = checkpoints.get(shardAllocationId)__        final long globalCheckpoint = cps.globalCheckpoint__        final long computedGlobalCheckpoint = computeGlobalCheckpoint(pendingInSync, checkpoints.values(), getGlobalCheckpoint())__        assert computedGlobalCheckpoint >= globalCheckpoint : "new global checkpoint [" + computedGlobalCheckpoint +_            "] is lower than previous one [" + globalCheckpoint + "]"__        if (globalCheckpoint != computedGlobalCheckpoint) {_            cps.globalCheckpoint = computedGlobalCheckpoint__            logger.trace("updated global checkpoint to [{}]", computedGlobalCheckpoint)__            onGlobalCheckpointUpdated.accept(computedGlobalCheckpoint)__        }_    };scans,through,the,currently,known,local,checkpoint,and,updates,the,global,checkpoint,accordingly;private,synchronized,void,update,global,checkpoint,on,primary,assert,primary,mode,final,checkpoint,state,cps,checkpoints,get,shard,allocation,id,final,long,global,checkpoint,cps,global,checkpoint,final,long,computed,global,checkpoint,compute,global,checkpoint,pending,in,sync,checkpoints,values,get,global,checkpoint,assert,computed,global,checkpoint,global,checkpoint,new,global,checkpoint,computed,global,checkpoint,is,lower,than,previous,one,global,checkpoint,if,global,checkpoint,computed,global,checkpoint,cps,global,checkpoint,computed,global,checkpoint,logger,trace,updated,global,checkpoint,to,computed,global,checkpoint,on,global,checkpoint,updated,accept,computed,global,checkpoint
ReplicationTracker -> private synchronized void updateGlobalCheckpointOnPrimary();1548677511;Scans through the currently known local checkpoint and updates the global checkpoint accordingly.;private synchronized void updateGlobalCheckpointOnPrimary() {_        assert primaryMode__        final CheckpointState cps = checkpoints.get(shardAllocationId)__        final long globalCheckpoint = cps.globalCheckpoint__        final long computedGlobalCheckpoint = computeGlobalCheckpoint(pendingInSync, checkpoints.values(), getGlobalCheckpoint())__        assert computedGlobalCheckpoint >= globalCheckpoint : "new global checkpoint [" + computedGlobalCheckpoint +_            "] is lower than previous one [" + globalCheckpoint + "]"__        if (globalCheckpoint != computedGlobalCheckpoint) {_            cps.globalCheckpoint = computedGlobalCheckpoint__            logger.trace("updated global checkpoint to [{}]", computedGlobalCheckpoint)__            onGlobalCheckpointUpdated.accept(computedGlobalCheckpoint)__        }_    };scans,through,the,currently,known,local,checkpoint,and,updates,the,global,checkpoint,accordingly;private,synchronized,void,update,global,checkpoint,on,primary,assert,primary,mode,final,checkpoint,state,cps,checkpoints,get,shard,allocation,id,final,long,global,checkpoint,cps,global,checkpoint,final,long,computed,global,checkpoint,compute,global,checkpoint,pending,in,sync,checkpoints,values,get,global,checkpoint,assert,computed,global,checkpoint,global,checkpoint,new,global,checkpoint,computed,global,checkpoint,is,lower,than,previous,one,global,checkpoint,if,global,checkpoint,computed,global,checkpoint,cps,global,checkpoint,computed,global,checkpoint,logger,trace,updated,global,checkpoint,to,computed,global,checkpoint,on,global,checkpoint,updated,accept,computed,global,checkpoint
ReplicationTracker -> private synchronized void updateGlobalCheckpointOnPrimary();1548944389;Scans through the currently known local checkpoint and updates the global checkpoint accordingly.;private synchronized void updateGlobalCheckpointOnPrimary() {_        assert primaryMode__        final CheckpointState cps = checkpoints.get(shardAllocationId)__        final long globalCheckpoint = cps.globalCheckpoint__        final long computedGlobalCheckpoint = computeGlobalCheckpoint(pendingInSync, checkpoints.values(), getGlobalCheckpoint())__        assert computedGlobalCheckpoint >= globalCheckpoint : "new global checkpoint [" + computedGlobalCheckpoint +_            "] is lower than previous one [" + globalCheckpoint + "]"__        if (globalCheckpoint != computedGlobalCheckpoint) {_            cps.globalCheckpoint = computedGlobalCheckpoint__            logger.trace("updated global checkpoint to [{}]", computedGlobalCheckpoint)__            onGlobalCheckpointUpdated.accept(computedGlobalCheckpoint)__        }_    };scans,through,the,currently,known,local,checkpoint,and,updates,the,global,checkpoint,accordingly;private,synchronized,void,update,global,checkpoint,on,primary,assert,primary,mode,final,checkpoint,state,cps,checkpoints,get,shard,allocation,id,final,long,global,checkpoint,cps,global,checkpoint,final,long,computed,global,checkpoint,compute,global,checkpoint,pending,in,sync,checkpoints,values,get,global,checkpoint,assert,computed,global,checkpoint,global,checkpoint,new,global,checkpoint,computed,global,checkpoint,is,lower,than,previous,one,global,checkpoint,if,global,checkpoint,computed,global,checkpoint,cps,global,checkpoint,computed,global,checkpoint,logger,trace,updated,global,checkpoint,to,computed,global,checkpoint,on,global,checkpoint,updated,accept,computed,global,checkpoint
ReplicationTracker -> private synchronized void updateGlobalCheckpointOnPrimary();1549059559;Scans through the currently known local checkpoint and updates the global checkpoint accordingly.;private synchronized void updateGlobalCheckpointOnPrimary() {_        assert primaryMode__        final CheckpointState cps = checkpoints.get(shardAllocationId)__        final long globalCheckpoint = cps.globalCheckpoint__        final long computedGlobalCheckpoint = computeGlobalCheckpoint(pendingInSync, checkpoints.values(), getGlobalCheckpoint())__        assert computedGlobalCheckpoint >= globalCheckpoint : "new global checkpoint [" + computedGlobalCheckpoint +_            "] is lower than previous one [" + globalCheckpoint + "]"__        if (globalCheckpoint != computedGlobalCheckpoint) {_            cps.globalCheckpoint = computedGlobalCheckpoint__            logger.trace("updated global checkpoint to [{}]", computedGlobalCheckpoint)__            onGlobalCheckpointUpdated.accept(computedGlobalCheckpoint)__        }_    };scans,through,the,currently,known,local,checkpoint,and,updates,the,global,checkpoint,accordingly;private,synchronized,void,update,global,checkpoint,on,primary,assert,primary,mode,final,checkpoint,state,cps,checkpoints,get,shard,allocation,id,final,long,global,checkpoint,cps,global,checkpoint,final,long,computed,global,checkpoint,compute,global,checkpoint,pending,in,sync,checkpoints,values,get,global,checkpoint,assert,computed,global,checkpoint,global,checkpoint,new,global,checkpoint,computed,global,checkpoint,is,lower,than,previous,one,global,checkpoint,if,global,checkpoint,computed,global,checkpoint,cps,global,checkpoint,computed,global,checkpoint,logger,trace,updated,global,checkpoint,to,computed,global,checkpoint,on,global,checkpoint,updated,accept,computed,global,checkpoint
ReplicationTracker -> private synchronized void updateGlobalCheckpointOnPrimary();1549294529;Scans through the currently known local checkpoint and updates the global checkpoint accordingly.;private synchronized void updateGlobalCheckpointOnPrimary() {_        assert primaryMode__        final CheckpointState cps = checkpoints.get(shardAllocationId)__        final long globalCheckpoint = cps.globalCheckpoint__        final long computedGlobalCheckpoint = computeGlobalCheckpoint(pendingInSync, checkpoints.values(), getGlobalCheckpoint())__        assert computedGlobalCheckpoint >= globalCheckpoint : "new global checkpoint [" + computedGlobalCheckpoint +_            "] is lower than previous one [" + globalCheckpoint + "]"__        if (globalCheckpoint != computedGlobalCheckpoint) {_            cps.globalCheckpoint = computedGlobalCheckpoint__            logger.trace("updated global checkpoint to [{}]", computedGlobalCheckpoint)__            onGlobalCheckpointUpdated.accept(computedGlobalCheckpoint)__        }_    };scans,through,the,currently,known,local,checkpoint,and,updates,the,global,checkpoint,accordingly;private,synchronized,void,update,global,checkpoint,on,primary,assert,primary,mode,final,checkpoint,state,cps,checkpoints,get,shard,allocation,id,final,long,global,checkpoint,cps,global,checkpoint,final,long,computed,global,checkpoint,compute,global,checkpoint,pending,in,sync,checkpoints,values,get,global,checkpoint,assert,computed,global,checkpoint,global,checkpoint,new,global,checkpoint,computed,global,checkpoint,is,lower,than,previous,one,global,checkpoint,if,global,checkpoint,computed,global,checkpoint,cps,global,checkpoint,computed,global,checkpoint,logger,trace,updated,global,checkpoint,to,computed,global,checkpoint,on,global,checkpoint,updated,accept,computed,global,checkpoint
ReplicationTracker -> private synchronized void updateGlobalCheckpointOnPrimary();1549395737;Scans through the currently known local checkpoint and updates the global checkpoint accordingly.;private synchronized void updateGlobalCheckpointOnPrimary() {_        assert primaryMode__        final CheckpointState cps = checkpoints.get(shardAllocationId)__        final long globalCheckpoint = cps.globalCheckpoint__        final long computedGlobalCheckpoint = computeGlobalCheckpoint(pendingInSync, checkpoints.values(), getGlobalCheckpoint())__        assert computedGlobalCheckpoint >= globalCheckpoint : "new global checkpoint [" + computedGlobalCheckpoint +_            "] is lower than previous one [" + globalCheckpoint + "]"__        if (globalCheckpoint != computedGlobalCheckpoint) {_            cps.globalCheckpoint = computedGlobalCheckpoint__            logger.trace("updated global checkpoint to [{}]", computedGlobalCheckpoint)__            onGlobalCheckpointUpdated.accept(computedGlobalCheckpoint)__        }_    };scans,through,the,currently,known,local,checkpoint,and,updates,the,global,checkpoint,accordingly;private,synchronized,void,update,global,checkpoint,on,primary,assert,primary,mode,final,checkpoint,state,cps,checkpoints,get,shard,allocation,id,final,long,global,checkpoint,cps,global,checkpoint,final,long,computed,global,checkpoint,compute,global,checkpoint,pending,in,sync,checkpoints,values,get,global,checkpoint,assert,computed,global,checkpoint,global,checkpoint,new,global,checkpoint,computed,global,checkpoint,is,lower,than,previous,one,global,checkpoint,if,global,checkpoint,computed,global,checkpoint,cps,global,checkpoint,computed,global,checkpoint,logger,trace,updated,global,checkpoint,to,computed,global,checkpoint,on,global,checkpoint,updated,accept,computed,global,checkpoint
ReplicationTracker -> private synchronized void updateGlobalCheckpointOnPrimary();1549937843;Scans through the currently known local checkpoint and updates the global checkpoint accordingly.;private synchronized void updateGlobalCheckpointOnPrimary() {_        assert primaryMode__        final CheckpointState cps = checkpoints.get(shardAllocationId)__        final long globalCheckpoint = cps.globalCheckpoint__        final long computedGlobalCheckpoint = computeGlobalCheckpoint(pendingInSync, checkpoints.values(), getGlobalCheckpoint())__        assert computedGlobalCheckpoint >= globalCheckpoint : "new global checkpoint [" + computedGlobalCheckpoint +_            "] is lower than previous one [" + globalCheckpoint + "]"__        if (globalCheckpoint != computedGlobalCheckpoint) {_            cps.globalCheckpoint = computedGlobalCheckpoint__            logger.trace("updated global checkpoint to [{}]", computedGlobalCheckpoint)__            onGlobalCheckpointUpdated.accept(computedGlobalCheckpoint)__        }_    };scans,through,the,currently,known,local,checkpoint,and,updates,the,global,checkpoint,accordingly;private,synchronized,void,update,global,checkpoint,on,primary,assert,primary,mode,final,checkpoint,state,cps,checkpoints,get,shard,allocation,id,final,long,global,checkpoint,cps,global,checkpoint,final,long,computed,global,checkpoint,compute,global,checkpoint,pending,in,sync,checkpoints,values,get,global,checkpoint,assert,computed,global,checkpoint,global,checkpoint,new,global,checkpoint,computed,global,checkpoint,is,lower,than,previous,one,global,checkpoint,if,global,checkpoint,computed,global,checkpoint,cps,global,checkpoint,computed,global,checkpoint,logger,trace,updated,global,checkpoint,to,computed,global,checkpoint,on,global,checkpoint,updated,accept,computed,global,checkpoint
ReplicationTracker -> private synchronized void updateGlobalCheckpointOnPrimary();1549949489;Scans through the currently known local checkpoint and updates the global checkpoint accordingly.;private synchronized void updateGlobalCheckpointOnPrimary() {_        assert primaryMode__        final CheckpointState cps = checkpoints.get(shardAllocationId)__        final long globalCheckpoint = cps.globalCheckpoint__        final long computedGlobalCheckpoint = computeGlobalCheckpoint(pendingInSync, checkpoints.values(), getGlobalCheckpoint())__        assert computedGlobalCheckpoint >= globalCheckpoint : "new global checkpoint [" + computedGlobalCheckpoint +_            "] is lower than previous one [" + globalCheckpoint + "]"__        if (globalCheckpoint != computedGlobalCheckpoint) {_            cps.globalCheckpoint = computedGlobalCheckpoint__            logger.trace("updated global checkpoint to [{}]", computedGlobalCheckpoint)__            onGlobalCheckpointUpdated.accept(computedGlobalCheckpoint)__        }_    };scans,through,the,currently,known,local,checkpoint,and,updates,the,global,checkpoint,accordingly;private,synchronized,void,update,global,checkpoint,on,primary,assert,primary,mode,final,checkpoint,state,cps,checkpoints,get,shard,allocation,id,final,long,global,checkpoint,cps,global,checkpoint,final,long,computed,global,checkpoint,compute,global,checkpoint,pending,in,sync,checkpoints,values,get,global,checkpoint,assert,computed,global,checkpoint,global,checkpoint,new,global,checkpoint,computed,global,checkpoint,is,lower,than,previous,one,global,checkpoint,if,global,checkpoint,computed,global,checkpoint,cps,global,checkpoint,computed,global,checkpoint,logger,trace,updated,global,checkpoint,to,computed,global,checkpoint,on,global,checkpoint,updated,accept,computed,global,checkpoint
ReplicationTracker -> private synchronized void updateGlobalCheckpointOnPrimary();1550526771;Scans through the currently known local checkpoint and updates the global checkpoint accordingly.;private synchronized void updateGlobalCheckpointOnPrimary() {_        assert primaryMode__        final CheckpointState cps = checkpoints.get(shardAllocationId)__        final long globalCheckpoint = cps.globalCheckpoint__        final long computedGlobalCheckpoint = computeGlobalCheckpoint(pendingInSync, checkpoints.values(), getGlobalCheckpoint())__        assert computedGlobalCheckpoint >= globalCheckpoint : "new global checkpoint [" + computedGlobalCheckpoint +_            "] is lower than previous one [" + globalCheckpoint + "]"__        if (globalCheckpoint != computedGlobalCheckpoint) {_            cps.globalCheckpoint = computedGlobalCheckpoint__            logger.trace("updated global checkpoint to [{}]", computedGlobalCheckpoint)__            onGlobalCheckpointUpdated.accept(computedGlobalCheckpoint)__        }_    };scans,through,the,currently,known,local,checkpoint,and,updates,the,global,checkpoint,accordingly;private,synchronized,void,update,global,checkpoint,on,primary,assert,primary,mode,final,checkpoint,state,cps,checkpoints,get,shard,allocation,id,final,long,global,checkpoint,cps,global,checkpoint,final,long,computed,global,checkpoint,compute,global,checkpoint,pending,in,sync,checkpoints,values,get,global,checkpoint,assert,computed,global,checkpoint,global,checkpoint,new,global,checkpoint,computed,global,checkpoint,is,lower,than,previous,one,global,checkpoint,if,global,checkpoint,computed,global,checkpoint,cps,global,checkpoint,computed,global,checkpoint,logger,trace,updated,global,checkpoint,to,computed,global,checkpoint,on,global,checkpoint,updated,accept,computed,global,checkpoint
ReplicationTracker -> CheckpointState -> public CheckpointState copy();1524684173;Returns a full copy of this object;public CheckpointState copy() {_            return new CheckpointState(localCheckpoint, globalCheckpoint, inSync, tracked)__        };returns,a,full,copy,of,this,object;public,checkpoint,state,copy,return,new,checkpoint,state,local,checkpoint,global,checkpoint,in,sync,tracked
ReplicationTracker -> CheckpointState -> public CheckpointState copy();1525334055;Returns a full copy of this object;public CheckpointState copy() {_            return new CheckpointState(localCheckpoint, globalCheckpoint, inSync, tracked)__        };returns,a,full,copy,of,this,object;public,checkpoint,state,copy,return,new,checkpoint,state,local,checkpoint,global,checkpoint,in,sync,tracked
ReplicationTracker -> CheckpointState -> public CheckpointState copy();1533295538;Returns a full copy of this object;public CheckpointState copy() {_            return new CheckpointState(localCheckpoint, globalCheckpoint, inSync, tracked)__        };returns,a,full,copy,of,this,object;public,checkpoint,state,copy,return,new,checkpoint,state,local,checkpoint,global,checkpoint,in,sync,tracked
ReplicationTracker -> CheckpointState -> public CheckpointState copy();1533738061;Returns a full copy of this object;public CheckpointState copy() {_            return new CheckpointState(localCheckpoint, globalCheckpoint, inSync, tracked)__        };returns,a,full,copy,of,this,object;public,checkpoint,state,copy,return,new,checkpoint,state,local,checkpoint,global,checkpoint,in,sync,tracked
ReplicationTracker -> CheckpointState -> public CheckpointState copy();1546875837;Returns a full copy of this object;public CheckpointState copy() {_            return new CheckpointState(localCheckpoint, globalCheckpoint, inSync, tracked)__        };returns,a,full,copy,of,this,object;public,checkpoint,state,copy,return,new,checkpoint,state,local,checkpoint,global,checkpoint,in,sync,tracked
ReplicationTracker -> CheckpointState -> public CheckpointState copy();1546927432;Returns a full copy of this object;public CheckpointState copy() {_            return new CheckpointState(localCheckpoint, globalCheckpoint, inSync, tracked)__        };returns,a,full,copy,of,this,object;public,checkpoint,state,copy,return,new,checkpoint,state,local,checkpoint,global,checkpoint,in,sync,tracked
ReplicationTracker -> CheckpointState -> public CheckpointState copy();1547332999;Returns a full copy of this object;public CheckpointState copy() {_            return new CheckpointState(localCheckpoint, globalCheckpoint, inSync, tracked)__        };returns,a,full,copy,of,this,object;public,checkpoint,state,copy,return,new,checkpoint,state,local,checkpoint,global,checkpoint,in,sync,tracked
ReplicationTracker -> CheckpointState -> public CheckpointState copy();1548593396;Returns a full copy of this object;public CheckpointState copy() {_            return new CheckpointState(localCheckpoint, globalCheckpoint, inSync, tracked)__        };returns,a,full,copy,of,this,object;public,checkpoint,state,copy,return,new,checkpoint,state,local,checkpoint,global,checkpoint,in,sync,tracked
ReplicationTracker -> CheckpointState -> public CheckpointState copy();1548594827;Returns a full copy of this object;public CheckpointState copy() {_            return new CheckpointState(localCheckpoint, globalCheckpoint, inSync, tracked)__        };returns,a,full,copy,of,this,object;public,checkpoint,state,copy,return,new,checkpoint,state,local,checkpoint,global,checkpoint,in,sync,tracked
ReplicationTracker -> CheckpointState -> public CheckpointState copy();1548677511;Returns a full copy of this object;public CheckpointState copy() {_            return new CheckpointState(localCheckpoint, globalCheckpoint, inSync, tracked)__        };returns,a,full,copy,of,this,object;public,checkpoint,state,copy,return,new,checkpoint,state,local,checkpoint,global,checkpoint,in,sync,tracked
ReplicationTracker -> CheckpointState -> public CheckpointState copy();1548944389;Returns a full copy of this object;public CheckpointState copy() {_            return new CheckpointState(localCheckpoint, globalCheckpoint, inSync, tracked)__        };returns,a,full,copy,of,this,object;public,checkpoint,state,copy,return,new,checkpoint,state,local,checkpoint,global,checkpoint,in,sync,tracked
ReplicationTracker -> CheckpointState -> public CheckpointState copy();1549059559;Returns a full copy of this object;public CheckpointState copy() {_            return new CheckpointState(localCheckpoint, globalCheckpoint, inSync, tracked)__        };returns,a,full,copy,of,this,object;public,checkpoint,state,copy,return,new,checkpoint,state,local,checkpoint,global,checkpoint,in,sync,tracked
ReplicationTracker -> CheckpointState -> public CheckpointState copy();1549294529;Returns a full copy of this object;public CheckpointState copy() {_            return new CheckpointState(localCheckpoint, globalCheckpoint, inSync, tracked)__        };returns,a,full,copy,of,this,object;public,checkpoint,state,copy,return,new,checkpoint,state,local,checkpoint,global,checkpoint,in,sync,tracked
ReplicationTracker -> CheckpointState -> public CheckpointState copy();1549395737;Returns a full copy of this object;public CheckpointState copy() {_            return new CheckpointState(localCheckpoint, globalCheckpoint, inSync, tracked)__        };returns,a,full,copy,of,this,object;public,checkpoint,state,copy,return,new,checkpoint,state,local,checkpoint,global,checkpoint,in,sync,tracked
ReplicationTracker -> CheckpointState -> public CheckpointState copy();1549937843;Returns a full copy of this object;public CheckpointState copy() {_            return new CheckpointState(localCheckpoint, globalCheckpoint, inSync, tracked)__        };returns,a,full,copy,of,this,object;public,checkpoint,state,copy,return,new,checkpoint,state,local,checkpoint,global,checkpoint,in,sync,tracked
ReplicationTracker -> CheckpointState -> public CheckpointState copy();1549949489;Returns a full copy of this object;public CheckpointState copy() {_            return new CheckpointState(localCheckpoint, globalCheckpoint, inSync, tracked)__        };returns,a,full,copy,of,this,object;public,checkpoint,state,copy,return,new,checkpoint,state,local,checkpoint,global,checkpoint,in,sync,tracked
ReplicationTracker -> CheckpointState -> public CheckpointState copy();1550526771;Returns a full copy of this object;public CheckpointState copy() {_            return new CheckpointState(localCheckpoint, globalCheckpoint, inSync, tracked)__        };returns,a,full,copy,of,this,object;public,checkpoint,state,copy,return,new,checkpoint,state,local,checkpoint,global,checkpoint,in,sync,tracked
ReplicationTracker -> public synchronized void completeRelocationHandoff();1524684173;Marks a relocation handoff attempt as successful. Moves the tracker into replica mode.;public synchronized void completeRelocationHandoff() {_        assert invariant()__        assert primaryMode__        assert handoffInProgress__        primaryMode = false__        handoffInProgress = false__        _        checkpoints.entrySet().stream().forEach(e -> {_            final CheckpointState cps = e.getValue()__            if (cps.localCheckpoint != SequenceNumbers.UNASSIGNED_SEQ_NO &&_                cps.localCheckpoint != SequenceNumbers.PRE_60_NODE_CHECKPOINT) {_                cps.localCheckpoint = SequenceNumbers.UNASSIGNED_SEQ_NO__            }_            if (e.getKey().equals(shardAllocationId) == false) {_                _                if (cps.globalCheckpoint != SequenceNumbers.UNASSIGNED_SEQ_NO &&_                    cps.globalCheckpoint != SequenceNumbers.PRE_60_NODE_CHECKPOINT) {_                    cps.globalCheckpoint = SequenceNumbers.UNASSIGNED_SEQ_NO__                }_            }_        })__        assert invariant()__    };marks,a,relocation,handoff,attempt,as,successful,moves,the,tracker,into,replica,mode;public,synchronized,void,complete,relocation,handoff,assert,invariant,assert,primary,mode,assert,handoff,in,progress,primary,mode,false,handoff,in,progress,false,checkpoints,entry,set,stream,for,each,e,final,checkpoint,state,cps,e,get,value,if,cps,local,checkpoint,sequence,numbers,cps,local,checkpoint,sequence,numbers,cps,local,checkpoint,sequence,numbers,if,e,get,key,equals,shard,allocation,id,false,if,cps,global,checkpoint,sequence,numbers,cps,global,checkpoint,sequence,numbers,cps,global,checkpoint,sequence,numbers,assert,invariant
ReplicationTracker -> public synchronized void completeRelocationHandoff();1525334055;Marks a relocation handoff attempt as successful. Moves the tracker into replica mode.;public synchronized void completeRelocationHandoff() {_        assert invariant()__        assert primaryMode__        assert handoffInProgress__        primaryMode = false__        handoffInProgress = false__        _        checkpoints.entrySet().stream().forEach(e -> {_            final CheckpointState cps = e.getValue()__            if (cps.localCheckpoint != SequenceNumbers.UNASSIGNED_SEQ_NO &&_                cps.localCheckpoint != SequenceNumbers.PRE_60_NODE_CHECKPOINT) {_                cps.localCheckpoint = SequenceNumbers.UNASSIGNED_SEQ_NO__            }_            if (e.getKey().equals(shardAllocationId) == false) {_                _                if (cps.globalCheckpoint != SequenceNumbers.UNASSIGNED_SEQ_NO &&_                    cps.globalCheckpoint != SequenceNumbers.PRE_60_NODE_CHECKPOINT) {_                    cps.globalCheckpoint = SequenceNumbers.UNASSIGNED_SEQ_NO__                }_            }_        })__        assert invariant()__    };marks,a,relocation,handoff,attempt,as,successful,moves,the,tracker,into,replica,mode;public,synchronized,void,complete,relocation,handoff,assert,invariant,assert,primary,mode,assert,handoff,in,progress,primary,mode,false,handoff,in,progress,false,checkpoints,entry,set,stream,for,each,e,final,checkpoint,state,cps,e,get,value,if,cps,local,checkpoint,sequence,numbers,cps,local,checkpoint,sequence,numbers,cps,local,checkpoint,sequence,numbers,if,e,get,key,equals,shard,allocation,id,false,if,cps,global,checkpoint,sequence,numbers,cps,global,checkpoint,sequence,numbers,cps,global,checkpoint,sequence,numbers,assert,invariant
ReplicationTracker -> public synchronized void completeRelocationHandoff();1533295538;Marks a relocation handoff attempt as successful. Moves the tracker into replica mode.;public synchronized void completeRelocationHandoff() {_        assert invariant()__        assert primaryMode__        assert handoffInProgress__        assert relocated == false__        primaryMode = false__        handoffInProgress = false__        relocated = true__        _        checkpoints.entrySet().stream().forEach(e -> {_            final CheckpointState cps = e.getValue()__            if (cps.localCheckpoint != SequenceNumbers.UNASSIGNED_SEQ_NO &&_                cps.localCheckpoint != SequenceNumbers.PRE_60_NODE_CHECKPOINT) {_                cps.localCheckpoint = SequenceNumbers.UNASSIGNED_SEQ_NO__            }_            if (e.getKey().equals(shardAllocationId) == false) {_                _                if (cps.globalCheckpoint != SequenceNumbers.UNASSIGNED_SEQ_NO &&_                    cps.globalCheckpoint != SequenceNumbers.PRE_60_NODE_CHECKPOINT) {_                    cps.globalCheckpoint = SequenceNumbers.UNASSIGNED_SEQ_NO__                }_            }_        })__        assert invariant()__    };marks,a,relocation,handoff,attempt,as,successful,moves,the,tracker,into,replica,mode;public,synchronized,void,complete,relocation,handoff,assert,invariant,assert,primary,mode,assert,handoff,in,progress,assert,relocated,false,primary,mode,false,handoff,in,progress,false,relocated,true,checkpoints,entry,set,stream,for,each,e,final,checkpoint,state,cps,e,get,value,if,cps,local,checkpoint,sequence,numbers,cps,local,checkpoint,sequence,numbers,cps,local,checkpoint,sequence,numbers,if,e,get,key,equals,shard,allocation,id,false,if,cps,global,checkpoint,sequence,numbers,cps,global,checkpoint,sequence,numbers,cps,global,checkpoint,sequence,numbers,assert,invariant
ReplicationTracker -> public synchronized void completeRelocationHandoff();1533738061;Marks a relocation handoff attempt as successful. Moves the tracker into replica mode.;public synchronized void completeRelocationHandoff() {_        assert invariant()__        assert primaryMode__        assert handoffInProgress__        assert relocated == false__        primaryMode = false__        handoffInProgress = false__        relocated = true__        _        checkpoints.entrySet().stream().forEach(e -> {_            final CheckpointState cps = e.getValue()__            if (cps.localCheckpoint != SequenceNumbers.UNASSIGNED_SEQ_NO &&_                cps.localCheckpoint != SequenceNumbers.PRE_60_NODE_CHECKPOINT) {_                cps.localCheckpoint = SequenceNumbers.UNASSIGNED_SEQ_NO__            }_            if (e.getKey().equals(shardAllocationId) == false) {_                _                if (cps.globalCheckpoint != SequenceNumbers.UNASSIGNED_SEQ_NO &&_                    cps.globalCheckpoint != SequenceNumbers.PRE_60_NODE_CHECKPOINT) {_                    cps.globalCheckpoint = SequenceNumbers.UNASSIGNED_SEQ_NO__                }_            }_        })__        assert invariant()__    };marks,a,relocation,handoff,attempt,as,successful,moves,the,tracker,into,replica,mode;public,synchronized,void,complete,relocation,handoff,assert,invariant,assert,primary,mode,assert,handoff,in,progress,assert,relocated,false,primary,mode,false,handoff,in,progress,false,relocated,true,checkpoints,entry,set,stream,for,each,e,final,checkpoint,state,cps,e,get,value,if,cps,local,checkpoint,sequence,numbers,cps,local,checkpoint,sequence,numbers,cps,local,checkpoint,sequence,numbers,if,e,get,key,equals,shard,allocation,id,false,if,cps,global,checkpoint,sequence,numbers,cps,global,checkpoint,sequence,numbers,cps,global,checkpoint,sequence,numbers,assert,invariant
ReplicationTracker -> public synchronized void completeRelocationHandoff();1546875837;Marks a relocation handoff attempt as successful. Moves the tracker into replica mode.;public synchronized void completeRelocationHandoff() {_        assert invariant()__        assert primaryMode__        assert handoffInProgress__        assert relocated == false__        primaryMode = false__        handoffInProgress = false__        relocated = true__        _        checkpoints.entrySet().stream().forEach(e -> {_            final CheckpointState cps = e.getValue()__            if (cps.localCheckpoint != SequenceNumbers.UNASSIGNED_SEQ_NO &&_                cps.localCheckpoint != SequenceNumbers.PRE_60_NODE_CHECKPOINT) {_                cps.localCheckpoint = SequenceNumbers.UNASSIGNED_SEQ_NO__            }_            if (e.getKey().equals(shardAllocationId) == false) {_                _                if (cps.globalCheckpoint != SequenceNumbers.UNASSIGNED_SEQ_NO &&_                    cps.globalCheckpoint != SequenceNumbers.PRE_60_NODE_CHECKPOINT) {_                    cps.globalCheckpoint = SequenceNumbers.UNASSIGNED_SEQ_NO__                }_            }_        })__        assert invariant()__    };marks,a,relocation,handoff,attempt,as,successful,moves,the,tracker,into,replica,mode;public,synchronized,void,complete,relocation,handoff,assert,invariant,assert,primary,mode,assert,handoff,in,progress,assert,relocated,false,primary,mode,false,handoff,in,progress,false,relocated,true,checkpoints,entry,set,stream,for,each,e,final,checkpoint,state,cps,e,get,value,if,cps,local,checkpoint,sequence,numbers,cps,local,checkpoint,sequence,numbers,cps,local,checkpoint,sequence,numbers,if,e,get,key,equals,shard,allocation,id,false,if,cps,global,checkpoint,sequence,numbers,cps,global,checkpoint,sequence,numbers,cps,global,checkpoint,sequence,numbers,assert,invariant
ReplicationTracker -> public synchronized void completeRelocationHandoff();1546927432;Marks a relocation handoff attempt as successful. Moves the tracker into replica mode.;public synchronized void completeRelocationHandoff() {_        assert invariant()__        assert primaryMode__        assert handoffInProgress__        assert relocated == false__        primaryMode = false__        handoffInProgress = false__        relocated = true__        _        checkpoints.entrySet().stream().forEach(e -> {_            final CheckpointState cps = e.getValue()__            if (cps.localCheckpoint != SequenceNumbers.UNASSIGNED_SEQ_NO &&_                cps.localCheckpoint != SequenceNumbers.PRE_60_NODE_CHECKPOINT) {_                cps.localCheckpoint = SequenceNumbers.UNASSIGNED_SEQ_NO__            }_            if (e.getKey().equals(shardAllocationId) == false) {_                _                if (cps.globalCheckpoint != SequenceNumbers.UNASSIGNED_SEQ_NO &&_                    cps.globalCheckpoint != SequenceNumbers.PRE_60_NODE_CHECKPOINT) {_                    cps.globalCheckpoint = SequenceNumbers.UNASSIGNED_SEQ_NO__                }_            }_        })__        assert invariant()__    };marks,a,relocation,handoff,attempt,as,successful,moves,the,tracker,into,replica,mode;public,synchronized,void,complete,relocation,handoff,assert,invariant,assert,primary,mode,assert,handoff,in,progress,assert,relocated,false,primary,mode,false,handoff,in,progress,false,relocated,true,checkpoints,entry,set,stream,for,each,e,final,checkpoint,state,cps,e,get,value,if,cps,local,checkpoint,sequence,numbers,cps,local,checkpoint,sequence,numbers,cps,local,checkpoint,sequence,numbers,if,e,get,key,equals,shard,allocation,id,false,if,cps,global,checkpoint,sequence,numbers,cps,global,checkpoint,sequence,numbers,cps,global,checkpoint,sequence,numbers,assert,invariant
ReplicationTracker -> public synchronized void completeRelocationHandoff();1547332999;Marks a relocation handoff attempt as successful. Moves the tracker into replica mode.;public synchronized void completeRelocationHandoff() {_        assert invariant()__        assert primaryMode__        assert handoffInProgress__        assert relocated == false__        primaryMode = false__        handoffInProgress = false__        relocated = true__        _        checkpoints.entrySet().stream().forEach(e -> {_            final CheckpointState cps = e.getValue()__            if (cps.localCheckpoint != SequenceNumbers.UNASSIGNED_SEQ_NO &&_                cps.localCheckpoint != SequenceNumbers.PRE_60_NODE_CHECKPOINT) {_                cps.localCheckpoint = SequenceNumbers.UNASSIGNED_SEQ_NO__            }_            if (e.getKey().equals(shardAllocationId) == false) {_                _                if (cps.globalCheckpoint != SequenceNumbers.UNASSIGNED_SEQ_NO &&_                    cps.globalCheckpoint != SequenceNumbers.PRE_60_NODE_CHECKPOINT) {_                    cps.globalCheckpoint = SequenceNumbers.UNASSIGNED_SEQ_NO__                }_            }_        })__        assert invariant()__    };marks,a,relocation,handoff,attempt,as,successful,moves,the,tracker,into,replica,mode;public,synchronized,void,complete,relocation,handoff,assert,invariant,assert,primary,mode,assert,handoff,in,progress,assert,relocated,false,primary,mode,false,handoff,in,progress,false,relocated,true,checkpoints,entry,set,stream,for,each,e,final,checkpoint,state,cps,e,get,value,if,cps,local,checkpoint,sequence,numbers,cps,local,checkpoint,sequence,numbers,cps,local,checkpoint,sequence,numbers,if,e,get,key,equals,shard,allocation,id,false,if,cps,global,checkpoint,sequence,numbers,cps,global,checkpoint,sequence,numbers,cps,global,checkpoint,sequence,numbers,assert,invariant
ReplicationTracker -> public synchronized void completeRelocationHandoff();1548593396;Marks a relocation handoff attempt as successful. Moves the tracker into replica mode.;public synchronized void completeRelocationHandoff() {_        assert invariant()__        assert primaryMode__        assert handoffInProgress__        assert relocated == false__        primaryMode = false__        handoffInProgress = false__        relocated = true__        _        checkpoints.entrySet().stream().forEach(e -> {_            final CheckpointState cps = e.getValue()__            if (cps.localCheckpoint != SequenceNumbers.UNASSIGNED_SEQ_NO &&_                cps.localCheckpoint != SequenceNumbers.PRE_60_NODE_CHECKPOINT) {_                cps.localCheckpoint = SequenceNumbers.UNASSIGNED_SEQ_NO__            }_            if (e.getKey().equals(shardAllocationId) == false) {_                _                if (cps.globalCheckpoint != SequenceNumbers.UNASSIGNED_SEQ_NO &&_                    cps.globalCheckpoint != SequenceNumbers.PRE_60_NODE_CHECKPOINT) {_                    cps.globalCheckpoint = SequenceNumbers.UNASSIGNED_SEQ_NO__                }_            }_        })__        assert invariant()__    };marks,a,relocation,handoff,attempt,as,successful,moves,the,tracker,into,replica,mode;public,synchronized,void,complete,relocation,handoff,assert,invariant,assert,primary,mode,assert,handoff,in,progress,assert,relocated,false,primary,mode,false,handoff,in,progress,false,relocated,true,checkpoints,entry,set,stream,for,each,e,final,checkpoint,state,cps,e,get,value,if,cps,local,checkpoint,sequence,numbers,cps,local,checkpoint,sequence,numbers,cps,local,checkpoint,sequence,numbers,if,e,get,key,equals,shard,allocation,id,false,if,cps,global,checkpoint,sequence,numbers,cps,global,checkpoint,sequence,numbers,cps,global,checkpoint,sequence,numbers,assert,invariant
ReplicationTracker -> public synchronized void completeRelocationHandoff();1548594827;Marks a relocation handoff attempt as successful. Moves the tracker into replica mode.;public synchronized void completeRelocationHandoff() {_        assert invariant()__        assert primaryMode__        assert handoffInProgress__        assert relocated == false__        primaryMode = false__        handoffInProgress = false__        relocated = true__        _        checkpoints.entrySet().stream().forEach(e -> {_            final CheckpointState cps = e.getValue()__            if (cps.localCheckpoint != SequenceNumbers.UNASSIGNED_SEQ_NO &&_                cps.localCheckpoint != SequenceNumbers.PRE_60_NODE_CHECKPOINT) {_                cps.localCheckpoint = SequenceNumbers.UNASSIGNED_SEQ_NO__            }_            if (e.getKey().equals(shardAllocationId) == false) {_                _                if (cps.globalCheckpoint != SequenceNumbers.UNASSIGNED_SEQ_NO &&_                    cps.globalCheckpoint != SequenceNumbers.PRE_60_NODE_CHECKPOINT) {_                    cps.globalCheckpoint = SequenceNumbers.UNASSIGNED_SEQ_NO__                }_            }_        })__        assert invariant()__    };marks,a,relocation,handoff,attempt,as,successful,moves,the,tracker,into,replica,mode;public,synchronized,void,complete,relocation,handoff,assert,invariant,assert,primary,mode,assert,handoff,in,progress,assert,relocated,false,primary,mode,false,handoff,in,progress,false,relocated,true,checkpoints,entry,set,stream,for,each,e,final,checkpoint,state,cps,e,get,value,if,cps,local,checkpoint,sequence,numbers,cps,local,checkpoint,sequence,numbers,cps,local,checkpoint,sequence,numbers,if,e,get,key,equals,shard,allocation,id,false,if,cps,global,checkpoint,sequence,numbers,cps,global,checkpoint,sequence,numbers,cps,global,checkpoint,sequence,numbers,assert,invariant
ReplicationTracker -> public synchronized void completeRelocationHandoff();1548677511;Marks a relocation handoff attempt as successful. Moves the tracker into replica mode.;public synchronized void completeRelocationHandoff() {_        assert invariant()__        assert primaryMode__        assert handoffInProgress__        assert relocated == false__        primaryMode = false__        handoffInProgress = false__        relocated = true__        _        checkpoints.entrySet().stream().forEach(e -> {_            final CheckpointState cps = e.getValue()__            if (cps.localCheckpoint != SequenceNumbers.UNASSIGNED_SEQ_NO &&_                cps.localCheckpoint != SequenceNumbers.PRE_60_NODE_CHECKPOINT) {_                cps.localCheckpoint = SequenceNumbers.UNASSIGNED_SEQ_NO__            }_            if (e.getKey().equals(shardAllocationId) == false) {_                _                if (cps.globalCheckpoint != SequenceNumbers.UNASSIGNED_SEQ_NO &&_                    cps.globalCheckpoint != SequenceNumbers.PRE_60_NODE_CHECKPOINT) {_                    cps.globalCheckpoint = SequenceNumbers.UNASSIGNED_SEQ_NO__                }_            }_        })__        assert invariant()__    };marks,a,relocation,handoff,attempt,as,successful,moves,the,tracker,into,replica,mode;public,synchronized,void,complete,relocation,handoff,assert,invariant,assert,primary,mode,assert,handoff,in,progress,assert,relocated,false,primary,mode,false,handoff,in,progress,false,relocated,true,checkpoints,entry,set,stream,for,each,e,final,checkpoint,state,cps,e,get,value,if,cps,local,checkpoint,sequence,numbers,cps,local,checkpoint,sequence,numbers,cps,local,checkpoint,sequence,numbers,if,e,get,key,equals,shard,allocation,id,false,if,cps,global,checkpoint,sequence,numbers,cps,global,checkpoint,sequence,numbers,cps,global,checkpoint,sequence,numbers,assert,invariant
ReplicationTracker -> public synchronized void completeRelocationHandoff();1548944389;Marks a relocation handoff attempt as successful. Moves the tracker into replica mode.;public synchronized void completeRelocationHandoff() {_        assert invariant()__        assert primaryMode__        assert handoffInProgress__        assert relocated == false__        primaryMode = false__        handoffInProgress = false__        relocated = true__        _        checkpoints.entrySet().stream().forEach(e -> {_            final CheckpointState cps = e.getValue()__            if (cps.localCheckpoint != SequenceNumbers.UNASSIGNED_SEQ_NO &&_                cps.localCheckpoint != SequenceNumbers.PRE_60_NODE_CHECKPOINT) {_                cps.localCheckpoint = SequenceNumbers.UNASSIGNED_SEQ_NO__            }_            if (e.getKey().equals(shardAllocationId) == false) {_                _                if (cps.globalCheckpoint != SequenceNumbers.UNASSIGNED_SEQ_NO &&_                    cps.globalCheckpoint != SequenceNumbers.PRE_60_NODE_CHECKPOINT) {_                    cps.globalCheckpoint = SequenceNumbers.UNASSIGNED_SEQ_NO__                }_            }_        })__        assert invariant()__    };marks,a,relocation,handoff,attempt,as,successful,moves,the,tracker,into,replica,mode;public,synchronized,void,complete,relocation,handoff,assert,invariant,assert,primary,mode,assert,handoff,in,progress,assert,relocated,false,primary,mode,false,handoff,in,progress,false,relocated,true,checkpoints,entry,set,stream,for,each,e,final,checkpoint,state,cps,e,get,value,if,cps,local,checkpoint,sequence,numbers,cps,local,checkpoint,sequence,numbers,cps,local,checkpoint,sequence,numbers,if,e,get,key,equals,shard,allocation,id,false,if,cps,global,checkpoint,sequence,numbers,cps,global,checkpoint,sequence,numbers,cps,global,checkpoint,sequence,numbers,assert,invariant
ReplicationTracker -> public synchronized void completeRelocationHandoff();1549059559;Marks a relocation handoff attempt as successful. Moves the tracker into replica mode.;public synchronized void completeRelocationHandoff() {_        assert invariant()__        assert primaryMode__        assert handoffInProgress__        assert relocated == false__        primaryMode = false__        handoffInProgress = false__        relocated = true__        _        checkpoints.entrySet().stream().forEach(e -> {_            final CheckpointState cps = e.getValue()__            if (cps.localCheckpoint != SequenceNumbers.UNASSIGNED_SEQ_NO &&_                cps.localCheckpoint != SequenceNumbers.PRE_60_NODE_CHECKPOINT) {_                cps.localCheckpoint = SequenceNumbers.UNASSIGNED_SEQ_NO__            }_            if (e.getKey().equals(shardAllocationId) == false) {_                _                if (cps.globalCheckpoint != SequenceNumbers.UNASSIGNED_SEQ_NO &&_                    cps.globalCheckpoint != SequenceNumbers.PRE_60_NODE_CHECKPOINT) {_                    cps.globalCheckpoint = SequenceNumbers.UNASSIGNED_SEQ_NO__                }_            }_        })__        assert invariant()__    };marks,a,relocation,handoff,attempt,as,successful,moves,the,tracker,into,replica,mode;public,synchronized,void,complete,relocation,handoff,assert,invariant,assert,primary,mode,assert,handoff,in,progress,assert,relocated,false,primary,mode,false,handoff,in,progress,false,relocated,true,checkpoints,entry,set,stream,for,each,e,final,checkpoint,state,cps,e,get,value,if,cps,local,checkpoint,sequence,numbers,cps,local,checkpoint,sequence,numbers,cps,local,checkpoint,sequence,numbers,if,e,get,key,equals,shard,allocation,id,false,if,cps,global,checkpoint,sequence,numbers,cps,global,checkpoint,sequence,numbers,cps,global,checkpoint,sequence,numbers,assert,invariant
ReplicationTracker -> public synchronized void completeRelocationHandoff();1549294529;Marks a relocation handoff attempt as successful. Moves the tracker into replica mode.;public synchronized void completeRelocationHandoff() {_        assert invariant()__        assert primaryMode__        assert handoffInProgress__        assert relocated == false__        primaryMode = false__        handoffInProgress = false__        relocated = true__        _        checkpoints.entrySet().stream().forEach(e -> {_            final CheckpointState cps = e.getValue()__            if (cps.localCheckpoint != SequenceNumbers.UNASSIGNED_SEQ_NO &&_                cps.localCheckpoint != SequenceNumbers.PRE_60_NODE_CHECKPOINT) {_                cps.localCheckpoint = SequenceNumbers.UNASSIGNED_SEQ_NO__            }_            if (e.getKey().equals(shardAllocationId) == false) {_                _                if (cps.globalCheckpoint != SequenceNumbers.UNASSIGNED_SEQ_NO &&_                    cps.globalCheckpoint != SequenceNumbers.PRE_60_NODE_CHECKPOINT) {_                    cps.globalCheckpoint = SequenceNumbers.UNASSIGNED_SEQ_NO__                }_            }_        })__        assert invariant()__    };marks,a,relocation,handoff,attempt,as,successful,moves,the,tracker,into,replica,mode;public,synchronized,void,complete,relocation,handoff,assert,invariant,assert,primary,mode,assert,handoff,in,progress,assert,relocated,false,primary,mode,false,handoff,in,progress,false,relocated,true,checkpoints,entry,set,stream,for,each,e,final,checkpoint,state,cps,e,get,value,if,cps,local,checkpoint,sequence,numbers,cps,local,checkpoint,sequence,numbers,cps,local,checkpoint,sequence,numbers,if,e,get,key,equals,shard,allocation,id,false,if,cps,global,checkpoint,sequence,numbers,cps,global,checkpoint,sequence,numbers,cps,global,checkpoint,sequence,numbers,assert,invariant
ReplicationTracker -> public synchronized void completeRelocationHandoff();1549395737;Marks a relocation handoff attempt as successful. Moves the tracker into replica mode.;public synchronized void completeRelocationHandoff() {_        assert invariant()__        assert primaryMode__        assert handoffInProgress__        assert relocated == false__        primaryMode = false__        handoffInProgress = false__        relocated = true__        _        checkpoints.entrySet().stream().forEach(e -> {_            final CheckpointState cps = e.getValue()__            if (cps.localCheckpoint != SequenceNumbers.UNASSIGNED_SEQ_NO &&_                cps.localCheckpoint != SequenceNumbers.PRE_60_NODE_CHECKPOINT) {_                cps.localCheckpoint = SequenceNumbers.UNASSIGNED_SEQ_NO__            }_            if (e.getKey().equals(shardAllocationId) == false) {_                _                if (cps.globalCheckpoint != SequenceNumbers.UNASSIGNED_SEQ_NO &&_                    cps.globalCheckpoint != SequenceNumbers.PRE_60_NODE_CHECKPOINT) {_                    cps.globalCheckpoint = SequenceNumbers.UNASSIGNED_SEQ_NO__                }_            }_        })__        assert invariant()__    };marks,a,relocation,handoff,attempt,as,successful,moves,the,tracker,into,replica,mode;public,synchronized,void,complete,relocation,handoff,assert,invariant,assert,primary,mode,assert,handoff,in,progress,assert,relocated,false,primary,mode,false,handoff,in,progress,false,relocated,true,checkpoints,entry,set,stream,for,each,e,final,checkpoint,state,cps,e,get,value,if,cps,local,checkpoint,sequence,numbers,cps,local,checkpoint,sequence,numbers,cps,local,checkpoint,sequence,numbers,if,e,get,key,equals,shard,allocation,id,false,if,cps,global,checkpoint,sequence,numbers,cps,global,checkpoint,sequence,numbers,cps,global,checkpoint,sequence,numbers,assert,invariant
ReplicationTracker -> public synchronized void completeRelocationHandoff();1549937843;Marks a relocation handoff attempt as successful. Moves the tracker into replica mode.;public synchronized void completeRelocationHandoff() {_        assert invariant()__        assert primaryMode__        assert handoffInProgress__        assert relocated == false__        primaryMode = false__        handoffInProgress = false__        relocated = true__        _        checkpoints.entrySet().stream().forEach(e -> {_            final CheckpointState cps = e.getValue()__            if (cps.localCheckpoint != SequenceNumbers.UNASSIGNED_SEQ_NO &&_                cps.localCheckpoint != SequenceNumbers.PRE_60_NODE_CHECKPOINT) {_                cps.localCheckpoint = SequenceNumbers.UNASSIGNED_SEQ_NO__            }_            if (e.getKey().equals(shardAllocationId) == false) {_                _                if (cps.globalCheckpoint != SequenceNumbers.UNASSIGNED_SEQ_NO &&_                    cps.globalCheckpoint != SequenceNumbers.PRE_60_NODE_CHECKPOINT) {_                    cps.globalCheckpoint = SequenceNumbers.UNASSIGNED_SEQ_NO__                }_            }_        })__        assert invariant()__    };marks,a,relocation,handoff,attempt,as,successful,moves,the,tracker,into,replica,mode;public,synchronized,void,complete,relocation,handoff,assert,invariant,assert,primary,mode,assert,handoff,in,progress,assert,relocated,false,primary,mode,false,handoff,in,progress,false,relocated,true,checkpoints,entry,set,stream,for,each,e,final,checkpoint,state,cps,e,get,value,if,cps,local,checkpoint,sequence,numbers,cps,local,checkpoint,sequence,numbers,cps,local,checkpoint,sequence,numbers,if,e,get,key,equals,shard,allocation,id,false,if,cps,global,checkpoint,sequence,numbers,cps,global,checkpoint,sequence,numbers,cps,global,checkpoint,sequence,numbers,assert,invariant
ReplicationTracker -> public synchronized void completeRelocationHandoff();1549949489;Marks a relocation handoff attempt as successful. Moves the tracker into replica mode.;public synchronized void completeRelocationHandoff() {_        assert invariant()__        assert primaryMode__        assert handoffInProgress__        assert relocated == false__        primaryMode = false__        handoffInProgress = false__        relocated = true__        _        checkpoints.entrySet().stream().forEach(e -> {_            final CheckpointState cps = e.getValue()__            if (cps.localCheckpoint != SequenceNumbers.UNASSIGNED_SEQ_NO &&_                cps.localCheckpoint != SequenceNumbers.PRE_60_NODE_CHECKPOINT) {_                cps.localCheckpoint = SequenceNumbers.UNASSIGNED_SEQ_NO__            }_            if (e.getKey().equals(shardAllocationId) == false) {_                _                if (cps.globalCheckpoint != SequenceNumbers.UNASSIGNED_SEQ_NO &&_                    cps.globalCheckpoint != SequenceNumbers.PRE_60_NODE_CHECKPOINT) {_                    cps.globalCheckpoint = SequenceNumbers.UNASSIGNED_SEQ_NO__                }_            }_        })__        assert invariant()__    };marks,a,relocation,handoff,attempt,as,successful,moves,the,tracker,into,replica,mode;public,synchronized,void,complete,relocation,handoff,assert,invariant,assert,primary,mode,assert,handoff,in,progress,assert,relocated,false,primary,mode,false,handoff,in,progress,false,relocated,true,checkpoints,entry,set,stream,for,each,e,final,checkpoint,state,cps,e,get,value,if,cps,local,checkpoint,sequence,numbers,cps,local,checkpoint,sequence,numbers,cps,local,checkpoint,sequence,numbers,if,e,get,key,equals,shard,allocation,id,false,if,cps,global,checkpoint,sequence,numbers,cps,global,checkpoint,sequence,numbers,cps,global,checkpoint,sequence,numbers,assert,invariant
ReplicationTracker -> public synchronized void completeRelocationHandoff();1550526771;Marks a relocation handoff attempt as successful. Moves the tracker into replica mode.;public synchronized void completeRelocationHandoff() {_        assert invariant()__        assert primaryMode__        assert handoffInProgress__        assert relocated == false__        primaryMode = false__        handoffInProgress = false__        relocated = true__        _        checkpoints.entrySet().stream().forEach(e -> {_            final CheckpointState cps = e.getValue()__            if (cps.localCheckpoint != SequenceNumbers.UNASSIGNED_SEQ_NO &&_                cps.localCheckpoint != SequenceNumbers.PRE_60_NODE_CHECKPOINT) {_                cps.localCheckpoint = SequenceNumbers.UNASSIGNED_SEQ_NO__            }_            if (e.getKey().equals(shardAllocationId) == false) {_                _                if (cps.globalCheckpoint != SequenceNumbers.UNASSIGNED_SEQ_NO &&_                    cps.globalCheckpoint != SequenceNumbers.PRE_60_NODE_CHECKPOINT) {_                    cps.globalCheckpoint = SequenceNumbers.UNASSIGNED_SEQ_NO__                }_            }_        })__        assert invariant()__    };marks,a,relocation,handoff,attempt,as,successful,moves,the,tracker,into,replica,mode;public,synchronized,void,complete,relocation,handoff,assert,invariant,assert,primary,mode,assert,handoff,in,progress,assert,relocated,false,primary,mode,false,handoff,in,progress,false,relocated,true,checkpoints,entry,set,stream,for,each,e,final,checkpoint,state,cps,e,get,value,if,cps,local,checkpoint,sequence,numbers,cps,local,checkpoint,sequence,numbers,cps,local,checkpoint,sequence,numbers,if,e,get,key,equals,shard,allocation,id,false,if,cps,global,checkpoint,sequence,numbers,cps,global,checkpoint,sequence,numbers,cps,global,checkpoint,sequence,numbers,assert,invariant
ReplicationTracker -> public synchronized RetentionLease renewRetentionLease(final String id, final long retainingSequenceNumber, final String source);1548593396;Renews an existing retention lease.__@param id                      the identifier of the retention lease_@param retainingSequenceNumber the retaining sequence number_@param source                  the source of the retention lease_@return the renewed retention lease_@throws IllegalArgumentException if the specified retention lease does not exist;public synchronized RetentionLease renewRetentionLease(final String id, final long retainingSequenceNumber, final String source) {_        assert primaryMode__        if (retentionLeases.containsKey(id) == false) {_            throw new IllegalArgumentException("retention lease with ID [" + id + "] does not exist")__        }_        final RetentionLease retentionLease =_                new RetentionLease(id, retainingSequenceNumber, currentTimeMillisSupplier.getAsLong(), source)__        final RetentionLease existingRetentionLease = retentionLeases.put(id, retentionLease)__        assert existingRetentionLease != null__        assert existingRetentionLease.retainingSequenceNumber() <= retentionLease.retainingSequenceNumber() :_                "retention lease renewal for [" + id + "]"_                        + " from [" + source + "]"_                        + " renewed a lower retaining sequence number [" + retentionLease.retainingSequenceNumber() + "]"_                        + " than the current lease retaining sequence number [" + existingRetentionLease.retainingSequenceNumber() + "]"__        return retentionLease__    };renews,an,existing,retention,lease,param,id,the,identifier,of,the,retention,lease,param,retaining,sequence,number,the,retaining,sequence,number,param,source,the,source,of,the,retention,lease,return,the,renewed,retention,lease,throws,illegal,argument,exception,if,the,specified,retention,lease,does,not,exist;public,synchronized,retention,lease,renew,retention,lease,final,string,id,final,long,retaining,sequence,number,final,string,source,assert,primary,mode,if,retention,leases,contains,key,id,false,throw,new,illegal,argument,exception,retention,lease,with,id,id,does,not,exist,final,retention,lease,retention,lease,new,retention,lease,id,retaining,sequence,number,current,time,millis,supplier,get,as,long,source,final,retention,lease,existing,retention,lease,retention,leases,put,id,retention,lease,assert,existing,retention,lease,null,assert,existing,retention,lease,retaining,sequence,number,retention,lease,retaining,sequence,number,retention,lease,renewal,for,id,from,source,renewed,a,lower,retaining,sequence,number,retention,lease,retaining,sequence,number,than,the,current,lease,retaining,sequence,number,existing,retention,lease,retaining,sequence,number,return,retention,lease
ReplicationTracker -> public synchronized RetentionLease renewRetentionLease(final String id, final long retainingSequenceNumber, final String source);1548594827;Renews an existing retention lease.__@param id                      the identifier of the retention lease_@param retainingSequenceNumber the retaining sequence number_@param source                  the source of the retention lease_@return the renewed retention lease_@throws IllegalArgumentException if the specified retention lease does not exist;public synchronized RetentionLease renewRetentionLease(final String id, final long retainingSequenceNumber, final String source) {_        assert primaryMode__        if (retentionLeases.containsKey(id) == false) {_            throw new IllegalArgumentException("retention lease with ID [" + id + "] does not exist")__        }_        final RetentionLease retentionLease =_                new RetentionLease(id, retainingSequenceNumber, currentTimeMillisSupplier.getAsLong(), source)__        final RetentionLease existingRetentionLease = retentionLeases.put(id, retentionLease)__        assert existingRetentionLease != null__        assert existingRetentionLease.retainingSequenceNumber() <= retentionLease.retainingSequenceNumber() :_                "retention lease renewal for [" + id + "]"_                        + " from [" + source + "]"_                        + " renewed a lower retaining sequence number [" + retentionLease.retainingSequenceNumber() + "]"_                        + " than the current lease retaining sequence number [" + existingRetentionLease.retainingSequenceNumber() + "]"__        return retentionLease__    };renews,an,existing,retention,lease,param,id,the,identifier,of,the,retention,lease,param,retaining,sequence,number,the,retaining,sequence,number,param,source,the,source,of,the,retention,lease,return,the,renewed,retention,lease,throws,illegal,argument,exception,if,the,specified,retention,lease,does,not,exist;public,synchronized,retention,lease,renew,retention,lease,final,string,id,final,long,retaining,sequence,number,final,string,source,assert,primary,mode,if,retention,leases,contains,key,id,false,throw,new,illegal,argument,exception,retention,lease,with,id,id,does,not,exist,final,retention,lease,retention,lease,new,retention,lease,id,retaining,sequence,number,current,time,millis,supplier,get,as,long,source,final,retention,lease,existing,retention,lease,retention,leases,put,id,retention,lease,assert,existing,retention,lease,null,assert,existing,retention,lease,retaining,sequence,number,retention,lease,retaining,sequence,number,retention,lease,renewal,for,id,from,source,renewed,a,lower,retaining,sequence,number,retention,lease,retaining,sequence,number,than,the,current,lease,retaining,sequence,number,existing,retention,lease,retaining,sequence,number,return,retention,lease
ReplicationTracker -> public synchronized RetentionLease renewRetentionLease(final String id, final long retainingSequenceNumber, final String source);1548677511;Renews an existing retention lease.__@param id                      the identifier of the retention lease_@param retainingSequenceNumber the retaining sequence number_@param source                  the source of the retention lease_@return the renewed retention lease_@throws IllegalArgumentException if the specified retention lease does not exist;public synchronized RetentionLease renewRetentionLease(final String id, final long retainingSequenceNumber, final String source) {_        assert primaryMode__        if (retentionLeases.containsKey(id) == false) {_            throw new IllegalArgumentException("retention lease with ID [" + id + "] does not exist")__        }_        final RetentionLease retentionLease =_                new RetentionLease(id, retainingSequenceNumber, currentTimeMillisSupplier.getAsLong(), source)__        final RetentionLease existingRetentionLease = retentionLeases.put(id, retentionLease)__        assert existingRetentionLease != null__        assert existingRetentionLease.retainingSequenceNumber() <= retentionLease.retainingSequenceNumber() :_                "retention lease renewal for [" + id + "]"_                        + " from [" + source + "]"_                        + " renewed a lower retaining sequence number [" + retentionLease.retainingSequenceNumber() + "]"_                        + " than the current lease retaining sequence number [" + existingRetentionLease.retainingSequenceNumber() + "]"__        return retentionLease__    };renews,an,existing,retention,lease,param,id,the,identifier,of,the,retention,lease,param,retaining,sequence,number,the,retaining,sequence,number,param,source,the,source,of,the,retention,lease,return,the,renewed,retention,lease,throws,illegal,argument,exception,if,the,specified,retention,lease,does,not,exist;public,synchronized,retention,lease,renew,retention,lease,final,string,id,final,long,retaining,sequence,number,final,string,source,assert,primary,mode,if,retention,leases,contains,key,id,false,throw,new,illegal,argument,exception,retention,lease,with,id,id,does,not,exist,final,retention,lease,retention,lease,new,retention,lease,id,retaining,sequence,number,current,time,millis,supplier,get,as,long,source,final,retention,lease,existing,retention,lease,retention,leases,put,id,retention,lease,assert,existing,retention,lease,null,assert,existing,retention,lease,retaining,sequence,number,retention,lease,retaining,sequence,number,retention,lease,renewal,for,id,from,source,renewed,a,lower,retaining,sequence,number,retention,lease,retaining,sequence,number,than,the,current,lease,retaining,sequence,number,existing,retention,lease,retaining,sequence,number,return,retention,lease
ReplicationTracker -> public synchronized RetentionLease renewRetentionLease(final String id, final long retainingSequenceNumber, final String source);1548944389;Renews an existing retention lease.__@param id                      the identifier of the retention lease_@param retainingSequenceNumber the retaining sequence number_@param source                  the source of the retention lease_@return the renewed retention lease_@throws IllegalArgumentException if the specified retention lease does not exist;public synchronized RetentionLease renewRetentionLease(final String id, final long retainingSequenceNumber, final String source) {_        assert primaryMode__        if (retentionLeases.containsKey(id) == false) {_            throw new IllegalArgumentException("retention lease with ID [" + id + "] does not exist")__        }_        final RetentionLease retentionLease =_                new RetentionLease(id, retainingSequenceNumber, currentTimeMillisSupplier.getAsLong(), source)__        final RetentionLease existingRetentionLease = retentionLeases.put(id, retentionLease)__        assert existingRetentionLease != null__        assert existingRetentionLease.retainingSequenceNumber() <= retentionLease.retainingSequenceNumber() :_                "retention lease renewal for [" + id + "]"_                        + " from [" + source + "]"_                        + " renewed a lower retaining sequence number [" + retentionLease.retainingSequenceNumber() + "]"_                        + " than the current lease retaining sequence number [" + existingRetentionLease.retainingSequenceNumber() + "]"__        return retentionLease__    };renews,an,existing,retention,lease,param,id,the,identifier,of,the,retention,lease,param,retaining,sequence,number,the,retaining,sequence,number,param,source,the,source,of,the,retention,lease,return,the,renewed,retention,lease,throws,illegal,argument,exception,if,the,specified,retention,lease,does,not,exist;public,synchronized,retention,lease,renew,retention,lease,final,string,id,final,long,retaining,sequence,number,final,string,source,assert,primary,mode,if,retention,leases,contains,key,id,false,throw,new,illegal,argument,exception,retention,lease,with,id,id,does,not,exist,final,retention,lease,retention,lease,new,retention,lease,id,retaining,sequence,number,current,time,millis,supplier,get,as,long,source,final,retention,lease,existing,retention,lease,retention,leases,put,id,retention,lease,assert,existing,retention,lease,null,assert,existing,retention,lease,retaining,sequence,number,retention,lease,retaining,sequence,number,retention,lease,renewal,for,id,from,source,renewed,a,lower,retaining,sequence,number,retention,lease,retaining,sequence,number,than,the,current,lease,retaining,sequence,number,existing,retention,lease,retaining,sequence,number,return,retention,lease
ReplicationTracker -> public synchronized RetentionLease renewRetentionLease(final String id, final long retainingSequenceNumber, final String source);1549059559;Renews an existing retention lease.__@param id                      the identifier of the retention lease_@param retainingSequenceNumber the retaining sequence number_@param source                  the source of the retention lease_@return the renewed retention lease_@throws IllegalArgumentException if the specified retention lease does not exist;public synchronized RetentionLease renewRetentionLease(final String id, final long retainingSequenceNumber, final String source) {_        assert primaryMode__        if (retentionLeases.contains(id) == false) {_            throw new IllegalArgumentException("retention lease with ID [" + id + "] does not exist")__        }_        final RetentionLease retentionLease =_                new RetentionLease(id, retainingSequenceNumber, currentTimeMillisSupplier.getAsLong(), source)__        final RetentionLease existingRetentionLease = retentionLeases.get(id)__        assert existingRetentionLease != null__        assert existingRetentionLease.retainingSequenceNumber() <= retentionLease.retainingSequenceNumber() :_                "retention lease renewal for [" + id + "]"_                        + " from [" + source + "]"_                        + " renewed a lower retaining sequence number [" + retentionLease.retainingSequenceNumber() + "]"_                        + " than the current lease retaining sequence number [" + existingRetentionLease.retainingSequenceNumber() + "]"__        retentionLeases = new RetentionLeases(_                operationPrimaryTerm,_                retentionLeases.version() + 1,_                Stream.concat(_                        retentionLeases.leases().stream().filter(lease -> lease.id().equals(id) == false),_                        Stream.of(retentionLease))_                        .collect(Collectors.toList()))__        return retentionLease__    };renews,an,existing,retention,lease,param,id,the,identifier,of,the,retention,lease,param,retaining,sequence,number,the,retaining,sequence,number,param,source,the,source,of,the,retention,lease,return,the,renewed,retention,lease,throws,illegal,argument,exception,if,the,specified,retention,lease,does,not,exist;public,synchronized,retention,lease,renew,retention,lease,final,string,id,final,long,retaining,sequence,number,final,string,source,assert,primary,mode,if,retention,leases,contains,id,false,throw,new,illegal,argument,exception,retention,lease,with,id,id,does,not,exist,final,retention,lease,retention,lease,new,retention,lease,id,retaining,sequence,number,current,time,millis,supplier,get,as,long,source,final,retention,lease,existing,retention,lease,retention,leases,get,id,assert,existing,retention,lease,null,assert,existing,retention,lease,retaining,sequence,number,retention,lease,retaining,sequence,number,retention,lease,renewal,for,id,from,source,renewed,a,lower,retaining,sequence,number,retention,lease,retaining,sequence,number,than,the,current,lease,retaining,sequence,number,existing,retention,lease,retaining,sequence,number,retention,leases,new,retention,leases,operation,primary,term,retention,leases,version,1,stream,concat,retention,leases,leases,stream,filter,lease,lease,id,equals,id,false,stream,of,retention,lease,collect,collectors,to,list,return,retention,lease
ReplicationTracker -> public synchronized RetentionLease renewRetentionLease(final String id, final long retainingSequenceNumber, final String source);1549294529;Renews an existing retention lease.__@param id                      the identifier of the retention lease_@param retainingSequenceNumber the retaining sequence number_@param source                  the source of the retention lease_@return the renewed retention lease_@throws IllegalArgumentException if the specified retention lease does not exist;public synchronized RetentionLease renewRetentionLease(final String id, final long retainingSequenceNumber, final String source) {_        assert primaryMode__        if (retentionLeases.contains(id) == false) {_            throw new IllegalArgumentException("retention lease with ID [" + id + "] does not exist")__        }_        final RetentionLease retentionLease =_                new RetentionLease(id, retainingSequenceNumber, currentTimeMillisSupplier.getAsLong(), source)__        final RetentionLease existingRetentionLease = retentionLeases.get(id)__        assert existingRetentionLease != null__        assert existingRetentionLease.retainingSequenceNumber() <= retentionLease.retainingSequenceNumber() :_                "retention lease renewal for [" + id + "]"_                        + " from [" + source + "]"_                        + " renewed a lower retaining sequence number [" + retentionLease.retainingSequenceNumber() + "]"_                        + " than the current lease retaining sequence number [" + existingRetentionLease.retainingSequenceNumber() + "]"__        retentionLeases = new RetentionLeases(_                operationPrimaryTerm,_                retentionLeases.version() + 1,_                Stream.concat(_                        retentionLeases.leases().stream().filter(lease -> lease.id().equals(id) == false),_                        Stream.of(retentionLease))_                        .collect(Collectors.toList()))__        return retentionLease__    };renews,an,existing,retention,lease,param,id,the,identifier,of,the,retention,lease,param,retaining,sequence,number,the,retaining,sequence,number,param,source,the,source,of,the,retention,lease,return,the,renewed,retention,lease,throws,illegal,argument,exception,if,the,specified,retention,lease,does,not,exist;public,synchronized,retention,lease,renew,retention,lease,final,string,id,final,long,retaining,sequence,number,final,string,source,assert,primary,mode,if,retention,leases,contains,id,false,throw,new,illegal,argument,exception,retention,lease,with,id,id,does,not,exist,final,retention,lease,retention,lease,new,retention,lease,id,retaining,sequence,number,current,time,millis,supplier,get,as,long,source,final,retention,lease,existing,retention,lease,retention,leases,get,id,assert,existing,retention,lease,null,assert,existing,retention,lease,retaining,sequence,number,retention,lease,retaining,sequence,number,retention,lease,renewal,for,id,from,source,renewed,a,lower,retaining,sequence,number,retention,lease,retaining,sequence,number,than,the,current,lease,retaining,sequence,number,existing,retention,lease,retaining,sequence,number,retention,leases,new,retention,leases,operation,primary,term,retention,leases,version,1,stream,concat,retention,leases,leases,stream,filter,lease,lease,id,equals,id,false,stream,of,retention,lease,collect,collectors,to,list,return,retention,lease
ReplicationTracker -> public synchronized RetentionLease renewRetentionLease(final String id, final long retainingSequenceNumber, final String source);1549395737;Renews an existing retention lease.__@param id                      the identifier of the retention lease_@param retainingSequenceNumber the retaining sequence number_@param source                  the source of the retention lease_@return the renewed retention lease_@throws IllegalArgumentException if the specified retention lease does not exist;public synchronized RetentionLease renewRetentionLease(final String id, final long retainingSequenceNumber, final String source) {_        assert primaryMode__        if (retentionLeases.contains(id) == false) {_            throw new IllegalArgumentException("retention lease with ID [" + id + "] does not exist")__        }_        final RetentionLease retentionLease =_                new RetentionLease(id, retainingSequenceNumber, currentTimeMillisSupplier.getAsLong(), source)__        final RetentionLease existingRetentionLease = retentionLeases.get(id)__        assert existingRetentionLease != null__        assert existingRetentionLease.retainingSequenceNumber() <= retentionLease.retainingSequenceNumber() :_                "retention lease renewal for [" + id + "]"_                        + " from [" + source + "]"_                        + " renewed a lower retaining sequence number [" + retentionLease.retainingSequenceNumber() + "]"_                        + " than the current lease retaining sequence number [" + existingRetentionLease.retainingSequenceNumber() + "]"__        retentionLeases = new RetentionLeases(_                operationPrimaryTerm,_                retentionLeases.version() + 1,_                Stream.concat(_                        retentionLeases.leases().stream().filter(lease -> lease.id().equals(id) == false),_                        Stream.of(retentionLease))_                        .collect(Collectors.toList()))__        return retentionLease__    };renews,an,existing,retention,lease,param,id,the,identifier,of,the,retention,lease,param,retaining,sequence,number,the,retaining,sequence,number,param,source,the,source,of,the,retention,lease,return,the,renewed,retention,lease,throws,illegal,argument,exception,if,the,specified,retention,lease,does,not,exist;public,synchronized,retention,lease,renew,retention,lease,final,string,id,final,long,retaining,sequence,number,final,string,source,assert,primary,mode,if,retention,leases,contains,id,false,throw,new,illegal,argument,exception,retention,lease,with,id,id,does,not,exist,final,retention,lease,retention,lease,new,retention,lease,id,retaining,sequence,number,current,time,millis,supplier,get,as,long,source,final,retention,lease,existing,retention,lease,retention,leases,get,id,assert,existing,retention,lease,null,assert,existing,retention,lease,retaining,sequence,number,retention,lease,retaining,sequence,number,retention,lease,renewal,for,id,from,source,renewed,a,lower,retaining,sequence,number,retention,lease,retaining,sequence,number,than,the,current,lease,retaining,sequence,number,existing,retention,lease,retaining,sequence,number,retention,leases,new,retention,leases,operation,primary,term,retention,leases,version,1,stream,concat,retention,leases,leases,stream,filter,lease,lease,id,equals,id,false,stream,of,retention,lease,collect,collectors,to,list,return,retention,lease
ReplicationTracker -> public synchronized RetentionLease renewRetentionLease(final String id, final long retainingSequenceNumber, final String source);1549937843;Renews an existing retention lease.__@param id                      the identifier of the retention lease_@param retainingSequenceNumber the retaining sequence number_@param source                  the source of the retention lease_@return the renewed retention lease_@throws IllegalArgumentException if the specified retention lease does not exist;public synchronized RetentionLease renewRetentionLease(final String id, final long retainingSequenceNumber, final String source) {_        assert primaryMode__        if (retentionLeases.contains(id) == false) {_            throw new IllegalArgumentException("retention lease with ID [" + id + "] does not exist")__        }_        final RetentionLease retentionLease =_                new RetentionLease(id, retainingSequenceNumber, currentTimeMillisSupplier.getAsLong(), source)__        final RetentionLease existingRetentionLease = retentionLeases.get(id)__        assert existingRetentionLease != null__        assert existingRetentionLease.retainingSequenceNumber() <= retentionLease.retainingSequenceNumber() :_                "retention lease renewal for [" + id + "]"_                        + " from [" + source + "]"_                        + " renewed a lower retaining sequence number [" + retentionLease.retainingSequenceNumber() + "]"_                        + " than the current lease retaining sequence number [" + existingRetentionLease.retainingSequenceNumber() + "]"__        retentionLeases = new RetentionLeases(_                operationPrimaryTerm,_                retentionLeases.version() + 1,_                Stream.concat(_                        retentionLeases.leases().stream().filter(lease -> lease.id().equals(id) == false),_                        Stream.of(retentionLease))_                        .collect(Collectors.toList()))__        return retentionLease__    };renews,an,existing,retention,lease,param,id,the,identifier,of,the,retention,lease,param,retaining,sequence,number,the,retaining,sequence,number,param,source,the,source,of,the,retention,lease,return,the,renewed,retention,lease,throws,illegal,argument,exception,if,the,specified,retention,lease,does,not,exist;public,synchronized,retention,lease,renew,retention,lease,final,string,id,final,long,retaining,sequence,number,final,string,source,assert,primary,mode,if,retention,leases,contains,id,false,throw,new,illegal,argument,exception,retention,lease,with,id,id,does,not,exist,final,retention,lease,retention,lease,new,retention,lease,id,retaining,sequence,number,current,time,millis,supplier,get,as,long,source,final,retention,lease,existing,retention,lease,retention,leases,get,id,assert,existing,retention,lease,null,assert,existing,retention,lease,retaining,sequence,number,retention,lease,retaining,sequence,number,retention,lease,renewal,for,id,from,source,renewed,a,lower,retaining,sequence,number,retention,lease,retaining,sequence,number,than,the,current,lease,retaining,sequence,number,existing,retention,lease,retaining,sequence,number,retention,leases,new,retention,leases,operation,primary,term,retention,leases,version,1,stream,concat,retention,leases,leases,stream,filter,lease,lease,id,equals,id,false,stream,of,retention,lease,collect,collectors,to,list,return,retention,lease
ReplicationTracker -> public synchronized RetentionLease renewRetentionLease(final String id, final long retainingSequenceNumber, final String source);1549949489;Renews an existing retention lease.__@param id                      the identifier of the retention lease_@param retainingSequenceNumber the retaining sequence number_@param source                  the source of the retention lease_@return the renewed retention lease_@throws IllegalArgumentException if the specified retention lease does not exist;public synchronized RetentionLease renewRetentionLease(final String id, final long retainingSequenceNumber, final String source) {_        assert primaryMode__        if (retentionLeases.contains(id) == false) {_            throw new RetentionLeaseNotFoundException(id)__        }_        final RetentionLease retentionLease =_                new RetentionLease(id, retainingSequenceNumber, currentTimeMillisSupplier.getAsLong(), source)__        final RetentionLease existingRetentionLease = retentionLeases.get(id)__        assert existingRetentionLease != null__        assert existingRetentionLease.retainingSequenceNumber() <= retentionLease.retainingSequenceNumber() :_                "retention lease renewal for [" + id + "]"_                        + " from [" + source + "]"_                        + " renewed a lower retaining sequence number [" + retentionLease.retainingSequenceNumber() + "]"_                        + " than the current lease retaining sequence number [" + existingRetentionLease.retainingSequenceNumber() + "]"__        retentionLeases = new RetentionLeases(_                operationPrimaryTerm,_                retentionLeases.version() + 1,_                Stream.concat(_                        retentionLeases.leases().stream().filter(lease -> lease.id().equals(id) == false),_                        Stream.of(retentionLease))_                        .collect(Collectors.toList()))__        return retentionLease__    };renews,an,existing,retention,lease,param,id,the,identifier,of,the,retention,lease,param,retaining,sequence,number,the,retaining,sequence,number,param,source,the,source,of,the,retention,lease,return,the,renewed,retention,lease,throws,illegal,argument,exception,if,the,specified,retention,lease,does,not,exist;public,synchronized,retention,lease,renew,retention,lease,final,string,id,final,long,retaining,sequence,number,final,string,source,assert,primary,mode,if,retention,leases,contains,id,false,throw,new,retention,lease,not,found,exception,id,final,retention,lease,retention,lease,new,retention,lease,id,retaining,sequence,number,current,time,millis,supplier,get,as,long,source,final,retention,lease,existing,retention,lease,retention,leases,get,id,assert,existing,retention,lease,null,assert,existing,retention,lease,retaining,sequence,number,retention,lease,retaining,sequence,number,retention,lease,renewal,for,id,from,source,renewed,a,lower,retaining,sequence,number,retention,lease,retaining,sequence,number,than,the,current,lease,retaining,sequence,number,existing,retention,lease,retaining,sequence,number,retention,leases,new,retention,leases,operation,primary,term,retention,leases,version,1,stream,concat,retention,leases,leases,stream,filter,lease,lease,id,equals,id,false,stream,of,retention,lease,collect,collectors,to,list,return,retention,lease
ReplicationTracker -> public synchronized RetentionLease renewRetentionLease(final String id, final long retainingSequenceNumber, final String source);1550526771;Renews an existing retention lease.__@param id                      the identifier of the retention lease_@param retainingSequenceNumber the retaining sequence number_@param source                  the source of the retention lease_@return the renewed retention lease_@throws IllegalArgumentException if the specified retention lease does not exist;public synchronized RetentionLease renewRetentionLease(final String id, final long retainingSequenceNumber, final String source) {_        assert primaryMode__        if (retentionLeases.contains(id) == false) {_            throw new RetentionLeaseNotFoundException(id)__        }_        final RetentionLease retentionLease =_                new RetentionLease(id, retainingSequenceNumber, currentTimeMillisSupplier.getAsLong(), source)__        final RetentionLease existingRetentionLease = retentionLeases.get(id)__        assert existingRetentionLease != null__        assert existingRetentionLease.retainingSequenceNumber() <= retentionLease.retainingSequenceNumber() :_                "retention lease renewal for [" + id + "]"_                        + " from [" + source + "]"_                        + " renewed a lower retaining sequence number [" + retentionLease.retainingSequenceNumber() + "]"_                        + " than the current lease retaining sequence number [" + existingRetentionLease.retainingSequenceNumber() + "]"__        retentionLeases = new RetentionLeases(_                operationPrimaryTerm,_                retentionLeases.version() + 1,_                Stream.concat(_                        retentionLeases.leases().stream().filter(lease -> lease.id().equals(id) == false),_                        Stream.of(retentionLease))_                        .collect(Collectors.toList()))__        return retentionLease__    };renews,an,existing,retention,lease,param,id,the,identifier,of,the,retention,lease,param,retaining,sequence,number,the,retaining,sequence,number,param,source,the,source,of,the,retention,lease,return,the,renewed,retention,lease,throws,illegal,argument,exception,if,the,specified,retention,lease,does,not,exist;public,synchronized,retention,lease,renew,retention,lease,final,string,id,final,long,retaining,sequence,number,final,string,source,assert,primary,mode,if,retention,leases,contains,id,false,throw,new,retention,lease,not,found,exception,id,final,retention,lease,retention,lease,new,retention,lease,id,retaining,sequence,number,current,time,millis,supplier,get,as,long,source,final,retention,lease,existing,retention,lease,retention,leases,get,id,assert,existing,retention,lease,null,assert,existing,retention,lease,retaining,sequence,number,retention,lease,retaining,sequence,number,retention,lease,renewal,for,id,from,source,renewed,a,lower,retaining,sequence,number,retention,lease,retaining,sequence,number,than,the,current,lease,retaining,sequence,number,existing,retention,lease,retaining,sequence,number,retention,leases,new,retention,leases,operation,primary,term,retention,leases,version,1,stream,concat,retention,leases,leases,stream,filter,lease,lease,id,equals,id,false,stream,of,retention,lease,collect,collectors,to,list,return,retention,lease
ReplicationTracker -> public synchronized PrimaryContext startRelocationHandoff();1524684173;Initiates a relocation handoff and returns the corresponding primary context.;public synchronized PrimaryContext startRelocationHandoff() {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        assert pendingInSync.isEmpty() : "relocation handoff started while there are still shard copies pending in-sync: " + pendingInSync__        handoffInProgress = true__        _        _        _        _        _        Map<String, CheckpointState> localCheckpointsCopy = new HashMap<>()__        for (Map.Entry<String, CheckpointState> entry : checkpoints.entrySet()) {_            localCheckpointsCopy.put(entry.getKey(), entry.getValue().copy())__        }_        assert invariant()__        return new PrimaryContext(appliedClusterStateVersion, localCheckpointsCopy, routingTable)__    };initiates,a,relocation,handoff,and,returns,the,corresponding,primary,context;public,synchronized,primary,context,start,relocation,handoff,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,assert,pending,in,sync,is,empty,relocation,handoff,started,while,there,are,still,shard,copies,pending,in,sync,pending,in,sync,handoff,in,progress,true,map,string,checkpoint,state,local,checkpoints,copy,new,hash,map,for,map,entry,string,checkpoint,state,entry,checkpoints,entry,set,local,checkpoints,copy,put,entry,get,key,entry,get,value,copy,assert,invariant,return,new,primary,context,applied,cluster,state,version,local,checkpoints,copy,routing,table
ReplicationTracker -> public synchronized PrimaryContext startRelocationHandoff();1525334055;Initiates a relocation handoff and returns the corresponding primary context.;public synchronized PrimaryContext startRelocationHandoff() {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        assert pendingInSync.isEmpty() : "relocation handoff started while there are still shard copies pending in-sync: " + pendingInSync__        handoffInProgress = true__        _        _        _        _        _        Map<String, CheckpointState> localCheckpointsCopy = new HashMap<>()__        for (Map.Entry<String, CheckpointState> entry : checkpoints.entrySet()) {_            localCheckpointsCopy.put(entry.getKey(), entry.getValue().copy())__        }_        assert invariant()__        return new PrimaryContext(appliedClusterStateVersion, localCheckpointsCopy, routingTable)__    };initiates,a,relocation,handoff,and,returns,the,corresponding,primary,context;public,synchronized,primary,context,start,relocation,handoff,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,assert,pending,in,sync,is,empty,relocation,handoff,started,while,there,are,still,shard,copies,pending,in,sync,pending,in,sync,handoff,in,progress,true,map,string,checkpoint,state,local,checkpoints,copy,new,hash,map,for,map,entry,string,checkpoint,state,entry,checkpoints,entry,set,local,checkpoints,copy,put,entry,get,key,entry,get,value,copy,assert,invariant,return,new,primary,context,applied,cluster,state,version,local,checkpoints,copy,routing,table
ReplicationTracker -> public synchronized PrimaryContext startRelocationHandoff();1533295538;Initiates a relocation handoff and returns the corresponding primary context.;public synchronized PrimaryContext startRelocationHandoff() {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        assert pendingInSync.isEmpty() : "relocation handoff started while there are still shard copies pending in-sync: " + pendingInSync__        handoffInProgress = true__        _        _        _        _        _        Map<String, CheckpointState> localCheckpointsCopy = new HashMap<>()__        for (Map.Entry<String, CheckpointState> entry : checkpoints.entrySet()) {_            localCheckpointsCopy.put(entry.getKey(), entry.getValue().copy())__        }_        assert invariant()__        return new PrimaryContext(appliedClusterStateVersion, localCheckpointsCopy, routingTable)__    };initiates,a,relocation,handoff,and,returns,the,corresponding,primary,context;public,synchronized,primary,context,start,relocation,handoff,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,assert,pending,in,sync,is,empty,relocation,handoff,started,while,there,are,still,shard,copies,pending,in,sync,pending,in,sync,handoff,in,progress,true,map,string,checkpoint,state,local,checkpoints,copy,new,hash,map,for,map,entry,string,checkpoint,state,entry,checkpoints,entry,set,local,checkpoints,copy,put,entry,get,key,entry,get,value,copy,assert,invariant,return,new,primary,context,applied,cluster,state,version,local,checkpoints,copy,routing,table
ReplicationTracker -> public synchronized PrimaryContext startRelocationHandoff();1533738061;Initiates a relocation handoff and returns the corresponding primary context.;public synchronized PrimaryContext startRelocationHandoff() {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        assert pendingInSync.isEmpty() : "relocation handoff started while there are still shard copies pending in-sync: " + pendingInSync__        handoffInProgress = true__        _        _        _        _        _        Map<String, CheckpointState> localCheckpointsCopy = new HashMap<>()__        for (Map.Entry<String, CheckpointState> entry : checkpoints.entrySet()) {_            localCheckpointsCopy.put(entry.getKey(), entry.getValue().copy())__        }_        assert invariant()__        return new PrimaryContext(appliedClusterStateVersion, localCheckpointsCopy, routingTable)__    };initiates,a,relocation,handoff,and,returns,the,corresponding,primary,context;public,synchronized,primary,context,start,relocation,handoff,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,assert,pending,in,sync,is,empty,relocation,handoff,started,while,there,are,still,shard,copies,pending,in,sync,pending,in,sync,handoff,in,progress,true,map,string,checkpoint,state,local,checkpoints,copy,new,hash,map,for,map,entry,string,checkpoint,state,entry,checkpoints,entry,set,local,checkpoints,copy,put,entry,get,key,entry,get,value,copy,assert,invariant,return,new,primary,context,applied,cluster,state,version,local,checkpoints,copy,routing,table
ReplicationTracker -> public synchronized PrimaryContext startRelocationHandoff();1546875837;Initiates a relocation handoff and returns the corresponding primary context.;public synchronized PrimaryContext startRelocationHandoff() {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        assert pendingInSync.isEmpty() : "relocation handoff started while there are still shard copies pending in-sync: " + pendingInSync__        handoffInProgress = true__        _        _        _        _        _        Map<String, CheckpointState> localCheckpointsCopy = new HashMap<>()__        for (Map.Entry<String, CheckpointState> entry : checkpoints.entrySet()) {_            localCheckpointsCopy.put(entry.getKey(), entry.getValue().copy())__        }_        assert invariant()__        return new PrimaryContext(appliedClusterStateVersion, localCheckpointsCopy, routingTable)__    };initiates,a,relocation,handoff,and,returns,the,corresponding,primary,context;public,synchronized,primary,context,start,relocation,handoff,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,assert,pending,in,sync,is,empty,relocation,handoff,started,while,there,are,still,shard,copies,pending,in,sync,pending,in,sync,handoff,in,progress,true,map,string,checkpoint,state,local,checkpoints,copy,new,hash,map,for,map,entry,string,checkpoint,state,entry,checkpoints,entry,set,local,checkpoints,copy,put,entry,get,key,entry,get,value,copy,assert,invariant,return,new,primary,context,applied,cluster,state,version,local,checkpoints,copy,routing,table
ReplicationTracker -> public synchronized PrimaryContext startRelocationHandoff();1546927432;Initiates a relocation handoff and returns the corresponding primary context.;public synchronized PrimaryContext startRelocationHandoff() {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        assert pendingInSync.isEmpty() : "relocation handoff started while there are still shard copies pending in-sync: " + pendingInSync__        handoffInProgress = true__        _        _        _        _        _        Map<String, CheckpointState> localCheckpointsCopy = new HashMap<>()__        for (Map.Entry<String, CheckpointState> entry : checkpoints.entrySet()) {_            localCheckpointsCopy.put(entry.getKey(), entry.getValue().copy())__        }_        assert invariant()__        return new PrimaryContext(appliedClusterStateVersion, localCheckpointsCopy, routingTable)__    };initiates,a,relocation,handoff,and,returns,the,corresponding,primary,context;public,synchronized,primary,context,start,relocation,handoff,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,assert,pending,in,sync,is,empty,relocation,handoff,started,while,there,are,still,shard,copies,pending,in,sync,pending,in,sync,handoff,in,progress,true,map,string,checkpoint,state,local,checkpoints,copy,new,hash,map,for,map,entry,string,checkpoint,state,entry,checkpoints,entry,set,local,checkpoints,copy,put,entry,get,key,entry,get,value,copy,assert,invariant,return,new,primary,context,applied,cluster,state,version,local,checkpoints,copy,routing,table
ReplicationTracker -> public synchronized PrimaryContext startRelocationHandoff();1547332999;Initiates a relocation handoff and returns the corresponding primary context.;public synchronized PrimaryContext startRelocationHandoff() {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        assert pendingInSync.isEmpty() : "relocation handoff started while there are still shard copies pending in-sync: " + pendingInSync__        handoffInProgress = true__        _        _        _        _        _        Map<String, CheckpointState> localCheckpointsCopy = new HashMap<>()__        for (Map.Entry<String, CheckpointState> entry : checkpoints.entrySet()) {_            localCheckpointsCopy.put(entry.getKey(), entry.getValue().copy())__        }_        assert invariant()__        return new PrimaryContext(appliedClusterStateVersion, localCheckpointsCopy, routingTable)__    };initiates,a,relocation,handoff,and,returns,the,corresponding,primary,context;public,synchronized,primary,context,start,relocation,handoff,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,assert,pending,in,sync,is,empty,relocation,handoff,started,while,there,are,still,shard,copies,pending,in,sync,pending,in,sync,handoff,in,progress,true,map,string,checkpoint,state,local,checkpoints,copy,new,hash,map,for,map,entry,string,checkpoint,state,entry,checkpoints,entry,set,local,checkpoints,copy,put,entry,get,key,entry,get,value,copy,assert,invariant,return,new,primary,context,applied,cluster,state,version,local,checkpoints,copy,routing,table
ReplicationTracker -> public synchronized PrimaryContext startRelocationHandoff();1548593396;Initiates a relocation handoff and returns the corresponding primary context.;public synchronized PrimaryContext startRelocationHandoff() {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        assert pendingInSync.isEmpty() : "relocation handoff started while there are still shard copies pending in-sync: " + pendingInSync__        handoffInProgress = true__        _        _        _        _        _        Map<String, CheckpointState> localCheckpointsCopy = new HashMap<>()__        for (Map.Entry<String, CheckpointState> entry : checkpoints.entrySet()) {_            localCheckpointsCopy.put(entry.getKey(), entry.getValue().copy())__        }_        assert invariant()__        return new PrimaryContext(appliedClusterStateVersion, localCheckpointsCopy, routingTable)__    };initiates,a,relocation,handoff,and,returns,the,corresponding,primary,context;public,synchronized,primary,context,start,relocation,handoff,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,assert,pending,in,sync,is,empty,relocation,handoff,started,while,there,are,still,shard,copies,pending,in,sync,pending,in,sync,handoff,in,progress,true,map,string,checkpoint,state,local,checkpoints,copy,new,hash,map,for,map,entry,string,checkpoint,state,entry,checkpoints,entry,set,local,checkpoints,copy,put,entry,get,key,entry,get,value,copy,assert,invariant,return,new,primary,context,applied,cluster,state,version,local,checkpoints,copy,routing,table
ReplicationTracker -> public synchronized PrimaryContext startRelocationHandoff();1548594827;Initiates a relocation handoff and returns the corresponding primary context.;public synchronized PrimaryContext startRelocationHandoff() {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        assert pendingInSync.isEmpty() : "relocation handoff started while there are still shard copies pending in-sync: " + pendingInSync__        handoffInProgress = true__        _        _        _        _        _        Map<String, CheckpointState> localCheckpointsCopy = new HashMap<>()__        for (Map.Entry<String, CheckpointState> entry : checkpoints.entrySet()) {_            localCheckpointsCopy.put(entry.getKey(), entry.getValue().copy())__        }_        assert invariant()__        return new PrimaryContext(appliedClusterStateVersion, localCheckpointsCopy, routingTable)__    };initiates,a,relocation,handoff,and,returns,the,corresponding,primary,context;public,synchronized,primary,context,start,relocation,handoff,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,assert,pending,in,sync,is,empty,relocation,handoff,started,while,there,are,still,shard,copies,pending,in,sync,pending,in,sync,handoff,in,progress,true,map,string,checkpoint,state,local,checkpoints,copy,new,hash,map,for,map,entry,string,checkpoint,state,entry,checkpoints,entry,set,local,checkpoints,copy,put,entry,get,key,entry,get,value,copy,assert,invariant,return,new,primary,context,applied,cluster,state,version,local,checkpoints,copy,routing,table
ReplicationTracker -> public synchronized PrimaryContext startRelocationHandoff();1548677511;Initiates a relocation handoff and returns the corresponding primary context.;public synchronized PrimaryContext startRelocationHandoff() {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        assert pendingInSync.isEmpty() : "relocation handoff started while there are still shard copies pending in-sync: " + pendingInSync__        handoffInProgress = true__        _        _        _        _        _        Map<String, CheckpointState> localCheckpointsCopy = new HashMap<>()__        for (Map.Entry<String, CheckpointState> entry : checkpoints.entrySet()) {_            localCheckpointsCopy.put(entry.getKey(), entry.getValue().copy())__        }_        assert invariant()__        return new PrimaryContext(appliedClusterStateVersion, localCheckpointsCopy, routingTable)__    };initiates,a,relocation,handoff,and,returns,the,corresponding,primary,context;public,synchronized,primary,context,start,relocation,handoff,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,assert,pending,in,sync,is,empty,relocation,handoff,started,while,there,are,still,shard,copies,pending,in,sync,pending,in,sync,handoff,in,progress,true,map,string,checkpoint,state,local,checkpoints,copy,new,hash,map,for,map,entry,string,checkpoint,state,entry,checkpoints,entry,set,local,checkpoints,copy,put,entry,get,key,entry,get,value,copy,assert,invariant,return,new,primary,context,applied,cluster,state,version,local,checkpoints,copy,routing,table
ReplicationTracker -> public synchronized PrimaryContext startRelocationHandoff();1548944389;Initiates a relocation handoff and returns the corresponding primary context.;public synchronized PrimaryContext startRelocationHandoff() {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        assert pendingInSync.isEmpty() : "relocation handoff started while there are still shard copies pending in-sync: " + pendingInSync__        handoffInProgress = true__        _        _        _        _        _        Map<String, CheckpointState> localCheckpointsCopy = new HashMap<>()__        for (Map.Entry<String, CheckpointState> entry : checkpoints.entrySet()) {_            localCheckpointsCopy.put(entry.getKey(), entry.getValue().copy())__        }_        assert invariant()__        return new PrimaryContext(appliedClusterStateVersion, localCheckpointsCopy, routingTable)__    };initiates,a,relocation,handoff,and,returns,the,corresponding,primary,context;public,synchronized,primary,context,start,relocation,handoff,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,assert,pending,in,sync,is,empty,relocation,handoff,started,while,there,are,still,shard,copies,pending,in,sync,pending,in,sync,handoff,in,progress,true,map,string,checkpoint,state,local,checkpoints,copy,new,hash,map,for,map,entry,string,checkpoint,state,entry,checkpoints,entry,set,local,checkpoints,copy,put,entry,get,key,entry,get,value,copy,assert,invariant,return,new,primary,context,applied,cluster,state,version,local,checkpoints,copy,routing,table
ReplicationTracker -> public synchronized PrimaryContext startRelocationHandoff();1549059559;Initiates a relocation handoff and returns the corresponding primary context.;public synchronized PrimaryContext startRelocationHandoff() {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        assert pendingInSync.isEmpty() : "relocation handoff started while there are still shard copies pending in-sync: " + pendingInSync__        handoffInProgress = true__        _        _        _        _        _        Map<String, CheckpointState> localCheckpointsCopy = new HashMap<>()__        for (Map.Entry<String, CheckpointState> entry : checkpoints.entrySet()) {_            localCheckpointsCopy.put(entry.getKey(), entry.getValue().copy())__        }_        assert invariant()__        return new PrimaryContext(appliedClusterStateVersion, localCheckpointsCopy, routingTable)__    };initiates,a,relocation,handoff,and,returns,the,corresponding,primary,context;public,synchronized,primary,context,start,relocation,handoff,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,assert,pending,in,sync,is,empty,relocation,handoff,started,while,there,are,still,shard,copies,pending,in,sync,pending,in,sync,handoff,in,progress,true,map,string,checkpoint,state,local,checkpoints,copy,new,hash,map,for,map,entry,string,checkpoint,state,entry,checkpoints,entry,set,local,checkpoints,copy,put,entry,get,key,entry,get,value,copy,assert,invariant,return,new,primary,context,applied,cluster,state,version,local,checkpoints,copy,routing,table
ReplicationTracker -> public synchronized PrimaryContext startRelocationHandoff();1549294529;Initiates a relocation handoff and returns the corresponding primary context.;public synchronized PrimaryContext startRelocationHandoff() {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        assert pendingInSync.isEmpty() : "relocation handoff started while there are still shard copies pending in-sync: " + pendingInSync__        handoffInProgress = true__        _        _        _        _        _        Map<String, CheckpointState> localCheckpointsCopy = new HashMap<>()__        for (Map.Entry<String, CheckpointState> entry : checkpoints.entrySet()) {_            localCheckpointsCopy.put(entry.getKey(), entry.getValue().copy())__        }_        assert invariant()__        return new PrimaryContext(appliedClusterStateVersion, localCheckpointsCopy, routingTable)__    };initiates,a,relocation,handoff,and,returns,the,corresponding,primary,context;public,synchronized,primary,context,start,relocation,handoff,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,assert,pending,in,sync,is,empty,relocation,handoff,started,while,there,are,still,shard,copies,pending,in,sync,pending,in,sync,handoff,in,progress,true,map,string,checkpoint,state,local,checkpoints,copy,new,hash,map,for,map,entry,string,checkpoint,state,entry,checkpoints,entry,set,local,checkpoints,copy,put,entry,get,key,entry,get,value,copy,assert,invariant,return,new,primary,context,applied,cluster,state,version,local,checkpoints,copy,routing,table
ReplicationTracker -> public synchronized PrimaryContext startRelocationHandoff();1549395737;Initiates a relocation handoff and returns the corresponding primary context.;public synchronized PrimaryContext startRelocationHandoff() {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        assert pendingInSync.isEmpty() : "relocation handoff started while there are still shard copies pending in-sync: " + pendingInSync__        handoffInProgress = true__        _        _        _        _        _        Map<String, CheckpointState> localCheckpointsCopy = new HashMap<>()__        for (Map.Entry<String, CheckpointState> entry : checkpoints.entrySet()) {_            localCheckpointsCopy.put(entry.getKey(), entry.getValue().copy())__        }_        assert invariant()__        return new PrimaryContext(appliedClusterStateVersion, localCheckpointsCopy, routingTable)__    };initiates,a,relocation,handoff,and,returns,the,corresponding,primary,context;public,synchronized,primary,context,start,relocation,handoff,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,assert,pending,in,sync,is,empty,relocation,handoff,started,while,there,are,still,shard,copies,pending,in,sync,pending,in,sync,handoff,in,progress,true,map,string,checkpoint,state,local,checkpoints,copy,new,hash,map,for,map,entry,string,checkpoint,state,entry,checkpoints,entry,set,local,checkpoints,copy,put,entry,get,key,entry,get,value,copy,assert,invariant,return,new,primary,context,applied,cluster,state,version,local,checkpoints,copy,routing,table
ReplicationTracker -> public synchronized PrimaryContext startRelocationHandoff();1549937843;Initiates a relocation handoff and returns the corresponding primary context.;public synchronized PrimaryContext startRelocationHandoff() {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        assert pendingInSync.isEmpty() : "relocation handoff started while there are still shard copies pending in-sync: " + pendingInSync__        handoffInProgress = true__        _        _        _        _        _        Map<String, CheckpointState> localCheckpointsCopy = new HashMap<>()__        for (Map.Entry<String, CheckpointState> entry : checkpoints.entrySet()) {_            localCheckpointsCopy.put(entry.getKey(), entry.getValue().copy())__        }_        assert invariant()__        return new PrimaryContext(appliedClusterStateVersion, localCheckpointsCopy, routingTable)__    };initiates,a,relocation,handoff,and,returns,the,corresponding,primary,context;public,synchronized,primary,context,start,relocation,handoff,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,assert,pending,in,sync,is,empty,relocation,handoff,started,while,there,are,still,shard,copies,pending,in,sync,pending,in,sync,handoff,in,progress,true,map,string,checkpoint,state,local,checkpoints,copy,new,hash,map,for,map,entry,string,checkpoint,state,entry,checkpoints,entry,set,local,checkpoints,copy,put,entry,get,key,entry,get,value,copy,assert,invariant,return,new,primary,context,applied,cluster,state,version,local,checkpoints,copy,routing,table
ReplicationTracker -> public synchronized PrimaryContext startRelocationHandoff();1549949489;Initiates a relocation handoff and returns the corresponding primary context.;public synchronized PrimaryContext startRelocationHandoff() {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        assert pendingInSync.isEmpty() : "relocation handoff started while there are still shard copies pending in-sync: " + pendingInSync__        handoffInProgress = true__        _        _        _        _        _        Map<String, CheckpointState> localCheckpointsCopy = new HashMap<>()__        for (Map.Entry<String, CheckpointState> entry : checkpoints.entrySet()) {_            localCheckpointsCopy.put(entry.getKey(), entry.getValue().copy())__        }_        assert invariant()__        return new PrimaryContext(appliedClusterStateVersion, localCheckpointsCopy, routingTable)__    };initiates,a,relocation,handoff,and,returns,the,corresponding,primary,context;public,synchronized,primary,context,start,relocation,handoff,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,assert,pending,in,sync,is,empty,relocation,handoff,started,while,there,are,still,shard,copies,pending,in,sync,pending,in,sync,handoff,in,progress,true,map,string,checkpoint,state,local,checkpoints,copy,new,hash,map,for,map,entry,string,checkpoint,state,entry,checkpoints,entry,set,local,checkpoints,copy,put,entry,get,key,entry,get,value,copy,assert,invariant,return,new,primary,context,applied,cluster,state,version,local,checkpoints,copy,routing,table
ReplicationTracker -> public synchronized PrimaryContext startRelocationHandoff();1550526771;Initiates a relocation handoff and returns the corresponding primary context.;public synchronized PrimaryContext startRelocationHandoff() {_        assert invariant()__        assert primaryMode__        assert handoffInProgress == false__        assert pendingInSync.isEmpty() : "relocation handoff started while there are still shard copies pending in-sync: " + pendingInSync__        handoffInProgress = true__        _        _        _        _        _        Map<String, CheckpointState> localCheckpointsCopy = new HashMap<>()__        for (Map.Entry<String, CheckpointState> entry : checkpoints.entrySet()) {_            localCheckpointsCopy.put(entry.getKey(), entry.getValue().copy())__        }_        assert invariant()__        return new PrimaryContext(appliedClusterStateVersion, localCheckpointsCopy, routingTable)__    };initiates,a,relocation,handoff,and,returns,the,corresponding,primary,context;public,synchronized,primary,context,start,relocation,handoff,assert,invariant,assert,primary,mode,assert,handoff,in,progress,false,assert,pending,in,sync,is,empty,relocation,handoff,started,while,there,are,still,shard,copies,pending,in,sync,pending,in,sync,handoff,in,progress,true,map,string,checkpoint,state,local,checkpoints,copy,new,hash,map,for,map,entry,string,checkpoint,state,entry,checkpoints,entry,set,local,checkpoints,copy,put,entry,get,key,entry,get,value,copy,assert,invariant,return,new,primary,context,applied,cluster,state,version,local,checkpoints,copy,routing,table
ReplicationTracker -> public Collection<RetentionLease> getRetentionLeases();1548677511;Get all non-expired retention leases tracked on this shard. An unmodifiable copy of the retention leases is returned. Note that only_the primary shard calculates which leases are expired, and if any have expired, syncs the retention leases to any replicas.__@return the retention leases;public Collection<RetentionLease> getRetentionLeases() {_        final boolean wasPrimaryMode__        final Collection<RetentionLease> nonExpiredRetentionLeases__        synchronized (this) {_            if (primaryMode) {_                _                final long currentTimeMillis = currentTimeMillisSupplier.getAsLong()__                final long retentionLeaseMillis = indexSettings.getRetentionLeaseMillis()__                final Collection<RetentionLease> expiredRetentionLeases = retentionLeases_                        .values()_                        .stream()_                        .filter(retentionLease -> currentTimeMillis - retentionLease.timestamp() > retentionLeaseMillis)_                        .collect(Collectors.toList())__                if (expiredRetentionLeases.isEmpty()) {_                    _                    return copyRetentionLeases()__                }_                _                for (final RetentionLease expiredRetentionLease : expiredRetentionLeases) {_                    retentionLeases.remove(expiredRetentionLease.id())__                }_            }_            _            wasPrimaryMode = primaryMode__            nonExpiredRetentionLeases = copyRetentionLeases()__        }_        if (wasPrimaryMode) {_            onSyncRetentionLeases.accept(nonExpiredRetentionLeases, ActionListener.wrap(() -> {}))__        }_        return nonExpiredRetentionLeases__    };get,all,non,expired,retention,leases,tracked,on,this,shard,an,unmodifiable,copy,of,the,retention,leases,is,returned,note,that,only,the,primary,shard,calculates,which,leases,are,expired,and,if,any,have,expired,syncs,the,retention,leases,to,any,replicas,return,the,retention,leases;public,collection,retention,lease,get,retention,leases,final,boolean,was,primary,mode,final,collection,retention,lease,non,expired,retention,leases,synchronized,this,if,primary,mode,final,long,current,time,millis,current,time,millis,supplier,get,as,long,final,long,retention,lease,millis,index,settings,get,retention,lease,millis,final,collection,retention,lease,expired,retention,leases,retention,leases,values,stream,filter,retention,lease,current,time,millis,retention,lease,timestamp,retention,lease,millis,collect,collectors,to,list,if,expired,retention,leases,is,empty,return,copy,retention,leases,for,final,retention,lease,expired,retention,lease,expired,retention,leases,retention,leases,remove,expired,retention,lease,id,was,primary,mode,primary,mode,non,expired,retention,leases,copy,retention,leases,if,was,primary,mode,on,sync,retention,leases,accept,non,expired,retention,leases,action,listener,wrap,return,non,expired,retention,leases
ReplicationTracker -> public Collection<RetentionLease> getRetentionLeases();1548944389;Get all non-expired retention leases tracked on this shard. An unmodifiable copy of the retention leases is returned. Note that only_the primary shard calculates which leases are expired, and if any have expired, syncs the retention leases to any replicas.__@return the retention leases;public Collection<RetentionLease> getRetentionLeases() {_        final boolean wasPrimaryMode__        final Collection<RetentionLease> nonExpiredRetentionLeases__        synchronized (this) {_            if (primaryMode) {_                _                final long currentTimeMillis = currentTimeMillisSupplier.getAsLong()__                final long retentionLeaseMillis = indexSettings.getRetentionLeaseMillis()__                final Collection<RetentionLease> expiredRetentionLeases = retentionLeases_                        .values()_                        .stream()_                        .filter(retentionLease -> currentTimeMillis - retentionLease.timestamp() > retentionLeaseMillis)_                        .collect(Collectors.toList())__                if (expiredRetentionLeases.isEmpty()) {_                    _                    return copyRetentionLeases()__                }_                _                for (final RetentionLease expiredRetentionLease : expiredRetentionLeases) {_                    retentionLeases.remove(expiredRetentionLease.id())__                }_            }_            _            wasPrimaryMode = primaryMode__            nonExpiredRetentionLeases = copyRetentionLeases()__        }_        if (wasPrimaryMode) {_            onSyncRetentionLeases.accept(nonExpiredRetentionLeases, ActionListener.wrap(() -> {}))__        }_        return nonExpiredRetentionLeases__    };get,all,non,expired,retention,leases,tracked,on,this,shard,an,unmodifiable,copy,of,the,retention,leases,is,returned,note,that,only,the,primary,shard,calculates,which,leases,are,expired,and,if,any,have,expired,syncs,the,retention,leases,to,any,replicas,return,the,retention,leases;public,collection,retention,lease,get,retention,leases,final,boolean,was,primary,mode,final,collection,retention,lease,non,expired,retention,leases,synchronized,this,if,primary,mode,final,long,current,time,millis,current,time,millis,supplier,get,as,long,final,long,retention,lease,millis,index,settings,get,retention,lease,millis,final,collection,retention,lease,expired,retention,leases,retention,leases,values,stream,filter,retention,lease,current,time,millis,retention,lease,timestamp,retention,lease,millis,collect,collectors,to,list,if,expired,retention,leases,is,empty,return,copy,retention,leases,for,final,retention,lease,expired,retention,lease,expired,retention,leases,retention,leases,remove,expired,retention,lease,id,was,primary,mode,primary,mode,non,expired,retention,leases,copy,retention,leases,if,was,primary,mode,on,sync,retention,leases,accept,non,expired,retention,leases,action,listener,wrap,return,non,expired,retention,leases
ReplicationTracker -> public long getOperationPrimaryTerm();1548944389;Returns the current operation primary term.__@return the primary term;public long getOperationPrimaryTerm() {_        return operationPrimaryTerm__    };returns,the,current,operation,primary,term,return,the,primary,term;public,long,get,operation,primary,term,return,operation,primary,term
ReplicationTracker -> public long getOperationPrimaryTerm();1549059559;Returns the current operation primary term.__@return the primary term;public long getOperationPrimaryTerm() {_        return operationPrimaryTerm__    };returns,the,current,operation,primary,term,return,the,primary,term;public,long,get,operation,primary,term,return,operation,primary,term
ReplicationTracker -> public long getOperationPrimaryTerm();1549294529;Returns the current operation primary term.__@return the primary term;public long getOperationPrimaryTerm() {_        return operationPrimaryTerm__    };returns,the,current,operation,primary,term,return,the,primary,term;public,long,get,operation,primary,term,return,operation,primary,term
ReplicationTracker -> public long getOperationPrimaryTerm();1549395737;Returns the current operation primary term.__@return the primary term;public long getOperationPrimaryTerm() {_        return operationPrimaryTerm__    };returns,the,current,operation,primary,term,return,the,primary,term;public,long,get,operation,primary,term,return,operation,primary,term
ReplicationTracker -> public long getOperationPrimaryTerm();1549937843;Returns the current operation primary term.__@return the primary term;public long getOperationPrimaryTerm() {_        return operationPrimaryTerm__    };returns,the,current,operation,primary,term,return,the,primary,term;public,long,get,operation,primary,term,return,operation,primary,term
ReplicationTracker -> public long getOperationPrimaryTerm();1549949489;Returns the current operation primary term.__@return the primary term;public long getOperationPrimaryTerm() {_        return operationPrimaryTerm__    };returns,the,current,operation,primary,term,return,the,primary,term;public,long,get,operation,primary,term,return,operation,primary,term
ReplicationTracker -> public long getOperationPrimaryTerm();1550526771;Returns the current operation primary term.__@return the primary term;public long getOperationPrimaryTerm() {_        return operationPrimaryTerm__    };returns,the,current,operation,primary,term,return,the,primary,term;public,long,get,operation,primary,term,return,operation,primary,term
ReplicationTracker -> public synchronized void updateRetentionLeasesOnReplica(final RetentionLeases retentionLeases);1549059559;Updates retention leases on a replica.__@param retentionLeases the retention leases;public synchronized void updateRetentionLeasesOnReplica(final RetentionLeases retentionLeases) {_        assert primaryMode == false__        if (retentionLeases.supersedes(this.retentionLeases)) {_            this.retentionLeases = retentionLeases__        }_    };updates,retention,leases,on,a,replica,param,retention,leases,the,retention,leases;public,synchronized,void,update,retention,leases,on,replica,final,retention,leases,retention,leases,assert,primary,mode,false,if,retention,leases,supersedes,this,retention,leases,this,retention,leases,retention,leases
ReplicationTracker -> public synchronized void updateRetentionLeasesOnReplica(final RetentionLeases retentionLeases);1549294529;Updates retention leases on a replica.__@param retentionLeases the retention leases;public synchronized void updateRetentionLeasesOnReplica(final RetentionLeases retentionLeases) {_        assert primaryMode == false__        if (retentionLeases.supersedes(this.retentionLeases)) {_            this.retentionLeases = retentionLeases__        }_    };updates,retention,leases,on,a,replica,param,retention,leases,the,retention,leases;public,synchronized,void,update,retention,leases,on,replica,final,retention,leases,retention,leases,assert,primary,mode,false,if,retention,leases,supersedes,this,retention,leases,this,retention,leases,retention,leases
ReplicationTracker -> public synchronized void updateRetentionLeasesOnReplica(final RetentionLeases retentionLeases);1549395737;Updates retention leases on a replica.__@param retentionLeases the retention leases;public synchronized void updateRetentionLeasesOnReplica(final RetentionLeases retentionLeases) {_        assert primaryMode == false__        if (retentionLeases.supersedes(this.retentionLeases)) {_            this.retentionLeases = retentionLeases__        }_    };updates,retention,leases,on,a,replica,param,retention,leases,the,retention,leases;public,synchronized,void,update,retention,leases,on,replica,final,retention,leases,retention,leases,assert,primary,mode,false,if,retention,leases,supersedes,this,retention,leases,this,retention,leases,retention,leases
ReplicationTracker -> public synchronized void updateRetentionLeasesOnReplica(final RetentionLeases retentionLeases);1549937843;Updates retention leases on a replica.__@param retentionLeases the retention leases;public synchronized void updateRetentionLeasesOnReplica(final RetentionLeases retentionLeases) {_        assert primaryMode == false__        if (retentionLeases.supersedes(this.retentionLeases)) {_            this.retentionLeases = retentionLeases__        }_    };updates,retention,leases,on,a,replica,param,retention,leases,the,retention,leases;public,synchronized,void,update,retention,leases,on,replica,final,retention,leases,retention,leases,assert,primary,mode,false,if,retention,leases,supersedes,this,retention,leases,this,retention,leases,retention,leases
ReplicationTracker -> public synchronized void updateRetentionLeasesOnReplica(final RetentionLeases retentionLeases);1549949489;Updates retention leases on a replica.__@param retentionLeases the retention leases;public synchronized void updateRetentionLeasesOnReplica(final RetentionLeases retentionLeases) {_        assert primaryMode == false__        if (retentionLeases.supersedes(this.retentionLeases)) {_            this.retentionLeases = retentionLeases__        }_    };updates,retention,leases,on,a,replica,param,retention,leases,the,retention,leases;public,synchronized,void,update,retention,leases,on,replica,final,retention,leases,retention,leases,assert,primary,mode,false,if,retention,leases,supersedes,this,retention,leases,this,retention,leases,retention,leases
ReplicationTracker -> public synchronized void updateRetentionLeasesOnReplica(final RetentionLeases retentionLeases);1550526771;Updates retention leases on a replica.__@param retentionLeases the retention leases;public synchronized void updateRetentionLeasesOnReplica(final RetentionLeases retentionLeases) {_        assert primaryMode == false__        if (retentionLeases.supersedes(this.retentionLeases)) {_            this.retentionLeases = retentionLeases__        }_    };updates,retention,leases,on,a,replica,param,retention,leases,the,retention,leases;public,synchronized,void,update,retention,leases,on,replica,final,retention,leases,retention,leases,assert,primary,mode,false,if,retention,leases,supersedes,this,retention,leases,this,retention,leases,retention,leases
ReplicationTracker -> public synchronized CheckpointState getTrackedLocalCheckpointForShard(String allocationId);1524684173;Returns the local checkpoint information tracked for a specific shard. Used by tests.;public synchronized CheckpointState getTrackedLocalCheckpointForShard(String allocationId) {_        assert primaryMode__        return checkpoints.get(allocationId)__    };returns,the,local,checkpoint,information,tracked,for,a,specific,shard,used,by,tests;public,synchronized,checkpoint,state,get,tracked,local,checkpoint,for,shard,string,allocation,id,assert,primary,mode,return,checkpoints,get,allocation,id
ReplicationTracker -> public synchronized CheckpointState getTrackedLocalCheckpointForShard(String allocationId);1525334055;Returns the local checkpoint information tracked for a specific shard. Used by tests.;public synchronized CheckpointState getTrackedLocalCheckpointForShard(String allocationId) {_        assert primaryMode__        return checkpoints.get(allocationId)__    };returns,the,local,checkpoint,information,tracked,for,a,specific,shard,used,by,tests;public,synchronized,checkpoint,state,get,tracked,local,checkpoint,for,shard,string,allocation,id,assert,primary,mode,return,checkpoints,get,allocation,id
ReplicationTracker -> public synchronized CheckpointState getTrackedLocalCheckpointForShard(String allocationId);1533295538;Returns the local checkpoint information tracked for a specific shard. Used by tests.;public synchronized CheckpointState getTrackedLocalCheckpointForShard(String allocationId) {_        assert primaryMode__        return checkpoints.get(allocationId)__    };returns,the,local,checkpoint,information,tracked,for,a,specific,shard,used,by,tests;public,synchronized,checkpoint,state,get,tracked,local,checkpoint,for,shard,string,allocation,id,assert,primary,mode,return,checkpoints,get,allocation,id
ReplicationTracker -> public synchronized CheckpointState getTrackedLocalCheckpointForShard(String allocationId);1533738061;Returns the local checkpoint information tracked for a specific shard. Used by tests.;public synchronized CheckpointState getTrackedLocalCheckpointForShard(String allocationId) {_        assert primaryMode__        return checkpoints.get(allocationId)__    };returns,the,local,checkpoint,information,tracked,for,a,specific,shard,used,by,tests;public,synchronized,checkpoint,state,get,tracked,local,checkpoint,for,shard,string,allocation,id,assert,primary,mode,return,checkpoints,get,allocation,id
ReplicationTracker -> public synchronized CheckpointState getTrackedLocalCheckpointForShard(String allocationId);1546875837;Returns the local checkpoint information tracked for a specific shard. Used by tests.;public synchronized CheckpointState getTrackedLocalCheckpointForShard(String allocationId) {_        assert primaryMode__        return checkpoints.get(allocationId)__    };returns,the,local,checkpoint,information,tracked,for,a,specific,shard,used,by,tests;public,synchronized,checkpoint,state,get,tracked,local,checkpoint,for,shard,string,allocation,id,assert,primary,mode,return,checkpoints,get,allocation,id
ReplicationTracker -> public synchronized CheckpointState getTrackedLocalCheckpointForShard(String allocationId);1546927432;Returns the local checkpoint information tracked for a specific shard. Used by tests.;public synchronized CheckpointState getTrackedLocalCheckpointForShard(String allocationId) {_        assert primaryMode__        return checkpoints.get(allocationId)__    };returns,the,local,checkpoint,information,tracked,for,a,specific,shard,used,by,tests;public,synchronized,checkpoint,state,get,tracked,local,checkpoint,for,shard,string,allocation,id,assert,primary,mode,return,checkpoints,get,allocation,id
ReplicationTracker -> public synchronized CheckpointState getTrackedLocalCheckpointForShard(String allocationId);1547332999;Returns the local checkpoint information tracked for a specific shard. Used by tests.;public synchronized CheckpointState getTrackedLocalCheckpointForShard(String allocationId) {_        assert primaryMode__        return checkpoints.get(allocationId)__    };returns,the,local,checkpoint,information,tracked,for,a,specific,shard,used,by,tests;public,synchronized,checkpoint,state,get,tracked,local,checkpoint,for,shard,string,allocation,id,assert,primary,mode,return,checkpoints,get,allocation,id
ReplicationTracker -> public synchronized CheckpointState getTrackedLocalCheckpointForShard(String allocationId);1548593396;Returns the local checkpoint information tracked for a specific shard. Used by tests.;public synchronized CheckpointState getTrackedLocalCheckpointForShard(String allocationId) {_        assert primaryMode__        return checkpoints.get(allocationId)__    };returns,the,local,checkpoint,information,tracked,for,a,specific,shard,used,by,tests;public,synchronized,checkpoint,state,get,tracked,local,checkpoint,for,shard,string,allocation,id,assert,primary,mode,return,checkpoints,get,allocation,id
ReplicationTracker -> public synchronized CheckpointState getTrackedLocalCheckpointForShard(String allocationId);1548594827;Returns the local checkpoint information tracked for a specific shard. Used by tests.;public synchronized CheckpointState getTrackedLocalCheckpointForShard(String allocationId) {_        assert primaryMode__        return checkpoints.get(allocationId)__    };returns,the,local,checkpoint,information,tracked,for,a,specific,shard,used,by,tests;public,synchronized,checkpoint,state,get,tracked,local,checkpoint,for,shard,string,allocation,id,assert,primary,mode,return,checkpoints,get,allocation,id
ReplicationTracker -> public synchronized CheckpointState getTrackedLocalCheckpointForShard(String allocationId);1548677511;Returns the local checkpoint information tracked for a specific shard. Used by tests.;public synchronized CheckpointState getTrackedLocalCheckpointForShard(String allocationId) {_        assert primaryMode__        return checkpoints.get(allocationId)__    };returns,the,local,checkpoint,information,tracked,for,a,specific,shard,used,by,tests;public,synchronized,checkpoint,state,get,tracked,local,checkpoint,for,shard,string,allocation,id,assert,primary,mode,return,checkpoints,get,allocation,id
ReplicationTracker -> public synchronized CheckpointState getTrackedLocalCheckpointForShard(String allocationId);1548944389;Returns the local checkpoint information tracked for a specific shard. Used by tests.;public synchronized CheckpointState getTrackedLocalCheckpointForShard(String allocationId) {_        assert primaryMode__        return checkpoints.get(allocationId)__    };returns,the,local,checkpoint,information,tracked,for,a,specific,shard,used,by,tests;public,synchronized,checkpoint,state,get,tracked,local,checkpoint,for,shard,string,allocation,id,assert,primary,mode,return,checkpoints,get,allocation,id
ReplicationTracker -> public synchronized CheckpointState getTrackedLocalCheckpointForShard(String allocationId);1549059559;Returns the local checkpoint information tracked for a specific shard. Used by tests.;public synchronized CheckpointState getTrackedLocalCheckpointForShard(String allocationId) {_        assert primaryMode__        return checkpoints.get(allocationId)__    };returns,the,local,checkpoint,information,tracked,for,a,specific,shard,used,by,tests;public,synchronized,checkpoint,state,get,tracked,local,checkpoint,for,shard,string,allocation,id,assert,primary,mode,return,checkpoints,get,allocation,id
ReplicationTracker -> public synchronized CheckpointState getTrackedLocalCheckpointForShard(String allocationId);1549294529;Returns the local checkpoint information tracked for a specific shard. Used by tests.;public synchronized CheckpointState getTrackedLocalCheckpointForShard(String allocationId) {_        assert primaryMode__        return checkpoints.get(allocationId)__    };returns,the,local,checkpoint,information,tracked,for,a,specific,shard,used,by,tests;public,synchronized,checkpoint,state,get,tracked,local,checkpoint,for,shard,string,allocation,id,assert,primary,mode,return,checkpoints,get,allocation,id
ReplicationTracker -> public synchronized CheckpointState getTrackedLocalCheckpointForShard(String allocationId);1549395737;Returns the local checkpoint information tracked for a specific shard. Used by tests.;public synchronized CheckpointState getTrackedLocalCheckpointForShard(String allocationId) {_        assert primaryMode__        return checkpoints.get(allocationId)__    };returns,the,local,checkpoint,information,tracked,for,a,specific,shard,used,by,tests;public,synchronized,checkpoint,state,get,tracked,local,checkpoint,for,shard,string,allocation,id,assert,primary,mode,return,checkpoints,get,allocation,id
ReplicationTracker -> public synchronized CheckpointState getTrackedLocalCheckpointForShard(String allocationId);1549937843;Returns the local checkpoint information tracked for a specific shard. Used by tests.;public synchronized CheckpointState getTrackedLocalCheckpointForShard(String allocationId) {_        assert primaryMode__        return checkpoints.get(allocationId)__    };returns,the,local,checkpoint,information,tracked,for,a,specific,shard,used,by,tests;public,synchronized,checkpoint,state,get,tracked,local,checkpoint,for,shard,string,allocation,id,assert,primary,mode,return,checkpoints,get,allocation,id
ReplicationTracker -> public synchronized CheckpointState getTrackedLocalCheckpointForShard(String allocationId);1549949489;Returns the local checkpoint information tracked for a specific shard. Used by tests.;public synchronized CheckpointState getTrackedLocalCheckpointForShard(String allocationId) {_        assert primaryMode__        return checkpoints.get(allocationId)__    };returns,the,local,checkpoint,information,tracked,for,a,specific,shard,used,by,tests;public,synchronized,checkpoint,state,get,tracked,local,checkpoint,for,shard,string,allocation,id,assert,primary,mode,return,checkpoints,get,allocation,id
ReplicationTracker -> public synchronized CheckpointState getTrackedLocalCheckpointForShard(String allocationId);1550526771;Returns the local checkpoint information tracked for a specific shard. Used by tests.;public synchronized CheckpointState getTrackedLocalCheckpointForShard(String allocationId) {_        assert primaryMode__        return checkpoints.get(allocationId)__    };returns,the,local,checkpoint,information,tracked,for,a,specific,shard,used,by,tests;public,synchronized,checkpoint,state,get,tracked,local,checkpoint,for,shard,string,allocation,id,assert,primary,mode,return,checkpoints,get,allocation,id
ReplicationTracker -> public boolean isRelocated();1533295538;Returns whether the replication tracker has relocated away to another shard copy.;public boolean isRelocated() {_        return relocated__    };returns,whether,the,replication,tracker,has,relocated,away,to,another,shard,copy;public,boolean,is,relocated,return,relocated
ReplicationTracker -> public boolean isRelocated();1533738061;Returns whether the replication tracker has relocated away to another shard copy.;public boolean isRelocated() {_        return relocated__    };returns,whether,the,replication,tracker,has,relocated,away,to,another,shard,copy;public,boolean,is,relocated,return,relocated
ReplicationTracker -> public boolean isRelocated();1546875837;Returns whether the replication tracker has relocated away to another shard copy.;public boolean isRelocated() {_        return relocated__    };returns,whether,the,replication,tracker,has,relocated,away,to,another,shard,copy;public,boolean,is,relocated,return,relocated
ReplicationTracker -> public boolean isRelocated();1546927432;Returns whether the replication tracker has relocated away to another shard copy.;public boolean isRelocated() {_        return relocated__    };returns,whether,the,replication,tracker,has,relocated,away,to,another,shard,copy;public,boolean,is,relocated,return,relocated
ReplicationTracker -> public boolean isRelocated();1547332999;Returns whether the replication tracker has relocated away to another shard copy.;public boolean isRelocated() {_        return relocated__    };returns,whether,the,replication,tracker,has,relocated,away,to,another,shard,copy;public,boolean,is,relocated,return,relocated
ReplicationTracker -> public boolean isRelocated();1548593396;Returns whether the replication tracker has relocated away to another shard copy.;public boolean isRelocated() {_        return relocated__    };returns,whether,the,replication,tracker,has,relocated,away,to,another,shard,copy;public,boolean,is,relocated,return,relocated
ReplicationTracker -> public boolean isRelocated();1548594827;Returns whether the replication tracker has relocated away to another shard copy.;public boolean isRelocated() {_        return relocated__    };returns,whether,the,replication,tracker,has,relocated,away,to,another,shard,copy;public,boolean,is,relocated,return,relocated
ReplicationTracker -> public boolean isRelocated();1548677511;Returns whether the replication tracker has relocated away to another shard copy.;public boolean isRelocated() {_        return relocated__    };returns,whether,the,replication,tracker,has,relocated,away,to,another,shard,copy;public,boolean,is,relocated,return,relocated
ReplicationTracker -> public boolean isRelocated();1548944389;Returns whether the replication tracker has relocated away to another shard copy.;public boolean isRelocated() {_        return relocated__    };returns,whether,the,replication,tracker,has,relocated,away,to,another,shard,copy;public,boolean,is,relocated,return,relocated
ReplicationTracker -> public boolean isRelocated();1549059559;Returns whether the replication tracker has relocated away to another shard copy.;public boolean isRelocated() {_        return relocated__    };returns,whether,the,replication,tracker,has,relocated,away,to,another,shard,copy;public,boolean,is,relocated,return,relocated
ReplicationTracker -> public boolean isRelocated();1549294529;Returns whether the replication tracker has relocated away to another shard copy.;public boolean isRelocated() {_        return relocated__    };returns,whether,the,replication,tracker,has,relocated,away,to,another,shard,copy;public,boolean,is,relocated,return,relocated
ReplicationTracker -> public boolean isRelocated();1549395737;Returns whether the replication tracker has relocated away to another shard copy.;public boolean isRelocated() {_        return relocated__    };returns,whether,the,replication,tracker,has,relocated,away,to,another,shard,copy;public,boolean,is,relocated,return,relocated
ReplicationTracker -> public boolean isRelocated();1549937843;Returns whether the replication tracker has relocated away to another shard copy.;public boolean isRelocated() {_        return relocated__    };returns,whether,the,replication,tracker,has,relocated,away,to,another,shard,copy;public,boolean,is,relocated,return,relocated
ReplicationTracker -> public boolean isRelocated();1549949489;Returns whether the replication tracker has relocated away to another shard copy.;public boolean isRelocated() {_        return relocated__    };returns,whether,the,replication,tracker,has,relocated,away,to,another,shard,copy;public,boolean,is,relocated,return,relocated
ReplicationTracker -> public boolean isRelocated();1550526771;Returns whether the replication tracker has relocated away to another shard copy.;public boolean isRelocated() {_        return relocated__    };returns,whether,the,replication,tracker,has,relocated,away,to,another,shard,copy;public,boolean,is,relocated,return,relocated
