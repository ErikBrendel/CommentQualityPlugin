commented;modifiers;parameterAmount;loc;comment;code
true;protected;1;8;/**  * Resolve any strings in the ranges so we have a number value for the from  * and to of each range. The ranges are also sorted before being returned.  */ ;/**  * Resolve any strings in the ranges so we have a number value for the from  * and to of each range. The ranges are also sorted before being returned.  */ protected Range[] processRanges(Function<Range, Range> rangeProcessor) {     Range[] ranges = new Range[this.ranges.size()].     for (int i = 0. i < ranges.length. i++) {         ranges[i] = rangeProcessor.apply(this.ranges.get(i)).     }     sortRanges(ranges).     return ranges. }
false;protected;2;6;;@Override protected void swap(int i, int j) {     final Range tmp = ranges[i].     ranges[i] = ranges[j].     ranges[j] = tmp. }
false;protected;2;8;;@Override protected int compare(int i, int j) {     int cmp = Double.compare(ranges[i].from, ranges[j].from).     if (cmp == 0) {         cmp = Double.compare(ranges[i].to, ranges[j].to).     }     return cmp. }
false;private,static;1;20;;private static void sortRanges(final Range[] ranges) {     new InPlaceMergeSorter() {          @Override         protected void swap(int i, int j) {             final Range tmp = ranges[i].             ranges[i] = ranges[j].             ranges[j] = tmp.         }          @Override         protected int compare(int i, int j) {             int cmp = Double.compare(ranges[i].from, ranges[j].from).             if (cmp == 0) {                 cmp = Double.compare(ranges[i].to, ranges[j].to).             }             return cmp.         }     }.sort(0, ranges.length). }
false;protected;1;8;;@Override protected void innerWriteTo(StreamOutput out) throws IOException {     out.writeVInt(ranges.size()).     for (Range range : ranges) {         range.writeTo(out).     }     out.writeBoolean(keyed). }
false;public;1;7;;public AB addRange(R range) {     if (range == null) {         throw new IllegalArgumentException("[range] must not be null: [" + name + "]").     }     ranges.add(range).     return (AB) this. }
false;public;0;3;;public List<R> ranges() {     return ranges. }
false;public;1;4;;public AB keyed(boolean keyed) {     this.keyed = keyed.     return (AB) this. }
false;public;0;3;;public boolean keyed() {     return keyed. }
false;protected;2;6;;@Override protected XContentBuilder doXContentBody(XContentBuilder builder, Params params) throws IOException {     builder.field(RangeAggregator.RANGES_FIELD.getPreferredName(), ranges).     builder.field(RangeAggregator.KEYED_FIELD.getPreferredName(), keyed).     return builder. }
false;protected;0;4;;@Override protected int innerHashCode() {     return Objects.hash(ranges, keyed). }
false;protected;1;6;;@Override protected boolean innerEquals(Object obj) {     AbstractRangeBuilder<AB, R> other = (AbstractRangeBuilder<AB, R>) obj.     return Objects.equals(ranges, other.ranges) && Objects.equals(keyed, other.keyed). }
