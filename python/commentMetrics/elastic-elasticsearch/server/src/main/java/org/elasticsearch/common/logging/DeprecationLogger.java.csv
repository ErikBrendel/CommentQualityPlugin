commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;8;/**  * Set the {@link ThreadContext} used to add deprecation headers to network responses.  * <p>  * This is expected to <em>only</em> be invoked by the {@code Node}'s constructor (therefore once outside of tests).  *  * @param threadContext The thread context owned by the {@code ThreadPool} (and implicitly a {@code Node})  * @throws IllegalStateException if this {@code threadContext} has already been set  */ ;/**  * Set the {@link ThreadContext} used to add deprecation headers to network responses.  * <p>  * This is expected to <em>only</em> be invoked by the {@code Node}'s constructor (therefore once outside of tests).  *  * @param threadContext The thread context owned by the {@code ThreadPool} (and implicitly a {@code Node})  * @throws IllegalStateException if this {@code threadContext} has already been set  */ public static void setThreadContext(ThreadContext threadContext) {     Objects.requireNonNull(threadContext, "Cannot register a null ThreadContext").     // add returning false means it _did_ have it already     if (THREAD_CONTEXT.add(threadContext) == false) {         throw new IllegalStateException("Double-setting ThreadContext not allowed!").     } }
true;public,static;1;8;/**  * Remove the {@link ThreadContext} used to add deprecation headers to network responses.  * <p>  * This is expected to <em>only</em> be invoked by the {@code Node}'s {@code close} method (therefore once outside of tests).  *  * @param threadContext The thread context owned by the {@code ThreadPool} (and implicitly a {@code Node})  * @throws IllegalStateException if this {@code threadContext} is unknown (and presumably already unset before)  */ ;/**  * Remove the {@link ThreadContext} used to add deprecation headers to network responses.  * <p>  * This is expected to <em>only</em> be invoked by the {@code Node}'s {@code close} method (therefore once outside of tests).  *  * @param threadContext The thread context owned by the {@code ThreadPool} (and implicitly a {@code Node})  * @throws IllegalStateException if this {@code threadContext} is unknown (and presumably already unset before)  */ public static void removeThreadContext(ThreadContext threadContext) {     assert threadContext != null.     // remove returning false means it did not have it already     if (THREAD_CONTEXT.remove(threadContext) == false) {         throw new IllegalStateException("Removing unknown ThreadContext not allowed!").     } }
true;public;2;3;/**  * Logs a deprecation message, adding a formatted warning message as a response header on the thread context.  */ ;/**  * Logs a deprecation message, adding a formatted warning message as a response header on the thread context.  */ public void deprecated(String msg, Object... params) {     deprecated(THREAD_CONTEXT, msg, params). }
false;protected;1;4;;@Override protected boolean removeEldestEntry(final Map.Entry<String, Boolean> eldest) {     return size() > 128. }
true;public;3;3;/**  * Adds a formatted warning message as a response header on the thread context, and logs a deprecation message if the associated key has  * not recently been seen.  *  * @param key    the key used to determine if this deprecation should be logged  * @param msg    the message to log  * @param params parameters to the message  */ ;/**  * Adds a formatted warning message as a response header on the thread context, and logs a deprecation message if the associated key has  * not recently been seen.  *  * @param key    the key used to determine if this deprecation should be logged  * @param msg    the message to log  * @param params parameters to the message  */ public void deprecatedAndMaybeLog(final String key, final String msg, final Object... params) {     deprecated(THREAD_CONTEXT, msg, keys.add(key), params). }
true;public,static;1;19;/**  * Extracts the warning value from the value of a warning header that is formatted according to RFC 7234. That is, given a string  * {@code 299 Elasticsearch-6.0.0 "warning value"}, the return value of this method would be {@code warning value}.  *  * @param s the value of a warning header formatted according to RFC 7234.  * @return the extracted warning value  */ ;// closing quote (optional, since an older version can still send a warn-date) /**  * Extracts the warning value from the value of a warning header that is formatted according to RFC 7234. That is, given a string  * {@code 299 Elasticsearch-6.0.0 "warning value"}, the return value of this method would be {@code warning value}.  *  * @param s the value of a warning header formatted according to RFC 7234.  * @return the extracted warning value  */ public static String extractWarningValueFromWarningHeader(final String s) {     /*          * We know the exact format of the warning header, so to extract the warning value we can skip forward from the front to the first          * quote and we know the last quote is at the end of the string          *          *   299 Elasticsearch-6.0.0 "warning value"          *                           ^             ^          *                           firstQuote    lastQuote          *          * We parse this manually rather than using the capturing regular expression because the regular expression involves a lot of          * backtracking and carries a performance penalty. However, when assertions are enabled, we still use the regular expression to          * verify that we are maintaining the warning header format.          */     final int firstQuote = s.indexOf('\"').     final int lastQuote = s.length() - 1.     final String warningValue = s.substring(firstQuote + 1, lastQuote).     assert assertWarningValue(s, warningValue).     return warningValue. }
true;private,static;2;6;/**  * Assert that the specified string has the warning value equal to the provided warning value.  *  * @param s            the string representing a full warning header  * @param warningValue the expected warning header  * @return {@code true} if the specified string has the expected warning value  */ ;/**  * Assert that the specified string has the warning value equal to the provided warning value.  *  * @param s            the string representing a full warning header  * @param warningValue the expected warning header  * @return {@code true} if the specified string has the expected warning value  */ private static boolean assertWarningValue(final String s, final String warningValue) {     final Matcher matcher = WARNING_HEADER_PATTERN.matcher(s).     final boolean matches = matcher.matches().     assert matches.     return matcher.group(1).equals(warningValue). }
true;;3;3;/**  * Logs a deprecated message to the deprecation log, as well as to the local {@link ThreadContext}.  *  * @param threadContexts The node's {@link ThreadContext} (outside of concurrent tests, this should only ever have one context).  * @param message The deprecation message.  * @param params The parameters used to fill in the message, if any exist.  */ ;/**  * Logs a deprecated message to the deprecation log, as well as to the local {@link ThreadContext}.  *  * @param threadContexts The node's {@link ThreadContext} (outside of concurrent tests, this should only ever have one context).  * @param message The deprecation message.  * @param params The parameters used to fill in the message, if any exist.  */ void deprecated(final Set<ThreadContext> threadContexts, final String message, final Object... params) {     deprecated(threadContexts, message, true, params). }
false;public;0;6;;@SuppressLoggerChecks(reason = "safely delegates to logger") @Override public Void run() {     logger.warn(message, params).     return null. }
false;;4;29;;void deprecated(final Set<ThreadContext> threadContexts, final String message, final boolean log, final Object... params) {     final Iterator<ThreadContext> iterator = threadContexts.iterator().     if (iterator.hasNext()) {         final String formattedMessage = LoggerMessageFormat.format(message, params).         final String warningHeaderValue = formatWarning(formattedMessage).         assert WARNING_HEADER_PATTERN.matcher(warningHeaderValue).matches().         assert extractWarningValueFromWarningHeader(warningHeaderValue).equals(escapeAndEncode(formattedMessage)).         while (iterator.hasNext()) {             try {                 final ThreadContext next = iterator.next().                 next.addResponseHeader("Warning", warningHeaderValue).             } catch (final IllegalStateException e) {             // ignored. it should be removed shortly             }         }     }     if (log) {         AccessController.doPrivileged(new PrivilegedAction<Void>() {              @SuppressLoggerChecks(reason = "safely delegates to logger")             @Override             public Void run() {                 logger.warn(message, params).                 return null.             }         }).     } }
true;public,static;1;7;/**  * Format a warning string in the proper warning format by prepending a warn code, warn agent, wrapping the warning string in quotes,  * and appending the RFC 7231 date.  *  * @param s the warning string to format  * @return a warning value formatted according to RFC 7234  */ ;/**  * Format a warning string in the proper warning format by prepending a warn code, warn agent, wrapping the warning string in quotes,  * and appending the RFC 7231 date.  *  * @param s the warning string to format  * @return a warning value formatted according to RFC 7234  */ public static String formatWarning(final String s) {     // Assume that the common scenario won't have a string to escape and encode.     int length = WARNING_PREFIX.length() + s.length() + 3.     final StringBuilder sb = new StringBuilder(length).     sb.append(WARNING_PREFIX).append(" \"").append(escapeAndEncode(s)).append("\"").     return sb.toString(). }
true;public,static;1;3;/**  * Escape and encode a string as a valid RFC 7230 quoted-string.  *  * @param s the string to escape and encode  * @return the escaped and encoded string  */ ;/**  * Escape and encode a string as a valid RFC 7230 quoted-string.  *  * @param s the string to escape and encode  * @return the escaped and encoded string  */ public static String escapeAndEncode(final String s) {     return encode(escapeBackslashesAndQuotes(s)). }
true;static;1;27;/**  * Escape backslashes and quotes in the specified string.  *  * @param s the string to escape  * @return the escaped string  */ ;/**  * Escape backslashes and quotes in the specified string.  *  * @param s the string to escape  * @return the escaped string  */ static String escapeBackslashesAndQuotes(final String s) {     /*          * We want a fast path check to avoid creating the string builder and copying characters if needed. So we walk the string looking          * for either of the characters that we need to escape. If we find a character that needs escaping, we start over and          */     boolean escapingNeeded = false.     for (int i = 0. i < s.length(). i++) {         final char c = s.charAt(i).         if (c == '\\' || c == '"') {             escapingNeeded = true.             break.         }     }     if (escapingNeeded) {         final StringBuilder sb = new StringBuilder().         for (final char c : s.toCharArray()) {             if (c == '\\' || c == '"') {                 sb.append("\\").             }             sb.append(c).         }         return sb.toString().     } else {         return s.     } }
true;static;1;42;/**  * Encode a string containing characters outside of the legal characters for an RFC 7230 quoted-string.  *  * @param s the string to encode  * @return the encoded string  */ ;/**  * Encode a string containing characters outside of the legal characters for an RFC 7230 quoted-string.  *  * @param s the string to encode  * @return the encoded string  */ static String encode(final String s) {     // first check if the string needs any encoding. this is the fast path and we want to avoid creating a string builder and copying     boolean encodingNeeded = false.     for (int i = 0. i < s.length(). i++) {         int current = s.charAt(i).         if (doesNotNeedEncoding.get(current) == false) {             encodingNeeded = true.             break.         }     }     if (encodingNeeded == false) {         return s.     }     final StringBuilder sb = new StringBuilder(s.length()).     for (int i = 0. i < s.length(). ) {         int current = s.charAt(i).         /*              * Either the character does not need encoding or it does. when the character does not need encoding we append the character to              * a buffer and move to the next character and when the character does need encoding, we peel off as many characters as possible              * which we encode using UTF-8 until we encounter another character that does not need encoding.              */         if (doesNotNeedEncoding.get(current)) {             // append directly and move to the next character             sb.append((char) current).             i++.         } else {             int startIndex = i.             do {                 i++.             } while (i < s.length() && doesNotNeedEncoding.get(s.charAt(i)) == false).             final byte[] bytes = s.substring(startIndex, i).getBytes(UTF_8).             // noinspection ForLoopReplaceableByForEach             for (int j = 0. j < bytes.length. j++) {                 sb.append('%').append(hex(bytes[j] >> 4)).append(hex(bytes[j])).             }         }     }     return sb.toString(). }
false;private,static;1;8;;private static char hex(int b) {     final char ch = Character.forDigit(b & 0xF, 16).     if (Character.isLetter(ch)) {         return Character.toUpperCase(ch).     } else {         return ch.     } }
