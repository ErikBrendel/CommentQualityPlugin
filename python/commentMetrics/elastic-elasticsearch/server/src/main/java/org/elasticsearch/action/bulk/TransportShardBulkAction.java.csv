commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;4;;@Override protected TransportRequestOptions transportOptions(Settings settings) {     return BulkAction.INSTANCE.transportOptions(settings). }
false;protected;0;4;;@Override protected BulkShardResponse newResponseInstance() {     return new BulkShardResponse(). }
false;protected;0;4;;@Override protected boolean resolveIndex() {     return false. }
false;public;1;4;;@Override public void onNewClusterState(ClusterState state) {     waitingFuture.onResponse(null). }
false;public;0;4;;@Override public void onClusterServiceClose() {     waitingFuture.onFailure(new NodeClosedException(clusterService.localNode())). }
false;public;1;5;;@Override public void onTimeout(TimeValue timeout) {     waitingFuture.onFailure(new MapperException("timed out while waiting for a dynamic mapping update")). }
false;protected;2;28;;@Override protected WritePrimaryResult<BulkShardRequest, BulkShardResponse> shardOperationOnPrimary(BulkShardRequest request, IndexShard primary) throws Exception {     ClusterStateObserver observer = new ClusterStateObserver(clusterService, request.timeout(), logger, threadPool.getThreadContext()).     CheckedRunnable<Exception> waitForMappingUpdate = () -> {         PlainActionFuture<Void> waitingFuture = new PlainActionFuture<>().         observer.waitForNextChange(new ClusterStateObserver.Listener() {              @Override             public void onNewClusterState(ClusterState state) {                 waitingFuture.onResponse(null).             }              @Override             public void onClusterServiceClose() {                 waitingFuture.onFailure(new NodeClosedException(clusterService.localNode())).             }              @Override             public void onTimeout(TimeValue timeout) {                 waitingFuture.onFailure(new MapperException("timed out while waiting for a dynamic mapping update")).             }         }).         waitingFuture.get().     }.     return performOnPrimary(request, primary, updateHelper, threadPool::absoluteTimeInMillis, new ConcreteMappingUpdatePerformer(), waitForMappingUpdate). }
false;public,static;6;10;;public static WritePrimaryResult<BulkShardRequest, BulkShardResponse> performOnPrimary(BulkShardRequest request, IndexShard primary, UpdateHelper updateHelper, LongSupplier nowInMillisSupplier, MappingUpdatePerformer mappingUpdater, CheckedRunnable<Exception> waitForMappingUpdate) throws Exception {     BulkPrimaryExecutionContext context = new BulkPrimaryExecutionContext(request, primary).     return performOnPrimary(context, updateHelper, nowInMillisSupplier, mappingUpdater, waitForMappingUpdate). }
false;private,static;5;11;;private static WritePrimaryResult<BulkShardRequest, BulkShardResponse> performOnPrimary(BulkPrimaryExecutionContext context, UpdateHelper updateHelper, LongSupplier nowInMillisSupplier, MappingUpdatePerformer mappingUpdater, CheckedRunnable<Exception> waitForMappingUpdate) throws Exception {     while (context.hasMoreOperationsToExecute()) {         executeBulkItemRequest(context, updateHelper, nowInMillisSupplier, mappingUpdater, waitForMappingUpdate).         // either completed and moved to next or reset         assert context.isInitial().     }     return new WritePrimaryResult<>(context.getBulkShardRequest(), context.buildShardResponse(), context.getLocationToSync(), null, context.getPrimary(), logger). }
true;static;5;76;/**  * Executes bulk item requests and handles request execution exceptions  */ ;/**  * Executes bulk item requests and handles request execution exceptions  */ static void executeBulkItemRequest(BulkPrimaryExecutionContext context, UpdateHelper updateHelper, LongSupplier nowInMillisSupplier, MappingUpdatePerformer mappingUpdater, CheckedRunnable<Exception> waitForMappingUpdate) throws Exception {     final DocWriteRequest.OpType opType = context.getCurrent().opType().     final UpdateHelper.Result updateResult.     if (opType == DocWriteRequest.OpType.UPDATE) {         final UpdateRequest updateRequest = (UpdateRequest) context.getCurrent().         try {             updateResult = updateHelper.prepare(updateRequest, context.getPrimary(), nowInMillisSupplier).         } catch (Exception failure) {             // we may fail translating a update to index or delete operation             // we use index result to communicate failure while translating update request             final Engine.Result result = new Engine.IndexResult(failure, updateRequest.version(), SequenceNumbers.UNASSIGNED_SEQ_NO).             context.setRequestToExecute(updateRequest).             context.markOperationAsExecuted(result).             context.markAsCompleted(context.getExecutionResult()).             return.         }         // execute translated update request         switch(updateResult.getResponseResult()) {             case CREATED:             case UPDATED:                 IndexRequest indexRequest = updateResult.action().                 IndexMetaData metaData = context.getPrimary().indexSettings().getIndexMetaData().                 MappingMetaData mappingMd = metaData.mappingOrDefault().                 indexRequest.process(metaData.getCreationVersion(), mappingMd, updateRequest.concreteIndex()).                 context.setRequestToExecute(indexRequest).                 break.             case DELETED:                 context.setRequestToExecute(updateResult.action()).                 break.             case NOOP:                 context.markOperationAsNoOp(updateResult.action()).                 context.markAsCompleted(context.getExecutionResult()).                 return.             default:                 throw new IllegalStateException("Illegal update operation " + updateResult.getResponseResult()).         }     } else {         context.setRequestToExecute(context.getCurrent()).         updateResult = null.     }     // also checks that we're in TRANSLATED state     assert context.getRequestToExecute() != null.     if (context.getRequestToExecute().opType() == DocWriteRequest.OpType.DELETE) {         executeDeleteRequestOnPrimary(context, mappingUpdater).     } else {         executeIndexRequestOnPrimary(context, mappingUpdater).     }     if (context.requiresWaitingForMappingUpdate()) {         try {             waitForMappingUpdate.run().             context.resetForExecutionForRetry().         } catch (Exception e) {             context.failOnMappingUpdate(e).         }         return.     }     assert context.isOperationExecuted().     if (opType == DocWriteRequest.OpType.UPDATE && context.getExecutionResult().isFailed() && isConflictException(context.getExecutionResult().getFailure().getCause())) {         final UpdateRequest updateRequest = (UpdateRequest) context.getCurrent().         if (context.getRetryCounter() < updateRequest.retryOnConflict()) {             context.resetForExecutionForRetry().             return.         }     }     finalizePrimaryOperationOnCompletion(context, opType, updateResult). }
false;private,static;3;24;;private static void finalizePrimaryOperationOnCompletion(BulkPrimaryExecutionContext context, DocWriteRequest.OpType opType, UpdateHelper.Result updateResult) {     final BulkItemResponse executionResult = context.getExecutionResult().     if (opType == DocWriteRequest.OpType.UPDATE) {         final UpdateRequest updateRequest = (UpdateRequest) context.getCurrent().         context.markAsCompleted(processUpdateResponse(updateRequest, context.getConcreteIndex(), executionResult, updateResult)).     } else if (executionResult.isFailed()) {         final Exception failure = executionResult.getFailure().getCause().         final DocWriteRequest docWriteRequest = context.getCurrent().         if (TransportShardBulkAction.isConflictException(failure)) {             logger.trace(() -> new ParameterizedMessage("{} failed to execute bulk item ({}) {}", context.getPrimary().shardId(), docWriteRequest.opType().getLowercase(), docWriteRequest), failure).         } else {             logger.debug(() -> new ParameterizedMessage("{} failed to execute bulk item ({}) {}", context.getPrimary().shardId(), docWriteRequest.opType().getLowercase(), docWriteRequest), failure).         }         context.markAsCompleted(executionResult).     } else {         context.markAsCompleted(executionResult).     }     assert context.isInitial(). }
false;private,static;1;3;;private static boolean isConflictException(final Exception e) {     return ExceptionsHelper.unwrapCause(e) instanceof VersionConflictEngineException. }
true;static;4;44;/**  * Creates a new bulk item result from the given requests and result of performing the update operation on the shard.  */ ;/**  * Creates a new bulk item result from the given requests and result of performing the update operation on the shard.  */ static BulkItemResponse processUpdateResponse(final UpdateRequest updateRequest, final String concreteIndex, BulkItemResponse operationResponse, final UpdateHelper.Result translate) {     final BulkItemResponse response.     DocWriteResponse.Result translatedResult = translate.getResponseResult().     if (operationResponse.isFailed()) {         response = new BulkItemResponse(operationResponse.getItemId(), DocWriteRequest.OpType.UPDATE, operationResponse.getFailure()).     } else {         final UpdateResponse updateResponse.         if (translatedResult == DocWriteResponse.Result.CREATED || translatedResult == DocWriteResponse.Result.UPDATED) {             final IndexRequest updateIndexRequest = translate.action().             final IndexResponse indexResponse = operationResponse.getResponse().             updateResponse = new UpdateResponse(indexResponse.getShardInfo(), indexResponse.getShardId(), indexResponse.getType(), indexResponse.getId(), indexResponse.getSeqNo(), indexResponse.getPrimaryTerm(), indexResponse.getVersion(), indexResponse.getResult()).             if (updateRequest.fetchSource() != null && updateRequest.fetchSource().fetchSource()) {                 final BytesReference indexSourceAsBytes = updateIndexRequest.source().                 final Tuple<XContentType, Map<String, Object>> sourceAndContent = XContentHelper.convertToMap(indexSourceAsBytes, true, updateIndexRequest.getContentType()).                 updateResponse.setGetResult(UpdateHelper.extractGetResult(updateRequest, concreteIndex, indexResponse.getSeqNo(), indexResponse.getPrimaryTerm(), indexResponse.getVersion(), sourceAndContent.v2(), sourceAndContent.v1(), indexSourceAsBytes)).             }         } else if (translatedResult == DocWriteResponse.Result.DELETED) {             final DeleteResponse deleteResponse = operationResponse.getResponse().             updateResponse = new UpdateResponse(deleteResponse.getShardInfo(), deleteResponse.getShardId(), deleteResponse.getType(), deleteResponse.getId(), deleteResponse.getSeqNo(), deleteResponse.getPrimaryTerm(), deleteResponse.getVersion(), deleteResponse.getResult()).             final GetResult getResult = UpdateHelper.extractGetResult(updateRequest, concreteIndex, deleteResponse.getSeqNo(), deleteResponse.getPrimaryTerm(), deleteResponse.getVersion(), translate.updatedSourceAsMap(), translate.updateSourceContentType(), null).             updateResponse.setGetResult(getResult).         } else {             throw new IllegalArgumentException("unknown operation type: " + translatedResult).         }         response = new BulkItemResponse(operationResponse.getItemId(), DocWriteRequest.OpType.UPDATE, updateResponse).     }     return response. }
true;static;2;18;/**  * Determines whether a bulk item request should be executed on the replica.  *  * @return {@link ReplicaItemExecutionMode#NORMAL} upon normal primary execution with no failures  * {@link ReplicaItemExecutionMode#FAILURE} upon primary execution failure after sequence no generation  * {@link ReplicaItemExecutionMode#NOOP} upon primary execution failure before sequence no generation or  * when primary execution resulted in noop (only possible for write requests from pre-6.0 nodes)  */ ;/**  * Determines whether a bulk item request should be executed on the replica.  *  * @return {@link ReplicaItemExecutionMode#NORMAL} upon normal primary execution with no failures  * {@link ReplicaItemExecutionMode#FAILURE} upon primary execution failure after sequence no generation  * {@link ReplicaItemExecutionMode#NOOP} upon primary execution failure before sequence no generation or  * when primary execution resulted in noop (only possible for write requests from pre-6.0 nodes)  */ static ReplicaItemExecutionMode replicaItemExecutionMode(final BulkItemRequest request, final int index) {     final BulkItemResponse primaryResponse = request.getPrimaryResponse().     assert primaryResponse != null : "expected primary response to be set for item [" + index + "] request [" + request.request() + "]".     if (primaryResponse.isFailed()) {         return primaryResponse.getFailure().getSeqNo() != SequenceNumbers.UNASSIGNED_SEQ_NO ? // we have a seq no generated with the failure, replicate as no-op         ReplicaItemExecutionMode.FAILURE : // no seq no generated, ignore replication         ReplicaItemExecutionMode.NOOP.     } else {         // both failures and indexing operations.         return primaryResponse.getResponse().getResult() != DocWriteResponse.Result.NOOP ? // execution successful on primary         ReplicaItemExecutionMode.NORMAL : // ignore replication         ReplicaItemExecutionMode.NOOP.     } }
false;public;2;5;;@Override public WriteReplicaResult<BulkShardRequest> shardOperationOnReplica(BulkShardRequest request, IndexShard replica) throws Exception {     final Translog.Location location = performOnReplica(request, replica).     return new WriteReplicaResult<>(request, location, null, replica, logger). }
false;public,static;2;28;;public static Translog.Location performOnReplica(BulkShardRequest request, IndexShard replica) throws Exception {     Translog.Location location = null.     for (int i = 0. i < request.items().length. i++) {         BulkItemRequest item = request.items()[i].         final Engine.Result operationResult.         DocWriteRequest<?> docWriteRequest = item.request().         switch(replicaItemExecutionMode(item, i)) {             case NORMAL:                 final DocWriteResponse primaryResponse = item.getPrimaryResponse().getResponse().                 operationResult = performOpOnReplica(primaryResponse, docWriteRequest, replica).                 assert operationResult != null : "operation result must never be null when primary response has no failure".                 location = syncOperationResultOrThrow(operationResult, location).                 break.             case NOOP:                 break.             case FAILURE:                 final BulkItemResponse.Failure failure = item.getPrimaryResponse().getFailure().                 assert failure.getSeqNo() != SequenceNumbers.UNASSIGNED_SEQ_NO : "seq no must be assigned".                 operationResult = replica.markSeqNoAsNoop(failure.getSeqNo(), failure.getMessage()).                 assert operationResult != null : "operation result must never be null when primary response has no failure".                 location = syncOperationResultOrThrow(operationResult, location).                 break.             default:                 throw new IllegalStateException("illegal replica item execution mode for: " + docWriteRequest).         }     }     return location. }
false;private,static;3;36;;private static Engine.Result performOpOnReplica(DocWriteResponse primaryResponse, DocWriteRequest<?> docWriteRequest, IndexShard replica) throws Exception {     final Engine.Result result.     switch(docWriteRequest.opType()) {         case CREATE:         case INDEX:             final IndexRequest indexRequest = (IndexRequest) docWriteRequest.             final ShardId shardId = replica.shardId().             final SourceToParse sourceToParse = new SourceToParse(shardId.getIndexName(), indexRequest.type(), indexRequest.id(), indexRequest.source(), indexRequest.getContentType(), indexRequest.routing()).             result = replica.applyIndexOperationOnReplica(primaryResponse.getSeqNo(), primaryResponse.getVersion(), indexRequest.getAutoGeneratedTimestamp(), indexRequest.isRetry(), sourceToParse).             break.         case DELETE:             DeleteRequest deleteRequest = (DeleteRequest) docWriteRequest.             result = replica.applyDeleteOperationOnReplica(primaryResponse.getSeqNo(), primaryResponse.getVersion(), deleteRequest.type(), deleteRequest.id()).             break.         default:             throw new IllegalStateException("Unexpected request operation type on replica: " + docWriteRequest.opType().getLowercase()).     }     if (result.getResultType() == Engine.Result.Type.MAPPING_UPDATE_REQUIRED) {         // applied the new mapping, so there is no other option than to wait.         throw new TransportReplicationAction.RetryOnReplicaException(replica.shardId(), "Mappings are not available on the replica yet, triggered update: " + result.getRequiredMappingUpdate()).     }     return result. }
true;private,static;2;14;/**  * Executes index operation on primary shard after updates mapping if dynamic mappings are found  */ ;/**  * Executes index operation on primary shard after updates mapping if dynamic mappings are found  */ private static void executeIndexRequestOnPrimary(BulkPrimaryExecutionContext context, MappingUpdatePerformer mappingUpdater) throws Exception {     final IndexRequest request = context.getRequestToExecute().     final IndexShard primary = context.getPrimary().     final SourceToParse sourceToParse = new SourceToParse(request.index(), request.type(), request.id(), request.source(), request.getContentType(), request.routing()).     executeOnPrimaryWhileHandlingMappingUpdates(context, () -> primary.applyIndexOperationOnPrimary(request.version(), request.versionType(), sourceToParse, request.ifSeqNo(), request.ifPrimaryTerm(), request.getAutoGeneratedTimestamp(), request.isRetry()), e -> primary.getFailedIndexResult(e, request.version()), context::markOperationAsExecuted, mapping -> mappingUpdater.updateMappings(mapping, primary.shardId(), request.type())). }
false;private,static;2;11;;private static void executeDeleteRequestOnPrimary(BulkPrimaryExecutionContext context, MappingUpdatePerformer mappingUpdater) throws Exception {     final DeleteRequest request = context.getRequestToExecute().     final IndexShard primary = context.getPrimary().     executeOnPrimaryWhileHandlingMappingUpdates(context, () -> primary.applyDeleteOperationOnPrimary(request.version(), request.type(), request.id(), request.versionType(), request.ifSeqNo(), request.ifPrimaryTerm()), e -> primary.getFailedDeleteResult(e, request.version()), context::markOperationAsExecuted, mapping -> mappingUpdater.updateMappings(mapping, primary.shardId(), request.type())). }
false;private,static;5;20;;private static <T extends Engine.Result> void executeOnPrimaryWhileHandlingMappingUpdates(BulkPrimaryExecutionContext context, CheckedSupplier<T, IOException> toExecute, Function<Exception, T> exceptionToResult, Consumer<T> onComplete, Consumer<Mapping> mappingUpdater) throws IOException {     T result = toExecute.get().     if (result.getResultType() == Engine.Result.Type.MAPPING_UPDATE_REQUIRED) {         // try to update the mappings and mark the context as needing to try again.         try {             mappingUpdater.accept(result.getRequiredMappingUpdate()).             context.markAsRequiringMappingUpdate().         } catch (Exception e) {             // failure to update the mapping should translate to a failure of specific requests. Other requests             // still need to be executed and replicated.             onComplete.accept(exceptionToResult.apply(e)).             return.         }     } else {         onComplete.accept(result).     } }
false;public;3;8;;@Override public void updateMappings(final Mapping update, final ShardId shardId, final String type) {     assert update != null.     assert shardId != null.     // can throw timeout exception when updating mappings or ISE for attempting to     // update default mappings which are bubbled up     mappingUpdatedAction.updateMappingOnMaster(shardId.getIndex(), type, update). }
