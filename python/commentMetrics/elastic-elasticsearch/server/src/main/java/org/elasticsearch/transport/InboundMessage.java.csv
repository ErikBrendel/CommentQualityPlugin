commented;modifiers;parameterAmount;loc;comment;code
false;;0;3;;StreamInput getStreamInput() {     return streamInput. }
false;;1;57;;InboundMessage deserialize(BytesReference reference) throws IOException {     int messageLengthBytes = reference.length().     final int totalMessageSize = messageLengthBytes + TcpHeader.MARKER_BYTES_SIZE + TcpHeader.MESSAGE_LENGTH_SIZE.     // we have additional bytes to read, outside of the header     boolean hasMessageBytesToRead = (totalMessageSize - TcpHeader.HEADER_SIZE) > 0.     StreamInput streamInput = reference.streamInput().     boolean success = false.     try (ThreadContext.StoredContext existing = threadContext.stashContext()) {         long requestId = streamInput.readLong().         byte status = streamInput.readByte().         Version remoteVersion = Version.fromId(streamInput.readInt()).         final boolean isHandshake = TransportStatus.isHandshake(status).         ensureVersionCompatibility(remoteVersion, version, isHandshake).         if (TransportStatus.isCompress(status) && hasMessageBytesToRead && streamInput.available() > 0) {             Compressor compressor.             try {                 final int bytesConsumed = TcpHeader.REQUEST_ID_SIZE + TcpHeader.STATUS_SIZE + TcpHeader.VERSION_ID_SIZE.                 compressor = CompressorFactory.compressor(reference.slice(bytesConsumed, reference.length() - bytesConsumed)).             } catch (NotCompressedException ex) {                 int maxToRead = Math.min(reference.length(), 10).                 StringBuilder sb = new StringBuilder("stream marked as compressed, but no compressor found, first [").append(maxToRead).append("] content bytes out of [").append(reference.length()).append("] readable bytes with message size [").append(messageLengthBytes).append("] ").append("] are [").                 for (int i = 0. i < maxToRead. i++) {                     sb.append(reference.get(i)).append(",").                 }                 sb.append("]").                 throw new IllegalStateException(sb.toString()).             }             streamInput = compressor.streamInput(streamInput).         }         streamInput = new NamedWriteableAwareStreamInput(streamInput, namedWriteableRegistry).         streamInput.setVersion(remoteVersion).         threadContext.readHeaders(streamInput).         InboundMessage message.         if (TransportStatus.isRequest(status)) {             final Set<String> features.             if (remoteVersion.onOrAfter(Version.V_6_3_0)) {                 features = Collections.unmodifiableSet(new TreeSet<>(Arrays.asList(streamInput.readStringArray()))).             } else {                 features = Collections.emptySet().             }             final String action = streamInput.readString().             message = new RequestMessage(threadContext, remoteVersion, status, requestId, action, features, streamInput).         } else {             message = new ResponseMessage(threadContext, remoteVersion, status, requestId, streamInput).         }         success = true.         return message.     } finally {         if (success == false) {             IOUtils.closeWhileHandlingException(streamInput).         }     } }
false;public;0;4;;@Override public void close() throws IOException {     streamInput.close(). }
false;private,static;3;12;;private static void ensureVersionCompatibility(Version version, Version currentVersion, boolean isHandshake) {     // for handshakes we are compatible with N-2 since otherwise we can't figure out our initial version     // since we are compatible with N-1 and N+1 so we always send our minCompatVersion as the initial version in the     // handshake. This looks odd but it's required to establish the connection correctly we check for real compatibility     // once the connection is established     final Version compatibilityVersion = isHandshake ? currentVersion.minimumCompatibilityVersion() : currentVersion.     if (version.isCompatible(compatibilityVersion) == false) {         final Version minCompatibilityVersion = isHandshake ? compatibilityVersion : compatibilityVersion.minimumCompatibilityVersion().         String msg = "Received " + (isHandshake ? "handshake " : "") + "message from unsupported version: [".         throw new IllegalStateException(msg + version + "] minimal compatible version is: [" + minCompatibilityVersion + "]").     } }
false;;0;3;;String getActionName() {     return actionName. }
false;;0;3;;Set<String> getFeatures() {     return features. }
