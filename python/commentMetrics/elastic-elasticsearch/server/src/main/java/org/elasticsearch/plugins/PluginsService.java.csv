# id;timestamp;commentText;codeText;commentWords;codeWords
PluginsService -> public PluginsAndModules info();1524684173;Get information about plugins and modules;public PluginsAndModules info() {_        return info__    };get,information,about,plugins,and,modules;public,plugins,and,modules,info,return,info
PluginsService -> public PluginsAndModules info();1526900724;Get information about plugins and modules;public PluginsAndModules info() {_        return info__    };get,information,about,plugins,and,modules;public,plugins,and,modules,info,return,info
PluginsService -> public PluginsAndModules info();1527583663;Get information about plugins and modules;public PluginsAndModules info() {_        return info__    };get,information,about,plugins,and,modules;public,plugins,and,modules,info,return,info
PluginsService -> public PluginsAndModules info();1527878678;Get information about plugins and modules;public PluginsAndModules info() {_        return info__    };get,information,about,plugins,and,modules;public,plugins,and,modules,info,return,info
PluginsService -> public PluginsAndModules info();1528762805;Get information about plugins and modules;public PluginsAndModules info() {_        return info__    };get,information,about,plugins,and,modules;public,plugins,and,modules,info,return,info
PluginsService -> public PluginsAndModules info();1539615817;Get information about plugins and modules;public PluginsAndModules info() {_        return info__    };get,information,about,plugins,and,modules;public,plugins,and,modules,info,return,info
PluginsService -> public PluginsAndModules info();1540486836;Get information about plugins and modules;public PluginsAndModules info() {_        return info__    };get,information,about,plugins,and,modules;public,plugins,and,modules,info,return,info
PluginsService -> public PluginsAndModules info();1541008027;Get information about plugins and modules;public PluginsAndModules info() {_        return info__    };get,information,about,plugins,and,modules;public,plugins,and,modules,info,return,info
PluginsService -> public PluginsAndModules info();1541092382;Get information about plugins and modules;public PluginsAndModules info() {_        return info__    };get,information,about,plugins,and,modules;public,plugins,and,modules,info,return,info
PluginsService -> public PluginsAndModules info();1542402632;Get information about plugins and modules;public PluginsAndModules info() {_        return info__    };get,information,about,plugins,and,modules;public,plugins,and,modules,info,return,info
PluginsService -> public PluginsAndModules info();1544823664;Get information about plugins and modules;public PluginsAndModules info() {_        return info__    };get,information,about,plugins,and,modules;public,plugins,and,modules,info,return,info
PluginsService -> public PluginsAndModules info();1545199608;Get information about plugins and modules;public PluginsAndModules info() {_        return info__    };get,information,about,plugins,and,modules;public,plugins,and,modules,info,return,info
PluginsService -> public Collection<Class<? extends LifecycleComponent>> getGuiceServiceClasses();1524684173;Returns all classes injected into guice by plugins which extend {@link LifecycleComponent}.;public Collection<Class<? extends LifecycleComponent>> getGuiceServiceClasses() {_        List<Class<? extends LifecycleComponent>> services = new ArrayList<>()__        for (Tuple<PluginInfo, Plugin> plugin : plugins) {_            services.addAll(plugin.v2().getGuiceServiceClasses())__        }_        return services__    };returns,all,classes,injected,into,guice,by,plugins,which,extend,link,lifecycle,component;public,collection,class,extends,lifecycle,component,get,guice,service,classes,list,class,extends,lifecycle,component,services,new,array,list,for,tuple,plugin,info,plugin,plugin,plugins,services,add,all,plugin,v2,get,guice,service,classes,return,services
PluginsService -> public Collection<Class<? extends LifecycleComponent>> getGuiceServiceClasses();1526900724;Returns all classes injected into guice by plugins which extend {@link LifecycleComponent}.;public Collection<Class<? extends LifecycleComponent>> getGuiceServiceClasses() {_        List<Class<? extends LifecycleComponent>> services = new ArrayList<>()__        for (Tuple<PluginInfo, Plugin> plugin : plugins) {_            services.addAll(plugin.v2().getGuiceServiceClasses())__        }_        return services__    };returns,all,classes,injected,into,guice,by,plugins,which,extend,link,lifecycle,component;public,collection,class,extends,lifecycle,component,get,guice,service,classes,list,class,extends,lifecycle,component,services,new,array,list,for,tuple,plugin,info,plugin,plugin,plugins,services,add,all,plugin,v2,get,guice,service,classes,return,services
PluginsService -> public Collection<Class<? extends LifecycleComponent>> getGuiceServiceClasses();1527583663;Returns all classes injected into guice by plugins which extend {@link LifecycleComponent}.;public Collection<Class<? extends LifecycleComponent>> getGuiceServiceClasses() {_        List<Class<? extends LifecycleComponent>> services = new ArrayList<>()__        for (Tuple<PluginInfo, Plugin> plugin : plugins) {_            services.addAll(plugin.v2().getGuiceServiceClasses())__        }_        return services__    };returns,all,classes,injected,into,guice,by,plugins,which,extend,link,lifecycle,component;public,collection,class,extends,lifecycle,component,get,guice,service,classes,list,class,extends,lifecycle,component,services,new,array,list,for,tuple,plugin,info,plugin,plugin,plugins,services,add,all,plugin,v2,get,guice,service,classes,return,services
PluginsService -> public Collection<Class<? extends LifecycleComponent>> getGuiceServiceClasses();1527878678;Returns all classes injected into guice by plugins which extend {@link LifecycleComponent}.;public Collection<Class<? extends LifecycleComponent>> getGuiceServiceClasses() {_        List<Class<? extends LifecycleComponent>> services = new ArrayList<>()__        for (Tuple<PluginInfo, Plugin> plugin : plugins) {_            services.addAll(plugin.v2().getGuiceServiceClasses())__        }_        return services__    };returns,all,classes,injected,into,guice,by,plugins,which,extend,link,lifecycle,component;public,collection,class,extends,lifecycle,component,get,guice,service,classes,list,class,extends,lifecycle,component,services,new,array,list,for,tuple,plugin,info,plugin,plugin,plugins,services,add,all,plugin,v2,get,guice,service,classes,return,services
PluginsService -> public Collection<Class<? extends LifecycleComponent>> getGuiceServiceClasses();1528762805;Returns all classes injected into guice by plugins which extend {@link LifecycleComponent}.;public Collection<Class<? extends LifecycleComponent>> getGuiceServiceClasses() {_        List<Class<? extends LifecycleComponent>> services = new ArrayList<>()__        for (Tuple<PluginInfo, Plugin> plugin : plugins) {_            services.addAll(plugin.v2().getGuiceServiceClasses())__        }_        return services__    };returns,all,classes,injected,into,guice,by,plugins,which,extend,link,lifecycle,component;public,collection,class,extends,lifecycle,component,get,guice,service,classes,list,class,extends,lifecycle,component,services,new,array,list,for,tuple,plugin,info,plugin,plugin,plugins,services,add,all,plugin,v2,get,guice,service,classes,return,services
PluginsService -> public Collection<Class<? extends LifecycleComponent>> getGuiceServiceClasses();1539615817;Returns all classes injected into guice by plugins which extend {@link LifecycleComponent}.;public Collection<Class<? extends LifecycleComponent>> getGuiceServiceClasses() {_        List<Class<? extends LifecycleComponent>> services = new ArrayList<>()__        for (Tuple<PluginInfo, Plugin> plugin : plugins) {_            services.addAll(plugin.v2().getGuiceServiceClasses())__        }_        return services__    };returns,all,classes,injected,into,guice,by,plugins,which,extend,link,lifecycle,component;public,collection,class,extends,lifecycle,component,get,guice,service,classes,list,class,extends,lifecycle,component,services,new,array,list,for,tuple,plugin,info,plugin,plugin,plugins,services,add,all,plugin,v2,get,guice,service,classes,return,services
PluginsService -> public Collection<Class<? extends LifecycleComponent>> getGuiceServiceClasses();1540486836;Returns all classes injected into guice by plugins which extend {@link LifecycleComponent}.;public Collection<Class<? extends LifecycleComponent>> getGuiceServiceClasses() {_        List<Class<? extends LifecycleComponent>> services = new ArrayList<>()__        for (Tuple<PluginInfo, Plugin> plugin : plugins) {_            services.addAll(plugin.v2().getGuiceServiceClasses())__        }_        return services__    };returns,all,classes,injected,into,guice,by,plugins,which,extend,link,lifecycle,component;public,collection,class,extends,lifecycle,component,get,guice,service,classes,list,class,extends,lifecycle,component,services,new,array,list,for,tuple,plugin,info,plugin,plugin,plugins,services,add,all,plugin,v2,get,guice,service,classes,return,services
PluginsService -> public Collection<Class<? extends LifecycleComponent>> getGuiceServiceClasses();1541008027;Returns all classes injected into guice by plugins which extend {@link LifecycleComponent}.;public Collection<Class<? extends LifecycleComponent>> getGuiceServiceClasses() {_        List<Class<? extends LifecycleComponent>> services = new ArrayList<>()__        for (Tuple<PluginInfo, Plugin> plugin : plugins) {_            services.addAll(plugin.v2().getGuiceServiceClasses())__        }_        return services__    };returns,all,classes,injected,into,guice,by,plugins,which,extend,link,lifecycle,component;public,collection,class,extends,lifecycle,component,get,guice,service,classes,list,class,extends,lifecycle,component,services,new,array,list,for,tuple,plugin,info,plugin,plugin,plugins,services,add,all,plugin,v2,get,guice,service,classes,return,services
PluginsService -> public Collection<Class<? extends LifecycleComponent>> getGuiceServiceClasses();1541092382;Returns all classes injected into guice by plugins which extend {@link LifecycleComponent}.;public Collection<Class<? extends LifecycleComponent>> getGuiceServiceClasses() {_        List<Class<? extends LifecycleComponent>> services = new ArrayList<>()__        for (Tuple<PluginInfo, Plugin> plugin : plugins) {_            services.addAll(plugin.v2().getGuiceServiceClasses())__        }_        return services__    };returns,all,classes,injected,into,guice,by,plugins,which,extend,link,lifecycle,component;public,collection,class,extends,lifecycle,component,get,guice,service,classes,list,class,extends,lifecycle,component,services,new,array,list,for,tuple,plugin,info,plugin,plugin,plugins,services,add,all,plugin,v2,get,guice,service,classes,return,services
PluginsService -> public Collection<Class<? extends LifecycleComponent>> getGuiceServiceClasses();1542402632;Returns all classes injected into guice by plugins which extend {@link LifecycleComponent}.;public Collection<Class<? extends LifecycleComponent>> getGuiceServiceClasses() {_        List<Class<? extends LifecycleComponent>> services = new ArrayList<>()__        for (Tuple<PluginInfo, Plugin> plugin : plugins) {_            services.addAll(plugin.v2().getGuiceServiceClasses())__        }_        return services__    };returns,all,classes,injected,into,guice,by,plugins,which,extend,link,lifecycle,component;public,collection,class,extends,lifecycle,component,get,guice,service,classes,list,class,extends,lifecycle,component,services,new,array,list,for,tuple,plugin,info,plugin,plugin,plugins,services,add,all,plugin,v2,get,guice,service,classes,return,services
PluginsService -> public Collection<Class<? extends LifecycleComponent>> getGuiceServiceClasses();1544823664;Returns all classes injected into guice by plugins which extend {@link LifecycleComponent}.;public Collection<Class<? extends LifecycleComponent>> getGuiceServiceClasses() {_        List<Class<? extends LifecycleComponent>> services = new ArrayList<>()__        for (Tuple<PluginInfo, Plugin> plugin : plugins) {_            services.addAll(plugin.v2().getGuiceServiceClasses())__        }_        return services__    };returns,all,classes,injected,into,guice,by,plugins,which,extend,link,lifecycle,component;public,collection,class,extends,lifecycle,component,get,guice,service,classes,list,class,extends,lifecycle,component,services,new,array,list,for,tuple,plugin,info,plugin,plugin,plugins,services,add,all,plugin,v2,get,guice,service,classes,return,services
PluginsService -> public Collection<Class<? extends LifecycleComponent>> getGuiceServiceClasses();1545199608;Returns all classes injected into guice by plugins which extend {@link LifecycleComponent}.;public Collection<Class<? extends LifecycleComponent>> getGuiceServiceClasses() {_        List<Class<? extends LifecycleComponent>> services = new ArrayList<>()__        for (Tuple<PluginInfo, Plugin> plugin : plugins) {_            services.addAll(plugin.v2().getGuiceServiceClasses())__        }_        return services__    };returns,all,classes,injected,into,guice,by,plugins,which,extend,link,lifecycle,component;public,collection,class,extends,lifecycle,component,get,guice,service,classes,list,class,extends,lifecycle,component,services,new,array,list,for,tuple,plugin,info,plugin,plugin,plugins,services,add,all,plugin,v2,get,guice,service,classes,return,services
PluginsService -> static void reloadLuceneSPI(ClassLoader loader);1524684173;Reloads all Lucene SPI implementations using the new classloader._This method must be called after the new classloader has been created to_register the services for use.;static void reloadLuceneSPI(ClassLoader loader) {_        __        _        PostingsFormat.reloadPostingsFormats(loader)__        DocValuesFormat.reloadDocValuesFormats(loader)__        Codec.reloadCodecs(loader)__        _        CharFilterFactory.reloadCharFilters(loader)__        TokenFilterFactory.reloadTokenFilters(loader)__        TokenizerFactory.reloadTokenizers(loader)__    };reloads,all,lucene,spi,implementations,using,the,new,classloader,this,method,must,be,called,after,the,new,classloader,has,been,created,to,register,the,services,for,use;static,void,reload,lucene,spi,class,loader,loader,postings,format,reload,postings,formats,loader,doc,values,format,reload,doc,values,formats,loader,codec,reload,codecs,loader,char,filter,factory,reload,char,filters,loader,token,filter,factory,reload,token,filters,loader,tokenizer,factory,reload,tokenizers,loader
PluginsService -> static void reloadLuceneSPI(ClassLoader loader);1526900724;Reloads all Lucene SPI implementations using the new classloader._This method must be called after the new classloader has been created to_register the services for use.;static void reloadLuceneSPI(ClassLoader loader) {_        __        _        PostingsFormat.reloadPostingsFormats(loader)__        DocValuesFormat.reloadDocValuesFormats(loader)__        Codec.reloadCodecs(loader)__        _        CharFilterFactory.reloadCharFilters(loader)__        TokenFilterFactory.reloadTokenFilters(loader)__        TokenizerFactory.reloadTokenizers(loader)__    };reloads,all,lucene,spi,implementations,using,the,new,classloader,this,method,must,be,called,after,the,new,classloader,has,been,created,to,register,the,services,for,use;static,void,reload,lucene,spi,class,loader,loader,postings,format,reload,postings,formats,loader,doc,values,format,reload,doc,values,formats,loader,codec,reload,codecs,loader,char,filter,factory,reload,char,filters,loader,token,filter,factory,reload,token,filters,loader,tokenizer,factory,reload,tokenizers,loader
PluginsService -> static void reloadLuceneSPI(ClassLoader loader);1527583663;Reloads all Lucene SPI implementations using the new classloader._This method must be called after the new classloader has been created to_register the services for use.;static void reloadLuceneSPI(ClassLoader loader) {_        __        _        PostingsFormat.reloadPostingsFormats(loader)__        DocValuesFormat.reloadDocValuesFormats(loader)__        Codec.reloadCodecs(loader)__        _        CharFilterFactory.reloadCharFilters(loader)__        TokenFilterFactory.reloadTokenFilters(loader)__        TokenizerFactory.reloadTokenizers(loader)__    };reloads,all,lucene,spi,implementations,using,the,new,classloader,this,method,must,be,called,after,the,new,classloader,has,been,created,to,register,the,services,for,use;static,void,reload,lucene,spi,class,loader,loader,postings,format,reload,postings,formats,loader,doc,values,format,reload,doc,values,formats,loader,codec,reload,codecs,loader,char,filter,factory,reload,char,filters,loader,token,filter,factory,reload,token,filters,loader,tokenizer,factory,reload,tokenizers,loader
PluginsService -> static void reloadLuceneSPI(ClassLoader loader);1527878678;Reloads all Lucene SPI implementations using the new classloader._This method must be called after the new classloader has been created to_register the services for use.;static void reloadLuceneSPI(ClassLoader loader) {_        __        _        PostingsFormat.reloadPostingsFormats(loader)__        DocValuesFormat.reloadDocValuesFormats(loader)__        Codec.reloadCodecs(loader)__        _        CharFilterFactory.reloadCharFilters(loader)__        TokenFilterFactory.reloadTokenFilters(loader)__        TokenizerFactory.reloadTokenizers(loader)__    };reloads,all,lucene,spi,implementations,using,the,new,classloader,this,method,must,be,called,after,the,new,classloader,has,been,created,to,register,the,services,for,use;static,void,reload,lucene,spi,class,loader,loader,postings,format,reload,postings,formats,loader,doc,values,format,reload,doc,values,formats,loader,codec,reload,codecs,loader,char,filter,factory,reload,char,filters,loader,token,filter,factory,reload,token,filters,loader,tokenizer,factory,reload,tokenizers,loader
PluginsService -> static void reloadLuceneSPI(ClassLoader loader);1528762805;Reloads all Lucene SPI implementations using the new classloader._This method must be called after the new classloader has been created to_register the services for use.;static void reloadLuceneSPI(ClassLoader loader) {_        __        _        PostingsFormat.reloadPostingsFormats(loader)__        DocValuesFormat.reloadDocValuesFormats(loader)__        Codec.reloadCodecs(loader)__        _        CharFilterFactory.reloadCharFilters(loader)__        TokenFilterFactory.reloadTokenFilters(loader)__        TokenizerFactory.reloadTokenizers(loader)__    };reloads,all,lucene,spi,implementations,using,the,new,classloader,this,method,must,be,called,after,the,new,classloader,has,been,created,to,register,the,services,for,use;static,void,reload,lucene,spi,class,loader,loader,postings,format,reload,postings,formats,loader,doc,values,format,reload,doc,values,formats,loader,codec,reload,codecs,loader,char,filter,factory,reload,char,filters,loader,token,filter,factory,reload,token,filters,loader,tokenizer,factory,reload,tokenizers,loader
PluginsService -> static void reloadLuceneSPI(ClassLoader loader);1539615817;Reloads all Lucene SPI implementations using the new classloader._This method must be called after the new classloader has been created to_register the services for use.;static void reloadLuceneSPI(ClassLoader loader) {_        __        _        PostingsFormat.reloadPostingsFormats(loader)__        DocValuesFormat.reloadDocValuesFormats(loader)__        Codec.reloadCodecs(loader)__        _        CharFilterFactory.reloadCharFilters(loader)__        TokenFilterFactory.reloadTokenFilters(loader)__        TokenizerFactory.reloadTokenizers(loader)__    };reloads,all,lucene,spi,implementations,using,the,new,classloader,this,method,must,be,called,after,the,new,classloader,has,been,created,to,register,the,services,for,use;static,void,reload,lucene,spi,class,loader,loader,postings,format,reload,postings,formats,loader,doc,values,format,reload,doc,values,formats,loader,codec,reload,codecs,loader,char,filter,factory,reload,char,filters,loader,token,filter,factory,reload,token,filters,loader,tokenizer,factory,reload,tokenizers,loader
PluginsService -> static void reloadLuceneSPI(ClassLoader loader);1540486836;Reloads all Lucene SPI implementations using the new classloader._This method must be called after the new classloader has been created to_register the services for use.;static void reloadLuceneSPI(ClassLoader loader) {_        __        _        PostingsFormat.reloadPostingsFormats(loader)__        DocValuesFormat.reloadDocValuesFormats(loader)__        Codec.reloadCodecs(loader)__        _        CharFilterFactory.reloadCharFilters(loader)__        TokenFilterFactory.reloadTokenFilters(loader)__        TokenizerFactory.reloadTokenizers(loader)__    };reloads,all,lucene,spi,implementations,using,the,new,classloader,this,method,must,be,called,after,the,new,classloader,has,been,created,to,register,the,services,for,use;static,void,reload,lucene,spi,class,loader,loader,postings,format,reload,postings,formats,loader,doc,values,format,reload,doc,values,formats,loader,codec,reload,codecs,loader,char,filter,factory,reload,char,filters,loader,token,filter,factory,reload,token,filters,loader,tokenizer,factory,reload,tokenizers,loader
PluginsService -> static void reloadLuceneSPI(ClassLoader loader);1541008027;Reloads all Lucene SPI implementations using the new classloader._This method must be called after the new classloader has been created to_register the services for use.;static void reloadLuceneSPI(ClassLoader loader) {_        __        _        PostingsFormat.reloadPostingsFormats(loader)__        DocValuesFormat.reloadDocValuesFormats(loader)__        Codec.reloadCodecs(loader)__        _        CharFilterFactory.reloadCharFilters(loader)__        TokenFilterFactory.reloadTokenFilters(loader)__        TokenizerFactory.reloadTokenizers(loader)__    };reloads,all,lucene,spi,implementations,using,the,new,classloader,this,method,must,be,called,after,the,new,classloader,has,been,created,to,register,the,services,for,use;static,void,reload,lucene,spi,class,loader,loader,postings,format,reload,postings,formats,loader,doc,values,format,reload,doc,values,formats,loader,codec,reload,codecs,loader,char,filter,factory,reload,char,filters,loader,token,filter,factory,reload,token,filters,loader,tokenizer,factory,reload,tokenizers,loader
PluginsService -> static void reloadLuceneSPI(ClassLoader loader);1541092382;Reloads all Lucene SPI implementations using the new classloader._This method must be called after the new classloader has been created to_register the services for use.;static void reloadLuceneSPI(ClassLoader loader) {_        __        _        PostingsFormat.reloadPostingsFormats(loader)__        DocValuesFormat.reloadDocValuesFormats(loader)__        Codec.reloadCodecs(loader)__        _        CharFilterFactory.reloadCharFilters(loader)__        TokenFilterFactory.reloadTokenFilters(loader)__        TokenizerFactory.reloadTokenizers(loader)__    };reloads,all,lucene,spi,implementations,using,the,new,classloader,this,method,must,be,called,after,the,new,classloader,has,been,created,to,register,the,services,for,use;static,void,reload,lucene,spi,class,loader,loader,postings,format,reload,postings,formats,loader,doc,values,format,reload,doc,values,formats,loader,codec,reload,codecs,loader,char,filter,factory,reload,char,filters,loader,token,filter,factory,reload,token,filters,loader,tokenizer,factory,reload,tokenizers,loader
PluginsService -> static void reloadLuceneSPI(ClassLoader loader);1542402632;Reloads all Lucene SPI implementations using the new classloader._This method must be called after the new classloader has been created to_register the services for use.;static void reloadLuceneSPI(ClassLoader loader) {_        __        _        PostingsFormat.reloadPostingsFormats(loader)__        DocValuesFormat.reloadDocValuesFormats(loader)__        Codec.reloadCodecs(loader)__        _        CharFilterFactory.reloadCharFilters(loader)__        TokenFilterFactory.reloadTokenFilters(loader)__        TokenizerFactory.reloadTokenizers(loader)__    };reloads,all,lucene,spi,implementations,using,the,new,classloader,this,method,must,be,called,after,the,new,classloader,has,been,created,to,register,the,services,for,use;static,void,reload,lucene,spi,class,loader,loader,postings,format,reload,postings,formats,loader,doc,values,format,reload,doc,values,formats,loader,codec,reload,codecs,loader,char,filter,factory,reload,char,filters,loader,token,filter,factory,reload,token,filters,loader,tokenizer,factory,reload,tokenizers,loader
PluginsService -> static void reloadLuceneSPI(ClassLoader loader);1544823664;Reloads all Lucene SPI implementations using the new classloader._This method must be called after the new classloader has been created to_register the services for use.;static void reloadLuceneSPI(ClassLoader loader) {_        __        _        PostingsFormat.reloadPostingsFormats(loader)__        DocValuesFormat.reloadDocValuesFormats(loader)__        Codec.reloadCodecs(loader)__        _        CharFilterFactory.reloadCharFilters(loader)__        TokenFilterFactory.reloadTokenFilters(loader)__        TokenizerFactory.reloadTokenizers(loader)__    };reloads,all,lucene,spi,implementations,using,the,new,classloader,this,method,must,be,called,after,the,new,classloader,has,been,created,to,register,the,services,for,use;static,void,reload,lucene,spi,class,loader,loader,postings,format,reload,postings,formats,loader,doc,values,format,reload,doc,values,formats,loader,codec,reload,codecs,loader,char,filter,factory,reload,char,filters,loader,token,filter,factory,reload,token,filters,loader,tokenizer,factory,reload,tokenizers,loader
PluginsService -> static void reloadLuceneSPI(ClassLoader loader);1545199608;Reloads all Lucene SPI implementations using the new classloader._This method must be called after the new classloader has been created to_register the services for use.;static void reloadLuceneSPI(ClassLoader loader) {_        __        _        PostingsFormat.reloadPostingsFormats(loader)__        DocValuesFormat.reloadDocValuesFormats(loader)__        Codec.reloadCodecs(loader)__        _        CharFilterFactory.reloadCharFilters(loader)__        TokenFilterFactory.reloadTokenFilters(loader)__        TokenizerFactory.reloadTokenizers(loader)__    };reloads,all,lucene,spi,implementations,using,the,new,classloader,this,method,must,be,called,after,the,new,classloader,has,been,created,to,register,the,services,for,use;static,void,reload,lucene,spi,class,loader,loader,postings,format,reload,postings,formats,loader,doc,values,format,reload,doc,values,formats,loader,codec,reload,codecs,loader,char,filter,factory,reload,char,filters,loader,token,filter,factory,reload,token,filters,loader,tokenizer,factory,reload,tokenizers,loader
PluginsService -> public PluginsService(Settings settings, Path configPath, Path modulesDirectory, Path pluginsDirectory, Collection<Class<? extends Plugin>> classpathPlugins);1524684173;Constructs a new PluginService_@param settings The settings of the system_@param modulesDirectory The directory modules exist in, or null if modules should not be loaded from the filesystem_@param pluginsDirectory The directory plugins exist in, or null if plugins should not be loaded from the filesystem_@param classpathPlugins Plugins that exist in the classpath which should be loaded;public PluginsService(Settings settings, Path configPath, Path modulesDirectory, Path pluginsDirectory, Collection<Class<? extends Plugin>> classpathPlugins) {_        super(settings)___        this.configPath = configPath___        List<Tuple<PluginInfo, Plugin>> pluginsLoaded = new ArrayList<>()__        List<PluginInfo> pluginsList = new ArrayList<>()__        _        final List<String> pluginsNames = new ArrayList<>()__        _        for (Class<? extends Plugin> pluginClass : classpathPlugins) {_            Plugin plugin = loadPlugin(pluginClass, settings, configPath)__            PluginInfo pluginInfo = new PluginInfo(pluginClass.getName(), "classpath plugin", "NA", Version.CURRENT, "1.8",_                                                   pluginClass.getName(), Collections.emptyList(), false)__            if (logger.isTraceEnabled()) {_                logger.trace("plugin loaded from classpath [{}]", pluginInfo)__            }_            pluginsLoaded.add(new Tuple<>(pluginInfo, plugin))__            pluginsList.add(pluginInfo)__            pluginsNames.add(pluginInfo.getName())__        }__        Set<Bundle> seenBundles = new LinkedHashSet<>()__        List<PluginInfo> modulesList = new ArrayList<>()__        _        if (modulesDirectory != null) {_            try {_                Set<Bundle> modules = getModuleBundles(modulesDirectory)__                for (Bundle bundle : modules) {_                    modulesList.add(bundle.plugin)__                }_                seenBundles.addAll(modules)__            } catch (IOException ex) {_                throw new IllegalStateException("Unable to initialize modules", ex)__            }_        }__        _        if (pluginsDirectory != null) {_            try {_                _                if (isAccessibleDirectory(pluginsDirectory, logger)) {_                    checkForFailedPluginRemovals(pluginsDirectory)__                    _                    List<BundleCollection> plugins = findBundles(pluginsDirectory, "plugin")__                    for (final BundleCollection plugin : plugins) {_                        final Collection<Bundle> bundles = plugin.bundles()__                        for (final Bundle bundle : bundles) {_                            pluginsList.add(bundle.plugin)__                        }_                        seenBundles.addAll(bundles)__                        pluginsNames.add(plugin.name())__                    }_                }_            } catch (IOException ex) {_                throw new IllegalStateException("Unable to initialize plugins", ex)__            }_        }__        List<Tuple<PluginInfo, Plugin>> loaded = loadBundles(seenBundles)__        pluginsLoaded.addAll(loaded)___        this.info = new PluginsAndModules(pluginsList, modulesList)__        this.plugins = Collections.unmodifiableList(pluginsLoaded)___        _        List<String> mandatoryPlugins = MANDATORY_SETTING.get(settings)__        if (mandatoryPlugins.isEmpty() == false) {_            Set<String> missingPlugins = new HashSet<>()__            for (String mandatoryPlugin : mandatoryPlugins) {_                if (!pluginsNames.contains(mandatoryPlugin) && !missingPlugins.contains(mandatoryPlugin)) {_                    missingPlugins.add(mandatoryPlugin)__                }_            }_            if (!missingPlugins.isEmpty()) {_                final String message = String.format(_                        Locale.ROOT,_                        "missing mandatory plugins [%s], found plugins [%s]",_                        Strings.collectionToDelimitedString(missingPlugins, ", "),_                        Strings.collectionToDelimitedString(pluginsNames, ", "))__                throw new IllegalStateException(message)__            }_        }__        _        _        logPluginInfo(info.getModuleInfos(), "module", logger)__        logPluginInfo(info.getPluginInfos(), "plugin", logger)__    };constructs,a,new,plugin,service,param,settings,the,settings,of,the,system,param,modules,directory,the,directory,modules,exist,in,or,null,if,modules,should,not,be,loaded,from,the,filesystem,param,plugins,directory,the,directory,plugins,exist,in,or,null,if,plugins,should,not,be,loaded,from,the,filesystem,param,classpath,plugins,plugins,that,exist,in,the,classpath,which,should,be,loaded;public,plugins,service,settings,settings,path,config,path,path,modules,directory,path,plugins,directory,collection,class,extends,plugin,classpath,plugins,super,settings,this,config,path,config,path,list,tuple,plugin,info,plugin,plugins,loaded,new,array,list,list,plugin,info,plugins,list,new,array,list,final,list,string,plugins,names,new,array,list,for,class,extends,plugin,plugin,class,classpath,plugins,plugin,plugin,load,plugin,plugin,class,settings,config,path,plugin,info,plugin,info,new,plugin,info,plugin,class,get,name,classpath,plugin,na,version,current,1,8,plugin,class,get,name,collections,empty,list,false,if,logger,is,trace,enabled,logger,trace,plugin,loaded,from,classpath,plugin,info,plugins,loaded,add,new,tuple,plugin,info,plugin,plugins,list,add,plugin,info,plugins,names,add,plugin,info,get,name,set,bundle,seen,bundles,new,linked,hash,set,list,plugin,info,modules,list,new,array,list,if,modules,directory,null,try,set,bundle,modules,get,module,bundles,modules,directory,for,bundle,bundle,modules,modules,list,add,bundle,plugin,seen,bundles,add,all,modules,catch,ioexception,ex,throw,new,illegal,state,exception,unable,to,initialize,modules,ex,if,plugins,directory,null,try,if,is,accessible,directory,plugins,directory,logger,check,for,failed,plugin,removals,plugins,directory,list,bundle,collection,plugins,find,bundles,plugins,directory,plugin,for,final,bundle,collection,plugin,plugins,final,collection,bundle,bundles,plugin,bundles,for,final,bundle,bundle,bundles,plugins,list,add,bundle,plugin,seen,bundles,add,all,bundles,plugins,names,add,plugin,name,catch,ioexception,ex,throw,new,illegal,state,exception,unable,to,initialize,plugins,ex,list,tuple,plugin,info,plugin,loaded,load,bundles,seen,bundles,plugins,loaded,add,all,loaded,this,info,new,plugins,and,modules,plugins,list,modules,list,this,plugins,collections,unmodifiable,list,plugins,loaded,list,string,mandatory,plugins,get,settings,if,mandatory,plugins,is,empty,false,set,string,missing,plugins,new,hash,set,for,string,mandatory,plugin,mandatory,plugins,if,plugins,names,contains,mandatory,plugin,missing,plugins,contains,mandatory,plugin,missing,plugins,add,mandatory,plugin,if,missing,plugins,is,empty,final,string,message,string,format,locale,root,missing,mandatory,plugins,s,found,plugins,s,strings,collection,to,delimited,string,missing,plugins,strings,collection,to,delimited,string,plugins,names,throw,new,illegal,state,exception,message,log,plugin,info,info,get,module,infos,module,logger,log,plugin,info,info,get,plugin,infos,plugin,logger
PluginsService -> public PluginsService(Settings settings, Path configPath, Path modulesDirectory, Path pluginsDirectory, Collection<Class<? extends Plugin>> classpathPlugins);1526900724;Constructs a new PluginService_@param settings The settings of the system_@param modulesDirectory The directory modules exist in, or null if modules should not be loaded from the filesystem_@param pluginsDirectory The directory plugins exist in, or null if plugins should not be loaded from the filesystem_@param classpathPlugins Plugins that exist in the classpath which should be loaded;public PluginsService(Settings settings, Path configPath, Path modulesDirectory, Path pluginsDirectory, Collection<Class<? extends Plugin>> classpathPlugins) {_        super(settings)___        this.configPath = configPath___        List<Tuple<PluginInfo, Plugin>> pluginsLoaded = new ArrayList<>()__        List<PluginInfo> pluginsList = new ArrayList<>()__        _        final List<String> pluginsNames = new ArrayList<>()__        _        for (Class<? extends Plugin> pluginClass : classpathPlugins) {_            Plugin plugin = loadPlugin(pluginClass, settings, configPath)__            PluginInfo pluginInfo = new PluginInfo(pluginClass.getName(), "classpath plugin", "NA", Version.CURRENT, "1.8",_                                                   pluginClass.getName(), Collections.emptyList(), false)__            if (logger.isTraceEnabled()) {_                logger.trace("plugin loaded from classpath [{}]", pluginInfo)__            }_            pluginsLoaded.add(new Tuple<>(pluginInfo, plugin))__            pluginsList.add(pluginInfo)__            pluginsNames.add(pluginInfo.getName())__        }__        Set<Bundle> seenBundles = new LinkedHashSet<>()__        List<PluginInfo> modulesList = new ArrayList<>()__        _        if (modulesDirectory != null) {_            try {_                Set<Bundle> modules = getModuleBundles(modulesDirectory)__                for (Bundle bundle : modules) {_                    modulesList.add(bundle.plugin)__                }_                seenBundles.addAll(modules)__            } catch (IOException ex) {_                throw new IllegalStateException("Unable to initialize modules", ex)__            }_        }__        _        if (pluginsDirectory != null) {_            try {_                _                if (isAccessibleDirectory(pluginsDirectory, logger)) {_                    checkForFailedPluginRemovals(pluginsDirectory)__                    Set<Bundle> plugins = getPluginBundles(pluginsDirectory)__                    for (final Bundle bundle : plugins) {_                        pluginsList.add(bundle.plugin)__                        pluginsNames.add(bundle.plugin.getName())__                    }_                    seenBundles.addAll(plugins)__                }_            } catch (IOException ex) {_                throw new IllegalStateException("Unable to initialize plugins", ex)__            }_        }__        List<Tuple<PluginInfo, Plugin>> loaded = loadBundles(seenBundles)__        pluginsLoaded.addAll(loaded)___        this.info = new PluginsAndModules(pluginsList, modulesList)__        this.plugins = Collections.unmodifiableList(pluginsLoaded)___        _        List<String> mandatoryPlugins = MANDATORY_SETTING.get(settings)__        if (mandatoryPlugins.isEmpty() == false) {_            Set<String> missingPlugins = new HashSet<>()__            for (String mandatoryPlugin : mandatoryPlugins) {_                if (!pluginsNames.contains(mandatoryPlugin) && !missingPlugins.contains(mandatoryPlugin)) {_                    missingPlugins.add(mandatoryPlugin)__                }_            }_            if (!missingPlugins.isEmpty()) {_                final String message = String.format(_                        Locale.ROOT,_                        "missing mandatory plugins [%s], found plugins [%s]",_                        Strings.collectionToDelimitedString(missingPlugins, ", "),_                        Strings.collectionToDelimitedString(pluginsNames, ", "))__                throw new IllegalStateException(message)__            }_        }__        _        _        logPluginInfo(info.getModuleInfos(), "module", logger)__        logPluginInfo(info.getPluginInfos(), "plugin", logger)__    };constructs,a,new,plugin,service,param,settings,the,settings,of,the,system,param,modules,directory,the,directory,modules,exist,in,or,null,if,modules,should,not,be,loaded,from,the,filesystem,param,plugins,directory,the,directory,plugins,exist,in,or,null,if,plugins,should,not,be,loaded,from,the,filesystem,param,classpath,plugins,plugins,that,exist,in,the,classpath,which,should,be,loaded;public,plugins,service,settings,settings,path,config,path,path,modules,directory,path,plugins,directory,collection,class,extends,plugin,classpath,plugins,super,settings,this,config,path,config,path,list,tuple,plugin,info,plugin,plugins,loaded,new,array,list,list,plugin,info,plugins,list,new,array,list,final,list,string,plugins,names,new,array,list,for,class,extends,plugin,plugin,class,classpath,plugins,plugin,plugin,load,plugin,plugin,class,settings,config,path,plugin,info,plugin,info,new,plugin,info,plugin,class,get,name,classpath,plugin,na,version,current,1,8,plugin,class,get,name,collections,empty,list,false,if,logger,is,trace,enabled,logger,trace,plugin,loaded,from,classpath,plugin,info,plugins,loaded,add,new,tuple,plugin,info,plugin,plugins,list,add,plugin,info,plugins,names,add,plugin,info,get,name,set,bundle,seen,bundles,new,linked,hash,set,list,plugin,info,modules,list,new,array,list,if,modules,directory,null,try,set,bundle,modules,get,module,bundles,modules,directory,for,bundle,bundle,modules,modules,list,add,bundle,plugin,seen,bundles,add,all,modules,catch,ioexception,ex,throw,new,illegal,state,exception,unable,to,initialize,modules,ex,if,plugins,directory,null,try,if,is,accessible,directory,plugins,directory,logger,check,for,failed,plugin,removals,plugins,directory,set,bundle,plugins,get,plugin,bundles,plugins,directory,for,final,bundle,bundle,plugins,plugins,list,add,bundle,plugin,plugins,names,add,bundle,plugin,get,name,seen,bundles,add,all,plugins,catch,ioexception,ex,throw,new,illegal,state,exception,unable,to,initialize,plugins,ex,list,tuple,plugin,info,plugin,loaded,load,bundles,seen,bundles,plugins,loaded,add,all,loaded,this,info,new,plugins,and,modules,plugins,list,modules,list,this,plugins,collections,unmodifiable,list,plugins,loaded,list,string,mandatory,plugins,get,settings,if,mandatory,plugins,is,empty,false,set,string,missing,plugins,new,hash,set,for,string,mandatory,plugin,mandatory,plugins,if,plugins,names,contains,mandatory,plugin,missing,plugins,contains,mandatory,plugin,missing,plugins,add,mandatory,plugin,if,missing,plugins,is,empty,final,string,message,string,format,locale,root,missing,mandatory,plugins,s,found,plugins,s,strings,collection,to,delimited,string,missing,plugins,strings,collection,to,delimited,string,plugins,names,throw,new,illegal,state,exception,message,log,plugin,info,info,get,module,infos,module,logger,log,plugin,info,info,get,plugin,infos,plugin,logger
PluginsService -> public PluginsService(Settings settings, Path configPath, Path modulesDirectory, Path pluginsDirectory, Collection<Class<? extends Plugin>> classpathPlugins);1527583663;Constructs a new PluginService_@param settings The settings of the system_@param modulesDirectory The directory modules exist in, or null if modules should not be loaded from the filesystem_@param pluginsDirectory The directory plugins exist in, or null if plugins should not be loaded from the filesystem_@param classpathPlugins Plugins that exist in the classpath which should be loaded;public PluginsService(Settings settings, Path configPath, Path modulesDirectory, Path pluginsDirectory, Collection<Class<? extends Plugin>> classpathPlugins) {_        super(settings)___        this.configPath = configPath___        List<Tuple<PluginInfo, Plugin>> pluginsLoaded = new ArrayList<>()__        List<PluginInfo> pluginsList = new ArrayList<>()__        _        final List<String> pluginsNames = new ArrayList<>()__        _        for (Class<? extends Plugin> pluginClass : classpathPlugins) {_            Plugin plugin = loadPlugin(pluginClass, settings, configPath)__            PluginInfo pluginInfo = new PluginInfo(pluginClass.getName(), "classpath plugin", "NA", Version.CURRENT, "1.8",_                                                   pluginClass.getName(), Collections.emptyList(), false)__            if (logger.isTraceEnabled()) {_                logger.trace("plugin loaded from classpath [{}]", pluginInfo)__            }_            pluginsLoaded.add(new Tuple<>(pluginInfo, plugin))__            pluginsList.add(pluginInfo)__            pluginsNames.add(pluginInfo.getName())__        }__        Set<Bundle> seenBundles = new LinkedHashSet<>()__        List<PluginInfo> modulesList = new ArrayList<>()__        _        if (modulesDirectory != null) {_            try {_                Set<Bundle> modules = getModuleBundles(modulesDirectory)__                for (Bundle bundle : modules) {_                    modulesList.add(bundle.plugin)__                }_                seenBundles.addAll(modules)__            } catch (IOException ex) {_                throw new IllegalStateException("Unable to initialize modules", ex)__            }_        }__        _        if (pluginsDirectory != null) {_            try {_                _                if (isAccessibleDirectory(pluginsDirectory, logger)) {_                    checkForFailedPluginRemovals(pluginsDirectory)__                    Set<Bundle> plugins = getPluginBundles(pluginsDirectory)__                    for (final Bundle bundle : plugins) {_                        pluginsList.add(bundle.plugin)__                        pluginsNames.add(bundle.plugin.getName())__                    }_                    seenBundles.addAll(plugins)__                }_            } catch (IOException ex) {_                throw new IllegalStateException("Unable to initialize plugins", ex)__            }_        }__        List<Tuple<PluginInfo, Plugin>> loaded = loadBundles(seenBundles)__        pluginsLoaded.addAll(loaded)___        this.info = new PluginsAndModules(pluginsList, modulesList)__        this.plugins = Collections.unmodifiableList(pluginsLoaded)___        _        List<String> mandatoryPlugins = MANDATORY_SETTING.get(settings)__        if (mandatoryPlugins.isEmpty() == false) {_            Set<String> missingPlugins = new HashSet<>()__            for (String mandatoryPlugin : mandatoryPlugins) {_                if (!pluginsNames.contains(mandatoryPlugin) && !missingPlugins.contains(mandatoryPlugin)) {_                    missingPlugins.add(mandatoryPlugin)__                }_            }_            if (!missingPlugins.isEmpty()) {_                final String message = String.format(_                        Locale.ROOT,_                        "missing mandatory plugins [%s], found plugins [%s]",_                        Strings.collectionToDelimitedString(missingPlugins, ", "),_                        Strings.collectionToDelimitedString(pluginsNames, ", "))__                throw new IllegalStateException(message)__            }_        }__        _        _        logPluginInfo(info.getModuleInfos(), "module", logger)__        logPluginInfo(info.getPluginInfos(), "plugin", logger)__    };constructs,a,new,plugin,service,param,settings,the,settings,of,the,system,param,modules,directory,the,directory,modules,exist,in,or,null,if,modules,should,not,be,loaded,from,the,filesystem,param,plugins,directory,the,directory,plugins,exist,in,or,null,if,plugins,should,not,be,loaded,from,the,filesystem,param,classpath,plugins,plugins,that,exist,in,the,classpath,which,should,be,loaded;public,plugins,service,settings,settings,path,config,path,path,modules,directory,path,plugins,directory,collection,class,extends,plugin,classpath,plugins,super,settings,this,config,path,config,path,list,tuple,plugin,info,plugin,plugins,loaded,new,array,list,list,plugin,info,plugins,list,new,array,list,final,list,string,plugins,names,new,array,list,for,class,extends,plugin,plugin,class,classpath,plugins,plugin,plugin,load,plugin,plugin,class,settings,config,path,plugin,info,plugin,info,new,plugin,info,plugin,class,get,name,classpath,plugin,na,version,current,1,8,plugin,class,get,name,collections,empty,list,false,if,logger,is,trace,enabled,logger,trace,plugin,loaded,from,classpath,plugin,info,plugins,loaded,add,new,tuple,plugin,info,plugin,plugins,list,add,plugin,info,plugins,names,add,plugin,info,get,name,set,bundle,seen,bundles,new,linked,hash,set,list,plugin,info,modules,list,new,array,list,if,modules,directory,null,try,set,bundle,modules,get,module,bundles,modules,directory,for,bundle,bundle,modules,modules,list,add,bundle,plugin,seen,bundles,add,all,modules,catch,ioexception,ex,throw,new,illegal,state,exception,unable,to,initialize,modules,ex,if,plugins,directory,null,try,if,is,accessible,directory,plugins,directory,logger,check,for,failed,plugin,removals,plugins,directory,set,bundle,plugins,get,plugin,bundles,plugins,directory,for,final,bundle,bundle,plugins,plugins,list,add,bundle,plugin,plugins,names,add,bundle,plugin,get,name,seen,bundles,add,all,plugins,catch,ioexception,ex,throw,new,illegal,state,exception,unable,to,initialize,plugins,ex,list,tuple,plugin,info,plugin,loaded,load,bundles,seen,bundles,plugins,loaded,add,all,loaded,this,info,new,plugins,and,modules,plugins,list,modules,list,this,plugins,collections,unmodifiable,list,plugins,loaded,list,string,mandatory,plugins,get,settings,if,mandatory,plugins,is,empty,false,set,string,missing,plugins,new,hash,set,for,string,mandatory,plugin,mandatory,plugins,if,plugins,names,contains,mandatory,plugin,missing,plugins,contains,mandatory,plugin,missing,plugins,add,mandatory,plugin,if,missing,plugins,is,empty,final,string,message,string,format,locale,root,missing,mandatory,plugins,s,found,plugins,s,strings,collection,to,delimited,string,missing,plugins,strings,collection,to,delimited,string,plugins,names,throw,new,illegal,state,exception,message,log,plugin,info,info,get,module,infos,module,logger,log,plugin,info,info,get,plugin,infos,plugin,logger
PluginsService -> public PluginsService(Settings settings, Path configPath, Path modulesDirectory, Path pluginsDirectory, Collection<Class<? extends Plugin>> classpathPlugins);1527878678;Constructs a new PluginService_@param settings The settings of the system_@param modulesDirectory The directory modules exist in, or null if modules should not be loaded from the filesystem_@param pluginsDirectory The directory plugins exist in, or null if plugins should not be loaded from the filesystem_@param classpathPlugins Plugins that exist in the classpath which should be loaded;public PluginsService(Settings settings, Path configPath, Path modulesDirectory, Path pluginsDirectory, Collection<Class<? extends Plugin>> classpathPlugins) {_        super(settings)___        this.configPath = configPath___        List<Tuple<PluginInfo, Plugin>> pluginsLoaded = new ArrayList<>()__        List<PluginInfo> pluginsList = new ArrayList<>()__        _        final List<String> pluginsNames = new ArrayList<>()__        _        for (Class<? extends Plugin> pluginClass : classpathPlugins) {_            Plugin plugin = loadPlugin(pluginClass, settings, configPath)__            PluginInfo pluginInfo = new PluginInfo(pluginClass.getName(), "classpath plugin", "NA", Version.CURRENT, "1.8",_                                                   pluginClass.getName(), Collections.emptyList(), false)__            if (logger.isTraceEnabled()) {_                logger.trace("plugin loaded from classpath [{}]", pluginInfo)__            }_            pluginsLoaded.add(new Tuple<>(pluginInfo, plugin))__            pluginsList.add(pluginInfo)__            pluginsNames.add(pluginInfo.getName())__        }__        Set<Bundle> seenBundles = new LinkedHashSet<>()__        List<PluginInfo> modulesList = new ArrayList<>()__        _        if (modulesDirectory != null) {_            try {_                Set<Bundle> modules = getModuleBundles(modulesDirectory)__                for (Bundle bundle : modules) {_                    modulesList.add(bundle.plugin)__                }_                seenBundles.addAll(modules)__            } catch (IOException ex) {_                throw new IllegalStateException("Unable to initialize modules", ex)__            }_        }__        _        if (pluginsDirectory != null) {_            try {_                _                if (isAccessibleDirectory(pluginsDirectory, logger)) {_                    checkForFailedPluginRemovals(pluginsDirectory)__                    Set<Bundle> plugins = getPluginBundles(pluginsDirectory)__                    for (final Bundle bundle : plugins) {_                        pluginsList.add(bundle.plugin)__                        pluginsNames.add(bundle.plugin.getName())__                    }_                    seenBundles.addAll(plugins)__                }_            } catch (IOException ex) {_                throw new IllegalStateException("Unable to initialize plugins", ex)__            }_        }__        List<Tuple<PluginInfo, Plugin>> loaded = loadBundles(seenBundles)__        pluginsLoaded.addAll(loaded)___        this.info = new PluginsAndModules(pluginsList, modulesList)__        this.plugins = Collections.unmodifiableList(pluginsLoaded)___        _        List<String> mandatoryPlugins = MANDATORY_SETTING.get(settings)__        if (mandatoryPlugins.isEmpty() == false) {_            Set<String> missingPlugins = new HashSet<>()__            for (String mandatoryPlugin : mandatoryPlugins) {_                if (!pluginsNames.contains(mandatoryPlugin) && !missingPlugins.contains(mandatoryPlugin)) {_                    missingPlugins.add(mandatoryPlugin)__                }_            }_            if (!missingPlugins.isEmpty()) {_                final String message = String.format(_                        Locale.ROOT,_                        "missing mandatory plugins [%s], found plugins [%s]",_                        Strings.collectionToDelimitedString(missingPlugins, ", "),_                        Strings.collectionToDelimitedString(pluginsNames, ", "))__                throw new IllegalStateException(message)__            }_        }__        _        _        logPluginInfo(info.getModuleInfos(), "module", logger)__        logPluginInfo(info.getPluginInfos(), "plugin", logger)__    };constructs,a,new,plugin,service,param,settings,the,settings,of,the,system,param,modules,directory,the,directory,modules,exist,in,or,null,if,modules,should,not,be,loaded,from,the,filesystem,param,plugins,directory,the,directory,plugins,exist,in,or,null,if,plugins,should,not,be,loaded,from,the,filesystem,param,classpath,plugins,plugins,that,exist,in,the,classpath,which,should,be,loaded;public,plugins,service,settings,settings,path,config,path,path,modules,directory,path,plugins,directory,collection,class,extends,plugin,classpath,plugins,super,settings,this,config,path,config,path,list,tuple,plugin,info,plugin,plugins,loaded,new,array,list,list,plugin,info,plugins,list,new,array,list,final,list,string,plugins,names,new,array,list,for,class,extends,plugin,plugin,class,classpath,plugins,plugin,plugin,load,plugin,plugin,class,settings,config,path,plugin,info,plugin,info,new,plugin,info,plugin,class,get,name,classpath,plugin,na,version,current,1,8,plugin,class,get,name,collections,empty,list,false,if,logger,is,trace,enabled,logger,trace,plugin,loaded,from,classpath,plugin,info,plugins,loaded,add,new,tuple,plugin,info,plugin,plugins,list,add,plugin,info,plugins,names,add,plugin,info,get,name,set,bundle,seen,bundles,new,linked,hash,set,list,plugin,info,modules,list,new,array,list,if,modules,directory,null,try,set,bundle,modules,get,module,bundles,modules,directory,for,bundle,bundle,modules,modules,list,add,bundle,plugin,seen,bundles,add,all,modules,catch,ioexception,ex,throw,new,illegal,state,exception,unable,to,initialize,modules,ex,if,plugins,directory,null,try,if,is,accessible,directory,plugins,directory,logger,check,for,failed,plugin,removals,plugins,directory,set,bundle,plugins,get,plugin,bundles,plugins,directory,for,final,bundle,bundle,plugins,plugins,list,add,bundle,plugin,plugins,names,add,bundle,plugin,get,name,seen,bundles,add,all,plugins,catch,ioexception,ex,throw,new,illegal,state,exception,unable,to,initialize,plugins,ex,list,tuple,plugin,info,plugin,loaded,load,bundles,seen,bundles,plugins,loaded,add,all,loaded,this,info,new,plugins,and,modules,plugins,list,modules,list,this,plugins,collections,unmodifiable,list,plugins,loaded,list,string,mandatory,plugins,get,settings,if,mandatory,plugins,is,empty,false,set,string,missing,plugins,new,hash,set,for,string,mandatory,plugin,mandatory,plugins,if,plugins,names,contains,mandatory,plugin,missing,plugins,contains,mandatory,plugin,missing,plugins,add,mandatory,plugin,if,missing,plugins,is,empty,final,string,message,string,format,locale,root,missing,mandatory,plugins,s,found,plugins,s,strings,collection,to,delimited,string,missing,plugins,strings,collection,to,delimited,string,plugins,names,throw,new,illegal,state,exception,message,log,plugin,info,info,get,module,infos,module,logger,log,plugin,info,info,get,plugin,infos,plugin,logger
PluginsService -> public PluginsService(Settings settings, Path configPath, Path modulesDirectory, Path pluginsDirectory, Collection<Class<? extends Plugin>> classpathPlugins);1528762805;Constructs a new PluginService_@param settings The settings of the system_@param modulesDirectory The directory modules exist in, or null if modules should not be loaded from the filesystem_@param pluginsDirectory The directory plugins exist in, or null if plugins should not be loaded from the filesystem_@param classpathPlugins Plugins that exist in the classpath which should be loaded;public PluginsService(Settings settings, Path configPath, Path modulesDirectory, Path pluginsDirectory, Collection<Class<? extends Plugin>> classpathPlugins) {_        super(settings)___        this.configPath = configPath___        List<Tuple<PluginInfo, Plugin>> pluginsLoaded = new ArrayList<>()__        List<PluginInfo> pluginsList = new ArrayList<>()__        _        final List<String> pluginsNames = new ArrayList<>()__        _        for (Class<? extends Plugin> pluginClass : classpathPlugins) {_            Plugin plugin = loadPlugin(pluginClass, settings, configPath)__            PluginInfo pluginInfo = new PluginInfo(pluginClass.getName(), "classpath plugin", "NA", Version.CURRENT, "1.8",_                                                   pluginClass.getName(), Collections.emptyList(), false)__            if (logger.isTraceEnabled()) {_                logger.trace("plugin loaded from classpath [{}]", pluginInfo)__            }_            pluginsLoaded.add(new Tuple<>(pluginInfo, plugin))__            pluginsList.add(pluginInfo)__            pluginsNames.add(pluginInfo.getName())__        }__        Set<Bundle> seenBundles = new LinkedHashSet<>()__        List<PluginInfo> modulesList = new ArrayList<>()__        _        if (modulesDirectory != null) {_            try {_                Set<Bundle> modules = getModuleBundles(modulesDirectory)__                for (Bundle bundle : modules) {_                    modulesList.add(bundle.plugin)__                }_                seenBundles.addAll(modules)__            } catch (IOException ex) {_                throw new IllegalStateException("Unable to initialize modules", ex)__            }_        }__        _        if (pluginsDirectory != null) {_            try {_                _                if (isAccessibleDirectory(pluginsDirectory, logger)) {_                    checkForFailedPluginRemovals(pluginsDirectory)__                    Set<Bundle> plugins = getPluginBundles(pluginsDirectory)__                    for (final Bundle bundle : plugins) {_                        pluginsList.add(bundle.plugin)__                        pluginsNames.add(bundle.plugin.getName())__                    }_                    seenBundles.addAll(plugins)__                }_            } catch (IOException ex) {_                throw new IllegalStateException("Unable to initialize plugins", ex)__            }_        }__        List<Tuple<PluginInfo, Plugin>> loaded = loadBundles(seenBundles)__        pluginsLoaded.addAll(loaded)___        this.info = new PluginsAndModules(pluginsList, modulesList)__        this.plugins = Collections.unmodifiableList(pluginsLoaded)___        _        List<String> mandatoryPlugins = MANDATORY_SETTING.get(settings)__        if (mandatoryPlugins.isEmpty() == false) {_            Set<String> missingPlugins = new HashSet<>()__            for (String mandatoryPlugin : mandatoryPlugins) {_                if (!pluginsNames.contains(mandatoryPlugin) && !missingPlugins.contains(mandatoryPlugin)) {_                    missingPlugins.add(mandatoryPlugin)__                }_            }_            if (!missingPlugins.isEmpty()) {_                final String message = String.format(_                        Locale.ROOT,_                        "missing mandatory plugins [%s], found plugins [%s]",_                        Strings.collectionToDelimitedString(missingPlugins, ", "),_                        Strings.collectionToDelimitedString(pluginsNames, ", "))__                throw new IllegalStateException(message)__            }_        }__        _        _        logPluginInfo(info.getModuleInfos(), "module", logger)__        logPluginInfo(info.getPluginInfos(), "plugin", logger)__    };constructs,a,new,plugin,service,param,settings,the,settings,of,the,system,param,modules,directory,the,directory,modules,exist,in,or,null,if,modules,should,not,be,loaded,from,the,filesystem,param,plugins,directory,the,directory,plugins,exist,in,or,null,if,plugins,should,not,be,loaded,from,the,filesystem,param,classpath,plugins,plugins,that,exist,in,the,classpath,which,should,be,loaded;public,plugins,service,settings,settings,path,config,path,path,modules,directory,path,plugins,directory,collection,class,extends,plugin,classpath,plugins,super,settings,this,config,path,config,path,list,tuple,plugin,info,plugin,plugins,loaded,new,array,list,list,plugin,info,plugins,list,new,array,list,final,list,string,plugins,names,new,array,list,for,class,extends,plugin,plugin,class,classpath,plugins,plugin,plugin,load,plugin,plugin,class,settings,config,path,plugin,info,plugin,info,new,plugin,info,plugin,class,get,name,classpath,plugin,na,version,current,1,8,plugin,class,get,name,collections,empty,list,false,if,logger,is,trace,enabled,logger,trace,plugin,loaded,from,classpath,plugin,info,plugins,loaded,add,new,tuple,plugin,info,plugin,plugins,list,add,plugin,info,plugins,names,add,plugin,info,get,name,set,bundle,seen,bundles,new,linked,hash,set,list,plugin,info,modules,list,new,array,list,if,modules,directory,null,try,set,bundle,modules,get,module,bundles,modules,directory,for,bundle,bundle,modules,modules,list,add,bundle,plugin,seen,bundles,add,all,modules,catch,ioexception,ex,throw,new,illegal,state,exception,unable,to,initialize,modules,ex,if,plugins,directory,null,try,if,is,accessible,directory,plugins,directory,logger,check,for,failed,plugin,removals,plugins,directory,set,bundle,plugins,get,plugin,bundles,plugins,directory,for,final,bundle,bundle,plugins,plugins,list,add,bundle,plugin,plugins,names,add,bundle,plugin,get,name,seen,bundles,add,all,plugins,catch,ioexception,ex,throw,new,illegal,state,exception,unable,to,initialize,plugins,ex,list,tuple,plugin,info,plugin,loaded,load,bundles,seen,bundles,plugins,loaded,add,all,loaded,this,info,new,plugins,and,modules,plugins,list,modules,list,this,plugins,collections,unmodifiable,list,plugins,loaded,list,string,mandatory,plugins,get,settings,if,mandatory,plugins,is,empty,false,set,string,missing,plugins,new,hash,set,for,string,mandatory,plugin,mandatory,plugins,if,plugins,names,contains,mandatory,plugin,missing,plugins,contains,mandatory,plugin,missing,plugins,add,mandatory,plugin,if,missing,plugins,is,empty,final,string,message,string,format,locale,root,missing,mandatory,plugins,s,found,plugins,s,strings,collection,to,delimited,string,missing,plugins,strings,collection,to,delimited,string,plugins,names,throw,new,illegal,state,exception,message,log,plugin,info,info,get,module,infos,module,logger,log,plugin,info,info,get,plugin,infos,plugin,logger
PluginsService -> public PluginsService(Settings settings, Path configPath, Path modulesDirectory, Path pluginsDirectory, Collection<Class<? extends Plugin>> classpathPlugins);1539615817;Constructs a new PluginService_@param settings The settings of the system_@param modulesDirectory The directory modules exist in, or null if modules should not be loaded from the filesystem_@param pluginsDirectory The directory plugins exist in, or null if plugins should not be loaded from the filesystem_@param classpathPlugins Plugins that exist in the classpath which should be loaded;public PluginsService(Settings settings, Path configPath, Path modulesDirectory, Path pluginsDirectory, Collection<Class<? extends Plugin>> classpathPlugins) {_        super(settings)___        this.configPath = configPath___        List<Tuple<PluginInfo, Plugin>> pluginsLoaded = new ArrayList<>()__        List<PluginInfo> pluginsList = new ArrayList<>()__        _        final List<String> pluginsNames = new ArrayList<>()__        _        for (Class<? extends Plugin> pluginClass : classpathPlugins) {_            Plugin plugin = loadPlugin(pluginClass, settings, configPath)__            PluginInfo pluginInfo = new PluginInfo(pluginClass.getName(), "classpath plugin", "NA", Version.CURRENT, "1.8",_                                                   pluginClass.getName(), Collections.emptyList(), false)__            if (logger.isTraceEnabled()) {_                logger.trace("plugin loaded from classpath [{}]", pluginInfo)__            }_            pluginsLoaded.add(new Tuple<>(pluginInfo, plugin))__            pluginsList.add(pluginInfo)__            pluginsNames.add(pluginInfo.getName())__        }__        Set<Bundle> seenBundles = new LinkedHashSet<>()__        List<PluginInfo> modulesList = new ArrayList<>()__        _        if (modulesDirectory != null) {_            try {_                Set<Bundle> modules = getModuleBundles(modulesDirectory)__                for (Bundle bundle : modules) {_                    modulesList.add(bundle.plugin)__                }_                seenBundles.addAll(modules)__            } catch (IOException ex) {_                throw new IllegalStateException("Unable to initialize modules", ex)__            }_        }__        _        if (pluginsDirectory != null) {_            try {_                _                if (isAccessibleDirectory(pluginsDirectory, logger)) {_                    checkForFailedPluginRemovals(pluginsDirectory)__                    Set<Bundle> plugins = getPluginBundles(pluginsDirectory)__                    for (final Bundle bundle : plugins) {_                        pluginsList.add(bundle.plugin)__                        pluginsNames.add(bundle.plugin.getName())__                    }_                    seenBundles.addAll(plugins)__                }_            } catch (IOException ex) {_                throw new IllegalStateException("Unable to initialize plugins", ex)__            }_        }__        List<Tuple<PluginInfo, Plugin>> loaded = loadBundles(seenBundles)__        pluginsLoaded.addAll(loaded)___        this.info = new PluginsAndModules(pluginsList, modulesList)__        this.plugins = Collections.unmodifiableList(pluginsLoaded)___        _        List<String> mandatoryPlugins = MANDATORY_SETTING.get(settings)__        if (mandatoryPlugins.isEmpty() == false) {_            Set<String> missingPlugins = new HashSet<>()__            for (String mandatoryPlugin : mandatoryPlugins) {_                if (!pluginsNames.contains(mandatoryPlugin) && !missingPlugins.contains(mandatoryPlugin)) {_                    missingPlugins.add(mandatoryPlugin)__                }_            }_            if (!missingPlugins.isEmpty()) {_                final String message = String.format(_                        Locale.ROOT,_                        "missing mandatory plugins [%s], found plugins [%s]",_                        Strings.collectionToDelimitedString(missingPlugins, ", "),_                        Strings.collectionToDelimitedString(pluginsNames, ", "))__                throw new IllegalStateException(message)__            }_        }__        _        _        logPluginInfo(info.getModuleInfos(), "module", logger)__        logPluginInfo(info.getPluginInfos(), "plugin", logger)__    };constructs,a,new,plugin,service,param,settings,the,settings,of,the,system,param,modules,directory,the,directory,modules,exist,in,or,null,if,modules,should,not,be,loaded,from,the,filesystem,param,plugins,directory,the,directory,plugins,exist,in,or,null,if,plugins,should,not,be,loaded,from,the,filesystem,param,classpath,plugins,plugins,that,exist,in,the,classpath,which,should,be,loaded;public,plugins,service,settings,settings,path,config,path,path,modules,directory,path,plugins,directory,collection,class,extends,plugin,classpath,plugins,super,settings,this,config,path,config,path,list,tuple,plugin,info,plugin,plugins,loaded,new,array,list,list,plugin,info,plugins,list,new,array,list,final,list,string,plugins,names,new,array,list,for,class,extends,plugin,plugin,class,classpath,plugins,plugin,plugin,load,plugin,plugin,class,settings,config,path,plugin,info,plugin,info,new,plugin,info,plugin,class,get,name,classpath,plugin,na,version,current,1,8,plugin,class,get,name,collections,empty,list,false,if,logger,is,trace,enabled,logger,trace,plugin,loaded,from,classpath,plugin,info,plugins,loaded,add,new,tuple,plugin,info,plugin,plugins,list,add,plugin,info,plugins,names,add,plugin,info,get,name,set,bundle,seen,bundles,new,linked,hash,set,list,plugin,info,modules,list,new,array,list,if,modules,directory,null,try,set,bundle,modules,get,module,bundles,modules,directory,for,bundle,bundle,modules,modules,list,add,bundle,plugin,seen,bundles,add,all,modules,catch,ioexception,ex,throw,new,illegal,state,exception,unable,to,initialize,modules,ex,if,plugins,directory,null,try,if,is,accessible,directory,plugins,directory,logger,check,for,failed,plugin,removals,plugins,directory,set,bundle,plugins,get,plugin,bundles,plugins,directory,for,final,bundle,bundle,plugins,plugins,list,add,bundle,plugin,plugins,names,add,bundle,plugin,get,name,seen,bundles,add,all,plugins,catch,ioexception,ex,throw,new,illegal,state,exception,unable,to,initialize,plugins,ex,list,tuple,plugin,info,plugin,loaded,load,bundles,seen,bundles,plugins,loaded,add,all,loaded,this,info,new,plugins,and,modules,plugins,list,modules,list,this,plugins,collections,unmodifiable,list,plugins,loaded,list,string,mandatory,plugins,get,settings,if,mandatory,plugins,is,empty,false,set,string,missing,plugins,new,hash,set,for,string,mandatory,plugin,mandatory,plugins,if,plugins,names,contains,mandatory,plugin,missing,plugins,contains,mandatory,plugin,missing,plugins,add,mandatory,plugin,if,missing,plugins,is,empty,final,string,message,string,format,locale,root,missing,mandatory,plugins,s,found,plugins,s,strings,collection,to,delimited,string,missing,plugins,strings,collection,to,delimited,string,plugins,names,throw,new,illegal,state,exception,message,log,plugin,info,info,get,module,infos,module,logger,log,plugin,info,info,get,plugin,infos,plugin,logger
PluginsService -> public PluginsService(Settings settings, Path configPath, Path modulesDirectory, Path pluginsDirectory, Collection<Class<? extends Plugin>> classpathPlugins);1540486836;Constructs a new PluginService_@param settings The settings of the system_@param modulesDirectory The directory modules exist in, or null if modules should not be loaded from the filesystem_@param pluginsDirectory The directory plugins exist in, or null if plugins should not be loaded from the filesystem_@param classpathPlugins Plugins that exist in the classpath which should be loaded;public PluginsService(Settings settings, Path configPath, Path modulesDirectory, Path pluginsDirectory, Collection<Class<? extends Plugin>> classpathPlugins) {_        super(settings)___        this.configPath = configPath___        List<Tuple<PluginInfo, Plugin>> pluginsLoaded = new ArrayList<>()__        List<PluginInfo> pluginsList = new ArrayList<>()__        _        final List<String> pluginsNames = new ArrayList<>()__        _        for (Class<? extends Plugin> pluginClass : classpathPlugins) {_            Plugin plugin = loadPlugin(pluginClass, settings, configPath)__            PluginInfo pluginInfo = new PluginInfo(pluginClass.getName(), "classpath plugin", "NA", Version.CURRENT, "1.8",_                                                   pluginClass.getName(), Collections.emptyList(), false)__            if (logger.isTraceEnabled()) {_                logger.trace("plugin loaded from classpath [{}]", pluginInfo)__            }_            pluginsLoaded.add(new Tuple<>(pluginInfo, plugin))__            pluginsList.add(pluginInfo)__            pluginsNames.add(pluginInfo.getName())__        }__        Set<Bundle> seenBundles = new LinkedHashSet<>()__        List<PluginInfo> modulesList = new ArrayList<>()__        _        if (modulesDirectory != null) {_            try {_                Set<Bundle> modules = getModuleBundles(modulesDirectory)__                for (Bundle bundle : modules) {_                    modulesList.add(bundle.plugin)__                }_                seenBundles.addAll(modules)__            } catch (IOException ex) {_                throw new IllegalStateException("Unable to initialize modules", ex)__            }_        }__        _        if (pluginsDirectory != null) {_            try {_                _                if (isAccessibleDirectory(pluginsDirectory, logger)) {_                    checkForFailedPluginRemovals(pluginsDirectory)__                    Set<Bundle> plugins = getPluginBundles(pluginsDirectory)__                    for (final Bundle bundle : plugins) {_                        pluginsList.add(bundle.plugin)__                        pluginsNames.add(bundle.plugin.getName())__                    }_                    seenBundles.addAll(plugins)__                }_            } catch (IOException ex) {_                throw new IllegalStateException("Unable to initialize plugins", ex)__            }_        }__        List<Tuple<PluginInfo, Plugin>> loaded = loadBundles(seenBundles)__        pluginsLoaded.addAll(loaded)___        this.info = new PluginsAndModules(pluginsList, modulesList)__        this.plugins = Collections.unmodifiableList(pluginsLoaded)___        _        List<String> mandatoryPlugins = MANDATORY_SETTING.get(settings)__        if (mandatoryPlugins.isEmpty() == false) {_            Set<String> missingPlugins = new HashSet<>()__            for (String mandatoryPlugin : mandatoryPlugins) {_                if (!pluginsNames.contains(mandatoryPlugin) && !missingPlugins.contains(mandatoryPlugin)) {_                    missingPlugins.add(mandatoryPlugin)__                }_            }_            if (!missingPlugins.isEmpty()) {_                final String message = String.format(_                        Locale.ROOT,_                        "missing mandatory plugins [%s], found plugins [%s]",_                        Strings.collectionToDelimitedString(missingPlugins, ", "),_                        Strings.collectionToDelimitedString(pluginsNames, ", "))__                throw new IllegalStateException(message)__            }_        }__        _        _        logPluginInfo(info.getModuleInfos(), "module", logger)__        logPluginInfo(info.getPluginInfos(), "plugin", logger)__    };constructs,a,new,plugin,service,param,settings,the,settings,of,the,system,param,modules,directory,the,directory,modules,exist,in,or,null,if,modules,should,not,be,loaded,from,the,filesystem,param,plugins,directory,the,directory,plugins,exist,in,or,null,if,plugins,should,not,be,loaded,from,the,filesystem,param,classpath,plugins,plugins,that,exist,in,the,classpath,which,should,be,loaded;public,plugins,service,settings,settings,path,config,path,path,modules,directory,path,plugins,directory,collection,class,extends,plugin,classpath,plugins,super,settings,this,config,path,config,path,list,tuple,plugin,info,plugin,plugins,loaded,new,array,list,list,plugin,info,plugins,list,new,array,list,final,list,string,plugins,names,new,array,list,for,class,extends,plugin,plugin,class,classpath,plugins,plugin,plugin,load,plugin,plugin,class,settings,config,path,plugin,info,plugin,info,new,plugin,info,plugin,class,get,name,classpath,plugin,na,version,current,1,8,plugin,class,get,name,collections,empty,list,false,if,logger,is,trace,enabled,logger,trace,plugin,loaded,from,classpath,plugin,info,plugins,loaded,add,new,tuple,plugin,info,plugin,plugins,list,add,plugin,info,plugins,names,add,plugin,info,get,name,set,bundle,seen,bundles,new,linked,hash,set,list,plugin,info,modules,list,new,array,list,if,modules,directory,null,try,set,bundle,modules,get,module,bundles,modules,directory,for,bundle,bundle,modules,modules,list,add,bundle,plugin,seen,bundles,add,all,modules,catch,ioexception,ex,throw,new,illegal,state,exception,unable,to,initialize,modules,ex,if,plugins,directory,null,try,if,is,accessible,directory,plugins,directory,logger,check,for,failed,plugin,removals,plugins,directory,set,bundle,plugins,get,plugin,bundles,plugins,directory,for,final,bundle,bundle,plugins,plugins,list,add,bundle,plugin,plugins,names,add,bundle,plugin,get,name,seen,bundles,add,all,plugins,catch,ioexception,ex,throw,new,illegal,state,exception,unable,to,initialize,plugins,ex,list,tuple,plugin,info,plugin,loaded,load,bundles,seen,bundles,plugins,loaded,add,all,loaded,this,info,new,plugins,and,modules,plugins,list,modules,list,this,plugins,collections,unmodifiable,list,plugins,loaded,list,string,mandatory,plugins,get,settings,if,mandatory,plugins,is,empty,false,set,string,missing,plugins,new,hash,set,for,string,mandatory,plugin,mandatory,plugins,if,plugins,names,contains,mandatory,plugin,missing,plugins,contains,mandatory,plugin,missing,plugins,add,mandatory,plugin,if,missing,plugins,is,empty,final,string,message,string,format,locale,root,missing,mandatory,plugins,s,found,plugins,s,strings,collection,to,delimited,string,missing,plugins,strings,collection,to,delimited,string,plugins,names,throw,new,illegal,state,exception,message,log,plugin,info,info,get,module,infos,module,logger,log,plugin,info,info,get,plugin,infos,plugin,logger
PluginsService -> public PluginsService(Settings settings, Path configPath, Path modulesDirectory, Path pluginsDirectory, Collection<Class<? extends Plugin>> classpathPlugins);1541008027;Constructs a new PluginService_@param settings The settings of the system_@param modulesDirectory The directory modules exist in, or null if modules should not be loaded from the filesystem_@param pluginsDirectory The directory plugins exist in, or null if plugins should not be loaded from the filesystem_@param classpathPlugins Plugins that exist in the classpath which should be loaded;public PluginsService(Settings settings, Path configPath, Path modulesDirectory, Path pluginsDirectory, Collection<Class<? extends Plugin>> classpathPlugins) {_        super(settings)__        this.settings = settings__        this.configPath = configPath___        List<Tuple<PluginInfo, Plugin>> pluginsLoaded = new ArrayList<>()__        List<PluginInfo> pluginsList = new ArrayList<>()__        _        final List<String> pluginsNames = new ArrayList<>()__        _        for (Class<? extends Plugin> pluginClass : classpathPlugins) {_            Plugin plugin = loadPlugin(pluginClass, settings, configPath)__            PluginInfo pluginInfo = new PluginInfo(pluginClass.getName(), "classpath plugin", "NA", Version.CURRENT, "1.8",_                                                   pluginClass.getName(), Collections.emptyList(), false)__            if (logger.isTraceEnabled()) {_                logger.trace("plugin loaded from classpath [{}]", pluginInfo)__            }_            pluginsLoaded.add(new Tuple<>(pluginInfo, plugin))__            pluginsList.add(pluginInfo)__            pluginsNames.add(pluginInfo.getName())__        }__        Set<Bundle> seenBundles = new LinkedHashSet<>()__        List<PluginInfo> modulesList = new ArrayList<>()__        _        if (modulesDirectory != null) {_            try {_                Set<Bundle> modules = getModuleBundles(modulesDirectory)__                for (Bundle bundle : modules) {_                    modulesList.add(bundle.plugin)__                }_                seenBundles.addAll(modules)__            } catch (IOException ex) {_                throw new IllegalStateException("Unable to initialize modules", ex)__            }_        }__        _        if (pluginsDirectory != null) {_            try {_                _                if (isAccessibleDirectory(pluginsDirectory, logger)) {_                    checkForFailedPluginRemovals(pluginsDirectory)__                    Set<Bundle> plugins = getPluginBundles(pluginsDirectory)__                    for (final Bundle bundle : plugins) {_                        pluginsList.add(bundle.plugin)__                        pluginsNames.add(bundle.plugin.getName())__                    }_                    seenBundles.addAll(plugins)__                }_            } catch (IOException ex) {_                throw new IllegalStateException("Unable to initialize plugins", ex)__            }_        }__        List<Tuple<PluginInfo, Plugin>> loaded = loadBundles(seenBundles)__        pluginsLoaded.addAll(loaded)___        this.info = new PluginsAndModules(pluginsList, modulesList)__        this.plugins = Collections.unmodifiableList(pluginsLoaded)___        _        List<String> mandatoryPlugins = MANDATORY_SETTING.get(settings)__        if (mandatoryPlugins.isEmpty() == false) {_            Set<String> missingPlugins = new HashSet<>()__            for (String mandatoryPlugin : mandatoryPlugins) {_                if (!pluginsNames.contains(mandatoryPlugin) && !missingPlugins.contains(mandatoryPlugin)) {_                    missingPlugins.add(mandatoryPlugin)__                }_            }_            if (!missingPlugins.isEmpty()) {_                final String message = String.format(_                        Locale.ROOT,_                        "missing mandatory plugins [%s], found plugins [%s]",_                        Strings.collectionToDelimitedString(missingPlugins, ", "),_                        Strings.collectionToDelimitedString(pluginsNames, ", "))__                throw new IllegalStateException(message)__            }_        }__        _        _        logPluginInfo(info.getModuleInfos(), "module", logger)__        logPluginInfo(info.getPluginInfos(), "plugin", logger)__    };constructs,a,new,plugin,service,param,settings,the,settings,of,the,system,param,modules,directory,the,directory,modules,exist,in,or,null,if,modules,should,not,be,loaded,from,the,filesystem,param,plugins,directory,the,directory,plugins,exist,in,or,null,if,plugins,should,not,be,loaded,from,the,filesystem,param,classpath,plugins,plugins,that,exist,in,the,classpath,which,should,be,loaded;public,plugins,service,settings,settings,path,config,path,path,modules,directory,path,plugins,directory,collection,class,extends,plugin,classpath,plugins,super,settings,this,settings,settings,this,config,path,config,path,list,tuple,plugin,info,plugin,plugins,loaded,new,array,list,list,plugin,info,plugins,list,new,array,list,final,list,string,plugins,names,new,array,list,for,class,extends,plugin,plugin,class,classpath,plugins,plugin,plugin,load,plugin,plugin,class,settings,config,path,plugin,info,plugin,info,new,plugin,info,plugin,class,get,name,classpath,plugin,na,version,current,1,8,plugin,class,get,name,collections,empty,list,false,if,logger,is,trace,enabled,logger,trace,plugin,loaded,from,classpath,plugin,info,plugins,loaded,add,new,tuple,plugin,info,plugin,plugins,list,add,plugin,info,plugins,names,add,plugin,info,get,name,set,bundle,seen,bundles,new,linked,hash,set,list,plugin,info,modules,list,new,array,list,if,modules,directory,null,try,set,bundle,modules,get,module,bundles,modules,directory,for,bundle,bundle,modules,modules,list,add,bundle,plugin,seen,bundles,add,all,modules,catch,ioexception,ex,throw,new,illegal,state,exception,unable,to,initialize,modules,ex,if,plugins,directory,null,try,if,is,accessible,directory,plugins,directory,logger,check,for,failed,plugin,removals,plugins,directory,set,bundle,plugins,get,plugin,bundles,plugins,directory,for,final,bundle,bundle,plugins,plugins,list,add,bundle,plugin,plugins,names,add,bundle,plugin,get,name,seen,bundles,add,all,plugins,catch,ioexception,ex,throw,new,illegal,state,exception,unable,to,initialize,plugins,ex,list,tuple,plugin,info,plugin,loaded,load,bundles,seen,bundles,plugins,loaded,add,all,loaded,this,info,new,plugins,and,modules,plugins,list,modules,list,this,plugins,collections,unmodifiable,list,plugins,loaded,list,string,mandatory,plugins,get,settings,if,mandatory,plugins,is,empty,false,set,string,missing,plugins,new,hash,set,for,string,mandatory,plugin,mandatory,plugins,if,plugins,names,contains,mandatory,plugin,missing,plugins,contains,mandatory,plugin,missing,plugins,add,mandatory,plugin,if,missing,plugins,is,empty,final,string,message,string,format,locale,root,missing,mandatory,plugins,s,found,plugins,s,strings,collection,to,delimited,string,missing,plugins,strings,collection,to,delimited,string,plugins,names,throw,new,illegal,state,exception,message,log,plugin,info,info,get,module,infos,module,logger,log,plugin,info,info,get,plugin,infos,plugin,logger
PluginsService -> public PluginsService(Settings settings, Path configPath, Path modulesDirectory, Path pluginsDirectory, Collection<Class<? extends Plugin>> classpathPlugins);1541092382;Constructs a new PluginService_@param settings The settings of the system_@param modulesDirectory The directory modules exist in, or null if modules should not be loaded from the filesystem_@param pluginsDirectory The directory plugins exist in, or null if plugins should not be loaded from the filesystem_@param classpathPlugins Plugins that exist in the classpath which should be loaded;public PluginsService(Settings settings, Path configPath, Path modulesDirectory, Path pluginsDirectory, Collection<Class<? extends Plugin>> classpathPlugins) {_        this.settings = settings__        this.configPath = configPath___        List<Tuple<PluginInfo, Plugin>> pluginsLoaded = new ArrayList<>()__        List<PluginInfo> pluginsList = new ArrayList<>()__        _        final List<String> pluginsNames = new ArrayList<>()__        _        for (Class<? extends Plugin> pluginClass : classpathPlugins) {_            Plugin plugin = loadPlugin(pluginClass, settings, configPath)__            PluginInfo pluginInfo = new PluginInfo(pluginClass.getName(), "classpath plugin", "NA", Version.CURRENT, "1.8",_                                                   pluginClass.getName(), Collections.emptyList(), false)__            if (logger.isTraceEnabled()) {_                logger.trace("plugin loaded from classpath [{}]", pluginInfo)__            }_            pluginsLoaded.add(new Tuple<>(pluginInfo, plugin))__            pluginsList.add(pluginInfo)__            pluginsNames.add(pluginInfo.getName())__        }__        Set<Bundle> seenBundles = new LinkedHashSet<>()__        List<PluginInfo> modulesList = new ArrayList<>()__        _        if (modulesDirectory != null) {_            try {_                Set<Bundle> modules = getModuleBundles(modulesDirectory)__                for (Bundle bundle : modules) {_                    modulesList.add(bundle.plugin)__                }_                seenBundles.addAll(modules)__            } catch (IOException ex) {_                throw new IllegalStateException("Unable to initialize modules", ex)__            }_        }__        _        if (pluginsDirectory != null) {_            try {_                _                if (isAccessibleDirectory(pluginsDirectory, logger)) {_                    checkForFailedPluginRemovals(pluginsDirectory)__                    Set<Bundle> plugins = getPluginBundles(pluginsDirectory)__                    for (final Bundle bundle : plugins) {_                        pluginsList.add(bundle.plugin)__                        pluginsNames.add(bundle.plugin.getName())__                    }_                    seenBundles.addAll(plugins)__                }_            } catch (IOException ex) {_                throw new IllegalStateException("Unable to initialize plugins", ex)__            }_        }__        List<Tuple<PluginInfo, Plugin>> loaded = loadBundles(seenBundles)__        pluginsLoaded.addAll(loaded)___        this.info = new PluginsAndModules(pluginsList, modulesList)__        this.plugins = Collections.unmodifiableList(pluginsLoaded)___        _        List<String> mandatoryPlugins = MANDATORY_SETTING.get(settings)__        if (mandatoryPlugins.isEmpty() == false) {_            Set<String> missingPlugins = new HashSet<>()__            for (String mandatoryPlugin : mandatoryPlugins) {_                if (!pluginsNames.contains(mandatoryPlugin) && !missingPlugins.contains(mandatoryPlugin)) {_                    missingPlugins.add(mandatoryPlugin)__                }_            }_            if (!missingPlugins.isEmpty()) {_                final String message = String.format(_                        Locale.ROOT,_                        "missing mandatory plugins [%s], found plugins [%s]",_                        Strings.collectionToDelimitedString(missingPlugins, ", "),_                        Strings.collectionToDelimitedString(pluginsNames, ", "))__                throw new IllegalStateException(message)__            }_        }__        _        _        logPluginInfo(info.getModuleInfos(), "module", logger)__        logPluginInfo(info.getPluginInfos(), "plugin", logger)__    };constructs,a,new,plugin,service,param,settings,the,settings,of,the,system,param,modules,directory,the,directory,modules,exist,in,or,null,if,modules,should,not,be,loaded,from,the,filesystem,param,plugins,directory,the,directory,plugins,exist,in,or,null,if,plugins,should,not,be,loaded,from,the,filesystem,param,classpath,plugins,plugins,that,exist,in,the,classpath,which,should,be,loaded;public,plugins,service,settings,settings,path,config,path,path,modules,directory,path,plugins,directory,collection,class,extends,plugin,classpath,plugins,this,settings,settings,this,config,path,config,path,list,tuple,plugin,info,plugin,plugins,loaded,new,array,list,list,plugin,info,plugins,list,new,array,list,final,list,string,plugins,names,new,array,list,for,class,extends,plugin,plugin,class,classpath,plugins,plugin,plugin,load,plugin,plugin,class,settings,config,path,plugin,info,plugin,info,new,plugin,info,plugin,class,get,name,classpath,plugin,na,version,current,1,8,plugin,class,get,name,collections,empty,list,false,if,logger,is,trace,enabled,logger,trace,plugin,loaded,from,classpath,plugin,info,plugins,loaded,add,new,tuple,plugin,info,plugin,plugins,list,add,plugin,info,plugins,names,add,plugin,info,get,name,set,bundle,seen,bundles,new,linked,hash,set,list,plugin,info,modules,list,new,array,list,if,modules,directory,null,try,set,bundle,modules,get,module,bundles,modules,directory,for,bundle,bundle,modules,modules,list,add,bundle,plugin,seen,bundles,add,all,modules,catch,ioexception,ex,throw,new,illegal,state,exception,unable,to,initialize,modules,ex,if,plugins,directory,null,try,if,is,accessible,directory,plugins,directory,logger,check,for,failed,plugin,removals,plugins,directory,set,bundle,plugins,get,plugin,bundles,plugins,directory,for,final,bundle,bundle,plugins,plugins,list,add,bundle,plugin,plugins,names,add,bundle,plugin,get,name,seen,bundles,add,all,plugins,catch,ioexception,ex,throw,new,illegal,state,exception,unable,to,initialize,plugins,ex,list,tuple,plugin,info,plugin,loaded,load,bundles,seen,bundles,plugins,loaded,add,all,loaded,this,info,new,plugins,and,modules,plugins,list,modules,list,this,plugins,collections,unmodifiable,list,plugins,loaded,list,string,mandatory,plugins,get,settings,if,mandatory,plugins,is,empty,false,set,string,missing,plugins,new,hash,set,for,string,mandatory,plugin,mandatory,plugins,if,plugins,names,contains,mandatory,plugin,missing,plugins,contains,mandatory,plugin,missing,plugins,add,mandatory,plugin,if,missing,plugins,is,empty,final,string,message,string,format,locale,root,missing,mandatory,plugins,s,found,plugins,s,strings,collection,to,delimited,string,missing,plugins,strings,collection,to,delimited,string,plugins,names,throw,new,illegal,state,exception,message,log,plugin,info,info,get,module,infos,module,logger,log,plugin,info,info,get,plugin,infos,plugin,logger
PluginsService -> public PluginsService(Settings settings, Path configPath, Path modulesDirectory, Path pluginsDirectory, Collection<Class<? extends Plugin>> classpathPlugins);1542402632;Constructs a new PluginService_@param settings The settings of the system_@param modulesDirectory The directory modules exist in, or null if modules should not be loaded from the filesystem_@param pluginsDirectory The directory plugins exist in, or null if plugins should not be loaded from the filesystem_@param classpathPlugins Plugins that exist in the classpath which should be loaded;public PluginsService(Settings settings, Path configPath, Path modulesDirectory, Path pluginsDirectory, Collection<Class<? extends Plugin>> classpathPlugins) {_        this.settings = settings__        this.configPath = configPath___        List<Tuple<PluginInfo, Plugin>> pluginsLoaded = new ArrayList<>()__        List<PluginInfo> pluginsList = new ArrayList<>()__        _        final List<String> pluginsNames = new ArrayList<>()__        _        for (Class<? extends Plugin> pluginClass : classpathPlugins) {_            Plugin plugin = loadPlugin(pluginClass, settings, configPath)__            PluginInfo pluginInfo = new PluginInfo(pluginClass.getName(), "classpath plugin", "NA", Version.CURRENT, "1.8",_                                                   pluginClass.getName(), Collections.emptyList(), false)__            if (logger.isTraceEnabled()) {_                logger.trace("plugin loaded from classpath [{}]", pluginInfo)__            }_            pluginsLoaded.add(new Tuple<>(pluginInfo, plugin))__            pluginsList.add(pluginInfo)__            pluginsNames.add(pluginInfo.getName())__        }__        Set<Bundle> seenBundles = new LinkedHashSet<>()__        List<PluginInfo> modulesList = new ArrayList<>()__        _        if (modulesDirectory != null) {_            try {_                Set<Bundle> modules = getModuleBundles(modulesDirectory)__                for (Bundle bundle : modules) {_                    modulesList.add(bundle.plugin)__                }_                seenBundles.addAll(modules)__            } catch (IOException ex) {_                throw new IllegalStateException("Unable to initialize modules", ex)__            }_        }__        _        if (pluginsDirectory != null) {_            try {_                _                if (isAccessibleDirectory(pluginsDirectory, logger)) {_                    checkForFailedPluginRemovals(pluginsDirectory)__                    Set<Bundle> plugins = getPluginBundles(pluginsDirectory)__                    for (final Bundle bundle : plugins) {_                        pluginsList.add(bundle.plugin)__                        pluginsNames.add(bundle.plugin.getName())__                    }_                    seenBundles.addAll(plugins)__                }_            } catch (IOException ex) {_                throw new IllegalStateException("Unable to initialize plugins", ex)__            }_        }__        List<Tuple<PluginInfo, Plugin>> loaded = loadBundles(seenBundles)__        pluginsLoaded.addAll(loaded)___        this.info = new PluginsAndModules(pluginsList, modulesList)__        this.plugins = Collections.unmodifiableList(pluginsLoaded)___        _        List<String> mandatoryPlugins = MANDATORY_SETTING.get(settings)__        if (mandatoryPlugins.isEmpty() == false) {_            Set<String> missingPlugins = new HashSet<>()__            for (String mandatoryPlugin : mandatoryPlugins) {_                if (!pluginsNames.contains(mandatoryPlugin) && !missingPlugins.contains(mandatoryPlugin)) {_                    missingPlugins.add(mandatoryPlugin)__                }_            }_            if (!missingPlugins.isEmpty()) {_                final String message = String.format(_                        Locale.ROOT,_                        "missing mandatory plugins [%s], found plugins [%s]",_                        Strings.collectionToDelimitedString(missingPlugins, ", "),_                        Strings.collectionToDelimitedString(pluginsNames, ", "))__                throw new IllegalStateException(message)__            }_        }__        _        _        logPluginInfo(info.getModuleInfos(), "module", logger)__        logPluginInfo(info.getPluginInfos(), "plugin", logger)__    };constructs,a,new,plugin,service,param,settings,the,settings,of,the,system,param,modules,directory,the,directory,modules,exist,in,or,null,if,modules,should,not,be,loaded,from,the,filesystem,param,plugins,directory,the,directory,plugins,exist,in,or,null,if,plugins,should,not,be,loaded,from,the,filesystem,param,classpath,plugins,plugins,that,exist,in,the,classpath,which,should,be,loaded;public,plugins,service,settings,settings,path,config,path,path,modules,directory,path,plugins,directory,collection,class,extends,plugin,classpath,plugins,this,settings,settings,this,config,path,config,path,list,tuple,plugin,info,plugin,plugins,loaded,new,array,list,list,plugin,info,plugins,list,new,array,list,final,list,string,plugins,names,new,array,list,for,class,extends,plugin,plugin,class,classpath,plugins,plugin,plugin,load,plugin,plugin,class,settings,config,path,plugin,info,plugin,info,new,plugin,info,plugin,class,get,name,classpath,plugin,na,version,current,1,8,plugin,class,get,name,collections,empty,list,false,if,logger,is,trace,enabled,logger,trace,plugin,loaded,from,classpath,plugin,info,plugins,loaded,add,new,tuple,plugin,info,plugin,plugins,list,add,plugin,info,plugins,names,add,plugin,info,get,name,set,bundle,seen,bundles,new,linked,hash,set,list,plugin,info,modules,list,new,array,list,if,modules,directory,null,try,set,bundle,modules,get,module,bundles,modules,directory,for,bundle,bundle,modules,modules,list,add,bundle,plugin,seen,bundles,add,all,modules,catch,ioexception,ex,throw,new,illegal,state,exception,unable,to,initialize,modules,ex,if,plugins,directory,null,try,if,is,accessible,directory,plugins,directory,logger,check,for,failed,plugin,removals,plugins,directory,set,bundle,plugins,get,plugin,bundles,plugins,directory,for,final,bundle,bundle,plugins,plugins,list,add,bundle,plugin,plugins,names,add,bundle,plugin,get,name,seen,bundles,add,all,plugins,catch,ioexception,ex,throw,new,illegal,state,exception,unable,to,initialize,plugins,ex,list,tuple,plugin,info,plugin,loaded,load,bundles,seen,bundles,plugins,loaded,add,all,loaded,this,info,new,plugins,and,modules,plugins,list,modules,list,this,plugins,collections,unmodifiable,list,plugins,loaded,list,string,mandatory,plugins,get,settings,if,mandatory,plugins,is,empty,false,set,string,missing,plugins,new,hash,set,for,string,mandatory,plugin,mandatory,plugins,if,plugins,names,contains,mandatory,plugin,missing,plugins,contains,mandatory,plugin,missing,plugins,add,mandatory,plugin,if,missing,plugins,is,empty,final,string,message,string,format,locale,root,missing,mandatory,plugins,s,found,plugins,s,strings,collection,to,delimited,string,missing,plugins,strings,collection,to,delimited,string,plugins,names,throw,new,illegal,state,exception,message,log,plugin,info,info,get,module,infos,module,logger,log,plugin,info,info,get,plugin,infos,plugin,logger
PluginsService -> public PluginsService(Settings settings, Path configPath, Path modulesDirectory, Path pluginsDirectory, Collection<Class<? extends Plugin>> classpathPlugins);1544823664;Constructs a new PluginService_@param settings The settings of the system_@param modulesDirectory The directory modules exist in, or null if modules should not be loaded from the filesystem_@param pluginsDirectory The directory plugins exist in, or null if plugins should not be loaded from the filesystem_@param classpathPlugins Plugins that exist in the classpath which should be loaded;public PluginsService(Settings settings, Path configPath, Path modulesDirectory, Path pluginsDirectory, Collection<Class<? extends Plugin>> classpathPlugins) {_        this.settings = settings__        this.configPath = configPath___        List<Tuple<PluginInfo, Plugin>> pluginsLoaded = new ArrayList<>()__        List<PluginInfo> pluginsList = new ArrayList<>()__        _        final List<String> pluginsNames = new ArrayList<>()__        _        for (Class<? extends Plugin> pluginClass : classpathPlugins) {_            Plugin plugin = loadPlugin(pluginClass, settings, configPath)__            PluginInfo pluginInfo = new PluginInfo(pluginClass.getName(), "classpath plugin", "NA", Version.CURRENT, "1.8",_                                                   pluginClass.getName(), Collections.emptyList(), false)__            if (logger.isTraceEnabled()) {_                logger.trace("plugin loaded from classpath [{}]", pluginInfo)__            }_            pluginsLoaded.add(new Tuple<>(pluginInfo, plugin))__            pluginsList.add(pluginInfo)__            pluginsNames.add(pluginInfo.getName())__        }__        Set<Bundle> seenBundles = new LinkedHashSet<>()__        List<PluginInfo> modulesList = new ArrayList<>()__        _        if (modulesDirectory != null) {_            try {_                Set<Bundle> modules = getModuleBundles(modulesDirectory)__                for (Bundle bundle : modules) {_                    modulesList.add(bundle.plugin)__                }_                seenBundles.addAll(modules)__            } catch (IOException ex) {_                throw new IllegalStateException("Unable to initialize modules", ex)__            }_        }__        _        if (pluginsDirectory != null) {_            try {_                _                if (isAccessibleDirectory(pluginsDirectory, logger)) {_                    checkForFailedPluginRemovals(pluginsDirectory)__                    Set<Bundle> plugins = getPluginBundles(pluginsDirectory)__                    for (final Bundle bundle : plugins) {_                        pluginsList.add(bundle.plugin)__                        pluginsNames.add(bundle.plugin.getName())__                    }_                    seenBundles.addAll(plugins)__                }_            } catch (IOException ex) {_                throw new IllegalStateException("Unable to initialize plugins", ex)__            }_        }__        List<Tuple<PluginInfo, Plugin>> loaded = loadBundles(seenBundles)__        pluginsLoaded.addAll(loaded)___        this.info = new PluginsAndModules(pluginsList, modulesList)__        this.plugins = Collections.unmodifiableList(pluginsLoaded)___        _        List<String> mandatoryPlugins = MANDATORY_SETTING.get(settings)__        if (mandatoryPlugins.isEmpty() == false) {_            Set<String> missingPlugins = new HashSet<>()__            for (String mandatoryPlugin : mandatoryPlugins) {_                if (!pluginsNames.contains(mandatoryPlugin) && !missingPlugins.contains(mandatoryPlugin)) {_                    missingPlugins.add(mandatoryPlugin)__                }_            }_            if (!missingPlugins.isEmpty()) {_                final String message = String.format(_                        Locale.ROOT,_                        "missing mandatory plugins [%s], found plugins [%s]",_                        Strings.collectionToDelimitedString(missingPlugins, ", "),_                        Strings.collectionToDelimitedString(pluginsNames, ", "))__                throw new IllegalStateException(message)__            }_        }__        _        _        logPluginInfo(info.getModuleInfos(), "module", logger)__        logPluginInfo(info.getPluginInfos(), "plugin", logger)__    };constructs,a,new,plugin,service,param,settings,the,settings,of,the,system,param,modules,directory,the,directory,modules,exist,in,or,null,if,modules,should,not,be,loaded,from,the,filesystem,param,plugins,directory,the,directory,plugins,exist,in,or,null,if,plugins,should,not,be,loaded,from,the,filesystem,param,classpath,plugins,plugins,that,exist,in,the,classpath,which,should,be,loaded;public,plugins,service,settings,settings,path,config,path,path,modules,directory,path,plugins,directory,collection,class,extends,plugin,classpath,plugins,this,settings,settings,this,config,path,config,path,list,tuple,plugin,info,plugin,plugins,loaded,new,array,list,list,plugin,info,plugins,list,new,array,list,final,list,string,plugins,names,new,array,list,for,class,extends,plugin,plugin,class,classpath,plugins,plugin,plugin,load,plugin,plugin,class,settings,config,path,plugin,info,plugin,info,new,plugin,info,plugin,class,get,name,classpath,plugin,na,version,current,1,8,plugin,class,get,name,collections,empty,list,false,if,logger,is,trace,enabled,logger,trace,plugin,loaded,from,classpath,plugin,info,plugins,loaded,add,new,tuple,plugin,info,plugin,plugins,list,add,plugin,info,plugins,names,add,plugin,info,get,name,set,bundle,seen,bundles,new,linked,hash,set,list,plugin,info,modules,list,new,array,list,if,modules,directory,null,try,set,bundle,modules,get,module,bundles,modules,directory,for,bundle,bundle,modules,modules,list,add,bundle,plugin,seen,bundles,add,all,modules,catch,ioexception,ex,throw,new,illegal,state,exception,unable,to,initialize,modules,ex,if,plugins,directory,null,try,if,is,accessible,directory,plugins,directory,logger,check,for,failed,plugin,removals,plugins,directory,set,bundle,plugins,get,plugin,bundles,plugins,directory,for,final,bundle,bundle,plugins,plugins,list,add,bundle,plugin,plugins,names,add,bundle,plugin,get,name,seen,bundles,add,all,plugins,catch,ioexception,ex,throw,new,illegal,state,exception,unable,to,initialize,plugins,ex,list,tuple,plugin,info,plugin,loaded,load,bundles,seen,bundles,plugins,loaded,add,all,loaded,this,info,new,plugins,and,modules,plugins,list,modules,list,this,plugins,collections,unmodifiable,list,plugins,loaded,list,string,mandatory,plugins,get,settings,if,mandatory,plugins,is,empty,false,set,string,missing,plugins,new,hash,set,for,string,mandatory,plugin,mandatory,plugins,if,plugins,names,contains,mandatory,plugin,missing,plugins,contains,mandatory,plugin,missing,plugins,add,mandatory,plugin,if,missing,plugins,is,empty,final,string,message,string,format,locale,root,missing,mandatory,plugins,s,found,plugins,s,strings,collection,to,delimited,string,missing,plugins,strings,collection,to,delimited,string,plugins,names,throw,new,illegal,state,exception,message,log,plugin,info,info,get,module,infos,module,logger,log,plugin,info,info,get,plugin,infos,plugin,logger
PluginsService -> static Set<Bundle> getPluginBundles(final Path pluginsDirectory) throws IOException;1524684173;Get bundles for plugins installed in the given plugins directory.;static Set<Bundle> getPluginBundles(final Path pluginsDirectory) throws IOException {_        return findBundles(pluginsDirectory, "plugin").stream().flatMap(b -> b.bundles().stream()).collect(Collectors.toSet())__    };get,bundles,for,plugins,installed,in,the,given,plugins,directory;static,set,bundle,get,plugin,bundles,final,path,plugins,directory,throws,ioexception,return,find,bundles,plugins,directory,plugin,stream,flat,map,b,b,bundles,stream,collect,collectors,to,set
PluginsService -> static Set<Bundle> getPluginBundles(final Path pluginsDirectory) throws IOException;1526900724;Get bundles for plugins installed in the given plugins directory.;static Set<Bundle> getPluginBundles(final Path pluginsDirectory) throws IOException {_        return findBundles(pluginsDirectory, "plugin")__    };get,bundles,for,plugins,installed,in,the,given,plugins,directory;static,set,bundle,get,plugin,bundles,final,path,plugins,directory,throws,ioexception,return,find,bundles,plugins,directory,plugin
PluginsService -> static Set<Bundle> getPluginBundles(final Path pluginsDirectory) throws IOException;1527583663;Get bundles for plugins installed in the given plugins directory.;static Set<Bundle> getPluginBundles(final Path pluginsDirectory) throws IOException {_        return findBundles(pluginsDirectory, "plugin")__    };get,bundles,for,plugins,installed,in,the,given,plugins,directory;static,set,bundle,get,plugin,bundles,final,path,plugins,directory,throws,ioexception,return,find,bundles,plugins,directory,plugin
PluginsService -> static Set<Bundle> getPluginBundles(final Path pluginsDirectory) throws IOException;1527878678;Get bundles for plugins installed in the given plugins directory.;static Set<Bundle> getPluginBundles(final Path pluginsDirectory) throws IOException {_        return findBundles(pluginsDirectory, "plugin")__    };get,bundles,for,plugins,installed,in,the,given,plugins,directory;static,set,bundle,get,plugin,bundles,final,path,plugins,directory,throws,ioexception,return,find,bundles,plugins,directory,plugin
PluginsService -> static Set<Bundle> getPluginBundles(final Path pluginsDirectory) throws IOException;1528762805;Get bundles for plugins installed in the given plugins directory.;static Set<Bundle> getPluginBundles(final Path pluginsDirectory) throws IOException {_        return findBundles(pluginsDirectory, "plugin")__    };get,bundles,for,plugins,installed,in,the,given,plugins,directory;static,set,bundle,get,plugin,bundles,final,path,plugins,directory,throws,ioexception,return,find,bundles,plugins,directory,plugin
PluginsService -> static Set<Bundle> getPluginBundles(final Path pluginsDirectory) throws IOException;1539615817;Get bundles for plugins installed in the given plugins directory.;static Set<Bundle> getPluginBundles(final Path pluginsDirectory) throws IOException {_        return findBundles(pluginsDirectory, "plugin")__    };get,bundles,for,plugins,installed,in,the,given,plugins,directory;static,set,bundle,get,plugin,bundles,final,path,plugins,directory,throws,ioexception,return,find,bundles,plugins,directory,plugin
PluginsService -> static Set<Bundle> getPluginBundles(final Path pluginsDirectory) throws IOException;1540486836;Get bundles for plugins installed in the given plugins directory.;static Set<Bundle> getPluginBundles(final Path pluginsDirectory) throws IOException {_        return findBundles(pluginsDirectory, "plugin")__    };get,bundles,for,plugins,installed,in,the,given,plugins,directory;static,set,bundle,get,plugin,bundles,final,path,plugins,directory,throws,ioexception,return,find,bundles,plugins,directory,plugin
PluginsService -> static Set<Bundle> getPluginBundles(final Path pluginsDirectory) throws IOException;1541008027;Get bundles for plugins installed in the given plugins directory.;static Set<Bundle> getPluginBundles(final Path pluginsDirectory) throws IOException {_        return findBundles(pluginsDirectory, "plugin")__    };get,bundles,for,plugins,installed,in,the,given,plugins,directory;static,set,bundle,get,plugin,bundles,final,path,plugins,directory,throws,ioexception,return,find,bundles,plugins,directory,plugin
PluginsService -> static Set<Bundle> getPluginBundles(final Path pluginsDirectory) throws IOException;1541092382;Get bundles for plugins installed in the given plugins directory.;static Set<Bundle> getPluginBundles(final Path pluginsDirectory) throws IOException {_        return findBundles(pluginsDirectory, "plugin")__    };get,bundles,for,plugins,installed,in,the,given,plugins,directory;static,set,bundle,get,plugin,bundles,final,path,plugins,directory,throws,ioexception,return,find,bundles,plugins,directory,plugin
PluginsService -> static Set<Bundle> getPluginBundles(final Path pluginsDirectory) throws IOException;1542402632;Get bundles for plugins installed in the given plugins directory.;static Set<Bundle> getPluginBundles(final Path pluginsDirectory) throws IOException {_        return findBundles(pluginsDirectory, "plugin")__    };get,bundles,for,plugins,installed,in,the,given,plugins,directory;static,set,bundle,get,plugin,bundles,final,path,plugins,directory,throws,ioexception,return,find,bundles,plugins,directory,plugin
PluginsService -> static Set<Bundle> getPluginBundles(final Path pluginsDirectory) throws IOException;1544823664;Get bundles for plugins installed in the given plugins directory.;static Set<Bundle> getPluginBundles(final Path pluginsDirectory) throws IOException {_        return findBundles(pluginsDirectory, "plugin")__    };get,bundles,for,plugins,installed,in,the,given,plugins,directory;static,set,bundle,get,plugin,bundles,final,path,plugins,directory,throws,ioexception,return,find,bundles,plugins,directory,plugin
PluginsService -> static Set<Bundle> getPluginBundles(final Path pluginsDirectory) throws IOException;1545199608;Get bundles for plugins installed in the given plugins directory.;static Set<Bundle> getPluginBundles(final Path pluginsDirectory) throws IOException {_        return findBundles(pluginsDirectory, "plugin")__    };get,bundles,for,plugins,installed,in,the,given,plugins,directory;static,set,bundle,get,plugin,bundles,final,path,plugins,directory,throws,ioexception,return,find,bundles,plugins,directory,plugin
PluginsService -> static List<Bundle> sortBundles(Set<Bundle> bundles);1524684173;Return the given bundles, sorted in dependency loading order.__This sort is stable, so that if two plugins do not have any interdependency,_their relative order from iteration of the provided set will not change.__@throws IllegalStateException if a dependency cycle is found;static List<Bundle> sortBundles(Set<Bundle> bundles) {_        Map<String, Bundle> namedBundles = bundles.stream().collect(Collectors.toMap(b -> b.plugin.getName(), Function.identity()))__        LinkedHashSet<Bundle> sortedBundles = new LinkedHashSet<>()__        LinkedHashSet<String> dependencyStack = new LinkedHashSet<>()__        for (Bundle bundle : bundles) {_            addSortedBundle(bundle, namedBundles, sortedBundles, dependencyStack)__        }_        return new ArrayList<>(sortedBundles)__    };return,the,given,bundles,sorted,in,dependency,loading,order,this,sort,is,stable,so,that,if,two,plugins,do,not,have,any,interdependency,their,relative,order,from,iteration,of,the,provided,set,will,not,change,throws,illegal,state,exception,if,a,dependency,cycle,is,found;static,list,bundle,sort,bundles,set,bundle,bundles,map,string,bundle,named,bundles,bundles,stream,collect,collectors,to,map,b,b,plugin,get,name,function,identity,linked,hash,set,bundle,sorted,bundles,new,linked,hash,set,linked,hash,set,string,dependency,stack,new,linked,hash,set,for,bundle,bundle,bundles,add,sorted,bundle,bundle,named,bundles,sorted,bundles,dependency,stack,return,new,array,list,sorted,bundles
PluginsService -> static List<Bundle> sortBundles(Set<Bundle> bundles);1526900724;Return the given bundles, sorted in dependency loading order.__This sort is stable, so that if two plugins do not have any interdependency,_their relative order from iteration of the provided set will not change.__@throws IllegalStateException if a dependency cycle is found;static List<Bundle> sortBundles(Set<Bundle> bundles) {_        Map<String, Bundle> namedBundles = bundles.stream().collect(Collectors.toMap(b -> b.plugin.getName(), Function.identity()))__        LinkedHashSet<Bundle> sortedBundles = new LinkedHashSet<>()__        LinkedHashSet<String> dependencyStack = new LinkedHashSet<>()__        for (Bundle bundle : bundles) {_            addSortedBundle(bundle, namedBundles, sortedBundles, dependencyStack)__        }_        return new ArrayList<>(sortedBundles)__    };return,the,given,bundles,sorted,in,dependency,loading,order,this,sort,is,stable,so,that,if,two,plugins,do,not,have,any,interdependency,their,relative,order,from,iteration,of,the,provided,set,will,not,change,throws,illegal,state,exception,if,a,dependency,cycle,is,found;static,list,bundle,sort,bundles,set,bundle,bundles,map,string,bundle,named,bundles,bundles,stream,collect,collectors,to,map,b,b,plugin,get,name,function,identity,linked,hash,set,bundle,sorted,bundles,new,linked,hash,set,linked,hash,set,string,dependency,stack,new,linked,hash,set,for,bundle,bundle,bundles,add,sorted,bundle,bundle,named,bundles,sorted,bundles,dependency,stack,return,new,array,list,sorted,bundles
PluginsService -> static List<Bundle> sortBundles(Set<Bundle> bundles);1527583663;Return the given bundles, sorted in dependency loading order.__This sort is stable, so that if two plugins do not have any interdependency,_their relative order from iteration of the provided set will not change.__@throws IllegalStateException if a dependency cycle is found;static List<Bundle> sortBundles(Set<Bundle> bundles) {_        Map<String, Bundle> namedBundles = bundles.stream().collect(Collectors.toMap(b -> b.plugin.getName(), Function.identity()))__        LinkedHashSet<Bundle> sortedBundles = new LinkedHashSet<>()__        LinkedHashSet<String> dependencyStack = new LinkedHashSet<>()__        for (Bundle bundle : bundles) {_            addSortedBundle(bundle, namedBundles, sortedBundles, dependencyStack)__        }_        return new ArrayList<>(sortedBundles)__    };return,the,given,bundles,sorted,in,dependency,loading,order,this,sort,is,stable,so,that,if,two,plugins,do,not,have,any,interdependency,their,relative,order,from,iteration,of,the,provided,set,will,not,change,throws,illegal,state,exception,if,a,dependency,cycle,is,found;static,list,bundle,sort,bundles,set,bundle,bundles,map,string,bundle,named,bundles,bundles,stream,collect,collectors,to,map,b,b,plugin,get,name,function,identity,linked,hash,set,bundle,sorted,bundles,new,linked,hash,set,linked,hash,set,string,dependency,stack,new,linked,hash,set,for,bundle,bundle,bundles,add,sorted,bundle,bundle,named,bundles,sorted,bundles,dependency,stack,return,new,array,list,sorted,bundles
PluginsService -> static List<Bundle> sortBundles(Set<Bundle> bundles);1527878678;Return the given bundles, sorted in dependency loading order.__This sort is stable, so that if two plugins do not have any interdependency,_their relative order from iteration of the provided set will not change.__@throws IllegalStateException if a dependency cycle is found;static List<Bundle> sortBundles(Set<Bundle> bundles) {_        Map<String, Bundle> namedBundles = bundles.stream().collect(Collectors.toMap(b -> b.plugin.getName(), Function.identity()))__        LinkedHashSet<Bundle> sortedBundles = new LinkedHashSet<>()__        LinkedHashSet<String> dependencyStack = new LinkedHashSet<>()__        for (Bundle bundle : bundles) {_            addSortedBundle(bundle, namedBundles, sortedBundles, dependencyStack)__        }_        return new ArrayList<>(sortedBundles)__    };return,the,given,bundles,sorted,in,dependency,loading,order,this,sort,is,stable,so,that,if,two,plugins,do,not,have,any,interdependency,their,relative,order,from,iteration,of,the,provided,set,will,not,change,throws,illegal,state,exception,if,a,dependency,cycle,is,found;static,list,bundle,sort,bundles,set,bundle,bundles,map,string,bundle,named,bundles,bundles,stream,collect,collectors,to,map,b,b,plugin,get,name,function,identity,linked,hash,set,bundle,sorted,bundles,new,linked,hash,set,linked,hash,set,string,dependency,stack,new,linked,hash,set,for,bundle,bundle,bundles,add,sorted,bundle,bundle,named,bundles,sorted,bundles,dependency,stack,return,new,array,list,sorted,bundles
PluginsService -> static List<Bundle> sortBundles(Set<Bundle> bundles);1528762805;Return the given bundles, sorted in dependency loading order.__This sort is stable, so that if two plugins do not have any interdependency,_their relative order from iteration of the provided set will not change.__@throws IllegalStateException if a dependency cycle is found;static List<Bundle> sortBundles(Set<Bundle> bundles) {_        Map<String, Bundle> namedBundles = bundles.stream().collect(Collectors.toMap(b -> b.plugin.getName(), Function.identity()))__        LinkedHashSet<Bundle> sortedBundles = new LinkedHashSet<>()__        LinkedHashSet<String> dependencyStack = new LinkedHashSet<>()__        for (Bundle bundle : bundles) {_            addSortedBundle(bundle, namedBundles, sortedBundles, dependencyStack)__        }_        return new ArrayList<>(sortedBundles)__    };return,the,given,bundles,sorted,in,dependency,loading,order,this,sort,is,stable,so,that,if,two,plugins,do,not,have,any,interdependency,their,relative,order,from,iteration,of,the,provided,set,will,not,change,throws,illegal,state,exception,if,a,dependency,cycle,is,found;static,list,bundle,sort,bundles,set,bundle,bundles,map,string,bundle,named,bundles,bundles,stream,collect,collectors,to,map,b,b,plugin,get,name,function,identity,linked,hash,set,bundle,sorted,bundles,new,linked,hash,set,linked,hash,set,string,dependency,stack,new,linked,hash,set,for,bundle,bundle,bundles,add,sorted,bundle,bundle,named,bundles,sorted,bundles,dependency,stack,return,new,array,list,sorted,bundles
PluginsService -> static List<Bundle> sortBundles(Set<Bundle> bundles);1539615817;Return the given bundles, sorted in dependency loading order.__This sort is stable, so that if two plugins do not have any interdependency,_their relative order from iteration of the provided set will not change.__@throws IllegalStateException if a dependency cycle is found;static List<Bundle> sortBundles(Set<Bundle> bundles) {_        Map<String, Bundle> namedBundles = bundles.stream().collect(Collectors.toMap(b -> b.plugin.getName(), Function.identity()))__        LinkedHashSet<Bundle> sortedBundles = new LinkedHashSet<>()__        LinkedHashSet<String> dependencyStack = new LinkedHashSet<>()__        for (Bundle bundle : bundles) {_            addSortedBundle(bundle, namedBundles, sortedBundles, dependencyStack)__        }_        return new ArrayList<>(sortedBundles)__    };return,the,given,bundles,sorted,in,dependency,loading,order,this,sort,is,stable,so,that,if,two,plugins,do,not,have,any,interdependency,their,relative,order,from,iteration,of,the,provided,set,will,not,change,throws,illegal,state,exception,if,a,dependency,cycle,is,found;static,list,bundle,sort,bundles,set,bundle,bundles,map,string,bundle,named,bundles,bundles,stream,collect,collectors,to,map,b,b,plugin,get,name,function,identity,linked,hash,set,bundle,sorted,bundles,new,linked,hash,set,linked,hash,set,string,dependency,stack,new,linked,hash,set,for,bundle,bundle,bundles,add,sorted,bundle,bundle,named,bundles,sorted,bundles,dependency,stack,return,new,array,list,sorted,bundles
PluginsService -> static List<Bundle> sortBundles(Set<Bundle> bundles);1540486836;Return the given bundles, sorted in dependency loading order.__This sort is stable, so that if two plugins do not have any interdependency,_their relative order from iteration of the provided set will not change.__@throws IllegalStateException if a dependency cycle is found;static List<Bundle> sortBundles(Set<Bundle> bundles) {_        Map<String, Bundle> namedBundles = bundles.stream().collect(Collectors.toMap(b -> b.plugin.getName(), Function.identity()))__        LinkedHashSet<Bundle> sortedBundles = new LinkedHashSet<>()__        LinkedHashSet<String> dependencyStack = new LinkedHashSet<>()__        for (Bundle bundle : bundles) {_            addSortedBundle(bundle, namedBundles, sortedBundles, dependencyStack)__        }_        return new ArrayList<>(sortedBundles)__    };return,the,given,bundles,sorted,in,dependency,loading,order,this,sort,is,stable,so,that,if,two,plugins,do,not,have,any,interdependency,their,relative,order,from,iteration,of,the,provided,set,will,not,change,throws,illegal,state,exception,if,a,dependency,cycle,is,found;static,list,bundle,sort,bundles,set,bundle,bundles,map,string,bundle,named,bundles,bundles,stream,collect,collectors,to,map,b,b,plugin,get,name,function,identity,linked,hash,set,bundle,sorted,bundles,new,linked,hash,set,linked,hash,set,string,dependency,stack,new,linked,hash,set,for,bundle,bundle,bundles,add,sorted,bundle,bundle,named,bundles,sorted,bundles,dependency,stack,return,new,array,list,sorted,bundles
PluginsService -> static List<Bundle> sortBundles(Set<Bundle> bundles);1541008027;Return the given bundles, sorted in dependency loading order.__This sort is stable, so that if two plugins do not have any interdependency,_their relative order from iteration of the provided set will not change.__@throws IllegalStateException if a dependency cycle is found;static List<Bundle> sortBundles(Set<Bundle> bundles) {_        Map<String, Bundle> namedBundles = bundles.stream().collect(Collectors.toMap(b -> b.plugin.getName(), Function.identity()))__        LinkedHashSet<Bundle> sortedBundles = new LinkedHashSet<>()__        LinkedHashSet<String> dependencyStack = new LinkedHashSet<>()__        for (Bundle bundle : bundles) {_            addSortedBundle(bundle, namedBundles, sortedBundles, dependencyStack)__        }_        return new ArrayList<>(sortedBundles)__    };return,the,given,bundles,sorted,in,dependency,loading,order,this,sort,is,stable,so,that,if,two,plugins,do,not,have,any,interdependency,their,relative,order,from,iteration,of,the,provided,set,will,not,change,throws,illegal,state,exception,if,a,dependency,cycle,is,found;static,list,bundle,sort,bundles,set,bundle,bundles,map,string,bundle,named,bundles,bundles,stream,collect,collectors,to,map,b,b,plugin,get,name,function,identity,linked,hash,set,bundle,sorted,bundles,new,linked,hash,set,linked,hash,set,string,dependency,stack,new,linked,hash,set,for,bundle,bundle,bundles,add,sorted,bundle,bundle,named,bundles,sorted,bundles,dependency,stack,return,new,array,list,sorted,bundles
PluginsService -> static List<Bundle> sortBundles(Set<Bundle> bundles);1541092382;Return the given bundles, sorted in dependency loading order.__This sort is stable, so that if two plugins do not have any interdependency,_their relative order from iteration of the provided set will not change.__@throws IllegalStateException if a dependency cycle is found;static List<Bundle> sortBundles(Set<Bundle> bundles) {_        Map<String, Bundle> namedBundles = bundles.stream().collect(Collectors.toMap(b -> b.plugin.getName(), Function.identity()))__        LinkedHashSet<Bundle> sortedBundles = new LinkedHashSet<>()__        LinkedHashSet<String> dependencyStack = new LinkedHashSet<>()__        for (Bundle bundle : bundles) {_            addSortedBundle(bundle, namedBundles, sortedBundles, dependencyStack)__        }_        return new ArrayList<>(sortedBundles)__    };return,the,given,bundles,sorted,in,dependency,loading,order,this,sort,is,stable,so,that,if,two,plugins,do,not,have,any,interdependency,their,relative,order,from,iteration,of,the,provided,set,will,not,change,throws,illegal,state,exception,if,a,dependency,cycle,is,found;static,list,bundle,sort,bundles,set,bundle,bundles,map,string,bundle,named,bundles,bundles,stream,collect,collectors,to,map,b,b,plugin,get,name,function,identity,linked,hash,set,bundle,sorted,bundles,new,linked,hash,set,linked,hash,set,string,dependency,stack,new,linked,hash,set,for,bundle,bundle,bundles,add,sorted,bundle,bundle,named,bundles,sorted,bundles,dependency,stack,return,new,array,list,sorted,bundles
PluginsService -> static List<Bundle> sortBundles(Set<Bundle> bundles);1542402632;Return the given bundles, sorted in dependency loading order.__This sort is stable, so that if two plugins do not have any interdependency,_their relative order from iteration of the provided set will not change.__@throws IllegalStateException if a dependency cycle is found;static List<Bundle> sortBundles(Set<Bundle> bundles) {_        Map<String, Bundle> namedBundles = bundles.stream().collect(Collectors.toMap(b -> b.plugin.getName(), Function.identity()))__        LinkedHashSet<Bundle> sortedBundles = new LinkedHashSet<>()__        LinkedHashSet<String> dependencyStack = new LinkedHashSet<>()__        for (Bundle bundle : bundles) {_            addSortedBundle(bundle, namedBundles, sortedBundles, dependencyStack)__        }_        return new ArrayList<>(sortedBundles)__    };return,the,given,bundles,sorted,in,dependency,loading,order,this,sort,is,stable,so,that,if,two,plugins,do,not,have,any,interdependency,their,relative,order,from,iteration,of,the,provided,set,will,not,change,throws,illegal,state,exception,if,a,dependency,cycle,is,found;static,list,bundle,sort,bundles,set,bundle,bundles,map,string,bundle,named,bundles,bundles,stream,collect,collectors,to,map,b,b,plugin,get,name,function,identity,linked,hash,set,bundle,sorted,bundles,new,linked,hash,set,linked,hash,set,string,dependency,stack,new,linked,hash,set,for,bundle,bundle,bundles,add,sorted,bundle,bundle,named,bundles,sorted,bundles,dependency,stack,return,new,array,list,sorted,bundles
PluginsService -> static List<Bundle> sortBundles(Set<Bundle> bundles);1544823664;Return the given bundles, sorted in dependency loading order.__This sort is stable, so that if two plugins do not have any interdependency,_their relative order from iteration of the provided set will not change.__@throws IllegalStateException if a dependency cycle is found;static List<Bundle> sortBundles(Set<Bundle> bundles) {_        Map<String, Bundle> namedBundles = bundles.stream().collect(Collectors.toMap(b -> b.plugin.getName(), Function.identity()))__        LinkedHashSet<Bundle> sortedBundles = new LinkedHashSet<>()__        LinkedHashSet<String> dependencyStack = new LinkedHashSet<>()__        for (Bundle bundle : bundles) {_            addSortedBundle(bundle, namedBundles, sortedBundles, dependencyStack)__        }_        return new ArrayList<>(sortedBundles)__    };return,the,given,bundles,sorted,in,dependency,loading,order,this,sort,is,stable,so,that,if,two,plugins,do,not,have,any,interdependency,their,relative,order,from,iteration,of,the,provided,set,will,not,change,throws,illegal,state,exception,if,a,dependency,cycle,is,found;static,list,bundle,sort,bundles,set,bundle,bundles,map,string,bundle,named,bundles,bundles,stream,collect,collectors,to,map,b,b,plugin,get,name,function,identity,linked,hash,set,bundle,sorted,bundles,new,linked,hash,set,linked,hash,set,string,dependency,stack,new,linked,hash,set,for,bundle,bundle,bundles,add,sorted,bundle,bundle,named,bundles,sorted,bundles,dependency,stack,return,new,array,list,sorted,bundles
PluginsService -> static List<Bundle> sortBundles(Set<Bundle> bundles);1545199608;Return the given bundles, sorted in dependency loading order.__This sort is stable, so that if two plugins do not have any interdependency,_their relative order from iteration of the provided set will not change.__@throws IllegalStateException if a dependency cycle is found;static List<Bundle> sortBundles(Set<Bundle> bundles) {_        Map<String, Bundle> namedBundles = bundles.stream().collect(Collectors.toMap(b -> b.plugin.getName(), Function.identity()))__        LinkedHashSet<Bundle> sortedBundles = new LinkedHashSet<>()__        LinkedHashSet<String> dependencyStack = new LinkedHashSet<>()__        for (Bundle bundle : bundles) {_            addSortedBundle(bundle, namedBundles, sortedBundles, dependencyStack)__        }_        return new ArrayList<>(sortedBundles)__    };return,the,given,bundles,sorted,in,dependency,loading,order,this,sort,is,stable,so,that,if,two,plugins,do,not,have,any,interdependency,their,relative,order,from,iteration,of,the,provided,set,will,not,change,throws,illegal,state,exception,if,a,dependency,cycle,is,found;static,list,bundle,sort,bundles,set,bundle,bundles,map,string,bundle,named,bundles,bundles,stream,collect,collectors,to,map,b,b,plugin,get,name,function,identity,linked,hash,set,bundle,sorted,bundles,new,linked,hash,set,linked,hash,set,string,dependency,stack,new,linked,hash,set,for,bundle,bundle,bundles,add,sorted,bundle,bundle,named,bundles,sorted,bundles,dependency,stack,return,new,array,list,sorted,bundles
PluginsService -> static void verifyCompatibility(PluginInfo info);1524684173;Verify the given plugin is compatible with the current Elasticsearch installation.;static void verifyCompatibility(PluginInfo info) {_        if (info.getElasticsearchVersion().equals(Version.CURRENT) == false) {_            throw new IllegalArgumentException("Plugin [" + info.getName() + "] was built for Elasticsearch version "_                + info.getElasticsearchVersion() + " but version " + Version.CURRENT + " is running")__        }_        JarHell.checkJavaVersion(info.getName(), info.getJavaVersion())__    };verify,the,given,plugin,is,compatible,with,the,current,elasticsearch,installation;static,void,verify,compatibility,plugin,info,info,if,info,get,elasticsearch,version,equals,version,current,false,throw,new,illegal,argument,exception,plugin,info,get,name,was,built,for,elasticsearch,version,info,get,elasticsearch,version,but,version,version,current,is,running,jar,hell,check,java,version,info,get,name,info,get,java,version
PluginsService -> static void verifyCompatibility(PluginInfo info);1526900724;Verify the given plugin is compatible with the current Elasticsearch installation.;static void verifyCompatibility(PluginInfo info) {_        if (info.getElasticsearchVersion().equals(Version.CURRENT) == false) {_            throw new IllegalArgumentException("Plugin [" + info.getName() + "] was built for Elasticsearch version "_                + info.getElasticsearchVersion() + " but version " + Version.CURRENT + " is running")__        }_        JarHell.checkJavaVersion(info.getName(), info.getJavaVersion())__    };verify,the,given,plugin,is,compatible,with,the,current,elasticsearch,installation;static,void,verify,compatibility,plugin,info,info,if,info,get,elasticsearch,version,equals,version,current,false,throw,new,illegal,argument,exception,plugin,info,get,name,was,built,for,elasticsearch,version,info,get,elasticsearch,version,but,version,version,current,is,running,jar,hell,check,java,version,info,get,name,info,get,java,version
PluginsService -> static void verifyCompatibility(PluginInfo info);1527583663;Verify the given plugin is compatible with the current Elasticsearch installation.;static void verifyCompatibility(PluginInfo info) {_        if (info.getElasticsearchVersion().equals(Version.CURRENT) == false) {_            throw new IllegalArgumentException("Plugin [" + info.getName() + "] was built for Elasticsearch version "_                + info.getElasticsearchVersion() + " but version " + Version.CURRENT + " is running")__        }_        JarHell.checkJavaVersion(info.getName(), info.getJavaVersion())__    };verify,the,given,plugin,is,compatible,with,the,current,elasticsearch,installation;static,void,verify,compatibility,plugin,info,info,if,info,get,elasticsearch,version,equals,version,current,false,throw,new,illegal,argument,exception,plugin,info,get,name,was,built,for,elasticsearch,version,info,get,elasticsearch,version,but,version,version,current,is,running,jar,hell,check,java,version,info,get,name,info,get,java,version
PluginsService -> static void verifyCompatibility(PluginInfo info);1527878678;Verify the given plugin is compatible with the current Elasticsearch installation.;static void verifyCompatibility(PluginInfo info) {_        if (info.getElasticsearchVersion().equals(Version.CURRENT) == false) {_            throw new IllegalArgumentException("Plugin [" + info.getName() + "] was built for Elasticsearch version "_                + info.getElasticsearchVersion() + " but version " + Version.CURRENT + " is running")__        }_        JarHell.checkJavaVersion(info.getName(), info.getJavaVersion())__    };verify,the,given,plugin,is,compatible,with,the,current,elasticsearch,installation;static,void,verify,compatibility,plugin,info,info,if,info,get,elasticsearch,version,equals,version,current,false,throw,new,illegal,argument,exception,plugin,info,get,name,was,built,for,elasticsearch,version,info,get,elasticsearch,version,but,version,version,current,is,running,jar,hell,check,java,version,info,get,name,info,get,java,version
PluginsService -> static void verifyCompatibility(PluginInfo info);1528762805;Verify the given plugin is compatible with the current Elasticsearch installation.;static void verifyCompatibility(PluginInfo info) {_        if (info.getElasticsearchVersion().equals(Version.CURRENT) == false) {_            throw new IllegalArgumentException("Plugin [" + info.getName() + "] was built for Elasticsearch version "_                + info.getElasticsearchVersion() + " but version " + Version.CURRENT + " is running")__        }_        JarHell.checkJavaVersion(info.getName(), info.getJavaVersion())__    };verify,the,given,plugin,is,compatible,with,the,current,elasticsearch,installation;static,void,verify,compatibility,plugin,info,info,if,info,get,elasticsearch,version,equals,version,current,false,throw,new,illegal,argument,exception,plugin,info,get,name,was,built,for,elasticsearch,version,info,get,elasticsearch,version,but,version,version,current,is,running,jar,hell,check,java,version,info,get,name,info,get,java,version
PluginsService -> static void verifyCompatibility(PluginInfo info);1539615817;Verify the given plugin is compatible with the current Elasticsearch installation.;static void verifyCompatibility(PluginInfo info) {_        if (info.getElasticsearchVersion().equals(Version.CURRENT) == false) {_            throw new IllegalArgumentException("Plugin [" + info.getName() + "] was built for Elasticsearch version "_                + info.getElasticsearchVersion() + " but version " + Version.CURRENT + " is running")__        }_        JarHell.checkJavaVersion(info.getName(), info.getJavaVersion())__    };verify,the,given,plugin,is,compatible,with,the,current,elasticsearch,installation;static,void,verify,compatibility,plugin,info,info,if,info,get,elasticsearch,version,equals,version,current,false,throw,new,illegal,argument,exception,plugin,info,get,name,was,built,for,elasticsearch,version,info,get,elasticsearch,version,but,version,version,current,is,running,jar,hell,check,java,version,info,get,name,info,get,java,version
PluginsService -> static void verifyCompatibility(PluginInfo info);1540486836;Verify the given plugin is compatible with the current Elasticsearch installation.;static void verifyCompatibility(PluginInfo info) {_        if (info.getElasticsearchVersion().equals(Version.CURRENT) == false) {_            throw new IllegalArgumentException("Plugin [" + info.getName() + "] was built for Elasticsearch version "_                + info.getElasticsearchVersion() + " but version " + Version.CURRENT + " is running")__        }_        JarHell.checkJavaVersion(info.getName(), info.getJavaVersion())__    };verify,the,given,plugin,is,compatible,with,the,current,elasticsearch,installation;static,void,verify,compatibility,plugin,info,info,if,info,get,elasticsearch,version,equals,version,current,false,throw,new,illegal,argument,exception,plugin,info,get,name,was,built,for,elasticsearch,version,info,get,elasticsearch,version,but,version,version,current,is,running,jar,hell,check,java,version,info,get,name,info,get,java,version
PluginsService -> static void verifyCompatibility(PluginInfo info);1541008027;Verify the given plugin is compatible with the current Elasticsearch installation.;static void verifyCompatibility(PluginInfo info) {_        if (info.getElasticsearchVersion().equals(Version.CURRENT) == false) {_            throw new IllegalArgumentException("Plugin [" + info.getName() + "] was built for Elasticsearch version "_                + info.getElasticsearchVersion() + " but version " + Version.CURRENT + " is running")__        }_        JarHell.checkJavaVersion(info.getName(), info.getJavaVersion())__    };verify,the,given,plugin,is,compatible,with,the,current,elasticsearch,installation;static,void,verify,compatibility,plugin,info,info,if,info,get,elasticsearch,version,equals,version,current,false,throw,new,illegal,argument,exception,plugin,info,get,name,was,built,for,elasticsearch,version,info,get,elasticsearch,version,but,version,version,current,is,running,jar,hell,check,java,version,info,get,name,info,get,java,version
PluginsService -> static void verifyCompatibility(PluginInfo info);1541092382;Verify the given plugin is compatible with the current Elasticsearch installation.;static void verifyCompatibility(PluginInfo info) {_        if (info.getElasticsearchVersion().equals(Version.CURRENT) == false) {_            throw new IllegalArgumentException("Plugin [" + info.getName() + "] was built for Elasticsearch version "_                + info.getElasticsearchVersion() + " but version " + Version.CURRENT + " is running")__        }_        JarHell.checkJavaVersion(info.getName(), info.getJavaVersion())__    };verify,the,given,plugin,is,compatible,with,the,current,elasticsearch,installation;static,void,verify,compatibility,plugin,info,info,if,info,get,elasticsearch,version,equals,version,current,false,throw,new,illegal,argument,exception,plugin,info,get,name,was,built,for,elasticsearch,version,info,get,elasticsearch,version,but,version,version,current,is,running,jar,hell,check,java,version,info,get,name,info,get,java,version
PluginsService -> static void verifyCompatibility(PluginInfo info);1542402632;Verify the given plugin is compatible with the current Elasticsearch installation.;static void verifyCompatibility(PluginInfo info) {_        if (info.getElasticsearchVersion().equals(Version.CURRENT) == false) {_            throw new IllegalArgumentException("Plugin [" + info.getName() + "] was built for Elasticsearch version "_                + info.getElasticsearchVersion() + " but version " + Version.CURRENT + " is running")__        }_        JarHell.checkJavaVersion(info.getName(), info.getJavaVersion())__    };verify,the,given,plugin,is,compatible,with,the,current,elasticsearch,installation;static,void,verify,compatibility,plugin,info,info,if,info,get,elasticsearch,version,equals,version,current,false,throw,new,illegal,argument,exception,plugin,info,get,name,was,built,for,elasticsearch,version,info,get,elasticsearch,version,but,version,version,current,is,running,jar,hell,check,java,version,info,get,name,info,get,java,version
PluginsService -> static void verifyCompatibility(PluginInfo info);1544823664;Verify the given plugin is compatible with the current Elasticsearch installation.;static void verifyCompatibility(PluginInfo info) {_        if (info.getElasticsearchVersion().equals(Version.CURRENT) == false) {_            throw new IllegalArgumentException("Plugin [" + info.getName() + "] was built for Elasticsearch version "_                + info.getElasticsearchVersion() + " but version " + Version.CURRENT + " is running")__        }_        JarHell.checkJavaVersion(info.getName(), info.getJavaVersion())__    };verify,the,given,plugin,is,compatible,with,the,current,elasticsearch,installation;static,void,verify,compatibility,plugin,info,info,if,info,get,elasticsearch,version,equals,version,current,false,throw,new,illegal,argument,exception,plugin,info,get,name,was,built,for,elasticsearch,version,info,get,elasticsearch,version,but,version,version,current,is,running,jar,hell,check,java,version,info,get,name,info,get,java,version
PluginsService -> static void verifyCompatibility(PluginInfo info);1545199608;Verify the given plugin is compatible with the current Elasticsearch installation.;static void verifyCompatibility(PluginInfo info) {_        if (info.getElasticsearchVersion().equals(Version.CURRENT) == false) {_            throw new IllegalArgumentException("Plugin [" + info.getName() + "] was built for Elasticsearch version "_                + info.getElasticsearchVersion() + " but version " + Version.CURRENT + " is running")__        }_        JarHell.checkJavaVersion(info.getName(), info.getJavaVersion())__    };verify,the,given,plugin,is,compatible,with,the,current,elasticsearch,installation;static,void,verify,compatibility,plugin,info,info,if,info,get,elasticsearch,version,equals,version,current,false,throw,new,illegal,argument,exception,plugin,info,get,name,was,built,for,elasticsearch,version,info,get,elasticsearch,version,but,version,version,current,is,running,jar,hell,check,java,version,info,get,name,info,get,java,version
PluginsService -> static Set<Bundle> getModuleBundles(Path modulesDirectory) throws IOException;1524684173;Get bundles for plugins installed in the given modules directory.;static Set<Bundle> getModuleBundles(Path modulesDirectory) throws IOException {_        return findBundles(modulesDirectory, "module").stream().flatMap(b -> b.bundles().stream()).collect(Collectors.toSet())__    };get,bundles,for,plugins,installed,in,the,given,modules,directory;static,set,bundle,get,module,bundles,path,modules,directory,throws,ioexception,return,find,bundles,modules,directory,module,stream,flat,map,b,b,bundles,stream,collect,collectors,to,set
PluginsService -> static Set<Bundle> getModuleBundles(Path modulesDirectory) throws IOException;1526900724;Get bundles for plugins installed in the given modules directory.;static Set<Bundle> getModuleBundles(Path modulesDirectory) throws IOException {_        return findBundles(modulesDirectory, "module")__    };get,bundles,for,plugins,installed,in,the,given,modules,directory;static,set,bundle,get,module,bundles,path,modules,directory,throws,ioexception,return,find,bundles,modules,directory,module
PluginsService -> static Set<Bundle> getModuleBundles(Path modulesDirectory) throws IOException;1527583663;Get bundles for plugins installed in the given modules directory.;static Set<Bundle> getModuleBundles(Path modulesDirectory) throws IOException {_        return findBundles(modulesDirectory, "module")__    };get,bundles,for,plugins,installed,in,the,given,modules,directory;static,set,bundle,get,module,bundles,path,modules,directory,throws,ioexception,return,find,bundles,modules,directory,module
PluginsService -> static Set<Bundle> getModuleBundles(Path modulesDirectory) throws IOException;1527878678;Get bundles for plugins installed in the given modules directory.;static Set<Bundle> getModuleBundles(Path modulesDirectory) throws IOException {_        return findBundles(modulesDirectory, "module")__    };get,bundles,for,plugins,installed,in,the,given,modules,directory;static,set,bundle,get,module,bundles,path,modules,directory,throws,ioexception,return,find,bundles,modules,directory,module
PluginsService -> static Set<Bundle> getModuleBundles(Path modulesDirectory) throws IOException;1528762805;Get bundles for plugins installed in the given modules directory.;static Set<Bundle> getModuleBundles(Path modulesDirectory) throws IOException {_        return findBundles(modulesDirectory, "module")__    };get,bundles,for,plugins,installed,in,the,given,modules,directory;static,set,bundle,get,module,bundles,path,modules,directory,throws,ioexception,return,find,bundles,modules,directory,module
PluginsService -> static Set<Bundle> getModuleBundles(Path modulesDirectory) throws IOException;1539615817;Get bundles for plugins installed in the given modules directory.;static Set<Bundle> getModuleBundles(Path modulesDirectory) throws IOException {_        return findBundles(modulesDirectory, "module")__    };get,bundles,for,plugins,installed,in,the,given,modules,directory;static,set,bundle,get,module,bundles,path,modules,directory,throws,ioexception,return,find,bundles,modules,directory,module
PluginsService -> static Set<Bundle> getModuleBundles(Path modulesDirectory) throws IOException;1540486836;Get bundles for plugins installed in the given modules directory.;static Set<Bundle> getModuleBundles(Path modulesDirectory) throws IOException {_        return findBundles(modulesDirectory, "module")__    };get,bundles,for,plugins,installed,in,the,given,modules,directory;static,set,bundle,get,module,bundles,path,modules,directory,throws,ioexception,return,find,bundles,modules,directory,module
PluginsService -> static Set<Bundle> getModuleBundles(Path modulesDirectory) throws IOException;1541008027;Get bundles for plugins installed in the given modules directory.;static Set<Bundle> getModuleBundles(Path modulesDirectory) throws IOException {_        return findBundles(modulesDirectory, "module")__    };get,bundles,for,plugins,installed,in,the,given,modules,directory;static,set,bundle,get,module,bundles,path,modules,directory,throws,ioexception,return,find,bundles,modules,directory,module
PluginsService -> static Set<Bundle> getModuleBundles(Path modulesDirectory) throws IOException;1541092382;Get bundles for plugins installed in the given modules directory.;static Set<Bundle> getModuleBundles(Path modulesDirectory) throws IOException {_        return findBundles(modulesDirectory, "module")__    };get,bundles,for,plugins,installed,in,the,given,modules,directory;static,set,bundle,get,module,bundles,path,modules,directory,throws,ioexception,return,find,bundles,modules,directory,module
PluginsService -> static Set<Bundle> getModuleBundles(Path modulesDirectory) throws IOException;1542402632;Get bundles for plugins installed in the given modules directory.;static Set<Bundle> getModuleBundles(Path modulesDirectory) throws IOException {_        return findBundles(modulesDirectory, "module")__    };get,bundles,for,plugins,installed,in,the,given,modules,directory;static,set,bundle,get,module,bundles,path,modules,directory,throws,ioexception,return,find,bundles,modules,directory,module
PluginsService -> static Set<Bundle> getModuleBundles(Path modulesDirectory) throws IOException;1544823664;Get bundles for plugins installed in the given modules directory.;static Set<Bundle> getModuleBundles(Path modulesDirectory) throws IOException {_        return findBundles(modulesDirectory, "module")__    };get,bundles,for,plugins,installed,in,the,given,modules,directory;static,set,bundle,get,module,bundles,path,modules,directory,throws,ioexception,return,find,bundles,modules,directory,module
PluginsService -> static Set<Bundle> getModuleBundles(Path modulesDirectory) throws IOException;1545199608;Get bundles for plugins installed in the given modules directory.;static Set<Bundle> getModuleBundles(Path modulesDirectory) throws IOException {_        return findBundles(modulesDirectory, "module")__    };get,bundles,for,plugins,installed,in,the,given,modules,directory;static,set,bundle,get,module,bundles,path,modules,directory,throws,ioexception,return,find,bundles,modules,directory,module
PluginsService -> public static List<Path> findPluginDirs(final Path rootPath) throws IOException;1524684173;Extracts all installed plugin directories from the provided {@code rootPath} expanding meta-plugins if needed.__@param rootPath the path where the plugins are installed_@return a list of all plugin paths installed in the {@code rootPath}_@throws IOException if an I/O exception occurred reading the directories;public static List<Path> findPluginDirs(final Path rootPath) throws IOException {_        final Tuple<List<Path>, Map<String, List<Path>>> groupedPluginDirs = findGroupedPluginDirs(rootPath)__        return Stream.concat(_                groupedPluginDirs.v1().stream(),_                groupedPluginDirs.v2().values().stream().flatMap(Collection::stream))_                .collect(Collectors.toList())__    };extracts,all,installed,plugin,directories,from,the,provided,code,root,path,expanding,meta,plugins,if,needed,param,root,path,the,path,where,the,plugins,are,installed,return,a,list,of,all,plugin,paths,installed,in,the,code,root,path,throws,ioexception,if,an,i,o,exception,occurred,reading,the,directories;public,static,list,path,find,plugin,dirs,final,path,root,path,throws,ioexception,final,tuple,list,path,map,string,list,path,grouped,plugin,dirs,find,grouped,plugin,dirs,root,path,return,stream,concat,grouped,plugin,dirs,v1,stream,grouped,plugin,dirs,v2,values,stream,flat,map,collection,stream,collect,collectors,to,list
PluginsService -> public static List<Path> findPluginDirs(final Path rootPath) throws IOException;1526900724;Extracts all installed plugin directories from the provided {@code rootPath}.__@param rootPath the path where the plugins are installed_@return a list of all plugin paths installed in the {@code rootPath}_@throws IOException if an I/O exception occurred reading the directories;public static List<Path> findPluginDirs(final Path rootPath) throws IOException {_        final List<Path> plugins = new ArrayList<>()__        final Set<String> seen = new HashSet<>()__        if (Files.exists(rootPath)) {_            try (DirectoryStream<Path> stream = Files.newDirectoryStream(rootPath)) {_                for (Path plugin : stream) {_                    if (FileSystemUtils.isDesktopServicesStore(plugin) ||_                        plugin.getFileName().toString().startsWith(".removing-")) {_                        continue__                    }_                    if (seen.add(plugin.getFileName().toString()) == false) {_                        throw new IllegalStateException("duplicate plugin: " + plugin)__                    }_                    plugins.add(plugin)__                }_            }_        }_        return plugins__    };extracts,all,installed,plugin,directories,from,the,provided,code,root,path,param,root,path,the,path,where,the,plugins,are,installed,return,a,list,of,all,plugin,paths,installed,in,the,code,root,path,throws,ioexception,if,an,i,o,exception,occurred,reading,the,directories;public,static,list,path,find,plugin,dirs,final,path,root,path,throws,ioexception,final,list,path,plugins,new,array,list,final,set,string,seen,new,hash,set,if,files,exists,root,path,try,directory,stream,path,stream,files,new,directory,stream,root,path,for,path,plugin,stream,if,file,system,utils,is,desktop,services,store,plugin,plugin,get,file,name,to,string,starts,with,removing,continue,if,seen,add,plugin,get,file,name,to,string,false,throw,new,illegal,state,exception,duplicate,plugin,plugin,plugins,add,plugin,return,plugins
PluginsService -> public static List<Path> findPluginDirs(final Path rootPath) throws IOException;1527583663;Extracts all installed plugin directories from the provided {@code rootPath}.__@param rootPath the path where the plugins are installed_@return a list of all plugin paths installed in the {@code rootPath}_@throws IOException if an I/O exception occurred reading the directories;public static List<Path> findPluginDirs(final Path rootPath) throws IOException {_        final List<Path> plugins = new ArrayList<>()__        final Set<String> seen = new HashSet<>()__        if (Files.exists(rootPath)) {_            try (DirectoryStream<Path> stream = Files.newDirectoryStream(rootPath)) {_                for (Path plugin : stream) {_                    if (FileSystemUtils.isDesktopServicesStore(plugin) ||_                        plugin.getFileName().toString().startsWith(".removing-")) {_                        continue__                    }_                    if (seen.add(plugin.getFileName().toString()) == false) {_                        throw new IllegalStateException("duplicate plugin: " + plugin)__                    }_                    plugins.add(plugin)__                }_            }_        }_        return plugins__    };extracts,all,installed,plugin,directories,from,the,provided,code,root,path,param,root,path,the,path,where,the,plugins,are,installed,return,a,list,of,all,plugin,paths,installed,in,the,code,root,path,throws,ioexception,if,an,i,o,exception,occurred,reading,the,directories;public,static,list,path,find,plugin,dirs,final,path,root,path,throws,ioexception,final,list,path,plugins,new,array,list,final,set,string,seen,new,hash,set,if,files,exists,root,path,try,directory,stream,path,stream,files,new,directory,stream,root,path,for,path,plugin,stream,if,file,system,utils,is,desktop,services,store,plugin,plugin,get,file,name,to,string,starts,with,removing,continue,if,seen,add,plugin,get,file,name,to,string,false,throw,new,illegal,state,exception,duplicate,plugin,plugin,plugins,add,plugin,return,plugins
PluginsService -> public static List<Path> findPluginDirs(final Path rootPath) throws IOException;1527878678;Extracts all installed plugin directories from the provided {@code rootPath}.__@param rootPath the path where the plugins are installed_@return a list of all plugin paths installed in the {@code rootPath}_@throws IOException if an I/O exception occurred reading the directories;public static List<Path> findPluginDirs(final Path rootPath) throws IOException {_        final List<Path> plugins = new ArrayList<>()__        final Set<String> seen = new HashSet<>()__        if (Files.exists(rootPath)) {_            try (DirectoryStream<Path> stream = Files.newDirectoryStream(rootPath)) {_                for (Path plugin : stream) {_                    if (FileSystemUtils.isDesktopServicesStore(plugin) ||_                        plugin.getFileName().toString().startsWith(".removing-")) {_                        continue__                    }_                    if (seen.add(plugin.getFileName().toString()) == false) {_                        throw new IllegalStateException("duplicate plugin: " + plugin)__                    }_                    plugins.add(plugin)__                }_            }_        }_        return plugins__    };extracts,all,installed,plugin,directories,from,the,provided,code,root,path,param,root,path,the,path,where,the,plugins,are,installed,return,a,list,of,all,plugin,paths,installed,in,the,code,root,path,throws,ioexception,if,an,i,o,exception,occurred,reading,the,directories;public,static,list,path,find,plugin,dirs,final,path,root,path,throws,ioexception,final,list,path,plugins,new,array,list,final,set,string,seen,new,hash,set,if,files,exists,root,path,try,directory,stream,path,stream,files,new,directory,stream,root,path,for,path,plugin,stream,if,file,system,utils,is,desktop,services,store,plugin,plugin,get,file,name,to,string,starts,with,removing,continue,if,seen,add,plugin,get,file,name,to,string,false,throw,new,illegal,state,exception,duplicate,plugin,plugin,plugins,add,plugin,return,plugins
PluginsService -> public static List<Path> findPluginDirs(final Path rootPath) throws IOException;1528762805;Extracts all installed plugin directories from the provided {@code rootPath}.__@param rootPath the path where the plugins are installed_@return a list of all plugin paths installed in the {@code rootPath}_@throws IOException if an I/O exception occurred reading the directories;public static List<Path> findPluginDirs(final Path rootPath) throws IOException {_        final List<Path> plugins = new ArrayList<>()__        final Set<String> seen = new HashSet<>()__        if (Files.exists(rootPath)) {_            try (DirectoryStream<Path> stream = Files.newDirectoryStream(rootPath)) {_                for (Path plugin : stream) {_                    if (FileSystemUtils.isDesktopServicesStore(plugin) ||_                        plugin.getFileName().toString().startsWith(".removing-")) {_                        continue__                    }_                    if (seen.add(plugin.getFileName().toString()) == false) {_                        throw new IllegalStateException("duplicate plugin: " + plugin)__                    }_                    plugins.add(plugin)__                }_            }_        }_        return plugins__    };extracts,all,installed,plugin,directories,from,the,provided,code,root,path,param,root,path,the,path,where,the,plugins,are,installed,return,a,list,of,all,plugin,paths,installed,in,the,code,root,path,throws,ioexception,if,an,i,o,exception,occurred,reading,the,directories;public,static,list,path,find,plugin,dirs,final,path,root,path,throws,ioexception,final,list,path,plugins,new,array,list,final,set,string,seen,new,hash,set,if,files,exists,root,path,try,directory,stream,path,stream,files,new,directory,stream,root,path,for,path,plugin,stream,if,file,system,utils,is,desktop,services,store,plugin,plugin,get,file,name,to,string,starts,with,removing,continue,if,seen,add,plugin,get,file,name,to,string,false,throw,new,illegal,state,exception,duplicate,plugin,plugin,plugins,add,plugin,return,plugins
PluginsService -> public static List<Path> findPluginDirs(final Path rootPath) throws IOException;1539615817;Extracts all installed plugin directories from the provided {@code rootPath}.__@param rootPath the path where the plugins are installed_@return a list of all plugin paths installed in the {@code rootPath}_@throws IOException if an I/O exception occurred reading the directories;public static List<Path> findPluginDirs(final Path rootPath) throws IOException {_        final List<Path> plugins = new ArrayList<>()__        final Set<String> seen = new HashSet<>()__        if (Files.exists(rootPath)) {_            try (DirectoryStream<Path> stream = Files.newDirectoryStream(rootPath)) {_                for (Path plugin : stream) {_                    if (FileSystemUtils.isDesktopServicesStore(plugin) ||_                        plugin.getFileName().toString().startsWith(".removing-")) {_                        continue__                    }_                    if (seen.add(plugin.getFileName().toString()) == false) {_                        throw new IllegalStateException("duplicate plugin: " + plugin)__                    }_                    plugins.add(plugin)__                }_            }_        }_        return plugins__    };extracts,all,installed,plugin,directories,from,the,provided,code,root,path,param,root,path,the,path,where,the,plugins,are,installed,return,a,list,of,all,plugin,paths,installed,in,the,code,root,path,throws,ioexception,if,an,i,o,exception,occurred,reading,the,directories;public,static,list,path,find,plugin,dirs,final,path,root,path,throws,ioexception,final,list,path,plugins,new,array,list,final,set,string,seen,new,hash,set,if,files,exists,root,path,try,directory,stream,path,stream,files,new,directory,stream,root,path,for,path,plugin,stream,if,file,system,utils,is,desktop,services,store,plugin,plugin,get,file,name,to,string,starts,with,removing,continue,if,seen,add,plugin,get,file,name,to,string,false,throw,new,illegal,state,exception,duplicate,plugin,plugin,plugins,add,plugin,return,plugins
PluginsService -> public static List<Path> findPluginDirs(final Path rootPath) throws IOException;1540486836;Extracts all installed plugin directories from the provided {@code rootPath}.__@param rootPath the path where the plugins are installed_@return a list of all plugin paths installed in the {@code rootPath}_@throws IOException if an I/O exception occurred reading the directories;public static List<Path> findPluginDirs(final Path rootPath) throws IOException {_        final List<Path> plugins = new ArrayList<>()__        final Set<String> seen = new HashSet<>()__        if (Files.exists(rootPath)) {_            try (DirectoryStream<Path> stream = Files.newDirectoryStream(rootPath)) {_                for (Path plugin : stream) {_                    if (FileSystemUtils.isDesktopServicesStore(plugin) ||_                        plugin.getFileName().toString().startsWith(".removing-")) {_                        continue__                    }_                    if (seen.add(plugin.getFileName().toString()) == false) {_                        throw new IllegalStateException("duplicate plugin: " + plugin)__                    }_                    plugins.add(plugin)__                }_            }_        }_        return plugins__    };extracts,all,installed,plugin,directories,from,the,provided,code,root,path,param,root,path,the,path,where,the,plugins,are,installed,return,a,list,of,all,plugin,paths,installed,in,the,code,root,path,throws,ioexception,if,an,i,o,exception,occurred,reading,the,directories;public,static,list,path,find,plugin,dirs,final,path,root,path,throws,ioexception,final,list,path,plugins,new,array,list,final,set,string,seen,new,hash,set,if,files,exists,root,path,try,directory,stream,path,stream,files,new,directory,stream,root,path,for,path,plugin,stream,if,file,system,utils,is,desktop,services,store,plugin,plugin,get,file,name,to,string,starts,with,removing,continue,if,seen,add,plugin,get,file,name,to,string,false,throw,new,illegal,state,exception,duplicate,plugin,plugin,plugins,add,plugin,return,plugins
PluginsService -> public static List<Path> findPluginDirs(final Path rootPath) throws IOException;1541008027;Extracts all installed plugin directories from the provided {@code rootPath}.__@param rootPath the path where the plugins are installed_@return a list of all plugin paths installed in the {@code rootPath}_@throws IOException if an I/O exception occurred reading the directories;public static List<Path> findPluginDirs(final Path rootPath) throws IOException {_        final List<Path> plugins = new ArrayList<>()__        final Set<String> seen = new HashSet<>()__        if (Files.exists(rootPath)) {_            try (DirectoryStream<Path> stream = Files.newDirectoryStream(rootPath)) {_                for (Path plugin : stream) {_                    if (FileSystemUtils.isDesktopServicesStore(plugin) ||_                        plugin.getFileName().toString().startsWith(".removing-")) {_                        continue__                    }_                    if (seen.add(plugin.getFileName().toString()) == false) {_                        throw new IllegalStateException("duplicate plugin: " + plugin)__                    }_                    plugins.add(plugin)__                }_            }_        }_        return plugins__    };extracts,all,installed,plugin,directories,from,the,provided,code,root,path,param,root,path,the,path,where,the,plugins,are,installed,return,a,list,of,all,plugin,paths,installed,in,the,code,root,path,throws,ioexception,if,an,i,o,exception,occurred,reading,the,directories;public,static,list,path,find,plugin,dirs,final,path,root,path,throws,ioexception,final,list,path,plugins,new,array,list,final,set,string,seen,new,hash,set,if,files,exists,root,path,try,directory,stream,path,stream,files,new,directory,stream,root,path,for,path,plugin,stream,if,file,system,utils,is,desktop,services,store,plugin,plugin,get,file,name,to,string,starts,with,removing,continue,if,seen,add,plugin,get,file,name,to,string,false,throw,new,illegal,state,exception,duplicate,plugin,plugin,plugins,add,plugin,return,plugins
PluginsService -> public static List<Path> findPluginDirs(final Path rootPath) throws IOException;1541092382;Extracts all installed plugin directories from the provided {@code rootPath}.__@param rootPath the path where the plugins are installed_@return a list of all plugin paths installed in the {@code rootPath}_@throws IOException if an I/O exception occurred reading the directories;public static List<Path> findPluginDirs(final Path rootPath) throws IOException {_        final List<Path> plugins = new ArrayList<>()__        final Set<String> seen = new HashSet<>()__        if (Files.exists(rootPath)) {_            try (DirectoryStream<Path> stream = Files.newDirectoryStream(rootPath)) {_                for (Path plugin : stream) {_                    if (FileSystemUtils.isDesktopServicesStore(plugin) ||_                        plugin.getFileName().toString().startsWith(".removing-")) {_                        continue__                    }_                    if (seen.add(plugin.getFileName().toString()) == false) {_                        throw new IllegalStateException("duplicate plugin: " + plugin)__                    }_                    plugins.add(plugin)__                }_            }_        }_        return plugins__    };extracts,all,installed,plugin,directories,from,the,provided,code,root,path,param,root,path,the,path,where,the,plugins,are,installed,return,a,list,of,all,plugin,paths,installed,in,the,code,root,path,throws,ioexception,if,an,i,o,exception,occurred,reading,the,directories;public,static,list,path,find,plugin,dirs,final,path,root,path,throws,ioexception,final,list,path,plugins,new,array,list,final,set,string,seen,new,hash,set,if,files,exists,root,path,try,directory,stream,path,stream,files,new,directory,stream,root,path,for,path,plugin,stream,if,file,system,utils,is,desktop,services,store,plugin,plugin,get,file,name,to,string,starts,with,removing,continue,if,seen,add,plugin,get,file,name,to,string,false,throw,new,illegal,state,exception,duplicate,plugin,plugin,plugins,add,plugin,return,plugins
PluginsService -> public static List<Path> findPluginDirs(final Path rootPath) throws IOException;1542402632;Extracts all installed plugin directories from the provided {@code rootPath}.__@param rootPath the path where the plugins are installed_@return a list of all plugin paths installed in the {@code rootPath}_@throws IOException if an I/O exception occurred reading the directories;public static List<Path> findPluginDirs(final Path rootPath) throws IOException {_        final List<Path> plugins = new ArrayList<>()__        final Set<String> seen = new HashSet<>()__        if (Files.exists(rootPath)) {_            try (DirectoryStream<Path> stream = Files.newDirectoryStream(rootPath)) {_                for (Path plugin : stream) {_                    if (FileSystemUtils.isDesktopServicesStore(plugin) ||_                        plugin.getFileName().toString().startsWith(".removing-")) {_                        continue__                    }_                    if (seen.add(plugin.getFileName().toString()) == false) {_                        throw new IllegalStateException("duplicate plugin: " + plugin)__                    }_                    plugins.add(plugin)__                }_            }_        }_        return plugins__    };extracts,all,installed,plugin,directories,from,the,provided,code,root,path,param,root,path,the,path,where,the,plugins,are,installed,return,a,list,of,all,plugin,paths,installed,in,the,code,root,path,throws,ioexception,if,an,i,o,exception,occurred,reading,the,directories;public,static,list,path,find,plugin,dirs,final,path,root,path,throws,ioexception,final,list,path,plugins,new,array,list,final,set,string,seen,new,hash,set,if,files,exists,root,path,try,directory,stream,path,stream,files,new,directory,stream,root,path,for,path,plugin,stream,if,file,system,utils,is,desktop,services,store,plugin,plugin,get,file,name,to,string,starts,with,removing,continue,if,seen,add,plugin,get,file,name,to,string,false,throw,new,illegal,state,exception,duplicate,plugin,plugin,plugins,add,plugin,return,plugins
PluginsService -> public static List<Path> findPluginDirs(final Path rootPath) throws IOException;1544823664;Extracts all installed plugin directories from the provided {@code rootPath}.__@param rootPath the path where the plugins are installed_@return a list of all plugin paths installed in the {@code rootPath}_@throws IOException if an I/O exception occurred reading the directories;public static List<Path> findPluginDirs(final Path rootPath) throws IOException {_        final List<Path> plugins = new ArrayList<>()__        final Set<String> seen = new HashSet<>()__        if (Files.exists(rootPath)) {_            try (DirectoryStream<Path> stream = Files.newDirectoryStream(rootPath)) {_                for (Path plugin : stream) {_                    if (FileSystemUtils.isDesktopServicesStore(plugin) ||_                        plugin.getFileName().toString().startsWith(".removing-")) {_                        continue__                    }_                    if (seen.add(plugin.getFileName().toString()) == false) {_                        throw new IllegalStateException("duplicate plugin: " + plugin)__                    }_                    plugins.add(plugin)__                }_            }_        }_        return plugins__    };extracts,all,installed,plugin,directories,from,the,provided,code,root,path,param,root,path,the,path,where,the,plugins,are,installed,return,a,list,of,all,plugin,paths,installed,in,the,code,root,path,throws,ioexception,if,an,i,o,exception,occurred,reading,the,directories;public,static,list,path,find,plugin,dirs,final,path,root,path,throws,ioexception,final,list,path,plugins,new,array,list,final,set,string,seen,new,hash,set,if,files,exists,root,path,try,directory,stream,path,stream,files,new,directory,stream,root,path,for,path,plugin,stream,if,file,system,utils,is,desktop,services,store,plugin,plugin,get,file,name,to,string,starts,with,removing,continue,if,seen,add,plugin,get,file,name,to,string,false,throw,new,illegal,state,exception,duplicate,plugin,plugin,plugins,add,plugin,return,plugins
PluginsService -> public static List<Path> findPluginDirs(final Path rootPath) throws IOException;1545199608;Extracts all installed plugin directories from the provided {@code rootPath}.__@param rootPath the path where the plugins are installed_@return a list of all plugin paths installed in the {@code rootPath}_@throws IOException if an I/O exception occurred reading the directories;public static List<Path> findPluginDirs(final Path rootPath) throws IOException {_        final List<Path> plugins = new ArrayList<>()__        final Set<String> seen = new HashSet<>()__        if (Files.exists(rootPath)) {_            try (DirectoryStream<Path> stream = Files.newDirectoryStream(rootPath)) {_                for (Path plugin : stream) {_                    if (FileSystemUtils.isDesktopServicesStore(plugin) ||_                        plugin.getFileName().toString().startsWith(".removing-")) {_                        continue__                    }_                    if (seen.add(plugin.getFileName().toString()) == false) {_                        throw new IllegalStateException("duplicate plugin: " + plugin)__                    }_                    plugins.add(plugin)__                }_            }_        }_        return plugins__    };extracts,all,installed,plugin,directories,from,the,provided,code,root,path,param,root,path,the,path,where,the,plugins,are,installed,return,a,list,of,all,plugin,paths,installed,in,the,code,root,path,throws,ioexception,if,an,i,o,exception,occurred,reading,the,directories;public,static,list,path,find,plugin,dirs,final,path,root,path,throws,ioexception,final,list,path,plugins,new,array,list,final,set,string,seen,new,hash,set,if,files,exists,root,path,try,directory,stream,path,stream,files,new,directory,stream,root,path,for,path,plugin,stream,if,file,system,utils,is,desktop,services,store,plugin,plugin,get,file,name,to,string,starts,with,removing,continue,if,seen,add,plugin,get,file,name,to,string,false,throw,new,illegal,state,exception,duplicate,plugin,plugin,plugins,add,plugin,return,plugins
