commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public List<Setting<?>> getPluginSettings() {     return plugins.stream().flatMap(p -> p.v2().getSettings().stream()).collect(Collectors.toList()). }
false;public;0;3;;public List<String> getPluginSettingsFilter() {     return plugins.stream().flatMap(p -> p.v2().getSettingsFilter().stream()).collect(Collectors.toList()). }
false;private,static;3;10;;private static void logPluginInfo(final List<PluginInfo> pluginInfos, final String type, final Logger logger) {     assert pluginInfos != null.     if (pluginInfos.isEmpty()) {         logger.info("no " + type + "s loaded").     } else {         for (final String name : pluginInfos.stream().map(PluginInfo::getName).sorted().collect(Collectors.toList())) {             logger.info("loaded " + type + " [" + name + "]").         }     } }
false;public;0;34;;public Settings updatedSettings() {     Map<String, String> foundSettings = new HashMap<>().     final Map<String, String> features = new TreeMap<>().     final Settings.Builder builder = Settings.builder().     for (Tuple<PluginInfo, Plugin> plugin : plugins) {         Settings settings = plugin.v2().additionalSettings().         for (String setting : settings.keySet()) {             String oldPlugin = foundSettings.put(setting, plugin.v1().getName()).             if (oldPlugin != null) {                 throw new IllegalArgumentException("Cannot have additional setting [" + setting + "] " + "in plugin [" + plugin.v1().getName() + "], already added in plugin [" + oldPlugin + "]").             }         }         builder.put(settings).         final Optional<String> maybeFeature = plugin.v2().getFeature().         if (maybeFeature.isPresent()) {             final String feature = maybeFeature.get().             if (features.containsKey(feature)) {                 final String message = String.format(Locale.ROOT, "duplicate feature [%s] in plugin [%s], already added in [%s]", feature, plugin.v1().getName(), features.get(feature)).                 throw new IllegalArgumentException(message).             }             features.put(feature, plugin.v1().getName()).         }     }     for (final String feature : features.keySet()) {         builder.put(TransportSettings.FEATURE_PREFIX + "." + feature, true).     }     return builder.put(this.settings).build(). }
false;public;0;7;;public Collection<Module> createGuiceModules() {     List<Module> modules = new ArrayList<>().     for (Tuple<PluginInfo, Plugin> plugin : plugins) {         modules.addAll(plugin.v2().createGuiceModules()).     }     return modules. }
false;public;1;7;;public List<ExecutorBuilder<?>> getExecutorBuilders(Settings settings) {     final ArrayList<ExecutorBuilder<?>> builders = new ArrayList<>().     for (final Tuple<PluginInfo, Plugin> plugin : plugins) {         builders.addAll(plugin.v2().getExecutorBuilders(settings)).     }     return builders. }
true;public;0;7;/**  * Returns all classes injected into guice by plugins which extend {@link LifecycleComponent}.  */ ;/**  * Returns all classes injected into guice by plugins which extend {@link LifecycleComponent}.  */ public Collection<Class<? extends LifecycleComponent>> getGuiceServiceClasses() {     List<Class<? extends LifecycleComponent>> services = new ArrayList<>().     for (Tuple<PluginInfo, Plugin> plugin : plugins) {         services.addAll(plugin.v2().getGuiceServiceClasses()).     }     return services. }
false;public;1;5;;public void onIndexModule(IndexModule indexModule) {     for (Tuple<PluginInfo, Plugin> plugin : plugins) {         plugin.v2().onIndexModule(indexModule).     } }
true;public;0;3;/**  * Get information about plugins and modules  */ ;/**  * Get information about plugins and modules  */ public PluginsAndModules info() {     return info. }
false;public;1;7;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     Bundle bundle = (Bundle) o.     return Objects.equals(plugin, bundle.plugin). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(plugin). }
true;public,static;1;19;/**  * Extracts all installed plugin directories from the provided {@code rootPath}.  *  * @param rootPath the path where the plugins are installed  * @return a list of all plugin paths installed in the {@code rootPath}  * @throws IOException if an I/O exception occurred reading the directories  */ ;/**  * Extracts all installed plugin directories from the provided {@code rootPath}.  *  * @param rootPath the path where the plugins are installed  * @return a list of all plugin paths installed in the {@code rootPath}  * @throws IOException if an I/O exception occurred reading the directories  */ public static List<Path> findPluginDirs(final Path rootPath) throws IOException {     final List<Path> plugins = new ArrayList<>().     final Set<String> seen = new HashSet<>().     if (Files.exists(rootPath)) {         try (DirectoryStream<Path> stream = Files.newDirectoryStream(rootPath)) {             for (Path plugin : stream) {                 if (FileSystemUtils.isDesktopServicesStore(plugin) || plugin.getFileName().toString().startsWith(".removing-")) {                     continue.                 }                 if (seen.add(plugin.getFileName().toString()) == false) {                     throw new IllegalStateException("duplicate plugin: " + plugin).                 }                 plugins.add(plugin).             }         }     }     return plugins. }
true;static;1;7;/**  * Verify the given plugin is compatible with the current Elasticsearch installation.  */ ;/**  * Verify the given plugin is compatible with the current Elasticsearch installation.  */ static void verifyCompatibility(PluginInfo info) {     if (info.getElasticsearchVersion().equals(Version.CURRENT) == false) {         throw new IllegalArgumentException("Plugin [" + info.getName() + "] was built for Elasticsearch version " + info.getElasticsearchVersion() + " but version " + Version.CURRENT + " is running").     }     JarHell.checkJavaVersion(info.getName(), info.getJavaVersion()). }
false;static;1;20;;static void checkForFailedPluginRemovals(final Path pluginsDirectory) throws IOException {     /*          * Check for the existence of a marker file that indicates any plugins are in a garbage state from a failed attempt to remove the          * plugin.          */     try (DirectoryStream<Path> stream = Files.newDirectoryStream(pluginsDirectory, ".removing-*")) {         final Iterator<Path> iterator = stream.iterator().         if (iterator.hasNext()) {             final Path removing = iterator.next().             final String fileName = removing.getFileName().toString().             final String name = fileName.substring(1 + fileName.indexOf("-")).             final String message = String.format(Locale.ROOT, "found file [%s] from a failed attempt to remove the plugin [%s]. execute [elasticsearch-plugin remove %2$s]", removing, name).             throw new IllegalStateException(message).         }     } }
true;static;1;3;/**  * Get bundles for plugins installed in the given modules directory.  */ ;/**  * Get bundles for plugins installed in the given modules directory.  */ static Set<Bundle> getModuleBundles(Path modulesDirectory) throws IOException {     return findBundles(modulesDirectory, "module"). }
true;static;1;3;/**  * Get bundles for plugins installed in the given plugins directory.  */ ;/**  * Get bundles for plugins installed in the given plugins directory.  */ static Set<Bundle> getPluginBundles(final Path pluginsDirectory) throws IOException {     return findBundles(pluginsDirectory, "plugin"). }
true;private,static;2;9;// searches subdirectories under the given directory for plugin directories ;// searches subdirectories under the given directory for plugin directories private static Set<Bundle> findBundles(final Path directory, String type) throws IOException {     final Set<Bundle> bundles = new HashSet<>().     for (final Path plugin : findPluginDirs(directory)) {         final Bundle bundle = readPluginBundle(bundles, plugin, type).         bundles.add(bundle).     }     return bundles. }
true;private,static;3;15;// get a bundle for a single plugin dir ;// get a bundle for a single plugin dir private static Bundle readPluginBundle(final Set<Bundle> bundles, final Path plugin, String type) throws IOException {     LogManager.getLogger(PluginsService.class).trace("--- adding [{}] [{}]", type, plugin.toAbsolutePath()).     final PluginInfo info.     try {         info = PluginInfo.readFromProperties(plugin).     } catch (final IOException e) {         throw new IllegalStateException("Could not load plugin descriptor for " + type + " directory [" + plugin.getFileName() + "]", e).     }     final Bundle bundle = new Bundle(info, plugin).     if (bundles.add(bundle) == false) {         throw new IllegalStateException("duplicate " + type + ": " + info).     }     return bundle. }
true;static;1;9;// pkg private for tests ;/**  * Return the given bundles, sorted in dependency loading order.  *  * This sort is stable, so that if two plugins do not have any interdependency,  * their relative order from iteration of the provided set will not change.  *  * @throws IllegalStateException if a dependency cycle is found  */ // pkg private for tests static List<Bundle> sortBundles(Set<Bundle> bundles) {     Map<String, Bundle> namedBundles = bundles.stream().collect(Collectors.toMap(b -> b.plugin.getName(), Function.identity())).     LinkedHashSet<Bundle> sortedBundles = new LinkedHashSet<>().     LinkedHashSet<String> dependencyStack = new LinkedHashSet<>().     for (Bundle bundle : bundles) {         addSortedBundle(bundle, namedBundles, sortedBundles, dependencyStack).     }     return new ArrayList<>(sortedBundles). }
true;private,static;4;31;// add the given bundle to the sorted bundles, first adding dependencies ;// add the given bundle to the sorted bundles, first adding dependencies private static void addSortedBundle(Bundle bundle, Map<String, Bundle> bundles, LinkedHashSet<Bundle> sortedBundles, LinkedHashSet<String> dependencyStack) {     String name = bundle.plugin.getName().     if (dependencyStack.contains(name)) {         StringBuilder msg = new StringBuilder("Cycle found in plugin dependencies: ").         dependencyStack.forEach(s -> {             msg.append(s).             msg.append(" -> ").         }).         msg.append(name).         throw new IllegalStateException(msg.toString()).     }     if (sortedBundles.contains(bundle)) {         // already added this plugin, via a dependency         return.     }     dependencyStack.add(name).     for (String dependency : bundle.plugin.getExtendedPlugins()) {         Bundle depBundle = bundles.get(dependency).         if (depBundle == null) {             throw new IllegalArgumentException("Missing plugin [" + dependency + "], dependency of [" + name + "]").         }         addSortedBundle(depBundle, bundles, sortedBundles, dependencyStack).         assert sortedBundles.contains(depBundle).     }     dependencyStack.remove(name).     sortedBundles.add(bundle). }
false;private;1;15;;private List<Tuple<PluginInfo, Plugin>> loadBundles(Set<Bundle> bundles) {     List<Tuple<PluginInfo, Plugin>> plugins = new ArrayList<>().     Map<String, Plugin> loaded = new HashMap<>().     Map<String, Set<URL>> transitiveUrls = new HashMap<>().     List<Bundle> sortedBundles = sortBundles(bundles).     for (Bundle bundle : sortedBundles) {         checkBundleJarHell(JarHell.parseClassPath(), bundle, transitiveUrls).         final Plugin plugin = loadBundle(bundle, loaded).         plugins.add(new Tuple<>(bundle.plugin, plugin)).     }     return Collections.unmodifiableList(plugins). }
true;static;3;47;// the plugin cli does it, but we do it again, in case lusers mess with jar files manually ;// jar-hell check the bundle against the parent classloader and extended plugins // the plugin cli does it, but we do it again, in case lusers mess with jar files manually static void checkBundleJarHell(Set<URL> classpath, Bundle bundle, Map<String, Set<URL>> transitiveUrls) {     // invariant: any plugins this plugin bundle extends have already been added to transitiveUrls     List<String> exts = bundle.plugin.getExtendedPlugins().     try {         final Logger logger = LogManager.getLogger(JarHell.class).         Set<URL> urls = new HashSet<>().         for (String extendedPlugin : exts) {             Set<URL> pluginUrls = transitiveUrls.get(extendedPlugin).             assert pluginUrls != null : "transitive urls should have already been set for " + extendedPlugin.             Set<URL> intersection = new HashSet<>(urls).             intersection.retainAll(pluginUrls).             if (intersection.isEmpty() == false) {                 throw new IllegalStateException("jar hell! extended plugins " + exts + " have duplicate codebases with each other: " + intersection).             }             intersection = new HashSet<>(bundle.urls).             intersection.retainAll(pluginUrls).             if (intersection.isEmpty() == false) {                 throw new IllegalStateException("jar hell! duplicate codebases with extended plugin [" + extendedPlugin + "]: " + intersection).             }             urls.addAll(pluginUrls).             // check jarhell as we add each extended plugin's urls             JarHell.checkJarHell(urls, logger::debug).         }         urls.addAll(bundle.urls).         // check jarhell of each extended plugin against this plugin         JarHell.checkJarHell(urls, logger::debug).         transitiveUrls.put(bundle.plugin.getName(), urls).         // check we don't have conflicting codebases with core         Set<URL> intersection = new HashSet<>(classpath).         intersection.retainAll(bundle.urls).         if (intersection.isEmpty() == false) {             throw new IllegalStateException("jar hell! duplicate codebases between plugin and core: " + intersection).         }         // check we don't have conflicting classes         Set<URL> union = new HashSet<>(classpath).         union.addAll(bundle.urls).         JarHell.checkJarHell(union, logger::debug).     } catch (Exception e) {         throw new IllegalStateException("failed to load plugin " + bundle.plugin.getName() + " due to jar hell", e).     } }
false;private;2;32;;private Plugin loadBundle(Bundle bundle, Map<String, Plugin> loaded) {     String name = bundle.plugin.getName().     verifyCompatibility(bundle.plugin).     // collect loaders of extended plugins     List<ClassLoader> extendedLoaders = new ArrayList<>().     for (String extendedPluginName : bundle.plugin.getExtendedPlugins()) {         Plugin extendedPlugin = loaded.get(extendedPluginName).         assert extendedPlugin != null.         if (ExtensiblePlugin.class.isInstance(extendedPlugin) == false) {             throw new IllegalStateException("Plugin [" + name + "] cannot extend non-extensible plugin [" + extendedPluginName + "]").         }         extendedLoaders.add(extendedPlugin.getClass().getClassLoader()).     }     // create a child to load the plugin in this bundle     ClassLoader parentLoader = PluginLoaderIndirection.createLoader(getClass().getClassLoader(), extendedLoaders).     ClassLoader loader = URLClassLoader.newInstance(bundle.urls.toArray(new URL[0]), parentLoader).     // reload SPI with any new services from the plugin     reloadLuceneSPI(loader).     for (String extendedPluginName : bundle.plugin.getExtendedPlugins()) {         // note: already asserted above that extended plugins are loaded and extensible         ExtensiblePlugin.class.cast(loaded.get(extendedPluginName)).reloadSPI(loader).     }     Class<? extends Plugin> pluginClass = loadPluginClass(bundle.plugin.getClassname(), loader).     Plugin plugin = loadPlugin(pluginClass, settings, configPath).     loaded.put(name, plugin).     return plugin. }
true;static;1;12;/**  * Reloads all Lucene SPI implementations using the new classloader.  * This method must be called after the new classloader has been created to  * register the services for use.  */ ;/**  * Reloads all Lucene SPI implementations using the new classloader.  * This method must be called after the new classloader has been created to  * register the services for use.  */ static void reloadLuceneSPI(ClassLoader loader) {     // do NOT change the order of these method calls!     // Codecs:     PostingsFormat.reloadPostingsFormats(loader).     DocValuesFormat.reloadDocValuesFormats(loader).     Codec.reloadCodecs(loader).     // Analysis:     CharFilterFactory.reloadCharFilters(loader).     TokenFilterFactory.reloadTokenFilters(loader).     TokenizerFactory.reloadTokenizers(loader). }
false;private;2;7;;private Class<? extends Plugin> loadPluginClass(String className, ClassLoader loader) {     try {         return loader.loadClass(className).asSubclass(Plugin.class).     } catch (ClassNotFoundException e) {         throw new ElasticsearchException("Could not find plugin class [" + className + "]", e).     } }
false;private;3;30;;private Plugin loadPlugin(Class<? extends Plugin> pluginClass, Settings settings, Path configPath) {     final Constructor<?>[] constructors = pluginClass.getConstructors().     if (constructors.length == 0) {         throw new IllegalStateException("no public constructor for [" + pluginClass.getName() + "]").     }     if (constructors.length > 1) {         throw new IllegalStateException("no unique public constructor for [" + pluginClass.getName() + "]").     }     final Constructor<?> constructor = constructors[0].     if (constructor.getParameterCount() > 2) {         throw new IllegalStateException(signatureMessage(pluginClass)).     }     final Class[] parameterTypes = constructor.getParameterTypes().     try {         if (constructor.getParameterCount() == 2 && parameterTypes[0] == Settings.class && parameterTypes[1] == Path.class) {             return (Plugin) constructor.newInstance(settings, configPath).         } else if (constructor.getParameterCount() == 1 && parameterTypes[0] == Settings.class) {             return (Plugin) constructor.newInstance(settings).         } else if (constructor.getParameterCount() == 0) {             return (Plugin) constructor.newInstance().         } else {             throw new IllegalStateException(signatureMessage(pluginClass)).         }     } catch (final ReflectiveOperationException e) {         throw new IllegalStateException("failed to load plugin class [" + pluginClass.getName() + "]", e).     } }
false;private;1;9;;private String signatureMessage(final Class<? extends Plugin> clazz) {     return String.format(Locale.ROOT, "no public constructor of correct signature for [%s]. must be [%s], [%s], or [%s]", clazz.getName(), "(org.elasticsearch.common.settings.Settings,java.nio.file.Path)", "(org.elasticsearch.common.settings.Settings)", "()"). }
false;public;1;4;;public <T> List<T> filterPlugins(Class<T> type) {     return plugins.stream().filter(x -> type.isAssignableFrom(x.v2().getClass())).map(p -> ((T) p.v2())).collect(Collectors.toList()). }
