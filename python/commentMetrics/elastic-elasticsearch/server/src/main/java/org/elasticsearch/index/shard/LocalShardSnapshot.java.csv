commented;modifiers;parameterAmount;loc;comment;code
false;;0;3;;Index getIndex() {     return shard.indexSettings().getIndex(). }
false;;0;3;;long maxSeqNo() {     return shard.getEngine().getSeqNoStats(-1).getMaxSeqNo(). }
false;;0;3;;long maxUnsafeAutoIdTimestamp() {     return Long.parseLong(shard.getEngine().commitStats().getUserData().get(Engine.MAX_UNSAFE_AUTO_ID_TIMESTAMP_COMMIT_ID)). }
false;public;0;6;;@Override public String[] listAll() throws IOException {     Collection<String> fileNames = indexCommit.getIndexCommit().getFileNames().     final String[] fileNameArray = fileNames.toArray(new String[fileNames.size()]).     return fileNameArray. }
false;public;1;4;;@Override public void deleteFile(String name) throws IOException {     throw new UnsupportedOperationException("this directory is read-only"). }
false;public;1;4;;@Override public void sync(Collection<String> names) throws IOException {     throw new UnsupportedOperationException("this directory is read-only"). }
false;public;2;4;;@Override public void rename(String source, String dest) throws IOException {     throw new UnsupportedOperationException("this directory is read-only"). }
false;public;2;4;;@Override public IndexOutput createOutput(String name, IOContext context) throws IOException {     throw new UnsupportedOperationException("this directory is read-only"). }
false;public;3;4;;@Override public IndexOutput createTempOutput(String prefix, String suffix, IOContext context) throws IOException {     throw new UnsupportedOperationException("this directory is read-only"). }
false;public;1;7;;@Override public Lock obtainLock(String name) throws IOException {     /* we do explicitly a no-lock instance since we hold an index commit from a SnapshotDeletionPolicy so we                      * can we certain that nobody messes with the files on disk. We also hold a ref on the store which means                      * no external source will delete files either.*/     return NoLockFactory.INSTANCE.obtainLock(in, name). }
false;public;0;4;;@Override public void close() throws IOException {     throw new UnsupportedOperationException("nobody should close this directory wrapper"). }
false;;0;50;;Directory getSnapshotDirectory() {     /* this directory will not be used for anything else but reading / copying files to another directory          * we prevent all write operations on this directory with UOE - nobody should close it either. */     return new FilterDirectory(store.directory()) {          @Override         public String[] listAll() throws IOException {             Collection<String> fileNames = indexCommit.getIndexCommit().getFileNames().             final String[] fileNameArray = fileNames.toArray(new String[fileNames.size()]).             return fileNameArray.         }          @Override         public void deleteFile(String name) throws IOException {             throw new UnsupportedOperationException("this directory is read-only").         }          @Override         public void sync(Collection<String> names) throws IOException {             throw new UnsupportedOperationException("this directory is read-only").         }          @Override         public void rename(String source, String dest) throws IOException {             throw new UnsupportedOperationException("this directory is read-only").         }          @Override         public IndexOutput createOutput(String name, IOContext context) throws IOException {             throw new UnsupportedOperationException("this directory is read-only").         }          @Override         public IndexOutput createTempOutput(String prefix, String suffix, IOContext context) throws IOException {             throw new UnsupportedOperationException("this directory is read-only").         }          @Override         public Lock obtainLock(String name) throws IOException {             /* we do explicitly a no-lock instance since we hold an index commit from a SnapshotDeletionPolicy so we                      * can we certain that nobody messes with the files on disk. We also hold a ref on the store which means                      * no external source will delete files either.*/             return NoLockFactory.INSTANCE.obtainLock(in, name).         }          @Override         public void close() throws IOException {             throw new UnsupportedOperationException("nobody should close this directory wrapper").         }     }. }
false;public;0;10;;@Override public void close() throws IOException {     if (closed.compareAndSet(false, true)) {         try {             indexCommit.close().         } finally {             store.decRef().         }     } }
false;;0;3;;IndexMetaData getIndexMetaData() {     return shard.indexSettings.getIndexMetaData(). }
false;public;0;4;;@Override public String toString() {     return "local_shard_snapshot:[" + shard.shardId() + " indexCommit: " + indexCommit + "]". }
