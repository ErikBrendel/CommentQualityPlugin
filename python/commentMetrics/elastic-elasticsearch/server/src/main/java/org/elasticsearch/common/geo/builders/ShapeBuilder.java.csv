commented;modifiers;parameterAmount;loc;comment;code
false;protected,static;1;9;;protected static Coordinate readFromStream(StreamInput in) throws IOException {     double x = in.readDouble().     double y = in.readDouble().     Double z = null.     if (in.getVersion().onOrAfter(Version.V_6_3_0)) {         z = in.readOptionalDouble().     }     return z == null ? new Coordinate(x, y) : new Coordinate(x, y, z). }
false;public;1;7;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeVInt(coordinates.size()).     for (Coordinate point : coordinates) {         writeCoordinateTo(point, out).     } }
false;protected,static;2;7;;protected static void writeCoordinateTo(Coordinate coordinate, StreamOutput out) throws IOException {     out.writeDouble(coordinate.x).     out.writeDouble(coordinate.y).     if (out.getVersion().onOrAfter(Version.V_6_3_0)) {         out.writeOptionalDouble(Double.isNaN(coordinate.z) ? null : coordinate.z).     } }
false;private;0;4;;@SuppressWarnings("unchecked") private E thisRef() {     return (E) this. }
true;public;2;3;/**  * Add a new coordinate to the collection  * @param longitude longitude of the coordinate  * @param latitude latitude of the coordinate  * @return this  */ ;/**  * Add a new coordinate to the collection  * @param longitude longitude of the coordinate  * @param latitude latitude of the coordinate  * @return this  */ public E coordinate(double longitude, double latitude) {     return this.coordinate(new Coordinate(longitude, latitude)). }
true;public;1;4;/**  * Add a new coordinate to the collection  * @param coordinate coordinate of the point  * @return this  */ ;/**  * Add a new coordinate to the collection  * @param coordinate coordinate of the point  * @return this  */ public E coordinate(Coordinate coordinate) {     this.coordinates.add(coordinate).     return thisRef(). }
true;public;1;3;/**  * Add a array of coordinates to the collection  *  * @param coordinates array of {@link Coordinate}s to add  * @return this  */ ;/**  * Add a array of coordinates to the collection  *  * @param coordinates array of {@link Coordinate}s to add  * @return this  */ public E coordinates(Coordinate... coordinates) {     return this.coordinates(Arrays.asList(coordinates)). }
true;public;1;4;/**  * Add a collection of coordinates to the collection  *  * @param coordinates array of {@link Coordinate}s to add  * @return this  */ ;/**  * Add a collection of coordinates to the collection  *  * @param coordinates array of {@link Coordinate}s to add  * @return this  */ public E coordinates(Collection<? extends Coordinate> coordinates) {     this.coordinates.addAll(coordinates).     return thisRef(). }
true;protected;1;7;/**  * Copy all coordinate to a new Array  *  * @param closed if set to true the first point of the array is repeated as last element  * @return Array of coordinates  */ ;/**  * Copy all coordinate to a new Array  *  * @param closed if set to true the first point of the array is repeated as last element  * @return Array of coordinates  */ protected Coordinate[] coordinates(boolean closed) {     Coordinate[] result = coordinates.toArray(new Coordinate[coordinates.size() + (closed ? 1 : 0)]).     if (closed) {         result[result.length - 1] = result[0].     }     return result. }
false;protected;1;9;;protected JtsGeometry jtsGeometry(Geometry geom) {     // dateline180Check is false because ElasticSearch does it's own dateline wrapping     JtsGeometry jtsGeometry = new JtsGeometry(geom, SPATIAL_CONTEXT, false, MULTI_POLYGON_MAY_OVERLAP).     if (AUTO_VALIDATE_JTS_GEOMETRY)         jtsGeometry.validate().     if (AUTO_INDEX_JTS_GEOMETRY)         jtsGeometry.index().     return jtsGeometry. }
true;public,abstract;0;1;/**  * Create a new Shape from this builder. Since calling this method could change the  * defined shape. (by inserting new coordinates or change the position of points)  * the builder looses its validity. So this method should only be called once on a builder  * @return new {@link Shape} defined by the builder  */ ;/**  * Create a new Shape from this builder. Since calling this method could change the  * defined shape. (by inserting new coordinates or change the position of points)  * the builder looses its validity. So this method should only be called once on a builder  * @return new {@link Shape} defined by the builder  */ public abstract T buildS4J().
true;public,abstract;0;1;/**  * build lucene geometry.  *  * @return GeoPoint, double[][], Line, Line[], Polygon, Polygon[], Rectangle, Object[]  */ ;/**  * build lucene geometry.  *  * @return GeoPoint, double[][], Line, Line[], Polygon, Polygon[], Rectangle, Object[]  */ public abstract G buildGeometry().
false;protected,static;2;7;;protected static Coordinate shift(Coordinate coordinate, double dateline) {     if (dateline == 0) {         return coordinate.     } else {         return new Coordinate(-2 * dateline + coordinate.x, coordinate.y).     } }
true;public,abstract;0;1;/**  * get the shapes type  * @return type of the shape  */ ;/**  * get the shapes type  * @return type of the shape  */ public abstract GeoShapeType type().
true;public,abstract;0;1;/**  * tracks number of dimensions for this shape  */ ;/**  * tracks number of dimensions for this shape  */ public abstract int numDimensions().
true;protected,static,final;3;14;/**  * Calculate the intersection of a line segment and a vertical dateline.  *  * @param p1  *            start-point of the line segment  * @param p2  *            end-point of the line segment  * @param dateline  *            x-coordinate of the vertical dateline  * @return position of the intersection in the open range (0..1] if the line  *         segment intersects with the line segment. Otherwise this method  *         returns {@link Double#NaN}  */ ;/**  * Calculate the intersection of a line segment and a vertical dateline.  *  * @param p1  *            start-point of the line segment  * @param p2  *            end-point of the line segment  * @param dateline  *            x-coordinate of the vertical dateline  * @return position of the intersection in the open range (0..1] if the line  *         segment intersects with the line segment. Otherwise this method  *         returns {@link Double#NaN}  */ protected static final double intersection(Coordinate p1, Coordinate p2, double dateline) {     if (p1.x == p2.x && p1.x != dateline) {         return Double.NaN.     } else if (p1.x == p2.x && p1.x == dateline) {         return 1.0.     } else {         final double t = (dateline - p1.x) / (p2.x - p1.x).         if (t > 1 || t <= 0) {             return Double.NaN.         } else {             return t.         }     } }
true;protected,static;2;18;/**  * Calculate all intersections of line segments and a vertical line. The  * Array of edges will be ordered asc by the y-coordinate of the  * intersections of edges.  *  * @param dateline  *            x-coordinate of the dateline  * @param edges  *            set of edges that may intersect with the dateline  * @return number of intersecting edges  */ ;/**  * Calculate all intersections of line segments and a vertical line. The  * Array of edges will be ordered asc by the y-coordinate of the  * intersections of edges.  *  * @param dateline  *            x-coordinate of the dateline  * @param edges  *            set of edges that may intersect with the dateline  * @return number of intersecting edges  */ protected static int intersections(double dateline, Edge[] edges) {     int numIntersections = 0.     assert !Double.isNaN(dateline).     for (int i = 0. i < edges.length. i++) {         Coordinate p1 = edges[i].coordinate.         Coordinate p2 = edges[i].next.coordinate.         assert !Double.isNaN(p2.x) && !Double.isNaN(p1.x).         edges[i].intersect = Edge.MAX_COORDINATE.         double position = intersection(p1, p2, dateline).         if (!Double.isNaN(position)) {             edges[i].intersection(position).             numIntersections++.         }     }     Arrays.sort(edges, INTERSECTION_ORDER).     return numIntersections. }
false;protected;1;10;;protected void setNext(Edge next) {     // don't bother setting next if its null     if (next != null) {         // self-loop throws an invalid shape         if (this.coordinate.equals(next.coordinate)) {             throw new InvalidShapeException("Provided shape has duplicate consecutive coordinates at: " + this.coordinate).         }         this.next = next.     } }
true;protected;1;3;/**  * Set the intersection of this line segment to the given position  *  * @param position  *            position of the intersection [0..1]  * @return the {@link Coordinate} of the intersection  */ ;/**  * Set the intersection of this line segment to the given position  *  * @param position  *            position of the intersection [0..1]  * @return the {@link Coordinate} of the intersection  */ protected Coordinate intersection(double position) {     return intersect = position(coordinate, next.coordinate, position). }
false;protected,static;3;11;;protected static Coordinate position(Coordinate p1, Coordinate p2, double position) {     if (position == 0) {         return p1.     } else if (position == 1) {         return p2.     } else {         final double x = p1.x + position * (p2.x - p1.x).         final double y = p1.y + position * (p2.y - p1.y).         return new Coordinate(x, y).     } }
false;public;0;4;;@Override public String toString() {     return "Edge[Component=" + component + ". start=" + coordinate + " " + ". intersection=" + intersect + "]". }
false;protected;0;3;;protected StringBuilder contentToWKT() {     return coordinateListToWKT(this.coordinates). }
false;public;0;7;;public String toWKT() {     StringBuilder sb = new StringBuilder().     sb.append(type().wktName()).     sb.append(GeoWKTParser.SPACE).     sb.append(contentToWKT()).     return sb.toString(). }
false;protected,static;1;19;;protected static StringBuilder coordinateListToWKT(final List<Coordinate> coordinates) {     final StringBuilder sb = new StringBuilder().     if (coordinates.isEmpty()) {         sb.append(GeoWKTParser.EMPTY).     } else {         // walk through coordinates:         sb.append(GeoWKTParser.LPAREN).         sb.append(coordinateToWKT(coordinates.get(0))).         for (int i = 1. i < coordinates.size(). ++i) {             sb.append(GeoWKTParser.COMMA).             sb.append(GeoWKTParser.SPACE).             sb.append(coordinateToWKT(coordinates.get(i))).         }         sb.append(GeoWKTParser.RPAREN).     }     return sb. }
false;private,static;1;8;;private static String coordinateToWKT(final Coordinate coordinate) {     final StringBuilder sb = new StringBuilder().     sb.append(coordinate.x + GeoWKTParser.SPACE + coordinate.y).     if (Double.isNaN(coordinate.z) == false) {         sb.append(GeoWKTParser.SPACE + coordinate.z).     }     return sb.toString(). }
false;public;2;4;;@Override public int compare(Edge o1, Edge o2) {     return Double.compare(o1.intersect.y, o2.intersect.y). }
false;public;1;3;;public void writeTo(StreamOutput out) throws IOException {     out.writeBoolean(this == Orientation.RIGHT). }
false;public,static;1;3;;public static Orientation readFrom(StreamInput in) throws IOException {     return in.readBoolean() ? Orientation.RIGHT : Orientation.LEFT. }
false;public,static;1;15;;public static Orientation fromString(String orientation) {     orientation = orientation.toLowerCase(Locale.ROOT).     switch(orientation) {         case "right":         case "counterclockwise":         case "ccw":             return Orientation.RIGHT.         case "left":         case "clockwise":         case "cw":             return Orientation.LEFT.         default:             throw new IllegalArgumentException("Unknown orientation [" + orientation + "]").     } }
false;protected,static,final;0;3;;protected static final boolean debugEnabled() {     return LOGGER.isDebugEnabled() || DEBUG. }
false;protected,static;2;7;;protected static XContentBuilder toXContent(XContentBuilder builder, Coordinate coordinate) throws IOException {     builder.startArray().value(coordinate.x).value(coordinate.y).     if (Double.isNaN(coordinate.z) == false) {         builder.value(coordinate.z).     }     return builder.endArray(). }
true;protected;2;15;/**  * builds an array of coordinates to a {@link XContentBuilder}  *  * @param builder builder to use  * @param closed repeat the first point at the end of the array if it's not already defines as last element of the array  * @return the builder  */ ;/**  * builds an array of coordinates to a {@link XContentBuilder}  *  * @param builder builder to use  * @param closed repeat the first point at the end of the array if it's not already defines as last element of the array  * @return the builder  */ protected XContentBuilder coordinatesToXcontent(XContentBuilder builder, boolean closed) throws IOException {     builder.startArray().     for (Coordinate coord : coordinates) {         toXContent(builder, coord).     }     if (closed) {         Coordinate start = coordinates.get(0).         Coordinate end = coordinates.get(coordinates.size() - 1).         if (start.x != end.x || start.y != end.y) {             toXContent(builder, coordinates.get(0)).         }     }     builder.endArray().     return builder. }
false;public;1;9;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (!(o instanceof ShapeBuilder))         return false.     ShapeBuilder<?, ?, ?> that = (ShapeBuilder<?, ?, ?>) o.     return Objects.equals(coordinates, that.coordinates). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(coordinates). }
false;public;0;4;;@Override public String getWriteableName() {     return type().shapeName(). }
false;public;0;4;;@Override public String toString() {     return Strings.toString(this, true, true). }
