commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;6;;@Override protected void doWriteTo(StreamOutput out) throws IOException {     writeQueries(out, clauses).     out.writeVInt(slop).     out.writeBoolean(inOrder). }
true;public;0;3;/**  * @return the maximum number of intervening unmatched positions permitted  */ ;/**  * @return the maximum number of intervening unmatched positions permitted  */ public int slop() {     return this.slop. }
true;public;1;7;/**  * Add a span clause to the current list of clauses  */ ;/**  * Add a span clause to the current list of clauses  */ public SpanNearQueryBuilder addClause(SpanQueryBuilder clause) {     if (clause == null) {         throw new IllegalArgumentException("[" + NAME + "]  clauses cannot be null").     }     clauses.add(clause).     return this. }
true;public;0;3;/**  * @return the {@link SpanQueryBuilder} clauses that were set for this query  */ ;/**  * @return the {@link SpanQueryBuilder} clauses that were set for this query  */ public List<SpanQueryBuilder> clauses() {     return Collections.unmodifiableList(this.clauses). }
true;public;1;4;/**  * When <code>inOrder</code> is true, the spans from each clause  * must be in the same order as in <code>clauses</code> and must be non-overlapping.  * Defaults to <code>true</code>  */ ;/**  * When <code>inOrder</code> is true, the spans from each clause  * must be in the same order as in <code>clauses</code> and must be non-overlapping.  * Defaults to <code>true</code>  */ public SpanNearQueryBuilder inOrder(boolean inOrder) {     this.inOrder = inOrder.     return this. }
true;public;0;3;/**  * @see SpanNearQueryBuilder#inOrder(boolean)  */ ;/**  * @see SpanNearQueryBuilder#inOrder(boolean)  */ public boolean inOrder() {     return this.inOrder. }
false;protected;2;13;;@Override protected void doXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject(NAME).     builder.startArray(CLAUSES_FIELD.getPreferredName()).     for (SpanQueryBuilder clause : clauses) {         clause.toXContent(builder, params).     }     builder.endArray().     builder.field(SLOP_FIELD.getPreferredName(), slop).     builder.field(IN_ORDER_FIELD.getPreferredName(), inOrder).     printBoostAndQueryName(builder).     builder.endObject(). }
false;public,static;1;57;;public static SpanNearQueryBuilder fromXContent(XContentParser parser) throws IOException {     float boost = AbstractQueryBuilder.DEFAULT_BOOST.     int slop = DEFAULT_SLOP.     boolean inOrder = DEFAULT_IN_ORDER.     String queryName = null.     List<SpanQueryBuilder> clauses = new ArrayList<>().     String currentFieldName = null.     XContentParser.Token token.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (token == XContentParser.Token.START_ARRAY) {             if (CLAUSES_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {                     QueryBuilder query = parseInnerQueryBuilder(parser).                     if (query instanceof SpanQueryBuilder == false) {                         throw new ParsingException(parser.getTokenLocation(), "span_near [clauses] must be of type span query").                     }                     final SpanQueryBuilder clause = (SpanQueryBuilder) query.                     checkNoBoost(NAME, currentFieldName, parser, clause).                     clauses.add(clause).                 }             } else {                 throw new ParsingException(parser.getTokenLocation(), "[span_near] query does not support [" + currentFieldName + "]").             }         } else if (token.isValue()) {             if (IN_ORDER_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 inOrder = parser.booleanValue().             } else if (SLOP_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 slop = parser.intValue().             } else if (AbstractQueryBuilder.BOOST_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 boost = parser.floatValue().             } else if (AbstractQueryBuilder.NAME_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 queryName = parser.text().             } else {                 throw new ParsingException(parser.getTokenLocation(), "[span_near] query does not support [" + currentFieldName + "]").             }         } else {             throw new ParsingException(parser.getTokenLocation(), "[span_near] query does not support [" + currentFieldName + "]").         }     }     if (clauses.isEmpty()) {         throw new ParsingException(parser.getTokenLocation(), "span_near must include [clauses]").     }     SpanNearQueryBuilder queryBuilder = new SpanNearQueryBuilder(clauses.get(0), slop).     for (int i = 1. i < clauses.size(). i++) {         queryBuilder.addClause(clauses.get(i)).     }     queryBuilder.inOrder(inOrder).     queryBuilder.boost(boost).     queryBuilder.queryName(queryName).     return queryBuilder. }
false;protected;1;54;;@Override protected Query doToQuery(QueryShardContext context) throws IOException {     SpanQueryBuilder queryBuilder = clauses.get(0).     boolean isGap = queryBuilder instanceof SpanGapQueryBuilder.     Query query = null.     if (!isGap) {         query = queryBuilder.toQuery(context).         assert query instanceof SpanQuery.     }     if (clauses.size() == 1) {         assert !isGap.         return query.     }     String spanNearFieldName = null.     if (isGap) {         String fieldName = ((SpanGapQueryBuilder) queryBuilder).fieldName().         spanNearFieldName = queryFieldName(context, fieldName).     } else {         spanNearFieldName = ((SpanQuery) query).getField().     }     SpanNearQuery.Builder builder = new SpanNearQuery.Builder(spanNearFieldName, inOrder).     builder.setSlop(slop).     /*          * Lucene SpanNearQuery throws exceptions for certain use cases like adding gap to a          * unordered SpanNearQuery. Should ES have the same checks or wrap those thrown exceptions?          */     if (isGap) {         int gap = ((SpanGapQueryBuilder) queryBuilder).width().         builder.addGap(gap).     } else {         builder.addClause((SpanQuery) query).     }     for (int i = 1. i < clauses.size(). i++) {         queryBuilder = clauses.get(i).         isGap = queryBuilder instanceof SpanGapQueryBuilder.         if (isGap) {             String fieldName = ((SpanGapQueryBuilder) queryBuilder).fieldName().             String spanGapFieldName = queryFieldName(context, fieldName).             if (!spanNearFieldName.equals(spanGapFieldName)) {                 throw new IllegalArgumentException("[span_near] clauses must have same field").             }             int gap = ((SpanGapQueryBuilder) queryBuilder).width().             builder.addGap(gap).         } else {             query = clauses.get(i).toQuery(context).             assert query instanceof SpanQuery.             builder.addClause((SpanQuery) query).         }     }     return builder.build(). }
false;private;2;4;;private String queryFieldName(QueryShardContext context, String fieldName) {     MappedFieldType fieldType = context.fieldMapper(fieldName).     return fieldType != null ? fieldType.name() : fieldName. }
false;protected;0;4;;@Override protected int doHashCode() {     return Objects.hash(clauses, slop, inOrder). }
false;protected;1;6;;@Override protected boolean doEquals(SpanNearQueryBuilder other) {     return Objects.equals(clauses, other.clauses) && Objects.equals(slop, other.slop) && Objects.equals(inOrder, other.inOrder). }
false;public;0;4;;@Override public String getWriteableName() {     return NAME. }
true;public;0;3;/**  * @return fieldName  The name of the field  */ ;/**  * @return fieldName  The name of the field  */ public String fieldName() {     return fieldName. }
true;public;0;3;/**  * @return width The width of the gap introduced  */ ;/**  * @return width The width of the gap introduced  */ public int width() {     return width. }
false;public;1;4;;@Override public Query toQuery(QueryShardContext context) throws IOException {     throw new UnsupportedOperationException(). }
false;public;0;4;;@Override public String queryName() {     throw new UnsupportedOperationException(). }
false;public;1;4;;@Override public QueryBuilder queryName(String queryName) {     throw new UnsupportedOperationException(). }
false;public;0;4;;@Override public float boost() {     throw new UnsupportedOperationException(). }
false;public;1;4;;@Override public QueryBuilder boost(float boost) {     throw new UnsupportedOperationException(). }
false;public;0;4;;@Override public String getName() {     return NAME. }
false;public;0;4;;@Override public String getWriteableName() {     return NAME. }
false;public,final;1;5;;@Override public final void writeTo(StreamOutput out) throws IOException {     out.writeString(fieldName).     out.writeInt(width). }
false;public;2;9;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     builder.startObject(getName()).     builder.field(fieldName, width).     builder.endObject().     builder.endObject().     return builder. }
false;public,static;1;17;;public static SpanGapQueryBuilder fromXContent(XContentParser parser) throws IOException {     String fieldName = null.     int width = 0.     String currentFieldName = null.     XContentParser.Token token.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().             throwParsingExceptionOnMultipleFields(NAME, parser.getTokenLocation(), fieldName, currentFieldName).             fieldName = currentFieldName.         } else if (token.isValue()) {             width = parser.intValue().         }     }     SpanGapQueryBuilder result = new SpanGapQueryBuilder(fieldName, width).     return result. }
false;public,final;1;12;;@Override public final boolean equals(Object obj) {     if (this == obj) {         return true.     }     if (obj == null || getClass() != obj.getClass()) {         return false.     }     SpanGapQueryBuilder other = (SpanGapQueryBuilder) obj.     return Objects.equals(fieldName, other.fieldName) && Objects.equals(width, other.width). }
false;public,final;0;4;;@Override public final int hashCode() {     return Objects.hash(getClass(), fieldName, width). }
false;public,final;0;4;;@Override public final String toString() {     return Strings.toString(this, true, true). }
true;protected,static;4;7;// copied from AbstractQueryBuilder ;// copied from AbstractQueryBuilder protected static void throwParsingExceptionOnMultipleFields(String queryName, XContentLocation contentLocation, String processedFieldName, String currentFieldName) {     if (processedFieldName != null) {         throw new ParsingException(contentLocation, "[" + queryName + "] query doesn't support multiple fields, found [" + processedFieldName + "] and [" + currentFieldName + "]").     } }
