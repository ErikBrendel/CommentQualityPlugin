commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public void doWriteTo(StreamOutput out) throws IOException {     out.writeNamedWriteable(formatter). }
false;public;0;4;;@Override public String getWriteableName() {     return CumulativeSumPipelineAggregationBuilder.NAME. }
false;public;2;26;;@Override public InternalAggregation reduce(InternalAggregation aggregation, ReduceContext reduceContext) {     InternalMultiBucketAggregation<? extends InternalMultiBucketAggregation, ? extends InternalMultiBucketAggregation.InternalBucket> histo = (InternalMultiBucketAggregation<? extends InternalMultiBucketAggregation, ? extends InternalMultiBucketAggregation.InternalBucket>) aggregation.     List<? extends InternalMultiBucketAggregation.InternalBucket> buckets = histo.getBuckets().     HistogramFactory factory = (HistogramFactory) histo.     List<Bucket> newBuckets = new ArrayList<>(buckets.size()).     double sum = 0.     for (InternalMultiBucketAggregation.InternalBucket bucket : buckets) {         Double thisBucketValue = resolveBucketValue(histo, bucket, bucketsPaths()[0], GapPolicy.INSERT_ZEROS).         // Only increment the sum if it's a finite value, otherwise "increment by zero" is correct         if (thisBucketValue != null && thisBucketValue.isInfinite() == false && thisBucketValue.isNaN() == false) {             sum += thisBucketValue.         }         List<InternalAggregation> aggs = StreamSupport.stream(bucket.getAggregations().spliterator(), false).map((p) -> (InternalAggregation) p).collect(Collectors.toList()).         aggs.add(new InternalSimpleValue(name(), sum, formatter, new ArrayList<>(), metaData())).         Bucket newBucket = factory.createBucket(factory.getKey(bucket), bucket.getDocCount(), new InternalAggregations(aggs)).         newBuckets.add(newBucket).     }     return factory.createAggregation(newBuckets). }
