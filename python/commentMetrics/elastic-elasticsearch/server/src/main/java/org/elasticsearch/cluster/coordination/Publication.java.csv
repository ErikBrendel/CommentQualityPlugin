commented;modifiers;parameterAmount;loc;comment;code
false;public;1;9;;public void start(Set<DiscoveryNode> faultyNodes) {     logger.trace("publishing {} to {}", publishRequest, publicationTargets).     for (final DiscoveryNode faultyNode : faultyNodes) {         onFaultyNode(faultyNode).     }     onPossibleCommitFailure().     publicationTargets.forEach(PublicationTarget::sendPublishRequest). }
false;public;1;15;;public void cancel(String reason) {     if (isCompleted) {         return.     }     assert cancelled == false.     cancelled = true.     if (applyCommitRequest.isPresent() == false) {         logger.debug("cancel: [{}] cancelled before committing (reason: {})", this, reason).         // fail all current publications         final Exception e = new ElasticsearchException("publication cancelled before committing: " + reason).         publicationTargets.stream().filter(PublicationTarget::isActive).forEach(pt -> pt.setFailed(e)).     }     onPossibleCompletion(). }
false;public;1;4;;public void onFaultyNode(DiscoveryNode faultyNode) {     publicationTargets.forEach(t -> t.onFaultyNode(faultyNode)).     onPossibleCompletion(). }
false;public;0;6;;public List<DiscoveryNode> completedNodes() {     return publicationTargets.stream().filter(PublicationTarget::isSuccessfullyCompleted).map(PublicationTarget::getDiscoveryNode).collect(Collectors.toList()). }
false;public;0;3;;public boolean isCommitted() {     return applyCommitRequest.isPresent(). }
false;private;0;27;;private void onPossibleCompletion() {     if (isCompleted) {         return.     }     if (cancelled == false) {         for (final PublicationTarget target : publicationTargets) {             if (target.isActive()) {                 return.             }         }     }     if (applyCommitRequest.isPresent() == false) {         logger.debug("onPossibleCompletion: [{}] commit failed", this).         assert isCompleted == false.         isCompleted = true.         onCompletion(false).         return.     }     assert isCompleted == false.     isCompleted = true.     onCompletion(true).     assert applyCommitRequest.isPresent().     logger.trace("onPossibleCompletion: [{}] was successful", this). }
true;private;0;10;// For assertions only: verify that this invariant holds ;// For assertions only: verify that this invariant holds private boolean publicationCompletedIffAllTargetsInactiveOrCancelled() {     if (cancelled == false) {         for (final PublicationTarget target : publicationTargets) {             if (target.isActive()) {                 return isCompleted == false.             }         }     }     return isCompleted. }
true;;0;3;// For assertions ;// For assertions ClusterState publishedState() {     return publishRequest.getAcceptedState(). }
false;private;0;23;;private void onPossibleCommitFailure() {     if (applyCommitRequest.isPresent()) {         onPossibleCompletion().         return.     }     final CoordinationState.VoteCollection possiblySuccessfulNodes = new CoordinationState.VoteCollection().     for (PublicationTarget publicationTarget : publicationTargets) {         if (publicationTarget.mayCommitInFuture()) {             possiblySuccessfulNodes.addVote(publicationTarget.discoveryNode).         } else {             assert publicationTarget.isFailed() : publicationTarget.         }     }     if (isPublishQuorum(possiblySuccessfulNodes) == false) {         logger.debug("onPossibleCommitFailure: non-failed nodes {} do not form a quorum, so {} cannot succeed", possiblySuccessfulNodes, this).         Exception e = new FailedToCommitClusterStateException("non-failed nodes do not form a quorum").         publicationTargets.stream().filter(PublicationTarget::isActive).forEach(pt -> pt.setFailed(e)).         onPossibleCompletion().     } }
false;protected,abstract;1;1;;protected abstract void onCompletion(boolean committed).
false;protected,abstract;1;1;;protected abstract boolean isPublishQuorum(CoordinationState.VoteCollection votes).
false;protected,abstract;2;1;;protected abstract Optional<ApplyCommitRequest> handlePublishResponse(DiscoveryNode sourceNode, PublishResponse publishResponse).
false;protected,abstract;1;1;;protected abstract void onJoin(Join join).
false;protected,abstract;1;1;;protected abstract void onMissingJoin(DiscoveryNode discoveryNode).
false;protected,abstract;3;2;;protected abstract void sendPublishRequest(DiscoveryNode destination, PublishRequest publishRequest, ActionListener<PublishWithJoinResponse> responseActionListener).
false;protected,abstract;3;2;;protected abstract void sendApplyCommit(DiscoveryNode destination, ApplyCommitRequest applyCommit, ActionListener<TransportResponse.Empty> responseActionListener).
false;public;0;5;;@Override public String toString() {     return "Publication{term=" + publishRequest.getAcceptedState().term() + ", version=" + publishRequest.getAcceptedState().version() + '}'. }
false;public;0;8;;@Override public String toString() {     return "PublicationTarget{" + "discoveryNode=" + discoveryNode + ", state=" + state + ", ackIsPending=" + ackIsPending + '}'. }
false;;0;10;;void sendPublishRequest() {     if (isFailed()) {         return.     }     assert state == PublicationTargetState.NOT_STARTED : state + " -> " + PublicationTargetState.SENT_PUBLISH_REQUEST.     state = PublicationTargetState.SENT_PUBLISH_REQUEST.     Publication.this.sendPublishRequest(discoveryNode, publishRequest, new PublishResponseHandler()).     // TODO Can this ^ fail with an exception? Target should be failed if so.     assert publicationCompletedIffAllTargetsInactiveOrCancelled(). }
false;;1;14;;void handlePublishResponse(PublishResponse publishResponse) {     assert isWaitingForQuorum() : this.     logger.trace("handlePublishResponse: handling [{}] from [{}])", publishResponse, discoveryNode).     if (applyCommitRequest.isPresent()) {         sendApplyCommit().     } else {         Publication.this.handlePublishResponse(discoveryNode, publishResponse).ifPresent(applyCommit -> {             assert applyCommitRequest.isPresent() == false.             applyCommitRequest = Optional.of(applyCommit).             ackListener.onCommit(TimeValue.timeValueMillis(currentTimeSupplier.getAsLong() - startTime)).             publicationTargets.stream().filter(PublicationTarget::isWaitingForQuorum).forEach(PublicationTarget::sendApplyCommit).         }).     } }
false;;0;7;;void sendApplyCommit() {     assert state == PublicationTargetState.WAITING_FOR_QUORUM : state + " -> " + PublicationTargetState.SENT_APPLY_COMMIT.     state = PublicationTargetState.SENT_APPLY_COMMIT.     assert applyCommitRequest.isPresent().     Publication.this.sendApplyCommit(discoveryNode, applyCommitRequest.get(), new ApplyCommitResponseHandler()).     assert publicationCompletedIffAllTargetsInactiveOrCancelled(). }
false;;0;5;;void setAppliedCommit() {     assert state == PublicationTargetState.SENT_APPLY_COMMIT : state + " -> " + PublicationTargetState.APPLIED_COMMIT.     state = PublicationTargetState.APPLIED_COMMIT.     ackOnce(null). }
false;;1;5;;void setFailed(Exception e) {     assert state != PublicationTargetState.APPLIED_COMMIT : state + " -> " + PublicationTargetState.FAILED.     state = PublicationTargetState.FAILED.     ackOnce(e). }
false;;1;7;;void onFaultyNode(DiscoveryNode faultyNode) {     if (isActive() && discoveryNode.equals(faultyNode)) {         logger.debug("onFaultyNode: [{}] is faulty, failing target in publication {}", faultyNode, Publication.this).         setFailed(new ElasticsearchException("faulty node")).         onPossibleCommitFailure().     } }
false;;0;3;;DiscoveryNode getDiscoveryNode() {     return discoveryNode. }
false;private;1;6;;private void ackOnce(Exception e) {     if (ackIsPending) {         ackIsPending = false.         ackListener.onNodeAck(discoveryNode, e).     } }
false;;0;4;;boolean isActive() {     return state != PublicationTargetState.FAILED && state != PublicationTargetState.APPLIED_COMMIT. }
false;;0;3;;boolean isSuccessfullyCompleted() {     return state == PublicationTargetState.APPLIED_COMMIT. }
false;;0;3;;boolean isWaitingForQuorum() {     return state == PublicationTargetState.WAITING_FOR_QUORUM. }
false;;0;5;;boolean mayCommitInFuture() {     return (state == PublicationTargetState.NOT_STARTED || state == PublicationTargetState.SENT_PUBLISH_REQUEST || state == PublicationTargetState.WAITING_FOR_QUORUM). }
false;;0;3;;boolean isFailed() {     return state == PublicationTargetState.FAILED. }
false;public;1;25;;@Override public void onResponse(PublishWithJoinResponse response) {     if (isFailed()) {         logger.debug("PublishResponseHandler.handleResponse: already failed, ignoring response from [{}]", discoveryNode).         assert publicationCompletedIffAllTargetsInactiveOrCancelled().         return.     }     if (response.getJoin().isPresent()) {         final Join join = response.getJoin().get().         assert discoveryNode.equals(join.getSourceNode()).         assert join.getTerm() == response.getPublishResponse().getTerm() : response.         logger.trace("handling join within publish response: {}", join).         onJoin(join).     } else {         logger.trace("publish response from {} contained no join", discoveryNode).         onMissingJoin(discoveryNode).     }     assert state == PublicationTargetState.SENT_PUBLISH_REQUEST : state + " -> " + PublicationTargetState.WAITING_FOR_QUORUM.     state = PublicationTargetState.WAITING_FOR_QUORUM.     handlePublishResponse(response.getPublishResponse()).     assert publicationCompletedIffAllTargetsInactiveOrCancelled(). }
false;public;1;10;;@Override public void onFailure(Exception e) {     assert e instanceof TransportException.     final TransportException exp = (TransportException) e.     logger.debug(() -> new ParameterizedMessage("PublishResponseHandler: [{}] failed", discoveryNode), exp).     assert ((TransportException) e).getRootCause() instanceof Exception.     setFailed((Exception) exp.getRootCause()).     onPossibleCommitFailure().     assert publicationCompletedIffAllTargetsInactiveOrCancelled(). }
false;public;1;11;;@Override public void onResponse(TransportResponse.Empty ignored) {     if (isFailed()) {         logger.debug("ApplyCommitResponseHandler.handleResponse: already failed, ignoring response from [{}]", discoveryNode).         return.     }     setAppliedCommit().     onPossibleCompletion().     assert publicationCompletedIffAllTargetsInactiveOrCancelled(). }
false;public;1;10;;@Override public void onFailure(Exception e) {     assert e instanceof TransportException.     final TransportException exp = (TransportException) e.     logger.debug(() -> new ParameterizedMessage("ApplyCommitResponseHandler: [{}] failed", discoveryNode), exp).     assert ((TransportException) e).getRootCause() instanceof Exception.     setFailed((Exception) exp.getRootCause()).     onPossibleCompletion().     assert publicationCompletedIffAllTargetsInactiveOrCancelled(). }
