# id;timestamp;commentText;codeText;commentWords;codeWords
LuceneChangesSnapshot -> LuceneChangesSnapshot(Engine.Searcher engineSearcher, MapperService mapperService, int searchBatchSize,                           long fromSeqNo, long toSeqNo, boolean requiredFullRange) throws IOException;1535723122;Creates a new "translog" snapshot from Lucene for reading operations whose seq# in the specified range.__@param engineSearcher    the internal engine searcher which will be taken over if the snapshot is opened successfully_@param mapperService     the mapper service which will be mainly used to resolve the document's type and uid_@param searchBatchSize   the number of documents should be returned by each search_@param fromSeqNo         the min requesting seq# - inclusive_@param toSeqNo           the maximum requesting seq# - inclusive_@param requiredFullRange if true, the snapshot will strictly check for the existence of operations between fromSeqNo and toSeqNo;LuceneChangesSnapshot(Engine.Searcher engineSearcher, MapperService mapperService, int searchBatchSize,_                          long fromSeqNo, long toSeqNo, boolean requiredFullRange) throws IOException {_        if (fromSeqNo < 0 || toSeqNo < 0 || fromSeqNo > toSeqNo) {_            throw new IllegalArgumentException("Invalid range_ from_seqno [" + fromSeqNo + "], to_seqno [" + toSeqNo + "]")__        }_        if (searchBatchSize <= 0) {_            throw new IllegalArgumentException("Search_batch_size must be positive [" + searchBatchSize + "]")__        }_        final AtomicBoolean closed = new AtomicBoolean()__        this.onClose = () -> {_            if (closed.compareAndSet(false, true)) {_                IOUtils.close(engineSearcher)__            }_        }__        this.mapperService = mapperService__        this.searchBatchSize = searchBatchSize__        this.fromSeqNo = fromSeqNo__        this.toSeqNo = toSeqNo__        this.lastSeenSeqNo = fromSeqNo - 1__        this.requiredFullRange = requiredFullRange__        this.indexSearcher = new IndexSearcher(Lucene.wrapAllDocsLive(engineSearcher.getDirectoryReader()))__        this.indexSearcher.setQueryCache(null)__        this.parallelArray = new ParallelArray(searchBatchSize)__        final TopDocs topDocs = searchOperations(null)__        this.totalHits = Math.toIntExact(topDocs.totalHits)__        this.scoreDocs = topDocs.scoreDocs__        fillParallelArray(scoreDocs, parallelArray)__    };creates,a,new,translog,snapshot,from,lucene,for,reading,operations,whose,seq,in,the,specified,range,param,engine,searcher,the,internal,engine,searcher,which,will,be,taken,over,if,the,snapshot,is,opened,successfully,param,mapper,service,the,mapper,service,which,will,be,mainly,used,to,resolve,the,document,s,type,and,uid,param,search,batch,size,the,number,of,documents,should,be,returned,by,each,search,param,from,seq,no,the,min,requesting,seq,inclusive,param,to,seq,no,the,maximum,requesting,seq,inclusive,param,required,full,range,if,true,the,snapshot,will,strictly,check,for,the,existence,of,operations,between,from,seq,no,and,to,seq,no;lucene,changes,snapshot,engine,searcher,engine,searcher,mapper,service,mapper,service,int,search,batch,size,long,from,seq,no,long,to,seq,no,boolean,required,full,range,throws,ioexception,if,from,seq,no,0,to,seq,no,0,from,seq,no,to,seq,no,throw,new,illegal,argument,exception,invalid,range,from,seq,no,to,seq,no,if,search,batch,size,0,throw,new,illegal,argument,exception,must,be,positive,search,batch,size,final,atomic,boolean,closed,new,atomic,boolean,this,on,close,if,closed,compare,and,set,false,true,ioutils,close,engine,searcher,this,mapper,service,mapper,service,this,search,batch,size,search,batch,size,this,from,seq,no,from,seq,no,this,to,seq,no,to,seq,no,this,last,seen,seq,no,from,seq,no,1,this,required,full,range,required,full,range,this,index,searcher,new,index,searcher,lucene,wrap,all,docs,live,engine,searcher,get,directory,reader,this,index,searcher,set,query,cache,null,this,parallel,array,new,parallel,array,search,batch,size,final,top,docs,top,docs,search,operations,null,this,total,hits,math,to,int,exact,top,docs,total,hits,this,score,docs,top,docs,score,docs,fill,parallel,array,score,docs,parallel,array
LuceneChangesSnapshot -> LuceneChangesSnapshot(Engine.Searcher engineSearcher, MapperService mapperService, int searchBatchSize,                           long fromSeqNo, long toSeqNo, boolean requiredFullRange) throws IOException;1536137328;Creates a new "translog" snapshot from Lucene for reading operations whose seq# in the specified range.__@param engineSearcher    the internal engine searcher which will be taken over if the snapshot is opened successfully_@param mapperService     the mapper service which will be mainly used to resolve the document's type and uid_@param searchBatchSize   the number of documents should be returned by each search_@param fromSeqNo         the min requesting seq# - inclusive_@param toSeqNo           the maximum requesting seq# - inclusive_@param requiredFullRange if true, the snapshot will strictly check for the existence of operations between fromSeqNo and toSeqNo;LuceneChangesSnapshot(Engine.Searcher engineSearcher, MapperService mapperService, int searchBatchSize,_                          long fromSeqNo, long toSeqNo, boolean requiredFullRange) throws IOException {_        if (fromSeqNo < 0 || toSeqNo < 0 || fromSeqNo > toSeqNo) {_            throw new IllegalArgumentException("Invalid range_ from_seqno [" + fromSeqNo + "], to_seqno [" + toSeqNo + "]")__        }_        if (searchBatchSize <= 0) {_            throw new IllegalArgumentException("Search_batch_size must be positive [" + searchBatchSize + "]")__        }_        final AtomicBoolean closed = new AtomicBoolean()__        this.onClose = () -> {_            if (closed.compareAndSet(false, true)) {_                IOUtils.close(engineSearcher)__            }_        }__        this.mapperService = mapperService__        this.searchBatchSize = searchBatchSize__        this.fromSeqNo = fromSeqNo__        this.toSeqNo = toSeqNo__        this.lastSeenSeqNo = fromSeqNo - 1__        this.requiredFullRange = requiredFullRange__        this.indexSearcher = new IndexSearcher(Lucene.wrapAllDocsLive(engineSearcher.getDirectoryReader()))__        this.indexSearcher.setQueryCache(null)__        this.parallelArray = new ParallelArray(searchBatchSize)__        final TopDocs topDocs = searchOperations(null)__        this.totalHits = Math.toIntExact(topDocs.totalHits)__        this.scoreDocs = topDocs.scoreDocs__        fillParallelArray(scoreDocs, parallelArray)__    };creates,a,new,translog,snapshot,from,lucene,for,reading,operations,whose,seq,in,the,specified,range,param,engine,searcher,the,internal,engine,searcher,which,will,be,taken,over,if,the,snapshot,is,opened,successfully,param,mapper,service,the,mapper,service,which,will,be,mainly,used,to,resolve,the,document,s,type,and,uid,param,search,batch,size,the,number,of,documents,should,be,returned,by,each,search,param,from,seq,no,the,min,requesting,seq,inclusive,param,to,seq,no,the,maximum,requesting,seq,inclusive,param,required,full,range,if,true,the,snapshot,will,strictly,check,for,the,existence,of,operations,between,from,seq,no,and,to,seq,no;lucene,changes,snapshot,engine,searcher,engine,searcher,mapper,service,mapper,service,int,search,batch,size,long,from,seq,no,long,to,seq,no,boolean,required,full,range,throws,ioexception,if,from,seq,no,0,to,seq,no,0,from,seq,no,to,seq,no,throw,new,illegal,argument,exception,invalid,range,from,seq,no,to,seq,no,if,search,batch,size,0,throw,new,illegal,argument,exception,must,be,positive,search,batch,size,final,atomic,boolean,closed,new,atomic,boolean,this,on,close,if,closed,compare,and,set,false,true,ioutils,close,engine,searcher,this,mapper,service,mapper,service,this,search,batch,size,search,batch,size,this,from,seq,no,from,seq,no,this,to,seq,no,to,seq,no,this,last,seen,seq,no,from,seq,no,1,this,required,full,range,required,full,range,this,index,searcher,new,index,searcher,lucene,wrap,all,docs,live,engine,searcher,get,directory,reader,this,index,searcher,set,query,cache,null,this,parallel,array,new,parallel,array,search,batch,size,final,top,docs,top,docs,search,operations,null,this,total,hits,math,to,int,exact,top,docs,total,hits,this,score,docs,top,docs,score,docs,fill,parallel,array,score,docs,parallel,array
LuceneChangesSnapshot -> LuceneChangesSnapshot(Engine.Searcher engineSearcher, MapperService mapperService, int searchBatchSize,                           long fromSeqNo, long toSeqNo, boolean requiredFullRange) throws IOException;1536314350;Creates a new "translog" snapshot from Lucene for reading operations whose seq# in the specified range.__@param engineSearcher    the internal engine searcher which will be taken over if the snapshot is opened successfully_@param mapperService     the mapper service which will be mainly used to resolve the document's type and uid_@param searchBatchSize   the number of documents should be returned by each search_@param fromSeqNo         the min requesting seq# - inclusive_@param toSeqNo           the maximum requesting seq# - inclusive_@param requiredFullRange if true, the snapshot will strictly check for the existence of operations between fromSeqNo and toSeqNo;LuceneChangesSnapshot(Engine.Searcher engineSearcher, MapperService mapperService, int searchBatchSize,_                          long fromSeqNo, long toSeqNo, boolean requiredFullRange) throws IOException {_        if (fromSeqNo < 0 || toSeqNo < 0 || fromSeqNo > toSeqNo) {_            throw new IllegalArgumentException("Invalid range_ from_seqno [" + fromSeqNo + "], to_seqno [" + toSeqNo + "]")__        }_        if (searchBatchSize <= 0) {_            throw new IllegalArgumentException("Search_batch_size must be positive [" + searchBatchSize + "]")__        }_        final AtomicBoolean closed = new AtomicBoolean()__        this.onClose = () -> {_            if (closed.compareAndSet(false, true)) {_                IOUtils.close(engineSearcher)__            }_        }__        this.mapperService = mapperService__        this.searchBatchSize = searchBatchSize__        this.fromSeqNo = fromSeqNo__        this.toSeqNo = toSeqNo__        this.lastSeenSeqNo = fromSeqNo - 1__        this.requiredFullRange = requiredFullRange__        this.indexSearcher = new IndexSearcher(Lucene.wrapAllDocsLive(engineSearcher.getDirectoryReader()))__        this.indexSearcher.setQueryCache(null)__        this.parallelArray = new ParallelArray(searchBatchSize)__        final TopDocs topDocs = searchOperations(null)__        this.totalHits = Math.toIntExact(topDocs.totalHits.value)__        this.scoreDocs = topDocs.scoreDocs__        fillParallelArray(scoreDocs, parallelArray)__    };creates,a,new,translog,snapshot,from,lucene,for,reading,operations,whose,seq,in,the,specified,range,param,engine,searcher,the,internal,engine,searcher,which,will,be,taken,over,if,the,snapshot,is,opened,successfully,param,mapper,service,the,mapper,service,which,will,be,mainly,used,to,resolve,the,document,s,type,and,uid,param,search,batch,size,the,number,of,documents,should,be,returned,by,each,search,param,from,seq,no,the,min,requesting,seq,inclusive,param,to,seq,no,the,maximum,requesting,seq,inclusive,param,required,full,range,if,true,the,snapshot,will,strictly,check,for,the,existence,of,operations,between,from,seq,no,and,to,seq,no;lucene,changes,snapshot,engine,searcher,engine,searcher,mapper,service,mapper,service,int,search,batch,size,long,from,seq,no,long,to,seq,no,boolean,required,full,range,throws,ioexception,if,from,seq,no,0,to,seq,no,0,from,seq,no,to,seq,no,throw,new,illegal,argument,exception,invalid,range,from,seq,no,to,seq,no,if,search,batch,size,0,throw,new,illegal,argument,exception,must,be,positive,search,batch,size,final,atomic,boolean,closed,new,atomic,boolean,this,on,close,if,closed,compare,and,set,false,true,ioutils,close,engine,searcher,this,mapper,service,mapper,service,this,search,batch,size,search,batch,size,this,from,seq,no,from,seq,no,this,to,seq,no,to,seq,no,this,last,seen,seq,no,from,seq,no,1,this,required,full,range,required,full,range,this,index,searcher,new,index,searcher,lucene,wrap,all,docs,live,engine,searcher,get,directory,reader,this,index,searcher,set,query,cache,null,this,parallel,array,new,parallel,array,search,batch,size,final,top,docs,top,docs,search,operations,null,this,total,hits,math,to,int,exact,top,docs,total,hits,value,this,score,docs,top,docs,score,docs,fill,parallel,array,score,docs,parallel,array
LuceneChangesSnapshot -> LuceneChangesSnapshot(Engine.Searcher engineSearcher, MapperService mapperService, int searchBatchSize,                           long fromSeqNo, long toSeqNo, boolean requiredFullRange) throws IOException;1541162995;Creates a new "translog" snapshot from Lucene for reading operations whose seq# in the specified range.__@param engineSearcher    the internal engine searcher which will be taken over if the snapshot is opened successfully_@param mapperService     the mapper service which will be mainly used to resolve the document's type and uid_@param searchBatchSize   the number of documents should be returned by each search_@param fromSeqNo         the min requesting seq# - inclusive_@param toSeqNo           the maximum requesting seq# - inclusive_@param requiredFullRange if true, the snapshot will strictly check for the existence of operations between fromSeqNo and toSeqNo;LuceneChangesSnapshot(Engine.Searcher engineSearcher, MapperService mapperService, int searchBatchSize,_                          long fromSeqNo, long toSeqNo, boolean requiredFullRange) throws IOException {_        if (fromSeqNo < 0 || toSeqNo < 0 || fromSeqNo > toSeqNo) {_            throw new IllegalArgumentException("Invalid range_ from_seqno [" + fromSeqNo + "], to_seqno [" + toSeqNo + "]")__        }_        if (searchBatchSize <= 0) {_            throw new IllegalArgumentException("Search_batch_size must be positive [" + searchBatchSize + "]")__        }_        final AtomicBoolean closed = new AtomicBoolean()__        this.onClose = () -> {_            if (closed.compareAndSet(false, true)) {_                IOUtils.close(engineSearcher)__            }_        }__        this.mapperService = mapperService__        final long requestingSize = (toSeqNo - fromSeqNo) == Long.MAX_VALUE ? Long.MAX_VALUE : (toSeqNo - fromSeqNo + 1L)__        this.searchBatchSize = requestingSize < searchBatchSize ? Math.toIntExact(requestingSize) : searchBatchSize__        this.fromSeqNo = fromSeqNo__        this.toSeqNo = toSeqNo__        this.lastSeenSeqNo = fromSeqNo - 1__        this.requiredFullRange = requiredFullRange__        this.indexSearcher = new IndexSearcher(Lucene.wrapAllDocsLive(engineSearcher.getDirectoryReader()))__        this.indexSearcher.setQueryCache(null)__        this.parallelArray = new ParallelArray(this.searchBatchSize)__        final TopDocs topDocs = searchOperations(null)__        this.totalHits = Math.toIntExact(topDocs.totalHits.value)__        this.scoreDocs = topDocs.scoreDocs__        fillParallelArray(scoreDocs, parallelArray)__    };creates,a,new,translog,snapshot,from,lucene,for,reading,operations,whose,seq,in,the,specified,range,param,engine,searcher,the,internal,engine,searcher,which,will,be,taken,over,if,the,snapshot,is,opened,successfully,param,mapper,service,the,mapper,service,which,will,be,mainly,used,to,resolve,the,document,s,type,and,uid,param,search,batch,size,the,number,of,documents,should,be,returned,by,each,search,param,from,seq,no,the,min,requesting,seq,inclusive,param,to,seq,no,the,maximum,requesting,seq,inclusive,param,required,full,range,if,true,the,snapshot,will,strictly,check,for,the,existence,of,operations,between,from,seq,no,and,to,seq,no;lucene,changes,snapshot,engine,searcher,engine,searcher,mapper,service,mapper,service,int,search,batch,size,long,from,seq,no,long,to,seq,no,boolean,required,full,range,throws,ioexception,if,from,seq,no,0,to,seq,no,0,from,seq,no,to,seq,no,throw,new,illegal,argument,exception,invalid,range,from,seq,no,to,seq,no,if,search,batch,size,0,throw,new,illegal,argument,exception,must,be,positive,search,batch,size,final,atomic,boolean,closed,new,atomic,boolean,this,on,close,if,closed,compare,and,set,false,true,ioutils,close,engine,searcher,this,mapper,service,mapper,service,final,long,requesting,size,to,seq,no,from,seq,no,long,long,to,seq,no,from,seq,no,1l,this,search,batch,size,requesting,size,search,batch,size,math,to,int,exact,requesting,size,search,batch,size,this,from,seq,no,from,seq,no,this,to,seq,no,to,seq,no,this,last,seen,seq,no,from,seq,no,1,this,required,full,range,required,full,range,this,index,searcher,new,index,searcher,lucene,wrap,all,docs,live,engine,searcher,get,directory,reader,this,index,searcher,set,query,cache,null,this,parallel,array,new,parallel,array,this,search,batch,size,final,top,docs,top,docs,search,operations,null,this,total,hits,math,to,int,exact,top,docs,total,hits,value,this,score,docs,top,docs,score,docs,fill,parallel,array,score,docs,parallel,array
LuceneChangesSnapshot -> LuceneChangesSnapshot(Engine.Searcher engineSearcher, MapperService mapperService, int searchBatchSize,                           long fromSeqNo, long toSeqNo, boolean requiredFullRange) throws IOException;1548664204;Creates a new "translog" snapshot from Lucene for reading operations whose seq# in the specified range.__@param engineSearcher    the internal engine searcher which will be taken over if the snapshot is opened successfully_@param mapperService     the mapper service which will be mainly used to resolve the document's type and uid_@param searchBatchSize   the number of documents should be returned by each search_@param fromSeqNo         the min requesting seq# - inclusive_@param toSeqNo           the maximum requesting seq# - inclusive_@param requiredFullRange if true, the snapshot will strictly check for the existence of operations between fromSeqNo and toSeqNo;LuceneChangesSnapshot(Engine.Searcher engineSearcher, MapperService mapperService, int searchBatchSize,_                          long fromSeqNo, long toSeqNo, boolean requiredFullRange) throws IOException {_        if (fromSeqNo < 0 || toSeqNo < 0 || fromSeqNo > toSeqNo) {_            throw new IllegalArgumentException("Invalid range_ from_seqno [" + fromSeqNo + "], to_seqno [" + toSeqNo + "]")__        }_        if (searchBatchSize <= 0) {_            throw new IllegalArgumentException("Search_batch_size must be positive [" + searchBatchSize + "]")__        }_        final AtomicBoolean closed = new AtomicBoolean()__        this.onClose = () -> {_            if (closed.compareAndSet(false, true)) {_                IOUtils.close(engineSearcher)__            }_        }__        this.mapperService = mapperService__        final long requestingSize = (toSeqNo - fromSeqNo) == Long.MAX_VALUE ? Long.MAX_VALUE : (toSeqNo - fromSeqNo + 1L)__        this.searchBatchSize = requestingSize < searchBatchSize ? Math.toIntExact(requestingSize) : searchBatchSize__        this.fromSeqNo = fromSeqNo__        this.toSeqNo = toSeqNo__        this.lastSeenSeqNo = fromSeqNo - 1__        this.requiredFullRange = requiredFullRange__        this.indexSearcher = new IndexSearcher(Lucene.wrapAllDocsLive(engineSearcher.getDirectoryReader()))__        this.indexSearcher.setQueryCache(null)__        this.parallelArray = new ParallelArray(this.searchBatchSize)__        final TopDocs topDocs = searchOperations(null)__        this.totalHits = Math.toIntExact(topDocs.totalHits.value)__        this.scoreDocs = topDocs.scoreDocs__        fillParallelArray(scoreDocs, parallelArray)__    };creates,a,new,translog,snapshot,from,lucene,for,reading,operations,whose,seq,in,the,specified,range,param,engine,searcher,the,internal,engine,searcher,which,will,be,taken,over,if,the,snapshot,is,opened,successfully,param,mapper,service,the,mapper,service,which,will,be,mainly,used,to,resolve,the,document,s,type,and,uid,param,search,batch,size,the,number,of,documents,should,be,returned,by,each,search,param,from,seq,no,the,min,requesting,seq,inclusive,param,to,seq,no,the,maximum,requesting,seq,inclusive,param,required,full,range,if,true,the,snapshot,will,strictly,check,for,the,existence,of,operations,between,from,seq,no,and,to,seq,no;lucene,changes,snapshot,engine,searcher,engine,searcher,mapper,service,mapper,service,int,search,batch,size,long,from,seq,no,long,to,seq,no,boolean,required,full,range,throws,ioexception,if,from,seq,no,0,to,seq,no,0,from,seq,no,to,seq,no,throw,new,illegal,argument,exception,invalid,range,from,seq,no,to,seq,no,if,search,batch,size,0,throw,new,illegal,argument,exception,must,be,positive,search,batch,size,final,atomic,boolean,closed,new,atomic,boolean,this,on,close,if,closed,compare,and,set,false,true,ioutils,close,engine,searcher,this,mapper,service,mapper,service,final,long,requesting,size,to,seq,no,from,seq,no,long,long,to,seq,no,from,seq,no,1l,this,search,batch,size,requesting,size,search,batch,size,math,to,int,exact,requesting,size,search,batch,size,this,from,seq,no,from,seq,no,this,to,seq,no,to,seq,no,this,last,seen,seq,no,from,seq,no,1,this,required,full,range,required,full,range,this,index,searcher,new,index,searcher,lucene,wrap,all,docs,live,engine,searcher,get,directory,reader,this,index,searcher,set,query,cache,null,this,parallel,array,new,parallel,array,this,search,batch,size,final,top,docs,top,docs,search,operations,null,this,total,hits,math,to,int,exact,top,docs,total,hits,value,this,score,docs,top,docs,score,docs,fill,parallel,array,score,docs,parallel,array
