commented;modifiers;parameterAmount;loc;comment;code
false;public;0;8;;@Override public ActionRequestValidationException validate() {     ActionRequestValidationException validationException = null.     if (CollectionUtils.isEmpty(indices)) {         validationException = addValidationError("index is missing", validationException).     }     return validationException. }
true;public;0;4;/**  * The indices to be opened  * @return the indices to be opened  */ ;/**  * The indices to be opened  * @return the indices to be opened  */ @Override public String[] indices() {     return indices. }
true;public;1;5;/**  * Sets the indices to be opened  * @param indices the indices to be opened  * @return the request itself  */ ;/**  * Sets the indices to be opened  * @param indices the indices to be opened  * @return the request itself  */ @Override public OpenIndexRequest indices(String... indices) {     this.indices = indices.     return this. }
true;public;0;4;/**  * Specifies what type of requested indices to ignore and how to deal with wildcard expressions.  * For example indices that don't exist.  *  * @return the current behaviour when it comes to index names and wildcard indices expressions  */ ;/**  * Specifies what type of requested indices to ignore and how to deal with wildcard expressions.  * For example indices that don't exist.  *  * @return the current behaviour when it comes to index names and wildcard indices expressions  */ @Override public IndicesOptions indicesOptions() {     return indicesOptions. }
true;public;1;4;/**  * Specifies what type of requested indices to ignore and how to deal with wildcard expressions.  * For example indices that don't exist.  *  * @param indicesOptions the desired behaviour regarding indices to ignore and wildcard indices expressions  * @return the request itself  */ ;/**  * Specifies what type of requested indices to ignore and how to deal with wildcard expressions.  * For example indices that don't exist.  *  * @param indicesOptions the desired behaviour regarding indices to ignore and wildcard indices expressions  * @return the request itself  */ public OpenIndexRequest indicesOptions(IndicesOptions indicesOptions) {     this.indicesOptions = indicesOptions.     return this. }
false;public;0;3;;public ActiveShardCount waitForActiveShards() {     return waitForActiveShards. }
true;public;1;4;/**  * Sets the number of shard copies that should be active for indices opening to return.  * Defaults to {@link ActiveShardCount#DEFAULT}, which will wait for one shard copy  * (the primary) to become active. Set this value to {@link ActiveShardCount#ALL} to  * wait for all shards (primary and all replicas) to be active before returning.  * Otherwise, use {@link ActiveShardCount#from(int)} to set this value to any  * non-negative integer, up to the number of copies per shard (number of replicas + 1),  * to wait for the desired amount of shard copies to become active before returning.  * Indices opening will only wait up until the timeout value for the number of shard copies  * to be active before returning.  Check {@link OpenIndexResponse#isShardsAcknowledged()} to  * determine if the requisite shard copies were all started before returning or timing out.  *  * @param waitForActiveShards number of active shard copies to wait on  */ ;/**  * Sets the number of shard copies that should be active for indices opening to return.  * Defaults to {@link ActiveShardCount#DEFAULT}, which will wait for one shard copy  * (the primary) to become active. Set this value to {@link ActiveShardCount#ALL} to  * wait for all shards (primary and all replicas) to be active before returning.  * Otherwise, use {@link ActiveShardCount#from(int)} to set this value to any  * non-negative integer, up to the number of copies per shard (number of replicas + 1),  * to wait for the desired amount of shard copies to become active before returning.  * Indices opening will only wait up until the timeout value for the number of shard copies  * to be active before returning.  Check {@link OpenIndexResponse#isShardsAcknowledged()} to  * determine if the requisite shard copies were all started before returning or timing out.  *  * @param waitForActiveShards number of active shard copies to wait on  */ public OpenIndexRequest waitForActiveShards(ActiveShardCount waitForActiveShards) {     this.waitForActiveShards = waitForActiveShards.     return this. }
true;public;1;3;/**  * A shortcut for {@link #waitForActiveShards(ActiveShardCount)} where the numerical  * shard count is passed in, instead of having to first call {@link ActiveShardCount#from(int)}  * to get the ActiveShardCount.  */ ;/**  * A shortcut for {@link #waitForActiveShards(ActiveShardCount)} where the numerical  * shard count is passed in, instead of having to first call {@link ActiveShardCount#from(int)}  * to get the ActiveShardCount.  */ public OpenIndexRequest waitForActiveShards(final int waitForActiveShards) {     return waitForActiveShards(ActiveShardCount.from(waitForActiveShards)). }
false;public;1;9;;@Override public void readFrom(StreamInput in) throws IOException {     super.readFrom(in).     indices = in.readStringArray().     indicesOptions = IndicesOptions.readIndicesOptions(in).     if (in.getVersion().onOrAfter(Version.V_6_1_0)) {         waitForActiveShards = ActiveShardCount.readFrom(in).     } }
false;public;1;9;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeStringArray(indices).     indicesOptions.writeIndicesOptions(out).     if (out.getVersion().onOrAfter(Version.V_6_1_0)) {         waitForActiveShards.writeTo(out).     } }
