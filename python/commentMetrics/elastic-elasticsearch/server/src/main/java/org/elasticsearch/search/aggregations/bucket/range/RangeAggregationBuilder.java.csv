commented;modifiers;parameterAmount;loc;comment;code
false;public,static;2;3;;public static AggregationBuilder parse(String aggregationName, XContentParser parser) throws IOException {     return PARSER.parse(parser, new RangeAggregationBuilder(aggregationName), null). }
false;private,static;1;3;;private static Range parseRange(XContentParser parser) throws IOException {     return Range.fromXContent(parser). }
false;protected;2;4;;@Override protected AggregationBuilder shallowCopy(Builder factoriesBuilder, Map<String, Object> metaData) {     return new RangeAggregationBuilder(this, factoriesBuilder, metaData). }
true;public;3;4;/**  * Add a new range to this aggregation.  *  * @param key  *            the key to use for this range in the response  * @param from  *            the lower bound on the distances, inclusive  * @param to  *            the upper bound on the distances, exclusive  */ ;/**  * Add a new range to this aggregation.  *  * @param key  *            the key to use for this range in the response  * @param from  *            the lower bound on the distances, inclusive  * @param to  *            the upper bound on the distances, exclusive  */ public RangeAggregationBuilder addRange(String key, double from, double to) {     addRange(new Range(key, from, to)).     return this. }
true;public;2;3;/**  * Same as {@link #addRange(String, double, double)} but the key will be  * automatically generated based on <code>from</code> and  * <code>to</code>.  */ ;/**  * Same as {@link #addRange(String, double, double)} but the key will be  * automatically generated based on <code>from</code> and  * <code>to</code>.  */ public RangeAggregationBuilder addRange(double from, double to) {     return addRange(null, from, to). }
true;public;2;4;/**  * Add a new range with no lower bound.  *  * @param key  *            the key to use for this range in the response  * @param to  *            the upper bound on the distances, exclusive  */ ;/**  * Add a new range with no lower bound.  *  * @param key  *            the key to use for this range in the response  * @param to  *            the upper bound on the distances, exclusive  */ public RangeAggregationBuilder addUnboundedTo(String key, double to) {     addRange(new Range(key, null, to)).     return this. }
true;public;1;3;/**  * Same as {@link #addUnboundedTo(String, double)} but the key will be  * computed automatically.  */ ;/**  * Same as {@link #addUnboundedTo(String, double)} but the key will be  * computed automatically.  */ public RangeAggregationBuilder addUnboundedTo(double to) {     return addUnboundedTo(null, to). }
true;public;2;4;/**  * Add a new range with no upper bound.  *  * @param key  *            the key to use for this range in the response  * @param from  *            the lower bound on the distances, inclusive  */ ;/**  * Add a new range with no upper bound.  *  * @param key  *            the key to use for this range in the response  * @param from  *            the lower bound on the distances, inclusive  */ public RangeAggregationBuilder addUnboundedFrom(String key, double from) {     addRange(new Range(key, from, null)).     return this. }
true;public;1;3;/**  * Same as {@link #addUnboundedFrom(String, double)} but the key will be  * computed automatically.  */ ;/**  * Same as {@link #addUnboundedFrom(String, double)} but the key will be  * computed automatically.  */ public RangeAggregationBuilder addUnboundedFrom(double from) {     return addUnboundedFrom(null, from). }
false;protected;4;23;;@Override protected RangeAggregatorFactory innerBuild(SearchContext context, ValuesSourceConfig<Numeric> config, AggregatorFactory<?> parent, Builder subFactoriesBuilder) throws IOException {     // We need to call processRanges here so they are parsed before we make the decision of whether to cache the request     Range[] ranges = processRanges(range -> {         DocValueFormat parser = config.format().         assert parser != null.         Double from = range.from.         Double to = range.to.         if (range.fromAsStr != null) {             from = parser.parseDouble(range.fromAsStr, false, context.getQueryShardContext()::nowInMillis).         }         if (range.toAsStr != null) {             to = parser.parseDouble(range.toAsStr, false, context.getQueryShardContext()::nowInMillis).         }         return new Range(range.key, from, range.fromAsStr, to, range.toAsStr).     }).     if (ranges.length == 0) {         throw new IllegalArgumentException("No [ranges] specified for the [" + this.getName() + "] aggregation").     }     return new RangeAggregatorFactory(name, config, ranges, keyed, rangeFactory, context, parent, subFactoriesBuilder, metaData). }
false;public;0;4;;@Override public String getType() {     return NAME. }
