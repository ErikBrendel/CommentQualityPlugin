commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public Iterator<DiscoveryNode> iterator() {     return nodes.valuesIt(). }
true;public;0;7;/**  * Returns {@code true} if the local node is the elected master node.  */ ;/**  * Returns {@code true} if the local node is the elected master node.  */ public boolean isLocalNodeElectedMaster() {     if (localNodeId == null) {         // we don't know yet the local node id, return false         return false.     }     return localNodeId.equals(masterNodeId). }
true;public;0;3;/**  * Get the number of known nodes  *  * @return number of nodes  */ ;/**  * Get the number of known nodes  *  * @return number of nodes  */ public int getSize() {     return nodes.size(). }
true;public;0;3;/**  * Get a {@link Map} of the discovered nodes arranged by their ids  *  * @return {@link Map} of the discovered nodes arranged by their ids  */ ;/**  * Get a {@link Map} of the discovered nodes arranged by their ids  *  * @return {@link Map} of the discovered nodes arranged by their ids  */ public ImmutableOpenMap<String, DiscoveryNode> getNodes() {     return this.nodes. }
true;public;0;3;/**  * Get a {@link Map} of the discovered data nodes arranged by their ids  *  * @return {@link Map} of the discovered data nodes arranged by their ids  */ ;/**  * Get a {@link Map} of the discovered data nodes arranged by their ids  *  * @return {@link Map} of the discovered data nodes arranged by their ids  */ public ImmutableOpenMap<String, DiscoveryNode> getDataNodes() {     return this.dataNodes. }
true;public;0;3;/**  * Get a {@link Map} of the discovered master nodes arranged by their ids  *  * @return {@link Map} of the discovered master nodes arranged by their ids  */ ;/**  * Get a {@link Map} of the discovered master nodes arranged by their ids  *  * @return {@link Map} of the discovered master nodes arranged by their ids  */ public ImmutableOpenMap<String, DiscoveryNode> getMasterNodes() {     return this.masterNodes. }
true;public;0;3;/**  * @return All the ingest nodes arranged by their ids  */ ;/**  * @return All the ingest nodes arranged by their ids  */ public ImmutableOpenMap<String, DiscoveryNode> getIngestNodes() {     return ingestNodes. }
true;public;0;5;/**  * Get a {@link Map} of the discovered master and data nodes arranged by their ids  *  * @return {@link Map} of the discovered master and data nodes arranged by their ids  */ ;/**  * Get a {@link Map} of the discovered master and data nodes arranged by their ids  *  * @return {@link Map} of the discovered master and data nodes arranged by their ids  */ public ImmutableOpenMap<String, DiscoveryNode> getMasterAndDataNodes() {     ImmutableOpenMap.Builder<String, DiscoveryNode> nodes = ImmutableOpenMap.builder(dataNodes).     nodes.putAll(masterNodes).     return nodes.build(). }
true;public;0;7;/**  * Get a {@link Map} of the coordinating only nodes (nodes which are neither master, nor data, nor ingest nodes) arranged by their ids  *  * @return {@link Map} of the coordinating only nodes arranged by their ids  */ ;/**  * Get a {@link Map} of the coordinating only nodes (nodes which are neither master, nor data, nor ingest nodes) arranged by their ids  *  * @return {@link Map} of the coordinating only nodes arranged by their ids  */ public ImmutableOpenMap<String, DiscoveryNode> getCoordinatingOnlyNodes() {     ImmutableOpenMap.Builder<String, DiscoveryNode> nodes = ImmutableOpenMap.builder(this.nodes).     nodes.removeAll(masterNodes.keys()).     nodes.removeAll(dataNodes.keys()).     nodes.removeAll(ingestNodes.keys()).     return nodes.build(). }
true;public;0;4;/**  * Returns a stream of all nodes, with master nodes at the front  */ ;/**  * Returns a stream of all nodes, with master nodes at the front  */ public Stream<DiscoveryNode> mastersFirstStream() {     return Stream.concat(StreamSupport.stream(masterNodes.spliterator(), false).map(cur -> cur.value), StreamSupport.stream(this.spliterator(), false).filter(n -> n.isMasterNode() == false)). }
true;public;1;3;/**  * Get a node by its id  *  * @param nodeId id of the wanted node  * @return wanted node if it exists. Otherwise <code>null</code>  */ ;/**  * Get a node by its id  *  * @param nodeId id of the wanted node  * @return wanted node if it exists. Otherwise <code>null</code>  */ public DiscoveryNode get(String nodeId) {     return nodes.get(nodeId). }
true;public;1;3;/**  * Determine if a given node id exists  *  * @param nodeId id of the node which existence should be verified  * @return <code>true</code> if the node exists. Otherwise <code>false</code>  */ ;/**  * Determine if a given node id exists  *  * @param nodeId id of the node which existence should be verified  * @return <code>true</code> if the node exists. Otherwise <code>false</code>  */ public boolean nodeExists(String nodeId) {     return nodes.containsKey(nodeId). }
true;public;1;4;/**  * Determine if a given node exists  *  * @param node of the node which existence should be verified  * @return <code>true</code> if the node exists. Otherwise <code>false</code>  */ ;/**  * Determine if a given node exists  *  * @param node of the node which existence should be verified  * @return <code>true</code> if the node exists. Otherwise <code>false</code>  */ public boolean nodeExists(DiscoveryNode node) {     DiscoveryNode existing = nodes.get(node.getId()).     return existing != null && existing.equals(node). }
true;public;0;3;/**  * Get the id of the master node  *  * @return id of the master  */ ;/**  * Get the id of the master node  *  * @return id of the master  */ public String getMasterNodeId() {     return this.masterNodeId. }
true;public;0;3;/**  * Get the id of the local node  *  * @return id of the local node  */ ;/**  * Get the id of the local node  *  * @return id of the local node  */ public String getLocalNodeId() {     return this.localNodeId. }
true;public;0;3;/**  * Get the local node  *  * @return local node  */ ;/**  * Get the local node  *  * @return local node  */ public DiscoveryNode getLocalNode() {     return nodes.get(localNodeId). }
true;public;0;7;/**  * Returns the master node, or {@code null} if there is no master node  */ ;/**  * Returns the master node, or {@code null} if there is no master node  */ @Nullable public DiscoveryNode getMasterNode() {     if (masterNodeId != null) {         return nodes.get(masterNodeId).     }     return null. }
true;public;1;9;/**  * Get a node by its address  *  * @param address {@link TransportAddress} of the wanted node  * @return node identified by the given address or <code>null</code> if no such node exists  */ ;/**  * Get a node by its address  *  * @param address {@link TransportAddress} of the wanted node  * @return node identified by the given address or <code>null</code> if no such node exists  */ public DiscoveryNode findByAddress(TransportAddress address) {     for (ObjectCursor<DiscoveryNode> cursor : nodes.values()) {         DiscoveryNode node = cursor.value.         if (node.getAddress().equals(address)) {             return node.         }     }     return null. }
true;public;0;3;/**  * Returns the version of the node with the oldest version in the cluster that is not a client node  *  * If there are no non-client nodes, Version.CURRENT will be returned.  *  * @return the oldest version in the cluster  */ ;/**  * Returns the version of the node with the oldest version in the cluster that is not a client node  *  * If there are no non-client nodes, Version.CURRENT will be returned.  *  * @return the oldest version in the cluster  */ public Version getSmallestNonClientNodeVersion() {     return minNonClientNodeVersion. }
true;public;0;3;/**  * Returns the version of the node with the youngest version in the cluster that is not a client node.  *  * If there are no non-client nodes, Version.CURRENT will be returned.  *  * @return the youngest version in the cluster  */ ;/**  * Returns the version of the node with the youngest version in the cluster that is not a client node.  *  * If there are no non-client nodes, Version.CURRENT will be returned.  *  * @return the youngest version in the cluster  */ public Version getLargestNonClientNodeVersion() {     return maxNonClientNodeVersion. }
true;public;0;3;/**  * Returns the version of the node with the oldest version in the cluster.  *  * @return the oldest version in the cluster  */ ;/**  * Returns the version of the node with the oldest version in the cluster.  *  * @return the oldest version in the cluster  */ public Version getMinNodeVersion() {     return minNodeVersion. }
true;public;0;3;/**  * Returns the version of the node with the youngest version in the cluster  *  * @return the youngest version in the cluster  */ ;/**  * Returns the version of the node with the youngest version in the cluster  *  * @return the youngest version in the cluster  */ public Version getMaxNodeVersion() {     return maxNodeVersion. }
true;public;1;11;/**  * Resolve a node with a given id  *  * @param node id of the node to discover  * @return discovered node matching the given id  * @throws IllegalArgumentException if more than one node matches the request or no nodes have been resolved  */ ;/**  * Resolve a node with a given id  *  * @param node id of the node to discover  * @return discovered node matching the given id  * @throws IllegalArgumentException if more than one node matches the request or no nodes have been resolved  */ public DiscoveryNode resolveNode(String node) {     String[] resolvedNodeIds = resolveNodes(node).     if (resolvedNodeIds.length > 1) {         throw new IllegalArgumentException("resolved [" + node + "] into [" + resolvedNodeIds.length + "] nodes, where expected to be resolved to a single node").     }     if (resolvedNodeIds.length == 0) {         throw new IllegalArgumentException("failed to resolve [" + node + "], no matching nodes").     }     return nodes.get(resolvedNodeIds[0]). }
true;public;1;72;/**  * resolves a set of node "descriptions" to concrete and existing node ids. "descriptions" can be (resolved in this order):  * - "_local" or "_master" for the relevant nodes  * - a node id  * - a wild card pattern that will be matched against node names  * - a "attr:value" pattern, where attr can be a node role (master, data, ingest etc.) in which case the value can be true or false,  *   or a generic node attribute name in which case value will be treated as a wildcard and matched against the node attribute values.  */ ;/**  * resolves a set of node "descriptions" to concrete and existing node ids. "descriptions" can be (resolved in this order):  * - "_local" or "_master" for the relevant nodes  * - a node id  * - a wild card pattern that will be matched against node names  * - a "attr:value" pattern, where attr can be a node role (master, data, ingest etc.) in which case the value can be true or false,  *   or a generic node attribute name in which case value will be treated as a wildcard and matched against the node attribute values.  */ public String[] resolveNodes(String... nodes) {     if (nodes == null || nodes.length == 0) {         return StreamSupport.stream(this.spliterator(), false).map(DiscoveryNode::getId).toArray(String[]::new).     } else {         ObjectHashSet<String> resolvedNodesIds = new ObjectHashSet<>(nodes.length).         for (String nodeId : nodes) {             if (nodeId.equals("_local")) {                 String localNodeId = getLocalNodeId().                 if (localNodeId != null) {                     resolvedNodesIds.add(localNodeId).                 }             } else if (nodeId.equals("_master")) {                 String masterNodeId = getMasterNodeId().                 if (masterNodeId != null) {                     resolvedNodesIds.add(masterNodeId).                 }             } else if (nodeExists(nodeId)) {                 resolvedNodesIds.add(nodeId).             } else {                 for (DiscoveryNode node : this) {                     if ("_all".equals(nodeId) || Regex.simpleMatch(nodeId, node.getName()) || Regex.simpleMatch(nodeId, node.getHostAddress()) || Regex.simpleMatch(nodeId, node.getHostName())) {                         resolvedNodesIds.add(node.getId()).                     }                 }                 int index = nodeId.indexOf(':').                 if (index != -1) {                     String matchAttrName = nodeId.substring(0, index).                     String matchAttrValue = nodeId.substring(index + 1).                     if (DiscoveryNode.Role.DATA.getRoleName().equals(matchAttrName)) {                         if (Booleans.parseBoolean(matchAttrValue, true)) {                             resolvedNodesIds.addAll(dataNodes.keys()).                         } else {                             resolvedNodesIds.removeAll(dataNodes.keys()).                         }                     } else if (DiscoveryNode.Role.MASTER.getRoleName().equals(matchAttrName)) {                         if (Booleans.parseBoolean(matchAttrValue, true)) {                             resolvedNodesIds.addAll(masterNodes.keys()).                         } else {                             resolvedNodesIds.removeAll(masterNodes.keys()).                         }                     } else if (DiscoveryNode.Role.INGEST.getRoleName().equals(matchAttrName)) {                         if (Booleans.parseBoolean(matchAttrValue, true)) {                             resolvedNodesIds.addAll(ingestNodes.keys()).                         } else {                             resolvedNodesIds.removeAll(ingestNodes.keys()).                         }                     } else if (DiscoveryNode.COORDINATING_ONLY.equals(matchAttrName)) {                         if (Booleans.parseBoolean(matchAttrValue, true)) {                             resolvedNodesIds.addAll(getCoordinatingOnlyNodes().keys()).                         } else {                             resolvedNodesIds.removeAll(getCoordinatingOnlyNodes().keys()).                         }                     } else {                         for (DiscoveryNode node : this) {                             for (Map.Entry<String, String> entry : node.getAttributes().entrySet()) {                                 String attrName = entry.getKey().                                 String attrValue = entry.getValue().                                 if (Regex.simpleMatch(matchAttrName, attrName) && Regex.simpleMatch(matchAttrValue, attrValue)) {                                     resolvedNodesIds.add(node.getId()).                                 }                             }                         }                     }                 }             }         }         return resolvedNodesIds.toArray(String.class).     } }
false;public;1;3;;public DiscoveryNodes newNode(DiscoveryNode node) {     return new Builder(this).add(node).build(). }
true;public;1;17;/**  * Returns the changes comparing this nodes to the provided nodes.  */ ;/**  * Returns the changes comparing this nodes to the provided nodes.  */ public Delta delta(DiscoveryNodes other) {     final List<DiscoveryNode> removed = new ArrayList<>().     final List<DiscoveryNode> added = new ArrayList<>().     for (DiscoveryNode node : other) {         if (this.nodeExists(node) == false) {             removed.add(node).         }     }     for (DiscoveryNode node : this) {         if (other.nodeExists(node) == false) {             added.add(node).         }     }     return new Delta(other.getMasterNode(), getMasterNode(), localNodeId, Collections.unmodifiableList(removed), Collections.unmodifiableList(added)). }
false;public;0;16;;@Override public String toString() {     StringBuilder sb = new StringBuilder().     sb.append("nodes: \n").     for (DiscoveryNode node : this) {         sb.append("   ").append(node).         if (node == getLocalNode()) {             sb.append(", local").         }         if (node == getMasterNode()) {             sb.append(", master").         }         sb.append("\n").     }     return sb.toString(). }
false;public;0;3;;public boolean hasChanges() {     return masterNodeChanged() || !removed.isEmpty() || !added.isEmpty(). }
false;public;0;3;;public boolean masterNodeChanged() {     return Objects.equals(newMasterNode, previousMasterNode) == false. }
false;public;0;4;;@Nullable public DiscoveryNode previousMasterNode() {     return previousMasterNode. }
false;public;0;4;;@Nullable public DiscoveryNode newMasterNode() {     return newMasterNode. }
false;public;0;3;;public boolean removed() {     return !removed.isEmpty(). }
false;public;0;3;;public List<DiscoveryNode> removedNodes() {     return removed. }
false;public;0;3;;public boolean added() {     return !added.isEmpty(). }
false;public;0;3;;public List<DiscoveryNode> addedNodes() {     return added. }
false;public;0;41;;public String shortSummary() {     final StringBuilder summary = new StringBuilder().     if (masterNodeChanged()) {         summary.append("master node changed {previous [").         if (previousMasterNode() != null) {             summary.append(previousMasterNode()).         }         summary.append("], current [").         if (newMasterNode() != null) {             summary.append(newMasterNode()).         }         summary.append("]}").     }     if (removed()) {         if (summary.length() > 0) {             summary.append(", ").         }         summary.append("removed {").         for (DiscoveryNode node : removedNodes()) {             summary.append(node).append(',').         }         summary.append("}").     }     if (added()) {         // don't print if there is one added, and it is us         if (!(addedNodes().size() == 1 && addedNodes().get(0).getId().equals(localNodeId))) {             if (summary.length() > 0) {                 summary.append(", ").             }             summary.append("added {").             for (DiscoveryNode node : addedNodes()) {                 if (!node.getId().equals(localNodeId)) {                     // don't print ourself                     summary.append(node).append(',').                 }             }             summary.append("}").         }     }     return summary.toString(). }
false;public;1;13;;@Override public void writeTo(StreamOutput out) throws IOException {     if (masterNodeId == null) {         out.writeBoolean(false).     } else {         out.writeBoolean(true).         out.writeString(masterNodeId).     }     out.writeVInt(nodes.size()).     for (DiscoveryNode node : this) {         node.writeTo(out).     } }
false;public,static;2;22;;public static DiscoveryNodes readFrom(StreamInput in, DiscoveryNode localNode) throws IOException {     Builder builder = new Builder().     if (in.readBoolean()) {         builder.masterNodeId(in.readString()).     }     if (localNode != null) {         builder.localNodeId(localNode.getId()).     }     int size = in.readVInt().     for (int i = 0. i < size. i++) {         DiscoveryNode node = new DiscoveryNode(in).         if (localNode != null && node.getId().equals(localNode.getId())) {             // reuse the same instance of our address and local node id for faster equality             node = localNode.         }         // some one already built this and validated it's OK, skip the n2 scans         assert builder.validateAdd(node) == null : "building disco nodes from network doesn't pass preflight: " + builder.validateAdd(node).         builder.putUnsafe(node).     }     return builder.build(). }
false;public,static;2;3;;public static Diff<DiscoveryNodes> readDiffFrom(StreamInput in, DiscoveryNode localNode) throws IOException {     return AbstractDiffable.readDiffFrom(in1 -> readFrom(in1, localNode), in). }
false;public,static;0;3;;public static Builder builder() {     return new Builder(). }
false;public,static;1;3;;public static Builder builder(DiscoveryNodes nodes) {     return new Builder(nodes). }
true;public;1;8;/**  * adds a disco node to the builder. Will throw an {@link IllegalArgumentException} if  * the supplied node doesn't pass the pre-flight checks performed by {@link #validateAdd(DiscoveryNode)}  */ ;/**  * adds a disco node to the builder. Will throw an {@link IllegalArgumentException} if  * the supplied node doesn't pass the pre-flight checks performed by {@link #validateAdd(DiscoveryNode)}  */ public Builder add(DiscoveryNode node) {     final String preflight = validateAdd(node).     if (preflight != null) {         throw new IllegalArgumentException(preflight).     }     putUnsafe(node).     return this. }
true;public;1;3;/**  * Get a node by its id  *  * @param nodeId id of the wanted node  * @return wanted node if it exists. Otherwise <code>null</code>  */ ;/**  * Get a node by its id  *  * @param nodeId id of the wanted node  * @return wanted node if it exists. Otherwise <code>null</code>  */ @Nullable public DiscoveryNode get(String nodeId) {     return nodes.get(nodeId). }
false;private;1;3;;private void putUnsafe(DiscoveryNode node) {     nodes.put(node.getId(), node). }
false;public;1;4;;public Builder remove(String nodeId) {     nodes.remove(nodeId).     return this. }
false;public;1;6;;public Builder remove(DiscoveryNode node) {     if (node.equals(nodes.get(node.getId()))) {         nodes.remove(node.getId()).     }     return this. }
false;public;1;4;;public Builder masterNodeId(String masterNodeId) {     this.masterNodeId = masterNodeId.     return this. }
false;public;1;4;;public Builder localNodeId(String localNodeId) {     this.localNodeId = localNodeId.     return this. }
true;private;1;15;/**  * Checks that a node can be safely added to this node collection.  *  * @return null if all is OK or an error message explaining why a node can not be added.  *  * Note: if this method returns a non-null value, calling {@link #add(DiscoveryNode)} will fail with an  * exception  */ ;/**  * Checks that a node can be safely added to this node collection.  *  * @return null if all is OK or an error message explaining why a node can not be added.  *  * Note: if this method returns a non-null value, calling {@link #add(DiscoveryNode)} will fail with an  * exception  */ private String validateAdd(DiscoveryNode node) {     for (ObjectCursor<DiscoveryNode> cursor : nodes.values()) {         final DiscoveryNode existingNode = cursor.value.         if (node.getAddress().equals(existingNode.getAddress()) && node.getId().equals(existingNode.getId()) == false) {             return "can't add node " + node + ", found existing node " + existingNode + " with same address".         }         if (node.getId().equals(existingNode.getId()) && node.equals(existingNode) == false) {             return "can't add node " + node + ", found existing node " + existingNode + " with the same id but is a different node instance".         }     }     return null. }
false;public;0;40;;public DiscoveryNodes build() {     ImmutableOpenMap.Builder<String, DiscoveryNode> dataNodesBuilder = ImmutableOpenMap.builder().     ImmutableOpenMap.Builder<String, DiscoveryNode> masterNodesBuilder = ImmutableOpenMap.builder().     ImmutableOpenMap.Builder<String, DiscoveryNode> ingestNodesBuilder = ImmutableOpenMap.builder().     Version minNodeVersion = null.     Version maxNodeVersion = null.     Version minNonClientNodeVersion = null.     Version maxNonClientNodeVersion = null.     for (ObjectObjectCursor<String, DiscoveryNode> nodeEntry : nodes) {         if (nodeEntry.value.isDataNode()) {             dataNodesBuilder.put(nodeEntry.key, nodeEntry.value).         }         if (nodeEntry.value.isMasterNode()) {             masterNodesBuilder.put(nodeEntry.key, nodeEntry.value).         }         final Version version = nodeEntry.value.getVersion().         if (nodeEntry.value.isDataNode() || nodeEntry.value.isMasterNode()) {             if (minNonClientNodeVersion == null) {                 minNonClientNodeVersion = version.                 maxNonClientNodeVersion = version.             } else {                 minNonClientNodeVersion = Version.min(minNonClientNodeVersion, version).                 maxNonClientNodeVersion = Version.max(maxNonClientNodeVersion, version).             }         }         if (nodeEntry.value.isIngestNode()) {             ingestNodesBuilder.put(nodeEntry.key, nodeEntry.value).         }         minNodeVersion = minNodeVersion == null ? version : Version.min(minNodeVersion, version).         maxNodeVersion = maxNodeVersion == null ? version : Version.max(maxNodeVersion, version).     }     return new DiscoveryNodes(nodes.build(), dataNodesBuilder.build(), masterNodesBuilder.build(), ingestNodesBuilder.build(), masterNodeId, localNodeId, minNonClientNodeVersion == null ? Version.CURRENT : minNonClientNodeVersion, maxNonClientNodeVersion == null ? Version.CURRENT : maxNonClientNodeVersion, maxNodeVersion == null ? Version.CURRENT : maxNodeVersion, minNodeVersion == null ? Version.CURRENT : minNodeVersion). }
false;public;0;3;;public boolean isLocalNodeElectedMaster() {     return masterNodeId != null && masterNodeId.equals(localNodeId). }
