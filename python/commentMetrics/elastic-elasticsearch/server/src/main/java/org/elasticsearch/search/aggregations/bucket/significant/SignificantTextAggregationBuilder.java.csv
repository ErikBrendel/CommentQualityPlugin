commented;modifiers;parameterAmount;loc;comment;code
false;public;2;6;;@Override public AggregationBuilder parse(String aggregationName, XContentParser parser) throws IOException {     return PARSER.parse(parser, new SignificantTextAggregationBuilder(aggregationName, null), null). }
false;public,static;1;54;;public static Aggregator.Parser getParser(ParseFieldRegistry<SignificanceHeuristicParser> significanceHeuristicParserRegistry) {     ObjectParser<SignificantTextAggregationBuilder, Void> PARSER = new ObjectParser<>(SignificantTextAggregationBuilder.NAME).     PARSER.declareInt(SignificantTextAggregationBuilder::shardSize, TermsAggregationBuilder.SHARD_SIZE_FIELD_NAME).     PARSER.declareLong(SignificantTextAggregationBuilder::minDocCount, TermsAggregationBuilder.MIN_DOC_COUNT_FIELD_NAME).     PARSER.declareLong(SignificantTextAggregationBuilder::shardMinDocCount, TermsAggregationBuilder.SHARD_MIN_DOC_COUNT_FIELD_NAME).     PARSER.declareInt(SignificantTextAggregationBuilder::size, TermsAggregationBuilder.REQUIRED_SIZE_FIELD_NAME).     PARSER.declareString(SignificantTextAggregationBuilder::fieldName, FIELD_NAME).     PARSER.declareStringArray(SignificantTextAggregationBuilder::sourceFieldNames, SOURCE_FIELDS_NAME).     PARSER.declareBoolean(SignificantTextAggregationBuilder::filterDuplicateText, FILTER_DUPLICATE_TEXT_FIELD_NAME).     PARSER.declareObject(SignificantTextAggregationBuilder::backgroundFilter, (p, context) -> AbstractQueryBuilder.parseInnerQueryBuilder(p), SignificantTermsAggregationBuilder.BACKGROUND_FILTER).     PARSER.declareField((b, v) -> b.includeExclude(IncludeExclude.merge(v, b.includeExclude())), IncludeExclude::parseInclude, IncludeExclude.INCLUDE_FIELD, ObjectParser.ValueType.OBJECT_ARRAY_OR_STRING).     PARSER.declareField((b, v) -> b.includeExclude(IncludeExclude.merge(b.includeExclude(), v)), IncludeExclude::parseExclude, IncludeExclude.EXCLUDE_FIELD, ObjectParser.ValueType.STRING_ARRAY).     for (String name : significanceHeuristicParserRegistry.getNames()) {         PARSER.declareObject(SignificantTextAggregationBuilder::significanceHeuristic, (p, context) -> {             SignificanceHeuristicParser significanceHeuristicParser = significanceHeuristicParserRegistry.lookupReturningNullIfNotFound(name, p.getDeprecationHandler()).             return significanceHeuristicParser.parse(p).         }, new ParseField(name)).     }     return new Aggregator.Parser() {          @Override         public AggregationBuilder parse(String aggregationName, XContentParser parser) throws IOException {             return PARSER.parse(parser, new SignificantTextAggregationBuilder(aggregationName, null), null).         }     }. }
false;protected;2;4;;@Override protected AggregationBuilder shallowCopy(Builder factoriesBuilder, Map<String, Object> metaData) {     return new SignificantTextAggregationBuilder(this, factoriesBuilder, metaData). }
false;protected;0;3;;protected TermsAggregator.BucketCountThresholds getBucketCountThresholds() {     return new TermsAggregator.BucketCountThresholds(bucketCountThresholds). }
false;public;0;3;;public TermsAggregator.BucketCountThresholds bucketCountThresholds() {     return bucketCountThresholds. }
false;public;1;5;;@Override public SignificantTextAggregationBuilder subAggregations(Builder subFactories) {     throw new AggregationInitializationException("Aggregator [" + name + "] of type [" + getType() + "] cannot accept sub-aggregations"). }
false;public;1;5;;@Override public SignificantTextAggregationBuilder subAggregation(AggregationBuilder aggregation) {     throw new AggregationInitializationException("Aggregator [" + name + "] of type [" + getType() + "] cannot accept sub-aggregations"). }
false;public;1;9;;public SignificantTextAggregationBuilder bucketCountThresholds(TermsAggregator.BucketCountThresholds bucketCountThresholds) {     if (bucketCountThresholds == null) {         throw new IllegalArgumentException("[bucketCountThresholds] must not be null: [" + name + "]").     }     this.bucketCountThresholds = bucketCountThresholds.     return this. }
true;public;1;8;/**  * Sets the size - indicating how many term buckets should be returned  * (defaults to 10)  */ ;/**  * Sets the size - indicating how many term buckets should be returned  * (defaults to 10)  */ public SignificantTextAggregationBuilder size(int size) {     if (size <= 0) {         throw new IllegalArgumentException("[size] must be greater than 0. Found [" + size + "] in [" + name + "]").     }     bucketCountThresholds.setRequiredSize(size).     return this. }
true;public;1;8;/**  * Sets the shard_size - indicating the number of term buckets each shard  * will return to the coordinating node (the node that coordinates the  * search execution). The higher the shard size is, the more accurate the  * results are.  */ ;/**  * Sets the shard_size - indicating the number of term buckets each shard  * will return to the coordinating node (the node that coordinates the  * search execution). The higher the shard size is, the more accurate the  * results are.  */ public SignificantTextAggregationBuilder shardSize(int shardSize) {     if (shardSize <= 0) {         throw new IllegalArgumentException("[shardSize] must be greater than  0. Found [" + shardSize + "] in [" + name + "]").     }     bucketCountThresholds.setShardSize(shardSize).     return this. }
true;public;1;4;/**  * Sets the name of the text field that will be the subject of this  * aggregation.  */ ;/**  * Sets the name of the text field that will be the subject of this  * aggregation.  */ public SignificantTextAggregationBuilder fieldName(String fieldName) {     this.fieldName = fieldName.     return this. }
true;public;1;4;/**  * Selects the fields to load from _source JSON and analyze.  * If none are specified, the indexed "fieldName" value is assumed  * to also be the name of the JSON field holding the value  */ ;/**  * Selects the fields to load from _source JSON and analyze.  * If none are specified, the indexed "fieldName" value is assumed  * to also be the name of the JSON field holding the value  */ public SignificantTextAggregationBuilder sourceFieldNames(List<String> names) {     this.sourceFieldNames = names.toArray(new String[names.size()]).     return this. }
true;public;1;4;/**  * Control if duplicate paragraphs of text should try be filtered from the  * statistical text analysis. Can improve results but slows down analysis.  * Default is false.  */ ;/**  * Control if duplicate paragraphs of text should try be filtered from the  * statistical text analysis. Can improve results but slows down analysis.  * Default is false.  */ public SignificantTextAggregationBuilder filterDuplicateText(boolean filterDuplicateText) {     this.filterDuplicateText = filterDuplicateText.     return this. }
true;public;1;9;/**  * Set the minimum document count terms should have in order to appear in  * the response.  */ ;/**  * Set the minimum document count terms should have in order to appear in  * the response.  */ public SignificantTextAggregationBuilder minDocCount(long minDocCount) {     if (minDocCount < 0) {         throw new IllegalArgumentException("[minDocCount] must be greater than or equal to 0. Found [" + minDocCount + "] in [" + name + "]").     }     bucketCountThresholds.setMinDocCount(minDocCount).     return this. }
true;public;1;9;/**  * Set the minimum document count terms should have on the shard in order to  * appear in the response.  */ ;/**  * Set the minimum document count terms should have on the shard in order to  * appear in the response.  */ public SignificantTextAggregationBuilder shardMinDocCount(long shardMinDocCount) {     if (shardMinDocCount < 0) {         throw new IllegalArgumentException("[shardMinDocCount] must be greater than or equal to 0. Found [" + shardMinDocCount + "] in [" + name + "]").     }     bucketCountThresholds.setShardMinDocCount(shardMinDocCount).     return this. }
false;public;1;8;;public SignificantTextAggregationBuilder backgroundFilter(QueryBuilder backgroundFilter) {     if (backgroundFilter == null) {         throw new IllegalArgumentException("[backgroundFilter] must not be null: [" + name + "]").     }     this.filterBuilder = backgroundFilter.     return this. }
false;public;0;3;;public QueryBuilder backgroundFilter() {     return filterBuilder. }
true;public;1;4;/**  * Set terms to include and exclude from the aggregation results  */ ;/**  * Set terms to include and exclude from the aggregation results  */ public SignificantTextAggregationBuilder includeExclude(IncludeExclude includeExclude) {     this.includeExclude = includeExclude.     return this. }
true;public;0;3;/**  * Get terms to include and exclude from the aggregation results  */ ;/**  * Get terms to include and exclude from the aggregation results  */ public IncludeExclude includeExclude() {     return includeExclude. }
false;public;1;9;;public SignificantTextAggregationBuilder significanceHeuristic(SignificanceHeuristic significanceHeuristic) {     if (significanceHeuristic == null) {         throw new IllegalArgumentException("[significanceHeuristic] must not be null: [" + name + "]").     }     this.significanceHeuristic = significanceHeuristic.     return this. }
false;public;0;3;;public SignificanceHeuristic significanceHeuristic() {     return significanceHeuristic. }
false;protected;1;10;;@Override protected void doWriteTo(StreamOutput out) throws IOException {     out.writeString(fieldName).     out.writeBoolean(filterDuplicateText).     bucketCountThresholds.writeTo(out).     out.writeOptionalNamedWriteable(filterBuilder).     out.writeOptionalWriteable(includeExclude).     out.writeNamedWriteable(significanceHeuristic).     out.writeOptionalStringArray(sourceFieldNames). }
false;protected;3;9;;@Override protected AggregatorFactory<?> doBuild(SearchContext context, AggregatorFactory<?> parent, Builder subFactoriesBuilder) throws IOException {     SignificanceHeuristic executionHeuristic = this.significanceHeuristic.rewrite(context).     return new SignificantTextAggregatorFactory(name, includeExclude, filterBuilder, bucketCountThresholds, executionHeuristic, context, parent, subFactoriesBuilder, fieldName, sourceFieldNames, filterDuplicateText, metaData). }
false;protected;2;27;;@Override protected XContentBuilder internalXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     bucketCountThresholds.toXContent(builder, params).     if (fieldName != null) {         builder.field(FIELD_NAME.getPreferredName(), fieldName).     }     if (sourceFieldNames != null) {         builder.array(SOURCE_FIELDS_NAME.getPreferredName(), sourceFieldNames).     }     if (filterDuplicateText) {         builder.field(FILTER_DUPLICATE_TEXT_FIELD_NAME.getPreferredName(), filterDuplicateText).     }     if (filterBuilder != null) {         builder.field(SignificantTermsAggregationBuilder.BACKGROUND_FILTER.getPreferredName(), filterBuilder).     }     if (includeExclude != null) {         includeExclude.toXContent(builder, params).     }     significanceHeuristic.toXContent(builder, params).     builder.endObject().     return builder. }
false;protected;0;5;;@Override protected int doHashCode() {     return Objects.hash(bucketCountThresholds, fieldName, filterDuplicateText, filterBuilder, includeExclude, significanceHeuristic, Arrays.hashCode(sourceFieldNames)). }
false;protected;1;11;;@Override protected boolean doEquals(Object obj) {     SignificantTextAggregationBuilder other = (SignificantTextAggregationBuilder) obj.     return Objects.equals(bucketCountThresholds, other.bucketCountThresholds) && Objects.equals(fieldName, other.fieldName) && Arrays.equals(sourceFieldNames, other.sourceFieldNames) && filterDuplicateText == other.filterDuplicateText && Objects.equals(filterBuilder, other.filterBuilder) && Objects.equals(includeExclude, other.includeExclude) && Objects.equals(significanceHeuristic, other.significanceHeuristic). }
false;public;0;4;;@Override public String getType() {     return NAME. }
