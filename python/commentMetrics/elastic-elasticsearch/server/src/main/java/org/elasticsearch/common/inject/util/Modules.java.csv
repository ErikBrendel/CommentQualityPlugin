commented;modifiers;parameterAmount;loc;comment;code
false;public;1;3;;@Override public void configure(Binder binder) { }
true;public,static;1;3;/**  * Returns a builder that creates a module that overlays override modules over the given  * modules. If a key is bound in both sets of modules, only the binding from the override modules  * is kept. This can be used to replace the bindings of a production module with test bindings:  * <pre>  * Module functionalTestModule  *     = Modules.override(new ProductionModule()).with(new TestModule()).  * </pre>  * <p>  * Prefer to write smaller modules that can be reused and tested without overrides.  *  * @param modules the modules whose bindings are open to be overridden  */ ;/**  * Returns a builder that creates a module that overlays override modules over the given  * modules. If a key is bound in both sets of modules, only the binding from the override modules  * is kept. This can be used to replace the bindings of a production module with test bindings:  * <pre>  * Module functionalTestModule  *     = Modules.override(new ProductionModule()).with(new TestModule()).  * </pre>  * <p>  * Prefer to write smaller modules that can be reused and tested without overrides.  *  * @param modules the modules whose bindings are open to be overridden  */ public static OverriddenModuleBuilder override(Module... modules) {     return new RealOverriddenModuleBuilder(Arrays.asList(modules)). }
true;public,static;1;3;/**  * Returns a builder that creates a module that overlays override modules over the given  * modules. If a key is bound in both sets of modules, only the binding from the override modules  * is kept. This can be used to replace the bindings of a production module with test bindings:  * <pre>  * Module functionalTestModule  *     = Modules.override(getProductionModules()).with(getTestModules()).  * </pre>  * <p>  * Prefer to write smaller modules that can be reused and tested without overrides.  *  * @param modules the modules whose bindings are open to be overridden  */ ;/**  * Returns a builder that creates a module that overlays override modules over the given  * modules. If a key is bound in both sets of modules, only the binding from the override modules  * is kept. This can be used to replace the bindings of a production module with test bindings:  * <pre>  * Module functionalTestModule  *     = Modules.override(getProductionModules()).with(getTestModules()).  * </pre>  * <p>  * Prefer to write smaller modules that can be reused and tested without overrides.  *  * @param modules the modules whose bindings are open to be overridden  */ public static OverriddenModuleBuilder override(Iterable<? extends Module> modules) {     return new RealOverriddenModuleBuilder(modules). }
true;public,static;1;3;/**  * Returns a new module that installs all of {@code modules}.  */ ;/**  * Returns a new module that installs all of {@code modules}.  */ public static Module combine(Module... modules) {     return combine(Arrays.asList(modules)). }
false;public;1;7;;@Override public void configure(Binder binder) {     binder = binder.skipSources(getClass()).     for (Module module : modulesSet) {         binder.install(module).     } }
true;public,static;1;12;/**  * Returns a new module that installs all of {@code modules}.  */ ;/**  * Returns a new module that installs all of {@code modules}.  */ public static Module combine(Iterable<? extends Module> modules) {     final Set<? extends Module> modulesSet = newHashSet(modules).     return new Module() {          @Override         public void configure(Binder binder) {             binder = binder.skipSources(getClass()).             for (Module module : modulesSet) {                 binder.install(module).             }         }     }. }
true;;1;1;/**  * See the EDSL example at {@link Modules#override(Module[]) override()}.  */ ;/**  * See the EDSL example at {@link Modules#override(Module[]) override()}.  */ Module with(Module... overrides).
true;;1;1;/**  * See the EDSL example at {@link Modules#override(Module[]) override()}.  */ ;/**  * See the EDSL example at {@link Modules#override(Module[]) override()}.  */ Module with(Iterable<? extends Module> overrides).
false;public;1;4;;@Override public Module with(Module... overrides) {     return with(Arrays.asList(overrides)). }
false;public;1;5;;@Override public <T> Void visit(Binding<T> binding) {     overriddenKeys.add(binding.getKey()).     return super.visit(binding). }
false;public;1;5;;@Override public Void visit(ScopeBinding scopeBinding) {     overridesScopeAnnotations.add(scopeBinding.getAnnotationType()).     return super.visit(scopeBinding). }
false;public;1;5;;@Override public Void visit(PrivateElements privateElements) {     overriddenKeys.addAll(privateElements.getExposedKeys()).     return super.visit(privateElements). }
false;public;1;14;;@Override public <T> Void visit(Binding<T> binding) {     if (!overriddenKeys.remove(binding.getKey())) {         super.visit(binding).         // Record when a scope instance is used in a binding         Scope scope = getScopeInstanceOrNull(binding).         if (scope != null) {             scopeInstancesInUse.put(scope, binding.getSource()).         }     }     return null. }
false;public;1;27;;@Override public Void visit(PrivateElements privateElements) {     PrivateBinder privateBinder = binder.withSource(privateElements.getSource()).newPrivateBinder().     Set<Key<?>> skippedExposes = new HashSet<>().     for (Key<?> key : privateElements.getExposedKeys()) {         if (overriddenKeys.remove(key)) {             skippedExposes.add(key).         } else {             privateBinder.withSource(privateElements.getExposedSource(key)).expose(key).         }     }     // have to search through this set of elements for PrivateElements, recursively     for (Element element : privateElements.getElements()) {         if (element instanceof Binding && skippedExposes.contains(((Binding) element).getKey())) {             continue.         }         element.applyTo(privateBinder).     }     return null. }
false;public;1;5;;@Override public Void visit(ScopeBinding scopeBinding) {     scopeBindings.add(scopeBinding).     return null. }
false;public;1;14;;@Override public Void visit(ScopeBinding scopeBinding) {     if (!overridesScopeAnnotations.remove(scopeBinding.getAnnotationType())) {         super.visit(scopeBinding).     } else {         Object source = scopeInstancesInUse.get(scopeBinding.getScope()).         if (source != null) {             binder().withSource(source).addError("The scope for @%s is bound directly and cannot be overridden.", scopeBinding.getAnnotationType().getSimpleName()).         }     }     return null. }
false;public;0;106;;@Override public void configure() {     final List<Element> elements = Elements.getElements(baseModules).     final List<Element> overrideElements = Elements.getElements(overrides).     final Set<Key> overriddenKeys = new HashSet<>().     final Set<Class<? extends Annotation>> overridesScopeAnnotations = new HashSet<>().     // execute the overrides module, keeping track of which keys and scopes are bound     new ModuleWriter(binder()) {          @Override         public <T> Void visit(Binding<T> binding) {             overriddenKeys.add(binding.getKey()).             return super.visit(binding).         }          @Override         public Void visit(ScopeBinding scopeBinding) {             overridesScopeAnnotations.add(scopeBinding.getAnnotationType()).             return super.visit(scopeBinding).         }          @Override         public Void visit(PrivateElements privateElements) {             overriddenKeys.addAll(privateElements.getExposedKeys()).             return super.visit(privateElements).         }     }.writeAll(overrideElements).     // execute the original module, skipping all scopes and overridden keys. We only skip each     // overridden binding once so things still blow up if the module binds the same thing     // multiple times.     final Map<Scope, Object> scopeInstancesInUse = new HashMap<>().     final List<ScopeBinding> scopeBindings = new ArrayList<>().     new ModuleWriter(binder()) {          @Override         public <T> Void visit(Binding<T> binding) {             if (!overriddenKeys.remove(binding.getKey())) {                 super.visit(binding).                 // Record when a scope instance is used in a binding                 Scope scope = getScopeInstanceOrNull(binding).                 if (scope != null) {                     scopeInstancesInUse.put(scope, binding.getSource()).                 }             }             return null.         }          @Override         public Void visit(PrivateElements privateElements) {             PrivateBinder privateBinder = binder.withSource(privateElements.getSource()).newPrivateBinder().             Set<Key<?>> skippedExposes = new HashSet<>().             for (Key<?> key : privateElements.getExposedKeys()) {                 if (overriddenKeys.remove(key)) {                     skippedExposes.add(key).                 } else {                     privateBinder.withSource(privateElements.getExposedSource(key)).expose(key).                 }             }             // have to search through this set of elements for PrivateElements, recursively             for (Element element : privateElements.getElements()) {                 if (element instanceof Binding && skippedExposes.contains(((Binding) element).getKey())) {                     continue.                 }                 element.applyTo(privateBinder).             }             return null.         }          @Override         public Void visit(ScopeBinding scopeBinding) {             scopeBindings.add(scopeBinding).             return null.         }     }.writeAll(elements).     // execute the scope bindings, skipping scopes that have been overridden. Any scope that     // is overridden and in active use will prompt an error     new ModuleWriter(binder()) {          @Override         public Void visit(ScopeBinding scopeBinding) {             if (!overridesScopeAnnotations.remove(scopeBinding.getAnnotationType())) {                 super.visit(scopeBinding).             } else {                 Object source = scopeInstancesInUse.get(scopeBinding.getScope()).                 if (source != null) {                     binder().withSource(source).addError("The scope for @%s is bound directly and cannot be overridden.", scopeBinding.getAnnotationType().getSimpleName()).                 }             }             return null.         }     }.writeAll(scopeBindings). // TODO: bind the overridden keys using multibinder }
false;public;1;4;;@Override public Scope visitScope(Scope scope) {     return scope. }
false;private;1;8;;private Scope getScopeInstanceOrNull(Binding<?> binding) {     return binding.acceptScopingVisitor(new DefaultBindingScopingVisitor<Scope>() {          @Override         public Scope visitScope(Scope scope) {             return scope.         }     }). }
false;public;1;120;;@Override public Module with(final Iterable<? extends Module> overrides) {     return new AbstractModule() {          @Override         public void configure() {             final List<Element> elements = Elements.getElements(baseModules).             final List<Element> overrideElements = Elements.getElements(overrides).             final Set<Key> overriddenKeys = new HashSet<>().             final Set<Class<? extends Annotation>> overridesScopeAnnotations = new HashSet<>().             // execute the overrides module, keeping track of which keys and scopes are bound             new ModuleWriter(binder()) {                  @Override                 public <T> Void visit(Binding<T> binding) {                     overriddenKeys.add(binding.getKey()).                     return super.visit(binding).                 }                  @Override                 public Void visit(ScopeBinding scopeBinding) {                     overridesScopeAnnotations.add(scopeBinding.getAnnotationType()).                     return super.visit(scopeBinding).                 }                  @Override                 public Void visit(PrivateElements privateElements) {                     overriddenKeys.addAll(privateElements.getExposedKeys()).                     return super.visit(privateElements).                 }             }.writeAll(overrideElements).             // execute the original module, skipping all scopes and overridden keys. We only skip each             // overridden binding once so things still blow up if the module binds the same thing             // multiple times.             final Map<Scope, Object> scopeInstancesInUse = new HashMap<>().             final List<ScopeBinding> scopeBindings = new ArrayList<>().             new ModuleWriter(binder()) {                  @Override                 public <T> Void visit(Binding<T> binding) {                     if (!overriddenKeys.remove(binding.getKey())) {                         super.visit(binding).                         // Record when a scope instance is used in a binding                         Scope scope = getScopeInstanceOrNull(binding).                         if (scope != null) {                             scopeInstancesInUse.put(scope, binding.getSource()).                         }                     }                     return null.                 }                  @Override                 public Void visit(PrivateElements privateElements) {                     PrivateBinder privateBinder = binder.withSource(privateElements.getSource()).newPrivateBinder().                     Set<Key<?>> skippedExposes = new HashSet<>().                     for (Key<?> key : privateElements.getExposedKeys()) {                         if (overriddenKeys.remove(key)) {                             skippedExposes.add(key).                         } else {                             privateBinder.withSource(privateElements.getExposedSource(key)).expose(key).                         }                     }                     // have to search through this set of elements for PrivateElements, recursively                     for (Element element : privateElements.getElements()) {                         if (element instanceof Binding && skippedExposes.contains(((Binding) element).getKey())) {                             continue.                         }                         element.applyTo(privateBinder).                     }                     return null.                 }                  @Override                 public Void visit(ScopeBinding scopeBinding) {                     scopeBindings.add(scopeBinding).                     return null.                 }             }.writeAll(elements).             // execute the scope bindings, skipping scopes that have been overridden. Any scope that             // is overridden and in active use will prompt an error             new ModuleWriter(binder()) {                  @Override                 public Void visit(ScopeBinding scopeBinding) {                     if (!overridesScopeAnnotations.remove(scopeBinding.getAnnotationType())) {                         super.visit(scopeBinding).                     } else {                         Object source = scopeInstancesInUse.get(scopeBinding.getScope()).                         if (source != null) {                             binder().withSource(source).addError("The scope for @%s is bound directly and cannot be overridden.", scopeBinding.getAnnotationType().getSimpleName()).                         }                     }                     return null.                 }             }.writeAll(scopeBindings).         // TODO: bind the overridden keys using multibinder         }          private Scope getScopeInstanceOrNull(Binding<?> binding) {             return binding.acceptScopingVisitor(new DefaultBindingScopingVisitor<Scope>() {                  @Override                 public Scope visitScope(Scope scope) {                     return scope.                 }             }).         }     }. }
false;protected;1;5;;@Override protected Void visitOther(Element element) {     element.applyTo(binder).     return null. }
false;;1;5;;void writeAll(Iterable<? extends Element> elements) {     for (Element element : elements) {         element.acceptVisitor(this).     } }
