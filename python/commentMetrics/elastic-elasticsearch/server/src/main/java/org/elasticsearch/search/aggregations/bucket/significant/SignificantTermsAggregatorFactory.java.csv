commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Get the number of docs in the superset.  */ ;/**  * Get the number of docs in the superset.  */ public long getSupersetNumDocs() {     return supersetNumDocs. }
false;private;1;12;;private FilterableTermsEnum getTermsEnum(String field) throws IOException {     if (termsEnum != null) {         return termsEnum.     }     IndexReader reader = context.searcher().getIndexReader().     if (numberOfAggregatorsCreated > 1) {         termsEnum = new FreqTermsEnum(reader, field, true, false, filter, context.bigArrays()).     } else {         termsEnum = new FilterableTermsEnum(reader, indexedFieldName, PostingsEnum.NONE, filter).     }     return termsEnum. }
false;private;1;22;;private long getBackgroundFrequency(String value) throws IOException {     Query query = fieldType.termQuery(value, context.getQueryShardContext()).     if (query instanceof TermQuery) {         // for types that use the inverted index, we prefer using a caching terms         // enum that will do a better job at reusing index inputs         Term term = ((TermQuery) query).getTerm().         FilterableTermsEnum termsEnum = getTermsEnum(term.field()).         if (termsEnum.seekExact(term.bytes())) {             return termsEnum.docFreq().         } else {             return 0.         }     }     // otherwise do it the naive way     if (filter != null) {         query = new BooleanQuery.Builder().add(query, Occur.FILTER).add(filter, Occur.FILTER).build().     }     return context.searcher().count(query). }
false;public;1;4;;public long getBackgroundFrequency(BytesRef termBytes) throws IOException {     String value = config.format().format(termBytes).toString().     return getBackgroundFrequency(value). }
false;public;1;4;;public long getBackgroundFrequency(long termNum) throws IOException {     String value = config.format().format(termNum).toString().     return getBackgroundFrequency(value). }
false;public;0;4;;@Override public InternalAggregation buildEmptyAggregation() {     return aggregation. }
false;protected;3;12;;@Override protected Aggregator createUnmapped(Aggregator parent, List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData) throws IOException {     final InternalAggregation aggregation = new UnmappedSignificantTerms(name, bucketCountThresholds.getRequiredSize(), bucketCountThresholds.getMinDocCount(), pipelineAggregators, metaData).     return new NonCollectingAggregator(name, context, parent, pipelineAggregators, metaData) {          @Override         public InternalAggregation buildEmptyAggregation() {             return aggregation.         }     }. }
false;protected;5;72;;@Override protected Aggregator doCreateInternal(ValuesSource valuesSource, Aggregator parent, boolean collectsFromSingleBucket, List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData) throws IOException {     if (collectsFromSingleBucket == false) {         return asMultiBucketAggregator(this, context, parent).     }     numberOfAggregatorsCreated++.     BucketCountThresholds bucketCountThresholds = new BucketCountThresholds(this.bucketCountThresholds).     if (bucketCountThresholds.getShardSize() == SignificantTermsAggregationBuilder.DEFAULT_BUCKET_COUNT_THRESHOLDS.getShardSize()) {         // The user has not made a shardSize selection .         // Use default heuristic to avoid any wrong-ranking caused by         // distributed counting         // but request double the usual amount.         // We typically need more than the number of "top" terms requested         // by other aggregations         // as the significance algorithm is in less of a position to         // down-select at shard-level -         // some of the things we want to find have only one occurrence on         // each shard and as         // such are impossible to differentiate from non-significant terms         // at that early stage.         bucketCountThresholds.setShardSize(2 * BucketUtils.suggestShardSideQueueSize(bucketCountThresholds.getRequiredSize())).     }     if (valuesSource instanceof ValuesSource.Bytes) {         ExecutionMode execution = null.         if (executionHint != null) {             execution = ExecutionMode.fromString(executionHint, deprecationLogger).         }         if (valuesSource instanceof ValuesSource.Bytes.WithOrdinals == false) {             execution = ExecutionMode.MAP.         }         if (execution == null) {             execution = ExecutionMode.GLOBAL_ORDINALS.         }         assert execution != null.         DocValueFormat format = config.format().         if ((includeExclude != null) && (includeExclude.isRegexBased()) && format != DocValueFormat.RAW) {             throw new AggregationExecutionException("Aggregation [" + name + "] cannot support regular expression style " + "include/exclude settings as they can only be applied to string fields. Use an array of values for " + "include/exclude clauses").         }         return execution.create(name, factories, valuesSource, format, bucketCountThresholds, includeExclude, context, parent, significanceHeuristic, this, pipelineAggregators, metaData).     }     if ((includeExclude != null) && (includeExclude.isRegexBased())) {         throw new AggregationExecutionException("Aggregation [" + name + "] cannot support regular expression style include/exclude " + "settings as they can only be applied to string fields. Use an array of numeric values for include/exclude clauses " + "used to filter numeric fields").     }     if (valuesSource instanceof ValuesSource.Numeric) {         if (((ValuesSource.Numeric) valuesSource).isFloatingPoint()) {             throw new UnsupportedOperationException("No support for examining floating point numerics").         }         IncludeExclude.LongFilter longFilter = null.         if (includeExclude != null) {             longFilter = includeExclude.convertToLongFilter(config.format()).         }         return new SignificantLongTermsAggregator(name, factories, (ValuesSource.Numeric) valuesSource, config.format(), bucketCountThresholds, context, parent, significanceHeuristic, this, longFilter, pipelineAggregators, metaData).     }     throw new AggregationExecutionException("significant_terms aggregation cannot be applied to field [" + config.fieldContext().field() + "]. It can only be applied to numeric or string fields."). }
false;;12;19;;@Override Aggregator create(String name, AggregatorFactories factories, ValuesSource valuesSource, DocValueFormat format, TermsAggregator.BucketCountThresholds bucketCountThresholds, IncludeExclude includeExclude, SearchContext aggregationContext, Aggregator parent, SignificanceHeuristic significanceHeuristic, SignificantTermsAggregatorFactory termsAggregatorFactory, List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData) throws IOException {     final IncludeExclude.StringFilter filter = includeExclude == null ? null : includeExclude.convertToStringFilter(format).     return new SignificantStringTermsAggregator(name, factories, valuesSource, format, bucketCountThresholds, filter, aggregationContext, parent, significanceHeuristic, termsAggregatorFactory, pipelineAggregators, metaData). }
false;;12;33;;@Override Aggregator create(String name, AggregatorFactories factories, ValuesSource valuesSource, DocValueFormat format, TermsAggregator.BucketCountThresholds bucketCountThresholds, IncludeExclude includeExclude, SearchContext aggregationContext, Aggregator parent, SignificanceHeuristic significanceHeuristic, SignificantTermsAggregatorFactory termsAggregatorFactory, List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData) throws IOException {     final IncludeExclude.OrdinalsFilter filter = includeExclude == null ? null : includeExclude.convertToOrdinalsFilter(format).     boolean remapGlobalOrd = true.     if (Aggregator.descendsFromBucketAggregator(parent) == false && factories == AggregatorFactories.EMPTY && includeExclude == null) {         /**          * We don't need to remap global ords iff this aggregator:          *    - is not a child of a bucket aggregator AND          *    - has no include/exclude rules AND          *    - has no sub-aggregator          */         remapGlobalOrd = false.     }     return new GlobalOrdinalsSignificantTermsAggregator(name, factories, (ValuesSource.Bytes.WithOrdinals.FieldData) valuesSource, format, bucketCountThresholds, filter, aggregationContext, parent, remapGlobalOrd, significanceHeuristic, termsAggregatorFactory, pipelineAggregators, metaData). }
false;public,static;2;11;;public static ExecutionMode fromString(String value, final DeprecationLogger deprecationLogger) {     if ("global_ordinals".equals(value)) {         return GLOBAL_ORDINALS.     } else if ("global_ordinals_hash".equals(value)) {         deprecationLogger.deprecated("global_ordinals_hash is deprecated. Please use [global_ordinals] instead.").         return GLOBAL_ORDINALS.     } else if ("map".equals(value)) {         return MAP.     }     throw new IllegalArgumentException("Unknown `execution_hint`: [" + value + "], expected any of [map, global_ordinals]"). }
false;abstract;12;12;;abstract Aggregator create(String name, AggregatorFactories factories, ValuesSource valuesSource, DocValueFormat format, TermsAggregator.BucketCountThresholds bucketCountThresholds, IncludeExclude includeExclude, SearchContext aggregationContext, Aggregator parent, SignificanceHeuristic significanceHeuristic, SignificantTermsAggregatorFactory termsAggregatorFactory, List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData) throws IOException.
false;public;0;4;;@Override public String toString() {     return parseField.getPreferredName(). }
false;public;0;10;;@Override public void close() {     try {         if (termsEnum instanceof Releasable) {             ((Releasable) termsEnum).close().         }     } finally {         termsEnum = null.     } }
