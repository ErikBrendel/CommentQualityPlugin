commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String getName() {     return "cluster_health_action". }
false;public;2;30;;@Override public RestChannelConsumer prepareRequest(final RestRequest request, final NodeClient client) throws IOException {     final ClusterHealthRequest clusterHealthRequest = clusterHealthRequest(Strings.splitStringByCommaToArray(request.param("index"))).     clusterHealthRequest.indicesOptions(IndicesOptions.fromRequest(request, clusterHealthRequest.indicesOptions())).     clusterHealthRequest.local(request.paramAsBoolean("local", clusterHealthRequest.local())).     clusterHealthRequest.masterNodeTimeout(request.paramAsTime("master_timeout", clusterHealthRequest.masterNodeTimeout())).     clusterHealthRequest.timeout(request.paramAsTime("timeout", clusterHealthRequest.timeout())).     String waitForStatus = request.param("wait_for_status").     if (waitForStatus != null) {         clusterHealthRequest.waitForStatus(ClusterHealthStatus.valueOf(waitForStatus.toUpperCase(Locale.ROOT))).     }     clusterHealthRequest.waitForNoRelocatingShards(request.paramAsBoolean("wait_for_no_relocating_shards", clusterHealthRequest.waitForNoRelocatingShards())).     clusterHealthRequest.waitForNoInitializingShards(request.paramAsBoolean("wait_for_no_initializing_shards", clusterHealthRequest.waitForNoRelocatingShards())).     if (request.hasParam("wait_for_relocating_shards")) {         // wait_for_relocating_shards has been removed in favor of wait_for_no_relocating_shards         throw new IllegalArgumentException("wait_for_relocating_shards has been removed, " + "use wait_for_no_relocating_shards [true/false] instead").     }     String waitForActiveShards = request.param("wait_for_active_shards").     if (waitForActiveShards != null) {         clusterHealthRequest.waitForActiveShards(ActiveShardCount.parseString(waitForActiveShards)).     }     clusterHealthRequest.waitForNodes(request.param("wait_for_nodes", clusterHealthRequest.waitForNodes())).     if (request.param("wait_for_events") != null) {         clusterHealthRequest.waitForEvents(Priority.valueOf(request.param("wait_for_events").toUpperCase(Locale.ROOT))).     }     return channel -> client.admin().cluster().health(clusterHealthRequest, new RestStatusToXContentListener<>(channel)). }
false;protected;0;4;;@Override protected Set<String> responseParams() {     return RESPONSE_PARAMS. }
false;public;0;4;;@Override public boolean canTripCircuitBreaker() {     return false. }
