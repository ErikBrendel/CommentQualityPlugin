commented;modifiers;parameterAmount;loc;comment;code
false;public;1;74;;public void performStateRecovery(final GatewayStateRecoveredListener listener) throws GatewayException {     final String[] nodesIds = clusterService.state().nodes().getMasterNodes().keys().toArray(String.class).     logger.trace("performing state recovery from {}", Arrays.toString(nodesIds)).     final TransportNodesListGatewayMetaState.NodesGatewayMetaState nodesState = listGatewayMetaState.list(nodesIds, null).actionGet().     final int requiredAllocation = Math.max(1, minimumMasterNodes).     if (nodesState.hasFailures()) {         for (final FailedNodeException failedNodeException : nodesState.failures()) {             logger.warn("failed to fetch state from node", failedNodeException).         }     }     final ObjectFloatHashMap<Index> indices = new ObjectFloatHashMap<>().     MetaData electedGlobalState = null.     int found = 0.     for (final TransportNodesListGatewayMetaState.NodeGatewayMetaState nodeState : nodesState.getNodes()) {         if (nodeState.metaData() == null) {             continue.         }         found++.         if (electedGlobalState == null) {             electedGlobalState = nodeState.metaData().         } else if (nodeState.metaData().version() > electedGlobalState.version()) {             electedGlobalState = nodeState.metaData().         }         for (final ObjectCursor<IndexMetaData> cursor : nodeState.metaData().indices().values()) {             indices.addTo(cursor.value.getIndex(), 1).         }     }     if (found < requiredAllocation) {         listener.onFailure("found [" + found + "] metadata states, required [" + requiredAllocation + "]").         return.     }     // update the global state, and clean the indices, we elect them in the next phase     final MetaData.Builder metaDataBuilder = MetaData.builder(electedGlobalState).removeAllIndices().     assert !indices.containsKey(null).     final Object[] keys = indices.keys.     for (int i = 0. i < keys.length. i++) {         if (keys[i] != null) {             final Index index = (Index) keys[i].             IndexMetaData electedIndexMetaData = null.             int indexMetaDataCount = 0.             for (final TransportNodesListGatewayMetaState.NodeGatewayMetaState nodeState : nodesState.getNodes()) {                 if (nodeState.metaData() == null) {                     continue.                 }                 final IndexMetaData indexMetaData = nodeState.metaData().index(index).                 if (indexMetaData == null) {                     continue.                 }                 if (electedIndexMetaData == null) {                     electedIndexMetaData = indexMetaData.                 } else if (indexMetaData.getVersion() > electedIndexMetaData.getVersion()) {                     electedIndexMetaData = indexMetaData.                 }                 indexMetaDataCount++.             }             if (electedIndexMetaData != null) {                 if (indexMetaDataCount < requiredAllocation) {                     logger.debug("[{}] found [{}], required [{}], not adding", index, indexMetaDataCount, requiredAllocation).                 }                 // TODO if this logging statement is correct then we are missing an else here                 metaDataBuilder.put(electedIndexMetaData, false).             }         }     }     ClusterState recoveredState = Function.<ClusterState>identity().andThen(state -> ClusterStateUpdaters.upgradeAndArchiveUnknownOrInvalidSettings(state, clusterService.getClusterSettings())).apply(ClusterState.builder(clusterService.getClusterName()).metaData(metaDataBuilder).build()).     listener.onSuccess(recoveredState). }
false;;1;1;;void onSuccess(ClusterState build).
false;;1;1;;void onFailure(String s).
