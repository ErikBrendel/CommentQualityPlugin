commented;modifiers;parameterAmount;loc;comment;code
false;public;0;7;;@Override public ScoreMode scoreMode() {     if (valuesSource != null && valuesSource.needsScores()) {         return ScoreMode.COMPLETE.     }     return super.scoreMode(). }
false;public;2;25;;@Override public void collect(int doc, long bucket) throws IOException {     assert bucket == 0.     if (values.advanceExact(doc)) {         final int valuesCount = values.docValueCount().         double previousKey = Double.NEGATIVE_INFINITY.         for (int i = 0. i < valuesCount. ++i) {             double value = values.nextValue().             double key = Math.floor((value - offset) / interval).             assert key >= previousKey.             if (key == previousKey) {                 continue.             }             long bucketOrd = bucketOrds.add(Double.doubleToLongBits(key)).             if (bucketOrd < 0) {                 // already seen                 bucketOrd = -1 - bucketOrd.                 collectExistingBucket(sub, doc, bucketOrd).             } else {                 collectBucket(sub, doc, bucketOrd).             }             previousKey = key.         }     } }
false;public;2;36;;@Override public LeafBucketCollector getLeafCollector(LeafReaderContext ctx, final LeafBucketCollector sub) throws IOException {     if (valuesSource == null) {         return LeafBucketCollector.NO_OP_COLLECTOR.     }     final SortedNumericDoubleValues values = valuesSource.doubleValues(ctx).     return new LeafBucketCollectorBase(sub, values) {          @Override         public void collect(int doc, long bucket) throws IOException {             assert bucket == 0.             if (values.advanceExact(doc)) {                 final int valuesCount = values.docValueCount().                 double previousKey = Double.NEGATIVE_INFINITY.                 for (int i = 0. i < valuesCount. ++i) {                     double value = values.nextValue().                     double key = Math.floor((value - offset) / interval).                     assert key >= previousKey.                     if (key == previousKey) {                         continue.                     }                     long bucketOrd = bucketOrds.add(Double.doubleToLongBits(key)).                     if (bucketOrd < 0) {                         // already seen                         bucketOrd = -1 - bucketOrd.                         collectExistingBucket(sub, doc, bucketOrd).                     } else {                         collectBucket(sub, doc, bucketOrd).                     }                     previousKey = key.                 }             }         }     }. }
false;public;1;21;;@Override public InternalAggregation buildAggregation(long bucket) throws IOException {     assert bucket == 0.     consumeBucketsAndMaybeBreak((int) bucketOrds.size()).     List<InternalHistogram.Bucket> buckets = new ArrayList<>((int) bucketOrds.size()).     for (long i = 0. i < bucketOrds.size(). i++) {         double roundKey = Double.longBitsToDouble(bucketOrds.get(i)).         double key = roundKey * interval + offset.         buckets.add(new InternalHistogram.Bucket(key, bucketDocCount(i), keyed, formatter, bucketAggregations(i))).     }     // the contract of the histogram aggregation is that shards must return buckets ordered by key in ascending order     CollectionUtil.introSort(buckets, BucketOrder.key(true).comparator(this)).     EmptyBucketInfo emptyBucketInfo = null.     if (minDocCount == 0) {         emptyBucketInfo = new EmptyBucketInfo(interval, offset, minBound, maxBound, buildEmptySubAggregations()).     }     return new InternalHistogram(name, buckets, order, minDocCount, emptyBucketInfo, formatter, keyed, pipelineAggregators(), metaData()). }
false;public;0;9;;@Override public InternalAggregation buildEmptyAggregation() {     EmptyBucketInfo emptyBucketInfo = null.     if (minDocCount == 0) {         emptyBucketInfo = new EmptyBucketInfo(interval, offset, minBound, maxBound, buildEmptySubAggregations()).     }     return new InternalHistogram(name, Collections.emptyList(), order, minDocCount, emptyBucketInfo, formatter, keyed, pipelineAggregators(), metaData()). }
false;public;0;4;;@Override public void doClose() {     Releasables.close(bucketOrds). }
