# id;timestamp;commentText;codeText;commentWords;codeWords
KeyStoreWrapper -> public static Path keystorePath(Path configDir);1524684173;Returns a path representing the ES keystore in the given config dir.;public static Path keystorePath(Path configDir) {_        return configDir.resolve(KEYSTORE_FILENAME)__    };returns,a,path,representing,the,es,keystore,in,the,given,config,dir;public,static,path,keystore,path,path,config,dir,return,config,dir,resolve
KeyStoreWrapper -> public static Path keystorePath(Path configDir);1525645056;Returns a path representing the ES keystore in the given config dir.;public static Path keystorePath(Path configDir) {_        return configDir.resolve(KEYSTORE_FILENAME)__    };returns,a,path,representing,the,es,keystore,in,the,given,config,dir;public,static,path,keystore,path,path,config,dir,return,config,dir,resolve
KeyStoreWrapper -> public static Path keystorePath(Path configDir);1526374795;Returns a path representing the ES keystore in the given config dir.;public static Path keystorePath(Path configDir) {_        return configDir.resolve(KEYSTORE_FILENAME)__    };returns,a,path,representing,the,es,keystore,in,the,given,config,dir;public,static,path,keystore,path,path,config,dir,return,config,dir,resolve
KeyStoreWrapper -> public static Path keystorePath(Path configDir);1529341607;Returns a path representing the ES keystore in the given config dir.;public static Path keystorePath(Path configDir) {_        return configDir.resolve(KEYSTORE_FILENAME)__    };returns,a,path,representing,the,es,keystore,in,the,given,config,dir;public,static,path,keystore,path,path,config,dir,return,config,dir,resolve
KeyStoreWrapper -> public static Path keystorePath(Path configDir);1532511554;Returns a path representing the ES keystore in the given config dir.;public static Path keystorePath(Path configDir) {_        return configDir.resolve(KEYSTORE_FILENAME)__    };returns,a,path,representing,the,es,keystore,in,the,given,config,dir;public,static,path,keystore,path,path,config,dir,return,config,dir,resolve
KeyStoreWrapper -> public static Path keystorePath(Path configDir);1533063033;Returns a path representing the ES keystore in the given config dir.;public static Path keystorePath(Path configDir) {_        return configDir.resolve(KEYSTORE_FILENAME)__    };returns,a,path,representing,the,es,keystore,in,the,given,config,dir;public,static,path,keystore,path,path,config,dir,return,config,dir,resolve
KeyStoreWrapper -> void setString(String setting, char[] value);1524684173;Set a string setting.;void setString(String setting, char[] value) {_        assert isLoaded()__        validateSettingName(setting)___        ByteBuffer byteBuffer = StandardCharsets.UTF_8.encode(CharBuffer.wrap(value))__        byte[] bytes = Arrays.copyOfRange(byteBuffer.array(), byteBuffer.position(), byteBuffer.limit())__        Entry oldEntry = entries.get().put(setting, new Entry(EntryType.STRING, bytes))__        if (oldEntry != null) {_            Arrays.fill(oldEntry.bytes, (byte)0)__        }_    };set,a,string,setting;void,set,string,string,setting,char,value,assert,is,loaded,validate,setting,name,setting,byte,buffer,byte,buffer,standard,charsets,encode,char,buffer,wrap,value,byte,bytes,arrays,copy,of,range,byte,buffer,array,byte,buffer,position,byte,buffer,limit,entry,old,entry,entries,get,put,setting,new,entry,entry,type,string,bytes,if,old,entry,null,arrays,fill,old,entry,bytes,byte,0
KeyStoreWrapper -> void setString(String setting, char[] value);1525645056;Set a string setting.;void setString(String setting, char[] value) {_        assert isLoaded()__        validateSettingName(setting)___        ByteBuffer byteBuffer = StandardCharsets.UTF_8.encode(CharBuffer.wrap(value))__        byte[] bytes = Arrays.copyOfRange(byteBuffer.array(), byteBuffer.position(), byteBuffer.limit())__        Entry oldEntry = entries.get().put(setting, new Entry(EntryType.STRING, bytes))__        if (oldEntry != null) {_            Arrays.fill(oldEntry.bytes, (byte)0)__        }_    };set,a,string,setting;void,set,string,string,setting,char,value,assert,is,loaded,validate,setting,name,setting,byte,buffer,byte,buffer,standard,charsets,encode,char,buffer,wrap,value,byte,bytes,arrays,copy,of,range,byte,buffer,array,byte,buffer,position,byte,buffer,limit,entry,old,entry,entries,get,put,setting,new,entry,entry,type,string,bytes,if,old,entry,null,arrays,fill,old,entry,bytes,byte,0
KeyStoreWrapper -> public static KeyStoreWrapper load(Path configDir) throws IOException;1524684173;Loads information about the Elasticsearch keystore from the provided config directory.__{@link #decrypt(char[])} must be called before reading or writing any entries._Returns {@code null} if no keystore exists.;public static KeyStoreWrapper load(Path configDir) throws IOException {_        Path keystoreFile = keystorePath(configDir)__        if (Files.exists(keystoreFile) == false) {_            return null__        }__        SimpleFSDirectory directory = new SimpleFSDirectory(configDir)__        try (IndexInput indexInput = directory.openInput(KEYSTORE_FILENAME, IOContext.READONCE)) {_            ChecksumIndexInput input = new BufferedChecksumIndexInput(indexInput)__            int formatVersion = CodecUtil.checkHeader(input, KEYSTORE_FILENAME, MIN_FORMAT_VERSION, FORMAT_VERSION)__            byte hasPasswordByte = input.readByte()__            boolean hasPassword = hasPasswordByte == 1__            if (hasPassword == false && hasPasswordByte != 0) {_                throw new IllegalStateException("hasPassword boolean is corrupt: "_                    + String.format(Locale.ROOT, "%02x", hasPasswordByte))__            }__            if (formatVersion <= 2) {_                String type = input.readString()__                if (type.equals("PKCS12") == false) {_                    throw new IllegalStateException("Corrupted legacy keystore string encryption algorithm")__                }__                final String stringKeyAlgo = input.readString()__                if (stringKeyAlgo.equals("PBE") == false) {_                    throw new IllegalStateException("Corrupted legacy keystore string encryption algorithm")__                }_                if (formatVersion == 2) {_                    final String fileKeyAlgo = input.readString()__                    if (fileKeyAlgo.equals("PBE") == false) {_                        throw new IllegalStateException("Corrupted legacy keystore file encryption algorithm")__                    }_                }_            }__            final byte[] dataBytes__            if (formatVersion == 2) {_                _                _                _                _                Map<String, String> settingTypes = input.readMapOfStrings()__                ByteArrayOutputStream bytes = new ByteArrayOutputStream()__                try (DataOutputStream output = new DataOutputStream(bytes)) {_                    output.writeInt(settingTypes.size())__                    for (Map.Entry<String, String> entry : settingTypes.entrySet()) {_                        output.writeUTF(entry.getKey())__                        output.writeUTF(entry.getValue())__                    }_                    int keystoreLen = input.readInt()__                    byte[] keystoreBytes = new byte[keystoreLen]__                    input.readBytes(keystoreBytes, 0, keystoreLen)__                    output.write(keystoreBytes)__                }_                dataBytes = bytes.toByteArray()__            } else {_                int dataBytesLen = input.readInt()__                dataBytes = new byte[dataBytesLen]__                input.readBytes(dataBytes, 0, dataBytesLen)__            }__            CodecUtil.checkFooter(input)__            return new KeyStoreWrapper(formatVersion, hasPassword, dataBytes)__        }_    };loads,information,about,the,elasticsearch,keystore,from,the,provided,config,directory,link,decrypt,char,must,be,called,before,reading,or,writing,any,entries,returns,code,null,if,no,keystore,exists;public,static,key,store,wrapper,load,path,config,dir,throws,ioexception,path,keystore,file,keystore,path,config,dir,if,files,exists,keystore,file,false,return,null,simple,fsdirectory,directory,new,simple,fsdirectory,config,dir,try,index,input,index,input,directory,open,input,iocontext,readonce,checksum,index,input,input,new,buffered,checksum,index,input,index,input,int,format,version,codec,util,check,header,input,byte,has,password,byte,input,read,byte,boolean,has,password,has,password,byte,1,if,has,password,false,has,password,byte,0,throw,new,illegal,state,exception,has,password,boolean,is,corrupt,string,format,locale,root,02x,has,password,byte,if,format,version,2,string,type,input,read,string,if,type,equals,pkcs12,false,throw,new,illegal,state,exception,corrupted,legacy,keystore,string,encryption,algorithm,final,string,string,key,algo,input,read,string,if,string,key,algo,equals,pbe,false,throw,new,illegal,state,exception,corrupted,legacy,keystore,string,encryption,algorithm,if,format,version,2,final,string,file,key,algo,input,read,string,if,file,key,algo,equals,pbe,false,throw,new,illegal,state,exception,corrupted,legacy,keystore,file,encryption,algorithm,final,byte,data,bytes,if,format,version,2,map,string,string,setting,types,input,read,map,of,strings,byte,array,output,stream,bytes,new,byte,array,output,stream,try,data,output,stream,output,new,data,output,stream,bytes,output,write,int,setting,types,size,for,map,entry,string,string,entry,setting,types,entry,set,output,write,utf,entry,get,key,output,write,utf,entry,get,value,int,keystore,len,input,read,int,byte,keystore,bytes,new,byte,keystore,len,input,read,bytes,keystore,bytes,0,keystore,len,output,write,keystore,bytes,data,bytes,bytes,to,byte,array,else,int,data,bytes,len,input,read,int,data,bytes,new,byte,data,bytes,len,input,read,bytes,data,bytes,0,data,bytes,len,codec,util,check,footer,input,return,new,key,store,wrapper,format,version,has,password,data,bytes
KeyStoreWrapper -> public static KeyStoreWrapper load(Path configDir) throws IOException;1525645056;Loads information about the Elasticsearch keystore from the provided config directory.__{@link #decrypt(char[])} must be called before reading or writing any entries._Returns {@code null} if no keystore exists.;public static KeyStoreWrapper load(Path configDir) throws IOException {_        Path keystoreFile = keystorePath(configDir)__        if (Files.exists(keystoreFile) == false) {_            return null__        }__        SimpleFSDirectory directory = new SimpleFSDirectory(configDir)__        try (IndexInput indexInput = directory.openInput(KEYSTORE_FILENAME, IOContext.READONCE)) {_            ChecksumIndexInput input = new BufferedChecksumIndexInput(indexInput)__            int formatVersion = CodecUtil.checkHeader(input, KEYSTORE_FILENAME, MIN_FORMAT_VERSION, FORMAT_VERSION)__            byte hasPasswordByte = input.readByte()__            boolean hasPassword = hasPasswordByte == 1__            if (hasPassword == false && hasPasswordByte != 0) {_                throw new IllegalStateException("hasPassword boolean is corrupt: "_                    + String.format(Locale.ROOT, "%02x", hasPasswordByte))__            }__            if (formatVersion <= 2) {_                String type = input.readString()__                if (type.equals("PKCS12") == false) {_                    throw new IllegalStateException("Corrupted legacy keystore string encryption algorithm")__                }__                final String stringKeyAlgo = input.readString()__                if (stringKeyAlgo.equals("PBE") == false) {_                    throw new IllegalStateException("Corrupted legacy keystore string encryption algorithm")__                }_                if (formatVersion == 2) {_                    final String fileKeyAlgo = input.readString()__                    if (fileKeyAlgo.equals("PBE") == false) {_                        throw new IllegalStateException("Corrupted legacy keystore file encryption algorithm")__                    }_                }_            }__            final byte[] dataBytes__            if (formatVersion == 2) {_                _                _                _                _                Map<String, String> settingTypes = input.readMapOfStrings()__                ByteArrayOutputStream bytes = new ByteArrayOutputStream()__                try (DataOutputStream output = new DataOutputStream(bytes)) {_                    output.writeInt(settingTypes.size())__                    for (Map.Entry<String, String> entry : settingTypes.entrySet()) {_                        output.writeUTF(entry.getKey())__                        output.writeUTF(entry.getValue())__                    }_                    int keystoreLen = input.readInt()__                    byte[] keystoreBytes = new byte[keystoreLen]__                    input.readBytes(keystoreBytes, 0, keystoreLen)__                    output.write(keystoreBytes)__                }_                dataBytes = bytes.toByteArray()__            } else {_                int dataBytesLen = input.readInt()__                dataBytes = new byte[dataBytesLen]__                input.readBytes(dataBytes, 0, dataBytesLen)__            }__            CodecUtil.checkFooter(input)__            return new KeyStoreWrapper(formatVersion, hasPassword, dataBytes)__        }_    };loads,information,about,the,elasticsearch,keystore,from,the,provided,config,directory,link,decrypt,char,must,be,called,before,reading,or,writing,any,entries,returns,code,null,if,no,keystore,exists;public,static,key,store,wrapper,load,path,config,dir,throws,ioexception,path,keystore,file,keystore,path,config,dir,if,files,exists,keystore,file,false,return,null,simple,fsdirectory,directory,new,simple,fsdirectory,config,dir,try,index,input,index,input,directory,open,input,iocontext,readonce,checksum,index,input,input,new,buffered,checksum,index,input,index,input,int,format,version,codec,util,check,header,input,byte,has,password,byte,input,read,byte,boolean,has,password,has,password,byte,1,if,has,password,false,has,password,byte,0,throw,new,illegal,state,exception,has,password,boolean,is,corrupt,string,format,locale,root,02x,has,password,byte,if,format,version,2,string,type,input,read,string,if,type,equals,pkcs12,false,throw,new,illegal,state,exception,corrupted,legacy,keystore,string,encryption,algorithm,final,string,string,key,algo,input,read,string,if,string,key,algo,equals,pbe,false,throw,new,illegal,state,exception,corrupted,legacy,keystore,string,encryption,algorithm,if,format,version,2,final,string,file,key,algo,input,read,string,if,file,key,algo,equals,pbe,false,throw,new,illegal,state,exception,corrupted,legacy,keystore,file,encryption,algorithm,final,byte,data,bytes,if,format,version,2,map,string,string,setting,types,input,read,map,of,strings,byte,array,output,stream,bytes,new,byte,array,output,stream,try,data,output,stream,output,new,data,output,stream,bytes,output,write,int,setting,types,size,for,map,entry,string,string,entry,setting,types,entry,set,output,write,utf,entry,get,key,output,write,utf,entry,get,value,int,keystore,len,input,read,int,byte,keystore,bytes,new,byte,keystore,len,input,read,bytes,keystore,bytes,0,keystore,len,output,write,keystore,bytes,data,bytes,bytes,to,byte,array,else,int,data,bytes,len,input,read,int,data,bytes,new,byte,data,bytes,len,input,read,bytes,data,bytes,0,data,bytes,len,codec,util,check,footer,input,return,new,key,store,wrapper,format,version,has,password,data,bytes
KeyStoreWrapper -> public static KeyStoreWrapper load(Path configDir) throws IOException;1526374795;Loads information about the Elasticsearch keystore from the provided config directory.__{@link #decrypt(char[])} must be called before reading or writing any entries._Returns {@code null} if no keystore exists.;public static KeyStoreWrapper load(Path configDir) throws IOException {_        Path keystoreFile = keystorePath(configDir)__        if (Files.exists(keystoreFile) == false) {_            return null__        }__        SimpleFSDirectory directory = new SimpleFSDirectory(configDir)__        try (IndexInput indexInput = directory.openInput(KEYSTORE_FILENAME, IOContext.READONCE)) {_            ChecksumIndexInput input = new BufferedChecksumIndexInput(indexInput)__            int formatVersion = CodecUtil.checkHeader(input, KEYSTORE_FILENAME, MIN_FORMAT_VERSION, FORMAT_VERSION)__            byte hasPasswordByte = input.readByte()__            boolean hasPassword = hasPasswordByte == 1__            if (hasPassword == false && hasPasswordByte != 0) {_                throw new IllegalStateException("hasPassword boolean is corrupt: "_                    + String.format(Locale.ROOT, "%02x", hasPasswordByte))__            }__            if (formatVersion <= 2) {_                String type = input.readString()__                if (type.equals("PKCS12") == false) {_                    throw new IllegalStateException("Corrupted legacy keystore string encryption algorithm")__                }__                final String stringKeyAlgo = input.readString()__                if (stringKeyAlgo.equals("PBE") == false) {_                    throw new IllegalStateException("Corrupted legacy keystore string encryption algorithm")__                }_                if (formatVersion == 2) {_                    final String fileKeyAlgo = input.readString()__                    if (fileKeyAlgo.equals("PBE") == false) {_                        throw new IllegalStateException("Corrupted legacy keystore file encryption algorithm")__                    }_                }_            }__            final byte[] dataBytes__            if (formatVersion == 2) {_                _                _                _                _                Map<String, String> settingTypes = input.readMapOfStrings()__                ByteArrayOutputStream bytes = new ByteArrayOutputStream()__                try (DataOutputStream output = new DataOutputStream(bytes)) {_                    output.writeInt(settingTypes.size())__                    for (Map.Entry<String, String> entry : settingTypes.entrySet()) {_                        output.writeUTF(entry.getKey())__                        output.writeUTF(entry.getValue())__                    }_                    int keystoreLen = input.readInt()__                    byte[] keystoreBytes = new byte[keystoreLen]__                    input.readBytes(keystoreBytes, 0, keystoreLen)__                    output.write(keystoreBytes)__                }_                dataBytes = bytes.toByteArray()__            } else {_                int dataBytesLen = input.readInt()__                dataBytes = new byte[dataBytesLen]__                input.readBytes(dataBytes, 0, dataBytesLen)__            }__            CodecUtil.checkFooter(input)__            return new KeyStoreWrapper(formatVersion, hasPassword, dataBytes)__        }_    };loads,information,about,the,elasticsearch,keystore,from,the,provided,config,directory,link,decrypt,char,must,be,called,before,reading,or,writing,any,entries,returns,code,null,if,no,keystore,exists;public,static,key,store,wrapper,load,path,config,dir,throws,ioexception,path,keystore,file,keystore,path,config,dir,if,files,exists,keystore,file,false,return,null,simple,fsdirectory,directory,new,simple,fsdirectory,config,dir,try,index,input,index,input,directory,open,input,iocontext,readonce,checksum,index,input,input,new,buffered,checksum,index,input,index,input,int,format,version,codec,util,check,header,input,byte,has,password,byte,input,read,byte,boolean,has,password,has,password,byte,1,if,has,password,false,has,password,byte,0,throw,new,illegal,state,exception,has,password,boolean,is,corrupt,string,format,locale,root,02x,has,password,byte,if,format,version,2,string,type,input,read,string,if,type,equals,pkcs12,false,throw,new,illegal,state,exception,corrupted,legacy,keystore,string,encryption,algorithm,final,string,string,key,algo,input,read,string,if,string,key,algo,equals,pbe,false,throw,new,illegal,state,exception,corrupted,legacy,keystore,string,encryption,algorithm,if,format,version,2,final,string,file,key,algo,input,read,string,if,file,key,algo,equals,pbe,false,throw,new,illegal,state,exception,corrupted,legacy,keystore,file,encryption,algorithm,final,byte,data,bytes,if,format,version,2,map,string,string,setting,types,input,read,map,of,strings,byte,array,output,stream,bytes,new,byte,array,output,stream,try,data,output,stream,output,new,data,output,stream,bytes,output,write,int,setting,types,size,for,map,entry,string,string,entry,setting,types,entry,set,output,write,utf,entry,get,key,output,write,utf,entry,get,value,int,keystore,len,input,read,int,byte,keystore,bytes,new,byte,keystore,len,input,read,bytes,keystore,bytes,0,keystore,len,output,write,keystore,bytes,data,bytes,bytes,to,byte,array,else,int,data,bytes,len,input,read,int,data,bytes,new,byte,data,bytes,len,input,read,bytes,data,bytes,0,data,bytes,len,codec,util,check,footer,input,return,new,key,store,wrapper,format,version,has,password,data,bytes
KeyStoreWrapper -> public static KeyStoreWrapper load(Path configDir) throws IOException;1529341607;Loads information about the Elasticsearch keystore from the provided config directory.__{@link #decrypt(char[])} must be called before reading or writing any entries._Returns {@code null} if no keystore exists.;public static KeyStoreWrapper load(Path configDir) throws IOException {_        Path keystoreFile = keystorePath(configDir)__        if (Files.exists(keystoreFile) == false) {_            return null__        }__        SimpleFSDirectory directory = new SimpleFSDirectory(configDir)__        try (IndexInput indexInput = directory.openInput(KEYSTORE_FILENAME, IOContext.READONCE)) {_            ChecksumIndexInput input = new BufferedChecksumIndexInput(indexInput)__            int formatVersion = CodecUtil.checkHeader(input, KEYSTORE_FILENAME, MIN_FORMAT_VERSION, FORMAT_VERSION)__            byte hasPasswordByte = input.readByte()__            boolean hasPassword = hasPasswordByte == 1__            if (hasPassword == false && hasPasswordByte != 0) {_                throw new IllegalStateException("hasPassword boolean is corrupt: "_                    + String.format(Locale.ROOT, "%02x", hasPasswordByte))__            }__            if (formatVersion <= 2) {_                String type = input.readString()__                if (type.equals("PKCS12") == false) {_                    throw new IllegalStateException("Corrupted legacy keystore string encryption algorithm")__                }__                final String stringKeyAlgo = input.readString()__                if (stringKeyAlgo.equals("PBE") == false) {_                    throw new IllegalStateException("Corrupted legacy keystore string encryption algorithm")__                }_                if (formatVersion == 2) {_                    final String fileKeyAlgo = input.readString()__                    if (fileKeyAlgo.equals("PBE") == false) {_                        throw new IllegalStateException("Corrupted legacy keystore file encryption algorithm")__                    }_                }_            }__            final byte[] dataBytes__            if (formatVersion == 2) {_                _                _                _                _                Map<String, String> settingTypes = input.readMapOfStrings()__                ByteArrayOutputStream bytes = new ByteArrayOutputStream()__                try (DataOutputStream output = new DataOutputStream(bytes)) {_                    output.writeInt(settingTypes.size())__                    for (Map.Entry<String, String> entry : settingTypes.entrySet()) {_                        output.writeUTF(entry.getKey())__                        output.writeUTF(entry.getValue())__                    }_                    int keystoreLen = input.readInt()__                    byte[] keystoreBytes = new byte[keystoreLen]__                    input.readBytes(keystoreBytes, 0, keystoreLen)__                    output.write(keystoreBytes)__                }_                dataBytes = bytes.toByteArray()__            } else {_                int dataBytesLen = input.readInt()__                dataBytes = new byte[dataBytesLen]__                input.readBytes(dataBytes, 0, dataBytesLen)__            }__            CodecUtil.checkFooter(input)__            return new KeyStoreWrapper(formatVersion, hasPassword, dataBytes)__        }_    };loads,information,about,the,elasticsearch,keystore,from,the,provided,config,directory,link,decrypt,char,must,be,called,before,reading,or,writing,any,entries,returns,code,null,if,no,keystore,exists;public,static,key,store,wrapper,load,path,config,dir,throws,ioexception,path,keystore,file,keystore,path,config,dir,if,files,exists,keystore,file,false,return,null,simple,fsdirectory,directory,new,simple,fsdirectory,config,dir,try,index,input,index,input,directory,open,input,iocontext,readonce,checksum,index,input,input,new,buffered,checksum,index,input,index,input,int,format,version,codec,util,check,header,input,byte,has,password,byte,input,read,byte,boolean,has,password,has,password,byte,1,if,has,password,false,has,password,byte,0,throw,new,illegal,state,exception,has,password,boolean,is,corrupt,string,format,locale,root,02x,has,password,byte,if,format,version,2,string,type,input,read,string,if,type,equals,pkcs12,false,throw,new,illegal,state,exception,corrupted,legacy,keystore,string,encryption,algorithm,final,string,string,key,algo,input,read,string,if,string,key,algo,equals,pbe,false,throw,new,illegal,state,exception,corrupted,legacy,keystore,string,encryption,algorithm,if,format,version,2,final,string,file,key,algo,input,read,string,if,file,key,algo,equals,pbe,false,throw,new,illegal,state,exception,corrupted,legacy,keystore,file,encryption,algorithm,final,byte,data,bytes,if,format,version,2,map,string,string,setting,types,input,read,map,of,strings,byte,array,output,stream,bytes,new,byte,array,output,stream,try,data,output,stream,output,new,data,output,stream,bytes,output,write,int,setting,types,size,for,map,entry,string,string,entry,setting,types,entry,set,output,write,utf,entry,get,key,output,write,utf,entry,get,value,int,keystore,len,input,read,int,byte,keystore,bytes,new,byte,keystore,len,input,read,bytes,keystore,bytes,0,keystore,len,output,write,keystore,bytes,data,bytes,bytes,to,byte,array,else,int,data,bytes,len,input,read,int,data,bytes,new,byte,data,bytes,len,input,read,bytes,data,bytes,0,data,bytes,len,codec,util,check,footer,input,return,new,key,store,wrapper,format,version,has,password,data,bytes
KeyStoreWrapper -> public static KeyStoreWrapper load(Path configDir) throws IOException;1532511554;Loads information about the Elasticsearch keystore from the provided config directory.__{@link #decrypt(char[])} must be called before reading or writing any entries._Returns {@code null} if no keystore exists.;public static KeyStoreWrapper load(Path configDir) throws IOException {_        Path keystoreFile = keystorePath(configDir)__        if (Files.exists(keystoreFile) == false) {_            return null__        }__        SimpleFSDirectory directory = new SimpleFSDirectory(configDir)__        try (IndexInput indexInput = directory.openInput(KEYSTORE_FILENAME, IOContext.READONCE)) {_            ChecksumIndexInput input = new BufferedChecksumIndexInput(indexInput)__            int formatVersion = CodecUtil.checkHeader(input, KEYSTORE_FILENAME, MIN_FORMAT_VERSION, FORMAT_VERSION)__            byte hasPasswordByte = input.readByte()__            boolean hasPassword = hasPasswordByte == 1__            if (hasPassword == false && hasPasswordByte != 0) {_                throw new IllegalStateException("hasPassword boolean is corrupt: "_                    + String.format(Locale.ROOT, "%02x", hasPasswordByte))__            }__            if (formatVersion <= 2) {_                String type = input.readString()__                if (type.equals("PKCS12") == false) {_                    throw new IllegalStateException("Corrupted legacy keystore string encryption algorithm")__                }__                final String stringKeyAlgo = input.readString()__                if (stringKeyAlgo.equals("PBE") == false) {_                    throw new IllegalStateException("Corrupted legacy keystore string encryption algorithm")__                }_                if (formatVersion == 2) {_                    final String fileKeyAlgo = input.readString()__                    if (fileKeyAlgo.equals("PBE") == false) {_                        throw new IllegalStateException("Corrupted legacy keystore file encryption algorithm")__                    }_                }_            }__            final byte[] dataBytes__            if (formatVersion == 2) {_                _                _                _                _                Map<String, String> settingTypes = input.readMapOfStrings()__                ByteArrayOutputStream bytes = new ByteArrayOutputStream()__                try (DataOutputStream output = new DataOutputStream(bytes)) {_                    output.writeInt(settingTypes.size())__                    for (Map.Entry<String, String> entry : settingTypes.entrySet()) {_                        output.writeUTF(entry.getKey())__                        output.writeUTF(entry.getValue())__                    }_                    int keystoreLen = input.readInt()__                    byte[] keystoreBytes = new byte[keystoreLen]__                    input.readBytes(keystoreBytes, 0, keystoreLen)__                    output.write(keystoreBytes)__                }_                dataBytes = bytes.toByteArray()__            } else {_                int dataBytesLen = input.readInt()__                dataBytes = new byte[dataBytesLen]__                input.readBytes(dataBytes, 0, dataBytesLen)__            }__            CodecUtil.checkFooter(input)__            return new KeyStoreWrapper(formatVersion, hasPassword, dataBytes)__        }_    };loads,information,about,the,elasticsearch,keystore,from,the,provided,config,directory,link,decrypt,char,must,be,called,before,reading,or,writing,any,entries,returns,code,null,if,no,keystore,exists;public,static,key,store,wrapper,load,path,config,dir,throws,ioexception,path,keystore,file,keystore,path,config,dir,if,files,exists,keystore,file,false,return,null,simple,fsdirectory,directory,new,simple,fsdirectory,config,dir,try,index,input,index,input,directory,open,input,iocontext,readonce,checksum,index,input,input,new,buffered,checksum,index,input,index,input,int,format,version,codec,util,check,header,input,byte,has,password,byte,input,read,byte,boolean,has,password,has,password,byte,1,if,has,password,false,has,password,byte,0,throw,new,illegal,state,exception,has,password,boolean,is,corrupt,string,format,locale,root,02x,has,password,byte,if,format,version,2,string,type,input,read,string,if,type,equals,pkcs12,false,throw,new,illegal,state,exception,corrupted,legacy,keystore,string,encryption,algorithm,final,string,string,key,algo,input,read,string,if,string,key,algo,equals,pbe,false,throw,new,illegal,state,exception,corrupted,legacy,keystore,string,encryption,algorithm,if,format,version,2,final,string,file,key,algo,input,read,string,if,file,key,algo,equals,pbe,false,throw,new,illegal,state,exception,corrupted,legacy,keystore,file,encryption,algorithm,final,byte,data,bytes,if,format,version,2,map,string,string,setting,types,input,read,map,of,strings,byte,array,output,stream,bytes,new,byte,array,output,stream,try,data,output,stream,output,new,data,output,stream,bytes,output,write,int,setting,types,size,for,map,entry,string,string,entry,setting,types,entry,set,output,write,utf,entry,get,key,output,write,utf,entry,get,value,int,keystore,len,input,read,int,byte,keystore,bytes,new,byte,keystore,len,input,read,bytes,keystore,bytes,0,keystore,len,output,write,keystore,bytes,data,bytes,bytes,to,byte,array,else,int,data,bytes,len,input,read,int,data,bytes,new,byte,data,bytes,len,input,read,bytes,data,bytes,0,data,bytes,len,codec,util,check,footer,input,return,new,key,store,wrapper,format,version,has,password,data,bytes
KeyStoreWrapper -> public static KeyStoreWrapper load(Path configDir) throws IOException;1533063033;Loads information about the Elasticsearch keystore from the provided config directory.__{@link #decrypt(char[])} must be called before reading or writing any entries._Returns {@code null} if no keystore exists.;public static KeyStoreWrapper load(Path configDir) throws IOException {_        Path keystoreFile = keystorePath(configDir)__        if (Files.exists(keystoreFile) == false) {_            return null__        }__        SimpleFSDirectory directory = new SimpleFSDirectory(configDir)__        try (IndexInput indexInput = directory.openInput(KEYSTORE_FILENAME, IOContext.READONCE)) {_            ChecksumIndexInput input = new BufferedChecksumIndexInput(indexInput)__            int formatVersion = CodecUtil.checkHeader(input, KEYSTORE_FILENAME, MIN_FORMAT_VERSION, FORMAT_VERSION)__            byte hasPasswordByte = input.readByte()__            boolean hasPassword = hasPasswordByte == 1__            if (hasPassword == false && hasPasswordByte != 0) {_                throw new IllegalStateException("hasPassword boolean is corrupt: "_                    + String.format(Locale.ROOT, "%02x", hasPasswordByte))__            }__            if (formatVersion <= 2) {_                String type = input.readString()__                if (type.equals("PKCS12") == false) {_                    throw new IllegalStateException("Corrupted legacy keystore string encryption algorithm")__                }__                final String stringKeyAlgo = input.readString()__                if (stringKeyAlgo.equals("PBE") == false) {_                    throw new IllegalStateException("Corrupted legacy keystore string encryption algorithm")__                }_                if (formatVersion == 2) {_                    final String fileKeyAlgo = input.readString()__                    if (fileKeyAlgo.equals("PBE") == false) {_                        throw new IllegalStateException("Corrupted legacy keystore file encryption algorithm")__                    }_                }_            }__            final byte[] dataBytes__            if (formatVersion == 2) {_                _                _                _                _                Map<String, String> settingTypes = input.readMapOfStrings()__                ByteArrayOutputStream bytes = new ByteArrayOutputStream()__                try (DataOutputStream output = new DataOutputStream(bytes)) {_                    output.writeInt(settingTypes.size())__                    for (Map.Entry<String, String> entry : settingTypes.entrySet()) {_                        output.writeUTF(entry.getKey())__                        output.writeUTF(entry.getValue())__                    }_                    int keystoreLen = input.readInt()__                    byte[] keystoreBytes = new byte[keystoreLen]__                    input.readBytes(keystoreBytes, 0, keystoreLen)__                    output.write(keystoreBytes)__                }_                dataBytes = bytes.toByteArray()__            } else {_                int dataBytesLen = input.readInt()__                dataBytes = new byte[dataBytesLen]__                input.readBytes(dataBytes, 0, dataBytesLen)__            }__            CodecUtil.checkFooter(input)__            return new KeyStoreWrapper(formatVersion, hasPassword, dataBytes)__        }_    };loads,information,about,the,elasticsearch,keystore,from,the,provided,config,directory,link,decrypt,char,must,be,called,before,reading,or,writing,any,entries,returns,code,null,if,no,keystore,exists;public,static,key,store,wrapper,load,path,config,dir,throws,ioexception,path,keystore,file,keystore,path,config,dir,if,files,exists,keystore,file,false,return,null,simple,fsdirectory,directory,new,simple,fsdirectory,config,dir,try,index,input,index,input,directory,open,input,iocontext,readonce,checksum,index,input,input,new,buffered,checksum,index,input,index,input,int,format,version,codec,util,check,header,input,byte,has,password,byte,input,read,byte,boolean,has,password,has,password,byte,1,if,has,password,false,has,password,byte,0,throw,new,illegal,state,exception,has,password,boolean,is,corrupt,string,format,locale,root,02x,has,password,byte,if,format,version,2,string,type,input,read,string,if,type,equals,pkcs12,false,throw,new,illegal,state,exception,corrupted,legacy,keystore,string,encryption,algorithm,final,string,string,key,algo,input,read,string,if,string,key,algo,equals,pbe,false,throw,new,illegal,state,exception,corrupted,legacy,keystore,string,encryption,algorithm,if,format,version,2,final,string,file,key,algo,input,read,string,if,file,key,algo,equals,pbe,false,throw,new,illegal,state,exception,corrupted,legacy,keystore,file,encryption,algorithm,final,byte,data,bytes,if,format,version,2,map,string,string,setting,types,input,read,map,of,strings,byte,array,output,stream,bytes,new,byte,array,output,stream,try,data,output,stream,output,new,data,output,stream,bytes,output,write,int,setting,types,size,for,map,entry,string,string,entry,setting,types,entry,set,output,write,utf,entry,get,key,output,write,utf,entry,get,value,int,keystore,len,input,read,int,byte,keystore,bytes,new,byte,keystore,len,input,read,bytes,keystore,bytes,0,keystore,len,output,write,keystore,bytes,data,bytes,bytes,to,byte,array,else,int,data,bytes,len,input,read,int,data,bytes,new,byte,data,bytes,len,input,read,bytes,data,bytes,0,data,bytes,len,codec,util,check,footer,input,return,new,key,store,wrapper,format,version,has,password,data,bytes
KeyStoreWrapper -> public void decrypt(char[] password) throws GeneralSecurityException, IOException;1524684173;Decrypts the underlying keystore data.__This may only be called once.;public void decrypt(char[] password) throws GeneralSecurityException, IOException {_        if (entries.get() != null) {_            throw new IllegalStateException("Keystore has already been decrypted")__        }_        if (formatVersion <= 2) {_            decryptLegacyEntries()__            assert password.length == 0__            return__        }__        final byte[] salt__        final byte[] iv__        final byte[] encryptedBytes__        try (ByteArrayInputStream bytesStream = new ByteArrayInputStream(dataBytes)__             DataInputStream input = new DataInputStream(bytesStream)) {_            int saltLen = input.readInt()__            salt = new byte[saltLen]__            if (input.read(salt) != saltLen) {_                throw new SecurityException("Keystore has been corrupted or tampered with")__            }_            int ivLen = input.readInt()__            iv = new byte[ivLen]__            if (input.read(iv) != ivLen) {_                throw new SecurityException("Keystore has been corrupted or tampered with")__            }_            int encryptedLen = input.readInt()__            encryptedBytes = new byte[encryptedLen]__            if (input.read(encryptedBytes) != encryptedLen) {_                throw new SecurityException("Keystore has been corrupted or tampered with")__            }_        }__        Cipher cipher = createCipher(Cipher.DECRYPT_MODE, password, salt, iv)__        try (ByteArrayInputStream bytesStream = new ByteArrayInputStream(encryptedBytes)__             CipherInputStream cipherStream = new CipherInputStream(bytesStream, cipher)__             DataInputStream input = new DataInputStream(cipherStream)) {__            entries.set(new HashMap<>())__            int numEntries = input.readInt()__            while (numEntries-- > 0) {_                String setting = input.readUTF()__                EntryType entryType = EntryType.valueOf(input.readUTF())__                int entrySize = input.readInt()__                byte[] entryBytes = new byte[entrySize]__                if (input.read(entryBytes) != entrySize) {_                    throw new SecurityException("Keystore has been corrupted or tampered with")__                }_                entries.get().put(setting, new Entry(entryType, entryBytes))__            }_        }_    };decrypts,the,underlying,keystore,data,this,may,only,be,called,once;public,void,decrypt,char,password,throws,general,security,exception,ioexception,if,entries,get,null,throw,new,illegal,state,exception,keystore,has,already,been,decrypted,if,format,version,2,decrypt,legacy,entries,assert,password,length,0,return,final,byte,salt,final,byte,iv,final,byte,encrypted,bytes,try,byte,array,input,stream,bytes,stream,new,byte,array,input,stream,data,bytes,data,input,stream,input,new,data,input,stream,bytes,stream,int,salt,len,input,read,int,salt,new,byte,salt,len,if,input,read,salt,salt,len,throw,new,security,exception,keystore,has,been,corrupted,or,tampered,with,int,iv,len,input,read,int,iv,new,byte,iv,len,if,input,read,iv,iv,len,throw,new,security,exception,keystore,has,been,corrupted,or,tampered,with,int,encrypted,len,input,read,int,encrypted,bytes,new,byte,encrypted,len,if,input,read,encrypted,bytes,encrypted,len,throw,new,security,exception,keystore,has,been,corrupted,or,tampered,with,cipher,cipher,create,cipher,cipher,password,salt,iv,try,byte,array,input,stream,bytes,stream,new,byte,array,input,stream,encrypted,bytes,cipher,input,stream,cipher,stream,new,cipher,input,stream,bytes,stream,cipher,data,input,stream,input,new,data,input,stream,cipher,stream,entries,set,new,hash,map,int,num,entries,input,read,int,while,num,entries,0,string,setting,input,read,utf,entry,type,entry,type,entry,type,value,of,input,read,utf,int,entry,size,input,read,int,byte,entry,bytes,new,byte,entry,size,if,input,read,entry,bytes,entry,size,throw,new,security,exception,keystore,has,been,corrupted,or,tampered,with,entries,get,put,setting,new,entry,entry,type,entry,bytes
KeyStoreWrapper -> public void decrypt(char[] password) throws GeneralSecurityException, IOException;1525645056;Decrypts the underlying keystore data.__This may only be called once.;public void decrypt(char[] password) throws GeneralSecurityException, IOException {_        if (entries.get() != null) {_            throw new IllegalStateException("Keystore has already been decrypted")__        }_        if (formatVersion <= 2) {_            decryptLegacyEntries()__            assert password.length == 0__            return__        }__        final byte[] salt__        final byte[] iv__        final byte[] encryptedBytes__        try (ByteArrayInputStream bytesStream = new ByteArrayInputStream(dataBytes)__             DataInputStream input = new DataInputStream(bytesStream)) {_            int saltLen = input.readInt()__            salt = new byte[saltLen]__            input.readFully(salt)__            int ivLen = input.readInt()__            iv = new byte[ivLen]__            input.readFully(iv)__            int encryptedLen = input.readInt()__            encryptedBytes = new byte[encryptedLen]__            input.readFully(encryptedBytes)__            if (input.read() != -1) {_                throw new SecurityException("Keystore has been corrupted or tampered with")__            }_        } catch (EOFException e) {_            throw new SecurityException("Keystore has been corrupted or tampered with", e)__        }__        Cipher cipher = createCipher(Cipher.DECRYPT_MODE, password, salt, iv)__        try (ByteArrayInputStream bytesStream = new ByteArrayInputStream(encryptedBytes)__             CipherInputStream cipherStream = new CipherInputStream(bytesStream, cipher)__             DataInputStream input = new DataInputStream(cipherStream)) {_            entries.set(new HashMap<>())__            int numEntries = input.readInt()__            while (numEntries-- > 0) {_                String setting = input.readUTF()__                EntryType entryType = EntryType.valueOf(input.readUTF())__                int entrySize = input.readInt()__                byte[] entryBytes = new byte[entrySize]__                input.readFully(entryBytes)__                entries.get().put(setting, new Entry(entryType, entryBytes))__            }_            if (input.read() != -1) {_                throw new SecurityException("Keystore has been corrupted or tampered with")__            }_        } catch (EOFException e) {_            throw new SecurityException("Keystore has been corrupted or tampered with", e)__        }_    };decrypts,the,underlying,keystore,data,this,may,only,be,called,once;public,void,decrypt,char,password,throws,general,security,exception,ioexception,if,entries,get,null,throw,new,illegal,state,exception,keystore,has,already,been,decrypted,if,format,version,2,decrypt,legacy,entries,assert,password,length,0,return,final,byte,salt,final,byte,iv,final,byte,encrypted,bytes,try,byte,array,input,stream,bytes,stream,new,byte,array,input,stream,data,bytes,data,input,stream,input,new,data,input,stream,bytes,stream,int,salt,len,input,read,int,salt,new,byte,salt,len,input,read,fully,salt,int,iv,len,input,read,int,iv,new,byte,iv,len,input,read,fully,iv,int,encrypted,len,input,read,int,encrypted,bytes,new,byte,encrypted,len,input,read,fully,encrypted,bytes,if,input,read,1,throw,new,security,exception,keystore,has,been,corrupted,or,tampered,with,catch,eofexception,e,throw,new,security,exception,keystore,has,been,corrupted,or,tampered,with,e,cipher,cipher,create,cipher,cipher,password,salt,iv,try,byte,array,input,stream,bytes,stream,new,byte,array,input,stream,encrypted,bytes,cipher,input,stream,cipher,stream,new,cipher,input,stream,bytes,stream,cipher,data,input,stream,input,new,data,input,stream,cipher,stream,entries,set,new,hash,map,int,num,entries,input,read,int,while,num,entries,0,string,setting,input,read,utf,entry,type,entry,type,entry,type,value,of,input,read,utf,int,entry,size,input,read,int,byte,entry,bytes,new,byte,entry,size,input,read,fully,entry,bytes,entries,get,put,setting,new,entry,entry,type,entry,bytes,if,input,read,1,throw,new,security,exception,keystore,has,been,corrupted,or,tampered,with,catch,eofexception,e,throw,new,security,exception,keystore,has,been,corrupted,or,tampered,with,e
KeyStoreWrapper -> public void decrypt(char[] password) throws GeneralSecurityException, IOException;1526374795;Decrypts the underlying keystore data.__This may only be called once.;public void decrypt(char[] password) throws GeneralSecurityException, IOException {_        if (entries.get() != null) {_            throw new IllegalStateException("Keystore has already been decrypted")__        }_        if (formatVersion <= 2) {_            decryptLegacyEntries()__            assert password.length == 0__            return__        }__        final byte[] salt__        final byte[] iv__        final byte[] encryptedBytes__        try (ByteArrayInputStream bytesStream = new ByteArrayInputStream(dataBytes)__             DataInputStream input = new DataInputStream(bytesStream)) {_            int saltLen = input.readInt()__            salt = new byte[saltLen]__            input.readFully(salt)__            int ivLen = input.readInt()__            iv = new byte[ivLen]__            input.readFully(iv)__            int encryptedLen = input.readInt()__            encryptedBytes = new byte[encryptedLen]__            input.readFully(encryptedBytes)__            if (input.read() != -1) {_                throw new SecurityException("Keystore has been corrupted or tampered with")__            }_        } catch (EOFException e) {_            throw new SecurityException("Keystore has been corrupted or tampered with", e)__        }__        Cipher cipher = createCipher(Cipher.DECRYPT_MODE, password, salt, iv)__        try (ByteArrayInputStream bytesStream = new ByteArrayInputStream(encryptedBytes)__             CipherInputStream cipherStream = new CipherInputStream(bytesStream, cipher)__             DataInputStream input = new DataInputStream(cipherStream)) {_            entries.set(new HashMap<>())__            int numEntries = input.readInt()__            while (numEntries-- > 0) {_                String setting = input.readUTF()__                EntryType entryType = EntryType.valueOf(input.readUTF())__                int entrySize = input.readInt()__                byte[] entryBytes = new byte[entrySize]__                input.readFully(entryBytes)__                entries.get().put(setting, new Entry(entryType, entryBytes))__            }_            if (input.read() != -1) {_                throw new SecurityException("Keystore has been corrupted or tampered with")__            }_        } catch (EOFException e) {_            throw new SecurityException("Keystore has been corrupted or tampered with", e)__        }_    };decrypts,the,underlying,keystore,data,this,may,only,be,called,once;public,void,decrypt,char,password,throws,general,security,exception,ioexception,if,entries,get,null,throw,new,illegal,state,exception,keystore,has,already,been,decrypted,if,format,version,2,decrypt,legacy,entries,assert,password,length,0,return,final,byte,salt,final,byte,iv,final,byte,encrypted,bytes,try,byte,array,input,stream,bytes,stream,new,byte,array,input,stream,data,bytes,data,input,stream,input,new,data,input,stream,bytes,stream,int,salt,len,input,read,int,salt,new,byte,salt,len,input,read,fully,salt,int,iv,len,input,read,int,iv,new,byte,iv,len,input,read,fully,iv,int,encrypted,len,input,read,int,encrypted,bytes,new,byte,encrypted,len,input,read,fully,encrypted,bytes,if,input,read,1,throw,new,security,exception,keystore,has,been,corrupted,or,tampered,with,catch,eofexception,e,throw,new,security,exception,keystore,has,been,corrupted,or,tampered,with,e,cipher,cipher,create,cipher,cipher,password,salt,iv,try,byte,array,input,stream,bytes,stream,new,byte,array,input,stream,encrypted,bytes,cipher,input,stream,cipher,stream,new,cipher,input,stream,bytes,stream,cipher,data,input,stream,input,new,data,input,stream,cipher,stream,entries,set,new,hash,map,int,num,entries,input,read,int,while,num,entries,0,string,setting,input,read,utf,entry,type,entry,type,entry,type,value,of,input,read,utf,int,entry,size,input,read,int,byte,entry,bytes,new,byte,entry,size,input,read,fully,entry,bytes,entries,get,put,setting,new,entry,entry,type,entry,bytes,if,input,read,1,throw,new,security,exception,keystore,has,been,corrupted,or,tampered,with,catch,eofexception,e,throw,new,security,exception,keystore,has,been,corrupted,or,tampered,with,e
KeyStoreWrapper -> public void decrypt(char[] password) throws GeneralSecurityException, IOException;1529341607;Decrypts the underlying keystore data.__This may only be called once.;public void decrypt(char[] password) throws GeneralSecurityException, IOException {_        if (entries.get() != null) {_            throw new IllegalStateException("Keystore has already been decrypted")__        }_        if (formatVersion <= 2) {_            decryptLegacyEntries()__            if (password.length != 0) {_                throw new IllegalArgumentException("Keystore format does not accept non-empty passwords")__            }_            return__        }__        final byte[] salt__        final byte[] iv__        final byte[] encryptedBytes__        try (ByteArrayInputStream bytesStream = new ByteArrayInputStream(dataBytes)__             DataInputStream input = new DataInputStream(bytesStream)) {_            int saltLen = input.readInt()__            salt = new byte[saltLen]__            input.readFully(salt)__            int ivLen = input.readInt()__            iv = new byte[ivLen]__            input.readFully(iv)__            int encryptedLen = input.readInt()__            encryptedBytes = new byte[encryptedLen]__            input.readFully(encryptedBytes)__            if (input.read() != -1) {_                throw new SecurityException("Keystore has been corrupted or tampered with")__            }_        } catch (EOFException e) {_            throw new SecurityException("Keystore has been corrupted or tampered with", e)__        }__        Cipher cipher = createCipher(Cipher.DECRYPT_MODE, password, salt, iv)__        try (ByteArrayInputStream bytesStream = new ByteArrayInputStream(encryptedBytes)__             CipherInputStream cipherStream = new CipherInputStream(bytesStream, cipher)__             DataInputStream input = new DataInputStream(cipherStream)) {_            entries.set(new HashMap<>())__            int numEntries = input.readInt()__            while (numEntries-- > 0) {_                String setting = input.readUTF()__                EntryType entryType = EntryType.valueOf(input.readUTF())__                int entrySize = input.readInt()__                byte[] entryBytes = new byte[entrySize]__                input.readFully(entryBytes)__                entries.get().put(setting, new Entry(entryType, entryBytes))__            }_            if (input.read() != -1) {_                throw new SecurityException("Keystore has been corrupted or tampered with")__            }_        } catch (EOFException e) {_            throw new SecurityException("Keystore has been corrupted or tampered with", e)__        }_    };decrypts,the,underlying,keystore,data,this,may,only,be,called,once;public,void,decrypt,char,password,throws,general,security,exception,ioexception,if,entries,get,null,throw,new,illegal,state,exception,keystore,has,already,been,decrypted,if,format,version,2,decrypt,legacy,entries,if,password,length,0,throw,new,illegal,argument,exception,keystore,format,does,not,accept,non,empty,passwords,return,final,byte,salt,final,byte,iv,final,byte,encrypted,bytes,try,byte,array,input,stream,bytes,stream,new,byte,array,input,stream,data,bytes,data,input,stream,input,new,data,input,stream,bytes,stream,int,salt,len,input,read,int,salt,new,byte,salt,len,input,read,fully,salt,int,iv,len,input,read,int,iv,new,byte,iv,len,input,read,fully,iv,int,encrypted,len,input,read,int,encrypted,bytes,new,byte,encrypted,len,input,read,fully,encrypted,bytes,if,input,read,1,throw,new,security,exception,keystore,has,been,corrupted,or,tampered,with,catch,eofexception,e,throw,new,security,exception,keystore,has,been,corrupted,or,tampered,with,e,cipher,cipher,create,cipher,cipher,password,salt,iv,try,byte,array,input,stream,bytes,stream,new,byte,array,input,stream,encrypted,bytes,cipher,input,stream,cipher,stream,new,cipher,input,stream,bytes,stream,cipher,data,input,stream,input,new,data,input,stream,cipher,stream,entries,set,new,hash,map,int,num,entries,input,read,int,while,num,entries,0,string,setting,input,read,utf,entry,type,entry,type,entry,type,value,of,input,read,utf,int,entry,size,input,read,int,byte,entry,bytes,new,byte,entry,size,input,read,fully,entry,bytes,entries,get,put,setting,new,entry,entry,type,entry,bytes,if,input,read,1,throw,new,security,exception,keystore,has,been,corrupted,or,tampered,with,catch,eofexception,e,throw,new,security,exception,keystore,has,been,corrupted,or,tampered,with,e
KeyStoreWrapper -> public void decrypt(char[] password) throws GeneralSecurityException, IOException;1532511554;Decrypts the underlying keystore data.__This may only be called once.;public void decrypt(char[] password) throws GeneralSecurityException, IOException {_        if (entries.get() != null) {_            throw new IllegalStateException("Keystore has already been decrypted")__        }_        if (formatVersion <= 2) {_            decryptLegacyEntries()__            if (password.length != 0) {_                throw new IllegalArgumentException("Keystore format does not accept non-empty passwords")__            }_            return__        }__        final byte[] salt__        final byte[] iv__        final byte[] encryptedBytes__        try (ByteArrayInputStream bytesStream = new ByteArrayInputStream(dataBytes)__             DataInputStream input = new DataInputStream(bytesStream)) {_            int saltLen = input.readInt()__            salt = new byte[saltLen]__            input.readFully(salt)__            int ivLen = input.readInt()__            iv = new byte[ivLen]__            input.readFully(iv)__            int encryptedLen = input.readInt()__            encryptedBytes = new byte[encryptedLen]__            input.readFully(encryptedBytes)__            if (input.read() != -1) {_                throw new SecurityException("Keystore has been corrupted or tampered with")__            }_        } catch (EOFException e) {_            throw new SecurityException("Keystore has been corrupted or tampered with", e)__        }__        Cipher cipher = createCipher(Cipher.DECRYPT_MODE, password, salt, iv)__        try (ByteArrayInputStream bytesStream = new ByteArrayInputStream(encryptedBytes)__             CipherInputStream cipherStream = new CipherInputStream(bytesStream, cipher)__             DataInputStream input = new DataInputStream(cipherStream)) {_            entries.set(new HashMap<>())__            int numEntries = input.readInt()__            while (numEntries-- > 0) {_                String setting = input.readUTF()__                EntryType entryType = EntryType.valueOf(input.readUTF())__                int entrySize = input.readInt()__                byte[] entryBytes = new byte[entrySize]__                input.readFully(entryBytes)__                entries.get().put(setting, new Entry(entryType, entryBytes))__            }_            if (input.read() != -1) {_                throw new SecurityException("Keystore has been corrupted or tampered with")__            }_        } catch (EOFException e) {_            throw new SecurityException("Keystore has been corrupted or tampered with", e)__        }_    };decrypts,the,underlying,keystore,data,this,may,only,be,called,once;public,void,decrypt,char,password,throws,general,security,exception,ioexception,if,entries,get,null,throw,new,illegal,state,exception,keystore,has,already,been,decrypted,if,format,version,2,decrypt,legacy,entries,if,password,length,0,throw,new,illegal,argument,exception,keystore,format,does,not,accept,non,empty,passwords,return,final,byte,salt,final,byte,iv,final,byte,encrypted,bytes,try,byte,array,input,stream,bytes,stream,new,byte,array,input,stream,data,bytes,data,input,stream,input,new,data,input,stream,bytes,stream,int,salt,len,input,read,int,salt,new,byte,salt,len,input,read,fully,salt,int,iv,len,input,read,int,iv,new,byte,iv,len,input,read,fully,iv,int,encrypted,len,input,read,int,encrypted,bytes,new,byte,encrypted,len,input,read,fully,encrypted,bytes,if,input,read,1,throw,new,security,exception,keystore,has,been,corrupted,or,tampered,with,catch,eofexception,e,throw,new,security,exception,keystore,has,been,corrupted,or,tampered,with,e,cipher,cipher,create,cipher,cipher,password,salt,iv,try,byte,array,input,stream,bytes,stream,new,byte,array,input,stream,encrypted,bytes,cipher,input,stream,cipher,stream,new,cipher,input,stream,bytes,stream,cipher,data,input,stream,input,new,data,input,stream,cipher,stream,entries,set,new,hash,map,int,num,entries,input,read,int,while,num,entries,0,string,setting,input,read,utf,entry,type,entry,type,entry,type,value,of,input,read,utf,int,entry,size,input,read,int,byte,entry,bytes,new,byte,entry,size,input,read,fully,entry,bytes,entries,get,put,setting,new,entry,entry,type,entry,bytes,if,input,read,1,throw,new,security,exception,keystore,has,been,corrupted,or,tampered,with,catch,eofexception,e,throw,new,security,exception,keystore,has,been,corrupted,or,tampered,with,e
KeyStoreWrapper -> public void decrypt(char[] password) throws GeneralSecurityException, IOException;1533063033;Decrypts the underlying keystore data.__This may only be called once.;public void decrypt(char[] password) throws GeneralSecurityException, IOException {_        if (entries.get() != null) {_            throw new IllegalStateException("Keystore has already been decrypted")__        }_        if (formatVersion <= 2) {_            decryptLegacyEntries()__            if (password.length != 0) {_                throw new IllegalArgumentException("Keystore format does not accept non-empty passwords")__            }_            return__        }__        final byte[] salt__        final byte[] iv__        final byte[] encryptedBytes__        try (ByteArrayInputStream bytesStream = new ByteArrayInputStream(dataBytes)__             DataInputStream input = new DataInputStream(bytesStream)) {_            int saltLen = input.readInt()__            salt = new byte[saltLen]__            input.readFully(salt)__            int ivLen = input.readInt()__            iv = new byte[ivLen]__            input.readFully(iv)__            int encryptedLen = input.readInt()__            encryptedBytes = new byte[encryptedLen]__            input.readFully(encryptedBytes)__            if (input.read() != -1) {_                throw new SecurityException("Keystore has been corrupted or tampered with")__            }_        } catch (EOFException e) {_            throw new SecurityException("Keystore has been corrupted or tampered with", e)__        }__        Cipher cipher = createCipher(Cipher.DECRYPT_MODE, password, salt, iv)__        try (ByteArrayInputStream bytesStream = new ByteArrayInputStream(encryptedBytes)__             CipherInputStream cipherStream = new CipherInputStream(bytesStream, cipher)__             DataInputStream input = new DataInputStream(cipherStream)) {_            entries.set(new HashMap<>())__            int numEntries = input.readInt()__            while (numEntries-- > 0) {_                String setting = input.readUTF()__                EntryType entryType = EntryType.valueOf(input.readUTF())__                int entrySize = input.readInt()__                byte[] entryBytes = new byte[entrySize]__                input.readFully(entryBytes)__                entries.get().put(setting, new Entry(entryType, entryBytes))__            }_            if (input.read() != -1) {_                throw new SecurityException("Keystore has been corrupted or tampered with")__            }_        } catch (IOException e) {_            throw new SecurityException("Keystore has been corrupted or tampered with", e)__        }_    };decrypts,the,underlying,keystore,data,this,may,only,be,called,once;public,void,decrypt,char,password,throws,general,security,exception,ioexception,if,entries,get,null,throw,new,illegal,state,exception,keystore,has,already,been,decrypted,if,format,version,2,decrypt,legacy,entries,if,password,length,0,throw,new,illegal,argument,exception,keystore,format,does,not,accept,non,empty,passwords,return,final,byte,salt,final,byte,iv,final,byte,encrypted,bytes,try,byte,array,input,stream,bytes,stream,new,byte,array,input,stream,data,bytes,data,input,stream,input,new,data,input,stream,bytes,stream,int,salt,len,input,read,int,salt,new,byte,salt,len,input,read,fully,salt,int,iv,len,input,read,int,iv,new,byte,iv,len,input,read,fully,iv,int,encrypted,len,input,read,int,encrypted,bytes,new,byte,encrypted,len,input,read,fully,encrypted,bytes,if,input,read,1,throw,new,security,exception,keystore,has,been,corrupted,or,tampered,with,catch,eofexception,e,throw,new,security,exception,keystore,has,been,corrupted,or,tampered,with,e,cipher,cipher,create,cipher,cipher,password,salt,iv,try,byte,array,input,stream,bytes,stream,new,byte,array,input,stream,encrypted,bytes,cipher,input,stream,cipher,stream,new,cipher,input,stream,bytes,stream,cipher,data,input,stream,input,new,data,input,stream,cipher,stream,entries,set,new,hash,map,int,num,entries,input,read,int,while,num,entries,0,string,setting,input,read,utf,entry,type,entry,type,entry,type,value,of,input,read,utf,int,entry,size,input,read,int,byte,entry,bytes,new,byte,entry,size,input,read,fully,entry,bytes,entries,get,put,setting,new,entry,entry,type,entry,bytes,if,input,read,1,throw,new,security,exception,keystore,has,been,corrupted,or,tampered,with,catch,ioexception,e,throw,new,security,exception,keystore,has,been,corrupted,or,tampered,with,e
KeyStoreWrapper -> public void save(Path configDir, char[] password) throws Exception;1524684173;Write the keystore to the given config directory.;public void save(Path configDir, char[] password) throws Exception {_        assert isLoaded()___        SimpleFSDirectory directory = new SimpleFSDirectory(configDir)__        _        String tmpFile = KEYSTORE_FILENAME + ".tmp"__        try (IndexOutput output = directory.createOutput(tmpFile, IOContext.DEFAULT)) {_            CodecUtil.writeHeader(output, KEYSTORE_FILENAME, FORMAT_VERSION)__            output.writeByte(password.length == 0 ? (byte)0 : (byte)1)___            _            SecureRandom random = Randomness.createSecure()__            _            _            byte[] salt = new byte[64]__            random.nextBytes(salt)__            _            _            byte[] iv = new byte[12]__            random.nextBytes(iv)__            _            byte[] encryptedBytes = encrypt(password, salt, iv)___            _            output.writeInt(4 + salt.length + 4 + iv.length + 4 + encryptedBytes.length)___            output.writeInt(salt.length)__            output.writeBytes(salt, salt.length)__            output.writeInt(iv.length)__            output.writeBytes(iv, iv.length)__            output.writeInt(encryptedBytes.length)__            output.writeBytes(encryptedBytes, encryptedBytes.length)___            CodecUtil.writeFooter(output)___        } catch (final AccessDeniedException e) {_            final String message = String.format(_                    Locale.ROOT,_                    "unable to create temporary keystore at [%s], please check filesystem permissions",_                    configDir.resolve(tmpFile))__            throw new UserException(ExitCodes.CONFIG, message, e)__        }__        Path keystoreFile = keystorePath(configDir)__        Files.move(configDir.resolve(tmpFile), keystoreFile, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.ATOMIC_MOVE)__        PosixFileAttributeView attrs = Files.getFileAttributeView(keystoreFile, PosixFileAttributeView.class)__        if (attrs != null) {_            _            attrs.setPermissions(PosixFilePermissions.fromString("rw-rw----"))__        }_    };write,the,keystore,to,the,given,config,directory;public,void,save,path,config,dir,char,password,throws,exception,assert,is,loaded,simple,fsdirectory,directory,new,simple,fsdirectory,config,dir,string,tmp,file,tmp,try,index,output,output,directory,create,output,tmp,file,iocontext,default,codec,util,write,header,output,output,write,byte,password,length,0,byte,0,byte,1,secure,random,random,randomness,create,secure,byte,salt,new,byte,64,random,next,bytes,salt,byte,iv,new,byte,12,random,next,bytes,iv,byte,encrypted,bytes,encrypt,password,salt,iv,output,write,int,4,salt,length,4,iv,length,4,encrypted,bytes,length,output,write,int,salt,length,output,write,bytes,salt,salt,length,output,write,int,iv,length,output,write,bytes,iv,iv,length,output,write,int,encrypted,bytes,length,output,write,bytes,encrypted,bytes,encrypted,bytes,length,codec,util,write,footer,output,catch,final,access,denied,exception,e,final,string,message,string,format,locale,root,unable,to,create,temporary,keystore,at,s,please,check,filesystem,permissions,config,dir,resolve,tmp,file,throw,new,user,exception,exit,codes,config,message,e,path,keystore,file,keystore,path,config,dir,files,move,config,dir,resolve,tmp,file,keystore,file,standard,copy,option,standard,copy,option,posix,file,attribute,view,attrs,files,get,file,attribute,view,keystore,file,posix,file,attribute,view,class,if,attrs,null,attrs,set,permissions,posix,file,permissions,from,string,rw,rw
KeyStoreWrapper -> public void save(Path configDir, char[] password) throws Exception;1525645056;Write the keystore to the given config directory.;public void save(Path configDir, char[] password) throws Exception {_        assert isLoaded()___        SimpleFSDirectory directory = new SimpleFSDirectory(configDir)__        _        String tmpFile = KEYSTORE_FILENAME + ".tmp"__        try (IndexOutput output = directory.createOutput(tmpFile, IOContext.DEFAULT)) {_            CodecUtil.writeHeader(output, KEYSTORE_FILENAME, FORMAT_VERSION)__            output.writeByte(password.length == 0 ? (byte)0 : (byte)1)___            _            SecureRandom random = Randomness.createSecure()__            _            _            byte[] salt = new byte[64]__            random.nextBytes(salt)__            _            _            byte[] iv = new byte[12]__            random.nextBytes(iv)__            _            byte[] encryptedBytes = encrypt(password, salt, iv)___            _            output.writeInt(4 + salt.length + 4 + iv.length + 4 + encryptedBytes.length)___            output.writeInt(salt.length)__            output.writeBytes(salt, salt.length)__            output.writeInt(iv.length)__            output.writeBytes(iv, iv.length)__            output.writeInt(encryptedBytes.length)__            output.writeBytes(encryptedBytes, encryptedBytes.length)___            CodecUtil.writeFooter(output)___        } catch (final AccessDeniedException e) {_            final String message = String.format(_                    Locale.ROOT,_                    "unable to create temporary keystore at [%s], please check filesystem permissions",_                    configDir.resolve(tmpFile))__            throw new UserException(ExitCodes.CONFIG, message, e)__        }__        Path keystoreFile = keystorePath(configDir)__        Files.move(configDir.resolve(tmpFile), keystoreFile, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.ATOMIC_MOVE)__        PosixFileAttributeView attrs = Files.getFileAttributeView(keystoreFile, PosixFileAttributeView.class)__        if (attrs != null) {_            _            attrs.setPermissions(PosixFilePermissions.fromString("rw-rw----"))__        }_    };write,the,keystore,to,the,given,config,directory;public,void,save,path,config,dir,char,password,throws,exception,assert,is,loaded,simple,fsdirectory,directory,new,simple,fsdirectory,config,dir,string,tmp,file,tmp,try,index,output,output,directory,create,output,tmp,file,iocontext,default,codec,util,write,header,output,output,write,byte,password,length,0,byte,0,byte,1,secure,random,random,randomness,create,secure,byte,salt,new,byte,64,random,next,bytes,salt,byte,iv,new,byte,12,random,next,bytes,iv,byte,encrypted,bytes,encrypt,password,salt,iv,output,write,int,4,salt,length,4,iv,length,4,encrypted,bytes,length,output,write,int,salt,length,output,write,bytes,salt,salt,length,output,write,int,iv,length,output,write,bytes,iv,iv,length,output,write,int,encrypted,bytes,length,output,write,bytes,encrypted,bytes,encrypted,bytes,length,codec,util,write,footer,output,catch,final,access,denied,exception,e,final,string,message,string,format,locale,root,unable,to,create,temporary,keystore,at,s,please,check,filesystem,permissions,config,dir,resolve,tmp,file,throw,new,user,exception,exit,codes,config,message,e,path,keystore,file,keystore,path,config,dir,files,move,config,dir,resolve,tmp,file,keystore,file,standard,copy,option,standard,copy,option,posix,file,attribute,view,attrs,files,get,file,attribute,view,keystore,file,posix,file,attribute,view,class,if,attrs,null,attrs,set,permissions,posix,file,permissions,from,string,rw,rw
KeyStoreWrapper -> public int getFormatVersion();1532511554;Get the metadata format version for the keystore;public int getFormatVersion() {_        return formatVersion__    };get,the,metadata,format,version,for,the,keystore;public,int,get,format,version,return,format,version
KeyStoreWrapper -> public int getFormatVersion();1533063033;Get the metadata format version for the keystore;public int getFormatVersion() {_        return formatVersion__    };get,the,metadata,format,version,for,the,keystore;public,int,get,format,version,return,format,version
KeyStoreWrapper -> public static void addBootstrapSeed(KeyStoreWrapper wrapper);1524684173;Add the bootstrap seed setting, which may be used as a unique, secure, random value by the node;public static void addBootstrapSeed(KeyStoreWrapper wrapper) {_        assert wrapper.getSettingNames().contains(SEED_SETTING.getKey()) == false__        SecureRandom random = Randomness.createSecure()__        int passwordLength = 20_ _        char[] characters = new char[passwordLength]__        for (int i = 0_ i < passwordLength_ ++i) {_            characters[i] = SEED_CHARS[random.nextInt(SEED_CHARS.length)]__        }_        wrapper.setString(SEED_SETTING.getKey(), characters)__        Arrays.fill(characters, (char)0)__    };add,the,bootstrap,seed,setting,which,may,be,used,as,a,unique,secure,random,value,by,the,node;public,static,void,add,bootstrap,seed,key,store,wrapper,wrapper,assert,wrapper,get,setting,names,contains,get,key,false,secure,random,random,randomness,create,secure,int,password,length,20,char,characters,new,char,password,length,for,int,i,0,i,password,length,i,characters,i,random,next,int,length,wrapper,set,string,get,key,characters,arrays,fill,characters,char,0
KeyStoreWrapper -> public static void addBootstrapSeed(KeyStoreWrapper wrapper);1525645056;Add the bootstrap seed setting, which may be used as a unique, secure, random value by the node;public static void addBootstrapSeed(KeyStoreWrapper wrapper) {_        assert wrapper.getSettingNames().contains(SEED_SETTING.getKey()) == false__        SecureRandom random = Randomness.createSecure()__        int passwordLength = 20_ _        char[] characters = new char[passwordLength]__        for (int i = 0_ i < passwordLength_ ++i) {_            characters[i] = SEED_CHARS[random.nextInt(SEED_CHARS.length)]__        }_        wrapper.setString(SEED_SETTING.getKey(), characters)__        Arrays.fill(characters, (char)0)__    };add,the,bootstrap,seed,setting,which,may,be,used,as,a,unique,secure,random,value,by,the,node;public,static,void,add,bootstrap,seed,key,store,wrapper,wrapper,assert,wrapper,get,setting,names,contains,get,key,false,secure,random,random,randomness,create,secure,int,password,length,20,char,characters,new,char,password,length,for,int,i,0,i,password,length,i,characters,i,random,next,int,length,wrapper,set,string,get,key,characters,arrays,fill,characters,char,0
KeyStoreWrapper -> public static void addBootstrapSeed(KeyStoreWrapper wrapper);1526374795;Add the bootstrap seed setting, which may be used as a unique, secure, random value by the node;public static void addBootstrapSeed(KeyStoreWrapper wrapper) {_        assert wrapper.getSettingNames().contains(SEED_SETTING.getKey()) == false__        SecureRandom random = Randomness.createSecure()__        int passwordLength = 20_ _        char[] characters = new char[passwordLength]__        for (int i = 0_ i < passwordLength_ ++i) {_            characters[i] = SEED_CHARS[random.nextInt(SEED_CHARS.length)]__        }_        wrapper.setString(SEED_SETTING.getKey(), characters)__        Arrays.fill(characters, (char)0)__    };add,the,bootstrap,seed,setting,which,may,be,used,as,a,unique,secure,random,value,by,the,node;public,static,void,add,bootstrap,seed,key,store,wrapper,wrapper,assert,wrapper,get,setting,names,contains,get,key,false,secure,random,random,randomness,create,secure,int,password,length,20,char,characters,new,char,password,length,for,int,i,0,i,password,length,i,characters,i,random,next,int,length,wrapper,set,string,get,key,characters,arrays,fill,characters,char,0
KeyStoreWrapper -> public static void addBootstrapSeed(KeyStoreWrapper wrapper);1529341607;Add the bootstrap seed setting, which may be used as a unique, secure, random value by the node;public static void addBootstrapSeed(KeyStoreWrapper wrapper) {_        assert wrapper.getSettingNames().contains(SEED_SETTING.getKey()) == false__        SecureRandom random = Randomness.createSecure()__        int passwordLength = 20_ _        char[] characters = new char[passwordLength]__        for (int i = 0_ i < passwordLength_ ++i) {_            characters[i] = SEED_CHARS[random.nextInt(SEED_CHARS.length)]__        }_        wrapper.setString(SEED_SETTING.getKey(), characters)__        Arrays.fill(characters, (char)0)__    };add,the,bootstrap,seed,setting,which,may,be,used,as,a,unique,secure,random,value,by,the,node;public,static,void,add,bootstrap,seed,key,store,wrapper,wrapper,assert,wrapper,get,setting,names,contains,get,key,false,secure,random,random,randomness,create,secure,int,password,length,20,char,characters,new,char,password,length,for,int,i,0,i,password,length,i,characters,i,random,next,int,length,wrapper,set,string,get,key,characters,arrays,fill,characters,char,0
KeyStoreWrapper -> public static void addBootstrapSeed(KeyStoreWrapper wrapper);1532511554;Add the bootstrap seed setting, which may be used as a unique, secure, random value by the node;public static void addBootstrapSeed(KeyStoreWrapper wrapper) {_        assert wrapper.getSettingNames().contains(SEED_SETTING.getKey()) == false__        SecureRandom random = Randomness.createSecure()__        int passwordLength = 20_ _        char[] characters = new char[passwordLength]__        for (int i = 0_ i < passwordLength_ ++i) {_            characters[i] = SEED_CHARS[random.nextInt(SEED_CHARS.length)]__        }_        wrapper.setString(SEED_SETTING.getKey(), characters)__        Arrays.fill(characters, (char)0)__    };add,the,bootstrap,seed,setting,which,may,be,used,as,a,unique,secure,random,value,by,the,node;public,static,void,add,bootstrap,seed,key,store,wrapper,wrapper,assert,wrapper,get,setting,names,contains,get,key,false,secure,random,random,randomness,create,secure,int,password,length,20,char,characters,new,char,password,length,for,int,i,0,i,password,length,i,characters,i,random,next,int,length,wrapper,set,string,get,key,characters,arrays,fill,characters,char,0
KeyStoreWrapper -> public static void addBootstrapSeed(KeyStoreWrapper wrapper);1533063033;Add the bootstrap seed setting, which may be used as a unique, secure, random value by the node;public static void addBootstrapSeed(KeyStoreWrapper wrapper) {_        assert wrapper.getSettingNames().contains(SEED_SETTING.getKey()) == false__        SecureRandom random = Randomness.createSecure()__        int passwordLength = 20_ _        char[] characters = new char[passwordLength]__        for (int i = 0_ i < passwordLength_ ++i) {_            characters[i] = SEED_CHARS[random.nextInt(SEED_CHARS.length)]__        }_        wrapper.setString(SEED_SETTING.getKey(), characters)__        Arrays.fill(characters, (char)0)__    };add,the,bootstrap,seed,setting,which,may,be,used,as,a,unique,secure,random,value,by,the,node;public,static,void,add,bootstrap,seed,key,store,wrapper,wrapper,assert,wrapper,get,setting,names,contains,get,key,false,secure,random,random,randomness,create,secure,int,password,length,20,char,characters,new,char,password,length,for,int,i,0,i,password,length,i,characters,i,random,next,int,length,wrapper,set,string,get,key,characters,arrays,fill,characters,char,0
KeyStoreWrapper -> public static void upgrade(KeyStoreWrapper wrapper, Path configDir, char[] password) throws Exception;1524684173;Upgrades the format of the keystore, if necessary.;public static void upgrade(KeyStoreWrapper wrapper, Path configDir, char[] password) throws Exception {_        _        if (wrapper.getSettingNames().contains(SEED_SETTING.getKey())) {_            return__        }_        addBootstrapSeed(wrapper)__        wrapper.save(configDir, password)__    };upgrades,the,format,of,the,keystore,if,necessary;public,static,void,upgrade,key,store,wrapper,wrapper,path,config,dir,char,password,throws,exception,if,wrapper,get,setting,names,contains,get,key,return,add,bootstrap,seed,wrapper,wrapper,save,config,dir,password
KeyStoreWrapper -> public static void upgrade(KeyStoreWrapper wrapper, Path configDir, char[] password) throws Exception;1525645056;Upgrades the format of the keystore, if necessary.;public static void upgrade(KeyStoreWrapper wrapper, Path configDir, char[] password) throws Exception {_        _        if (wrapper.getSettingNames().contains(SEED_SETTING.getKey())) {_            return__        }_        addBootstrapSeed(wrapper)__        wrapper.save(configDir, password)__    };upgrades,the,format,of,the,keystore,if,necessary;public,static,void,upgrade,key,store,wrapper,wrapper,path,config,dir,char,password,throws,exception,if,wrapper,get,setting,names,contains,get,key,return,add,bootstrap,seed,wrapper,wrapper,save,config,dir,password
KeyStoreWrapper -> public static void upgrade(KeyStoreWrapper wrapper, Path configDir, char[] password) throws Exception;1526374795;Upgrades the format of the keystore, if necessary.;public static void upgrade(KeyStoreWrapper wrapper, Path configDir, char[] password) throws Exception {_        _        if (wrapper.getSettingNames().contains(SEED_SETTING.getKey())) {_            return__        }_        addBootstrapSeed(wrapper)__        wrapper.save(configDir, password)__    };upgrades,the,format,of,the,keystore,if,necessary;public,static,void,upgrade,key,store,wrapper,wrapper,path,config,dir,char,password,throws,exception,if,wrapper,get,setting,names,contains,get,key,return,add,bootstrap,seed,wrapper,wrapper,save,config,dir,password
KeyStoreWrapper -> public static void upgrade(KeyStoreWrapper wrapper, Path configDir, char[] password) throws Exception;1529341607;Upgrades the format of the keystore, if necessary.;public static void upgrade(KeyStoreWrapper wrapper, Path configDir, char[] password) throws Exception {_        _        if (wrapper.getSettingNames().contains(SEED_SETTING.getKey())) {_            return__        }_        addBootstrapSeed(wrapper)__        wrapper.save(configDir, password)__    };upgrades,the,format,of,the,keystore,if,necessary;public,static,void,upgrade,key,store,wrapper,wrapper,path,config,dir,char,password,throws,exception,if,wrapper,get,setting,names,contains,get,key,return,add,bootstrap,seed,wrapper,wrapper,save,config,dir,password
KeyStoreWrapper -> public static void upgrade(KeyStoreWrapper wrapper, Path configDir, char[] password) throws Exception;1532511554;Upgrades the format of the keystore, if necessary.;public static void upgrade(KeyStoreWrapper wrapper, Path configDir, char[] password) throws Exception {_        _        if (wrapper.getSettingNames().contains(SEED_SETTING.getKey())) {_            return__        }_        addBootstrapSeed(wrapper)__        wrapper.save(configDir, password)__    };upgrades,the,format,of,the,keystore,if,necessary;public,static,void,upgrade,key,store,wrapper,wrapper,path,config,dir,char,password,throws,exception,if,wrapper,get,setting,names,contains,get,key,return,add,bootstrap,seed,wrapper,wrapper,save,config,dir,password
KeyStoreWrapper -> public static void upgrade(KeyStoreWrapper wrapper, Path configDir, char[] password) throws Exception;1533063033;Upgrades the format of the keystore, if necessary.;public static void upgrade(KeyStoreWrapper wrapper, Path configDir, char[] password) throws Exception {_        _        if (wrapper.getSettingNames().contains(SEED_SETTING.getKey())) {_            return__        }_        addBootstrapSeed(wrapper)__        wrapper.save(configDir, password)__    };upgrades,the,format,of,the,keystore,if,necessary;public,static,void,upgrade,key,store,wrapper,wrapper,path,config,dir,char,password,throws,exception,if,wrapper,get,setting,names,contains,get,key,return,add,bootstrap,seed,wrapper,wrapper,save,config,dir,password
KeyStoreWrapper -> @Override     public Set<String> getSettingNames();1526374795;It is possible to retrieve the setting names even if the keystore is closed._This allows {@link SecureSetting} to correctly determine that a entry exists even though it cannot be read. Thus attempting to_read a secure setting after the keystore is closed will generate a "keystore is closed" exception rather than using the fallback_setting.;@Override_    public Set<String> getSettingNames() {_        assert entries.get() != null : "Keystore is not loaded"__        return entries.get().keySet()__    };it,is,possible,to,retrieve,the,setting,names,even,if,the,keystore,is,closed,this,allows,link,secure,setting,to,correctly,determine,that,a,entry,exists,even,though,it,cannot,be,read,thus,attempting,to,read,a,secure,setting,after,the,keystore,is,closed,will,generate,a,keystore,is,closed,exception,rather,than,using,the,fallback,setting;override,public,set,string,get,setting,names,assert,entries,get,null,keystore,is,not,loaded,return,entries,get,key,set
KeyStoreWrapper -> @Override     public Set<String> getSettingNames();1529341607;It is possible to retrieve the setting names even if the keystore is closed._This allows {@link SecureSetting} to correctly determine that a entry exists even though it cannot be read. Thus attempting to_read a secure setting after the keystore is closed will generate a "keystore is closed" exception rather than using the fallback_setting.;@Override_    public Set<String> getSettingNames() {_        assert entries.get() != null : "Keystore is not loaded"__        return entries.get().keySet()__    };it,is,possible,to,retrieve,the,setting,names,even,if,the,keystore,is,closed,this,allows,link,secure,setting,to,correctly,determine,that,a,entry,exists,even,though,it,cannot,be,read,thus,attempting,to,read,a,secure,setting,after,the,keystore,is,closed,will,generate,a,keystore,is,closed,exception,rather,than,using,the,fallback,setting;override,public,set,string,get,setting,names,assert,entries,get,null,keystore,is,not,loaded,return,entries,get,key,set
KeyStoreWrapper -> @Override     public Set<String> getSettingNames();1532511554;It is possible to retrieve the setting names even if the keystore is closed._This allows {@link SecureSetting} to correctly determine that a entry exists even though it cannot be read. Thus attempting to_read a secure setting after the keystore is closed will generate a "keystore is closed" exception rather than using the fallback_setting.;@Override_    public Set<String> getSettingNames() {_        assert entries.get() != null : "Keystore is not loaded"__        return entries.get().keySet()__    };it,is,possible,to,retrieve,the,setting,names,even,if,the,keystore,is,closed,this,allows,link,secure,setting,to,correctly,determine,that,a,entry,exists,even,though,it,cannot,be,read,thus,attempting,to,read,a,secure,setting,after,the,keystore,is,closed,will,generate,a,keystore,is,closed,exception,rather,than,using,the,fallback,setting;override,public,set,string,get,setting,names,assert,entries,get,null,keystore,is,not,loaded,return,entries,get,key,set
KeyStoreWrapper -> @Override     public Set<String> getSettingNames();1533063033;It is possible to retrieve the setting names even if the keystore is closed._This allows {@link SecureSetting} to correctly determine that a entry exists even though it cannot be read. Thus attempting to_read a secure setting after the keystore is closed will generate a "keystore is closed" exception rather than using the fallback_setting.;@Override_    public Set<String> getSettingNames() {_        assert entries.get() != null : "Keystore is not loaded"__        return entries.get().keySet()__    };it,is,possible,to,retrieve,the,setting,names,even,if,the,keystore,is,closed,this,allows,link,secure,setting,to,correctly,determine,that,a,entry,exists,even,though,it,cannot,be,read,thus,attempting,to,read,a,secure,setting,after,the,keystore,is,closed,will,generate,a,keystore,is,closed,exception,rather,than,using,the,fallback,setting;override,public,set,string,get,setting,names,assert,entries,get,null,keystore,is,not,loaded,return,entries,get,key,set
KeyStoreWrapper -> public synchronized void save(Path configDir, char[] password) throws Exception;1526374795;Write the keystore to the given config directory.;public synchronized void save(Path configDir, char[] password) throws Exception {_        ensureOpen()___        SimpleFSDirectory directory = new SimpleFSDirectory(configDir)__        _        String tmpFile = KEYSTORE_FILENAME + ".tmp"__        try (IndexOutput output = directory.createOutput(tmpFile, IOContext.DEFAULT)) {_            CodecUtil.writeHeader(output, KEYSTORE_FILENAME, FORMAT_VERSION)__            output.writeByte(password.length == 0 ? (byte)0 : (byte)1)___            _            SecureRandom random = Randomness.createSecure()__            _            _            byte[] salt = new byte[64]__            random.nextBytes(salt)__            _            _            byte[] iv = new byte[12]__            random.nextBytes(iv)__            _            byte[] encryptedBytes = encrypt(password, salt, iv)___            _            output.writeInt(4 + salt.length + 4 + iv.length + 4 + encryptedBytes.length)___            output.writeInt(salt.length)__            output.writeBytes(salt, salt.length)__            output.writeInt(iv.length)__            output.writeBytes(iv, iv.length)__            output.writeInt(encryptedBytes.length)__            output.writeBytes(encryptedBytes, encryptedBytes.length)___            CodecUtil.writeFooter(output)___        } catch (final AccessDeniedException e) {_            final String message = String.format(_                    Locale.ROOT,_                    "unable to create temporary keystore at [%s], please check filesystem permissions",_                    configDir.resolve(tmpFile))__            throw new UserException(ExitCodes.CONFIG, message, e)__        }__        Path keystoreFile = keystorePath(configDir)__        Files.move(configDir.resolve(tmpFile), keystoreFile, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.ATOMIC_MOVE)__        PosixFileAttributeView attrs = Files.getFileAttributeView(keystoreFile, PosixFileAttributeView.class)__        if (attrs != null) {_            _            attrs.setPermissions(PosixFilePermissions.fromString("rw-rw----"))__        }_    };write,the,keystore,to,the,given,config,directory;public,synchronized,void,save,path,config,dir,char,password,throws,exception,ensure,open,simple,fsdirectory,directory,new,simple,fsdirectory,config,dir,string,tmp,file,tmp,try,index,output,output,directory,create,output,tmp,file,iocontext,default,codec,util,write,header,output,output,write,byte,password,length,0,byte,0,byte,1,secure,random,random,randomness,create,secure,byte,salt,new,byte,64,random,next,bytes,salt,byte,iv,new,byte,12,random,next,bytes,iv,byte,encrypted,bytes,encrypt,password,salt,iv,output,write,int,4,salt,length,4,iv,length,4,encrypted,bytes,length,output,write,int,salt,length,output,write,bytes,salt,salt,length,output,write,int,iv,length,output,write,bytes,iv,iv,length,output,write,int,encrypted,bytes,length,output,write,bytes,encrypted,bytes,encrypted,bytes,length,codec,util,write,footer,output,catch,final,access,denied,exception,e,final,string,message,string,format,locale,root,unable,to,create,temporary,keystore,at,s,please,check,filesystem,permissions,config,dir,resolve,tmp,file,throw,new,user,exception,exit,codes,config,message,e,path,keystore,file,keystore,path,config,dir,files,move,config,dir,resolve,tmp,file,keystore,file,standard,copy,option,standard,copy,option,posix,file,attribute,view,attrs,files,get,file,attribute,view,keystore,file,posix,file,attribute,view,class,if,attrs,null,attrs,set,permissions,posix,file,permissions,from,string,rw,rw
KeyStoreWrapper -> public synchronized void save(Path configDir, char[] password) throws Exception;1529341607;Write the keystore to the given config directory.;public synchronized void save(Path configDir, char[] password) throws Exception {_        ensureOpen()___        SimpleFSDirectory directory = new SimpleFSDirectory(configDir)__        _        String tmpFile = KEYSTORE_FILENAME + ".tmp"__        try (IndexOutput output = directory.createOutput(tmpFile, IOContext.DEFAULT)) {_            CodecUtil.writeHeader(output, KEYSTORE_FILENAME, FORMAT_VERSION)__            output.writeByte(password.length == 0 ? (byte)0 : (byte)1)___            _            SecureRandom random = Randomness.createSecure()__            _            _            byte[] salt = new byte[64]__            random.nextBytes(salt)__            _            _            byte[] iv = new byte[12]__            random.nextBytes(iv)__            _            byte[] encryptedBytes = encrypt(password, salt, iv)___            _            output.writeInt(4 + salt.length + 4 + iv.length + 4 + encryptedBytes.length)___            output.writeInt(salt.length)__            output.writeBytes(salt, salt.length)__            output.writeInt(iv.length)__            output.writeBytes(iv, iv.length)__            output.writeInt(encryptedBytes.length)__            output.writeBytes(encryptedBytes, encryptedBytes.length)___            CodecUtil.writeFooter(output)___        } catch (final AccessDeniedException e) {_            final String message = String.format(_                    Locale.ROOT,_                    "unable to create temporary keystore at [%s], please check filesystem permissions",_                    configDir.resolve(tmpFile))__            throw new UserException(ExitCodes.CONFIG, message, e)__        }__        Path keystoreFile = keystorePath(configDir)__        Files.move(configDir.resolve(tmpFile), keystoreFile, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.ATOMIC_MOVE)__        PosixFileAttributeView attrs = Files.getFileAttributeView(keystoreFile, PosixFileAttributeView.class)__        if (attrs != null) {_            _            attrs.setPermissions(PosixFilePermissions.fromString("rw-rw----"))__        }_    };write,the,keystore,to,the,given,config,directory;public,synchronized,void,save,path,config,dir,char,password,throws,exception,ensure,open,simple,fsdirectory,directory,new,simple,fsdirectory,config,dir,string,tmp,file,tmp,try,index,output,output,directory,create,output,tmp,file,iocontext,default,codec,util,write,header,output,output,write,byte,password,length,0,byte,0,byte,1,secure,random,random,randomness,create,secure,byte,salt,new,byte,64,random,next,bytes,salt,byte,iv,new,byte,12,random,next,bytes,iv,byte,encrypted,bytes,encrypt,password,salt,iv,output,write,int,4,salt,length,4,iv,length,4,encrypted,bytes,length,output,write,int,salt,length,output,write,bytes,salt,salt,length,output,write,int,iv,length,output,write,bytes,iv,iv,length,output,write,int,encrypted,bytes,length,output,write,bytes,encrypted,bytes,encrypted,bytes,length,codec,util,write,footer,output,catch,final,access,denied,exception,e,final,string,message,string,format,locale,root,unable,to,create,temporary,keystore,at,s,please,check,filesystem,permissions,config,dir,resolve,tmp,file,throw,new,user,exception,exit,codes,config,message,e,path,keystore,file,keystore,path,config,dir,files,move,config,dir,resolve,tmp,file,keystore,file,standard,copy,option,standard,copy,option,posix,file,attribute,view,attrs,files,get,file,attribute,view,keystore,file,posix,file,attribute,view,class,if,attrs,null,attrs,set,permissions,posix,file,permissions,from,string,rw,rw
KeyStoreWrapper -> public synchronized void save(Path configDir, char[] password) throws Exception;1532511554;Write the keystore to the given config directory.;public synchronized void save(Path configDir, char[] password) throws Exception {_        ensureOpen()___        SimpleFSDirectory directory = new SimpleFSDirectory(configDir)__        _        String tmpFile = KEYSTORE_FILENAME + ".tmp"__        try (IndexOutput output = directory.createOutput(tmpFile, IOContext.DEFAULT)) {_            CodecUtil.writeHeader(output, KEYSTORE_FILENAME, FORMAT_VERSION)__            output.writeByte(password.length == 0 ? (byte)0 : (byte)1)___            _            SecureRandom random = Randomness.createSecure()__            _            _            byte[] salt = new byte[64]__            random.nextBytes(salt)__            _            _            byte[] iv = new byte[12]__            random.nextBytes(iv)__            _            byte[] encryptedBytes = encrypt(password, salt, iv)___            _            output.writeInt(4 + salt.length + 4 + iv.length + 4 + encryptedBytes.length)___            output.writeInt(salt.length)__            output.writeBytes(salt, salt.length)__            output.writeInt(iv.length)__            output.writeBytes(iv, iv.length)__            output.writeInt(encryptedBytes.length)__            output.writeBytes(encryptedBytes, encryptedBytes.length)___            CodecUtil.writeFooter(output)___        } catch (final AccessDeniedException e) {_            final String message = String.format(_                    Locale.ROOT,_                    "unable to create temporary keystore at [%s], please check filesystem permissions",_                    configDir.resolve(tmpFile))__            throw new UserException(ExitCodes.CONFIG, message, e)__        }__        Path keystoreFile = keystorePath(configDir)__        Files.move(configDir.resolve(tmpFile), keystoreFile, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.ATOMIC_MOVE)__        PosixFileAttributeView attrs = Files.getFileAttributeView(keystoreFile, PosixFileAttributeView.class)__        if (attrs != null) {_            _            attrs.setPermissions(PosixFilePermissions.fromString("rw-rw----"))__        }_    };write,the,keystore,to,the,given,config,directory;public,synchronized,void,save,path,config,dir,char,password,throws,exception,ensure,open,simple,fsdirectory,directory,new,simple,fsdirectory,config,dir,string,tmp,file,tmp,try,index,output,output,directory,create,output,tmp,file,iocontext,default,codec,util,write,header,output,output,write,byte,password,length,0,byte,0,byte,1,secure,random,random,randomness,create,secure,byte,salt,new,byte,64,random,next,bytes,salt,byte,iv,new,byte,12,random,next,bytes,iv,byte,encrypted,bytes,encrypt,password,salt,iv,output,write,int,4,salt,length,4,iv,length,4,encrypted,bytes,length,output,write,int,salt,length,output,write,bytes,salt,salt,length,output,write,int,iv,length,output,write,bytes,iv,iv,length,output,write,int,encrypted,bytes,length,output,write,bytes,encrypted,bytes,encrypted,bytes,length,codec,util,write,footer,output,catch,final,access,denied,exception,e,final,string,message,string,format,locale,root,unable,to,create,temporary,keystore,at,s,please,check,filesystem,permissions,config,dir,resolve,tmp,file,throw,new,user,exception,exit,codes,config,message,e,path,keystore,file,keystore,path,config,dir,files,move,config,dir,resolve,tmp,file,keystore,file,standard,copy,option,standard,copy,option,posix,file,attribute,view,attrs,files,get,file,attribute,view,keystore,file,posix,file,attribute,view,class,if,attrs,null,attrs,set,permissions,posix,file,permissions,from,string,rw,rw
KeyStoreWrapper -> public synchronized void save(Path configDir, char[] password) throws Exception;1533063033;Write the keystore to the given config directory.;public synchronized void save(Path configDir, char[] password) throws Exception {_        ensureOpen()___        SimpleFSDirectory directory = new SimpleFSDirectory(configDir)__        _        String tmpFile = KEYSTORE_FILENAME + ".tmp"__        try (IndexOutput output = directory.createOutput(tmpFile, IOContext.DEFAULT)) {_            CodecUtil.writeHeader(output, KEYSTORE_FILENAME, FORMAT_VERSION)__            output.writeByte(password.length == 0 ? (byte)0 : (byte)1)___            _            SecureRandom random = Randomness.createSecure()__            _            _            byte[] salt = new byte[64]__            random.nextBytes(salt)__            _            _            byte[] iv = new byte[12]__            random.nextBytes(iv)__            _            byte[] encryptedBytes = encrypt(password, salt, iv)___            _            output.writeInt(4 + salt.length + 4 + iv.length + 4 + encryptedBytes.length)___            output.writeInt(salt.length)__            output.writeBytes(salt, salt.length)__            output.writeInt(iv.length)__            output.writeBytes(iv, iv.length)__            output.writeInt(encryptedBytes.length)__            output.writeBytes(encryptedBytes, encryptedBytes.length)___            CodecUtil.writeFooter(output)___        } catch (final AccessDeniedException e) {_            final String message = String.format(_                    Locale.ROOT,_                    "unable to create temporary keystore at [%s], please check filesystem permissions",_                    configDir.resolve(tmpFile))__            throw new UserException(ExitCodes.CONFIG, message, e)__        }__        Path keystoreFile = keystorePath(configDir)__        Files.move(configDir.resolve(tmpFile), keystoreFile, StandardCopyOption.REPLACE_EXISTING, StandardCopyOption.ATOMIC_MOVE)__        PosixFileAttributeView attrs = Files.getFileAttributeView(keystoreFile, PosixFileAttributeView.class)__        if (attrs != null) {_            _            attrs.setPermissions(PosixFilePermissions.fromString("rw-rw----"))__        }_    };write,the,keystore,to,the,given,config,directory;public,synchronized,void,save,path,config,dir,char,password,throws,exception,ensure,open,simple,fsdirectory,directory,new,simple,fsdirectory,config,dir,string,tmp,file,tmp,try,index,output,output,directory,create,output,tmp,file,iocontext,default,codec,util,write,header,output,output,write,byte,password,length,0,byte,0,byte,1,secure,random,random,randomness,create,secure,byte,salt,new,byte,64,random,next,bytes,salt,byte,iv,new,byte,12,random,next,bytes,iv,byte,encrypted,bytes,encrypt,password,salt,iv,output,write,int,4,salt,length,4,iv,length,4,encrypted,bytes,length,output,write,int,salt,length,output,write,bytes,salt,salt,length,output,write,int,iv,length,output,write,bytes,iv,iv,length,output,write,int,encrypted,bytes,length,output,write,bytes,encrypted,bytes,encrypted,bytes,length,codec,util,write,footer,output,catch,final,access,denied,exception,e,final,string,message,string,format,locale,root,unable,to,create,temporary,keystore,at,s,please,check,filesystem,permissions,config,dir,resolve,tmp,file,throw,new,user,exception,exit,codes,config,message,e,path,keystore,file,keystore,path,config,dir,files,move,config,dir,resolve,tmp,file,keystore,file,standard,copy,option,standard,copy,option,posix,file,attribute,view,attrs,files,get,file,attribute,view,keystore,file,posix,file,attribute,view,class,if,attrs,null,attrs,set,permissions,posix,file,permissions,from,string,rw,rw
KeyStoreWrapper -> void remove(String setting);1524684173;Remove the given setting from the keystore.;void remove(String setting) {_        assert isLoaded()__        Entry oldEntry = entries.get().remove(setting)__        if (oldEntry != null) {_            Arrays.fill(oldEntry.bytes, (byte)0)__        }_    };remove,the,given,setting,from,the,keystore;void,remove,string,setting,assert,is,loaded,entry,old,entry,entries,get,remove,setting,if,old,entry,null,arrays,fill,old,entry,bytes,byte,0
KeyStoreWrapper -> void remove(String setting);1525645056;Remove the given setting from the keystore.;void remove(String setting) {_        assert isLoaded()__        Entry oldEntry = entries.get().remove(setting)__        if (oldEntry != null) {_            Arrays.fill(oldEntry.bytes, (byte)0)__        }_    };remove,the,given,setting,from,the,keystore;void,remove,string,setting,assert,is,loaded,entry,old,entry,entries,get,remove,setting,if,old,entry,null,arrays,fill,old,entry,bytes,byte,0
KeyStoreWrapper -> void remove(String setting);1526374795;Remove the given setting from the keystore.;void remove(String setting) {_        ensureOpen()__        Entry oldEntry = entries.get().remove(setting)__        if (oldEntry != null) {_            Arrays.fill(oldEntry.bytes, (byte)0)__        }_    };remove,the,given,setting,from,the,keystore;void,remove,string,setting,ensure,open,entry,old,entry,entries,get,remove,setting,if,old,entry,null,arrays,fill,old,entry,bytes,byte,0
KeyStoreWrapper -> void remove(String setting);1529341607;Remove the given setting from the keystore.;void remove(String setting) {_        ensureOpen()__        Entry oldEntry = entries.get().remove(setting)__        if (oldEntry != null) {_            Arrays.fill(oldEntry.bytes, (byte)0)__        }_    };remove,the,given,setting,from,the,keystore;void,remove,string,setting,ensure,open,entry,old,entry,entries,get,remove,setting,if,old,entry,null,arrays,fill,old,entry,bytes,byte,0
KeyStoreWrapper -> void remove(String setting);1532511554;Remove the given setting from the keystore.;void remove(String setting) {_        ensureOpen()__        Entry oldEntry = entries.get().remove(setting)__        if (oldEntry != null) {_            Arrays.fill(oldEntry.bytes, (byte)0)__        }_    };remove,the,given,setting,from,the,keystore;void,remove,string,setting,ensure,open,entry,old,entry,entries,get,remove,setting,if,old,entry,null,arrays,fill,old,entry,bytes,byte,0
KeyStoreWrapper -> void remove(String setting);1533063033;Remove the given setting from the keystore.;void remove(String setting) {_        ensureOpen()__        Entry oldEntry = entries.get().remove(setting)__        if (oldEntry != null) {_            Arrays.fill(oldEntry.bytes, (byte)0)__        }_    };remove,the,given,setting,from,the,keystore;void,remove,string,setting,ensure,open,entry,old,entry,entries,get,remove,setting,if,old,entry,null,arrays,fill,old,entry,bytes,byte,0
KeyStoreWrapper -> synchronized void setString(String setting, char[] value);1526374795;Set a string setting.;synchronized void setString(String setting, char[] value) {_        ensureOpen()__        validateSettingName(setting)___        ByteBuffer byteBuffer = StandardCharsets.UTF_8.encode(CharBuffer.wrap(value))__        byte[] bytes = Arrays.copyOfRange(byteBuffer.array(), byteBuffer.position(), byteBuffer.limit())__        Entry oldEntry = entries.get().put(setting, new Entry(EntryType.STRING, bytes))__        if (oldEntry != null) {_            Arrays.fill(oldEntry.bytes, (byte)0)__        }_    };set,a,string,setting;synchronized,void,set,string,string,setting,char,value,ensure,open,validate,setting,name,setting,byte,buffer,byte,buffer,standard,charsets,encode,char,buffer,wrap,value,byte,bytes,arrays,copy,of,range,byte,buffer,array,byte,buffer,position,byte,buffer,limit,entry,old,entry,entries,get,put,setting,new,entry,entry,type,string,bytes,if,old,entry,null,arrays,fill,old,entry,bytes,byte,0
KeyStoreWrapper -> synchronized void setString(String setting, char[] value);1529341607;Set a string setting.;synchronized void setString(String setting, char[] value) {_        ensureOpen()__        validateSettingName(setting)___        ByteBuffer byteBuffer = StandardCharsets.UTF_8.encode(CharBuffer.wrap(value))__        byte[] bytes = Arrays.copyOfRange(byteBuffer.array(), byteBuffer.position(), byteBuffer.limit())__        Entry oldEntry = entries.get().put(setting, new Entry(EntryType.STRING, bytes))__        if (oldEntry != null) {_            Arrays.fill(oldEntry.bytes, (byte)0)__        }_    };set,a,string,setting;synchronized,void,set,string,string,setting,char,value,ensure,open,validate,setting,name,setting,byte,buffer,byte,buffer,standard,charsets,encode,char,buffer,wrap,value,byte,bytes,arrays,copy,of,range,byte,buffer,array,byte,buffer,position,byte,buffer,limit,entry,old,entry,entries,get,put,setting,new,entry,entry,type,string,bytes,if,old,entry,null,arrays,fill,old,entry,bytes,byte,0
KeyStoreWrapper -> synchronized void setString(String setting, char[] value);1532511554;Set a string setting.;synchronized void setString(String setting, char[] value) {_        ensureOpen()__        validateSettingName(setting)___        ByteBuffer byteBuffer = StandardCharsets.UTF_8.encode(CharBuffer.wrap(value))__        byte[] bytes = Arrays.copyOfRange(byteBuffer.array(), byteBuffer.position(), byteBuffer.limit())__        Entry oldEntry = entries.get().put(setting, new Entry(EntryType.STRING, bytes))__        if (oldEntry != null) {_            Arrays.fill(oldEntry.bytes, (byte)0)__        }_    };set,a,string,setting;synchronized,void,set,string,string,setting,char,value,ensure,open,validate,setting,name,setting,byte,buffer,byte,buffer,standard,charsets,encode,char,buffer,wrap,value,byte,bytes,arrays,copy,of,range,byte,buffer,array,byte,buffer,position,byte,buffer,limit,entry,old,entry,entries,get,put,setting,new,entry,entry,type,string,bytes,if,old,entry,null,arrays,fill,old,entry,bytes,byte,0
KeyStoreWrapper -> synchronized void setString(String setting, char[] value);1533063033;Set a string setting.;synchronized void setString(String setting, char[] value) {_        ensureOpen()__        validateSettingName(setting)___        ByteBuffer byteBuffer = StandardCharsets.UTF_8.encode(CharBuffer.wrap(value))__        byte[] bytes = Arrays.copyOfRange(byteBuffer.array(), byteBuffer.position(), byteBuffer.limit())__        Entry oldEntry = entries.get().put(setting, new Entry(EntryType.STRING, bytes))__        if (oldEntry != null) {_            Arrays.fill(oldEntry.bytes, (byte)0)__        }_    };set,a,string,setting;synchronized,void,set,string,string,setting,char,value,ensure,open,validate,setting,name,setting,byte,buffer,byte,buffer,standard,charsets,encode,char,buffer,wrap,value,byte,bytes,arrays,copy,of,range,byte,buffer,array,byte,buffer,position,byte,buffer,limit,entry,old,entry,entries,get,put,setting,new,entry,entry,type,string,bytes,if,old,entry,null,arrays,fill,old,entry,bytes,byte,0
KeyStoreWrapper -> public static void validateSettingName(String setting);1524684173;Ensure the given setting name is allowed.__@throws IllegalArgumentException if the setting name is not valid;public static void validateSettingName(String setting) {_        if (ALLOWED_SETTING_NAME.matcher(setting).matches() == false) {_            throw new IllegalArgumentException("Setting name [" + setting + "] does not match the allowed setting name pattern ["_                + ALLOWED_SETTING_NAME.pattern() + "]")__        }_    };ensure,the,given,setting,name,is,allowed,throws,illegal,argument,exception,if,the,setting,name,is,not,valid;public,static,void,validate,setting,name,string,setting,if,matcher,setting,matches,false,throw,new,illegal,argument,exception,setting,name,setting,does,not,match,the,allowed,setting,name,pattern,pattern
KeyStoreWrapper -> public static void validateSettingName(String setting);1525645056;Ensure the given setting name is allowed.__@throws IllegalArgumentException if the setting name is not valid;public static void validateSettingName(String setting) {_        if (ALLOWED_SETTING_NAME.matcher(setting).matches() == false) {_            throw new IllegalArgumentException("Setting name [" + setting + "] does not match the allowed setting name pattern ["_                + ALLOWED_SETTING_NAME.pattern() + "]")__        }_    };ensure,the,given,setting,name,is,allowed,throws,illegal,argument,exception,if,the,setting,name,is,not,valid;public,static,void,validate,setting,name,string,setting,if,matcher,setting,matches,false,throw,new,illegal,argument,exception,setting,name,setting,does,not,match,the,allowed,setting,name,pattern,pattern
KeyStoreWrapper -> public static void validateSettingName(String setting);1526374795;Ensure the given setting name is allowed.__@throws IllegalArgumentException if the setting name is not valid;public static void validateSettingName(String setting) {_        if (ALLOWED_SETTING_NAME.matcher(setting).matches() == false) {_            throw new IllegalArgumentException("Setting name [" + setting + "] does not match the allowed setting name pattern ["_                + ALLOWED_SETTING_NAME.pattern() + "]")__        }_    };ensure,the,given,setting,name,is,allowed,throws,illegal,argument,exception,if,the,setting,name,is,not,valid;public,static,void,validate,setting,name,string,setting,if,matcher,setting,matches,false,throw,new,illegal,argument,exception,setting,name,setting,does,not,match,the,allowed,setting,name,pattern,pattern
KeyStoreWrapper -> public static void validateSettingName(String setting);1529341607;Ensure the given setting name is allowed.__@throws IllegalArgumentException if the setting name is not valid;public static void validateSettingName(String setting) {_        if (ALLOWED_SETTING_NAME.matcher(setting).matches() == false) {_            throw new IllegalArgumentException("Setting name [" + setting + "] does not match the allowed setting name pattern ["_                + ALLOWED_SETTING_NAME.pattern() + "]")__        }_    };ensure,the,given,setting,name,is,allowed,throws,illegal,argument,exception,if,the,setting,name,is,not,valid;public,static,void,validate,setting,name,string,setting,if,matcher,setting,matches,false,throw,new,illegal,argument,exception,setting,name,setting,does,not,match,the,allowed,setting,name,pattern,pattern
KeyStoreWrapper -> public static void validateSettingName(String setting);1532511554;Ensure the given setting name is allowed.__@throws IllegalArgumentException if the setting name is not valid;public static void validateSettingName(String setting) {_        if (ALLOWED_SETTING_NAME.matcher(setting).matches() == false) {_            throw new IllegalArgumentException("Setting name [" + setting + "] does not match the allowed setting name pattern ["_                + ALLOWED_SETTING_NAME.pattern() + "]")__        }_    };ensure,the,given,setting,name,is,allowed,throws,illegal,argument,exception,if,the,setting,name,is,not,valid;public,static,void,validate,setting,name,string,setting,if,matcher,setting,matches,false,throw,new,illegal,argument,exception,setting,name,setting,does,not,match,the,allowed,setting,name,pattern,pattern
KeyStoreWrapper -> public static void validateSettingName(String setting);1533063033;Ensure the given setting name is allowed.__@throws IllegalArgumentException if the setting name is not valid;public static void validateSettingName(String setting) {_        if (ALLOWED_SETTING_NAME.matcher(setting).matches() == false) {_            throw new IllegalArgumentException("Setting name [" + setting + "] does not match the allowed setting name pattern ["_                + ALLOWED_SETTING_NAME.pattern() + "]")__        }_    };ensure,the,given,setting,name,is,allowed,throws,illegal,argument,exception,if,the,setting,name,is,not,valid;public,static,void,validate,setting,name,string,setting,if,matcher,setting,matches,false,throw,new,illegal,argument,exception,setting,name,setting,does,not,match,the,allowed,setting,name,pattern,pattern
KeyStoreWrapper -> public static KeyStoreWrapper create();1524684173;Constructs a new keystore with the given password.;public static KeyStoreWrapper create() {_        KeyStoreWrapper wrapper = new KeyStoreWrapper(FORMAT_VERSION, false, null)__        wrapper.entries.set(new HashMap<>())__        addBootstrapSeed(wrapper)__        return wrapper__    };constructs,a,new,keystore,with,the,given,password;public,static,key,store,wrapper,create,key,store,wrapper,wrapper,new,key,store,wrapper,false,null,wrapper,entries,set,new,hash,map,add,bootstrap,seed,wrapper,return,wrapper
KeyStoreWrapper -> public static KeyStoreWrapper create();1525645056;Constructs a new keystore with the given password.;public static KeyStoreWrapper create() {_        KeyStoreWrapper wrapper = new KeyStoreWrapper(FORMAT_VERSION, false, null)__        wrapper.entries.set(new HashMap<>())__        addBootstrapSeed(wrapper)__        return wrapper__    };constructs,a,new,keystore,with,the,given,password;public,static,key,store,wrapper,create,key,store,wrapper,wrapper,new,key,store,wrapper,false,null,wrapper,entries,set,new,hash,map,add,bootstrap,seed,wrapper,return,wrapper
KeyStoreWrapper -> public static KeyStoreWrapper create();1526374795;Constructs a new keystore with the given password.;public static KeyStoreWrapper create() {_        KeyStoreWrapper wrapper = new KeyStoreWrapper(FORMAT_VERSION, false, null)__        wrapper.entries.set(new HashMap<>())__        addBootstrapSeed(wrapper)__        return wrapper__    };constructs,a,new,keystore,with,the,given,password;public,static,key,store,wrapper,create,key,store,wrapper,wrapper,new,key,store,wrapper,false,null,wrapper,entries,set,new,hash,map,add,bootstrap,seed,wrapper,return,wrapper
KeyStoreWrapper -> public static KeyStoreWrapper create();1529341607;Constructs a new keystore with the given password.;public static KeyStoreWrapper create() {_        KeyStoreWrapper wrapper = new KeyStoreWrapper(FORMAT_VERSION, false, null)__        wrapper.entries.set(new HashMap<>())__        addBootstrapSeed(wrapper)__        return wrapper__    };constructs,a,new,keystore,with,the,given,password;public,static,key,store,wrapper,create,key,store,wrapper,wrapper,new,key,store,wrapper,false,null,wrapper,entries,set,new,hash,map,add,bootstrap,seed,wrapper,return,wrapper
KeyStoreWrapper -> public static KeyStoreWrapper create();1532511554;Constructs a new keystore with the given password.;public static KeyStoreWrapper create() {_        KeyStoreWrapper wrapper = new KeyStoreWrapper(FORMAT_VERSION, false, null)__        wrapper.entries.set(new HashMap<>())__        addBootstrapSeed(wrapper)__        return wrapper__    };constructs,a,new,keystore,with,the,given,password;public,static,key,store,wrapper,create,key,store,wrapper,wrapper,new,key,store,wrapper,false,null,wrapper,entries,set,new,hash,map,add,bootstrap,seed,wrapper,return,wrapper
KeyStoreWrapper -> public static KeyStoreWrapper create();1533063033;Constructs a new keystore with the given password.;public static KeyStoreWrapper create() {_        KeyStoreWrapper wrapper = new KeyStoreWrapper(FORMAT_VERSION, false, null)__        wrapper.entries.set(new HashMap<>())__        addBootstrapSeed(wrapper)__        return wrapper__    };constructs,a,new,keystore,with,the,given,password;public,static,key,store,wrapper,create,key,store,wrapper,wrapper,new,key,store,wrapper,false,null,wrapper,entries,set,new,hash,map,add,bootstrap,seed,wrapper,return,wrapper
KeyStoreWrapper -> private byte[] encrypt(char[] password, byte[] salt, byte[] iv) throws GeneralSecurityException, IOException;1524684173;Encrypt the keystore entries and return the encrypted data.;private byte[] encrypt(char[] password, byte[] salt, byte[] iv) throws GeneralSecurityException, IOException {_        assert isLoaded()___        ByteArrayOutputStream bytes = new ByteArrayOutputStream()__        Cipher cipher = createCipher(Cipher.ENCRYPT_MODE, password, salt, iv)__        try (CipherOutputStream cipherStream = new CipherOutputStream(bytes, cipher)__             DataOutputStream output = new DataOutputStream(cipherStream)) {__            output.writeInt(entries.get().size())__            for (Map.Entry<String, Entry> mapEntry : entries.get().entrySet()) {_                output.writeUTF(mapEntry.getKey())__                Entry entry = mapEntry.getValue()__                output.writeUTF(entry.type.name())__                output.writeInt(entry.bytes.length)__                output.write(entry.bytes)__            }_        }__        return bytes.toByteArray()__    };encrypt,the,keystore,entries,and,return,the,encrypted,data;private,byte,encrypt,char,password,byte,salt,byte,iv,throws,general,security,exception,ioexception,assert,is,loaded,byte,array,output,stream,bytes,new,byte,array,output,stream,cipher,cipher,create,cipher,cipher,password,salt,iv,try,cipher,output,stream,cipher,stream,new,cipher,output,stream,bytes,cipher,data,output,stream,output,new,data,output,stream,cipher,stream,output,write,int,entries,get,size,for,map,entry,string,entry,map,entry,entries,get,entry,set,output,write,utf,map,entry,get,key,entry,entry,map,entry,get,value,output,write,utf,entry,type,name,output,write,int,entry,bytes,length,output,write,entry,bytes,return,bytes,to,byte,array
KeyStoreWrapper -> private byte[] encrypt(char[] password, byte[] salt, byte[] iv) throws GeneralSecurityException, IOException;1525645056;Encrypt the keystore entries and return the encrypted data.;private byte[] encrypt(char[] password, byte[] salt, byte[] iv) throws GeneralSecurityException, IOException {_        assert isLoaded()___        ByteArrayOutputStream bytes = new ByteArrayOutputStream()__        Cipher cipher = createCipher(Cipher.ENCRYPT_MODE, password, salt, iv)__        try (CipherOutputStream cipherStream = new CipherOutputStream(bytes, cipher)__             DataOutputStream output = new DataOutputStream(cipherStream)) {_            output.writeInt(entries.get().size())__            for (Map.Entry<String, Entry> mapEntry : entries.get().entrySet()) {_                output.writeUTF(mapEntry.getKey())__                Entry entry = mapEntry.getValue()__                output.writeUTF(entry.type.name())__                output.writeInt(entry.bytes.length)__                output.write(entry.bytes)__            }_        }_        return bytes.toByteArray()__    };encrypt,the,keystore,entries,and,return,the,encrypted,data;private,byte,encrypt,char,password,byte,salt,byte,iv,throws,general,security,exception,ioexception,assert,is,loaded,byte,array,output,stream,bytes,new,byte,array,output,stream,cipher,cipher,create,cipher,cipher,password,salt,iv,try,cipher,output,stream,cipher,stream,new,cipher,output,stream,bytes,cipher,data,output,stream,output,new,data,output,stream,cipher,stream,output,write,int,entries,get,size,for,map,entry,string,entry,map,entry,entries,get,entry,set,output,write,utf,map,entry,get,key,entry,entry,map,entry,get,value,output,write,utf,entry,type,name,output,write,int,entry,bytes,length,output,write,entry,bytes,return,bytes,to,byte,array
KeyStoreWrapper -> private byte[] encrypt(char[] password, byte[] salt, byte[] iv) throws GeneralSecurityException, IOException;1526374795;Encrypt the keystore entries and return the encrypted data.;private byte[] encrypt(char[] password, byte[] salt, byte[] iv) throws GeneralSecurityException, IOException {_        assert isLoaded()___        ByteArrayOutputStream bytes = new ByteArrayOutputStream()__        Cipher cipher = createCipher(Cipher.ENCRYPT_MODE, password, salt, iv)__        try (CipherOutputStream cipherStream = new CipherOutputStream(bytes, cipher)__             DataOutputStream output = new DataOutputStream(cipherStream)) {_            output.writeInt(entries.get().size())__            for (Map.Entry<String, Entry> mapEntry : entries.get().entrySet()) {_                output.writeUTF(mapEntry.getKey())__                Entry entry = mapEntry.getValue()__                output.writeUTF(entry.type.name())__                output.writeInt(entry.bytes.length)__                output.write(entry.bytes)__            }_        }_        return bytes.toByteArray()__    };encrypt,the,keystore,entries,and,return,the,encrypted,data;private,byte,encrypt,char,password,byte,salt,byte,iv,throws,general,security,exception,ioexception,assert,is,loaded,byte,array,output,stream,bytes,new,byte,array,output,stream,cipher,cipher,create,cipher,cipher,password,salt,iv,try,cipher,output,stream,cipher,stream,new,cipher,output,stream,bytes,cipher,data,output,stream,output,new,data,output,stream,cipher,stream,output,write,int,entries,get,size,for,map,entry,string,entry,map,entry,entries,get,entry,set,output,write,utf,map,entry,get,key,entry,entry,map,entry,get,value,output,write,utf,entry,type,name,output,write,int,entry,bytes,length,output,write,entry,bytes,return,bytes,to,byte,array
KeyStoreWrapper -> private byte[] encrypt(char[] password, byte[] salt, byte[] iv) throws GeneralSecurityException, IOException;1529341607;Encrypt the keystore entries and return the encrypted data.;private byte[] encrypt(char[] password, byte[] salt, byte[] iv) throws GeneralSecurityException, IOException {_        assert isLoaded()___        ByteArrayOutputStream bytes = new ByteArrayOutputStream()__        Cipher cipher = createCipher(Cipher.ENCRYPT_MODE, password, salt, iv)__        try (CipherOutputStream cipherStream = new CipherOutputStream(bytes, cipher)__             DataOutputStream output = new DataOutputStream(cipherStream)) {_            output.writeInt(entries.get().size())__            for (Map.Entry<String, Entry> mapEntry : entries.get().entrySet()) {_                output.writeUTF(mapEntry.getKey())__                Entry entry = mapEntry.getValue()__                output.writeUTF(entry.type.name())__                output.writeInt(entry.bytes.length)__                output.write(entry.bytes)__            }_        }_        return bytes.toByteArray()__    };encrypt,the,keystore,entries,and,return,the,encrypted,data;private,byte,encrypt,char,password,byte,salt,byte,iv,throws,general,security,exception,ioexception,assert,is,loaded,byte,array,output,stream,bytes,new,byte,array,output,stream,cipher,cipher,create,cipher,cipher,password,salt,iv,try,cipher,output,stream,cipher,stream,new,cipher,output,stream,bytes,cipher,data,output,stream,output,new,data,output,stream,cipher,stream,output,write,int,entries,get,size,for,map,entry,string,entry,map,entry,entries,get,entry,set,output,write,utf,map,entry,get,key,entry,entry,map,entry,get,value,output,write,utf,entry,type,name,output,write,int,entry,bytes,length,output,write,entry,bytes,return,bytes,to,byte,array
KeyStoreWrapper -> private byte[] encrypt(char[] password, byte[] salt, byte[] iv) throws GeneralSecurityException, IOException;1532511554;Encrypt the keystore entries and return the encrypted data.;private byte[] encrypt(char[] password, byte[] salt, byte[] iv) throws GeneralSecurityException, IOException {_        assert isLoaded()___        ByteArrayOutputStream bytes = new ByteArrayOutputStream()__        Cipher cipher = createCipher(Cipher.ENCRYPT_MODE, password, salt, iv)__        try (CipherOutputStream cipherStream = new CipherOutputStream(bytes, cipher)__             DataOutputStream output = new DataOutputStream(cipherStream)) {_            output.writeInt(entries.get().size())__            for (Map.Entry<String, Entry> mapEntry : entries.get().entrySet()) {_                output.writeUTF(mapEntry.getKey())__                Entry entry = mapEntry.getValue()__                output.writeUTF(entry.type.name())__                output.writeInt(entry.bytes.length)__                output.write(entry.bytes)__            }_        }_        return bytes.toByteArray()__    };encrypt,the,keystore,entries,and,return,the,encrypted,data;private,byte,encrypt,char,password,byte,salt,byte,iv,throws,general,security,exception,ioexception,assert,is,loaded,byte,array,output,stream,bytes,new,byte,array,output,stream,cipher,cipher,create,cipher,cipher,password,salt,iv,try,cipher,output,stream,cipher,stream,new,cipher,output,stream,bytes,cipher,data,output,stream,output,new,data,output,stream,cipher,stream,output,write,int,entries,get,size,for,map,entry,string,entry,map,entry,entries,get,entry,set,output,write,utf,map,entry,get,key,entry,entry,map,entry,get,value,output,write,utf,entry,type,name,output,write,int,entry,bytes,length,output,write,entry,bytes,return,bytes,to,byte,array
KeyStoreWrapper -> private byte[] encrypt(char[] password, byte[] salt, byte[] iv) throws GeneralSecurityException, IOException;1533063033;Encrypt the keystore entries and return the encrypted data.;private byte[] encrypt(char[] password, byte[] salt, byte[] iv) throws GeneralSecurityException, IOException {_        assert isLoaded()___        ByteArrayOutputStream bytes = new ByteArrayOutputStream()__        Cipher cipher = createCipher(Cipher.ENCRYPT_MODE, password, salt, iv)__        try (CipherOutputStream cipherStream = new CipherOutputStream(bytes, cipher)__             DataOutputStream output = new DataOutputStream(cipherStream)) {_            output.writeInt(entries.get().size())__            for (Map.Entry<String, Entry> mapEntry : entries.get().entrySet()) {_                output.writeUTF(mapEntry.getKey())__                Entry entry = mapEntry.getValue()__                output.writeUTF(entry.type.name())__                output.writeInt(entry.bytes.length)__                output.write(entry.bytes)__            }_        }_        return bytes.toByteArray()__    };encrypt,the,keystore,entries,and,return,the,encrypted,data;private,byte,encrypt,char,password,byte,salt,byte,iv,throws,general,security,exception,ioexception,assert,is,loaded,byte,array,output,stream,bytes,new,byte,array,output,stream,cipher,cipher,create,cipher,cipher,password,salt,iv,try,cipher,output,stream,cipher,stream,new,cipher,output,stream,bytes,cipher,data,output,stream,output,new,data,output,stream,cipher,stream,output,write,int,entries,get,size,for,map,entry,string,entry,map,entry,entries,get,entry,set,output,write,utf,map,entry,get,key,entry,entry,map,entry,get,value,output,write,utf,entry,type,name,output,write,int,entry,bytes,length,output,write,entry,bytes,return,bytes,to,byte,array
KeyStoreWrapper -> void setFile(String setting, byte[] bytes);1524684173;Set a file setting.;void setFile(String setting, byte[] bytes) {_        assert isLoaded()__        validateSettingName(setting)___        Entry oldEntry = entries.get().put(setting, new Entry(EntryType.FILE, Arrays.copyOf(bytes, bytes.length)))__        if (oldEntry != null) {_            Arrays.fill(oldEntry.bytes, (byte)0)__        }_    };set,a,file,setting;void,set,file,string,setting,byte,bytes,assert,is,loaded,validate,setting,name,setting,entry,old,entry,entries,get,put,setting,new,entry,entry,type,file,arrays,copy,of,bytes,bytes,length,if,old,entry,null,arrays,fill,old,entry,bytes,byte,0
KeyStoreWrapper -> void setFile(String setting, byte[] bytes);1525645056;Set a file setting.;void setFile(String setting, byte[] bytes) {_        assert isLoaded()__        validateSettingName(setting)___        Entry oldEntry = entries.get().put(setting, new Entry(EntryType.FILE, Arrays.copyOf(bytes, bytes.length)))__        if (oldEntry != null) {_            Arrays.fill(oldEntry.bytes, (byte)0)__        }_    };set,a,file,setting;void,set,file,string,setting,byte,bytes,assert,is,loaded,validate,setting,name,setting,entry,old,entry,entries,get,put,setting,new,entry,entry,type,file,arrays,copy,of,bytes,bytes,length,if,old,entry,null,arrays,fill,old,entry,bytes,byte,0
KeyStoreWrapper -> synchronized void setFile(String setting, byte[] bytes);1526374795;Set a file setting.;synchronized void setFile(String setting, byte[] bytes) {_        ensureOpen()__        validateSettingName(setting)___        Entry oldEntry = entries.get().put(setting, new Entry(EntryType.FILE, Arrays.copyOf(bytes, bytes.length)))__        if (oldEntry != null) {_            Arrays.fill(oldEntry.bytes, (byte)0)__        }_    };set,a,file,setting;synchronized,void,set,file,string,setting,byte,bytes,ensure,open,validate,setting,name,setting,entry,old,entry,entries,get,put,setting,new,entry,entry,type,file,arrays,copy,of,bytes,bytes,length,if,old,entry,null,arrays,fill,old,entry,bytes,byte,0
KeyStoreWrapper -> synchronized void setFile(String setting, byte[] bytes);1529341607;Set a file setting.;synchronized void setFile(String setting, byte[] bytes) {_        ensureOpen()__        validateSettingName(setting)___        Entry oldEntry = entries.get().put(setting, new Entry(EntryType.FILE, Arrays.copyOf(bytes, bytes.length)))__        if (oldEntry != null) {_            Arrays.fill(oldEntry.bytes, (byte)0)__        }_    };set,a,file,setting;synchronized,void,set,file,string,setting,byte,bytes,ensure,open,validate,setting,name,setting,entry,old,entry,entries,get,put,setting,new,entry,entry,type,file,arrays,copy,of,bytes,bytes,length,if,old,entry,null,arrays,fill,old,entry,bytes,byte,0
KeyStoreWrapper -> synchronized void setFile(String setting, byte[] bytes);1532511554;Set a file setting.;synchronized void setFile(String setting, byte[] bytes) {_        ensureOpen()__        validateSettingName(setting)___        Entry oldEntry = entries.get().put(setting, new Entry(EntryType.FILE, Arrays.copyOf(bytes, bytes.length)))__        if (oldEntry != null) {_            Arrays.fill(oldEntry.bytes, (byte)0)__        }_    };set,a,file,setting;synchronized,void,set,file,string,setting,byte,bytes,ensure,open,validate,setting,name,setting,entry,old,entry,entries,get,put,setting,new,entry,entry,type,file,arrays,copy,of,bytes,bytes,length,if,old,entry,null,arrays,fill,old,entry,bytes,byte,0
KeyStoreWrapper -> synchronized void setFile(String setting, byte[] bytes);1533063033;Set a file setting.;synchronized void setFile(String setting, byte[] bytes) {_        ensureOpen()__        validateSettingName(setting)___        Entry oldEntry = entries.get().put(setting, new Entry(EntryType.FILE, Arrays.copyOf(bytes, bytes.length)))__        if (oldEntry != null) {_            Arrays.fill(oldEntry.bytes, (byte)0)__        }_    };set,a,file,setting;synchronized,void,set,file,string,setting,byte,bytes,ensure,open,validate,setting,name,setting,entry,old,entry,entries,get,put,setting,new,entry,entry,type,file,arrays,copy,of,bytes,bytes,length,if,old,entry,null,arrays,fill,old,entry,bytes,byte,0
KeyStoreWrapper -> public boolean hasPassword();1524684173;Return true iff calling {@link #decrypt(char[])} requires a non-empty password.;public boolean hasPassword() {_        return hasPassword__    };return,true,iff,calling,link,decrypt,char,requires,a,non,empty,password;public,boolean,has,password,return,has,password
KeyStoreWrapper -> public boolean hasPassword();1525645056;Return true iff calling {@link #decrypt(char[])} requires a non-empty password.;public boolean hasPassword() {_        return hasPassword__    };return,true,iff,calling,link,decrypt,char,requires,a,non,empty,password;public,boolean,has,password,return,has,password
KeyStoreWrapper -> public boolean hasPassword();1526374795;Return true iff calling {@link #decrypt(char[])} requires a non-empty password.;public boolean hasPassword() {_        return hasPassword__    };return,true,iff,calling,link,decrypt,char,requires,a,non,empty,password;public,boolean,has,password,return,has,password
KeyStoreWrapper -> public boolean hasPassword();1529341607;Return true iff calling {@link #decrypt(char[])} requires a non-empty password.;public boolean hasPassword() {_        return hasPassword__    };return,true,iff,calling,link,decrypt,char,requires,a,non,empty,password;public,boolean,has,password,return,has,password
KeyStoreWrapper -> public boolean hasPassword();1532511554;Return true iff calling {@link #decrypt(char[])} requires a non-empty password.;public boolean hasPassword() {_        return hasPassword__    };return,true,iff,calling,link,decrypt,char,requires,a,non,empty,password;public,boolean,has,password,return,has,password
KeyStoreWrapper -> public boolean hasPassword();1533063033;Return true iff calling {@link #decrypt(char[])} requires a non-empty password.;public boolean hasPassword() {_        return hasPassword__    };return,true,iff,calling,link,decrypt,char,requires,a,non,empty,password;public,boolean,has,password,return,has,password
