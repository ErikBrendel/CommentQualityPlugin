commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected String executor() {     return ThreadPool.Names.MANAGEMENT. }
false;protected;2;4;;@Override protected ClusterBlockException checkBlock(ClusterAllocationExplainRequest request, ClusterState state) {     return state.blocks().globalBlockedException(ClusterBlockLevel.METADATA_READ). }
false;protected;0;4;;@Override protected ClusterAllocationExplainResponse newResponse() {     return new ClusterAllocationExplainResponse(). }
false;protected;3;15;;@Override protected void masterOperation(final ClusterAllocationExplainRequest request, final ClusterState state, final ActionListener<ClusterAllocationExplainResponse> listener) {     final RoutingNodes routingNodes = state.getRoutingNodes().     final ClusterInfo clusterInfo = clusterInfoService.getClusterInfo().     final RoutingAllocation allocation = new RoutingAllocation(allocationDeciders, routingNodes, state, clusterInfo, System.nanoTime()).     ShardRouting shardRouting = findShardToExplain(request, allocation).     logger.debug("explaining the allocation for [{}], found shard [{}]", request, shardRouting).     ClusterAllocationExplanation cae = explainShard(shardRouting, allocation, request.includeDiskInfo() ? clusterInfo : null, request.includeYesDecisions(), gatewayAllocator, shardAllocator).     listener.onResponse(new ClusterAllocationExplainResponse(cae)). }
true;public,static;6;23;// public for testing ;// public for testing public static ClusterAllocationExplanation explainShard(ShardRouting shardRouting, RoutingAllocation allocation, ClusterInfo clusterInfo, boolean includeYesDecisions, GatewayAllocator gatewayAllocator, ShardsAllocator shardAllocator) {     allocation.setDebugMode(includeYesDecisions ? DebugMode.ON : DebugMode.EXCLUDE_YES_DECISIONS).     ShardAllocationDecision shardDecision.     if (shardRouting.initializing() || shardRouting.relocating()) {         shardDecision = ShardAllocationDecision.NOT_TAKEN.     } else {         AllocateUnassignedDecision allocateDecision = shardRouting.unassigned() ? gatewayAllocator.decideUnassignedShardAllocation(shardRouting, allocation) : AllocateUnassignedDecision.NOT_TAKEN.         if (allocateDecision.isDecisionTaken() == false) {             shardDecision = shardAllocator.decideShardAllocation(shardRouting, allocation).         } else {             shardDecision = new ShardAllocationDecision(allocateDecision, MoveDecision.NOT_TAKEN).         }     }     return new ClusterAllocationExplanation(shardRouting, shardRouting.currentNodeId() != null ? allocation.nodes().get(shardRouting.currentNodeId()) : null, shardRouting.relocatingNodeId() != null ? allocation.nodes().get(shardRouting.relocatingNodeId()) : null, clusterInfo, shardDecision). }
true;public,static;2;68;// public for testing ;// public for testing public static ShardRouting findShardToExplain(ClusterAllocationExplainRequest request, RoutingAllocation allocation) {     ShardRouting foundShard = null.     if (request.useAnyUnassignedShard()) {         // If we can use any shard, just pick the first unassigned one (if there are any)         RoutingNodes.UnassignedShards.UnassignedIterator ui = allocation.routingNodes().unassigned().iterator().         if (ui.hasNext()) {             foundShard = ui.next().         }         if (foundShard == null) {             throw new IllegalArgumentException("unable to find any unassigned shards to explain [" + request + "]").         }     } else {         String index = request.getIndex().         int shard = request.getShard().         if (request.isPrimary()) {             // If we're looking for the primary shard, there's only one copy, so pick it directly             foundShard = allocation.routingTable().shardRoutingTable(index, shard).primaryShard().             if (request.getCurrentNode() != null) {                 DiscoveryNode primaryNode = allocation.nodes().resolveNode(request.getCurrentNode()).                 // the primary is assigned to a node other than the node specified in the request                 if (primaryNode.getId().equals(foundShard.currentNodeId()) == false) {                     throw new IllegalArgumentException("unable to find primary shard assigned to node [" + request.getCurrentNode() + "]").                 }             }         } else {             // If looking for a replica, go through all the replica shards             List<ShardRouting> replicaShardRoutings = allocation.routingTable().shardRoutingTable(index, shard).replicaShards().             if (request.getCurrentNode() != null) {                 // the request is to explain a replica shard already assigned on a particular node,                 // so find that shard copy                 DiscoveryNode replicaNode = allocation.nodes().resolveNode(request.getCurrentNode()).                 for (ShardRouting replica : replicaShardRoutings) {                     if (replicaNode.getId().equals(replica.currentNodeId())) {                         foundShard = replica.                         break.                     }                 }                 if (foundShard == null) {                     throw new IllegalArgumentException("unable to find a replica shard assigned to node [" + request.getCurrentNode() + "]").                 }             } else {                 if (replicaShardRoutings.size() > 0) {                     // Pick the first replica at the very least                     foundShard = replicaShardRoutings.get(0).                     for (ShardRouting replica : replicaShardRoutings) {                         // try to find one that is unassigned at least                         if (replica.unassigned()) {                             foundShard = replica.                             break.                         } else if (replica.started() && (foundShard.initializing() || foundShard.relocating())) {                             // prefer started shards to initializing or relocating shards because started shards                             // can be explained                             foundShard = replica.                         }                     }                 }             }         }     }     if (foundShard == null) {         throw new IllegalArgumentException("unable to find any shards to explain [" + request + "] in the routing table").     }     return foundShard. }
