commented;modifiers;parameterAmount;loc;comment;code
true;public,final;0;4;/**  * Iterates over the {@link Aggregation}s.  */ ;/**  * Iterates over the {@link Aggregation}s.  */ @Override public final Iterator<Aggregation> iterator() {     return aggregations.stream().map((p) -> (Aggregation) p).iterator(). }
true;public,final;0;3;/**  * The list of {@link Aggregation}s.  */ ;/**  * The list of {@link Aggregation}s.  */ public final List<Aggregation> asList() {     return Collections.unmodifiableList(aggregations). }
true;public,final;0;3;/**  * Returns the {@link Aggregation}s keyed by aggregation name.  */ ;/**  * Returns the {@link Aggregation}s keyed by aggregation name.  */ public final Map<String, Aggregation> asMap() {     return getAsMap(). }
true;public,final;0;10;/**  * Returns the {@link Aggregation}s keyed by aggregation name.  */ ;/**  * Returns the {@link Aggregation}s keyed by aggregation name.  */ public final Map<String, Aggregation> getAsMap() {     if (aggregationsAsMap == null) {         Map<String, Aggregation> newAggregationsAsMap = new HashMap<>(aggregations.size()).         for (Aggregation aggregation : aggregations) {             newAggregationsAsMap.put(aggregation.getName(), aggregation).         }         this.aggregationsAsMap = unmodifiableMap(newAggregationsAsMap).     }     return aggregationsAsMap. }
true;public,final;1;4;/**  * Returns the aggregation that is associated with the specified name.  */ ;/**  * Returns the aggregation that is associated with the specified name.  */ @SuppressWarnings("unchecked") public final <A extends Aggregation> A get(String name) {     return (A) asMap().get(name). }
false;public,final;1;7;;@Override public final boolean equals(Object obj) {     if (obj == null || getClass() != obj.getClass()) {         return false.     }     return aggregations.equals(((Aggregations) obj).aggregations). }
false;public,final;0;4;;@Override public final int hashCode() {     return Objects.hash(getClass(), aggregations). }
false;public;2;9;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     if (aggregations.isEmpty()) {         return builder.     }     builder.startObject(AGGREGATIONS_FIELD).     toXContentInternal(builder, params).     return builder.endObject(). }
true;public;2;6;/**  * Directly write all the aggregations without their bounding object. Used by sub-aggregations (non top level aggs)  */ ;/**  * Directly write all the aggregations without their bounding object. Used by sub-aggregations (non top level aggs)  */ public XContentBuilder toXContentInternal(XContentBuilder builder, Params params) throws IOException {     for (Aggregation aggregation : aggregations) {         aggregation.toXContent(builder, params).     }     return builder. }
false;public,static;1;18;;public static Aggregations fromXContent(XContentParser parser) throws IOException {     final List<Aggregation> aggregations = new ArrayList<>().     XContentParser.Token token.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.START_OBJECT) {             SetOnce<Aggregation> typedAgg = new SetOnce<>().             String currentField = parser.currentName().             parseTypedKeysObject(parser, Aggregation.TYPED_KEYS_DELIMITER, Aggregation.class, typedAgg::set).             if (typedAgg.get() != null) {                 aggregations.add(typedAgg.get()).             } else {                 throw new ParsingException(parser.getTokenLocation(), String.format(Locale.ROOT, "Could not parse aggregation keyed as [%s]", currentField)).             }         }     }     return new Aggregations(aggregations). }
