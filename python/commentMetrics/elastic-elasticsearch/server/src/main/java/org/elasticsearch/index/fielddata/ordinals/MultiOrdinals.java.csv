commented;modifiers;parameterAmount;loc;comment;code
true;public,static;4;15;/**  * Return true if this impl is going to be smaller than {@link SinglePackedOrdinals} by at least 20%.  */ ;/**  * Return true if this impl is going to be smaller than {@link SinglePackedOrdinals} by at least 20%.  */ public static boolean significantlySmallerThanSinglePackedOrdinals(int maxDoc, int numDocsWithValue, long numOrds, float acceptableOverheadRatio) {     int bitsPerOrd = PackedInts.bitsRequired(numOrds).     bitsPerOrd = PackedInts.fastestFormatAndBits(numDocsWithValue, bitsPerOrd, acceptableOverheadRatio).bitsPerValue.     // Compute the worst-case number of bits per value for offsets in the worst case, eg. if no docs have a value at the     // beginning of the block and all docs have one at the end of the block     final float avgValuesPerDoc = (float) numDocsWithValue / maxDoc.     final int maxDelta = (int) Math.ceil(OFFSETS_PAGE_SIZE * (1 - avgValuesPerDoc) * avgValuesPerDoc).     // +1 because of the sign     int bitsPerOffset = PackedInts.bitsRequired(maxDelta) + 1.     bitsPerOffset = PackedInts.fastestFormatAndBits(maxDoc, bitsPerOffset, acceptableOverheadRatio).bitsPerValue.     final long expectedMultiSizeInBytes = (long) numDocsWithValue * bitsPerOrd + (long) maxDoc * bitsPerOffset.     final long expectedSingleSizeInBytes = (long) maxDoc * bitsPerOrd.     return expectedMultiSizeInBytes < 0.8f * expectedSingleSizeInBytes. }
false;public;0;4;;@Override public long ramBytesUsed() {     return endOffsets.ramBytesUsed() + ords.ramBytesUsed(). }
false;public;0;7;;@Override public Collection<Accountable> getChildResources() {     List<Accountable> resources = new ArrayList<>().     resources.add(Accountables.namedAccountable("offsets", endOffsets)).     resources.add(Accountables.namedAccountable("ordinals", ords)).     return Collections.unmodifiableCollection(resources). }
false;public;1;8;;@Override public SortedSetDocValues ordinals(ValuesHolder values) {     if (multiValued) {         return new MultiDocs(this, values).     } else {         return (SortedSetDocValues) DocValues.singleton(new SingleDocs(this, values)).     } }
false;public;0;4;;@Override public int ordValue() {     return (int) ords.get(currentStartOffset). }
false;public;1;7;;@Override public boolean advanceExact(int docId) throws IOException {     currentDoc = docId.     currentStartOffset = docId != 0 ? endOffsets.get(docId - 1) : 0.     currentEndOffset = endOffsets.get(docId).     return currentStartOffset != currentEndOffset. }
false;public;0;4;;@Override public int docID() {     return currentDoc. }
false;public;1;4;;@Override public BytesRef lookupOrd(int ord) {     return values.lookupOrd(ord). }
false;public;0;4;;@Override public int getValueCount() {     return valueCount. }
false;public;0;4;;@Override public long getValueCount() {     return valueCount. }
false;public;1;6;;@Override public boolean advanceExact(int docId) throws IOException {     currentOffset = docId != 0 ? endOffsets.get(docId - 1) : 0.     currentEndOffset = endOffsets.get(docId).     return currentOffset != currentEndOffset. }
false;public;0;8;;@Override public long nextOrd() throws IOException {     if (currentOffset == currentEndOffset) {         return SortedSetDocValues.NO_MORE_ORDS.     } else {         return ords.get(currentOffset++).     } }
false;public;1;4;;@Override public BytesRef lookupOrd(long ord) {     return values.lookupOrd(ord). }
