commented;modifiers;parameterAmount;loc;comment;code
false;public,static;2;3;;public static HistogramAggregationBuilder parse(String aggregationName, XContentParser parser) throws IOException {     return PARSER.parse(parser, new HistogramAggregationBuilder(aggregationName), null). }
false;protected;2;4;;@Override protected AggregationBuilder shallowCopy(Builder factoriesBuilder, Map<String, Object> metaData) {     return new HistogramAggregationBuilder(this, factoriesBuilder, metaData). }
false;protected;1;10;;@Override protected void innerWriteTo(StreamOutput out) throws IOException {     InternalOrder.Streams.writeHistogramOrder(order, out, true).     out.writeBoolean(keyed).     out.writeVLong(minDocCount).     out.writeDouble(interval).     out.writeDouble(offset).     out.writeDouble(minBound).     out.writeDouble(maxBound). }
true;public;0;3;/**  * Get the current interval that is set on this builder.  */ ;/**  * Get the current interval that is set on this builder.  */ public double interval() {     return interval. }
true;public;1;7;/**  * Set the interval on this builder, and return the builder so that calls can be chained.  */ ;/**  * Set the interval on this builder, and return the builder so that calls can be chained.  */ public HistogramAggregationBuilder interval(double interval) {     if (interval <= 0) {         throw new IllegalArgumentException("[interval] must be >0 for histogram aggregation [" + name + "]").     }     this.interval = interval.     return this. }
true;public;0;3;/**  * Get the current offset that is set on this builder.  */ ;/**  * Get the current offset that is set on this builder.  */ public double offset() {     return offset. }
true;public;1;4;/**  * Set the offset on this builder, and return the builder so that calls can be chained.  */ ;/**  * Set the offset on this builder, and return the builder so that calls can be chained.  */ public HistogramAggregationBuilder offset(double offset) {     this.offset = offset.     return this. }
true;public;0;3;/**  * Get the current minimum bound that is set on this builder.  */ ;/**  * Get the current minimum bound that is set on this builder.  */ public double minBound() {     return minBound. }
true;public;0;3;/**  * Get the current maximum bound that is set on this builder.  */ ;/**  * Get the current maximum bound that is set on this builder.  */ public double maxBound() {     return maxBound. }
true;public;2;14;/**  * Set extended bounds on this builder: buckets between {@code minBound} and  * {@code maxBound} will be created even if no documents fell into these  * buckets.  *  * @throws IllegalArgumentException  *             if maxBound is less that minBound, or if either of the bounds  *             are not finite.  */ ;/**  * Set extended bounds on this builder: buckets between {@code minBound} and  * {@code maxBound} will be created even if no documents fell into these  * buckets.  *  * @throws IllegalArgumentException  *             if maxBound is less that minBound, or if either of the bounds  *             are not finite.  */ public HistogramAggregationBuilder extendedBounds(double minBound, double maxBound) {     if (Double.isFinite(minBound) == false) {         throw new IllegalArgumentException("minBound must be finite, got: " + minBound).     }     if (Double.isFinite(maxBound) == false) {         throw new IllegalArgumentException("maxBound must be finite, got: " + maxBound).     }     if (maxBound < minBound) {         throw new IllegalArgumentException("maxBound [" + maxBound + "] must be greater than minBound [" + minBound + "]").     }     this.minBound = minBound.     this.maxBound = maxBound.     return this. }
true;public;0;3;/**  * Return the order to use to sort buckets of this histogram.  */ ;/**  * Return the order to use to sort buckets of this histogram.  */ public BucketOrder order() {     return order. }
true;public;1;11;/**  * Set a new order on this builder and return the builder so that calls  *  can be chained. A tie-breaker may be added to avoid non-deterministic ordering.  */ ;/**  * Set a new order on this builder and return the builder so that calls  *  can be chained. A tie-breaker may be added to avoid non-deterministic ordering.  */ public HistogramAggregationBuilder order(BucketOrder order) {     if (order == null) {         throw new IllegalArgumentException("[order] must not be null: [" + name + "]").     }     if (order instanceof CompoundOrder || InternalOrder.isKeyOrder(order)) {         // if order already contains a tie-breaker we are good to go         this.order = order.     } else {         // otherwise add a tie-breaker by using a compound order         this.order = BucketOrder.compound(order).     }     return this. }
true;public;1;8;/**  * Sets the order in which the buckets will be returned. A tie-breaker may be added to avoid non-deterministic  * ordering.  */ ;/**  * Sets the order in which the buckets will be returned. A tie-breaker may be added to avoid non-deterministic  * ordering.  */ public HistogramAggregationBuilder order(List<BucketOrder> orders) {     if (orders == null) {         throw new IllegalArgumentException("[orders] must not be null: [" + name + "]").     }     // if the list only contains one order use that to avoid inconsistent xcontent     order(orders.size() > 1 ? BucketOrder.compound(orders) : orders.get(0)).     return this. }
true;public;0;3;/**  * Return whether buckets should be returned as a hash. In case  *  {@code keyed} is false, buckets will be returned as an array.  */ ;/**  * Return whether buckets should be returned as a hash. In case  *  {@code keyed} is false, buckets will be returned as an array.  */ public boolean keyed() {     return keyed. }
true;public;1;4;/**  * Set whether to return buckets as a hash or as an array, and return the  *  builder so that calls can be chained.  */ ;/**  * Set whether to return buckets as a hash or as an array, and return the  *  builder so that calls can be chained.  */ public HistogramAggregationBuilder keyed(boolean keyed) {     this.keyed = keyed.     return this. }
true;public;0;3;/**  * Return the minimum count of documents that buckets need to have in order  *  to be included in the response.  */ ;/**  * Return the minimum count of documents that buckets need to have in order  *  to be included in the response.  */ public long minDocCount() {     return minDocCount. }
true;public;1;8;/**  * Set the minimum count of matching documents that buckets need to have  *  and return this builder so that calls can be chained.  */ ;/**  * Set the minimum count of matching documents that buckets need to have  *  and return this builder so that calls can be chained.  */ public HistogramAggregationBuilder minDocCount(long minDocCount) {     if (minDocCount < 0) {         throw new IllegalArgumentException("[minDocCount] must be greater than or equal to 0. Found [" + minDocCount + "] in [" + name + "]").     }     this.minDocCount = minDocCount.     return this. }
false;protected;2;28;;@Override protected XContentBuilder doXContentBody(XContentBuilder builder, Params params) throws IOException {     builder.field(Histogram.INTERVAL_FIELD.getPreferredName(), interval).     builder.field(Histogram.OFFSET_FIELD.getPreferredName(), offset).     if (order != null) {         builder.field(Histogram.ORDER_FIELD.getPreferredName()).         order.toXContent(builder, params).     }     builder.field(Histogram.KEYED_FIELD.getPreferredName(), keyed).     builder.field(Histogram.MIN_DOC_COUNT_FIELD.getPreferredName(), minDocCount).     if (Double.isFinite(minBound) || Double.isFinite(maxBound)) {         builder.startObject(Histogram.EXTENDED_BOUNDS_FIELD.getPreferredName()).         if (Double.isFinite(minBound)) {             builder.field("min", minBound).         }         if (Double.isFinite(maxBound)) {             builder.field("max", maxBound).         }         builder.endObject().     }     return builder. }
false;public;0;4;;@Override public String getType() {     return NAME. }
false;protected;4;6;;@Override protected ValuesSourceAggregatorFactory<Numeric, ?> innerBuild(SearchContext context, ValuesSourceConfig<Numeric> config, AggregatorFactory<?> parent, Builder subFactoriesBuilder) throws IOException {     return new HistogramAggregatorFactory(name, config, interval, offset, order, keyed, minDocCount, minBound, maxBound, context, parent, subFactoriesBuilder, metaData). }
false;protected;0;4;;@Override protected int innerHashCode() {     return Objects.hash(order, keyed, minDocCount, interval, offset, minBound, maxBound). }
false;protected;1;11;;@Override protected boolean innerEquals(Object obj) {     HistogramAggregationBuilder other = (HistogramAggregationBuilder) obj.     return Objects.equals(order, other.order) && Objects.equals(keyed, other.keyed) && Objects.equals(minDocCount, other.minDocCount) && Objects.equals(interval, other.interval) && Objects.equals(offset, other.offset) && Objects.equals(minBound, other.minBound) && Objects.equals(maxBound, other.maxBound). }
