commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;7;/**  * Compute the required precision so that <code>count</code> distinct entries would be counted with linear counting.  */ ;/**  * Compute the required precision so that <code>count</code> distinct entries would be counted with linear counting.  */ public static int precisionFromThreshold(long count) {     final long hashTableEntries = (long) Math.ceil(count / MAX_LOAD_FACTOR).     int precision = PackedInts.bitsRequired(hashTableEntries * Integer.BYTES).     precision = Math.max(precision, MIN_PRECISION).     precision = Math.min(precision, MAX_PRECISION).     return precision. }
true;public,static;1;3;/**  * Return the expected per-bucket memory usage for the given precision.  */ ;/**  * Return the expected per-bucket memory usage for the given precision.  */ public static long memoryUsage(int precision) {     return 1L << precision. }
false;public;0;3;;public int precision() {     return p. }
false;public;0;3;;public long maxBucket() {     return runLens.size() >>> p. }
false;private;1;3;;private void ensureCapacity(long numBuckets) {     runLens = bigArrays.grow(runLens, numBuckets << p). }
false;public;3;30;;public void merge(long thisBucket, HyperLogLogPlusPlus other, long otherBucket) {     if (p != other.p) {         throw new IllegalArgumentException().     }     ensureCapacity(thisBucket + 1).     if (other.algorithm.get(otherBucket) == LINEAR_COUNTING) {         final IntArray values = other.hashSet.values(otherBucket).         try {             for (long i = 0. i < values.size(). ++i) {                 final int encoded = values.get(i).                 if (algorithm.get(thisBucket) == LINEAR_COUNTING) {                     collectLcEncoded(thisBucket, encoded).                 } else {                     collectHllEncoded(thisBucket, encoded).                 }             }         } finally {             Releasables.close(values).         }     } else {         if (algorithm.get(thisBucket) != HYPERLOGLOG) {             upgradeToHll(thisBucket).         }         final long thisStart = thisBucket << p.         final long otherStart = otherBucket << p.         for (int i = 0. i < m. ++i) {             runLens.set(thisStart + i, (byte) Math.max(runLens.get(thisStart + i), other.runLens.get(otherStart + i))).         }     } }
false;public;2;8;;public void collect(long bucket, long hash) {     ensureCapacity(bucket + 1).     if (algorithm.get(bucket) == LINEAR_COUNTING) {         collectLc(bucket, hash).     } else {         collectHll(bucket, hash).     } }
false;private;2;4;;private void collectLc(long bucket, long hash) {     final int k = encodeHash(hash, p).     collectLcEncoded(bucket, k). }
false;private;2;6;;private void collectLcEncoded(long bucket, int encoded) {     final int newSize = hashSet.add(bucket, encoded).     if (newSize > hashSet.threshold) {         upgradeToHll(bucket).     } }
false;private;2;5;;private void collectHll(long bucket, long hash) {     final long index = index(hash, p).     final int runLen = runLen(hash, p).     collectHll(bucket, index, runLen). }
false;private;2;5;;private void collectHllEncoded(long bucket, int encoded) {     final int runLen = decodeRunLen(encoded, p).     final int index = decodeIndex(encoded, p).     collectHll(bucket, index, runLen). }
false;private;3;4;;private void collectHll(long bucket, long index, int runLen) {     final long bucketIndex = (bucket << p) + index.     runLens.set(bucketIndex, (byte) Math.max(runLen, runLens.get(bucketIndex))). }
false;public;1;7;;public long cardinality(long bucket) {     if (algorithm.get(bucket) == LINEAR_COUNTING) {         return cardinalityLc(bucket).     } else {         return cardinalityHll(bucket).     } }
false;private;1;5;;private long cardinalityLc(long bucket) {     final long m = 1 << P2.     final long v = m - hashSet.size(bucket).     return linearCounting(m, v). }
false;private;1;24;;private long cardinalityHll(long bucket) {     double inverseSum = 0.     int zeros = 0.     for (long i = bucket << p, end = i + m. i < end. ++i) {         final int runLen = runLens.get(i).         inverseSum += 1. / (1L << runLen).         if (runLen == 0) {             ++zeros.         }     }     double e1 = alphaMM / inverseSum.     double e2 = e1 <= 5 * m ? e1 - estimateBias(e1) : e1.     long h.     if (zeros != 0) {         h = linearCounting(m, zeros).     } else {         h = Math.round(e2).     }     if (h <= threshold()) {         return h.     } else {         return Math.round(e2).     } }
false;;1;14;;void upgradeToHll(long bucket) {     ensureCapacity(bucket + 1).     final IntArray values = hashSet.values(bucket).     try {         runLens.fill(bucket << p, (bucket << p) + m, (byte) 0).         for (long i = 0. i < values.size(). ++i) {             final int encoded = values.get(i).             collectHllEncoded(bucket, encoded).         }         algorithm.set(bucket).     } finally {         Releasables.close(values).     } }
false;static;2;3;;static long linearCounting(long m, long v) {     return Math.round(m * Math.log((double) m / v)). }
false;static;1;3;;static long mask(int bits) {     return (1L << bits) - 1. }
true;static;2;13;/**  * Encode the hash on 32 bits. The encoded hash cannot be equal to <code>0</code>.  */ ;/**  * Encode the hash on 32 bits. The encoded hash cannot be equal to <code>0</code>.  */ static int encodeHash(long hash, int p) {     final long e = hash >>> (64 - P2).     final long encoded.     if ((e & mask(P2 - p)) == 0) {         final int runLen = 1 + Math.min(Long.numberOfLeadingZeros(hash << P2), 64 - P2).         encoded = (e << 7) | (runLen << 1) | 1.     } else {         encoded = e << 1.     }     assert PackedInts.bitsRequired(encoded) <= 32.     assert encoded != 0.     return (int) encoded. }
false;static;2;9;;static int decodeRunLen(int encoded, int p) {     if ((encoded & 1) == 1) {         return (((encoded >>> 1) & 0x3F) + (P2 - p)).     } else {         final int bits = encoded << (31 + p - P2).         assert bits != 0.         return 1 + Integer.numberOfLeadingZeros(bits).     } }
false;static;2;9;;static int decodeIndex(int encoded, int p) {     long index.     if ((encoded & 1) == 1) {         index = encoded >>> 7.     } else {         index = encoded >>> 1.     }     return (int) (index >>> (P2 - p)). }
false;static;2;3;;static long index(long hash, int p) {     return hash >>> (64 - p). }
false;static;2;3;;static int runLen(long hash, int p) {     return 1 + Math.min(Long.numberOfLeadingZeros(hash << p), 64 - p). }
false;private;1;28;;private double estimateBias(double e) {     final double[] rawEstimateData = rawEstimateData().     final double[] biasData = biasData().     final double[] weights = new double[BIAS_K].     int index = biasData.length - BIAS_K.     for (int i = 0. i < rawEstimateData.length. ++i) {         final double w = 1.0 / Math.abs(rawEstimateData[i] - e).         final int j = i % weights.length.         if (Double.isInfinite(w)) {             return biasData[i].         } else if (weights[j] >= w) {             index = i - BIAS_K.             break.         }         weights[j] = w.     }     double weightSum = 0.0.     double biasSum = 0.0.     for (int i = 0, j = index. i < BIAS_K. ++i, ++j) {         final double w = weights[i].         final double b = biasData[j].         biasSum += w * b.         weightSum += w.     }     return biasSum / weightSum. }
false;private;0;3;;private double[] biasData() {     return BIAS_DATA[p - 4]. }
false;private;0;3;;private double[] rawEstimateData() {     return RAW_ESTIMATE_DATA[p - 4]. }
false;private;0;3;;private long threshold() {     return THRESHOLDS[p - 4]. }
false;public;0;4;;@Override public void close() {     Releasables.close(runLens, hashSet.sizes). }
false;private;1;23;;private Object getComparableData(long bucket) {     if (algorithm.get(bucket) == LINEAR_COUNTING) {         Set<Integer> values = new HashSet<>().         try (IntArray hashSetValues = hashSet.values(bucket)) {             for (long i = 0. i < hashSetValues.size(). i++) {                 values.add(hashSetValues.get(i)).             }         }         return values.     } else {         Map<Byte, Integer> values = new HashMap<>().         for (long i = 0. i < runLens.size(). i++) {             byte runLength = runLens.get((bucket << p) + i).             Integer numOccurances = values.get(runLength).             if (numOccurances == null) {                 values.put(runLength, 1).             } else {                 values.put(runLength, numOccurances + 1).             }         }         return values.     } }
false;public;1;3;;public int hashCode(long bucket) {     return Objects.hash(p, algorithm.get(bucket), getComparableData(bucket)). }
false;public;2;5;;public boolean equals(long bucket, HyperLogLogPlusPlus other) {     return Objects.equals(p, other.p) && Objects.equals(algorithm.get(bucket), other.algorithm.get(bucket)) && Objects.equals(getComparableData(bucket), other.getComparableData(bucket)). }
false;private;2;3;;private long index(long bucket, int index) {     return (bucket << p) + (index << 2). }
false;private;2;4;;private int get(long bucket, int index) {     runLens.get(index(bucket, index), 4, readSpare).     return ByteUtils.readIntLE(readSpare.bytes, readSpare.offset). }
false;private;3;4;;private void set(long bucket, int index, int value) {     writeSpare.putInt(0, value).     runLens.set(index(bucket, index), writeSpare.array(), 0, 4). }
false;private;1;10;;private int recomputedSize(long bucket) {     int size = 0.     for (int i = 0. i <= mask. ++i) {         final int v = get(bucket, i).         if (v != 0) {             ++size.         }     }     return size. }
false;public;1;8;;public int size(long bucket) {     if (bucket >= sizes.size()) {         return 0.     }     final int size = sizes.get(bucket).     assert size == recomputedSize(bucket).     return size. }
true;public;2;15;/**  * Add <code>k</code> to the hash table associated with <code>bucket</code>. Return {@code -1} if the value was already in the set  * or the new set size if it was added.  */ ;/**  * Add <code>k</code> to the hash table associated with <code>bucket</code>. Return {@code -1} if the value was already in the set  * or the new set size if it was added.  */ public int add(long bucket, int k) {     sizes = bigArrays.grow(sizes, bucket + 1).     assert k != 0.     for (int i = (k & mask). . i = (i + 1) & mask) {         final int v = get(bucket, i).         if (v == 0) {             // means unused, take it!             set(bucket, i, k).             return sizes.increment(bucket, 1).         } else if (v == k) {             // k is already in the set             return -1.         }     } }
false;public;1;16;;public IntArray values(final long bucket) {     final int size = size(bucket).     final IntArray values = bigArrays.newIntArray(size).     if (size == 0) {         return values.     }     int i = 0.     for (int j = 0. j < capacity. ++j) {         final int k = get(bucket, j).         if (k != 0) {             values.set(i++, k).         }     }     assert i == values.size().     return values. }
false;public;2;17;;public void writeTo(long bucket, StreamOutput out) throws IOException {     out.writeVInt(p).     if (algorithm.get(bucket) == LINEAR_COUNTING) {         out.writeBoolean(LINEAR_COUNTING).         try (IntArray hashes = hashSet.values(bucket)) {             out.writeVLong(hashes.size()).             for (long i = 0. i < hashes.size(). ++i) {                 out.writeInt(hashes.get(i)).             }         }     } else {         out.writeBoolean(HYPERLOGLOG).         for (long i = bucket << p, end = i + m. i < end. ++i) {             out.writeByte(runLens.get(i)).         }     } }
false;public,static;2;19;;public static HyperLogLogPlusPlus readFrom(StreamInput in, BigArrays bigArrays) throws IOException {     final int precision = in.readVInt().     HyperLogLogPlusPlus counts = new HyperLogLogPlusPlus(precision, bigArrays, 1).     final boolean algorithm = in.readBoolean().     if (algorithm == LINEAR_COUNTING) {         counts.algorithm.clear(0).         final long size = in.readVLong().         for (long i = 0. i < size. ++i) {             final int encoded = in.readInt().             counts.hashSet.add(0, encoded).         }     } else {         counts.algorithm.set(0).         for (int i = 0. i < counts.m. ++i) {             counts.runLens.set(i, in.readByte()).         }     }     return counts. }
false;;1;7;;boolean get(long bit) {     if (bit < impl.length()) {         return impl.get(bit).     } else {         return false.     } }
false;;1;3;;void ensureCapacity(long bit) {     impl = LongBitSet.ensureCapacity(impl, bit). }
false;;1;4;;void set(long bit) {     ensureCapacity(bit).     impl.set(bit). }
false;;1;4;;void clear(long bit) {     ensureCapacity(bit).     impl.clear(bit). }
