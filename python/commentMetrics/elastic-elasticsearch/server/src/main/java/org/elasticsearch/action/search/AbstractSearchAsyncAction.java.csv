commented;modifiers;parameterAmount;loc;comment;code
true;;0;3;/**  * Builds how long it took to execute the search.  */ ;/**  * Builds how long it took to execute the search.  */ long buildTookInMillis() {     return timeProvider.buildTookInMillis(). }
true;public,final;0;16;/**  * This is the main entry point for a search. This method starts the search execution of the initial phase.  */ ;/**  * This is the main entry point for a search. This method starts the search execution of the initial phase.  */ public final void start() {     if (getNumShards() == 0) {         // no search shards to search on, bail with empty response         // (it happens with search across _all with no indices around and consistent with broadcast operations)         int trackTotalHitsUpTo = request.source() == null ? SearchContext.DEFAULT_TRACK_TOTAL_HITS_UP_TO : request.source().trackTotalHitsUpTo() == null ? SearchContext.DEFAULT_TRACK_TOTAL_HITS_UP_TO : request.source().trackTotalHitsUpTo().         // total hits is null in the response if the tracking of total hits is disabled         boolean withTotalHits = trackTotalHitsUpTo != SearchContext.TRACK_TOTAL_HITS_DISABLED.         listener.onResponse(new SearchResponse(InternalSearchResponse.empty(withTotalHits), null, 0, 0, 0, buildTookInMillis(), ShardSearchFailure.EMPTY_ARRAY, clusters)).         return.     }     executePhase(this). }
false;public,final;2;34;;@Override public final void executeNextPhase(SearchPhase currentPhase, SearchPhase nextPhase) {     /* This is the main search phase transition where we move to the next phase. At this point we check if there is          * at least one successful operation left and if so we move to the next phase. If not we immediately fail the          * search phase as "all shards failed"*/     if (successfulOps.get() == 0) {         // we have 0 successful results that means we shortcut stuff and return a failure         final ShardOperationFailedException[] shardSearchFailures = ExceptionsHelper.groupBy(buildShardFailures()).         Throwable cause = shardSearchFailures.length == 0 ? null : ElasticsearchException.guessRootCauses(shardSearchFailures[0].getCause())[0].         logger.debug(() -> new ParameterizedMessage("All shards failed for phase: [{}]", getName()), cause).         onPhaseFailure(currentPhase, "all shards failed", cause).     } else {         Boolean allowPartialResults = request.allowPartialSearchResults().         assert allowPartialResults != null : "SearchRequest missing setting for allowPartialSearchResults".         if (allowPartialResults == false && shardFailures.get() != null) {             if (logger.isDebugEnabled()) {                 final ShardOperationFailedException[] shardSearchFailures = ExceptionsHelper.groupBy(buildShardFailures()).                 Throwable cause = shardSearchFailures.length == 0 ? null : ElasticsearchException.guessRootCauses(shardSearchFailures[0].getCause())[0].                 logger.debug(() -> new ParameterizedMessage("{} shards failed for phase: [{}]", shardSearchFailures.length, getName()), cause).             }             onPhaseFailure(currentPhase, "Partial shards failure", null).         } else {             if (logger.isTraceEnabled()) {                 final String resultsFrom = results.getSuccessfulResults().map(r -> r.getSearchShardTarget().toString()).collect(Collectors.joining(",")).                 logger.trace("[{}] Moving to next phase: [{}], based on results from: {} (cluster state version: {})", currentPhase.getName(), nextPhase.getName(), resultsFrom, clusterStateVersion).             }             executePhase(nextPhase).         }     } }
false;private;1;10;;private void executePhase(SearchPhase phase) {     try {         phase.run().     } catch (Exception e) {         if (logger.isDebugEnabled()) {             logger.debug(new ParameterizedMessage("Failed to execute [{}] while moving to [{}] phase", request, phase.getName()), e).         }         onPhaseFailure(phase, "", e).     } }
false;private;0;12;;private ShardSearchFailure[] buildShardFailures() {     AtomicArray<ShardSearchFailure> shardFailures = this.shardFailures.get().     if (shardFailures == null) {         return ShardSearchFailure.EMPTY_ARRAY.     }     List<ShardSearchFailure> entries = shardFailures.asList().     ShardSearchFailure[] failures = new ShardSearchFailure[entries.size()].     for (int i = 0. i < failures.length. i++) {         failures[i] = entries.get(i).     }     return failures. }
false;public,final;3;32;;public final void onShardFailure(final int shardIndex, @Nullable SearchShardTarget shardTarget, Exception e) {     // we don't aggregate shard failures on non active shards (but do keep the header counts right)     if (TransportActions.isShardNotAvailableException(e) == false) {         AtomicArray<ShardSearchFailure> shardFailures = this.shardFailures.get().         // lazily create shard failures, so we can early build the empty shard failure list in most cases (no failures)         if (shardFailures == null) {             // this is double checked locking but it's fine since SetOnce uses a volatile read internally             synchronized (shardFailuresMutex) {                 // read again otherwise somebody else has created it?                 shardFailures = this.shardFailures.get().                 if (shardFailures == null) {                     // still null so we are the first and create a new instance                     shardFailures = new AtomicArray<>(getNumShards()).                     this.shardFailures.set(shardFailures).                 }             }         }         ShardSearchFailure failure = shardFailures.get(shardIndex).         if (failure == null) {             shardFailures.set(shardIndex, new ShardSearchFailure(e, shardTarget)).         } else {             // for example, getting illegal shard state             if (TransportActions.isReadOverrideException(e)) {                 shardFailures.set(shardIndex, new ShardSearchFailure(e, shardTarget)).             }         }         if (results.hasResult(shardIndex)) {             assert failure == null : "shard failed before but shouldn't: " + failure.             // if this shard was successful before (initial phase) we have to adjust the counter             successfulOps.decrementAndGet().         }     }     results.consumeShardFailure(shardIndex). }
true;private;1;13;/**  * This method should be called if a search phase failed to ensure all relevant search contexts and resources are released.  * this method will also notify the listener and sends back a failure to the user.  *  * @param exception the exception explaining or causing the phase failure  */ ;/**  * This method should be called if a search phase failed to ensure all relevant search contexts and resources are released.  * this method will also notify the listener and sends back a failure to the user.  *  * @param exception the exception explaining or causing the phase failure  */ private void raisePhaseFailure(SearchPhaseExecutionException exception) {     results.getSuccessfulResults().forEach((entry) -> {         try {             SearchShardTarget searchShardTarget = entry.getSearchShardTarget().             Transport.Connection connection = getConnection(searchShardTarget.getClusterAlias(), searchShardTarget.getNodeId()).             sendReleaseSearchContext(entry.getRequestId(), connection, searchShardTarget.getOriginalIndices()).         } catch (Exception inner) {             inner.addSuppressed(exception).             logger.trace("failed to release context", inner).         }     }).     listener.onFailure(exception). }
false;public,final;1;15;;@Override public final void onShardSuccess(Result result) {     successfulOps.incrementAndGet().     results.consumeResult(result).     if (logger.isTraceEnabled()) {         logger.trace("got first-phase result from {}", result != null ? result.getSearchShardTarget() : null).     }     // clean a previous error on this shard group (note, this code will be serialized on the same shardIndex value level     // so its ok concurrency wise to miss potentially the shard failures being created because of another failure     // in the #addShardFailure, because by definition, it will happen on *another* shardIndex     AtomicArray<ShardSearchFailure> shardFailures = this.shardFailures.get().     if (shardFailures != null) {         shardFailures.set(result.getShardIndex(), null).     } }
false;public,final;0;4;;@Override public final void onPhaseDone() {     executeNextPhase(this, getNextPhase(results, this)). }
false;public,final;0;4;;@Override public final int getNumShards() {     return results.getNumShards(). }
false;public,final;0;4;;@Override public final Logger getLogger() {     return logger. }
false;public,final;0;4;;@Override public final SearchTask getTask() {     return task. }
false;public,final;0;4;;@Override public final SearchRequest getRequest() {     return request. }
false;public,final;2;11;;@Override public final SearchResponse buildSearchResponse(InternalSearchResponse internalSearchResponse, String scrollId) {     ShardSearchFailure[] failures = buildShardFailures().     Boolean allowPartialResults = request.allowPartialSearchResults().     assert allowPartialResults != null : "SearchRequest missing setting for allowPartialSearchResults".     if (allowPartialResults == false && failures.length > 0) {         raisePhaseFailure(new SearchPhaseExecutionException("", "Shard failures", null, failures)).     }     return new SearchResponse(internalSearchResponse, scrollId, getNumShards(), successfulOps.get(), skippedOps.get(), buildTookInMillis(), failures, clusters). }
false;public,final;3;4;;@Override public final void onPhaseFailure(SearchPhase phase, String msg, Throwable cause) {     raisePhaseFailure(new SearchPhaseExecutionException(phase.getName(), msg, cause, buildShardFailures())). }
false;public,final;2;4;;@Override public final Transport.Connection getConnection(String clusterAlias, String nodeId) {     return nodeIdToConnection.apply(clusterAlias, nodeId). }
false;public,final;0;4;;@Override public final SearchTransportService getSearchTransport() {     return searchTransportService. }
false;public,final;1;4;;@Override public final void execute(Runnable command) {     executor.execute(command). }
false;public,final;1;4;;@Override public final void onResponse(SearchResponse response) {     listener.onResponse(response). }
false;public,final;1;4;;@Override public final void onFailure(Exception e) {     listener.onFailure(e). }
false;public,final;1;11;;@Override public final ShardSearchTransportRequest buildShardSearchRequest(SearchShardIterator shardIt) {     AliasFilter filter = aliasFilter.get(shardIt.shardId().getIndex().getUUID()).     assert filter != null.     float indexBoost = concreteIndexBoosts.getOrDefault(shardIt.shardId().getIndex().getUUID(), DEFAULT_INDEX_BOOST).     String indexName = shardIt.shardId().getIndex().getName().     final String[] routings = indexRoutings.getOrDefault(indexName, Collections.emptySet()).toArray(new String[0]).     return new ShardSearchTransportRequest(shardIt.getOriginalIndices(), request, shardIt.shardId(), getNumShards(), filter, indexBoost, timeProvider.getAbsoluteStartMillis(), shardIt.getClusterAlias(), routings). }
true;protected,abstract;2;1;/**  * Returns the next phase based on the results of the initial search phase  * @param results the results of the initial search phase. Each non null element in the result array represent a successfully  *                executed shard request  * @param context the search context for the next phase  */ ;/**  * Returns the next phase based on the results of the initial search phase  * @param results the results of the initial search phase. Each non null element in the result array represent a successfully  *                executed shard request  * @param context the search context for the next phase  */ protected abstract SearchPhase getNextPhase(SearchPhaseResults<Result> results, SearchPhaseContext context).
false;protected;1;6;;@Override protected void skipShard(SearchShardIterator iterator) {     successfulOps.incrementAndGet().     skippedOps.incrementAndGet().     super.skipShard(iterator). }
