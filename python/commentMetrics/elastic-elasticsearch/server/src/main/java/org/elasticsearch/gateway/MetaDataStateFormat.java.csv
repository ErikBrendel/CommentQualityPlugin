# id;timestamp;commentText;codeText;commentWords;codeWords
MetaDataStateFormat -> public abstract void toXContent(XContentBuilder builder, T state) throws IOException_;1524684173;Writes the given state to the given XContentBuilder_Subclasses need to implement this class for theirs specific state.;public abstract void toXContent(XContentBuilder builder, T state) throws IOException_;writes,the,given,state,to,the,given,xcontent,builder,subclasses,need,to,implement,this,class,for,theirs,specific,state;public,abstract,void,to,xcontent,xcontent,builder,builder,t,state,throws,ioexception
MetaDataStateFormat -> public abstract void toXContent(XContentBuilder builder, T state) throws IOException_;1525334055;Writes the given state to the given XContentBuilder_Subclasses need to implement this class for theirs specific state.;public abstract void toXContent(XContentBuilder builder, T state) throws IOException_;writes,the,given,state,to,the,given,xcontent,builder,subclasses,need,to,implement,this,class,for,theirs,specific,state;public,abstract,void,to,xcontent,xcontent,builder,builder,t,state,throws,ioexception
MetaDataStateFormat -> public abstract void toXContent(XContentBuilder builder, T state) throws IOException_;1527773340;Writes the given state to the given XContentBuilder_Subclasses need to implement this class for theirs specific state.;public abstract void toXContent(XContentBuilder builder, T state) throws IOException_;writes,the,given,state,to,the,given,xcontent,builder,subclasses,need,to,implement,this,class,for,theirs,specific,state;public,abstract,void,to,xcontent,xcontent,builder,builder,t,state,throws,ioexception
MetaDataStateFormat -> public abstract void toXContent(XContentBuilder builder, T state) throws IOException_;1529015561;Writes the given state to the given XContentBuilder_Subclasses need to implement this class for theirs specific state.;public abstract void toXContent(XContentBuilder builder, T state) throws IOException_;writes,the,given,state,to,the,given,xcontent,builder,subclasses,need,to,implement,this,class,for,theirs,specific,state;public,abstract,void,to,xcontent,xcontent,builder,builder,t,state,throws,ioexception
MetaDataStateFormat -> public abstract void toXContent(XContentBuilder builder, T state) throws IOException_;1531179852;Writes the given state to the given XContentBuilder_Subclasses need to implement this class for theirs specific state.;public abstract void toXContent(XContentBuilder builder, T state) throws IOException_;writes,the,given,state,to,the,given,xcontent,builder,subclasses,need,to,implement,this,class,for,theirs,specific,state;public,abstract,void,to,xcontent,xcontent,builder,builder,t,state,throws,ioexception
MetaDataStateFormat -> public abstract void toXContent(XContentBuilder builder, T state) throws IOException_;1540486836;Writes the given state to the given XContentBuilder_Subclasses need to implement this class for theirs specific state.;public abstract void toXContent(XContentBuilder builder, T state) throws IOException_;writes,the,given,state,to,the,given,xcontent,builder,subclasses,need,to,implement,this,class,for,theirs,specific,state;public,abstract,void,to,xcontent,xcontent,builder,builder,t,state,throws,ioexception
MetaDataStateFormat -> public abstract void toXContent(XContentBuilder builder, T state) throws IOException_;1544081506;Writes the given state to the given XContentBuilder_Subclasses need to implement this class for theirs specific state.;public abstract void toXContent(XContentBuilder builder, T state) throws IOException_;writes,the,given,state,to,the,given,xcontent,builder,subclasses,need,to,implement,this,class,for,theirs,specific,state;public,abstract,void,to,xcontent,xcontent,builder,builder,t,state,throws,ioexception
MetaDataStateFormat -> public  T loadLatestState(Logger logger, NamedXContentRegistry namedXContentRegistry, Path... dataLocations) throws IOException;1524684173;Tries to load the latest state from the given data-locations. It tries to load the latest state determined by_the states version from one or more data directories and if none of the latest states can be loaded an exception_is thrown to prevent accidentally loading a previous state and silently omitting the latest state.__@param logger a logger instance_@param dataLocations the data-locations to try._@return the latest state or <code>null</code> if no state was found.;public  T loadLatestState(Logger logger, NamedXContentRegistry namedXContentRegistry, Path... dataLocations) throws IOException {_        List<PathAndStateId> files = new ArrayList<>()__        long maxStateId = -1__        boolean maxStateIdIsLegacy = true__        if (dataLocations != null) { _            for (Path dataLocation : dataLocations) {_                final Path stateDir = dataLocation.resolve(STATE_DIR_NAME)__                _                _                _                _                try (DirectoryStream<Path> paths = Files.newDirectoryStream(stateDir)) {_                    for (Path stateFile : paths) {_                        final Matcher matcher = stateFilePattern.matcher(stateFile.getFileName().toString())__                        if (matcher.matches()) {_                            final long stateId = Long.parseLong(matcher.group(1))__                            maxStateId = Math.max(maxStateId, stateId)__                            final boolean legacy = MetaDataStateFormat.STATE_FILE_EXTENSION.equals(matcher.group(2)) == false__                            maxStateIdIsLegacy &= legacy_ _                            PathAndStateId pav = new PathAndStateId(stateFile, stateId, legacy)__                            logger.trace("found state file: {}", pav)__                            files.add(pav)__                        }_                    }_                } catch (NoSuchFileException | FileNotFoundException ex) {_                    _                }_            }_        }_        final List<Throwable> exceptions = new ArrayList<>()__        T state = null__        _        _        _        _        _        Collection<PathAndStateId> pathAndStateIds = files_                .stream()_                .filter(new StateIdAndLegacyPredicate(maxStateId, maxStateIdIsLegacy))_                .collect(Collectors.toCollection(ArrayList::new))___        for (PathAndStateId pathAndStateId : pathAndStateIds) {_            try {_                final Path stateFile = pathAndStateId.file__                final long id = pathAndStateId.id__                if (pathAndStateId.legacy) { _                    final byte[] data = Files.readAllBytes(stateFile)__                    if (data.length == 0) {_                        logger.debug("{}: no data for [{}], ignoring...", prefix, stateFile.toAbsolutePath())__                        continue__                    }_                    try (XContentParser parser = XContentHelper_                            .createParser(namedXContentRegistry, LoggingDeprecationHandler.INSTANCE, new BytesArray(data))) {_                        state = fromXContent(parser)__                    }_                    if (state == null) {_                        logger.debug("{}: no data for [{}], ignoring...", prefix, stateFile.toAbsolutePath())__                    }_                } else {_                    state = read(namedXContentRegistry, stateFile)__                    logger.trace("state id [{}] read from [{}]", id, stateFile.getFileName())__                }_                return state__            } catch (Exception e) {_                exceptions.add(new IOException("failed to read " + pathAndStateId.toString(), e))__                logger.debug(() -> new ParameterizedMessage(_                        "{}: failed to read [{}], ignoring...", pathAndStateId.file.toAbsolutePath(), prefix), e)__            }_        }_        _        ExceptionsHelper.maybeThrowRuntimeAndSuppress(exceptions)__        if (files.size() > 0) {_            _            throw new IllegalStateException("Could not find a state file to recover from among " + files)__        }_        return state__    };tries,to,load,the,latest,state,from,the,given,data,locations,it,tries,to,load,the,latest,state,determined,by,the,states,version,from,one,or,more,data,directories,and,if,none,of,the,latest,states,can,be,loaded,an,exception,is,thrown,to,prevent,accidentally,loading,a,previous,state,and,silently,omitting,the,latest,state,param,logger,a,logger,instance,param,data,locations,the,data,locations,to,try,return,the,latest,state,or,code,null,code,if,no,state,was,found;public,t,load,latest,state,logger,logger,named,xcontent,registry,named,xcontent,registry,path,data,locations,throws,ioexception,list,path,and,state,id,files,new,array,list,long,max,state,id,1,boolean,max,state,id,is,legacy,true,if,data,locations,null,for,path,data,location,data,locations,final,path,state,dir,data,location,resolve,try,directory,stream,path,paths,files,new,directory,stream,state,dir,for,path,state,file,paths,final,matcher,matcher,state,file,pattern,matcher,state,file,get,file,name,to,string,if,matcher,matches,final,long,state,id,long,parse,long,matcher,group,1,max,state,id,math,max,max,state,id,state,id,final,boolean,legacy,meta,data,state,format,equals,matcher,group,2,false,max,state,id,is,legacy,legacy,path,and,state,id,pav,new,path,and,state,id,state,file,state,id,legacy,logger,trace,found,state,file,pav,files,add,pav,catch,no,such,file,exception,file,not,found,exception,ex,final,list,throwable,exceptions,new,array,list,t,state,null,collection,path,and,state,id,path,and,state,ids,files,stream,filter,new,state,id,and,legacy,predicate,max,state,id,max,state,id,is,legacy,collect,collectors,to,collection,array,list,new,for,path,and,state,id,path,and,state,id,path,and,state,ids,try,final,path,state,file,path,and,state,id,file,final,long,id,path,and,state,id,id,if,path,and,state,id,legacy,final,byte,data,files,read,all,bytes,state,file,if,data,length,0,logger,debug,no,data,for,ignoring,prefix,state,file,to,absolute,path,continue,try,xcontent,parser,parser,xcontent,helper,create,parser,named,xcontent,registry,logging,deprecation,handler,instance,new,bytes,array,data,state,from,xcontent,parser,if,state,null,logger,debug,no,data,for,ignoring,prefix,state,file,to,absolute,path,else,state,read,named,xcontent,registry,state,file,logger,trace,state,id,read,from,id,state,file,get,file,name,return,state,catch,exception,e,exceptions,add,new,ioexception,failed,to,read,path,and,state,id,to,string,e,logger,debug,new,parameterized,message,failed,to,read,ignoring,path,and,state,id,file,to,absolute,path,prefix,e,exceptions,helper,maybe,throw,runtime,and,suppress,exceptions,if,files,size,0,throw,new,illegal,state,exception,could,not,find,a,state,file,to,recover,from,among,files,return,state
MetaDataStateFormat -> public  T loadLatestState(Logger logger, NamedXContentRegistry namedXContentRegistry, Path... dataLocations) throws IOException;1525334055;Tries to load the latest state from the given data-locations. It tries to load the latest state determined by_the states version from one or more data directories and if none of the latest states can be loaded an exception_is thrown to prevent accidentally loading a previous state and silently omitting the latest state.__@param logger a logger instance_@param dataLocations the data-locations to try._@return the latest state or <code>null</code> if no state was found.;public  T loadLatestState(Logger logger, NamedXContentRegistry namedXContentRegistry, Path... dataLocations) throws IOException {_        List<PathAndStateId> files = new ArrayList<>()__        long maxStateId = -1__        boolean maxStateIdIsLegacy = true__        if (dataLocations != null) { _            for (Path dataLocation : dataLocations) {_                final Path stateDir = dataLocation.resolve(STATE_DIR_NAME)__                _                _                _                _                try (DirectoryStream<Path> paths = Files.newDirectoryStream(stateDir)) {_                    for (Path stateFile : paths) {_                        final Matcher matcher = stateFilePattern.matcher(stateFile.getFileName().toString())__                        if (matcher.matches()) {_                            final long stateId = Long.parseLong(matcher.group(1))__                            maxStateId = Math.max(maxStateId, stateId)__                            final boolean legacy = MetaDataStateFormat.STATE_FILE_EXTENSION.equals(matcher.group(2)) == false__                            maxStateIdIsLegacy &= legacy_ _                            PathAndStateId pav = new PathAndStateId(stateFile, stateId, legacy)__                            logger.trace("found state file: {}", pav)__                            files.add(pav)__                        }_                    }_                } catch (NoSuchFileException | FileNotFoundException ex) {_                    _                }_            }_        }_        final List<Throwable> exceptions = new ArrayList<>()__        T state = null__        _        _        _        _        _        Collection<PathAndStateId> pathAndStateIds = files_                .stream()_                .filter(new StateIdAndLegacyPredicate(maxStateId, maxStateIdIsLegacy))_                .collect(Collectors.toCollection(ArrayList::new))___        for (PathAndStateId pathAndStateId : pathAndStateIds) {_            try {_                final Path stateFile = pathAndStateId.file__                final long id = pathAndStateId.id__                if (pathAndStateId.legacy) { _                    final byte[] data = Files.readAllBytes(stateFile)__                    if (data.length == 0) {_                        logger.debug("{}: no data for [{}], ignoring...", prefix, stateFile.toAbsolutePath())__                        continue__                    }_                    try (XContentParser parser = XContentHelper_                            .createParser(namedXContentRegistry, LoggingDeprecationHandler.INSTANCE, new BytesArray(data))) {_                        state = fromXContent(parser)__                    }_                    if (state == null) {_                        logger.debug("{}: no data for [{}], ignoring...", prefix, stateFile.toAbsolutePath())__                    }_                } else {_                    state = read(namedXContentRegistry, stateFile)__                    logger.trace("state id [{}] read from [{}]", id, stateFile.getFileName())__                }_                return state__            } catch (Exception e) {_                exceptions.add(new IOException("failed to read " + pathAndStateId.toString(), e))__                logger.debug(() -> new ParameterizedMessage(_                        "{}: failed to read [{}], ignoring...", pathAndStateId.file.toAbsolutePath(), prefix), e)__            }_        }_        _        ExceptionsHelper.maybeThrowRuntimeAndSuppress(exceptions)__        if (files.size() > 0) {_            _            throw new IllegalStateException("Could not find a state file to recover from among " + files)__        }_        return state__    };tries,to,load,the,latest,state,from,the,given,data,locations,it,tries,to,load,the,latest,state,determined,by,the,states,version,from,one,or,more,data,directories,and,if,none,of,the,latest,states,can,be,loaded,an,exception,is,thrown,to,prevent,accidentally,loading,a,previous,state,and,silently,omitting,the,latest,state,param,logger,a,logger,instance,param,data,locations,the,data,locations,to,try,return,the,latest,state,or,code,null,code,if,no,state,was,found;public,t,load,latest,state,logger,logger,named,xcontent,registry,named,xcontent,registry,path,data,locations,throws,ioexception,list,path,and,state,id,files,new,array,list,long,max,state,id,1,boolean,max,state,id,is,legacy,true,if,data,locations,null,for,path,data,location,data,locations,final,path,state,dir,data,location,resolve,try,directory,stream,path,paths,files,new,directory,stream,state,dir,for,path,state,file,paths,final,matcher,matcher,state,file,pattern,matcher,state,file,get,file,name,to,string,if,matcher,matches,final,long,state,id,long,parse,long,matcher,group,1,max,state,id,math,max,max,state,id,state,id,final,boolean,legacy,meta,data,state,format,equals,matcher,group,2,false,max,state,id,is,legacy,legacy,path,and,state,id,pav,new,path,and,state,id,state,file,state,id,legacy,logger,trace,found,state,file,pav,files,add,pav,catch,no,such,file,exception,file,not,found,exception,ex,final,list,throwable,exceptions,new,array,list,t,state,null,collection,path,and,state,id,path,and,state,ids,files,stream,filter,new,state,id,and,legacy,predicate,max,state,id,max,state,id,is,legacy,collect,collectors,to,collection,array,list,new,for,path,and,state,id,path,and,state,id,path,and,state,ids,try,final,path,state,file,path,and,state,id,file,final,long,id,path,and,state,id,id,if,path,and,state,id,legacy,final,byte,data,files,read,all,bytes,state,file,if,data,length,0,logger,debug,no,data,for,ignoring,prefix,state,file,to,absolute,path,continue,try,xcontent,parser,parser,xcontent,helper,create,parser,named,xcontent,registry,logging,deprecation,handler,instance,new,bytes,array,data,state,from,xcontent,parser,if,state,null,logger,debug,no,data,for,ignoring,prefix,state,file,to,absolute,path,else,state,read,named,xcontent,registry,state,file,logger,trace,state,id,read,from,id,state,file,get,file,name,return,state,catch,exception,e,exceptions,add,new,ioexception,failed,to,read,path,and,state,id,to,string,e,logger,debug,new,parameterized,message,failed,to,read,ignoring,path,and,state,id,file,to,absolute,path,prefix,e,exceptions,helper,maybe,throw,runtime,and,suppress,exceptions,if,files,size,0,throw,new,illegal,state,exception,could,not,find,a,state,file,to,recover,from,among,files,return,state
MetaDataStateFormat -> public  T loadLatestState(Logger logger, NamedXContentRegistry namedXContentRegistry, Path... dataLocations) throws IOException;1527773340;Tries to load the latest state from the given data-locations. It tries to load the latest state determined by_the states version from one or more data directories and if none of the latest states can be loaded an exception_is thrown to prevent accidentally loading a previous state and silently omitting the latest state.__@param logger a logger instance_@param dataLocations the data-locations to try._@return the latest state or <code>null</code> if no state was found.;public  T loadLatestState(Logger logger, NamedXContentRegistry namedXContentRegistry, Path... dataLocations) throws IOException {_        List<PathAndStateId> files = new ArrayList<>()__        long maxStateId = -1__        boolean maxStateIdIsLegacy = true__        if (dataLocations != null) { _            for (Path dataLocation : dataLocations) {_                final Path stateDir = dataLocation.resolve(STATE_DIR_NAME)__                _                _                _                _                try (DirectoryStream<Path> paths = Files.newDirectoryStream(stateDir)) {_                    for (Path stateFile : paths) {_                        final Matcher matcher = stateFilePattern.matcher(stateFile.getFileName().toString())__                        if (matcher.matches()) {_                            final long stateId = Long.parseLong(matcher.group(1))__                            maxStateId = Math.max(maxStateId, stateId)__                            final boolean legacy = MetaDataStateFormat.STATE_FILE_EXTENSION.equals(matcher.group(2)) == false__                            maxStateIdIsLegacy &= legacy_ _                            PathAndStateId pav = new PathAndStateId(stateFile, stateId, legacy)__                            logger.trace("found state file: {}", pav)__                            files.add(pav)__                        }_                    }_                } catch (NoSuchFileException | FileNotFoundException ex) {_                    _                }_            }_        }_        final List<Throwable> exceptions = new ArrayList<>()__        T state = null__        _        _        _        _        _        Collection<PathAndStateId> pathAndStateIds = files_                .stream()_                .filter(new StateIdAndLegacyPredicate(maxStateId, maxStateIdIsLegacy))_                .collect(Collectors.toCollection(ArrayList::new))___        for (PathAndStateId pathAndStateId : pathAndStateIds) {_            try {_                final Path stateFile = pathAndStateId.file__                final long id = pathAndStateId.id__                if (pathAndStateId.legacy) { _                    final byte[] data = Files.readAllBytes(stateFile)__                    if (data.length == 0) {_                        logger.debug("{}: no data for [{}], ignoring...", prefix, stateFile.toAbsolutePath())__                        continue__                    }_                    try (XContentParser parser = XContentHelper_                            .createParser(namedXContentRegistry, LoggingDeprecationHandler.INSTANCE, new BytesArray(data))) {_                        state = fromXContent(parser)__                    }_                    if (state == null) {_                        logger.debug("{}: no data for [{}], ignoring...", prefix, stateFile.toAbsolutePath())__                    }_                } else {_                    state = read(namedXContentRegistry, stateFile)__                    logger.trace("state id [{}] read from [{}]", id, stateFile.getFileName())__                }_                return state__            } catch (Exception e) {_                exceptions.add(new IOException("failed to read " + pathAndStateId.toString(), e))__                logger.debug(() -> new ParameterizedMessage(_                        "{}: failed to read [{}], ignoring...", pathAndStateId.file.toAbsolutePath(), prefix), e)__            }_        }_        _        ExceptionsHelper.maybeThrowRuntimeAndSuppress(exceptions)__        if (files.size() > 0) {_            _            throw new IllegalStateException("Could not find a state file to recover from among " + files)__        }_        return state__    };tries,to,load,the,latest,state,from,the,given,data,locations,it,tries,to,load,the,latest,state,determined,by,the,states,version,from,one,or,more,data,directories,and,if,none,of,the,latest,states,can,be,loaded,an,exception,is,thrown,to,prevent,accidentally,loading,a,previous,state,and,silently,omitting,the,latest,state,param,logger,a,logger,instance,param,data,locations,the,data,locations,to,try,return,the,latest,state,or,code,null,code,if,no,state,was,found;public,t,load,latest,state,logger,logger,named,xcontent,registry,named,xcontent,registry,path,data,locations,throws,ioexception,list,path,and,state,id,files,new,array,list,long,max,state,id,1,boolean,max,state,id,is,legacy,true,if,data,locations,null,for,path,data,location,data,locations,final,path,state,dir,data,location,resolve,try,directory,stream,path,paths,files,new,directory,stream,state,dir,for,path,state,file,paths,final,matcher,matcher,state,file,pattern,matcher,state,file,get,file,name,to,string,if,matcher,matches,final,long,state,id,long,parse,long,matcher,group,1,max,state,id,math,max,max,state,id,state,id,final,boolean,legacy,meta,data,state,format,equals,matcher,group,2,false,max,state,id,is,legacy,legacy,path,and,state,id,pav,new,path,and,state,id,state,file,state,id,legacy,logger,trace,found,state,file,pav,files,add,pav,catch,no,such,file,exception,file,not,found,exception,ex,final,list,throwable,exceptions,new,array,list,t,state,null,collection,path,and,state,id,path,and,state,ids,files,stream,filter,new,state,id,and,legacy,predicate,max,state,id,max,state,id,is,legacy,collect,collectors,to,collection,array,list,new,for,path,and,state,id,path,and,state,id,path,and,state,ids,try,final,path,state,file,path,and,state,id,file,final,long,id,path,and,state,id,id,if,path,and,state,id,legacy,final,byte,data,files,read,all,bytes,state,file,if,data,length,0,logger,debug,no,data,for,ignoring,prefix,state,file,to,absolute,path,continue,try,xcontent,parser,parser,xcontent,helper,create,parser,named,xcontent,registry,logging,deprecation,handler,instance,new,bytes,array,data,state,from,xcontent,parser,if,state,null,logger,debug,no,data,for,ignoring,prefix,state,file,to,absolute,path,else,state,read,named,xcontent,registry,state,file,logger,trace,state,id,read,from,id,state,file,get,file,name,return,state,catch,exception,e,exceptions,add,new,ioexception,failed,to,read,path,and,state,id,to,string,e,logger,debug,new,parameterized,message,failed,to,read,ignoring,path,and,state,id,file,to,absolute,path,prefix,e,exceptions,helper,maybe,throw,runtime,and,suppress,exceptions,if,files,size,0,throw,new,illegal,state,exception,could,not,find,a,state,file,to,recover,from,among,files,return,state
MetaDataStateFormat -> public  T loadLatestState(Logger logger, NamedXContentRegistry namedXContentRegistry, Path... dataLocations) throws IOException;1529015561;Tries to load the latest state from the given data-locations. It tries to load the latest state determined by_the states version from one or more data directories and if none of the latest states can be loaded an exception_is thrown to prevent accidentally loading a previous state and silently omitting the latest state.__@param logger a logger instance_@param dataLocations the data-locations to try._@return the latest state or <code>null</code> if no state was found.;public  T loadLatestState(Logger logger, NamedXContentRegistry namedXContentRegistry, Path... dataLocations) throws IOException {_        List<PathAndStateId> files = new ArrayList<>()__        long maxStateId = -1__        boolean maxStateIdIsLegacy = true__        if (dataLocations != null) { _            for (Path dataLocation : dataLocations) {_                final Path stateDir = dataLocation.resolve(STATE_DIR_NAME)__                _                _                _                _                try (DirectoryStream<Path> paths = Files.newDirectoryStream(stateDir)) {_                    for (Path stateFile : paths) {_                        final Matcher matcher = stateFilePattern.matcher(stateFile.getFileName().toString())__                        if (matcher.matches()) {_                            final long stateId = Long.parseLong(matcher.group(1))__                            maxStateId = Math.max(maxStateId, stateId)__                            final boolean legacy = MetaDataStateFormat.STATE_FILE_EXTENSION.equals(matcher.group(2)) == false__                            maxStateIdIsLegacy &= legacy_ _                            PathAndStateId pav = new PathAndStateId(stateFile, stateId, legacy)__                            logger.trace("found state file: {}", pav)__                            files.add(pav)__                        }_                    }_                } catch (NoSuchFileException | FileNotFoundException ex) {_                    _                }_            }_        }_        final List<Throwable> exceptions = new ArrayList<>()__        T state = null__        _        _        _        _        _        Collection<PathAndStateId> pathAndStateIds = files_                .stream()_                .filter(new StateIdAndLegacyPredicate(maxStateId, maxStateIdIsLegacy))_                .collect(Collectors.toCollection(ArrayList::new))___        for (PathAndStateId pathAndStateId : pathAndStateIds) {_            try {_                final Path stateFile = pathAndStateId.file__                final long id = pathAndStateId.id__                if (pathAndStateId.legacy) { _                    final byte[] data = Files.readAllBytes(stateFile)__                    if (data.length == 0) {_                        logger.debug("{}: no data for [{}], ignoring...", prefix, stateFile.toAbsolutePath())__                        continue__                    }_                    try (XContentParser parser = XContentHelper_                            .createParser(namedXContentRegistry, LoggingDeprecationHandler.INSTANCE, new BytesArray(data))) {_                        state = fromXContent(parser)__                    }_                    if (state == null) {_                        logger.debug("{}: no data for [{}], ignoring...", prefix, stateFile.toAbsolutePath())__                    }_                } else {_                    state = read(namedXContentRegistry, stateFile)__                    logger.trace("state id [{}] read from [{}]", id, stateFile.getFileName())__                }_                return state__            } catch (Exception e) {_                exceptions.add(new IOException("failed to read " + pathAndStateId.toString(), e))__                logger.debug(() -> new ParameterizedMessage(_                        "{}: failed to read [{}], ignoring...", pathAndStateId.file.toAbsolutePath(), prefix), e)__            }_        }_        _        ExceptionsHelper.maybeThrowRuntimeAndSuppress(exceptions)__        if (files.size() > 0) {_            _            throw new IllegalStateException("Could not find a state file to recover from among " + files)__        }_        return state__    };tries,to,load,the,latest,state,from,the,given,data,locations,it,tries,to,load,the,latest,state,determined,by,the,states,version,from,one,or,more,data,directories,and,if,none,of,the,latest,states,can,be,loaded,an,exception,is,thrown,to,prevent,accidentally,loading,a,previous,state,and,silently,omitting,the,latest,state,param,logger,a,logger,instance,param,data,locations,the,data,locations,to,try,return,the,latest,state,or,code,null,code,if,no,state,was,found;public,t,load,latest,state,logger,logger,named,xcontent,registry,named,xcontent,registry,path,data,locations,throws,ioexception,list,path,and,state,id,files,new,array,list,long,max,state,id,1,boolean,max,state,id,is,legacy,true,if,data,locations,null,for,path,data,location,data,locations,final,path,state,dir,data,location,resolve,try,directory,stream,path,paths,files,new,directory,stream,state,dir,for,path,state,file,paths,final,matcher,matcher,state,file,pattern,matcher,state,file,get,file,name,to,string,if,matcher,matches,final,long,state,id,long,parse,long,matcher,group,1,max,state,id,math,max,max,state,id,state,id,final,boolean,legacy,meta,data,state,format,equals,matcher,group,2,false,max,state,id,is,legacy,legacy,path,and,state,id,pav,new,path,and,state,id,state,file,state,id,legacy,logger,trace,found,state,file,pav,files,add,pav,catch,no,such,file,exception,file,not,found,exception,ex,final,list,throwable,exceptions,new,array,list,t,state,null,collection,path,and,state,id,path,and,state,ids,files,stream,filter,new,state,id,and,legacy,predicate,max,state,id,max,state,id,is,legacy,collect,collectors,to,collection,array,list,new,for,path,and,state,id,path,and,state,id,path,and,state,ids,try,final,path,state,file,path,and,state,id,file,final,long,id,path,and,state,id,id,if,path,and,state,id,legacy,final,byte,data,files,read,all,bytes,state,file,if,data,length,0,logger,debug,no,data,for,ignoring,prefix,state,file,to,absolute,path,continue,try,xcontent,parser,parser,xcontent,helper,create,parser,named,xcontent,registry,logging,deprecation,handler,instance,new,bytes,array,data,state,from,xcontent,parser,if,state,null,logger,debug,no,data,for,ignoring,prefix,state,file,to,absolute,path,else,state,read,named,xcontent,registry,state,file,logger,trace,state,id,read,from,id,state,file,get,file,name,return,state,catch,exception,e,exceptions,add,new,ioexception,failed,to,read,path,and,state,id,to,string,e,logger,debug,new,parameterized,message,failed,to,read,ignoring,path,and,state,id,file,to,absolute,path,prefix,e,exceptions,helper,maybe,throw,runtime,and,suppress,exceptions,if,files,size,0,throw,new,illegal,state,exception,could,not,find,a,state,file,to,recover,from,among,files,return,state
MetaDataStateFormat -> public static void deleteMetaState(Path... dataLocations) throws IOException;1524684173;Deletes all meta state directories recursively for the given data locations_@param dataLocations the data location to delete;public static void deleteMetaState(Path... dataLocations) throws IOException {_        Path[] stateDirectories = new Path[dataLocations.length]__        for (int i = 0_ i < dataLocations.length_ i++) {_            stateDirectories[i] = dataLocations[i].resolve(STATE_DIR_NAME)__        }_        IOUtils.rm(stateDirectories)__    };deletes,all,meta,state,directories,recursively,for,the,given,data,locations,param,data,locations,the,data,location,to,delete;public,static,void,delete,meta,state,path,data,locations,throws,ioexception,path,state,directories,new,path,data,locations,length,for,int,i,0,i,data,locations,length,i,state,directories,i,data,locations,i,resolve,ioutils,rm,state,directories
MetaDataStateFormat -> public static void deleteMetaState(Path... dataLocations) throws IOException;1525334055;Deletes all meta state directories recursively for the given data locations_@param dataLocations the data location to delete;public static void deleteMetaState(Path... dataLocations) throws IOException {_        Path[] stateDirectories = new Path[dataLocations.length]__        for (int i = 0_ i < dataLocations.length_ i++) {_            stateDirectories[i] = dataLocations[i].resolve(STATE_DIR_NAME)__        }_        IOUtils.rm(stateDirectories)__    };deletes,all,meta,state,directories,recursively,for,the,given,data,locations,param,data,locations,the,data,location,to,delete;public,static,void,delete,meta,state,path,data,locations,throws,ioexception,path,state,directories,new,path,data,locations,length,for,int,i,0,i,data,locations,length,i,state,directories,i,data,locations,i,resolve,ioutils,rm,state,directories
MetaDataStateFormat -> public static void deleteMetaState(Path... dataLocations) throws IOException;1527773340;Deletes all meta state directories recursively for the given data locations_@param dataLocations the data location to delete;public static void deleteMetaState(Path... dataLocations) throws IOException {_        Path[] stateDirectories = new Path[dataLocations.length]__        for (int i = 0_ i < dataLocations.length_ i++) {_            stateDirectories[i] = dataLocations[i].resolve(STATE_DIR_NAME)__        }_        IOUtils.rm(stateDirectories)__    };deletes,all,meta,state,directories,recursively,for,the,given,data,locations,param,data,locations,the,data,location,to,delete;public,static,void,delete,meta,state,path,data,locations,throws,ioexception,path,state,directories,new,path,data,locations,length,for,int,i,0,i,data,locations,length,i,state,directories,i,data,locations,i,resolve,ioutils,rm,state,directories
MetaDataStateFormat -> public static void deleteMetaState(Path... dataLocations) throws IOException;1529015561;Deletes all meta state directories recursively for the given data locations_@param dataLocations the data location to delete;public static void deleteMetaState(Path... dataLocations) throws IOException {_        Path[] stateDirectories = new Path[dataLocations.length]__        for (int i = 0_ i < dataLocations.length_ i++) {_            stateDirectories[i] = dataLocations[i].resolve(STATE_DIR_NAME)__        }_        IOUtils.rm(stateDirectories)__    };deletes,all,meta,state,directories,recursively,for,the,given,data,locations,param,data,locations,the,data,location,to,delete;public,static,void,delete,meta,state,path,data,locations,throws,ioexception,path,state,directories,new,path,data,locations,length,for,int,i,0,i,data,locations,length,i,state,directories,i,data,locations,i,resolve,ioutils,rm,state,directories
MetaDataStateFormat -> public static void deleteMetaState(Path... dataLocations) throws IOException;1531179852;Deletes all meta state directories recursively for the given data locations_@param dataLocations the data location to delete;public static void deleteMetaState(Path... dataLocations) throws IOException {_        Path[] stateDirectories = new Path[dataLocations.length]__        for (int i = 0_ i < dataLocations.length_ i++) {_            stateDirectories[i] = dataLocations[i].resolve(STATE_DIR_NAME)__        }_        IOUtils.rm(stateDirectories)__    };deletes,all,meta,state,directories,recursively,for,the,given,data,locations,param,data,locations,the,data,location,to,delete;public,static,void,delete,meta,state,path,data,locations,throws,ioexception,path,state,directories,new,path,data,locations,length,for,int,i,0,i,data,locations,length,i,state,directories,i,data,locations,i,resolve,ioutils,rm,state,directories
MetaDataStateFormat -> public static void deleteMetaState(Path... dataLocations) throws IOException;1540486836;Deletes all meta state directories recursively for the given data locations_@param dataLocations the data location to delete;public static void deleteMetaState(Path... dataLocations) throws IOException {_        Path[] stateDirectories = new Path[dataLocations.length]__        for (int i = 0_ i < dataLocations.length_ i++) {_            stateDirectories[i] = dataLocations[i].resolve(STATE_DIR_NAME)__        }_        IOUtils.rm(stateDirectories)__    };deletes,all,meta,state,directories,recursively,for,the,given,data,locations,param,data,locations,the,data,location,to,delete;public,static,void,delete,meta,state,path,data,locations,throws,ioexception,path,state,directories,new,path,data,locations,length,for,int,i,0,i,data,locations,length,i,state,directories,i,data,locations,i,resolve,ioutils,rm,state,directories
MetaDataStateFormat -> public static void deleteMetaState(Path... dataLocations) throws IOException;1544081506;Deletes all meta state directories recursively for the given data locations_@param dataLocations the data location to delete;public static void deleteMetaState(Path... dataLocations) throws IOException {_        Path[] stateDirectories = new Path[dataLocations.length]__        for (int i = 0_ i < dataLocations.length_ i++) {_            stateDirectories[i] = dataLocations[i].resolve(STATE_DIR_NAME)__        }_        IOUtils.rm(stateDirectories)__    };deletes,all,meta,state,directories,recursively,for,the,given,data,locations,param,data,locations,the,data,location,to,delete;public,static,void,delete,meta,state,path,data,locations,throws,ioexception,path,state,directories,new,path,data,locations,length,for,int,i,0,i,data,locations,length,i,state,directories,i,data,locations,i,resolve,ioutils,rm,state,directories
MetaDataStateFormat -> public abstract T fromXContent(XContentParser parser) throws IOException_;1524684173;Reads a new instance of the state from the given XContentParser_Subclasses need to implement this class for theirs specific state.;public abstract T fromXContent(XContentParser parser) throws IOException_;reads,a,new,instance,of,the,state,from,the,given,xcontent,parser,subclasses,need,to,implement,this,class,for,theirs,specific,state;public,abstract,t,from,xcontent,xcontent,parser,parser,throws,ioexception
MetaDataStateFormat -> public abstract T fromXContent(XContentParser parser) throws IOException_;1525334055;Reads a new instance of the state from the given XContentParser_Subclasses need to implement this class for theirs specific state.;public abstract T fromXContent(XContentParser parser) throws IOException_;reads,a,new,instance,of,the,state,from,the,given,xcontent,parser,subclasses,need,to,implement,this,class,for,theirs,specific,state;public,abstract,t,from,xcontent,xcontent,parser,parser,throws,ioexception
MetaDataStateFormat -> public abstract T fromXContent(XContentParser parser) throws IOException_;1527773340;Reads a new instance of the state from the given XContentParser_Subclasses need to implement this class for theirs specific state.;public abstract T fromXContent(XContentParser parser) throws IOException_;reads,a,new,instance,of,the,state,from,the,given,xcontent,parser,subclasses,need,to,implement,this,class,for,theirs,specific,state;public,abstract,t,from,xcontent,xcontent,parser,parser,throws,ioexception
MetaDataStateFormat -> public abstract T fromXContent(XContentParser parser) throws IOException_;1529015561;Reads a new instance of the state from the given XContentParser_Subclasses need to implement this class for theirs specific state.;public abstract T fromXContent(XContentParser parser) throws IOException_;reads,a,new,instance,of,the,state,from,the,given,xcontent,parser,subclasses,need,to,implement,this,class,for,theirs,specific,state;public,abstract,t,from,xcontent,xcontent,parser,parser,throws,ioexception
MetaDataStateFormat -> public abstract T fromXContent(XContentParser parser) throws IOException_;1531179852;Reads a new instance of the state from the given XContentParser_Subclasses need to implement this class for theirs specific state.;public abstract T fromXContent(XContentParser parser) throws IOException_;reads,a,new,instance,of,the,state,from,the,given,xcontent,parser,subclasses,need,to,implement,this,class,for,theirs,specific,state;public,abstract,t,from,xcontent,xcontent,parser,parser,throws,ioexception
MetaDataStateFormat -> public abstract T fromXContent(XContentParser parser) throws IOException_;1540486836;Reads a new instance of the state from the given XContentParser_Subclasses need to implement this class for theirs specific state.;public abstract T fromXContent(XContentParser parser) throws IOException_;reads,a,new,instance,of,the,state,from,the,given,xcontent,parser,subclasses,need,to,implement,this,class,for,theirs,specific,state;public,abstract,t,from,xcontent,xcontent,parser,parser,throws,ioexception
MetaDataStateFormat -> public abstract T fromXContent(XContentParser parser) throws IOException_;1544081506;Reads a new instance of the state from the given XContentParser_Subclasses need to implement this class for theirs specific state.;public abstract T fromXContent(XContentParser parser) throws IOException_;reads,a,new,instance,of,the,state,from,the,given,xcontent,parser,subclasses,need,to,implement,this,class,for,theirs,specific,state;public,abstract,t,from,xcontent,xcontent,parser,parser,throws,ioexception
MetaDataStateFormat -> protected MetaDataStateFormat(String prefix);1524684173;Creates a new {@link MetaDataStateFormat} instance;protected MetaDataStateFormat(String prefix) {_        this.prefix = prefix__        this.stateFilePattern = Pattern.compile(Pattern.quote(prefix) + "(\\d+)(" + MetaDataStateFormat.STATE_FILE_EXTENSION + ")?")___    };creates,a,new,link,meta,data,state,format,instance;protected,meta,data,state,format,string,prefix,this,prefix,prefix,this,state,file,pattern,pattern,compile,pattern,quote,prefix,d,meta,data,state,format
MetaDataStateFormat -> protected MetaDataStateFormat(String prefix);1525334055;Creates a new {@link MetaDataStateFormat} instance;protected MetaDataStateFormat(String prefix) {_        this.prefix = prefix__        this.stateFilePattern = Pattern.compile(Pattern.quote(prefix) + "(\\d+)(" + MetaDataStateFormat.STATE_FILE_EXTENSION + ")?")___    };creates,a,new,link,meta,data,state,format,instance;protected,meta,data,state,format,string,prefix,this,prefix,prefix,this,state,file,pattern,pattern,compile,pattern,quote,prefix,d,meta,data,state,format
MetaDataStateFormat -> protected MetaDataStateFormat(String prefix);1527773340;Creates a new {@link MetaDataStateFormat} instance;protected MetaDataStateFormat(String prefix) {_        this.prefix = prefix__        this.stateFilePattern = Pattern.compile(Pattern.quote(prefix) + "(\\d+)(" + MetaDataStateFormat.STATE_FILE_EXTENSION + ")?")___    };creates,a,new,link,meta,data,state,format,instance;protected,meta,data,state,format,string,prefix,this,prefix,prefix,this,state,file,pattern,pattern,compile,pattern,quote,prefix,d,meta,data,state,format
MetaDataStateFormat -> protected MetaDataStateFormat(String prefix);1529015561;Creates a new {@link MetaDataStateFormat} instance;protected MetaDataStateFormat(String prefix) {_        this.prefix = prefix__        this.stateFilePattern = Pattern.compile(Pattern.quote(prefix) + "(\\d+)(" + MetaDataStateFormat.STATE_FILE_EXTENSION + ")?")___    };creates,a,new,link,meta,data,state,format,instance;protected,meta,data,state,format,string,prefix,this,prefix,prefix,this,state,file,pattern,pattern,compile,pattern,quote,prefix,d,meta,data,state,format
MetaDataStateFormat -> protected MetaDataStateFormat(String prefix);1531179852;Creates a new {@link MetaDataStateFormat} instance;protected MetaDataStateFormat(String prefix) {_        this.prefix = prefix__        this.stateFilePattern = Pattern.compile(Pattern.quote(prefix) + "(\\d+)(" + MetaDataStateFormat.STATE_FILE_EXTENSION + ")?")___    };creates,a,new,link,meta,data,state,format,instance;protected,meta,data,state,format,string,prefix,this,prefix,prefix,this,state,file,pattern,pattern,compile,pattern,quote,prefix,d,meta,data,state,format
MetaDataStateFormat -> protected MetaDataStateFormat(String prefix);1540486836;Creates a new {@link MetaDataStateFormat} instance;protected MetaDataStateFormat(String prefix) {_        this.prefix = prefix__        this.stateFilePattern = Pattern.compile(Pattern.quote(prefix) + "(\\d+)(" + MetaDataStateFormat.STATE_FILE_EXTENSION + ")?")___    };creates,a,new,link,meta,data,state,format,instance;protected,meta,data,state,format,string,prefix,this,prefix,prefix,this,state,file,pattern,pattern,compile,pattern,quote,prefix,d,meta,data,state,format
MetaDataStateFormat -> protected MetaDataStateFormat(String prefix);1544081506;Creates a new {@link MetaDataStateFormat} instance;protected MetaDataStateFormat(String prefix) {_        this.prefix = prefix__        this.stateFilePattern = Pattern.compile(Pattern.quote(prefix) + "(\\d+)(" + MetaDataStateFormat.STATE_FILE_EXTENSION + ")?")__    };creates,a,new,link,meta,data,state,format,instance;protected,meta,data,state,format,string,prefix,this,prefix,prefix,this,state,file,pattern,pattern,compile,pattern,quote,prefix,d,meta,data,state,format
MetaDataStateFormat -> public final T read(NamedXContentRegistry namedXContentRegistry, Path file) throws IOException;1524684173;Reads the state from a given file and compares the expected version against the actual version of_the state.;public final T read(NamedXContentRegistry namedXContentRegistry, Path file) throws IOException {_        try (Directory dir = newDirectory(file.getParent())) {_            try (IndexInput indexInput = dir.openInput(file.getFileName().toString(), IOContext.DEFAULT)) {_                 _                CodecUtil.checksumEntireFile(indexInput)__                final int fileVersion = CodecUtil.checkHeader(indexInput, STATE_FILE_CODEC, MIN_COMPATIBLE_STATE_FILE_VERSION,_                    STATE_FILE_VERSION)__                final XContentType xContentType = XContentType.values()[indexInput.readInt()]__                if (xContentType != FORMAT) {_                    throw new IllegalStateException("expected state in " + file + " to be " + FORMAT + " format but was " + xContentType)__                }_                if (fileVersion == STATE_FILE_VERSION_ES_2X_AND_BELOW) {_                    _                    indexInput.readLong()_ _                }_                long filePointer = indexInput.getFilePointer()__                long contentSize = indexInput.length() - CodecUtil.footerLength() - filePointer__                try (IndexInput slice = indexInput.slice("state_xcontent", filePointer, contentSize)) {_                    try (XContentParser parser = XContentFactory.xContent(FORMAT)_                            .createParser(namedXContentRegistry, LoggingDeprecationHandler.INSTANCE,_                                new InputStreamIndexInput(slice, contentSize))) {_                        return fromXContent(parser)__                    }_                }_            } catch(CorruptIndexException | IndexFormatTooOldException | IndexFormatTooNewException ex) {_                _                throw new CorruptStateException(ex)__            }_        }_    };reads,the,state,from,a,given,file,and,compares,the,expected,version,against,the,actual,version,of,the,state;public,final,t,read,named,xcontent,registry,named,xcontent,registry,path,file,throws,ioexception,try,directory,dir,new,directory,file,get,parent,try,index,input,index,input,dir,open,input,file,get,file,name,to,string,iocontext,default,codec,util,checksum,entire,file,index,input,final,int,file,version,codec,util,check,header,index,input,final,xcontent,type,x,content,type,xcontent,type,values,index,input,read,int,if,x,content,type,format,throw,new,illegal,state,exception,expected,state,in,file,to,be,format,format,but,was,x,content,type,if,file,version,index,input,read,long,long,file,pointer,index,input,get,file,pointer,long,content,size,index,input,length,codec,util,footer,length,file,pointer,try,index,input,slice,index,input,slice,file,pointer,content,size,try,xcontent,parser,parser,xcontent,factory,x,content,format,create,parser,named,xcontent,registry,logging,deprecation,handler,instance,new,input,stream,index,input,slice,content,size,return,from,xcontent,parser,catch,corrupt,index,exception,index,format,too,old,exception,index,format,too,new,exception,ex,throw,new,corrupt,state,exception,ex
MetaDataStateFormat -> public final T read(NamedXContentRegistry namedXContentRegistry, Path file) throws IOException;1525334055;Reads the state from a given file and compares the expected version against the actual version of_the state.;public final T read(NamedXContentRegistry namedXContentRegistry, Path file) throws IOException {_        try (Directory dir = newDirectory(file.getParent())) {_            try (IndexInput indexInput = dir.openInput(file.getFileName().toString(), IOContext.DEFAULT)) {_                 _                CodecUtil.checksumEntireFile(indexInput)__                final int fileVersion = CodecUtil.checkHeader(indexInput, STATE_FILE_CODEC, MIN_COMPATIBLE_STATE_FILE_VERSION,_                    STATE_FILE_VERSION)__                final XContentType xContentType = XContentType.values()[indexInput.readInt()]__                if (xContentType != FORMAT) {_                    throw new IllegalStateException("expected state in " + file + " to be " + FORMAT + " format but was " + xContentType)__                }_                if (fileVersion == STATE_FILE_VERSION_ES_2X_AND_BELOW) {_                    _                    indexInput.readLong()_ _                }_                long filePointer = indexInput.getFilePointer()__                long contentSize = indexInput.length() - CodecUtil.footerLength() - filePointer__                try (IndexInput slice = indexInput.slice("state_xcontent", filePointer, contentSize)) {_                    try (XContentParser parser = XContentFactory.xContent(FORMAT)_                            .createParser(namedXContentRegistry, LoggingDeprecationHandler.INSTANCE,_                                new InputStreamIndexInput(slice, contentSize))) {_                        return fromXContent(parser)__                    }_                }_            } catch(CorruptIndexException | IndexFormatTooOldException | IndexFormatTooNewException ex) {_                _                throw new CorruptStateException(ex)__            }_        }_    };reads,the,state,from,a,given,file,and,compares,the,expected,version,against,the,actual,version,of,the,state;public,final,t,read,named,xcontent,registry,named,xcontent,registry,path,file,throws,ioexception,try,directory,dir,new,directory,file,get,parent,try,index,input,index,input,dir,open,input,file,get,file,name,to,string,iocontext,default,codec,util,checksum,entire,file,index,input,final,int,file,version,codec,util,check,header,index,input,final,xcontent,type,x,content,type,xcontent,type,values,index,input,read,int,if,x,content,type,format,throw,new,illegal,state,exception,expected,state,in,file,to,be,format,format,but,was,x,content,type,if,file,version,index,input,read,long,long,file,pointer,index,input,get,file,pointer,long,content,size,index,input,length,codec,util,footer,length,file,pointer,try,index,input,slice,index,input,slice,file,pointer,content,size,try,xcontent,parser,parser,xcontent,factory,x,content,format,create,parser,named,xcontent,registry,logging,deprecation,handler,instance,new,input,stream,index,input,slice,content,size,return,from,xcontent,parser,catch,corrupt,index,exception,index,format,too,old,exception,index,format,too,new,exception,ex,throw,new,corrupt,state,exception,ex
MetaDataStateFormat -> public final T read(NamedXContentRegistry namedXContentRegistry, Path file) throws IOException;1527773340;Reads the state from a given file and compares the expected version against the actual version of_the state.;public final T read(NamedXContentRegistry namedXContentRegistry, Path file) throws IOException {_        try (Directory dir = newDirectory(file.getParent())) {_            try (IndexInput indexInput = dir.openInput(file.getFileName().toString(), IOContext.DEFAULT)) {_                 _                CodecUtil.checksumEntireFile(indexInput)__                final int fileVersion = CodecUtil.checkHeader(indexInput, STATE_FILE_CODEC, MIN_COMPATIBLE_STATE_FILE_VERSION,_                    STATE_FILE_VERSION)__                final XContentType xContentType = XContentType.values()[indexInput.readInt()]__                if (xContentType != FORMAT) {_                    throw new IllegalStateException("expected state in " + file + " to be " + FORMAT + " format but was " + xContentType)__                }_                if (fileVersion == STATE_FILE_VERSION_ES_2X_AND_BELOW) {_                    _                    indexInput.readLong()_ _                }_                long filePointer = indexInput.getFilePointer()__                long contentSize = indexInput.length() - CodecUtil.footerLength() - filePointer__                try (IndexInput slice = indexInput.slice("state_xcontent", filePointer, contentSize)) {_                    try (XContentParser parser = XContentFactory.xContent(FORMAT)_                            .createParser(namedXContentRegistry, LoggingDeprecationHandler.INSTANCE,_                                new InputStreamIndexInput(slice, contentSize))) {_                        return fromXContent(parser)__                    }_                }_            } catch(CorruptIndexException | IndexFormatTooOldException | IndexFormatTooNewException ex) {_                _                throw new CorruptStateException(ex)__            }_        }_    };reads,the,state,from,a,given,file,and,compares,the,expected,version,against,the,actual,version,of,the,state;public,final,t,read,named,xcontent,registry,named,xcontent,registry,path,file,throws,ioexception,try,directory,dir,new,directory,file,get,parent,try,index,input,index,input,dir,open,input,file,get,file,name,to,string,iocontext,default,codec,util,checksum,entire,file,index,input,final,int,file,version,codec,util,check,header,index,input,final,xcontent,type,x,content,type,xcontent,type,values,index,input,read,int,if,x,content,type,format,throw,new,illegal,state,exception,expected,state,in,file,to,be,format,format,but,was,x,content,type,if,file,version,index,input,read,long,long,file,pointer,index,input,get,file,pointer,long,content,size,index,input,length,codec,util,footer,length,file,pointer,try,index,input,slice,index,input,slice,file,pointer,content,size,try,xcontent,parser,parser,xcontent,factory,x,content,format,create,parser,named,xcontent,registry,logging,deprecation,handler,instance,new,input,stream,index,input,slice,content,size,return,from,xcontent,parser,catch,corrupt,index,exception,index,format,too,old,exception,index,format,too,new,exception,ex,throw,new,corrupt,state,exception,ex
MetaDataStateFormat -> public final T read(NamedXContentRegistry namedXContentRegistry, Path file) throws IOException;1529015561;Reads the state from a given file and compares the expected version against the actual version of_the state.;public final T read(NamedXContentRegistry namedXContentRegistry, Path file) throws IOException {_        try (Directory dir = newDirectory(file.getParent())) {_            try (IndexInput indexInput = dir.openInput(file.getFileName().toString(), IOContext.DEFAULT)) {_                 _                CodecUtil.checksumEntireFile(indexInput)__                final int fileVersion = CodecUtil.checkHeader(indexInput, STATE_FILE_CODEC, MIN_COMPATIBLE_STATE_FILE_VERSION,_                    STATE_FILE_VERSION)__                final XContentType xContentType = XContentType.values()[indexInput.readInt()]__                if (xContentType != FORMAT) {_                    throw new IllegalStateException("expected state in " + file + " to be " + FORMAT + " format but was " + xContentType)__                }_                if (fileVersion == STATE_FILE_VERSION_ES_2X_AND_BELOW) {_                    _                    indexInput.readLong()_ _                }_                long filePointer = indexInput.getFilePointer()__                long contentSize = indexInput.length() - CodecUtil.footerLength() - filePointer__                try (IndexInput slice = indexInput.slice("state_xcontent", filePointer, contentSize)) {_                    try (XContentParser parser = XContentFactory.xContent(FORMAT)_                            .createParser(namedXContentRegistry, LoggingDeprecationHandler.INSTANCE,_                                new InputStreamIndexInput(slice, contentSize))) {_                        return fromXContent(parser)__                    }_                }_            } catch(CorruptIndexException | IndexFormatTooOldException | IndexFormatTooNewException ex) {_                _                throw new CorruptStateException(ex)__            }_        }_    };reads,the,state,from,a,given,file,and,compares,the,expected,version,against,the,actual,version,of,the,state;public,final,t,read,named,xcontent,registry,named,xcontent,registry,path,file,throws,ioexception,try,directory,dir,new,directory,file,get,parent,try,index,input,index,input,dir,open,input,file,get,file,name,to,string,iocontext,default,codec,util,checksum,entire,file,index,input,final,int,file,version,codec,util,check,header,index,input,final,xcontent,type,x,content,type,xcontent,type,values,index,input,read,int,if,x,content,type,format,throw,new,illegal,state,exception,expected,state,in,file,to,be,format,format,but,was,x,content,type,if,file,version,index,input,read,long,long,file,pointer,index,input,get,file,pointer,long,content,size,index,input,length,codec,util,footer,length,file,pointer,try,index,input,slice,index,input,slice,file,pointer,content,size,try,xcontent,parser,parser,xcontent,factory,x,content,format,create,parser,named,xcontent,registry,logging,deprecation,handler,instance,new,input,stream,index,input,slice,content,size,return,from,xcontent,parser,catch,corrupt,index,exception,index,format,too,old,exception,index,format,too,new,exception,ex,throw,new,corrupt,state,exception,ex
MetaDataStateFormat -> public final T read(NamedXContentRegistry namedXContentRegistry, Path file) throws IOException;1531179852;Reads the state from a given file and compares the expected version against the actual version of_the state.;public final T read(NamedXContentRegistry namedXContentRegistry, Path file) throws IOException {_        try (Directory dir = newDirectory(file.getParent())) {_            try (IndexInput indexInput = dir.openInput(file.getFileName().toString(), IOContext.DEFAULT)) {_                 _                CodecUtil.checksumEntireFile(indexInput)__                CodecUtil.checkHeader(indexInput, STATE_FILE_CODEC, MIN_COMPATIBLE_STATE_FILE_VERSION, STATE_FILE_VERSION)__                final XContentType xContentType = XContentType.values()[indexInput.readInt()]__                if (xContentType != FORMAT) {_                    throw new IllegalStateException("expected state in " + file + " to be " + FORMAT + " format but was " + xContentType)__                }_                long filePointer = indexInput.getFilePointer()__                long contentSize = indexInput.length() - CodecUtil.footerLength() - filePointer__                try (IndexInput slice = indexInput.slice("state_xcontent", filePointer, contentSize)) {_                    try (XContentParser parser = XContentFactory.xContent(FORMAT)_                            .createParser(namedXContentRegistry, LoggingDeprecationHandler.INSTANCE,_                                new InputStreamIndexInput(slice, contentSize))) {_                        return fromXContent(parser)__                    }_                }_            } catch(CorruptIndexException | IndexFormatTooOldException | IndexFormatTooNewException ex) {_                _                throw new CorruptStateException(ex)__            }_        }_    };reads,the,state,from,a,given,file,and,compares,the,expected,version,against,the,actual,version,of,the,state;public,final,t,read,named,xcontent,registry,named,xcontent,registry,path,file,throws,ioexception,try,directory,dir,new,directory,file,get,parent,try,index,input,index,input,dir,open,input,file,get,file,name,to,string,iocontext,default,codec,util,checksum,entire,file,index,input,codec,util,check,header,index,input,final,xcontent,type,x,content,type,xcontent,type,values,index,input,read,int,if,x,content,type,format,throw,new,illegal,state,exception,expected,state,in,file,to,be,format,format,but,was,x,content,type,long,file,pointer,index,input,get,file,pointer,long,content,size,index,input,length,codec,util,footer,length,file,pointer,try,index,input,slice,index,input,slice,file,pointer,content,size,try,xcontent,parser,parser,xcontent,factory,x,content,format,create,parser,named,xcontent,registry,logging,deprecation,handler,instance,new,input,stream,index,input,slice,content,size,return,from,xcontent,parser,catch,corrupt,index,exception,index,format,too,old,exception,index,format,too,new,exception,ex,throw,new,corrupt,state,exception,ex
MetaDataStateFormat -> public final T read(NamedXContentRegistry namedXContentRegistry, Path file) throws IOException;1540486836;Reads the state from a given file and compares the expected version against the actual version of_the state.;public final T read(NamedXContentRegistry namedXContentRegistry, Path file) throws IOException {_        try (Directory dir = newDirectory(file.getParent())) {_            try (IndexInput indexInput = dir.openInput(file.getFileName().toString(), IOContext.DEFAULT)) {_                 _                CodecUtil.checksumEntireFile(indexInput)__                CodecUtil.checkHeader(indexInput, STATE_FILE_CODEC, MIN_COMPATIBLE_STATE_FILE_VERSION, STATE_FILE_VERSION)__                final XContentType xContentType = XContentType.values()[indexInput.readInt()]__                if (xContentType != FORMAT) {_                    throw new IllegalStateException("expected state in " + file + " to be " + FORMAT + " format but was " + xContentType)__                }_                long filePointer = indexInput.getFilePointer()__                long contentSize = indexInput.length() - CodecUtil.footerLength() - filePointer__                try (IndexInput slice = indexInput.slice("state_xcontent", filePointer, contentSize)) {_                    try (XContentParser parser = XContentFactory.xContent(FORMAT)_                            .createParser(namedXContentRegistry, LoggingDeprecationHandler.INSTANCE,_                                new InputStreamIndexInput(slice, contentSize))) {_                        return fromXContent(parser)__                    }_                }_            } catch(CorruptIndexException | IndexFormatTooOldException | IndexFormatTooNewException ex) {_                _                throw new CorruptStateException(ex)__            }_        }_    };reads,the,state,from,a,given,file,and,compares,the,expected,version,against,the,actual,version,of,the,state;public,final,t,read,named,xcontent,registry,named,xcontent,registry,path,file,throws,ioexception,try,directory,dir,new,directory,file,get,parent,try,index,input,index,input,dir,open,input,file,get,file,name,to,string,iocontext,default,codec,util,checksum,entire,file,index,input,codec,util,check,header,index,input,final,xcontent,type,x,content,type,xcontent,type,values,index,input,read,int,if,x,content,type,format,throw,new,illegal,state,exception,expected,state,in,file,to,be,format,format,but,was,x,content,type,long,file,pointer,index,input,get,file,pointer,long,content,size,index,input,length,codec,util,footer,length,file,pointer,try,index,input,slice,index,input,slice,file,pointer,content,size,try,xcontent,parser,parser,xcontent,factory,x,content,format,create,parser,named,xcontent,registry,logging,deprecation,handler,instance,new,input,stream,index,input,slice,content,size,return,from,xcontent,parser,catch,corrupt,index,exception,index,format,too,old,exception,index,format,too,new,exception,ex,throw,new,corrupt,state,exception,ex
MetaDataStateFormat -> public final T read(NamedXContentRegistry namedXContentRegistry, Path file) throws IOException;1544081506;Reads the state from a given file and compares the expected version against the actual version of_the state.;public final T read(NamedXContentRegistry namedXContentRegistry, Path file) throws IOException {_        try (Directory dir = newDirectory(file.getParent())) {_            try (IndexInput indexInput = dir.openInput(file.getFileName().toString(), IOContext.DEFAULT)) {_                _                CodecUtil.checksumEntireFile(indexInput)__                CodecUtil.checkHeader(indexInput, STATE_FILE_CODEC, MIN_COMPATIBLE_STATE_FILE_VERSION, STATE_FILE_VERSION)__                final XContentType xContentType = XContentType.values()[indexInput.readInt()]__                if (xContentType != FORMAT) {_                    throw new IllegalStateException("expected state in " + file + " to be " + FORMAT + " format but was " + xContentType)__                }_                long filePointer = indexInput.getFilePointer()__                long contentSize = indexInput.length() - CodecUtil.footerLength() - filePointer__                try (IndexInput slice = indexInput.slice("state_xcontent", filePointer, contentSize)) {_                    try (XContentParser parser = XContentFactory.xContent(FORMAT)_                            .createParser(namedXContentRegistry, LoggingDeprecationHandler.INSTANCE,_                                    new InputStreamIndexInput(slice, contentSize))) {_                        return fromXContent(parser)__                    }_                }_            } catch(CorruptIndexException | IndexFormatTooOldException | IndexFormatTooNewException ex) {_                _                throw new CorruptStateException(ex)__            }_        }_    };reads,the,state,from,a,given,file,and,compares,the,expected,version,against,the,actual,version,of,the,state;public,final,t,read,named,xcontent,registry,named,xcontent,registry,path,file,throws,ioexception,try,directory,dir,new,directory,file,get,parent,try,index,input,index,input,dir,open,input,file,get,file,name,to,string,iocontext,default,codec,util,checksum,entire,file,index,input,codec,util,check,header,index,input,final,xcontent,type,x,content,type,xcontent,type,values,index,input,read,int,if,x,content,type,format,throw,new,illegal,state,exception,expected,state,in,file,to,be,format,format,but,was,x,content,type,long,file,pointer,index,input,get,file,pointer,long,content,size,index,input,length,codec,util,footer,length,file,pointer,try,index,input,slice,index,input,slice,file,pointer,content,size,try,xcontent,parser,parser,xcontent,factory,x,content,format,create,parser,named,xcontent,registry,logging,deprecation,handler,instance,new,input,stream,index,input,slice,content,size,return,from,xcontent,parser,catch,corrupt,index,exception,index,format,too,old,exception,index,format,too,new,exception,ex,throw,new,corrupt,state,exception,ex
MetaDataStateFormat -> public T loadLatestState(Logger logger, NamedXContentRegistry namedXContentRegistry, Path... dataLocations) throws IOException;1531179852;Tries to load the latest state from the given data-locations. It tries to load the latest state determined by_the states version from one or more data directories and if none of the latest states can be loaded an exception_is thrown to prevent accidentally loading a previous state and silently omitting the latest state.__@param logger a logger instance_@param dataLocations the data-locations to try._@return the latest state or <code>null</code> if no state was found.;public T loadLatestState(Logger logger, NamedXContentRegistry namedXContentRegistry, Path... dataLocations) throws IOException {_        List<PathAndStateId> files = new ArrayList<>()__        long maxStateId = -1__        if (dataLocations != null) { _            for (Path dataLocation : dataLocations) {_                final Path stateDir = dataLocation.resolve(STATE_DIR_NAME)__                _                _                _                _                try (DirectoryStream<Path> paths = Files.newDirectoryStream(stateDir)) {_                    for (Path stateFile : paths) {_                        final Matcher matcher = stateFilePattern.matcher(stateFile.getFileName().toString())__                        if (matcher.matches()) {_                            final long stateId = Long.parseLong(matcher.group(1))__                            maxStateId = Math.max(maxStateId, stateId)__                            PathAndStateId pav = new PathAndStateId(stateFile, stateId)__                            logger.trace("found state file: {}", pav)__                            files.add(pav)__                        }_                    }_                } catch (NoSuchFileException | FileNotFoundException ex) {_                    _                }_            }_        }_        _        _        long finalMaxStateId = maxStateId__        Collection<PathAndStateId> pathAndStateIds = files_                .stream()_                .filter(pathAndStateId -> pathAndStateId.id == finalMaxStateId)_                .collect(Collectors.toCollection(ArrayList::new))___        final List<Throwable> exceptions = new ArrayList<>()__        for (PathAndStateId pathAndStateId : pathAndStateIds) {_            try {_                T state = read(namedXContentRegistry, pathAndStateId.file)__                logger.trace("state id [{}] read from [{}]", pathAndStateId.id, pathAndStateId.file.getFileName())__                return state__            } catch (Exception e) {_                exceptions.add(new IOException("failed to read " + pathAndStateId.toString(), e))__                logger.debug(() -> new ParameterizedMessage(_                        "{}: failed to read [{}], ignoring...", pathAndStateId.file.toAbsolutePath(), prefix), e)__            }_        }_        _        ExceptionsHelper.maybeThrowRuntimeAndSuppress(exceptions)__        if (files.size() > 0) {_            _            throw new IllegalStateException("Could not find a state file to recover from among " + files)__        }_        return null__    };tries,to,load,the,latest,state,from,the,given,data,locations,it,tries,to,load,the,latest,state,determined,by,the,states,version,from,one,or,more,data,directories,and,if,none,of,the,latest,states,can,be,loaded,an,exception,is,thrown,to,prevent,accidentally,loading,a,previous,state,and,silently,omitting,the,latest,state,param,logger,a,logger,instance,param,data,locations,the,data,locations,to,try,return,the,latest,state,or,code,null,code,if,no,state,was,found;public,t,load,latest,state,logger,logger,named,xcontent,registry,named,xcontent,registry,path,data,locations,throws,ioexception,list,path,and,state,id,files,new,array,list,long,max,state,id,1,if,data,locations,null,for,path,data,location,data,locations,final,path,state,dir,data,location,resolve,try,directory,stream,path,paths,files,new,directory,stream,state,dir,for,path,state,file,paths,final,matcher,matcher,state,file,pattern,matcher,state,file,get,file,name,to,string,if,matcher,matches,final,long,state,id,long,parse,long,matcher,group,1,max,state,id,math,max,max,state,id,state,id,path,and,state,id,pav,new,path,and,state,id,state,file,state,id,logger,trace,found,state,file,pav,files,add,pav,catch,no,such,file,exception,file,not,found,exception,ex,long,final,max,state,id,max,state,id,collection,path,and,state,id,path,and,state,ids,files,stream,filter,path,and,state,id,path,and,state,id,id,final,max,state,id,collect,collectors,to,collection,array,list,new,final,list,throwable,exceptions,new,array,list,for,path,and,state,id,path,and,state,id,path,and,state,ids,try,t,state,read,named,xcontent,registry,path,and,state,id,file,logger,trace,state,id,read,from,path,and,state,id,id,path,and,state,id,file,get,file,name,return,state,catch,exception,e,exceptions,add,new,ioexception,failed,to,read,path,and,state,id,to,string,e,logger,debug,new,parameterized,message,failed,to,read,ignoring,path,and,state,id,file,to,absolute,path,prefix,e,exceptions,helper,maybe,throw,runtime,and,suppress,exceptions,if,files,size,0,throw,new,illegal,state,exception,could,not,find,a,state,file,to,recover,from,among,files,return,null
MetaDataStateFormat -> public T loadLatestState(Logger logger, NamedXContentRegistry namedXContentRegistry, Path... dataLocations) throws IOException;1540486836;Tries to load the latest state from the given data-locations. It tries to load the latest state determined by_the states version from one or more data directories and if none of the latest states can be loaded an exception_is thrown to prevent accidentally loading a previous state and silently omitting the latest state.__@param logger a logger instance_@param dataLocations the data-locations to try._@return the latest state or <code>null</code> if no state was found.;public T loadLatestState(Logger logger, NamedXContentRegistry namedXContentRegistry, Path... dataLocations) throws IOException {_        List<PathAndStateId> files = new ArrayList<>()__        long maxStateId = -1__        if (dataLocations != null) { _            for (Path dataLocation : dataLocations) {_                final Path stateDir = dataLocation.resolve(STATE_DIR_NAME)__                _                _                _                _                try (DirectoryStream<Path> paths = Files.newDirectoryStream(stateDir)) {_                    for (Path stateFile : paths) {_                        final Matcher matcher = stateFilePattern.matcher(stateFile.getFileName().toString())__                        if (matcher.matches()) {_                            final long stateId = Long.parseLong(matcher.group(1))__                            maxStateId = Math.max(maxStateId, stateId)__                            PathAndStateId pav = new PathAndStateId(stateFile, stateId)__                            logger.trace("found state file: {}", pav)__                            files.add(pav)__                        }_                    }_                } catch (NoSuchFileException | FileNotFoundException ex) {_                    _                }_            }_        }_        _        _        long finalMaxStateId = maxStateId__        Collection<PathAndStateId> pathAndStateIds = files_                .stream()_                .filter(pathAndStateId -> pathAndStateId.id == finalMaxStateId)_                .collect(Collectors.toCollection(ArrayList::new))___        final List<Throwable> exceptions = new ArrayList<>()__        for (PathAndStateId pathAndStateId : pathAndStateIds) {_            try {_                T state = read(namedXContentRegistry, pathAndStateId.file)__                logger.trace("state id [{}] read from [{}]", pathAndStateId.id, pathAndStateId.file.getFileName())__                return state__            } catch (Exception e) {_                exceptions.add(new IOException("failed to read " + pathAndStateId.toString(), e))__                logger.debug(() -> new ParameterizedMessage(_                        "{}: failed to read [{}], ignoring...", pathAndStateId.file.toAbsolutePath(), prefix), e)__            }_        }_        _        ExceptionsHelper.maybeThrowRuntimeAndSuppress(exceptions)__        if (files.size() > 0) {_            _            throw new IllegalStateException("Could not find a state file to recover from among " + files)__        }_        return null__    };tries,to,load,the,latest,state,from,the,given,data,locations,it,tries,to,load,the,latest,state,determined,by,the,states,version,from,one,or,more,data,directories,and,if,none,of,the,latest,states,can,be,loaded,an,exception,is,thrown,to,prevent,accidentally,loading,a,previous,state,and,silently,omitting,the,latest,state,param,logger,a,logger,instance,param,data,locations,the,data,locations,to,try,return,the,latest,state,or,code,null,code,if,no,state,was,found;public,t,load,latest,state,logger,logger,named,xcontent,registry,named,xcontent,registry,path,data,locations,throws,ioexception,list,path,and,state,id,files,new,array,list,long,max,state,id,1,if,data,locations,null,for,path,data,location,data,locations,final,path,state,dir,data,location,resolve,try,directory,stream,path,paths,files,new,directory,stream,state,dir,for,path,state,file,paths,final,matcher,matcher,state,file,pattern,matcher,state,file,get,file,name,to,string,if,matcher,matches,final,long,state,id,long,parse,long,matcher,group,1,max,state,id,math,max,max,state,id,state,id,path,and,state,id,pav,new,path,and,state,id,state,file,state,id,logger,trace,found,state,file,pav,files,add,pav,catch,no,such,file,exception,file,not,found,exception,ex,long,final,max,state,id,max,state,id,collection,path,and,state,id,path,and,state,ids,files,stream,filter,path,and,state,id,path,and,state,id,id,final,max,state,id,collect,collectors,to,collection,array,list,new,final,list,throwable,exceptions,new,array,list,for,path,and,state,id,path,and,state,id,path,and,state,ids,try,t,state,read,named,xcontent,registry,path,and,state,id,file,logger,trace,state,id,read,from,path,and,state,id,id,path,and,state,id,file,get,file,name,return,state,catch,exception,e,exceptions,add,new,ioexception,failed,to,read,path,and,state,id,to,string,e,logger,debug,new,parameterized,message,failed,to,read,ignoring,path,and,state,id,file,to,absolute,path,prefix,e,exceptions,helper,maybe,throw,runtime,and,suppress,exceptions,if,files,size,0,throw,new,illegal,state,exception,could,not,find,a,state,file,to,recover,from,among,files,return,null
MetaDataStateFormat -> public final void write(final T state, final Path... locations) throws IOException;1524684173;Writes the given state to the given directories. The state is written to a_state directory ({@value #STATE_DIR_NAME}) underneath each of the given file locations and is created if it_doesn't exist. The state is serialized to a temporary file in that directory and is then atomically moved to_it's target filename of the pattern <tt>{prefix}{version}.st</tt>.__@param state the state object to write_@param locations the locations where the state should be written to._@throws IOException if an IOException occurs;public final void write(final T state, final Path... locations) throws IOException {_        if (locations == null) {_            throw new IllegalArgumentException("Locations must not be null")__        }_        if (locations.length <= 0) {_            throw new IllegalArgumentException("One or more locations required")__        }_        final long maxStateId = findMaxStateId(prefix, locations)+1__        assert maxStateId >= 0 : "maxStateId must be positive but was: [" + maxStateId + "]"__        final String fileName = prefix + maxStateId + STATE_FILE_EXTENSION__        Path stateLocation = locations[0].resolve(STATE_DIR_NAME)__        Files.createDirectories(stateLocation)__        final Path tmpStatePath = stateLocation.resolve(fileName + ".tmp")__        final Path finalStatePath = stateLocation.resolve(fileName)__        try {_            final String resourceDesc = "MetaDataStateFormat.write(path=\"" + tmpStatePath + "\")"__            try (OutputStreamIndexOutput out =_                     new OutputStreamIndexOutput(resourceDesc, fileName, Files.newOutputStream(tmpStatePath), BUFFER_SIZE)) {_                CodecUtil.writeHeader(out, STATE_FILE_CODEC, STATE_FILE_VERSION)__                out.writeInt(FORMAT.index())__                try (XContentBuilder builder = newXContentBuilder(FORMAT, new IndexOutputOutputStream(out) {_                    @Override_                    public void close() throws IOException {_                        _                        _                    } })) {__                    builder.startObject()__                    {_                        toXContent(builder, state)__                    }_                    builder.endObject()__                }_                CodecUtil.writeFooter(out)__            }_            IOUtils.fsync(tmpStatePath, false)_ _            Files.move(tmpStatePath, finalStatePath, StandardCopyOption.ATOMIC_MOVE)__            IOUtils.fsync(stateLocation, true)__            for (int i = 1_ i < locations.length_ i++) {_                stateLocation = locations[i].resolve(STATE_DIR_NAME)__                Files.createDirectories(stateLocation)__                Path tmpPath = stateLocation.resolve(fileName + ".tmp")__                Path finalPath = stateLocation.resolve(fileName)__                try {_                    Files.copy(finalStatePath, tmpPath)__                    _                    Files.move(tmpPath, finalPath, StandardCopyOption.ATOMIC_MOVE)__                    IOUtils.fsync(stateLocation, true)_ _                } finally {_                    Files.deleteIfExists(tmpPath)__                }_            }_        } finally {_            Files.deleteIfExists(tmpStatePath)__        }_        cleanupOldFiles(prefix, fileName, locations)__    };writes,the,given,state,to,the,given,directories,the,state,is,written,to,a,state,directory,value,underneath,each,of,the,given,file,locations,and,is,created,if,it,doesn,t,exist,the,state,is,serialized,to,a,temporary,file,in,that,directory,and,is,then,atomically,moved,to,it,s,target,filename,of,the,pattern,tt,prefix,version,st,tt,param,state,the,state,object,to,write,param,locations,the,locations,where,the,state,should,be,written,to,throws,ioexception,if,an,ioexception,occurs;public,final,void,write,final,t,state,final,path,locations,throws,ioexception,if,locations,null,throw,new,illegal,argument,exception,locations,must,not,be,null,if,locations,length,0,throw,new,illegal,argument,exception,one,or,more,locations,required,final,long,max,state,id,find,max,state,id,prefix,locations,1,assert,max,state,id,0,max,state,id,must,be,positive,but,was,max,state,id,final,string,file,name,prefix,max,state,id,path,state,location,locations,0,resolve,files,create,directories,state,location,final,path,tmp,state,path,state,location,resolve,file,name,tmp,final,path,final,state,path,state,location,resolve,file,name,try,final,string,resource,desc,meta,data,state,format,write,path,tmp,state,path,try,output,stream,index,output,out,new,output,stream,index,output,resource,desc,file,name,files,new,output,stream,tmp,state,path,codec,util,write,header,out,out,write,int,format,index,try,xcontent,builder,builder,new,xcontent,builder,format,new,index,output,output,stream,out,override,public,void,close,throws,ioexception,builder,start,object,to,xcontent,builder,state,builder,end,object,codec,util,write,footer,out,ioutils,fsync,tmp,state,path,false,files,move,tmp,state,path,final,state,path,standard,copy,option,ioutils,fsync,state,location,true,for,int,i,1,i,locations,length,i,state,location,locations,i,resolve,files,create,directories,state,location,path,tmp,path,state,location,resolve,file,name,tmp,path,final,path,state,location,resolve,file,name,try,files,copy,final,state,path,tmp,path,files,move,tmp,path,final,path,standard,copy,option,ioutils,fsync,state,location,true,finally,files,delete,if,exists,tmp,path,finally,files,delete,if,exists,tmp,state,path,cleanup,old,files,prefix,file,name,locations
MetaDataStateFormat -> public final void write(final T state, final Path... locations) throws IOException;1525334055;Writes the given state to the given directories. The state is written to a_state directory ({@value #STATE_DIR_NAME}) underneath each of the given file locations and is created if it_doesn't exist. The state is serialized to a temporary file in that directory and is then atomically moved to_it's target filename of the pattern {@code {prefix}{version}.st}.__@param state the state object to write_@param locations the locations where the state should be written to._@throws IOException if an IOException occurs;public final void write(final T state, final Path... locations) throws IOException {_        if (locations == null) {_            throw new IllegalArgumentException("Locations must not be null")__        }_        if (locations.length <= 0) {_            throw new IllegalArgumentException("One or more locations required")__        }_        final long maxStateId = findMaxStateId(prefix, locations)+1__        assert maxStateId >= 0 : "maxStateId must be positive but was: [" + maxStateId + "]"__        final String fileName = prefix + maxStateId + STATE_FILE_EXTENSION__        Path stateLocation = locations[0].resolve(STATE_DIR_NAME)__        Files.createDirectories(stateLocation)__        final Path tmpStatePath = stateLocation.resolve(fileName + ".tmp")__        final Path finalStatePath = stateLocation.resolve(fileName)__        try {_            final String resourceDesc = "MetaDataStateFormat.write(path=\"" + tmpStatePath + "\")"__            try (OutputStreamIndexOutput out =_                     new OutputStreamIndexOutput(resourceDesc, fileName, Files.newOutputStream(tmpStatePath), BUFFER_SIZE)) {_                CodecUtil.writeHeader(out, STATE_FILE_CODEC, STATE_FILE_VERSION)__                out.writeInt(FORMAT.index())__                try (XContentBuilder builder = newXContentBuilder(FORMAT, new IndexOutputOutputStream(out) {_                    @Override_                    public void close() throws IOException {_                        _                        _                    } })) {__                    builder.startObject()__                    {_                        toXContent(builder, state)__                    }_                    builder.endObject()__                }_                CodecUtil.writeFooter(out)__            }_            IOUtils.fsync(tmpStatePath, false)_ _            Files.move(tmpStatePath, finalStatePath, StandardCopyOption.ATOMIC_MOVE)__            IOUtils.fsync(stateLocation, true)__            for (int i = 1_ i < locations.length_ i++) {_                stateLocation = locations[i].resolve(STATE_DIR_NAME)__                Files.createDirectories(stateLocation)__                Path tmpPath = stateLocation.resolve(fileName + ".tmp")__                Path finalPath = stateLocation.resolve(fileName)__                try {_                    Files.copy(finalStatePath, tmpPath)__                    _                    Files.move(tmpPath, finalPath, StandardCopyOption.ATOMIC_MOVE)__                    IOUtils.fsync(stateLocation, true)_ _                } finally {_                    Files.deleteIfExists(tmpPath)__                }_            }_        } finally {_            Files.deleteIfExists(tmpStatePath)__        }_        cleanupOldFiles(prefix, fileName, locations)__    };writes,the,given,state,to,the,given,directories,the,state,is,written,to,a,state,directory,value,underneath,each,of,the,given,file,locations,and,is,created,if,it,doesn,t,exist,the,state,is,serialized,to,a,temporary,file,in,that,directory,and,is,then,atomically,moved,to,it,s,target,filename,of,the,pattern,code,prefix,version,st,param,state,the,state,object,to,write,param,locations,the,locations,where,the,state,should,be,written,to,throws,ioexception,if,an,ioexception,occurs;public,final,void,write,final,t,state,final,path,locations,throws,ioexception,if,locations,null,throw,new,illegal,argument,exception,locations,must,not,be,null,if,locations,length,0,throw,new,illegal,argument,exception,one,or,more,locations,required,final,long,max,state,id,find,max,state,id,prefix,locations,1,assert,max,state,id,0,max,state,id,must,be,positive,but,was,max,state,id,final,string,file,name,prefix,max,state,id,path,state,location,locations,0,resolve,files,create,directories,state,location,final,path,tmp,state,path,state,location,resolve,file,name,tmp,final,path,final,state,path,state,location,resolve,file,name,try,final,string,resource,desc,meta,data,state,format,write,path,tmp,state,path,try,output,stream,index,output,out,new,output,stream,index,output,resource,desc,file,name,files,new,output,stream,tmp,state,path,codec,util,write,header,out,out,write,int,format,index,try,xcontent,builder,builder,new,xcontent,builder,format,new,index,output,output,stream,out,override,public,void,close,throws,ioexception,builder,start,object,to,xcontent,builder,state,builder,end,object,codec,util,write,footer,out,ioutils,fsync,tmp,state,path,false,files,move,tmp,state,path,final,state,path,standard,copy,option,ioutils,fsync,state,location,true,for,int,i,1,i,locations,length,i,state,location,locations,i,resolve,files,create,directories,state,location,path,tmp,path,state,location,resolve,file,name,tmp,path,final,path,state,location,resolve,file,name,try,files,copy,final,state,path,tmp,path,files,move,tmp,path,final,path,standard,copy,option,ioutils,fsync,state,location,true,finally,files,delete,if,exists,tmp,path,finally,files,delete,if,exists,tmp,state,path,cleanup,old,files,prefix,file,name,locations
MetaDataStateFormat -> public final void write(final T state, final Path... locations) throws IOException;1527773340;Writes the given state to the given directories. The state is written to a_state directory ({@value #STATE_DIR_NAME}) underneath each of the given file locations and is created if it_doesn't exist. The state is serialized to a temporary file in that directory and is then atomically moved to_it's target filename of the pattern {@code {prefix}{version}.st}.__@param state the state object to write_@param locations the locations where the state should be written to._@throws IOException if an IOException occurs;public final void write(final T state, final Path... locations) throws IOException {_        if (locations == null) {_            throw new IllegalArgumentException("Locations must not be null")__        }_        if (locations.length <= 0) {_            throw new IllegalArgumentException("One or more locations required")__        }_        final long maxStateId = findMaxStateId(prefix, locations)+1__        assert maxStateId >= 0 : "maxStateId must be positive but was: [" + maxStateId + "]"__        final String fileName = prefix + maxStateId + STATE_FILE_EXTENSION__        Path stateLocation = locations[0].resolve(STATE_DIR_NAME)__        Files.createDirectories(stateLocation)__        final Path tmpStatePath = stateLocation.resolve(fileName + ".tmp")__        final Path finalStatePath = stateLocation.resolve(fileName)__        try {_            final String resourceDesc = "MetaDataStateFormat.write(path=\"" + tmpStatePath + "\")"__            try (OutputStreamIndexOutput out =_                     new OutputStreamIndexOutput(resourceDesc, fileName, Files.newOutputStream(tmpStatePath), BUFFER_SIZE)) {_                CodecUtil.writeHeader(out, STATE_FILE_CODEC, STATE_FILE_VERSION)__                out.writeInt(FORMAT.index())__                try (XContentBuilder builder = newXContentBuilder(FORMAT, new IndexOutputOutputStream(out) {_                    @Override_                    public void close() throws IOException {_                        _                        _                    } })) {__                    builder.startObject()__                    {_                        toXContent(builder, state)__                    }_                    builder.endObject()__                }_                CodecUtil.writeFooter(out)__            }_            IOUtils.fsync(tmpStatePath, false)_ _            Files.move(tmpStatePath, finalStatePath, StandardCopyOption.ATOMIC_MOVE)__            IOUtils.fsync(stateLocation, true)__            for (int i = 1_ i < locations.length_ i++) {_                stateLocation = locations[i].resolve(STATE_DIR_NAME)__                Files.createDirectories(stateLocation)__                Path tmpPath = stateLocation.resolve(fileName + ".tmp")__                Path finalPath = stateLocation.resolve(fileName)__                try {_                    Files.copy(finalStatePath, tmpPath)__                    IOUtils.fsync(tmpPath, false)_ _                    _                    Files.move(tmpPath, finalPath, StandardCopyOption.ATOMIC_MOVE)__                    IOUtils.fsync(stateLocation, true)__                } finally {_                    Files.deleteIfExists(tmpPath)__                }_            }_        } finally {_            Files.deleteIfExists(tmpStatePath)__        }_        cleanupOldFiles(prefix, fileName, locations)__    };writes,the,given,state,to,the,given,directories,the,state,is,written,to,a,state,directory,value,underneath,each,of,the,given,file,locations,and,is,created,if,it,doesn,t,exist,the,state,is,serialized,to,a,temporary,file,in,that,directory,and,is,then,atomically,moved,to,it,s,target,filename,of,the,pattern,code,prefix,version,st,param,state,the,state,object,to,write,param,locations,the,locations,where,the,state,should,be,written,to,throws,ioexception,if,an,ioexception,occurs;public,final,void,write,final,t,state,final,path,locations,throws,ioexception,if,locations,null,throw,new,illegal,argument,exception,locations,must,not,be,null,if,locations,length,0,throw,new,illegal,argument,exception,one,or,more,locations,required,final,long,max,state,id,find,max,state,id,prefix,locations,1,assert,max,state,id,0,max,state,id,must,be,positive,but,was,max,state,id,final,string,file,name,prefix,max,state,id,path,state,location,locations,0,resolve,files,create,directories,state,location,final,path,tmp,state,path,state,location,resolve,file,name,tmp,final,path,final,state,path,state,location,resolve,file,name,try,final,string,resource,desc,meta,data,state,format,write,path,tmp,state,path,try,output,stream,index,output,out,new,output,stream,index,output,resource,desc,file,name,files,new,output,stream,tmp,state,path,codec,util,write,header,out,out,write,int,format,index,try,xcontent,builder,builder,new,xcontent,builder,format,new,index,output,output,stream,out,override,public,void,close,throws,ioexception,builder,start,object,to,xcontent,builder,state,builder,end,object,codec,util,write,footer,out,ioutils,fsync,tmp,state,path,false,files,move,tmp,state,path,final,state,path,standard,copy,option,ioutils,fsync,state,location,true,for,int,i,1,i,locations,length,i,state,location,locations,i,resolve,files,create,directories,state,location,path,tmp,path,state,location,resolve,file,name,tmp,path,final,path,state,location,resolve,file,name,try,files,copy,final,state,path,tmp,path,ioutils,fsync,tmp,path,false,files,move,tmp,path,final,path,standard,copy,option,ioutils,fsync,state,location,true,finally,files,delete,if,exists,tmp,path,finally,files,delete,if,exists,tmp,state,path,cleanup,old,files,prefix,file,name,locations
MetaDataStateFormat -> public final void write(final T state, final Path... locations) throws IOException;1529015561;Writes the given state to the given directories. The state is written to a_state directory ({@value #STATE_DIR_NAME}) underneath each of the given file locations and is created if it_doesn't exist. The state is serialized to a temporary file in that directory and is then atomically moved to_it's target filename of the pattern {@code {prefix}{version}.st}.__@param state the state object to write_@param locations the locations where the state should be written to._@throws IOException if an IOException occurs;public final void write(final T state, final Path... locations) throws IOException {_        if (locations == null) {_            throw new IllegalArgumentException("Locations must not be null")__        }_        if (locations.length <= 0) {_            throw new IllegalArgumentException("One or more locations required")__        }_        final long maxStateId = findMaxStateId(prefix, locations)+1__        assert maxStateId >= 0 : "maxStateId must be positive but was: [" + maxStateId + "]"__        final String fileName = prefix + maxStateId + STATE_FILE_EXTENSION__        Path stateLocation = locations[0].resolve(STATE_DIR_NAME)__        Files.createDirectories(stateLocation)__        final Path tmpStatePath = stateLocation.resolve(fileName + ".tmp")__        final Path finalStatePath = stateLocation.resolve(fileName)__        try {_            final String resourceDesc = "MetaDataStateFormat.write(path=\"" + tmpStatePath + "\")"__            try (OutputStreamIndexOutput out =_                     new OutputStreamIndexOutput(resourceDesc, fileName, Files.newOutputStream(tmpStatePath), BUFFER_SIZE)) {_                CodecUtil.writeHeader(out, STATE_FILE_CODEC, STATE_FILE_VERSION)__                out.writeInt(FORMAT.index())__                try (XContentBuilder builder = newXContentBuilder(FORMAT, new IndexOutputOutputStream(out) {_                    @Override_                    public void close() throws IOException {_                        _                        _                    } })) {__                    builder.startObject()__                    {_                        toXContent(builder, state)__                    }_                    builder.endObject()__                }_                CodecUtil.writeFooter(out)__            }_            IOUtils.fsync(tmpStatePath, false)_ _            Files.move(tmpStatePath, finalStatePath, StandardCopyOption.ATOMIC_MOVE)__            IOUtils.fsync(stateLocation, true)__            logger.trace("written state to {}", finalStatePath)__            for (int i = 1_ i < locations.length_ i++) {_                stateLocation = locations[i].resolve(STATE_DIR_NAME)__                Files.createDirectories(stateLocation)__                Path tmpPath = stateLocation.resolve(fileName + ".tmp")__                Path finalPath = stateLocation.resolve(fileName)__                try {_                    Files.copy(finalStatePath, tmpPath)__                    IOUtils.fsync(tmpPath, false)_ _                    _                    Files.move(tmpPath, finalPath, StandardCopyOption.ATOMIC_MOVE)__                    IOUtils.fsync(stateLocation, true)__                    logger.trace("copied state to {}", finalPath)__                } finally {_                    Files.deleteIfExists(tmpPath)__                    logger.trace("cleaned up {}", tmpPath)__                }_            }_        } finally {_            Files.deleteIfExists(tmpStatePath)__            logger.trace("cleaned up {}", tmpStatePath)__        }_        cleanupOldFiles(prefix, fileName, locations)__    };writes,the,given,state,to,the,given,directories,the,state,is,written,to,a,state,directory,value,underneath,each,of,the,given,file,locations,and,is,created,if,it,doesn,t,exist,the,state,is,serialized,to,a,temporary,file,in,that,directory,and,is,then,atomically,moved,to,it,s,target,filename,of,the,pattern,code,prefix,version,st,param,state,the,state,object,to,write,param,locations,the,locations,where,the,state,should,be,written,to,throws,ioexception,if,an,ioexception,occurs;public,final,void,write,final,t,state,final,path,locations,throws,ioexception,if,locations,null,throw,new,illegal,argument,exception,locations,must,not,be,null,if,locations,length,0,throw,new,illegal,argument,exception,one,or,more,locations,required,final,long,max,state,id,find,max,state,id,prefix,locations,1,assert,max,state,id,0,max,state,id,must,be,positive,but,was,max,state,id,final,string,file,name,prefix,max,state,id,path,state,location,locations,0,resolve,files,create,directories,state,location,final,path,tmp,state,path,state,location,resolve,file,name,tmp,final,path,final,state,path,state,location,resolve,file,name,try,final,string,resource,desc,meta,data,state,format,write,path,tmp,state,path,try,output,stream,index,output,out,new,output,stream,index,output,resource,desc,file,name,files,new,output,stream,tmp,state,path,codec,util,write,header,out,out,write,int,format,index,try,xcontent,builder,builder,new,xcontent,builder,format,new,index,output,output,stream,out,override,public,void,close,throws,ioexception,builder,start,object,to,xcontent,builder,state,builder,end,object,codec,util,write,footer,out,ioutils,fsync,tmp,state,path,false,files,move,tmp,state,path,final,state,path,standard,copy,option,ioutils,fsync,state,location,true,logger,trace,written,state,to,final,state,path,for,int,i,1,i,locations,length,i,state,location,locations,i,resolve,files,create,directories,state,location,path,tmp,path,state,location,resolve,file,name,tmp,path,final,path,state,location,resolve,file,name,try,files,copy,final,state,path,tmp,path,ioutils,fsync,tmp,path,false,files,move,tmp,path,final,path,standard,copy,option,ioutils,fsync,state,location,true,logger,trace,copied,state,to,final,path,finally,files,delete,if,exists,tmp,path,logger,trace,cleaned,up,tmp,path,finally,files,delete,if,exists,tmp,state,path,logger,trace,cleaned,up,tmp,state,path,cleanup,old,files,prefix,file,name,locations
MetaDataStateFormat -> public final void write(final T state, final Path... locations) throws IOException;1531179852;Writes the given state to the given directories. The state is written to a_state directory ({@value #STATE_DIR_NAME}) underneath each of the given file locations and is created if it_doesn't exist. The state is serialized to a temporary file in that directory and is then atomically moved to_it's target filename of the pattern {@code {prefix}{version}.st}.__@param state the state object to write_@param locations the locations where the state should be written to._@throws IOException if an IOException occurs;public final void write(final T state, final Path... locations) throws IOException {_        if (locations == null) {_            throw new IllegalArgumentException("Locations must not be null")__        }_        if (locations.length <= 0) {_            throw new IllegalArgumentException("One or more locations required")__        }_        final long maxStateId = findMaxStateId(prefix, locations)+1__        assert maxStateId >= 0 : "maxStateId must be positive but was: [" + maxStateId + "]"__        final String fileName = prefix + maxStateId + STATE_FILE_EXTENSION__        Path stateLocation = locations[0].resolve(STATE_DIR_NAME)__        Files.createDirectories(stateLocation)__        final Path tmpStatePath = stateLocation.resolve(fileName + ".tmp")__        final Path finalStatePath = stateLocation.resolve(fileName)__        try {_            final String resourceDesc = "MetaDataStateFormat.write(path=\"" + tmpStatePath + "\")"__            try (OutputStreamIndexOutput out =_                     new OutputStreamIndexOutput(resourceDesc, fileName, Files.newOutputStream(tmpStatePath), BUFFER_SIZE)) {_                CodecUtil.writeHeader(out, STATE_FILE_CODEC, STATE_FILE_VERSION)__                out.writeInt(FORMAT.index())__                try (XContentBuilder builder = newXContentBuilder(FORMAT, new IndexOutputOutputStream(out) {_                    @Override_                    public void close() throws IOException {_                        _                        _                    } })) {__                    builder.startObject()__                    {_                        toXContent(builder, state)__                    }_                    builder.endObject()__                }_                CodecUtil.writeFooter(out)__            }_            IOUtils.fsync(tmpStatePath, false)_ _            Files.move(tmpStatePath, finalStatePath, StandardCopyOption.ATOMIC_MOVE)__            IOUtils.fsync(stateLocation, true)__            logger.trace("written state to {}", finalStatePath)__            for (int i = 1_ i < locations.length_ i++) {_                stateLocation = locations[i].resolve(STATE_DIR_NAME)__                Files.createDirectories(stateLocation)__                Path tmpPath = stateLocation.resolve(fileName + ".tmp")__                Path finalPath = stateLocation.resolve(fileName)__                try {_                    Files.copy(finalStatePath, tmpPath)__                    IOUtils.fsync(tmpPath, false)_ _                    _                    Files.move(tmpPath, finalPath, StandardCopyOption.ATOMIC_MOVE)__                    IOUtils.fsync(stateLocation, true)__                    logger.trace("copied state to {}", finalPath)__                } finally {_                    Files.deleteIfExists(tmpPath)__                    logger.trace("cleaned up {}", tmpPath)__                }_            }_        } finally {_            Files.deleteIfExists(tmpStatePath)__            logger.trace("cleaned up {}", tmpStatePath)__        }_        cleanupOldFiles(prefix, fileName, locations)__    };writes,the,given,state,to,the,given,directories,the,state,is,written,to,a,state,directory,value,underneath,each,of,the,given,file,locations,and,is,created,if,it,doesn,t,exist,the,state,is,serialized,to,a,temporary,file,in,that,directory,and,is,then,atomically,moved,to,it,s,target,filename,of,the,pattern,code,prefix,version,st,param,state,the,state,object,to,write,param,locations,the,locations,where,the,state,should,be,written,to,throws,ioexception,if,an,ioexception,occurs;public,final,void,write,final,t,state,final,path,locations,throws,ioexception,if,locations,null,throw,new,illegal,argument,exception,locations,must,not,be,null,if,locations,length,0,throw,new,illegal,argument,exception,one,or,more,locations,required,final,long,max,state,id,find,max,state,id,prefix,locations,1,assert,max,state,id,0,max,state,id,must,be,positive,but,was,max,state,id,final,string,file,name,prefix,max,state,id,path,state,location,locations,0,resolve,files,create,directories,state,location,final,path,tmp,state,path,state,location,resolve,file,name,tmp,final,path,final,state,path,state,location,resolve,file,name,try,final,string,resource,desc,meta,data,state,format,write,path,tmp,state,path,try,output,stream,index,output,out,new,output,stream,index,output,resource,desc,file,name,files,new,output,stream,tmp,state,path,codec,util,write,header,out,out,write,int,format,index,try,xcontent,builder,builder,new,xcontent,builder,format,new,index,output,output,stream,out,override,public,void,close,throws,ioexception,builder,start,object,to,xcontent,builder,state,builder,end,object,codec,util,write,footer,out,ioutils,fsync,tmp,state,path,false,files,move,tmp,state,path,final,state,path,standard,copy,option,ioutils,fsync,state,location,true,logger,trace,written,state,to,final,state,path,for,int,i,1,i,locations,length,i,state,location,locations,i,resolve,files,create,directories,state,location,path,tmp,path,state,location,resolve,file,name,tmp,path,final,path,state,location,resolve,file,name,try,files,copy,final,state,path,tmp,path,ioutils,fsync,tmp,path,false,files,move,tmp,path,final,path,standard,copy,option,ioutils,fsync,state,location,true,logger,trace,copied,state,to,final,path,finally,files,delete,if,exists,tmp,path,logger,trace,cleaned,up,tmp,path,finally,files,delete,if,exists,tmp,state,path,logger,trace,cleaned,up,tmp,state,path,cleanup,old,files,prefix,file,name,locations
MetaDataStateFormat -> public final void write(final T state, final Path... locations) throws IOException;1540486836;Writes the given state to the given directories. The state is written to a_state directory ({@value #STATE_DIR_NAME}) underneath each of the given file locations and is created if it_doesn't exist. The state is serialized to a temporary file in that directory and is then atomically moved to_it's target filename of the pattern {@code {prefix}{version}.st}.__@param state the state object to write_@param locations the locations where the state should be written to._@throws IOException if an IOException occurs;public final void write(final T state, final Path... locations) throws IOException {_        if (locations == null) {_            throw new IllegalArgumentException("Locations must not be null")__        }_        if (locations.length <= 0) {_            throw new IllegalArgumentException("One or more locations required")__        }_        final long maxStateId = findMaxStateId(prefix, locations)+1__        assert maxStateId >= 0 : "maxStateId must be positive but was: [" + maxStateId + "]"__        final String fileName = prefix + maxStateId + STATE_FILE_EXTENSION__        Path stateLocation = locations[0].resolve(STATE_DIR_NAME)__        Files.createDirectories(stateLocation)__        final Path tmpStatePath = stateLocation.resolve(fileName + ".tmp")__        final Path finalStatePath = stateLocation.resolve(fileName)__        try {_            final String resourceDesc = "MetaDataStateFormat.write(path=\"" + tmpStatePath + "\")"__            try (OutputStreamIndexOutput out =_                     new OutputStreamIndexOutput(resourceDesc, fileName, Files.newOutputStream(tmpStatePath), BUFFER_SIZE)) {_                CodecUtil.writeHeader(out, STATE_FILE_CODEC, STATE_FILE_VERSION)__                out.writeInt(FORMAT.index())__                try (XContentBuilder builder = newXContentBuilder(FORMAT, new IndexOutputOutputStream(out) {_                    @Override_                    public void close() throws IOException {_                        _                        _                    } })) {__                    builder.startObject()__                    {_                        toXContent(builder, state)__                    }_                    builder.endObject()__                }_                CodecUtil.writeFooter(out)__            }_            IOUtils.fsync(tmpStatePath, false)_ _            Files.move(tmpStatePath, finalStatePath, StandardCopyOption.ATOMIC_MOVE)__            IOUtils.fsync(stateLocation, true)__            logger.trace("written state to {}", finalStatePath)__            for (int i = 1_ i < locations.length_ i++) {_                stateLocation = locations[i].resolve(STATE_DIR_NAME)__                Files.createDirectories(stateLocation)__                Path tmpPath = stateLocation.resolve(fileName + ".tmp")__                Path finalPath = stateLocation.resolve(fileName)__                try {_                    Files.copy(finalStatePath, tmpPath)__                    IOUtils.fsync(tmpPath, false)_ _                    _                    Files.move(tmpPath, finalPath, StandardCopyOption.ATOMIC_MOVE)__                    IOUtils.fsync(stateLocation, true)__                    logger.trace("copied state to {}", finalPath)__                } finally {_                    Files.deleteIfExists(tmpPath)__                    logger.trace("cleaned up {}", tmpPath)__                }_            }_        } finally {_            Files.deleteIfExists(tmpStatePath)__            logger.trace("cleaned up {}", tmpStatePath)__        }_        cleanupOldFiles(prefix, fileName, locations)__    };writes,the,given,state,to,the,given,directories,the,state,is,written,to,a,state,directory,value,underneath,each,of,the,given,file,locations,and,is,created,if,it,doesn,t,exist,the,state,is,serialized,to,a,temporary,file,in,that,directory,and,is,then,atomically,moved,to,it,s,target,filename,of,the,pattern,code,prefix,version,st,param,state,the,state,object,to,write,param,locations,the,locations,where,the,state,should,be,written,to,throws,ioexception,if,an,ioexception,occurs;public,final,void,write,final,t,state,final,path,locations,throws,ioexception,if,locations,null,throw,new,illegal,argument,exception,locations,must,not,be,null,if,locations,length,0,throw,new,illegal,argument,exception,one,or,more,locations,required,final,long,max,state,id,find,max,state,id,prefix,locations,1,assert,max,state,id,0,max,state,id,must,be,positive,but,was,max,state,id,final,string,file,name,prefix,max,state,id,path,state,location,locations,0,resolve,files,create,directories,state,location,final,path,tmp,state,path,state,location,resolve,file,name,tmp,final,path,final,state,path,state,location,resolve,file,name,try,final,string,resource,desc,meta,data,state,format,write,path,tmp,state,path,try,output,stream,index,output,out,new,output,stream,index,output,resource,desc,file,name,files,new,output,stream,tmp,state,path,codec,util,write,header,out,out,write,int,format,index,try,xcontent,builder,builder,new,xcontent,builder,format,new,index,output,output,stream,out,override,public,void,close,throws,ioexception,builder,start,object,to,xcontent,builder,state,builder,end,object,codec,util,write,footer,out,ioutils,fsync,tmp,state,path,false,files,move,tmp,state,path,final,state,path,standard,copy,option,ioutils,fsync,state,location,true,logger,trace,written,state,to,final,state,path,for,int,i,1,i,locations,length,i,state,location,locations,i,resolve,files,create,directories,state,location,path,tmp,path,state,location,resolve,file,name,tmp,path,final,path,state,location,resolve,file,name,try,files,copy,final,state,path,tmp,path,ioutils,fsync,tmp,path,false,files,move,tmp,path,final,path,standard,copy,option,ioutils,fsync,state,location,true,logger,trace,copied,state,to,final,path,finally,files,delete,if,exists,tmp,path,logger,trace,cleaned,up,tmp,path,finally,files,delete,if,exists,tmp,state,path,logger,trace,cleaned,up,tmp,state,path,cleanup,old,files,prefix,file,name,locations
