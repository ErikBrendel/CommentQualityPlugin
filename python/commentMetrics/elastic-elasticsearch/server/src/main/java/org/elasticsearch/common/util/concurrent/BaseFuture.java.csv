commented;modifiers;parameterAmount;loc;comment;code
true;public;2;6;/**  * {@inheritDoc}  * <p>  * The default {@link BaseFuture} implementation throws {@code  * InterruptedException} if the current thread is interrupted before or during  * the call, even if the value is already available.  *  * @throws InterruptedException  if the current thread was interrupted before  *                               or during the call (optional but recommended).  * @throws CancellationException {@inheritDoc}  */ ;/*     * Improve the documentation of when InterruptedException is thrown. Our     * behavior matches the JDK's, but the JDK's documentation is misleading.     */ /**  * {@inheritDoc}  * <p>  * The default {@link BaseFuture} implementation throws {@code  * InterruptedException} if the current thread is interrupted before or during  * the call, even if the value is already available.  *  * @throws InterruptedException  if the current thread was interrupted before  *                               or during the call (optional but recommended).  * @throws CancellationException {@inheritDoc}  */ @Override public V get(long timeout, TimeUnit unit) throws InterruptedException, TimeoutException, ExecutionException {     assert timeout <= 0 || blockingAllowed().     return sync.get(unit.toNanos(timeout)). }
true;public;0;5;/**  * {@inheritDoc}  * <p>  * The default {@link BaseFuture} implementation throws {@code  * InterruptedException} if the current thread is interrupted before or during  * the call, even if the value is already available.  *  * @throws InterruptedException  if the current thread was interrupted before  *                               or during the call (optional but recommended).  * @throws CancellationException {@inheritDoc}  */ ;/*     * Improve the documentation of when InterruptedException is thrown. Our     * behavior matches the JDK's, but the JDK's documentation is misleading.     */ /**  * {@inheritDoc}  * <p>  * The default {@link BaseFuture} implementation throws {@code  * InterruptedException} if the current thread is interrupted before or during  * the call, even if the value is already available.  *  * @throws InterruptedException  if the current thread was interrupted before  *                               or during the call (optional but recommended).  * @throws CancellationException {@inheritDoc}  */ @Override public V get() throws InterruptedException, ExecutionException {     assert blockingAllowed().     return sync.get(). }
true;protected;0;6;// protected so that it can be overridden in specific instances ;// protected so that it can be overridden in specific instances protected boolean blockingAllowed() {     return Transports.assertNotTransportThread(BLOCKING_OP_REASON) && ThreadPool.assertNotScheduleThread(BLOCKING_OP_REASON) && ClusterApplierService.assertNotClusterStateUpdateThread(BLOCKING_OP_REASON) && MasterService.assertNotMasterUpdateThread(BLOCKING_OP_REASON). }
false;public;0;4;;@Override public boolean isDone() {     return sync.isDone(). }
false;public;0;4;;@Override public boolean isCancelled() {     return sync.isCancelled(). }
false;public;1;11;;@Override public boolean cancel(boolean mayInterruptIfRunning) {     if (!sync.cancel()) {         return false.     }     done().     if (mayInterruptIfRunning) {         interruptTask().     }     return true. }
true;protected;0;2;/**  * Subclasses can override this method to implement interruption of the  * future's computation. The method is invoked automatically by a successful  * call to {@link #cancel(boolean) cancel(true)}.  * <p>  * The default implementation does nothing.  *  * @since 10.0  */ ;/**  * Subclasses can override this method to implement interruption of the  * future's computation. The method is invoked automatically by a successful  * call to {@link #cancel(boolean) cancel(true)}.  * <p>  * The default implementation does nothing.  *  * @since 10.0  */ protected void interruptTask() { }
true;protected;1;7;/**  * Subclasses should invoke this method to set the result of the computation  * to {@code value}.  This will set the state of the future to  * {@link BaseFuture.Sync#COMPLETED} and call {@link #done()} if the  * state was successfully changed.  *  * @param value the value that was the result of the task.  * @return true if the state was successfully changed.  */ ;/**  * Subclasses should invoke this method to set the result of the computation  * to {@code value}.  This will set the state of the future to  * {@link BaseFuture.Sync#COMPLETED} and call {@link #done()} if the  * state was successfully changed.  *  * @param value the value that was the result of the task.  * @return true if the state was successfully changed.  */ protected boolean set(@Nullable V value) {     boolean result = sync.set(value).     if (result) {         done().     }     return result. }
true;protected;1;16;/**  * Subclasses should invoke this method to set the result of the computation  * to an error, {@code throwable}.  This will set the state of the future to  * {@link BaseFuture.Sync#COMPLETED} and call {@link #done()} if the  * state was successfully changed.  *  * @param throwable the exception that the task failed with.  * @return true if the state was successfully changed.  * @throws Error if the throwable was an {@link Error}.  */ ;/**  * Subclasses should invoke this method to set the result of the computation  * to an error, {@code throwable}.  This will set the state of the future to  * {@link BaseFuture.Sync#COMPLETED} and call {@link #done()} if the  * state was successfully changed.  *  * @param throwable the exception that the task failed with.  * @return true if the state was successfully changed.  * @throws Error if the throwable was an {@link Error}.  */ protected boolean setException(Throwable throwable) {     boolean result = sync.setException(Objects.requireNonNull(throwable)).     if (result) {         done().     }     // }     return result. }
false;protected;0;2;;protected void done() { }
true;protected;1;7;/*         * Acquisition succeeds if the future is done, otherwise it fails.         */ ;/*         * Acquisition succeeds if the future is done, otherwise it fails.         */ @Override protected int tryAcquireShared(int ignored) {     if (isDone()) {         return 1.     }     return -1. }
true;protected;1;5;/*         * We always allow a release to go through, this means the state has been         * successfully changed and the result is available.         */ ;/*         * We always allow a release to go through, this means the state has been         * successfully changed and the result is available.         */ @Override protected boolean tryReleaseShared(int finalState) {     setState(finalState).     return true. }
true;;1;10;/**  * Blocks until the task is complete or the timeout expires.  Throws a  * {@link TimeoutException} if the timer expires, otherwise behaves like  * {@link #get()}.  */ ;/**  * Blocks until the task is complete or the timeout expires.  Throws a  * {@link TimeoutException} if the timer expires, otherwise behaves like  * {@link #get()}.  */ V get(long nanos) throws TimeoutException, CancellationException, ExecutionException, InterruptedException {     // Attempt to acquire the shared lock with a timeout.     if (!tryAcquireSharedNanos(-1, nanos)) {         throw new TimeoutException("Timeout waiting for task.").     }     return getValue(). }
true;;0;7;/**  * Blocks until {@link #complete(Object, Throwable, int)} has been  * successfully called.  Throws a {@link CancellationException} if the task  * was cancelled, or a {@link ExecutionException} if the task completed with  * an error.  */ ;/**  * Blocks until {@link #complete(Object, Throwable, int)} has been  * successfully called.  Throws a {@link CancellationException} if the task  * was cancelled, or a {@link ExecutionException} if the task completed with  * an error.  */ V get() throws CancellationException, ExecutionException, InterruptedException {     // Acquire the shared lock allowing interruption.     acquireSharedInterruptibly(-1).     return getValue(). }
true;private;0;18;/**  * Implementation of the actual value retrieval.  Will return the value  * on success, an exception on failure, a cancellation on cancellation, or  * an illegal state if the synchronizer is in an invalid state.  */ ;/**  * Implementation of the actual value retrieval.  Will return the value  * on success, an exception on failure, a cancellation on cancellation, or  * an illegal state if the synchronizer is in an invalid state.  */ private V getValue() throws CancellationException, ExecutionException {     int state = getState().     switch(state) {         case COMPLETED:             if (exception != null) {                 throw new ExecutionException(exception).             } else {                 return value.             }         case CANCELLED:             throw new CancellationException("Task was cancelled.").         default:             throw new IllegalStateException("Error, synchronizer in invalid state: " + state).     } }
true;;0;3;/**  * Checks if the state is {@link #COMPLETED} or {@link #CANCELLED}.  */ ;/**  * Checks if the state is {@link #COMPLETED} or {@link #CANCELLED}.  */ boolean isDone() {     return (getState() & (COMPLETED | CANCELLED)) != 0. }
true;;0;3;/**  * Checks if the state is {@link #CANCELLED}.  */ ;/**  * Checks if the state is {@link #CANCELLED}.  */ boolean isCancelled() {     return getState() == CANCELLED. }
true;;1;3;/**  * Transition to the COMPLETED state and set the value.  */ ;/**  * Transition to the COMPLETED state and set the value.  */ boolean set(@Nullable V v) {     return complete(v, null, COMPLETED). }
true;;1;3;/**  * Transition to the COMPLETED state and set the exception.  */ ;/**  * Transition to the COMPLETED state and set the exception.  */ boolean setException(Throwable t) {     return complete(null, t, COMPLETED). }
true;;0;3;/**  * Transition to the CANCELLED state.  */ ;/**  * Transition to the CANCELLED state.  */ boolean cancel() {     return complete(null, null, CANCELLED). }
true;private;3;16;/**  * Implementation of completing a task.  Either {@code v} or {@code t} will  * be set but not both.  The {@code finalState} is the state to change to  * from {@link #RUNNING}.  If the state is not in the RUNNING state we  * return {@code false} after waiting for the state to be set to a valid  * final state ({@link #COMPLETED} or {@link #CANCELLED}).  *  * @param v          the value to set as the result of the computation.  * @param t          the exception to set as the result of the computation.  * @param finalState the state to transition to.  */ ;/**  * Implementation of completing a task.  Either {@code v} or {@code t} will  * be set but not both.  The {@code finalState} is the state to change to  * from {@link #RUNNING}.  If the state is not in the RUNNING state we  * return {@code false} after waiting for the state to be set to a valid  * final state ({@link #COMPLETED} or {@link #CANCELLED}).  *  * @param v          the value to set as the result of the computation.  * @param t          the exception to set as the result of the computation.  * @param finalState the state to transition to.  */ private boolean complete(@Nullable V v, @Nullable Throwable t, int finalState) {     boolean doCompletion = compareAndSetState(RUNNING, COMPLETING).     if (doCompletion) {         // If this thread successfully transitioned to COMPLETING, set the value         // and exception and then release to the final state.         this.value = v.         this.exception = t.         releaseShared(finalState).     } else if (getState() == COMPLETING) {         // If some other thread is currently completing the future, block until         // they are done so we can guarantee completion.         acquireShared(-1).     }     return doCompletion. }
