commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;4;;@Override protected ClusterStateUpdateResponse newResponse(boolean acknowledged) {     return new ClusterStateUpdateResponse(acknowledged). }
false;public;1;4;;@Override public ClusterState execute(final ClusterState currentState) {     return deleteIndices(currentState, Sets.newHashSet(request.indices())). }
false;public;2;20;;public void deleteIndices(final DeleteIndexClusterStateUpdateRequest request, final ActionListener<ClusterStateUpdateResponse> listener) {     if (request.indices() == null || request.indices().length == 0) {         throw new IllegalArgumentException("Index name is required").     }     clusterService.submitStateUpdateTask("delete-index " + Arrays.toString(request.indices()), new AckedClusterStateUpdateTask<ClusterStateUpdateResponse>(Priority.URGENT, request, listener) {          @Override         protected ClusterStateUpdateResponse newResponse(boolean acknowledged) {             return new ClusterStateUpdateResponse(acknowledged).         }          @Override         public ClusterState execute(final ClusterState currentState) {             return deleteIndices(currentState, Sets.newHashSet(request.indices())).         }     }). }
true;public;2;48;/**  * Delete some indices from the cluster state.  */ ;/**  * Delete some indices from the cluster state.  */ public ClusterState deleteIndices(ClusterState currentState, Set<Index> indices) {     final MetaData meta = currentState.metaData().     final Set<IndexMetaData> metaDatas = indices.stream().map(i -> meta.getIndexSafe(i)).collect(toSet()).     // Check if index deletion conflicts with any running snapshots     SnapshotsService.checkIndexDeletion(currentState, metaDatas).     RoutingTable.Builder routingTableBuilder = RoutingTable.builder(currentState.routingTable()).     MetaData.Builder metaDataBuilder = MetaData.builder(meta).     ClusterBlocks.Builder clusterBlocksBuilder = ClusterBlocks.builder().blocks(currentState.blocks()).     final IndexGraveyard.Builder graveyardBuilder = IndexGraveyard.builder(metaDataBuilder.indexGraveyard()).     final int previousGraveyardSize = graveyardBuilder.tombstones().size().     for (final Index index : indices) {         String indexName = index.getName().         logger.info("{} deleting index", index).         routingTableBuilder.remove(indexName).         clusterBlocksBuilder.removeIndexBlocks(indexName).         metaDataBuilder.remove(indexName).     }     // add tombstones to the cluster state for each deleted index     final IndexGraveyard currentGraveyard = graveyardBuilder.addTombstones(indices).build(settings).     // the new graveyard set on the metadata     metaDataBuilder.indexGraveyard(currentGraveyard).     logger.trace("{} tombstones purged from the cluster state. Previous tombstone size: {}. Current tombstone size: {}.", graveyardBuilder.getNumPurged(), previousGraveyardSize, currentGraveyard.getTombstones().size()).     MetaData newMetaData = metaDataBuilder.build().     ClusterBlocks blocks = clusterBlocksBuilder.build().     // update snapshot restore entries     ImmutableOpenMap<String, ClusterState.Custom> customs = currentState.getCustoms().     final RestoreInProgress restoreInProgress = currentState.custom(RestoreInProgress.TYPE).     if (restoreInProgress != null) {         RestoreInProgress updatedRestoreInProgress = RestoreService.updateRestoreStateWithDeletedIndices(restoreInProgress, indices).         if (updatedRestoreInProgress != restoreInProgress) {             ImmutableOpenMap.Builder<String, ClusterState.Custom> builder = ImmutableOpenMap.builder(customs).             builder.put(RestoreInProgress.TYPE, updatedRestoreInProgress).             customs = builder.build().         }     }     return allocationService.reroute(ClusterState.builder(currentState).routingTable(routingTableBuilder.build()).metaData(newMetaData).blocks(blocks).customs(customs).build(), "deleted indices [" + indices + "]"). }
