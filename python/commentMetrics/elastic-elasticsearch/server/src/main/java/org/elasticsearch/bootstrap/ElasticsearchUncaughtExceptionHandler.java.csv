commented;modifiers;parameterAmount;loc;comment;code
false;public;2;26;;@Override public void uncaughtException(Thread t, Throwable e) {     if (isFatalUncaught(e)) {         try {             onFatalUncaught(t.getName(), e).         } finally {             // will have some indication of the error bringing us down             if (e instanceof InternalError) {                 halt(128).             } else if (e instanceof OutOfMemoryError) {                 halt(127).             } else if (e instanceof StackOverflowError) {                 halt(126).             } else if (e instanceof UnknownError) {                 halt(125).             } else if (e instanceof IOError) {                 halt(124).             } else {                 halt(1).             }         }     } else {         onNonFatalUncaught(t.getName(), e).     } }
false;static;1;3;;static boolean isFatalUncaught(Throwable e) {     return e instanceof Error. }
false;;2;3;;void onFatalUncaught(final String threadName, final Throwable t) {     logger.error(() -> new ParameterizedMessage("fatal error in thread [{}], exiting", threadName), t). }
false;;2;3;;void onNonFatalUncaught(final String threadName, final Throwable t) {     logger.warn(() -> new ParameterizedMessage("uncaught exception in thread [{}]", threadName), t). }
false;;1;3;;void halt(int status) {     AccessController.doPrivileged(new PrivilegedHaltAction(status)). }
false;public;0;7;;@SuppressForbidden(reason = "halt") @Override public Void run() {     // we halt to prevent shutdown hooks from running     Runtime.getRuntime().halt(status).     return null. }
