# id;timestamp;commentText;codeText;commentWords;codeWords
MetaDataIndexUpgradeService -> private void checkMappingsCompatibility(IndexMetaData indexMetaData);1524684173;Checks the mappings for compatibility with the current version;private void checkMappingsCompatibility(IndexMetaData indexMetaData) {_        try {__            _            _            _            _            _            __            IndexSettings indexSettings = new IndexSettings(indexMetaData, this.settings)___            final Map<String, TriFunction<Settings, Version, ScriptService, Similarity>> similarityMap_                    = new AbstractMap<String, TriFunction<Settings, Version, ScriptService, Similarity>>() {_                @Override_                public boolean containsKey(Object key) {_                    return true__                }__                @Override_                public TriFunction<Settings, Version, ScriptService, Similarity> get(Object key) {_                    assert key instanceof String : "key must be a string but was: " + key.getClass()__                    return SimilarityService.BUILT_IN.get(SimilarityService.DEFAULT_SIMILARITY)__                }__                _                _                @Override_                public Set<Entry<String, TriFunction<Settings, Version, ScriptService, Similarity>>> entrySet() {_                    return Collections.emptySet()__                }_            }__            SimilarityService similarityService = new SimilarityService(indexSettings, null, similarityMap)__            final NamedAnalyzer fakeDefault = new NamedAnalyzer("default", AnalyzerScope.INDEX, new Analyzer() {_                @Override_                protected TokenStreamComponents createComponents(String fieldName) {_                    throw new UnsupportedOperationException("shouldn't be here")__                }_            })___            final Map<String, NamedAnalyzer> analyzerMap = new AbstractMap<String, NamedAnalyzer>() {_                @Override_                public NamedAnalyzer get(Object key) {_                    assert key instanceof String : "key must be a string but was: " + key.getClass()__                    return new NamedAnalyzer((String)key, AnalyzerScope.INDEX, fakeDefault.analyzer())__                }__                _                _                @Override_                public Set<Entry<String, NamedAnalyzer>> entrySet() {_                    return Collections.emptySet()__                }_            }__            try (IndexAnalyzers fakeIndexAnalzyers = new IndexAnalyzers(indexSettings, fakeDefault, fakeDefault, fakeDefault, analyzerMap, analyzerMap)) {_                MapperService mapperService = new MapperService(indexSettings, fakeIndexAnalzyers, xContentRegistry, similarityService,_                        mapperRegistry, () -> null)__                mapperService.merge(indexMetaData, MapperService.MergeReason.MAPPING_RECOVERY)__            }_        } catch (Exception ex) {_            _            throw new IllegalStateException("unable to upgrade the mappings for the index [" + indexMetaData.getIndex() + "]", ex)__        }_    };checks,the,mappings,for,compatibility,with,the,current,version;private,void,check,mappings,compatibility,index,meta,data,index,meta,data,try,index,settings,index,settings,new,index,settings,index,meta,data,this,settings,final,map,string,tri,function,settings,version,script,service,similarity,similarity,map,new,abstract,map,string,tri,function,settings,version,script,service,similarity,override,public,boolean,contains,key,object,key,return,true,override,public,tri,function,settings,version,script,service,similarity,get,object,key,assert,key,instanceof,string,key,must,be,a,string,but,was,key,get,class,return,similarity,service,get,similarity,service,override,public,set,entry,string,tri,function,settings,version,script,service,similarity,entry,set,return,collections,empty,set,similarity,service,similarity,service,new,similarity,service,index,settings,null,similarity,map,final,named,analyzer,fake,default,new,named,analyzer,default,analyzer,scope,index,new,analyzer,override,protected,token,stream,components,create,components,string,field,name,throw,new,unsupported,operation,exception,shouldn,t,be,here,final,map,string,named,analyzer,analyzer,map,new,abstract,map,string,named,analyzer,override,public,named,analyzer,get,object,key,assert,key,instanceof,string,key,must,be,a,string,but,was,key,get,class,return,new,named,analyzer,string,key,analyzer,scope,index,fake,default,analyzer,override,public,set,entry,string,named,analyzer,entry,set,return,collections,empty,set,try,index,analyzers,fake,index,analzyers,new,index,analyzers,index,settings,fake,default,fake,default,fake,default,analyzer,map,analyzer,map,mapper,service,mapper,service,new,mapper,service,index,settings,fake,index,analzyers,x,content,registry,similarity,service,mapper,registry,null,mapper,service,merge,index,meta,data,mapper,service,merge,reason,catch,exception,ex,throw,new,illegal,state,exception,unable,to,upgrade,the,mappings,for,the,index,index,meta,data,get,index,ex
MetaDataIndexUpgradeService -> private void checkMappingsCompatibility(IndexMetaData indexMetaData);1527840262;Checks the mappings for compatibility with the current version;private void checkMappingsCompatibility(IndexMetaData indexMetaData) {_        try {__            _            _            _            _            _            __            IndexSettings indexSettings = new IndexSettings(indexMetaData, this.settings)___            final Map<String, TriFunction<Settings, Version, ScriptService, Similarity>> similarityMap_                    = new AbstractMap<String, TriFunction<Settings, Version, ScriptService, Similarity>>() {_                @Override_                public boolean containsKey(Object key) {_                    return true__                }__                @Override_                public TriFunction<Settings, Version, ScriptService, Similarity> get(Object key) {_                    assert key instanceof String : "key must be a string but was: " + key.getClass()__                    return SimilarityService.BUILT_IN.get(SimilarityService.DEFAULT_SIMILARITY)__                }__                _                _                @Override_                public Set<Entry<String, TriFunction<Settings, Version, ScriptService, Similarity>>> entrySet() {_                    return Collections.emptySet()__                }_            }__            SimilarityService similarityService = new SimilarityService(indexSettings, null, similarityMap)__            final NamedAnalyzer fakeDefault = new NamedAnalyzer("default", AnalyzerScope.INDEX, new Analyzer() {_                @Override_                protected TokenStreamComponents createComponents(String fieldName) {_                    throw new UnsupportedOperationException("shouldn't be here")__                }_            })___            final Map<String, NamedAnalyzer> analyzerMap = new AbstractMap<String, NamedAnalyzer>() {_                @Override_                public NamedAnalyzer get(Object key) {_                    assert key instanceof String : "key must be a string but was: " + key.getClass()__                    return new NamedAnalyzer((String)key, AnalyzerScope.INDEX, fakeDefault.analyzer())__                }__                _                _                @Override_                public Set<Entry<String, NamedAnalyzer>> entrySet() {_                    return Collections.emptySet()__                }_            }__            try (IndexAnalyzers fakeIndexAnalzyers = new IndexAnalyzers(indexSettings, fakeDefault, fakeDefault, fakeDefault, analyzerMap, analyzerMap, analyzerMap)) {_                MapperService mapperService = new MapperService(indexSettings, fakeIndexAnalzyers, xContentRegistry, similarityService,_                        mapperRegistry, () -> null)__                mapperService.merge(indexMetaData, MapperService.MergeReason.MAPPING_RECOVERY)__            }_        } catch (Exception ex) {_            _            throw new IllegalStateException("unable to upgrade the mappings for the index [" + indexMetaData.getIndex() + "]", ex)__        }_    };checks,the,mappings,for,compatibility,with,the,current,version;private,void,check,mappings,compatibility,index,meta,data,index,meta,data,try,index,settings,index,settings,new,index,settings,index,meta,data,this,settings,final,map,string,tri,function,settings,version,script,service,similarity,similarity,map,new,abstract,map,string,tri,function,settings,version,script,service,similarity,override,public,boolean,contains,key,object,key,return,true,override,public,tri,function,settings,version,script,service,similarity,get,object,key,assert,key,instanceof,string,key,must,be,a,string,but,was,key,get,class,return,similarity,service,get,similarity,service,override,public,set,entry,string,tri,function,settings,version,script,service,similarity,entry,set,return,collections,empty,set,similarity,service,similarity,service,new,similarity,service,index,settings,null,similarity,map,final,named,analyzer,fake,default,new,named,analyzer,default,analyzer,scope,index,new,analyzer,override,protected,token,stream,components,create,components,string,field,name,throw,new,unsupported,operation,exception,shouldn,t,be,here,final,map,string,named,analyzer,analyzer,map,new,abstract,map,string,named,analyzer,override,public,named,analyzer,get,object,key,assert,key,instanceof,string,key,must,be,a,string,but,was,key,get,class,return,new,named,analyzer,string,key,analyzer,scope,index,fake,default,analyzer,override,public,set,entry,string,named,analyzer,entry,set,return,collections,empty,set,try,index,analyzers,fake,index,analzyers,new,index,analyzers,index,settings,fake,default,fake,default,fake,default,analyzer,map,analyzer,map,analyzer,map,mapper,service,mapper,service,new,mapper,service,index,settings,fake,index,analzyers,x,content,registry,similarity,service,mapper,registry,null,mapper,service,merge,index,meta,data,mapper,service,merge,reason,catch,exception,ex,throw,new,illegal,state,exception,unable,to,upgrade,the,mappings,for,the,index,index,meta,data,get,index,ex
MetaDataIndexUpgradeService -> private void checkMappingsCompatibility(IndexMetaData indexMetaData);1539615817;Checks the mappings for compatibility with the current version;private void checkMappingsCompatibility(IndexMetaData indexMetaData) {_        try {__            _            _            _            _            _            __            IndexSettings indexSettings = new IndexSettings(indexMetaData, this.settings)___            final Map<String, TriFunction<Settings, Version, ScriptService, Similarity>> similarityMap_                    = new AbstractMap<String, TriFunction<Settings, Version, ScriptService, Similarity>>() {_                @Override_                public boolean containsKey(Object key) {_                    return true__                }__                @Override_                public TriFunction<Settings, Version, ScriptService, Similarity> get(Object key) {_                    assert key instanceof String : "key must be a string but was: " + key.getClass()__                    return SimilarityService.BUILT_IN.get(SimilarityService.DEFAULT_SIMILARITY)__                }__                _                _                @Override_                public Set<Entry<String, TriFunction<Settings, Version, ScriptService, Similarity>>> entrySet() {_                    return Collections.emptySet()__                }_            }__            SimilarityService similarityService = new SimilarityService(indexSettings, null, similarityMap)__            final NamedAnalyzer fakeDefault = new NamedAnalyzer("default", AnalyzerScope.INDEX, new Analyzer() {_                @Override_                protected TokenStreamComponents createComponents(String fieldName) {_                    throw new UnsupportedOperationException("shouldn't be here")__                }_            })___            final Map<String, NamedAnalyzer> analyzerMap = new AbstractMap<String, NamedAnalyzer>() {_                @Override_                public NamedAnalyzer get(Object key) {_                    assert key instanceof String : "key must be a string but was: " + key.getClass()__                    return new NamedAnalyzer((String)key, AnalyzerScope.INDEX, fakeDefault.analyzer())__                }__                _                _                @Override_                public Set<Entry<String, NamedAnalyzer>> entrySet() {_                    return Collections.emptySet()__                }_            }__            try (IndexAnalyzers fakeIndexAnalzyers = new IndexAnalyzers(indexSettings, fakeDefault, fakeDefault, fakeDefault, analyzerMap, analyzerMap, analyzerMap)) {_                MapperService mapperService = new MapperService(indexSettings, fakeIndexAnalzyers, xContentRegistry, similarityService,_                        mapperRegistry, () -> null)__                mapperService.merge(indexMetaData, MapperService.MergeReason.MAPPING_RECOVERY)__            }_        } catch (Exception ex) {_            _            throw new IllegalStateException("unable to upgrade the mappings for the index [" + indexMetaData.getIndex() + "]", ex)__        }_    };checks,the,mappings,for,compatibility,with,the,current,version;private,void,check,mappings,compatibility,index,meta,data,index,meta,data,try,index,settings,index,settings,new,index,settings,index,meta,data,this,settings,final,map,string,tri,function,settings,version,script,service,similarity,similarity,map,new,abstract,map,string,tri,function,settings,version,script,service,similarity,override,public,boolean,contains,key,object,key,return,true,override,public,tri,function,settings,version,script,service,similarity,get,object,key,assert,key,instanceof,string,key,must,be,a,string,but,was,key,get,class,return,similarity,service,get,similarity,service,override,public,set,entry,string,tri,function,settings,version,script,service,similarity,entry,set,return,collections,empty,set,similarity,service,similarity,service,new,similarity,service,index,settings,null,similarity,map,final,named,analyzer,fake,default,new,named,analyzer,default,analyzer,scope,index,new,analyzer,override,protected,token,stream,components,create,components,string,field,name,throw,new,unsupported,operation,exception,shouldn,t,be,here,final,map,string,named,analyzer,analyzer,map,new,abstract,map,string,named,analyzer,override,public,named,analyzer,get,object,key,assert,key,instanceof,string,key,must,be,a,string,but,was,key,get,class,return,new,named,analyzer,string,key,analyzer,scope,index,fake,default,analyzer,override,public,set,entry,string,named,analyzer,entry,set,return,collections,empty,set,try,index,analyzers,fake,index,analzyers,new,index,analyzers,index,settings,fake,default,fake,default,fake,default,analyzer,map,analyzer,map,analyzer,map,mapper,service,mapper,service,new,mapper,service,index,settings,fake,index,analzyers,x,content,registry,similarity,service,mapper,registry,null,mapper,service,merge,index,meta,data,mapper,service,merge,reason,catch,exception,ex,throw,new,illegal,state,exception,unable,to,upgrade,the,mappings,for,the,index,index,meta,data,get,index,ex
MetaDataIndexUpgradeService -> private void checkMappingsCompatibility(IndexMetaData indexMetaData);1540847035;Checks the mappings for compatibility with the current version;private void checkMappingsCompatibility(IndexMetaData indexMetaData) {_        try {__            _            _            _            _            _            __            IndexSettings indexSettings = new IndexSettings(indexMetaData, this.settings)___            final Map<String, TriFunction<Settings, Version, ScriptService, Similarity>> similarityMap_                    = new AbstractMap<String, TriFunction<Settings, Version, ScriptService, Similarity>>() {_                @Override_                public boolean containsKey(Object key) {_                    return true__                }__                @Override_                public TriFunction<Settings, Version, ScriptService, Similarity> get(Object key) {_                    assert key instanceof String : "key must be a string but was: " + key.getClass()__                    return SimilarityService.BUILT_IN.get(SimilarityService.DEFAULT_SIMILARITY)__                }__                _                _                @Override_                public Set<Entry<String, TriFunction<Settings, Version, ScriptService, Similarity>>> entrySet() {_                    return Collections.emptySet()__                }_            }__            SimilarityService similarityService = new SimilarityService(indexSettings, null, similarityMap)__            final NamedAnalyzer fakeDefault = new NamedAnalyzer("default", AnalyzerScope.INDEX, new Analyzer() {_                @Override_                protected TokenStreamComponents createComponents(String fieldName) {_                    throw new UnsupportedOperationException("shouldn't be here")__                }_            })___            final Map<String, NamedAnalyzer> analyzerMap = new AbstractMap<String, NamedAnalyzer>() {_                @Override_                public NamedAnalyzer get(Object key) {_                    assert key instanceof String : "key must be a string but was: " + key.getClass()__                    return new NamedAnalyzer((String)key, AnalyzerScope.INDEX, fakeDefault.analyzer())__                }__                _                _                @Override_                public Set<Entry<String, NamedAnalyzer>> entrySet() {_                    return Collections.emptySet()__                }_            }__            try (IndexAnalyzers fakeIndexAnalzyers =_                     new IndexAnalyzers(indexSettings, fakeDefault, fakeDefault, fakeDefault, analyzerMap, analyzerMap, analyzerMap)) {_                MapperService mapperService = new MapperService(indexSettings, fakeIndexAnalzyers, xContentRegistry, similarityService,_                        mapperRegistry, () -> null)__                mapperService.merge(indexMetaData, MapperService.MergeReason.MAPPING_RECOVERY)__            }_        } catch (Exception ex) {_            _            throw new IllegalStateException("unable to upgrade the mappings for the index [" + indexMetaData.getIndex() + "]", ex)__        }_    };checks,the,mappings,for,compatibility,with,the,current,version;private,void,check,mappings,compatibility,index,meta,data,index,meta,data,try,index,settings,index,settings,new,index,settings,index,meta,data,this,settings,final,map,string,tri,function,settings,version,script,service,similarity,similarity,map,new,abstract,map,string,tri,function,settings,version,script,service,similarity,override,public,boolean,contains,key,object,key,return,true,override,public,tri,function,settings,version,script,service,similarity,get,object,key,assert,key,instanceof,string,key,must,be,a,string,but,was,key,get,class,return,similarity,service,get,similarity,service,override,public,set,entry,string,tri,function,settings,version,script,service,similarity,entry,set,return,collections,empty,set,similarity,service,similarity,service,new,similarity,service,index,settings,null,similarity,map,final,named,analyzer,fake,default,new,named,analyzer,default,analyzer,scope,index,new,analyzer,override,protected,token,stream,components,create,components,string,field,name,throw,new,unsupported,operation,exception,shouldn,t,be,here,final,map,string,named,analyzer,analyzer,map,new,abstract,map,string,named,analyzer,override,public,named,analyzer,get,object,key,assert,key,instanceof,string,key,must,be,a,string,but,was,key,get,class,return,new,named,analyzer,string,key,analyzer,scope,index,fake,default,analyzer,override,public,set,entry,string,named,analyzer,entry,set,return,collections,empty,set,try,index,analyzers,fake,index,analzyers,new,index,analyzers,index,settings,fake,default,fake,default,fake,default,analyzer,map,analyzer,map,analyzer,map,mapper,service,mapper,service,new,mapper,service,index,settings,fake,index,analzyers,x,content,registry,similarity,service,mapper,registry,null,mapper,service,merge,index,meta,data,mapper,service,merge,reason,catch,exception,ex,throw,new,illegal,state,exception,unable,to,upgrade,the,mappings,for,the,index,index,meta,data,get,index,ex
MetaDataIndexUpgradeService -> private void checkMappingsCompatibility(IndexMetaData indexMetaData);1541008027;Checks the mappings for compatibility with the current version;private void checkMappingsCompatibility(IndexMetaData indexMetaData) {_        try {__            _            _            _            _            _            __            IndexSettings indexSettings = new IndexSettings(indexMetaData, this.settings)___            final Map<String, TriFunction<Settings, Version, ScriptService, Similarity>> similarityMap_                    = new AbstractMap<String, TriFunction<Settings, Version, ScriptService, Similarity>>() {_                @Override_                public boolean containsKey(Object key) {_                    return true__                }__                @Override_                public TriFunction<Settings, Version, ScriptService, Similarity> get(Object key) {_                    assert key instanceof String : "key must be a string but was: " + key.getClass()__                    return SimilarityService.BUILT_IN.get(SimilarityService.DEFAULT_SIMILARITY)__                }__                _                _                @Override_                public Set<Entry<String, TriFunction<Settings, Version, ScriptService, Similarity>>> entrySet() {_                    return Collections.emptySet()__                }_            }__            SimilarityService similarityService = new SimilarityService(indexSettings, null, similarityMap)__            final NamedAnalyzer fakeDefault = new NamedAnalyzer("default", AnalyzerScope.INDEX, new Analyzer() {_                @Override_                protected TokenStreamComponents createComponents(String fieldName) {_                    throw new UnsupportedOperationException("shouldn't be here")__                }_            })___            final Map<String, NamedAnalyzer> analyzerMap = new AbstractMap<String, NamedAnalyzer>() {_                @Override_                public NamedAnalyzer get(Object key) {_                    assert key instanceof String : "key must be a string but was: " + key.getClass()__                    return new NamedAnalyzer((String)key, AnalyzerScope.INDEX, fakeDefault.analyzer())__                }__                _                _                @Override_                public Set<Entry<String, NamedAnalyzer>> entrySet() {_                    return Collections.emptySet()__                }_            }__            try (IndexAnalyzers fakeIndexAnalzyers =_                     new IndexAnalyzers(indexSettings, fakeDefault, fakeDefault, fakeDefault, analyzerMap, analyzerMap, analyzerMap)) {_                MapperService mapperService = new MapperService(indexSettings, fakeIndexAnalzyers, xContentRegistry, similarityService,_                        mapperRegistry, () -> null)__                mapperService.merge(indexMetaData, MapperService.MergeReason.MAPPING_RECOVERY)__            }_        } catch (Exception ex) {_            _            throw new IllegalStateException("unable to upgrade the mappings for the index [" + indexMetaData.getIndex() + "]", ex)__        }_    };checks,the,mappings,for,compatibility,with,the,current,version;private,void,check,mappings,compatibility,index,meta,data,index,meta,data,try,index,settings,index,settings,new,index,settings,index,meta,data,this,settings,final,map,string,tri,function,settings,version,script,service,similarity,similarity,map,new,abstract,map,string,tri,function,settings,version,script,service,similarity,override,public,boolean,contains,key,object,key,return,true,override,public,tri,function,settings,version,script,service,similarity,get,object,key,assert,key,instanceof,string,key,must,be,a,string,but,was,key,get,class,return,similarity,service,get,similarity,service,override,public,set,entry,string,tri,function,settings,version,script,service,similarity,entry,set,return,collections,empty,set,similarity,service,similarity,service,new,similarity,service,index,settings,null,similarity,map,final,named,analyzer,fake,default,new,named,analyzer,default,analyzer,scope,index,new,analyzer,override,protected,token,stream,components,create,components,string,field,name,throw,new,unsupported,operation,exception,shouldn,t,be,here,final,map,string,named,analyzer,analyzer,map,new,abstract,map,string,named,analyzer,override,public,named,analyzer,get,object,key,assert,key,instanceof,string,key,must,be,a,string,but,was,key,get,class,return,new,named,analyzer,string,key,analyzer,scope,index,fake,default,analyzer,override,public,set,entry,string,named,analyzer,entry,set,return,collections,empty,set,try,index,analyzers,fake,index,analzyers,new,index,analyzers,index,settings,fake,default,fake,default,fake,default,analyzer,map,analyzer,map,analyzer,map,mapper,service,mapper,service,new,mapper,service,index,settings,fake,index,analzyers,x,content,registry,similarity,service,mapper,registry,null,mapper,service,merge,index,meta,data,mapper,service,merge,reason,catch,exception,ex,throw,new,illegal,state,exception,unable,to,upgrade,the,mappings,for,the,index,index,meta,data,get,index,ex
MetaDataIndexUpgradeService -> private void checkMappingsCompatibility(IndexMetaData indexMetaData);1541092382;Checks the mappings for compatibility with the current version;private void checkMappingsCompatibility(IndexMetaData indexMetaData) {_        try {__            _            _            _            _            _            __            IndexSettings indexSettings = new IndexSettings(indexMetaData, this.settings)___            final Map<String, TriFunction<Settings, Version, ScriptService, Similarity>> similarityMap_                    = new AbstractMap<String, TriFunction<Settings, Version, ScriptService, Similarity>>() {_                @Override_                public boolean containsKey(Object key) {_                    return true__                }__                @Override_                public TriFunction<Settings, Version, ScriptService, Similarity> get(Object key) {_                    assert key instanceof String : "key must be a string but was: " + key.getClass()__                    return SimilarityService.BUILT_IN.get(SimilarityService.DEFAULT_SIMILARITY)__                }__                _                _                @Override_                public Set<Entry<String, TriFunction<Settings, Version, ScriptService, Similarity>>> entrySet() {_                    return Collections.emptySet()__                }_            }__            SimilarityService similarityService = new SimilarityService(indexSettings, null, similarityMap)__            final NamedAnalyzer fakeDefault = new NamedAnalyzer("default", AnalyzerScope.INDEX, new Analyzer() {_                @Override_                protected TokenStreamComponents createComponents(String fieldName) {_                    throw new UnsupportedOperationException("shouldn't be here")__                }_            })___            final Map<String, NamedAnalyzer> analyzerMap = new AbstractMap<String, NamedAnalyzer>() {_                @Override_                public NamedAnalyzer get(Object key) {_                    assert key instanceof String : "key must be a string but was: " + key.getClass()__                    return new NamedAnalyzer((String)key, AnalyzerScope.INDEX, fakeDefault.analyzer())__                }__                _                _                @Override_                public Set<Entry<String, NamedAnalyzer>> entrySet() {_                    return Collections.emptySet()__                }_            }__            try (IndexAnalyzers fakeIndexAnalzyers =_                     new IndexAnalyzers(indexSettings, fakeDefault, fakeDefault, fakeDefault, analyzerMap, analyzerMap, analyzerMap)) {_                MapperService mapperService = new MapperService(indexSettings, fakeIndexAnalzyers, xContentRegistry, similarityService,_                        mapperRegistry, () -> null)__                mapperService.merge(indexMetaData, MapperService.MergeReason.MAPPING_RECOVERY)__            }_        } catch (Exception ex) {_            _            throw new IllegalStateException("unable to upgrade the mappings for the index [" + indexMetaData.getIndex() + "]", ex)__        }_    };checks,the,mappings,for,compatibility,with,the,current,version;private,void,check,mappings,compatibility,index,meta,data,index,meta,data,try,index,settings,index,settings,new,index,settings,index,meta,data,this,settings,final,map,string,tri,function,settings,version,script,service,similarity,similarity,map,new,abstract,map,string,tri,function,settings,version,script,service,similarity,override,public,boolean,contains,key,object,key,return,true,override,public,tri,function,settings,version,script,service,similarity,get,object,key,assert,key,instanceof,string,key,must,be,a,string,but,was,key,get,class,return,similarity,service,get,similarity,service,override,public,set,entry,string,tri,function,settings,version,script,service,similarity,entry,set,return,collections,empty,set,similarity,service,similarity,service,new,similarity,service,index,settings,null,similarity,map,final,named,analyzer,fake,default,new,named,analyzer,default,analyzer,scope,index,new,analyzer,override,protected,token,stream,components,create,components,string,field,name,throw,new,unsupported,operation,exception,shouldn,t,be,here,final,map,string,named,analyzer,analyzer,map,new,abstract,map,string,named,analyzer,override,public,named,analyzer,get,object,key,assert,key,instanceof,string,key,must,be,a,string,but,was,key,get,class,return,new,named,analyzer,string,key,analyzer,scope,index,fake,default,analyzer,override,public,set,entry,string,named,analyzer,entry,set,return,collections,empty,set,try,index,analyzers,fake,index,analzyers,new,index,analyzers,index,settings,fake,default,fake,default,fake,default,analyzer,map,analyzer,map,analyzer,map,mapper,service,mapper,service,new,mapper,service,index,settings,fake,index,analzyers,x,content,registry,similarity,service,mapper,registry,null,mapper,service,merge,index,meta,data,mapper,service,merge,reason,catch,exception,ex,throw,new,illegal,state,exception,unable,to,upgrade,the,mappings,for,the,index,index,meta,data,get,index,ex
MetaDataIndexUpgradeService -> private void checkMappingsCompatibility(IndexMetaData indexMetaData);1542402632;Checks the mappings for compatibility with the current version;private void checkMappingsCompatibility(IndexMetaData indexMetaData) {_        try {__            _            _            _            _            _            __            IndexSettings indexSettings = new IndexSettings(indexMetaData, this.settings)___            final Map<String, TriFunction<Settings, Version, ScriptService, Similarity>> similarityMap_                    = new AbstractMap<String, TriFunction<Settings, Version, ScriptService, Similarity>>() {_                @Override_                public boolean containsKey(Object key) {_                    return true__                }__                @Override_                public TriFunction<Settings, Version, ScriptService, Similarity> get(Object key) {_                    assert key instanceof String : "key must be a string but was: " + key.getClass()__                    return SimilarityService.BUILT_IN.get(SimilarityService.DEFAULT_SIMILARITY)__                }__                _                _                @Override_                public Set<Entry<String, TriFunction<Settings, Version, ScriptService, Similarity>>> entrySet() {_                    return Collections.emptySet()__                }_            }__            SimilarityService similarityService = new SimilarityService(indexSettings, null, similarityMap)__            final NamedAnalyzer fakeDefault = new NamedAnalyzer("default", AnalyzerScope.INDEX, new Analyzer() {_                @Override_                protected TokenStreamComponents createComponents(String fieldName) {_                    throw new UnsupportedOperationException("shouldn't be here")__                }_            })___            final Map<String, NamedAnalyzer> analyzerMap = new AbstractMap<String, NamedAnalyzer>() {_                @Override_                public NamedAnalyzer get(Object key) {_                    assert key instanceof String : "key must be a string but was: " + key.getClass()__                    return new NamedAnalyzer((String)key, AnalyzerScope.INDEX, fakeDefault.analyzer())__                }__                _                _                @Override_                public Set<Entry<String, NamedAnalyzer>> entrySet() {_                    return Collections.emptySet()__                }_            }__            try (IndexAnalyzers fakeIndexAnalzyers =_                     new IndexAnalyzers(indexSettings, fakeDefault, fakeDefault, fakeDefault, analyzerMap, analyzerMap, analyzerMap)) {_                MapperService mapperService = new MapperService(indexSettings, fakeIndexAnalzyers, xContentRegistry, similarityService,_                        mapperRegistry, () -> null)__                mapperService.merge(indexMetaData, MapperService.MergeReason.MAPPING_RECOVERY)__            }_        } catch (Exception ex) {_            _            throw new IllegalStateException("unable to upgrade the mappings for the index [" + indexMetaData.getIndex() + "]", ex)__        }_    };checks,the,mappings,for,compatibility,with,the,current,version;private,void,check,mappings,compatibility,index,meta,data,index,meta,data,try,index,settings,index,settings,new,index,settings,index,meta,data,this,settings,final,map,string,tri,function,settings,version,script,service,similarity,similarity,map,new,abstract,map,string,tri,function,settings,version,script,service,similarity,override,public,boolean,contains,key,object,key,return,true,override,public,tri,function,settings,version,script,service,similarity,get,object,key,assert,key,instanceof,string,key,must,be,a,string,but,was,key,get,class,return,similarity,service,get,similarity,service,override,public,set,entry,string,tri,function,settings,version,script,service,similarity,entry,set,return,collections,empty,set,similarity,service,similarity,service,new,similarity,service,index,settings,null,similarity,map,final,named,analyzer,fake,default,new,named,analyzer,default,analyzer,scope,index,new,analyzer,override,protected,token,stream,components,create,components,string,field,name,throw,new,unsupported,operation,exception,shouldn,t,be,here,final,map,string,named,analyzer,analyzer,map,new,abstract,map,string,named,analyzer,override,public,named,analyzer,get,object,key,assert,key,instanceof,string,key,must,be,a,string,but,was,key,get,class,return,new,named,analyzer,string,key,analyzer,scope,index,fake,default,analyzer,override,public,set,entry,string,named,analyzer,entry,set,return,collections,empty,set,try,index,analyzers,fake,index,analzyers,new,index,analyzers,index,settings,fake,default,fake,default,fake,default,analyzer,map,analyzer,map,analyzer,map,mapper,service,mapper,service,new,mapper,service,index,settings,fake,index,analzyers,x,content,registry,similarity,service,mapper,registry,null,mapper,service,merge,index,meta,data,mapper,service,merge,reason,catch,exception,ex,throw,new,illegal,state,exception,unable,to,upgrade,the,mappings,for,the,index,index,meta,data,get,index,ex
MetaDataIndexUpgradeService -> private IndexMetaData markAsUpgraded(IndexMetaData indexMetaData);1524684173;Marks index as upgraded so we don't have to test it again;private IndexMetaData markAsUpgraded(IndexMetaData indexMetaData) {_        Settings settings = Settings.builder().put(indexMetaData.getSettings()).put(IndexMetaData.SETTING_VERSION_UPGRADED, Version.CURRENT).build()__        return IndexMetaData.builder(indexMetaData).settings(settings).build()__    };marks,index,as,upgraded,so,we,don,t,have,to,test,it,again;private,index,meta,data,mark,as,upgraded,index,meta,data,index,meta,data,settings,settings,settings,builder,put,index,meta,data,get,settings,put,index,meta,data,version,current,build,return,index,meta,data,builder,index,meta,data,settings,settings,build
MetaDataIndexUpgradeService -> private IndexMetaData markAsUpgraded(IndexMetaData indexMetaData);1527840262;Marks index as upgraded so we don't have to test it again;private IndexMetaData markAsUpgraded(IndexMetaData indexMetaData) {_        Settings settings = Settings.builder().put(indexMetaData.getSettings()).put(IndexMetaData.SETTING_VERSION_UPGRADED, Version.CURRENT).build()__        return IndexMetaData.builder(indexMetaData).settings(settings).build()__    };marks,index,as,upgraded,so,we,don,t,have,to,test,it,again;private,index,meta,data,mark,as,upgraded,index,meta,data,index,meta,data,settings,settings,settings,builder,put,index,meta,data,get,settings,put,index,meta,data,version,current,build,return,index,meta,data,builder,index,meta,data,settings,settings,build
MetaDataIndexUpgradeService -> private IndexMetaData markAsUpgraded(IndexMetaData indexMetaData);1539615817;Marks index as upgraded so we don't have to test it again;private IndexMetaData markAsUpgraded(IndexMetaData indexMetaData) {_        Settings settings = Settings.builder().put(indexMetaData.getSettings()).put(IndexMetaData.SETTING_VERSION_UPGRADED, Version.CURRENT).build()__        return IndexMetaData.builder(indexMetaData).settings(settings).build()__    };marks,index,as,upgraded,so,we,don,t,have,to,test,it,again;private,index,meta,data,mark,as,upgraded,index,meta,data,index,meta,data,settings,settings,settings,builder,put,index,meta,data,get,settings,put,index,meta,data,version,current,build,return,index,meta,data,builder,index,meta,data,settings,settings,build
MetaDataIndexUpgradeService -> private IndexMetaData markAsUpgraded(IndexMetaData indexMetaData);1540847035;Marks index as upgraded so we don't have to test it again;private IndexMetaData markAsUpgraded(IndexMetaData indexMetaData) {_        Settings settings = Settings.builder().put(indexMetaData.getSettings())_            .put(IndexMetaData.SETTING_VERSION_UPGRADED, Version.CURRENT).build()__        return IndexMetaData.builder(indexMetaData).settings(settings).build()__    };marks,index,as,upgraded,so,we,don,t,have,to,test,it,again;private,index,meta,data,mark,as,upgraded,index,meta,data,index,meta,data,settings,settings,settings,builder,put,index,meta,data,get,settings,put,index,meta,data,version,current,build,return,index,meta,data,builder,index,meta,data,settings,settings,build
MetaDataIndexUpgradeService -> private IndexMetaData markAsUpgraded(IndexMetaData indexMetaData);1541008027;Marks index as upgraded so we don't have to test it again;private IndexMetaData markAsUpgraded(IndexMetaData indexMetaData) {_        Settings settings = Settings.builder().put(indexMetaData.getSettings())_            .put(IndexMetaData.SETTING_VERSION_UPGRADED, Version.CURRENT).build()__        return IndexMetaData.builder(indexMetaData).settings(settings).build()__    };marks,index,as,upgraded,so,we,don,t,have,to,test,it,again;private,index,meta,data,mark,as,upgraded,index,meta,data,index,meta,data,settings,settings,settings,builder,put,index,meta,data,get,settings,put,index,meta,data,version,current,build,return,index,meta,data,builder,index,meta,data,settings,settings,build
MetaDataIndexUpgradeService -> private IndexMetaData markAsUpgraded(IndexMetaData indexMetaData);1541092382;Marks index as upgraded so we don't have to test it again;private IndexMetaData markAsUpgraded(IndexMetaData indexMetaData) {_        Settings settings = Settings.builder().put(indexMetaData.getSettings())_            .put(IndexMetaData.SETTING_VERSION_UPGRADED, Version.CURRENT).build()__        return IndexMetaData.builder(indexMetaData).settings(settings).build()__    };marks,index,as,upgraded,so,we,don,t,have,to,test,it,again;private,index,meta,data,mark,as,upgraded,index,meta,data,index,meta,data,settings,settings,settings,builder,put,index,meta,data,get,settings,put,index,meta,data,version,current,build,return,index,meta,data,builder,index,meta,data,settings,settings,build
MetaDataIndexUpgradeService -> private IndexMetaData markAsUpgraded(IndexMetaData indexMetaData);1542402632;Marks index as upgraded so we don't have to test it again;private IndexMetaData markAsUpgraded(IndexMetaData indexMetaData) {_        Settings settings = Settings.builder().put(indexMetaData.getSettings())_            .put(IndexMetaData.SETTING_VERSION_UPGRADED, Version.CURRENT).build()__        return IndexMetaData.builder(indexMetaData).settings(settings).build()__    };marks,index,as,upgraded,so,we,don,t,have,to,test,it,again;private,index,meta,data,mark,as,upgraded,index,meta,data,index,meta,data,settings,settings,settings,builder,put,index,meta,data,get,settings,put,index,meta,data,version,current,build,return,index,meta,data,builder,index,meta,data,settings,settings,build
MetaDataIndexUpgradeService -> boolean isUpgraded(IndexMetaData indexMetaData);1524684173;Checks if the index was already opened by this version of Elasticsearch and doesn't require any additional checks.;boolean isUpgraded(IndexMetaData indexMetaData) {_        return indexMetaData.getUpgradedVersion().onOrAfter(Version.CURRENT)__    };checks,if,the,index,was,already,opened,by,this,version,of,elasticsearch,and,doesn,t,require,any,additional,checks;boolean,is,upgraded,index,meta,data,index,meta,data,return,index,meta,data,get,upgraded,version,on,or,after,version,current
MetaDataIndexUpgradeService -> boolean isUpgraded(IndexMetaData indexMetaData);1527840262;Checks if the index was already opened by this version of Elasticsearch and doesn't require any additional checks.;boolean isUpgraded(IndexMetaData indexMetaData) {_        return indexMetaData.getUpgradedVersion().onOrAfter(Version.CURRENT)__    };checks,if,the,index,was,already,opened,by,this,version,of,elasticsearch,and,doesn,t,require,any,additional,checks;boolean,is,upgraded,index,meta,data,index,meta,data,return,index,meta,data,get,upgraded,version,on,or,after,version,current
MetaDataIndexUpgradeService -> boolean isUpgraded(IndexMetaData indexMetaData);1539615817;Checks if the index was already opened by this version of Elasticsearch and doesn't require any additional checks.;boolean isUpgraded(IndexMetaData indexMetaData) {_        return indexMetaData.getUpgradedVersion().onOrAfter(Version.CURRENT)__    };checks,if,the,index,was,already,opened,by,this,version,of,elasticsearch,and,doesn,t,require,any,additional,checks;boolean,is,upgraded,index,meta,data,index,meta,data,return,index,meta,data,get,upgraded,version,on,or,after,version,current
MetaDataIndexUpgradeService -> boolean isUpgraded(IndexMetaData indexMetaData);1540847035;Checks if the index was already opened by this version of Elasticsearch and doesn't require any additional checks.;boolean isUpgraded(IndexMetaData indexMetaData) {_        return indexMetaData.getUpgradedVersion().onOrAfter(Version.CURRENT)__    };checks,if,the,index,was,already,opened,by,this,version,of,elasticsearch,and,doesn,t,require,any,additional,checks;boolean,is,upgraded,index,meta,data,index,meta,data,return,index,meta,data,get,upgraded,version,on,or,after,version,current
MetaDataIndexUpgradeService -> boolean isUpgraded(IndexMetaData indexMetaData);1541008027;Checks if the index was already opened by this version of Elasticsearch and doesn't require any additional checks.;boolean isUpgraded(IndexMetaData indexMetaData) {_        return indexMetaData.getUpgradedVersion().onOrAfter(Version.CURRENT)__    };checks,if,the,index,was,already,opened,by,this,version,of,elasticsearch,and,doesn,t,require,any,additional,checks;boolean,is,upgraded,index,meta,data,index,meta,data,return,index,meta,data,get,upgraded,version,on,or,after,version,current
MetaDataIndexUpgradeService -> boolean isUpgraded(IndexMetaData indexMetaData);1541092382;Checks if the index was already opened by this version of Elasticsearch and doesn't require any additional checks.;boolean isUpgraded(IndexMetaData indexMetaData) {_        return indexMetaData.getUpgradedVersion().onOrAfter(Version.CURRENT)__    };checks,if,the,index,was,already,opened,by,this,version,of,elasticsearch,and,doesn,t,require,any,additional,checks;boolean,is,upgraded,index,meta,data,index,meta,data,return,index,meta,data,get,upgraded,version,on,or,after,version,current
MetaDataIndexUpgradeService -> boolean isUpgraded(IndexMetaData indexMetaData);1542402632;Checks if the index was already opened by this version of Elasticsearch and doesn't require any additional checks.;boolean isUpgraded(IndexMetaData indexMetaData) {_        return indexMetaData.getUpgradedVersion().onOrAfter(Version.CURRENT)__    };checks,if,the,index,was,already,opened,by,this,version,of,elasticsearch,and,doesn,t,require,any,additional,checks;boolean,is,upgraded,index,meta,data,index,meta,data,return,index,meta,data,get,upgraded,version,on,or,after,version,current
MetaDataIndexUpgradeService -> private void checkSupportedVersion(IndexMetaData indexMetaData, Version minimumIndexCompatibilityVersion);1524684173;Elasticsearch v6.0 no longer supports indices created pre v5.0. All indices_that were created before Elasticsearch v5.0 should be re-indexed in Elasticsearch 5.x_before they can be opened by this version of elasticsearch.;private void checkSupportedVersion(IndexMetaData indexMetaData, Version minimumIndexCompatibilityVersion) {_        if (indexMetaData.getState() == IndexMetaData.State.OPEN && isSupportedVersion(indexMetaData,_            minimumIndexCompatibilityVersion) == false) {_            throw new IllegalStateException("The index [" + indexMetaData.getIndex() + "] was created with version ["_                + indexMetaData.getCreationVersion() + "] but the minimum compatible version is ["__                + minimumIndexCompatibilityVersion + "]. It should be re-indexed in Elasticsearch " + minimumIndexCompatibilityVersion.major_                + ".x before upgrading to " + Version.CURRENT + ".")__        }_    };elasticsearch,v6,0,no,longer,supports,indices,created,pre,v5,0,all,indices,that,were,created,before,elasticsearch,v5,0,should,be,re,indexed,in,elasticsearch,5,x,before,they,can,be,opened,by,this,version,of,elasticsearch;private,void,check,supported,version,index,meta,data,index,meta,data,version,minimum,index,compatibility,version,if,index,meta,data,get,state,index,meta,data,state,open,is,supported,version,index,meta,data,minimum,index,compatibility,version,false,throw,new,illegal,state,exception,the,index,index,meta,data,get,index,was,created,with,version,index,meta,data,get,creation,version,but,the,minimum,compatible,version,is,minimum,index,compatibility,version,it,should,be,re,indexed,in,elasticsearch,minimum,index,compatibility,version,major,x,before,upgrading,to,version,current
MetaDataIndexUpgradeService -> private void checkSupportedVersion(IndexMetaData indexMetaData, Version minimumIndexCompatibilityVersion);1527840262;Elasticsearch v6.0 no longer supports indices created pre v5.0. All indices_that were created before Elasticsearch v5.0 should be re-indexed in Elasticsearch 5.x_before they can be opened by this version of elasticsearch.;private void checkSupportedVersion(IndexMetaData indexMetaData, Version minimumIndexCompatibilityVersion) {_        if (indexMetaData.getState() == IndexMetaData.State.OPEN && isSupportedVersion(indexMetaData,_            minimumIndexCompatibilityVersion) == false) {_            throw new IllegalStateException("The index [" + indexMetaData.getIndex() + "] was created with version ["_                + indexMetaData.getCreationVersion() + "] but the minimum compatible version is ["__                + minimumIndexCompatibilityVersion + "]. It should be re-indexed in Elasticsearch " + minimumIndexCompatibilityVersion.major_                + ".x before upgrading to " + Version.CURRENT + ".")__        }_    };elasticsearch,v6,0,no,longer,supports,indices,created,pre,v5,0,all,indices,that,were,created,before,elasticsearch,v5,0,should,be,re,indexed,in,elasticsearch,5,x,before,they,can,be,opened,by,this,version,of,elasticsearch;private,void,check,supported,version,index,meta,data,index,meta,data,version,minimum,index,compatibility,version,if,index,meta,data,get,state,index,meta,data,state,open,is,supported,version,index,meta,data,minimum,index,compatibility,version,false,throw,new,illegal,state,exception,the,index,index,meta,data,get,index,was,created,with,version,index,meta,data,get,creation,version,but,the,minimum,compatible,version,is,minimum,index,compatibility,version,it,should,be,re,indexed,in,elasticsearch,minimum,index,compatibility,version,major,x,before,upgrading,to,version,current
MetaDataIndexUpgradeService -> private void checkSupportedVersion(IndexMetaData indexMetaData, Version minimumIndexCompatibilityVersion);1539615817;Elasticsearch v6.0 no longer supports indices created pre v5.0. All indices_that were created before Elasticsearch v5.0 should be re-indexed in Elasticsearch 5.x_before they can be opened by this version of elasticsearch.;private void checkSupportedVersion(IndexMetaData indexMetaData, Version minimumIndexCompatibilityVersion) {_        if (indexMetaData.getState() == IndexMetaData.State.OPEN && isSupportedVersion(indexMetaData,_            minimumIndexCompatibilityVersion) == false) {_            throw new IllegalStateException("The index [" + indexMetaData.getIndex() + "] was created with version ["_                + indexMetaData.getCreationVersion() + "] but the minimum compatible version is ["__                + minimumIndexCompatibilityVersion + "]. It should be re-indexed in Elasticsearch " + minimumIndexCompatibilityVersion.major_                + ".x before upgrading to " + Version.CURRENT + ".")__        }_    };elasticsearch,v6,0,no,longer,supports,indices,created,pre,v5,0,all,indices,that,were,created,before,elasticsearch,v5,0,should,be,re,indexed,in,elasticsearch,5,x,before,they,can,be,opened,by,this,version,of,elasticsearch;private,void,check,supported,version,index,meta,data,index,meta,data,version,minimum,index,compatibility,version,if,index,meta,data,get,state,index,meta,data,state,open,is,supported,version,index,meta,data,minimum,index,compatibility,version,false,throw,new,illegal,state,exception,the,index,index,meta,data,get,index,was,created,with,version,index,meta,data,get,creation,version,but,the,minimum,compatible,version,is,minimum,index,compatibility,version,it,should,be,re,indexed,in,elasticsearch,minimum,index,compatibility,version,major,x,before,upgrading,to,version,current
MetaDataIndexUpgradeService -> private void checkSupportedVersion(IndexMetaData indexMetaData, Version minimumIndexCompatibilityVersion);1540847035;Elasticsearch v6.0 no longer supports indices created pre v5.0. All indices_that were created before Elasticsearch v5.0 should be re-indexed in Elasticsearch 5.x_before they can be opened by this version of elasticsearch.;private void checkSupportedVersion(IndexMetaData indexMetaData, Version minimumIndexCompatibilityVersion) {_        if (indexMetaData.getState() == IndexMetaData.State.OPEN && isSupportedVersion(indexMetaData,_            minimumIndexCompatibilityVersion) == false) {_            throw new IllegalStateException("The index [" + indexMetaData.getIndex() + "] was created with version ["_                + indexMetaData.getCreationVersion() + "] but the minimum compatible version is ["__                + minimumIndexCompatibilityVersion + "]. It should be re-indexed in Elasticsearch " + minimumIndexCompatibilityVersion.major_                + ".x before upgrading to " + Version.CURRENT + ".")__        }_    };elasticsearch,v6,0,no,longer,supports,indices,created,pre,v5,0,all,indices,that,were,created,before,elasticsearch,v5,0,should,be,re,indexed,in,elasticsearch,5,x,before,they,can,be,opened,by,this,version,of,elasticsearch;private,void,check,supported,version,index,meta,data,index,meta,data,version,minimum,index,compatibility,version,if,index,meta,data,get,state,index,meta,data,state,open,is,supported,version,index,meta,data,minimum,index,compatibility,version,false,throw,new,illegal,state,exception,the,index,index,meta,data,get,index,was,created,with,version,index,meta,data,get,creation,version,but,the,minimum,compatible,version,is,minimum,index,compatibility,version,it,should,be,re,indexed,in,elasticsearch,minimum,index,compatibility,version,major,x,before,upgrading,to,version,current
MetaDataIndexUpgradeService -> private void checkSupportedVersion(IndexMetaData indexMetaData, Version minimumIndexCompatibilityVersion);1541008027;Elasticsearch v6.0 no longer supports indices created pre v5.0. All indices_that were created before Elasticsearch v5.0 should be re-indexed in Elasticsearch 5.x_before they can be opened by this version of elasticsearch.;private void checkSupportedVersion(IndexMetaData indexMetaData, Version minimumIndexCompatibilityVersion) {_        if (indexMetaData.getState() == IndexMetaData.State.OPEN && isSupportedVersion(indexMetaData,_            minimumIndexCompatibilityVersion) == false) {_            throw new IllegalStateException("The index [" + indexMetaData.getIndex() + "] was created with version ["_                + indexMetaData.getCreationVersion() + "] but the minimum compatible version is ["__                + minimumIndexCompatibilityVersion + "]. It should be re-indexed in Elasticsearch " + minimumIndexCompatibilityVersion.major_                + ".x before upgrading to " + Version.CURRENT + ".")__        }_    };elasticsearch,v6,0,no,longer,supports,indices,created,pre,v5,0,all,indices,that,were,created,before,elasticsearch,v5,0,should,be,re,indexed,in,elasticsearch,5,x,before,they,can,be,opened,by,this,version,of,elasticsearch;private,void,check,supported,version,index,meta,data,index,meta,data,version,minimum,index,compatibility,version,if,index,meta,data,get,state,index,meta,data,state,open,is,supported,version,index,meta,data,minimum,index,compatibility,version,false,throw,new,illegal,state,exception,the,index,index,meta,data,get,index,was,created,with,version,index,meta,data,get,creation,version,but,the,minimum,compatible,version,is,minimum,index,compatibility,version,it,should,be,re,indexed,in,elasticsearch,minimum,index,compatibility,version,major,x,before,upgrading,to,version,current
MetaDataIndexUpgradeService -> private void checkSupportedVersion(IndexMetaData indexMetaData, Version minimumIndexCompatibilityVersion);1541092382;Elasticsearch v6.0 no longer supports indices created pre v5.0. All indices_that were created before Elasticsearch v5.0 should be re-indexed in Elasticsearch 5.x_before they can be opened by this version of elasticsearch.;private void checkSupportedVersion(IndexMetaData indexMetaData, Version minimumIndexCompatibilityVersion) {_        if (indexMetaData.getState() == IndexMetaData.State.OPEN && isSupportedVersion(indexMetaData,_            minimumIndexCompatibilityVersion) == false) {_            throw new IllegalStateException("The index [" + indexMetaData.getIndex() + "] was created with version ["_                + indexMetaData.getCreationVersion() + "] but the minimum compatible version is ["__                + minimumIndexCompatibilityVersion + "]. It should be re-indexed in Elasticsearch " + minimumIndexCompatibilityVersion.major_                + ".x before upgrading to " + Version.CURRENT + ".")__        }_    };elasticsearch,v6,0,no,longer,supports,indices,created,pre,v5,0,all,indices,that,were,created,before,elasticsearch,v5,0,should,be,re,indexed,in,elasticsearch,5,x,before,they,can,be,opened,by,this,version,of,elasticsearch;private,void,check,supported,version,index,meta,data,index,meta,data,version,minimum,index,compatibility,version,if,index,meta,data,get,state,index,meta,data,state,open,is,supported,version,index,meta,data,minimum,index,compatibility,version,false,throw,new,illegal,state,exception,the,index,index,meta,data,get,index,was,created,with,version,index,meta,data,get,creation,version,but,the,minimum,compatible,version,is,minimum,index,compatibility,version,it,should,be,re,indexed,in,elasticsearch,minimum,index,compatibility,version,major,x,before,upgrading,to,version,current
MetaDataIndexUpgradeService -> private void checkSupportedVersion(IndexMetaData indexMetaData, Version minimumIndexCompatibilityVersion);1542402632;Elasticsearch v6.0 no longer supports indices created pre v5.0. All indices_that were created before Elasticsearch v5.0 should be re-indexed in Elasticsearch 5.x_before they can be opened by this version of elasticsearch.;private void checkSupportedVersion(IndexMetaData indexMetaData, Version minimumIndexCompatibilityVersion) {_        if (indexMetaData.getState() == IndexMetaData.State.OPEN && isSupportedVersion(indexMetaData,_            minimumIndexCompatibilityVersion) == false) {_            throw new IllegalStateException("The index [" + indexMetaData.getIndex() + "] was created with version ["_                + indexMetaData.getCreationVersion() + "] but the minimum compatible version is ["__                + minimumIndexCompatibilityVersion + "]. It should be re-indexed in Elasticsearch " + minimumIndexCompatibilityVersion.major_                + ".x before upgrading to " + Version.CURRENT + ".")__        }_    };elasticsearch,v6,0,no,longer,supports,indices,created,pre,v5,0,all,indices,that,were,created,before,elasticsearch,v5,0,should,be,re,indexed,in,elasticsearch,5,x,before,they,can,be,opened,by,this,version,of,elasticsearch;private,void,check,supported,version,index,meta,data,index,meta,data,version,minimum,index,compatibility,version,if,index,meta,data,get,state,index,meta,data,state,open,is,supported,version,index,meta,data,minimum,index,compatibility,version,false,throw,new,illegal,state,exception,the,index,index,meta,data,get,index,was,created,with,version,index,meta,data,get,creation,version,but,the,minimum,compatible,version,is,minimum,index,compatibility,version,it,should,be,re,indexed,in,elasticsearch,minimum,index,compatibility,version,major,x,before,upgrading,to,version,current
MetaDataIndexUpgradeService -> public IndexMetaData upgradeIndexMetaData(IndexMetaData indexMetaData, Version minimumIndexCompatibilityVersion);1524684173;Checks that the index can be upgraded to the current version of the master node.__<p>_If the index does not need upgrade it returns the index metadata unchanged, otherwise it returns a modified index metadata. If index_cannot be updated the method throws an exception.;public IndexMetaData upgradeIndexMetaData(IndexMetaData indexMetaData, Version minimumIndexCompatibilityVersion) {_        _        if (isUpgraded(indexMetaData)) {_            return indexMetaData__        }_        checkSupportedVersion(indexMetaData, minimumIndexCompatibilityVersion)__        IndexMetaData newMetaData = indexMetaData__        _        _        newMetaData = archiveBrokenIndexSettings(newMetaData)__        _        checkMappingsCompatibility(newMetaData)__        _        newMetaData = upgraders.apply(newMetaData)__        return markAsUpgraded(newMetaData)__    };checks,that,the,index,can,be,upgraded,to,the,current,version,of,the,master,node,p,if,the,index,does,not,need,upgrade,it,returns,the,index,metadata,unchanged,otherwise,it,returns,a,modified,index,metadata,if,index,cannot,be,updated,the,method,throws,an,exception;public,index,meta,data,upgrade,index,meta,data,index,meta,data,index,meta,data,version,minimum,index,compatibility,version,if,is,upgraded,index,meta,data,return,index,meta,data,check,supported,version,index,meta,data,minimum,index,compatibility,version,index,meta,data,new,meta,data,index,meta,data,new,meta,data,archive,broken,index,settings,new,meta,data,check,mappings,compatibility,new,meta,data,new,meta,data,upgraders,apply,new,meta,data,return,mark,as,upgraded,new,meta,data
MetaDataIndexUpgradeService -> public IndexMetaData upgradeIndexMetaData(IndexMetaData indexMetaData, Version minimumIndexCompatibilityVersion);1527840262;Checks that the index can be upgraded to the current version of the master node.__<p>_If the index does not need upgrade it returns the index metadata unchanged, otherwise it returns a modified index metadata. If index_cannot be updated the method throws an exception.;public IndexMetaData upgradeIndexMetaData(IndexMetaData indexMetaData, Version minimumIndexCompatibilityVersion) {_        _        if (isUpgraded(indexMetaData)) {_            return indexMetaData__        }_        checkSupportedVersion(indexMetaData, minimumIndexCompatibilityVersion)__        IndexMetaData newMetaData = indexMetaData__        _        _        newMetaData = archiveBrokenIndexSettings(newMetaData)__        _        checkMappingsCompatibility(newMetaData)__        _        newMetaData = upgraders.apply(newMetaData)__        return markAsUpgraded(newMetaData)__    };checks,that,the,index,can,be,upgraded,to,the,current,version,of,the,master,node,p,if,the,index,does,not,need,upgrade,it,returns,the,index,metadata,unchanged,otherwise,it,returns,a,modified,index,metadata,if,index,cannot,be,updated,the,method,throws,an,exception;public,index,meta,data,upgrade,index,meta,data,index,meta,data,index,meta,data,version,minimum,index,compatibility,version,if,is,upgraded,index,meta,data,return,index,meta,data,check,supported,version,index,meta,data,minimum,index,compatibility,version,index,meta,data,new,meta,data,index,meta,data,new,meta,data,archive,broken,index,settings,new,meta,data,check,mappings,compatibility,new,meta,data,new,meta,data,upgraders,apply,new,meta,data,return,mark,as,upgraded,new,meta,data
MetaDataIndexUpgradeService -> public IndexMetaData upgradeIndexMetaData(IndexMetaData indexMetaData, Version minimumIndexCompatibilityVersion);1539615817;Checks that the index can be upgraded to the current version of the master node.__<p>_If the index does not need upgrade it returns the index metadata unchanged, otherwise it returns a modified index metadata. If index_cannot be updated the method throws an exception.;public IndexMetaData upgradeIndexMetaData(IndexMetaData indexMetaData, Version minimumIndexCompatibilityVersion) {_        _        if (isUpgraded(indexMetaData)) {_            return indexMetaData__        }_        checkSupportedVersion(indexMetaData, minimumIndexCompatibilityVersion)__        IndexMetaData newMetaData = indexMetaData__        _        _        newMetaData = archiveBrokenIndexSettings(newMetaData)__        _        checkMappingsCompatibility(newMetaData)__        _        newMetaData = upgraders.apply(newMetaData)__        return markAsUpgraded(newMetaData)__    };checks,that,the,index,can,be,upgraded,to,the,current,version,of,the,master,node,p,if,the,index,does,not,need,upgrade,it,returns,the,index,metadata,unchanged,otherwise,it,returns,a,modified,index,metadata,if,index,cannot,be,updated,the,method,throws,an,exception;public,index,meta,data,upgrade,index,meta,data,index,meta,data,index,meta,data,version,minimum,index,compatibility,version,if,is,upgraded,index,meta,data,return,index,meta,data,check,supported,version,index,meta,data,minimum,index,compatibility,version,index,meta,data,new,meta,data,index,meta,data,new,meta,data,archive,broken,index,settings,new,meta,data,check,mappings,compatibility,new,meta,data,new,meta,data,upgraders,apply,new,meta,data,return,mark,as,upgraded,new,meta,data
MetaDataIndexUpgradeService -> public IndexMetaData upgradeIndexMetaData(IndexMetaData indexMetaData, Version minimumIndexCompatibilityVersion);1540847035;Checks that the index can be upgraded to the current version of the master node.__<p>_If the index does not need upgrade it returns the index metadata unchanged, otherwise it returns a modified index metadata. If index_cannot be updated the method throws an exception.;public IndexMetaData upgradeIndexMetaData(IndexMetaData indexMetaData, Version minimumIndexCompatibilityVersion) {_        _        if (isUpgraded(indexMetaData)) {_            return indexMetaData__        }_        checkSupportedVersion(indexMetaData, minimumIndexCompatibilityVersion)__        IndexMetaData newMetaData = indexMetaData__        _        _        newMetaData = archiveBrokenIndexSettings(newMetaData)__        _        checkMappingsCompatibility(newMetaData)__        _        newMetaData = upgraders.apply(newMetaData)__        return markAsUpgraded(newMetaData)__    };checks,that,the,index,can,be,upgraded,to,the,current,version,of,the,master,node,p,if,the,index,does,not,need,upgrade,it,returns,the,index,metadata,unchanged,otherwise,it,returns,a,modified,index,metadata,if,index,cannot,be,updated,the,method,throws,an,exception;public,index,meta,data,upgrade,index,meta,data,index,meta,data,index,meta,data,version,minimum,index,compatibility,version,if,is,upgraded,index,meta,data,return,index,meta,data,check,supported,version,index,meta,data,minimum,index,compatibility,version,index,meta,data,new,meta,data,index,meta,data,new,meta,data,archive,broken,index,settings,new,meta,data,check,mappings,compatibility,new,meta,data,new,meta,data,upgraders,apply,new,meta,data,return,mark,as,upgraded,new,meta,data
MetaDataIndexUpgradeService -> public IndexMetaData upgradeIndexMetaData(IndexMetaData indexMetaData, Version minimumIndexCompatibilityVersion);1541008027;Checks that the index can be upgraded to the current version of the master node.__<p>_If the index does not need upgrade it returns the index metadata unchanged, otherwise it returns a modified index metadata. If index_cannot be updated the method throws an exception.;public IndexMetaData upgradeIndexMetaData(IndexMetaData indexMetaData, Version minimumIndexCompatibilityVersion) {_        _        if (isUpgraded(indexMetaData)) {_            return indexMetaData__        }_        checkSupportedVersion(indexMetaData, minimumIndexCompatibilityVersion)__        IndexMetaData newMetaData = indexMetaData__        _        _        newMetaData = archiveBrokenIndexSettings(newMetaData)__        _        checkMappingsCompatibility(newMetaData)__        _        newMetaData = upgraders.apply(newMetaData)__        return markAsUpgraded(newMetaData)__    };checks,that,the,index,can,be,upgraded,to,the,current,version,of,the,master,node,p,if,the,index,does,not,need,upgrade,it,returns,the,index,metadata,unchanged,otherwise,it,returns,a,modified,index,metadata,if,index,cannot,be,updated,the,method,throws,an,exception;public,index,meta,data,upgrade,index,meta,data,index,meta,data,index,meta,data,version,minimum,index,compatibility,version,if,is,upgraded,index,meta,data,return,index,meta,data,check,supported,version,index,meta,data,minimum,index,compatibility,version,index,meta,data,new,meta,data,index,meta,data,new,meta,data,archive,broken,index,settings,new,meta,data,check,mappings,compatibility,new,meta,data,new,meta,data,upgraders,apply,new,meta,data,return,mark,as,upgraded,new,meta,data
MetaDataIndexUpgradeService -> public IndexMetaData upgradeIndexMetaData(IndexMetaData indexMetaData, Version minimumIndexCompatibilityVersion);1541092382;Checks that the index can be upgraded to the current version of the master node.__<p>_If the index does not need upgrade it returns the index metadata unchanged, otherwise it returns a modified index metadata. If index_cannot be updated the method throws an exception.;public IndexMetaData upgradeIndexMetaData(IndexMetaData indexMetaData, Version minimumIndexCompatibilityVersion) {_        _        if (isUpgraded(indexMetaData)) {_            return indexMetaData__        }_        checkSupportedVersion(indexMetaData, minimumIndexCompatibilityVersion)__        IndexMetaData newMetaData = indexMetaData__        _        _        newMetaData = archiveBrokenIndexSettings(newMetaData)__        _        checkMappingsCompatibility(newMetaData)__        _        newMetaData = upgraders.apply(newMetaData)__        return markAsUpgraded(newMetaData)__    };checks,that,the,index,can,be,upgraded,to,the,current,version,of,the,master,node,p,if,the,index,does,not,need,upgrade,it,returns,the,index,metadata,unchanged,otherwise,it,returns,a,modified,index,metadata,if,index,cannot,be,updated,the,method,throws,an,exception;public,index,meta,data,upgrade,index,meta,data,index,meta,data,index,meta,data,version,minimum,index,compatibility,version,if,is,upgraded,index,meta,data,return,index,meta,data,check,supported,version,index,meta,data,minimum,index,compatibility,version,index,meta,data,new,meta,data,index,meta,data,new,meta,data,archive,broken,index,settings,new,meta,data,check,mappings,compatibility,new,meta,data,new,meta,data,upgraders,apply,new,meta,data,return,mark,as,upgraded,new,meta,data
MetaDataIndexUpgradeService -> public IndexMetaData upgradeIndexMetaData(IndexMetaData indexMetaData, Version minimumIndexCompatibilityVersion);1542402632;Checks that the index can be upgraded to the current version of the master node.__<p>_If the index does not need upgrade it returns the index metadata unchanged, otherwise it returns a modified index metadata. If index_cannot be updated the method throws an exception.;public IndexMetaData upgradeIndexMetaData(IndexMetaData indexMetaData, Version minimumIndexCompatibilityVersion) {_        _        if (isUpgraded(indexMetaData)) {_            return indexMetaData__        }_        checkSupportedVersion(indexMetaData, minimumIndexCompatibilityVersion)__        IndexMetaData newMetaData = indexMetaData__        _        _        newMetaData = archiveBrokenIndexSettings(newMetaData)__        _        checkMappingsCompatibility(newMetaData)__        _        newMetaData = upgraders.apply(newMetaData)__        return markAsUpgraded(newMetaData)__    };checks,that,the,index,can,be,upgraded,to,the,current,version,of,the,master,node,p,if,the,index,does,not,need,upgrade,it,returns,the,index,metadata,unchanged,otherwise,it,returns,a,modified,index,metadata,if,index,cannot,be,updated,the,method,throws,an,exception;public,index,meta,data,upgrade,index,meta,data,index,meta,data,index,meta,data,version,minimum,index,compatibility,version,if,is,upgraded,index,meta,data,return,index,meta,data,check,supported,version,index,meta,data,minimum,index,compatibility,version,index,meta,data,new,meta,data,index,meta,data,new,meta,data,archive,broken,index,settings,new,meta,data,check,mappings,compatibility,new,meta,data,new,meta,data,upgraders,apply,new,meta,data,return,mark,as,upgraded,new,meta,data
