commented;modifiers;parameterAmount;loc;comment;code
true;public;2;16;/**  * Checks that the index can be upgraded to the current version of the master node.  *  * <p>  * If the index does not need upgrade it returns the index metadata unchanged, otherwise it returns a modified index metadata. If index  * cannot be updated the method throws an exception.  */ ;/**  * Checks that the index can be upgraded to the current version of the master node.  *  * <p>  * If the index does not need upgrade it returns the index metadata unchanged, otherwise it returns a modified index metadata. If index  * cannot be updated the method throws an exception.  */ public IndexMetaData upgradeIndexMetaData(IndexMetaData indexMetaData, Version minimumIndexCompatibilityVersion) {     // Throws an exception if there are too-old segments:     if (isUpgraded(indexMetaData)) {         return indexMetaData.     }     checkSupportedVersion(indexMetaData, minimumIndexCompatibilityVersion).     IndexMetaData newMetaData = indexMetaData.     // we have to run this first otherwise in we try to create IndexSettings     // with broken settings and fail in checkMappingsCompatibility     newMetaData = archiveBrokenIndexSettings(newMetaData).     // only run the check with the upgraded settings!!     checkMappingsCompatibility(newMetaData).     // apply plugin checks     newMetaData = upgraders.apply(newMetaData).     return markAsUpgraded(newMetaData). }
true;;1;3;/**  * Checks if the index was already opened by this version of Elasticsearch and doesn't require any additional checks.  */ ;/**  * Checks if the index was already opened by this version of Elasticsearch and doesn't require any additional checks.  */ boolean isUpgraded(IndexMetaData indexMetaData) {     return indexMetaData.getUpgradedVersion().onOrAfter(Version.CURRENT). }
true;private;2;10;/**  * Elasticsearch v6.0 no longer supports indices created pre v5.0. All indices  * that were created before Elasticsearch v5.0 should be re-indexed in Elasticsearch 5.x  * before they can be opened by this version of elasticsearch.  */ ;/**  * Elasticsearch v6.0 no longer supports indices created pre v5.0. All indices  * that were created before Elasticsearch v5.0 should be re-indexed in Elasticsearch 5.x  * before they can be opened by this version of elasticsearch.  */ private void checkSupportedVersion(IndexMetaData indexMetaData, Version minimumIndexCompatibilityVersion) {     if (indexMetaData.getState() == IndexMetaData.State.OPEN && isSupportedVersion(indexMetaData, minimumIndexCompatibilityVersion) == false) {         throw new IllegalStateException("The index [" + indexMetaData.getIndex() + "] was created with version [" + indexMetaData.getCreationVersion() + "] but the minimum compatible version is [" + minimumIndexCompatibilityVersion + "]. It should be re-indexed in Elasticsearch " + minimumIndexCompatibilityVersion.major + ".x before upgrading to " + Version.CURRENT + ".").     } }
true;private,static;2;3;/*      * Returns true if this index can be supported by the current version of elasticsearch      */ ;/*      * Returns true if this index can be supported by the current version of elasticsearch      */ private static boolean isSupportedVersion(IndexMetaData indexMetaData, Version minimumIndexCompatibilityVersion) {     return indexMetaData.getCreationVersion().onOrAfter(minimumIndexCompatibilityVersion). }
false;public;1;4;;@Override public boolean containsKey(Object key) {     return true. }
false;public;1;5;;@Override public TriFunction<Settings, Version, ScriptService, Similarity> get(Object key) {     assert key instanceof String : "key must be a string but was: " + key.getClass().     return SimilarityService.BUILT_IN.get(SimilarityService.DEFAULT_SIMILARITY). }
true;public;0;4;// over all similarities ;// this entrySet impl isn't fully correct but necessary as SimilarityService will iterate // over all similarities @Override public Set<Entry<String, TriFunction<Settings, Version, ScriptService, Similarity>>> entrySet() {     return Collections.emptySet(). }
false;protected;1;4;;@Override protected TokenStreamComponents createComponents(String fieldName) {     throw new UnsupportedOperationException("shouldn't be here"). }
false;public;1;5;;@Override public NamedAnalyzer get(Object key) {     assert key instanceof String : "key must be a string but was: " + key.getClass().     return new NamedAnalyzer((String) key, AnalyzerScope.INDEX, fakeDefault.analyzer()). }
true;public;0;4;// over all analyzers to close them ;// this entrySet impl isn't fully correct but necessary as IndexAnalyzers will iterate // over all analyzers to close them @Override public Set<Entry<String, NamedAnalyzer>> entrySet() {     return Collections.emptySet(). }
true;private;1;65;/**  * Checks the mappings for compatibility with the current version  */ ;/**  * Checks the mappings for compatibility with the current version  */ private void checkMappingsCompatibility(IndexMetaData indexMetaData) {     try {         // We cannot instantiate real analysis server or similarity service at this point because the node         // might not have been started yet. However, we don't really need real analyzers or similarities at         // this stage - so we can fake it using constant maps accepting every key.         // This is ok because all used similarities and analyzers for this index were known before the upgrade.         // Missing analyzers and similarities plugin will still trigger the appropriate error during the         // actual upgrade.         IndexSettings indexSettings = new IndexSettings(indexMetaData, this.settings).         final Map<String, TriFunction<Settings, Version, ScriptService, Similarity>> similarityMap = new AbstractMap<String, TriFunction<Settings, Version, ScriptService, Similarity>>() {              @Override             public boolean containsKey(Object key) {                 return true.             }              @Override             public TriFunction<Settings, Version, ScriptService, Similarity> get(Object key) {                 assert key instanceof String : "key must be a string but was: " + key.getClass().                 return SimilarityService.BUILT_IN.get(SimilarityService.DEFAULT_SIMILARITY).             }              // this entrySet impl isn't fully correct but necessary as SimilarityService will iterate             // over all similarities             @Override             public Set<Entry<String, TriFunction<Settings, Version, ScriptService, Similarity>>> entrySet() {                 return Collections.emptySet().             }         }.         SimilarityService similarityService = new SimilarityService(indexSettings, null, similarityMap).         final NamedAnalyzer fakeDefault = new NamedAnalyzer("default", AnalyzerScope.INDEX, new Analyzer() {              @Override             protected TokenStreamComponents createComponents(String fieldName) {                 throw new UnsupportedOperationException("shouldn't be here").             }         }).         final Map<String, NamedAnalyzer> analyzerMap = new AbstractMap<String, NamedAnalyzer>() {              @Override             public NamedAnalyzer get(Object key) {                 assert key instanceof String : "key must be a string but was: " + key.getClass().                 return new NamedAnalyzer((String) key, AnalyzerScope.INDEX, fakeDefault.analyzer()).             }              // this entrySet impl isn't fully correct but necessary as IndexAnalyzers will iterate             // over all analyzers to close them             @Override             public Set<Entry<String, NamedAnalyzer>> entrySet() {                 return Collections.emptySet().             }         }.         try (IndexAnalyzers fakeIndexAnalzyers = new IndexAnalyzers(indexSettings, fakeDefault, fakeDefault, fakeDefault, analyzerMap, analyzerMap, analyzerMap)) {             MapperService mapperService = new MapperService(indexSettings, fakeIndexAnalzyers, xContentRegistry, similarityService, mapperRegistry, () -> null).             mapperService.merge(indexMetaData, MapperService.MergeReason.MAPPING_RECOVERY).         }     } catch (Exception ex) {         // Wrap the inner exception so we have the index name in the exception message         throw new IllegalStateException("unable to upgrade the mappings for the index [" + indexMetaData.getIndex() + "]", ex).     } }
true;private;1;5;/**  * Marks index as upgraded so we don't have to test it again  */ ;/**  * Marks index as upgraded so we don't have to test it again  */ private IndexMetaData markAsUpgraded(IndexMetaData indexMetaData) {     Settings settings = Settings.builder().put(indexMetaData.getSettings()).put(IndexMetaData.SETTING_VERSION_UPGRADED, Version.CURRENT).build().     return IndexMetaData.builder(indexMetaData).settings(settings).build(). }
false;;1;14;;IndexMetaData archiveBrokenIndexSettings(IndexMetaData indexMetaData) {     final Settings settings = indexMetaData.getSettings().     final Settings upgrade = indexScopedSettings.archiveUnknownOrInvalidSettings(settings, e -> logger.warn("{} ignoring unknown index setting: [{}] with value [{}]. archiving", indexMetaData.getIndex(), e.getKey(), e.getValue()), (e, ex) -> logger.warn(() -> new ParameterizedMessage("{} ignoring invalid index setting: [{}] with value [{}]. archiving", indexMetaData.getIndex(), e.getKey(), e.getValue()), ex)).     if (upgrade != settings) {         return IndexMetaData.builder(indexMetaData).settings(upgrade).build().     } else {         return indexMetaData.     } }
