commented;modifiers;parameterAmount;loc;comment;code
true;public,static;3;15;/**  * Creates a parser based on the bytes provided  * @deprecated use {@link #createParser(NamedXContentRegistry, DeprecationHandler, BytesReference, XContentType)}  * to avoid content type auto-detection  */ ;/**  * Creates a parser based on the bytes provided  * @deprecated use {@link #createParser(NamedXContentRegistry, DeprecationHandler, BytesReference, XContentType)}  * to avoid content type auto-detection  */ @Deprecated public static XContentParser createParser(NamedXContentRegistry xContentRegistry, DeprecationHandler deprecationHandler, BytesReference bytes) throws IOException {     Compressor compressor = CompressorFactory.compressor(bytes).     if (compressor != null) {         InputStream compressedInput = compressor.streamInput(bytes.streamInput()).         if (compressedInput.markSupported() == false) {             compressedInput = new BufferedInputStream(compressedInput).         }         final XContentType contentType = XContentFactory.xContentType(compressedInput).         return XContentFactory.xContent(contentType).createParser(xContentRegistry, deprecationHandler, compressedInput).     } else {         return XContentFactory.xContent(xContentType(bytes)).createParser(xContentRegistry, deprecationHandler, bytes.streamInput()).     } }
true;public,static;4;14;/**  * Creates a parser for the bytes using the supplied content-type  */ ;/**  * Creates a parser for the bytes using the supplied content-type  */ public static XContentParser createParser(NamedXContentRegistry xContentRegistry, DeprecationHandler deprecationHandler, BytesReference bytes, XContentType xContentType) throws IOException {     Objects.requireNonNull(xContentType).     Compressor compressor = CompressorFactory.compressor(bytes).     if (compressor != null) {         InputStream compressedInput = compressor.streamInput(bytes.streamInput()).         if (compressedInput.markSupported() == false) {             compressedInput = new BufferedInputStream(compressedInput).         }         return XContentFactory.xContent(xContentType).createParser(xContentRegistry, deprecationHandler, compressedInput).     } else {         return xContentType.xContent().createParser(xContentRegistry, deprecationHandler, bytes.streamInput()).     } }
true;public,static;2;5;/**  * Converts the given bytes into a map that is optionally ordered.  * @deprecated this method relies on auto-detection of content type. Use {@link #convertToMap(BytesReference, boolean, XContentType)}  *             instead with the proper {@link XContentType}  */ ;/**  * Converts the given bytes into a map that is optionally ordered.  * @deprecated this method relies on auto-detection of content type. Use {@link #convertToMap(BytesReference, boolean, XContentType)}  *             instead with the proper {@link XContentType}  */ @Deprecated public static Tuple<XContentType, Map<String, Object>> convertToMap(BytesReference bytes, boolean ordered) throws ElasticsearchParseException {     return convertToMap(bytes, ordered, null). }
true;public,static;3;24;/**  * Converts the given bytes into a map that is optionally ordered. The provided {@link XContentType} must be non-null.  */ ;/**  * Converts the given bytes into a map that is optionally ordered. The provided {@link XContentType} must be non-null.  */ public static Tuple<XContentType, Map<String, Object>> convertToMap(BytesReference bytes, boolean ordered, XContentType xContentType) throws ElasticsearchParseException {     try {         final XContentType contentType.         InputStream input.         Compressor compressor = CompressorFactory.compressor(bytes).         if (compressor != null) {             InputStream compressedStreamInput = compressor.streamInput(bytes.streamInput()).             if (compressedStreamInput.markSupported() == false) {                 compressedStreamInput = new BufferedInputStream(compressedStreamInput).             }             input = compressedStreamInput.         } else {             input = bytes.streamInput().         }         contentType = xContentType != null ? xContentType : XContentFactory.xContentType(input).         try (InputStream stream = input) {             return new Tuple<>(Objects.requireNonNull(contentType), convertToMap(XContentFactory.xContent(contentType), stream, ordered)).         }     } catch (IOException e) {         throw new ElasticsearchParseException("Failed to parse content to map", e).     } }
true;public,static;3;9;/**  * Convert a string in some {@link XContent} format to a {@link Map}. Throws an {@link ElasticsearchParseException} if there is any  * error.  */ ;/**  * Convert a string in some {@link XContent} format to a {@link Map}. Throws an {@link ElasticsearchParseException} if there is any  * error.  */ public static Map<String, Object> convertToMap(XContent xContent, String string, boolean ordered) throws ElasticsearchParseException {     // It is safe to use EMPTY here because this never uses namedObject     try (XContentParser parser = xContent.createParser(NamedXContentRegistry.EMPTY, DeprecationHandler.THROW_UNSUPPORTED_OPERATION, string)) {         return ordered ? parser.mapOrdered() : parser.map().     } catch (IOException e) {         throw new ElasticsearchParseException("Failed to parse content to map", e).     } }
true;public,static;3;10;/**  * Convert a string in some {@link XContent} format to a {@link Map}. Throws an {@link ElasticsearchParseException} if there is any  * error. Note that unlike {@link #convertToMap(BytesReference, boolean)}, this doesn't automatically uncompress the input.  */ ;/**  * Convert a string in some {@link XContent} format to a {@link Map}. Throws an {@link ElasticsearchParseException} if there is any  * error. Note that unlike {@link #convertToMap(BytesReference, boolean)}, this doesn't automatically uncompress the input.  */ public static Map<String, Object> convertToMap(XContent xContent, InputStream input, boolean ordered) throws ElasticsearchParseException {     // It is safe to use EMPTY here because this never uses namedObject     try (XContentParser parser = xContent.createParser(NamedXContentRegistry.EMPTY, DeprecationHandler.THROW_UNSUPPORTED_OPERATION, input)) {         return ordered ? parser.mapOrdered() : parser.map().     } catch (IOException e) {         throw new ElasticsearchParseException("Failed to parse content to map", e).     } }
false;public,static;2;4;;@Deprecated public static String convertToJson(BytesReference bytes, boolean reformatJson) throws IOException {     return convertToJson(bytes, reformatJson, false). }
false;public,static;3;4;;@Deprecated public static String convertToJson(BytesReference bytes, boolean reformatJson, boolean prettyPrint) throws IOException {     return convertToJson(bytes, reformatJson, prettyPrint, XContentFactory.xContentType(bytes.toBytesRef().bytes)). }
false;public,static;3;3;;public static String convertToJson(BytesReference bytes, boolean reformatJson, XContentType xContentType) throws IOException {     return convertToJson(bytes, reformatJson, false, xContentType). }
false;public,static;4;20;;public static String convertToJson(BytesReference bytes, boolean reformatJson, boolean prettyPrint, XContentType xContentType) throws IOException {     Objects.requireNonNull(xContentType).     if (xContentType == XContentType.JSON && !reformatJson) {         return bytes.utf8ToString().     }     // It is safe to use EMPTY here because this never uses namedObject     try (InputStream stream = bytes.streamInput().         XContentParser parser = XContentFactory.xContent(xContentType).createParser(NamedXContentRegistry.EMPTY, DeprecationHandler.THROW_UNSUPPORTED_OPERATION, stream)) {         parser.nextToken().         XContentBuilder builder = XContentFactory.jsonBuilder().         if (prettyPrint) {             builder.prettyPrint().         }         builder.copyCurrentStructure(parser).         return Strings.toString(builder).     } }
true;public,static;3;29;/**  * Updates the provided changes into the source. If the key exists in the changes, it overrides the one in source  * unless both are Maps, in which case it recursively updated it.  *  * @param source                 the original map to be updated  * @param changes                the changes to update into updated  * @param checkUpdatesAreUnequal should this method check if updates to the same key (that are not both maps) are  *                               unequal?  This is just a .equals check on the objects, but that can take some time on long strings.  * @return true if the source map was modified  */ ;/**  * Updates the provided changes into the source. If the key exists in the changes, it overrides the one in source  * unless both are Maps, in which case it recursively updated it.  *  * @param source                 the original map to be updated  * @param changes                the changes to update into updated  * @param checkUpdatesAreUnequal should this method check if updates to the same key (that are not both maps) are  *                               unequal?  This is just a .equals check on the objects, but that can take some time on long strings.  * @return true if the source map was modified  */ public static boolean update(Map<String, Object> source, Map<String, Object> changes, boolean checkUpdatesAreUnequal) {     boolean modified = false.     for (Map.Entry<String, Object> changesEntry : changes.entrySet()) {         if (!source.containsKey(changesEntry.getKey())) {             // safe to copy, change does not exist in source             source.put(changesEntry.getKey(), changesEntry.getValue()).             modified = true.             continue.         }         Object old = source.get(changesEntry.getKey()).         if (old instanceof Map && changesEntry.getValue() instanceof Map) {             // recursive merge maps             modified |= update((Map<String, Object>) source.get(changesEntry.getKey()), (Map<String, Object>) changesEntry.getValue(), checkUpdatesAreUnequal && !modified).             continue.         }         // update the field         source.put(changesEntry.getKey(), changesEntry.getValue()).         if (modified) {             continue.         }         if (!checkUpdatesAreUnequal) {             modified = true.             continue.         }         modified = !Objects.equals(old, changesEntry.getValue()).     }     return modified. }
true;public,static;2;50;/**  * Merges the defaults provided as the second parameter into the content of the first. Only does recursive merge  * for inner maps.  */ ;/**  * Merges the defaults provided as the second parameter into the content of the first. Only does recursive merge  * for inner maps.  */ public static void mergeDefaults(Map<String, Object> content, Map<String, Object> defaults) {     for (Map.Entry<String, Object> defaultEntry : defaults.entrySet()) {         if (!content.containsKey(defaultEntry.getKey())) {             // copy it over, it does not exists in the content             content.put(defaultEntry.getKey(), defaultEntry.getValue()).         } else {             // in the content and in the default, only merge compound ones (maps)             if (content.get(defaultEntry.getKey()) instanceof Map && defaultEntry.getValue() instanceof Map) {                 mergeDefaults((Map<String, Object>) content.get(defaultEntry.getKey()), (Map<String, Object>) defaultEntry.getValue()).             } else if (content.get(defaultEntry.getKey()) instanceof List && defaultEntry.getValue() instanceof List) {                 List defaultList = (List) defaultEntry.getValue().                 List contentList = (List) content.get(defaultEntry.getKey()).                 List mergedList = new ArrayList().                 if (allListValuesAreMapsOfOne(defaultList) && allListValuesAreMapsOfOne(contentList)) {                     // all are in the form of [ {"key1" : {}}, {"key2" : {}} ], merge based on keys                     Map<String, Map<String, Object>> processed = new LinkedHashMap<>().                     for (Object o : contentList) {                         Map<String, Object> map = (Map<String, Object>) o.                         Map.Entry<String, Object> entry = map.entrySet().iterator().next().                         processed.put(entry.getKey(), map).                     }                     for (Object o : defaultList) {                         Map<String, Object> map = (Map<String, Object>) o.                         Map.Entry<String, Object> entry = map.entrySet().iterator().next().                         if (processed.containsKey(entry.getKey())) {                             mergeDefaults(processed.get(entry.getKey()), map).                         } else {                             // put the default entries after the content ones.                             processed.put(entry.getKey(), map).                         }                     }                     for (Map<String, Object> map : processed.values()) {                         mergedList.add(map).                     }                 } else {                     // if both are lists, simply combine them, first the defaults, then the content                     // just make sure not to add the same value twice                     mergedList.addAll(defaultList).                     for (Object o : contentList) {                         if (!mergedList.contains(o)) {                             mergedList.add(o).                         }                     }                 }                 content.put(defaultEntry.getKey(), mergedList).             }         }     } }
false;private,static;1;11;;private static boolean allListValuesAreMapsOfOne(List list) {     for (Object o : list) {         if (!(o instanceof Map)) {             return false.         }         if (((Map) o).size() != 1) {             return false.         }     }     return true. }
true;public,static;4;14;/**  * Writes a "raw" (bytes) field, handling cases where the bytes are compressed, and tries to optimize writing using  * {@link XContentBuilder#rawField(String, InputStream)}.  * @deprecated use {@link #writeRawField(String, BytesReference, XContentType, XContentBuilder, Params)} to avoid content type  * auto-detection  */ ;/**  * Writes a "raw" (bytes) field, handling cases where the bytes are compressed, and tries to optimize writing using  * {@link XContentBuilder#rawField(String, InputStream)}.  * @deprecated use {@link #writeRawField(String, BytesReference, XContentType, XContentBuilder, Params)} to avoid content type  * auto-detection  */ @Deprecated public static void writeRawField(String field, BytesReference source, XContentBuilder builder, ToXContent.Params params) throws IOException {     Compressor compressor = CompressorFactory.compressor(source).     if (compressor != null) {         try (InputStream compressedStreamInput = compressor.streamInput(source.streamInput())) {             builder.rawField(field, compressedStreamInput).         }     } else {         try (InputStream stream = source.streamInput()) {             builder.rawField(field, stream).         }     } }
true;public,static;5;14;/**  * Writes a "raw" (bytes) field, handling cases where the bytes are compressed, and tries to optimize writing using  * {@link XContentBuilder#rawField(String, InputStream, XContentType)}.  */ ;/**  * Writes a "raw" (bytes) field, handling cases where the bytes are compressed, and tries to optimize writing using  * {@link XContentBuilder#rawField(String, InputStream, XContentType)}.  */ public static void writeRawField(String field, BytesReference source, XContentType xContentType, XContentBuilder builder, ToXContent.Params params) throws IOException {     Objects.requireNonNull(xContentType).     Compressor compressor = CompressorFactory.compressor(source).     if (compressor != null) {         try (InputStream compressedStreamInput = compressor.streamInput(source.streamInput())) {             builder.rawField(field, compressedStreamInput, xContentType).         }     } else {         try (InputStream stream = source.streamInput()) {             builder.rawField(field, stream, xContentType).         }     } }
true;public,static;3;3;/**  * Returns the bytes that represent the XContent output of the provided {@link ToXContent} object, using the provided  * {@link XContentType}. Wraps the output into a new anonymous object according to the value returned  * by the {@link ToXContent#isFragment()} method returns.  */ ;/**  * Returns the bytes that represent the XContent output of the provided {@link ToXContent} object, using the provided  * {@link XContentType}. Wraps the output into a new anonymous object according to the value returned  * by the {@link ToXContent#isFragment()} method returns.  */ public static BytesReference toXContent(ToXContent toXContent, XContentType xContentType, boolean humanReadable) throws IOException {     return toXContent(toXContent, xContentType, ToXContent.EMPTY_PARAMS, humanReadable). }
true;public,static;4;14;/**  * Returns the bytes that represent the XContent output of the provided {@link ToXContent} object, using the provided  * {@link XContentType}. Wraps the output into a new anonymous object according to the value returned  * by the {@link ToXContent#isFragment()} method returns.  */ ;/**  * Returns the bytes that represent the XContent output of the provided {@link ToXContent} object, using the provided  * {@link XContentType}. Wraps the output into a new anonymous object according to the value returned  * by the {@link ToXContent#isFragment()} method returns.  */ public static BytesReference toXContent(ToXContent toXContent, XContentType xContentType, Params params, boolean humanReadable) throws IOException {     try (XContentBuilder builder = XContentBuilder.builder(xContentType.xContent())) {         builder.humanReadable(humanReadable).         if (toXContent.isFragment()) {             builder.startObject().         }         toXContent.toXContent(builder, params).         if (toXContent.isFragment()) {             builder.endObject().         }         return BytesReference.bytes(builder).     } }
true;public,static;1;5;/**  * Guesses the content type based on the provided bytes.  *  * @deprecated the content type should not be guessed except for few cases where we effectively don't know the content type.  * The REST layer should move to reading the Content-Type header instead. There are other places where auto-detection may be needed.  * This method is deprecated to prevent usages of it from spreading further without specific reasons.  */ ;/**  * Guesses the content type based on the provided bytes.  *  * @deprecated the content type should not be guessed except for few cases where we effectively don't know the content type.  * The REST layer should move to reading the Content-Type header instead. There are other places where auto-detection may be needed.  * This method is deprecated to prevent usages of it from spreading further without specific reasons.  */ @Deprecated public static XContentType xContentType(BytesReference bytes) {     BytesRef br = bytes.toBytesRef().     return XContentFactory.xContentType(br.bytes, br.offset, br.length). }
