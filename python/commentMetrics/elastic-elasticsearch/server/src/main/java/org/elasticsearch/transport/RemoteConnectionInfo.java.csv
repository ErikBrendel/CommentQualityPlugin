commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public List<String> getSeedNodes() {     return seedNodes. }
false;public;0;3;;public int getConnectionsPerCluster() {     return connectionsPerCluster. }
false;public;0;3;;public TimeValue getInitialConnectionTimeout() {     return initialConnectionTimeout. }
false;public;0;3;;public int getNumNodesConnected() {     return numNodesConnected. }
false;public;0;3;;public String getClusterAlias() {     return clusterAlias. }
false;public;0;3;;public boolean isSkipUnavailable() {     return skipUnavailable. }
false;public;1;41;;@Override public void writeTo(StreamOutput out) throws IOException {     if (out.getVersion().onOrAfter(Version.V_7_0_0)) {         out.writeStringArray(seedNodes.toArray(new String[0])).     } else {         // versions prior to 7.0.0 received the resolved transport address of the seed nodes         out.writeList(seedNodes.stream().map(s -> {             final Tuple<String, Integer> hostPort = RemoteClusterAware.parseHostPort(s).             assert hostPort.v2() != null : s.             try {                 return new TransportAddress(InetAddress.getByAddress(hostPort.v1(), TransportAddress.META_ADDRESS.getAddress()), hostPort.v2()).             } catch (final UnknownHostException e) {                 throw new AssertionError(e).             }         }).collect(Collectors.toList())).     }     if (out.getVersion().before(Version.V_7_0_0)) {         /*              * Versions before 7.0 sent the HTTP addresses of all nodes in the              * remote cluster here but it was expensive to fetch and we              * ultimately figured out how to do without it. So we removed it.              *              * When sending this request to a node that expects HTTP addresses              * here we pretend that we didn't find any. This *should* be fine              * because, after all, we haven't been using this information for              * a while.              */         out.writeList(emptyList()).     }     out.writeVInt(connectionsPerCluster).     out.writeTimeValue(initialConnectionTimeout).     out.writeVInt(numNodesConnected).     out.writeString(clusterAlias).     out.writeBoolean(skipUnavailable). }
false;public;2;18;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject(clusterAlias).     {         builder.startArray("seeds").         for (String addr : seedNodes) {             builder.value(addr).         }         builder.endArray().         builder.field("connected", numNodesConnected > 0).         builder.field("num_nodes_connected", numNodesConnected).         builder.field("max_connections_per_cluster", connectionsPerCluster).         builder.field("initial_connect_timeout", initialConnectionTimeout).         builder.field("skip_unavailable", skipUnavailable).     }     builder.endObject().     return builder. }
false;public;1;12;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     RemoteConnectionInfo that = (RemoteConnectionInfo) o.     return connectionsPerCluster == that.connectionsPerCluster && numNodesConnected == that.numNodesConnected && Objects.equals(seedNodes, that.seedNodes) && Objects.equals(initialConnectionTimeout, that.initialConnectionTimeout) && Objects.equals(clusterAlias, that.clusterAlias) && skipUnavailable == that.skipUnavailable. }
false;public;0;5;;@Override public int hashCode() {     return Objects.hash(seedNodes, connectionsPerCluster, initialConnectionTimeout, numNodesConnected, clusterAlias, skipUnavailable). }
