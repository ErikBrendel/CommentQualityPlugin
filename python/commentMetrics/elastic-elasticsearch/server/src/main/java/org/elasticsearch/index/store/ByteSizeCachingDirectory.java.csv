commented;modifiers;parameterAmount;loc;comment;code
false;private,static;1;13;;private static long estimateSizeInBytes(Directory directory) throws IOException {     long estimatedSize = 0.     String[] files = directory.listAll().     for (String file : files) {         try {             estimatedSize += directory.fileLength(file).         } catch (NoSuchFileException | FileNotFoundException | AccessDeniedException e) {         // ignore, the file is not there no more. on Windows, if one thread concurrently deletes a file while         // calling Files.size, you can also sometimes hit AccessDeniedException         }     }     return estimatedSize. }
false;protected;0;23;;@Override protected SizeAndModCount refresh() {     // It is ok for the size of the directory to be more recent than     // the mod count, we would just recompute the size of the     // directory on the next call as well. However the opposite     // would be bad as we would potentially have a stale cache     // entry for a long time. So we fetch the values of modCount and     // numOpenOutputs BEFORE computing the size of the directory.     final long modCount.     final boolean pendingWrite.     synchronized (ByteSizeCachingDirectory.this) {         modCount = ByteSizeCachingDirectory.this.modCount.         pendingWrite = ByteSizeCachingDirectory.this.numOpenOutputs != 0.     }     final long size.     try {         // Compute this OUTSIDE of the lock         size = estimateSizeInBytes(getDelegate()).     } catch (IOException e) {         throw new UncheckedIOException(e).     }     return new SizeAndModCount(size, modCount, pendingWrite). }
false;protected;0;18;;@Override protected boolean needsRefresh() {     if (super.needsRefresh() == false) {         // The size was computed recently, don't recompute         return false.     }     SizeAndModCount cached = getNoRefresh().     if (cached.pendingWrite) {         // writes, so the size might be stale: recompute.         return true.     }     synchronized (ByteSizeCachingDirectory.this) {         // written/deleted since last time: recompute         return numOpenOutputs != 0 || cached.modCount != modCount.     } }
true;;0;8;/**  * Return the cumulative size of all files in this directory.  */ ;/**  * Return the cumulative size of all files in this directory.  */ long estimateSizeInBytes() throws IOException {     try {         return size.getOrRefresh().size.     } catch (UncheckedIOException e) {         // we wrapped in the cache and unwrap here         throw e.getCause().     } }
false;public;2;4;;@Override public IndexOutput createOutput(String name, IOContext context) throws IOException {     return wrapIndexOutput(super.createOutput(name, context)). }
false;public;3;4;;@Override public IndexOutput createTempOutput(String prefix, String suffix, IOContext context) throws IOException {     return wrapIndexOutput(super.createTempOutput(prefix, suffix, context)). }
false;public;2;6;;@Override public void writeBytes(byte[] b, int length) throws IOException {     // Don't write to atomicXXX here since it might be called in     // tight loops and memory barriers are costly     super.writeBytes(b, length). }
false;public;1;6;;@Override public void writeByte(byte b) throws IOException {     // Don't write to atomicXXX here since it might be called in     // tight loops and memory barriers are costly     super.writeByte(b). }
false;public;0;13;;@Override public void close() throws IOException {     // increment the modification counter too.     try {         super.close().     } finally {         synchronized (this) {             numOpenOutputs--.             modCount++.         }     } }
false;private;1;34;;private IndexOutput wrapIndexOutput(IndexOutput out) {     synchronized (this) {         numOpenOutputs++.     }     return new FilterIndexOutput(out.toString(), out) {          @Override         public void writeBytes(byte[] b, int length) throws IOException {             // Don't write to atomicXXX here since it might be called in             // tight loops and memory barriers are costly             super.writeBytes(b, length).         }          @Override         public void writeByte(byte b) throws IOException {             // Don't write to atomicXXX here since it might be called in             // tight loops and memory barriers are costly             super.writeByte(b).         }          @Override         public void close() throws IOException {             // increment the modification counter too.             try {                 super.close().             } finally {                 synchronized (this) {                     numOpenOutputs--.                     modCount++.                 }             }         }     }. }
false;public;1;10;;@Override public void deleteFile(String name) throws IOException {     try {         super.deleteFile(name).     } finally {         synchronized (this) {             modCount++.         }     } }
