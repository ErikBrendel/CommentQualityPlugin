commented;modifiers;parameterAmount;loc;comment;code
false;public;0;10;;@Override public byte readByte() throws IOException {     if (offset >= length) {         throw new EOFException().     }     maybeNextSlice().     byte b = slice.bytes[slice.offset + (sliceIndex++)].     offset++.     return b. }
false;private;0;9;;private void maybeNextSlice() throws IOException {     while (sliceIndex == slice.length) {         slice = iterator.next().         sliceIndex = 0.         if (slice == null) {             throw new EOFException().         }     } }
false;public;3;7;;@Override public void readBytes(byte[] b, int bOffset, int len) throws IOException {     if (offset + len > length) {         throw new IndexOutOfBoundsException("Cannot read " + len + " bytes from stream with length " + length + " at offset " + offset).     }     read(b, bOffset, len). }
false;public;0;7;;@Override public int read() throws IOException {     if (offset >= length) {         return -1.     }     return Byte.toUnsignedInt(readByte()). }
false;public;3;21;;@Override public int read(final byte[] b, final int bOffset, final int len) throws IOException {     if (offset >= length) {         return -1.     }     final int numBytesToCopy = Math.min(len, length - offset).     // copy the full length or the remaining part     int remaining = numBytesToCopy.     int destOffset = bOffset.     while (remaining > 0) {         maybeNextSlice().         final int currentLen = Math.min(remaining, slice.length - sliceIndex).         assert currentLen > 0 : "length has to be > 0 to make progress but was: " + currentLen.         System.arraycopy(slice.bytes, slice.offset + sliceIndex, b, destOffset, currentLen).         destOffset += currentLen.         remaining -= currentLen.         sliceIndex += currentLen.         offset += currentLen.         assert remaining >= 0 : "remaining: " + remaining.     }     return numBytesToCopy. }
false;public;0;4;;@Override public void close() throws IOException { // do nothing }
false;public;0;4;;@Override public int available() throws IOException {     return length - offset. }
false;protected;1;7;;@Override protected void ensureCanReadBytes(int bytesToRead) throws EOFException {     int bytesAvailable = length - offset.     if (bytesAvailable < bytesToRead) {         throw new EOFException("tried to read: " + bytesToRead + " bytes but only " + bytesAvailable + " remaining").     } }
false;public;1;15;;@Override public long skip(long n) throws IOException {     final int skip = (int) Math.min(Integer.MAX_VALUE, n).     final int numBytesSkipped = Math.min(skip, length - offset).     int remaining = numBytesSkipped.     while (remaining > 0) {         maybeNextSlice().         int currentLen = Math.min(remaining, slice.length - sliceIndex).         remaining -= currentLen.         sliceIndex += currentLen.         offset += currentLen.         assert remaining >= 0 : "remaining: " + remaining.     }     return numBytesSkipped. }
false;;0;3;;int getOffset() {     return offset. }
