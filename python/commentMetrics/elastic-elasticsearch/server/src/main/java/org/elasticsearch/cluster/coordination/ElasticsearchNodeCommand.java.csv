commented;modifiers;parameterAmount;loc;comment;code
false;protected;3;18;;protected void processNodePathsWithLock(Terminal terminal, OptionSet options, Environment env) throws IOException {     terminal.println(Terminal.Verbosity.VERBOSE, "Obtaining lock for node").     Integer nodeOrdinal = nodeOrdinalOption.value(options).     if (nodeOrdinal == null) {         nodeOrdinal = 0.     }     try (NodeEnvironment.NodeLock lock = new NodeEnvironment.NodeLock(nodeOrdinal, logger, env, Files::exists)) {         final Path[] dataPaths = Arrays.stream(lock.getNodePaths()).filter(Objects::nonNull).map(p -> p.path).toArray(Path[]::new).         if (dataPaths.length == 0) {             throw new ElasticsearchException(NO_NODE_FOLDER_FOUND_MSG).         }         processNodePaths(terminal, dataPaths).     } catch (LockObtainFailedException ex) {         throw new ElasticsearchException(FAILED_TO_OBTAIN_NODE_LOCK_MSG + " [" + ex.getMessage() + "]").     } }
false;protected;2;19;;protected Tuple<Manifest, MetaData> loadMetaData(Terminal terminal, Path[] dataPaths) throws IOException {     terminal.println(Terminal.Verbosity.VERBOSE, "Loading manifest file").     final Manifest manifest = Manifest.FORMAT.loadLatestState(logger, namedXContentRegistry, dataPaths).     if (manifest == null) {         throw new ElasticsearchException(NO_MANIFEST_FILE_FOUND_MSG).     }     if (manifest.isGlobalGenerationMissing()) {         throw new ElasticsearchException(GLOBAL_GENERATION_MISSING_MSG).     }     terminal.println(Terminal.Verbosity.VERBOSE, "Loading global metadata file").     final MetaData metaData = MetaData.FORMAT.loadGeneration(logger, namedXContentRegistry, manifest.getGlobalGeneration(), dataPaths).     if (metaData == null) {         throw new ElasticsearchException(NO_GLOBAL_METADATA_MSG + " [generation = " + manifest.getGlobalGeneration() + "]").     }     return Tuple.tuple(manifest, metaData). }
false;protected;2;7;;protected void confirm(Terminal terminal, String msg) {     terminal.println(msg).     String text = terminal.readText("Confirm [y/N] ").     if (text.equalsIgnoreCase("y") == false) {         throw new ElasticsearchException(ABORTED_BY_USER_MSG).     } }
false;protected;3;4;;@Override protected void execute(Terminal terminal, OptionSet options, Environment env) throws Exception {     terminal.println(STOP_WARNING_MSG). }
false;protected,abstract;2;1;;protected abstract void processNodePaths(Terminal terminal, Path[] dataPaths) throws IOException.
false;protected;6;22;;protected void writeNewMetaData(Terminal terminal, Manifest oldManifest, long newCurrentTerm, MetaData oldMetaData, MetaData newMetaData, Path[] dataPaths) {     try {         terminal.println(Terminal.Verbosity.VERBOSE, "[clusterUUID = " + oldMetaData.clusterUUID() + ", committed = " + oldMetaData.clusterUUIDCommitted() + "] => " + "[clusterUUID = " + newMetaData.clusterUUID() + ", committed = " + newMetaData.clusterUUIDCommitted() + "]").         terminal.println(Terminal.Verbosity.VERBOSE, "New coordination metadata is " + newMetaData.coordinationMetaData()).         terminal.println(Terminal.Verbosity.VERBOSE, "Writing new global metadata to disk").         long newGeneration = MetaData.FORMAT.write(newMetaData, dataPaths).         Manifest newManifest = new Manifest(newCurrentTerm, oldManifest.getClusterStateVersion(), newGeneration, oldManifest.getIndexGenerations()).         terminal.println(Terminal.Verbosity.VERBOSE, "New manifest is " + newManifest).         terminal.println(Terminal.Verbosity.VERBOSE, "Writing new manifest file to disk").         Manifest.FORMAT.writeAndCleanup(newManifest, dataPaths).         terminal.println(Terminal.Verbosity.VERBOSE, "Cleaning up old metadata").         MetaData.FORMAT.cleanupOldFiles(newGeneration, dataPaths).     } catch (Exception e) {         terminal.println(Terminal.Verbosity.VERBOSE, "Cleaning up new metadata").         MetaData.FORMAT.cleanupOldFiles(oldManifest.getGlobalGeneration(), dataPaths).         throw new ElasticsearchException(WRITE_METADATA_EXCEPTION_MSG, e).     } }
true;;0;3;// package-private for testing ;// package-private for testing OptionParser getParser() {     return parser. }
