commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public Set<ClusterBlock> global() {     return global. }
false;public;0;3;;public ImmutableOpenMap<String, Set<ClusterBlock>> indices() {     return indicesBlocks. }
false;public;1;3;;public Set<ClusterBlock> global(ClusterBlockLevel level) {     return levelHolders.get(level).global(). }
false;public;1;3;;public ImmutableOpenMap<String, Set<ClusterBlock>> indices(ClusterBlockLevel level) {     return levelHolders.get(level).indices(). }
false;private;2;3;;private Set<ClusterBlock> blocksForIndex(ClusterBlockLevel level, String index) {     return indices(level).getOrDefault(index, emptySet()). }
false;private,static;2;19;;private static EnumMap<ClusterBlockLevel, ImmutableLevelHolder> generateLevelHolders(Set<ClusterBlock> global, ImmutableOpenMap<String, Set<ClusterBlock>> indicesBlocks) {     EnumMap<ClusterBlockLevel, ImmutableLevelHolder> levelHolders = new EnumMap<>(ClusterBlockLevel.class).     for (final ClusterBlockLevel level : ClusterBlockLevel.values()) {         Predicate<ClusterBlock> containsLevel = block -> block.contains(level).         Set<ClusterBlock> newGlobal = unmodifiableSet(global.stream().filter(containsLevel).collect(toSet())).         ImmutableOpenMap.Builder<String, Set<ClusterBlock>> indicesBuilder = ImmutableOpenMap.builder().         for (ObjectObjectCursor<String, Set<ClusterBlock>> entry : indicesBlocks) {             indicesBuilder.put(entry.key, unmodifiableSet(entry.value.stream().filter(containsLevel).collect(toSet()))).         }         levelHolders.put(level, new ImmutableLevelHolder(newGlobal, indicesBuilder.build())).     }     return levelHolders. }
true;public;0;8;/**  * Returns {@code true} if one of the global blocks as its disable state persistence flag set.  */ ;/**  * Returns {@code true} if one of the global blocks as its disable state persistence flag set.  */ public boolean disableStatePersistence() {     for (ClusterBlock clusterBlock : global) {         if (clusterBlock.disableStatePersistence()) {             return true.         }     }     return false. }
false;public;1;3;;public boolean hasGlobalBlock(ClusterBlock block) {     return global.contains(block). }
false;public;1;8;;public boolean hasGlobalBlockWithId(final int blockId) {     for (ClusterBlock clusterBlock : global) {         if (clusterBlock.id() == blockId) {             return true.         }     }     return false. }
false;public;1;3;;public boolean hasGlobalBlockWithLevel(ClusterBlockLevel level) {     return global(level).size() > 0. }
true;public;1;8;/**  * Is there a global block with the provided status?  */ ;/**  * Is there a global block with the provided status?  */ public boolean hasGlobalBlockWithStatus(final RestStatus status) {     for (ClusterBlock clusterBlock : global) {         if (clusterBlock.status().equals(status)) {             return true.         }     }     return false. }
false;public;2;3;;public boolean hasIndexBlock(String index, ClusterBlock block) {     return indicesBlocks.containsKey(index) && indicesBlocks.get(index).contains(block). }
false;public;2;11;;public boolean hasIndexBlockWithId(String index, int blockId) {     final Set<ClusterBlock> clusterBlocks = indicesBlocks.get(index).     if (clusterBlocks != null) {         for (ClusterBlock clusterBlock : clusterBlocks) {             if (clusterBlock.id() == blockId) {                 return true.             }         }     }     return false. }
false;public;2;12;;@Nullable public ClusterBlock getIndexBlockWithId(final String index, final int blockId) {     final Set<ClusterBlock> clusterBlocks = indicesBlocks.get(index).     if (clusterBlocks != null) {         for (ClusterBlock clusterBlock : clusterBlocks) {             if (clusterBlock.id() == blockId) {                 return clusterBlock.             }         }     }     return null. }
false;public;1;6;;public void globalBlockedRaiseException(ClusterBlockLevel level) throws ClusterBlockException {     ClusterBlockException blockException = globalBlockedException(level).     if (blockException != null) {         throw blockException.     } }
false;private;1;3;;private boolean globalBlocked(ClusterBlockLevel level) {     return global(level).isEmpty() == false. }
false;public;1;6;;public ClusterBlockException globalBlockedException(ClusterBlockLevel level) {     if (globalBlocked(level) == false) {         return null.     }     return new ClusterBlockException(global(level)). }
false;public;2;6;;public void indexBlockedRaiseException(ClusterBlockLevel level, String index) throws ClusterBlockException {     ClusterBlockException blockException = indexBlockedException(level, index).     if (blockException != null) {         throw blockException.     } }
false;public;2;9;;public ClusterBlockException indexBlockedException(ClusterBlockLevel level, String index) {     if (!indexBlocked(level, index)) {         return null.     }     Stream<ClusterBlock> blocks = concat(global(level).stream(), blocksForIndex(level, index).stream()).     return new ClusterBlockException(unmodifiableSet(blocks.collect(toSet()))). }
false;public;2;3;;public boolean indexBlocked(ClusterBlockLevel level, String index) {     return globalBlocked(level) || blocksForIndex(level, index).isEmpty() == false. }
false;public;2;16;;public ClusterBlockException indicesBlockedException(ClusterBlockLevel level, String[] indices) {     boolean indexIsBlocked = false.     for (String index : indices) {         if (indexBlocked(level, index)) {             indexIsBlocked = true.         }     }     if (globalBlocked(level) == false && indexIsBlocked == false) {         return null.     }     Function<String, Stream<ClusterBlock>> blocksForIndexAtLevel = index -> blocksForIndex(level, index).stream().     Stream<ClusterBlock> blocks = concat(global(level).stream(), Stream.of(indices).flatMap(blocksForIndexAtLevel)).     return new ClusterBlockException(unmodifiableSet(blocks.collect(toSet()))). }
true;public;1;12;/**  * Returns <code>true</code> iff non of the given have a {@link ClusterBlockLevel#METADATA_WRITE} in place where the  * {@link ClusterBlock#isAllowReleaseResources()} returns <code>false</code>. This is used in places where resources will be released  * like the deletion of an index to free up resources on nodes.  * @param indices the indices to check  */ ;/**  * Returns <code>true</code> iff non of the given have a {@link ClusterBlockLevel#METADATA_WRITE} in place where the  * {@link ClusterBlock#isAllowReleaseResources()} returns <code>false</code>. This is used in places where resources will be released  * like the deletion of an index to free up resources on nodes.  * @param indices the indices to check  */ public ClusterBlockException indicesAllowReleaseResources(String[] indices) {     final Function<String, Stream<ClusterBlock>> blocksForIndexAtLevel = index -> blocksForIndex(ClusterBlockLevel.METADATA_WRITE, index).stream().     Stream<ClusterBlock> blocks = concat(global(ClusterBlockLevel.METADATA_WRITE).stream(), Stream.of(indices).flatMap(blocksForIndexAtLevel)).filter(clusterBlock -> clusterBlock.isAllowReleaseResources() == false).     Set<ClusterBlock> clusterBlocks = unmodifiableSet(blocks.collect(toSet())).     if (clusterBlocks.isEmpty()) {         return null.     }     return new ClusterBlockException(clusterBlocks). }
false;public;0;22;;@Override public String toString() {     if (global.isEmpty() && indices().isEmpty()) {         return "".     }     StringBuilder sb = new StringBuilder().     sb.append("blocks: \n").     if (global.isEmpty() == false) {         sb.append("   _global_:\n").         for (ClusterBlock block : global) {             sb.append("      ").append(block).         }     }     for (ObjectObjectCursor<String, Set<ClusterBlock>> entry : indices()) {         sb.append("   ").append(entry.key).append(":\n").         for (ClusterBlock block : entry.value) {             sb.append("      ").append(block).         }     }     sb.append("\n").     return sb.toString(). }
false;public;1;9;;@Override public void writeTo(StreamOutput out) throws IOException {     writeBlockSet(global, out).     out.writeVInt(indicesBlocks.size()).     for (ObjectObjectCursor<String, Set<ClusterBlock>> entry : indicesBlocks) {         out.writeString(entry.key).         writeBlockSet(entry.value, out).     } }
false;private,static;2;6;;private static void writeBlockSet(Set<ClusterBlock> blocks, StreamOutput out) throws IOException {     out.writeVInt(blocks.size()).     for (ClusterBlock block : blocks) {         block.writeTo(out).     } }
false;private,static;1;8;;private static Set<ClusterBlock> readBlockSet(StreamInput in) throws IOException {     int totalBlocks = in.readVInt().     Set<ClusterBlock> blocks = new HashSet<>(totalBlocks).     for (int i = 0. i < totalBlocks. i++) {         blocks.add(new ClusterBlock(in)).     }     return unmodifiableSet(blocks). }
false;public,static;1;3;;public static Diff<ClusterBlocks> readDiffFrom(StreamInput in) throws IOException {     return AbstractDiffable.readDiffFrom(ClusterBlocks::new, in). }
false;public;0;3;;public Set<ClusterBlock> global() {     return global. }
false;public;0;3;;public ImmutableOpenMap<String, Set<ClusterBlock>> indices() {     return indices. }
false;public,static;0;3;;public static Builder builder() {     return new Builder(). }
false;public;1;10;;public Builder blocks(ClusterBlocks blocks) {     global.addAll(blocks.global()).     for (ObjectObjectCursor<String, Set<ClusterBlock>> entry : blocks.indices()) {         if (!indices.containsKey(entry.key)) {             indices.put(entry.key, new HashSet<>()).         }         indices.get(entry.key).addAll(entry.value).     }     return this. }
false;public;1;22;;public Builder addBlocks(IndexMetaData indexMetaData) {     String indexName = indexMetaData.getIndex().getName().     if (indexMetaData.getState() == IndexMetaData.State.CLOSE) {         addIndexBlock(indexName, MetaDataIndexStateService.INDEX_CLOSED_BLOCK).     }     if (IndexMetaData.INDEX_READ_ONLY_SETTING.get(indexMetaData.getSettings())) {         addIndexBlock(indexName, IndexMetaData.INDEX_READ_ONLY_BLOCK).     }     if (IndexMetaData.INDEX_BLOCKS_READ_SETTING.get(indexMetaData.getSettings())) {         addIndexBlock(indexName, IndexMetaData.INDEX_READ_BLOCK).     }     if (IndexMetaData.INDEX_BLOCKS_WRITE_SETTING.get(indexMetaData.getSettings())) {         addIndexBlock(indexName, IndexMetaData.INDEX_WRITE_BLOCK).     }     if (IndexMetaData.INDEX_BLOCKS_METADATA_SETTING.get(indexMetaData.getSettings())) {         addIndexBlock(indexName, IndexMetaData.INDEX_METADATA_BLOCK).     }     if (IndexMetaData.INDEX_BLOCKS_READ_ONLY_ALLOW_DELETE_SETTING.get(indexMetaData.getSettings())) {         addIndexBlock(indexName, IndexMetaData.INDEX_READ_ONLY_ALLOW_DELETE_BLOCK).     }     return this. }
false;public;1;5;;public Builder updateBlocks(IndexMetaData indexMetaData) {     // let's remove all blocks for this index and add them back -- no need to remove all individual blocks....     indices.remove(indexMetaData.getIndex().getName()).     return addBlocks(indexMetaData). }
false;public;1;4;;public Builder addGlobalBlock(ClusterBlock block) {     global.add(block).     return this. }
false;public;1;4;;public Builder removeGlobalBlock(ClusterBlock block) {     global.remove(block).     return this. }
false;public;1;4;;public Builder removeGlobalBlock(int blockId) {     global.removeIf(block -> block.id() == blockId).     return this. }
false;public;2;7;;public Builder addIndexBlock(String index, ClusterBlock block) {     if (!indices.containsKey(index)) {         indices.put(index, new HashSet<>()).     }     indices.get(index).add(block).     return this. }
false;public;1;7;;public Builder removeIndexBlocks(String index) {     if (!indices.containsKey(index)) {         return this.     }     indices.remove(index).     return this. }
false;public;2;10;;public Builder removeIndexBlock(String index, ClusterBlock block) {     if (!indices.containsKey(index)) {         return this.     }     indices.get(index).remove(block).     if (indices.get(index).isEmpty()) {         indices.remove(index).     }     return this. }
false;public;2;11;;public Builder removeIndexBlockWithId(String index, int blockId) {     final Set<ClusterBlock> indexBlocks = indices.get(index).     if (indexBlocks == null) {         return this.     }     indexBlocks.removeIf(block -> block.id() == blockId).     if (indexBlocks.isEmpty()) {         indices.remove(index).     }     return this. }
false;public;0;8;;public ClusterBlocks build() {     // We copy the block sets here in case of the builder is modified after build is called     ImmutableOpenMap.Builder<String, Set<ClusterBlock>> indicesBuilder = ImmutableOpenMap.builder(indices.size()).     for (Map.Entry<String, Set<ClusterBlock>> entry : indices.entrySet()) {         indicesBuilder.put(entry.getKey(), unmodifiableSet(new HashSet<>(entry.getValue()))).     }     return new ClusterBlocks(unmodifiableSet(new HashSet<>(global)), indicesBuilder.build()). }
