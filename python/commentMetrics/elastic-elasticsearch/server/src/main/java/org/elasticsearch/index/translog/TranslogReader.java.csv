commented;modifiers;parameterAmount;loc;comment;code
true;public,static;4;5;/**  * Given a file channel, opens a {@link TranslogReader}, taking care of checking and validating the file header.  *  * @param channel the translog file channel  * @param path the path to the translog  * @param checkpoint the translog checkpoint  * @param translogUUID the tranlog UUID  * @return a new TranslogReader  * @throws IOException if any of the file operations resulted in an I/O exception  */ ;/**  * Given a file channel, opens a {@link TranslogReader}, taking care of checking and validating the file header.  *  * @param channel the translog file channel  * @param path the path to the translog  * @param checkpoint the translog checkpoint  * @param translogUUID the tranlog UUID  * @return a new TranslogReader  * @throws IOException if any of the file operations resulted in an I/O exception  */ public static TranslogReader open(final FileChannel channel, final Path path, final Checkpoint checkpoint, final String translogUUID) throws IOException {     final TranslogHeader header = TranslogHeader.read(translogUUID, path, channel).     return new TranslogReader(checkpoint, channel, path, header). }
true;;2;29;/**  * Closes current reader and creates new one with new checkoint and same file channel  */ ;/**  * Closes current reader and creates new one with new checkoint and same file channel  */ TranslogReader closeIntoTrimmedReader(long aboveSeqNo, ChannelFactory channelFactory) throws IOException {     if (closed.compareAndSet(false, true)) {         Closeable toCloseOnFailure = channel.         final TranslogReader newReader.         try {             if (aboveSeqNo < checkpoint.trimmedAboveSeqNo || aboveSeqNo < checkpoint.maxSeqNo && checkpoint.trimmedAboveSeqNo == SequenceNumbers.UNASSIGNED_SEQ_NO) {                 final Path checkpointFile = path.getParent().resolve(getCommitCheckpointFileName(checkpoint.generation)).                 final Checkpoint newCheckpoint = new Checkpoint(checkpoint.offset, checkpoint.numOps, checkpoint.generation, checkpoint.minSeqNo, checkpoint.maxSeqNo, checkpoint.globalCheckpoint, checkpoint.minTranslogGeneration, aboveSeqNo).                 Checkpoint.write(channelFactory, checkpointFile, newCheckpoint, StandardOpenOption.WRITE).                 IOUtils.fsync(checkpointFile, false).                 IOUtils.fsync(checkpointFile.getParent(), true).                 newReader = new TranslogReader(newCheckpoint, channel, path, header).             } else {                 newReader = new TranslogReader(checkpoint, channel, path, header).             }             toCloseOnFailure = null.             return newReader.         } finally {             IOUtils.close(toCloseOnFailure).         }     } else {         throw new AlreadyClosedException(toString() + " is already closed").     } }
false;public;0;3;;public long sizeInBytes() {     return length. }
false;public;0;3;;public int totalOperations() {     return totalOperations. }
false;final;0;4;;@Override final Checkpoint getCheckpoint() {     return checkpoint. }
true;protected;2;10;/**  * reads an operation at the given position into the given buffer.  */ ;/**  * reads an operation at the given position into the given buffer.  */ protected void readBytes(ByteBuffer buffer, long position) throws IOException {     if (position >= length) {         throw new EOFException("read requested past EOF. pos [" + position + "] end: [" + length + "]").     }     if (position < getFirstOperationOffset()) {         throw new IOException("read requested before position of first ops. pos [" + position + "] first op on: [" + getFirstOperationOffset() + "]").     }     Channels.readFromFileChannelWithEofException(channel, position, buffer). }
false;public,final;0;6;;@Override public final void close() throws IOException {     if (closed.compareAndSet(false, true)) {         channel.close().     } }
false;protected,final;0;3;;protected final boolean isClosed() {     return closed.get(). }
false;protected;0;5;;protected void ensureOpen() {     if (isClosed()) {         throw new AlreadyClosedException(toString() + " is already closed").     } }
