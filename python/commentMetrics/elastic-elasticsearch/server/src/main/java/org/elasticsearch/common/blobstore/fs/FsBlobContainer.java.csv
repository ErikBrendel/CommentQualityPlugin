commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public Map<String, BlobMetaData> listBlobs() throws IOException {     return listBlobsByPrefix(null). }
false;public;1;16;;@Override public Map<String, BlobMetaData> listBlobsByPrefix(String blobNamePrefix) throws IOException {     // If we get duplicate files we should just take the last entry     Map<String, BlobMetaData> builder = new HashMap<>().     blobNamePrefix = blobNamePrefix == null ? "" : blobNamePrefix.     try (DirectoryStream<Path> stream = Files.newDirectoryStream(path, blobNamePrefix + "*")) {         for (Path file : stream) {             final BasicFileAttributes attrs = Files.readAttributes(file, BasicFileAttributes.class).             if (attrs.isRegularFile()) {                 builder.put(file.getFileName().toString(), new PlainBlobMetaData(file.getFileName().toString(), attrs.size())).             }         }     }     return unmodifiableMap(builder). }
false;public;2;5;;@Override public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {     Files.delete(dir).     return FileVisitResult.CONTINUE. }
false;public;1;17;;@Override public void deleteBlob(String blobName) throws IOException {     Path blobPath = path.resolve(blobName).     if (Files.isDirectory(blobPath)) {         // delete directory recursively as long as it is empty (only contains empty directories),         // which is the reason we aren't deleting any files, only the directories on the post-visit         Files.walkFileTree(blobPath, new SimpleFileVisitor<Path>() {              @Override             public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {                 Files.delete(dir).                 return FileVisitResult.CONTINUE.             }         }).     } else {         Files.delete(blobPath).     } }
false;public;1;4;;@Override public boolean blobExists(String blobName) {     return Files.exists(path.resolve(blobName)). }
false;public;1;9;;@Override public InputStream readBlob(String name) throws IOException {     final Path resolvedPath = path.resolve(name).     try {         return new BufferedInputStream(Files.newInputStream(resolvedPath), blobStore.bufferSizeInBytes()).     } catch (FileNotFoundException fnfe) {         throw new NoSuchFileException("[" + name + "] blob not found").     } }
false;public;4;12;;@Override public void writeBlob(String blobName, InputStream inputStream, long blobSize, boolean failIfAlreadyExists) throws IOException {     if (failIfAlreadyExists == false) {         deleteBlobIgnoringIfNotExists(blobName).     }     final Path file = path.resolve(blobName).     try (OutputStream outputStream = Files.newOutputStream(file, StandardOpenOption.CREATE_NEW)) {         Streams.copy(inputStream, outputStream).     }     IOUtils.fsync(file, false).     IOUtils.fsync(path, true). }
false;public;4;22;;@Override public void writeBlobAtomic(final String blobName, final InputStream inputStream, final long blobSize, boolean failIfAlreadyExists) throws IOException {     final String tempBlob = tempBlobName(blobName).     final Path tempBlobPath = path.resolve(tempBlob).     try {         try (OutputStream outputStream = Files.newOutputStream(tempBlobPath, StandardOpenOption.CREATE_NEW)) {             Streams.copy(inputStream, outputStream).         }         IOUtils.fsync(tempBlobPath, false).         moveBlobAtomic(tempBlob, blobName, failIfAlreadyExists).     } catch (IOException ex) {         try {             deleteBlobIgnoringIfNotExists(tempBlob).         } catch (IOException e) {             ex.addSuppressed(e).         }         throw ex.     } finally {         IOUtils.fsync(path, true).     } }
false;public;3;15;;public void moveBlobAtomic(final String sourceBlobName, final String targetBlobName, final boolean failIfAlreadyExists) throws IOException {     final Path sourceBlobPath = path.resolve(sourceBlobName).     final Path targetBlobPath = path.resolve(targetBlobName).     // the existing file might be replaced or this method fails by throwing an IOException.     if (Files.exists(targetBlobPath)) {         if (failIfAlreadyExists) {             throw new FileAlreadyExistsException("blob [" + targetBlobPath + "] already exists, cannot overwrite").         } else {             deleteBlobIgnoringIfNotExists(targetBlobName).         }     }     Files.move(sourceBlobPath, targetBlobPath, StandardCopyOption.ATOMIC_MOVE). }
false;public,static;1;3;;public static String tempBlobName(final String blobName) {     return "pending-" + blobName + "-" + UUIDs.randomBase64UUID(). }
true;public,static;1;3;/**  * Returns true if the blob is a leftover temporary blob.  *  * The temporary blobs might be left after failed atomic write operation.  */ ;/**  * Returns true if the blob is a leftover temporary blob.  *  * The temporary blobs might be left after failed atomic write operation.  */ public static boolean isTempBlobName(final String blobName) {     return blobName.startsWith(TEMP_FILE_PREFIX). }
