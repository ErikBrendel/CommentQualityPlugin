commented;modifiers;parameterAmount;loc;comment;code
false;public;1;7;;public void setTrackedNodes(final Iterable<DiscoveryNode> discoveryNodes) {     final Set<DiscoveryNode> discoveryNodeSet = new HashSet<>().     discoveryNodes.forEach(discoveryNodeSet::add).     discoveryNodeSet.remove(localNodeSupplier.get()).     appliedStateTrackersByNode.keySet().retainAll(discoveryNodeSet).     discoveryNodeSet.forEach(node -> appliedStateTrackersByNode.putIfAbsent(node, new NodeAppliedStateTracker(node))). }
false;public;0;3;;public void clearTrackedNodes() {     appliedStateTrackersByNode.clear(). }
false;public;2;9;;public void setAppliedVersion(final DiscoveryNode discoveryNode, final long appliedVersion) {     final NodeAppliedStateTracker nodeAppliedStateTracker = appliedStateTrackersByNode.get(discoveryNode).     if (nodeAppliedStateTracker == null) {         // Received an ack from a node that a later publication has removed (or we are no longer master). No big deal.         logger.trace("node {} applied version {} but this node's version is not being tracked", discoveryNode, appliedVersion).     } else {         nodeAppliedStateTracker.increaseAppliedVersion(appliedVersion).     } }
false;public;0;4;;@Override public void run() {     laggingTrackers.forEach(t -> t.checkForLag(version)). }
false;public;0;4;;@Override public String toString() {     return "lag detector for version " + version + " on " + laggingTrackers. }
false;public;1;22;;public void startLagDetector(final long version) {     final List<NodeAppliedStateTracker> laggingTrackers = appliedStateTrackersByNode.values().stream().filter(t -> t.appliedVersionLessThan(version)).collect(Collectors.toList()).     if (laggingTrackers.isEmpty()) {         logger.trace("lag detection for version {} is unnecessary: {}", version, appliedStateTrackersByNode.values()).     } else {         logger.debug("starting lag detector for version {}: {}", version, laggingTrackers).         threadPool.scheduleUnlessShuttingDown(clusterStateApplicationTimeout, Names.GENERIC, new Runnable() {              @Override             public void run() {                 laggingTrackers.forEach(t -> t.checkForLag(version)).             }              @Override             public String toString() {                 return "lag detector for version " + version + " on " + laggingTrackers.             }         }).     } }
false;public;0;7;;@Override public String toString() {     return "LagDetector{" + "clusterStateApplicationTimeout=" + clusterStateApplicationTimeout + ", appliedStateTrackersByNode=" + appliedStateTrackersByNode.values() + '}'. }
true;;0;3;// for assertions ;// for assertions Set<DiscoveryNode> getTrackedNodes() {     return Collections.unmodifiableSet(appliedStateTrackersByNode.keySet()). }
false;;1;4;;void increaseAppliedVersion(long appliedVersion) {     long maxAppliedVersion = this.appliedVersion.updateAndGet(v -> Math.max(v, appliedVersion)).     logger.trace("{} applied version {}, max now {}", this, appliedVersion, maxAppliedVersion). }
false;;1;3;;boolean appliedVersionLessThan(final long version) {     return appliedVersion.get() < version. }
false;public;0;7;;@Override public String toString() {     return "NodeAppliedStateTracker{" + "discoveryNode=" + discoveryNode + ", appliedVersion=" + appliedVersion + '}'. }
false;;1;15;;void checkForLag(final long version) {     if (appliedStateTrackersByNode.get(discoveryNode) != this) {         logger.trace("{} no longer active when checking version {}", this, version).         return.     }     long appliedVersion = this.appliedVersion.get().     if (version <= appliedVersion) {         logger.trace("{} satisfied when checking version {}, node applied version {}", this, version, appliedVersion).         return.     }     logger.debug("{}, detected lag at version {}, node has only applied version {}", this, version, appliedVersion).     onLagDetected.accept(discoveryNode). }
