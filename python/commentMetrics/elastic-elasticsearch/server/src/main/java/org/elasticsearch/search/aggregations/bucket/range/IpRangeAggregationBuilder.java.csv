commented;modifiers;parameterAmount;loc;comment;code
false;public,static;2;3;;public static AggregationBuilder parse(String aggregationName, XContentParser parser) throws IOException {     return PARSER.parse(parser, new IpRangeAggregationBuilder(aggregationName), null). }
false;private,static;1;34;;private static Range parseRange(XContentParser parser) throws IOException {     String key = null.     String from = null.     String to = null.     String mask = null.     if (parser.currentToken() != Token.START_OBJECT) {         throw new ParsingException(parser.getTokenLocation(), "[ranges] must contain objects, but hit a " + parser.currentToken()).     }     while (parser.nextToken() != Token.END_OBJECT) {         if (parser.currentToken() == Token.FIELD_NAME) {             continue.         }         if (RangeAggregator.Range.KEY_FIELD.match(parser.currentName(), parser.getDeprecationHandler())) {             key = parser.text().         } else if (RangeAggregator.Range.FROM_FIELD.match(parser.currentName(), parser.getDeprecationHandler())) {             from = parser.textOrNull().         } else if (RangeAggregator.Range.TO_FIELD.match(parser.currentName(), parser.getDeprecationHandler())) {             to = parser.textOrNull().         } else if (MASK_FIELD.match(parser.currentName(), parser.getDeprecationHandler())) {             mask = parser.text().         } else {             throw new ParsingException(parser.getTokenLocation(), "Unexpected ip range parameter: [" + parser.currentName() + "]").         }     }     if (mask != null) {         if (key == null) {             key = mask.         }         return new Range(key, mask).     } else {         return new Range(key, from, to).     } }
false;;1;5;;void writeTo(StreamOutput out) throws IOException {     out.writeOptionalString(key).     out.writeOptionalString(from).     out.writeOptionalString(to). }
false;public;0;3;;public String getKey() {     return key. }
false;public;0;3;;public String getFrom() {     return from. }
false;public;0;3;;public String getTo() {     return to. }
false;public;1;10;;@Override public boolean equals(Object obj) {     if (obj == null || getClass() != obj.getClass()) {         return false.     }     Range that = (Range) obj.     return Objects.equals(key, that.key) && Objects.equals(from, that.from) && Objects.equals(to, that.to). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(getClass(), key, from, to). }
false;public;2;15;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     if (key != null) {         builder.field(RangeAggregator.Range.KEY_FIELD.getPreferredName(), key).     }     if (from != null) {         builder.field(RangeAggregator.Range.FROM_FIELD.getPreferredName(), from).     }     if (to != null) {         builder.field(RangeAggregator.Range.TO_FIELD.getPreferredName(), to).     }     builder.endObject().     return builder. }
false;protected;2;4;;@Override protected AggregationBuilder shallowCopy(Builder factoriesBuilder, Map<String, Object> metaData) {     return new IpRangeAggregationBuilder(this, factoriesBuilder, metaData). }
false;public;0;4;;@Override public String getType() {     return NAME. }
false;public;1;4;;public IpRangeAggregationBuilder keyed(boolean keyed) {     this.keyed = keyed.     return this. }
false;public;0;3;;public boolean keyed() {     return keyed. }
true;public;0;3;/**  * Get the current list or ranges that are configured on this aggregation.  */ ;/**  * Get the current list or ranges that are configured on this aggregation.  */ public List<Range> getRanges() {     return Collections.unmodifiableList(ranges). }
true;public;1;4;/**  * Add a new {@link Range} to this aggregation.  */ ;/**  * Add a new {@link Range} to this aggregation.  */ public IpRangeAggregationBuilder addRange(Range range) {     ranges.add(range).     return this. }
true;public;3;4;/**  * Add a new range to this aggregation.  *  * @param key  *            the key to use for this range in the response  * @param from  *            the lower bound on the distances, inclusive  * @param to  *            the upper bound on the distances, exclusive  */ ;/**  * Add a new range to this aggregation.  *  * @param key  *            the key to use for this range in the response  * @param from  *            the lower bound on the distances, inclusive  * @param to  *            the upper bound on the distances, exclusive  */ public IpRangeAggregationBuilder addRange(String key, String from, String to) {     addRange(new Range(key, from, to)).     return this. }
true;public;2;3;/**  * Add a new range to this aggregation using the CIDR notation.  */ ;/**  * Add a new range to this aggregation using the CIDR notation.  */ public IpRangeAggregationBuilder addMaskRange(String key, String mask) {     return addRange(new Range(key, mask)). }
true;public;1;3;/**  * Same as {@link #addMaskRange(String, String)} but uses the mask itself as  * a key.  */ ;/**  * Same as {@link #addMaskRange(String, String)} but uses the mask itself as  * a key.  */ public IpRangeAggregationBuilder addMaskRange(String mask) {     return addRange(new Range(mask, mask)). }
true;public;2;3;/**  * Same as {@link #addRange(String, String, String)} but the key will be  * automatically generated.  */ ;/**  * Same as {@link #addRange(String, String, String)} but the key will be  * automatically generated.  */ public IpRangeAggregationBuilder addRange(String from, String to) {     return addRange(null, from, to). }
true;public;2;4;/**  * Same as {@link #addRange(String, String, String)} but there will be no  * lower bound.  */ ;/**  * Same as {@link #addRange(String, String, String)} but there will be no  * lower bound.  */ public IpRangeAggregationBuilder addUnboundedTo(String key, String to) {     addRange(new Range(key, null, to)).     return this. }
true;public;1;3;/**  * Same as {@link #addUnboundedTo(String, String)} but the key will be  * generated automatically.  */ ;/**  * Same as {@link #addUnboundedTo(String, String)} but the key will be  * generated automatically.  */ public IpRangeAggregationBuilder addUnboundedTo(String to) {     return addUnboundedTo(null, to). }
true;public;2;4;/**  * Same as {@link #addRange(String, String, String)} but there will be no  * upper bound.  */ ;/**  * Same as {@link #addRange(String, String, String)} but there will be no  * upper bound.  */ public IpRangeAggregationBuilder addUnboundedFrom(String key, String from) {     addRange(new Range(key, from, null)).     return this. }
false;public;1;4;;@Override public IpRangeAggregationBuilder script(Script script) {     throw new IllegalArgumentException("[ip_range] does not support scripts"). }
true;public;1;3;/**  * Same as {@link #addUnboundedFrom(String, String)} but the key will be  * generated automatically.  */ ;/**  * Same as {@link #addUnboundedFrom(String, String)} but the key will be  * generated automatically.  */ public IpRangeAggregationBuilder addUnboundedFrom(String from) {     return addUnboundedFrom(null, from). }
false;protected;1;8;;@Override protected void innerWriteTo(StreamOutput out) throws IOException {     out.writeVInt(ranges.size()).     for (Range range : ranges) {         range.writeTo(out).     }     out.writeBoolean(keyed). }
false;private,static;1;8;;private static BytesRef toBytesRef(String ip) {     if (ip == null) {         return null.     }     InetAddress address = InetAddresses.forString(ip).     byte[] bytes = InetAddressPoint.encode(address).     return new BytesRef(bytes). }
false;protected;4;15;;@Override protected ValuesSourceAggregatorFactory<ValuesSource.Bytes, ?> innerBuild(SearchContext context, ValuesSourceConfig<ValuesSource.Bytes> config, AggregatorFactory<?> parent, Builder subFactoriesBuilder) throws IOException {     List<BinaryRangeAggregator.Range> ranges = new ArrayList<>().     if (this.ranges.size() == 0) {         throw new IllegalArgumentException("No [ranges] specified for the [" + this.getName() + "] aggregation").     }     for (Range range : this.ranges) {         ranges.add(new BinaryRangeAggregator.Range(range.key, toBytesRef(range.from), toBytesRef(range.to))).     }     return new BinaryRangeAggregatorFactory(name, config, ranges, keyed, context, parent, subFactoriesBuilder, metaData). }
false;protected;2;6;;@Override protected XContentBuilder doXContentBody(XContentBuilder builder, Params params) throws IOException {     builder.field(RangeAggregator.RANGES_FIELD.getPreferredName(), ranges).     builder.field(RangeAggregator.KEYED_FIELD.getPreferredName(), keyed).     return builder. }
false;protected;0;4;;@Override protected int innerHashCode() {     return Objects.hash(keyed, ranges). }
false;protected;1;6;;@Override protected boolean innerEquals(Object obj) {     IpRangeAggregationBuilder that = (IpRangeAggregationBuilder) obj.     return keyed == that.keyed && ranges.equals(that.ranges). }
