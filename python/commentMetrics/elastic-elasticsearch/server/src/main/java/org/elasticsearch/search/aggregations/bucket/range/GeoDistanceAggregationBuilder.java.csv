commented;modifiers;parameterAmount;loc;comment;code
false;public,static;2;7;;public static AggregationBuilder parse(String aggregationName, XContentParser parser) throws IOException {     GeoDistanceAggregationBuilder builder = PARSER.parse(parser, new GeoDistanceAggregationBuilder(aggregationName), null).     if (builder.origin() == null) {         throw new IllegalArgumentException("Aggregation [" + aggregationName + "] must define an [origin].").     }     return builder. }
false;public;1;6;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeOptionalString(key).     out.writeDouble(from).     out.writeDouble(to). }
false;private,static;3;10;;private static String key(String key, Double from, Double to) {     if (key != null) {         return key.     }     StringBuilder sb = new StringBuilder().     sb.append((from == null || from == 0) ? "*" : from).     sb.append("-").     sb.append((to == null || Double.isInfinite(to)) ? "*" : to).     return sb.toString(). }
false;private,static;1;47;;private static GeoPoint parseGeoPoint(XContentParser parser) throws IOException {     Token token = parser.currentToken().     if (token == XContentParser.Token.VALUE_STRING) {         GeoPoint point = new GeoPoint().         point.resetFromString(parser.text()).         return point.     }     if (token == XContentParser.Token.START_ARRAY) {         double lat = Double.NaN.         double lon = Double.NaN.         while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {             if (Double.isNaN(lon)) {                 lon = parser.doubleValue().             } else if (Double.isNaN(lat)) {                 lat = parser.doubleValue().             } else {                 throw new ParsingException(parser.getTokenLocation(), "malformed [" + ORIGIN_FIELD.getPreferredName() + "]: a geo point array must be of the form [lon, lat]").             }         }         return new GeoPoint(lat, lon).     }     if (token == XContentParser.Token.START_OBJECT) {         String currentFieldName = null.         double lat = Double.NaN.         double lon = Double.NaN.         while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {             if (token == XContentParser.Token.FIELD_NAME) {                 currentFieldName = parser.currentName().             } else if (token == XContentParser.Token.VALUE_NUMBER) {                 if ("lat".equals(currentFieldName)) {                     lat = parser.doubleValue().                 } else if ("lon".equals(currentFieldName)) {                     lon = parser.doubleValue().                 }             }         }         if (Double.isNaN(lat) || Double.isNaN(lon)) {             throw new ParsingException(parser.getTokenLocation(), "malformed [" + currentFieldName + "] geo point object. either [lat] or [lon] (or both) are " + "missing").         }         return new GeoPoint(lat, lon).     }     // should not happen since we only parse geo points when we encounter a string, an object or an array     throw new IllegalArgumentException("Unexpected token [" + token + "] while parsing geo point"). }
false;private,static;1;47;;private static Range parseRange(XContentParser parser) throws IOException {     String fromAsStr = null.     String toAsStr = null.     double from = 0.0.     double to = Double.POSITIVE_INFINITY.     String key = null.     String currentFieldName = null.     Token token.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (token == XContentParser.Token.VALUE_NUMBER) {             if (FROM_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 from = parser.doubleValue().             } else if (TO_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 to = parser.doubleValue().             } else {                 XContentParserUtils.throwUnknownField(currentFieldName, parser.getTokenLocation()).             }         } else if (token == XContentParser.Token.VALUE_STRING) {             if (KEY_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 key = parser.text().             } else if (FROM_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 fromAsStr = parser.text().             } else if (TO_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 toAsStr = parser.text().             } else {                 XContentParserUtils.throwUnknownField(currentFieldName, parser.getTokenLocation()).             }         } else if (token == XContentParser.Token.VALUE_NULL) {             if (FROM_FIELD.match(currentFieldName, parser.getDeprecationHandler()) || TO_FIELD.match(currentFieldName, parser.getDeprecationHandler()) || KEY_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {             // ignore null value             } else {                 XContentParserUtils.throwUnknownField(currentFieldName, parser.getTokenLocation()).             }         } else {             XContentParserUtils.throwUnknownToken(token, parser.getTokenLocation()).         }     }     if (fromAsStr != null || toAsStr != null) {         return new Range(key, Double.parseDouble(fromAsStr), Double.parseDouble(toAsStr)).     } else {         return new Range(key, from, to).     } }
false;protected;2;4;;@Override protected AggregationBuilder shallowCopy(Builder factoriesBuilder, Map<String, Object> metaData) {     return new GeoDistanceAggregationBuilder(this, factoriesBuilder, metaData). }
false;;1;4;;GeoDistanceAggregationBuilder origin(GeoPoint origin) {     this.origin = origin.     return this. }
true;public;0;3;/**  * Return the {@link GeoPoint} that is used for distance computations.  */ ;/**  * Return the {@link GeoPoint} that is used for distance computations.  */ public GeoPoint origin() {     return origin. }
false;protected;1;12;;@Override protected void innerWriteTo(StreamOutput out) throws IOException {     out.writeDouble(origin.lat()).     out.writeDouble(origin.lon()).     out.writeVInt(ranges.size()).     for (Range range : ranges) {         range.writeTo(out).     }     out.writeBoolean(keyed).     distanceType.writeTo(out).     unit.writeTo(out). }
false;public;1;7;;public GeoDistanceAggregationBuilder addRange(Range range) {     if (range == null) {         throw new IllegalArgumentException("[range] must not be null: [" + name + "]").     }     ranges.add(range).     return this. }
true;public;3;4;/**  * Add a new range to this aggregation.  *  * @param key  *            the key to use for this range in the response  * @param from  *            the lower bound on the distances, inclusive  * @param to  *            the upper bound on the distances, exclusive  */ ;/**  * Add a new range to this aggregation.  *  * @param key  *            the key to use for this range in the response  * @param from  *            the lower bound on the distances, inclusive  * @param to  *            the upper bound on the distances, exclusive  */ public GeoDistanceAggregationBuilder addRange(String key, double from, double to) {     ranges.add(new Range(key, from, to)).     return this. }
true;public;2;3;/**  * Same as {@link #addRange(String, double, double)} but the key will be  * automatically generated based on <code>from</code> and  * <code>to</code>.  */ ;/**  * Same as {@link #addRange(String, double, double)} but the key will be  * automatically generated based on <code>from</code> and  * <code>to</code>.  */ public GeoDistanceAggregationBuilder addRange(double from, double to) {     return addRange(null, from, to). }
true;public;2;4;/**  * Add a new range with no lower bound.  *  * @param key  *            the key to use for this range in the response  * @param to  *            the upper bound on the distances, exclusive  */ ;/**  * Add a new range with no lower bound.  *  * @param key  *            the key to use for this range in the response  * @param to  *            the upper bound on the distances, exclusive  */ public GeoDistanceAggregationBuilder addUnboundedTo(String key, double to) {     ranges.add(new Range(key, null, to)).     return this. }
true;public;1;3;/**  * Same as {@link #addUnboundedTo(String, double)} but the key will be  * computed automatically.  */ ;/**  * Same as {@link #addUnboundedTo(String, double)} but the key will be  * computed automatically.  */ public GeoDistanceAggregationBuilder addUnboundedTo(double to) {     return addUnboundedTo(null, to). }
true;public;2;4;/**  * Add a new range with no upper bound.  *  * @param key  *            the key to use for this range in the response  * @param from  *            the lower bound on the distances, inclusive  */ ;/**  * Add a new range with no upper bound.  *  * @param key  *            the key to use for this range in the response  * @param from  *            the lower bound on the distances, inclusive  */ public GeoDistanceAggregationBuilder addUnboundedFrom(String key, double from) {     addRange(new Range(key, from, null)).     return this. }
true;public;1;3;/**  * Same as {@link #addUnboundedFrom(String, double)} but the key will be  * computed automatically.  */ ;/**  * Same as {@link #addUnboundedFrom(String, double)} but the key will be  * computed automatically.  */ public GeoDistanceAggregationBuilder addUnboundedFrom(double from) {     return addUnboundedFrom(null, from). }
false;public;0;3;;public List<Range> range() {     return ranges. }
false;public;0;4;;@Override public String getType() {     return NAME. }
false;public;1;7;;public GeoDistanceAggregationBuilder unit(DistanceUnit unit) {     if (unit == null) {         throw new IllegalArgumentException("[unit] must not be null: [" + name + "]").     }     this.unit = unit.     return this. }
false;public;0;3;;public DistanceUnit unit() {     return unit. }
false;public;1;7;;public GeoDistanceAggregationBuilder distanceType(GeoDistance distanceType) {     if (distanceType == null) {         throw new IllegalArgumentException("[distanceType] must not be null: [" + name + "]").     }     this.distanceType = distanceType.     return this. }
false;public;0;3;;public GeoDistance distanceType() {     return distanceType. }
false;public;1;4;;public GeoDistanceAggregationBuilder keyed(boolean keyed) {     this.keyed = keyed.     return this. }
false;public;0;3;;public boolean keyed() {     return keyed. }
false;protected;4;11;;@Override protected ValuesSourceAggregatorFactory<ValuesSource.GeoPoint, ?> innerBuild(SearchContext context, ValuesSourceConfig<ValuesSource.GeoPoint> config, AggregatorFactory<?> parent, Builder subFactoriesBuilder) throws IOException {     Range[] ranges = this.ranges.toArray(new Range[this.range().size()]).     if (ranges.length == 0) {         throw new IllegalArgumentException("No [ranges] specified for the [" + this.getName() + "] aggregation").     }     return new GeoDistanceRangeAggregatorFactory(name, config, origin, ranges, unit, distanceType, keyed, context, parent, subFactoriesBuilder, metaData). }
false;protected;2;9;;@Override protected XContentBuilder doXContentBody(XContentBuilder builder, Params params) throws IOException {     builder.field(ORIGIN_FIELD.getPreferredName(), origin).     builder.field(RangeAggregator.RANGES_FIELD.getPreferredName(), ranges).     builder.field(RangeAggregator.KEYED_FIELD.getPreferredName(), keyed).     builder.field(UNIT_FIELD.getPreferredName(), unit).     builder.field(DISTANCE_TYPE_FIELD.getPreferredName(), distanceType).     return builder. }
false;protected;0;4;;@Override protected int innerHashCode() {     return Objects.hash(origin, ranges, keyed, distanceType, unit). }
false;protected;1;9;;@Override protected boolean innerEquals(Object obj) {     GeoDistanceAggregationBuilder other = (GeoDistanceAggregationBuilder) obj.     return Objects.equals(origin, other.origin) && Objects.equals(ranges, other.ranges) && Objects.equals(keyed, other.keyed) && Objects.equals(distanceType, other.distanceType) && Objects.equals(unit, other.unit). }
