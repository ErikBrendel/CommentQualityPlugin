commented;modifiers;parameterAmount;loc;comment;code
false;public,final;0;3;;public final long getUsageCount() {     return usageCount.sum(). }
true;public,abstract;0;1;/**  * @return the name of this handler. The name should be human readable and  *         should describe the action that will performed when this API is  *         called. This name is used in the response to the  *         {@link RestNodesUsageAction}.  */ ;/**  * @return the name of this handler. The name should be human readable and  *         should describe the action that will performed when this API is  *         called. This name is used in the response to the  *         {@link RestNodesUsageAction}.  */ public abstract String getName().
false;public,final;3;26;;@Override public final void handleRequest(RestRequest request, RestChannel channel, NodeClient client) throws Exception {     // prepare the request for execution. has the side effect of touching the request parameters     final RestChannelConsumer action = prepareRequest(request, client).     // validate unconsumed params, but we must exclude params used to format the response     // use a sorted set so the unconsumed parameters appear in a reliable sorted order     final SortedSet<String> unconsumedParams = request.unconsumedParams().stream().filter(p -> !responseParams().contains(p)).collect(Collectors.toCollection(TreeSet::new)).     // validate the non-response params     if (!unconsumedParams.isEmpty()) {         final Set<String> candidateParams = new HashSet<>().         candidateParams.addAll(request.consumedParams()).         candidateParams.addAll(responseParams()).         throw new IllegalArgumentException(unrecognized(request, unconsumedParams, candidateParams, "parameter")).     }     if (request.hasContent() && request.isContentConsumed() == false) {         throw new IllegalArgumentException("request [" + request.method() + " " + request.path() + "] does not support having a body").     }     usageCount.increment().     // execute the action     action.accept(channel). }
false;protected,final;4;46;;protected final String unrecognized(final RestRequest request, final Set<String> invalids, final Set<String> candidates, final String detail) {     StringBuilder message = new StringBuilder(String.format(Locale.ROOT, "request [%s] contains unrecognized %s%s: ", request.path(), detail, invalids.size() > 1 ? "s" : "")).     boolean first = true.     for (final String invalid : invalids) {         final LevenshteinDistance ld = new LevenshteinDistance().         final List<Tuple<Float, String>> scoredParams = new ArrayList<>().         for (final String candidate : candidates) {             final float distance = ld.getDistance(invalid, candidate).             if (distance > 0.5f) {                 scoredParams.add(new Tuple<>(distance, candidate)).             }         }         CollectionUtil.timSort(scoredParams, (a, b) -> {             // sort by distance in reverse order, then parameter name for equal distances             int compare = a.v1().compareTo(b.v1()).             if (compare != 0)                 return -compare.             else                 return a.v2().compareTo(b.v2()).         }).         if (first == false) {             message.append(", ").         }         message.append("[").append(invalid).append("]").         final List<String> keys = scoredParams.stream().map(Tuple::v2).collect(Collectors.toList()).         if (keys.isEmpty() == false) {             message.append(" -> did you mean ").             if (keys.size() == 1) {                 message.append("[").append(keys.get(0)).append("]").             } else {                 message.append("any of ").append(keys.toString()).             }             message.append("?").         }         first = false.     }     return message.toString(). }
true;protected,abstract;2;1;/**  * Prepare the request for execution. Implementations should consume all request params before  * returning the runnable for actual execution. Unconsumed params will immediately terminate  * execution of the request. However, some params are only used in processing the response.  * implementations can override {@link BaseRestHandler#responseParams()} to indicate such  * params.  *  * @param request the request to execute  * @param client  client for executing actions on the local node  * @return the action to execute  * @throws IOException if an I/O exception occurred parsing the request and preparing for  *                     execution  */ ;/**  * Prepare the request for execution. Implementations should consume all request params before  * returning the runnable for actual execution. Unconsumed params will immediately terminate  * execution of the request. However, some params are only used in processing the response.  * implementations can override {@link BaseRestHandler#responseParams()} to indicate such  * params.  *  * @param request the request to execute  * @param client  client for executing actions on the local node  * @return the action to execute  * @throws IOException if an I/O exception occurred parsing the request and preparing for  *                     execution  */ protected abstract RestChannelConsumer prepareRequest(RestRequest request, NodeClient client) throws IOException.
true;protected;0;3;/**  * Parameters used for controlling the response and thus might not be consumed during  * preparation of the request execution in  * {@link BaseRestHandler#prepareRequest(RestRequest, NodeClient)}.  *  * @return a set of parameters used to control the response and thus should not trip strict  * URL parameter checks.  */ ;/**  * Parameters used for controlling the response and thus might not be consumed during  * preparation of the request execution in  * {@link BaseRestHandler#prepareRequest(RestRequest, NodeClient)}.  *  * @return a set of parameters used to control the response and thus should not trip strict  * URL parameter checks.  */ protected Set<String> responseParams() {     return Collections.emptySet(). }
