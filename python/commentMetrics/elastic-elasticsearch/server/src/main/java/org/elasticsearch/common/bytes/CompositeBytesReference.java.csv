commented;modifiers;parameterAmount;loc;comment;code
false;public;1;5;;@Override public byte get(int index) {     final int i = getOffsetIndex(index).     return references[i].get(index - offsets[i]). }
false;public;0;4;;@Override public int length() {     return length. }
false;public;2;26;;@Override public BytesReference slice(int from, int length) {     FutureObjects.checkFromIndexSize(from, length, this.length).     if (length == 0) {         return BytesArray.EMPTY.     }     // for slices we only need to find the start and the end reference     // adjust them and pass on the references in between as they are fully contained     final int to = from + length.     final int limit = getOffsetIndex(to - 1).     final int start = getOffsetIndex(from).     final BytesReference[] inSlice = new BytesReference[1 + (limit - start)].     for (int i = 0, j = start. i < inSlice.length. i++) {         inSlice[i] = references[j++].     }     int inSliceOffset = from - offsets[start].     if (inSlice.length == 1) {         return inSlice[0].slice(inSliceOffset, length).     }     // now adjust slices in front and at the end     inSlice[0] = inSlice[0].slice(inSliceOffset, inSlice[0].length() - inSliceOffset).     inSlice[inSlice.length - 1] = inSlice[inSlice.length - 1].slice(0, to - offsets[limit]).     return new CompositeBytesReference(inSlice). }
false;private;1;4;;private int getOffsetIndex(int offset) {     final int i = Arrays.binarySearch(offsets, offset).     return i < 0 ? (-(i + 1)) - 1 : i. }
false;public;0;15;;@Override public BytesRef toBytesRef() {     BytesRefBuilder builder = new BytesRefBuilder().     builder.grow(length()).     BytesRef spare.     BytesRefIterator iterator = iterator().     try {         while ((spare = iterator.next()) != null) {             builder.append(spare).         }     } catch (IOException ex) {         // this is really an error since we don't do IO in our bytesreferences         throw new AssertionError("won't happen", ex).     }     return builder.toBytesRef(). }
false;public;0;14;;@Override public BytesRef next() throws IOException {     BytesRef next = current.next().     if (next == null) {         while (index < references.length) {             current = references[index++].iterator().             next = current.next().             if (next != null) {                 break.             }         }     }     return next. }
false;public;0;26;;@Override public BytesRefIterator iterator() {     if (references.length > 0) {         return new BytesRefIterator() {              int index = 0.              private BytesRefIterator current = references[index++].iterator().              @Override             public BytesRef next() throws IOException {                 BytesRef next = current.next().                 if (next == null) {                     while (index < references.length) {                         current = references[index++].iterator().                         next = current.next().                         if (next != null) {                             break.                         }                     }                 }                 return next.             }         }.     } else {         return () -> null.     } }
false;public;0;4;;@Override public long ramBytesUsed() {     return ramBytesUsed. }
