commented;modifiers;parameterAmount;loc;comment;code
false;public;1;7;;@Override public void configure(Binder binder) {     binder.bind(Settings.class).toInstance(settings).     binder.bind(SettingsFilter.class).toInstance(settingsFilter).     binder.bind(ClusterSettings.class).toInstance(clusterSettings).     binder.bind(IndexScopedSettings.class).toInstance(indexScopedSettings). }
true;private;1;25;/**  * Registers a new setting. This method should be used by plugins in order to expose any custom settings the plugin defines.  * Unless a setting is registered the setting is unusable. If a setting is never the less specified the node will reject  * the setting during startup.  */ ;/**  * Registers a new setting. This method should be used by plugins in order to expose any custom settings the plugin defines.  * Unless a setting is registered the setting is unusable. If a setting is never the less specified the node will reject  * the setting during startup.  */ private void registerSetting(Setting<?> setting) {     if (setting.isFiltered()) {         if (settingsFilterPattern.contains(setting.getKey()) == false) {             registerSettingsFilter(setting.getKey()).         }     }     if (setting.hasNodeScope() || setting.hasIndexScope()) {         if (setting.hasNodeScope()) {             Setting<?> existingSetting = nodeSettings.get(setting.getKey()).             if (existingSetting != null) {                 throw new IllegalArgumentException("Cannot register setting [" + setting.getKey() + "] twice").             }             nodeSettings.put(setting.getKey(), setting).         }         if (setting.hasIndexScope()) {             Setting<?> existingSetting = indexSettings.get(setting.getKey()).             if (existingSetting != null) {                 throw new IllegalArgumentException("Cannot register setting [" + setting.getKey() + "] twice").             }             indexSettings.put(setting.getKey(), setting).         }     } else {         throw new IllegalArgumentException("No scope found for setting [" + setting.getKey() + "]").     } }
true;private;1;9;/**  * Registers a settings filter pattern that allows to filter out certain settings that for instance contain sensitive information  * or if a setting is for internal purposes only. The given pattern must either be a valid settings key or a simple regexp pattern.  */ ;/**  * Registers a settings filter pattern that allows to filter out certain settings that for instance contain sensitive information  * or if a setting is for internal purposes only. The given pattern must either be a valid settings key or a simple regexp pattern.  */ private void registerSettingsFilter(String filter) {     if (SettingsFilter.isValidPattern(filter) == false) {         throw new IllegalArgumentException("filter [" + filter + "] is invalid must be either a key or a regex pattern").     }     if (settingsFilterPattern.contains(filter)) {         throw new IllegalArgumentException("filter [" + filter + "] has already been registered").     }     settingsFilterPattern.add(filter). }
false;public;0;3;;public Settings getSettings() {     return settings. }
false;public;0;3;;public IndexScopedSettings getIndexScopedSettings() {     return indexScopedSettings. }
false;public;0;3;;public ClusterSettings getClusterSettings() {     return clusterSettings. }
false;public;0;3;;public SettingsFilter getSettingsFilter() {     return settingsFilter. }
