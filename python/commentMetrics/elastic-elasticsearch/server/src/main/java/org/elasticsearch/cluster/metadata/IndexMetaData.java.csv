commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public byte id() {     return this.id. }
false;public,static;1;8;;public static State fromId(byte id) {     if (id == 0) {         return OPEN.     } else if (id == 1) {         return CLOSE.     }     throw new IllegalStateException("No state match for id [" + id + "]"). }
false;public,static;1;8;;public static State fromString(String state) {     if ("open".equals(state)) {         return OPEN.     } else if ("close".equals(state)) {         return CLOSE.     }     throw new IllegalStateException("No state match for [" + state + "]"). }
false;static;0;12;;static Setting<Integer> buildNumberOfShardsSetting() {     /* This is a safety limit that should only be exceeded in very rare and special cases. The assumption is that          * 99% of the users have less than 1024 shards per index. We also make it a hard check that requires restart of nodes          * if a cluster should allow to create more than 1024 shards per index. NOTE: this does not limit the number of shards          * per cluster. this also prevents creating stuff like a new index with millions of shards by accident which essentially          * kills the entire cluster with OOM on the spot.*/     final int maxNumShards = Integer.parseInt(System.getProperty("es.index.max_number_of_shards", "1024")).     if (maxNumShards < 1) {         throw new IllegalArgumentException("es.index.max_number_of_shards must be > 0").     }     return Setting.intSetting(SETTING_NUMBER_OF_SHARDS, 1, 1, maxNumShards, Property.IndexScope, Property.Final). }
false;public;1;3;;@Override public void validate(Integer value) { }
false;public;2;9;;@Override public void validate(Integer numRoutingShards, Map<Setting<Integer>, Integer> settings) {     Integer numShards = settings.get(INDEX_NUMBER_OF_SHARDS_SETTING).     if (numRoutingShards < numShards) {         throw new IllegalArgumentException("index.number_of_routing_shards [" + numRoutingShards + "] must be >= index.number_of_shards [" + numShards + "]").     }     getRoutingFactor(numShards, numRoutingShards). }
false;public;0;4;;@Override public Iterator<Setting<Integer>> settings() {     return Collections.singleton(INDEX_NUMBER_OF_SHARDS_SETTING).iterator(). }
false;public;0;3;;public Index getIndex() {     return index. }
false;public;0;3;;public String getIndexUUID() {     return index.getUUID(). }
true;public;1;8;/**  * Test whether the current index UUID is the same as the given one. Returns true if either are _na_  */ ;/**  * Test whether the current index UUID is the same as the given one. Returns true if either are _na_  */ public boolean isSameUUID(String otherUUID) {     assert otherUUID != null.     assert getIndexUUID() != null.     if (INDEX_UUID_NA_VALUE.equals(otherUUID) || INDEX_UUID_NA_VALUE.equals(getIndexUUID())) {         return true.     }     return otherUUID.equals(getIndexUUID()). }
false;public;0;3;;public long getVersion() {     return this.version. }
false;public;0;3;;public long getMappingVersion() {     return mappingVersion. }
false;public;0;3;;public long getSettingsVersion() {     return settingsVersion. }
true;public;1;3;/**  * The term of the current selected primary. This is a non-negative number incremented when  * a primary shard is assigned after a full cluster restart or a replica shard is promoted to a primary.  *  * Note: since we increment the term every time a shard is assigned, the term for any operational shard (i.e., a shard  * that can be indexed into) is larger than 0. See {@link IndexMetaDataUpdater#applyChanges}.  */ ;/**  * The term of the current selected primary. This is a non-negative number incremented when  * a primary shard is assigned after a full cluster restart or a replica shard is promoted to a primary.  *  * Note: since we increment the term every time a shard is assigned, the term for any operational shard (i.e., a shard  * that can be indexed into) is larger than 0. See {@link IndexMetaDataUpdater#applyChanges}.  */ public long primaryTerm(int shardId) {     return this.primaryTerms[shardId]. }
true;public;0;3;/**  * Return the {@link Version} on which this index has been created. This  * information is typically useful for backward compatibility.  */ ;/**  * Return the {@link Version} on which this index has been created. This  * information is typically useful for backward compatibility.  */ public Version getCreationVersion() {     return indexCreatedVersion. }
true;public;0;3;/**  * Return the {@link Version} on which this index has been upgraded. This  * information is typically useful for backward compatibility.  */ ;/**  * Return the {@link Version} on which this index has been upgraded. This  * information is typically useful for backward compatibility.  */ public Version getUpgradedVersion() {     return indexUpgradedVersion. }
false;public;0;3;;public long getCreationDate() {     return settings.getAsLong(SETTING_CREATION_DATE, -1L). }
false;public;0;3;;public State getState() {     return this.state. }
false;public;0;3;;public int getNumberOfShards() {     return numberOfShards. }
false;public;0;3;;public int getNumberOfReplicas() {     return numberOfReplicas. }
false;public;0;3;;public int getRoutingPartitionSize() {     return routingPartitionSize. }
false;public;0;3;;public boolean isRoutingPartitionedIndex() {     return routingPartitionSize != 1. }
false;public;0;3;;public int getTotalNumberOfShards() {     return totalNumberOfShards. }
true;public;0;3;/**  * Returns the configured {@link #SETTING_WAIT_FOR_ACTIVE_SHARDS}, which defaults  * to an active shard count of 1 if not specified.  */ ;/**  * Returns the configured {@link #SETTING_WAIT_FOR_ACTIVE_SHARDS}, which defaults  * to an active shard count of 1 if not specified.  */ public ActiveShardCount getWaitForActiveShards() {     return waitForActiveShards. }
false;public;0;3;;public Settings getSettings() {     return settings. }
false;public;0;3;;public ImmutableOpenMap<String, AliasMetaData> getAliases() {     return this.aliases. }
true;public;0;4;/**  * Return an object that maps each type to the associated mappings.  * The return value is never {@code null} but may be empty if the index  * has no mappings.  * @deprecated Use {@link #mapping()} instead now that indices have a single type  */ ;/**  * Return an object that maps each type to the associated mappings.  * The return value is never {@code null} but may be empty if the index  * has no mappings.  * @deprecated Use {@link #mapping()} instead now that indices have a single type  */ @Deprecated public ImmutableOpenMap<String, MappingMetaData> getMappings() {     return mappings. }
true;public;0;9;/**  * Return the concrete mapping for this index or {@code null} if this index has no mappings at all.  */ ;/**  * Return the concrete mapping for this index or {@code null} if this index has no mappings at all.  */ @Nullable public MappingMetaData mapping() {     for (ObjectObjectCursor<String, MappingMetaData> cursor : mappings) {         if (cursor.key.equals(MapperService.DEFAULT_MAPPING) == false) {             return cursor.value.         }     }     return null. }
true;public;0;4;/**  * Get the default mapping.  * NOTE: this is always {@code null} for 7.x indices which are disallowed to have a default mapping.  */ ;/**  * Get the default mapping.  * NOTE: this is always {@code null} for 7.x indices which are disallowed to have a default mapping.  */ @Nullable public MappingMetaData defaultMapping() {     return mappings.get(MapperService.DEFAULT_MAPPING). }
false;public;0;4;;public Index getResizeSourceIndex() {     return INDEX_RESIZE_SOURCE_UUID.exists(settings) ? new Index(INDEX_RESIZE_SOURCE_NAME.get(settings), INDEX_RESIZE_SOURCE_UUID.get(settings)) : null. }
true;public;0;11;/**  * Sometimes, the default mapping exists and an actual mapping is not created yet (introduced),  * in this case, we want to return the default mapping in case it has some default mapping definitions.  * <p>  * Note, once the mapping type is introduced, the default mapping is applied on the actual typed MappingMetaData,  * setting its routing, timestamp, and so on if needed.  */ ;/**  * Sometimes, the default mapping exists and an actual mapping is not created yet (introduced),  * in this case, we want to return the default mapping in case it has some default mapping definitions.  * <p>  * Note, once the mapping type is introduced, the default mapping is applied on the actual typed MappingMetaData,  * setting its routing, timestamp, and so on if needed.  */ @Nullable public MappingMetaData mappingOrDefault() {     MappingMetaData mapping = null.     for (ObjectCursor<MappingMetaData> m : mappings.values()) {         if (mapping == null || mapping.type().equals(MapperService.DEFAULT_MAPPING)) {             mapping = m.value.         }     }     return mapping. }
false;;0;3;;ImmutableOpenMap<String, DiffableStringMap> getCustomData() {     return this.customData. }
false;public;1;3;;public Map<String, String> getCustomData(final String key) {     return this.customData.get(key). }
false;public;0;3;;public ImmutableOpenIntMap<Set<String>> getInSyncAllocationIds() {     return inSyncAllocationIds. }
false;public;0;3;;public ImmutableOpenMap<String, RolloverInfo> getRolloverInfos() {     return rolloverInfos. }
false;public;1;4;;public Set<String> inSyncAllocationIds(int shardId) {     assert shardId >= 0 && shardId < numberOfShards.     return inSyncAllocationIds.get(shardId). }
false;public;0;4;;@Nullable public DiscoveryNodeFilters requireFilters() {     return requireFilters. }
false;public;0;4;;@Nullable public DiscoveryNodeFilters getInitialRecoveryFilters() {     return initialRecoveryFilters. }
false;public;0;4;;@Nullable public DiscoveryNodeFilters includeFilters() {     return includeFilters. }
false;public;0;4;;@Nullable public DiscoveryNodeFilters excludeFilters() {     return excludeFilters. }
false;public;1;50;;@Override public boolean equals(Object o) {     if (this == o) {         return true.     }     if (o == null || getClass() != o.getClass()) {         return false.     }     IndexMetaData that = (IndexMetaData) o.     if (version != that.version) {         return false.     }     if (!aliases.equals(that.aliases)) {         return false.     }     if (!index.equals(that.index)) {         return false.     }     if (!mappings.equals(that.mappings)) {         return false.     }     if (!settings.equals(that.settings)) {         return false.     }     if (state != that.state) {         return false.     }     if (!customData.equals(that.customData)) {         return false.     }     if (routingNumShards != that.routingNumShards) {         return false.     }     if (routingFactor != that.routingFactor) {         return false.     }     if (Arrays.equals(primaryTerms, that.primaryTerms) == false) {         return false.     }     if (!inSyncAllocationIds.equals(that.inSyncAllocationIds)) {         return false.     }     if (rolloverInfos.equals(that.rolloverInfos) == false) {         return false.     }     return true. }
false;public;0;16;;@Override public int hashCode() {     int result = index.hashCode().     result = 31 * result + Long.hashCode(version).     result = 31 * result + state.hashCode().     result = 31 * result + aliases.hashCode().     result = 31 * result + settings.hashCode().     result = 31 * result + mappings.hashCode().     result = 31 * result + customData.hashCode().     result = 31 * result + Long.hashCode(routingFactor).     result = 31 * result + Long.hashCode(routingNumShards).     result = 31 * result + Arrays.hashCode(primaryTerms).     result = 31 * result + inSyncAllocationIds.hashCode().     result = 31 * result + rolloverInfos.hashCode().     return result. }
false;public;1;4;;@Override public Diff<IndexMetaData> diff(IndexMetaData previousState) {     return new IndexMetaDataDiff(previousState, this). }
false;public,static;1;3;;public static Diff<IndexMetaData> readDiffFrom(StreamInput in) throws IOException {     return new IndexMetaDataDiff(in). }
false;public,static;1;3;;public static IndexMetaData fromXContent(XContentParser parser) throws IOException {     return Builder.fromXContent(parser). }
false;public;2;5;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     Builder.toXContent(this, builder, params).     return builder. }
false;public;1;22;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeString(index).     out.writeInt(routingNumShards).     out.writeLong(version).     if (out.getVersion().onOrAfter(Version.V_6_5_0)) {         out.writeVLong(mappingVersion).     }     if (out.getVersion().onOrAfter(Version.V_6_5_0)) {         out.writeVLong(settingsVersion).     }     out.writeByte(state.id).     Settings.writeSettingsToStream(settings, out).     out.writeVLongArray(primaryTerms).     mappings.writeTo(out).     aliases.writeTo(out).     customData.writeTo(out).     inSyncAllocationIds.writeTo(out).     if (out.getVersion().onOrAfter(Version.V_6_4_0)) {         rolloverInfos.writeTo(out).     } }
false;public;1;17;;@Override public IndexMetaData apply(IndexMetaData part) {     Builder builder = builder(index).     builder.version(version).     builder.mappingVersion(mappingVersion).     builder.settingsVersion(settingsVersion).     builder.setRoutingNumShards(routingNumShards).     builder.state(state).     builder.settings(settings).     builder.primaryTerms(primaryTerms).     builder.mappings.putAll(mappings.apply(part.mappings)).     builder.aliases.putAll(aliases.apply(part.aliases)).     builder.customMetaData.putAll(customData.apply(part.customData)).     builder.inSyncAllocationIds.putAll(inSyncAllocationIds.apply(part.inSyncAllocationIds)).     builder.rolloverInfos.putAll(rolloverInfos.apply(part.rolloverInfos)).     return builder.build(). }
false;public,static;1;54;;public static IndexMetaData readFrom(StreamInput in) throws IOException {     Builder builder = new Builder(in.readString()).     builder.version(in.readLong()).     if (in.getVersion().onOrAfter(Version.V_6_5_0)) {         builder.mappingVersion(in.readVLong()).     } else {         builder.mappingVersion(1).     }     if (in.getVersion().onOrAfter(Version.V_6_5_0)) {         builder.settingsVersion(in.readVLong()).     } else {         builder.settingsVersion(1).     }     builder.setRoutingNumShards(in.readInt()).     builder.state(State.fromId(in.readByte())).     builder.settings(readSettingsFromStream(in)).     builder.primaryTerms(in.readVLongArray()).     int mappingsSize = in.readVInt().     for (int i = 0. i < mappingsSize. i++) {         MappingMetaData mappingMd = new MappingMetaData(in).         builder.putMapping(mappingMd).     }     int aliasesSize = in.readVInt().     for (int i = 0. i < aliasesSize. i++) {         AliasMetaData aliasMd = new AliasMetaData(in).         builder.putAlias(aliasMd).     }     int customSize = in.readVInt().     if (in.getVersion().onOrAfter(Version.V_6_5_0)) {         for (int i = 0. i < customSize. i++) {             String key = in.readString().             DiffableStringMap custom = new DiffableStringMap(in).             builder.putCustom(key, custom).         }     } else {         assert customSize == 0 : "expected no custom index metadata".         if (customSize > 0) {             throw new IllegalStateException("unexpected custom metadata when none is supported").         }     }     int inSyncAllocationIdsSize = in.readVInt().     for (int i = 0. i < inSyncAllocationIdsSize. i++) {         int key = in.readVInt().         Set<String> allocationIds = DiffableUtils.StringSetValueSerializer.getInstance().read(in, key).         builder.putInSyncAllocationIds(key, allocationIds).     }     if (in.getVersion().onOrAfter(Version.V_6_4_0)) {         int rolloverAliasesSize = in.readVInt().         for (int i = 0. i < rolloverAliasesSize. i++) {             builder.putRolloverInfo(new RolloverInfo(in)).         }     }     return builder.build(). }
false;public;1;43;;@Override public void writeTo(StreamOutput out) throws IOException {     // uuid will come as part of settings     out.writeString(index.getName()).     out.writeLong(version).     if (out.getVersion().onOrAfter(Version.V_6_5_0)) {         out.writeVLong(mappingVersion).     }     if (out.getVersion().onOrAfter(Version.V_6_5_0)) {         out.writeVLong(settingsVersion).     }     out.writeInt(routingNumShards).     out.writeByte(state.id()).     writeSettingsToStream(settings, out).     out.writeVLongArray(primaryTerms).     out.writeVInt(mappings.size()).     for (ObjectCursor<MappingMetaData> cursor : mappings.values()) {         cursor.value.writeTo(out).     }     out.writeVInt(aliases.size()).     for (ObjectCursor<AliasMetaData> cursor : aliases.values()) {         cursor.value.writeTo(out).     }     if (out.getVersion().onOrAfter(Version.V_6_5_0)) {         out.writeVInt(customData.size()).         for (final ObjectObjectCursor<String, DiffableStringMap> cursor : customData) {             out.writeString(cursor.key).             cursor.value.writeTo(out).         }     } else {         out.writeVInt(0).     }     out.writeVInt(inSyncAllocationIds.size()).     for (IntObjectCursor<Set<String>> cursor : inSyncAllocationIds) {         out.writeVInt(cursor.key).         DiffableUtils.StringSetValueSerializer.getInstance().write(cursor.value, out).     }     if (out.getVersion().onOrAfter(Version.V_6_4_0)) {         out.writeVInt(rolloverInfos.size()).         for (ObjectCursor<RolloverInfo> cursor : rolloverInfos.values()) {             cursor.value.writeTo(out).         }     } }
false;public,static;1;3;;public static Builder builder(String index) {     return new Builder(index). }
false;public,static;1;3;;public static Builder builder(IndexMetaData indexMetaData) {     return new Builder(indexMetaData). }
false;public;1;4;;public Builder index(String index) {     this.index = index.     return this. }
false;public;1;4;;public Builder numberOfShards(int numberOfShards) {     settings = Settings.builder().put(settings).put(SETTING_NUMBER_OF_SHARDS, numberOfShards).build().     return this. }
true;public;1;4;/**  * Sets the number of shards that should be used for routing. This should only be used if the number of shards in  * an index has changed ie if the index is shrunk.  */ ;/**  * Sets the number of shards that should be used for routing. This should only be used if the number of shards in  * an index has changed ie if the index is shrunk.  */ public Builder setRoutingNumShards(int routingNumShards) {     this.routingNumShards = routingNumShards.     return this. }
true;public;0;3;/**  * Returns number of shards that should be used for routing. By default this method will return the number of shards  * for this index.  *  * @see #setRoutingNumShards(int)  * @see #numberOfShards()  */ ;/**  * Returns number of shards that should be used for routing. By default this method will return the number of shards  * for this index.  *  * @see #setRoutingNumShards(int)  * @see #numberOfShards()  */ public int getRoutingNumShards() {     return routingNumShards == null ? numberOfShards() : routingNumShards. }
true;public;0;3;/**  * Returns the number of shards.  *  * @return the provided value or -1 if it has not been set.  */ ;/**  * Returns the number of shards.  *  * @return the provided value or -1 if it has not been set.  */ public int numberOfShards() {     return settings.getAsInt(SETTING_NUMBER_OF_SHARDS, -1). }
false;public;1;4;;public Builder numberOfReplicas(int numberOfReplicas) {     settings = Settings.builder().put(settings).put(SETTING_NUMBER_OF_REPLICAS, numberOfReplicas).build().     return this. }
false;public;1;4;;public Builder routingPartitionSize(int routingPartitionSize) {     settings = Settings.builder().put(settings).put(SETTING_ROUTING_PARTITION_SIZE, routingPartitionSize).build().     return this. }
false;public;1;4;;public Builder creationDate(long creationDate) {     settings = Settings.builder().put(settings).put(SETTING_CREATION_DATE, creationDate).build().     return this. }
false;public;1;3;;public Builder settings(Settings.Builder settings) {     return settings(settings.build()). }
false;public;1;4;;public Builder settings(Settings settings) {     this.settings = settings.     return this. }
false;public;1;3;;public MappingMetaData mapping(String type) {     return mappings.get(type). }
false;public;2;4;;public Builder putMapping(String type, String source) throws IOException {     putMapping(new MappingMetaData(type, XContentHelper.convertToMap(XContentFactory.xContent(source), source, true))).     return this. }
false;public;1;4;;public Builder putMapping(MappingMetaData mappingMd) {     mappings.put(mappingMd.type(), mappingMd).     return this. }
false;public;1;4;;public Builder state(State state) {     this.state = state.     return this. }
false;public;1;4;;public Builder putAlias(AliasMetaData aliasMetaData) {     aliases.put(aliasMetaData.alias(), aliasMetaData).     return this. }
false;public;1;4;;public Builder putAlias(AliasMetaData.Builder aliasMetaData) {     aliases.put(aliasMetaData.alias(), aliasMetaData.build()).     return this. }
false;public;1;4;;public Builder removeAlias(String alias) {     aliases.remove(alias).     return this. }
false;public;0;4;;public Builder removeAllAliases() {     aliases.clear().     return this. }
false;public;2;4;;public Builder putCustom(String type, Map<String, String> customIndexMetaData) {     this.customMetaData.put(type, new DiffableStringMap(customIndexMetaData)).     return this. }
false;public;1;3;;public Map<String, String> removeCustom(String type) {     return this.customMetaData.remove(type). }
false;public;1;3;;public Set<String> getInSyncAllocationIds(int shardId) {     return inSyncAllocationIds.get(shardId). }
false;public;2;4;;public Builder putInSyncAllocationIds(int shardId, Set<String> allocationIds) {     inSyncAllocationIds.put(shardId, new HashSet<>(allocationIds)).     return this. }
false;public;1;4;;public Builder putRolloverInfo(RolloverInfo rolloverInfo) {     rolloverInfos.put(rolloverInfo.getAlias(), rolloverInfo).     return this. }
false;public;0;3;;public long version() {     return this.version. }
false;public;1;4;;public Builder version(long version) {     this.version = version.     return this. }
false;public;0;3;;public long mappingVersion() {     return mappingVersion. }
false;public;0;3;;public long settingsVersion() {     return settingsVersion. }
false;public;1;4;;public Builder mappingVersion(final long mappingVersion) {     this.mappingVersion = mappingVersion.     return this. }
false;public;1;4;;public Builder settingsVersion(final long settingsVersion) {     this.settingsVersion = settingsVersion.     return this. }
true;public;1;6;/**  * returns the primary term for the given shard.  * See {@link IndexMetaData#primaryTerm(int)} for more information.  */ ;/**  * returns the primary term for the given shard.  * See {@link IndexMetaData#primaryTerm(int)} for more information.  */ public long primaryTerm(int shardId) {     if (primaryTerms == null) {         initializePrimaryTerms().     }     return this.primaryTerms[shardId]. }
true;public;2;7;/**  * sets the primary term for the given shard.  * See {@link IndexMetaData#primaryTerm(int)} for more information.  */ ;/**  * sets the primary term for the given shard.  * See {@link IndexMetaData#primaryTerm(int)} for more information.  */ public Builder primaryTerm(int shardId, long primaryTerm) {     if (primaryTerms == null) {         initializePrimaryTerms().     }     this.primaryTerms[shardId] = primaryTerm.     return this. }
false;private;1;3;;private void primaryTerms(long[] primaryTerms) {     this.primaryTerms = primaryTerms.clone(). }
false;private;0;8;;private void initializePrimaryTerms() {     assert primaryTerms == null.     if (numberOfShards() < 0) {         throw new IllegalStateException("you must set the number of shards before setting/reading primary terms").     }     primaryTerms = new long[numberOfShards()].     Arrays.fill(primaryTerms, SequenceNumbers.UNASSIGNED_PRIMARY_TERM). }
false;public;0;97;;public IndexMetaData build() {     ImmutableOpenMap.Builder<String, AliasMetaData> tmpAliases = aliases.     Settings tmpSettings = settings.     // update default mapping on the MappingMetaData     if (mappings.containsKey(MapperService.DEFAULT_MAPPING)) {         MappingMetaData defaultMapping = mappings.get(MapperService.DEFAULT_MAPPING).         for (ObjectCursor<MappingMetaData> cursor : mappings.values()) {             cursor.value.updateDefaultMapping(defaultMapping).         }     }     Integer maybeNumberOfShards = settings.getAsInt(SETTING_NUMBER_OF_SHARDS, null).     if (maybeNumberOfShards == null) {         throw new IllegalArgumentException("must specify numberOfShards for index [" + index + "]").     }     int numberOfShards = maybeNumberOfShards.     if (numberOfShards <= 0) {         throw new IllegalArgumentException("must specify positive number of shards for index [" + index + "]").     }     Integer maybeNumberOfReplicas = settings.getAsInt(SETTING_NUMBER_OF_REPLICAS, null).     if (maybeNumberOfReplicas == null) {         throw new IllegalArgumentException("must specify numberOfReplicas for index [" + index + "]").     }     int numberOfReplicas = maybeNumberOfReplicas.     if (numberOfReplicas < 0) {         throw new IllegalArgumentException("must specify non-negative number of replicas for index [" + index + "]").     }     int routingPartitionSize = INDEX_ROUTING_PARTITION_SIZE_SETTING.get(settings).     if (routingPartitionSize != 1 && routingPartitionSize >= getRoutingNumShards()) {         throw new IllegalArgumentException("routing partition size [" + routingPartitionSize + "] should be a positive number" + " less than the number of shards [" + getRoutingNumShards() + "] for [" + index + "]").     }     // fill missing slots in inSyncAllocationIds with empty set if needed and make all entries immutable     ImmutableOpenIntMap.Builder<Set<String>> filledInSyncAllocationIds = ImmutableOpenIntMap.builder().     for (int i = 0. i < numberOfShards. i++) {         if (inSyncAllocationIds.containsKey(i)) {             filledInSyncAllocationIds.put(i, Collections.unmodifiableSet(new HashSet<>(inSyncAllocationIds.get(i)))).         } else {             filledInSyncAllocationIds.put(i, Collections.emptySet()).         }     }     final Map<String, String> requireMap = INDEX_ROUTING_REQUIRE_GROUP_SETTING.getAsMap(settings).     final DiscoveryNodeFilters requireFilters.     if (requireMap.isEmpty()) {         requireFilters = null.     } else {         requireFilters = DiscoveryNodeFilters.buildFromKeyValue(AND, requireMap).     }     Map<String, String> includeMap = INDEX_ROUTING_INCLUDE_GROUP_SETTING.getAsMap(settings).     final DiscoveryNodeFilters includeFilters.     if (includeMap.isEmpty()) {         includeFilters = null.     } else {         includeFilters = DiscoveryNodeFilters.buildFromKeyValue(OR, includeMap).     }     Map<String, String> excludeMap = INDEX_ROUTING_EXCLUDE_GROUP_SETTING.getAsMap(settings).     final DiscoveryNodeFilters excludeFilters.     if (excludeMap.isEmpty()) {         excludeFilters = null.     } else {         excludeFilters = DiscoveryNodeFilters.buildFromKeyValue(OR, excludeMap).     }     Map<String, String> initialRecoveryMap = INDEX_ROUTING_INITIAL_RECOVERY_GROUP_SETTING.getAsMap(settings).     final DiscoveryNodeFilters initialRecoveryFilters.     if (initialRecoveryMap.isEmpty()) {         initialRecoveryFilters = null.     } else {         initialRecoveryFilters = DiscoveryNodeFilters.buildFromKeyValue(OR, initialRecoveryMap).     }     Version indexCreatedVersion = Version.indexCreated(settings).     Version indexUpgradedVersion = settings.getAsVersion(IndexMetaData.SETTING_VERSION_UPGRADED, indexCreatedVersion).     if (primaryTerms == null) {         initializePrimaryTerms().     } else if (primaryTerms.length != numberOfShards) {         throw new IllegalStateException("primaryTerms length is [" + primaryTerms.length + "] but should be equal to number of shards [" + numberOfShards() + "]").     }     final ActiveShardCount waitForActiveShards = SETTING_WAIT_FOR_ACTIVE_SHARDS.get(settings).     if (waitForActiveShards.validate(numberOfReplicas) == false) {         throw new IllegalArgumentException("invalid " + SETTING_WAIT_FOR_ACTIVE_SHARDS.getKey() + "[" + waitForActiveShards + "]: cannot be greater than " + "number of shard copies [" + (numberOfReplicas + 1) + "]").     }     final String uuid = settings.get(SETTING_INDEX_UUID, INDEX_UUID_NA_VALUE).     return new IndexMetaData(new Index(index, uuid), version, mappingVersion, settingsVersion, primaryTerms, state, numberOfShards, numberOfReplicas, tmpSettings, mappings.build(), tmpAliases.build(), customMetaData.build(), filledInSyncAllocationIds.build(), requireFilters, initialRecoveryFilters, includeFilters, excludeFilters, indexCreatedVersion, indexUpgradedVersion, getRoutingNumShards(), routingPartitionSize, waitForActiveShards, rolloverInfos.build()). }
false;public,static;3;60;;public static void toXContent(IndexMetaData indexMetaData, XContentBuilder builder, ToXContent.Params params) throws IOException {     builder.startObject(indexMetaData.getIndex().getName()).     builder.field(KEY_VERSION, indexMetaData.getVersion()).     builder.field(KEY_MAPPING_VERSION, indexMetaData.getMappingVersion()).     builder.field(KEY_SETTINGS_VERSION, indexMetaData.getSettingsVersion()).     builder.field(KEY_ROUTING_NUM_SHARDS, indexMetaData.getRoutingNumShards()).     builder.field(KEY_STATE, indexMetaData.getState().toString().toLowerCase(Locale.ENGLISH)).     boolean binary = params.paramAsBoolean("binary", false).     builder.startObject(KEY_SETTINGS).     indexMetaData.getSettings().toXContent(builder, new MapParams(Collections.singletonMap("flat_settings", "true"))).     builder.endObject().     builder.startArray(KEY_MAPPINGS).     for (ObjectObjectCursor<String, MappingMetaData> cursor : indexMetaData.getMappings()) {         if (binary) {             builder.value(cursor.value.source().compressed()).         } else {             builder.map(XContentHelper.convertToMap(new BytesArray(cursor.value.source().uncompressed()), true).v2()).         }     }     builder.endArray().     for (ObjectObjectCursor<String, DiffableStringMap> cursor : indexMetaData.customData) {         builder.field(cursor.key).         builder.map(cursor.value).     }     builder.startObject(KEY_ALIASES).     for (ObjectCursor<AliasMetaData> cursor : indexMetaData.getAliases().values()) {         AliasMetaData.Builder.toXContent(cursor.value, builder, params).     }     builder.endObject().     builder.startArray(KEY_PRIMARY_TERMS).     for (int i = 0. i < indexMetaData.getNumberOfShards(). i++) {         builder.value(indexMetaData.primaryTerm(i)).     }     builder.endArray().     builder.startObject(KEY_IN_SYNC_ALLOCATIONS).     for (IntObjectCursor<Set<String>> cursor : indexMetaData.inSyncAllocationIds) {         builder.startArray(String.valueOf(cursor.key)).         for (String allocationId : cursor.value) {             builder.value(allocationId).         }         builder.endArray().     }     builder.endObject().     builder.startObject(KEY_ROLLOVER_INFOS).     for (ObjectCursor<RolloverInfo> cursor : indexMetaData.getRolloverInfos().values()) {         cursor.value.toXContent(builder, params).     }     builder.endObject().     builder.endObject(). }
false;public,static;1;134;;public static IndexMetaData fromXContent(XContentParser parser) throws IOException {     if (parser.currentToken() == null) {         // fresh parser? move to the first token         parser.nextToken().     }     if (parser.currentToken() == XContentParser.Token.START_OBJECT) {         // on a start object move to next token         parser.nextToken().     }     if (parser.currentToken() != XContentParser.Token.FIELD_NAME) {         throw new IllegalArgumentException("expected field name but got a " + parser.currentToken()).     }     Builder builder = new Builder(parser.currentName()).     String currentFieldName = null.     XContentParser.Token token = parser.nextToken().     if (token != XContentParser.Token.START_OBJECT) {         throw new IllegalArgumentException("expected object but got a " + token).     }     boolean mappingVersion = false.     boolean settingsVersion = false.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (token == XContentParser.Token.START_OBJECT) {             if (KEY_SETTINGS.equals(currentFieldName)) {                 builder.settings(Settings.fromXContent(parser)).             } else if (KEY_MAPPINGS.equals(currentFieldName)) {                 while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {                     if (token == XContentParser.Token.FIELD_NAME) {                         currentFieldName = parser.currentName().                     } else if (token == XContentParser.Token.START_OBJECT) {                         String mappingType = currentFieldName.                         Map<String, Object> mappingSource = MapBuilder.<String, Object>newMapBuilder().put(mappingType, parser.mapOrdered()).map().                         builder.putMapping(new MappingMetaData(mappingType, mappingSource)).                     } else {                         throw new IllegalArgumentException("Unexpected token: " + token).                     }                 }             } else if (KEY_ALIASES.equals(currentFieldName)) {                 while (parser.nextToken() != XContentParser.Token.END_OBJECT) {                     builder.putAlias(AliasMetaData.Builder.fromXContent(parser)).                 }             } else if (KEY_IN_SYNC_ALLOCATIONS.equals(currentFieldName)) {                 while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {                     if (token == XContentParser.Token.FIELD_NAME) {                         currentFieldName = parser.currentName().                     } else if (token == XContentParser.Token.START_ARRAY) {                         String shardId = currentFieldName.                         Set<String> allocationIds = new HashSet<>().                         while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {                             if (token == XContentParser.Token.VALUE_STRING) {                                 allocationIds.add(parser.text()).                             }                         }                         builder.putInSyncAllocationIds(Integer.valueOf(shardId), allocationIds).                     } else {                         throw new IllegalArgumentException("Unexpected token: " + token).                     }                 }             } else if (KEY_ROLLOVER_INFOS.equals(currentFieldName)) {                 while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {                     if (token == XContentParser.Token.FIELD_NAME) {                         currentFieldName = parser.currentName().                     } else if (token == XContentParser.Token.START_OBJECT) {                         builder.putRolloverInfo(RolloverInfo.parse(parser, currentFieldName)).                     } else {                         throw new IllegalArgumentException("Unexpected token: " + token).                     }                 }             } else if ("warmers".equals(currentFieldName)) {                 // simply ignored when upgrading from 2.x                 assert Version.CURRENT.major <= 5.                 parser.skipChildren().             } else {                 // assume it's custom index metadata                 builder.putCustom(currentFieldName, parser.mapStrings()).             }         } else if (token == XContentParser.Token.START_ARRAY) {             if (KEY_MAPPINGS.equals(currentFieldName)) {                 while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {                     if (token == XContentParser.Token.VALUE_EMBEDDED_OBJECT) {                         builder.putMapping(new MappingMetaData(new CompressedXContent(parser.binaryValue()))).                     } else {                         Map<String, Object> mapping = parser.mapOrdered().                         if (mapping.size() == 1) {                             String mappingType = mapping.keySet().iterator().next().                             builder.putMapping(new MappingMetaData(mappingType, mapping)).                         }                     }                 }             } else if (KEY_PRIMARY_TERMS.equals(currentFieldName)) {                 LongArrayList list = new LongArrayList().                 while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {                     if (token == XContentParser.Token.VALUE_NUMBER) {                         list.add(parser.longValue()).                     } else {                         throw new IllegalStateException("found a non-numeric value under [" + KEY_PRIMARY_TERMS + "]").                     }                 }                 builder.primaryTerms(list.toArray()).             } else {                 throw new IllegalArgumentException("Unexpected field for an array " + currentFieldName).             }         } else if (token.isValue()) {             if (KEY_STATE.equals(currentFieldName)) {                 builder.state(State.fromString(parser.text())).             } else if (KEY_VERSION.equals(currentFieldName)) {                 builder.version(parser.longValue()).             } else if (KEY_MAPPING_VERSION.equals(currentFieldName)) {                 mappingVersion = true.                 builder.mappingVersion(parser.longValue()).             } else if (KEY_SETTINGS_VERSION.equals(currentFieldName)) {                 settingsVersion = true.                 builder.settingsVersion(parser.longValue()).             } else if (KEY_ROUTING_NUM_SHARDS.equals(currentFieldName)) {                 builder.setRoutingNumShards(parser.intValue()).             } else {                 throw new IllegalArgumentException("Unexpected field [" + currentFieldName + "]").             }         } else {             throw new IllegalArgumentException("Unexpected token " + token).         }     }     if (Assertions.ENABLED && Version.indexCreated(builder.settings).onOrAfter(Version.V_6_5_0)) {         assert mappingVersion : "mapping version should be present for indices created on or after 6.5.0".     }     if (Assertions.ENABLED && Version.indexCreated(builder.settings).onOrAfter(Version.V_6_5_0)) {         assert settingsVersion : "settings version should be present for indices created on or after 6.5.0".     }     return builder.build(). }
true;public,static;1;17;/**  * Adds human readable version and creation date settings.  * This method is used to display the settings in a human readable format in REST API  */ ;/**  * Adds human readable version and creation date settings.  * This method is used to display the settings in a human readable format in REST API  */ public static Settings addHumanReadableSettings(Settings settings) {     Settings.Builder builder = Settings.builder().put(settings).     Version version = SETTING_INDEX_VERSION_CREATED.get(settings).     if (version != Version.V_EMPTY) {         builder.put(SETTING_VERSION_CREATED_STRING, version.toString()).     }     Version versionUpgraded = settings.getAsVersion(SETTING_VERSION_UPGRADED, null).     if (versionUpgraded != null) {         builder.put(SETTING_VERSION_UPGRADED_STRING, versionUpgraded.toString()).     }     Long creationDate = settings.getAsLong(SETTING_CREATION_DATE, null).     if (creationDate != null) {         ZonedDateTime creationDateTime = ZonedDateTime.ofInstant(Instant.ofEpochMilli(creationDate), ZoneOffset.UTC).         builder.put(SETTING_CREATION_DATE_STRING, creationDateTime.toString()).     }     return builder.build(). }
false;public;2;4;;@Override public void toXContent(XContentBuilder builder, IndexMetaData state) throws IOException {     Builder.toXContent(state, builder, FORMAT_PARAMS). }
false;public;1;6;;@Override public IndexMetaData fromXContent(XContentParser parser) throws IOException {     assert parser.getXContentRegistry() != NamedXContentRegistry.EMPTY : "loading index metadata requires a working named xcontent registry".     return Builder.fromXContent(parser). }
true;public;0;3;/**  * Returns the number of shards that should be used for routing. This basically defines the hash space we use in  * {@link org.elasticsearch.cluster.routing.OperationRouting#generateShardId(IndexMetaData, String, String)} to route documents  * to shards based on their ID or their specific routing value. The default value is {@link #getNumberOfShards()}. This value only  * changes if and index is shrunk.  */ ;/**  * Returns the number of shards that should be used for routing. This basically defines the hash space we use in  * {@link org.elasticsearch.cluster.routing.OperationRouting#generateShardId(IndexMetaData, String, String)} to route documents  * to shards based on their ID or their specific routing value. The default value is {@link #getNumberOfShards()}. This value only  * changes if and index is shrunk.  */ public int getRoutingNumShards() {     return routingNumShards. }
true;public;0;3;/**  * Returns the routing factor for this index. The default is {@code 1}.  *  * @see #getRoutingFactor(int, int) for details  */ ;/**  * Returns the routing factor for this index. The default is {@code 1}.  *  * @see #getRoutingFactor(int, int) for details  */ public int getRoutingFactor() {     return routingFactor. }
true;public,static;3;10;/**  * Returns the source shard ID to split the given target shard off  * @param shardId the id of the target shard to split into  * @param sourceIndexMetadata the source index metadata  * @param numTargetShards the total number of shards in the target index  * @return a the source shard ID to split off from  */ ;/**  * Returns the source shard ID to split the given target shard off  * @param shardId the id of the target shard to split into  * @param sourceIndexMetadata the source index metadata  * @param numTargetShards the total number of shards in the target index  * @return a the source shard ID to split off from  */ public static ShardId selectSplitShard(int shardId, IndexMetaData sourceIndexMetadata, int numTargetShards) {     int numSourceShards = sourceIndexMetadata.getNumberOfShards().     if (shardId >= numTargetShards) {         throw new IllegalArgumentException("the number of target shards (" + numTargetShards + ") must be greater than the shard id: " + shardId).     }     final int routingFactor = getRoutingFactor(numSourceShards, numTargetShards).     assertSplitMetadata(numSourceShards, numTargetShards, sourceIndexMetadata).     return new ShardId(sourceIndexMetadata.getIndex(), shardId / routingFactor). }
false;private,static;3;18;;private static void assertSplitMetadata(int numSourceShards, int numTargetShards, IndexMetaData sourceIndexMetadata) {     if (numSourceShards > numTargetShards) {         throw new IllegalArgumentException("the number of source shards [" + numSourceShards + "] must be less that the number of target shards [" + numTargetShards + "]").     }     // now we verify that the numRoutingShards is valid in the source index     // note: if the number of shards is 1 in the source index we can just assume it's correct since from 1 we can split into anything     // this is important to special case here since we use this to validate this in various places in the code but allow to split form     // 1 to N but we never modify the sourceIndexMetadata to accommodate for that     int routingNumShards = numSourceShards == 1 ? numTargetShards : sourceIndexMetadata.getRoutingNumShards().     if (routingNumShards % numTargetShards != 0) {         throw new IllegalStateException("the number of routing shards [" + routingNumShards + "] must be a multiple of the target shards [" + numTargetShards + "]").     }     // this is just an additional assertion that ensures we are a factor of the routing num shards.     assert // special case - we can split into anything from 1 shard     sourceIndexMetadata.getNumberOfShards() == 1 || getRoutingFactor(numTargetShards, routingNumShards) >= 0. }
true;public,static;3;8;/**  * Selects the source shards for a local shard recovery. This might either be a split or a shrink operation.  * @param shardId the target shard ID to select the source shards for  * @param sourceIndexMetadata the source metadata  * @param numTargetShards the number of target shards  */ ;/**  * Selects the source shards for a local shard recovery. This might either be a split or a shrink operation.  * @param shardId the target shard ID to select the source shards for  * @param sourceIndexMetadata the source metadata  * @param numTargetShards the number of target shards  */ public static Set<ShardId> selectRecoverFromShards(int shardId, IndexMetaData sourceIndexMetadata, int numTargetShards) {     if (sourceIndexMetadata.getNumberOfShards() > numTargetShards) {         return selectShrinkShards(shardId, sourceIndexMetadata, numTargetShards).     } else if (sourceIndexMetadata.getNumberOfShards() < numTargetShards) {         return Collections.singleton(selectSplitShard(shardId, sourceIndexMetadata, numTargetShards)).     }     throw new IllegalArgumentException("can't select recover from shards if both indices have the same number of shards"). }
true;public,static;3;16;/**  * Returns the source shard ids to shrink into the given shard id.  * @param shardId the id of the target shard to shrink to  * @param sourceIndexMetadata the source index metadata  * @param numTargetShards the total number of shards in the target index  * @return a set of shard IDs to shrink into the given shard ID.  */ ;/**  * Returns the source shard ids to shrink into the given shard id.  * @param shardId the id of the target shard to shrink to  * @param sourceIndexMetadata the source index metadata  * @param numTargetShards the total number of shards in the target index  * @return a set of shard IDs to shrink into the given shard ID.  */ public static Set<ShardId> selectShrinkShards(int shardId, IndexMetaData sourceIndexMetadata, int numTargetShards) {     if (shardId >= numTargetShards) {         throw new IllegalArgumentException("the number of target shards (" + numTargetShards + ") must be greater than the shard id: " + shardId).     }     if (sourceIndexMetadata.getNumberOfShards() < numTargetShards) {         throw new IllegalArgumentException("the number of target shards [" + numTargetShards + "] must be less that the number of source shards [" + sourceIndexMetadata.getNumberOfShards() + "]").     }     int routingFactor = getRoutingFactor(sourceIndexMetadata.getNumberOfShards(), numTargetShards).     Set<ShardId> shards = new HashSet<>(routingFactor).     for (int i = shardId * routingFactor. i < routingFactor * shardId + routingFactor. i++) {         shards.add(new ShardId(sourceIndexMetadata.getIndex(), i)).     }     return shards. }
true;public,static;2;21;/**  * Returns the routing factor for and shrunk index with the given number of target shards.  * This factor is used in the hash function in  * {@link org.elasticsearch.cluster.routing.OperationRouting#generateShardId(IndexMetaData, String, String)} to guarantee consistent  * hashing / routing of documents even if the number of shards changed (ie. a shrunk index).  *  * @param sourceNumberOfShards the total number of shards in the source index  * @param targetNumberOfShards the total number of shards in the target index  * @return the routing factor for and shrunk index with the given number of target shards.  * @throws IllegalArgumentException if the number of source shards is less than the number of target shards or if the source shards  * are not divisible by the number of target shards.  */ ;/**  * Returns the routing factor for and shrunk index with the given number of target shards.  * This factor is used in the hash function in  * {@link org.elasticsearch.cluster.routing.OperationRouting#generateShardId(IndexMetaData, String, String)} to guarantee consistent  * hashing / routing of documents even if the number of shards changed (ie. a shrunk index).  *  * @param sourceNumberOfShards the total number of shards in the source index  * @param targetNumberOfShards the total number of shards in the target index  * @return the routing factor for and shrunk index with the given number of target shards.  * @throws IllegalArgumentException if the number of source shards is less than the number of target shards or if the source shards  * are not divisible by the number of target shards.  */ public static int getRoutingFactor(int sourceNumberOfShards, int targetNumberOfShards) {     final int factor.     if (sourceNumberOfShards < targetNumberOfShards) {         // split         factor = targetNumberOfShards / sourceNumberOfShards.         if (factor * sourceNumberOfShards != targetNumberOfShards || factor <= 1) {             throw new IllegalArgumentException("the number of source shards [" + sourceNumberOfShards + "] must be a " + "factor of [" + targetNumberOfShards + "]").         }     } else if (sourceNumberOfShards > targetNumberOfShards) {         // shrink         factor = sourceNumberOfShards / targetNumberOfShards.         if (factor * targetNumberOfShards != sourceNumberOfShards || factor <= 1) {             throw new IllegalArgumentException("the number of source shards [" + sourceNumberOfShards + "] must be a " + "multiple of [" + targetNumberOfShards + "]").         }     } else {         factor = 1.     }     return factor. }
