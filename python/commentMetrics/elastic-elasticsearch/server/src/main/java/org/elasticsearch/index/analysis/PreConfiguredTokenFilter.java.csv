commented;modifiers;parameterAmount;loc;comment;code
true;public,static;3;5;/**  * Create a pre-configured token filter that may not vary at all.  */ ;/**  * Create a pre-configured token filter that may not vary at all.  */ public static PreConfiguredTokenFilter singleton(String name, boolean useFilterForMultitermQueries, Function<TokenStream, TokenStream> create) {     return new PreConfiguredTokenFilter(name, useFilterForMultitermQueries, true, CachingStrategy.ONE, (tokenStream, version) -> create.apply(tokenStream)). }
true;public,static;4;6;/**  * Create a pre-configured token filter that may not vary at all.  */ ;/**  * Create a pre-configured token filter that may not vary at all.  */ public static PreConfiguredTokenFilter singleton(String name, boolean useFilterForMultitermQueries, boolean allowForSynonymParsing, Function<TokenStream, TokenStream> create) {     return new PreConfiguredTokenFilter(name, useFilterForMultitermQueries, allowForSynonymParsing, CachingStrategy.ONE, (tokenStream, version) -> create.apply(tokenStream)). }
true;public,static;3;5;/**  * Create a pre-configured token filter that may vary based on the Elasticsearch version.  */ ;/**  * Create a pre-configured token filter that may vary based on the Elasticsearch version.  */ public static PreConfiguredTokenFilter singletonWithVersion(String name, boolean useFilterForMultitermQueries, BiFunction<TokenStream, Version, TokenStream> create) {     return new PreConfiguredTokenFilter(name, useFilterForMultitermQueries, true, CachingStrategy.ONE, (tokenStream, version) -> create.apply(tokenStream, version)). }
true;public,static;4;6;/**  * Create a pre-configured token filter that may vary based on the Elasticsearch version.  */ ;/**  * Create a pre-configured token filter that may vary based on the Elasticsearch version.  */ public static PreConfiguredTokenFilter singletonWithVersion(String name, boolean useFilterForMultitermQueries, boolean useFilterForParsingSynonyms, BiFunction<TokenStream, Version, TokenStream> create) {     return new PreConfiguredTokenFilter(name, useFilterForMultitermQueries, useFilterForParsingSynonyms, CachingStrategy.ONE, (tokenStream, version) -> create.apply(tokenStream, version)). }
true;public,static;3;5;/**  * Create a pre-configured token filter that may vary based on the Lucene version.  */ ;/**  * Create a pre-configured token filter that may vary based on the Lucene version.  */ public static PreConfiguredTokenFilter luceneVersion(String name, boolean useFilterForMultitermQueries, BiFunction<TokenStream, org.apache.lucene.util.Version, TokenStream> create) {     return new PreConfiguredTokenFilter(name, useFilterForMultitermQueries, true, CachingStrategy.LUCENE, (tokenStream, version) -> create.apply(tokenStream, version.luceneVersion)). }
true;public,static;3;4;/**  * Create a pre-configured token filter that may vary based on the Elasticsearch version.  */ ;/**  * Create a pre-configured token filter that may vary based on the Elasticsearch version.  */ public static PreConfiguredTokenFilter elasticsearchVersion(String name, boolean useFilterForMultitermQueries, BiFunction<TokenStream, org.elasticsearch.Version, TokenStream> create) {     return new PreConfiguredTokenFilter(name, useFilterForMultitermQueries, true, CachingStrategy.ELASTICSEARCH, create). }
true;public;0;3;/**  * Can this {@link TokenFilter} be used in multi-term queries?  */ ;/**  * Can this {@link TokenFilter} be used in multi-term queries?  */ public boolean shouldUseFilterForMultitermQueries() {     return useFilterForMultitermQueries. }
false;public;1;4;;@Override public TokenStream normalize(TokenStream tokenStream) {     return create.apply(tokenStream, version). }
false;public;0;4;;@Override public String name() {     return getName(). }
false;public;1;4;;@Override public TokenStream create(TokenStream tokenStream) {     return create.apply(tokenStream, version). }
false;public;0;14;;@Override public TokenFilterFactory getSynonymFilter() {     if (allowForSynonymParsing) {         return this.     }     if (version.onOrAfter(Version.V_7_0_0)) {         throw new IllegalArgumentException("Token filter [" + name() + "] cannot be used to parse synonyms").     } else {         DEPRECATION_LOGGER.deprecatedAndMaybeLog(name(), "Token filter [" + name() + "] will not be usable to parse synonyms after v7.0").         return this.     } }
false;public;0;4;;@Override public String name() {     return getName(). }
false;public;1;4;;@Override public TokenStream create(TokenStream tokenStream) {     return create.apply(tokenStream, version). }
false;public;0;14;;@Override public TokenFilterFactory getSynonymFilter() {     if (allowForSynonymParsing) {         return this.     }     if (version.onOrAfter(Version.V_7_0_0)) {         throw new IllegalArgumentException("Token filter [" + name() + "] cannot be used to parse synonyms").     } else {         DEPRECATION_LOGGER.deprecatedAndMaybeLog(name(), "Token filter [" + name() + "] will not be usable to parse synonyms after v7.0").         return this.     } }
false;protected;1;63;;@Override protected TokenFilterFactory create(Version version) {     if (useFilterForMultitermQueries) {         return new NormalizingTokenFilterFactory() {              @Override             public TokenStream normalize(TokenStream tokenStream) {                 return create.apply(tokenStream, version).             }              @Override             public String name() {                 return getName().             }              @Override             public TokenStream create(TokenStream tokenStream) {                 return create.apply(tokenStream, version).             }              @Override             public TokenFilterFactory getSynonymFilter() {                 if (allowForSynonymParsing) {                     return this.                 }                 if (version.onOrAfter(Version.V_7_0_0)) {                     throw new IllegalArgumentException("Token filter [" + name() + "] cannot be used to parse synonyms").                 } else {                     DEPRECATION_LOGGER.deprecatedAndMaybeLog(name(), "Token filter [" + name() + "] will not be usable to parse synonyms after v7.0").                     return this.                 }             }         }.     }     return new TokenFilterFactory() {          @Override         public String name() {             return getName().         }          @Override         public TokenStream create(TokenStream tokenStream) {             return create.apply(tokenStream, version).         }          @Override         public TokenFilterFactory getSynonymFilter() {             if (allowForSynonymParsing) {                 return this.             }             if (version.onOrAfter(Version.V_7_0_0)) {                 throw new IllegalArgumentException("Token filter [" + name() + "] cannot be used to parse synonyms").             } else {                 DEPRECATION_LOGGER.deprecatedAndMaybeLog(name(), "Token filter [" + name() + "] will not be usable to parse synonyms after v7.0").                 return this.             }         }     }. }
