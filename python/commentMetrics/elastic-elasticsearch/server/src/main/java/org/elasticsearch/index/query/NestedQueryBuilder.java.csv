commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;8;;@Override protected void doWriteTo(StreamOutput out) throws IOException {     out.writeString(path).     out.writeVInt(scoreMode.ordinal()).     out.writeNamedWriteable(query).     out.writeOptionalWriteable(innerHitBuilder).     out.writeBoolean(ignoreUnmapped). }
true;public;0;3;/**  * Returns the nested query to execute.  */ ;/**  * Returns the nested query to execute.  */ public QueryBuilder query() {     return query. }
false;public;0;3;;/**  * Returns inner hit definition in the scope of this query and reusing the defined type and query.  */ public InnerHitBuilder innerHit() {     return innerHitBuilder. }
false;public;1;5;;public NestedQueryBuilder innerHit(InnerHitBuilder innerHitBuilder) {     this.innerHitBuilder = innerHitBuilder.     innerHitBuilder.setIgnoreUnmapped(ignoreUnmapped).     return this. }
true;public;0;3;/**  * Returns how the scores from the matching child documents are mapped into the nested parent document.  */ ;/**  * Returns how the scores from the matching child documents are mapped into the nested parent document.  */ public ScoreMode scoreMode() {     return scoreMode. }
true;public;1;7;/**  * Sets whether the query builder should ignore unmapped paths (and run a  * {@link MatchNoDocsQuery} in place of this query) or throw an exception if  * the path is unmapped.  */ ;/**  * Sets whether the query builder should ignore unmapped paths (and run a  * {@link MatchNoDocsQuery} in place of this query) or throw an exception if  * the path is unmapped.  */ public NestedQueryBuilder ignoreUnmapped(boolean ignoreUnmapped) {     this.ignoreUnmapped = ignoreUnmapped.     if (innerHitBuilder != null) {         innerHitBuilder.setIgnoreUnmapped(ignoreUnmapped).     }     return this. }
true;public;0;3;/**  * Gets whether the query builder will ignore unmapped fields (and run a  * {@link MatchNoDocsQuery} in place of this query) or throw an exception if  * the path is unmapped.  */ ;/**  * Gets whether the query builder will ignore unmapped fields (and run a  * {@link MatchNoDocsQuery} in place of this query) or throw an exception if  * the path is unmapped.  */ public boolean ignoreUnmapped() {     return ignoreUnmapped. }
false;protected;2;16;;@Override protected void doXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject(NAME).     builder.field(QUERY_FIELD.getPreferredName()).     query.toXContent(builder, params).     builder.field(PATH_FIELD.getPreferredName(), path).     builder.field(IGNORE_UNMAPPED_FIELD.getPreferredName(), ignoreUnmapped).     if (scoreMode != null) {         builder.field(SCORE_MODE_FIELD.getPreferredName(), scoreModeAsString(scoreMode)).     }     printBoostAndQueryName(builder).     if (innerHitBuilder != null) {         builder.field(INNER_HITS_FIELD.getPreferredName(), innerHitBuilder, params).     }     builder.endObject(). }
false;public,static;1;43;;public static NestedQueryBuilder fromXContent(XContentParser parser) throws IOException {     float boost = AbstractQueryBuilder.DEFAULT_BOOST.     ScoreMode scoreMode = ScoreMode.Avg.     String queryName = null.     QueryBuilder query = null.     String path = null.     String currentFieldName = null.     InnerHitBuilder innerHitBuilder = null.     boolean ignoreUnmapped = DEFAULT_IGNORE_UNMAPPED.     XContentParser.Token token.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (token == XContentParser.Token.START_OBJECT) {             if (QUERY_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 query = parseInnerQueryBuilder(parser).             } else if (INNER_HITS_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 innerHitBuilder = InnerHitBuilder.fromXContent(parser).             } else {                 throw new ParsingException(parser.getTokenLocation(), "[nested] query does not support [" + currentFieldName + "]").             }         } else if (token.isValue()) {             if (PATH_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 path = parser.text().             } else if (AbstractQueryBuilder.BOOST_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 boost = parser.floatValue().             } else if (IGNORE_UNMAPPED_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 ignoreUnmapped = parser.booleanValue().             } else if (SCORE_MODE_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 scoreMode = parseScoreMode(parser.text()).             } else if (AbstractQueryBuilder.NAME_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 queryName = parser.text().             } else {                 throw new ParsingException(parser.getTokenLocation(), "[nested] query does not support [" + currentFieldName + "]").             }         }     }     NestedQueryBuilder queryBuilder = new NestedQueryBuilder(path, query, scoreMode, innerHitBuilder).ignoreUnmapped(ignoreUnmapped).queryName(queryName).boost(boost).     return queryBuilder. }
false;public,static;1;14;;public static ScoreMode parseScoreMode(String scoreModeString) {     if ("none".equals(scoreModeString)) {         return ScoreMode.None.     } else if ("min".equals(scoreModeString)) {         return ScoreMode.Min.     } else if ("max".equals(scoreModeString)) {         return ScoreMode.Max.     } else if ("avg".equals(scoreModeString)) {         return ScoreMode.Avg.     } else if ("sum".equals(scoreModeString)) {         return ScoreMode.Total.     }     throw new IllegalArgumentException("No score mode for child query [" + scoreModeString + "] found"). }
false;public,static;1;8;;public static String scoreModeAsString(ScoreMode scoreMode) {     if (scoreMode == ScoreMode.Total) {         // Lucene uses 'total' but 'sum' is more consistent with other elasticsearch APIs         return "sum".     } else {         return scoreMode.name().toLowerCase(Locale.ROOT).     } }
false;public,final;0;4;;@Override public final String getWriteableName() {     return NAME. }
false;protected;1;8;;@Override protected boolean doEquals(NestedQueryBuilder that) {     return Objects.equals(query, that.query) && Objects.equals(path, that.path) && Objects.equals(scoreMode, that.scoreMode) && Objects.equals(innerHitBuilder, that.innerHitBuilder) && Objects.equals(ignoreUnmapped, that.ignoreUnmapped). }
false;protected;0;4;;@Override protected int doHashCode() {     return Objects.hash(query, path, scoreMode, innerHitBuilder, ignoreUnmapped). }
false;protected;1;38;;@Override protected Query doToQuery(QueryShardContext context) throws IOException {     ObjectMapper nestedObjectMapper = context.getObjectMapper(path).     if (nestedObjectMapper == null) {         if (ignoreUnmapped) {             return new MatchNoDocsQuery().         } else {             throw new IllegalStateException("[" + NAME + "] failed to find nested object under path [" + path + "]").         }     }     if (!nestedObjectMapper.nested().isNested()) {         throw new IllegalStateException("[" + NAME + "] nested object under path [" + path + "] is not of nested type").     }     final BitSetProducer parentFilter.     Query innerQuery.     ObjectMapper objectMapper = context.nestedScope().getObjectMapper().     if (objectMapper == null) {         parentFilter = context.bitsetFilter(Queries.newNonNestedFilter(context.indexVersionCreated())).     } else {         parentFilter = context.bitsetFilter(objectMapper.nestedTypeFilter()).     }     try {         context.nestedScope().nextLevel(nestedObjectMapper).         innerQuery = this.query.toQuery(context).     } finally {         context.nestedScope().previousLevel().     }     // in its child space     if (new NestedHelper(context.getMapperService()).mightMatchNonNestedDocs(innerQuery, path)) {         innerQuery = Queries.filtered(innerQuery, nestedObjectMapper.nestedTypeFilter()).     }     return new ESToParentBlockJoinQuery(innerQuery, parentFilter, scoreMode, objectMapper == null ? null : objectMapper.fullPath()). }
false;protected;1;10;;@Override protected QueryBuilder doRewrite(QueryRewriteContext queryRewriteContext) throws IOException {     QueryBuilder rewrittenQuery = query.rewrite(queryRewriteContext).     if (rewrittenQuery != query) {         NestedQueryBuilder nestedQuery = new NestedQueryBuilder(path, rewrittenQuery, scoreMode, innerHitBuilder).         nestedQuery.ignoreUnmapped(ignoreUnmapped).         return nestedQuery.     }     return this. }
false;public;1;14;;@Override public void extractInnerHitBuilders(Map<String, InnerHitContextBuilder> innerHits) {     if (innerHitBuilder != null) {         String name = innerHitBuilder.getName() != null ? innerHitBuilder.getName() : path.         if (innerHits.containsKey(name)) {             throw new IllegalArgumentException("[inner_hits] already contains an entry for key [" + name + "]").         }         Map<String, InnerHitContextBuilder> children = new HashMap<>().         InnerHitContextBuilder.extractInnerHits(query, children).         InnerHitContextBuilder innerHitContextBuilder = new NestedInnerHitContextBuilder(path, query, innerHitBuilder, children).         innerHits.put(name, innerHitContextBuilder).     } }
false;protected;2;21;;@Override protected void doBuild(SearchContext parentSearchContext, InnerHitsContext innerHitsContext) throws IOException {     QueryShardContext queryShardContext = parentSearchContext.getQueryShardContext().     ObjectMapper nestedObjectMapper = queryShardContext.getObjectMapper(path).     if (nestedObjectMapper == null) {         if (innerHitBuilder.isIgnoreUnmapped() == false) {             throw new IllegalStateException("[" + query.getName() + "] no mapping found for type [" + path + "]").         } else {             return.         }     }     String name = innerHitBuilder.getName() != null ? innerHitBuilder.getName() : nestedObjectMapper.fullPath().     ObjectMapper parentObjectMapper = queryShardContext.nestedScope().nextLevel(nestedObjectMapper).     NestedInnerHitSubContext nestedInnerHits = new NestedInnerHitSubContext(name, parentSearchContext, parentObjectMapper, nestedObjectMapper).     setupInnerHitsContext(queryShardContext, nestedInnerHits).     queryShardContext.nestedScope().previousLevel().     innerHitsContext.addInnerHitDefinition(nestedInnerHits). }
false;public;1;7;;@Override public void seqNoAndPrimaryTerm(boolean seqNoAndPrimaryTerm) {     assert seqNoAndPrimaryTerm() == false.     if (seqNoAndPrimaryTerm) {         throw new UnsupportedOperationException("nested documents are not assigned sequence numbers").     } }
false;public;1;57;;@Override public TopDocsAndMaxScore[] topDocs(SearchHit[] hits) throws IOException {     Weight innerHitQueryWeight = createInnerHitQueryWeight().     TopDocsAndMaxScore[] result = new TopDocsAndMaxScore[hits.length].     for (int i = 0. i < hits.length. i++) {         SearchHit hit = hits[i].         Query rawParentFilter.         if (parentObjectMapper == null) {             rawParentFilter = Queries.newNonNestedFilter(context.indexShard().indexSettings().getIndexVersionCreated()).         } else {             rawParentFilter = parentObjectMapper.nestedTypeFilter().         }         int parentDocId = hit.docId().         final int readerIndex = ReaderUtil.subIndex(parentDocId, searcher().getIndexReader().leaves()).         // With nested inner hits the nested docs are always in the same segement, so need to use the other segments         LeafReaderContext ctx = searcher().getIndexReader().leaves().get(readerIndex).         Query childFilter = childObjectMapper.nestedTypeFilter().         BitSetProducer parentFilter = context.bitsetFilterCache().getBitSetProducer(rawParentFilter).         Query q = new ParentChildrenBlockJoinQuery(parentFilter, childFilter, parentDocId).         Weight weight = context.searcher().createWeight(context.searcher().rewrite(q), org.apache.lucene.search.ScoreMode.COMPLETE_NO_SCORES, 1f).         if (size() == 0) {             TotalHitCountCollector totalHitCountCollector = new TotalHitCountCollector().             intersect(weight, innerHitQueryWeight, totalHitCountCollector, ctx).             result[i] = new TopDocsAndMaxScore(new TopDocs(new TotalHits(totalHitCountCollector.getTotalHits(), TotalHits.Relation.EQUAL_TO), Lucene.EMPTY_SCORE_DOCS), Float.NaN).         } else {             int topN = Math.min(from() + size(), context.searcher().getIndexReader().maxDoc()).             TopDocsCollector<?> topDocsCollector.             MaxScoreCollector maxScoreCollector = null.             if (sort() != null) {                 topDocsCollector = TopFieldCollector.create(sort().sort, topN, Integer.MAX_VALUE).                 if (trackScores()) {                     maxScoreCollector = new MaxScoreCollector().                 }             } else {                 topDocsCollector = TopScoreDocCollector.create(topN, Integer.MAX_VALUE).                 maxScoreCollector = new MaxScoreCollector().             }             try {                 intersect(weight, innerHitQueryWeight, MultiCollector.wrap(topDocsCollector, maxScoreCollector), ctx).             } finally {                 clearReleasables(Lifetime.COLLECTION).             }             TopDocs td = topDocsCollector.topDocs(from(), size()).             float maxScore = Float.NaN.             if (maxScoreCollector != null) {                 maxScore = maxScoreCollector.getMaxScore().             }             result[i] = new TopDocsAndMaxScore(td, maxScore).         }     }     return result. }
