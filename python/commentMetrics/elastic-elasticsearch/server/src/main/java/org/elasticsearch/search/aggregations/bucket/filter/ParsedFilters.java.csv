commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String getType() {     return FiltersAggregationBuilder.NAME. }
false;public;0;4;;@Override public List<? extends Filters.Bucket> getBuckets() {     return buckets. }
false;public;1;10;;@Override public ParsedBucket getBucketByKey(String key) {     if (bucketMap == null) {         bucketMap = new HashMap<>(buckets.size()).         for (ParsedBucket bucket : buckets) {             bucketMap.put(bucket.getKey(), bucket).         }     }     return bucketMap.get(key). }
false;public,static;2;14;;public static ParsedFilters fromXContent(XContentParser parser, String name) throws IOException {     ParsedFilters aggregation = PARSER.parse(parser, null).     aggregation.setName(name).     // in case this is not a keyed aggregation, we need to add numeric keys to the buckets     if (aggregation.keyed == false) {         int i = 0.         for (ParsedBucket bucket : aggregation.buckets) {             assert bucket.key == null.             bucket.key = String.valueOf(i).             i++.         }     }     return aggregation. }
false;public;0;4;;@Override public String getKey() {     return key. }
false;public;0;4;;@Override public String getKeyAsString() {     return key. }
false;public;2;12;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     if (isKeyed()) {         builder.startObject(key).     } else {         builder.startObject().     }     builder.field(CommonFields.DOC_COUNT.getPreferredName(), getDocCount()).     getAggregations().toXContentInternal(builder, params).     builder.endObject().     return builder. }
false;static;2;27;;static ParsedBucket fromXContent(XContentParser parser, boolean keyed) throws IOException {     final ParsedBucket bucket = new ParsedBucket().     bucket.setKeyed(keyed).     XContentParser.Token token = parser.currentToken().     String currentFieldName = parser.currentName().     if (keyed) {         ensureExpectedToken(XContentParser.Token.FIELD_NAME, token, parser::getTokenLocation).         bucket.key = currentFieldName.         ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation).     }     List<Aggregation> aggregations = new ArrayList<>().     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (token.isValue()) {             if (CommonFields.DOC_COUNT.getPreferredName().equals(currentFieldName)) {                 bucket.setDocCount(parser.longValue()).             }         } else if (token == XContentParser.Token.START_OBJECT) {             XContentParserUtils.parseTypedKeysObject(parser, Aggregation.TYPED_KEYS_DELIMITER, Aggregation.class, aggregations::add).         }     }     bucket.setAggregations(new Aggregations(aggregations)).     return bucket. }
