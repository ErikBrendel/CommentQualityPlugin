commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;4;;@Override protected void doWriteTo(StreamOutput out) throws IOException {     out.writeString(fieldName). }
true;public;0;3;/**  * @return the field name that has to exist for this query to match  */ ;/**  * @return the field name that has to exist for this query to match  */ public String fieldName() {     return this.fieldName. }
false;protected;2;7;;@Override protected void doXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject(NAME).     builder.field(FIELD_FIELD.getPreferredName(), fieldName).     printBoostAndQueryName(builder).     builder.endObject(). }
false;public,static;1;36;;public static ExistsQueryBuilder fromXContent(XContentParser parser) throws IOException {     String fieldPattern = null.     String queryName = null.     float boost = AbstractQueryBuilder.DEFAULT_BOOST.     XContentParser.Token token.     String currentFieldName = null.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (token.isValue()) {             if (FIELD_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 fieldPattern = parser.text().             } else if (AbstractQueryBuilder.NAME_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 queryName = parser.text().             } else if (AbstractQueryBuilder.BOOST_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 boost = parser.floatValue().             } else {                 throw new ParsingException(parser.getTokenLocation(), "[" + ExistsQueryBuilder.NAME + "] query does not support [" + currentFieldName + "]").             }         } else {             throw new ParsingException(parser.getTokenLocation(), "[" + ExistsQueryBuilder.NAME + "] unknown token [" + token + "] after [" + currentFieldName + "]").         }     }     if (fieldPattern == null) {         throw new ParsingException(parser.getTokenLocation(), "[" + ExistsQueryBuilder.NAME + "] must be provided with a [field]").     }     ExistsQueryBuilder builder = new ExistsQueryBuilder(fieldPattern).     builder.queryName(queryName).     builder.boost(boost).     return builder. }
false;protected;1;4;;@Override protected Query doToQuery(QueryShardContext context) throws IOException {     return newFilter(context, fieldName). }
false;public,static;2;33;;public static Query newFilter(QueryShardContext context, String fieldPattern) {     final FieldNamesFieldMapper.FieldNamesFieldType fieldNamesFieldType = (FieldNamesFieldMapper.FieldNamesFieldType) context.getMapperService().fullName(FieldNamesFieldMapper.NAME).     if (fieldNamesFieldType == null) {         // can only happen when no types exist, so no docs exist either         return Queries.newMatchNoDocsQuery("Missing types in \"" + NAME + "\" query.").     }     final Collection<String> fields.     if (context.getObjectMapper(fieldPattern) != null) {         // the _field_names field also indexes objects, so we don't have to         // do any more work to support exists queries on whole objects         fields = Collections.singleton(fieldPattern).     } else {         fields = context.simpleMatchToIndexNames(fieldPattern).     }     if (context.indexVersionCreated().before(Version.V_6_1_0)) {         return newLegacyExistsQuery(context, fields).     }     if (fields.size() == 1) {         String field = fields.iterator().next().         return newFieldExistsQuery(context, field).     }     BooleanQuery.Builder boolFilterBuilder = new BooleanQuery.Builder().     for (String field : fields) {         boolFilterBuilder.add(newFieldExistsQuery(context, field), BooleanClause.Occur.SHOULD).     }     return new ConstantScoreQuery(boolFilterBuilder.build()). }
false;private,static;2;15;;private static Query newLegacyExistsQuery(QueryShardContext context, Collection<String> fields) {     // so we don't end up with deprecation warnings     if (fields.size() == 1) {         Query filter = newLegacyExistsQuery(context, fields.iterator().next()).         return new ConstantScoreQuery(filter).     }     BooleanQuery.Builder boolFilterBuilder = new BooleanQuery.Builder().     for (String field : fields) {         Query filter = newLegacyExistsQuery(context, field).         boolFilterBuilder.add(filter, BooleanClause.Occur.SHOULD).     }     return new ConstantScoreQuery(boolFilterBuilder.build()). }
false;private,static;2;5;;private static Query newLegacyExistsQuery(QueryShardContext context, String field) {     MappedFieldType fieldType = context.fieldMapper(field).     String fieldName = fieldType != null ? fieldType.name() : field.     return new TermQuery(new Term(FieldNamesFieldMapper.NAME, fieldName)). }
false;private,static;2;13;;private static Query newFieldExistsQuery(QueryShardContext context, String field) {     MappedFieldType fieldType = context.getMapperService().fullName(field).     if (fieldType == null) {         // check for an object mapper         if (context.getObjectMapper(field) != null) {             return newObjectFieldExistsQuery(context, field).         }         return Queries.newMatchNoDocsQuery("No field \"" + field + "\" exists in mappings.").     }     Query filter = fieldType.existsQuery(context).     return new ConstantScoreQuery(filter). }
false;private,static;2;9;;private static Query newObjectFieldExistsQuery(QueryShardContext context, String objField) {     BooleanQuery.Builder booleanQuery = new BooleanQuery.Builder().     Collection<String> fields = context.simpleMatchToIndexNames(objField + ".*").     for (String field : fields) {         Query existsQuery = context.getMapperService().fullName(field).existsQuery(context).         booleanQuery.add(existsQuery, Occur.SHOULD).     }     return new ConstantScoreQuery(booleanQuery.build()). }
false;protected;0;4;;@Override protected int doHashCode() {     return Objects.hash(fieldName). }
false;protected;1;4;;@Override protected boolean doEquals(ExistsQueryBuilder other) {     return Objects.equals(fieldName, other.fieldName). }
false;public;0;4;;@Override public String getWriteableName() {     return NAME. }
