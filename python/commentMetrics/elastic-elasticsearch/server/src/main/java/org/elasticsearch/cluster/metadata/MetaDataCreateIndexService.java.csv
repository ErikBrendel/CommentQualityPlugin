# id;timestamp;commentText;codeText;commentWords;codeWords
MetaDataCreateIndexService -> public static void validateIndexOrAliasName(String index, BiFunction<String, String, ? extends RuntimeException> exceptionCtor);1524684173;Validate the name for an index or alias against some static rules.;public static void validateIndexOrAliasName(String index, BiFunction<String, String, ? extends RuntimeException> exceptionCtor) {_        if (!Strings.validFileName(index)) {_            throw exceptionCtor.apply(index, "must not contain the following characters " + Strings.INVALID_FILENAME_CHARS)__        }_        if (index.contains("#")) {_            throw exceptionCtor.apply(index, "must not contain '#'")__        }_        if (index.contains(":")) {_            throw exceptionCtor.apply(index, "must not contain ':'")__        }_        if (index.charAt(0) == '_' || index.charAt(0) == '-' || index.charAt(0) == '+') {_            throw exceptionCtor.apply(index, "must not start with '_', '-', or '+'")__        }_        int byteCount = 0__        try {_            byteCount = index.getBytes("UTF-8").length__        } catch (UnsupportedEncodingException e) {_            _            throw new ElasticsearchException("Unable to determine length of index name", e)__        }_        if (byteCount > MAX_INDEX_NAME_BYTES) {_            throw exceptionCtor.apply(index, "index name is too long, (" + byteCount + " > " + MAX_INDEX_NAME_BYTES + ")")__        }_        if (index.equals(".") || index.equals("..")) {_            throw exceptionCtor.apply(index, "must not be '.' or '..'")__        }_    };validate,the,name,for,an,index,or,alias,against,some,static,rules;public,static,void,validate,index,or,alias,name,string,index,bi,function,string,string,extends,runtime,exception,exception,ctor,if,strings,valid,file,name,index,throw,exception,ctor,apply,index,must,not,contain,the,following,characters,strings,if,index,contains,throw,exception,ctor,apply,index,must,not,contain,if,index,contains,throw,exception,ctor,apply,index,must,not,contain,if,index,char,at,0,index,char,at,0,index,char,at,0,throw,exception,ctor,apply,index,must,not,start,with,or,int,byte,count,0,try,byte,count,index,get,bytes,utf,8,length,catch,unsupported,encoding,exception,e,throw,new,elasticsearch,exception,unable,to,determine,length,of,index,name,e,if,byte,count,throw,exception,ctor,apply,index,index,name,is,too,long,byte,count,if,index,equals,index,equals,throw,exception,ctor,apply,index,must,not,be,or
MetaDataCreateIndexService -> public static void validateIndexOrAliasName(String index, BiFunction<String, String, ? extends RuntimeException> exceptionCtor);1525162917;Validate the name for an index or alias against some static rules.;public static void validateIndexOrAliasName(String index, BiFunction<String, String, ? extends RuntimeException> exceptionCtor) {_        if (!Strings.validFileName(index)) {_            throw exceptionCtor.apply(index, "must not contain the following characters " + Strings.INVALID_FILENAME_CHARS)__        }_        if (index.contains("#")) {_            throw exceptionCtor.apply(index, "must not contain '#'")__        }_        if (index.contains(":")) {_            throw exceptionCtor.apply(index, "must not contain ':'")__        }_        if (index.charAt(0) == '_' || index.charAt(0) == '-' || index.charAt(0) == '+') {_            throw exceptionCtor.apply(index, "must not start with '_', '-', or '+'")__        }_        int byteCount = 0__        try {_            byteCount = index.getBytes("UTF-8").length__        } catch (UnsupportedEncodingException e) {_            _            throw new ElasticsearchException("Unable to determine length of index name", e)__        }_        if (byteCount > MAX_INDEX_NAME_BYTES) {_            throw exceptionCtor.apply(index, "index name is too long, (" + byteCount + " > " + MAX_INDEX_NAME_BYTES + ")")__        }_        if (index.equals(".") || index.equals("..")) {_            throw exceptionCtor.apply(index, "must not be '.' or '..'")__        }_    };validate,the,name,for,an,index,or,alias,against,some,static,rules;public,static,void,validate,index,or,alias,name,string,index,bi,function,string,string,extends,runtime,exception,exception,ctor,if,strings,valid,file,name,index,throw,exception,ctor,apply,index,must,not,contain,the,following,characters,strings,if,index,contains,throw,exception,ctor,apply,index,must,not,contain,if,index,contains,throw,exception,ctor,apply,index,must,not,contain,if,index,char,at,0,index,char,at,0,index,char,at,0,throw,exception,ctor,apply,index,must,not,start,with,or,int,byte,count,0,try,byte,count,index,get,bytes,utf,8,length,catch,unsupported,encoding,exception,e,throw,new,elasticsearch,exception,unable,to,determine,length,of,index,name,e,if,byte,count,throw,exception,ctor,apply,index,index,name,is,too,long,byte,count,if,index,equals,index,equals,throw,exception,ctor,apply,index,must,not,be,or
MetaDataCreateIndexService -> public static void validateIndexOrAliasName(String index, BiFunction<String, String, ? extends RuntimeException> exceptionCtor);1525248068;Validate the name for an index or alias against some static rules.;public static void validateIndexOrAliasName(String index, BiFunction<String, String, ? extends RuntimeException> exceptionCtor) {_        if (!Strings.validFileName(index)) {_            throw exceptionCtor.apply(index, "must not contain the following characters " + Strings.INVALID_FILENAME_CHARS)__        }_        if (index.contains("#")) {_            throw exceptionCtor.apply(index, "must not contain '#'")__        }_        if (index.contains(":")) {_            throw exceptionCtor.apply(index, "must not contain ':'")__        }_        if (index.charAt(0) == '_' || index.charAt(0) == '-' || index.charAt(0) == '+') {_            throw exceptionCtor.apply(index, "must not start with '_', '-', or '+'")__        }_        int byteCount = 0__        try {_            byteCount = index.getBytes("UTF-8").length__        } catch (UnsupportedEncodingException e) {_            _            throw new ElasticsearchException("Unable to determine length of index name", e)__        }_        if (byteCount > MAX_INDEX_NAME_BYTES) {_            throw exceptionCtor.apply(index, "index name is too long, (" + byteCount + " > " + MAX_INDEX_NAME_BYTES + ")")__        }_        if (index.equals(".") || index.equals("..")) {_            throw exceptionCtor.apply(index, "must not be '.' or '..'")__        }_    };validate,the,name,for,an,index,or,alias,against,some,static,rules;public,static,void,validate,index,or,alias,name,string,index,bi,function,string,string,extends,runtime,exception,exception,ctor,if,strings,valid,file,name,index,throw,exception,ctor,apply,index,must,not,contain,the,following,characters,strings,if,index,contains,throw,exception,ctor,apply,index,must,not,contain,if,index,contains,throw,exception,ctor,apply,index,must,not,contain,if,index,char,at,0,index,char,at,0,index,char,at,0,throw,exception,ctor,apply,index,must,not,start,with,or,int,byte,count,0,try,byte,count,index,get,bytes,utf,8,length,catch,unsupported,encoding,exception,e,throw,new,elasticsearch,exception,unable,to,determine,length,of,index,name,e,if,byte,count,throw,exception,ctor,apply,index,index,name,is,too,long,byte,count,if,index,equals,index,equals,throw,exception,ctor,apply,index,must,not,be,or
MetaDataCreateIndexService -> public static void validateIndexOrAliasName(String index, BiFunction<String, String, ? extends RuntimeException> exceptionCtor);1526374795;Validate the name for an index or alias against some static rules.;public static void validateIndexOrAliasName(String index, BiFunction<String, String, ? extends RuntimeException> exceptionCtor) {_        if (!Strings.validFileName(index)) {_            throw exceptionCtor.apply(index, "must not contain the following characters " + Strings.INVALID_FILENAME_CHARS)__        }_        if (index.contains("#")) {_            throw exceptionCtor.apply(index, "must not contain '#'")__        }_        if (index.contains(":")) {_            throw exceptionCtor.apply(index, "must not contain ':'")__        }_        if (index.charAt(0) == '_' || index.charAt(0) == '-' || index.charAt(0) == '+') {_            throw exceptionCtor.apply(index, "must not start with '_', '-', or '+'")__        }_        int byteCount = 0__        try {_            byteCount = index.getBytes("UTF-8").length__        } catch (UnsupportedEncodingException e) {_            _            throw new ElasticsearchException("Unable to determine length of index name", e)__        }_        if (byteCount > MAX_INDEX_NAME_BYTES) {_            throw exceptionCtor.apply(index, "index name is too long, (" + byteCount + " > " + MAX_INDEX_NAME_BYTES + ")")__        }_        if (index.equals(".") || index.equals("..")) {_            throw exceptionCtor.apply(index, "must not be '.' or '..'")__        }_    };validate,the,name,for,an,index,or,alias,against,some,static,rules;public,static,void,validate,index,or,alias,name,string,index,bi,function,string,string,extends,runtime,exception,exception,ctor,if,strings,valid,file,name,index,throw,exception,ctor,apply,index,must,not,contain,the,following,characters,strings,if,index,contains,throw,exception,ctor,apply,index,must,not,contain,if,index,contains,throw,exception,ctor,apply,index,must,not,contain,if,index,char,at,0,index,char,at,0,index,char,at,0,throw,exception,ctor,apply,index,must,not,start,with,or,int,byte,count,0,try,byte,count,index,get,bytes,utf,8,length,catch,unsupported,encoding,exception,e,throw,new,elasticsearch,exception,unable,to,determine,length,of,index,name,e,if,byte,count,throw,exception,ctor,apply,index,index,name,is,too,long,byte,count,if,index,equals,index,equals,throw,exception,ctor,apply,index,must,not,be,or
MetaDataCreateIndexService -> public static void validateIndexOrAliasName(String index, BiFunction<String, String, ? extends RuntimeException> exceptionCtor);1529082965;Validate the name for an index or alias against some static rules.;public static void validateIndexOrAliasName(String index, BiFunction<String, String, ? extends RuntimeException> exceptionCtor) {_        if (!Strings.validFileName(index)) {_            throw exceptionCtor.apply(index, "must not contain the following characters " + Strings.INVALID_FILENAME_CHARS)__        }_        if (index.contains("#")) {_            throw exceptionCtor.apply(index, "must not contain '#'")__        }_        if (index.contains(":")) {_            throw exceptionCtor.apply(index, "must not contain ':'")__        }_        if (index.charAt(0) == '_' || index.charAt(0) == '-' || index.charAt(0) == '+') {_            throw exceptionCtor.apply(index, "must not start with '_', '-', or '+'")__        }_        int byteCount = 0__        try {_            byteCount = index.getBytes("UTF-8").length__        } catch (UnsupportedEncodingException e) {_            _            throw new ElasticsearchException("Unable to determine length of index name", e)__        }_        if (byteCount > MAX_INDEX_NAME_BYTES) {_            throw exceptionCtor.apply(index, "index name is too long, (" + byteCount + " > " + MAX_INDEX_NAME_BYTES + ")")__        }_        if (index.equals(".") || index.equals("..")) {_            throw exceptionCtor.apply(index, "must not be '.' or '..'")__        }_    };validate,the,name,for,an,index,or,alias,against,some,static,rules;public,static,void,validate,index,or,alias,name,string,index,bi,function,string,string,extends,runtime,exception,exception,ctor,if,strings,valid,file,name,index,throw,exception,ctor,apply,index,must,not,contain,the,following,characters,strings,if,index,contains,throw,exception,ctor,apply,index,must,not,contain,if,index,contains,throw,exception,ctor,apply,index,must,not,contain,if,index,char,at,0,index,char,at,0,index,char,at,0,throw,exception,ctor,apply,index,must,not,start,with,or,int,byte,count,0,try,byte,count,index,get,bytes,utf,8,length,catch,unsupported,encoding,exception,e,throw,new,elasticsearch,exception,unable,to,determine,length,of,index,name,e,if,byte,count,throw,exception,ctor,apply,index,index,name,is,too,long,byte,count,if,index,equals,index,equals,throw,exception,ctor,apply,index,must,not,be,or
MetaDataCreateIndexService -> public static void validateIndexOrAliasName(String index, BiFunction<String, String, ? extends RuntimeException> exceptionCtor);1531382259;Validate the name for an index or alias against some static rules.;public static void validateIndexOrAliasName(String index, BiFunction<String, String, ? extends RuntimeException> exceptionCtor) {_        if (!Strings.validFileName(index)) {_            throw exceptionCtor.apply(index, "must not contain the following characters " + Strings.INVALID_FILENAME_CHARS)__        }_        if (index.contains("#")) {_            throw exceptionCtor.apply(index, "must not contain '#'")__        }_        if (index.contains(":")) {_            throw exceptionCtor.apply(index, "must not contain ':'")__        }_        if (index.charAt(0) == '_' || index.charAt(0) == '-' || index.charAt(0) == '+') {_            throw exceptionCtor.apply(index, "must not start with '_', '-', or '+'")__        }_        int byteCount = 0__        try {_            byteCount = index.getBytes("UTF-8").length__        } catch (UnsupportedEncodingException e) {_            _            throw new ElasticsearchException("Unable to determine length of index name", e)__        }_        if (byteCount > MAX_INDEX_NAME_BYTES) {_            throw exceptionCtor.apply(index, "index name is too long, (" + byteCount + " > " + MAX_INDEX_NAME_BYTES + ")")__        }_        if (index.equals(".") || index.equals("..")) {_            throw exceptionCtor.apply(index, "must not be '.' or '..'")__        }_    };validate,the,name,for,an,index,or,alias,against,some,static,rules;public,static,void,validate,index,or,alias,name,string,index,bi,function,string,string,extends,runtime,exception,exception,ctor,if,strings,valid,file,name,index,throw,exception,ctor,apply,index,must,not,contain,the,following,characters,strings,if,index,contains,throw,exception,ctor,apply,index,must,not,contain,if,index,contains,throw,exception,ctor,apply,index,must,not,contain,if,index,char,at,0,index,char,at,0,index,char,at,0,throw,exception,ctor,apply,index,must,not,start,with,or,int,byte,count,0,try,byte,count,index,get,bytes,utf,8,length,catch,unsupported,encoding,exception,e,throw,new,elasticsearch,exception,unable,to,determine,length,of,index,name,e,if,byte,count,throw,exception,ctor,apply,index,index,name,is,too,long,byte,count,if,index,equals,index,equals,throw,exception,ctor,apply,index,must,not,be,or
MetaDataCreateIndexService -> public static void validateIndexOrAliasName(String index, BiFunction<String, String, ? extends RuntimeException> exceptionCtor);1535666657;Validate the name for an index or alias against some static rules.;public static void validateIndexOrAliasName(String index, BiFunction<String, String, ? extends RuntimeException> exceptionCtor) {_        if (!Strings.validFileName(index)) {_            throw exceptionCtor.apply(index, "must not contain the following characters " + Strings.INVALID_FILENAME_CHARS)__        }_        if (index.contains("#")) {_            throw exceptionCtor.apply(index, "must not contain '#'")__        }_        if (index.contains(":")) {_            throw exceptionCtor.apply(index, "must not contain ':'")__        }_        if (index.charAt(0) == '_' || index.charAt(0) == '-' || index.charAt(0) == '+') {_            throw exceptionCtor.apply(index, "must not start with '_', '-', or '+'")__        }_        int byteCount = 0__        try {_            byteCount = index.getBytes("UTF-8").length__        } catch (UnsupportedEncodingException e) {_            _            throw new ElasticsearchException("Unable to determine length of index name", e)__        }_        if (byteCount > MAX_INDEX_NAME_BYTES) {_            throw exceptionCtor.apply(index, "index name is too long, (" + byteCount + " > " + MAX_INDEX_NAME_BYTES + ")")__        }_        if (index.equals(".") || index.equals("..")) {_            throw exceptionCtor.apply(index, "must not be '.' or '..'")__        }_    };validate,the,name,for,an,index,or,alias,against,some,static,rules;public,static,void,validate,index,or,alias,name,string,index,bi,function,string,string,extends,runtime,exception,exception,ctor,if,strings,valid,file,name,index,throw,exception,ctor,apply,index,must,not,contain,the,following,characters,strings,if,index,contains,throw,exception,ctor,apply,index,must,not,contain,if,index,contains,throw,exception,ctor,apply,index,must,not,contain,if,index,char,at,0,index,char,at,0,index,char,at,0,throw,exception,ctor,apply,index,must,not,start,with,or,int,byte,count,0,try,byte,count,index,get,bytes,utf,8,length,catch,unsupported,encoding,exception,e,throw,new,elasticsearch,exception,unable,to,determine,length,of,index,name,e,if,byte,count,throw,exception,ctor,apply,index,index,name,is,too,long,byte,count,if,index,equals,index,equals,throw,exception,ctor,apply,index,must,not,be,or
MetaDataCreateIndexService -> public static void validateIndexOrAliasName(String index, BiFunction<String, String, ? extends RuntimeException> exceptionCtor);1536137328;Validate the name for an index or alias against some static rules.;public static void validateIndexOrAliasName(String index, BiFunction<String, String, ? extends RuntimeException> exceptionCtor) {_        if (!Strings.validFileName(index)) {_            throw exceptionCtor.apply(index, "must not contain the following characters " + Strings.INVALID_FILENAME_CHARS)__        }_        if (index.contains("#")) {_            throw exceptionCtor.apply(index, "must not contain '#'")__        }_        if (index.contains(":")) {_            throw exceptionCtor.apply(index, "must not contain ':'")__        }_        if (index.charAt(0) == '_' || index.charAt(0) == '-' || index.charAt(0) == '+') {_            throw exceptionCtor.apply(index, "must not start with '_', '-', or '+'")__        }_        int byteCount = 0__        try {_            byteCount = index.getBytes("UTF-8").length__        } catch (UnsupportedEncodingException e) {_            _            throw new ElasticsearchException("Unable to determine length of index name", e)__        }_        if (byteCount > MAX_INDEX_NAME_BYTES) {_            throw exceptionCtor.apply(index, "index name is too long, (" + byteCount + " > " + MAX_INDEX_NAME_BYTES + ")")__        }_        if (index.equals(".") || index.equals("..")) {_            throw exceptionCtor.apply(index, "must not be '.' or '..'")__        }_    };validate,the,name,for,an,index,or,alias,against,some,static,rules;public,static,void,validate,index,or,alias,name,string,index,bi,function,string,string,extends,runtime,exception,exception,ctor,if,strings,valid,file,name,index,throw,exception,ctor,apply,index,must,not,contain,the,following,characters,strings,if,index,contains,throw,exception,ctor,apply,index,must,not,contain,if,index,contains,throw,exception,ctor,apply,index,must,not,contain,if,index,char,at,0,index,char,at,0,index,char,at,0,throw,exception,ctor,apply,index,must,not,start,with,or,int,byte,count,0,try,byte,count,index,get,bytes,utf,8,length,catch,unsupported,encoding,exception,e,throw,new,elasticsearch,exception,unable,to,determine,length,of,index,name,e,if,byte,count,throw,exception,ctor,apply,index,index,name,is,too,long,byte,count,if,index,equals,index,equals,throw,exception,ctor,apply,index,must,not,be,or
MetaDataCreateIndexService -> public static void validateIndexOrAliasName(String index, BiFunction<String, String, ? extends RuntimeException> exceptionCtor);1536828374;Validate the name for an index or alias against some static rules.;public static void validateIndexOrAliasName(String index, BiFunction<String, String, ? extends RuntimeException> exceptionCtor) {_        if (!Strings.validFileName(index)) {_            throw exceptionCtor.apply(index, "must not contain the following characters " + Strings.INVALID_FILENAME_CHARS)__        }_        if (index.contains("#")) {_            throw exceptionCtor.apply(index, "must not contain '#'")__        }_        if (index.contains(":")) {_            throw exceptionCtor.apply(index, "must not contain ':'")__        }_        if (index.charAt(0) == '_' || index.charAt(0) == '-' || index.charAt(0) == '+') {_            throw exceptionCtor.apply(index, "must not start with '_', '-', or '+'")__        }_        int byteCount = 0__        try {_            byteCount = index.getBytes("UTF-8").length__        } catch (UnsupportedEncodingException e) {_            _            throw new ElasticsearchException("Unable to determine length of index name", e)__        }_        if (byteCount > MAX_INDEX_NAME_BYTES) {_            throw exceptionCtor.apply(index, "index name is too long, (" + byteCount + " > " + MAX_INDEX_NAME_BYTES + ")")__        }_        if (index.equals(".") || index.equals("..")) {_            throw exceptionCtor.apply(index, "must not be '.' or '..'")__        }_    };validate,the,name,for,an,index,or,alias,against,some,static,rules;public,static,void,validate,index,or,alias,name,string,index,bi,function,string,string,extends,runtime,exception,exception,ctor,if,strings,valid,file,name,index,throw,exception,ctor,apply,index,must,not,contain,the,following,characters,strings,if,index,contains,throw,exception,ctor,apply,index,must,not,contain,if,index,contains,throw,exception,ctor,apply,index,must,not,contain,if,index,char,at,0,index,char,at,0,index,char,at,0,throw,exception,ctor,apply,index,must,not,start,with,or,int,byte,count,0,try,byte,count,index,get,bytes,utf,8,length,catch,unsupported,encoding,exception,e,throw,new,elasticsearch,exception,unable,to,determine,length,of,index,name,e,if,byte,count,throw,exception,ctor,apply,index,index,name,is,too,long,byte,count,if,index,equals,index,equals,throw,exception,ctor,apply,index,must,not,be,or
MetaDataCreateIndexService -> public static void validateIndexOrAliasName(String index, BiFunction<String, String, ? extends RuntimeException> exceptionCtor);1540486836;Validate the name for an index or alias against some static rules.;public static void validateIndexOrAliasName(String index, BiFunction<String, String, ? extends RuntimeException> exceptionCtor) {_        if (!Strings.validFileName(index)) {_            throw exceptionCtor.apply(index, "must not contain the following characters " + Strings.INVALID_FILENAME_CHARS)__        }_        if (index.contains("#")) {_            throw exceptionCtor.apply(index, "must not contain '#'")__        }_        if (index.contains(":")) {_            throw exceptionCtor.apply(index, "must not contain ':'")__        }_        if (index.charAt(0) == '_' || index.charAt(0) == '-' || index.charAt(0) == '+') {_            throw exceptionCtor.apply(index, "must not start with '_', '-', or '+'")__        }_        int byteCount = 0__        try {_            byteCount = index.getBytes("UTF-8").length__        } catch (UnsupportedEncodingException e) {_            _            throw new ElasticsearchException("Unable to determine length of index name", e)__        }_        if (byteCount > MAX_INDEX_NAME_BYTES) {_            throw exceptionCtor.apply(index, "index name is too long, (" + byteCount + " > " + MAX_INDEX_NAME_BYTES + ")")__        }_        if (index.equals(".") || index.equals("..")) {_            throw exceptionCtor.apply(index, "must not be '.' or '..'")__        }_    };validate,the,name,for,an,index,or,alias,against,some,static,rules;public,static,void,validate,index,or,alias,name,string,index,bi,function,string,string,extends,runtime,exception,exception,ctor,if,strings,valid,file,name,index,throw,exception,ctor,apply,index,must,not,contain,the,following,characters,strings,if,index,contains,throw,exception,ctor,apply,index,must,not,contain,if,index,contains,throw,exception,ctor,apply,index,must,not,contain,if,index,char,at,0,index,char,at,0,index,char,at,0,throw,exception,ctor,apply,index,must,not,start,with,or,int,byte,count,0,try,byte,count,index,get,bytes,utf,8,length,catch,unsupported,encoding,exception,e,throw,new,elasticsearch,exception,unable,to,determine,length,of,index,name,e,if,byte,count,throw,exception,ctor,apply,index,index,name,is,too,long,byte,count,if,index,equals,index,equals,throw,exception,ctor,apply,index,must,not,be,or
MetaDataCreateIndexService -> public static void validateIndexOrAliasName(String index, BiFunction<String, String, ? extends RuntimeException> exceptionCtor);1540847035;Validate the name for an index or alias against some static rules.;public static void validateIndexOrAliasName(String index, BiFunction<String, String, ? extends RuntimeException> exceptionCtor) {_        if (!Strings.validFileName(index)) {_            throw exceptionCtor.apply(index, "must not contain the following characters " + Strings.INVALID_FILENAME_CHARS)__        }_        if (index.contains("#")) {_            throw exceptionCtor.apply(index, "must not contain '#'")__        }_        if (index.contains(":")) {_            throw exceptionCtor.apply(index, "must not contain ':'")__        }_        if (index.charAt(0) == '_' || index.charAt(0) == '-' || index.charAt(0) == '+') {_            throw exceptionCtor.apply(index, "must not start with '_', '-', or '+'")__        }_        int byteCount = 0__        try {_            byteCount = index.getBytes("UTF-8").length__        } catch (UnsupportedEncodingException e) {_            _            throw new ElasticsearchException("Unable to determine length of index name", e)__        }_        if (byteCount > MAX_INDEX_NAME_BYTES) {_            throw exceptionCtor.apply(index, "index name is too long, (" + byteCount + " > " + MAX_INDEX_NAME_BYTES + ")")__        }_        if (index.equals(".") || index.equals("..")) {_            throw exceptionCtor.apply(index, "must not be '.' or '..'")__        }_    };validate,the,name,for,an,index,or,alias,against,some,static,rules;public,static,void,validate,index,or,alias,name,string,index,bi,function,string,string,extends,runtime,exception,exception,ctor,if,strings,valid,file,name,index,throw,exception,ctor,apply,index,must,not,contain,the,following,characters,strings,if,index,contains,throw,exception,ctor,apply,index,must,not,contain,if,index,contains,throw,exception,ctor,apply,index,must,not,contain,if,index,char,at,0,index,char,at,0,index,char,at,0,throw,exception,ctor,apply,index,must,not,start,with,or,int,byte,count,0,try,byte,count,index,get,bytes,utf,8,length,catch,unsupported,encoding,exception,e,throw,new,elasticsearch,exception,unable,to,determine,length,of,index,name,e,if,byte,count,throw,exception,ctor,apply,index,index,name,is,too,long,byte,count,if,index,equals,index,equals,throw,exception,ctor,apply,index,must,not,be,or
MetaDataCreateIndexService -> public static void validateIndexOrAliasName(String index, BiFunction<String, String, ? extends RuntimeException> exceptionCtor);1541008027;Validate the name for an index or alias against some static rules.;public static void validateIndexOrAliasName(String index, BiFunction<String, String, ? extends RuntimeException> exceptionCtor) {_        if (!Strings.validFileName(index)) {_            throw exceptionCtor.apply(index, "must not contain the following characters " + Strings.INVALID_FILENAME_CHARS)__        }_        if (index.contains("#")) {_            throw exceptionCtor.apply(index, "must not contain '#'")__        }_        if (index.contains(":")) {_            throw exceptionCtor.apply(index, "must not contain ':'")__        }_        if (index.charAt(0) == '_' || index.charAt(0) == '-' || index.charAt(0) == '+') {_            throw exceptionCtor.apply(index, "must not start with '_', '-', or '+'")__        }_        int byteCount = 0__        try {_            byteCount = index.getBytes("UTF-8").length__        } catch (UnsupportedEncodingException e) {_            _            throw new ElasticsearchException("Unable to determine length of index name", e)__        }_        if (byteCount > MAX_INDEX_NAME_BYTES) {_            throw exceptionCtor.apply(index, "index name is too long, (" + byteCount + " > " + MAX_INDEX_NAME_BYTES + ")")__        }_        if (index.equals(".") || index.equals("..")) {_            throw exceptionCtor.apply(index, "must not be '.' or '..'")__        }_    };validate,the,name,for,an,index,or,alias,against,some,static,rules;public,static,void,validate,index,or,alias,name,string,index,bi,function,string,string,extends,runtime,exception,exception,ctor,if,strings,valid,file,name,index,throw,exception,ctor,apply,index,must,not,contain,the,following,characters,strings,if,index,contains,throw,exception,ctor,apply,index,must,not,contain,if,index,contains,throw,exception,ctor,apply,index,must,not,contain,if,index,char,at,0,index,char,at,0,index,char,at,0,throw,exception,ctor,apply,index,must,not,start,with,or,int,byte,count,0,try,byte,count,index,get,bytes,utf,8,length,catch,unsupported,encoding,exception,e,throw,new,elasticsearch,exception,unable,to,determine,length,of,index,name,e,if,byte,count,throw,exception,ctor,apply,index,index,name,is,too,long,byte,count,if,index,equals,index,equals,throw,exception,ctor,apply,index,must,not,be,or
MetaDataCreateIndexService -> public static void validateIndexOrAliasName(String index, BiFunction<String, String, ? extends RuntimeException> exceptionCtor);1541092382;Validate the name for an index or alias against some static rules.;public static void validateIndexOrAliasName(String index, BiFunction<String, String, ? extends RuntimeException> exceptionCtor) {_        if (!Strings.validFileName(index)) {_            throw exceptionCtor.apply(index, "must not contain the following characters " + Strings.INVALID_FILENAME_CHARS)__        }_        if (index.contains("#")) {_            throw exceptionCtor.apply(index, "must not contain '#'")__        }_        if (index.contains(":")) {_            throw exceptionCtor.apply(index, "must not contain ':'")__        }_        if (index.charAt(0) == '_' || index.charAt(0) == '-' || index.charAt(0) == '+') {_            throw exceptionCtor.apply(index, "must not start with '_', '-', or '+'")__        }_        int byteCount = 0__        try {_            byteCount = index.getBytes("UTF-8").length__        } catch (UnsupportedEncodingException e) {_            _            throw new ElasticsearchException("Unable to determine length of index name", e)__        }_        if (byteCount > MAX_INDEX_NAME_BYTES) {_            throw exceptionCtor.apply(index, "index name is too long, (" + byteCount + " > " + MAX_INDEX_NAME_BYTES + ")")__        }_        if (index.equals(".") || index.equals("..")) {_            throw exceptionCtor.apply(index, "must not be '.' or '..'")__        }_    };validate,the,name,for,an,index,or,alias,against,some,static,rules;public,static,void,validate,index,or,alias,name,string,index,bi,function,string,string,extends,runtime,exception,exception,ctor,if,strings,valid,file,name,index,throw,exception,ctor,apply,index,must,not,contain,the,following,characters,strings,if,index,contains,throw,exception,ctor,apply,index,must,not,contain,if,index,contains,throw,exception,ctor,apply,index,must,not,contain,if,index,char,at,0,index,char,at,0,index,char,at,0,throw,exception,ctor,apply,index,must,not,start,with,or,int,byte,count,0,try,byte,count,index,get,bytes,utf,8,length,catch,unsupported,encoding,exception,e,throw,new,elasticsearch,exception,unable,to,determine,length,of,index,name,e,if,byte,count,throw,exception,ctor,apply,index,index,name,is,too,long,byte,count,if,index,equals,index,equals,throw,exception,ctor,apply,index,must,not,be,or
MetaDataCreateIndexService -> public static void validateIndexOrAliasName(String index, BiFunction<String, String, ? extends RuntimeException> exceptionCtor);1541592065;Validate the name for an index or alias against some static rules.;public static void validateIndexOrAliasName(String index, BiFunction<String, String, ? extends RuntimeException> exceptionCtor) {_        if (!Strings.validFileName(index)) {_            throw exceptionCtor.apply(index, "must not contain the following characters " + Strings.INVALID_FILENAME_CHARS)__        }_        if (index.contains("#")) {_            throw exceptionCtor.apply(index, "must not contain '#'")__        }_        if (index.contains(":")) {_            throw exceptionCtor.apply(index, "must not contain ':'")__        }_        if (index.charAt(0) == '_' || index.charAt(0) == '-' || index.charAt(0) == '+') {_            throw exceptionCtor.apply(index, "must not start with '_', '-', or '+'")__        }_        int byteCount = 0__        try {_            byteCount = index.getBytes("UTF-8").length__        } catch (UnsupportedEncodingException e) {_            _            throw new ElasticsearchException("Unable to determine length of index name", e)__        }_        if (byteCount > MAX_INDEX_NAME_BYTES) {_            throw exceptionCtor.apply(index, "index name is too long, (" + byteCount + " > " + MAX_INDEX_NAME_BYTES + ")")__        }_        if (index.equals(".") || index.equals("..")) {_            throw exceptionCtor.apply(index, "must not be '.' or '..'")__        }_    };validate,the,name,for,an,index,or,alias,against,some,static,rules;public,static,void,validate,index,or,alias,name,string,index,bi,function,string,string,extends,runtime,exception,exception,ctor,if,strings,valid,file,name,index,throw,exception,ctor,apply,index,must,not,contain,the,following,characters,strings,if,index,contains,throw,exception,ctor,apply,index,must,not,contain,if,index,contains,throw,exception,ctor,apply,index,must,not,contain,if,index,char,at,0,index,char,at,0,index,char,at,0,throw,exception,ctor,apply,index,must,not,start,with,or,int,byte,count,0,try,byte,count,index,get,bytes,utf,8,length,catch,unsupported,encoding,exception,e,throw,new,elasticsearch,exception,unable,to,determine,length,of,index,name,e,if,byte,count,throw,exception,ctor,apply,index,index,name,is,too,long,byte,count,if,index,equals,index,equals,throw,exception,ctor,apply,index,must,not,be,or
MetaDataCreateIndexService -> public static void validateIndexOrAliasName(String index, BiFunction<String, String, ? extends RuntimeException> exceptionCtor);1542402632;Validate the name for an index or alias against some static rules.;public static void validateIndexOrAliasName(String index, BiFunction<String, String, ? extends RuntimeException> exceptionCtor) {_        if (!Strings.validFileName(index)) {_            throw exceptionCtor.apply(index, "must not contain the following characters " + Strings.INVALID_FILENAME_CHARS)__        }_        if (index.contains("#")) {_            throw exceptionCtor.apply(index, "must not contain '#'")__        }_        if (index.contains(":")) {_            throw exceptionCtor.apply(index, "must not contain ':'")__        }_        if (index.charAt(0) == '_' || index.charAt(0) == '-' || index.charAt(0) == '+') {_            throw exceptionCtor.apply(index, "must not start with '_', '-', or '+'")__        }_        int byteCount = 0__        try {_            byteCount = index.getBytes("UTF-8").length__        } catch (UnsupportedEncodingException e) {_            _            throw new ElasticsearchException("Unable to determine length of index name", e)__        }_        if (byteCount > MAX_INDEX_NAME_BYTES) {_            throw exceptionCtor.apply(index, "index name is too long, (" + byteCount + " > " + MAX_INDEX_NAME_BYTES + ")")__        }_        if (index.equals(".") || index.equals("..")) {_            throw exceptionCtor.apply(index, "must not be '.' or '..'")__        }_    };validate,the,name,for,an,index,or,alias,against,some,static,rules;public,static,void,validate,index,or,alias,name,string,index,bi,function,string,string,extends,runtime,exception,exception,ctor,if,strings,valid,file,name,index,throw,exception,ctor,apply,index,must,not,contain,the,following,characters,strings,if,index,contains,throw,exception,ctor,apply,index,must,not,contain,if,index,contains,throw,exception,ctor,apply,index,must,not,contain,if,index,char,at,0,index,char,at,0,index,char,at,0,throw,exception,ctor,apply,index,must,not,start,with,or,int,byte,count,0,try,byte,count,index,get,bytes,utf,8,length,catch,unsupported,encoding,exception,e,throw,new,elasticsearch,exception,unable,to,determine,length,of,index,name,e,if,byte,count,throw,exception,ctor,apply,index,index,name,is,too,long,byte,count,if,index,equals,index,equals,throw,exception,ctor,apply,index,must,not,be,or
MetaDataCreateIndexService -> public static void validateIndexOrAliasName(String index, BiFunction<String, String, ? extends RuntimeException> exceptionCtor);1543277112;Validate the name for an index or alias against some static rules.;public static void validateIndexOrAliasName(String index, BiFunction<String, String, ? extends RuntimeException> exceptionCtor) {_        if (!Strings.validFileName(index)) {_            throw exceptionCtor.apply(index, "must not contain the following characters " + Strings.INVALID_FILENAME_CHARS)__        }_        if (index.contains("#")) {_            throw exceptionCtor.apply(index, "must not contain '#'")__        }_        if (index.contains(":")) {_            throw exceptionCtor.apply(index, "must not contain ':'")__        }_        if (index.charAt(0) == '_' || index.charAt(0) == '-' || index.charAt(0) == '+') {_            throw exceptionCtor.apply(index, "must not start with '_', '-', or '+'")__        }_        int byteCount = 0__        try {_            byteCount = index.getBytes("UTF-8").length__        } catch (UnsupportedEncodingException e) {_            _            throw new ElasticsearchException("Unable to determine length of index name", e)__        }_        if (byteCount > MAX_INDEX_NAME_BYTES) {_            throw exceptionCtor.apply(index, "index name is too long, (" + byteCount + " > " + MAX_INDEX_NAME_BYTES + ")")__        }_        if (index.equals(".") || index.equals("..")) {_            throw exceptionCtor.apply(index, "must not be '.' or '..'")__        }_    };validate,the,name,for,an,index,or,alias,against,some,static,rules;public,static,void,validate,index,or,alias,name,string,index,bi,function,string,string,extends,runtime,exception,exception,ctor,if,strings,valid,file,name,index,throw,exception,ctor,apply,index,must,not,contain,the,following,characters,strings,if,index,contains,throw,exception,ctor,apply,index,must,not,contain,if,index,contains,throw,exception,ctor,apply,index,must,not,contain,if,index,char,at,0,index,char,at,0,index,char,at,0,throw,exception,ctor,apply,index,must,not,start,with,or,int,byte,count,0,try,byte,count,index,get,bytes,utf,8,length,catch,unsupported,encoding,exception,e,throw,new,elasticsearch,exception,unable,to,determine,length,of,index,name,e,if,byte,count,throw,exception,ctor,apply,index,index,name,is,too,long,byte,count,if,index,equals,index,equals,throw,exception,ctor,apply,index,must,not,be,or
MetaDataCreateIndexService -> public static void validateIndexOrAliasName(String index, BiFunction<String, String, ? extends RuntimeException> exceptionCtor);1544702062;Validate the name for an index or alias against some static rules.;public static void validateIndexOrAliasName(String index, BiFunction<String, String, ? extends RuntimeException> exceptionCtor) {_        if (!Strings.validFileName(index)) {_            throw exceptionCtor.apply(index, "must not contain the following characters " + Strings.INVALID_FILENAME_CHARS)__        }_        if (index.contains("#")) {_            throw exceptionCtor.apply(index, "must not contain '#'")__        }_        if (index.contains(":")) {_            throw exceptionCtor.apply(index, "must not contain ':'")__        }_        if (index.charAt(0) == '_' || index.charAt(0) == '-' || index.charAt(0) == '+') {_            throw exceptionCtor.apply(index, "must not start with '_', '-', or '+'")__        }_        int byteCount = 0__        try {_            byteCount = index.getBytes("UTF-8").length__        } catch (UnsupportedEncodingException e) {_            _            throw new ElasticsearchException("Unable to determine length of index name", e)__        }_        if (byteCount > MAX_INDEX_NAME_BYTES) {_            throw exceptionCtor.apply(index, "index name is too long, (" + byteCount + " > " + MAX_INDEX_NAME_BYTES + ")")__        }_        if (index.equals(".") || index.equals("..")) {_            throw exceptionCtor.apply(index, "must not be '.' or '..'")__        }_    };validate,the,name,for,an,index,or,alias,against,some,static,rules;public,static,void,validate,index,or,alias,name,string,index,bi,function,string,string,extends,runtime,exception,exception,ctor,if,strings,valid,file,name,index,throw,exception,ctor,apply,index,must,not,contain,the,following,characters,strings,if,index,contains,throw,exception,ctor,apply,index,must,not,contain,if,index,contains,throw,exception,ctor,apply,index,must,not,contain,if,index,char,at,0,index,char,at,0,index,char,at,0,throw,exception,ctor,apply,index,must,not,start,with,or,int,byte,count,0,try,byte,count,index,get,bytes,utf,8,length,catch,unsupported,encoding,exception,e,throw,new,elasticsearch,exception,unable,to,determine,length,of,index,name,e,if,byte,count,throw,exception,ctor,apply,index,index,name,is,too,long,byte,count,if,index,equals,index,equals,throw,exception,ctor,apply,index,must,not,be,or
MetaDataCreateIndexService -> public static void validateIndexOrAliasName(String index, BiFunction<String, String, ? extends RuntimeException> exceptionCtor);1548840504;Validate the name for an index or alias against some static rules.;public static void validateIndexOrAliasName(String index, BiFunction<String, String, ? extends RuntimeException> exceptionCtor) {_        if (!Strings.validFileName(index)) {_            throw exceptionCtor.apply(index, "must not contain the following characters " + Strings.INVALID_FILENAME_CHARS)__        }_        if (index.contains("#")) {_            throw exceptionCtor.apply(index, "must not contain '#'")__        }_        if (index.contains(":")) {_            throw exceptionCtor.apply(index, "must not contain ':'")__        }_        if (index.charAt(0) == '_' || index.charAt(0) == '-' || index.charAt(0) == '+') {_            throw exceptionCtor.apply(index, "must not start with '_', '-', or '+'")__        }_        int byteCount = 0__        try {_            byteCount = index.getBytes("UTF-8").length__        } catch (UnsupportedEncodingException e) {_            _            throw new ElasticsearchException("Unable to determine length of index name", e)__        }_        if (byteCount > MAX_INDEX_NAME_BYTES) {_            throw exceptionCtor.apply(index, "index name is too long, (" + byteCount + " > " + MAX_INDEX_NAME_BYTES + ")")__        }_        if (index.equals(".") || index.equals("..")) {_            throw exceptionCtor.apply(index, "must not be '.' or '..'")__        }_    };validate,the,name,for,an,index,or,alias,against,some,static,rules;public,static,void,validate,index,or,alias,name,string,index,bi,function,string,string,extends,runtime,exception,exception,ctor,if,strings,valid,file,name,index,throw,exception,ctor,apply,index,must,not,contain,the,following,characters,strings,if,index,contains,throw,exception,ctor,apply,index,must,not,contain,if,index,contains,throw,exception,ctor,apply,index,must,not,contain,if,index,char,at,0,index,char,at,0,index,char,at,0,throw,exception,ctor,apply,index,must,not,start,with,or,int,byte,count,0,try,byte,count,index,get,bytes,utf,8,length,catch,unsupported,encoding,exception,e,throw,new,elasticsearch,exception,unable,to,determine,length,of,index,name,e,if,byte,count,throw,exception,ctor,apply,index,index,name,is,too,long,byte,count,if,index,equals,index,equals,throw,exception,ctor,apply,index,must,not,be,or
MetaDataCreateIndexService -> public static void validateIndexOrAliasName(String index, BiFunction<String, String, ? extends RuntimeException> exceptionCtor);1549608646;Validate the name for an index or alias against some static rules.;public static void validateIndexOrAliasName(String index, BiFunction<String, String, ? extends RuntimeException> exceptionCtor) {_        if (!Strings.validFileName(index)) {_            throw exceptionCtor.apply(index, "must not contain the following characters " + Strings.INVALID_FILENAME_CHARS)__        }_        if (index.contains("#")) {_            throw exceptionCtor.apply(index, "must not contain '#'")__        }_        if (index.contains(":")) {_            throw exceptionCtor.apply(index, "must not contain ':'")__        }_        if (index.charAt(0) == '_' || index.charAt(0) == '-' || index.charAt(0) == '+') {_            throw exceptionCtor.apply(index, "must not start with '_', '-', or '+'")__        }_        int byteCount = 0__        try {_            byteCount = index.getBytes("UTF-8").length__        } catch (UnsupportedEncodingException e) {_            _            throw new ElasticsearchException("Unable to determine length of index name", e)__        }_        if (byteCount > MAX_INDEX_NAME_BYTES) {_            throw exceptionCtor.apply(index, "index name is too long, (" + byteCount + " > " + MAX_INDEX_NAME_BYTES + ")")__        }_        if (index.equals(".") || index.equals("..")) {_            throw exceptionCtor.apply(index, "must not be '.' or '..'")__        }_    };validate,the,name,for,an,index,or,alias,against,some,static,rules;public,static,void,validate,index,or,alias,name,string,index,bi,function,string,string,extends,runtime,exception,exception,ctor,if,strings,valid,file,name,index,throw,exception,ctor,apply,index,must,not,contain,the,following,characters,strings,if,index,contains,throw,exception,ctor,apply,index,must,not,contain,if,index,contains,throw,exception,ctor,apply,index,must,not,contain,if,index,char,at,0,index,char,at,0,index,char,at,0,throw,exception,ctor,apply,index,must,not,start,with,or,int,byte,count,0,try,byte,count,index,get,bytes,utf,8,length,catch,unsupported,encoding,exception,e,throw,new,elasticsearch,exception,unable,to,determine,length,of,index,name,e,if,byte,count,throw,exception,ctor,apply,index,index,name,is,too,long,byte,count,if,index,equals,index,equals,throw,exception,ctor,apply,index,must,not,be,or
MetaDataCreateIndexService -> static List<String> validateShrinkIndex(ClusterState state, String sourceIndex,                                         Set<String> targetIndexMappingsTypes, String targetIndexName,                                         Settings targetIndexSettings);1524684173;Validates the settings and mappings for shrinking an index._@return the list of nodes at least one instance of the source index shards are allocated;static List<String> validateShrinkIndex(ClusterState state, String sourceIndex,_                                        Set<String> targetIndexMappingsTypes, String targetIndexName,_                                        Settings targetIndexSettings) {_        IndexMetaData sourceMetaData = validateResize(state, sourceIndex, targetIndexMappingsTypes, targetIndexName, targetIndexSettings)__        assert IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.exists(targetIndexSettings)__        IndexMetaData.selectShrinkShards(0, sourceMetaData, IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.get(targetIndexSettings))___        if (sourceMetaData.getNumberOfShards() == 1) {_            throw new IllegalArgumentException("can't shrink an index with only one shard")__        }__        _        final IndexRoutingTable table = state.routingTable().index(sourceIndex)__        Map<String, AtomicInteger> nodesToNumRouting = new HashMap<>()__        int numShards = sourceMetaData.getNumberOfShards()__        for (ShardRouting routing : table.shardsWithState(ShardRoutingState.STARTED)) {_            nodesToNumRouting.computeIfAbsent(routing.currentNodeId(), (s) -> new AtomicInteger(0)).incrementAndGet()__        }_        List<String> nodesToAllocateOn = new ArrayList<>()__        for (Map.Entry<String, AtomicInteger> entries : nodesToNumRouting.entrySet()) {_            int numAllocations = entries.getValue().get()__            assert numAllocations <= numShards : "wait what? " + numAllocations + " is > than num shards " + numShards__            if (numAllocations == numShards) {_                nodesToAllocateOn.add(entries.getKey())__            }_        }_        if (nodesToAllocateOn.isEmpty()) {_            throw new IllegalStateException("index " + sourceIndex +_                " must have all shards allocated on the same node to shrink index")__        }_        return nodesToAllocateOn__    };validates,the,settings,and,mappings,for,shrinking,an,index,return,the,list,of,nodes,at,least,one,instance,of,the,source,index,shards,are,allocated;static,list,string,validate,shrink,index,cluster,state,state,string,source,index,set,string,target,index,mappings,types,string,target,index,name,settings,target,index,settings,index,meta,data,source,meta,data,validate,resize,state,source,index,target,index,mappings,types,target,index,name,target,index,settings,assert,index,meta,data,exists,target,index,settings,index,meta,data,select,shrink,shards,0,source,meta,data,index,meta,data,get,target,index,settings,if,source,meta,data,get,number,of,shards,1,throw,new,illegal,argument,exception,can,t,shrink,an,index,with,only,one,shard,final,index,routing,table,table,state,routing,table,index,source,index,map,string,atomic,integer,nodes,to,num,routing,new,hash,map,int,num,shards,source,meta,data,get,number,of,shards,for,shard,routing,routing,table,shards,with,state,shard,routing,state,started,nodes,to,num,routing,compute,if,absent,routing,current,node,id,s,new,atomic,integer,0,increment,and,get,list,string,nodes,to,allocate,on,new,array,list,for,map,entry,string,atomic,integer,entries,nodes,to,num,routing,entry,set,int,num,allocations,entries,get,value,get,assert,num,allocations,num,shards,wait,what,num,allocations,is,than,num,shards,num,shards,if,num,allocations,num,shards,nodes,to,allocate,on,add,entries,get,key,if,nodes,to,allocate,on,is,empty,throw,new,illegal,state,exception,index,source,index,must,have,all,shards,allocated,on,the,same,node,to,shrink,index,return,nodes,to,allocate,on
MetaDataCreateIndexService -> static List<String> validateShrinkIndex(ClusterState state, String sourceIndex,                                         Set<String> targetIndexMappingsTypes, String targetIndexName,                                         Settings targetIndexSettings);1525162917;Validates the settings and mappings for shrinking an index._@return the list of nodes at least one instance of the source index shards are allocated;static List<String> validateShrinkIndex(ClusterState state, String sourceIndex,_                                        Set<String> targetIndexMappingsTypes, String targetIndexName,_                                        Settings targetIndexSettings) {_        IndexMetaData sourceMetaData = validateResize(state, sourceIndex, targetIndexMappingsTypes, targetIndexName, targetIndexSettings)__        assert IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.exists(targetIndexSettings)__        IndexMetaData.selectShrinkShards(0, sourceMetaData, IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.get(targetIndexSettings))___        if (sourceMetaData.getNumberOfShards() == 1) {_            throw new IllegalArgumentException("can't shrink an index with only one shard")__        }__        _        final IndexRoutingTable table = state.routingTable().index(sourceIndex)__        Map<String, AtomicInteger> nodesToNumRouting = new HashMap<>()__        int numShards = sourceMetaData.getNumberOfShards()__        for (ShardRouting routing : table.shardsWithState(ShardRoutingState.STARTED)) {_            nodesToNumRouting.computeIfAbsent(routing.currentNodeId(), (s) -> new AtomicInteger(0)).incrementAndGet()__        }_        List<String> nodesToAllocateOn = new ArrayList<>()__        for (Map.Entry<String, AtomicInteger> entries : nodesToNumRouting.entrySet()) {_            int numAllocations = entries.getValue().get()__            assert numAllocations <= numShards : "wait what? " + numAllocations + " is > than num shards " + numShards__            if (numAllocations == numShards) {_                nodesToAllocateOn.add(entries.getKey())__            }_        }_        if (nodesToAllocateOn.isEmpty()) {_            throw new IllegalStateException("index " + sourceIndex +_                " must have all shards allocated on the same node to shrink index")__        }_        return nodesToAllocateOn__    };validates,the,settings,and,mappings,for,shrinking,an,index,return,the,list,of,nodes,at,least,one,instance,of,the,source,index,shards,are,allocated;static,list,string,validate,shrink,index,cluster,state,state,string,source,index,set,string,target,index,mappings,types,string,target,index,name,settings,target,index,settings,index,meta,data,source,meta,data,validate,resize,state,source,index,target,index,mappings,types,target,index,name,target,index,settings,assert,index,meta,data,exists,target,index,settings,index,meta,data,select,shrink,shards,0,source,meta,data,index,meta,data,get,target,index,settings,if,source,meta,data,get,number,of,shards,1,throw,new,illegal,argument,exception,can,t,shrink,an,index,with,only,one,shard,final,index,routing,table,table,state,routing,table,index,source,index,map,string,atomic,integer,nodes,to,num,routing,new,hash,map,int,num,shards,source,meta,data,get,number,of,shards,for,shard,routing,routing,table,shards,with,state,shard,routing,state,started,nodes,to,num,routing,compute,if,absent,routing,current,node,id,s,new,atomic,integer,0,increment,and,get,list,string,nodes,to,allocate,on,new,array,list,for,map,entry,string,atomic,integer,entries,nodes,to,num,routing,entry,set,int,num,allocations,entries,get,value,get,assert,num,allocations,num,shards,wait,what,num,allocations,is,than,num,shards,num,shards,if,num,allocations,num,shards,nodes,to,allocate,on,add,entries,get,key,if,nodes,to,allocate,on,is,empty,throw,new,illegal,state,exception,index,source,index,must,have,all,shards,allocated,on,the,same,node,to,shrink,index,return,nodes,to,allocate,on
MetaDataCreateIndexService -> static List<String> validateShrinkIndex(ClusterState state, String sourceIndex,                                         Set<String> targetIndexMappingsTypes, String targetIndexName,                                         Settings targetIndexSettings);1525248068;Validates the settings and mappings for shrinking an index._@return the list of nodes at least one instance of the source index shards are allocated;static List<String> validateShrinkIndex(ClusterState state, String sourceIndex,_                                        Set<String> targetIndexMappingsTypes, String targetIndexName,_                                        Settings targetIndexSettings) {_        IndexMetaData sourceMetaData = validateResize(state, sourceIndex, targetIndexMappingsTypes, targetIndexName, targetIndexSettings)__        assert IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.exists(targetIndexSettings)__        IndexMetaData.selectShrinkShards(0, sourceMetaData, IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.get(targetIndexSettings))___        if (sourceMetaData.getNumberOfShards() == 1) {_            throw new IllegalArgumentException("can't shrink an index with only one shard")__        }__        _        final IndexRoutingTable table = state.routingTable().index(sourceIndex)__        Map<String, AtomicInteger> nodesToNumRouting = new HashMap<>()__        int numShards = sourceMetaData.getNumberOfShards()__        for (ShardRouting routing : table.shardsWithState(ShardRoutingState.STARTED)) {_            nodesToNumRouting.computeIfAbsent(routing.currentNodeId(), (s) -> new AtomicInteger(0)).incrementAndGet()__        }_        List<String> nodesToAllocateOn = new ArrayList<>()__        for (Map.Entry<String, AtomicInteger> entries : nodesToNumRouting.entrySet()) {_            int numAllocations = entries.getValue().get()__            assert numAllocations <= numShards : "wait what? " + numAllocations + " is > than num shards " + numShards__            if (numAllocations == numShards) {_                nodesToAllocateOn.add(entries.getKey())__            }_        }_        if (nodesToAllocateOn.isEmpty()) {_            throw new IllegalStateException("index " + sourceIndex +_                " must have all shards allocated on the same node to shrink index")__        }_        return nodesToAllocateOn__    };validates,the,settings,and,mappings,for,shrinking,an,index,return,the,list,of,nodes,at,least,one,instance,of,the,source,index,shards,are,allocated;static,list,string,validate,shrink,index,cluster,state,state,string,source,index,set,string,target,index,mappings,types,string,target,index,name,settings,target,index,settings,index,meta,data,source,meta,data,validate,resize,state,source,index,target,index,mappings,types,target,index,name,target,index,settings,assert,index,meta,data,exists,target,index,settings,index,meta,data,select,shrink,shards,0,source,meta,data,index,meta,data,get,target,index,settings,if,source,meta,data,get,number,of,shards,1,throw,new,illegal,argument,exception,can,t,shrink,an,index,with,only,one,shard,final,index,routing,table,table,state,routing,table,index,source,index,map,string,atomic,integer,nodes,to,num,routing,new,hash,map,int,num,shards,source,meta,data,get,number,of,shards,for,shard,routing,routing,table,shards,with,state,shard,routing,state,started,nodes,to,num,routing,compute,if,absent,routing,current,node,id,s,new,atomic,integer,0,increment,and,get,list,string,nodes,to,allocate,on,new,array,list,for,map,entry,string,atomic,integer,entries,nodes,to,num,routing,entry,set,int,num,allocations,entries,get,value,get,assert,num,allocations,num,shards,wait,what,num,allocations,is,than,num,shards,num,shards,if,num,allocations,num,shards,nodes,to,allocate,on,add,entries,get,key,if,nodes,to,allocate,on,is,empty,throw,new,illegal,state,exception,index,source,index,must,have,all,shards,allocated,on,the,same,node,to,shrink,index,return,nodes,to,allocate,on
MetaDataCreateIndexService -> static List<String> validateShrinkIndex(ClusterState state, String sourceIndex,                                         Set<String> targetIndexMappingsTypes, String targetIndexName,                                         Settings targetIndexSettings);1526374795;Validates the settings and mappings for shrinking an index._@return the list of nodes at least one instance of the source index shards are allocated;static List<String> validateShrinkIndex(ClusterState state, String sourceIndex,_                                        Set<String> targetIndexMappingsTypes, String targetIndexName,_                                        Settings targetIndexSettings) {_        IndexMetaData sourceMetaData = validateResize(state, sourceIndex, targetIndexMappingsTypes, targetIndexName, targetIndexSettings)__        assert IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.exists(targetIndexSettings)__        IndexMetaData.selectShrinkShards(0, sourceMetaData, IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.get(targetIndexSettings))___        if (sourceMetaData.getNumberOfShards() == 1) {_            throw new IllegalArgumentException("can't shrink an index with only one shard")__        }__        _        final IndexRoutingTable table = state.routingTable().index(sourceIndex)__        Map<String, AtomicInteger> nodesToNumRouting = new HashMap<>()__        int numShards = sourceMetaData.getNumberOfShards()__        for (ShardRouting routing : table.shardsWithState(ShardRoutingState.STARTED)) {_            nodesToNumRouting.computeIfAbsent(routing.currentNodeId(), (s) -> new AtomicInteger(0)).incrementAndGet()__        }_        List<String> nodesToAllocateOn = new ArrayList<>()__        for (Map.Entry<String, AtomicInteger> entries : nodesToNumRouting.entrySet()) {_            int numAllocations = entries.getValue().get()__            assert numAllocations <= numShards : "wait what? " + numAllocations + " is > than num shards " + numShards__            if (numAllocations == numShards) {_                nodesToAllocateOn.add(entries.getKey())__            }_        }_        if (nodesToAllocateOn.isEmpty()) {_            throw new IllegalStateException("index " + sourceIndex +_                " must have all shards allocated on the same node to shrink index")__        }_        return nodesToAllocateOn__    };validates,the,settings,and,mappings,for,shrinking,an,index,return,the,list,of,nodes,at,least,one,instance,of,the,source,index,shards,are,allocated;static,list,string,validate,shrink,index,cluster,state,state,string,source,index,set,string,target,index,mappings,types,string,target,index,name,settings,target,index,settings,index,meta,data,source,meta,data,validate,resize,state,source,index,target,index,mappings,types,target,index,name,target,index,settings,assert,index,meta,data,exists,target,index,settings,index,meta,data,select,shrink,shards,0,source,meta,data,index,meta,data,get,target,index,settings,if,source,meta,data,get,number,of,shards,1,throw,new,illegal,argument,exception,can,t,shrink,an,index,with,only,one,shard,final,index,routing,table,table,state,routing,table,index,source,index,map,string,atomic,integer,nodes,to,num,routing,new,hash,map,int,num,shards,source,meta,data,get,number,of,shards,for,shard,routing,routing,table,shards,with,state,shard,routing,state,started,nodes,to,num,routing,compute,if,absent,routing,current,node,id,s,new,atomic,integer,0,increment,and,get,list,string,nodes,to,allocate,on,new,array,list,for,map,entry,string,atomic,integer,entries,nodes,to,num,routing,entry,set,int,num,allocations,entries,get,value,get,assert,num,allocations,num,shards,wait,what,num,allocations,is,than,num,shards,num,shards,if,num,allocations,num,shards,nodes,to,allocate,on,add,entries,get,key,if,nodes,to,allocate,on,is,empty,throw,new,illegal,state,exception,index,source,index,must,have,all,shards,allocated,on,the,same,node,to,shrink,index,return,nodes,to,allocate,on
MetaDataCreateIndexService -> static List<String> validateShrinkIndex(ClusterState state, String sourceIndex,                                         Set<String> targetIndexMappingsTypes, String targetIndexName,                                         Settings targetIndexSettings);1529082965;Validates the settings and mappings for shrinking an index._@return the list of nodes at least one instance of the source index shards are allocated;static List<String> validateShrinkIndex(ClusterState state, String sourceIndex,_                                        Set<String> targetIndexMappingsTypes, String targetIndexName,_                                        Settings targetIndexSettings) {_        IndexMetaData sourceMetaData = validateResize(state, sourceIndex, targetIndexMappingsTypes, targetIndexName, targetIndexSettings)__        assert IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.exists(targetIndexSettings)__        IndexMetaData.selectShrinkShards(0, sourceMetaData, IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.get(targetIndexSettings))___        if (sourceMetaData.getNumberOfShards() == 1) {_            throw new IllegalArgumentException("can't shrink an index with only one shard")__        }__        _        final IndexRoutingTable table = state.routingTable().index(sourceIndex)__        Map<String, AtomicInteger> nodesToNumRouting = new HashMap<>()__        int numShards = sourceMetaData.getNumberOfShards()__        for (ShardRouting routing : table.shardsWithState(ShardRoutingState.STARTED)) {_            nodesToNumRouting.computeIfAbsent(routing.currentNodeId(), (s) -> new AtomicInteger(0)).incrementAndGet()__        }_        List<String> nodesToAllocateOn = new ArrayList<>()__        for (Map.Entry<String, AtomicInteger> entries : nodesToNumRouting.entrySet()) {_            int numAllocations = entries.getValue().get()__            assert numAllocations <= numShards : "wait what? " + numAllocations + " is > than num shards " + numShards__            if (numAllocations == numShards) {_                nodesToAllocateOn.add(entries.getKey())__            }_        }_        if (nodesToAllocateOn.isEmpty()) {_            throw new IllegalStateException("index " + sourceIndex +_                " must have all shards allocated on the same node to shrink index")__        }_        return nodesToAllocateOn__    };validates,the,settings,and,mappings,for,shrinking,an,index,return,the,list,of,nodes,at,least,one,instance,of,the,source,index,shards,are,allocated;static,list,string,validate,shrink,index,cluster,state,state,string,source,index,set,string,target,index,mappings,types,string,target,index,name,settings,target,index,settings,index,meta,data,source,meta,data,validate,resize,state,source,index,target,index,mappings,types,target,index,name,target,index,settings,assert,index,meta,data,exists,target,index,settings,index,meta,data,select,shrink,shards,0,source,meta,data,index,meta,data,get,target,index,settings,if,source,meta,data,get,number,of,shards,1,throw,new,illegal,argument,exception,can,t,shrink,an,index,with,only,one,shard,final,index,routing,table,table,state,routing,table,index,source,index,map,string,atomic,integer,nodes,to,num,routing,new,hash,map,int,num,shards,source,meta,data,get,number,of,shards,for,shard,routing,routing,table,shards,with,state,shard,routing,state,started,nodes,to,num,routing,compute,if,absent,routing,current,node,id,s,new,atomic,integer,0,increment,and,get,list,string,nodes,to,allocate,on,new,array,list,for,map,entry,string,atomic,integer,entries,nodes,to,num,routing,entry,set,int,num,allocations,entries,get,value,get,assert,num,allocations,num,shards,wait,what,num,allocations,is,than,num,shards,num,shards,if,num,allocations,num,shards,nodes,to,allocate,on,add,entries,get,key,if,nodes,to,allocate,on,is,empty,throw,new,illegal,state,exception,index,source,index,must,have,all,shards,allocated,on,the,same,node,to,shrink,index,return,nodes,to,allocate,on
MetaDataCreateIndexService -> static List<String> validateShrinkIndex(ClusterState state, String sourceIndex,                                         Set<String> targetIndexMappingsTypes, String targetIndexName,                                         Settings targetIndexSettings);1531382259;Validates the settings and mappings for shrinking an index._@return the list of nodes at least one instance of the source index shards are allocated;static List<String> validateShrinkIndex(ClusterState state, String sourceIndex,_                                        Set<String> targetIndexMappingsTypes, String targetIndexName,_                                        Settings targetIndexSettings) {_        IndexMetaData sourceMetaData = validateResize(state, sourceIndex, targetIndexMappingsTypes, targetIndexName, targetIndexSettings)__        assert IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.exists(targetIndexSettings)__        IndexMetaData.selectShrinkShards(0, sourceMetaData, IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.get(targetIndexSettings))___        if (sourceMetaData.getNumberOfShards() == 1) {_            throw new IllegalArgumentException("can't shrink an index with only one shard")__        }__        _        final IndexRoutingTable table = state.routingTable().index(sourceIndex)__        Map<String, AtomicInteger> nodesToNumRouting = new HashMap<>()__        int numShards = sourceMetaData.getNumberOfShards()__        for (ShardRouting routing : table.shardsWithState(ShardRoutingState.STARTED)) {_            nodesToNumRouting.computeIfAbsent(routing.currentNodeId(), (s) -> new AtomicInteger(0)).incrementAndGet()__        }_        List<String> nodesToAllocateOn = new ArrayList<>()__        for (Map.Entry<String, AtomicInteger> entries : nodesToNumRouting.entrySet()) {_            int numAllocations = entries.getValue().get()__            assert numAllocations <= numShards : "wait what? " + numAllocations + " is > than num shards " + numShards__            if (numAllocations == numShards) {_                nodesToAllocateOn.add(entries.getKey())__            }_        }_        if (nodesToAllocateOn.isEmpty()) {_            throw new IllegalStateException("index " + sourceIndex +_                " must have all shards allocated on the same node to shrink index")__        }_        return nodesToAllocateOn__    };validates,the,settings,and,mappings,for,shrinking,an,index,return,the,list,of,nodes,at,least,one,instance,of,the,source,index,shards,are,allocated;static,list,string,validate,shrink,index,cluster,state,state,string,source,index,set,string,target,index,mappings,types,string,target,index,name,settings,target,index,settings,index,meta,data,source,meta,data,validate,resize,state,source,index,target,index,mappings,types,target,index,name,target,index,settings,assert,index,meta,data,exists,target,index,settings,index,meta,data,select,shrink,shards,0,source,meta,data,index,meta,data,get,target,index,settings,if,source,meta,data,get,number,of,shards,1,throw,new,illegal,argument,exception,can,t,shrink,an,index,with,only,one,shard,final,index,routing,table,table,state,routing,table,index,source,index,map,string,atomic,integer,nodes,to,num,routing,new,hash,map,int,num,shards,source,meta,data,get,number,of,shards,for,shard,routing,routing,table,shards,with,state,shard,routing,state,started,nodes,to,num,routing,compute,if,absent,routing,current,node,id,s,new,atomic,integer,0,increment,and,get,list,string,nodes,to,allocate,on,new,array,list,for,map,entry,string,atomic,integer,entries,nodes,to,num,routing,entry,set,int,num,allocations,entries,get,value,get,assert,num,allocations,num,shards,wait,what,num,allocations,is,than,num,shards,num,shards,if,num,allocations,num,shards,nodes,to,allocate,on,add,entries,get,key,if,nodes,to,allocate,on,is,empty,throw,new,illegal,state,exception,index,source,index,must,have,all,shards,allocated,on,the,same,node,to,shrink,index,return,nodes,to,allocate,on
MetaDataCreateIndexService -> static List<String> validateShrinkIndex(ClusterState state, String sourceIndex,                                         Set<String> targetIndexMappingsTypes, String targetIndexName,                                         Settings targetIndexSettings);1535666657;Validates the settings and mappings for shrinking an index._@return the list of nodes at least one instance of the source index shards are allocated;static List<String> validateShrinkIndex(ClusterState state, String sourceIndex,_                                        Set<String> targetIndexMappingsTypes, String targetIndexName,_                                        Settings targetIndexSettings) {_        IndexMetaData sourceMetaData = validateResize(state, sourceIndex, targetIndexMappingsTypes, targetIndexName, targetIndexSettings)__        assert IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.exists(targetIndexSettings)__        IndexMetaData.selectShrinkShards(0, sourceMetaData, IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.get(targetIndexSettings))___        if (sourceMetaData.getNumberOfShards() == 1) {_            throw new IllegalArgumentException("can't shrink an index with only one shard")__        }__        _        final IndexRoutingTable table = state.routingTable().index(sourceIndex)__        Map<String, AtomicInteger> nodesToNumRouting = new HashMap<>()__        int numShards = sourceMetaData.getNumberOfShards()__        for (ShardRouting routing : table.shardsWithState(ShardRoutingState.STARTED)) {_            nodesToNumRouting.computeIfAbsent(routing.currentNodeId(), (s) -> new AtomicInteger(0)).incrementAndGet()__        }_        List<String> nodesToAllocateOn = new ArrayList<>()__        for (Map.Entry<String, AtomicInteger> entries : nodesToNumRouting.entrySet()) {_            int numAllocations = entries.getValue().get()__            assert numAllocations <= numShards : "wait what? " + numAllocations + " is > than num shards " + numShards__            if (numAllocations == numShards) {_                nodesToAllocateOn.add(entries.getKey())__            }_        }_        if (nodesToAllocateOn.isEmpty()) {_            throw new IllegalStateException("index " + sourceIndex +_                " must have all shards allocated on the same node to shrink index")__        }_        return nodesToAllocateOn__    };validates,the,settings,and,mappings,for,shrinking,an,index,return,the,list,of,nodes,at,least,one,instance,of,the,source,index,shards,are,allocated;static,list,string,validate,shrink,index,cluster,state,state,string,source,index,set,string,target,index,mappings,types,string,target,index,name,settings,target,index,settings,index,meta,data,source,meta,data,validate,resize,state,source,index,target,index,mappings,types,target,index,name,target,index,settings,assert,index,meta,data,exists,target,index,settings,index,meta,data,select,shrink,shards,0,source,meta,data,index,meta,data,get,target,index,settings,if,source,meta,data,get,number,of,shards,1,throw,new,illegal,argument,exception,can,t,shrink,an,index,with,only,one,shard,final,index,routing,table,table,state,routing,table,index,source,index,map,string,atomic,integer,nodes,to,num,routing,new,hash,map,int,num,shards,source,meta,data,get,number,of,shards,for,shard,routing,routing,table,shards,with,state,shard,routing,state,started,nodes,to,num,routing,compute,if,absent,routing,current,node,id,s,new,atomic,integer,0,increment,and,get,list,string,nodes,to,allocate,on,new,array,list,for,map,entry,string,atomic,integer,entries,nodes,to,num,routing,entry,set,int,num,allocations,entries,get,value,get,assert,num,allocations,num,shards,wait,what,num,allocations,is,than,num,shards,num,shards,if,num,allocations,num,shards,nodes,to,allocate,on,add,entries,get,key,if,nodes,to,allocate,on,is,empty,throw,new,illegal,state,exception,index,source,index,must,have,all,shards,allocated,on,the,same,node,to,shrink,index,return,nodes,to,allocate,on
MetaDataCreateIndexService -> static List<String> validateShrinkIndex(ClusterState state, String sourceIndex,                                         Set<String> targetIndexMappingsTypes, String targetIndexName,                                         Settings targetIndexSettings);1536137328;Validates the settings and mappings for shrinking an index._@return the list of nodes at least one instance of the source index shards are allocated;static List<String> validateShrinkIndex(ClusterState state, String sourceIndex,_                                        Set<String> targetIndexMappingsTypes, String targetIndexName,_                                        Settings targetIndexSettings) {_        IndexMetaData sourceMetaData = validateResize(state, sourceIndex, targetIndexMappingsTypes, targetIndexName, targetIndexSettings)__        assert IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.exists(targetIndexSettings)__        IndexMetaData.selectShrinkShards(0, sourceMetaData, IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.get(targetIndexSettings))___        if (sourceMetaData.getNumberOfShards() == 1) {_            throw new IllegalArgumentException("can't shrink an index with only one shard")__        }__        _        final IndexRoutingTable table = state.routingTable().index(sourceIndex)__        Map<String, AtomicInteger> nodesToNumRouting = new HashMap<>()__        int numShards = sourceMetaData.getNumberOfShards()__        for (ShardRouting routing : table.shardsWithState(ShardRoutingState.STARTED)) {_            nodesToNumRouting.computeIfAbsent(routing.currentNodeId(), (s) -> new AtomicInteger(0)).incrementAndGet()__        }_        List<String> nodesToAllocateOn = new ArrayList<>()__        for (Map.Entry<String, AtomicInteger> entries : nodesToNumRouting.entrySet()) {_            int numAllocations = entries.getValue().get()__            assert numAllocations <= numShards : "wait what? " + numAllocations + " is > than num shards " + numShards__            if (numAllocations == numShards) {_                nodesToAllocateOn.add(entries.getKey())__            }_        }_        if (nodesToAllocateOn.isEmpty()) {_            throw new IllegalStateException("index " + sourceIndex +_                " must have all shards allocated on the same node to shrink index")__        }_        return nodesToAllocateOn__    };validates,the,settings,and,mappings,for,shrinking,an,index,return,the,list,of,nodes,at,least,one,instance,of,the,source,index,shards,are,allocated;static,list,string,validate,shrink,index,cluster,state,state,string,source,index,set,string,target,index,mappings,types,string,target,index,name,settings,target,index,settings,index,meta,data,source,meta,data,validate,resize,state,source,index,target,index,mappings,types,target,index,name,target,index,settings,assert,index,meta,data,exists,target,index,settings,index,meta,data,select,shrink,shards,0,source,meta,data,index,meta,data,get,target,index,settings,if,source,meta,data,get,number,of,shards,1,throw,new,illegal,argument,exception,can,t,shrink,an,index,with,only,one,shard,final,index,routing,table,table,state,routing,table,index,source,index,map,string,atomic,integer,nodes,to,num,routing,new,hash,map,int,num,shards,source,meta,data,get,number,of,shards,for,shard,routing,routing,table,shards,with,state,shard,routing,state,started,nodes,to,num,routing,compute,if,absent,routing,current,node,id,s,new,atomic,integer,0,increment,and,get,list,string,nodes,to,allocate,on,new,array,list,for,map,entry,string,atomic,integer,entries,nodes,to,num,routing,entry,set,int,num,allocations,entries,get,value,get,assert,num,allocations,num,shards,wait,what,num,allocations,is,than,num,shards,num,shards,if,num,allocations,num,shards,nodes,to,allocate,on,add,entries,get,key,if,nodes,to,allocate,on,is,empty,throw,new,illegal,state,exception,index,source,index,must,have,all,shards,allocated,on,the,same,node,to,shrink,index,return,nodes,to,allocate,on
MetaDataCreateIndexService -> static List<String> validateShrinkIndex(ClusterState state, String sourceIndex,                                         Set<String> targetIndexMappingsTypes, String targetIndexName,                                         Settings targetIndexSettings);1536828374;Validates the settings and mappings for shrinking an index._@return the list of nodes at least one instance of the source index shards are allocated;static List<String> validateShrinkIndex(ClusterState state, String sourceIndex,_                                        Set<String> targetIndexMappingsTypes, String targetIndexName,_                                        Settings targetIndexSettings) {_        IndexMetaData sourceMetaData = validateResize(state, sourceIndex, targetIndexMappingsTypes, targetIndexName, targetIndexSettings)__        assert IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.exists(targetIndexSettings)__        IndexMetaData.selectShrinkShards(0, sourceMetaData, IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.get(targetIndexSettings))___        if (sourceMetaData.getNumberOfShards() == 1) {_            throw new IllegalArgumentException("can't shrink an index with only one shard")__        }__        _        final IndexRoutingTable table = state.routingTable().index(sourceIndex)__        Map<String, AtomicInteger> nodesToNumRouting = new HashMap<>()__        int numShards = sourceMetaData.getNumberOfShards()__        for (ShardRouting routing : table.shardsWithState(ShardRoutingState.STARTED)) {_            nodesToNumRouting.computeIfAbsent(routing.currentNodeId(), (s) -> new AtomicInteger(0)).incrementAndGet()__        }_        List<String> nodesToAllocateOn = new ArrayList<>()__        for (Map.Entry<String, AtomicInteger> entries : nodesToNumRouting.entrySet()) {_            int numAllocations = entries.getValue().get()__            assert numAllocations <= numShards : "wait what? " + numAllocations + " is > than num shards " + numShards__            if (numAllocations == numShards) {_                nodesToAllocateOn.add(entries.getKey())__            }_        }_        if (nodesToAllocateOn.isEmpty()) {_            throw new IllegalStateException("index " + sourceIndex +_                " must have all shards allocated on the same node to shrink index")__        }_        return nodesToAllocateOn__    };validates,the,settings,and,mappings,for,shrinking,an,index,return,the,list,of,nodes,at,least,one,instance,of,the,source,index,shards,are,allocated;static,list,string,validate,shrink,index,cluster,state,state,string,source,index,set,string,target,index,mappings,types,string,target,index,name,settings,target,index,settings,index,meta,data,source,meta,data,validate,resize,state,source,index,target,index,mappings,types,target,index,name,target,index,settings,assert,index,meta,data,exists,target,index,settings,index,meta,data,select,shrink,shards,0,source,meta,data,index,meta,data,get,target,index,settings,if,source,meta,data,get,number,of,shards,1,throw,new,illegal,argument,exception,can,t,shrink,an,index,with,only,one,shard,final,index,routing,table,table,state,routing,table,index,source,index,map,string,atomic,integer,nodes,to,num,routing,new,hash,map,int,num,shards,source,meta,data,get,number,of,shards,for,shard,routing,routing,table,shards,with,state,shard,routing,state,started,nodes,to,num,routing,compute,if,absent,routing,current,node,id,s,new,atomic,integer,0,increment,and,get,list,string,nodes,to,allocate,on,new,array,list,for,map,entry,string,atomic,integer,entries,nodes,to,num,routing,entry,set,int,num,allocations,entries,get,value,get,assert,num,allocations,num,shards,wait,what,num,allocations,is,than,num,shards,num,shards,if,num,allocations,num,shards,nodes,to,allocate,on,add,entries,get,key,if,nodes,to,allocate,on,is,empty,throw,new,illegal,state,exception,index,source,index,must,have,all,shards,allocated,on,the,same,node,to,shrink,index,return,nodes,to,allocate,on
MetaDataCreateIndexService -> static List<String> validateShrinkIndex(ClusterState state, String sourceIndex,                                         Set<String> targetIndexMappingsTypes, String targetIndexName,                                         Settings targetIndexSettings);1540486836;Validates the settings and mappings for shrinking an index._@return the list of nodes at least one instance of the source index shards are allocated;static List<String> validateShrinkIndex(ClusterState state, String sourceIndex,_                                        Set<String> targetIndexMappingsTypes, String targetIndexName,_                                        Settings targetIndexSettings) {_        IndexMetaData sourceMetaData = validateResize(state, sourceIndex, targetIndexMappingsTypes, targetIndexName, targetIndexSettings)__        assert IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.exists(targetIndexSettings)__        IndexMetaData.selectShrinkShards(0, sourceMetaData, IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.get(targetIndexSettings))___        if (sourceMetaData.getNumberOfShards() == 1) {_            throw new IllegalArgumentException("can't shrink an index with only one shard")__        }__        _        final IndexRoutingTable table = state.routingTable().index(sourceIndex)__        Map<String, AtomicInteger> nodesToNumRouting = new HashMap<>()__        int numShards = sourceMetaData.getNumberOfShards()__        for (ShardRouting routing : table.shardsWithState(ShardRoutingState.STARTED)) {_            nodesToNumRouting.computeIfAbsent(routing.currentNodeId(), (s) -> new AtomicInteger(0)).incrementAndGet()__        }_        List<String> nodesToAllocateOn = new ArrayList<>()__        for (Map.Entry<String, AtomicInteger> entries : nodesToNumRouting.entrySet()) {_            int numAllocations = entries.getValue().get()__            assert numAllocations <= numShards : "wait what? " + numAllocations + " is > than num shards " + numShards__            if (numAllocations == numShards) {_                nodesToAllocateOn.add(entries.getKey())__            }_        }_        if (nodesToAllocateOn.isEmpty()) {_            throw new IllegalStateException("index " + sourceIndex +_                " must have all shards allocated on the same node to shrink index")__        }_        return nodesToAllocateOn__    };validates,the,settings,and,mappings,for,shrinking,an,index,return,the,list,of,nodes,at,least,one,instance,of,the,source,index,shards,are,allocated;static,list,string,validate,shrink,index,cluster,state,state,string,source,index,set,string,target,index,mappings,types,string,target,index,name,settings,target,index,settings,index,meta,data,source,meta,data,validate,resize,state,source,index,target,index,mappings,types,target,index,name,target,index,settings,assert,index,meta,data,exists,target,index,settings,index,meta,data,select,shrink,shards,0,source,meta,data,index,meta,data,get,target,index,settings,if,source,meta,data,get,number,of,shards,1,throw,new,illegal,argument,exception,can,t,shrink,an,index,with,only,one,shard,final,index,routing,table,table,state,routing,table,index,source,index,map,string,atomic,integer,nodes,to,num,routing,new,hash,map,int,num,shards,source,meta,data,get,number,of,shards,for,shard,routing,routing,table,shards,with,state,shard,routing,state,started,nodes,to,num,routing,compute,if,absent,routing,current,node,id,s,new,atomic,integer,0,increment,and,get,list,string,nodes,to,allocate,on,new,array,list,for,map,entry,string,atomic,integer,entries,nodes,to,num,routing,entry,set,int,num,allocations,entries,get,value,get,assert,num,allocations,num,shards,wait,what,num,allocations,is,than,num,shards,num,shards,if,num,allocations,num,shards,nodes,to,allocate,on,add,entries,get,key,if,nodes,to,allocate,on,is,empty,throw,new,illegal,state,exception,index,source,index,must,have,all,shards,allocated,on,the,same,node,to,shrink,index,return,nodes,to,allocate,on
MetaDataCreateIndexService -> static List<String> validateShrinkIndex(ClusterState state, String sourceIndex,                                         Set<String> targetIndexMappingsTypes, String targetIndexName,                                         Settings targetIndexSettings);1540847035;Validates the settings and mappings for shrinking an index._@return the list of nodes at least one instance of the source index shards are allocated;static List<String> validateShrinkIndex(ClusterState state, String sourceIndex,_                                        Set<String> targetIndexMappingsTypes, String targetIndexName,_                                        Settings targetIndexSettings) {_        IndexMetaData sourceMetaData = validateResize(state, sourceIndex, targetIndexMappingsTypes, targetIndexName, targetIndexSettings)__        assert IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.exists(targetIndexSettings)__        IndexMetaData.selectShrinkShards(0, sourceMetaData, IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.get(targetIndexSettings))___        if (sourceMetaData.getNumberOfShards() == 1) {_            throw new IllegalArgumentException("can't shrink an index with only one shard")__        }__        _        final IndexRoutingTable table = state.routingTable().index(sourceIndex)__        Map<String, AtomicInteger> nodesToNumRouting = new HashMap<>()__        int numShards = sourceMetaData.getNumberOfShards()__        for (ShardRouting routing : table.shardsWithState(ShardRoutingState.STARTED)) {_            nodesToNumRouting.computeIfAbsent(routing.currentNodeId(), (s) -> new AtomicInteger(0)).incrementAndGet()__        }_        List<String> nodesToAllocateOn = new ArrayList<>()__        for (Map.Entry<String, AtomicInteger> entries : nodesToNumRouting.entrySet()) {_            int numAllocations = entries.getValue().get()__            assert numAllocations <= numShards : "wait what? " + numAllocations + " is > than num shards " + numShards__            if (numAllocations == numShards) {_                nodesToAllocateOn.add(entries.getKey())__            }_        }_        if (nodesToAllocateOn.isEmpty()) {_            throw new IllegalStateException("index " + sourceIndex +_                " must have all shards allocated on the same node to shrink index")__        }_        return nodesToAllocateOn__    };validates,the,settings,and,mappings,for,shrinking,an,index,return,the,list,of,nodes,at,least,one,instance,of,the,source,index,shards,are,allocated;static,list,string,validate,shrink,index,cluster,state,state,string,source,index,set,string,target,index,mappings,types,string,target,index,name,settings,target,index,settings,index,meta,data,source,meta,data,validate,resize,state,source,index,target,index,mappings,types,target,index,name,target,index,settings,assert,index,meta,data,exists,target,index,settings,index,meta,data,select,shrink,shards,0,source,meta,data,index,meta,data,get,target,index,settings,if,source,meta,data,get,number,of,shards,1,throw,new,illegal,argument,exception,can,t,shrink,an,index,with,only,one,shard,final,index,routing,table,table,state,routing,table,index,source,index,map,string,atomic,integer,nodes,to,num,routing,new,hash,map,int,num,shards,source,meta,data,get,number,of,shards,for,shard,routing,routing,table,shards,with,state,shard,routing,state,started,nodes,to,num,routing,compute,if,absent,routing,current,node,id,s,new,atomic,integer,0,increment,and,get,list,string,nodes,to,allocate,on,new,array,list,for,map,entry,string,atomic,integer,entries,nodes,to,num,routing,entry,set,int,num,allocations,entries,get,value,get,assert,num,allocations,num,shards,wait,what,num,allocations,is,than,num,shards,num,shards,if,num,allocations,num,shards,nodes,to,allocate,on,add,entries,get,key,if,nodes,to,allocate,on,is,empty,throw,new,illegal,state,exception,index,source,index,must,have,all,shards,allocated,on,the,same,node,to,shrink,index,return,nodes,to,allocate,on
MetaDataCreateIndexService -> static List<String> validateShrinkIndex(ClusterState state, String sourceIndex,                                         Set<String> targetIndexMappingsTypes, String targetIndexName,                                         Settings targetIndexSettings);1541008027;Validates the settings and mappings for shrinking an index._@return the list of nodes at least one instance of the source index shards are allocated;static List<String> validateShrinkIndex(ClusterState state, String sourceIndex,_                                        Set<String> targetIndexMappingsTypes, String targetIndexName,_                                        Settings targetIndexSettings) {_        IndexMetaData sourceMetaData = validateResize(state, sourceIndex, targetIndexMappingsTypes, targetIndexName, targetIndexSettings)__        assert IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.exists(targetIndexSettings)__        IndexMetaData.selectShrinkShards(0, sourceMetaData, IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.get(targetIndexSettings))___        if (sourceMetaData.getNumberOfShards() == 1) {_            throw new IllegalArgumentException("can't shrink an index with only one shard")__        }__        _        final IndexRoutingTable table = state.routingTable().index(sourceIndex)__        Map<String, AtomicInteger> nodesToNumRouting = new HashMap<>()__        int numShards = sourceMetaData.getNumberOfShards()__        for (ShardRouting routing : table.shardsWithState(ShardRoutingState.STARTED)) {_            nodesToNumRouting.computeIfAbsent(routing.currentNodeId(), (s) -> new AtomicInteger(0)).incrementAndGet()__        }_        List<String> nodesToAllocateOn = new ArrayList<>()__        for (Map.Entry<String, AtomicInteger> entries : nodesToNumRouting.entrySet()) {_            int numAllocations = entries.getValue().get()__            assert numAllocations <= numShards : "wait what? " + numAllocations + " is > than num shards " + numShards__            if (numAllocations == numShards) {_                nodesToAllocateOn.add(entries.getKey())__            }_        }_        if (nodesToAllocateOn.isEmpty()) {_            throw new IllegalStateException("index " + sourceIndex +_                " must have all shards allocated on the same node to shrink index")__        }_        return nodesToAllocateOn__    };validates,the,settings,and,mappings,for,shrinking,an,index,return,the,list,of,nodes,at,least,one,instance,of,the,source,index,shards,are,allocated;static,list,string,validate,shrink,index,cluster,state,state,string,source,index,set,string,target,index,mappings,types,string,target,index,name,settings,target,index,settings,index,meta,data,source,meta,data,validate,resize,state,source,index,target,index,mappings,types,target,index,name,target,index,settings,assert,index,meta,data,exists,target,index,settings,index,meta,data,select,shrink,shards,0,source,meta,data,index,meta,data,get,target,index,settings,if,source,meta,data,get,number,of,shards,1,throw,new,illegal,argument,exception,can,t,shrink,an,index,with,only,one,shard,final,index,routing,table,table,state,routing,table,index,source,index,map,string,atomic,integer,nodes,to,num,routing,new,hash,map,int,num,shards,source,meta,data,get,number,of,shards,for,shard,routing,routing,table,shards,with,state,shard,routing,state,started,nodes,to,num,routing,compute,if,absent,routing,current,node,id,s,new,atomic,integer,0,increment,and,get,list,string,nodes,to,allocate,on,new,array,list,for,map,entry,string,atomic,integer,entries,nodes,to,num,routing,entry,set,int,num,allocations,entries,get,value,get,assert,num,allocations,num,shards,wait,what,num,allocations,is,than,num,shards,num,shards,if,num,allocations,num,shards,nodes,to,allocate,on,add,entries,get,key,if,nodes,to,allocate,on,is,empty,throw,new,illegal,state,exception,index,source,index,must,have,all,shards,allocated,on,the,same,node,to,shrink,index,return,nodes,to,allocate,on
MetaDataCreateIndexService -> static List<String> validateShrinkIndex(ClusterState state, String sourceIndex,                                         Set<String> targetIndexMappingsTypes, String targetIndexName,                                         Settings targetIndexSettings);1541092382;Validates the settings and mappings for shrinking an index._@return the list of nodes at least one instance of the source index shards are allocated;static List<String> validateShrinkIndex(ClusterState state, String sourceIndex,_                                        Set<String> targetIndexMappingsTypes, String targetIndexName,_                                        Settings targetIndexSettings) {_        IndexMetaData sourceMetaData = validateResize(state, sourceIndex, targetIndexMappingsTypes, targetIndexName, targetIndexSettings)__        assert IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.exists(targetIndexSettings)__        IndexMetaData.selectShrinkShards(0, sourceMetaData, IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.get(targetIndexSettings))___        if (sourceMetaData.getNumberOfShards() == 1) {_            throw new IllegalArgumentException("can't shrink an index with only one shard")__        }__        _        final IndexRoutingTable table = state.routingTable().index(sourceIndex)__        Map<String, AtomicInteger> nodesToNumRouting = new HashMap<>()__        int numShards = sourceMetaData.getNumberOfShards()__        for (ShardRouting routing : table.shardsWithState(ShardRoutingState.STARTED)) {_            nodesToNumRouting.computeIfAbsent(routing.currentNodeId(), (s) -> new AtomicInteger(0)).incrementAndGet()__        }_        List<String> nodesToAllocateOn = new ArrayList<>()__        for (Map.Entry<String, AtomicInteger> entries : nodesToNumRouting.entrySet()) {_            int numAllocations = entries.getValue().get()__            assert numAllocations <= numShards : "wait what? " + numAllocations + " is > than num shards " + numShards__            if (numAllocations == numShards) {_                nodesToAllocateOn.add(entries.getKey())__            }_        }_        if (nodesToAllocateOn.isEmpty()) {_            throw new IllegalStateException("index " + sourceIndex +_                " must have all shards allocated on the same node to shrink index")__        }_        return nodesToAllocateOn__    };validates,the,settings,and,mappings,for,shrinking,an,index,return,the,list,of,nodes,at,least,one,instance,of,the,source,index,shards,are,allocated;static,list,string,validate,shrink,index,cluster,state,state,string,source,index,set,string,target,index,mappings,types,string,target,index,name,settings,target,index,settings,index,meta,data,source,meta,data,validate,resize,state,source,index,target,index,mappings,types,target,index,name,target,index,settings,assert,index,meta,data,exists,target,index,settings,index,meta,data,select,shrink,shards,0,source,meta,data,index,meta,data,get,target,index,settings,if,source,meta,data,get,number,of,shards,1,throw,new,illegal,argument,exception,can,t,shrink,an,index,with,only,one,shard,final,index,routing,table,table,state,routing,table,index,source,index,map,string,atomic,integer,nodes,to,num,routing,new,hash,map,int,num,shards,source,meta,data,get,number,of,shards,for,shard,routing,routing,table,shards,with,state,shard,routing,state,started,nodes,to,num,routing,compute,if,absent,routing,current,node,id,s,new,atomic,integer,0,increment,and,get,list,string,nodes,to,allocate,on,new,array,list,for,map,entry,string,atomic,integer,entries,nodes,to,num,routing,entry,set,int,num,allocations,entries,get,value,get,assert,num,allocations,num,shards,wait,what,num,allocations,is,than,num,shards,num,shards,if,num,allocations,num,shards,nodes,to,allocate,on,add,entries,get,key,if,nodes,to,allocate,on,is,empty,throw,new,illegal,state,exception,index,source,index,must,have,all,shards,allocated,on,the,same,node,to,shrink,index,return,nodes,to,allocate,on
MetaDataCreateIndexService -> static List<String> validateShrinkIndex(ClusterState state, String sourceIndex,                                         Set<String> targetIndexMappingsTypes, String targetIndexName,                                         Settings targetIndexSettings);1541592065;Validates the settings and mappings for shrinking an index._@return the list of nodes at least one instance of the source index shards are allocated;static List<String> validateShrinkIndex(ClusterState state, String sourceIndex,_                                        Set<String> targetIndexMappingsTypes, String targetIndexName,_                                        Settings targetIndexSettings) {_        IndexMetaData sourceMetaData = validateResize(state, sourceIndex, targetIndexMappingsTypes, targetIndexName, targetIndexSettings)__        assert IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.exists(targetIndexSettings)__        IndexMetaData.selectShrinkShards(0, sourceMetaData, IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.get(targetIndexSettings))___        if (sourceMetaData.getNumberOfShards() == 1) {_            throw new IllegalArgumentException("can't shrink an index with only one shard")__        }__        _        final IndexRoutingTable table = state.routingTable().index(sourceIndex)__        Map<String, AtomicInteger> nodesToNumRouting = new HashMap<>()__        int numShards = sourceMetaData.getNumberOfShards()__        for (ShardRouting routing : table.shardsWithState(ShardRoutingState.STARTED)) {_            nodesToNumRouting.computeIfAbsent(routing.currentNodeId(), (s) -> new AtomicInteger(0)).incrementAndGet()__        }_        List<String> nodesToAllocateOn = new ArrayList<>()__        for (Map.Entry<String, AtomicInteger> entries : nodesToNumRouting.entrySet()) {_            int numAllocations = entries.getValue().get()__            assert numAllocations <= numShards : "wait what? " + numAllocations + " is > than num shards " + numShards__            if (numAllocations == numShards) {_                nodesToAllocateOn.add(entries.getKey())__            }_        }_        if (nodesToAllocateOn.isEmpty()) {_            throw new IllegalStateException("index " + sourceIndex +_                " must have all shards allocated on the same node to shrink index")__        }_        return nodesToAllocateOn__    };validates,the,settings,and,mappings,for,shrinking,an,index,return,the,list,of,nodes,at,least,one,instance,of,the,source,index,shards,are,allocated;static,list,string,validate,shrink,index,cluster,state,state,string,source,index,set,string,target,index,mappings,types,string,target,index,name,settings,target,index,settings,index,meta,data,source,meta,data,validate,resize,state,source,index,target,index,mappings,types,target,index,name,target,index,settings,assert,index,meta,data,exists,target,index,settings,index,meta,data,select,shrink,shards,0,source,meta,data,index,meta,data,get,target,index,settings,if,source,meta,data,get,number,of,shards,1,throw,new,illegal,argument,exception,can,t,shrink,an,index,with,only,one,shard,final,index,routing,table,table,state,routing,table,index,source,index,map,string,atomic,integer,nodes,to,num,routing,new,hash,map,int,num,shards,source,meta,data,get,number,of,shards,for,shard,routing,routing,table,shards,with,state,shard,routing,state,started,nodes,to,num,routing,compute,if,absent,routing,current,node,id,s,new,atomic,integer,0,increment,and,get,list,string,nodes,to,allocate,on,new,array,list,for,map,entry,string,atomic,integer,entries,nodes,to,num,routing,entry,set,int,num,allocations,entries,get,value,get,assert,num,allocations,num,shards,wait,what,num,allocations,is,than,num,shards,num,shards,if,num,allocations,num,shards,nodes,to,allocate,on,add,entries,get,key,if,nodes,to,allocate,on,is,empty,throw,new,illegal,state,exception,index,source,index,must,have,all,shards,allocated,on,the,same,node,to,shrink,index,return,nodes,to,allocate,on
MetaDataCreateIndexService -> static List<String> validateShrinkIndex(ClusterState state, String sourceIndex,                                         Set<String> targetIndexMappingsTypes, String targetIndexName,                                         Settings targetIndexSettings);1542402632;Validates the settings and mappings for shrinking an index._@return the list of nodes at least one instance of the source index shards are allocated;static List<String> validateShrinkIndex(ClusterState state, String sourceIndex,_                                        Set<String> targetIndexMappingsTypes, String targetIndexName,_                                        Settings targetIndexSettings) {_        IndexMetaData sourceMetaData = validateResize(state, sourceIndex, targetIndexMappingsTypes, targetIndexName, targetIndexSettings)__        assert IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.exists(targetIndexSettings)__        IndexMetaData.selectShrinkShards(0, sourceMetaData, IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.get(targetIndexSettings))___        if (sourceMetaData.getNumberOfShards() == 1) {_            throw new IllegalArgumentException("can't shrink an index with only one shard")__        }__        _        final IndexRoutingTable table = state.routingTable().index(sourceIndex)__        Map<String, AtomicInteger> nodesToNumRouting = new HashMap<>()__        int numShards = sourceMetaData.getNumberOfShards()__        for (ShardRouting routing : table.shardsWithState(ShardRoutingState.STARTED)) {_            nodesToNumRouting.computeIfAbsent(routing.currentNodeId(), (s) -> new AtomicInteger(0)).incrementAndGet()__        }_        List<String> nodesToAllocateOn = new ArrayList<>()__        for (Map.Entry<String, AtomicInteger> entries : nodesToNumRouting.entrySet()) {_            int numAllocations = entries.getValue().get()__            assert numAllocations <= numShards : "wait what? " + numAllocations + " is > than num shards " + numShards__            if (numAllocations == numShards) {_                nodesToAllocateOn.add(entries.getKey())__            }_        }_        if (nodesToAllocateOn.isEmpty()) {_            throw new IllegalStateException("index " + sourceIndex +_                " must have all shards allocated on the same node to shrink index")__        }_        return nodesToAllocateOn__    };validates,the,settings,and,mappings,for,shrinking,an,index,return,the,list,of,nodes,at,least,one,instance,of,the,source,index,shards,are,allocated;static,list,string,validate,shrink,index,cluster,state,state,string,source,index,set,string,target,index,mappings,types,string,target,index,name,settings,target,index,settings,index,meta,data,source,meta,data,validate,resize,state,source,index,target,index,mappings,types,target,index,name,target,index,settings,assert,index,meta,data,exists,target,index,settings,index,meta,data,select,shrink,shards,0,source,meta,data,index,meta,data,get,target,index,settings,if,source,meta,data,get,number,of,shards,1,throw,new,illegal,argument,exception,can,t,shrink,an,index,with,only,one,shard,final,index,routing,table,table,state,routing,table,index,source,index,map,string,atomic,integer,nodes,to,num,routing,new,hash,map,int,num,shards,source,meta,data,get,number,of,shards,for,shard,routing,routing,table,shards,with,state,shard,routing,state,started,nodes,to,num,routing,compute,if,absent,routing,current,node,id,s,new,atomic,integer,0,increment,and,get,list,string,nodes,to,allocate,on,new,array,list,for,map,entry,string,atomic,integer,entries,nodes,to,num,routing,entry,set,int,num,allocations,entries,get,value,get,assert,num,allocations,num,shards,wait,what,num,allocations,is,than,num,shards,num,shards,if,num,allocations,num,shards,nodes,to,allocate,on,add,entries,get,key,if,nodes,to,allocate,on,is,empty,throw,new,illegal,state,exception,index,source,index,must,have,all,shards,allocated,on,the,same,node,to,shrink,index,return,nodes,to,allocate,on
MetaDataCreateIndexService -> static List<String> validateShrinkIndex(ClusterState state, String sourceIndex,                                         Set<String> targetIndexMappingsTypes, String targetIndexName,                                         Settings targetIndexSettings);1543277112;Validates the settings and mappings for shrinking an index._@return the list of nodes at least one instance of the source index shards are allocated;static List<String> validateShrinkIndex(ClusterState state, String sourceIndex,_                                        Set<String> targetIndexMappingsTypes, String targetIndexName,_                                        Settings targetIndexSettings) {_        IndexMetaData sourceMetaData = validateResize(state, sourceIndex, targetIndexMappingsTypes, targetIndexName, targetIndexSettings)__        assert IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.exists(targetIndexSettings)__        IndexMetaData.selectShrinkShards(0, sourceMetaData, IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.get(targetIndexSettings))___        if (sourceMetaData.getNumberOfShards() == 1) {_            throw new IllegalArgumentException("can't shrink an index with only one shard")__        }__        _        final IndexRoutingTable table = state.routingTable().index(sourceIndex)__        Map<String, AtomicInteger> nodesToNumRouting = new HashMap<>()__        int numShards = sourceMetaData.getNumberOfShards()__        for (ShardRouting routing : table.shardsWithState(ShardRoutingState.STARTED)) {_            nodesToNumRouting.computeIfAbsent(routing.currentNodeId(), (s) -> new AtomicInteger(0)).incrementAndGet()__        }_        List<String> nodesToAllocateOn = new ArrayList<>()__        for (Map.Entry<String, AtomicInteger> entries : nodesToNumRouting.entrySet()) {_            int numAllocations = entries.getValue().get()__            assert numAllocations <= numShards : "wait what? " + numAllocations + " is > than num shards " + numShards__            if (numAllocations == numShards) {_                nodesToAllocateOn.add(entries.getKey())__            }_        }_        if (nodesToAllocateOn.isEmpty()) {_            throw new IllegalStateException("index " + sourceIndex +_                " must have all shards allocated on the same node to shrink index")__        }_        return nodesToAllocateOn__    };validates,the,settings,and,mappings,for,shrinking,an,index,return,the,list,of,nodes,at,least,one,instance,of,the,source,index,shards,are,allocated;static,list,string,validate,shrink,index,cluster,state,state,string,source,index,set,string,target,index,mappings,types,string,target,index,name,settings,target,index,settings,index,meta,data,source,meta,data,validate,resize,state,source,index,target,index,mappings,types,target,index,name,target,index,settings,assert,index,meta,data,exists,target,index,settings,index,meta,data,select,shrink,shards,0,source,meta,data,index,meta,data,get,target,index,settings,if,source,meta,data,get,number,of,shards,1,throw,new,illegal,argument,exception,can,t,shrink,an,index,with,only,one,shard,final,index,routing,table,table,state,routing,table,index,source,index,map,string,atomic,integer,nodes,to,num,routing,new,hash,map,int,num,shards,source,meta,data,get,number,of,shards,for,shard,routing,routing,table,shards,with,state,shard,routing,state,started,nodes,to,num,routing,compute,if,absent,routing,current,node,id,s,new,atomic,integer,0,increment,and,get,list,string,nodes,to,allocate,on,new,array,list,for,map,entry,string,atomic,integer,entries,nodes,to,num,routing,entry,set,int,num,allocations,entries,get,value,get,assert,num,allocations,num,shards,wait,what,num,allocations,is,than,num,shards,num,shards,if,num,allocations,num,shards,nodes,to,allocate,on,add,entries,get,key,if,nodes,to,allocate,on,is,empty,throw,new,illegal,state,exception,index,source,index,must,have,all,shards,allocated,on,the,same,node,to,shrink,index,return,nodes,to,allocate,on
MetaDataCreateIndexService -> static List<String> validateShrinkIndex(ClusterState state, String sourceIndex,                                         Set<String> targetIndexMappingsTypes, String targetIndexName,                                         Settings targetIndexSettings);1544702062;Validates the settings and mappings for shrinking an index._@return the list of nodes at least one instance of the source index shards are allocated;static List<String> validateShrinkIndex(ClusterState state, String sourceIndex,_                                        Set<String> targetIndexMappingsTypes, String targetIndexName,_                                        Settings targetIndexSettings) {_        IndexMetaData sourceMetaData = validateResize(state, sourceIndex, targetIndexMappingsTypes, targetIndexName, targetIndexSettings)__        assert IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.exists(targetIndexSettings)__        IndexMetaData.selectShrinkShards(0, sourceMetaData, IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.get(targetIndexSettings))___        if (sourceMetaData.getNumberOfShards() == 1) {_            throw new IllegalArgumentException("can't shrink an index with only one shard")__        }__        _        final IndexRoutingTable table = state.routingTable().index(sourceIndex)__        Map<String, AtomicInteger> nodesToNumRouting = new HashMap<>()__        int numShards = sourceMetaData.getNumberOfShards()__        for (ShardRouting routing : table.shardsWithState(ShardRoutingState.STARTED)) {_            nodesToNumRouting.computeIfAbsent(routing.currentNodeId(), (s) -> new AtomicInteger(0)).incrementAndGet()__        }_        List<String> nodesToAllocateOn = new ArrayList<>()__        for (Map.Entry<String, AtomicInteger> entries : nodesToNumRouting.entrySet()) {_            int numAllocations = entries.getValue().get()__            assert numAllocations <= numShards : "wait what? " + numAllocations + " is > than num shards " + numShards__            if (numAllocations == numShards) {_                nodesToAllocateOn.add(entries.getKey())__            }_        }_        if (nodesToAllocateOn.isEmpty()) {_            throw new IllegalStateException("index " + sourceIndex +_                " must have all shards allocated on the same node to shrink index")__        }_        return nodesToAllocateOn__    };validates,the,settings,and,mappings,for,shrinking,an,index,return,the,list,of,nodes,at,least,one,instance,of,the,source,index,shards,are,allocated;static,list,string,validate,shrink,index,cluster,state,state,string,source,index,set,string,target,index,mappings,types,string,target,index,name,settings,target,index,settings,index,meta,data,source,meta,data,validate,resize,state,source,index,target,index,mappings,types,target,index,name,target,index,settings,assert,index,meta,data,exists,target,index,settings,index,meta,data,select,shrink,shards,0,source,meta,data,index,meta,data,get,target,index,settings,if,source,meta,data,get,number,of,shards,1,throw,new,illegal,argument,exception,can,t,shrink,an,index,with,only,one,shard,final,index,routing,table,table,state,routing,table,index,source,index,map,string,atomic,integer,nodes,to,num,routing,new,hash,map,int,num,shards,source,meta,data,get,number,of,shards,for,shard,routing,routing,table,shards,with,state,shard,routing,state,started,nodes,to,num,routing,compute,if,absent,routing,current,node,id,s,new,atomic,integer,0,increment,and,get,list,string,nodes,to,allocate,on,new,array,list,for,map,entry,string,atomic,integer,entries,nodes,to,num,routing,entry,set,int,num,allocations,entries,get,value,get,assert,num,allocations,num,shards,wait,what,num,allocations,is,than,num,shards,num,shards,if,num,allocations,num,shards,nodes,to,allocate,on,add,entries,get,key,if,nodes,to,allocate,on,is,empty,throw,new,illegal,state,exception,index,source,index,must,have,all,shards,allocated,on,the,same,node,to,shrink,index,return,nodes,to,allocate,on
MetaDataCreateIndexService -> static List<String> validateShrinkIndex(ClusterState state, String sourceIndex,                                         Set<String> targetIndexMappingsTypes, String targetIndexName,                                         Settings targetIndexSettings);1548840504;Validates the settings and mappings for shrinking an index._@return the list of nodes at least one instance of the source index shards are allocated;static List<String> validateShrinkIndex(ClusterState state, String sourceIndex,_                                        Set<String> targetIndexMappingsTypes, String targetIndexName,_                                        Settings targetIndexSettings) {_        IndexMetaData sourceMetaData = validateResize(state, sourceIndex, targetIndexMappingsTypes, targetIndexName, targetIndexSettings)__        assert IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.exists(targetIndexSettings)__        IndexMetaData.selectShrinkShards(0, sourceMetaData, IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.get(targetIndexSettings))___        if (sourceMetaData.getNumberOfShards() == 1) {_            throw new IllegalArgumentException("can't shrink an index with only one shard")__        }__        _        final IndexRoutingTable table = state.routingTable().index(sourceIndex)__        Map<String, AtomicInteger> nodesToNumRouting = new HashMap<>()__        int numShards = sourceMetaData.getNumberOfShards()__        for (ShardRouting routing : table.shardsWithState(ShardRoutingState.STARTED)) {_            nodesToNumRouting.computeIfAbsent(routing.currentNodeId(), (s) -> new AtomicInteger(0)).incrementAndGet()__        }_        List<String> nodesToAllocateOn = new ArrayList<>()__        for (Map.Entry<String, AtomicInteger> entries : nodesToNumRouting.entrySet()) {_            int numAllocations = entries.getValue().get()__            assert numAllocations <= numShards : "wait what? " + numAllocations + " is > than num shards " + numShards__            if (numAllocations == numShards) {_                nodesToAllocateOn.add(entries.getKey())__            }_        }_        if (nodesToAllocateOn.isEmpty()) {_            throw new IllegalStateException("index " + sourceIndex +_                " must have all shards allocated on the same node to shrink index")__        }_        return nodesToAllocateOn__    };validates,the,settings,and,mappings,for,shrinking,an,index,return,the,list,of,nodes,at,least,one,instance,of,the,source,index,shards,are,allocated;static,list,string,validate,shrink,index,cluster,state,state,string,source,index,set,string,target,index,mappings,types,string,target,index,name,settings,target,index,settings,index,meta,data,source,meta,data,validate,resize,state,source,index,target,index,mappings,types,target,index,name,target,index,settings,assert,index,meta,data,exists,target,index,settings,index,meta,data,select,shrink,shards,0,source,meta,data,index,meta,data,get,target,index,settings,if,source,meta,data,get,number,of,shards,1,throw,new,illegal,argument,exception,can,t,shrink,an,index,with,only,one,shard,final,index,routing,table,table,state,routing,table,index,source,index,map,string,atomic,integer,nodes,to,num,routing,new,hash,map,int,num,shards,source,meta,data,get,number,of,shards,for,shard,routing,routing,table,shards,with,state,shard,routing,state,started,nodes,to,num,routing,compute,if,absent,routing,current,node,id,s,new,atomic,integer,0,increment,and,get,list,string,nodes,to,allocate,on,new,array,list,for,map,entry,string,atomic,integer,entries,nodes,to,num,routing,entry,set,int,num,allocations,entries,get,value,get,assert,num,allocations,num,shards,wait,what,num,allocations,is,than,num,shards,num,shards,if,num,allocations,num,shards,nodes,to,allocate,on,add,entries,get,key,if,nodes,to,allocate,on,is,empty,throw,new,illegal,state,exception,index,source,index,must,have,all,shards,allocated,on,the,same,node,to,shrink,index,return,nodes,to,allocate,on
MetaDataCreateIndexService -> static List<String> validateShrinkIndex(ClusterState state, String sourceIndex,                                         Set<String> targetIndexMappingsTypes, String targetIndexName,                                         Settings targetIndexSettings);1549608646;Validates the settings and mappings for shrinking an index._@return the list of nodes at least one instance of the source index shards are allocated;static List<String> validateShrinkIndex(ClusterState state, String sourceIndex,_                                        Set<String> targetIndexMappingsTypes, String targetIndexName,_                                        Settings targetIndexSettings) {_        IndexMetaData sourceMetaData = validateResize(state, sourceIndex, targetIndexMappingsTypes, targetIndexName, targetIndexSettings)__        assert IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.exists(targetIndexSettings)__        IndexMetaData.selectShrinkShards(0, sourceMetaData, IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.get(targetIndexSettings))___        if (sourceMetaData.getNumberOfShards() == 1) {_            throw new IllegalArgumentException("can't shrink an index with only one shard")__        }__        _        final IndexRoutingTable table = state.routingTable().index(sourceIndex)__        Map<String, AtomicInteger> nodesToNumRouting = new HashMap<>()__        int numShards = sourceMetaData.getNumberOfShards()__        for (ShardRouting routing : table.shardsWithState(ShardRoutingState.STARTED)) {_            nodesToNumRouting.computeIfAbsent(routing.currentNodeId(), (s) -> new AtomicInteger(0)).incrementAndGet()__        }_        List<String> nodesToAllocateOn = new ArrayList<>()__        for (Map.Entry<String, AtomicInteger> entries : nodesToNumRouting.entrySet()) {_            int numAllocations = entries.getValue().get()__            assert numAllocations <= numShards : "wait what? " + numAllocations + " is > than num shards " + numShards__            if (numAllocations == numShards) {_                nodesToAllocateOn.add(entries.getKey())__            }_        }_        if (nodesToAllocateOn.isEmpty()) {_            throw new IllegalStateException("index " + sourceIndex +_                " must have all shards allocated on the same node to shrink index")__        }_        return nodesToAllocateOn__    };validates,the,settings,and,mappings,for,shrinking,an,index,return,the,list,of,nodes,at,least,one,instance,of,the,source,index,shards,are,allocated;static,list,string,validate,shrink,index,cluster,state,state,string,source,index,set,string,target,index,mappings,types,string,target,index,name,settings,target,index,settings,index,meta,data,source,meta,data,validate,resize,state,source,index,target,index,mappings,types,target,index,name,target,index,settings,assert,index,meta,data,exists,target,index,settings,index,meta,data,select,shrink,shards,0,source,meta,data,index,meta,data,get,target,index,settings,if,source,meta,data,get,number,of,shards,1,throw,new,illegal,argument,exception,can,t,shrink,an,index,with,only,one,shard,final,index,routing,table,table,state,routing,table,index,source,index,map,string,atomic,integer,nodes,to,num,routing,new,hash,map,int,num,shards,source,meta,data,get,number,of,shards,for,shard,routing,routing,table,shards,with,state,shard,routing,state,started,nodes,to,num,routing,compute,if,absent,routing,current,node,id,s,new,atomic,integer,0,increment,and,get,list,string,nodes,to,allocate,on,new,array,list,for,map,entry,string,atomic,integer,entries,nodes,to,num,routing,entry,set,int,num,allocations,entries,get,value,get,assert,num,allocations,num,shards,wait,what,num,allocations,is,than,num,shards,num,shards,if,num,allocations,num,shards,nodes,to,allocate,on,add,entries,get,key,if,nodes,to,allocate,on,is,empty,throw,new,illegal,state,exception,index,source,index,must,have,all,shards,allocated,on,the,same,node,to,shrink,index,return,nodes,to,allocate,on
MetaDataCreateIndexService -> public static int calculateNumRoutingShards(int numShards, Version indexVersionCreated);1524684173;Returns a default number of routing shards based on the number of shards of the index. The default number of routing shards will_allow any index to be split at least once and at most 10 times by a factor of two. The closer the number or shards gets to 1024_the less default split operations are supported;public static int calculateNumRoutingShards(int numShards, Version indexVersionCreated) {_        if (indexVersionCreated.onOrAfter(Version.V_7_0_0_alpha1)) {_            _            _            _            _            _            _            int log2MaxNumShards = 10_ _            int log2NumShards = 32 - Integer.numberOfLeadingZeros(numShards - 1)_ _            int numSplits = log2MaxNumShards - log2NumShards__            numSplits = Math.max(1, numSplits)_ _            return numShards * 1 << numSplits__        } else {_            return numShards__        }_    };returns,a,default,number,of,routing,shards,based,on,the,number,of,shards,of,the,index,the,default,number,of,routing,shards,will,allow,any,index,to,be,split,at,least,once,and,at,most,10,times,by,a,factor,of,two,the,closer,the,number,or,shards,gets,to,1024,the,less,default,split,operations,are,supported;public,static,int,calculate,num,routing,shards,int,num,shards,version,index,version,created,if,index,version,created,on,or,after,version,int,log2max,num,shards,10,int,log2num,shards,32,integer,number,of,leading,zeros,num,shards,1,int,num,splits,log2max,num,shards,log2num,shards,num,splits,math,max,1,num,splits,return,num,shards,1,num,splits,else,return,num,shards
MetaDataCreateIndexService -> public static int calculateNumRoutingShards(int numShards, Version indexVersionCreated);1525162917;Returns a default number of routing shards based on the number of shards of the index. The default number of routing shards will_allow any index to be split at least once and at most 10 times by a factor of two. The closer the number or shards gets to 1024_the less default split operations are supported;public static int calculateNumRoutingShards(int numShards, Version indexVersionCreated) {_        if (indexVersionCreated.onOrAfter(Version.V_7_0_0_alpha1)) {_            _            _            _            _            _            _            int log2MaxNumShards = 10_ _            int log2NumShards = 32 - Integer.numberOfLeadingZeros(numShards - 1)_ _            int numSplits = log2MaxNumShards - log2NumShards__            numSplits = Math.max(1, numSplits)_ _            return numShards * 1 << numSplits__        } else {_            return numShards__        }_    };returns,a,default,number,of,routing,shards,based,on,the,number,of,shards,of,the,index,the,default,number,of,routing,shards,will,allow,any,index,to,be,split,at,least,once,and,at,most,10,times,by,a,factor,of,two,the,closer,the,number,or,shards,gets,to,1024,the,less,default,split,operations,are,supported;public,static,int,calculate,num,routing,shards,int,num,shards,version,index,version,created,if,index,version,created,on,or,after,version,int,log2max,num,shards,10,int,log2num,shards,32,integer,number,of,leading,zeros,num,shards,1,int,num,splits,log2max,num,shards,log2num,shards,num,splits,math,max,1,num,splits,return,num,shards,1,num,splits,else,return,num,shards
MetaDataCreateIndexService -> public static int calculateNumRoutingShards(int numShards, Version indexVersionCreated);1525248068;Returns a default number of routing shards based on the number of shards of the index. The default number of routing shards will_allow any index to be split at least once and at most 10 times by a factor of two. The closer the number or shards gets to 1024_the less default split operations are supported;public static int calculateNumRoutingShards(int numShards, Version indexVersionCreated) {_        if (indexVersionCreated.onOrAfter(Version.V_7_0_0_alpha1)) {_            _            _            _            _            _            _            int log2MaxNumShards = 10_ _            int log2NumShards = 32 - Integer.numberOfLeadingZeros(numShards - 1)_ _            int numSplits = log2MaxNumShards - log2NumShards__            numSplits = Math.max(1, numSplits)_ _            return numShards * 1 << numSplits__        } else {_            return numShards__        }_    };returns,a,default,number,of,routing,shards,based,on,the,number,of,shards,of,the,index,the,default,number,of,routing,shards,will,allow,any,index,to,be,split,at,least,once,and,at,most,10,times,by,a,factor,of,two,the,closer,the,number,or,shards,gets,to,1024,the,less,default,split,operations,are,supported;public,static,int,calculate,num,routing,shards,int,num,shards,version,index,version,created,if,index,version,created,on,or,after,version,int,log2max,num,shards,10,int,log2num,shards,32,integer,number,of,leading,zeros,num,shards,1,int,num,splits,log2max,num,shards,log2num,shards,num,splits,math,max,1,num,splits,return,num,shards,1,num,splits,else,return,num,shards
MetaDataCreateIndexService -> public static int calculateNumRoutingShards(int numShards, Version indexVersionCreated);1526374795;Returns a default number of routing shards based on the number of shards of the index. The default number of routing shards will_allow any index to be split at least once and at most 10 times by a factor of two. The closer the number or shards gets to 1024_the less default split operations are supported;public static int calculateNumRoutingShards(int numShards, Version indexVersionCreated) {_        if (indexVersionCreated.onOrAfter(Version.V_7_0_0_alpha1)) {_            _            _            _            _            _            _            int log2MaxNumShards = 10_ _            int log2NumShards = 32 - Integer.numberOfLeadingZeros(numShards - 1)_ _            int numSplits = log2MaxNumShards - log2NumShards__            numSplits = Math.max(1, numSplits)_ _            return numShards * 1 << numSplits__        } else {_            return numShards__        }_    };returns,a,default,number,of,routing,shards,based,on,the,number,of,shards,of,the,index,the,default,number,of,routing,shards,will,allow,any,index,to,be,split,at,least,once,and,at,most,10,times,by,a,factor,of,two,the,closer,the,number,or,shards,gets,to,1024,the,less,default,split,operations,are,supported;public,static,int,calculate,num,routing,shards,int,num,shards,version,index,version,created,if,index,version,created,on,or,after,version,int,log2max,num,shards,10,int,log2num,shards,32,integer,number,of,leading,zeros,num,shards,1,int,num,splits,log2max,num,shards,log2num,shards,num,splits,math,max,1,num,splits,return,num,shards,1,num,splits,else,return,num,shards
MetaDataCreateIndexService -> public static int calculateNumRoutingShards(int numShards, Version indexVersionCreated);1529082965;Returns a default number of routing shards based on the number of shards of the index. The default number of routing shards will_allow any index to be split at least once and at most 10 times by a factor of two. The closer the number or shards gets to 1024_the less default split operations are supported;public static int calculateNumRoutingShards(int numShards, Version indexVersionCreated) {_        if (indexVersionCreated.onOrAfter(Version.V_7_0_0_alpha1)) {_            _            _            _            _            _            _            int log2MaxNumShards = 10_ _            int log2NumShards = 32 - Integer.numberOfLeadingZeros(numShards - 1)_ _            int numSplits = log2MaxNumShards - log2NumShards__            numSplits = Math.max(1, numSplits)_ _            return numShards * 1 << numSplits__        } else {_            return numShards__        }_    };returns,a,default,number,of,routing,shards,based,on,the,number,of,shards,of,the,index,the,default,number,of,routing,shards,will,allow,any,index,to,be,split,at,least,once,and,at,most,10,times,by,a,factor,of,two,the,closer,the,number,or,shards,gets,to,1024,the,less,default,split,operations,are,supported;public,static,int,calculate,num,routing,shards,int,num,shards,version,index,version,created,if,index,version,created,on,or,after,version,int,log2max,num,shards,10,int,log2num,shards,32,integer,number,of,leading,zeros,num,shards,1,int,num,splits,log2max,num,shards,log2num,shards,num,splits,math,max,1,num,splits,return,num,shards,1,num,splits,else,return,num,shards
MetaDataCreateIndexService -> public static int calculateNumRoutingShards(int numShards, Version indexVersionCreated);1531382259;Returns a default number of routing shards based on the number of shards of the index. The default number of routing shards will_allow any index to be split at least once and at most 10 times by a factor of two. The closer the number or shards gets to 1024_the less default split operations are supported;public static int calculateNumRoutingShards(int numShards, Version indexVersionCreated) {_        if (indexVersionCreated.onOrAfter(Version.V_7_0_0_alpha1)) {_            _            _            _            _            _            _            int log2MaxNumShards = 10_ _            int log2NumShards = 32 - Integer.numberOfLeadingZeros(numShards - 1)_ _            int numSplits = log2MaxNumShards - log2NumShards__            numSplits = Math.max(1, numSplits)_ _            return numShards * 1 << numSplits__        } else {_            return numShards__        }_    };returns,a,default,number,of,routing,shards,based,on,the,number,of,shards,of,the,index,the,default,number,of,routing,shards,will,allow,any,index,to,be,split,at,least,once,and,at,most,10,times,by,a,factor,of,two,the,closer,the,number,or,shards,gets,to,1024,the,less,default,split,operations,are,supported;public,static,int,calculate,num,routing,shards,int,num,shards,version,index,version,created,if,index,version,created,on,or,after,version,int,log2max,num,shards,10,int,log2num,shards,32,integer,number,of,leading,zeros,num,shards,1,int,num,splits,log2max,num,shards,log2num,shards,num,splits,math,max,1,num,splits,return,num,shards,1,num,splits,else,return,num,shards
MetaDataCreateIndexService -> public static int calculateNumRoutingShards(int numShards, Version indexVersionCreated);1535666657;Returns a default number of routing shards based on the number of shards of the index. The default number of routing shards will_allow any index to be split at least once and at most 10 times by a factor of two. The closer the number or shards gets to 1024_the less default split operations are supported;public static int calculateNumRoutingShards(int numShards, Version indexVersionCreated) {_        if (indexVersionCreated.onOrAfter(Version.V_7_0_0_alpha1)) {_            _            _            _            _            _            _            int log2MaxNumShards = 10_ _            int log2NumShards = 32 - Integer.numberOfLeadingZeros(numShards - 1)_ _            int numSplits = log2MaxNumShards - log2NumShards__            numSplits = Math.max(1, numSplits)_ _            return numShards * 1 << numSplits__        } else {_            return numShards__        }_    };returns,a,default,number,of,routing,shards,based,on,the,number,of,shards,of,the,index,the,default,number,of,routing,shards,will,allow,any,index,to,be,split,at,least,once,and,at,most,10,times,by,a,factor,of,two,the,closer,the,number,or,shards,gets,to,1024,the,less,default,split,operations,are,supported;public,static,int,calculate,num,routing,shards,int,num,shards,version,index,version,created,if,index,version,created,on,or,after,version,int,log2max,num,shards,10,int,log2num,shards,32,integer,number,of,leading,zeros,num,shards,1,int,num,splits,log2max,num,shards,log2num,shards,num,splits,math,max,1,num,splits,return,num,shards,1,num,splits,else,return,num,shards
MetaDataCreateIndexService -> public static int calculateNumRoutingShards(int numShards, Version indexVersionCreated);1536137328;Returns a default number of routing shards based on the number of shards of the index. The default number of routing shards will_allow any index to be split at least once and at most 10 times by a factor of two. The closer the number or shards gets to 1024_the less default split operations are supported;public static int calculateNumRoutingShards(int numShards, Version indexVersionCreated) {_        if (indexVersionCreated.onOrAfter(Version.V_7_0_0_alpha1)) {_            _            _            _            _            _            _            int log2MaxNumShards = 10_ _            int log2NumShards = 32 - Integer.numberOfLeadingZeros(numShards - 1)_ _            int numSplits = log2MaxNumShards - log2NumShards__            numSplits = Math.max(1, numSplits)_ _            return numShards * 1 << numSplits__        } else {_            return numShards__        }_    };returns,a,default,number,of,routing,shards,based,on,the,number,of,shards,of,the,index,the,default,number,of,routing,shards,will,allow,any,index,to,be,split,at,least,once,and,at,most,10,times,by,a,factor,of,two,the,closer,the,number,or,shards,gets,to,1024,the,less,default,split,operations,are,supported;public,static,int,calculate,num,routing,shards,int,num,shards,version,index,version,created,if,index,version,created,on,or,after,version,int,log2max,num,shards,10,int,log2num,shards,32,integer,number,of,leading,zeros,num,shards,1,int,num,splits,log2max,num,shards,log2num,shards,num,splits,math,max,1,num,splits,return,num,shards,1,num,splits,else,return,num,shards
MetaDataCreateIndexService -> public static int calculateNumRoutingShards(int numShards, Version indexVersionCreated);1536828374;Returns a default number of routing shards based on the number of shards of the index. The default number of routing shards will_allow any index to be split at least once and at most 10 times by a factor of two. The closer the number or shards gets to 1024_the less default split operations are supported;public static int calculateNumRoutingShards(int numShards, Version indexVersionCreated) {_        if (indexVersionCreated.onOrAfter(Version.V_7_0_0_alpha1)) {_            _            _            _            _            _            _            int log2MaxNumShards = 10_ _            int log2NumShards = 32 - Integer.numberOfLeadingZeros(numShards - 1)_ _            int numSplits = log2MaxNumShards - log2NumShards__            numSplits = Math.max(1, numSplits)_ _            return numShards * 1 << numSplits__        } else {_            return numShards__        }_    };returns,a,default,number,of,routing,shards,based,on,the,number,of,shards,of,the,index,the,default,number,of,routing,shards,will,allow,any,index,to,be,split,at,least,once,and,at,most,10,times,by,a,factor,of,two,the,closer,the,number,or,shards,gets,to,1024,the,less,default,split,operations,are,supported;public,static,int,calculate,num,routing,shards,int,num,shards,version,index,version,created,if,index,version,created,on,or,after,version,int,log2max,num,shards,10,int,log2num,shards,32,integer,number,of,leading,zeros,num,shards,1,int,num,splits,log2max,num,shards,log2num,shards,num,splits,math,max,1,num,splits,return,num,shards,1,num,splits,else,return,num,shards
MetaDataCreateIndexService -> public static int calculateNumRoutingShards(int numShards, Version indexVersionCreated);1540486836;Returns a default number of routing shards based on the number of shards of the index. The default number of routing shards will_allow any index to be split at least once and at most 10 times by a factor of two. The closer the number or shards gets to 1024_the less default split operations are supported;public static int calculateNumRoutingShards(int numShards, Version indexVersionCreated) {_        if (indexVersionCreated.onOrAfter(Version.V_7_0_0_alpha1)) {_            _            _            _            _            _            _            int log2MaxNumShards = 10_ _            int log2NumShards = 32 - Integer.numberOfLeadingZeros(numShards - 1)_ _            int numSplits = log2MaxNumShards - log2NumShards__            numSplits = Math.max(1, numSplits)_ _            return numShards * 1 << numSplits__        } else {_            return numShards__        }_    };returns,a,default,number,of,routing,shards,based,on,the,number,of,shards,of,the,index,the,default,number,of,routing,shards,will,allow,any,index,to,be,split,at,least,once,and,at,most,10,times,by,a,factor,of,two,the,closer,the,number,or,shards,gets,to,1024,the,less,default,split,operations,are,supported;public,static,int,calculate,num,routing,shards,int,num,shards,version,index,version,created,if,index,version,created,on,or,after,version,int,log2max,num,shards,10,int,log2num,shards,32,integer,number,of,leading,zeros,num,shards,1,int,num,splits,log2max,num,shards,log2num,shards,num,splits,math,max,1,num,splits,return,num,shards,1,num,splits,else,return,num,shards
MetaDataCreateIndexService -> public static int calculateNumRoutingShards(int numShards, Version indexVersionCreated);1540847035;Returns a default number of routing shards based on the number of shards of the index. The default number of routing shards will_allow any index to be split at least once and at most 10 times by a factor of two. The closer the number or shards gets to 1024_the less default split operations are supported;public static int calculateNumRoutingShards(int numShards, Version indexVersionCreated) {_        if (indexVersionCreated.onOrAfter(Version.V_7_0_0_alpha1)) {_            _            _            _            _            _            _            int log2MaxNumShards = 10_ _            int log2NumShards = 32 - Integer.numberOfLeadingZeros(numShards - 1)_ _            int numSplits = log2MaxNumShards - log2NumShards__            numSplits = Math.max(1, numSplits)_ _            return numShards * 1 << numSplits__        } else {_            return numShards__        }_    };returns,a,default,number,of,routing,shards,based,on,the,number,of,shards,of,the,index,the,default,number,of,routing,shards,will,allow,any,index,to,be,split,at,least,once,and,at,most,10,times,by,a,factor,of,two,the,closer,the,number,or,shards,gets,to,1024,the,less,default,split,operations,are,supported;public,static,int,calculate,num,routing,shards,int,num,shards,version,index,version,created,if,index,version,created,on,or,after,version,int,log2max,num,shards,10,int,log2num,shards,32,integer,number,of,leading,zeros,num,shards,1,int,num,splits,log2max,num,shards,log2num,shards,num,splits,math,max,1,num,splits,return,num,shards,1,num,splits,else,return,num,shards
MetaDataCreateIndexService -> public static int calculateNumRoutingShards(int numShards, Version indexVersionCreated);1541008027;Returns a default number of routing shards based on the number of shards of the index. The default number of routing shards will_allow any index to be split at least once and at most 10 times by a factor of two. The closer the number or shards gets to 1024_the less default split operations are supported;public static int calculateNumRoutingShards(int numShards, Version indexVersionCreated) {_        if (indexVersionCreated.onOrAfter(Version.V_7_0_0_alpha1)) {_            _            _            _            _            _            _            int log2MaxNumShards = 10_ _            int log2NumShards = 32 - Integer.numberOfLeadingZeros(numShards - 1)_ _            int numSplits = log2MaxNumShards - log2NumShards__            numSplits = Math.max(1, numSplits)_ _            return numShards * 1 << numSplits__        } else {_            return numShards__        }_    };returns,a,default,number,of,routing,shards,based,on,the,number,of,shards,of,the,index,the,default,number,of,routing,shards,will,allow,any,index,to,be,split,at,least,once,and,at,most,10,times,by,a,factor,of,two,the,closer,the,number,or,shards,gets,to,1024,the,less,default,split,operations,are,supported;public,static,int,calculate,num,routing,shards,int,num,shards,version,index,version,created,if,index,version,created,on,or,after,version,int,log2max,num,shards,10,int,log2num,shards,32,integer,number,of,leading,zeros,num,shards,1,int,num,splits,log2max,num,shards,log2num,shards,num,splits,math,max,1,num,splits,return,num,shards,1,num,splits,else,return,num,shards
MetaDataCreateIndexService -> public static int calculateNumRoutingShards(int numShards, Version indexVersionCreated);1541092382;Returns a default number of routing shards based on the number of shards of the index. The default number of routing shards will_allow any index to be split at least once and at most 10 times by a factor of two. The closer the number or shards gets to 1024_the less default split operations are supported;public static int calculateNumRoutingShards(int numShards, Version indexVersionCreated) {_        if (indexVersionCreated.onOrAfter(Version.V_7_0_0_alpha1)) {_            _            _            _            _            _            _            int log2MaxNumShards = 10_ _            int log2NumShards = 32 - Integer.numberOfLeadingZeros(numShards - 1)_ _            int numSplits = log2MaxNumShards - log2NumShards__            numSplits = Math.max(1, numSplits)_ _            return numShards * 1 << numSplits__        } else {_            return numShards__        }_    };returns,a,default,number,of,routing,shards,based,on,the,number,of,shards,of,the,index,the,default,number,of,routing,shards,will,allow,any,index,to,be,split,at,least,once,and,at,most,10,times,by,a,factor,of,two,the,closer,the,number,or,shards,gets,to,1024,the,less,default,split,operations,are,supported;public,static,int,calculate,num,routing,shards,int,num,shards,version,index,version,created,if,index,version,created,on,or,after,version,int,log2max,num,shards,10,int,log2num,shards,32,integer,number,of,leading,zeros,num,shards,1,int,num,splits,log2max,num,shards,log2num,shards,num,splits,math,max,1,num,splits,return,num,shards,1,num,splits,else,return,num,shards
MetaDataCreateIndexService -> public static int calculateNumRoutingShards(int numShards, Version indexVersionCreated);1541592065;Returns a default number of routing shards based on the number of shards of the index. The default number of routing shards will_allow any index to be split at least once and at most 10 times by a factor of two. The closer the number or shards gets to 1024_the less default split operations are supported;public static int calculateNumRoutingShards(int numShards, Version indexVersionCreated) {_        if (indexVersionCreated.onOrAfter(Version.V_7_0_0)) {_            _            _            _            _            _            _            int log2MaxNumShards = 10_ _            int log2NumShards = 32 - Integer.numberOfLeadingZeros(numShards - 1)_ _            int numSplits = log2MaxNumShards - log2NumShards__            numSplits = Math.max(1, numSplits)_ _            return numShards * 1 << numSplits__        } else {_            return numShards__        }_    };returns,a,default,number,of,routing,shards,based,on,the,number,of,shards,of,the,index,the,default,number,of,routing,shards,will,allow,any,index,to,be,split,at,least,once,and,at,most,10,times,by,a,factor,of,two,the,closer,the,number,or,shards,gets,to,1024,the,less,default,split,operations,are,supported;public,static,int,calculate,num,routing,shards,int,num,shards,version,index,version,created,if,index,version,created,on,or,after,version,int,log2max,num,shards,10,int,log2num,shards,32,integer,number,of,leading,zeros,num,shards,1,int,num,splits,log2max,num,shards,log2num,shards,num,splits,math,max,1,num,splits,return,num,shards,1,num,splits,else,return,num,shards
MetaDataCreateIndexService -> public static int calculateNumRoutingShards(int numShards, Version indexVersionCreated);1542402632;Returns a default number of routing shards based on the number of shards of the index. The default number of routing shards will_allow any index to be split at least once and at most 10 times by a factor of two. The closer the number or shards gets to 1024_the less default split operations are supported;public static int calculateNumRoutingShards(int numShards, Version indexVersionCreated) {_        if (indexVersionCreated.onOrAfter(Version.V_7_0_0)) {_            _            _            _            _            _            _            int log2MaxNumShards = 10_ _            int log2NumShards = 32 - Integer.numberOfLeadingZeros(numShards - 1)_ _            int numSplits = log2MaxNumShards - log2NumShards__            numSplits = Math.max(1, numSplits)_ _            return numShards * 1 << numSplits__        } else {_            return numShards__        }_    };returns,a,default,number,of,routing,shards,based,on,the,number,of,shards,of,the,index,the,default,number,of,routing,shards,will,allow,any,index,to,be,split,at,least,once,and,at,most,10,times,by,a,factor,of,two,the,closer,the,number,or,shards,gets,to,1024,the,less,default,split,operations,are,supported;public,static,int,calculate,num,routing,shards,int,num,shards,version,index,version,created,if,index,version,created,on,or,after,version,int,log2max,num,shards,10,int,log2num,shards,32,integer,number,of,leading,zeros,num,shards,1,int,num,splits,log2max,num,shards,log2num,shards,num,splits,math,max,1,num,splits,return,num,shards,1,num,splits,else,return,num,shards
MetaDataCreateIndexService -> public static int calculateNumRoutingShards(int numShards, Version indexVersionCreated);1543277112;Returns a default number of routing shards based on the number of shards of the index. The default number of routing shards will_allow any index to be split at least once and at most 10 times by a factor of two. The closer the number or shards gets to 1024_the less default split operations are supported;public static int calculateNumRoutingShards(int numShards, Version indexVersionCreated) {_        if (indexVersionCreated.onOrAfter(Version.V_7_0_0)) {_            _            _            _            _            _            _            int log2MaxNumShards = 10_ _            int log2NumShards = 32 - Integer.numberOfLeadingZeros(numShards - 1)_ _            int numSplits = log2MaxNumShards - log2NumShards__            numSplits = Math.max(1, numSplits)_ _            return numShards * 1 << numSplits__        } else {_            return numShards__        }_    };returns,a,default,number,of,routing,shards,based,on,the,number,of,shards,of,the,index,the,default,number,of,routing,shards,will,allow,any,index,to,be,split,at,least,once,and,at,most,10,times,by,a,factor,of,two,the,closer,the,number,or,shards,gets,to,1024,the,less,default,split,operations,are,supported;public,static,int,calculate,num,routing,shards,int,num,shards,version,index,version,created,if,index,version,created,on,or,after,version,int,log2max,num,shards,10,int,log2num,shards,32,integer,number,of,leading,zeros,num,shards,1,int,num,splits,log2max,num,shards,log2num,shards,num,splits,math,max,1,num,splits,return,num,shards,1,num,splits,else,return,num,shards
MetaDataCreateIndexService -> public static int calculateNumRoutingShards(int numShards, Version indexVersionCreated);1544702062;Returns a default number of routing shards based on the number of shards of the index. The default number of routing shards will_allow any index to be split at least once and at most 10 times by a factor of two. The closer the number or shards gets to 1024_the less default split operations are supported;public static int calculateNumRoutingShards(int numShards, Version indexVersionCreated) {_        if (indexVersionCreated.onOrAfter(Version.V_7_0_0)) {_            _            _            _            _            _            _            int log2MaxNumShards = 10_ _            int log2NumShards = 32 - Integer.numberOfLeadingZeros(numShards - 1)_ _            int numSplits = log2MaxNumShards - log2NumShards__            numSplits = Math.max(1, numSplits)_ _            return numShards * 1 << numSplits__        } else {_            return numShards__        }_    };returns,a,default,number,of,routing,shards,based,on,the,number,of,shards,of,the,index,the,default,number,of,routing,shards,will,allow,any,index,to,be,split,at,least,once,and,at,most,10,times,by,a,factor,of,two,the,closer,the,number,or,shards,gets,to,1024,the,less,default,split,operations,are,supported;public,static,int,calculate,num,routing,shards,int,num,shards,version,index,version,created,if,index,version,created,on,or,after,version,int,log2max,num,shards,10,int,log2num,shards,32,integer,number,of,leading,zeros,num,shards,1,int,num,splits,log2max,num,shards,log2num,shards,num,splits,math,max,1,num,splits,return,num,shards,1,num,splits,else,return,num,shards
MetaDataCreateIndexService -> public static int calculateNumRoutingShards(int numShards, Version indexVersionCreated);1548840504;Returns a default number of routing shards based on the number of shards of the index. The default number of routing shards will_allow any index to be split at least once and at most 10 times by a factor of two. The closer the number or shards gets to 1024_the less default split operations are supported;public static int calculateNumRoutingShards(int numShards, Version indexVersionCreated) {_        if (indexVersionCreated.onOrAfter(Version.V_7_0_0)) {_            _            _            _            _            _            _            int log2MaxNumShards = 10_ _            int log2NumShards = 32 - Integer.numberOfLeadingZeros(numShards - 1)_ _            int numSplits = log2MaxNumShards - log2NumShards__            numSplits = Math.max(1, numSplits)_ _            return numShards * 1 << numSplits__        } else {_            return numShards__        }_    };returns,a,default,number,of,routing,shards,based,on,the,number,of,shards,of,the,index,the,default,number,of,routing,shards,will,allow,any,index,to,be,split,at,least,once,and,at,most,10,times,by,a,factor,of,two,the,closer,the,number,or,shards,gets,to,1024,the,less,default,split,operations,are,supported;public,static,int,calculate,num,routing,shards,int,num,shards,version,index,version,created,if,index,version,created,on,or,after,version,int,log2max,num,shards,10,int,log2num,shards,32,integer,number,of,leading,zeros,num,shards,1,int,num,splits,log2max,num,shards,log2num,shards,num,splits,math,max,1,num,splits,return,num,shards,1,num,splits,else,return,num,shards
MetaDataCreateIndexService -> public static int calculateNumRoutingShards(int numShards, Version indexVersionCreated);1549608646;Returns a default number of routing shards based on the number of shards of the index. The default number of routing shards will_allow any index to be split at least once and at most 10 times by a factor of two. The closer the number or shards gets to 1024_the less default split operations are supported;public static int calculateNumRoutingShards(int numShards, Version indexVersionCreated) {_        if (indexVersionCreated.onOrAfter(Version.V_7_0_0)) {_            _            _            _            _            _            _            int log2MaxNumShards = 10_ _            int log2NumShards = 32 - Integer.numberOfLeadingZeros(numShards - 1)_ _            int numSplits = log2MaxNumShards - log2NumShards__            numSplits = Math.max(1, numSplits)_ _            return numShards * 1 << numSplits__        } else {_            return numShards__        }_    };returns,a,default,number,of,routing,shards,based,on,the,number,of,shards,of,the,index,the,default,number,of,routing,shards,will,allow,any,index,to,be,split,at,least,once,and,at,most,10,times,by,a,factor,of,two,the,closer,the,number,or,shards,gets,to,1024,the,less,default,split,operations,are,supported;public,static,int,calculate,num,routing,shards,int,num,shards,version,index,version,created,if,index,version,created,on,or,after,version,int,log2max,num,shards,10,int,log2num,shards,32,integer,number,of,leading,zeros,num,shards,1,int,num,splits,log2max,num,shards,log2num,shards,num,splits,math,max,1,num,splits,return,num,shards,1,num,splits,else,return,num,shards
MetaDataCreateIndexService -> static Optional<String> checkShardLimit(Settings settings, ClusterState clusterState);1543277112;Checks whether an index can be created without going over the cluster shard limit.__@param settings The settings of the index to be created._@param clusterState The current cluster state._@return If present, an error message to be used to reject index creation. If empty, a signal that this operation may be carried out.;static Optional<String> checkShardLimit(Settings settings, ClusterState clusterState) {_        int shardsToCreate = IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.get(settings)_            * (1 + IndexMetaData.INDEX_NUMBER_OF_REPLICAS_SETTING.get(settings))___        return IndicesService.checkShardLimit(shardsToCreate, clusterState)__    };checks,whether,an,index,can,be,created,without,going,over,the,cluster,shard,limit,param,settings,the,settings,of,the,index,to,be,created,param,cluster,state,the,current,cluster,state,return,if,present,an,error,message,to,be,used,to,reject,index,creation,if,empty,a,signal,that,this,operation,may,be,carried,out;static,optional,string,check,shard,limit,settings,settings,cluster,state,cluster,state,int,shards,to,create,index,meta,data,get,settings,1,index,meta,data,get,settings,return,indices,service,check,shard,limit,shards,to,create,cluster,state
MetaDataCreateIndexService -> static Optional<String> checkShardLimit(Settings settings, ClusterState clusterState);1544702062;Checks whether an index can be created without going over the cluster shard limit.__@param settings The settings of the index to be created._@param clusterState The current cluster state._@return If present, an error message to be used to reject index creation. If empty, a signal that this operation may be carried out.;static Optional<String> checkShardLimit(Settings settings, ClusterState clusterState) {_        int shardsToCreate = IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.get(settings)_            * (1 + IndexMetaData.INDEX_NUMBER_OF_REPLICAS_SETTING.get(settings))___        return IndicesService.checkShardLimit(shardsToCreate, clusterState)__    };checks,whether,an,index,can,be,created,without,going,over,the,cluster,shard,limit,param,settings,the,settings,of,the,index,to,be,created,param,cluster,state,the,current,cluster,state,return,if,present,an,error,message,to,be,used,to,reject,index,creation,if,empty,a,signal,that,this,operation,may,be,carried,out;static,optional,string,check,shard,limit,settings,settings,cluster,state,cluster,state,int,shards,to,create,index,meta,data,get,settings,1,index,meta,data,get,settings,return,indices,service,check,shard,limit,shards,to,create,cluster,state
MetaDataCreateIndexService -> static Optional<String> checkShardLimit(Settings settings, ClusterState clusterState);1548840504;Checks whether an index can be created without going over the cluster shard limit.__@param settings The settings of the index to be created._@param clusterState The current cluster state._@return If present, an error message to be used to reject index creation. If empty, a signal that this operation may be carried out.;static Optional<String> checkShardLimit(Settings settings, ClusterState clusterState) {_        int shardsToCreate = IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.get(settings)_            * (1 + IndexMetaData.INDEX_NUMBER_OF_REPLICAS_SETTING.get(settings))___        return IndicesService.checkShardLimit(shardsToCreate, clusterState)__    };checks,whether,an,index,can,be,created,without,going,over,the,cluster,shard,limit,param,settings,the,settings,of,the,index,to,be,created,param,cluster,state,the,current,cluster,state,return,if,present,an,error,message,to,be,used,to,reject,index,creation,if,empty,a,signal,that,this,operation,may,be,carried,out;static,optional,string,check,shard,limit,settings,settings,cluster,state,cluster,state,int,shards,to,create,index,meta,data,get,settings,1,index,meta,data,get,settings,return,indices,service,check,shard,limit,shards,to,create,cluster,state
MetaDataCreateIndexService -> static Optional<String> checkShardLimit(Settings settings, ClusterState clusterState);1549608646;Checks whether an index can be created without going over the cluster shard limit.__@param settings The settings of the index to be created._@param clusterState The current cluster state._@return If present, an error message to be used to reject index creation. If empty, a signal that this operation may be carried out.;static Optional<String> checkShardLimit(Settings settings, ClusterState clusterState) {_        int shardsToCreate = IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.get(settings)_            * (1 + IndexMetaData.INDEX_NUMBER_OF_REPLICAS_SETTING.get(settings))___        return IndicesService.checkShardLimit(shardsToCreate, clusterState)__    };checks,whether,an,index,can,be,created,without,going,over,the,cluster,shard,limit,param,settings,the,settings,of,the,index,to,be,created,param,cluster,state,the,current,cluster,state,return,if,present,an,error,message,to,be,used,to,reject,index,creation,if,empty,a,signal,that,this,operation,may,be,carried,out;static,optional,string,check,shard,limit,settings,settings,cluster,state,cluster,state,int,shards,to,create,index,meta,data,get,settings,1,index,meta,data,get,settings,return,indices,service,check,shard,limit,shards,to,create,cluster,state
MetaDataCreateIndexService -> public static void validateIndexName(String index, ClusterState state);1524684173;Validate the name for an index against some static rules and a cluster state.;public static void validateIndexName(String index, ClusterState state) {_        validateIndexOrAliasName(index, InvalidIndexNameException::new)__        if (!index.toLowerCase(Locale.ROOT).equals(index)) {_            throw new InvalidIndexNameException(index, "must be lowercase")__        }_        if (state.routingTable().hasIndex(index)) {_            throw new ResourceAlreadyExistsException(state.routingTable().index(index).getIndex())__        }_        if (state.metaData().hasIndex(index)) {_            throw new ResourceAlreadyExistsException(state.metaData().index(index).getIndex())__        }_        if (state.metaData().hasAlias(index)) {_            throw new InvalidIndexNameException(index, "already exists as alias")__        }_    };validate,the,name,for,an,index,against,some,static,rules,and,a,cluster,state;public,static,void,validate,index,name,string,index,cluster,state,state,validate,index,or,alias,name,index,invalid,index,name,exception,new,if,index,to,lower,case,locale,root,equals,index,throw,new,invalid,index,name,exception,index,must,be,lowercase,if,state,routing,table,has,index,index,throw,new,resource,already,exists,exception,state,routing,table,index,index,get,index,if,state,meta,data,has,index,index,throw,new,resource,already,exists,exception,state,meta,data,index,index,get,index,if,state,meta,data,has,alias,index,throw,new,invalid,index,name,exception,index,already,exists,as,alias
MetaDataCreateIndexService -> public static void validateIndexName(String index, ClusterState state);1525162917;Validate the name for an index against some static rules and a cluster state.;public static void validateIndexName(String index, ClusterState state) {_        validateIndexOrAliasName(index, InvalidIndexNameException::new)__        if (!index.toLowerCase(Locale.ROOT).equals(index)) {_            throw new InvalidIndexNameException(index, "must be lowercase")__        }_        if (state.routingTable().hasIndex(index)) {_            throw new ResourceAlreadyExistsException(state.routingTable().index(index).getIndex())__        }_        if (state.metaData().hasIndex(index)) {_            throw new ResourceAlreadyExistsException(state.metaData().index(index).getIndex())__        }_        if (state.metaData().hasAlias(index)) {_            throw new InvalidIndexNameException(index, "already exists as alias")__        }_    };validate,the,name,for,an,index,against,some,static,rules,and,a,cluster,state;public,static,void,validate,index,name,string,index,cluster,state,state,validate,index,or,alias,name,index,invalid,index,name,exception,new,if,index,to,lower,case,locale,root,equals,index,throw,new,invalid,index,name,exception,index,must,be,lowercase,if,state,routing,table,has,index,index,throw,new,resource,already,exists,exception,state,routing,table,index,index,get,index,if,state,meta,data,has,index,index,throw,new,resource,already,exists,exception,state,meta,data,index,index,get,index,if,state,meta,data,has,alias,index,throw,new,invalid,index,name,exception,index,already,exists,as,alias
MetaDataCreateIndexService -> public static void validateIndexName(String index, ClusterState state);1525248068;Validate the name for an index against some static rules and a cluster state.;public static void validateIndexName(String index, ClusterState state) {_        validateIndexOrAliasName(index, InvalidIndexNameException::new)__        if (!index.toLowerCase(Locale.ROOT).equals(index)) {_            throw new InvalidIndexNameException(index, "must be lowercase")__        }_        if (state.routingTable().hasIndex(index)) {_            throw new ResourceAlreadyExistsException(state.routingTable().index(index).getIndex())__        }_        if (state.metaData().hasIndex(index)) {_            throw new ResourceAlreadyExistsException(state.metaData().index(index).getIndex())__        }_        if (state.metaData().hasAlias(index)) {_            throw new InvalidIndexNameException(index, "already exists as alias")__        }_    };validate,the,name,for,an,index,against,some,static,rules,and,a,cluster,state;public,static,void,validate,index,name,string,index,cluster,state,state,validate,index,or,alias,name,index,invalid,index,name,exception,new,if,index,to,lower,case,locale,root,equals,index,throw,new,invalid,index,name,exception,index,must,be,lowercase,if,state,routing,table,has,index,index,throw,new,resource,already,exists,exception,state,routing,table,index,index,get,index,if,state,meta,data,has,index,index,throw,new,resource,already,exists,exception,state,meta,data,index,index,get,index,if,state,meta,data,has,alias,index,throw,new,invalid,index,name,exception,index,already,exists,as,alias
MetaDataCreateIndexService -> public static void validateIndexName(String index, ClusterState state);1526374795;Validate the name for an index against some static rules and a cluster state.;public static void validateIndexName(String index, ClusterState state) {_        validateIndexOrAliasName(index, InvalidIndexNameException::new)__        if (!index.toLowerCase(Locale.ROOT).equals(index)) {_            throw new InvalidIndexNameException(index, "must be lowercase")__        }_        if (state.routingTable().hasIndex(index)) {_            throw new ResourceAlreadyExistsException(state.routingTable().index(index).getIndex())__        }_        if (state.metaData().hasIndex(index)) {_            throw new ResourceAlreadyExistsException(state.metaData().index(index).getIndex())__        }_        if (state.metaData().hasAlias(index)) {_            throw new InvalidIndexNameException(index, "already exists as alias")__        }_    };validate,the,name,for,an,index,against,some,static,rules,and,a,cluster,state;public,static,void,validate,index,name,string,index,cluster,state,state,validate,index,or,alias,name,index,invalid,index,name,exception,new,if,index,to,lower,case,locale,root,equals,index,throw,new,invalid,index,name,exception,index,must,be,lowercase,if,state,routing,table,has,index,index,throw,new,resource,already,exists,exception,state,routing,table,index,index,get,index,if,state,meta,data,has,index,index,throw,new,resource,already,exists,exception,state,meta,data,index,index,get,index,if,state,meta,data,has,alias,index,throw,new,invalid,index,name,exception,index,already,exists,as,alias
MetaDataCreateIndexService -> public static void validateIndexName(String index, ClusterState state);1529082965;Validate the name for an index against some static rules and a cluster state.;public static void validateIndexName(String index, ClusterState state) {_        validateIndexOrAliasName(index, InvalidIndexNameException::new)__        if (!index.toLowerCase(Locale.ROOT).equals(index)) {_            throw new InvalidIndexNameException(index, "must be lowercase")__        }_        if (state.routingTable().hasIndex(index)) {_            throw new ResourceAlreadyExistsException(state.routingTable().index(index).getIndex())__        }_        if (state.metaData().hasIndex(index)) {_            throw new ResourceAlreadyExistsException(state.metaData().index(index).getIndex())__        }_        if (state.metaData().hasAlias(index)) {_            throw new InvalidIndexNameException(index, "already exists as alias")__        }_    };validate,the,name,for,an,index,against,some,static,rules,and,a,cluster,state;public,static,void,validate,index,name,string,index,cluster,state,state,validate,index,or,alias,name,index,invalid,index,name,exception,new,if,index,to,lower,case,locale,root,equals,index,throw,new,invalid,index,name,exception,index,must,be,lowercase,if,state,routing,table,has,index,index,throw,new,resource,already,exists,exception,state,routing,table,index,index,get,index,if,state,meta,data,has,index,index,throw,new,resource,already,exists,exception,state,meta,data,index,index,get,index,if,state,meta,data,has,alias,index,throw,new,invalid,index,name,exception,index,already,exists,as,alias
MetaDataCreateIndexService -> public static void validateIndexName(String index, ClusterState state);1531382259;Validate the name for an index against some static rules and a cluster state.;public static void validateIndexName(String index, ClusterState state) {_        validateIndexOrAliasName(index, InvalidIndexNameException::new)__        if (!index.toLowerCase(Locale.ROOT).equals(index)) {_            throw new InvalidIndexNameException(index, "must be lowercase")__        }_        if (state.routingTable().hasIndex(index)) {_            throw new ResourceAlreadyExistsException(state.routingTable().index(index).getIndex())__        }_        if (state.metaData().hasIndex(index)) {_            throw new ResourceAlreadyExistsException(state.metaData().index(index).getIndex())__        }_        if (state.metaData().hasAlias(index)) {_            throw new InvalidIndexNameException(index, "already exists as alias")__        }_    };validate,the,name,for,an,index,against,some,static,rules,and,a,cluster,state;public,static,void,validate,index,name,string,index,cluster,state,state,validate,index,or,alias,name,index,invalid,index,name,exception,new,if,index,to,lower,case,locale,root,equals,index,throw,new,invalid,index,name,exception,index,must,be,lowercase,if,state,routing,table,has,index,index,throw,new,resource,already,exists,exception,state,routing,table,index,index,get,index,if,state,meta,data,has,index,index,throw,new,resource,already,exists,exception,state,meta,data,index,index,get,index,if,state,meta,data,has,alias,index,throw,new,invalid,index,name,exception,index,already,exists,as,alias
MetaDataCreateIndexService -> public static void validateIndexName(String index, ClusterState state);1535666657;Validate the name for an index against some static rules and a cluster state.;public static void validateIndexName(String index, ClusterState state) {_        validateIndexOrAliasName(index, InvalidIndexNameException::new)__        if (!index.toLowerCase(Locale.ROOT).equals(index)) {_            throw new InvalidIndexNameException(index, "must be lowercase")__        }_        if (state.routingTable().hasIndex(index)) {_            throw new ResourceAlreadyExistsException(state.routingTable().index(index).getIndex())__        }_        if (state.metaData().hasIndex(index)) {_            throw new ResourceAlreadyExistsException(state.metaData().index(index).getIndex())__        }_        if (state.metaData().hasAlias(index)) {_            throw new InvalidIndexNameException(index, "already exists as alias")__        }_    };validate,the,name,for,an,index,against,some,static,rules,and,a,cluster,state;public,static,void,validate,index,name,string,index,cluster,state,state,validate,index,or,alias,name,index,invalid,index,name,exception,new,if,index,to,lower,case,locale,root,equals,index,throw,new,invalid,index,name,exception,index,must,be,lowercase,if,state,routing,table,has,index,index,throw,new,resource,already,exists,exception,state,routing,table,index,index,get,index,if,state,meta,data,has,index,index,throw,new,resource,already,exists,exception,state,meta,data,index,index,get,index,if,state,meta,data,has,alias,index,throw,new,invalid,index,name,exception,index,already,exists,as,alias
MetaDataCreateIndexService -> public static void validateIndexName(String index, ClusterState state);1536137328;Validate the name for an index against some static rules and a cluster state.;public static void validateIndexName(String index, ClusterState state) {_        validateIndexOrAliasName(index, InvalidIndexNameException::new)__        if (!index.toLowerCase(Locale.ROOT).equals(index)) {_            throw new InvalidIndexNameException(index, "must be lowercase")__        }_        if (state.routingTable().hasIndex(index)) {_            throw new ResourceAlreadyExistsException(state.routingTable().index(index).getIndex())__        }_        if (state.metaData().hasIndex(index)) {_            throw new ResourceAlreadyExistsException(state.metaData().index(index).getIndex())__        }_        if (state.metaData().hasAlias(index)) {_            throw new InvalidIndexNameException(index, "already exists as alias")__        }_    };validate,the,name,for,an,index,against,some,static,rules,and,a,cluster,state;public,static,void,validate,index,name,string,index,cluster,state,state,validate,index,or,alias,name,index,invalid,index,name,exception,new,if,index,to,lower,case,locale,root,equals,index,throw,new,invalid,index,name,exception,index,must,be,lowercase,if,state,routing,table,has,index,index,throw,new,resource,already,exists,exception,state,routing,table,index,index,get,index,if,state,meta,data,has,index,index,throw,new,resource,already,exists,exception,state,meta,data,index,index,get,index,if,state,meta,data,has,alias,index,throw,new,invalid,index,name,exception,index,already,exists,as,alias
MetaDataCreateIndexService -> public static void validateIndexName(String index, ClusterState state);1536828374;Validate the name for an index against some static rules and a cluster state.;public static void validateIndexName(String index, ClusterState state) {_        validateIndexOrAliasName(index, InvalidIndexNameException::new)__        if (!index.toLowerCase(Locale.ROOT).equals(index)) {_            throw new InvalidIndexNameException(index, "must be lowercase")__        }_        if (state.routingTable().hasIndex(index)) {_            throw new ResourceAlreadyExistsException(state.routingTable().index(index).getIndex())__        }_        if (state.metaData().hasIndex(index)) {_            throw new ResourceAlreadyExistsException(state.metaData().index(index).getIndex())__        }_        if (state.metaData().hasAlias(index)) {_            throw new InvalidIndexNameException(index, "already exists as alias")__        }_    };validate,the,name,for,an,index,against,some,static,rules,and,a,cluster,state;public,static,void,validate,index,name,string,index,cluster,state,state,validate,index,or,alias,name,index,invalid,index,name,exception,new,if,index,to,lower,case,locale,root,equals,index,throw,new,invalid,index,name,exception,index,must,be,lowercase,if,state,routing,table,has,index,index,throw,new,resource,already,exists,exception,state,routing,table,index,index,get,index,if,state,meta,data,has,index,index,throw,new,resource,already,exists,exception,state,meta,data,index,index,get,index,if,state,meta,data,has,alias,index,throw,new,invalid,index,name,exception,index,already,exists,as,alias
MetaDataCreateIndexService -> public static void validateIndexName(String index, ClusterState state);1540486836;Validate the name for an index against some static rules and a cluster state.;public static void validateIndexName(String index, ClusterState state) {_        validateIndexOrAliasName(index, InvalidIndexNameException::new)__        if (!index.toLowerCase(Locale.ROOT).equals(index)) {_            throw new InvalidIndexNameException(index, "must be lowercase")__        }_        if (state.routingTable().hasIndex(index)) {_            throw new ResourceAlreadyExistsException(state.routingTable().index(index).getIndex())__        }_        if (state.metaData().hasIndex(index)) {_            throw new ResourceAlreadyExistsException(state.metaData().index(index).getIndex())__        }_        if (state.metaData().hasAlias(index)) {_            throw new InvalidIndexNameException(index, "already exists as alias")__        }_    };validate,the,name,for,an,index,against,some,static,rules,and,a,cluster,state;public,static,void,validate,index,name,string,index,cluster,state,state,validate,index,or,alias,name,index,invalid,index,name,exception,new,if,index,to,lower,case,locale,root,equals,index,throw,new,invalid,index,name,exception,index,must,be,lowercase,if,state,routing,table,has,index,index,throw,new,resource,already,exists,exception,state,routing,table,index,index,get,index,if,state,meta,data,has,index,index,throw,new,resource,already,exists,exception,state,meta,data,index,index,get,index,if,state,meta,data,has,alias,index,throw,new,invalid,index,name,exception,index,already,exists,as,alias
MetaDataCreateIndexService -> public static void validateIndexName(String index, ClusterState state);1540847035;Validate the name for an index against some static rules and a cluster state.;public static void validateIndexName(String index, ClusterState state) {_        validateIndexOrAliasName(index, InvalidIndexNameException::new)__        if (!index.toLowerCase(Locale.ROOT).equals(index)) {_            throw new InvalidIndexNameException(index, "must be lowercase")__        }_        if (state.routingTable().hasIndex(index)) {_            throw new ResourceAlreadyExistsException(state.routingTable().index(index).getIndex())__        }_        if (state.metaData().hasIndex(index)) {_            throw new ResourceAlreadyExistsException(state.metaData().index(index).getIndex())__        }_        if (state.metaData().hasAlias(index)) {_            throw new InvalidIndexNameException(index, "already exists as alias")__        }_    };validate,the,name,for,an,index,against,some,static,rules,and,a,cluster,state;public,static,void,validate,index,name,string,index,cluster,state,state,validate,index,or,alias,name,index,invalid,index,name,exception,new,if,index,to,lower,case,locale,root,equals,index,throw,new,invalid,index,name,exception,index,must,be,lowercase,if,state,routing,table,has,index,index,throw,new,resource,already,exists,exception,state,routing,table,index,index,get,index,if,state,meta,data,has,index,index,throw,new,resource,already,exists,exception,state,meta,data,index,index,get,index,if,state,meta,data,has,alias,index,throw,new,invalid,index,name,exception,index,already,exists,as,alias
MetaDataCreateIndexService -> public static void validateIndexName(String index, ClusterState state);1541008027;Validate the name for an index against some static rules and a cluster state.;public static void validateIndexName(String index, ClusterState state) {_        validateIndexOrAliasName(index, InvalidIndexNameException::new)__        if (!index.toLowerCase(Locale.ROOT).equals(index)) {_            throw new InvalidIndexNameException(index, "must be lowercase")__        }_        if (state.routingTable().hasIndex(index)) {_            throw new ResourceAlreadyExistsException(state.routingTable().index(index).getIndex())__        }_        if (state.metaData().hasIndex(index)) {_            throw new ResourceAlreadyExistsException(state.metaData().index(index).getIndex())__        }_        if (state.metaData().hasAlias(index)) {_            throw new InvalidIndexNameException(index, "already exists as alias")__        }_    };validate,the,name,for,an,index,against,some,static,rules,and,a,cluster,state;public,static,void,validate,index,name,string,index,cluster,state,state,validate,index,or,alias,name,index,invalid,index,name,exception,new,if,index,to,lower,case,locale,root,equals,index,throw,new,invalid,index,name,exception,index,must,be,lowercase,if,state,routing,table,has,index,index,throw,new,resource,already,exists,exception,state,routing,table,index,index,get,index,if,state,meta,data,has,index,index,throw,new,resource,already,exists,exception,state,meta,data,index,index,get,index,if,state,meta,data,has,alias,index,throw,new,invalid,index,name,exception,index,already,exists,as,alias
MetaDataCreateIndexService -> public static void validateIndexName(String index, ClusterState state);1541092382;Validate the name for an index against some static rules and a cluster state.;public static void validateIndexName(String index, ClusterState state) {_        validateIndexOrAliasName(index, InvalidIndexNameException::new)__        if (!index.toLowerCase(Locale.ROOT).equals(index)) {_            throw new InvalidIndexNameException(index, "must be lowercase")__        }_        if (state.routingTable().hasIndex(index)) {_            throw new ResourceAlreadyExistsException(state.routingTable().index(index).getIndex())__        }_        if (state.metaData().hasIndex(index)) {_            throw new ResourceAlreadyExistsException(state.metaData().index(index).getIndex())__        }_        if (state.metaData().hasAlias(index)) {_            throw new InvalidIndexNameException(index, "already exists as alias")__        }_    };validate,the,name,for,an,index,against,some,static,rules,and,a,cluster,state;public,static,void,validate,index,name,string,index,cluster,state,state,validate,index,or,alias,name,index,invalid,index,name,exception,new,if,index,to,lower,case,locale,root,equals,index,throw,new,invalid,index,name,exception,index,must,be,lowercase,if,state,routing,table,has,index,index,throw,new,resource,already,exists,exception,state,routing,table,index,index,get,index,if,state,meta,data,has,index,index,throw,new,resource,already,exists,exception,state,meta,data,index,index,get,index,if,state,meta,data,has,alias,index,throw,new,invalid,index,name,exception,index,already,exists,as,alias
MetaDataCreateIndexService -> public static void validateIndexName(String index, ClusterState state);1541592065;Validate the name for an index against some static rules and a cluster state.;public static void validateIndexName(String index, ClusterState state) {_        validateIndexOrAliasName(index, InvalidIndexNameException::new)__        if (!index.toLowerCase(Locale.ROOT).equals(index)) {_            throw new InvalidIndexNameException(index, "must be lowercase")__        }_        if (state.routingTable().hasIndex(index)) {_            throw new ResourceAlreadyExistsException(state.routingTable().index(index).getIndex())__        }_        if (state.metaData().hasIndex(index)) {_            throw new ResourceAlreadyExistsException(state.metaData().index(index).getIndex())__        }_        if (state.metaData().hasAlias(index)) {_            throw new InvalidIndexNameException(index, "already exists as alias")__        }_    };validate,the,name,for,an,index,against,some,static,rules,and,a,cluster,state;public,static,void,validate,index,name,string,index,cluster,state,state,validate,index,or,alias,name,index,invalid,index,name,exception,new,if,index,to,lower,case,locale,root,equals,index,throw,new,invalid,index,name,exception,index,must,be,lowercase,if,state,routing,table,has,index,index,throw,new,resource,already,exists,exception,state,routing,table,index,index,get,index,if,state,meta,data,has,index,index,throw,new,resource,already,exists,exception,state,meta,data,index,index,get,index,if,state,meta,data,has,alias,index,throw,new,invalid,index,name,exception,index,already,exists,as,alias
MetaDataCreateIndexService -> public static void validateIndexName(String index, ClusterState state);1542402632;Validate the name for an index against some static rules and a cluster state.;public static void validateIndexName(String index, ClusterState state) {_        validateIndexOrAliasName(index, InvalidIndexNameException::new)__        if (!index.toLowerCase(Locale.ROOT).equals(index)) {_            throw new InvalidIndexNameException(index, "must be lowercase")__        }_        if (state.routingTable().hasIndex(index)) {_            throw new ResourceAlreadyExistsException(state.routingTable().index(index).getIndex())__        }_        if (state.metaData().hasIndex(index)) {_            throw new ResourceAlreadyExistsException(state.metaData().index(index).getIndex())__        }_        if (state.metaData().hasAlias(index)) {_            throw new InvalidIndexNameException(index, "already exists as alias")__        }_    };validate,the,name,for,an,index,against,some,static,rules,and,a,cluster,state;public,static,void,validate,index,name,string,index,cluster,state,state,validate,index,or,alias,name,index,invalid,index,name,exception,new,if,index,to,lower,case,locale,root,equals,index,throw,new,invalid,index,name,exception,index,must,be,lowercase,if,state,routing,table,has,index,index,throw,new,resource,already,exists,exception,state,routing,table,index,index,get,index,if,state,meta,data,has,index,index,throw,new,resource,already,exists,exception,state,meta,data,index,index,get,index,if,state,meta,data,has,alias,index,throw,new,invalid,index,name,exception,index,already,exists,as,alias
MetaDataCreateIndexService -> public static void validateIndexName(String index, ClusterState state);1543277112;Validate the name for an index against some static rules and a cluster state.;public static void validateIndexName(String index, ClusterState state) {_        validateIndexOrAliasName(index, InvalidIndexNameException::new)__        if (!index.toLowerCase(Locale.ROOT).equals(index)) {_            throw new InvalidIndexNameException(index, "must be lowercase")__        }_        if (state.routingTable().hasIndex(index)) {_            throw new ResourceAlreadyExistsException(state.routingTable().index(index).getIndex())__        }_        if (state.metaData().hasIndex(index)) {_            throw new ResourceAlreadyExistsException(state.metaData().index(index).getIndex())__        }_        if (state.metaData().hasAlias(index)) {_            throw new InvalidIndexNameException(index, "already exists as alias")__        }_    };validate,the,name,for,an,index,against,some,static,rules,and,a,cluster,state;public,static,void,validate,index,name,string,index,cluster,state,state,validate,index,or,alias,name,index,invalid,index,name,exception,new,if,index,to,lower,case,locale,root,equals,index,throw,new,invalid,index,name,exception,index,must,be,lowercase,if,state,routing,table,has,index,index,throw,new,resource,already,exists,exception,state,routing,table,index,index,get,index,if,state,meta,data,has,index,index,throw,new,resource,already,exists,exception,state,meta,data,index,index,get,index,if,state,meta,data,has,alias,index,throw,new,invalid,index,name,exception,index,already,exists,as,alias
MetaDataCreateIndexService -> public static void validateIndexName(String index, ClusterState state);1544702062;Validate the name for an index against some static rules and a cluster state.;public static void validateIndexName(String index, ClusterState state) {_        validateIndexOrAliasName(index, InvalidIndexNameException::new)__        if (!index.toLowerCase(Locale.ROOT).equals(index)) {_            throw new InvalidIndexNameException(index, "must be lowercase")__        }_        if (state.routingTable().hasIndex(index)) {_            throw new ResourceAlreadyExistsException(state.routingTable().index(index).getIndex())__        }_        if (state.metaData().hasIndex(index)) {_            throw new ResourceAlreadyExistsException(state.metaData().index(index).getIndex())__        }_        if (state.metaData().hasAlias(index)) {_            throw new InvalidIndexNameException(index, "already exists as alias")__        }_    };validate,the,name,for,an,index,against,some,static,rules,and,a,cluster,state;public,static,void,validate,index,name,string,index,cluster,state,state,validate,index,or,alias,name,index,invalid,index,name,exception,new,if,index,to,lower,case,locale,root,equals,index,throw,new,invalid,index,name,exception,index,must,be,lowercase,if,state,routing,table,has,index,index,throw,new,resource,already,exists,exception,state,routing,table,index,index,get,index,if,state,meta,data,has,index,index,throw,new,resource,already,exists,exception,state,meta,data,index,index,get,index,if,state,meta,data,has,alias,index,throw,new,invalid,index,name,exception,index,already,exists,as,alias
MetaDataCreateIndexService -> public static void validateIndexName(String index, ClusterState state);1548840504;Validate the name for an index against some static rules and a cluster state.;public static void validateIndexName(String index, ClusterState state) {_        validateIndexOrAliasName(index, InvalidIndexNameException::new)__        if (!index.toLowerCase(Locale.ROOT).equals(index)) {_            throw new InvalidIndexNameException(index, "must be lowercase")__        }_        if (state.routingTable().hasIndex(index)) {_            throw new ResourceAlreadyExistsException(state.routingTable().index(index).getIndex())__        }_        if (state.metaData().hasIndex(index)) {_            throw new ResourceAlreadyExistsException(state.metaData().index(index).getIndex())__        }_        if (state.metaData().hasAlias(index)) {_            throw new InvalidIndexNameException(index, "already exists as alias")__        }_    };validate,the,name,for,an,index,against,some,static,rules,and,a,cluster,state;public,static,void,validate,index,name,string,index,cluster,state,state,validate,index,or,alias,name,index,invalid,index,name,exception,new,if,index,to,lower,case,locale,root,equals,index,throw,new,invalid,index,name,exception,index,must,be,lowercase,if,state,routing,table,has,index,index,throw,new,resource,already,exists,exception,state,routing,table,index,index,get,index,if,state,meta,data,has,index,index,throw,new,resource,already,exists,exception,state,meta,data,index,index,get,index,if,state,meta,data,has,alias,index,throw,new,invalid,index,name,exception,index,already,exists,as,alias
MetaDataCreateIndexService -> public static void validateIndexName(String index, ClusterState state);1549608646;Validate the name for an index against some static rules and a cluster state.;public static void validateIndexName(String index, ClusterState state) {_        validateIndexOrAliasName(index, InvalidIndexNameException::new)__        if (!index.toLowerCase(Locale.ROOT).equals(index)) {_            throw new InvalidIndexNameException(index, "must be lowercase")__        }_        if (state.routingTable().hasIndex(index)) {_            throw new ResourceAlreadyExistsException(state.routingTable().index(index).getIndex())__        }_        if (state.metaData().hasIndex(index)) {_            throw new ResourceAlreadyExistsException(state.metaData().index(index).getIndex())__        }_        if (state.metaData().hasAlias(index)) {_            throw new InvalidIndexNameException(index, "already exists as alias")__        }_    };validate,the,name,for,an,index,against,some,static,rules,and,a,cluster,state;public,static,void,validate,index,name,string,index,cluster,state,state,validate,index,or,alias,name,index,invalid,index,name,exception,new,if,index,to,lower,case,locale,root,equals,index,throw,new,invalid,index,name,exception,index,must,be,lowercase,if,state,routing,table,has,index,index,throw,new,resource,already,exists,exception,state,routing,table,index,index,get,index,if,state,meta,data,has,index,index,throw,new,resource,already,exists,exception,state,meta,data,index,index,get,index,if,state,meta,data,has,alias,index,throw,new,invalid,index,name,exception,index,already,exists,as,alias
MetaDataCreateIndexService -> static Optional<String> checkShardLimit(Settings settings, ClusterState clusterState, DeprecationLogger deprecationLogger);1540486836;Checks whether an index can be created without going over the cluster shard limit.__@param settings The settings of the index to be created._@param clusterState The current cluster state._@param deprecationLogger The logger to use to emit a deprecation warning, if appropriate._@return If present, an error message to be used to reject index creation. If empty, a signal that this operation may be carried out.;static Optional<String> checkShardLimit(Settings settings, ClusterState clusterState, DeprecationLogger deprecationLogger) {_        int shardsToCreate = IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.get(settings)_            * (1 + IndexMetaData.INDEX_NUMBER_OF_REPLICAS_SETTING.get(settings))___        return IndicesService.checkShardLimit(shardsToCreate, clusterState, deprecationLogger)__    };checks,whether,an,index,can,be,created,without,going,over,the,cluster,shard,limit,param,settings,the,settings,of,the,index,to,be,created,param,cluster,state,the,current,cluster,state,param,deprecation,logger,the,logger,to,use,to,emit,a,deprecation,warning,if,appropriate,return,if,present,an,error,message,to,be,used,to,reject,index,creation,if,empty,a,signal,that,this,operation,may,be,carried,out;static,optional,string,check,shard,limit,settings,settings,cluster,state,cluster,state,deprecation,logger,deprecation,logger,int,shards,to,create,index,meta,data,get,settings,1,index,meta,data,get,settings,return,indices,service,check,shard,limit,shards,to,create,cluster,state,deprecation,logger
MetaDataCreateIndexService -> static Optional<String> checkShardLimit(Settings settings, ClusterState clusterState, DeprecationLogger deprecationLogger);1540847035;Checks whether an index can be created without going over the cluster shard limit.__@param settings The settings of the index to be created._@param clusterState The current cluster state._@param deprecationLogger The logger to use to emit a deprecation warning, if appropriate._@return If present, an error message to be used to reject index creation. If empty, a signal that this operation may be carried out.;static Optional<String> checkShardLimit(Settings settings, ClusterState clusterState, DeprecationLogger deprecationLogger) {_        int shardsToCreate = IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.get(settings)_            * (1 + IndexMetaData.INDEX_NUMBER_OF_REPLICAS_SETTING.get(settings))___        return IndicesService.checkShardLimit(shardsToCreate, clusterState, deprecationLogger)__    };checks,whether,an,index,can,be,created,without,going,over,the,cluster,shard,limit,param,settings,the,settings,of,the,index,to,be,created,param,cluster,state,the,current,cluster,state,param,deprecation,logger,the,logger,to,use,to,emit,a,deprecation,warning,if,appropriate,return,if,present,an,error,message,to,be,used,to,reject,index,creation,if,empty,a,signal,that,this,operation,may,be,carried,out;static,optional,string,check,shard,limit,settings,settings,cluster,state,cluster,state,deprecation,logger,deprecation,logger,int,shards,to,create,index,meta,data,get,settings,1,index,meta,data,get,settings,return,indices,service,check,shard,limit,shards,to,create,cluster,state,deprecation,logger
MetaDataCreateIndexService -> static Optional<String> checkShardLimit(Settings settings, ClusterState clusterState, DeprecationLogger deprecationLogger);1541008027;Checks whether an index can be created without going over the cluster shard limit.__@param settings The settings of the index to be created._@param clusterState The current cluster state._@param deprecationLogger The logger to use to emit a deprecation warning, if appropriate._@return If present, an error message to be used to reject index creation. If empty, a signal that this operation may be carried out.;static Optional<String> checkShardLimit(Settings settings, ClusterState clusterState, DeprecationLogger deprecationLogger) {_        int shardsToCreate = IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.get(settings)_            * (1 + IndexMetaData.INDEX_NUMBER_OF_REPLICAS_SETTING.get(settings))___        return IndicesService.checkShardLimit(shardsToCreate, clusterState, deprecationLogger)__    };checks,whether,an,index,can,be,created,without,going,over,the,cluster,shard,limit,param,settings,the,settings,of,the,index,to,be,created,param,cluster,state,the,current,cluster,state,param,deprecation,logger,the,logger,to,use,to,emit,a,deprecation,warning,if,appropriate,return,if,present,an,error,message,to,be,used,to,reject,index,creation,if,empty,a,signal,that,this,operation,may,be,carried,out;static,optional,string,check,shard,limit,settings,settings,cluster,state,cluster,state,deprecation,logger,deprecation,logger,int,shards,to,create,index,meta,data,get,settings,1,index,meta,data,get,settings,return,indices,service,check,shard,limit,shards,to,create,cluster,state,deprecation,logger
MetaDataCreateIndexService -> static Optional<String> checkShardLimit(Settings settings, ClusterState clusterState, DeprecationLogger deprecationLogger);1541092382;Checks whether an index can be created without going over the cluster shard limit.__@param settings The settings of the index to be created._@param clusterState The current cluster state._@param deprecationLogger The logger to use to emit a deprecation warning, if appropriate._@return If present, an error message to be used to reject index creation. If empty, a signal that this operation may be carried out.;static Optional<String> checkShardLimit(Settings settings, ClusterState clusterState, DeprecationLogger deprecationLogger) {_        int shardsToCreate = IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.get(settings)_            * (1 + IndexMetaData.INDEX_NUMBER_OF_REPLICAS_SETTING.get(settings))___        return IndicesService.checkShardLimit(shardsToCreate, clusterState, deprecationLogger)__    };checks,whether,an,index,can,be,created,without,going,over,the,cluster,shard,limit,param,settings,the,settings,of,the,index,to,be,created,param,cluster,state,the,current,cluster,state,param,deprecation,logger,the,logger,to,use,to,emit,a,deprecation,warning,if,appropriate,return,if,present,an,error,message,to,be,used,to,reject,index,creation,if,empty,a,signal,that,this,operation,may,be,carried,out;static,optional,string,check,shard,limit,settings,settings,cluster,state,cluster,state,deprecation,logger,deprecation,logger,int,shards,to,create,index,meta,data,get,settings,1,index,meta,data,get,settings,return,indices,service,check,shard,limit,shards,to,create,cluster,state,deprecation,logger
MetaDataCreateIndexService -> static Optional<String> checkShardLimit(Settings settings, ClusterState clusterState, DeprecationLogger deprecationLogger);1541592065;Checks whether an index can be created without going over the cluster shard limit.__@param settings The settings of the index to be created._@param clusterState The current cluster state._@param deprecationLogger The logger to use to emit a deprecation warning, if appropriate._@return If present, an error message to be used to reject index creation. If empty, a signal that this operation may be carried out.;static Optional<String> checkShardLimit(Settings settings, ClusterState clusterState, DeprecationLogger deprecationLogger) {_        int shardsToCreate = IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.get(settings)_            * (1 + IndexMetaData.INDEX_NUMBER_OF_REPLICAS_SETTING.get(settings))___        return IndicesService.checkShardLimit(shardsToCreate, clusterState, deprecationLogger)__    };checks,whether,an,index,can,be,created,without,going,over,the,cluster,shard,limit,param,settings,the,settings,of,the,index,to,be,created,param,cluster,state,the,current,cluster,state,param,deprecation,logger,the,logger,to,use,to,emit,a,deprecation,warning,if,appropriate,return,if,present,an,error,message,to,be,used,to,reject,index,creation,if,empty,a,signal,that,this,operation,may,be,carried,out;static,optional,string,check,shard,limit,settings,settings,cluster,state,cluster,state,deprecation,logger,deprecation,logger,int,shards,to,create,index,meta,data,get,settings,1,index,meta,data,get,settings,return,indices,service,check,shard,limit,shards,to,create,cluster,state,deprecation,logger
MetaDataCreateIndexService -> static Optional<String> checkShardLimit(Settings settings, ClusterState clusterState, DeprecationLogger deprecationLogger);1542402632;Checks whether an index can be created without going over the cluster shard limit.__@param settings The settings of the index to be created._@param clusterState The current cluster state._@param deprecationLogger The logger to use to emit a deprecation warning, if appropriate._@return If present, an error message to be used to reject index creation. If empty, a signal that this operation may be carried out.;static Optional<String> checkShardLimit(Settings settings, ClusterState clusterState, DeprecationLogger deprecationLogger) {_        int shardsToCreate = IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.get(settings)_            * (1 + IndexMetaData.INDEX_NUMBER_OF_REPLICAS_SETTING.get(settings))___        return IndicesService.checkShardLimit(shardsToCreate, clusterState, deprecationLogger)__    };checks,whether,an,index,can,be,created,without,going,over,the,cluster,shard,limit,param,settings,the,settings,of,the,index,to,be,created,param,cluster,state,the,current,cluster,state,param,deprecation,logger,the,logger,to,use,to,emit,a,deprecation,warning,if,appropriate,return,if,present,an,error,message,to,be,used,to,reject,index,creation,if,empty,a,signal,that,this,operation,may,be,carried,out;static,optional,string,check,shard,limit,settings,settings,cluster,state,cluster,state,deprecation,logger,deprecation,logger,int,shards,to,create,index,meta,data,get,settings,1,index,meta,data,get,settings,return,indices,service,check,shard,limit,shards,to,create,cluster,state,deprecation,logger
MetaDataCreateIndexService -> public void createIndex(final CreateIndexClusterStateUpdateRequest request,                             final ActionListener<CreateIndexClusterStateUpdateResponse> listener);1524684173;Creates an index in the cluster state and waits for the specified number of shard copies to_become active (as specified in {@link CreateIndexClusterStateUpdateRequest#waitForActiveShards()})_before sending the response on the listener. If the index creation was successfully applied on_the cluster state, then {@link CreateIndexClusterStateUpdateResponse#isAcknowledged()} will return_true, otherwise it will return false and no waiting will occur for started shards_({@link CreateIndexClusterStateUpdateResponse#isShardsAcknowledged()} will also be false).  If the index_creation in the cluster state was successful and the requisite shard copies were started before_the timeout, then {@link CreateIndexClusterStateUpdateResponse#isShardsAcknowledged()} will_return true, otherwise if the operation timed out, then it will return false.__@param request the index creation cluster state update request_@param listener the listener on which to send the index creation cluster state update response;public void createIndex(final CreateIndexClusterStateUpdateRequest request,_                            final ActionListener<CreateIndexClusterStateUpdateResponse> listener) {_        onlyCreateIndex(request, ActionListener.wrap(response -> {_            if (response.isAcknowledged()) {_                activeShardsObserver.waitForActiveShards(new String[]{request.index()}, request.waitForActiveShards(), request.ackTimeout(),_                    shardsAcknowledged -> {_                        if (shardsAcknowledged == false) {_                            logger.debug("[{}] index created, but the operation timed out while waiting for " +_                                             "enough shards to be started.", request.index())__                        }_                        listener.onResponse(new CreateIndexClusterStateUpdateResponse(response.isAcknowledged(), shardsAcknowledged))__                    }, listener::onFailure)__            } else {_                listener.onResponse(new CreateIndexClusterStateUpdateResponse(false, false))__            }_        }, listener::onFailure))__    };creates,an,index,in,the,cluster,state,and,waits,for,the,specified,number,of,shard,copies,to,become,active,as,specified,in,link,create,index,cluster,state,update,request,wait,for,active,shards,before,sending,the,response,on,the,listener,if,the,index,creation,was,successfully,applied,on,the,cluster,state,then,link,create,index,cluster,state,update,response,is,acknowledged,will,return,true,otherwise,it,will,return,false,and,no,waiting,will,occur,for,started,shards,link,create,index,cluster,state,update,response,is,shards,acknowledged,will,also,be,false,if,the,index,creation,in,the,cluster,state,was,successful,and,the,requisite,shard,copies,were,started,before,the,timeout,then,link,create,index,cluster,state,update,response,is,shards,acknowledged,will,return,true,otherwise,if,the,operation,timed,out,then,it,will,return,false,param,request,the,index,creation,cluster,state,update,request,param,listener,the,listener,on,which,to,send,the,index,creation,cluster,state,update,response;public,void,create,index,final,create,index,cluster,state,update,request,request,final,action,listener,create,index,cluster,state,update,response,listener,only,create,index,request,action,listener,wrap,response,if,response,is,acknowledged,active,shards,observer,wait,for,active,shards,new,string,request,index,request,wait,for,active,shards,request,ack,timeout,shards,acknowledged,if,shards,acknowledged,false,logger,debug,index,created,but,the,operation,timed,out,while,waiting,for,enough,shards,to,be,started,request,index,listener,on,response,new,create,index,cluster,state,update,response,response,is,acknowledged,shards,acknowledged,listener,on,failure,else,listener,on,response,new,create,index,cluster,state,update,response,false,false,listener,on,failure
MetaDataCreateIndexService -> public void createIndex(final CreateIndexClusterStateUpdateRequest request,                             final ActionListener<CreateIndexClusterStateUpdateResponse> listener);1525162917;Creates an index in the cluster state and waits for the specified number of shard copies to_become active (as specified in {@link CreateIndexClusterStateUpdateRequest#waitForActiveShards()})_before sending the response on the listener. If the index creation was successfully applied on_the cluster state, then {@link CreateIndexClusterStateUpdateResponse#isAcknowledged()} will return_true, otherwise it will return false and no waiting will occur for started shards_({@link CreateIndexClusterStateUpdateResponse#isShardsAcknowledged()} will also be false).  If the index_creation in the cluster state was successful and the requisite shard copies were started before_the timeout, then {@link CreateIndexClusterStateUpdateResponse#isShardsAcknowledged()} will_return true, otherwise if the operation timed out, then it will return false.__@param request the index creation cluster state update request_@param listener the listener on which to send the index creation cluster state update response;public void createIndex(final CreateIndexClusterStateUpdateRequest request,_                            final ActionListener<CreateIndexClusterStateUpdateResponse> listener) {_        onlyCreateIndex(request, ActionListener.wrap(response -> {_            if (response.isAcknowledged()) {_                activeShardsObserver.waitForActiveShards(new String[]{request.index()}, request.waitForActiveShards(), request.ackTimeout(),_                    shardsAcknowledged -> {_                        if (shardsAcknowledged == false) {_                            logger.debug("[{}] index created, but the operation timed out while waiting for " +_                                             "enough shards to be started.", request.index())__                        }_                        listener.onResponse(new CreateIndexClusterStateUpdateResponse(response.isAcknowledged(), shardsAcknowledged))__                    }, listener::onFailure)__            } else {_                listener.onResponse(new CreateIndexClusterStateUpdateResponse(false, false))__            }_        }, listener::onFailure))__    };creates,an,index,in,the,cluster,state,and,waits,for,the,specified,number,of,shard,copies,to,become,active,as,specified,in,link,create,index,cluster,state,update,request,wait,for,active,shards,before,sending,the,response,on,the,listener,if,the,index,creation,was,successfully,applied,on,the,cluster,state,then,link,create,index,cluster,state,update,response,is,acknowledged,will,return,true,otherwise,it,will,return,false,and,no,waiting,will,occur,for,started,shards,link,create,index,cluster,state,update,response,is,shards,acknowledged,will,also,be,false,if,the,index,creation,in,the,cluster,state,was,successful,and,the,requisite,shard,copies,were,started,before,the,timeout,then,link,create,index,cluster,state,update,response,is,shards,acknowledged,will,return,true,otherwise,if,the,operation,timed,out,then,it,will,return,false,param,request,the,index,creation,cluster,state,update,request,param,listener,the,listener,on,which,to,send,the,index,creation,cluster,state,update,response;public,void,create,index,final,create,index,cluster,state,update,request,request,final,action,listener,create,index,cluster,state,update,response,listener,only,create,index,request,action,listener,wrap,response,if,response,is,acknowledged,active,shards,observer,wait,for,active,shards,new,string,request,index,request,wait,for,active,shards,request,ack,timeout,shards,acknowledged,if,shards,acknowledged,false,logger,debug,index,created,but,the,operation,timed,out,while,waiting,for,enough,shards,to,be,started,request,index,listener,on,response,new,create,index,cluster,state,update,response,response,is,acknowledged,shards,acknowledged,listener,on,failure,else,listener,on,response,new,create,index,cluster,state,update,response,false,false,listener,on,failure
MetaDataCreateIndexService -> public void createIndex(final CreateIndexClusterStateUpdateRequest request,                             final ActionListener<CreateIndexClusterStateUpdateResponse> listener);1525248068;Creates an index in the cluster state and waits for the specified number of shard copies to_become active (as specified in {@link CreateIndexClusterStateUpdateRequest#waitForActiveShards()})_before sending the response on the listener. If the index creation was successfully applied on_the cluster state, then {@link CreateIndexClusterStateUpdateResponse#isAcknowledged()} will return_true, otherwise it will return false and no waiting will occur for started shards_({@link CreateIndexClusterStateUpdateResponse#isShardsAcknowledged()} will also be false).  If the index_creation in the cluster state was successful and the requisite shard copies were started before_the timeout, then {@link CreateIndexClusterStateUpdateResponse#isShardsAcknowledged()} will_return true, otherwise if the operation timed out, then it will return false.__@param request the index creation cluster state update request_@param listener the listener on which to send the index creation cluster state update response;public void createIndex(final CreateIndexClusterStateUpdateRequest request,_                            final ActionListener<CreateIndexClusterStateUpdateResponse> listener) {_        onlyCreateIndex(request, ActionListener.wrap(response -> {_            if (response.isAcknowledged()) {_                activeShardsObserver.waitForActiveShards(new String[]{request.index()}, request.waitForActiveShards(), request.ackTimeout(),_                    shardsAcknowledged -> {_                        if (shardsAcknowledged == false) {_                            logger.debug("[{}] index created, but the operation timed out while waiting for " +_                                             "enough shards to be started.", request.index())__                        }_                        listener.onResponse(new CreateIndexClusterStateUpdateResponse(response.isAcknowledged(), shardsAcknowledged))__                    }, listener::onFailure)__            } else {_                listener.onResponse(new CreateIndexClusterStateUpdateResponse(false, false))__            }_        }, listener::onFailure))__    };creates,an,index,in,the,cluster,state,and,waits,for,the,specified,number,of,shard,copies,to,become,active,as,specified,in,link,create,index,cluster,state,update,request,wait,for,active,shards,before,sending,the,response,on,the,listener,if,the,index,creation,was,successfully,applied,on,the,cluster,state,then,link,create,index,cluster,state,update,response,is,acknowledged,will,return,true,otherwise,it,will,return,false,and,no,waiting,will,occur,for,started,shards,link,create,index,cluster,state,update,response,is,shards,acknowledged,will,also,be,false,if,the,index,creation,in,the,cluster,state,was,successful,and,the,requisite,shard,copies,were,started,before,the,timeout,then,link,create,index,cluster,state,update,response,is,shards,acknowledged,will,return,true,otherwise,if,the,operation,timed,out,then,it,will,return,false,param,request,the,index,creation,cluster,state,update,request,param,listener,the,listener,on,which,to,send,the,index,creation,cluster,state,update,response;public,void,create,index,final,create,index,cluster,state,update,request,request,final,action,listener,create,index,cluster,state,update,response,listener,only,create,index,request,action,listener,wrap,response,if,response,is,acknowledged,active,shards,observer,wait,for,active,shards,new,string,request,index,request,wait,for,active,shards,request,ack,timeout,shards,acknowledged,if,shards,acknowledged,false,logger,debug,index,created,but,the,operation,timed,out,while,waiting,for,enough,shards,to,be,started,request,index,listener,on,response,new,create,index,cluster,state,update,response,response,is,acknowledged,shards,acknowledged,listener,on,failure,else,listener,on,response,new,create,index,cluster,state,update,response,false,false,listener,on,failure
MetaDataCreateIndexService -> public void createIndex(final CreateIndexClusterStateUpdateRequest request,                             final ActionListener<CreateIndexClusterStateUpdateResponse> listener);1526374795;Creates an index in the cluster state and waits for the specified number of shard copies to_become active (as specified in {@link CreateIndexClusterStateUpdateRequest#waitForActiveShards()})_before sending the response on the listener. If the index creation was successfully applied on_the cluster state, then {@link CreateIndexClusterStateUpdateResponse#isAcknowledged()} will return_true, otherwise it will return false and no waiting will occur for started shards_({@link CreateIndexClusterStateUpdateResponse#isShardsAcknowledged()} will also be false).  If the index_creation in the cluster state was successful and the requisite shard copies were started before_the timeout, then {@link CreateIndexClusterStateUpdateResponse#isShardsAcknowledged()} will_return true, otherwise if the operation timed out, then it will return false.__@param request the index creation cluster state update request_@param listener the listener on which to send the index creation cluster state update response;public void createIndex(final CreateIndexClusterStateUpdateRequest request,_                            final ActionListener<CreateIndexClusterStateUpdateResponse> listener) {_        onlyCreateIndex(request, ActionListener.wrap(response -> {_            if (response.isAcknowledged()) {_                activeShardsObserver.waitForActiveShards(new String[]{request.index()}, request.waitForActiveShards(), request.ackTimeout(),_                    shardsAcknowledged -> {_                        if (shardsAcknowledged == false) {_                            logger.debug("[{}] index created, but the operation timed out while waiting for " +_                                             "enough shards to be started.", request.index())__                        }_                        listener.onResponse(new CreateIndexClusterStateUpdateResponse(response.isAcknowledged(), shardsAcknowledged))__                    }, listener::onFailure)__            } else {_                listener.onResponse(new CreateIndexClusterStateUpdateResponse(false, false))__            }_        }, listener::onFailure))__    };creates,an,index,in,the,cluster,state,and,waits,for,the,specified,number,of,shard,copies,to,become,active,as,specified,in,link,create,index,cluster,state,update,request,wait,for,active,shards,before,sending,the,response,on,the,listener,if,the,index,creation,was,successfully,applied,on,the,cluster,state,then,link,create,index,cluster,state,update,response,is,acknowledged,will,return,true,otherwise,it,will,return,false,and,no,waiting,will,occur,for,started,shards,link,create,index,cluster,state,update,response,is,shards,acknowledged,will,also,be,false,if,the,index,creation,in,the,cluster,state,was,successful,and,the,requisite,shard,copies,were,started,before,the,timeout,then,link,create,index,cluster,state,update,response,is,shards,acknowledged,will,return,true,otherwise,if,the,operation,timed,out,then,it,will,return,false,param,request,the,index,creation,cluster,state,update,request,param,listener,the,listener,on,which,to,send,the,index,creation,cluster,state,update,response;public,void,create,index,final,create,index,cluster,state,update,request,request,final,action,listener,create,index,cluster,state,update,response,listener,only,create,index,request,action,listener,wrap,response,if,response,is,acknowledged,active,shards,observer,wait,for,active,shards,new,string,request,index,request,wait,for,active,shards,request,ack,timeout,shards,acknowledged,if,shards,acknowledged,false,logger,debug,index,created,but,the,operation,timed,out,while,waiting,for,enough,shards,to,be,started,request,index,listener,on,response,new,create,index,cluster,state,update,response,response,is,acknowledged,shards,acknowledged,listener,on,failure,else,listener,on,response,new,create,index,cluster,state,update,response,false,false,listener,on,failure
MetaDataCreateIndexService -> public void createIndex(final CreateIndexClusterStateUpdateRequest request,                             final ActionListener<CreateIndexClusterStateUpdateResponse> listener);1529082965;Creates an index in the cluster state and waits for the specified number of shard copies to_become active (as specified in {@link CreateIndexClusterStateUpdateRequest#waitForActiveShards()})_before sending the response on the listener. If the index creation was successfully applied on_the cluster state, then {@link CreateIndexClusterStateUpdateResponse#isAcknowledged()} will return_true, otherwise it will return false and no waiting will occur for started shards_({@link CreateIndexClusterStateUpdateResponse#isShardsAcknowledged()} will also be false).  If the index_creation in the cluster state was successful and the requisite shard copies were started before_the timeout, then {@link CreateIndexClusterStateUpdateResponse#isShardsAcknowledged()} will_return true, otherwise if the operation timed out, then it will return false.__@param request the index creation cluster state update request_@param listener the listener on which to send the index creation cluster state update response;public void createIndex(final CreateIndexClusterStateUpdateRequest request,_                            final ActionListener<CreateIndexClusterStateUpdateResponse> listener) {_        onlyCreateIndex(request, ActionListener.wrap(response -> {_            if (response.isAcknowledged()) {_                activeShardsObserver.waitForActiveShards(new String[]{request.index()}, request.waitForActiveShards(), request.ackTimeout(),_                    shardsAcknowledged -> {_                        if (shardsAcknowledged == false) {_                            logger.debug("[{}] index created, but the operation timed out while waiting for " +_                                             "enough shards to be started.", request.index())__                        }_                        listener.onResponse(new CreateIndexClusterStateUpdateResponse(response.isAcknowledged(), shardsAcknowledged))__                    }, listener::onFailure)__            } else {_                listener.onResponse(new CreateIndexClusterStateUpdateResponse(false, false))__            }_        }, listener::onFailure))__    };creates,an,index,in,the,cluster,state,and,waits,for,the,specified,number,of,shard,copies,to,become,active,as,specified,in,link,create,index,cluster,state,update,request,wait,for,active,shards,before,sending,the,response,on,the,listener,if,the,index,creation,was,successfully,applied,on,the,cluster,state,then,link,create,index,cluster,state,update,response,is,acknowledged,will,return,true,otherwise,it,will,return,false,and,no,waiting,will,occur,for,started,shards,link,create,index,cluster,state,update,response,is,shards,acknowledged,will,also,be,false,if,the,index,creation,in,the,cluster,state,was,successful,and,the,requisite,shard,copies,were,started,before,the,timeout,then,link,create,index,cluster,state,update,response,is,shards,acknowledged,will,return,true,otherwise,if,the,operation,timed,out,then,it,will,return,false,param,request,the,index,creation,cluster,state,update,request,param,listener,the,listener,on,which,to,send,the,index,creation,cluster,state,update,response;public,void,create,index,final,create,index,cluster,state,update,request,request,final,action,listener,create,index,cluster,state,update,response,listener,only,create,index,request,action,listener,wrap,response,if,response,is,acknowledged,active,shards,observer,wait,for,active,shards,new,string,request,index,request,wait,for,active,shards,request,ack,timeout,shards,acknowledged,if,shards,acknowledged,false,logger,debug,index,created,but,the,operation,timed,out,while,waiting,for,enough,shards,to,be,started,request,index,listener,on,response,new,create,index,cluster,state,update,response,response,is,acknowledged,shards,acknowledged,listener,on,failure,else,listener,on,response,new,create,index,cluster,state,update,response,false,false,listener,on,failure
MetaDataCreateIndexService -> public void createIndex(final CreateIndexClusterStateUpdateRequest request,                             final ActionListener<CreateIndexClusterStateUpdateResponse> listener);1531382259;Creates an index in the cluster state and waits for the specified number of shard copies to_become active (as specified in {@link CreateIndexClusterStateUpdateRequest#waitForActiveShards()})_before sending the response on the listener. If the index creation was successfully applied on_the cluster state, then {@link CreateIndexClusterStateUpdateResponse#isAcknowledged()} will return_true, otherwise it will return false and no waiting will occur for started shards_({@link CreateIndexClusterStateUpdateResponse#isShardsAcknowledged()} will also be false).  If the index_creation in the cluster state was successful and the requisite shard copies were started before_the timeout, then {@link CreateIndexClusterStateUpdateResponse#isShardsAcknowledged()} will_return true, otherwise if the operation timed out, then it will return false.__@param request the index creation cluster state update request_@param listener the listener on which to send the index creation cluster state update response;public void createIndex(final CreateIndexClusterStateUpdateRequest request,_                            final ActionListener<CreateIndexClusterStateUpdateResponse> listener) {_        onlyCreateIndex(request, ActionListener.wrap(response -> {_            if (response.isAcknowledged()) {_                activeShardsObserver.waitForActiveShards(new String[]{request.index()}, request.waitForActiveShards(), request.ackTimeout(),_                    shardsAcknowledged -> {_                        if (shardsAcknowledged == false) {_                            logger.debug("[{}] index created, but the operation timed out while waiting for " +_                                             "enough shards to be started.", request.index())__                        }_                        listener.onResponse(new CreateIndexClusterStateUpdateResponse(response.isAcknowledged(), shardsAcknowledged))__                    }, listener::onFailure)__            } else {_                listener.onResponse(new CreateIndexClusterStateUpdateResponse(false, false))__            }_        }, listener::onFailure))__    };creates,an,index,in,the,cluster,state,and,waits,for,the,specified,number,of,shard,copies,to,become,active,as,specified,in,link,create,index,cluster,state,update,request,wait,for,active,shards,before,sending,the,response,on,the,listener,if,the,index,creation,was,successfully,applied,on,the,cluster,state,then,link,create,index,cluster,state,update,response,is,acknowledged,will,return,true,otherwise,it,will,return,false,and,no,waiting,will,occur,for,started,shards,link,create,index,cluster,state,update,response,is,shards,acknowledged,will,also,be,false,if,the,index,creation,in,the,cluster,state,was,successful,and,the,requisite,shard,copies,were,started,before,the,timeout,then,link,create,index,cluster,state,update,response,is,shards,acknowledged,will,return,true,otherwise,if,the,operation,timed,out,then,it,will,return,false,param,request,the,index,creation,cluster,state,update,request,param,listener,the,listener,on,which,to,send,the,index,creation,cluster,state,update,response;public,void,create,index,final,create,index,cluster,state,update,request,request,final,action,listener,create,index,cluster,state,update,response,listener,only,create,index,request,action,listener,wrap,response,if,response,is,acknowledged,active,shards,observer,wait,for,active,shards,new,string,request,index,request,wait,for,active,shards,request,ack,timeout,shards,acknowledged,if,shards,acknowledged,false,logger,debug,index,created,but,the,operation,timed,out,while,waiting,for,enough,shards,to,be,started,request,index,listener,on,response,new,create,index,cluster,state,update,response,response,is,acknowledged,shards,acknowledged,listener,on,failure,else,listener,on,response,new,create,index,cluster,state,update,response,false,false,listener,on,failure
MetaDataCreateIndexService -> public void createIndex(final CreateIndexClusterStateUpdateRequest request,                             final ActionListener<CreateIndexClusterStateUpdateResponse> listener);1535666657;Creates an index in the cluster state and waits for the specified number of shard copies to_become active (as specified in {@link CreateIndexClusterStateUpdateRequest#waitForActiveShards()})_before sending the response on the listener. If the index creation was successfully applied on_the cluster state, then {@link CreateIndexClusterStateUpdateResponse#isAcknowledged()} will return_true, otherwise it will return false and no waiting will occur for started shards_({@link CreateIndexClusterStateUpdateResponse#isShardsAcknowledged()} will also be false).  If the index_creation in the cluster state was successful and the requisite shard copies were started before_the timeout, then {@link CreateIndexClusterStateUpdateResponse#isShardsAcknowledged()} will_return true, otherwise if the operation timed out, then it will return false.__@param request the index creation cluster state update request_@param listener the listener on which to send the index creation cluster state update response;public void createIndex(final CreateIndexClusterStateUpdateRequest request,_                            final ActionListener<CreateIndexClusterStateUpdateResponse> listener) {_        onlyCreateIndex(request, ActionListener.wrap(response -> {_            if (response.isAcknowledged()) {_                activeShardsObserver.waitForActiveShards(new String[]{request.index()}, request.waitForActiveShards(), request.ackTimeout(),_                    shardsAcknowledged -> {_                        if (shardsAcknowledged == false) {_                            logger.debug("[{}] index created, but the operation timed out while waiting for " +_                                             "enough shards to be started.", request.index())__                        }_                        listener.onResponse(new CreateIndexClusterStateUpdateResponse(response.isAcknowledged(), shardsAcknowledged))__                    }, listener::onFailure)__            } else {_                listener.onResponse(new CreateIndexClusterStateUpdateResponse(false, false))__            }_        }, listener::onFailure))__    };creates,an,index,in,the,cluster,state,and,waits,for,the,specified,number,of,shard,copies,to,become,active,as,specified,in,link,create,index,cluster,state,update,request,wait,for,active,shards,before,sending,the,response,on,the,listener,if,the,index,creation,was,successfully,applied,on,the,cluster,state,then,link,create,index,cluster,state,update,response,is,acknowledged,will,return,true,otherwise,it,will,return,false,and,no,waiting,will,occur,for,started,shards,link,create,index,cluster,state,update,response,is,shards,acknowledged,will,also,be,false,if,the,index,creation,in,the,cluster,state,was,successful,and,the,requisite,shard,copies,were,started,before,the,timeout,then,link,create,index,cluster,state,update,response,is,shards,acknowledged,will,return,true,otherwise,if,the,operation,timed,out,then,it,will,return,false,param,request,the,index,creation,cluster,state,update,request,param,listener,the,listener,on,which,to,send,the,index,creation,cluster,state,update,response;public,void,create,index,final,create,index,cluster,state,update,request,request,final,action,listener,create,index,cluster,state,update,response,listener,only,create,index,request,action,listener,wrap,response,if,response,is,acknowledged,active,shards,observer,wait,for,active,shards,new,string,request,index,request,wait,for,active,shards,request,ack,timeout,shards,acknowledged,if,shards,acknowledged,false,logger,debug,index,created,but,the,operation,timed,out,while,waiting,for,enough,shards,to,be,started,request,index,listener,on,response,new,create,index,cluster,state,update,response,response,is,acknowledged,shards,acknowledged,listener,on,failure,else,listener,on,response,new,create,index,cluster,state,update,response,false,false,listener,on,failure
MetaDataCreateIndexService -> public void createIndex(final CreateIndexClusterStateUpdateRequest request,                             final ActionListener<CreateIndexClusterStateUpdateResponse> listener);1536137328;Creates an index in the cluster state and waits for the specified number of shard copies to_become active (as specified in {@link CreateIndexClusterStateUpdateRequest#waitForActiveShards()})_before sending the response on the listener. If the index creation was successfully applied on_the cluster state, then {@link CreateIndexClusterStateUpdateResponse#isAcknowledged()} will return_true, otherwise it will return false and no waiting will occur for started shards_({@link CreateIndexClusterStateUpdateResponse#isShardsAcknowledged()} will also be false).  If the index_creation in the cluster state was successful and the requisite shard copies were started before_the timeout, then {@link CreateIndexClusterStateUpdateResponse#isShardsAcknowledged()} will_return true, otherwise if the operation timed out, then it will return false.__@param request the index creation cluster state update request_@param listener the listener on which to send the index creation cluster state update response;public void createIndex(final CreateIndexClusterStateUpdateRequest request,_                            final ActionListener<CreateIndexClusterStateUpdateResponse> listener) {_        onlyCreateIndex(request, ActionListener.wrap(response -> {_            if (response.isAcknowledged()) {_                activeShardsObserver.waitForActiveShards(new String[]{request.index()}, request.waitForActiveShards(), request.ackTimeout(),_                    shardsAcknowledged -> {_                        if (shardsAcknowledged == false) {_                            logger.debug("[{}] index created, but the operation timed out while waiting for " +_                                             "enough shards to be started.", request.index())__                        }_                        listener.onResponse(new CreateIndexClusterStateUpdateResponse(response.isAcknowledged(), shardsAcknowledged))__                    }, listener::onFailure)__            } else {_                listener.onResponse(new CreateIndexClusterStateUpdateResponse(false, false))__            }_        }, listener::onFailure))__    };creates,an,index,in,the,cluster,state,and,waits,for,the,specified,number,of,shard,copies,to,become,active,as,specified,in,link,create,index,cluster,state,update,request,wait,for,active,shards,before,sending,the,response,on,the,listener,if,the,index,creation,was,successfully,applied,on,the,cluster,state,then,link,create,index,cluster,state,update,response,is,acknowledged,will,return,true,otherwise,it,will,return,false,and,no,waiting,will,occur,for,started,shards,link,create,index,cluster,state,update,response,is,shards,acknowledged,will,also,be,false,if,the,index,creation,in,the,cluster,state,was,successful,and,the,requisite,shard,copies,were,started,before,the,timeout,then,link,create,index,cluster,state,update,response,is,shards,acknowledged,will,return,true,otherwise,if,the,operation,timed,out,then,it,will,return,false,param,request,the,index,creation,cluster,state,update,request,param,listener,the,listener,on,which,to,send,the,index,creation,cluster,state,update,response;public,void,create,index,final,create,index,cluster,state,update,request,request,final,action,listener,create,index,cluster,state,update,response,listener,only,create,index,request,action,listener,wrap,response,if,response,is,acknowledged,active,shards,observer,wait,for,active,shards,new,string,request,index,request,wait,for,active,shards,request,ack,timeout,shards,acknowledged,if,shards,acknowledged,false,logger,debug,index,created,but,the,operation,timed,out,while,waiting,for,enough,shards,to,be,started,request,index,listener,on,response,new,create,index,cluster,state,update,response,response,is,acknowledged,shards,acknowledged,listener,on,failure,else,listener,on,response,new,create,index,cluster,state,update,response,false,false,listener,on,failure
MetaDataCreateIndexService -> public void createIndex(final CreateIndexClusterStateUpdateRequest request,                             final ActionListener<CreateIndexClusterStateUpdateResponse> listener);1536828374;Creates an index in the cluster state and waits for the specified number of shard copies to_become active (as specified in {@link CreateIndexClusterStateUpdateRequest#waitForActiveShards()})_before sending the response on the listener. If the index creation was successfully applied on_the cluster state, then {@link CreateIndexClusterStateUpdateResponse#isAcknowledged()} will return_true, otherwise it will return false and no waiting will occur for started shards_({@link CreateIndexClusterStateUpdateResponse#isShardsAcknowledged()} will also be false).  If the index_creation in the cluster state was successful and the requisite shard copies were started before_the timeout, then {@link CreateIndexClusterStateUpdateResponse#isShardsAcknowledged()} will_return true, otherwise if the operation timed out, then it will return false.__@param request the index creation cluster state update request_@param listener the listener on which to send the index creation cluster state update response;public void createIndex(final CreateIndexClusterStateUpdateRequest request,_                            final ActionListener<CreateIndexClusterStateUpdateResponse> listener) {_        onlyCreateIndex(request, ActionListener.wrap(response -> {_            if (response.isAcknowledged()) {_                activeShardsObserver.waitForActiveShards(new String[]{request.index()}, request.waitForActiveShards(), request.ackTimeout(),_                    shardsAcknowledged -> {_                        if (shardsAcknowledged == false) {_                            logger.debug("[{}] index created, but the operation timed out while waiting for " +_                                             "enough shards to be started.", request.index())__                        }_                        listener.onResponse(new CreateIndexClusterStateUpdateResponse(response.isAcknowledged(), shardsAcknowledged))__                    }, listener::onFailure)__            } else {_                listener.onResponse(new CreateIndexClusterStateUpdateResponse(false, false))__            }_        }, listener::onFailure))__    };creates,an,index,in,the,cluster,state,and,waits,for,the,specified,number,of,shard,copies,to,become,active,as,specified,in,link,create,index,cluster,state,update,request,wait,for,active,shards,before,sending,the,response,on,the,listener,if,the,index,creation,was,successfully,applied,on,the,cluster,state,then,link,create,index,cluster,state,update,response,is,acknowledged,will,return,true,otherwise,it,will,return,false,and,no,waiting,will,occur,for,started,shards,link,create,index,cluster,state,update,response,is,shards,acknowledged,will,also,be,false,if,the,index,creation,in,the,cluster,state,was,successful,and,the,requisite,shard,copies,were,started,before,the,timeout,then,link,create,index,cluster,state,update,response,is,shards,acknowledged,will,return,true,otherwise,if,the,operation,timed,out,then,it,will,return,false,param,request,the,index,creation,cluster,state,update,request,param,listener,the,listener,on,which,to,send,the,index,creation,cluster,state,update,response;public,void,create,index,final,create,index,cluster,state,update,request,request,final,action,listener,create,index,cluster,state,update,response,listener,only,create,index,request,action,listener,wrap,response,if,response,is,acknowledged,active,shards,observer,wait,for,active,shards,new,string,request,index,request,wait,for,active,shards,request,ack,timeout,shards,acknowledged,if,shards,acknowledged,false,logger,debug,index,created,but,the,operation,timed,out,while,waiting,for,enough,shards,to,be,started,request,index,listener,on,response,new,create,index,cluster,state,update,response,response,is,acknowledged,shards,acknowledged,listener,on,failure,else,listener,on,response,new,create,index,cluster,state,update,response,false,false,listener,on,failure
MetaDataCreateIndexService -> public void createIndex(final CreateIndexClusterStateUpdateRequest request,                             final ActionListener<CreateIndexClusterStateUpdateResponse> listener);1540486836;Creates an index in the cluster state and waits for the specified number of shard copies to_become active (as specified in {@link CreateIndexClusterStateUpdateRequest#waitForActiveShards()})_before sending the response on the listener. If the index creation was successfully applied on_the cluster state, then {@link CreateIndexClusterStateUpdateResponse#isAcknowledged()} will return_true, otherwise it will return false and no waiting will occur for started shards_({@link CreateIndexClusterStateUpdateResponse#isShardsAcknowledged()} will also be false).  If the index_creation in the cluster state was successful and the requisite shard copies were started before_the timeout, then {@link CreateIndexClusterStateUpdateResponse#isShardsAcknowledged()} will_return true, otherwise if the operation timed out, then it will return false.__@param request the index creation cluster state update request_@param listener the listener on which to send the index creation cluster state update response;public void createIndex(final CreateIndexClusterStateUpdateRequest request,_                            final ActionListener<CreateIndexClusterStateUpdateResponse> listener) {_        onlyCreateIndex(request, ActionListener.wrap(response -> {_            if (response.isAcknowledged()) {_                activeShardsObserver.waitForActiveShards(new String[]{request.index()}, request.waitForActiveShards(), request.ackTimeout(),_                    shardsAcknowledged -> {_                        if (shardsAcknowledged == false) {_                            logger.debug("[{}] index created, but the operation timed out while waiting for " +_                                             "enough shards to be started.", request.index())__                        }_                        listener.onResponse(new CreateIndexClusterStateUpdateResponse(response.isAcknowledged(), shardsAcknowledged))__                    }, listener::onFailure)__            } else {_                listener.onResponse(new CreateIndexClusterStateUpdateResponse(false, false))__            }_        }, listener::onFailure))__    };creates,an,index,in,the,cluster,state,and,waits,for,the,specified,number,of,shard,copies,to,become,active,as,specified,in,link,create,index,cluster,state,update,request,wait,for,active,shards,before,sending,the,response,on,the,listener,if,the,index,creation,was,successfully,applied,on,the,cluster,state,then,link,create,index,cluster,state,update,response,is,acknowledged,will,return,true,otherwise,it,will,return,false,and,no,waiting,will,occur,for,started,shards,link,create,index,cluster,state,update,response,is,shards,acknowledged,will,also,be,false,if,the,index,creation,in,the,cluster,state,was,successful,and,the,requisite,shard,copies,were,started,before,the,timeout,then,link,create,index,cluster,state,update,response,is,shards,acknowledged,will,return,true,otherwise,if,the,operation,timed,out,then,it,will,return,false,param,request,the,index,creation,cluster,state,update,request,param,listener,the,listener,on,which,to,send,the,index,creation,cluster,state,update,response;public,void,create,index,final,create,index,cluster,state,update,request,request,final,action,listener,create,index,cluster,state,update,response,listener,only,create,index,request,action,listener,wrap,response,if,response,is,acknowledged,active,shards,observer,wait,for,active,shards,new,string,request,index,request,wait,for,active,shards,request,ack,timeout,shards,acknowledged,if,shards,acknowledged,false,logger,debug,index,created,but,the,operation,timed,out,while,waiting,for,enough,shards,to,be,started,request,index,listener,on,response,new,create,index,cluster,state,update,response,response,is,acknowledged,shards,acknowledged,listener,on,failure,else,listener,on,response,new,create,index,cluster,state,update,response,false,false,listener,on,failure
MetaDataCreateIndexService -> public void createIndex(final CreateIndexClusterStateUpdateRequest request,                             final ActionListener<CreateIndexClusterStateUpdateResponse> listener);1540847035;Creates an index in the cluster state and waits for the specified number of shard copies to_become active (as specified in {@link CreateIndexClusterStateUpdateRequest#waitForActiveShards()})_before sending the response on the listener. If the index creation was successfully applied on_the cluster state, then {@link CreateIndexClusterStateUpdateResponse#isAcknowledged()} will return_true, otherwise it will return false and no waiting will occur for started shards_({@link CreateIndexClusterStateUpdateResponse#isShardsAcknowledged()} will also be false).  If the index_creation in the cluster state was successful and the requisite shard copies were started before_the timeout, then {@link CreateIndexClusterStateUpdateResponse#isShardsAcknowledged()} will_return true, otherwise if the operation timed out, then it will return false.__@param request the index creation cluster state update request_@param listener the listener on which to send the index creation cluster state update response;public void createIndex(final CreateIndexClusterStateUpdateRequest request,_                            final ActionListener<CreateIndexClusterStateUpdateResponse> listener) {_        onlyCreateIndex(request, ActionListener.wrap(response -> {_            if (response.isAcknowledged()) {_                activeShardsObserver.waitForActiveShards(new String[]{request.index()}, request.waitForActiveShards(), request.ackTimeout(),_                    shardsAcknowledged -> {_                        if (shardsAcknowledged == false) {_                            logger.debug("[{}] index created, but the operation timed out while waiting for " +_                                             "enough shards to be started.", request.index())__                        }_                        listener.onResponse(new CreateIndexClusterStateUpdateResponse(response.isAcknowledged(), shardsAcknowledged))__                    }, listener::onFailure)__            } else {_                listener.onResponse(new CreateIndexClusterStateUpdateResponse(false, false))__            }_        }, listener::onFailure))__    };creates,an,index,in,the,cluster,state,and,waits,for,the,specified,number,of,shard,copies,to,become,active,as,specified,in,link,create,index,cluster,state,update,request,wait,for,active,shards,before,sending,the,response,on,the,listener,if,the,index,creation,was,successfully,applied,on,the,cluster,state,then,link,create,index,cluster,state,update,response,is,acknowledged,will,return,true,otherwise,it,will,return,false,and,no,waiting,will,occur,for,started,shards,link,create,index,cluster,state,update,response,is,shards,acknowledged,will,also,be,false,if,the,index,creation,in,the,cluster,state,was,successful,and,the,requisite,shard,copies,were,started,before,the,timeout,then,link,create,index,cluster,state,update,response,is,shards,acknowledged,will,return,true,otherwise,if,the,operation,timed,out,then,it,will,return,false,param,request,the,index,creation,cluster,state,update,request,param,listener,the,listener,on,which,to,send,the,index,creation,cluster,state,update,response;public,void,create,index,final,create,index,cluster,state,update,request,request,final,action,listener,create,index,cluster,state,update,response,listener,only,create,index,request,action,listener,wrap,response,if,response,is,acknowledged,active,shards,observer,wait,for,active,shards,new,string,request,index,request,wait,for,active,shards,request,ack,timeout,shards,acknowledged,if,shards,acknowledged,false,logger,debug,index,created,but,the,operation,timed,out,while,waiting,for,enough,shards,to,be,started,request,index,listener,on,response,new,create,index,cluster,state,update,response,response,is,acknowledged,shards,acknowledged,listener,on,failure,else,listener,on,response,new,create,index,cluster,state,update,response,false,false,listener,on,failure
MetaDataCreateIndexService -> public void createIndex(final CreateIndexClusterStateUpdateRequest request,                             final ActionListener<CreateIndexClusterStateUpdateResponse> listener);1541008027;Creates an index in the cluster state and waits for the specified number of shard copies to_become active (as specified in {@link CreateIndexClusterStateUpdateRequest#waitForActiveShards()})_before sending the response on the listener. If the index creation was successfully applied on_the cluster state, then {@link CreateIndexClusterStateUpdateResponse#isAcknowledged()} will return_true, otherwise it will return false and no waiting will occur for started shards_({@link CreateIndexClusterStateUpdateResponse#isShardsAcknowledged()} will also be false).  If the index_creation in the cluster state was successful and the requisite shard copies were started before_the timeout, then {@link CreateIndexClusterStateUpdateResponse#isShardsAcknowledged()} will_return true, otherwise if the operation timed out, then it will return false.__@param request the index creation cluster state update request_@param listener the listener on which to send the index creation cluster state update response;public void createIndex(final CreateIndexClusterStateUpdateRequest request,_                            final ActionListener<CreateIndexClusterStateUpdateResponse> listener) {_        onlyCreateIndex(request, ActionListener.wrap(response -> {_            if (response.isAcknowledged()) {_                activeShardsObserver.waitForActiveShards(new String[]{request.index()}, request.waitForActiveShards(), request.ackTimeout(),_                    shardsAcknowledged -> {_                        if (shardsAcknowledged == false) {_                            logger.debug("[{}] index created, but the operation timed out while waiting for " +_                                             "enough shards to be started.", request.index())__                        }_                        listener.onResponse(new CreateIndexClusterStateUpdateResponse(response.isAcknowledged(), shardsAcknowledged))__                    }, listener::onFailure)__            } else {_                listener.onResponse(new CreateIndexClusterStateUpdateResponse(false, false))__            }_        }, listener::onFailure))__    };creates,an,index,in,the,cluster,state,and,waits,for,the,specified,number,of,shard,copies,to,become,active,as,specified,in,link,create,index,cluster,state,update,request,wait,for,active,shards,before,sending,the,response,on,the,listener,if,the,index,creation,was,successfully,applied,on,the,cluster,state,then,link,create,index,cluster,state,update,response,is,acknowledged,will,return,true,otherwise,it,will,return,false,and,no,waiting,will,occur,for,started,shards,link,create,index,cluster,state,update,response,is,shards,acknowledged,will,also,be,false,if,the,index,creation,in,the,cluster,state,was,successful,and,the,requisite,shard,copies,were,started,before,the,timeout,then,link,create,index,cluster,state,update,response,is,shards,acknowledged,will,return,true,otherwise,if,the,operation,timed,out,then,it,will,return,false,param,request,the,index,creation,cluster,state,update,request,param,listener,the,listener,on,which,to,send,the,index,creation,cluster,state,update,response;public,void,create,index,final,create,index,cluster,state,update,request,request,final,action,listener,create,index,cluster,state,update,response,listener,only,create,index,request,action,listener,wrap,response,if,response,is,acknowledged,active,shards,observer,wait,for,active,shards,new,string,request,index,request,wait,for,active,shards,request,ack,timeout,shards,acknowledged,if,shards,acknowledged,false,logger,debug,index,created,but,the,operation,timed,out,while,waiting,for,enough,shards,to,be,started,request,index,listener,on,response,new,create,index,cluster,state,update,response,response,is,acknowledged,shards,acknowledged,listener,on,failure,else,listener,on,response,new,create,index,cluster,state,update,response,false,false,listener,on,failure
MetaDataCreateIndexService -> public void createIndex(final CreateIndexClusterStateUpdateRequest request,                             final ActionListener<CreateIndexClusterStateUpdateResponse> listener);1541092382;Creates an index in the cluster state and waits for the specified number of shard copies to_become active (as specified in {@link CreateIndexClusterStateUpdateRequest#waitForActiveShards()})_before sending the response on the listener. If the index creation was successfully applied on_the cluster state, then {@link CreateIndexClusterStateUpdateResponse#isAcknowledged()} will return_true, otherwise it will return false and no waiting will occur for started shards_({@link CreateIndexClusterStateUpdateResponse#isShardsAcknowledged()} will also be false).  If the index_creation in the cluster state was successful and the requisite shard copies were started before_the timeout, then {@link CreateIndexClusterStateUpdateResponse#isShardsAcknowledged()} will_return true, otherwise if the operation timed out, then it will return false.__@param request the index creation cluster state update request_@param listener the listener on which to send the index creation cluster state update response;public void createIndex(final CreateIndexClusterStateUpdateRequest request,_                            final ActionListener<CreateIndexClusterStateUpdateResponse> listener) {_        onlyCreateIndex(request, ActionListener.wrap(response -> {_            if (response.isAcknowledged()) {_                activeShardsObserver.waitForActiveShards(new String[]{request.index()}, request.waitForActiveShards(), request.ackTimeout(),_                    shardsAcknowledged -> {_                        if (shardsAcknowledged == false) {_                            logger.debug("[{}] index created, but the operation timed out while waiting for " +_                                             "enough shards to be started.", request.index())__                        }_                        listener.onResponse(new CreateIndexClusterStateUpdateResponse(response.isAcknowledged(), shardsAcknowledged))__                    }, listener::onFailure)__            } else {_                listener.onResponse(new CreateIndexClusterStateUpdateResponse(false, false))__            }_        }, listener::onFailure))__    };creates,an,index,in,the,cluster,state,and,waits,for,the,specified,number,of,shard,copies,to,become,active,as,specified,in,link,create,index,cluster,state,update,request,wait,for,active,shards,before,sending,the,response,on,the,listener,if,the,index,creation,was,successfully,applied,on,the,cluster,state,then,link,create,index,cluster,state,update,response,is,acknowledged,will,return,true,otherwise,it,will,return,false,and,no,waiting,will,occur,for,started,shards,link,create,index,cluster,state,update,response,is,shards,acknowledged,will,also,be,false,if,the,index,creation,in,the,cluster,state,was,successful,and,the,requisite,shard,copies,were,started,before,the,timeout,then,link,create,index,cluster,state,update,response,is,shards,acknowledged,will,return,true,otherwise,if,the,operation,timed,out,then,it,will,return,false,param,request,the,index,creation,cluster,state,update,request,param,listener,the,listener,on,which,to,send,the,index,creation,cluster,state,update,response;public,void,create,index,final,create,index,cluster,state,update,request,request,final,action,listener,create,index,cluster,state,update,response,listener,only,create,index,request,action,listener,wrap,response,if,response,is,acknowledged,active,shards,observer,wait,for,active,shards,new,string,request,index,request,wait,for,active,shards,request,ack,timeout,shards,acknowledged,if,shards,acknowledged,false,logger,debug,index,created,but,the,operation,timed,out,while,waiting,for,enough,shards,to,be,started,request,index,listener,on,response,new,create,index,cluster,state,update,response,response,is,acknowledged,shards,acknowledged,listener,on,failure,else,listener,on,response,new,create,index,cluster,state,update,response,false,false,listener,on,failure
MetaDataCreateIndexService -> public void createIndex(final CreateIndexClusterStateUpdateRequest request,                             final ActionListener<CreateIndexClusterStateUpdateResponse> listener);1541592065;Creates an index in the cluster state and waits for the specified number of shard copies to_become active (as specified in {@link CreateIndexClusterStateUpdateRequest#waitForActiveShards()})_before sending the response on the listener. If the index creation was successfully applied on_the cluster state, then {@link CreateIndexClusterStateUpdateResponse#isAcknowledged()} will return_true, otherwise it will return false and no waiting will occur for started shards_({@link CreateIndexClusterStateUpdateResponse#isShardsAcknowledged()} will also be false).  If the index_creation in the cluster state was successful and the requisite shard copies were started before_the timeout, then {@link CreateIndexClusterStateUpdateResponse#isShardsAcknowledged()} will_return true, otherwise if the operation timed out, then it will return false.__@param request the index creation cluster state update request_@param listener the listener on which to send the index creation cluster state update response;public void createIndex(final CreateIndexClusterStateUpdateRequest request,_                            final ActionListener<CreateIndexClusterStateUpdateResponse> listener) {_        onlyCreateIndex(request, ActionListener.wrap(response -> {_            if (response.isAcknowledged()) {_                activeShardsObserver.waitForActiveShards(new String[]{request.index()}, request.waitForActiveShards(), request.ackTimeout(),_                    shardsAcknowledged -> {_                        if (shardsAcknowledged == false) {_                            logger.debug("[{}] index created, but the operation timed out while waiting for " +_                                             "enough shards to be started.", request.index())__                        }_                        listener.onResponse(new CreateIndexClusterStateUpdateResponse(response.isAcknowledged(), shardsAcknowledged))__                    }, listener::onFailure)__            } else {_                listener.onResponse(new CreateIndexClusterStateUpdateResponse(false, false))__            }_        }, listener::onFailure))__    };creates,an,index,in,the,cluster,state,and,waits,for,the,specified,number,of,shard,copies,to,become,active,as,specified,in,link,create,index,cluster,state,update,request,wait,for,active,shards,before,sending,the,response,on,the,listener,if,the,index,creation,was,successfully,applied,on,the,cluster,state,then,link,create,index,cluster,state,update,response,is,acknowledged,will,return,true,otherwise,it,will,return,false,and,no,waiting,will,occur,for,started,shards,link,create,index,cluster,state,update,response,is,shards,acknowledged,will,also,be,false,if,the,index,creation,in,the,cluster,state,was,successful,and,the,requisite,shard,copies,were,started,before,the,timeout,then,link,create,index,cluster,state,update,response,is,shards,acknowledged,will,return,true,otherwise,if,the,operation,timed,out,then,it,will,return,false,param,request,the,index,creation,cluster,state,update,request,param,listener,the,listener,on,which,to,send,the,index,creation,cluster,state,update,response;public,void,create,index,final,create,index,cluster,state,update,request,request,final,action,listener,create,index,cluster,state,update,response,listener,only,create,index,request,action,listener,wrap,response,if,response,is,acknowledged,active,shards,observer,wait,for,active,shards,new,string,request,index,request,wait,for,active,shards,request,ack,timeout,shards,acknowledged,if,shards,acknowledged,false,logger,debug,index,created,but,the,operation,timed,out,while,waiting,for,enough,shards,to,be,started,request,index,listener,on,response,new,create,index,cluster,state,update,response,response,is,acknowledged,shards,acknowledged,listener,on,failure,else,listener,on,response,new,create,index,cluster,state,update,response,false,false,listener,on,failure
MetaDataCreateIndexService -> public void createIndex(final CreateIndexClusterStateUpdateRequest request,                             final ActionListener<CreateIndexClusterStateUpdateResponse> listener);1542402632;Creates an index in the cluster state and waits for the specified number of shard copies to_become active (as specified in {@link CreateIndexClusterStateUpdateRequest#waitForActiveShards()})_before sending the response on the listener. If the index creation was successfully applied on_the cluster state, then {@link CreateIndexClusterStateUpdateResponse#isAcknowledged()} will return_true, otherwise it will return false and no waiting will occur for started shards_({@link CreateIndexClusterStateUpdateResponse#isShardsAcknowledged()} will also be false).  If the index_creation in the cluster state was successful and the requisite shard copies were started before_the timeout, then {@link CreateIndexClusterStateUpdateResponse#isShardsAcknowledged()} will_return true, otherwise if the operation timed out, then it will return false.__@param request the index creation cluster state update request_@param listener the listener on which to send the index creation cluster state update response;public void createIndex(final CreateIndexClusterStateUpdateRequest request,_                            final ActionListener<CreateIndexClusterStateUpdateResponse> listener) {_        onlyCreateIndex(request, ActionListener.wrap(response -> {_            if (response.isAcknowledged()) {_                activeShardsObserver.waitForActiveShards(new String[]{request.index()}, request.waitForActiveShards(), request.ackTimeout(),_                    shardsAcknowledged -> {_                        if (shardsAcknowledged == false) {_                            logger.debug("[{}] index created, but the operation timed out while waiting for " +_                                             "enough shards to be started.", request.index())__                        }_                        listener.onResponse(new CreateIndexClusterStateUpdateResponse(response.isAcknowledged(), shardsAcknowledged))__                    }, listener::onFailure)__            } else {_                listener.onResponse(new CreateIndexClusterStateUpdateResponse(false, false))__            }_        }, listener::onFailure))__    };creates,an,index,in,the,cluster,state,and,waits,for,the,specified,number,of,shard,copies,to,become,active,as,specified,in,link,create,index,cluster,state,update,request,wait,for,active,shards,before,sending,the,response,on,the,listener,if,the,index,creation,was,successfully,applied,on,the,cluster,state,then,link,create,index,cluster,state,update,response,is,acknowledged,will,return,true,otherwise,it,will,return,false,and,no,waiting,will,occur,for,started,shards,link,create,index,cluster,state,update,response,is,shards,acknowledged,will,also,be,false,if,the,index,creation,in,the,cluster,state,was,successful,and,the,requisite,shard,copies,were,started,before,the,timeout,then,link,create,index,cluster,state,update,response,is,shards,acknowledged,will,return,true,otherwise,if,the,operation,timed,out,then,it,will,return,false,param,request,the,index,creation,cluster,state,update,request,param,listener,the,listener,on,which,to,send,the,index,creation,cluster,state,update,response;public,void,create,index,final,create,index,cluster,state,update,request,request,final,action,listener,create,index,cluster,state,update,response,listener,only,create,index,request,action,listener,wrap,response,if,response,is,acknowledged,active,shards,observer,wait,for,active,shards,new,string,request,index,request,wait,for,active,shards,request,ack,timeout,shards,acknowledged,if,shards,acknowledged,false,logger,debug,index,created,but,the,operation,timed,out,while,waiting,for,enough,shards,to,be,started,request,index,listener,on,response,new,create,index,cluster,state,update,response,response,is,acknowledged,shards,acknowledged,listener,on,failure,else,listener,on,response,new,create,index,cluster,state,update,response,false,false,listener,on,failure
MetaDataCreateIndexService -> public void createIndex(final CreateIndexClusterStateUpdateRequest request,                             final ActionListener<CreateIndexClusterStateUpdateResponse> listener);1543277112;Creates an index in the cluster state and waits for the specified number of shard copies to_become active (as specified in {@link CreateIndexClusterStateUpdateRequest#waitForActiveShards()})_before sending the response on the listener. If the index creation was successfully applied on_the cluster state, then {@link CreateIndexClusterStateUpdateResponse#isAcknowledged()} will return_true, otherwise it will return false and no waiting will occur for started shards_({@link CreateIndexClusterStateUpdateResponse#isShardsAcknowledged()} will also be false).  If the index_creation in the cluster state was successful and the requisite shard copies were started before_the timeout, then {@link CreateIndexClusterStateUpdateResponse#isShardsAcknowledged()} will_return true, otherwise if the operation timed out, then it will return false.__@param request the index creation cluster state update request_@param listener the listener on which to send the index creation cluster state update response;public void createIndex(final CreateIndexClusterStateUpdateRequest request,_                            final ActionListener<CreateIndexClusterStateUpdateResponse> listener) {_        onlyCreateIndex(request, ActionListener.wrap(response -> {_            if (response.isAcknowledged()) {_                activeShardsObserver.waitForActiveShards(new String[]{request.index()}, request.waitForActiveShards(), request.ackTimeout(),_                    shardsAcknowledged -> {_                        if (shardsAcknowledged == false) {_                            logger.debug("[{}] index created, but the operation timed out while waiting for " +_                                             "enough shards to be started.", request.index())__                        }_                        listener.onResponse(new CreateIndexClusterStateUpdateResponse(response.isAcknowledged(), shardsAcknowledged))__                    }, listener::onFailure)__            } else {_                listener.onResponse(new CreateIndexClusterStateUpdateResponse(false, false))__            }_        }, listener::onFailure))__    };creates,an,index,in,the,cluster,state,and,waits,for,the,specified,number,of,shard,copies,to,become,active,as,specified,in,link,create,index,cluster,state,update,request,wait,for,active,shards,before,sending,the,response,on,the,listener,if,the,index,creation,was,successfully,applied,on,the,cluster,state,then,link,create,index,cluster,state,update,response,is,acknowledged,will,return,true,otherwise,it,will,return,false,and,no,waiting,will,occur,for,started,shards,link,create,index,cluster,state,update,response,is,shards,acknowledged,will,also,be,false,if,the,index,creation,in,the,cluster,state,was,successful,and,the,requisite,shard,copies,were,started,before,the,timeout,then,link,create,index,cluster,state,update,response,is,shards,acknowledged,will,return,true,otherwise,if,the,operation,timed,out,then,it,will,return,false,param,request,the,index,creation,cluster,state,update,request,param,listener,the,listener,on,which,to,send,the,index,creation,cluster,state,update,response;public,void,create,index,final,create,index,cluster,state,update,request,request,final,action,listener,create,index,cluster,state,update,response,listener,only,create,index,request,action,listener,wrap,response,if,response,is,acknowledged,active,shards,observer,wait,for,active,shards,new,string,request,index,request,wait,for,active,shards,request,ack,timeout,shards,acknowledged,if,shards,acknowledged,false,logger,debug,index,created,but,the,operation,timed,out,while,waiting,for,enough,shards,to,be,started,request,index,listener,on,response,new,create,index,cluster,state,update,response,response,is,acknowledged,shards,acknowledged,listener,on,failure,else,listener,on,response,new,create,index,cluster,state,update,response,false,false,listener,on,failure
MetaDataCreateIndexService -> public void createIndex(final CreateIndexClusterStateUpdateRequest request,                             final ActionListener<CreateIndexClusterStateUpdateResponse> listener);1544702062;Creates an index in the cluster state and waits for the specified number of shard copies to_become active (as specified in {@link CreateIndexClusterStateUpdateRequest#waitForActiveShards()})_before sending the response on the listener. If the index creation was successfully applied on_the cluster state, then {@link CreateIndexClusterStateUpdateResponse#isAcknowledged()} will return_true, otherwise it will return false and no waiting will occur for started shards_({@link CreateIndexClusterStateUpdateResponse#isShardsAcknowledged()} will also be false).  If the index_creation in the cluster state was successful and the requisite shard copies were started before_the timeout, then {@link CreateIndexClusterStateUpdateResponse#isShardsAcknowledged()} will_return true, otherwise if the operation timed out, then it will return false.__@param request the index creation cluster state update request_@param listener the listener on which to send the index creation cluster state update response;public void createIndex(final CreateIndexClusterStateUpdateRequest request,_                            final ActionListener<CreateIndexClusterStateUpdateResponse> listener) {_        onlyCreateIndex(request, ActionListener.wrap(response -> {_            if (response.isAcknowledged()) {_                activeShardsObserver.waitForActiveShards(new String[]{request.index()}, request.waitForActiveShards(), request.ackTimeout(),_                    shardsAcknowledged -> {_                        if (shardsAcknowledged == false) {_                            logger.debug("[{}] index created, but the operation timed out while waiting for " +_                                             "enough shards to be started.", request.index())__                        }_                        listener.onResponse(new CreateIndexClusterStateUpdateResponse(response.isAcknowledged(), shardsAcknowledged))__                    }, listener::onFailure)__            } else {_                listener.onResponse(new CreateIndexClusterStateUpdateResponse(false, false))__            }_        }, listener::onFailure))__    };creates,an,index,in,the,cluster,state,and,waits,for,the,specified,number,of,shard,copies,to,become,active,as,specified,in,link,create,index,cluster,state,update,request,wait,for,active,shards,before,sending,the,response,on,the,listener,if,the,index,creation,was,successfully,applied,on,the,cluster,state,then,link,create,index,cluster,state,update,response,is,acknowledged,will,return,true,otherwise,it,will,return,false,and,no,waiting,will,occur,for,started,shards,link,create,index,cluster,state,update,response,is,shards,acknowledged,will,also,be,false,if,the,index,creation,in,the,cluster,state,was,successful,and,the,requisite,shard,copies,were,started,before,the,timeout,then,link,create,index,cluster,state,update,response,is,shards,acknowledged,will,return,true,otherwise,if,the,operation,timed,out,then,it,will,return,false,param,request,the,index,creation,cluster,state,update,request,param,listener,the,listener,on,which,to,send,the,index,creation,cluster,state,update,response;public,void,create,index,final,create,index,cluster,state,update,request,request,final,action,listener,create,index,cluster,state,update,response,listener,only,create,index,request,action,listener,wrap,response,if,response,is,acknowledged,active,shards,observer,wait,for,active,shards,new,string,request,index,request,wait,for,active,shards,request,ack,timeout,shards,acknowledged,if,shards,acknowledged,false,logger,debug,index,created,but,the,operation,timed,out,while,waiting,for,enough,shards,to,be,started,request,index,listener,on,response,new,create,index,cluster,state,update,response,response,is,acknowledged,shards,acknowledged,listener,on,failure,else,listener,on,response,new,create,index,cluster,state,update,response,false,false,listener,on,failure
MetaDataCreateIndexService -> public void createIndex(final CreateIndexClusterStateUpdateRequest request,                             final ActionListener<CreateIndexClusterStateUpdateResponse> listener);1548840504;Creates an index in the cluster state and waits for the specified number of shard copies to_become active (as specified in {@link CreateIndexClusterStateUpdateRequest#waitForActiveShards()})_before sending the response on the listener. If the index creation was successfully applied on_the cluster state, then {@link CreateIndexClusterStateUpdateResponse#isAcknowledged()} will return_true, otherwise it will return false and no waiting will occur for started shards_({@link CreateIndexClusterStateUpdateResponse#isShardsAcknowledged()} will also be false).  If the index_creation in the cluster state was successful and the requisite shard copies were started before_the timeout, then {@link CreateIndexClusterStateUpdateResponse#isShardsAcknowledged()} will_return true, otherwise if the operation timed out, then it will return false.__@param request the index creation cluster state update request_@param listener the listener on which to send the index creation cluster state update response;public void createIndex(final CreateIndexClusterStateUpdateRequest request,_                            final ActionListener<CreateIndexClusterStateUpdateResponse> listener) {_        onlyCreateIndex(request, ActionListener.wrap(response -> {_            if (response.isAcknowledged()) {_                activeShardsObserver.waitForActiveShards(new String[]{request.index()}, request.waitForActiveShards(), request.ackTimeout(),_                    shardsAcknowledged -> {_                        if (shardsAcknowledged == false) {_                            logger.debug("[{}] index created, but the operation timed out while waiting for " +_                                             "enough shards to be started.", request.index())__                        }_                        listener.onResponse(new CreateIndexClusterStateUpdateResponse(response.isAcknowledged(), shardsAcknowledged))__                    }, listener::onFailure)__            } else {_                listener.onResponse(new CreateIndexClusterStateUpdateResponse(false, false))__            }_        }, listener::onFailure))__    };creates,an,index,in,the,cluster,state,and,waits,for,the,specified,number,of,shard,copies,to,become,active,as,specified,in,link,create,index,cluster,state,update,request,wait,for,active,shards,before,sending,the,response,on,the,listener,if,the,index,creation,was,successfully,applied,on,the,cluster,state,then,link,create,index,cluster,state,update,response,is,acknowledged,will,return,true,otherwise,it,will,return,false,and,no,waiting,will,occur,for,started,shards,link,create,index,cluster,state,update,response,is,shards,acknowledged,will,also,be,false,if,the,index,creation,in,the,cluster,state,was,successful,and,the,requisite,shard,copies,were,started,before,the,timeout,then,link,create,index,cluster,state,update,response,is,shards,acknowledged,will,return,true,otherwise,if,the,operation,timed,out,then,it,will,return,false,param,request,the,index,creation,cluster,state,update,request,param,listener,the,listener,on,which,to,send,the,index,creation,cluster,state,update,response;public,void,create,index,final,create,index,cluster,state,update,request,request,final,action,listener,create,index,cluster,state,update,response,listener,only,create,index,request,action,listener,wrap,response,if,response,is,acknowledged,active,shards,observer,wait,for,active,shards,new,string,request,index,request,wait,for,active,shards,request,ack,timeout,shards,acknowledged,if,shards,acknowledged,false,logger,debug,index,created,but,the,operation,timed,out,while,waiting,for,enough,shards,to,be,started,request,index,listener,on,response,new,create,index,cluster,state,update,response,response,is,acknowledged,shards,acknowledged,listener,on,failure,else,listener,on,response,new,create,index,cluster,state,update,response,false,false,listener,on,failure
MetaDataCreateIndexService -> public void createIndex(final CreateIndexClusterStateUpdateRequest request,                             final ActionListener<CreateIndexClusterStateUpdateResponse> listener);1549608646;Creates an index in the cluster state and waits for the specified number of shard copies to_become active (as specified in {@link CreateIndexClusterStateUpdateRequest#waitForActiveShards()})_before sending the response on the listener. If the index creation was successfully applied on_the cluster state, then {@link CreateIndexClusterStateUpdateResponse#isAcknowledged()} will return_true, otherwise it will return false and no waiting will occur for started shards_({@link CreateIndexClusterStateUpdateResponse#isShardsAcknowledged()} will also be false).  If the index_creation in the cluster state was successful and the requisite shard copies were started before_the timeout, then {@link CreateIndexClusterStateUpdateResponse#isShardsAcknowledged()} will_return true, otherwise if the operation timed out, then it will return false.__@param request the index creation cluster state update request_@param listener the listener on which to send the index creation cluster state update response;public void createIndex(final CreateIndexClusterStateUpdateRequest request,_                            final ActionListener<CreateIndexClusterStateUpdateResponse> listener) {_        onlyCreateIndex(request, ActionListener.wrap(response -> {_            if (response.isAcknowledged()) {_                activeShardsObserver.waitForActiveShards(new String[]{request.index()}, request.waitForActiveShards(), request.ackTimeout(),_                    shardsAcknowledged -> {_                        if (shardsAcknowledged == false) {_                            logger.debug("[{}] index created, but the operation timed out while waiting for " +_                                             "enough shards to be started.", request.index())__                        }_                        listener.onResponse(new CreateIndexClusterStateUpdateResponse(response.isAcknowledged(), shardsAcknowledged))__                    }, listener::onFailure)__            } else {_                listener.onResponse(new CreateIndexClusterStateUpdateResponse(false, false))__            }_        }, listener::onFailure))__    };creates,an,index,in,the,cluster,state,and,waits,for,the,specified,number,of,shard,copies,to,become,active,as,specified,in,link,create,index,cluster,state,update,request,wait,for,active,shards,before,sending,the,response,on,the,listener,if,the,index,creation,was,successfully,applied,on,the,cluster,state,then,link,create,index,cluster,state,update,response,is,acknowledged,will,return,true,otherwise,it,will,return,false,and,no,waiting,will,occur,for,started,shards,link,create,index,cluster,state,update,response,is,shards,acknowledged,will,also,be,false,if,the,index,creation,in,the,cluster,state,was,successful,and,the,requisite,shard,copies,were,started,before,the,timeout,then,link,create,index,cluster,state,update,response,is,shards,acknowledged,will,return,true,otherwise,if,the,operation,timed,out,then,it,will,return,false,param,request,the,index,creation,cluster,state,update,request,param,listener,the,listener,on,which,to,send,the,index,creation,cluster,state,update,response;public,void,create,index,final,create,index,cluster,state,update,request,request,final,action,listener,create,index,cluster,state,update,response,listener,only,create,index,request,action,listener,wrap,response,if,response,is,acknowledged,active,shards,observer,wait,for,active,shards,new,string,request,index,request,wait,for,active,shards,request,ack,timeout,shards,acknowledged,if,shards,acknowledged,false,logger,debug,index,created,but,the,operation,timed,out,while,waiting,for,enough,shards,to,be,started,request,index,listener,on,response,new,create,index,cluster,state,update,response,response,is,acknowledged,shards,acknowledged,listener,on,failure,else,listener,on,response,new,create,index,cluster,state,update,response,false,false,listener,on,failure
