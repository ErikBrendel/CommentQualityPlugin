commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;7;;@Override protected void doWriteTo(StreamOutput out) throws IOException {     out.writeNamedWriteable(include).     out.writeNamedWriteable(exclude).     out.writeVInt(pre).     out.writeVInt(post). }
true;public;0;3;/**  * @return the span query whose matches are filtered  */ ;/**  * @return the span query whose matches are filtered  */ public SpanQueryBuilder includeQuery() {     return this.include. }
true;public;0;3;/**  * @return the span query whose matches must not overlap  */ ;/**  * @return the span query whose matches must not overlap  */ public SpanQueryBuilder excludeQuery() {     return this.exclude. }
true;public;1;5;/**  * @param dist the amount of tokens from within the include span can’t have overlap with the exclude span.  * Equivalent to setting both pre and post parameter.  */ ;/**  * @param dist the amount of tokens from within the include span can’t have overlap with the exclude span.  * Equivalent to setting both pre and post parameter.  */ public SpanNotQueryBuilder dist(int dist) {     pre(dist).     post(dist).     return this. }
true;public;1;4;/**  * @param pre the amount of tokens before the include span that can’t have overlap with the exclude span. Values  * smaller than 0 will be ignored and 0 used instead.  */ ;/**  * @param pre the amount of tokens before the include span that can’t have overlap with the exclude span. Values  * smaller than 0 will be ignored and 0 used instead.  */ public SpanNotQueryBuilder pre(int pre) {     this.pre = (pre >= 0) ? pre : 0.     return this. }
true;public;0;3;/**  * @return the amount of tokens before the include span that can’t have overlap with the exclude span.  * @see SpanNotQueryBuilder#pre(int)  */ ;/**  * @return the amount of tokens before the include span that can’t have overlap with the exclude span.  * @see SpanNotQueryBuilder#pre(int)  */ public Integer pre() {     return this.pre. }
true;public;1;4;/**  * @param post the amount of tokens after the include span that can’t have overlap with the exclude span.  */ ;/**  * @param post the amount of tokens after the include span that can’t have overlap with the exclude span.  */ public SpanNotQueryBuilder post(int post) {     this.post = (post >= 0) ? post : 0.     return this. }
true;public;0;3;/**  * @return the amount of tokens after the include span that can’t have overlap with the exclude span.  * @see SpanNotQueryBuilder#post(int)  */ ;/**  * @return the amount of tokens after the include span that can’t have overlap with the exclude span.  * @see SpanNotQueryBuilder#post(int)  */ public Integer post() {     return this.post. }
false;protected;2;12;;@Override protected void doXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject(NAME).     builder.field(INCLUDE_FIELD.getPreferredName()).     include.toXContent(builder, params).     builder.field(EXCLUDE_FIELD.getPreferredName()).     exclude.toXContent(builder, params).     builder.field(PRE_FIELD.getPreferredName(), pre).     builder.field(POST_FIELD.getPreferredName(), post).     printBoostAndQueryName(builder).     builder.endObject(). }
false;public,static;1;75;;public static SpanNotQueryBuilder fromXContent(XContentParser parser) throws IOException {     float boost = AbstractQueryBuilder.DEFAULT_BOOST.     SpanQueryBuilder include = null.     SpanQueryBuilder exclude = null.     Integer dist = null.     Integer pre = null.     Integer post = null.     String queryName = null.     String currentFieldName = null.     XContentParser.Token token.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (token == XContentParser.Token.START_OBJECT) {             if (INCLUDE_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 QueryBuilder query = parseInnerQueryBuilder(parser).                 if (query instanceof SpanQueryBuilder == false) {                     throw new ParsingException(parser.getTokenLocation(), "span_not [include] must be of type span query").                 }                 include = (SpanQueryBuilder) query.                 checkNoBoost(NAME, currentFieldName, parser, include).             } else if (EXCLUDE_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 QueryBuilder query = parseInnerQueryBuilder(parser).                 if (query instanceof SpanQueryBuilder == false) {                     throw new ParsingException(parser.getTokenLocation(), "span_not [exclude] must be of type span query").                 }                 exclude = (SpanQueryBuilder) query.                 checkNoBoost(NAME, currentFieldName, parser, exclude).             } else {                 throw new ParsingException(parser.getTokenLocation(), "[span_not] query does not support [" + currentFieldName + "]").             }         } else {             if (DIST_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 dist = parser.intValue().             } else if (PRE_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 pre = parser.intValue().             } else if (POST_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 post = parser.intValue().             } else if (AbstractQueryBuilder.BOOST_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 boost = parser.floatValue().             } else if (AbstractQueryBuilder.NAME_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 queryName = parser.text().             } else {                 throw new ParsingException(parser.getTokenLocation(), "[span_not] query does not support [" + currentFieldName + "]").             }         }     }     if (include == null) {         throw new ParsingException(parser.getTokenLocation(), "span_not must have [include] span query clause").     }     if (exclude == null) {         throw new ParsingException(parser.getTokenLocation(), "span_not must have [exclude] span query clause").     }     if (dist != null && (pre != null || post != null)) {         throw new ParsingException(parser.getTokenLocation(), "span_not can either use [dist] or [pre] & [post] (or none)").     }     SpanNotQueryBuilder spanNotQuery = new SpanNotQueryBuilder(include, exclude).     if (dist != null) {         spanNotQuery.dist(dist).     }     if (pre != null) {         spanNotQuery.pre(pre).     }     if (post != null) {         spanNotQuery.post(post).     }     spanNotQuery.boost(boost).     spanNotQuery.queryName(queryName).     return spanNotQuery. }
false;protected;1;10;;@Override protected Query doToQuery(QueryShardContext context) throws IOException {     Query includeQuery = this.include.toQuery(context).     assert includeQuery instanceof SpanQuery.     Query excludeQuery = this.exclude.toQuery(context).     assert excludeQuery instanceof SpanQuery.     return new SpanNotQuery((SpanQuery) includeQuery, (SpanQuery) excludeQuery, pre, post). }
false;protected;0;4;;@Override protected int doHashCode() {     return Objects.hash(include, exclude, pre, post). }
false;protected;1;7;;@Override protected boolean doEquals(SpanNotQueryBuilder other) {     return Objects.equals(include, other.include) && Objects.equals(exclude, other.exclude) && (pre == other.pre) && (post == other.post). }
false;public;0;4;;@Override public String getWriteableName() {     return NAME. }
