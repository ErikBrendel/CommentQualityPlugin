commented;modifiers;parameterAmount;loc;comment;code
false;public;2;4;;@Override public Decision canAllocate(ShardRouting shardRouting, RoutingAllocation allocation) {     return canAllocate(shardRouting, null, allocation). }
false;public;3;37;;@Override public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {     final UnassignedInfo unassignedInfo = shardRouting.unassignedInfo().     if (unassignedInfo != null && shardRouting.recoverySource().getType() == RecoverySource.Type.LOCAL_SHARDS) {         // we only make decisions here if we have an unassigned info and we have to recover from another index ie. split / shrink         final IndexMetaData indexMetaData = allocation.metaData().getIndexSafe(shardRouting.index()).         Index resizeSourceIndex = indexMetaData.getResizeSourceIndex().         assert resizeSourceIndex != null.         if (allocation.metaData().index(resizeSourceIndex) == null) {             return allocation.decision(Decision.NO, NAME, "resize source index [%s] doesn't exists", resizeSourceIndex.toString()).         }         IndexMetaData sourceIndexMetaData = allocation.metaData().getIndexSafe(resizeSourceIndex).         if (indexMetaData.getNumberOfShards() < sourceIndexMetaData.getNumberOfShards()) {             // this only handles splits so far.             return Decision.ALWAYS.         }         ShardId shardId = IndexMetaData.selectSplitShard(shardRouting.id(), sourceIndexMetaData, indexMetaData.getNumberOfShards()).         ShardRouting sourceShardRouting = allocation.routingNodes().activePrimary(shardId).         if (sourceShardRouting == null) {             return allocation.decision(Decision.NO, NAME, "source primary shard [%s] is not active", shardId).         }         if (node != null) {             // we might get called from the 2 param canAllocate method..             if (node.node().getVersion().before(ResizeAction.COMPATIBILITY_VERSION)) {                 return allocation.decision(Decision.NO, NAME, "node [%s] is too old to split a shard", node.nodeId()).             }             if (sourceShardRouting.currentNodeId().equals(node.nodeId())) {                 return allocation.decision(Decision.YES, NAME, "source primary is allocated on this node").             } else {                 return allocation.decision(Decision.NO, NAME, "source primary is allocated on another node").             }         } else {             return allocation.decision(Decision.YES, NAME, "source primary is active").         }     }     return super.canAllocate(shardRouting, node, allocation). }
false;public;3;5;;@Override public Decision canForceAllocatePrimary(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {     assert shardRouting.primary() : "must not call canForceAllocatePrimary on a non-primary shard " + shardRouting.     return canAllocate(shardRouting, node, allocation). }
