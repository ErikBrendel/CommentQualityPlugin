commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;10;/**  * Retrieves the {@link IndexRequest} from the provided {@link DocWriteRequest} for index or upsert actions.  Upserts are  * modeled as {@link IndexRequest} inside the {@link UpdateRequest}. Ignores {@link org.elasticsearch.action.delete.DeleteRequest}'s  *  * @param docWriteRequest The request to find the {@link IndexRequest}  * @return the found {@link IndexRequest} or {@code null} if one can not be found.  */ ;/**  * Retrieves the {@link IndexRequest} from the provided {@link DocWriteRequest} for index or upsert actions.  Upserts are  * modeled as {@link IndexRequest} inside the {@link UpdateRequest}. Ignores {@link org.elasticsearch.action.delete.DeleteRequest}'s  *  * @param docWriteRequest The request to find the {@link IndexRequest}  * @return the found {@link IndexRequest} or {@code null} if one can not be found.  */ public static IndexRequest getIndexWriteRequest(DocWriteRequest docWriteRequest) {     IndexRequest indexRequest = null.     if (docWriteRequest instanceof IndexRequest) {         indexRequest = (IndexRequest) docWriteRequest.     } else if (docWriteRequest instanceof UpdateRequest) {         UpdateRequest updateRequest = (UpdateRequest) docWriteRequest.         indexRequest = updateRequest.docAsUpsert() ? updateRequest.doc() : updateRequest.upsertRequest().     }     return indexRequest. }
false;public;1;6;;@Override public void onResponse(CreateIndexResponse result) {     if (counter.decrementAndGet() == 0) {         executeIngestAndBulk(task, bulkRequest, startTime, listener, responses, indicesThatCannotBeCreated).     } }
false;public;1;18;;@Override public void onFailure(Exception e) {     if (!(ExceptionsHelper.unwrapCause(e) instanceof ResourceAlreadyExistsException)) {         // fail all requests involving this index, if create didn't work         for (int i = 0. i < bulkRequest.requests.size(). i++) {             DocWriteRequest<?> request = bulkRequest.requests.get(i).             if (request != null && setResponseFailureIfIndexMatches(responses, i, request, index, e)) {                 bulkRequest.requests.set(i, null).             }         }     }     if (counter.decrementAndGet() == 0) {         executeIngestAndBulk(task, bulkRequest, startTime, ActionListener.wrap(listener::onResponse, inner -> {             inner.addSuppressed(e).             listener.onFailure(inner).         }), responses, indicesThatCannotBeCreated).     } }
false;protected;3;72;;@Override protected void doExecute(Task task, BulkRequest bulkRequest, ActionListener<BulkResponse> listener) {     final long startTime = relativeTime().     final AtomicArray<BulkItemResponse> responses = new AtomicArray<>(bulkRequest.requests.size()).     if (needToCheck()) {         // Attempt to create all the indices that we're going to need during the bulk before we start.         // Step 1: collect all the indices in the request         final Set<String> indices = bulkRequest.requests.stream().filter(request -> request.opType() != DocWriteRequest.OpType.DELETE || request.versionType() == VersionType.EXTERNAL || request.versionType() == VersionType.EXTERNAL_GTE).map(DocWriteRequest::index).collect(Collectors.toSet()).         /* Step 2: filter that to indices that don't exist and we can create. At the same time build a map of indices we can't create              * that we'll use when we try to run the requests. */         final Map<String, IndexNotFoundException> indicesThatCannotBeCreated = new HashMap<>().         Set<String> autoCreateIndices = new HashSet<>().         ClusterState state = clusterService.state().         for (String index : indices) {             boolean shouldAutoCreate.             try {                 shouldAutoCreate = shouldAutoCreate(index, state).             } catch (IndexNotFoundException e) {                 shouldAutoCreate = false.                 indicesThatCannotBeCreated.put(index, e).             }             if (shouldAutoCreate) {                 autoCreateIndices.add(index).             }         }         // Step 3: create all the indices that are missing, if there are any missing. start the bulk after all the creates come back.         if (autoCreateIndices.isEmpty()) {             executeIngestAndBulk(task, bulkRequest, startTime, listener, responses, indicesThatCannotBeCreated).         } else {             final AtomicInteger counter = new AtomicInteger(autoCreateIndices.size()).             for (String index : autoCreateIndices) {                 createIndex(index, bulkRequest.timeout(), new ActionListener<CreateIndexResponse>() {                      @Override                     public void onResponse(CreateIndexResponse result) {                         if (counter.decrementAndGet() == 0) {                             executeIngestAndBulk(task, bulkRequest, startTime, listener, responses, indicesThatCannotBeCreated).                         }                     }                      @Override                     public void onFailure(Exception e) {                         if (!(ExceptionsHelper.unwrapCause(e) instanceof ResourceAlreadyExistsException)) {                             // fail all requests involving this index, if create didn't work                             for (int i = 0. i < bulkRequest.requests.size(). i++) {                                 DocWriteRequest<?> request = bulkRequest.requests.get(i).                                 if (request != null && setResponseFailureIfIndexMatches(responses, i, request, index, e)) {                                     bulkRequest.requests.set(i, null).                                 }                             }                         }                         if (counter.decrementAndGet() == 0) {                             executeIngestAndBulk(task, bulkRequest, startTime, ActionListener.wrap(listener::onResponse, inner -> {                                 inner.addSuppressed(e).                                 listener.onFailure(inner).                             }), responses, indicesThatCannotBeCreated).                         }                     }                 }).             }         }     } else {         executeIngestAndBulk(task, bulkRequest, startTime, listener, responses, emptyMap()).     } }
false;private;6;48;;private void executeIngestAndBulk(Task task, final BulkRequest bulkRequest, final long startTimeNanos, final ActionListener<BulkResponse> listener, final AtomicArray<BulkItemResponse> responses, Map<String, IndexNotFoundException> indicesThatCannotBeCreated) {     boolean hasIndexRequestsWithPipelines = false.     final MetaData metaData = clusterService.state().getMetaData().     ImmutableOpenMap<String, IndexMetaData> indicesMetaData = metaData.indices().     for (DocWriteRequest<?> actionRequest : bulkRequest.requests) {         IndexRequest indexRequest = getIndexWriteRequest(actionRequest).         if (indexRequest != null) {             String pipeline = indexRequest.getPipeline().             if (pipeline == null) {                 IndexMetaData indexMetaData = indicesMetaData.get(actionRequest.index()).                 if (indexMetaData == null && indexRequest.index() != null) {                     // check the alias                     AliasOrIndex indexOrAlias = metaData.getAliasAndIndexLookup().get(indexRequest.index()).                     if (indexOrAlias != null && indexOrAlias.isAlias()) {                         AliasOrIndex.Alias alias = (AliasOrIndex.Alias) indexOrAlias.                         indexMetaData = alias.getWriteIndex().                     }                 }                 if (indexMetaData == null) {                     indexRequest.setPipeline(IngestService.NOOP_PIPELINE_NAME).                 } else {                     String defaultPipeline = IndexSettings.DEFAULT_PIPELINE.get(indexMetaData.getSettings()).                     indexRequest.setPipeline(defaultPipeline).                     if (IngestService.NOOP_PIPELINE_NAME.equals(defaultPipeline) == false) {                         hasIndexRequestsWithPipelines = true.                     }                 }             } else if (IngestService.NOOP_PIPELINE_NAME.equals(pipeline) == false) {                 hasIndexRequestsWithPipelines = true.             }         }     }     if (hasIndexRequestsWithPipelines) {         try {             if (clusterService.localNode().isIngestNode()) {                 processBulkIndexIngestRequest(task, bulkRequest, listener).             } else {                 ingestForwarder.forwardIngestRequest(BulkAction.INSTANCE, bulkRequest, listener).             }         } catch (Exception e) {             listener.onFailure(e).         }     } else {         executeBulk(task, bulkRequest, startTimeNanos, listener, responses, indicesThatCannotBeCreated).     } }
false;;0;3;;boolean needToCheck() {     return autoCreateIndex.needToCheck(). }
false;;2;3;;boolean shouldAutoCreate(String index, ClusterState state) {     return autoCreateIndex.shouldAutoCreate(index, state). }
false;;3;7;;void createIndex(String index, TimeValue timeout, ActionListener<CreateIndexResponse> listener) {     CreateIndexRequest createIndexRequest = new CreateIndexRequest().     createIndexRequest.index(index).     createIndexRequest.cause("auto(bulk api)").     createIndexRequest.masterNodeTimeout(timeout).     client.admin().indices().create(createIndexRequest, listener). }
false;private;5;9;;private boolean setResponseFailureIfIndexMatches(AtomicArray<BulkItemResponse> responses, int idx, DocWriteRequest<?> request, String index, Exception e) {     if (index.equals(request.index())) {         responses.set(idx, new BulkItemResponse(idx, request.opType(), new BulkItemResponse.Failure(request.index(), request.type(), request.id(), e))).         return true.     }     return false. }
false;private;1;3;;private long buildTookInMillis(long startTimeNanos) {     return TimeUnit.NANOSECONDS.toMillis(relativeTime() - startTimeNanos). }
false;public;1;4;;@Override public void onFailure(Exception e) {     listener.onFailure(e). }
false;public;1;13;;@Override public void onResponse(BulkShardResponse bulkShardResponse) {     for (BulkItemResponse bulkItemResponse : bulkShardResponse.getResponses()) {         // we may have no response if item failed         if (bulkItemResponse.getResponse() != null) {             bulkItemResponse.getResponse().setShardInfo(bulkShardResponse.getShardInfo()).         }         responses.set(bulkItemResponse.getItemId(), bulkItemResponse).     }     if (counter.decrementAndGet() == 0) {         finishHim().     } }
false;public;1;13;;@Override public void onFailure(Exception e) {     // create failures for all relevant requests     for (BulkItemRequest request : requests) {         final String indexName = concreteIndices.getConcreteIndex(request.index()).getName().         DocWriteRequest<?> docWriteRequest = request.request().         responses.set(request.id(), new BulkItemResponse(request.id(), docWriteRequest.opType(), new BulkItemResponse.Failure(indexName, docWriteRequest.type(), docWriteRequest.id(), e))).     }     if (counter.decrementAndGet() == 0) {         finishHim().     } }
false;private;0;4;;private void finishHim() {     listener.onResponse(new BulkResponse(responses.toArray(new BulkItemResponse[responses.length()]), buildTookInMillis(startTimeNanos))). }
false;protected;0;120;;@Override protected void doRun() throws Exception {     final ClusterState clusterState = observer.setAndGetObservedState().     if (handleBlockExceptions(clusterState)) {         return.     }     final ConcreteIndices concreteIndices = new ConcreteIndices(clusterState, indexNameExpressionResolver).     MetaData metaData = clusterState.metaData().     for (int i = 0. i < bulkRequest.requests.size(). i++) {         DocWriteRequest<?> docWriteRequest = bulkRequest.requests.get(i).         // the request can only be null because we set it to null in the previous step, so it gets ignored         if (docWriteRequest == null) {             continue.         }         if (addFailureIfIndexIsUnavailable(docWriteRequest, i, concreteIndices, metaData)) {             continue.         }         Index concreteIndex = concreteIndices.resolveIfAbsent(docWriteRequest).         try {             switch(docWriteRequest.opType()) {                 case CREATE:                 case INDEX:                     IndexRequest indexRequest = (IndexRequest) docWriteRequest.                     final IndexMetaData indexMetaData = metaData.index(concreteIndex).                     MappingMetaData mappingMd = indexMetaData.mappingOrDefault().                     Version indexCreated = indexMetaData.getCreationVersion().                     indexRequest.resolveRouting(metaData).                     indexRequest.process(indexCreated, mappingMd, concreteIndex.getName()).                     break.                 case UPDATE:                     TransportUpdateAction.resolveAndValidateRouting(metaData, concreteIndex.getName(), (UpdateRequest) docWriteRequest).                     break.                 case DELETE:                     docWriteRequest.routing(metaData.resolveWriteIndexRouting(docWriteRequest.routing(), docWriteRequest.index())).                     // check if routing is required, if so, throw error if routing wasn't specified                     if (docWriteRequest.routing() == null && metaData.routingRequired(concreteIndex.getName())) {                         throw new RoutingMissingException(concreteIndex.getName(), docWriteRequest.type(), docWriteRequest.id()).                     }                     break.                 default:                     throw new AssertionError("request type not supported: [" + docWriteRequest.opType() + "]").             }         } catch (ElasticsearchParseException | IllegalArgumentException | RoutingMissingException e) {             BulkItemResponse.Failure failure = new BulkItemResponse.Failure(concreteIndex.getName(), docWriteRequest.type(), docWriteRequest.id(), e).             BulkItemResponse bulkItemResponse = new BulkItemResponse(i, docWriteRequest.opType(), failure).             responses.set(i, bulkItemResponse).             // make sure the request gets never processed again             bulkRequest.requests.set(i, null).         }     }     // first, go over all the requests and create a ShardId -> Operations mapping     Map<ShardId, List<BulkItemRequest>> requestsByShard = new HashMap<>().     for (int i = 0. i < bulkRequest.requests.size(). i++) {         DocWriteRequest<?> request = bulkRequest.requests.get(i).         if (request == null) {             continue.         }         String concreteIndex = concreteIndices.getConcreteIndex(request.index()).getName().         ShardId shardId = clusterService.operationRouting().indexShards(clusterState, concreteIndex, request.id(), request.routing()).shardId().         List<BulkItemRequest> shardRequests = requestsByShard.computeIfAbsent(shardId, shard -> new ArrayList<>()).         shardRequests.add(new BulkItemRequest(i, request)).     }     if (requestsByShard.isEmpty()) {         listener.onResponse(new BulkResponse(responses.toArray(new BulkItemResponse[responses.length()]), buildTookInMillis(startTimeNanos))).         return.     }     final AtomicInteger counter = new AtomicInteger(requestsByShard.size()).     String nodeId = clusterService.localNode().getId().     for (Map.Entry<ShardId, List<BulkItemRequest>> entry : requestsByShard.entrySet()) {         final ShardId shardId = entry.getKey().         final List<BulkItemRequest> requests = entry.getValue().         BulkShardRequest bulkShardRequest = new BulkShardRequest(shardId, bulkRequest.getRefreshPolicy(), requests.toArray(new BulkItemRequest[requests.size()])).         bulkShardRequest.waitForActiveShards(bulkRequest.waitForActiveShards()).         bulkShardRequest.timeout(bulkRequest.timeout()).         if (task != null) {             bulkShardRequest.setParentTask(nodeId, task.getId()).         }         shardBulkAction.execute(bulkShardRequest, new ActionListener<BulkShardResponse>() {              @Override             public void onResponse(BulkShardResponse bulkShardResponse) {                 for (BulkItemResponse bulkItemResponse : bulkShardResponse.getResponses()) {                     // we may have no response if item failed                     if (bulkItemResponse.getResponse() != null) {                         bulkItemResponse.getResponse().setShardInfo(bulkShardResponse.getShardInfo()).                     }                     responses.set(bulkItemResponse.getItemId(), bulkItemResponse).                 }                 if (counter.decrementAndGet() == 0) {                     finishHim().                 }             }              @Override             public void onFailure(Exception e) {                 // create failures for all relevant requests                 for (BulkItemRequest request : requests) {                     final String indexName = concreteIndices.getConcreteIndex(request.index()).getName().                     DocWriteRequest<?> docWriteRequest = request.request().                     responses.set(request.id(), new BulkItemResponse(request.id(), docWriteRequest.opType(), new BulkItemResponse.Failure(indexName, docWriteRequest.type(), docWriteRequest.id(), e))).                 }                 if (counter.decrementAndGet() == 0) {                     finishHim().                 }             }              private void finishHim() {                 listener.onResponse(new BulkResponse(responses.toArray(new BulkItemResponse[responses.length()]), buildTookInMillis(startTimeNanos))).             }         }).     } }
false;private;1;13;;private boolean handleBlockExceptions(ClusterState state) {     ClusterBlockException blockException = state.blocks().globalBlockedException(ClusterBlockLevel.WRITE).     if (blockException != null) {         if (blockException.retryable()) {             logger.trace("cluster is blocked, scheduling a retry", blockException).             retry(blockException).         } else {             onFailure(blockException).         }         return true.     }     return false. }
false;public;1;4;;@Override public void onNewClusterState(ClusterState state) {     run(). }
false;public;0;4;;@Override public void onClusterServiceClose() {     onFailure(new NodeClosedException(clusterService.localNode())). }
false;public;1;5;;@Override public void onTimeout(TimeValue timeout) {     // Try one more time...     run(). }
false;;1;25;;void retry(Exception failure) {     assert failure != null.     if (observer.isTimedOut()) {         // we running as a last attempt after a timeout has happened. don't retry         onFailure(failure).         return.     }     observer.waitForNextChange(new ClusterStateObserver.Listener() {          @Override         public void onNewClusterState(ClusterState state) {             run().         }          @Override         public void onClusterServiceClose() {             onFailure(new NodeClosedException(clusterService.localNode())).         }          @Override         public void onTimeout(TimeValue timeout) {             // Try one more time...             run().         }     }). }
false;private;4;23;;private boolean addFailureIfIndexIsUnavailable(DocWriteRequest<?> request, int idx, final ConcreteIndices concreteIndices, final MetaData metaData) {     IndexNotFoundException cannotCreate = indicesThatCannotBeCreated.get(request.index()).     if (cannotCreate != null) {         addFailure(request, idx, cannotCreate).         return true.     }     Index concreteIndex = concreteIndices.getConcreteIndex(request.index()).     if (concreteIndex == null) {         try {             concreteIndex = concreteIndices.resolveIfAbsent(request).         } catch (IndexClosedException | IndexNotFoundException ex) {             addFailure(request, idx, ex).             return true.         }     }     IndexMetaData indexMetaData = metaData.getIndexSafe(concreteIndex).     if (indexMetaData.getState() == IndexMetaData.State.CLOSE) {         addFailure(request, idx, new IndexClosedException(concreteIndex)).         return true.     }     return false. }
false;private;3;8;;private void addFailure(DocWriteRequest<?> request, int idx, Exception unavailableException) {     BulkItemResponse.Failure failure = new BulkItemResponse.Failure(request.index(), request.type(), request.id(), unavailableException).     BulkItemResponse bulkItemResponse = new BulkItemResponse(idx, request.opType(), failure).     responses.set(idx, bulkItemResponse).     // make sure the request gets never processed again     bulkRequest.requests.set(idx, null). }
false;;6;4;;void executeBulk(Task task, final BulkRequest bulkRequest, final long startTimeNanos, final ActionListener<BulkResponse> listener, final AtomicArray<BulkItemResponse> responses, Map<String, IndexNotFoundException> indicesThatCannotBeCreated) {     new BulkOperation(task, bulkRequest, listener, responses, startTimeNanos, indicesThatCannotBeCreated).run(). }
false;;1;3;;Index getConcreteIndex(String indexOrAlias) {     return indices.get(indexOrAlias). }
false;;1;8;;Index resolveIfAbsent(DocWriteRequest<?> request) {     Index concreteIndex = indices.get(request.index()).     if (concreteIndex == null) {         concreteIndex = indexNameExpressionResolver.concreteWriteIndex(state, request).         indices.put(request.index(), concreteIndex).     }     return concreteIndex. }
false;private;0;3;;private long relativeTime() {     return relativeTimeProvider.getAsLong(). }
false;;3;29;;void processBulkIndexIngestRequest(Task task, BulkRequest original, ActionListener<BulkResponse> listener) {     long ingestStartTimeInNanos = System.nanoTime().     BulkRequestModifier bulkRequestModifier = new BulkRequestModifier(original).     ingestService.executeBulkRequest(() -> bulkRequestModifier, (indexRequest, exception) -> {         logger.debug(() -> new ParameterizedMessage("failed to execute pipeline [{}] for document [{}/{}/{}]", indexRequest.getPipeline(), indexRequest.index(), indexRequest.type(), indexRequest.id()), exception).         bulkRequestModifier.markCurrentItemAsFailed(exception).     }, (exception) -> {         if (exception != null) {             logger.error("failed to execute pipeline for a bulk request", exception).             listener.onFailure(exception).         } else {             long ingestTookInMillis = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - ingestStartTimeInNanos).             BulkRequest bulkRequest = bulkRequestModifier.getBulkRequest().             ActionListener<BulkResponse> actionListener = bulkRequestModifier.wrapActionListenerIfNeeded(ingestTookInMillis, listener).             if (bulkRequest.requests().isEmpty()) {                 // at this stage, the transport bulk action can't deal with a bulk request with no requests,                 // so we stop and send an empty response back to the client.                 // (this will happen if pre-processing all items in the bulk failed)                 actionListener.onResponse(new BulkResponse(new BulkItemResponse[0], 0)).             } else {                 doExecute(task, bulkRequest, actionListener).             }         }     }, indexRequest -> bulkRequestModifier.markCurrentItemAsDropped()). }
false;public;0;4;;@Override public DocWriteRequest<?> next() {     return bulkRequest.requests().get(++currentSlot). }
false;public;0;4;;@Override public boolean hasNext() {     return (currentSlot + 1) < bulkRequest.requests().size(). }
false;;0;22;;BulkRequest getBulkRequest() {     if (itemResponses.isEmpty()) {         return bulkRequest.     } else {         BulkRequest modifiedBulkRequest = new BulkRequest().         modifiedBulkRequest.setRefreshPolicy(bulkRequest.getRefreshPolicy()).         modifiedBulkRequest.waitForActiveShards(bulkRequest.waitForActiveShards()).         modifiedBulkRequest.timeout(bulkRequest.timeout()).         int slot = 0.         List<DocWriteRequest<?>> requests = bulkRequest.requests().         // oversize, but that's ok         originalSlots = new int[requests.size()].         for (int i = 0. i < requests.size(). i++) {             DocWriteRequest<?> request = requests.get(i).             if (failedSlots.get(i) == false) {                 modifiedBulkRequest.add(request).                 originalSlots[slot++] = i.             }         }         return modifiedBulkRequest.     } }
false;;2;10;;ActionListener<BulkResponse> wrapActionListenerIfNeeded(long ingestTookInMillis, ActionListener<BulkResponse> actionListener) {     if (itemResponses.isEmpty()) {         return ActionListener.wrap(response -> actionListener.onResponse(new BulkResponse(response.getItems(), response.getTook().getMillis(), ingestTookInMillis)), actionListener::onFailure).     } else {         return new IngestBulkResponseListener(ingestTookInMillis, originalSlots, itemResponses, actionListener).     } }
false;;0;12;;void markCurrentItemAsDropped() {     IndexRequest indexRequest = getIndexWriteRequest(bulkRequest.requests().get(currentSlot)).     failedSlots.set(currentSlot).     itemResponses.add(new BulkItemResponse(currentSlot, indexRequest.opType(), new UpdateResponse(new ShardId(indexRequest.index(), IndexMetaData.INDEX_UUID_NA_VALUE, 0), indexRequest.type(), indexRequest.id(), indexRequest.version(), DocWriteResponse.Result.NOOP))). }
false;;1;11;;void markCurrentItemAsFailed(Exception e) {     IndexRequest indexRequest = getIndexWriteRequest(bulkRequest.requests().get(currentSlot)).     // We hit a error during preprocessing a request, so we:     // 1) Remember the request item slot from the bulk, so that we're done processing all requests we know what failed     // 2) Add a bulk item failure for this request     // 3) Continue with the next request in the bulk.     failedSlots.set(currentSlot).     BulkItemResponse.Failure failure = new BulkItemResponse.Failure(indexRequest.index(), indexRequest.type(), indexRequest.id(), e).     itemResponses.add(new BulkItemResponse(currentSlot, indexRequest.opType(), failure)). }
false;public;1;10;;@Override public void onResponse(BulkResponse response) {     BulkItemResponse[] items = response.getItems().     for (int i = 0. i < items.length. i++) {         itemResponses.add(originalSlots[i], response.getItems()[i]).     }     actionListener.onResponse(new BulkResponse(itemResponses.toArray(new BulkItemResponse[itemResponses.size()]), response.getTook().getMillis(), ingestTookInMillis)). }
false;public;1;4;;@Override public void onFailure(Exception e) {     actionListener.onFailure(e). }
