commented;modifiers;parameterAmount;loc;comment;code
false;public;0;5;;@Override public void doClose() {     // clear and scope phase we have     Releasables.close(searcher, engineSearcher). }
true;public;1;71;/**  * Should be called before executing the main query and after all other parameters have been set.  */ ;/**  * Should be called before executing the main query and after all other parameters have been set.  */ @Override public void preProcess(boolean rewrite) {     if (hasOnlySuggest()) {         return.     }     long from = from() == -1 ? 0 : from().     long size = size() == -1 ? 10 : size().     long resultWindow = from + size.     int maxResultWindow = indexService.getIndexSettings().getMaxResultWindow().     if (resultWindow > maxResultWindow) {         if (scrollContext == null) {             throw new IllegalArgumentException("Result window is too large, from + size must be less than or equal to: [" + maxResultWindow + "] but was [" + resultWindow + "]. See the scroll api for a more efficient way to request large data sets. " + "This limit can be set by changing the [" + IndexSettings.MAX_RESULT_WINDOW_SETTING.getKey() + "] index level setting.").         }         throw new IllegalArgumentException("Batch size is too large, size must be less than or equal to: [" + maxResultWindow + "] but was [" + resultWindow + "]. Scroll batch sizes cost as much memory as result windows so they are controlled by the [" + IndexSettings.MAX_RESULT_WINDOW_SETTING.getKey() + "] index level setting.").     }     if (rescore != null) {         if (sort != null) {             throw new IllegalArgumentException("Cannot use [sort] option in conjunction with [rescore].").         }         int maxWindow = indexService.getIndexSettings().getMaxRescoreWindow().         for (RescoreContext rescoreContext : rescore) {             if (rescoreContext.getWindowSize() > maxWindow) {                 throw new IllegalArgumentException("Rescore window [" + rescoreContext.getWindowSize() + "] is too large. " + "It must be less than [" + maxWindow + "]. This prevents allocating massive heaps for storing the results " + "to be rescored. This limit can be set by changing the [" + IndexSettings.MAX_RESCORE_WINDOW_SETTING.getKey() + "] index level setting.").             }         }     }     if (sliceBuilder != null) {         int sliceLimit = indexService.getIndexSettings().getMaxSlicesPerScroll().         int numSlices = sliceBuilder.getMax().         if (numSlices > sliceLimit) {             throw new IllegalArgumentException("The number of slices [" + numSlices + "] is too large. It must " + "be less than [" + sliceLimit + "]. This limit can be set by changing the [" + IndexSettings.MAX_SLICES_PER_SCROLL.getKey() + "] index level setting.").         }     }     // initialize the filtering alias based on the provided filters     try {         final QueryBuilder queryBuilder = request.getAliasFilter().getQueryBuilder().         aliasFilter = queryBuilder == null ? null : queryBuilder.toQuery(queryShardContext).     } catch (IOException e) {         throw new UncheckedIOException(e).     }     if (query() == null) {         parsedQuery(ParsedQuery.parsedMatchAllQuery()).     }     if (queryBoost() != AbstractQueryBuilder.DEFAULT_BOOST) {         parsedQuery(new ParsedQuery(new FunctionScoreQuery(query(), new WeightFactorFunction(queryBoost)), parsedQuery())).     }     this.query = buildFilteredQuery(query).     if (rewrite) {         try {             this.query = searcher.rewrite(query).         } catch (IOException e) {             throw new QueryPhaseExecutionException(this, "Failed to rewrite main query", e).         }     } }
false;public;1;34;;@Override public Query buildFilteredQuery(Query query) {     List<Query> filters = new ArrayList<>().     Query typeFilter = createTypeFilter(queryShardContext.getTypes()).     if (typeFilter != null) {         filters.add(typeFilter).     }     if (mapperService().hasNested() && // when a _type filter is set, it will automatically exclude nested docs     typeFilter == null && new NestedHelper(mapperService()).mightMatchNestedDocs(query) && (aliasFilter == null || new NestedHelper(mapperService()).mightMatchNestedDocs(aliasFilter))) {         filters.add(Queries.newNonNestedFilter(mapperService().getIndexSettings().getIndexVersionCreated())).     }     if (aliasFilter != null) {         filters.add(aliasFilter).     }     if (sliceBuilder != null) {         filters.add(sliceBuilder.toFilter(clusterService, request, queryShardContext, minNodeVersion)).     }     if (filters.isEmpty()) {         return query.     } else {         BooleanQuery.Builder builder = new BooleanQuery.Builder().         builder.add(query, Occur.MUST).         for (Query filter : filters) {             builder.add(filter, Occur.FILTER).         }         return builder.build().     } }
false;private;1;10;;private Query createTypeFilter(String[] types) {     if (types != null && types.length >= 1) {         MappedFieldType ft = mapperService().fullName(TypeFieldMapper.NAME).         if (ft != null) {             // ft might be null if no documents have been indexed yet             return ft.termsQuery(Arrays.asList(types), queryShardContext).         }     }     return null. }
false;public;0;4;;@Override public long id() {     return this.id. }
false;public;0;4;;@Override public String source() {     return engineSearcher.source(). }
false;public;0;4;;@Override public ShardSearchRequest request() {     return this.request. }
false;public;0;4;;@Override public SearchType searchType() {     return this.searchType. }
false;public;0;4;;@Override public SearchShardTarget shardTarget() {     return this.shardTarget. }
false;public;0;4;;@Override public int numberOfShards() {     return request.numberOfShards(). }
false;public;0;4;;@Override public float queryBoost() {     return queryBoost. }
false;public;0;4;;@Override public long getOriginNanoTime() {     return originNanoTime. }
false;public;0;4;;@Override public ScrollContext scrollContext() {     return this.scrollContext. }
false;public;1;5;;@Override public SearchContext scrollContext(ScrollContext scrollContext) {     this.scrollContext = scrollContext.     return this. }
false;public;0;4;;@Override public SearchContextAggregations aggregations() {     return aggregations. }
false;public;1;5;;@Override public SearchContext aggregations(SearchContextAggregations aggregations) {     this.aggregations = aggregations.     return this. }
false;public;1;6;;@Override public void addSearchExt(SearchExtBuilder searchExtBuilder) {     // it's ok to use the writeable name here given that we enforce it to be the same as the name of the element that gets     // parsed by the corresponding parser. There is one single name and one single way to retrieve the parsed object from the context.     searchExtBuilders.put(searchExtBuilder.getWriteableName(), searchExtBuilder). }
false;public;1;4;;@Override public SearchExtBuilder getSearchExt(String name) {     return searchExtBuilders.get(name). }
false;public;0;4;;@Override public SearchContextHighlight highlight() {     return highlight. }
false;public;1;4;;@Override public void highlight(SearchContextHighlight highlight) {     this.highlight = highlight. }
false;public;0;4;;@Override public SuggestionSearchContext suggest() {     return suggest. }
false;public;1;4;;@Override public void suggest(SuggestionSearchContext suggest) {     this.suggest = suggest. }
false;public;0;7;;@Override public List<RescoreContext> rescore() {     if (rescore == null) {         return Collections.emptyList().     }     return rescore. }
false;public;1;7;;@Override public void addRescore(RescoreContext rescore) {     if (this.rescore == null) {         this.rescore = new ArrayList<>().     }     this.rescore.add(rescore). }
false;public;0;4;;@Override public boolean hasScriptFields() {     return scriptFields != null. }
false;public;0;7;;@Override public ScriptFieldsContext scriptFields() {     if (scriptFields == null) {         scriptFields = new ScriptFieldsContext().     }     return this.scriptFields. }
true;public;0;4;/**  * A shortcut function to see whether there is a fetchSourceContext and it says the source is requested.  */ ;/**  * A shortcut function to see whether there is a fetchSourceContext and it says the source is requested.  */ @Override public boolean sourceRequested() {     return fetchSourceContext != null && fetchSourceContext.fetchSource(). }
false;public;0;4;;@Override public boolean hasFetchSourceContext() {     return fetchSourceContext != null. }
false;public;0;4;;@Override public FetchSourceContext fetchSourceContext() {     return this.fetchSourceContext. }
false;public;1;5;;@Override public SearchContext fetchSourceContext(FetchSourceContext fetchSourceContext) {     this.fetchSourceContext = fetchSourceContext.     return this. }
false;public;0;4;;@Override public DocValueFieldsContext docValueFieldsContext() {     return docValueFieldsContext. }
false;public;1;5;;@Override public SearchContext docValueFieldsContext(DocValueFieldsContext docValueFieldsContext) {     this.docValueFieldsContext = docValueFieldsContext.     return this. }
false;public;0;4;;@Override public ContextIndexSearcher searcher() {     return this.searcher. }
false;public;0;4;;@Override public IndexShard indexShard() {     return this.indexShard. }
false;public;0;4;;@Override public MapperService mapperService() {     return indexService.mapperService(). }
false;public;0;4;;@Override public SimilarityService similarityService() {     return indexService.similarityService(). }
false;public;0;4;;@Override public BigArrays bigArrays() {     return bigArrays. }
false;public;0;4;;@Override public BitsetFilterCache bitsetFilterCache() {     return indexService.cache().bitsetFilterCache(). }
false;public;1;4;;@Override public <IFD extends IndexFieldData<?>> IFD getForField(MappedFieldType fieldType) {     return queryShardContext.getForField(fieldType). }
false;public;0;4;;@Override public TimeValue timeout() {     return timeout. }
false;public;1;4;;@Override public void timeout(TimeValue timeout) {     this.timeout = timeout. }
false;public;0;4;;@Override public int terminateAfter() {     return terminateAfter. }
false;public;1;4;;@Override public void terminateAfter(int terminateAfter) {     this.terminateAfter = terminateAfter. }
false;public;1;5;;@Override public SearchContext minimumScore(float minimumScore) {     this.minimumScore = minimumScore.     return this. }
false;public;0;4;;@Override public Float minimumScore() {     return this.minimumScore. }
false;public;1;5;;@Override public SearchContext sort(SortAndFormats sort) {     this.sort = sort.     return this. }
false;public;0;4;;@Override public SortAndFormats sort() {     return this.sort. }
false;public;1;5;;@Override public SearchContext trackScores(boolean trackScores) {     this.trackScores = trackScores.     return this. }
false;public;0;4;;@Override public boolean trackScores() {     return this.trackScores. }
false;public;1;5;;@Override public SearchContext trackTotalHitsUpTo(int trackTotalHitsUpTo) {     this.trackTotalHitsUpTo = trackTotalHitsUpTo.     return this. }
false;public;0;4;;@Override public int trackTotalHitsUpTo() {     return trackTotalHitsUpTo. }
false;public;1;5;;@Override public SearchContext searchAfter(FieldDoc searchAfter) {     this.searchAfter = searchAfter.     return this. }
false;public;0;4;;@Override public boolean lowLevelCancellation() {     return lowLevelCancellation. }
false;public;1;3;;public void lowLevelCancellation(boolean lowLevelCancellation) {     this.lowLevelCancellation = lowLevelCancellation. }
false;public;0;4;;@Override public FieldDoc searchAfter() {     return searchAfter. }
false;public;1;5;;@Override public SearchContext collapse(CollapseContext collapse) {     this.collapse = collapse.     return this. }
false;public;0;4;;@Override public CollapseContext collapse() {     return collapse. }
false;public;1;4;;public SearchContext sliceBuilder(SliceBuilder sliceBuilder) {     this.sliceBuilder = sliceBuilder.     return this. }
false;public;1;5;;@Override public SearchContext parsedPostFilter(ParsedQuery postFilter) {     this.postFilter = postFilter.     return this. }
false;public;0;4;;@Override public ParsedQuery parsedPostFilter() {     return this.postFilter. }
false;public;0;4;;@Override public Query aliasFilter() {     return aliasFilter. }
false;public;1;6;;@Override public SearchContext parsedQuery(ParsedQuery query) {     this.originalQuery = query.     this.query = query.query().     return this. }
false;public;0;4;;@Override public ParsedQuery parsedQuery() {     return this.originalQuery. }
true;public;0;4;/**  * The query to execute, in its rewritten form.  */ ;/**  * The query to execute, in its rewritten form.  */ @Override public Query query() {     return this.query. }
false;public;0;4;;@Override public int from() {     return from. }
false;public;1;5;;@Override public SearchContext from(int from) {     this.from = from.     return this. }
false;public;0;4;;@Override public int size() {     return size. }
false;public;1;5;;@Override public SearchContext size(int size) {     this.size = size.     return this. }
false;public;0;4;;@Override public boolean hasStoredFields() {     return storedFields != null && storedFields.fieldNames() != null. }
false;public;0;4;;@Override public boolean hasStoredFieldsContext() {     return storedFields != null. }
false;public;0;4;;@Override public StoredFieldsContext storedFieldsContext() {     return storedFields. }
false;public;1;5;;@Override public SearchContext storedFieldsContext(StoredFieldsContext storedFieldsContext) {     this.storedFields = storedFieldsContext.     return this. }
false;public;0;4;;@Override public boolean storedFieldsRequested() {     return storedFields == null || storedFields.fetchFields(). }
false;public;0;4;;@Override public boolean explain() {     return explain. }
false;public;1;4;;@Override public void explain(boolean explain) {     this.explain = explain. }
false;public;0;5;;@Override @Nullable public List<String> groupStats() {     return this.groupStats. }
false;public;1;4;;@Override public void groupStats(List<String> groupStats) {     this.groupStats = groupStats. }
false;public;0;4;;@Override public boolean version() {     return version. }
false;public;1;4;;@Override public void version(boolean version) {     this.version = version. }
false;public;0;4;;@Override public boolean seqNoAndPrimaryTerm() {     return seqAndPrimaryTerm. }
false;public;1;4;;@Override public void seqNoAndPrimaryTerm(boolean seqNoAndPrimaryTerm) {     this.seqAndPrimaryTerm = seqNoAndPrimaryTerm. }
false;public;0;4;;@Override public int[] docIdsToLoad() {     return docIdsToLoad. }
false;public;0;4;;@Override public int docIdsToLoadFrom() {     return docsIdsToLoadFrom. }
false;public;0;4;;@Override public int docIdsToLoadSize() {     return docsIdsToLoadSize. }
false;public;3;7;;@Override public SearchContext docIdsToLoad(int[] docIdsToLoad, int docsIdsToLoadFrom, int docsIdsToLoadSize) {     this.docIdsToLoad = docIdsToLoad.     this.docsIdsToLoadFrom = docsIdsToLoadFrom.     this.docsIdsToLoadSize = docsIdsToLoadSize.     return this. }
false;public;1;4;;@Override public void accessed(long accessTime) {     this.lastAccessTime = accessTime. }
false;public;0;4;;@Override public long lastAccessTime() {     return this.lastAccessTime. }
false;public;0;4;;@Override public long keepAlive() {     return this.keepAlive. }
false;public;1;4;;@Override public void keepAlive(long keepAlive) {     this.keepAlive = keepAlive. }
false;public;0;4;;@Override public DfsSearchResult dfsResult() {     return dfsResult. }
false;public;0;4;;@Override public QuerySearchResult queryResult() {     return queryResult. }
false;public;0;4;;@Override public FetchPhase fetchPhase() {     return fetchPhase. }
false;public;0;4;;@Override public FetchSearchResult fetchResult() {     return fetchResult. }
false;public;1;4;;@Override public MappedFieldType smartNameFieldType(String name) {     return mapperService().fullName(name). }
false;public;1;4;;@Override public ObjectMapper getObjectMapper(String name) {     return mapperService().getObjectMapper(name). }
false;public;0;4;;@Override public long getRelativeTimeInMillis() {     return relativeTimeSupplier.getAsLong(). }
false;public;0;4;;@Override public Map<Class<?>, Collector> queryCollectors() {     return queryCollectors. }
false;public;0;4;;@Override public QueryShardContext getQueryShardContext() {     return queryShardContext. }
false;public;0;4;;@Override public Profilers getProfilers() {     return profilers. }
false;public;1;3;;public void setProfilers(Profilers profilers) {     this.profilers = profilers. }
false;public;1;4;;@Override public void setTask(SearchTask task) {     this.task = task. }
false;public;0;4;;@Override public SearchTask getTask() {     return task. }
false;public;0;4;;@Override public boolean isCancelled() {     return task.isCancelled(). }
