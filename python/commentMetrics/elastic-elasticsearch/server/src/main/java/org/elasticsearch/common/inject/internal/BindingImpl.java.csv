commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public Key<T> getKey() {     return key. }
false;public;0;4;;@Override public Object getSource() {     return source. }
false;public;0;11;;@Override public Provider<T> getProvider() {     if (provider == null) {         if (injector == null) {             throw new UnsupportedOperationException("getProvider() not supported for module bindings").         }         provider = injector.getProvider(key).     }     return provider. }
false;public;0;3;;public InternalFactory<? extends T> getInternalFactory() {     return internalFactory. }
false;public;0;3;;public Scoping getScoping() {     return scoping. }
true;public;0;3;/**  * Is this a constant binding? This returns true for constant bindings as  * well as toInstance() bindings.  */ ;/**  * Is this a constant binding? This returns true for constant bindings as  * well as toInstance() bindings.  */ public boolean isConstant() {     return this instanceof InstanceBinding. }
false;public;1;4;;@Override public <V> V acceptVisitor(ElementVisitor<V> visitor) {     return visitor.visit(this). }
false;public;1;4;;@Override public <V> V acceptScopingVisitor(BindingScopingVisitor<V> visitor) {     return scoping.acceptVisitor(visitor). }
false;protected;1;3;;protected BindingImpl<T> withScoping(Scoping scoping) {     throw new AssertionError(). }
false;protected;1;3;;protected BindingImpl<T> withKey(Key<T> key) {     throw new AssertionError(). }
false;public;0;8;;@Override public String toString() {     return new ToStringBuilder(Binding.class).add("key", key).add("scope", scoping).add("source", source).toString(). }
false;public;0;3;;public Injector getInjector() {     return injector. }
