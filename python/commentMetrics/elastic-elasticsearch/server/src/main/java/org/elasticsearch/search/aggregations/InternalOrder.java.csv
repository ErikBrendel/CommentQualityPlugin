# id;timestamp;commentText;codeText;commentWords;codeWords
InternalOrder -> public static boolean isKeyDesc(BucketOrder order);1524684173;Determine if the ordering strategy is sorting on bucket key descending.__@param order bucket ordering strategy to check._@return {@code true} if the ordering strategy is sorting on bucket key descending, {@code false} otherwise.;public static boolean isKeyDesc(BucketOrder order) {_        return isOrder(order, KEY_DESC)__    };determine,if,the,ordering,strategy,is,sorting,on,bucket,key,descending,param,order,bucket,ordering,strategy,to,check,return,code,true,if,the,ordering,strategy,is,sorting,on,bucket,key,descending,code,false,otherwise;public,static,boolean,is,key,desc,bucket,order,order,return,is,order,order
InternalOrder -> public static boolean isKeyDesc(BucketOrder order);1537806831;Determine if the ordering strategy is sorting on bucket key descending.__@param order bucket ordering strategy to check._@return {@code true} if the ordering strategy is sorting on bucket key descending, {@code false} otherwise.;public static boolean isKeyDesc(BucketOrder order) {_        return isOrder(order, KEY_DESC)__    };determine,if,the,ordering,strategy,is,sorting,on,bucket,key,descending,param,order,bucket,ordering,strategy,to,check,return,code,true,if,the,ordering,strategy,is,sorting,on,bucket,key,descending,code,false,otherwise;public,static,boolean,is,key,desc,bucket,order,order,return,is,order,order
InternalOrder -> public static boolean isKeyDesc(BucketOrder order);1540486836;Determine if the ordering strategy is sorting on bucket key descending.__@param order bucket ordering strategy to check._@return {@code true} if the ordering strategy is sorting on bucket key descending, {@code false} otherwise.;public static boolean isKeyDesc(BucketOrder order) {_        return isOrder(order, KEY_DESC)__    };determine,if,the,ordering,strategy,is,sorting,on,bucket,key,descending,param,order,bucket,ordering,strategy,to,check,return,code,true,if,the,ordering,strategy,is,sorting,on,bucket,key,descending,code,false,otherwise;public,static,boolean,is,key,desc,bucket,order,order,return,is,order,order
InternalOrder -> public static boolean isKeyDesc(BucketOrder order);1540583181;Determine if the ordering strategy is sorting on bucket key descending.__@param order bucket ordering strategy to check._@return {@code true} if the ordering strategy is sorting on bucket key descending, {@code false} otherwise.;public static boolean isKeyDesc(BucketOrder order) {_        return isOrder(order, KEY_DESC)__    };determine,if,the,ordering,strategy,is,sorting,on,bucket,key,descending,param,order,bucket,ordering,strategy,to,check,return,code,true,if,the,ordering,strategy,is,sorting,on,bucket,key,descending,code,false,otherwise;public,static,boolean,is,key,desc,bucket,order,order,return,is,order,order
InternalOrder -> Parser -> public static BucketOrder parseOrderParam(XContentParser parser) throws IOException;1524684173;Parse a {@link BucketOrder} from {@link XContent}.__@param parser  for parsing {@link XContent} that contains the order._@return bucket ordering strategy_@throws IOException on error a {@link XContent} parsing error.;public static BucketOrder parseOrderParam(XContentParser parser) throws IOException {_            XContentParser.Token token__            String orderKey = null__            boolean orderAsc = false__            while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {_                if (token == XContentParser.Token.FIELD_NAME) {_                    orderKey = parser.currentName()__                } else if (token == XContentParser.Token.VALUE_STRING) {_                    String dir = parser.text()__                    if ("asc".equalsIgnoreCase(dir)) {_                        orderAsc = true__                    } else if ("desc".equalsIgnoreCase(dir)) {_                        orderAsc = false__                    } else {_                        throw new ParsingException(parser.getTokenLocation(),_                            "Unknown order direction [" + dir + "]")__                    }_                } else {_                    throw new ParsingException(parser.getTokenLocation(),_                        "Unexpected token [" + token + "] for [order]")__                }_            }_            if (orderKey == null) {_                throw new ParsingException(parser.getTokenLocation(),_                    "Must specify at least one field for [order]")__            }_            _            if ("_term".equals(orderKey) || "_time".equals(orderKey)) {_                DEPRECATION_LOGGER.deprecated("Deprecated aggregation order key [{}] used, replaced by [_key]", orderKey)__            }_            switch (orderKey) {_                case "_term":_                case "_time":_                case "_key":_                    return orderAsc ? KEY_ASC : KEY_DESC__                case "_count":_                    return orderAsc ? COUNT_ASC : COUNT_DESC__                default: _                    return aggregation(orderKey, orderAsc)__            }_        };parse,a,link,bucket,order,from,link,xcontent,param,parser,for,parsing,link,xcontent,that,contains,the,order,return,bucket,ordering,strategy,throws,ioexception,on,error,a,link,xcontent,parsing,error;public,static,bucket,order,parse,order,param,xcontent,parser,parser,throws,ioexception,xcontent,parser,token,token,string,order,key,null,boolean,order,asc,false,while,token,parser,next,token,xcontent,parser,token,if,token,xcontent,parser,token,order,key,parser,current,name,else,if,token,xcontent,parser,token,string,dir,parser,text,if,asc,equals,ignore,case,dir,order,asc,true,else,if,desc,equals,ignore,case,dir,order,asc,false,else,throw,new,parsing,exception,parser,get,token,location,unknown,order,direction,dir,else,throw,new,parsing,exception,parser,get,token,location,unexpected,token,token,for,order,if,order,key,null,throw,new,parsing,exception,parser,get,token,location,must,specify,at,least,one,field,for,order,if,equals,order,key,equals,order,key,deprecated,deprecated,aggregation,order,key,used,replaced,by,order,key,switch,order,key,case,case,case,return,order,asc,case,return,order,asc,default,return,aggregation,order,key,order,asc
InternalOrder -> Parser -> public static BucketOrder parseOrderParam(XContentParser parser) throws IOException;1537806831;Parse a {@link BucketOrder} from {@link XContent}.__@param parser  for parsing {@link XContent} that contains the order._@return bucket ordering strategy_@throws IOException on error a {@link XContent} parsing error.;public static BucketOrder parseOrderParam(XContentParser parser) throws IOException {_            XContentParser.Token token__            String orderKey = null__            boolean orderAsc = false__            while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {_                if (token == XContentParser.Token.FIELD_NAME) {_                    orderKey = parser.currentName()__                } else if (token == XContentParser.Token.VALUE_STRING) {_                    String dir = parser.text()__                    if ("asc".equalsIgnoreCase(dir)) {_                        orderAsc = true__                    } else if ("desc".equalsIgnoreCase(dir)) {_                        orderAsc = false__                    } else {_                        throw new ParsingException(parser.getTokenLocation(),_                            "Unknown order direction [" + dir + "]")__                    }_                } else {_                    throw new ParsingException(parser.getTokenLocation(),_                        "Unexpected token [" + token + "] for [order]")__                }_            }_            if (orderKey == null) {_                throw new ParsingException(parser.getTokenLocation(),_                    "Must specify at least one field for [order]")__            }_            _            if ("_term".equals(orderKey) || "_time".equals(orderKey)) {_                DEPRECATION_LOGGER.deprecated("Deprecated aggregation order key [{}] used, replaced by [_key]", orderKey)__            }_            switch (orderKey) {_                case "_term":_                case "_time":_                case "_key":_                    return orderAsc ? KEY_ASC : KEY_DESC__                case "_count":_                    return orderAsc ? COUNT_ASC : COUNT_DESC__                default: _                    return aggregation(orderKey, orderAsc)__            }_        };parse,a,link,bucket,order,from,link,xcontent,param,parser,for,parsing,link,xcontent,that,contains,the,order,return,bucket,ordering,strategy,throws,ioexception,on,error,a,link,xcontent,parsing,error;public,static,bucket,order,parse,order,param,xcontent,parser,parser,throws,ioexception,xcontent,parser,token,token,string,order,key,null,boolean,order,asc,false,while,token,parser,next,token,xcontent,parser,token,if,token,xcontent,parser,token,order,key,parser,current,name,else,if,token,xcontent,parser,token,string,dir,parser,text,if,asc,equals,ignore,case,dir,order,asc,true,else,if,desc,equals,ignore,case,dir,order,asc,false,else,throw,new,parsing,exception,parser,get,token,location,unknown,order,direction,dir,else,throw,new,parsing,exception,parser,get,token,location,unexpected,token,token,for,order,if,order,key,null,throw,new,parsing,exception,parser,get,token,location,must,specify,at,least,one,field,for,order,if,equals,order,key,equals,order,key,deprecated,deprecated,aggregation,order,key,used,replaced,by,order,key,switch,order,key,case,case,case,return,order,asc,case,return,order,asc,default,return,aggregation,order,key,order,asc
InternalOrder -> Parser -> public static BucketOrder parseOrderParam(XContentParser parser) throws IOException;1540486836;Parse a {@link BucketOrder} from {@link XContent}.__@param parser  for parsing {@link XContent} that contains the order._@return bucket ordering strategy_@throws IOException on error a {@link XContent} parsing error.;public static BucketOrder parseOrderParam(XContentParser parser) throws IOException {_            XContentParser.Token token__            String orderKey = null__            boolean orderAsc = false__            while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {_                if (token == XContentParser.Token.FIELD_NAME) {_                    orderKey = parser.currentName()__                } else if (token == XContentParser.Token.VALUE_STRING) {_                    String dir = parser.text()__                    if ("asc".equalsIgnoreCase(dir)) {_                        orderAsc = true__                    } else if ("desc".equalsIgnoreCase(dir)) {_                        orderAsc = false__                    } else {_                        throw new ParsingException(parser.getTokenLocation(),_                            "Unknown order direction [" + dir + "]")__                    }_                } else {_                    throw new ParsingException(parser.getTokenLocation(),_                        "Unexpected token [" + token + "] for [order]")__                }_            }_            if (orderKey == null) {_                throw new ParsingException(parser.getTokenLocation(),_                    "Must specify at least one field for [order]")__            }_            _            if ("_term".equals(orderKey) || "_time".equals(orderKey)) {_                DEPRECATION_LOGGER.deprecated("Deprecated aggregation order key [{}] used, replaced by [_key]", orderKey)__            }_            switch (orderKey) {_                case "_term":_                case "_time":_                case "_key":_                    return orderAsc ? KEY_ASC : KEY_DESC__                case "_count":_                    return orderAsc ? COUNT_ASC : COUNT_DESC__                default: _                    return aggregation(orderKey, orderAsc)__            }_        };parse,a,link,bucket,order,from,link,xcontent,param,parser,for,parsing,link,xcontent,that,contains,the,order,return,bucket,ordering,strategy,throws,ioexception,on,error,a,link,xcontent,parsing,error;public,static,bucket,order,parse,order,param,xcontent,parser,parser,throws,ioexception,xcontent,parser,token,token,string,order,key,null,boolean,order,asc,false,while,token,parser,next,token,xcontent,parser,token,if,token,xcontent,parser,token,order,key,parser,current,name,else,if,token,xcontent,parser,token,string,dir,parser,text,if,asc,equals,ignore,case,dir,order,asc,true,else,if,desc,equals,ignore,case,dir,order,asc,false,else,throw,new,parsing,exception,parser,get,token,location,unknown,order,direction,dir,else,throw,new,parsing,exception,parser,get,token,location,unexpected,token,token,for,order,if,order,key,null,throw,new,parsing,exception,parser,get,token,location,must,specify,at,least,one,field,for,order,if,equals,order,key,equals,order,key,deprecated,deprecated,aggregation,order,key,used,replaced,by,order,key,switch,order,key,case,case,case,return,order,asc,case,return,order,asc,default,return,aggregation,order,key,order,asc
InternalOrder -> Parser -> public static BucketOrder parseOrderParam(XContentParser parser) throws IOException;1540583181;Parse a {@link BucketOrder} from {@link XContent}.__@param parser  for parsing {@link XContent} that contains the order._@return bucket ordering strategy_@throws IOException on error a {@link XContent} parsing error.;public static BucketOrder parseOrderParam(XContentParser parser) throws IOException {_            XContentParser.Token token__            String orderKey = null__            boolean orderAsc = false__            while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {_                if (token == XContentParser.Token.FIELD_NAME) {_                    orderKey = parser.currentName()__                } else if (token == XContentParser.Token.VALUE_STRING) {_                    String dir = parser.text()__                    if ("asc".equalsIgnoreCase(dir)) {_                        orderAsc = true__                    } else if ("desc".equalsIgnoreCase(dir)) {_                        orderAsc = false__                    } else {_                        throw new ParsingException(parser.getTokenLocation(),_                            "Unknown order direction [" + dir + "]")__                    }_                } else {_                    throw new ParsingException(parser.getTokenLocation(),_                        "Unexpected token [" + token + "] for [order]")__                }_            }_            if (orderKey == null) {_                throw new ParsingException(parser.getTokenLocation(),_                    "Must specify at least one field for [order]")__            }_            _            if ("_term".equals(orderKey) || "_time".equals(orderKey)) {_                deprecationLogger.deprecated("Deprecated aggregation order key [{}] used, replaced by [_key]", orderKey)__            }_            switch (orderKey) {_                case "_term":_                case "_time":_                case "_key":_                    return orderAsc ? KEY_ASC : KEY_DESC__                case "_count":_                    return orderAsc ? COUNT_ASC : COUNT_DESC__                default: _                    return aggregation(orderKey, orderAsc)__            }_        };parse,a,link,bucket,order,from,link,xcontent,param,parser,for,parsing,link,xcontent,that,contains,the,order,return,bucket,ordering,strategy,throws,ioexception,on,error,a,link,xcontent,parsing,error;public,static,bucket,order,parse,order,param,xcontent,parser,parser,throws,ioexception,xcontent,parser,token,token,string,order,key,null,boolean,order,asc,false,while,token,parser,next,token,xcontent,parser,token,if,token,xcontent,parser,token,order,key,parser,current,name,else,if,token,xcontent,parser,token,string,dir,parser,text,if,asc,equals,ignore,case,dir,order,asc,true,else,if,desc,equals,ignore,case,dir,order,asc,false,else,throw,new,parsing,exception,parser,get,token,location,unknown,order,direction,dir,else,throw,new,parsing,exception,parser,get,token,location,unexpected,token,token,for,order,if,order,key,null,throw,new,parsing,exception,parser,get,token,location,must,specify,at,least,one,field,for,order,if,equals,order,key,equals,order,key,deprecation,logger,deprecated,deprecated,aggregation,order,key,used,replaced,by,order,key,switch,order,key,case,case,case,return,order,asc,case,return,order,asc,default,return,aggregation,order,key,order,asc
InternalOrder -> Aggregation -> public AggregationPath path();1524684173;@return parsed path to the sub-aggregation to sort on.;public AggregationPath path() {_            return ((AggregationComparator) comparator).path__        };return,parsed,path,to,the,sub,aggregation,to,sort,on;public,aggregation,path,path,return,aggregation,comparator,comparator,path
InternalOrder -> Aggregation -> public AggregationPath path();1537806831;@return parsed path to the sub-aggregation to sort on.;public AggregationPath path() {_            return ((AggregationComparator) comparator).path__        };return,parsed,path,to,the,sub,aggregation,to,sort,on;public,aggregation,path,path,return,aggregation,comparator,comparator,path
InternalOrder -> Aggregation -> public AggregationPath path();1540486836;@return parsed path to the sub-aggregation to sort on.;public AggregationPath path() {_            return ((AggregationComparator) comparator).path__        };return,parsed,path,to,the,sub,aggregation,to,sort,on;public,aggregation,path,path,return,aggregation,comparator,comparator,path
InternalOrder -> Aggregation -> public AggregationPath path();1540583181;@return parsed path to the sub-aggregation to sort on.;public AggregationPath path() {_            return ((AggregationComparator) comparator).path__        };return,parsed,path,to,the,sub,aggregation,to,sort,on;public,aggregation,path,path,return,aggregation,comparator,comparator,path
InternalOrder -> private static Comparator<Bucket> comparingCounts();1524684173;@return compare by {@link Bucket#getDocCount()}.;private static Comparator<Bucket> comparingCounts() {_        return Comparator.comparingLong(Bucket::getDocCount)__    };return,compare,by,link,bucket,get,doc,count;private,static,comparator,bucket,comparing,counts,return,comparator,comparing,long,bucket,get,doc,count
InternalOrder -> private static Comparator<Bucket> comparingCounts();1537806831;@return compare by {@link Bucket#getDocCount()}.;private static Comparator<Bucket> comparingCounts() {_        return Comparator.comparingLong(Bucket::getDocCount)__    };return,compare,by,link,bucket,get,doc,count;private,static,comparator,bucket,comparing,counts,return,comparator,comparing,long,bucket,get,doc,count
InternalOrder -> private static Comparator<Bucket> comparingCounts();1540486836;@return compare by {@link Bucket#getDocCount()}.;private static Comparator<Bucket> comparingCounts() {_        return Comparator.comparingLong(Bucket::getDocCount)__    };return,compare,by,link,bucket,get,doc,count;private,static,comparator,bucket,comparing,counts,return,comparator,comparing,long,bucket,get,doc,count
InternalOrder -> private static Comparator<Bucket> comparingCounts();1540583181;@return compare by {@link Bucket#getDocCount()}.;private static Comparator<Bucket> comparingCounts() {_        return Comparator.comparingLong(Bucket::getDocCount)__    };return,compare,by,link,bucket,get,doc,count;private,static,comparator,bucket,comparing,counts,return,comparator,comparing,long,bucket,get,doc,count
InternalOrder -> @SuppressWarnings("unchecked")     private static Comparator<Bucket> comparingKeys();1524684173;@return compare by {@link Bucket#getKey()} from the appropriate implementation.;@SuppressWarnings("unchecked")_    private static Comparator<Bucket> comparingKeys() {_        return (b1, b2) -> {_            if (b1 instanceof KeyComparable) {_                return ((KeyComparable) b1).compareKey(b2)__            }_            throw new IllegalStateException("Unexpected order bucket class [" + b1.getClass() + "]")__        }__    };return,compare,by,link,bucket,get,key,from,the,appropriate,implementation;suppress,warnings,unchecked,private,static,comparator,bucket,comparing,keys,return,b1,b2,if,b1,instanceof,key,comparable,return,key,comparable,b1,compare,key,b2,throw,new,illegal,state,exception,unexpected,order,bucket,class,b1,get,class
InternalOrder -> @SuppressWarnings("unchecked")     private static Comparator<Bucket> comparingKeys();1537806831;@return compare by {@link Bucket#getKey()} from the appropriate implementation.;@SuppressWarnings("unchecked")_    private static Comparator<Bucket> comparingKeys() {_        return (b1, b2) -> {_            if (b1 instanceof KeyComparable) {_                return ((KeyComparable) b1).compareKey(b2)__            }_            throw new IllegalStateException("Unexpected order bucket class [" + b1.getClass() + "]")__        }__    };return,compare,by,link,bucket,get,key,from,the,appropriate,implementation;suppress,warnings,unchecked,private,static,comparator,bucket,comparing,keys,return,b1,b2,if,b1,instanceof,key,comparable,return,key,comparable,b1,compare,key,b2,throw,new,illegal,state,exception,unexpected,order,bucket,class,b1,get,class
InternalOrder -> @SuppressWarnings("unchecked")     private static Comparator<Bucket> comparingKeys();1540486836;@return compare by {@link Bucket#getKey()} from the appropriate implementation.;@SuppressWarnings("unchecked")_    private static Comparator<Bucket> comparingKeys() {_        return (b1, b2) -> {_            if (b1 instanceof KeyComparable) {_                return ((KeyComparable) b1).compareKey(b2)__            }_            throw new IllegalStateException("Unexpected order bucket class [" + b1.getClass() + "]")__        }__    };return,compare,by,link,bucket,get,key,from,the,appropriate,implementation;suppress,warnings,unchecked,private,static,comparator,bucket,comparing,keys,return,b1,b2,if,b1,instanceof,key,comparable,return,key,comparable,b1,compare,key,b2,throw,new,illegal,state,exception,unexpected,order,bucket,class,b1,get,class
InternalOrder -> @SuppressWarnings("unchecked")     private static Comparator<Bucket> comparingKeys();1540583181;@return compare by {@link Bucket#getKey()} from the appropriate implementation.;@SuppressWarnings("unchecked")_    private static Comparator<Bucket> comparingKeys() {_        return (b1, b2) -> {_            if (b1 instanceof KeyComparable) {_                return ((KeyComparable) b1).compareKey(b2)__            }_            throw new IllegalStateException("Unexpected order bucket class [" + b1.getClass() + "]")__        }__    };return,compare,by,link,bucket,get,key,from,the,appropriate,implementation;suppress,warnings,unchecked,private,static,comparator,bucket,comparing,keys,return,b1,b2,if,b1,instanceof,key,comparable,return,key,comparable,b1,compare,key,b2,throw,new,illegal,state,exception,unexpected,order,bucket,class,b1,get,class
InternalOrder -> Aggregation -> AggregationComparator -> AggregationComparator(String path, boolean asc);1524684173;Create a new {@link Bucket} ordering strategy to sort by a sub-aggregation.__@param path path to the sub-aggregation to sort on._@param asc  direction to sort by: {@code true} for ascending, {@code false} for descending._@see AggregationPath;AggregationComparator(String path, boolean asc) {_                this.asc = asc__                this.path = AggregationPath.parse(path)__            };create,a,new,link,bucket,ordering,strategy,to,sort,by,a,sub,aggregation,param,path,path,to,the,sub,aggregation,to,sort,on,param,asc,direction,to,sort,by,code,true,for,ascending,code,false,for,descending,see,aggregation,path;aggregation,comparator,string,path,boolean,asc,this,asc,asc,this,path,aggregation,path,parse,path
InternalOrder -> Aggregation -> AggregationComparator -> AggregationComparator(String path, boolean asc);1537806831;Create a new {@link Bucket} ordering strategy to sort by a sub-aggregation.__@param path path to the sub-aggregation to sort on._@param asc  direction to sort by: {@code true} for ascending, {@code false} for descending._@see AggregationPath;AggregationComparator(String path, boolean asc) {_                this.asc = asc__                this.path = AggregationPath.parse(path)__            };create,a,new,link,bucket,ordering,strategy,to,sort,by,a,sub,aggregation,param,path,path,to,the,sub,aggregation,to,sort,on,param,asc,direction,to,sort,by,code,true,for,ascending,code,false,for,descending,see,aggregation,path;aggregation,comparator,string,path,boolean,asc,this,asc,asc,this,path,aggregation,path,parse,path
InternalOrder -> Aggregation -> AggregationComparator -> AggregationComparator(String path, boolean asc);1540486836;Create a new {@link Bucket} ordering strategy to sort by a sub-aggregation.__@param path path to the sub-aggregation to sort on._@param asc  direction to sort by: {@code true} for ascending, {@code false} for descending._@see AggregationPath;AggregationComparator(String path, boolean asc) {_                this.asc = asc__                this.path = AggregationPath.parse(path)__            };create,a,new,link,bucket,ordering,strategy,to,sort,by,a,sub,aggregation,param,path,path,to,the,sub,aggregation,to,sort,on,param,asc,direction,to,sort,by,code,true,for,ascending,code,false,for,descending,see,aggregation,path;aggregation,comparator,string,path,boolean,asc,this,asc,asc,this,path,aggregation,path,parse,path
InternalOrder -> Aggregation -> AggregationComparator -> AggregationComparator(String path, boolean asc);1540583181;Create a new {@link Bucket} ordering strategy to sort by a sub-aggregation.__@param path path to the sub-aggregation to sort on._@param asc  direction to sort by: {@code true} for ascending, {@code false} for descending._@see AggregationPath;AggregationComparator(String path, boolean asc) {_                this.asc = asc__                this.path = AggregationPath.parse(path)__            };create,a,new,link,bucket,ordering,strategy,to,sort,by,a,sub,aggregation,param,path,path,to,the,sub,aggregation,to,sort,on,param,asc,direction,to,sort,by,code,true,for,ascending,code,false,for,descending,see,aggregation,path;aggregation,comparator,string,path,boolean,asc,this,asc,asc,this,path,aggregation,path,parse,path
InternalOrder -> Streams -> public static void writeHistogramOrder(BucketOrder order, StreamOutput out, boolean bwcOrderFlag) throws IOException;1524684173;ONLY FOR HISTOGRAM ORDER: Backwards compatibility logic to write a {@link BucketOrder} to a stream.__@param order        order to write to the stream._@param out          stream to write the order to._@param bwcOrderFlag {@code true} to always {@code out.writeBoolean(true)} for the backwards compat logic before_writing the order. {@code false} to skip this flag._@throws IOException on error writing to the stream.;public static void writeHistogramOrder(BucketOrder order, StreamOutput out, boolean bwcOrderFlag) throws IOException {_            if (out.getVersion().onOrAfter(Version.V_6_0_0_alpha2)) {_                order.writeTo(out)__            } else { _                if(bwcOrderFlag) { _                    out.writeBoolean(true)_ _                }_                if (order instanceof CompoundOrder) {_                    _                    order = ((CompoundOrder) order).orderElements.get(0)__                }_                if (order instanceof Aggregation) {_                    _                    order.writeTo(out)__                } else {_                    _                    byte id__                    switch (order.id()) {_                        case COUNT_DESC_ID: id = 4_ break__                        case COUNT_ASC_ID: id = 3_ break__                        case KEY_DESC_ID: id = 2_ break__                        case KEY_ASC_ID: id = 1_ break__                        default: throw new RuntimeException("unknown order id [" + order.id() + "]")__                    }_                    out.writeByte(id)__                }_            }_        };only,for,histogram,order,backwards,compatibility,logic,to,write,a,link,bucket,order,to,a,stream,param,order,order,to,write,to,the,stream,param,out,stream,to,write,the,order,to,param,bwc,order,flag,code,true,to,always,code,out,write,boolean,true,for,the,backwards,compat,logic,before,writing,the,order,code,false,to,skip,this,flag,throws,ioexception,on,error,writing,to,the,stream;public,static,void,write,histogram,order,bucket,order,order,stream,output,out,boolean,bwc,order,flag,throws,ioexception,if,out,get,version,on,or,after,version,order,write,to,out,else,if,bwc,order,flag,out,write,boolean,true,if,order,instanceof,compound,order,order,compound,order,order,order,elements,get,0,if,order,instanceof,aggregation,order,write,to,out,else,byte,id,switch,order,id,case,id,4,break,case,id,3,break,case,id,2,break,case,id,1,break,default,throw,new,runtime,exception,unknown,order,id,order,id,out,write,byte,id
InternalOrder -> Streams -> public static void writeHistogramOrder(BucketOrder order, StreamOutput out, boolean bwcOrderFlag) throws IOException;1537806831;ONLY FOR HISTOGRAM ORDER: Backwards compatibility logic to write a {@link BucketOrder} to a stream.__@param order        order to write to the stream._@param out          stream to write the order to._@param bwcOrderFlag {@code true} to always {@code out.writeBoolean(true)} for the backwards compat logic before_writing the order. {@code false} to skip this flag._@throws IOException on error writing to the stream.;public static void writeHistogramOrder(BucketOrder order, StreamOutput out, boolean bwcOrderFlag) throws IOException {_            if (out.getVersion().onOrAfter(Version.V_6_0_0_alpha2)) {_                order.writeTo(out)__            } else { _                if(bwcOrderFlag) { _                    out.writeBoolean(true)_ _                }_                if (order instanceof CompoundOrder) {_                    _                    order = ((CompoundOrder) order).orderElements.get(0)__                }_                if (order instanceof Aggregation) {_                    _                    order.writeTo(out)__                } else {_                    _                    byte id__                    switch (order.id()) {_                        case COUNT_DESC_ID:_                            id = 4__                            break__                        case COUNT_ASC_ID:_                            id = 3__                            break__                        case KEY_DESC_ID:_                            id = 2__                            break__                        case KEY_ASC_ID:_                            id = 1__                            break__                        default: throw new RuntimeException("unknown order id [" + order.id() + "]")__                    }_                    out.writeByte(id)__                }_            }_        };only,for,histogram,order,backwards,compatibility,logic,to,write,a,link,bucket,order,to,a,stream,param,order,order,to,write,to,the,stream,param,out,stream,to,write,the,order,to,param,bwc,order,flag,code,true,to,always,code,out,write,boolean,true,for,the,backwards,compat,logic,before,writing,the,order,code,false,to,skip,this,flag,throws,ioexception,on,error,writing,to,the,stream;public,static,void,write,histogram,order,bucket,order,order,stream,output,out,boolean,bwc,order,flag,throws,ioexception,if,out,get,version,on,or,after,version,order,write,to,out,else,if,bwc,order,flag,out,write,boolean,true,if,order,instanceof,compound,order,order,compound,order,order,order,elements,get,0,if,order,instanceof,aggregation,order,write,to,out,else,byte,id,switch,order,id,case,id,4,break,case,id,3,break,case,id,2,break,case,id,1,break,default,throw,new,runtime,exception,unknown,order,id,order,id,out,write,byte,id
InternalOrder -> Streams -> public static void writeHistogramOrder(BucketOrder order, StreamOutput out, boolean bwcOrderFlag) throws IOException;1540486836;ONLY FOR HISTOGRAM ORDER: Backwards compatibility logic to write a {@link BucketOrder} to a stream.__@param order        order to write to the stream._@param out          stream to write the order to._@param bwcOrderFlag {@code true} to always {@code out.writeBoolean(true)} for the backwards compat logic before_writing the order. {@code false} to skip this flag._@throws IOException on error writing to the stream.;public static void writeHistogramOrder(BucketOrder order, StreamOutput out, boolean bwcOrderFlag) throws IOException {_            if (out.getVersion().onOrAfter(Version.V_6_0_0_alpha2)) {_                order.writeTo(out)__            } else { _                if(bwcOrderFlag) { _                    out.writeBoolean(true)_ _                }_                if (order instanceof CompoundOrder) {_                    _                    order = ((CompoundOrder) order).orderElements.get(0)__                }_                if (order instanceof Aggregation) {_                    _                    order.writeTo(out)__                } else {_                    _                    byte id__                    switch (order.id()) {_                        case COUNT_DESC_ID:_                            id = 4__                            break__                        case COUNT_ASC_ID:_                            id = 3__                            break__                        case KEY_DESC_ID:_                            id = 2__                            break__                        case KEY_ASC_ID:_                            id = 1__                            break__                        default: throw new RuntimeException("unknown order id [" + order.id() + "]")__                    }_                    out.writeByte(id)__                }_            }_        };only,for,histogram,order,backwards,compatibility,logic,to,write,a,link,bucket,order,to,a,stream,param,order,order,to,write,to,the,stream,param,out,stream,to,write,the,order,to,param,bwc,order,flag,code,true,to,always,code,out,write,boolean,true,for,the,backwards,compat,logic,before,writing,the,order,code,false,to,skip,this,flag,throws,ioexception,on,error,writing,to,the,stream;public,static,void,write,histogram,order,bucket,order,order,stream,output,out,boolean,bwc,order,flag,throws,ioexception,if,out,get,version,on,or,after,version,order,write,to,out,else,if,bwc,order,flag,out,write,boolean,true,if,order,instanceof,compound,order,order,compound,order,order,order,elements,get,0,if,order,instanceof,aggregation,order,write,to,out,else,byte,id,switch,order,id,case,id,4,break,case,id,3,break,case,id,2,break,case,id,1,break,default,throw,new,runtime,exception,unknown,order,id,order,id,out,write,byte,id
InternalOrder -> Streams -> public static void writeHistogramOrder(BucketOrder order, StreamOutput out, boolean bwcOrderFlag) throws IOException;1540583181;ONLY FOR HISTOGRAM ORDER: Backwards compatibility logic to write a {@link BucketOrder} to a stream.__@param order        order to write to the stream._@param out          stream to write the order to._@param bwcOrderFlag {@code true} to always {@code out.writeBoolean(true)} for the backwards compat logic before_writing the order. {@code false} to skip this flag._@throws IOException on error writing to the stream.;public static void writeHistogramOrder(BucketOrder order, StreamOutput out, boolean bwcOrderFlag) throws IOException {_            if (out.getVersion().onOrAfter(Version.V_6_0_0_alpha2)) {_                order.writeTo(out)__            } else { _                if(bwcOrderFlag) { _                    out.writeBoolean(true)_ _                }_                if (order instanceof CompoundOrder) {_                    _                    order = ((CompoundOrder) order).orderElements.get(0)__                }_                if (order instanceof Aggregation) {_                    _                    order.writeTo(out)__                } else {_                    _                    byte id__                    switch (order.id()) {_                        case COUNT_DESC_ID:_                            id = 4__                            break__                        case COUNT_ASC_ID:_                            id = 3__                            break__                        case KEY_DESC_ID:_                            id = 2__                            break__                        case KEY_ASC_ID:_                            id = 1__                            break__                        default: throw new RuntimeException("unknown order id [" + order.id() + "]")__                    }_                    out.writeByte(id)__                }_            }_        };only,for,histogram,order,backwards,compatibility,logic,to,write,a,link,bucket,order,to,a,stream,param,order,order,to,write,to,the,stream,param,out,stream,to,write,the,order,to,param,bwc,order,flag,code,true,to,always,code,out,write,boolean,true,for,the,backwards,compat,logic,before,writing,the,order,code,false,to,skip,this,flag,throws,ioexception,on,error,writing,to,the,stream;public,static,void,write,histogram,order,bucket,order,order,stream,output,out,boolean,bwc,order,flag,throws,ioexception,if,out,get,version,on,or,after,version,order,write,to,out,else,if,bwc,order,flag,out,write,boolean,true,if,order,instanceof,compound,order,order,compound,order,order,order,elements,get,0,if,order,instanceof,aggregation,order,write,to,out,else,byte,id,switch,order,id,case,id,4,break,case,id,3,break,case,id,2,break,case,id,1,break,default,throw,new,runtime,exception,unknown,order,id,order,id,out,write,byte,id
InternalOrder -> CompoundOrder -> CompoundOrder(List<BucketOrder> compoundOrder);1524684173;Create a new ordering strategy to sort by multiple criteria. A tie-breaker may be added to avoid_non-deterministic ordering.__@param compoundOrder a list of {@link BucketOrder}s to sort on, in order of priority.;CompoundOrder(List<BucketOrder> compoundOrder) {_            this(compoundOrder, true)__        };create,a,new,ordering,strategy,to,sort,by,multiple,criteria,a,tie,breaker,may,be,added,to,avoid,non,deterministic,ordering,param,compound,order,a,list,of,link,bucket,order,s,to,sort,on,in,order,of,priority;compound,order,list,bucket,order,compound,order,this,compound,order,true
InternalOrder -> CompoundOrder -> CompoundOrder(List<BucketOrder> compoundOrder);1537806831;Create a new ordering strategy to sort by multiple criteria. A tie-breaker may be added to avoid_non-deterministic ordering.__@param compoundOrder a list of {@link BucketOrder}s to sort on, in order of priority.;CompoundOrder(List<BucketOrder> compoundOrder) {_            this(compoundOrder, true)__        };create,a,new,ordering,strategy,to,sort,by,multiple,criteria,a,tie,breaker,may,be,added,to,avoid,non,deterministic,ordering,param,compound,order,a,list,of,link,bucket,order,s,to,sort,on,in,order,of,priority;compound,order,list,bucket,order,compound,order,this,compound,order,true
InternalOrder -> CompoundOrder -> CompoundOrder(List<BucketOrder> compoundOrder);1540486836;Create a new ordering strategy to sort by multiple criteria. A tie-breaker may be added to avoid_non-deterministic ordering.__@param compoundOrder a list of {@link BucketOrder}s to sort on, in order of priority.;CompoundOrder(List<BucketOrder> compoundOrder) {_            this(compoundOrder, true)__        };create,a,new,ordering,strategy,to,sort,by,multiple,criteria,a,tie,breaker,may,be,added,to,avoid,non,deterministic,ordering,param,compound,order,a,list,of,link,bucket,order,s,to,sort,on,in,order,of,priority;compound,order,list,bucket,order,compound,order,this,compound,order,true
InternalOrder -> CompoundOrder -> CompoundOrder(List<BucketOrder> compoundOrder);1540583181;Create a new ordering strategy to sort by multiple criteria. A tie-breaker may be added to avoid_non-deterministic ordering.__@param compoundOrder a list of {@link BucketOrder}s to sort on, in order of priority.;CompoundOrder(List<BucketOrder> compoundOrder) {_            this(compoundOrder, true)__        };create,a,new,ordering,strategy,to,sort,by,multiple,criteria,a,tie,breaker,may,be,added,to,avoid,non,deterministic,ordering,param,compound,order,a,list,of,link,bucket,order,s,to,sort,on,in,order,of,priority;compound,order,list,bucket,order,compound,order,this,compound,order,true
InternalOrder -> CompoundOrder -> CompoundOrder(List<BucketOrder> compoundOrder, boolean absoluteOrdering);1524684173;Create a new ordering strategy to sort by multiple criteria.__@param compoundOrder    a list of {@link BucketOrder}s to sort on, in order of priority._@param absoluteOrdering {@code true} to add a tie-breaker to avoid non-deterministic ordering if needed,_{@code false} otherwise.;CompoundOrder(List<BucketOrder> compoundOrder, boolean absoluteOrdering) {_            this.orderElements = new LinkedList<>(compoundOrder)__            BucketOrder lastElement = null__            for (BucketOrder order : orderElements) {_                if (order instanceof CompoundOrder) {_                    throw new IllegalArgumentException("nested compound order not supported")__                }_                lastElement = order__            }_            if (absoluteOrdering && isKeyOrder(lastElement) == false) {_                _                _                this.orderElements.add(KEY_ASC)__            }_        };create,a,new,ordering,strategy,to,sort,by,multiple,criteria,param,compound,order,a,list,of,link,bucket,order,s,to,sort,on,in,order,of,priority,param,absolute,ordering,code,true,to,add,a,tie,breaker,to,avoid,non,deterministic,ordering,if,needed,code,false,otherwise;compound,order,list,bucket,order,compound,order,boolean,absolute,ordering,this,order,elements,new,linked,list,compound,order,bucket,order,last,element,null,for,bucket,order,order,order,elements,if,order,instanceof,compound,order,throw,new,illegal,argument,exception,nested,compound,order,not,supported,last,element,order,if,absolute,ordering,is,key,order,last,element,false,this,order,elements,add
InternalOrder -> CompoundOrder -> CompoundOrder(List<BucketOrder> compoundOrder, boolean absoluteOrdering);1537806831;Create a new ordering strategy to sort by multiple criteria.__@param compoundOrder    a list of {@link BucketOrder}s to sort on, in order of priority._@param absoluteOrdering {@code true} to add a tie-breaker to avoid non-deterministic ordering if needed,_{@code false} otherwise.;CompoundOrder(List<BucketOrder> compoundOrder, boolean absoluteOrdering) {_            this.orderElements = new LinkedList<>(compoundOrder)__            BucketOrder lastElement = null__            for (BucketOrder order : orderElements) {_                if (order instanceof CompoundOrder) {_                    throw new IllegalArgumentException("nested compound order not supported")__                }_                lastElement = order__            }_            if (absoluteOrdering && isKeyOrder(lastElement) == false) {_                _                _                this.orderElements.add(KEY_ASC)__            }_        };create,a,new,ordering,strategy,to,sort,by,multiple,criteria,param,compound,order,a,list,of,link,bucket,order,s,to,sort,on,in,order,of,priority,param,absolute,ordering,code,true,to,add,a,tie,breaker,to,avoid,non,deterministic,ordering,if,needed,code,false,otherwise;compound,order,list,bucket,order,compound,order,boolean,absolute,ordering,this,order,elements,new,linked,list,compound,order,bucket,order,last,element,null,for,bucket,order,order,order,elements,if,order,instanceof,compound,order,throw,new,illegal,argument,exception,nested,compound,order,not,supported,last,element,order,if,absolute,ordering,is,key,order,last,element,false,this,order,elements,add
InternalOrder -> CompoundOrder -> CompoundOrder(List<BucketOrder> compoundOrder, boolean absoluteOrdering);1540486836;Create a new ordering strategy to sort by multiple criteria.__@param compoundOrder    a list of {@link BucketOrder}s to sort on, in order of priority._@param absoluteOrdering {@code true} to add a tie-breaker to avoid non-deterministic ordering if needed,_{@code false} otherwise.;CompoundOrder(List<BucketOrder> compoundOrder, boolean absoluteOrdering) {_            this.orderElements = new LinkedList<>(compoundOrder)__            BucketOrder lastElement = null__            for (BucketOrder order : orderElements) {_                if (order instanceof CompoundOrder) {_                    throw new IllegalArgumentException("nested compound order not supported")__                }_                lastElement = order__            }_            if (absoluteOrdering && isKeyOrder(lastElement) == false) {_                _                _                this.orderElements.add(KEY_ASC)__            }_        };create,a,new,ordering,strategy,to,sort,by,multiple,criteria,param,compound,order,a,list,of,link,bucket,order,s,to,sort,on,in,order,of,priority,param,absolute,ordering,code,true,to,add,a,tie,breaker,to,avoid,non,deterministic,ordering,if,needed,code,false,otherwise;compound,order,list,bucket,order,compound,order,boolean,absolute,ordering,this,order,elements,new,linked,list,compound,order,bucket,order,last,element,null,for,bucket,order,order,order,elements,if,order,instanceof,compound,order,throw,new,illegal,argument,exception,nested,compound,order,not,supported,last,element,order,if,absolute,ordering,is,key,order,last,element,false,this,order,elements,add
InternalOrder -> CompoundOrder -> CompoundOrder(List<BucketOrder> compoundOrder, boolean absoluteOrdering);1540583181;Create a new ordering strategy to sort by multiple criteria.__@param compoundOrder    a list of {@link BucketOrder}s to sort on, in order of priority._@param absoluteOrdering {@code true} to add a tie-breaker to avoid non-deterministic ordering if needed,_{@code false} otherwise.;CompoundOrder(List<BucketOrder> compoundOrder, boolean absoluteOrdering) {_            this.orderElements = new LinkedList<>(compoundOrder)__            BucketOrder lastElement = null__            for (BucketOrder order : orderElements) {_                if (order instanceof CompoundOrder) {_                    throw new IllegalArgumentException("nested compound order not supported")__                }_                lastElement = order__            }_            if (absoluteOrdering && isKeyOrder(lastElement) == false) {_                _                _                this.orderElements.add(KEY_ASC)__            }_        };create,a,new,ordering,strategy,to,sort,by,multiple,criteria,param,compound,order,a,list,of,link,bucket,order,s,to,sort,on,in,order,of,priority,param,absolute,ordering,code,true,to,add,a,tie,breaker,to,avoid,non,deterministic,ordering,if,needed,code,false,otherwise;compound,order,list,bucket,order,compound,order,boolean,absolute,ordering,this,order,elements,new,linked,list,compound,order,bucket,order,last,element,null,for,bucket,order,order,order,elements,if,order,instanceof,compound,order,throw,new,illegal,argument,exception,nested,compound,order,not,supported,last,element,order,if,absolute,ordering,is,key,order,last,element,false,this,order,elements,add
InternalOrder -> CompoundOrder -> public List<BucketOrder> orderElements();1524684173;@return unmodifiable list of {@link BucketOrder}s to sort on.;public List<BucketOrder> orderElements() {_            return Collections.unmodifiableList(orderElements)__        };return,unmodifiable,list,of,link,bucket,order,s,to,sort,on;public,list,bucket,order,order,elements,return,collections,unmodifiable,list,order,elements
InternalOrder -> CompoundOrder -> public List<BucketOrder> orderElements();1537806831;@return unmodifiable list of {@link BucketOrder}s to sort on.;public List<BucketOrder> orderElements() {_            return Collections.unmodifiableList(orderElements)__        };return,unmodifiable,list,of,link,bucket,order,s,to,sort,on;public,list,bucket,order,order,elements,return,collections,unmodifiable,list,order,elements
InternalOrder -> CompoundOrder -> public List<BucketOrder> orderElements();1540486836;@return unmodifiable list of {@link BucketOrder}s to sort on.;public List<BucketOrder> orderElements() {_            return Collections.unmodifiableList(orderElements)__        };return,unmodifiable,list,of,link,bucket,order,s,to,sort,on;public,list,bucket,order,order,elements,return,collections,unmodifiable,list,order,elements
InternalOrder -> CompoundOrder -> public List<BucketOrder> orderElements();1540583181;@return unmodifiable list of {@link BucketOrder}s to sort on.;public List<BucketOrder> orderElements() {_            return Collections.unmodifiableList(orderElements)__        };return,unmodifiable,list,of,link,bucket,order,s,to,sort,on;public,list,bucket,order,order,elements,return,collections,unmodifiable,list,order,elements
InternalOrder -> public static boolean isKeyOrder(BucketOrder order);1524684173;Determine if the ordering strategy is sorting on bucket key (ascending or descending).__@param order bucket ordering strategy to check._@return {@code true} if the ordering strategy is sorting on bucket key, {@code false} otherwise.;public static boolean isKeyOrder(BucketOrder order) {_        return isOrder(order, KEY_ASC) || isOrder(order, KEY_DESC)__    };determine,if,the,ordering,strategy,is,sorting,on,bucket,key,ascending,or,descending,param,order,bucket,ordering,strategy,to,check,return,code,true,if,the,ordering,strategy,is,sorting,on,bucket,key,code,false,otherwise;public,static,boolean,is,key,order,bucket,order,order,return,is,order,order,is,order,order
InternalOrder -> public static boolean isKeyOrder(BucketOrder order);1537806831;Determine if the ordering strategy is sorting on bucket key (ascending or descending).__@param order bucket ordering strategy to check._@return {@code true} if the ordering strategy is sorting on bucket key, {@code false} otherwise.;public static boolean isKeyOrder(BucketOrder order) {_        return isOrder(order, KEY_ASC) || isOrder(order, KEY_DESC)__    };determine,if,the,ordering,strategy,is,sorting,on,bucket,key,ascending,or,descending,param,order,bucket,ordering,strategy,to,check,return,code,true,if,the,ordering,strategy,is,sorting,on,bucket,key,code,false,otherwise;public,static,boolean,is,key,order,bucket,order,order,return,is,order,order,is,order,order
InternalOrder -> public static boolean isKeyOrder(BucketOrder order);1540486836;Determine if the ordering strategy is sorting on bucket key (ascending or descending).__@param order bucket ordering strategy to check._@return {@code true} if the ordering strategy is sorting on bucket key, {@code false} otherwise.;public static boolean isKeyOrder(BucketOrder order) {_        return isOrder(order, KEY_ASC) || isOrder(order, KEY_DESC)__    };determine,if,the,ordering,strategy,is,sorting,on,bucket,key,ascending,or,descending,param,order,bucket,ordering,strategy,to,check,return,code,true,if,the,ordering,strategy,is,sorting,on,bucket,key,code,false,otherwise;public,static,boolean,is,key,order,bucket,order,order,return,is,order,order,is,order,order
InternalOrder -> public static boolean isKeyOrder(BucketOrder order);1540583181;Determine if the ordering strategy is sorting on bucket key (ascending or descending).__@param order bucket ordering strategy to check._@return {@code true} if the ordering strategy is sorting on bucket key, {@code false} otherwise.;public static boolean isKeyOrder(BucketOrder order) {_        return isOrder(order, KEY_ASC) || isOrder(order, KEY_DESC)__    };determine,if,the,ordering,strategy,is,sorting,on,bucket,key,ascending,or,descending,param,order,bucket,ordering,strategy,to,check,return,code,true,if,the,ordering,strategy,is,sorting,on,bucket,key,code,false,otherwise;public,static,boolean,is,key,order,bucket,order,order,return,is,order,order,is,order,order
InternalOrder -> Streams -> public static BucketOrder readHistogramOrder(StreamInput in, boolean bwcOrderFlag) throws IOException;1524684173;ONLY FOR HISTOGRAM ORDER: Backwards compatibility logic to read a {@link BucketOrder} from a {@link StreamInput}.__@param in           stream with order data to read._@param bwcOrderFlag {@code true} to check {@code in.readBoolean()} in the backwards compat logic before reading_the order. {@code false} to skip this flag (order always present)._@return order read from the stream_@throws IOException on error reading from the stream.;public static BucketOrder readHistogramOrder(StreamInput in, boolean bwcOrderFlag) throws IOException {_            if (in.getVersion().onOrAfter(Version.V_6_0_0_alpha2)) {_                return Streams.readOrder(in)__            } else { _                if (bwcOrderFlag == false || in.readBoolean()) {_                    _                    byte id = in.readByte()__                    switch (id) {_                        case 1: return KEY_ASC__                        case 2: return KEY_DESC__                        case 3: return COUNT_ASC__                        case 4: return COUNT_DESC__                        case 0: _                            boolean asc = in.readBoolean()__                            String key = in.readString()__                            return new Aggregation(key, asc)__                        default: _                            throw new RuntimeException("unknown histogram order id [" + id + "]")__                    }_                } else { _                    return KEY_ASC__                }_            }_        };only,for,histogram,order,backwards,compatibility,logic,to,read,a,link,bucket,order,from,a,link,stream,input,param,in,stream,with,order,data,to,read,param,bwc,order,flag,code,true,to,check,code,in,read,boolean,in,the,backwards,compat,logic,before,reading,the,order,code,false,to,skip,this,flag,order,always,present,return,order,read,from,the,stream,throws,ioexception,on,error,reading,from,the,stream;public,static,bucket,order,read,histogram,order,stream,input,in,boolean,bwc,order,flag,throws,ioexception,if,in,get,version,on,or,after,version,return,streams,read,order,in,else,if,bwc,order,flag,false,in,read,boolean,byte,id,in,read,byte,switch,id,case,1,return,case,2,return,case,3,return,case,4,return,case,0,boolean,asc,in,read,boolean,string,key,in,read,string,return,new,aggregation,key,asc,default,throw,new,runtime,exception,unknown,histogram,order,id,id,else,return
InternalOrder -> Streams -> public static BucketOrder readHistogramOrder(StreamInput in, boolean bwcOrderFlag) throws IOException;1537806831;ONLY FOR HISTOGRAM ORDER: Backwards compatibility logic to read a {@link BucketOrder} from a {@link StreamInput}.__@param in           stream with order data to read._@param bwcOrderFlag {@code true} to check {@code in.readBoolean()} in the backwards compat logic before reading_the order. {@code false} to skip this flag (order always present)._@return order read from the stream_@throws IOException on error reading from the stream.;public static BucketOrder readHistogramOrder(StreamInput in, boolean bwcOrderFlag) throws IOException {_            if (in.getVersion().onOrAfter(Version.V_6_0_0_alpha2)) {_                return Streams.readOrder(in)__            } else { _                if (bwcOrderFlag == false || in.readBoolean()) {_                    _                    byte id = in.readByte()__                    switch (id) {_                        case 1: return KEY_ASC__                        case 2: return KEY_DESC__                        case 3: return COUNT_ASC__                        case 4: return COUNT_DESC__                        case 0: _                            boolean asc = in.readBoolean()__                            String key = in.readString()__                            return new Aggregation(key, asc)__                        default: _                            throw new RuntimeException("unknown histogram order id [" + id + "]")__                    }_                } else { _                    return KEY_ASC__                }_            }_        };only,for,histogram,order,backwards,compatibility,logic,to,read,a,link,bucket,order,from,a,link,stream,input,param,in,stream,with,order,data,to,read,param,bwc,order,flag,code,true,to,check,code,in,read,boolean,in,the,backwards,compat,logic,before,reading,the,order,code,false,to,skip,this,flag,order,always,present,return,order,read,from,the,stream,throws,ioexception,on,error,reading,from,the,stream;public,static,bucket,order,read,histogram,order,stream,input,in,boolean,bwc,order,flag,throws,ioexception,if,in,get,version,on,or,after,version,return,streams,read,order,in,else,if,bwc,order,flag,false,in,read,boolean,byte,id,in,read,byte,switch,id,case,1,return,case,2,return,case,3,return,case,4,return,case,0,boolean,asc,in,read,boolean,string,key,in,read,string,return,new,aggregation,key,asc,default,throw,new,runtime,exception,unknown,histogram,order,id,id,else,return
InternalOrder -> Streams -> public static BucketOrder readHistogramOrder(StreamInput in, boolean bwcOrderFlag) throws IOException;1540486836;ONLY FOR HISTOGRAM ORDER: Backwards compatibility logic to read a {@link BucketOrder} from a {@link StreamInput}.__@param in           stream with order data to read._@param bwcOrderFlag {@code true} to check {@code in.readBoolean()} in the backwards compat logic before reading_the order. {@code false} to skip this flag (order always present)._@return order read from the stream_@throws IOException on error reading from the stream.;public static BucketOrder readHistogramOrder(StreamInput in, boolean bwcOrderFlag) throws IOException {_            if (in.getVersion().onOrAfter(Version.V_6_0_0_alpha2)) {_                return Streams.readOrder(in)__            } else { _                if (bwcOrderFlag == false || in.readBoolean()) {_                    _                    byte id = in.readByte()__                    switch (id) {_                        case 1: return KEY_ASC__                        case 2: return KEY_DESC__                        case 3: return COUNT_ASC__                        case 4: return COUNT_DESC__                        case 0: _                            boolean asc = in.readBoolean()__                            String key = in.readString()__                            return new Aggregation(key, asc)__                        default: _                            throw new RuntimeException("unknown histogram order id [" + id + "]")__                    }_                } else { _                    return KEY_ASC__                }_            }_        };only,for,histogram,order,backwards,compatibility,logic,to,read,a,link,bucket,order,from,a,link,stream,input,param,in,stream,with,order,data,to,read,param,bwc,order,flag,code,true,to,check,code,in,read,boolean,in,the,backwards,compat,logic,before,reading,the,order,code,false,to,skip,this,flag,order,always,present,return,order,read,from,the,stream,throws,ioexception,on,error,reading,from,the,stream;public,static,bucket,order,read,histogram,order,stream,input,in,boolean,bwc,order,flag,throws,ioexception,if,in,get,version,on,or,after,version,return,streams,read,order,in,else,if,bwc,order,flag,false,in,read,boolean,byte,id,in,read,byte,switch,id,case,1,return,case,2,return,case,3,return,case,4,return,case,0,boolean,asc,in,read,boolean,string,key,in,read,string,return,new,aggregation,key,asc,default,throw,new,runtime,exception,unknown,histogram,order,id,id,else,return
InternalOrder -> Streams -> public static BucketOrder readHistogramOrder(StreamInput in, boolean bwcOrderFlag) throws IOException;1540583181;ONLY FOR HISTOGRAM ORDER: Backwards compatibility logic to read a {@link BucketOrder} from a {@link StreamInput}.__@param in           stream with order data to read._@param bwcOrderFlag {@code true} to check {@code in.readBoolean()} in the backwards compat logic before reading_the order. {@code false} to skip this flag (order always present)._@return order read from the stream_@throws IOException on error reading from the stream.;public static BucketOrder readHistogramOrder(StreamInput in, boolean bwcOrderFlag) throws IOException {_            if (in.getVersion().onOrAfter(Version.V_6_0_0_alpha2)) {_                return Streams.readOrder(in)__            } else { _                if (bwcOrderFlag == false || in.readBoolean()) {_                    _                    byte id = in.readByte()__                    switch (id) {_                        case 1: return KEY_ASC__                        case 2: return KEY_DESC__                        case 3: return COUNT_ASC__                        case 4: return COUNT_DESC__                        case 0: _                            boolean asc = in.readBoolean()__                            String key = in.readString()__                            return new Aggregation(key, asc)__                        default: _                            throw new RuntimeException("unknown histogram order id [" + id + "]")__                    }_                } else { _                    return KEY_ASC__                }_            }_        };only,for,histogram,order,backwards,compatibility,logic,to,read,a,link,bucket,order,from,a,link,stream,input,param,in,stream,with,order,data,to,read,param,bwc,order,flag,code,true,to,check,code,in,read,boolean,in,the,backwards,compat,logic,before,reading,the,order,code,false,to,skip,this,flag,order,always,present,return,order,read,from,the,stream,throws,ioexception,on,error,reading,from,the,stream;public,static,bucket,order,read,histogram,order,stream,input,in,boolean,bwc,order,flag,throws,ioexception,if,in,get,version,on,or,after,version,return,streams,read,order,in,else,if,bwc,order,flag,false,in,read,boolean,byte,id,in,read,byte,switch,id,case,1,return,case,2,return,case,3,return,case,4,return,case,0,boolean,asc,in,read,boolean,string,key,in,read,string,return,new,aggregation,key,asc,default,throw,new,runtime,exception,unknown,histogram,order,id,id,else,return
InternalOrder -> Streams -> public static BucketOrder readOrder(StreamInput in) throws IOException;1524684173;Read a {@link BucketOrder} from a {@link StreamInput}.__@param in stream with order data to read._@return order read from the stream_@throws IOException on error reading from the stream.;public static BucketOrder readOrder(StreamInput in) throws IOException {_            byte id = in.readByte()__            switch (id) {_                case COUNT_DESC_ID: return COUNT_DESC__                case COUNT_ASC_ID: return COUNT_ASC__                case KEY_DESC_ID: return KEY_DESC__                case KEY_ASC_ID: return KEY_ASC__                case Aggregation.ID:_                    boolean asc = in.readBoolean()__                    String key = in.readString()__                    return new Aggregation(key, asc)__                case CompoundOrder.ID:_                    int size = in.readVInt()__                    List<BucketOrder> compoundOrder = new ArrayList<>(size)__                    for (int i = 0_ i < size_ i++) {_                        compoundOrder.add(Streams.readOrder(in))__                    }_                    return new CompoundOrder(compoundOrder, false)__                default:_                    throw new RuntimeException("unknown order id [" + id + "]")__            }_        };read,a,link,bucket,order,from,a,link,stream,input,param,in,stream,with,order,data,to,read,return,order,read,from,the,stream,throws,ioexception,on,error,reading,from,the,stream;public,static,bucket,order,read,order,stream,input,in,throws,ioexception,byte,id,in,read,byte,switch,id,case,return,case,return,case,return,case,return,case,aggregation,id,boolean,asc,in,read,boolean,string,key,in,read,string,return,new,aggregation,key,asc,case,compound,order,id,int,size,in,read,vint,list,bucket,order,compound,order,new,array,list,size,for,int,i,0,i,size,i,compound,order,add,streams,read,order,in,return,new,compound,order,compound,order,false,default,throw,new,runtime,exception,unknown,order,id,id
InternalOrder -> Streams -> public static BucketOrder readOrder(StreamInput in) throws IOException;1537806831;Read a {@link BucketOrder} from a {@link StreamInput}.__@param in stream with order data to read._@return order read from the stream_@throws IOException on error reading from the stream.;public static BucketOrder readOrder(StreamInput in) throws IOException {_            byte id = in.readByte()__            switch (id) {_                case COUNT_DESC_ID: return COUNT_DESC__                case COUNT_ASC_ID: return COUNT_ASC__                case KEY_DESC_ID: return KEY_DESC__                case KEY_ASC_ID: return KEY_ASC__                case Aggregation.ID:_                    boolean asc = in.readBoolean()__                    String key = in.readString()__                    return new Aggregation(key, asc)__                case CompoundOrder.ID:_                    int size = in.readVInt()__                    List<BucketOrder> compoundOrder = new ArrayList<>(size)__                    for (int i = 0_ i < size_ i++) {_                        compoundOrder.add(Streams.readOrder(in))__                    }_                    return new CompoundOrder(compoundOrder, false)__                default:_                    throw new RuntimeException("unknown order id [" + id + "]")__            }_        };read,a,link,bucket,order,from,a,link,stream,input,param,in,stream,with,order,data,to,read,return,order,read,from,the,stream,throws,ioexception,on,error,reading,from,the,stream;public,static,bucket,order,read,order,stream,input,in,throws,ioexception,byte,id,in,read,byte,switch,id,case,return,case,return,case,return,case,return,case,aggregation,id,boolean,asc,in,read,boolean,string,key,in,read,string,return,new,aggregation,key,asc,case,compound,order,id,int,size,in,read,vint,list,bucket,order,compound,order,new,array,list,size,for,int,i,0,i,size,i,compound,order,add,streams,read,order,in,return,new,compound,order,compound,order,false,default,throw,new,runtime,exception,unknown,order,id,id
InternalOrder -> Streams -> public static BucketOrder readOrder(StreamInput in) throws IOException;1540486836;Read a {@link BucketOrder} from a {@link StreamInput}.__@param in stream with order data to read._@return order read from the stream_@throws IOException on error reading from the stream.;public static BucketOrder readOrder(StreamInput in) throws IOException {_            byte id = in.readByte()__            switch (id) {_                case COUNT_DESC_ID: return COUNT_DESC__                case COUNT_ASC_ID: return COUNT_ASC__                case KEY_DESC_ID: return KEY_DESC__                case KEY_ASC_ID: return KEY_ASC__                case Aggregation.ID:_                    boolean asc = in.readBoolean()__                    String key = in.readString()__                    return new Aggregation(key, asc)__                case CompoundOrder.ID:_                    int size = in.readVInt()__                    List<BucketOrder> compoundOrder = new ArrayList<>(size)__                    for (int i = 0_ i < size_ i++) {_                        compoundOrder.add(Streams.readOrder(in))__                    }_                    return new CompoundOrder(compoundOrder, false)__                default:_                    throw new RuntimeException("unknown order id [" + id + "]")__            }_        };read,a,link,bucket,order,from,a,link,stream,input,param,in,stream,with,order,data,to,read,return,order,read,from,the,stream,throws,ioexception,on,error,reading,from,the,stream;public,static,bucket,order,read,order,stream,input,in,throws,ioexception,byte,id,in,read,byte,switch,id,case,return,case,return,case,return,case,return,case,aggregation,id,boolean,asc,in,read,boolean,string,key,in,read,string,return,new,aggregation,key,asc,case,compound,order,id,int,size,in,read,vint,list,bucket,order,compound,order,new,array,list,size,for,int,i,0,i,size,i,compound,order,add,streams,read,order,in,return,new,compound,order,compound,order,false,default,throw,new,runtime,exception,unknown,order,id,id
InternalOrder -> Streams -> public static BucketOrder readOrder(StreamInput in) throws IOException;1540583181;Read a {@link BucketOrder} from a {@link StreamInput}.__@param in stream with order data to read._@return order read from the stream_@throws IOException on error reading from the stream.;public static BucketOrder readOrder(StreamInput in) throws IOException {_            byte id = in.readByte()__            switch (id) {_                case COUNT_DESC_ID: return COUNT_DESC__                case COUNT_ASC_ID: return COUNT_ASC__                case KEY_DESC_ID: return KEY_DESC__                case KEY_ASC_ID: return KEY_ASC__                case Aggregation.ID:_                    boolean asc = in.readBoolean()__                    String key = in.readString()__                    return new Aggregation(key, asc)__                case CompoundOrder.ID:_                    int size = in.readVInt()__                    List<BucketOrder> compoundOrder = new ArrayList<>(size)__                    for (int i = 0_ i < size_ i++) {_                        compoundOrder.add(Streams.readOrder(in))__                    }_                    return new CompoundOrder(compoundOrder, false)__                default:_                    throw new RuntimeException("unknown order id [" + id + "]")__            }_        };read,a,link,bucket,order,from,a,link,stream,input,param,in,stream,with,order,data,to,read,return,order,read,from,the,stream,throws,ioexception,on,error,reading,from,the,stream;public,static,bucket,order,read,order,stream,input,in,throws,ioexception,byte,id,in,read,byte,switch,id,case,return,case,return,case,return,case,return,case,aggregation,id,boolean,asc,in,read,boolean,string,key,in,read,string,return,new,aggregation,key,asc,case,compound,order,id,int,size,in,read,vint,list,bucket,order,compound,order,new,array,list,size,for,int,i,0,i,size,i,compound,order,add,streams,read,order,in,return,new,compound,order,compound,order,false,default,throw,new,runtime,exception,unknown,order,id,id
InternalOrder -> Streams -> public static void writeOrder(BucketOrder order, StreamOutput out) throws IOException;1524684173;Write a {@link BucketOrder} to a {@link StreamOutput}.__@param order order to write to the stream._@param out   stream to write the order to._@throws IOException on error writing to the stream.;public static void writeOrder(BucketOrder order, StreamOutput out) throws IOException {_            out.writeByte(order.id())__            if (order instanceof Aggregation) {_                Aggregation aggregationOrder = (Aggregation) order__                out.writeBoolean(aggregationOrder.asc)__                out.writeString(aggregationOrder.path().toString())__            } else if (order instanceof CompoundOrder) {_                CompoundOrder compoundOrder = (CompoundOrder) order__                out.writeVInt(compoundOrder.orderElements.size())__                for (BucketOrder innerOrder : compoundOrder.orderElements) {_                    innerOrder.writeTo(out)__                }_            }_        };write,a,link,bucket,order,to,a,link,stream,output,param,order,order,to,write,to,the,stream,param,out,stream,to,write,the,order,to,throws,ioexception,on,error,writing,to,the,stream;public,static,void,write,order,bucket,order,order,stream,output,out,throws,ioexception,out,write,byte,order,id,if,order,instanceof,aggregation,aggregation,aggregation,order,aggregation,order,out,write,boolean,aggregation,order,asc,out,write,string,aggregation,order,path,to,string,else,if,order,instanceof,compound,order,compound,order,compound,order,compound,order,order,out,write,vint,compound,order,order,elements,size,for,bucket,order,inner,order,compound,order,order,elements,inner,order,write,to,out
InternalOrder -> Streams -> public static void writeOrder(BucketOrder order, StreamOutput out) throws IOException;1537806831;Write a {@link BucketOrder} to a {@link StreamOutput}.__@param order order to write to the stream._@param out   stream to write the order to._@throws IOException on error writing to the stream.;public static void writeOrder(BucketOrder order, StreamOutput out) throws IOException {_            out.writeByte(order.id())__            if (order instanceof Aggregation) {_                Aggregation aggregationOrder = (Aggregation) order__                out.writeBoolean(aggregationOrder.asc)__                out.writeString(aggregationOrder.path().toString())__            } else if (order instanceof CompoundOrder) {_                CompoundOrder compoundOrder = (CompoundOrder) order__                out.writeVInt(compoundOrder.orderElements.size())__                for (BucketOrder innerOrder : compoundOrder.orderElements) {_                    innerOrder.writeTo(out)__                }_            }_        };write,a,link,bucket,order,to,a,link,stream,output,param,order,order,to,write,to,the,stream,param,out,stream,to,write,the,order,to,throws,ioexception,on,error,writing,to,the,stream;public,static,void,write,order,bucket,order,order,stream,output,out,throws,ioexception,out,write,byte,order,id,if,order,instanceof,aggregation,aggregation,aggregation,order,aggregation,order,out,write,boolean,aggregation,order,asc,out,write,string,aggregation,order,path,to,string,else,if,order,instanceof,compound,order,compound,order,compound,order,compound,order,order,out,write,vint,compound,order,order,elements,size,for,bucket,order,inner,order,compound,order,order,elements,inner,order,write,to,out
InternalOrder -> Streams -> public static void writeOrder(BucketOrder order, StreamOutput out) throws IOException;1540486836;Write a {@link BucketOrder} to a {@link StreamOutput}.__@param order order to write to the stream._@param out   stream to write the order to._@throws IOException on error writing to the stream.;public static void writeOrder(BucketOrder order, StreamOutput out) throws IOException {_            out.writeByte(order.id())__            if (order instanceof Aggregation) {_                Aggregation aggregationOrder = (Aggregation) order__                out.writeBoolean(aggregationOrder.asc)__                out.writeString(aggregationOrder.path().toString())__            } else if (order instanceof CompoundOrder) {_                CompoundOrder compoundOrder = (CompoundOrder) order__                out.writeVInt(compoundOrder.orderElements.size())__                for (BucketOrder innerOrder : compoundOrder.orderElements) {_                    innerOrder.writeTo(out)__                }_            }_        };write,a,link,bucket,order,to,a,link,stream,output,param,order,order,to,write,to,the,stream,param,out,stream,to,write,the,order,to,throws,ioexception,on,error,writing,to,the,stream;public,static,void,write,order,bucket,order,order,stream,output,out,throws,ioexception,out,write,byte,order,id,if,order,instanceof,aggregation,aggregation,aggregation,order,aggregation,order,out,write,boolean,aggregation,order,asc,out,write,string,aggregation,order,path,to,string,else,if,order,instanceof,compound,order,compound,order,compound,order,compound,order,order,out,write,vint,compound,order,order,elements,size,for,bucket,order,inner,order,compound,order,order,elements,inner,order,write,to,out
InternalOrder -> Streams -> public static void writeOrder(BucketOrder order, StreamOutput out) throws IOException;1540583181;Write a {@link BucketOrder} to a {@link StreamOutput}.__@param order order to write to the stream._@param out   stream to write the order to._@throws IOException on error writing to the stream.;public static void writeOrder(BucketOrder order, StreamOutput out) throws IOException {_            out.writeByte(order.id())__            if (order instanceof Aggregation) {_                Aggregation aggregationOrder = (Aggregation) order__                out.writeBoolean(aggregationOrder.asc)__                out.writeString(aggregationOrder.path().toString())__            } else if (order instanceof CompoundOrder) {_                CompoundOrder compoundOrder = (CompoundOrder) order__                out.writeVInt(compoundOrder.orderElements.size())__                for (BucketOrder innerOrder : compoundOrder.orderElements) {_                    innerOrder.writeTo(out)__                }_            }_        };write,a,link,bucket,order,to,a,link,stream,output,param,order,order,to,write,to,the,stream,param,out,stream,to,write,the,order,to,throws,ioexception,on,error,writing,to,the,stream;public,static,void,write,order,bucket,order,order,stream,output,out,throws,ioexception,out,write,byte,order,id,if,order,instanceof,aggregation,aggregation,aggregation,order,aggregation,order,out,write,boolean,aggregation,order,asc,out,write,string,aggregation,order,path,to,string,else,if,order,instanceof,compound,order,compound,order,compound,order,compound,order,order,out,write,vint,compound,order,order,elements,size,for,bucket,order,inner,order,compound,order,order,elements,inner,order,write,to,out
InternalOrder -> public InternalOrder(byte id, String key, boolean asc, Comparator<Bucket> comparator);1524684173;Creates an ordering strategy that sorts {@link Bucket}s by some property.__@param id         unique ID for this ordering strategy._@param key        key of the property to sort on._@param asc        direction to sort by: {@code true} for ascending, {@code false} for descending._@param comparator determines how buckets will be ordered.;public InternalOrder(byte id, String key, boolean asc, Comparator<Bucket> comparator) {_        this.id = id__        this.key = key__        this.asc = asc__        this.comparator = comparator__    };creates,an,ordering,strategy,that,sorts,link,bucket,s,by,some,property,param,id,unique,id,for,this,ordering,strategy,param,key,key,of,the,property,to,sort,on,param,asc,direction,to,sort,by,code,true,for,ascending,code,false,for,descending,param,comparator,determines,how,buckets,will,be,ordered;public,internal,order,byte,id,string,key,boolean,asc,comparator,bucket,comparator,this,id,id,this,key,key,this,asc,asc,this,comparator,comparator
InternalOrder -> public InternalOrder(byte id, String key, boolean asc, Comparator<Bucket> comparator);1537806831;Creates an ordering strategy that sorts {@link Bucket}s by some property.__@param id         unique ID for this ordering strategy._@param key        key of the property to sort on._@param asc        direction to sort by: {@code true} for ascending, {@code false} for descending._@param comparator determines how buckets will be ordered.;public InternalOrder(byte id, String key, boolean asc, Comparator<Bucket> comparator) {_        this.id = id__        this.key = key__        this.asc = asc__        this.comparator = comparator__    };creates,an,ordering,strategy,that,sorts,link,bucket,s,by,some,property,param,id,unique,id,for,this,ordering,strategy,param,key,key,of,the,property,to,sort,on,param,asc,direction,to,sort,by,code,true,for,ascending,code,false,for,descending,param,comparator,determines,how,buckets,will,be,ordered;public,internal,order,byte,id,string,key,boolean,asc,comparator,bucket,comparator,this,id,id,this,key,key,this,asc,asc,this,comparator,comparator
InternalOrder -> public InternalOrder(byte id, String key, boolean asc, Comparator<Bucket> comparator);1540486836;Creates an ordering strategy that sorts {@link Bucket}s by some property.__@param id         unique ID for this ordering strategy._@param key        key of the property to sort on._@param asc        direction to sort by: {@code true} for ascending, {@code false} for descending._@param comparator determines how buckets will be ordered.;public InternalOrder(byte id, String key, boolean asc, Comparator<Bucket> comparator) {_        this.id = id__        this.key = key__        this.asc = asc__        this.comparator = comparator__    };creates,an,ordering,strategy,that,sorts,link,bucket,s,by,some,property,param,id,unique,id,for,this,ordering,strategy,param,key,key,of,the,property,to,sort,on,param,asc,direction,to,sort,by,code,true,for,ascending,code,false,for,descending,param,comparator,determines,how,buckets,will,be,ordered;public,internal,order,byte,id,string,key,boolean,asc,comparator,bucket,comparator,this,id,id,this,key,key,this,asc,asc,this,comparator,comparator
InternalOrder -> public InternalOrder(byte id, String key, boolean asc, Comparator<Bucket> comparator);1540583181;Creates an ordering strategy that sorts {@link Bucket}s by some property.__@param id         unique ID for this ordering strategy._@param key        key of the property to sort on._@param asc        direction to sort by: {@code true} for ascending, {@code false} for descending._@param comparator determines how buckets will be ordered.;public InternalOrder(byte id, String key, boolean asc, Comparator<Bucket> comparator) {_        this.id = id__        this.key = key__        this.asc = asc__        this.comparator = comparator__    };creates,an,ordering,strategy,that,sorts,link,bucket,s,by,some,property,param,id,unique,id,for,this,ordering,strategy,param,key,key,of,the,property,to,sort,on,param,asc,direction,to,sort,by,code,true,for,ascending,code,false,for,descending,param,comparator,determines,how,buckets,will,be,ordered;public,internal,order,byte,id,string,key,boolean,asc,comparator,bucket,comparator,this,id,id,this,key,key,this,asc,asc,this,comparator,comparator
InternalOrder -> public static boolean isCountDesc(BucketOrder order);1524684173;Determine if the ordering strategy is sorting on bucket count descending.__@param order bucket ordering strategy to check._@return {@code true} if the ordering strategy is sorting on bucket count descending, {@code false} otherwise.;public static boolean isCountDesc(BucketOrder order) {_        return isOrder(order, COUNT_DESC)__    };determine,if,the,ordering,strategy,is,sorting,on,bucket,count,descending,param,order,bucket,ordering,strategy,to,check,return,code,true,if,the,ordering,strategy,is,sorting,on,bucket,count,descending,code,false,otherwise;public,static,boolean,is,count,desc,bucket,order,order,return,is,order,order
InternalOrder -> public static boolean isCountDesc(BucketOrder order);1537806831;Determine if the ordering strategy is sorting on bucket count descending.__@param order bucket ordering strategy to check._@return {@code true} if the ordering strategy is sorting on bucket count descending, {@code false} otherwise.;public static boolean isCountDesc(BucketOrder order) {_        return isOrder(order, COUNT_DESC)__    };determine,if,the,ordering,strategy,is,sorting,on,bucket,count,descending,param,order,bucket,ordering,strategy,to,check,return,code,true,if,the,ordering,strategy,is,sorting,on,bucket,count,descending,code,false,otherwise;public,static,boolean,is,count,desc,bucket,order,order,return,is,order,order
InternalOrder -> public static boolean isCountDesc(BucketOrder order);1540486836;Determine if the ordering strategy is sorting on bucket count descending.__@param order bucket ordering strategy to check._@return {@code true} if the ordering strategy is sorting on bucket count descending, {@code false} otherwise.;public static boolean isCountDesc(BucketOrder order) {_        return isOrder(order, COUNT_DESC)__    };determine,if,the,ordering,strategy,is,sorting,on,bucket,count,descending,param,order,bucket,ordering,strategy,to,check,return,code,true,if,the,ordering,strategy,is,sorting,on,bucket,count,descending,code,false,otherwise;public,static,boolean,is,count,desc,bucket,order,order,return,is,order,order
InternalOrder -> public static boolean isCountDesc(BucketOrder order);1540583181;Determine if the ordering strategy is sorting on bucket count descending.__@param order bucket ordering strategy to check._@return {@code true} if the ordering strategy is sorting on bucket count descending, {@code false} otherwise.;public static boolean isCountDesc(BucketOrder order) {_        return isOrder(order, COUNT_DESC)__    };determine,if,the,ordering,strategy,is,sorting,on,bucket,count,descending,param,order,bucket,ordering,strategy,to,check,return,code,true,if,the,ordering,strategy,is,sorting,on,bucket,count,descending,code,false,otherwise;public,static,boolean,is,count,desc,bucket,order,order,return,is,order,order
InternalOrder -> public static boolean isKeyAsc(BucketOrder order);1524684173;Determine if the ordering strategy is sorting on bucket key ascending.__@param order bucket ordering strategy to check._@return {@code true} if the ordering strategy is sorting on bucket key ascending, {@code false} otherwise.;public static boolean isKeyAsc(BucketOrder order) {_        return isOrder(order, KEY_ASC)__    };determine,if,the,ordering,strategy,is,sorting,on,bucket,key,ascending,param,order,bucket,ordering,strategy,to,check,return,code,true,if,the,ordering,strategy,is,sorting,on,bucket,key,ascending,code,false,otherwise;public,static,boolean,is,key,asc,bucket,order,order,return,is,order,order
InternalOrder -> public static boolean isKeyAsc(BucketOrder order);1537806831;Determine if the ordering strategy is sorting on bucket key ascending.__@param order bucket ordering strategy to check._@return {@code true} if the ordering strategy is sorting on bucket key ascending, {@code false} otherwise.;public static boolean isKeyAsc(BucketOrder order) {_        return isOrder(order, KEY_ASC)__    };determine,if,the,ordering,strategy,is,sorting,on,bucket,key,ascending,param,order,bucket,ordering,strategy,to,check,return,code,true,if,the,ordering,strategy,is,sorting,on,bucket,key,ascending,code,false,otherwise;public,static,boolean,is,key,asc,bucket,order,order,return,is,order,order
InternalOrder -> public static boolean isKeyAsc(BucketOrder order);1540486836;Determine if the ordering strategy is sorting on bucket key ascending.__@param order bucket ordering strategy to check._@return {@code true} if the ordering strategy is sorting on bucket key ascending, {@code false} otherwise.;public static boolean isKeyAsc(BucketOrder order) {_        return isOrder(order, KEY_ASC)__    };determine,if,the,ordering,strategy,is,sorting,on,bucket,key,ascending,param,order,bucket,ordering,strategy,to,check,return,code,true,if,the,ordering,strategy,is,sorting,on,bucket,key,ascending,code,false,otherwise;public,static,boolean,is,key,asc,bucket,order,order,return,is,order,order
InternalOrder -> public static boolean isKeyAsc(BucketOrder order);1540583181;Determine if the ordering strategy is sorting on bucket key ascending.__@param order bucket ordering strategy to check._@return {@code true} if the ordering strategy is sorting on bucket key ascending, {@code false} otherwise.;public static boolean isKeyAsc(BucketOrder order) {_        return isOrder(order, KEY_ASC)__    };determine,if,the,ordering,strategy,is,sorting,on,bucket,key,ascending,param,order,bucket,ordering,strategy,to,check,return,code,true,if,the,ordering,strategy,is,sorting,on,bucket,key,ascending,code,false,otherwise;public,static,boolean,is,key,asc,bucket,order,order,return,is,order,order
InternalOrder -> CompoundOrder -> CompoundOrderComparator -> CompoundOrderComparator(List<BucketOrder> compoundOrder, Aggregator aggregator);1524684173;Create a new {@code Comparator} for sorting buckets by multiple criteria.__@param compoundOrder a list of {@link BucketOrder}s to sort on, in order of priority._@param aggregator    {@link BucketOrder#comparator(Aggregator)};CompoundOrderComparator(List<BucketOrder> compoundOrder, Aggregator aggregator) {_                this.compoundOrder = compoundOrder__                this.aggregator = aggregator__            };create,a,new,code,comparator,for,sorting,buckets,by,multiple,criteria,param,compound,order,a,list,of,link,bucket,order,s,to,sort,on,in,order,of,priority,param,aggregator,link,bucket,order,comparator,aggregator;compound,order,comparator,list,bucket,order,compound,order,aggregator,aggregator,this,compound,order,compound,order,this,aggregator,aggregator
InternalOrder -> CompoundOrder -> CompoundOrderComparator -> CompoundOrderComparator(List<BucketOrder> compoundOrder, Aggregator aggregator);1537806831;Create a new {@code Comparator} for sorting buckets by multiple criteria.__@param compoundOrder a list of {@link BucketOrder}s to sort on, in order of priority._@param aggregator    {@link BucketOrder#comparator(Aggregator)};CompoundOrderComparator(List<BucketOrder> compoundOrder, Aggregator aggregator) {_                this.compoundOrder = compoundOrder__                this.aggregator = aggregator__            };create,a,new,code,comparator,for,sorting,buckets,by,multiple,criteria,param,compound,order,a,list,of,link,bucket,order,s,to,sort,on,in,order,of,priority,param,aggregator,link,bucket,order,comparator,aggregator;compound,order,comparator,list,bucket,order,compound,order,aggregator,aggregator,this,compound,order,compound,order,this,aggregator,aggregator
InternalOrder -> CompoundOrder -> CompoundOrderComparator -> CompoundOrderComparator(List<BucketOrder> compoundOrder, Aggregator aggregator);1540486836;Create a new {@code Comparator} for sorting buckets by multiple criteria.__@param compoundOrder a list of {@link BucketOrder}s to sort on, in order of priority._@param aggregator    {@link BucketOrder#comparator(Aggregator)};CompoundOrderComparator(List<BucketOrder> compoundOrder, Aggregator aggregator) {_                this.compoundOrder = compoundOrder__                this.aggregator = aggregator__            };create,a,new,code,comparator,for,sorting,buckets,by,multiple,criteria,param,compound,order,a,list,of,link,bucket,order,s,to,sort,on,in,order,of,priority,param,aggregator,link,bucket,order,comparator,aggregator;compound,order,comparator,list,bucket,order,compound,order,aggregator,aggregator,this,compound,order,compound,order,this,aggregator,aggregator
InternalOrder -> CompoundOrder -> CompoundOrderComparator -> CompoundOrderComparator(List<BucketOrder> compoundOrder, Aggregator aggregator);1540583181;Create a new {@code Comparator} for sorting buckets by multiple criteria.__@param compoundOrder a list of {@link BucketOrder}s to sort on, in order of priority._@param aggregator    {@link BucketOrder#comparator(Aggregator)};CompoundOrderComparator(List<BucketOrder> compoundOrder, Aggregator aggregator) {_                this.compoundOrder = compoundOrder__                this.aggregator = aggregator__            };create,a,new,code,comparator,for,sorting,buckets,by,multiple,criteria,param,compound,order,a,list,of,link,bucket,order,s,to,sort,on,in,order,of,priority,param,aggregator,link,bucket,order,comparator,aggregator;compound,order,comparator,list,bucket,order,compound,order,aggregator,aggregator,this,compound,order,compound,order,this,aggregator,aggregator
InternalOrder -> public static BucketOrder validate(BucketOrder order, Aggregator aggregator) throws AggregationExecutionException;1524684173;Validate a bucket ordering strategy for an {@link Aggregator}.__@param order      bucket ordering strategy to sort on._@param aggregator aggregator to sort._@return unmodified bucket ordering strategy._@throws AggregationExecutionException if validation fails;public static BucketOrder validate(BucketOrder order, Aggregator aggregator) throws AggregationExecutionException {_        if (order instanceof CompoundOrder) {_            for (BucketOrder innerOrder : ((CompoundOrder) order).orderElements) {_                validate(innerOrder, aggregator)__            }_        } else if (order instanceof Aggregation) {_            ((Aggregation) order).path().validate(aggregator)__        }_        return order__    };validate,a,bucket,ordering,strategy,for,an,link,aggregator,param,order,bucket,ordering,strategy,to,sort,on,param,aggregator,aggregator,to,sort,return,unmodified,bucket,ordering,strategy,throws,aggregation,execution,exception,if,validation,fails;public,static,bucket,order,validate,bucket,order,order,aggregator,aggregator,throws,aggregation,execution,exception,if,order,instanceof,compound,order,for,bucket,order,inner,order,compound,order,order,order,elements,validate,inner,order,aggregator,else,if,order,instanceof,aggregation,aggregation,order,path,validate,aggregator,return,order
InternalOrder -> public static BucketOrder validate(BucketOrder order, Aggregator aggregator) throws AggregationExecutionException;1537806831;Validate a bucket ordering strategy for an {@link Aggregator}.__@param order      bucket ordering strategy to sort on._@param aggregator aggregator to sort._@return unmodified bucket ordering strategy._@throws AggregationExecutionException if validation fails;public static BucketOrder validate(BucketOrder order, Aggregator aggregator) throws AggregationExecutionException {_        if (order instanceof CompoundOrder) {_            for (BucketOrder innerOrder : ((CompoundOrder) order).orderElements) {_                validate(innerOrder, aggregator)__            }_        } else if (order instanceof Aggregation) {_            ((Aggregation) order).path().validate(aggregator)__        }_        return order__    };validate,a,bucket,ordering,strategy,for,an,link,aggregator,param,order,bucket,ordering,strategy,to,sort,on,param,aggregator,aggregator,to,sort,return,unmodified,bucket,ordering,strategy,throws,aggregation,execution,exception,if,validation,fails;public,static,bucket,order,validate,bucket,order,order,aggregator,aggregator,throws,aggregation,execution,exception,if,order,instanceof,compound,order,for,bucket,order,inner,order,compound,order,order,order,elements,validate,inner,order,aggregator,else,if,order,instanceof,aggregation,aggregation,order,path,validate,aggregator,return,order
InternalOrder -> public static BucketOrder validate(BucketOrder order, Aggregator aggregator) throws AggregationExecutionException;1540486836;Validate a bucket ordering strategy for an {@link Aggregator}.__@param order      bucket ordering strategy to sort on._@param aggregator aggregator to sort._@return unmodified bucket ordering strategy._@throws AggregationExecutionException if validation fails;public static BucketOrder validate(BucketOrder order, Aggregator aggregator) throws AggregationExecutionException {_        if (order instanceof CompoundOrder) {_            for (BucketOrder innerOrder : ((CompoundOrder) order).orderElements) {_                validate(innerOrder, aggregator)__            }_        } else if (order instanceof Aggregation) {_            ((Aggregation) order).path().validate(aggregator)__        }_        return order__    };validate,a,bucket,ordering,strategy,for,an,link,aggregator,param,order,bucket,ordering,strategy,to,sort,on,param,aggregator,aggregator,to,sort,return,unmodified,bucket,ordering,strategy,throws,aggregation,execution,exception,if,validation,fails;public,static,bucket,order,validate,bucket,order,order,aggregator,aggregator,throws,aggregation,execution,exception,if,order,instanceof,compound,order,for,bucket,order,inner,order,compound,order,order,order,elements,validate,inner,order,aggregator,else,if,order,instanceof,aggregation,aggregation,order,path,validate,aggregator,return,order
InternalOrder -> public static BucketOrder validate(BucketOrder order, Aggregator aggregator) throws AggregationExecutionException;1540583181;Validate a bucket ordering strategy for an {@link Aggregator}.__@param order      bucket ordering strategy to sort on._@param aggregator aggregator to sort._@return unmodified bucket ordering strategy._@throws AggregationExecutionException if validation fails;public static BucketOrder validate(BucketOrder order, Aggregator aggregator) throws AggregationExecutionException {_        if (order instanceof CompoundOrder) {_            for (BucketOrder innerOrder : ((CompoundOrder) order).orderElements) {_                validate(innerOrder, aggregator)__            }_        } else if (order instanceof Aggregation) {_            ((Aggregation) order).path().validate(aggregator)__        }_        return order__    };validate,a,bucket,ordering,strategy,for,an,link,aggregator,param,order,bucket,ordering,strategy,to,sort,on,param,aggregator,aggregator,to,sort,return,unmodified,bucket,ordering,strategy,throws,aggregation,execution,exception,if,validation,fails;public,static,bucket,order,validate,bucket,order,order,aggregator,aggregator,throws,aggregation,execution,exception,if,order,instanceof,compound,order,for,bucket,order,inner,order,compound,order,order,order,elements,validate,inner,order,aggregator,else,if,order,instanceof,aggregation,aggregation,order,path,validate,aggregator,return,order
InternalOrder -> Aggregation -> Aggregation(String path, boolean asc);1524684173;Create a new ordering strategy to sort by a sub-aggregation.__@param path path to the sub-aggregation to sort on._@param asc  direction to sort by: {@code true} for ascending, {@code false} for descending._@see AggregationPath;Aggregation(String path, boolean asc) {_            super(ID, path, asc, new AggregationComparator(path, asc))__        };create,a,new,ordering,strategy,to,sort,by,a,sub,aggregation,param,path,path,to,the,sub,aggregation,to,sort,on,param,asc,direction,to,sort,by,code,true,for,ascending,code,false,for,descending,see,aggregation,path;aggregation,string,path,boolean,asc,super,id,path,asc,new,aggregation,comparator,path,asc
InternalOrder -> Aggregation -> Aggregation(String path, boolean asc);1537806831;Create a new ordering strategy to sort by a sub-aggregation.__@param path path to the sub-aggregation to sort on._@param asc  direction to sort by: {@code true} for ascending, {@code false} for descending._@see AggregationPath;Aggregation(String path, boolean asc) {_            super(ID, path, asc, new AggregationComparator(path, asc))__        };create,a,new,ordering,strategy,to,sort,by,a,sub,aggregation,param,path,path,to,the,sub,aggregation,to,sort,on,param,asc,direction,to,sort,by,code,true,for,ascending,code,false,for,descending,see,aggregation,path;aggregation,string,path,boolean,asc,super,id,path,asc,new,aggregation,comparator,path,asc
InternalOrder -> Aggregation -> Aggregation(String path, boolean asc);1540486836;Create a new ordering strategy to sort by a sub-aggregation.__@param path path to the sub-aggregation to sort on._@param asc  direction to sort by: {@code true} for ascending, {@code false} for descending._@see AggregationPath;Aggregation(String path, boolean asc) {_            super(ID, path, asc, new AggregationComparator(path, asc))__        };create,a,new,ordering,strategy,to,sort,by,a,sub,aggregation,param,path,path,to,the,sub,aggregation,to,sort,on,param,asc,direction,to,sort,by,code,true,for,ascending,code,false,for,descending,see,aggregation,path;aggregation,string,path,boolean,asc,super,id,path,asc,new,aggregation,comparator,path,asc
InternalOrder -> Aggregation -> Aggregation(String path, boolean asc);1540583181;Create a new ordering strategy to sort by a sub-aggregation.__@param path path to the sub-aggregation to sort on._@param asc  direction to sort by: {@code true} for ascending, {@code false} for descending._@see AggregationPath;Aggregation(String path, boolean asc) {_            super(ID, path, asc, new AggregationComparator(path, asc))__        };create,a,new,ordering,strategy,to,sort,by,a,sub,aggregation,param,path,path,to,the,sub,aggregation,to,sort,on,param,asc,direction,to,sort,by,code,true,for,ascending,code,false,for,descending,see,aggregation,path;aggregation,string,path,boolean,asc,super,id,path,asc,new,aggregation,comparator,path,asc
InternalOrder -> private static boolean isOrder(BucketOrder order, BucketOrder expected);1524684173;Determine if the ordering strategy matches the expected one.__@param order    bucket ordering strategy to check. If this is a {@link CompoundOrder} the first element will be_check instead._@param expected expected  bucket ordering strategy._@return {@code true} if the order matches, {@code false} otherwise.;private static boolean isOrder(BucketOrder order, BucketOrder expected) {_        if (order == expected) {_            return true__        } else if (order instanceof CompoundOrder) {_            _            List<BucketOrder> orders = ((CompoundOrder) order).orderElements__            if (orders.size() >= 1) {_                return isOrder(orders.get(0), expected)__            }_        }_        return false__    };determine,if,the,ordering,strategy,matches,the,expected,one,param,order,bucket,ordering,strategy,to,check,if,this,is,a,link,compound,order,the,first,element,will,be,check,instead,param,expected,expected,bucket,ordering,strategy,return,code,true,if,the,order,matches,code,false,otherwise;private,static,boolean,is,order,bucket,order,order,bucket,order,expected,if,order,expected,return,true,else,if,order,instanceof,compound,order,list,bucket,order,orders,compound,order,order,order,elements,if,orders,size,1,return,is,order,orders,get,0,expected,return,false
InternalOrder -> private static boolean isOrder(BucketOrder order, BucketOrder expected);1537806831;Determine if the ordering strategy matches the expected one.__@param order    bucket ordering strategy to check. If this is a {@link CompoundOrder} the first element will be_check instead._@param expected expected  bucket ordering strategy._@return {@code true} if the order matches, {@code false} otherwise.;private static boolean isOrder(BucketOrder order, BucketOrder expected) {_        if (order == expected) {_            return true__        } else if (order instanceof CompoundOrder) {_            _            List<BucketOrder> orders = ((CompoundOrder) order).orderElements__            if (orders.size() >= 1) {_                return isOrder(orders.get(0), expected)__            }_        }_        return false__    };determine,if,the,ordering,strategy,matches,the,expected,one,param,order,bucket,ordering,strategy,to,check,if,this,is,a,link,compound,order,the,first,element,will,be,check,instead,param,expected,expected,bucket,ordering,strategy,return,code,true,if,the,order,matches,code,false,otherwise;private,static,boolean,is,order,bucket,order,order,bucket,order,expected,if,order,expected,return,true,else,if,order,instanceof,compound,order,list,bucket,order,orders,compound,order,order,order,elements,if,orders,size,1,return,is,order,orders,get,0,expected,return,false
InternalOrder -> private static boolean isOrder(BucketOrder order, BucketOrder expected);1540486836;Determine if the ordering strategy matches the expected one.__@param order    bucket ordering strategy to check. If this is a {@link CompoundOrder} the first element will be_check instead._@param expected expected  bucket ordering strategy._@return {@code true} if the order matches, {@code false} otherwise.;private static boolean isOrder(BucketOrder order, BucketOrder expected) {_        if (order == expected) {_            return true__        } else if (order instanceof CompoundOrder) {_            _            List<BucketOrder> orders = ((CompoundOrder) order).orderElements__            if (orders.size() >= 1) {_                return isOrder(orders.get(0), expected)__            }_        }_        return false__    };determine,if,the,ordering,strategy,matches,the,expected,one,param,order,bucket,ordering,strategy,to,check,if,this,is,a,link,compound,order,the,first,element,will,be,check,instead,param,expected,expected,bucket,ordering,strategy,return,code,true,if,the,order,matches,code,false,otherwise;private,static,boolean,is,order,bucket,order,order,bucket,order,expected,if,order,expected,return,true,else,if,order,instanceof,compound,order,list,bucket,order,orders,compound,order,order,order,elements,if,orders,size,1,return,is,order,orders,get,0,expected,return,false
InternalOrder -> private static boolean isOrder(BucketOrder order, BucketOrder expected);1540583181;Determine if the ordering strategy matches the expected one.__@param order    bucket ordering strategy to check. If this is a {@link CompoundOrder} the first element will be_check instead._@param expected expected  bucket ordering strategy._@return {@code true} if the order matches, {@code false} otherwise.;private static boolean isOrder(BucketOrder order, BucketOrder expected) {_        if (order == expected) {_            return true__        } else if (order instanceof CompoundOrder) {_            _            List<BucketOrder> orders = ((CompoundOrder) order).orderElements__            if (orders.size() >= 1) {_                return isOrder(orders.get(0), expected)__            }_        }_        return false__    };determine,if,the,ordering,strategy,matches,the,expected,one,param,order,bucket,ordering,strategy,to,check,if,this,is,a,link,compound,order,the,first,element,will,be,check,instead,param,expected,expected,bucket,ordering,strategy,return,code,true,if,the,order,matches,code,false,otherwise;private,static,boolean,is,order,bucket,order,order,bucket,order,expected,if,order,expected,return,true,else,if,order,instanceof,compound,order,list,bucket,order,orders,compound,order,order,order,elements,if,orders,size,1,return,is,order,orders,get,0,expected,return,false
