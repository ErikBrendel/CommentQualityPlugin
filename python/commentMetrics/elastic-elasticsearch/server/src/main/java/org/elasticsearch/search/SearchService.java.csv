# id;timestamp;commentText;codeText;commentWords;codeWords
SearchService -> private void shortcutDocIdsToLoad(SearchContext context);1524684173;Shortcut ids to load, we load only "from" and up to "size". The phase controller_handles this as well since the result is always size * shards for Q_T_F;private void shortcutDocIdsToLoad(SearchContext context) {_        final int[] docIdsToLoad__        int docsOffset = 0__        final Suggest suggest = context.queryResult().suggest()__        int numSuggestDocs = 0__        final List<CompletionSuggestion> completionSuggestions__        if (suggest != null && suggest.hasScoreDocs()) {_            completionSuggestions = suggest.filter(CompletionSuggestion.class)__            for (CompletionSuggestion completionSuggestion : completionSuggestions) {_                numSuggestDocs += completionSuggestion.getOptions().size()__            }_        } else {_            completionSuggestions = Collections.emptyList()__        }_        if (context.request().scroll() != null) {_            TopDocs topDocs = context.queryResult().topDocs()__            docIdsToLoad = new int[topDocs.scoreDocs.length + numSuggestDocs]__            for (int i = 0_ i < topDocs.scoreDocs.length_ i++) {_                docIdsToLoad[docsOffset++] = topDocs.scoreDocs[i].doc__            }_        } else {_            TopDocs topDocs = context.queryResult().topDocs()__            if (topDocs.scoreDocs.length < context.from()) {_                _                docIdsToLoad = new int[numSuggestDocs]__            } else {_                int totalSize = context.from() + context.size()__                docIdsToLoad = new int[Math.min(topDocs.scoreDocs.length - context.from(), context.size()) +_                    numSuggestDocs]__                for (int i = context.from()_ i < Math.min(totalSize, topDocs.scoreDocs.length)_ i++) {_                    docIdsToLoad[docsOffset++] = topDocs.scoreDocs[i].doc__                }_            }_        }_        for (CompletionSuggestion completionSuggestion : completionSuggestions) {_            for (CompletionSuggestion.Entry.Option option : completionSuggestion.getOptions()) {_                docIdsToLoad[docsOffset++] = option.getDoc().doc__            }_        }_        context.docIdsToLoad(docIdsToLoad, 0, docIdsToLoad.length)__    };shortcut,ids,to,load,we,load,only,from,and,up,to,size,the,phase,controller,handles,this,as,well,since,the,result,is,always,size,shards,for;private,void,shortcut,doc,ids,to,load,search,context,context,final,int,doc,ids,to,load,int,docs,offset,0,final,suggest,suggest,context,query,result,suggest,int,num,suggest,docs,0,final,list,completion,suggestion,completion,suggestions,if,suggest,null,suggest,has,score,docs,completion,suggestions,suggest,filter,completion,suggestion,class,for,completion,suggestion,completion,suggestion,completion,suggestions,num,suggest,docs,completion,suggestion,get,options,size,else,completion,suggestions,collections,empty,list,if,context,request,scroll,null,top,docs,top,docs,context,query,result,top,docs,doc,ids,to,load,new,int,top,docs,score,docs,length,num,suggest,docs,for,int,i,0,i,top,docs,score,docs,length,i,doc,ids,to,load,docs,offset,top,docs,score,docs,i,doc,else,top,docs,top,docs,context,query,result,top,docs,if,top,docs,score,docs,length,context,from,doc,ids,to,load,new,int,num,suggest,docs,else,int,total,size,context,from,context,size,doc,ids,to,load,new,int,math,min,top,docs,score,docs,length,context,from,context,size,num,suggest,docs,for,int,i,context,from,i,math,min,total,size,top,docs,score,docs,length,i,doc,ids,to,load,docs,offset,top,docs,score,docs,i,doc,for,completion,suggestion,completion,suggestion,completion,suggestions,for,completion,suggestion,entry,option,option,completion,suggestion,get,options,doc,ids,to,load,docs,offset,option,get,doc,doc,context,doc,ids,to,load,doc,ids,to,load,0,doc,ids,to,load,length
SearchService -> private void shortcutDocIdsToLoad(SearchContext context);1524780945;Shortcut ids to load, we load only "from" and up to "size". The phase controller_handles this as well since the result is always size * shards for Q_T_F;private void shortcutDocIdsToLoad(SearchContext context) {_        final int[] docIdsToLoad__        int docsOffset = 0__        final Suggest suggest = context.queryResult().suggest()__        int numSuggestDocs = 0__        final List<CompletionSuggestion> completionSuggestions__        if (suggest != null && suggest.hasScoreDocs()) {_            completionSuggestions = suggest.filter(CompletionSuggestion.class)__            for (CompletionSuggestion completionSuggestion : completionSuggestions) {_                numSuggestDocs += completionSuggestion.getOptions().size()__            }_        } else {_            completionSuggestions = Collections.emptyList()__        }_        if (context.request().scroll() != null) {_            TopDocs topDocs = context.queryResult().topDocs()__            docIdsToLoad = new int[topDocs.scoreDocs.length + numSuggestDocs]__            for (int i = 0_ i < topDocs.scoreDocs.length_ i++) {_                docIdsToLoad[docsOffset++] = topDocs.scoreDocs[i].doc__            }_        } else {_            TopDocs topDocs = context.queryResult().topDocs()__            if (topDocs.scoreDocs.length < context.from()) {_                _                docIdsToLoad = new int[numSuggestDocs]__            } else {_                int totalSize = context.from() + context.size()__                docIdsToLoad = new int[Math.min(topDocs.scoreDocs.length - context.from(), context.size()) +_                    numSuggestDocs]__                for (int i = context.from()_ i < Math.min(totalSize, topDocs.scoreDocs.length)_ i++) {_                    docIdsToLoad[docsOffset++] = topDocs.scoreDocs[i].doc__                }_            }_        }_        for (CompletionSuggestion completionSuggestion : completionSuggestions) {_            for (CompletionSuggestion.Entry.Option option : completionSuggestion.getOptions()) {_                docIdsToLoad[docsOffset++] = option.getDoc().doc__            }_        }_        context.docIdsToLoad(docIdsToLoad, 0, docIdsToLoad.length)__    };shortcut,ids,to,load,we,load,only,from,and,up,to,size,the,phase,controller,handles,this,as,well,since,the,result,is,always,size,shards,for;private,void,shortcut,doc,ids,to,load,search,context,context,final,int,doc,ids,to,load,int,docs,offset,0,final,suggest,suggest,context,query,result,suggest,int,num,suggest,docs,0,final,list,completion,suggestion,completion,suggestions,if,suggest,null,suggest,has,score,docs,completion,suggestions,suggest,filter,completion,suggestion,class,for,completion,suggestion,completion,suggestion,completion,suggestions,num,suggest,docs,completion,suggestion,get,options,size,else,completion,suggestions,collections,empty,list,if,context,request,scroll,null,top,docs,top,docs,context,query,result,top,docs,doc,ids,to,load,new,int,top,docs,score,docs,length,num,suggest,docs,for,int,i,0,i,top,docs,score,docs,length,i,doc,ids,to,load,docs,offset,top,docs,score,docs,i,doc,else,top,docs,top,docs,context,query,result,top,docs,if,top,docs,score,docs,length,context,from,doc,ids,to,load,new,int,num,suggest,docs,else,int,total,size,context,from,context,size,doc,ids,to,load,new,int,math,min,top,docs,score,docs,length,context,from,context,size,num,suggest,docs,for,int,i,context,from,i,math,min,total,size,top,docs,score,docs,length,i,doc,ids,to,load,docs,offset,top,docs,score,docs,i,doc,for,completion,suggestion,completion,suggestion,completion,suggestions,for,completion,suggestion,entry,option,option,completion,suggestion,get,options,doc,ids,to,load,docs,offset,option,get,doc,doc,context,doc,ids,to,load,doc,ids,to,load,0,doc,ids,to,load,length
SearchService -> private void shortcutDocIdsToLoad(SearchContext context);1525334055;Shortcut ids to load, we load only "from" and up to "size". The phase controller_handles this as well since the result is always size * shards for Q_T_F;private void shortcutDocIdsToLoad(SearchContext context) {_        final int[] docIdsToLoad__        int docsOffset = 0__        final Suggest suggest = context.queryResult().suggest()__        int numSuggestDocs = 0__        final List<CompletionSuggestion> completionSuggestions__        if (suggest != null && suggest.hasScoreDocs()) {_            completionSuggestions = suggest.filter(CompletionSuggestion.class)__            for (CompletionSuggestion completionSuggestion : completionSuggestions) {_                numSuggestDocs += completionSuggestion.getOptions().size()__            }_        } else {_            completionSuggestions = Collections.emptyList()__        }_        if (context.request().scroll() != null) {_            TopDocs topDocs = context.queryResult().topDocs()__            docIdsToLoad = new int[topDocs.scoreDocs.length + numSuggestDocs]__            for (int i = 0_ i < topDocs.scoreDocs.length_ i++) {_                docIdsToLoad[docsOffset++] = topDocs.scoreDocs[i].doc__            }_        } else {_            TopDocs topDocs = context.queryResult().topDocs()__            if (topDocs.scoreDocs.length < context.from()) {_                _                docIdsToLoad = new int[numSuggestDocs]__            } else {_                int totalSize = context.from() + context.size()__                docIdsToLoad = new int[Math.min(topDocs.scoreDocs.length - context.from(), context.size()) +_                    numSuggestDocs]__                for (int i = context.from()_ i < Math.min(totalSize, topDocs.scoreDocs.length)_ i++) {_                    docIdsToLoad[docsOffset++] = topDocs.scoreDocs[i].doc__                }_            }_        }_        for (CompletionSuggestion completionSuggestion : completionSuggestions) {_            for (CompletionSuggestion.Entry.Option option : completionSuggestion.getOptions()) {_                docIdsToLoad[docsOffset++] = option.getDoc().doc__            }_        }_        context.docIdsToLoad(docIdsToLoad, 0, docIdsToLoad.length)__    };shortcut,ids,to,load,we,load,only,from,and,up,to,size,the,phase,controller,handles,this,as,well,since,the,result,is,always,size,shards,for;private,void,shortcut,doc,ids,to,load,search,context,context,final,int,doc,ids,to,load,int,docs,offset,0,final,suggest,suggest,context,query,result,suggest,int,num,suggest,docs,0,final,list,completion,suggestion,completion,suggestions,if,suggest,null,suggest,has,score,docs,completion,suggestions,suggest,filter,completion,suggestion,class,for,completion,suggestion,completion,suggestion,completion,suggestions,num,suggest,docs,completion,suggestion,get,options,size,else,completion,suggestions,collections,empty,list,if,context,request,scroll,null,top,docs,top,docs,context,query,result,top,docs,doc,ids,to,load,new,int,top,docs,score,docs,length,num,suggest,docs,for,int,i,0,i,top,docs,score,docs,length,i,doc,ids,to,load,docs,offset,top,docs,score,docs,i,doc,else,top,docs,top,docs,context,query,result,top,docs,if,top,docs,score,docs,length,context,from,doc,ids,to,load,new,int,num,suggest,docs,else,int,total,size,context,from,context,size,doc,ids,to,load,new,int,math,min,top,docs,score,docs,length,context,from,context,size,num,suggest,docs,for,int,i,context,from,i,math,min,total,size,top,docs,score,docs,length,i,doc,ids,to,load,docs,offset,top,docs,score,docs,i,doc,for,completion,suggestion,completion,suggestion,completion,suggestions,for,completion,suggestion,entry,option,option,completion,suggestion,get,options,doc,ids,to,load,docs,offset,option,get,doc,doc,context,doc,ids,to,load,doc,ids,to,load,0,doc,ids,to,load,length
SearchService -> private void shortcutDocIdsToLoad(SearchContext context);1527583663;Shortcut ids to load, we load only "from" and up to "size". The phase controller_handles this as well since the result is always size * shards for Q_T_F;private void shortcutDocIdsToLoad(SearchContext context) {_        final int[] docIdsToLoad__        int docsOffset = 0__        final Suggest suggest = context.queryResult().suggest()__        int numSuggestDocs = 0__        final List<CompletionSuggestion> completionSuggestions__        if (suggest != null && suggest.hasScoreDocs()) {_            completionSuggestions = suggest.filter(CompletionSuggestion.class)__            for (CompletionSuggestion completionSuggestion : completionSuggestions) {_                numSuggestDocs += completionSuggestion.getOptions().size()__            }_        } else {_            completionSuggestions = Collections.emptyList()__        }_        if (context.request().scroll() != null) {_            TopDocs topDocs = context.queryResult().topDocs()__            docIdsToLoad = new int[topDocs.scoreDocs.length + numSuggestDocs]__            for (int i = 0_ i < topDocs.scoreDocs.length_ i++) {_                docIdsToLoad[docsOffset++] = topDocs.scoreDocs[i].doc__            }_        } else {_            TopDocs topDocs = context.queryResult().topDocs()__            if (topDocs.scoreDocs.length < context.from()) {_                _                docIdsToLoad = new int[numSuggestDocs]__            } else {_                int totalSize = context.from() + context.size()__                docIdsToLoad = new int[Math.min(topDocs.scoreDocs.length - context.from(), context.size()) +_                    numSuggestDocs]__                for (int i = context.from()_ i < Math.min(totalSize, topDocs.scoreDocs.length)_ i++) {_                    docIdsToLoad[docsOffset++] = topDocs.scoreDocs[i].doc__                }_            }_        }_        for (CompletionSuggestion completionSuggestion : completionSuggestions) {_            for (CompletionSuggestion.Entry.Option option : completionSuggestion.getOptions()) {_                docIdsToLoad[docsOffset++] = option.getDoc().doc__            }_        }_        context.docIdsToLoad(docIdsToLoad, 0, docIdsToLoad.length)__    };shortcut,ids,to,load,we,load,only,from,and,up,to,size,the,phase,controller,handles,this,as,well,since,the,result,is,always,size,shards,for;private,void,shortcut,doc,ids,to,load,search,context,context,final,int,doc,ids,to,load,int,docs,offset,0,final,suggest,suggest,context,query,result,suggest,int,num,suggest,docs,0,final,list,completion,suggestion,completion,suggestions,if,suggest,null,suggest,has,score,docs,completion,suggestions,suggest,filter,completion,suggestion,class,for,completion,suggestion,completion,suggestion,completion,suggestions,num,suggest,docs,completion,suggestion,get,options,size,else,completion,suggestions,collections,empty,list,if,context,request,scroll,null,top,docs,top,docs,context,query,result,top,docs,doc,ids,to,load,new,int,top,docs,score,docs,length,num,suggest,docs,for,int,i,0,i,top,docs,score,docs,length,i,doc,ids,to,load,docs,offset,top,docs,score,docs,i,doc,else,top,docs,top,docs,context,query,result,top,docs,if,top,docs,score,docs,length,context,from,doc,ids,to,load,new,int,num,suggest,docs,else,int,total,size,context,from,context,size,doc,ids,to,load,new,int,math,min,top,docs,score,docs,length,context,from,context,size,num,suggest,docs,for,int,i,context,from,i,math,min,total,size,top,docs,score,docs,length,i,doc,ids,to,load,docs,offset,top,docs,score,docs,i,doc,for,completion,suggestion,completion,suggestion,completion,suggestions,for,completion,suggestion,entry,option,option,completion,suggestion,get,options,doc,ids,to,load,docs,offset,option,get,doc,doc,context,doc,ids,to,load,doc,ids,to,load,0,doc,ids,to,load,length
SearchService -> private void shortcutDocIdsToLoad(SearchContext context);1533641732;Shortcut ids to load, we load only "from" and up to "size". The phase controller_handles this as well since the result is always size * shards for Q_T_F;private void shortcutDocIdsToLoad(SearchContext context) {_        final int[] docIdsToLoad__        int docsOffset = 0__        final Suggest suggest = context.queryResult().suggest()__        int numSuggestDocs = 0__        final List<CompletionSuggestion> completionSuggestions__        if (suggest != null && suggest.hasScoreDocs()) {_            completionSuggestions = suggest.filter(CompletionSuggestion.class)__            for (CompletionSuggestion completionSuggestion : completionSuggestions) {_                numSuggestDocs += completionSuggestion.getOptions().size()__            }_        } else {_            completionSuggestions = Collections.emptyList()__        }_        if (context.request().scroll() != null) {_            TopDocs topDocs = context.queryResult().topDocs()__            docIdsToLoad = new int[topDocs.scoreDocs.length + numSuggestDocs]__            for (int i = 0_ i < topDocs.scoreDocs.length_ i++) {_                docIdsToLoad[docsOffset++] = topDocs.scoreDocs[i].doc__            }_        } else {_            TopDocs topDocs = context.queryResult().topDocs()__            if (topDocs.scoreDocs.length < context.from()) {_                _                docIdsToLoad = new int[numSuggestDocs]__            } else {_                int totalSize = context.from() + context.size()__                docIdsToLoad = new int[Math.min(topDocs.scoreDocs.length - context.from(), context.size()) +_                    numSuggestDocs]__                for (int i = context.from()_ i < Math.min(totalSize, topDocs.scoreDocs.length)_ i++) {_                    docIdsToLoad[docsOffset++] = topDocs.scoreDocs[i].doc__                }_            }_        }_        for (CompletionSuggestion completionSuggestion : completionSuggestions) {_            for (CompletionSuggestion.Entry.Option option : completionSuggestion.getOptions()) {_                docIdsToLoad[docsOffset++] = option.getDoc().doc__            }_        }_        context.docIdsToLoad(docIdsToLoad, 0, docIdsToLoad.length)__    };shortcut,ids,to,load,we,load,only,from,and,up,to,size,the,phase,controller,handles,this,as,well,since,the,result,is,always,size,shards,for;private,void,shortcut,doc,ids,to,load,search,context,context,final,int,doc,ids,to,load,int,docs,offset,0,final,suggest,suggest,context,query,result,suggest,int,num,suggest,docs,0,final,list,completion,suggestion,completion,suggestions,if,suggest,null,suggest,has,score,docs,completion,suggestions,suggest,filter,completion,suggestion,class,for,completion,suggestion,completion,suggestion,completion,suggestions,num,suggest,docs,completion,suggestion,get,options,size,else,completion,suggestions,collections,empty,list,if,context,request,scroll,null,top,docs,top,docs,context,query,result,top,docs,doc,ids,to,load,new,int,top,docs,score,docs,length,num,suggest,docs,for,int,i,0,i,top,docs,score,docs,length,i,doc,ids,to,load,docs,offset,top,docs,score,docs,i,doc,else,top,docs,top,docs,context,query,result,top,docs,if,top,docs,score,docs,length,context,from,doc,ids,to,load,new,int,num,suggest,docs,else,int,total,size,context,from,context,size,doc,ids,to,load,new,int,math,min,top,docs,score,docs,length,context,from,context,size,num,suggest,docs,for,int,i,context,from,i,math,min,total,size,top,docs,score,docs,length,i,doc,ids,to,load,docs,offset,top,docs,score,docs,i,doc,for,completion,suggestion,completion,suggestion,completion,suggestions,for,completion,suggestion,entry,option,option,completion,suggestion,get,options,doc,ids,to,load,docs,offset,option,get,doc,doc,context,doc,ids,to,load,doc,ids,to,load,0,doc,ids,to,load,length
SearchService -> private void shortcutDocIdsToLoad(SearchContext context);1535046779;Shortcut ids to load, we load only "from" and up to "size". The phase controller_handles this as well since the result is always size * shards for Q_T_F;private void shortcutDocIdsToLoad(SearchContext context) {_        final int[] docIdsToLoad__        int docsOffset = 0__        final Suggest suggest = context.queryResult().suggest()__        int numSuggestDocs = 0__        final List<CompletionSuggestion> completionSuggestions__        if (suggest != null && suggest.hasScoreDocs()) {_            completionSuggestions = suggest.filter(CompletionSuggestion.class)__            for (CompletionSuggestion completionSuggestion : completionSuggestions) {_                numSuggestDocs += completionSuggestion.getOptions().size()__            }_        } else {_            completionSuggestions = Collections.emptyList()__        }_        if (context.request().scroll() != null) {_            TopDocs topDocs = context.queryResult().topDocs()__            docIdsToLoad = new int[topDocs.scoreDocs.length + numSuggestDocs]__            for (int i = 0_ i < topDocs.scoreDocs.length_ i++) {_                docIdsToLoad[docsOffset++] = topDocs.scoreDocs[i].doc__            }_        } else {_            TopDocs topDocs = context.queryResult().topDocs()__            if (topDocs.scoreDocs.length < context.from()) {_                _                docIdsToLoad = new int[numSuggestDocs]__            } else {_                int totalSize = context.from() + context.size()__                docIdsToLoad = new int[Math.min(topDocs.scoreDocs.length - context.from(), context.size()) +_                    numSuggestDocs]__                for (int i = context.from()_ i < Math.min(totalSize, topDocs.scoreDocs.length)_ i++) {_                    docIdsToLoad[docsOffset++] = topDocs.scoreDocs[i].doc__                }_            }_        }_        for (CompletionSuggestion completionSuggestion : completionSuggestions) {_            for (CompletionSuggestion.Entry.Option option : completionSuggestion.getOptions()) {_                docIdsToLoad[docsOffset++] = option.getDoc().doc__            }_        }_        context.docIdsToLoad(docIdsToLoad, 0, docIdsToLoad.length)__    };shortcut,ids,to,load,we,load,only,from,and,up,to,size,the,phase,controller,handles,this,as,well,since,the,result,is,always,size,shards,for;private,void,shortcut,doc,ids,to,load,search,context,context,final,int,doc,ids,to,load,int,docs,offset,0,final,suggest,suggest,context,query,result,suggest,int,num,suggest,docs,0,final,list,completion,suggestion,completion,suggestions,if,suggest,null,suggest,has,score,docs,completion,suggestions,suggest,filter,completion,suggestion,class,for,completion,suggestion,completion,suggestion,completion,suggestions,num,suggest,docs,completion,suggestion,get,options,size,else,completion,suggestions,collections,empty,list,if,context,request,scroll,null,top,docs,top,docs,context,query,result,top,docs,doc,ids,to,load,new,int,top,docs,score,docs,length,num,suggest,docs,for,int,i,0,i,top,docs,score,docs,length,i,doc,ids,to,load,docs,offset,top,docs,score,docs,i,doc,else,top,docs,top,docs,context,query,result,top,docs,if,top,docs,score,docs,length,context,from,doc,ids,to,load,new,int,num,suggest,docs,else,int,total,size,context,from,context,size,doc,ids,to,load,new,int,math,min,top,docs,score,docs,length,context,from,context,size,num,suggest,docs,for,int,i,context,from,i,math,min,total,size,top,docs,score,docs,length,i,doc,ids,to,load,docs,offset,top,docs,score,docs,i,doc,for,completion,suggestion,completion,suggestion,completion,suggestions,for,completion,suggestion,entry,option,option,completion,suggestion,get,options,doc,ids,to,load,docs,offset,option,get,doc,doc,context,doc,ids,to,load,doc,ids,to,load,0,doc,ids,to,load,length
SearchService -> private void shortcutDocIdsToLoad(SearchContext context);1536314350;Shortcut ids to load, we load only "from" and up to "size". The phase controller_handles this as well since the result is always size * shards for Q_T_F;private void shortcutDocIdsToLoad(SearchContext context) {_        final int[] docIdsToLoad__        int docsOffset = 0__        final Suggest suggest = context.queryResult().suggest()__        int numSuggestDocs = 0__        final List<CompletionSuggestion> completionSuggestions__        if (suggest != null && suggest.hasScoreDocs()) {_            completionSuggestions = suggest.filter(CompletionSuggestion.class)__            for (CompletionSuggestion completionSuggestion : completionSuggestions) {_                numSuggestDocs += completionSuggestion.getOptions().size()__            }_        } else {_            completionSuggestions = Collections.emptyList()__        }_        if (context.request().scroll() != null) {_            TopDocs topDocs = context.queryResult().topDocs().topDocs__            docIdsToLoad = new int[topDocs.scoreDocs.length + numSuggestDocs]__            for (int i = 0_ i < topDocs.scoreDocs.length_ i++) {_                docIdsToLoad[docsOffset++] = topDocs.scoreDocs[i].doc__            }_        } else {_            TopDocs topDocs = context.queryResult().topDocs().topDocs__            if (topDocs.scoreDocs.length < context.from()) {_                _                docIdsToLoad = new int[numSuggestDocs]__            } else {_                int totalSize = context.from() + context.size()__                docIdsToLoad = new int[Math.min(topDocs.scoreDocs.length - context.from(), context.size()) +_                    numSuggestDocs]__                for (int i = context.from()_ i < Math.min(totalSize, topDocs.scoreDocs.length)_ i++) {_                    docIdsToLoad[docsOffset++] = topDocs.scoreDocs[i].doc__                }_            }_        }_        for (CompletionSuggestion completionSuggestion : completionSuggestions) {_            for (CompletionSuggestion.Entry.Option option : completionSuggestion.getOptions()) {_                docIdsToLoad[docsOffset++] = option.getDoc().doc__            }_        }_        context.docIdsToLoad(docIdsToLoad, 0, docIdsToLoad.length)__    };shortcut,ids,to,load,we,load,only,from,and,up,to,size,the,phase,controller,handles,this,as,well,since,the,result,is,always,size,shards,for;private,void,shortcut,doc,ids,to,load,search,context,context,final,int,doc,ids,to,load,int,docs,offset,0,final,suggest,suggest,context,query,result,suggest,int,num,suggest,docs,0,final,list,completion,suggestion,completion,suggestions,if,suggest,null,suggest,has,score,docs,completion,suggestions,suggest,filter,completion,suggestion,class,for,completion,suggestion,completion,suggestion,completion,suggestions,num,suggest,docs,completion,suggestion,get,options,size,else,completion,suggestions,collections,empty,list,if,context,request,scroll,null,top,docs,top,docs,context,query,result,top,docs,top,docs,doc,ids,to,load,new,int,top,docs,score,docs,length,num,suggest,docs,for,int,i,0,i,top,docs,score,docs,length,i,doc,ids,to,load,docs,offset,top,docs,score,docs,i,doc,else,top,docs,top,docs,context,query,result,top,docs,top,docs,if,top,docs,score,docs,length,context,from,doc,ids,to,load,new,int,num,suggest,docs,else,int,total,size,context,from,context,size,doc,ids,to,load,new,int,math,min,top,docs,score,docs,length,context,from,context,size,num,suggest,docs,for,int,i,context,from,i,math,min,total,size,top,docs,score,docs,length,i,doc,ids,to,load,docs,offset,top,docs,score,docs,i,doc,for,completion,suggestion,completion,suggestion,completion,suggestions,for,completion,suggestion,entry,option,option,completion,suggestion,get,options,doc,ids,to,load,docs,offset,option,get,doc,doc,context,doc,ids,to,load,doc,ids,to,load,0,doc,ids,to,load,length
SearchService -> private void shortcutDocIdsToLoad(SearchContext context);1537806831;Shortcut ids to load, we load only "from" and up to "size". The phase controller_handles this as well since the result is always size * shards for Q_T_F;private void shortcutDocIdsToLoad(SearchContext context) {_        final int[] docIdsToLoad__        int docsOffset = 0__        final Suggest suggest = context.queryResult().suggest()__        int numSuggestDocs = 0__        final List<CompletionSuggestion> completionSuggestions__        if (suggest != null && suggest.hasScoreDocs()) {_            completionSuggestions = suggest.filter(CompletionSuggestion.class)__            for (CompletionSuggestion completionSuggestion : completionSuggestions) {_                numSuggestDocs += completionSuggestion.getOptions().size()__            }_        } else {_            completionSuggestions = Collections.emptyList()__        }_        if (context.request().scroll() != null) {_            TopDocs topDocs = context.queryResult().topDocs().topDocs__            docIdsToLoad = new int[topDocs.scoreDocs.length + numSuggestDocs]__            for (int i = 0_ i < topDocs.scoreDocs.length_ i++) {_                docIdsToLoad[docsOffset++] = topDocs.scoreDocs[i].doc__            }_        } else {_            TopDocs topDocs = context.queryResult().topDocs().topDocs__            if (topDocs.scoreDocs.length < context.from()) {_                _                docIdsToLoad = new int[numSuggestDocs]__            } else {_                int totalSize = context.from() + context.size()__                docIdsToLoad = new int[Math.min(topDocs.scoreDocs.length - context.from(), context.size()) +_                    numSuggestDocs]__                for (int i = context.from()_ i < Math.min(totalSize, topDocs.scoreDocs.length)_ i++) {_                    docIdsToLoad[docsOffset++] = topDocs.scoreDocs[i].doc__                }_            }_        }_        for (CompletionSuggestion completionSuggestion : completionSuggestions) {_            for (CompletionSuggestion.Entry.Option option : completionSuggestion.getOptions()) {_                docIdsToLoad[docsOffset++] = option.getDoc().doc__            }_        }_        context.docIdsToLoad(docIdsToLoad, 0, docIdsToLoad.length)__    };shortcut,ids,to,load,we,load,only,from,and,up,to,size,the,phase,controller,handles,this,as,well,since,the,result,is,always,size,shards,for;private,void,shortcut,doc,ids,to,load,search,context,context,final,int,doc,ids,to,load,int,docs,offset,0,final,suggest,suggest,context,query,result,suggest,int,num,suggest,docs,0,final,list,completion,suggestion,completion,suggestions,if,suggest,null,suggest,has,score,docs,completion,suggestions,suggest,filter,completion,suggestion,class,for,completion,suggestion,completion,suggestion,completion,suggestions,num,suggest,docs,completion,suggestion,get,options,size,else,completion,suggestions,collections,empty,list,if,context,request,scroll,null,top,docs,top,docs,context,query,result,top,docs,top,docs,doc,ids,to,load,new,int,top,docs,score,docs,length,num,suggest,docs,for,int,i,0,i,top,docs,score,docs,length,i,doc,ids,to,load,docs,offset,top,docs,score,docs,i,doc,else,top,docs,top,docs,context,query,result,top,docs,top,docs,if,top,docs,score,docs,length,context,from,doc,ids,to,load,new,int,num,suggest,docs,else,int,total,size,context,from,context,size,doc,ids,to,load,new,int,math,min,top,docs,score,docs,length,context,from,context,size,num,suggest,docs,for,int,i,context,from,i,math,min,total,size,top,docs,score,docs,length,i,doc,ids,to,load,docs,offset,top,docs,score,docs,i,doc,for,completion,suggestion,completion,suggestion,completion,suggestions,for,completion,suggestion,entry,option,option,completion,suggestion,get,options,doc,ids,to,load,docs,offset,option,get,doc,doc,context,doc,ids,to,load,doc,ids,to,load,0,doc,ids,to,load,length
SearchService -> private void shortcutDocIdsToLoad(SearchContext context);1540238977;Shortcut ids to load, we load only "from" and up to "size". The phase controller_handles this as well since the result is always size * shards for Q_T_F;private void shortcutDocIdsToLoad(SearchContext context) {_        final int[] docIdsToLoad__        int docsOffset = 0__        final Suggest suggest = context.queryResult().suggest()__        int numSuggestDocs = 0__        final List<CompletionSuggestion> completionSuggestions__        if (suggest != null && suggest.hasScoreDocs()) {_            completionSuggestions = suggest.filter(CompletionSuggestion.class)__            for (CompletionSuggestion completionSuggestion : completionSuggestions) {_                numSuggestDocs += completionSuggestion.getOptions().size()__            }_        } else {_            completionSuggestions = Collections.emptyList()__        }_        if (context.request().scroll() != null) {_            TopDocs topDocs = context.queryResult().topDocs().topDocs__            docIdsToLoad = new int[topDocs.scoreDocs.length + numSuggestDocs]__            for (int i = 0_ i < topDocs.scoreDocs.length_ i++) {_                docIdsToLoad[docsOffset++] = topDocs.scoreDocs[i].doc__            }_        } else {_            TopDocs topDocs = context.queryResult().topDocs().topDocs__            if (topDocs.scoreDocs.length < context.from()) {_                _                docIdsToLoad = new int[numSuggestDocs]__            } else {_                int totalSize = context.from() + context.size()__                docIdsToLoad = new int[Math.min(topDocs.scoreDocs.length - context.from(), context.size()) +_                    numSuggestDocs]__                for (int i = context.from()_ i < Math.min(totalSize, topDocs.scoreDocs.length)_ i++) {_                    docIdsToLoad[docsOffset++] = topDocs.scoreDocs[i].doc__                }_            }_        }_        for (CompletionSuggestion completionSuggestion : completionSuggestions) {_            for (CompletionSuggestion.Entry.Option option : completionSuggestion.getOptions()) {_                docIdsToLoad[docsOffset++] = option.getDoc().doc__            }_        }_        context.docIdsToLoad(docIdsToLoad, 0, docIdsToLoad.length)__    };shortcut,ids,to,load,we,load,only,from,and,up,to,size,the,phase,controller,handles,this,as,well,since,the,result,is,always,size,shards,for;private,void,shortcut,doc,ids,to,load,search,context,context,final,int,doc,ids,to,load,int,docs,offset,0,final,suggest,suggest,context,query,result,suggest,int,num,suggest,docs,0,final,list,completion,suggestion,completion,suggestions,if,suggest,null,suggest,has,score,docs,completion,suggestions,suggest,filter,completion,suggestion,class,for,completion,suggestion,completion,suggestion,completion,suggestions,num,suggest,docs,completion,suggestion,get,options,size,else,completion,suggestions,collections,empty,list,if,context,request,scroll,null,top,docs,top,docs,context,query,result,top,docs,top,docs,doc,ids,to,load,new,int,top,docs,score,docs,length,num,suggest,docs,for,int,i,0,i,top,docs,score,docs,length,i,doc,ids,to,load,docs,offset,top,docs,score,docs,i,doc,else,top,docs,top,docs,context,query,result,top,docs,top,docs,if,top,docs,score,docs,length,context,from,doc,ids,to,load,new,int,num,suggest,docs,else,int,total,size,context,from,context,size,doc,ids,to,load,new,int,math,min,top,docs,score,docs,length,context,from,context,size,num,suggest,docs,for,int,i,context,from,i,math,min,total,size,top,docs,score,docs,length,i,doc,ids,to,load,docs,offset,top,docs,score,docs,i,doc,for,completion,suggestion,completion,suggestion,completion,suggestions,for,completion,suggestion,entry,option,option,completion,suggestion,get,options,doc,ids,to,load,docs,offset,option,get,doc,doc,context,doc,ids,to,load,doc,ids,to,load,0,doc,ids,to,load,length
SearchService -> private void shortcutDocIdsToLoad(SearchContext context);1540583181;Shortcut ids to load, we load only "from" and up to "size". The phase controller_handles this as well since the result is always size * shards for Q_T_F;private void shortcutDocIdsToLoad(SearchContext context) {_        final int[] docIdsToLoad__        int docsOffset = 0__        final Suggest suggest = context.queryResult().suggest()__        int numSuggestDocs = 0__        final List<CompletionSuggestion> completionSuggestions__        if (suggest != null && suggest.hasScoreDocs()) {_            completionSuggestions = suggest.filter(CompletionSuggestion.class)__            for (CompletionSuggestion completionSuggestion : completionSuggestions) {_                numSuggestDocs += completionSuggestion.getOptions().size()__            }_        } else {_            completionSuggestions = Collections.emptyList()__        }_        if (context.request().scroll() != null) {_            TopDocs topDocs = context.queryResult().topDocs().topDocs__            docIdsToLoad = new int[topDocs.scoreDocs.length + numSuggestDocs]__            for (int i = 0_ i < topDocs.scoreDocs.length_ i++) {_                docIdsToLoad[docsOffset++] = topDocs.scoreDocs[i].doc__            }_        } else {_            TopDocs topDocs = context.queryResult().topDocs().topDocs__            if (topDocs.scoreDocs.length < context.from()) {_                _                docIdsToLoad = new int[numSuggestDocs]__            } else {_                int totalSize = context.from() + context.size()__                docIdsToLoad = new int[Math.min(topDocs.scoreDocs.length - context.from(), context.size()) +_                    numSuggestDocs]__                for (int i = context.from()_ i < Math.min(totalSize, topDocs.scoreDocs.length)_ i++) {_                    docIdsToLoad[docsOffset++] = topDocs.scoreDocs[i].doc__                }_            }_        }_        for (CompletionSuggestion completionSuggestion : completionSuggestions) {_            for (CompletionSuggestion.Entry.Option option : completionSuggestion.getOptions()) {_                docIdsToLoad[docsOffset++] = option.getDoc().doc__            }_        }_        context.docIdsToLoad(docIdsToLoad, 0, docIdsToLoad.length)__    };shortcut,ids,to,load,we,load,only,from,and,up,to,size,the,phase,controller,handles,this,as,well,since,the,result,is,always,size,shards,for;private,void,shortcut,doc,ids,to,load,search,context,context,final,int,doc,ids,to,load,int,docs,offset,0,final,suggest,suggest,context,query,result,suggest,int,num,suggest,docs,0,final,list,completion,suggestion,completion,suggestions,if,suggest,null,suggest,has,score,docs,completion,suggestions,suggest,filter,completion,suggestion,class,for,completion,suggestion,completion,suggestion,completion,suggestions,num,suggest,docs,completion,suggestion,get,options,size,else,completion,suggestions,collections,empty,list,if,context,request,scroll,null,top,docs,top,docs,context,query,result,top,docs,top,docs,doc,ids,to,load,new,int,top,docs,score,docs,length,num,suggest,docs,for,int,i,0,i,top,docs,score,docs,length,i,doc,ids,to,load,docs,offset,top,docs,score,docs,i,doc,else,top,docs,top,docs,context,query,result,top,docs,top,docs,if,top,docs,score,docs,length,context,from,doc,ids,to,load,new,int,num,suggest,docs,else,int,total,size,context,from,context,size,doc,ids,to,load,new,int,math,min,top,docs,score,docs,length,context,from,context,size,num,suggest,docs,for,int,i,context,from,i,math,min,total,size,top,docs,score,docs,length,i,doc,ids,to,load,docs,offset,top,docs,score,docs,i,doc,for,completion,suggestion,completion,suggestion,completion,suggestions,for,completion,suggestion,entry,option,option,completion,suggestion,get,options,doc,ids,to,load,docs,offset,option,get,doc,doc,context,doc,ids,to,load,doc,ids,to,load,0,doc,ids,to,load,length
SearchService -> private void shortcutDocIdsToLoad(SearchContext context);1541008027;Shortcut ids to load, we load only "from" and up to "size". The phase controller_handles this as well since the result is always size * shards for Q_T_F;private void shortcutDocIdsToLoad(SearchContext context) {_        final int[] docIdsToLoad__        int docsOffset = 0__        final Suggest suggest = context.queryResult().suggest()__        int numSuggestDocs = 0__        final List<CompletionSuggestion> completionSuggestions__        if (suggest != null && suggest.hasScoreDocs()) {_            completionSuggestions = suggest.filter(CompletionSuggestion.class)__            for (CompletionSuggestion completionSuggestion : completionSuggestions) {_                numSuggestDocs += completionSuggestion.getOptions().size()__            }_        } else {_            completionSuggestions = Collections.emptyList()__        }_        if (context.request().scroll() != null) {_            TopDocs topDocs = context.queryResult().topDocs().topDocs__            docIdsToLoad = new int[topDocs.scoreDocs.length + numSuggestDocs]__            for (int i = 0_ i < topDocs.scoreDocs.length_ i++) {_                docIdsToLoad[docsOffset++] = topDocs.scoreDocs[i].doc__            }_        } else {_            TopDocs topDocs = context.queryResult().topDocs().topDocs__            if (topDocs.scoreDocs.length < context.from()) {_                _                docIdsToLoad = new int[numSuggestDocs]__            } else {_                int totalSize = context.from() + context.size()__                docIdsToLoad = new int[Math.min(topDocs.scoreDocs.length - context.from(), context.size()) +_                    numSuggestDocs]__                for (int i = context.from()_ i < Math.min(totalSize, topDocs.scoreDocs.length)_ i++) {_                    docIdsToLoad[docsOffset++] = topDocs.scoreDocs[i].doc__                }_            }_        }_        for (CompletionSuggestion completionSuggestion : completionSuggestions) {_            for (CompletionSuggestion.Entry.Option option : completionSuggestion.getOptions()) {_                docIdsToLoad[docsOffset++] = option.getDoc().doc__            }_        }_        context.docIdsToLoad(docIdsToLoad, 0, docIdsToLoad.length)__    };shortcut,ids,to,load,we,load,only,from,and,up,to,size,the,phase,controller,handles,this,as,well,since,the,result,is,always,size,shards,for;private,void,shortcut,doc,ids,to,load,search,context,context,final,int,doc,ids,to,load,int,docs,offset,0,final,suggest,suggest,context,query,result,suggest,int,num,suggest,docs,0,final,list,completion,suggestion,completion,suggestions,if,suggest,null,suggest,has,score,docs,completion,suggestions,suggest,filter,completion,suggestion,class,for,completion,suggestion,completion,suggestion,completion,suggestions,num,suggest,docs,completion,suggestion,get,options,size,else,completion,suggestions,collections,empty,list,if,context,request,scroll,null,top,docs,top,docs,context,query,result,top,docs,top,docs,doc,ids,to,load,new,int,top,docs,score,docs,length,num,suggest,docs,for,int,i,0,i,top,docs,score,docs,length,i,doc,ids,to,load,docs,offset,top,docs,score,docs,i,doc,else,top,docs,top,docs,context,query,result,top,docs,top,docs,if,top,docs,score,docs,length,context,from,doc,ids,to,load,new,int,num,suggest,docs,else,int,total,size,context,from,context,size,doc,ids,to,load,new,int,math,min,top,docs,score,docs,length,context,from,context,size,num,suggest,docs,for,int,i,context,from,i,math,min,total,size,top,docs,score,docs,length,i,doc,ids,to,load,docs,offset,top,docs,score,docs,i,doc,for,completion,suggestion,completion,suggestion,completion,suggestions,for,completion,suggestion,entry,option,option,completion,suggestion,get,options,doc,ids,to,load,docs,offset,option,get,doc,doc,context,doc,ids,to,load,doc,ids,to,load,0,doc,ids,to,load,length
SearchService -> private void shortcutDocIdsToLoad(SearchContext context);1541092382;Shortcut ids to load, we load only "from" and up to "size". The phase controller_handles this as well since the result is always size * shards for Q_T_F;private void shortcutDocIdsToLoad(SearchContext context) {_        final int[] docIdsToLoad__        int docsOffset = 0__        final Suggest suggest = context.queryResult().suggest()__        int numSuggestDocs = 0__        final List<CompletionSuggestion> completionSuggestions__        if (suggest != null && suggest.hasScoreDocs()) {_            completionSuggestions = suggest.filter(CompletionSuggestion.class)__            for (CompletionSuggestion completionSuggestion : completionSuggestions) {_                numSuggestDocs += completionSuggestion.getOptions().size()__            }_        } else {_            completionSuggestions = Collections.emptyList()__        }_        if (context.request().scroll() != null) {_            TopDocs topDocs = context.queryResult().topDocs().topDocs__            docIdsToLoad = new int[topDocs.scoreDocs.length + numSuggestDocs]__            for (int i = 0_ i < topDocs.scoreDocs.length_ i++) {_                docIdsToLoad[docsOffset++] = topDocs.scoreDocs[i].doc__            }_        } else {_            TopDocs topDocs = context.queryResult().topDocs().topDocs__            if (topDocs.scoreDocs.length < context.from()) {_                _                docIdsToLoad = new int[numSuggestDocs]__            } else {_                int totalSize = context.from() + context.size()__                docIdsToLoad = new int[Math.min(topDocs.scoreDocs.length - context.from(), context.size()) +_                    numSuggestDocs]__                for (int i = context.from()_ i < Math.min(totalSize, topDocs.scoreDocs.length)_ i++) {_                    docIdsToLoad[docsOffset++] = topDocs.scoreDocs[i].doc__                }_            }_        }_        for (CompletionSuggestion completionSuggestion : completionSuggestions) {_            for (CompletionSuggestion.Entry.Option option : completionSuggestion.getOptions()) {_                docIdsToLoad[docsOffset++] = option.getDoc().doc__            }_        }_        context.docIdsToLoad(docIdsToLoad, 0, docIdsToLoad.length)__    };shortcut,ids,to,load,we,load,only,from,and,up,to,size,the,phase,controller,handles,this,as,well,since,the,result,is,always,size,shards,for;private,void,shortcut,doc,ids,to,load,search,context,context,final,int,doc,ids,to,load,int,docs,offset,0,final,suggest,suggest,context,query,result,suggest,int,num,suggest,docs,0,final,list,completion,suggestion,completion,suggestions,if,suggest,null,suggest,has,score,docs,completion,suggestions,suggest,filter,completion,suggestion,class,for,completion,suggestion,completion,suggestion,completion,suggestions,num,suggest,docs,completion,suggestion,get,options,size,else,completion,suggestions,collections,empty,list,if,context,request,scroll,null,top,docs,top,docs,context,query,result,top,docs,top,docs,doc,ids,to,load,new,int,top,docs,score,docs,length,num,suggest,docs,for,int,i,0,i,top,docs,score,docs,length,i,doc,ids,to,load,docs,offset,top,docs,score,docs,i,doc,else,top,docs,top,docs,context,query,result,top,docs,top,docs,if,top,docs,score,docs,length,context,from,doc,ids,to,load,new,int,num,suggest,docs,else,int,total,size,context,from,context,size,doc,ids,to,load,new,int,math,min,top,docs,score,docs,length,context,from,context,size,num,suggest,docs,for,int,i,context,from,i,math,min,total,size,top,docs,score,docs,length,i,doc,ids,to,load,docs,offset,top,docs,score,docs,i,doc,for,completion,suggestion,completion,suggestion,completion,suggestions,for,completion,suggestion,entry,option,option,completion,suggestion,get,options,doc,ids,to,load,docs,offset,option,get,doc,doc,context,doc,ids,to,load,doc,ids,to,load,0,doc,ids,to,load,length
SearchService -> private void shortcutDocIdsToLoad(SearchContext context);1542117235;Shortcut ids to load, we load only "from" and up to "size". The phase controller_handles this as well since the result is always size * shards for Q_T_F;private void shortcutDocIdsToLoad(SearchContext context) {_        final int[] docIdsToLoad__        int docsOffset = 0__        final Suggest suggest = context.queryResult().suggest()__        int numSuggestDocs = 0__        final List<CompletionSuggestion> completionSuggestions__        if (suggest != null && suggest.hasScoreDocs()) {_            completionSuggestions = suggest.filter(CompletionSuggestion.class)__            for (CompletionSuggestion completionSuggestion : completionSuggestions) {_                numSuggestDocs += completionSuggestion.getOptions().size()__            }_        } else {_            completionSuggestions = Collections.emptyList()__        }_        if (context.request().scroll() != null) {_            TopDocs topDocs = context.queryResult().topDocs().topDocs__            docIdsToLoad = new int[topDocs.scoreDocs.length + numSuggestDocs]__            for (int i = 0_ i < topDocs.scoreDocs.length_ i++) {_                docIdsToLoad[docsOffset++] = topDocs.scoreDocs[i].doc__            }_        } else {_            TopDocs topDocs = context.queryResult().topDocs().topDocs__            if (topDocs.scoreDocs.length < context.from()) {_                _                docIdsToLoad = new int[numSuggestDocs]__            } else {_                int totalSize = context.from() + context.size()__                docIdsToLoad = new int[Math.min(topDocs.scoreDocs.length - context.from(), context.size()) +_                    numSuggestDocs]__                for (int i = context.from()_ i < Math.min(totalSize, topDocs.scoreDocs.length)_ i++) {_                    docIdsToLoad[docsOffset++] = topDocs.scoreDocs[i].doc__                }_            }_        }_        for (CompletionSuggestion completionSuggestion : completionSuggestions) {_            for (CompletionSuggestion.Entry.Option option : completionSuggestion.getOptions()) {_                docIdsToLoad[docsOffset++] = option.getDoc().doc__            }_        }_        context.docIdsToLoad(docIdsToLoad, 0, docIdsToLoad.length)__    };shortcut,ids,to,load,we,load,only,from,and,up,to,size,the,phase,controller,handles,this,as,well,since,the,result,is,always,size,shards,for;private,void,shortcut,doc,ids,to,load,search,context,context,final,int,doc,ids,to,load,int,docs,offset,0,final,suggest,suggest,context,query,result,suggest,int,num,suggest,docs,0,final,list,completion,suggestion,completion,suggestions,if,suggest,null,suggest,has,score,docs,completion,suggestions,suggest,filter,completion,suggestion,class,for,completion,suggestion,completion,suggestion,completion,suggestions,num,suggest,docs,completion,suggestion,get,options,size,else,completion,suggestions,collections,empty,list,if,context,request,scroll,null,top,docs,top,docs,context,query,result,top,docs,top,docs,doc,ids,to,load,new,int,top,docs,score,docs,length,num,suggest,docs,for,int,i,0,i,top,docs,score,docs,length,i,doc,ids,to,load,docs,offset,top,docs,score,docs,i,doc,else,top,docs,top,docs,context,query,result,top,docs,top,docs,if,top,docs,score,docs,length,context,from,doc,ids,to,load,new,int,num,suggest,docs,else,int,total,size,context,from,context,size,doc,ids,to,load,new,int,math,min,top,docs,score,docs,length,context,from,context,size,num,suggest,docs,for,int,i,context,from,i,math,min,total,size,top,docs,score,docs,length,i,doc,ids,to,load,docs,offset,top,docs,score,docs,i,doc,for,completion,suggestion,completion,suggestion,completion,suggestions,for,completion,suggestion,entry,option,option,completion,suggestion,get,options,doc,ids,to,load,docs,offset,option,get,doc,doc,context,doc,ids,to,load,doc,ids,to,load,0,doc,ids,to,load,length
SearchService -> private void shortcutDocIdsToLoad(SearchContext context);1542646292;Shortcut ids to load, we load only "from" and up to "size". The phase controller_handles this as well since the result is always size * shards for Q_T_F;private void shortcutDocIdsToLoad(SearchContext context) {_        final int[] docIdsToLoad__        int docsOffset = 0__        final Suggest suggest = context.queryResult().suggest()__        int numSuggestDocs = 0__        final List<CompletionSuggestion> completionSuggestions__        if (suggest != null && suggest.hasScoreDocs()) {_            completionSuggestions = suggest.filter(CompletionSuggestion.class)__            for (CompletionSuggestion completionSuggestion : completionSuggestions) {_                numSuggestDocs += completionSuggestion.getOptions().size()__            }_        } else {_            completionSuggestions = Collections.emptyList()__        }_        if (context.request().scroll() != null) {_            TopDocs topDocs = context.queryResult().topDocs().topDocs__            docIdsToLoad = new int[topDocs.scoreDocs.length + numSuggestDocs]__            for (int i = 0_ i < topDocs.scoreDocs.length_ i++) {_                docIdsToLoad[docsOffset++] = topDocs.scoreDocs[i].doc__            }_        } else {_            TopDocs topDocs = context.queryResult().topDocs().topDocs__            if (topDocs.scoreDocs.length < context.from()) {_                _                docIdsToLoad = new int[numSuggestDocs]__            } else {_                int totalSize = context.from() + context.size()__                docIdsToLoad = new int[Math.min(topDocs.scoreDocs.length - context.from(), context.size()) +_                    numSuggestDocs]__                for (int i = context.from()_ i < Math.min(totalSize, topDocs.scoreDocs.length)_ i++) {_                    docIdsToLoad[docsOffset++] = topDocs.scoreDocs[i].doc__                }_            }_        }_        for (CompletionSuggestion completionSuggestion : completionSuggestions) {_            for (CompletionSuggestion.Entry.Option option : completionSuggestion.getOptions()) {_                docIdsToLoad[docsOffset++] = option.getDoc().doc__            }_        }_        context.docIdsToLoad(docIdsToLoad, 0, docIdsToLoad.length)__    };shortcut,ids,to,load,we,load,only,from,and,up,to,size,the,phase,controller,handles,this,as,well,since,the,result,is,always,size,shards,for;private,void,shortcut,doc,ids,to,load,search,context,context,final,int,doc,ids,to,load,int,docs,offset,0,final,suggest,suggest,context,query,result,suggest,int,num,suggest,docs,0,final,list,completion,suggestion,completion,suggestions,if,suggest,null,suggest,has,score,docs,completion,suggestions,suggest,filter,completion,suggestion,class,for,completion,suggestion,completion,suggestion,completion,suggestions,num,suggest,docs,completion,suggestion,get,options,size,else,completion,suggestions,collections,empty,list,if,context,request,scroll,null,top,docs,top,docs,context,query,result,top,docs,top,docs,doc,ids,to,load,new,int,top,docs,score,docs,length,num,suggest,docs,for,int,i,0,i,top,docs,score,docs,length,i,doc,ids,to,load,docs,offset,top,docs,score,docs,i,doc,else,top,docs,top,docs,context,query,result,top,docs,top,docs,if,top,docs,score,docs,length,context,from,doc,ids,to,load,new,int,num,suggest,docs,else,int,total,size,context,from,context,size,doc,ids,to,load,new,int,math,min,top,docs,score,docs,length,context,from,context,size,num,suggest,docs,for,int,i,context,from,i,math,min,total,size,top,docs,score,docs,length,i,doc,ids,to,load,docs,offset,top,docs,score,docs,i,doc,for,completion,suggestion,completion,suggestion,completion,suggestions,for,completion,suggestion,entry,option,option,completion,suggestion,get,options,doc,ids,to,load,docs,offset,option,get,doc,doc,context,doc,ids,to,load,doc,ids,to,load,0,doc,ids,to,load,length
SearchService -> private void shortcutDocIdsToLoad(SearchContext context);1543047942;Shortcut ids to load, we load only "from" and up to "size". The phase controller_handles this as well since the result is always size * shards for Q_T_F;private void shortcutDocIdsToLoad(SearchContext context) {_        final int[] docIdsToLoad__        int docsOffset = 0__        final Suggest suggest = context.queryResult().suggest()__        int numSuggestDocs = 0__        final List<CompletionSuggestion> completionSuggestions__        if (suggest != null && suggest.hasScoreDocs()) {_            completionSuggestions = suggest.filter(CompletionSuggestion.class)__            for (CompletionSuggestion completionSuggestion : completionSuggestions) {_                numSuggestDocs += completionSuggestion.getOptions().size()__            }_        } else {_            completionSuggestions = Collections.emptyList()__        }_        if (context.request().scroll() != null) {_            TopDocs topDocs = context.queryResult().topDocs().topDocs__            docIdsToLoad = new int[topDocs.scoreDocs.length + numSuggestDocs]__            for (int i = 0_ i < topDocs.scoreDocs.length_ i++) {_                docIdsToLoad[docsOffset++] = topDocs.scoreDocs[i].doc__            }_        } else {_            TopDocs topDocs = context.queryResult().topDocs().topDocs__            if (topDocs.scoreDocs.length < context.from()) {_                _                docIdsToLoad = new int[numSuggestDocs]__            } else {_                int totalSize = context.from() + context.size()__                docIdsToLoad = new int[Math.min(topDocs.scoreDocs.length - context.from(), context.size()) +_                    numSuggestDocs]__                for (int i = context.from()_ i < Math.min(totalSize, topDocs.scoreDocs.length)_ i++) {_                    docIdsToLoad[docsOffset++] = topDocs.scoreDocs[i].doc__                }_            }_        }_        for (CompletionSuggestion completionSuggestion : completionSuggestions) {_            for (CompletionSuggestion.Entry.Option option : completionSuggestion.getOptions()) {_                docIdsToLoad[docsOffset++] = option.getDoc().doc__            }_        }_        context.docIdsToLoad(docIdsToLoad, 0, docIdsToLoad.length)__    };shortcut,ids,to,load,we,load,only,from,and,up,to,size,the,phase,controller,handles,this,as,well,since,the,result,is,always,size,shards,for;private,void,shortcut,doc,ids,to,load,search,context,context,final,int,doc,ids,to,load,int,docs,offset,0,final,suggest,suggest,context,query,result,suggest,int,num,suggest,docs,0,final,list,completion,suggestion,completion,suggestions,if,suggest,null,suggest,has,score,docs,completion,suggestions,suggest,filter,completion,suggestion,class,for,completion,suggestion,completion,suggestion,completion,suggestions,num,suggest,docs,completion,suggestion,get,options,size,else,completion,suggestions,collections,empty,list,if,context,request,scroll,null,top,docs,top,docs,context,query,result,top,docs,top,docs,doc,ids,to,load,new,int,top,docs,score,docs,length,num,suggest,docs,for,int,i,0,i,top,docs,score,docs,length,i,doc,ids,to,load,docs,offset,top,docs,score,docs,i,doc,else,top,docs,top,docs,context,query,result,top,docs,top,docs,if,top,docs,score,docs,length,context,from,doc,ids,to,load,new,int,num,suggest,docs,else,int,total,size,context,from,context,size,doc,ids,to,load,new,int,math,min,top,docs,score,docs,length,context,from,context,size,num,suggest,docs,for,int,i,context,from,i,math,min,total,size,top,docs,score,docs,length,i,doc,ids,to,load,docs,offset,top,docs,score,docs,i,doc,for,completion,suggestion,completion,suggestion,completion,suggestions,for,completion,suggestion,entry,option,option,completion,suggestion,get,options,doc,ids,to,load,docs,offset,option,get,doc,doc,context,doc,ids,to,load,doc,ids,to,load,0,doc,ids,to,load,length
SearchService -> private void shortcutDocIdsToLoad(SearchContext context);1543236161;Shortcut ids to load, we load only "from" and up to "size". The phase controller_handles this as well since the result is always size * shards for Q_T_F;private void shortcutDocIdsToLoad(SearchContext context) {_        final int[] docIdsToLoad__        int docsOffset = 0__        final Suggest suggest = context.queryResult().suggest()__        int numSuggestDocs = 0__        final List<CompletionSuggestion> completionSuggestions__        if (suggest != null && suggest.hasScoreDocs()) {_            completionSuggestions = suggest.filter(CompletionSuggestion.class)__            for (CompletionSuggestion completionSuggestion : completionSuggestions) {_                numSuggestDocs += completionSuggestion.getOptions().size()__            }_        } else {_            completionSuggestions = Collections.emptyList()__        }_        if (context.request().scroll() != null) {_            TopDocs topDocs = context.queryResult().topDocs().topDocs__            docIdsToLoad = new int[topDocs.scoreDocs.length + numSuggestDocs]__            for (int i = 0_ i < topDocs.scoreDocs.length_ i++) {_                docIdsToLoad[docsOffset++] = topDocs.scoreDocs[i].doc__            }_        } else {_            TopDocs topDocs = context.queryResult().topDocs().topDocs__            if (topDocs.scoreDocs.length < context.from()) {_                _                docIdsToLoad = new int[numSuggestDocs]__            } else {_                int totalSize = context.from() + context.size()__                docIdsToLoad = new int[Math.min(topDocs.scoreDocs.length - context.from(), context.size()) +_                    numSuggestDocs]__                for (int i = context.from()_ i < Math.min(totalSize, topDocs.scoreDocs.length)_ i++) {_                    docIdsToLoad[docsOffset++] = topDocs.scoreDocs[i].doc__                }_            }_        }_        for (CompletionSuggestion completionSuggestion : completionSuggestions) {_            for (CompletionSuggestion.Entry.Option option : completionSuggestion.getOptions()) {_                docIdsToLoad[docsOffset++] = option.getDoc().doc__            }_        }_        context.docIdsToLoad(docIdsToLoad, 0, docIdsToLoad.length)__    };shortcut,ids,to,load,we,load,only,from,and,up,to,size,the,phase,controller,handles,this,as,well,since,the,result,is,always,size,shards,for;private,void,shortcut,doc,ids,to,load,search,context,context,final,int,doc,ids,to,load,int,docs,offset,0,final,suggest,suggest,context,query,result,suggest,int,num,suggest,docs,0,final,list,completion,suggestion,completion,suggestions,if,suggest,null,suggest,has,score,docs,completion,suggestions,suggest,filter,completion,suggestion,class,for,completion,suggestion,completion,suggestion,completion,suggestions,num,suggest,docs,completion,suggestion,get,options,size,else,completion,suggestions,collections,empty,list,if,context,request,scroll,null,top,docs,top,docs,context,query,result,top,docs,top,docs,doc,ids,to,load,new,int,top,docs,score,docs,length,num,suggest,docs,for,int,i,0,i,top,docs,score,docs,length,i,doc,ids,to,load,docs,offset,top,docs,score,docs,i,doc,else,top,docs,top,docs,context,query,result,top,docs,top,docs,if,top,docs,score,docs,length,context,from,doc,ids,to,load,new,int,num,suggest,docs,else,int,total,size,context,from,context,size,doc,ids,to,load,new,int,math,min,top,docs,score,docs,length,context,from,context,size,num,suggest,docs,for,int,i,context,from,i,math,min,total,size,top,docs,score,docs,length,i,doc,ids,to,load,docs,offset,top,docs,score,docs,i,doc,for,completion,suggestion,completion,suggestion,completion,suggestions,for,completion,suggestion,entry,option,option,completion,suggestion,get,options,doc,ids,to,load,docs,offset,option,get,doc,doc,context,doc,ids,to,load,doc,ids,to,load,0,doc,ids,to,load,length
SearchService -> private void shortcutDocIdsToLoad(SearchContext context);1543841718;Shortcut ids to load, we load only "from" and up to "size". The phase controller_handles this as well since the result is always size * shards for Q_T_F;private void shortcutDocIdsToLoad(SearchContext context) {_        final int[] docIdsToLoad__        int docsOffset = 0__        final Suggest suggest = context.queryResult().suggest()__        int numSuggestDocs = 0__        final List<CompletionSuggestion> completionSuggestions__        if (suggest != null && suggest.hasScoreDocs()) {_            completionSuggestions = suggest.filter(CompletionSuggestion.class)__            for (CompletionSuggestion completionSuggestion : completionSuggestions) {_                numSuggestDocs += completionSuggestion.getOptions().size()__            }_        } else {_            completionSuggestions = Collections.emptyList()__        }_        if (context.request().scroll() != null) {_            TopDocs topDocs = context.queryResult().topDocs().topDocs__            docIdsToLoad = new int[topDocs.scoreDocs.length + numSuggestDocs]__            for (int i = 0_ i < topDocs.scoreDocs.length_ i++) {_                docIdsToLoad[docsOffset++] = topDocs.scoreDocs[i].doc__            }_        } else {_            TopDocs topDocs = context.queryResult().topDocs().topDocs__            if (topDocs.scoreDocs.length < context.from()) {_                _                docIdsToLoad = new int[numSuggestDocs]__            } else {_                int totalSize = context.from() + context.size()__                docIdsToLoad = new int[Math.min(topDocs.scoreDocs.length - context.from(), context.size()) +_                    numSuggestDocs]__                for (int i = context.from()_ i < Math.min(totalSize, topDocs.scoreDocs.length)_ i++) {_                    docIdsToLoad[docsOffset++] = topDocs.scoreDocs[i].doc__                }_            }_        }_        for (CompletionSuggestion completionSuggestion : completionSuggestions) {_            for (CompletionSuggestion.Entry.Option option : completionSuggestion.getOptions()) {_                docIdsToLoad[docsOffset++] = option.getDoc().doc__            }_        }_        context.docIdsToLoad(docIdsToLoad, 0, docIdsToLoad.length)__    };shortcut,ids,to,load,we,load,only,from,and,up,to,size,the,phase,controller,handles,this,as,well,since,the,result,is,always,size,shards,for;private,void,shortcut,doc,ids,to,load,search,context,context,final,int,doc,ids,to,load,int,docs,offset,0,final,suggest,suggest,context,query,result,suggest,int,num,suggest,docs,0,final,list,completion,suggestion,completion,suggestions,if,suggest,null,suggest,has,score,docs,completion,suggestions,suggest,filter,completion,suggestion,class,for,completion,suggestion,completion,suggestion,completion,suggestions,num,suggest,docs,completion,suggestion,get,options,size,else,completion,suggestions,collections,empty,list,if,context,request,scroll,null,top,docs,top,docs,context,query,result,top,docs,top,docs,doc,ids,to,load,new,int,top,docs,score,docs,length,num,suggest,docs,for,int,i,0,i,top,docs,score,docs,length,i,doc,ids,to,load,docs,offset,top,docs,score,docs,i,doc,else,top,docs,top,docs,context,query,result,top,docs,top,docs,if,top,docs,score,docs,length,context,from,doc,ids,to,load,new,int,num,suggest,docs,else,int,total,size,context,from,context,size,doc,ids,to,load,new,int,math,min,top,docs,score,docs,length,context,from,context,size,num,suggest,docs,for,int,i,context,from,i,math,min,total,size,top,docs,score,docs,length,i,doc,ids,to,load,docs,offset,top,docs,score,docs,i,doc,for,completion,suggestion,completion,suggestion,completion,suggestions,for,completion,suggestion,entry,option,option,completion,suggestion,get,options,doc,ids,to,load,docs,offset,option,get,doc,doc,context,doc,ids,to,load,doc,ids,to,load,0,doc,ids,to,load,length
SearchService -> private void shortcutDocIdsToLoad(SearchContext context);1543863430;Shortcut ids to load, we load only "from" and up to "size". The phase controller_handles this as well since the result is always size * shards for Q_T_F;private void shortcutDocIdsToLoad(SearchContext context) {_        final int[] docIdsToLoad__        int docsOffset = 0__        final Suggest suggest = context.queryResult().suggest()__        int numSuggestDocs = 0__        final List<CompletionSuggestion> completionSuggestions__        if (suggest != null && suggest.hasScoreDocs()) {_            completionSuggestions = suggest.filter(CompletionSuggestion.class)__            for (CompletionSuggestion completionSuggestion : completionSuggestions) {_                numSuggestDocs += completionSuggestion.getOptions().size()__            }_        } else {_            completionSuggestions = Collections.emptyList()__        }_        if (context.request().scroll() != null) {_            TopDocs topDocs = context.queryResult().topDocs().topDocs__            docIdsToLoad = new int[topDocs.scoreDocs.length + numSuggestDocs]__            for (int i = 0_ i < topDocs.scoreDocs.length_ i++) {_                docIdsToLoad[docsOffset++] = topDocs.scoreDocs[i].doc__            }_        } else {_            TopDocs topDocs = context.queryResult().topDocs().topDocs__            if (topDocs.scoreDocs.length < context.from()) {_                _                docIdsToLoad = new int[numSuggestDocs]__            } else {_                int totalSize = context.from() + context.size()__                docIdsToLoad = new int[Math.min(topDocs.scoreDocs.length - context.from(), context.size()) +_                    numSuggestDocs]__                for (int i = context.from()_ i < Math.min(totalSize, topDocs.scoreDocs.length)_ i++) {_                    docIdsToLoad[docsOffset++] = topDocs.scoreDocs[i].doc__                }_            }_        }_        for (CompletionSuggestion completionSuggestion : completionSuggestions) {_            for (CompletionSuggestion.Entry.Option option : completionSuggestion.getOptions()) {_                docIdsToLoad[docsOffset++] = option.getDoc().doc__            }_        }_        context.docIdsToLoad(docIdsToLoad, 0, docIdsToLoad.length)__    };shortcut,ids,to,load,we,load,only,from,and,up,to,size,the,phase,controller,handles,this,as,well,since,the,result,is,always,size,shards,for;private,void,shortcut,doc,ids,to,load,search,context,context,final,int,doc,ids,to,load,int,docs,offset,0,final,suggest,suggest,context,query,result,suggest,int,num,suggest,docs,0,final,list,completion,suggestion,completion,suggestions,if,suggest,null,suggest,has,score,docs,completion,suggestions,suggest,filter,completion,suggestion,class,for,completion,suggestion,completion,suggestion,completion,suggestions,num,suggest,docs,completion,suggestion,get,options,size,else,completion,suggestions,collections,empty,list,if,context,request,scroll,null,top,docs,top,docs,context,query,result,top,docs,top,docs,doc,ids,to,load,new,int,top,docs,score,docs,length,num,suggest,docs,for,int,i,0,i,top,docs,score,docs,length,i,doc,ids,to,load,docs,offset,top,docs,score,docs,i,doc,else,top,docs,top,docs,context,query,result,top,docs,top,docs,if,top,docs,score,docs,length,context,from,doc,ids,to,load,new,int,num,suggest,docs,else,int,total,size,context,from,context,size,doc,ids,to,load,new,int,math,min,top,docs,score,docs,length,context,from,context,size,num,suggest,docs,for,int,i,context,from,i,math,min,total,size,top,docs,score,docs,length,i,doc,ids,to,load,docs,offset,top,docs,score,docs,i,doc,for,completion,suggestion,completion,suggestion,completion,suggestions,for,completion,suggestion,entry,option,option,completion,suggestion,get,options,doc,ids,to,load,docs,offset,option,get,doc,doc,context,doc,ids,to,load,doc,ids,to,load,0,doc,ids,to,load,length
SearchService -> private void shortcutDocIdsToLoad(SearchContext context);1545997405;Shortcut ids to load, we load only "from" and up to "size". The phase controller_handles this as well since the result is always size * shards for Q_T_F;private void shortcutDocIdsToLoad(SearchContext context) {_        final int[] docIdsToLoad__        int docsOffset = 0__        final Suggest suggest = context.queryResult().suggest()__        int numSuggestDocs = 0__        final List<CompletionSuggestion> completionSuggestions__        if (suggest != null && suggest.hasScoreDocs()) {_            completionSuggestions = suggest.filter(CompletionSuggestion.class)__            for (CompletionSuggestion completionSuggestion : completionSuggestions) {_                numSuggestDocs += completionSuggestion.getOptions().size()__            }_        } else {_            completionSuggestions = Collections.emptyList()__        }_        if (context.request().scroll() != null) {_            TopDocs topDocs = context.queryResult().topDocs().topDocs__            docIdsToLoad = new int[topDocs.scoreDocs.length + numSuggestDocs]__            for (int i = 0_ i < topDocs.scoreDocs.length_ i++) {_                docIdsToLoad[docsOffset++] = topDocs.scoreDocs[i].doc__            }_        } else {_            TopDocs topDocs = context.queryResult().topDocs().topDocs__            if (topDocs.scoreDocs.length < context.from()) {_                _                docIdsToLoad = new int[numSuggestDocs]__            } else {_                int totalSize = context.from() + context.size()__                docIdsToLoad = new int[Math.min(topDocs.scoreDocs.length - context.from(), context.size()) +_                    numSuggestDocs]__                for (int i = context.from()_ i < Math.min(totalSize, topDocs.scoreDocs.length)_ i++) {_                    docIdsToLoad[docsOffset++] = topDocs.scoreDocs[i].doc__                }_            }_        }_        for (CompletionSuggestion completionSuggestion : completionSuggestions) {_            for (CompletionSuggestion.Entry.Option option : completionSuggestion.getOptions()) {_                docIdsToLoad[docsOffset++] = option.getDoc().doc__            }_        }_        context.docIdsToLoad(docIdsToLoad, 0, docIdsToLoad.length)__    };shortcut,ids,to,load,we,load,only,from,and,up,to,size,the,phase,controller,handles,this,as,well,since,the,result,is,always,size,shards,for;private,void,shortcut,doc,ids,to,load,search,context,context,final,int,doc,ids,to,load,int,docs,offset,0,final,suggest,suggest,context,query,result,suggest,int,num,suggest,docs,0,final,list,completion,suggestion,completion,suggestions,if,suggest,null,suggest,has,score,docs,completion,suggestions,suggest,filter,completion,suggestion,class,for,completion,suggestion,completion,suggestion,completion,suggestions,num,suggest,docs,completion,suggestion,get,options,size,else,completion,suggestions,collections,empty,list,if,context,request,scroll,null,top,docs,top,docs,context,query,result,top,docs,top,docs,doc,ids,to,load,new,int,top,docs,score,docs,length,num,suggest,docs,for,int,i,0,i,top,docs,score,docs,length,i,doc,ids,to,load,docs,offset,top,docs,score,docs,i,doc,else,top,docs,top,docs,context,query,result,top,docs,top,docs,if,top,docs,score,docs,length,context,from,doc,ids,to,load,new,int,num,suggest,docs,else,int,total,size,context,from,context,size,doc,ids,to,load,new,int,math,min,top,docs,score,docs,length,context,from,context,size,num,suggest,docs,for,int,i,context,from,i,math,min,total,size,top,docs,score,docs,length,i,doc,ids,to,load,docs,offset,top,docs,score,docs,i,doc,for,completion,suggestion,completion,suggestion,completion,suggestions,for,completion,suggestion,entry,option,option,completion,suggestion,get,options,doc,ids,to,load,docs,offset,option,get,doc,doc,context,doc,ids,to,load,doc,ids,to,load,0,doc,ids,to,load,length
SearchService -> private void shortcutDocIdsToLoad(SearchContext context);1546434630;Shortcut ids to load, we load only "from" and up to "size". The phase controller_handles this as well since the result is always size * shards for Q_T_F;private void shortcutDocIdsToLoad(SearchContext context) {_        final int[] docIdsToLoad__        int docsOffset = 0__        final Suggest suggest = context.queryResult().suggest()__        int numSuggestDocs = 0__        final List<CompletionSuggestion> completionSuggestions__        if (suggest != null && suggest.hasScoreDocs()) {_            completionSuggestions = suggest.filter(CompletionSuggestion.class)__            for (CompletionSuggestion completionSuggestion : completionSuggestions) {_                numSuggestDocs += completionSuggestion.getOptions().size()__            }_        } else {_            completionSuggestions = Collections.emptyList()__        }_        if (context.request().scroll() != null) {_            TopDocs topDocs = context.queryResult().topDocs().topDocs__            docIdsToLoad = new int[topDocs.scoreDocs.length + numSuggestDocs]__            for (int i = 0_ i < topDocs.scoreDocs.length_ i++) {_                docIdsToLoad[docsOffset++] = topDocs.scoreDocs[i].doc__            }_        } else {_            TopDocs topDocs = context.queryResult().topDocs().topDocs__            if (topDocs.scoreDocs.length < context.from()) {_                _                docIdsToLoad = new int[numSuggestDocs]__            } else {_                int totalSize = context.from() + context.size()__                docIdsToLoad = new int[Math.min(topDocs.scoreDocs.length - context.from(), context.size()) +_                    numSuggestDocs]__                for (int i = context.from()_ i < Math.min(totalSize, topDocs.scoreDocs.length)_ i++) {_                    docIdsToLoad[docsOffset++] = topDocs.scoreDocs[i].doc__                }_            }_        }_        for (CompletionSuggestion completionSuggestion : completionSuggestions) {_            for (CompletionSuggestion.Entry.Option option : completionSuggestion.getOptions()) {_                docIdsToLoad[docsOffset++] = option.getDoc().doc__            }_        }_        context.docIdsToLoad(docIdsToLoad, 0, docIdsToLoad.length)__    };shortcut,ids,to,load,we,load,only,from,and,up,to,size,the,phase,controller,handles,this,as,well,since,the,result,is,always,size,shards,for;private,void,shortcut,doc,ids,to,load,search,context,context,final,int,doc,ids,to,load,int,docs,offset,0,final,suggest,suggest,context,query,result,suggest,int,num,suggest,docs,0,final,list,completion,suggestion,completion,suggestions,if,suggest,null,suggest,has,score,docs,completion,suggestions,suggest,filter,completion,suggestion,class,for,completion,suggestion,completion,suggestion,completion,suggestions,num,suggest,docs,completion,suggestion,get,options,size,else,completion,suggestions,collections,empty,list,if,context,request,scroll,null,top,docs,top,docs,context,query,result,top,docs,top,docs,doc,ids,to,load,new,int,top,docs,score,docs,length,num,suggest,docs,for,int,i,0,i,top,docs,score,docs,length,i,doc,ids,to,load,docs,offset,top,docs,score,docs,i,doc,else,top,docs,top,docs,context,query,result,top,docs,top,docs,if,top,docs,score,docs,length,context,from,doc,ids,to,load,new,int,num,suggest,docs,else,int,total,size,context,from,context,size,doc,ids,to,load,new,int,math,min,top,docs,score,docs,length,context,from,context,size,num,suggest,docs,for,int,i,context,from,i,math,min,total,size,top,docs,score,docs,length,i,doc,ids,to,load,docs,offset,top,docs,score,docs,i,doc,for,completion,suggestion,completion,suggestion,completion,suggestions,for,completion,suggestion,entry,option,option,completion,suggestion,get,options,doc,ids,to,load,docs,offset,option,get,doc,doc,context,doc,ids,to,load,doc,ids,to,load,0,doc,ids,to,load,length
SearchService -> private void shortcutDocIdsToLoad(SearchContext context);1546630609;Shortcut ids to load, we load only "from" and up to "size". The phase controller_handles this as well since the result is always size * shards for Q_T_F;private void shortcutDocIdsToLoad(SearchContext context) {_        final int[] docIdsToLoad__        int docsOffset = 0__        final Suggest suggest = context.queryResult().suggest()__        int numSuggestDocs = 0__        final List<CompletionSuggestion> completionSuggestions__        if (suggest != null && suggest.hasScoreDocs()) {_            completionSuggestions = suggest.filter(CompletionSuggestion.class)__            for (CompletionSuggestion completionSuggestion : completionSuggestions) {_                numSuggestDocs += completionSuggestion.getOptions().size()__            }_        } else {_            completionSuggestions = Collections.emptyList()__        }_        if (context.request().scroll() != null) {_            TopDocs topDocs = context.queryResult().topDocs().topDocs__            docIdsToLoad = new int[topDocs.scoreDocs.length + numSuggestDocs]__            for (int i = 0_ i < topDocs.scoreDocs.length_ i++) {_                docIdsToLoad[docsOffset++] = topDocs.scoreDocs[i].doc__            }_        } else {_            TopDocs topDocs = context.queryResult().topDocs().topDocs__            if (topDocs.scoreDocs.length < context.from()) {_                _                docIdsToLoad = new int[numSuggestDocs]__            } else {_                int totalSize = context.from() + context.size()__                docIdsToLoad = new int[Math.min(topDocs.scoreDocs.length - context.from(), context.size()) +_                    numSuggestDocs]__                for (int i = context.from()_ i < Math.min(totalSize, topDocs.scoreDocs.length)_ i++) {_                    docIdsToLoad[docsOffset++] = topDocs.scoreDocs[i].doc__                }_            }_        }_        for (CompletionSuggestion completionSuggestion : completionSuggestions) {_            for (CompletionSuggestion.Entry.Option option : completionSuggestion.getOptions()) {_                docIdsToLoad[docsOffset++] = option.getDoc().doc__            }_        }_        context.docIdsToLoad(docIdsToLoad, 0, docIdsToLoad.length)__    };shortcut,ids,to,load,we,load,only,from,and,up,to,size,the,phase,controller,handles,this,as,well,since,the,result,is,always,size,shards,for;private,void,shortcut,doc,ids,to,load,search,context,context,final,int,doc,ids,to,load,int,docs,offset,0,final,suggest,suggest,context,query,result,suggest,int,num,suggest,docs,0,final,list,completion,suggestion,completion,suggestions,if,suggest,null,suggest,has,score,docs,completion,suggestions,suggest,filter,completion,suggestion,class,for,completion,suggestion,completion,suggestion,completion,suggestions,num,suggest,docs,completion,suggestion,get,options,size,else,completion,suggestions,collections,empty,list,if,context,request,scroll,null,top,docs,top,docs,context,query,result,top,docs,top,docs,doc,ids,to,load,new,int,top,docs,score,docs,length,num,suggest,docs,for,int,i,0,i,top,docs,score,docs,length,i,doc,ids,to,load,docs,offset,top,docs,score,docs,i,doc,else,top,docs,top,docs,context,query,result,top,docs,top,docs,if,top,docs,score,docs,length,context,from,doc,ids,to,load,new,int,num,suggest,docs,else,int,total,size,context,from,context,size,doc,ids,to,load,new,int,math,min,top,docs,score,docs,length,context,from,context,size,num,suggest,docs,for,int,i,context,from,i,math,min,total,size,top,docs,score,docs,length,i,doc,ids,to,load,docs,offset,top,docs,score,docs,i,doc,for,completion,suggestion,completion,suggestion,completion,suggestions,for,completion,suggestion,entry,option,option,completion,suggestion,get,options,doc,ids,to,load,docs,offset,option,get,doc,doc,context,doc,ids,to,load,doc,ids,to,load,0,doc,ids,to,load,length
SearchService -> private void shortcutDocIdsToLoad(SearchContext context);1547625930;Shortcut ids to load, we load only "from" and up to "size". The phase controller_handles this as well since the result is always size * shards for Q_T_F;private void shortcutDocIdsToLoad(SearchContext context) {_        final int[] docIdsToLoad__        int docsOffset = 0__        final Suggest suggest = context.queryResult().suggest()__        int numSuggestDocs = 0__        final List<CompletionSuggestion> completionSuggestions__        if (suggest != null && suggest.hasScoreDocs()) {_            completionSuggestions = suggest.filter(CompletionSuggestion.class)__            for (CompletionSuggestion completionSuggestion : completionSuggestions) {_                numSuggestDocs += completionSuggestion.getOptions().size()__            }_        } else {_            completionSuggestions = Collections.emptyList()__        }_        if (context.request().scroll() != null) {_            TopDocs topDocs = context.queryResult().topDocs().topDocs__            docIdsToLoad = new int[topDocs.scoreDocs.length + numSuggestDocs]__            for (int i = 0_ i < topDocs.scoreDocs.length_ i++) {_                docIdsToLoad[docsOffset++] = topDocs.scoreDocs[i].doc__            }_        } else {_            TopDocs topDocs = context.queryResult().topDocs().topDocs__            if (topDocs.scoreDocs.length < context.from()) {_                _                docIdsToLoad = new int[numSuggestDocs]__            } else {_                int totalSize = context.from() + context.size()__                docIdsToLoad = new int[Math.min(topDocs.scoreDocs.length - context.from(), context.size()) +_                    numSuggestDocs]__                for (int i = context.from()_ i < Math.min(totalSize, topDocs.scoreDocs.length)_ i++) {_                    docIdsToLoad[docsOffset++] = topDocs.scoreDocs[i].doc__                }_            }_        }_        for (CompletionSuggestion completionSuggestion : completionSuggestions) {_            for (CompletionSuggestion.Entry.Option option : completionSuggestion.getOptions()) {_                docIdsToLoad[docsOffset++] = option.getDoc().doc__            }_        }_        context.docIdsToLoad(docIdsToLoad, 0, docIdsToLoad.length)__    };shortcut,ids,to,load,we,load,only,from,and,up,to,size,the,phase,controller,handles,this,as,well,since,the,result,is,always,size,shards,for;private,void,shortcut,doc,ids,to,load,search,context,context,final,int,doc,ids,to,load,int,docs,offset,0,final,suggest,suggest,context,query,result,suggest,int,num,suggest,docs,0,final,list,completion,suggestion,completion,suggestions,if,suggest,null,suggest,has,score,docs,completion,suggestions,suggest,filter,completion,suggestion,class,for,completion,suggestion,completion,suggestion,completion,suggestions,num,suggest,docs,completion,suggestion,get,options,size,else,completion,suggestions,collections,empty,list,if,context,request,scroll,null,top,docs,top,docs,context,query,result,top,docs,top,docs,doc,ids,to,load,new,int,top,docs,score,docs,length,num,suggest,docs,for,int,i,0,i,top,docs,score,docs,length,i,doc,ids,to,load,docs,offset,top,docs,score,docs,i,doc,else,top,docs,top,docs,context,query,result,top,docs,top,docs,if,top,docs,score,docs,length,context,from,doc,ids,to,load,new,int,num,suggest,docs,else,int,total,size,context,from,context,size,doc,ids,to,load,new,int,math,min,top,docs,score,docs,length,context,from,context,size,num,suggest,docs,for,int,i,context,from,i,math,min,total,size,top,docs,score,docs,length,i,doc,ids,to,load,docs,offset,top,docs,score,docs,i,doc,for,completion,suggestion,completion,suggestion,completion,suggestions,for,completion,suggestion,entry,option,option,completion,suggestion,get,options,doc,ids,to,load,docs,offset,option,get,doc,doc,context,doc,ids,to,load,doc,ids,to,load,0,doc,ids,to,load,length
SearchService -> private void shortcutDocIdsToLoad(SearchContext context);1548230518;Shortcut ids to load, we load only "from" and up to "size". The phase controller_handles this as well since the result is always size * shards for Q_T_F;private void shortcutDocIdsToLoad(SearchContext context) {_        final int[] docIdsToLoad__        int docsOffset = 0__        final Suggest suggest = context.queryResult().suggest()__        int numSuggestDocs = 0__        final List<CompletionSuggestion> completionSuggestions__        if (suggest != null && suggest.hasScoreDocs()) {_            completionSuggestions = suggest.filter(CompletionSuggestion.class)__            for (CompletionSuggestion completionSuggestion : completionSuggestions) {_                numSuggestDocs += completionSuggestion.getOptions().size()__            }_        } else {_            completionSuggestions = Collections.emptyList()__        }_        if (context.request().scroll() != null) {_            TopDocs topDocs = context.queryResult().topDocs().topDocs__            docIdsToLoad = new int[topDocs.scoreDocs.length + numSuggestDocs]__            for (int i = 0_ i < topDocs.scoreDocs.length_ i++) {_                docIdsToLoad[docsOffset++] = topDocs.scoreDocs[i].doc__            }_        } else {_            TopDocs topDocs = context.queryResult().topDocs().topDocs__            if (topDocs.scoreDocs.length < context.from()) {_                _                docIdsToLoad = new int[numSuggestDocs]__            } else {_                int totalSize = context.from() + context.size()__                docIdsToLoad = new int[Math.min(topDocs.scoreDocs.length - context.from(), context.size()) +_                    numSuggestDocs]__                for (int i = context.from()_ i < Math.min(totalSize, topDocs.scoreDocs.length)_ i++) {_                    docIdsToLoad[docsOffset++] = topDocs.scoreDocs[i].doc__                }_            }_        }_        for (CompletionSuggestion completionSuggestion : completionSuggestions) {_            for (CompletionSuggestion.Entry.Option option : completionSuggestion.getOptions()) {_                docIdsToLoad[docsOffset++] = option.getDoc().doc__            }_        }_        context.docIdsToLoad(docIdsToLoad, 0, docIdsToLoad.length)__    };shortcut,ids,to,load,we,load,only,from,and,up,to,size,the,phase,controller,handles,this,as,well,since,the,result,is,always,size,shards,for;private,void,shortcut,doc,ids,to,load,search,context,context,final,int,doc,ids,to,load,int,docs,offset,0,final,suggest,suggest,context,query,result,suggest,int,num,suggest,docs,0,final,list,completion,suggestion,completion,suggestions,if,suggest,null,suggest,has,score,docs,completion,suggestions,suggest,filter,completion,suggestion,class,for,completion,suggestion,completion,suggestion,completion,suggestions,num,suggest,docs,completion,suggestion,get,options,size,else,completion,suggestions,collections,empty,list,if,context,request,scroll,null,top,docs,top,docs,context,query,result,top,docs,top,docs,doc,ids,to,load,new,int,top,docs,score,docs,length,num,suggest,docs,for,int,i,0,i,top,docs,score,docs,length,i,doc,ids,to,load,docs,offset,top,docs,score,docs,i,doc,else,top,docs,top,docs,context,query,result,top,docs,top,docs,if,top,docs,score,docs,length,context,from,doc,ids,to,load,new,int,num,suggest,docs,else,int,total,size,context,from,context,size,doc,ids,to,load,new,int,math,min,top,docs,score,docs,length,context,from,context,size,num,suggest,docs,for,int,i,context,from,i,math,min,total,size,top,docs,score,docs,length,i,doc,ids,to,load,docs,offset,top,docs,score,docs,i,doc,for,completion,suggestion,completion,suggestion,completion,suggestions,for,completion,suggestion,entry,option,option,completion,suggestion,get,options,doc,ids,to,load,docs,offset,option,get,doc,doc,context,doc,ids,to,load,doc,ids,to,load,0,doc,ids,to,load,length
SearchService -> private void shortcutDocIdsToLoad(SearchContext context);1548243524;Shortcut ids to load, we load only "from" and up to "size". The phase controller_handles this as well since the result is always size * shards for Q_T_F;private void shortcutDocIdsToLoad(SearchContext context) {_        final int[] docIdsToLoad__        int docsOffset = 0__        final Suggest suggest = context.queryResult().suggest()__        int numSuggestDocs = 0__        final List<CompletionSuggestion> completionSuggestions__        if (suggest != null && suggest.hasScoreDocs()) {_            completionSuggestions = suggest.filter(CompletionSuggestion.class)__            for (CompletionSuggestion completionSuggestion : completionSuggestions) {_                numSuggestDocs += completionSuggestion.getOptions().size()__            }_        } else {_            completionSuggestions = Collections.emptyList()__        }_        if (context.request().scroll() != null) {_            TopDocs topDocs = context.queryResult().topDocs().topDocs__            docIdsToLoad = new int[topDocs.scoreDocs.length + numSuggestDocs]__            for (int i = 0_ i < topDocs.scoreDocs.length_ i++) {_                docIdsToLoad[docsOffset++] = topDocs.scoreDocs[i].doc__            }_        } else {_            TopDocs topDocs = context.queryResult().topDocs().topDocs__            if (topDocs.scoreDocs.length < context.from()) {_                _                docIdsToLoad = new int[numSuggestDocs]__            } else {_                int totalSize = context.from() + context.size()__                docIdsToLoad = new int[Math.min(topDocs.scoreDocs.length - context.from(), context.size()) +_                    numSuggestDocs]__                for (int i = context.from()_ i < Math.min(totalSize, topDocs.scoreDocs.length)_ i++) {_                    docIdsToLoad[docsOffset++] = topDocs.scoreDocs[i].doc__                }_            }_        }_        for (CompletionSuggestion completionSuggestion : completionSuggestions) {_            for (CompletionSuggestion.Entry.Option option : completionSuggestion.getOptions()) {_                docIdsToLoad[docsOffset++] = option.getDoc().doc__            }_        }_        context.docIdsToLoad(docIdsToLoad, 0, docIdsToLoad.length)__    };shortcut,ids,to,load,we,load,only,from,and,up,to,size,the,phase,controller,handles,this,as,well,since,the,result,is,always,size,shards,for;private,void,shortcut,doc,ids,to,load,search,context,context,final,int,doc,ids,to,load,int,docs,offset,0,final,suggest,suggest,context,query,result,suggest,int,num,suggest,docs,0,final,list,completion,suggestion,completion,suggestions,if,suggest,null,suggest,has,score,docs,completion,suggestions,suggest,filter,completion,suggestion,class,for,completion,suggestion,completion,suggestion,completion,suggestions,num,suggest,docs,completion,suggestion,get,options,size,else,completion,suggestions,collections,empty,list,if,context,request,scroll,null,top,docs,top,docs,context,query,result,top,docs,top,docs,doc,ids,to,load,new,int,top,docs,score,docs,length,num,suggest,docs,for,int,i,0,i,top,docs,score,docs,length,i,doc,ids,to,load,docs,offset,top,docs,score,docs,i,doc,else,top,docs,top,docs,context,query,result,top,docs,top,docs,if,top,docs,score,docs,length,context,from,doc,ids,to,load,new,int,num,suggest,docs,else,int,total,size,context,from,context,size,doc,ids,to,load,new,int,math,min,top,docs,score,docs,length,context,from,context,size,num,suggest,docs,for,int,i,context,from,i,math,min,total,size,top,docs,score,docs,length,i,doc,ids,to,load,docs,offset,top,docs,score,docs,i,doc,for,completion,suggestion,completion,suggestion,completion,suggestions,for,completion,suggestion,entry,option,option,completion,suggestion,get,options,doc,ids,to,load,docs,offset,option,get,doc,doc,context,doc,ids,to,load,doc,ids,to,load,0,doc,ids,to,load,length
SearchService -> private void shortcutDocIdsToLoad(SearchContext context);1548420339;Shortcut ids to load, we load only "from" and up to "size". The phase controller_handles this as well since the result is always size * shards for Q_T_F;private void shortcutDocIdsToLoad(SearchContext context) {_        final int[] docIdsToLoad__        int docsOffset = 0__        final Suggest suggest = context.queryResult().suggest()__        int numSuggestDocs = 0__        final List<CompletionSuggestion> completionSuggestions__        if (suggest != null && suggest.hasScoreDocs()) {_            completionSuggestions = suggest.filter(CompletionSuggestion.class)__            for (CompletionSuggestion completionSuggestion : completionSuggestions) {_                numSuggestDocs += completionSuggestion.getOptions().size()__            }_        } else {_            completionSuggestions = Collections.emptyList()__        }_        if (context.request().scroll() != null) {_            TopDocs topDocs = context.queryResult().topDocs().topDocs__            docIdsToLoad = new int[topDocs.scoreDocs.length + numSuggestDocs]__            for (int i = 0_ i < topDocs.scoreDocs.length_ i++) {_                docIdsToLoad[docsOffset++] = topDocs.scoreDocs[i].doc__            }_        } else {_            TopDocs topDocs = context.queryResult().topDocs().topDocs__            if (topDocs.scoreDocs.length < context.from()) {_                _                docIdsToLoad = new int[numSuggestDocs]__            } else {_                int totalSize = context.from() + context.size()__                docIdsToLoad = new int[Math.min(topDocs.scoreDocs.length - context.from(), context.size()) +_                    numSuggestDocs]__                for (int i = context.from()_ i < Math.min(totalSize, topDocs.scoreDocs.length)_ i++) {_                    docIdsToLoad[docsOffset++] = topDocs.scoreDocs[i].doc__                }_            }_        }_        for (CompletionSuggestion completionSuggestion : completionSuggestions) {_            for (CompletionSuggestion.Entry.Option option : completionSuggestion.getOptions()) {_                docIdsToLoad[docsOffset++] = option.getDoc().doc__            }_        }_        context.docIdsToLoad(docIdsToLoad, 0, docIdsToLoad.length)__    };shortcut,ids,to,load,we,load,only,from,and,up,to,size,the,phase,controller,handles,this,as,well,since,the,result,is,always,size,shards,for;private,void,shortcut,doc,ids,to,load,search,context,context,final,int,doc,ids,to,load,int,docs,offset,0,final,suggest,suggest,context,query,result,suggest,int,num,suggest,docs,0,final,list,completion,suggestion,completion,suggestions,if,suggest,null,suggest,has,score,docs,completion,suggestions,suggest,filter,completion,suggestion,class,for,completion,suggestion,completion,suggestion,completion,suggestions,num,suggest,docs,completion,suggestion,get,options,size,else,completion,suggestions,collections,empty,list,if,context,request,scroll,null,top,docs,top,docs,context,query,result,top,docs,top,docs,doc,ids,to,load,new,int,top,docs,score,docs,length,num,suggest,docs,for,int,i,0,i,top,docs,score,docs,length,i,doc,ids,to,load,docs,offset,top,docs,score,docs,i,doc,else,top,docs,top,docs,context,query,result,top,docs,top,docs,if,top,docs,score,docs,length,context,from,doc,ids,to,load,new,int,num,suggest,docs,else,int,total,size,context,from,context,size,doc,ids,to,load,new,int,math,min,top,docs,score,docs,length,context,from,context,size,num,suggest,docs,for,int,i,context,from,i,math,min,total,size,top,docs,score,docs,length,i,doc,ids,to,load,docs,offset,top,docs,score,docs,i,doc,for,completion,suggestion,completion,suggestion,completion,suggestions,for,completion,suggestion,entry,option,option,completion,suggestion,get,options,doc,ids,to,load,docs,offset,option,get,doc,doc,context,doc,ids,to,load,doc,ids,to,load,0,doc,ids,to,load,length
SearchService -> private void shortcutDocIdsToLoad(SearchContext context);1548943934;Shortcut ids to load, we load only "from" and up to "size". The phase controller_handles this as well since the result is always size * shards for Q_T_F;private void shortcutDocIdsToLoad(SearchContext context) {_        final int[] docIdsToLoad__        int docsOffset = 0__        final Suggest suggest = context.queryResult().suggest()__        int numSuggestDocs = 0__        final List<CompletionSuggestion> completionSuggestions__        if (suggest != null && suggest.hasScoreDocs()) {_            completionSuggestions = suggest.filter(CompletionSuggestion.class)__            for (CompletionSuggestion completionSuggestion : completionSuggestions) {_                numSuggestDocs += completionSuggestion.getOptions().size()__            }_        } else {_            completionSuggestions = Collections.emptyList()__        }_        if (context.request().scroll() != null) {_            TopDocs topDocs = context.queryResult().topDocs().topDocs__            docIdsToLoad = new int[topDocs.scoreDocs.length + numSuggestDocs]__            for (int i = 0_ i < topDocs.scoreDocs.length_ i++) {_                docIdsToLoad[docsOffset++] = topDocs.scoreDocs[i].doc__            }_        } else {_            TopDocs topDocs = context.queryResult().topDocs().topDocs__            if (topDocs.scoreDocs.length < context.from()) {_                _                docIdsToLoad = new int[numSuggestDocs]__            } else {_                int totalSize = context.from() + context.size()__                docIdsToLoad = new int[Math.min(topDocs.scoreDocs.length - context.from(), context.size()) +_                    numSuggestDocs]__                for (int i = context.from()_ i < Math.min(totalSize, topDocs.scoreDocs.length)_ i++) {_                    docIdsToLoad[docsOffset++] = topDocs.scoreDocs[i].doc__                }_            }_        }_        for (CompletionSuggestion completionSuggestion : completionSuggestions) {_            for (CompletionSuggestion.Entry.Option option : completionSuggestion.getOptions()) {_                docIdsToLoad[docsOffset++] = option.getDoc().doc__            }_        }_        context.docIdsToLoad(docIdsToLoad, 0, docIdsToLoad.length)__    };shortcut,ids,to,load,we,load,only,from,and,up,to,size,the,phase,controller,handles,this,as,well,since,the,result,is,always,size,shards,for;private,void,shortcut,doc,ids,to,load,search,context,context,final,int,doc,ids,to,load,int,docs,offset,0,final,suggest,suggest,context,query,result,suggest,int,num,suggest,docs,0,final,list,completion,suggestion,completion,suggestions,if,suggest,null,suggest,has,score,docs,completion,suggestions,suggest,filter,completion,suggestion,class,for,completion,suggestion,completion,suggestion,completion,suggestions,num,suggest,docs,completion,suggestion,get,options,size,else,completion,suggestions,collections,empty,list,if,context,request,scroll,null,top,docs,top,docs,context,query,result,top,docs,top,docs,doc,ids,to,load,new,int,top,docs,score,docs,length,num,suggest,docs,for,int,i,0,i,top,docs,score,docs,length,i,doc,ids,to,load,docs,offset,top,docs,score,docs,i,doc,else,top,docs,top,docs,context,query,result,top,docs,top,docs,if,top,docs,score,docs,length,context,from,doc,ids,to,load,new,int,num,suggest,docs,else,int,total,size,context,from,context,size,doc,ids,to,load,new,int,math,min,top,docs,score,docs,length,context,from,context,size,num,suggest,docs,for,int,i,context,from,i,math,min,total,size,top,docs,score,docs,length,i,doc,ids,to,load,docs,offset,top,docs,score,docs,i,doc,for,completion,suggestion,completion,suggestion,completion,suggestions,for,completion,suggestion,entry,option,option,completion,suggestion,get,options,doc,ids,to,load,docs,offset,option,get,doc,doc,context,doc,ids,to,load,doc,ids,to,load,0,doc,ids,to,load,length
SearchService -> private void shortcutDocIdsToLoad(SearchContext context);1550737421;Shortcut ids to load, we load only "from" and up to "size". The phase controller_handles this as well since the result is always size * shards for Q_T_F;private void shortcutDocIdsToLoad(SearchContext context) {_        final int[] docIdsToLoad__        int docsOffset = 0__        final Suggest suggest = context.queryResult().suggest()__        int numSuggestDocs = 0__        final List<CompletionSuggestion> completionSuggestions__        if (suggest != null && suggest.hasScoreDocs()) {_            completionSuggestions = suggest.filter(CompletionSuggestion.class)__            for (CompletionSuggestion completionSuggestion : completionSuggestions) {_                numSuggestDocs += completionSuggestion.getOptions().size()__            }_        } else {_            completionSuggestions = Collections.emptyList()__        }_        if (context.request().scroll() != null) {_            TopDocs topDocs = context.queryResult().topDocs().topDocs__            docIdsToLoad = new int[topDocs.scoreDocs.length + numSuggestDocs]__            for (int i = 0_ i < topDocs.scoreDocs.length_ i++) {_                docIdsToLoad[docsOffset++] = topDocs.scoreDocs[i].doc__            }_        } else {_            TopDocs topDocs = context.queryResult().topDocs().topDocs__            if (topDocs.scoreDocs.length < context.from()) {_                _                docIdsToLoad = new int[numSuggestDocs]__            } else {_                int totalSize = context.from() + context.size()__                docIdsToLoad = new int[Math.min(topDocs.scoreDocs.length - context.from(), context.size()) +_                    numSuggestDocs]__                for (int i = context.from()_ i < Math.min(totalSize, topDocs.scoreDocs.length)_ i++) {_                    docIdsToLoad[docsOffset++] = topDocs.scoreDocs[i].doc__                }_            }_        }_        for (CompletionSuggestion completionSuggestion : completionSuggestions) {_            for (CompletionSuggestion.Entry.Option option : completionSuggestion.getOptions()) {_                docIdsToLoad[docsOffset++] = option.getDoc().doc__            }_        }_        context.docIdsToLoad(docIdsToLoad, 0, docIdsToLoad.length)__    };shortcut,ids,to,load,we,load,only,from,and,up,to,size,the,phase,controller,handles,this,as,well,since,the,result,is,always,size,shards,for;private,void,shortcut,doc,ids,to,load,search,context,context,final,int,doc,ids,to,load,int,docs,offset,0,final,suggest,suggest,context,query,result,suggest,int,num,suggest,docs,0,final,list,completion,suggestion,completion,suggestions,if,suggest,null,suggest,has,score,docs,completion,suggestions,suggest,filter,completion,suggestion,class,for,completion,suggestion,completion,suggestion,completion,suggestions,num,suggest,docs,completion,suggestion,get,options,size,else,completion,suggestions,collections,empty,list,if,context,request,scroll,null,top,docs,top,docs,context,query,result,top,docs,top,docs,doc,ids,to,load,new,int,top,docs,score,docs,length,num,suggest,docs,for,int,i,0,i,top,docs,score,docs,length,i,doc,ids,to,load,docs,offset,top,docs,score,docs,i,doc,else,top,docs,top,docs,context,query,result,top,docs,top,docs,if,top,docs,score,docs,length,context,from,doc,ids,to,load,new,int,num,suggest,docs,else,int,total,size,context,from,context,size,doc,ids,to,load,new,int,math,min,top,docs,score,docs,length,context,from,context,size,num,suggest,docs,for,int,i,context,from,i,math,min,total,size,top,docs,score,docs,length,i,doc,ids,to,load,docs,offset,top,docs,score,docs,i,doc,for,completion,suggestion,completion,suggestion,completion,suggestions,for,completion,suggestion,entry,option,option,completion,suggestion,get,options,doc,ids,to,load,docs,offset,option,get,doc,doc,context,doc,ids,to,load,doc,ids,to,load,0,doc,ids,to,load,length
SearchService -> public int getActiveContexts();1524684173;Returns the number of active contexts in this_SearchService;public int getActiveContexts() {_        return this.activeContexts.size()__    };returns,the,number,of,active,contexts,in,this,search,service;public,int,get,active,contexts,return,this,active,contexts,size
SearchService -> public int getActiveContexts();1524780945;Returns the number of active contexts in this_SearchService;public int getActiveContexts() {_        return this.activeContexts.size()__    };returns,the,number,of,active,contexts,in,this,search,service;public,int,get,active,contexts,return,this,active,contexts,size
SearchService -> public int getActiveContexts();1525334055;Returns the number of active contexts in this_SearchService;public int getActiveContexts() {_        return this.activeContexts.size()__    };returns,the,number,of,active,contexts,in,this,search,service;public,int,get,active,contexts,return,this,active,contexts,size
SearchService -> public int getActiveContexts();1527583663;Returns the number of active contexts in this_SearchService;public int getActiveContexts() {_        return this.activeContexts.size()__    };returns,the,number,of,active,contexts,in,this,search,service;public,int,get,active,contexts,return,this,active,contexts,size
SearchService -> public int getActiveContexts();1533641732;Returns the number of active contexts in this_SearchService;public int getActiveContexts() {_        return this.activeContexts.size()__    };returns,the,number,of,active,contexts,in,this,search,service;public,int,get,active,contexts,return,this,active,contexts,size
SearchService -> public int getActiveContexts();1535046779;Returns the number of active contexts in this_SearchService;public int getActiveContexts() {_        return this.activeContexts.size()__    };returns,the,number,of,active,contexts,in,this,search,service;public,int,get,active,contexts,return,this,active,contexts,size
SearchService -> public int getActiveContexts();1536314350;Returns the number of active contexts in this_SearchService;public int getActiveContexts() {_        return this.activeContexts.size()__    };returns,the,number,of,active,contexts,in,this,search,service;public,int,get,active,contexts,return,this,active,contexts,size
SearchService -> public int getActiveContexts();1537806831;Returns the number of active contexts in this_SearchService;public int getActiveContexts() {_        return this.activeContexts.size()__    };returns,the,number,of,active,contexts,in,this,search,service;public,int,get,active,contexts,return,this,active,contexts,size
SearchService -> public int getActiveContexts();1540238977;Returns the number of active contexts in this_SearchService;public int getActiveContexts() {_        return this.activeContexts.size()__    };returns,the,number,of,active,contexts,in,this,search,service;public,int,get,active,contexts,return,this,active,contexts,size
SearchService -> public int getActiveContexts();1540583181;Returns the number of active contexts in this_SearchService;public int getActiveContexts() {_        return this.activeContexts.size()__    };returns,the,number,of,active,contexts,in,this,search,service;public,int,get,active,contexts,return,this,active,contexts,size
SearchService -> public int getActiveContexts();1541008027;Returns the number of active contexts in this_SearchService;public int getActiveContexts() {_        return this.activeContexts.size()__    };returns,the,number,of,active,contexts,in,this,search,service;public,int,get,active,contexts,return,this,active,contexts,size
SearchService -> public int getActiveContexts();1541092382;Returns the number of active contexts in this_SearchService;public int getActiveContexts() {_        return this.activeContexts.size()__    };returns,the,number,of,active,contexts,in,this,search,service;public,int,get,active,contexts,return,this,active,contexts,size
SearchService -> public int getActiveContexts();1542117235;Returns the number of active contexts in this_SearchService;public int getActiveContexts() {_        return this.activeContexts.size()__    };returns,the,number,of,active,contexts,in,this,search,service;public,int,get,active,contexts,return,this,active,contexts,size
SearchService -> public int getActiveContexts();1542646292;Returns the number of active contexts in this_SearchService;public int getActiveContexts() {_        return this.activeContexts.size()__    };returns,the,number,of,active,contexts,in,this,search,service;public,int,get,active,contexts,return,this,active,contexts,size
SearchService -> public int getActiveContexts();1543047942;Returns the number of active contexts in this_SearchService;public int getActiveContexts() {_        return this.activeContexts.size()__    };returns,the,number,of,active,contexts,in,this,search,service;public,int,get,active,contexts,return,this,active,contexts,size
SearchService -> public int getActiveContexts();1543236161;Returns the number of active contexts in this_SearchService;public int getActiveContexts() {_        return this.activeContexts.size()__    };returns,the,number,of,active,contexts,in,this,search,service;public,int,get,active,contexts,return,this,active,contexts,size
SearchService -> public int getActiveContexts();1543841718;Returns the number of active contexts in this_SearchService;public int getActiveContexts() {_        return this.activeContexts.size()__    };returns,the,number,of,active,contexts,in,this,search,service;public,int,get,active,contexts,return,this,active,contexts,size
SearchService -> public int getActiveContexts();1543863430;Returns the number of active contexts in this_SearchService;public int getActiveContexts() {_        return this.activeContexts.size()__    };returns,the,number,of,active,contexts,in,this,search,service;public,int,get,active,contexts,return,this,active,contexts,size
SearchService -> public int getActiveContexts();1545997405;Returns the number of active contexts in this_SearchService;public int getActiveContexts() {_        return this.activeContexts.size()__    };returns,the,number,of,active,contexts,in,this,search,service;public,int,get,active,contexts,return,this,active,contexts,size
SearchService -> public int getActiveContexts();1546434630;Returns the number of active contexts in this_SearchService;public int getActiveContexts() {_        return this.activeContexts.size()__    };returns,the,number,of,active,contexts,in,this,search,service;public,int,get,active,contexts,return,this,active,contexts,size
SearchService -> public int getActiveContexts();1546630609;Returns the number of active contexts in this_SearchService;public int getActiveContexts() {_        return this.activeContexts.size()__    };returns,the,number,of,active,contexts,in,this,search,service;public,int,get,active,contexts,return,this,active,contexts,size
SearchService -> public int getActiveContexts();1547625930;Returns the number of active contexts in this_SearchService;public int getActiveContexts() {_        return this.activeContexts.size()__    };returns,the,number,of,active,contexts,in,this,search,service;public,int,get,active,contexts,return,this,active,contexts,size
SearchService -> public int getActiveContexts();1548230518;Returns the number of active contexts in this_SearchService;public int getActiveContexts() {_        return this.activeContexts.size()__    };returns,the,number,of,active,contexts,in,this,search,service;public,int,get,active,contexts,return,this,active,contexts,size
SearchService -> public int getActiveContexts();1548243524;Returns the number of active contexts in this_SearchService;public int getActiveContexts() {_        return this.activeContexts.size()__    };returns,the,number,of,active,contexts,in,this,search,service;public,int,get,active,contexts,return,this,active,contexts,size
SearchService -> public int getActiveContexts();1548420339;Returns the number of active contexts in this_SearchService;public int getActiveContexts() {_        return this.activeContexts.size()__    };returns,the,number,of,active,contexts,in,this,search,service;public,int,get,active,contexts,return,this,active,contexts,size
SearchService -> public int getActiveContexts();1548943934;Returns the number of active contexts in this_SearchService;public int getActiveContexts() {_        return this.activeContexts.size()__    };returns,the,number,of,active,contexts,in,this,search,service;public,int,get,active,contexts,return,this,active,contexts,size
SearchService -> public int getActiveContexts();1550737421;Returns the number of active contexts in this_SearchService;public int getActiveContexts() {_        return this.activeContexts.size()__    };returns,the,number,of,active,contexts,in,this,search,service;public,int,get,active,contexts,return,this,active,contexts,size
SearchService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1524684173;Returns a new {@link QueryRewriteContext} with the given <tt>now</tt> provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return indicesService.getRewriteContext(nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,tt,now,tt,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,indices,service,get,rewrite,context,now,in,millis
SearchService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1524780945;Returns a new {@link QueryRewriteContext} with the given <tt>now</tt> provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return indicesService.getRewriteContext(nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,tt,now,tt,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,indices,service,get,rewrite,context,now,in,millis
SearchService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1525334055;Returns a new {@link QueryRewriteContext} with the given {@code now} provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return indicesService.getRewriteContext(nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,code,now,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,indices,service,get,rewrite,context,now,in,millis
SearchService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1527583663;Returns a new {@link QueryRewriteContext} with the given {@code now} provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return indicesService.getRewriteContext(nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,code,now,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,indices,service,get,rewrite,context,now,in,millis
SearchService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1533641732;Returns a new {@link QueryRewriteContext} with the given {@code now} provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return indicesService.getRewriteContext(nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,code,now,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,indices,service,get,rewrite,context,now,in,millis
SearchService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1535046779;Returns a new {@link QueryRewriteContext} with the given {@code now} provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return indicesService.getRewriteContext(nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,code,now,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,indices,service,get,rewrite,context,now,in,millis
SearchService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1536314350;Returns a new {@link QueryRewriteContext} with the given {@code now} provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return indicesService.getRewriteContext(nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,code,now,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,indices,service,get,rewrite,context,now,in,millis
SearchService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1537806831;Returns a new {@link QueryRewriteContext} with the given {@code now} provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return indicesService.getRewriteContext(nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,code,now,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,indices,service,get,rewrite,context,now,in,millis
SearchService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1540238977;Returns a new {@link QueryRewriteContext} with the given {@code now} provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return indicesService.getRewriteContext(nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,code,now,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,indices,service,get,rewrite,context,now,in,millis
SearchService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1540583181;Returns a new {@link QueryRewriteContext} with the given {@code now} provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return indicesService.getRewriteContext(nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,code,now,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,indices,service,get,rewrite,context,now,in,millis
SearchService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1541008027;Returns a new {@link QueryRewriteContext} with the given {@code now} provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return indicesService.getRewriteContext(nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,code,now,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,indices,service,get,rewrite,context,now,in,millis
SearchService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1541092382;Returns a new {@link QueryRewriteContext} with the given {@code now} provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return indicesService.getRewriteContext(nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,code,now,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,indices,service,get,rewrite,context,now,in,millis
SearchService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1542117235;Returns a new {@link QueryRewriteContext} with the given {@code now} provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return indicesService.getRewriteContext(nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,code,now,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,indices,service,get,rewrite,context,now,in,millis
SearchService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1542646292;Returns a new {@link QueryRewriteContext} with the given {@code now} provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return indicesService.getRewriteContext(nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,code,now,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,indices,service,get,rewrite,context,now,in,millis
SearchService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1543047942;Returns a new {@link QueryRewriteContext} with the given {@code now} provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return indicesService.getRewriteContext(nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,code,now,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,indices,service,get,rewrite,context,now,in,millis
SearchService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1543236161;Returns a new {@link QueryRewriteContext} with the given {@code now} provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return indicesService.getRewriteContext(nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,code,now,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,indices,service,get,rewrite,context,now,in,millis
SearchService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1543841718;Returns a new {@link QueryRewriteContext} with the given {@code now} provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return indicesService.getRewriteContext(nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,code,now,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,indices,service,get,rewrite,context,now,in,millis
SearchService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1543863430;Returns a new {@link QueryRewriteContext} with the given {@code now} provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return indicesService.getRewriteContext(nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,code,now,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,indices,service,get,rewrite,context,now,in,millis
SearchService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1545997405;Returns a new {@link QueryRewriteContext} with the given {@code now} provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return indicesService.getRewriteContext(nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,code,now,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,indices,service,get,rewrite,context,now,in,millis
SearchService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1546434630;Returns a new {@link QueryRewriteContext} with the given {@code now} provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return indicesService.getRewriteContext(nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,code,now,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,indices,service,get,rewrite,context,now,in,millis
SearchService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1546630609;Returns a new {@link QueryRewriteContext} with the given {@code now} provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return indicesService.getRewriteContext(nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,code,now,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,indices,service,get,rewrite,context,now,in,millis
SearchService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1547625930;Returns a new {@link QueryRewriteContext} with the given {@code now} provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return indicesService.getRewriteContext(nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,code,now,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,indices,service,get,rewrite,context,now,in,millis
SearchService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1548230518;Returns a new {@link QueryRewriteContext} with the given {@code now} provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return indicesService.getRewriteContext(nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,code,now,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,indices,service,get,rewrite,context,now,in,millis
SearchService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1548243524;Returns a new {@link QueryRewriteContext} with the given {@code now} provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return indicesService.getRewriteContext(nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,code,now,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,indices,service,get,rewrite,context,now,in,millis
SearchService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1548420339;Returns a new {@link QueryRewriteContext} with the given {@code now} provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return indicesService.getRewriteContext(nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,code,now,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,indices,service,get,rewrite,context,now,in,millis
SearchService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1548943934;Returns a new {@link QueryRewriteContext} with the given {@code now} provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return indicesService.getRewriteContext(nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,code,now,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,indices,service,get,rewrite,context,now,in,millis
SearchService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1550737421;Returns a new {@link QueryRewriteContext} with the given {@code now} provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return indicesService.getRewriteContext(nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,code,now,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,indices,service,get,rewrite,context,now,in,millis
SearchService -> public static boolean canRewriteToMatchNone(SearchSourceBuilder source);1524684173;Returns true iff the given search source builder can be early terminated by rewriting to a match none query. Or in other words_if the execution of a the search request can be early terminated without executing it. This is for instance not possible if_a global aggregation is part of this request or if there is a suggest builder present.;public static boolean canRewriteToMatchNone(SearchSourceBuilder source) {_        if (source == null || source.query() == null || source.query() instanceof MatchAllQueryBuilder || source.suggest() != null) {_            return false__        } else {_            AggregatorFactories.Builder aggregations = source.aggregations()__            if (aggregations != null) {_                if (aggregations.mustVisitAllDocs()) {_                    return false__                }_            }_        }_        return true__    };returns,true,iff,the,given,search,source,builder,can,be,early,terminated,by,rewriting,to,a,match,none,query,or,in,other,words,if,the,execution,of,a,the,search,request,can,be,early,terminated,without,executing,it,this,is,for,instance,not,possible,if,a,global,aggregation,is,part,of,this,request,or,if,there,is,a,suggest,builder,present;public,static,boolean,can,rewrite,to,match,none,search,source,builder,source,if,source,null,source,query,null,source,query,instanceof,match,all,query,builder,source,suggest,null,return,false,else,aggregator,factories,builder,aggregations,source,aggregations,if,aggregations,null,if,aggregations,must,visit,all,docs,return,false,return,true
SearchService -> public static boolean canRewriteToMatchNone(SearchSourceBuilder source);1524780945;Returns true iff the given search source builder can be early terminated by rewriting to a match none query. Or in other words_if the execution of a the search request can be early terminated without executing it. This is for instance not possible if_a global aggregation is part of this request or if there is a suggest builder present.;public static boolean canRewriteToMatchNone(SearchSourceBuilder source) {_        if (source == null || source.query() == null || source.query() instanceof MatchAllQueryBuilder || source.suggest() != null) {_            return false__        } else {_            AggregatorFactories.Builder aggregations = source.aggregations()__            if (aggregations != null) {_                if (aggregations.mustVisitAllDocs()) {_                    return false__                }_            }_        }_        return true__    };returns,true,iff,the,given,search,source,builder,can,be,early,terminated,by,rewriting,to,a,match,none,query,or,in,other,words,if,the,execution,of,a,the,search,request,can,be,early,terminated,without,executing,it,this,is,for,instance,not,possible,if,a,global,aggregation,is,part,of,this,request,or,if,there,is,a,suggest,builder,present;public,static,boolean,can,rewrite,to,match,none,search,source,builder,source,if,source,null,source,query,null,source,query,instanceof,match,all,query,builder,source,suggest,null,return,false,else,aggregator,factories,builder,aggregations,source,aggregations,if,aggregations,null,if,aggregations,must,visit,all,docs,return,false,return,true
SearchService -> public static boolean canRewriteToMatchNone(SearchSourceBuilder source);1525334055;Returns true iff the given search source builder can be early terminated by rewriting to a match none query. Or in other words_if the execution of a the search request can be early terminated without executing it. This is for instance not possible if_a global aggregation is part of this request or if there is a suggest builder present.;public static boolean canRewriteToMatchNone(SearchSourceBuilder source) {_        if (source == null || source.query() == null || source.query() instanceof MatchAllQueryBuilder || source.suggest() != null) {_            return false__        } else {_            AggregatorFactories.Builder aggregations = source.aggregations()__            if (aggregations != null) {_                if (aggregations.mustVisitAllDocs()) {_                    return false__                }_            }_        }_        return true__    };returns,true,iff,the,given,search,source,builder,can,be,early,terminated,by,rewriting,to,a,match,none,query,or,in,other,words,if,the,execution,of,a,the,search,request,can,be,early,terminated,without,executing,it,this,is,for,instance,not,possible,if,a,global,aggregation,is,part,of,this,request,or,if,there,is,a,suggest,builder,present;public,static,boolean,can,rewrite,to,match,none,search,source,builder,source,if,source,null,source,query,null,source,query,instanceof,match,all,query,builder,source,suggest,null,return,false,else,aggregator,factories,builder,aggregations,source,aggregations,if,aggregations,null,if,aggregations,must,visit,all,docs,return,false,return,true
SearchService -> public static boolean canRewriteToMatchNone(SearchSourceBuilder source);1527583663;Returns true iff the given search source builder can be early terminated by rewriting to a match none query. Or in other words_if the execution of a the search request can be early terminated without executing it. This is for instance not possible if_a global aggregation is part of this request or if there is a suggest builder present.;public static boolean canRewriteToMatchNone(SearchSourceBuilder source) {_        if (source == null || source.query() == null || source.query() instanceof MatchAllQueryBuilder || source.suggest() != null) {_            return false__        } else {_            AggregatorFactories.Builder aggregations = source.aggregations()__            if (aggregations != null) {_                if (aggregations.mustVisitAllDocs()) {_                    return false__                }_            }_        }_        return true__    };returns,true,iff,the,given,search,source,builder,can,be,early,terminated,by,rewriting,to,a,match,none,query,or,in,other,words,if,the,execution,of,a,the,search,request,can,be,early,terminated,without,executing,it,this,is,for,instance,not,possible,if,a,global,aggregation,is,part,of,this,request,or,if,there,is,a,suggest,builder,present;public,static,boolean,can,rewrite,to,match,none,search,source,builder,source,if,source,null,source,query,null,source,query,instanceof,match,all,query,builder,source,suggest,null,return,false,else,aggregator,factories,builder,aggregations,source,aggregations,if,aggregations,null,if,aggregations,must,visit,all,docs,return,false,return,true
SearchService -> public static boolean canRewriteToMatchNone(SearchSourceBuilder source);1533641732;Returns true iff the given search source builder can be early terminated by rewriting to a match none query. Or in other words_if the execution of a the search request can be early terminated without executing it. This is for instance not possible if_a global aggregation is part of this request or if there is a suggest builder present.;public static boolean canRewriteToMatchNone(SearchSourceBuilder source) {_        if (source == null || source.query() == null || source.query() instanceof MatchAllQueryBuilder || source.suggest() != null) {_            return false__        } else {_            AggregatorFactories.Builder aggregations = source.aggregations()__            if (aggregations != null) {_                if (aggregations.mustVisitAllDocs()) {_                    return false__                }_            }_        }_        return true__    };returns,true,iff,the,given,search,source,builder,can,be,early,terminated,by,rewriting,to,a,match,none,query,or,in,other,words,if,the,execution,of,a,the,search,request,can,be,early,terminated,without,executing,it,this,is,for,instance,not,possible,if,a,global,aggregation,is,part,of,this,request,or,if,there,is,a,suggest,builder,present;public,static,boolean,can,rewrite,to,match,none,search,source,builder,source,if,source,null,source,query,null,source,query,instanceof,match,all,query,builder,source,suggest,null,return,false,else,aggregator,factories,builder,aggregations,source,aggregations,if,aggregations,null,if,aggregations,must,visit,all,docs,return,false,return,true
SearchService -> public static boolean canRewriteToMatchNone(SearchSourceBuilder source);1535046779;Returns true iff the given search source builder can be early terminated by rewriting to a match none query. Or in other words_if the execution of a the search request can be early terminated without executing it. This is for instance not possible if_a global aggregation is part of this request or if there is a suggest builder present.;public static boolean canRewriteToMatchNone(SearchSourceBuilder source) {_        if (source == null || source.query() == null || source.query() instanceof MatchAllQueryBuilder || source.suggest() != null) {_            return false__        } else {_            AggregatorFactories.Builder aggregations = source.aggregations()__            if (aggregations != null) {_                if (aggregations.mustVisitAllDocs()) {_                    return false__                }_            }_        }_        return true__    };returns,true,iff,the,given,search,source,builder,can,be,early,terminated,by,rewriting,to,a,match,none,query,or,in,other,words,if,the,execution,of,a,the,search,request,can,be,early,terminated,without,executing,it,this,is,for,instance,not,possible,if,a,global,aggregation,is,part,of,this,request,or,if,there,is,a,suggest,builder,present;public,static,boolean,can,rewrite,to,match,none,search,source,builder,source,if,source,null,source,query,null,source,query,instanceof,match,all,query,builder,source,suggest,null,return,false,else,aggregator,factories,builder,aggregations,source,aggregations,if,aggregations,null,if,aggregations,must,visit,all,docs,return,false,return,true
SearchService -> public static boolean canRewriteToMatchNone(SearchSourceBuilder source);1536314350;Returns true iff the given search source builder can be early terminated by rewriting to a match none query. Or in other words_if the execution of a the search request can be early terminated without executing it. This is for instance not possible if_a global aggregation is part of this request or if there is a suggest builder present.;public static boolean canRewriteToMatchNone(SearchSourceBuilder source) {_        if (source == null || source.query() == null || source.query() instanceof MatchAllQueryBuilder || source.suggest() != null) {_            return false__        } else {_            AggregatorFactories.Builder aggregations = source.aggregations()__            if (aggregations != null) {_                if (aggregations.mustVisitAllDocs()) {_                    return false__                }_            }_        }_        return true__    };returns,true,iff,the,given,search,source,builder,can,be,early,terminated,by,rewriting,to,a,match,none,query,or,in,other,words,if,the,execution,of,a,the,search,request,can,be,early,terminated,without,executing,it,this,is,for,instance,not,possible,if,a,global,aggregation,is,part,of,this,request,or,if,there,is,a,suggest,builder,present;public,static,boolean,can,rewrite,to,match,none,search,source,builder,source,if,source,null,source,query,null,source,query,instanceof,match,all,query,builder,source,suggest,null,return,false,else,aggregator,factories,builder,aggregations,source,aggregations,if,aggregations,null,if,aggregations,must,visit,all,docs,return,false,return,true
SearchService -> public static boolean canRewriteToMatchNone(SearchSourceBuilder source);1537806831;Returns true iff the given search source builder can be early terminated by rewriting to a match none query. Or in other words_if the execution of a the search request can be early terminated without executing it. This is for instance not possible if_a global aggregation is part of this request or if there is a suggest builder present.;public static boolean canRewriteToMatchNone(SearchSourceBuilder source) {_        if (source == null || source.query() == null || source.query() instanceof MatchAllQueryBuilder || source.suggest() != null) {_            return false__        } else {_            AggregatorFactories.Builder aggregations = source.aggregations()__            if (aggregations != null) {_                if (aggregations.mustVisitAllDocs()) {_                    return false__                }_            }_        }_        return true__    };returns,true,iff,the,given,search,source,builder,can,be,early,terminated,by,rewriting,to,a,match,none,query,or,in,other,words,if,the,execution,of,a,the,search,request,can,be,early,terminated,without,executing,it,this,is,for,instance,not,possible,if,a,global,aggregation,is,part,of,this,request,or,if,there,is,a,suggest,builder,present;public,static,boolean,can,rewrite,to,match,none,search,source,builder,source,if,source,null,source,query,null,source,query,instanceof,match,all,query,builder,source,suggest,null,return,false,else,aggregator,factories,builder,aggregations,source,aggregations,if,aggregations,null,if,aggregations,must,visit,all,docs,return,false,return,true
SearchService -> public static boolean canRewriteToMatchNone(SearchSourceBuilder source);1540238977;Returns true iff the given search source builder can be early terminated by rewriting to a match none query. Or in other words_if the execution of a the search request can be early terminated without executing it. This is for instance not possible if_a global aggregation is part of this request or if there is a suggest builder present.;public static boolean canRewriteToMatchNone(SearchSourceBuilder source) {_        if (source == null || source.query() == null || source.query() instanceof MatchAllQueryBuilder || source.suggest() != null) {_            return false__        } else {_            AggregatorFactories.Builder aggregations = source.aggregations()__            if (aggregations != null) {_                if (aggregations.mustVisitAllDocs()) {_                    return false__                }_            }_        }_        return true__    };returns,true,iff,the,given,search,source,builder,can,be,early,terminated,by,rewriting,to,a,match,none,query,or,in,other,words,if,the,execution,of,a,the,search,request,can,be,early,terminated,without,executing,it,this,is,for,instance,not,possible,if,a,global,aggregation,is,part,of,this,request,or,if,there,is,a,suggest,builder,present;public,static,boolean,can,rewrite,to,match,none,search,source,builder,source,if,source,null,source,query,null,source,query,instanceof,match,all,query,builder,source,suggest,null,return,false,else,aggregator,factories,builder,aggregations,source,aggregations,if,aggregations,null,if,aggregations,must,visit,all,docs,return,false,return,true
SearchService -> public static boolean canRewriteToMatchNone(SearchSourceBuilder source);1540583181;Returns true iff the given search source builder can be early terminated by rewriting to a match none query. Or in other words_if the execution of a the search request can be early terminated without executing it. This is for instance not possible if_a global aggregation is part of this request or if there is a suggest builder present.;public static boolean canRewriteToMatchNone(SearchSourceBuilder source) {_        if (source == null || source.query() == null || source.query() instanceof MatchAllQueryBuilder || source.suggest() != null) {_            return false__        } else {_            AggregatorFactories.Builder aggregations = source.aggregations()__            if (aggregations != null) {_                if (aggregations.mustVisitAllDocs()) {_                    return false__                }_            }_        }_        return true__    };returns,true,iff,the,given,search,source,builder,can,be,early,terminated,by,rewriting,to,a,match,none,query,or,in,other,words,if,the,execution,of,a,the,search,request,can,be,early,terminated,without,executing,it,this,is,for,instance,not,possible,if,a,global,aggregation,is,part,of,this,request,or,if,there,is,a,suggest,builder,present;public,static,boolean,can,rewrite,to,match,none,search,source,builder,source,if,source,null,source,query,null,source,query,instanceof,match,all,query,builder,source,suggest,null,return,false,else,aggregator,factories,builder,aggregations,source,aggregations,if,aggregations,null,if,aggregations,must,visit,all,docs,return,false,return,true
SearchService -> public static boolean canRewriteToMatchNone(SearchSourceBuilder source);1541008027;Returns true iff the given search source builder can be early terminated by rewriting to a match none query. Or in other words_if the execution of a the search request can be early terminated without executing it. This is for instance not possible if_a global aggregation is part of this request or if there is a suggest builder present.;public static boolean canRewriteToMatchNone(SearchSourceBuilder source) {_        if (source == null || source.query() == null || source.query() instanceof MatchAllQueryBuilder || source.suggest() != null) {_            return false__        } else {_            AggregatorFactories.Builder aggregations = source.aggregations()__            if (aggregations != null) {_                if (aggregations.mustVisitAllDocs()) {_                    return false__                }_            }_        }_        return true__    };returns,true,iff,the,given,search,source,builder,can,be,early,terminated,by,rewriting,to,a,match,none,query,or,in,other,words,if,the,execution,of,a,the,search,request,can,be,early,terminated,without,executing,it,this,is,for,instance,not,possible,if,a,global,aggregation,is,part,of,this,request,or,if,there,is,a,suggest,builder,present;public,static,boolean,can,rewrite,to,match,none,search,source,builder,source,if,source,null,source,query,null,source,query,instanceof,match,all,query,builder,source,suggest,null,return,false,else,aggregator,factories,builder,aggregations,source,aggregations,if,aggregations,null,if,aggregations,must,visit,all,docs,return,false,return,true
SearchService -> public static boolean canRewriteToMatchNone(SearchSourceBuilder source);1541092382;Returns true iff the given search source builder can be early terminated by rewriting to a match none query. Or in other words_if the execution of a the search request can be early terminated without executing it. This is for instance not possible if_a global aggregation is part of this request or if there is a suggest builder present.;public static boolean canRewriteToMatchNone(SearchSourceBuilder source) {_        if (source == null || source.query() == null || source.query() instanceof MatchAllQueryBuilder || source.suggest() != null) {_            return false__        } else {_            AggregatorFactories.Builder aggregations = source.aggregations()__            if (aggregations != null) {_                if (aggregations.mustVisitAllDocs()) {_                    return false__                }_            }_        }_        return true__    };returns,true,iff,the,given,search,source,builder,can,be,early,terminated,by,rewriting,to,a,match,none,query,or,in,other,words,if,the,execution,of,a,the,search,request,can,be,early,terminated,without,executing,it,this,is,for,instance,not,possible,if,a,global,aggregation,is,part,of,this,request,or,if,there,is,a,suggest,builder,present;public,static,boolean,can,rewrite,to,match,none,search,source,builder,source,if,source,null,source,query,null,source,query,instanceof,match,all,query,builder,source,suggest,null,return,false,else,aggregator,factories,builder,aggregations,source,aggregations,if,aggregations,null,if,aggregations,must,visit,all,docs,return,false,return,true
SearchService -> public static boolean canRewriteToMatchNone(SearchSourceBuilder source);1542117235;Returns true iff the given search source builder can be early terminated by rewriting to a match none query. Or in other words_if the execution of a the search request can be early terminated without executing it. This is for instance not possible if_a global aggregation is part of this request or if there is a suggest builder present.;public static boolean canRewriteToMatchNone(SearchSourceBuilder source) {_        if (source == null || source.query() == null || source.query() instanceof MatchAllQueryBuilder || source.suggest() != null) {_            return false__        } else {_            AggregatorFactories.Builder aggregations = source.aggregations()__            if (aggregations != null) {_                if (aggregations.mustVisitAllDocs()) {_                    return false__                }_            }_        }_        return true__    };returns,true,iff,the,given,search,source,builder,can,be,early,terminated,by,rewriting,to,a,match,none,query,or,in,other,words,if,the,execution,of,a,the,search,request,can,be,early,terminated,without,executing,it,this,is,for,instance,not,possible,if,a,global,aggregation,is,part,of,this,request,or,if,there,is,a,suggest,builder,present;public,static,boolean,can,rewrite,to,match,none,search,source,builder,source,if,source,null,source,query,null,source,query,instanceof,match,all,query,builder,source,suggest,null,return,false,else,aggregator,factories,builder,aggregations,source,aggregations,if,aggregations,null,if,aggregations,must,visit,all,docs,return,false,return,true
SearchService -> public static boolean canRewriteToMatchNone(SearchSourceBuilder source);1542646292;Returns true iff the given search source builder can be early terminated by rewriting to a match none query. Or in other words_if the execution of a the search request can be early terminated without executing it. This is for instance not possible if_a global aggregation is part of this request or if there is a suggest builder present.;public static boolean canRewriteToMatchNone(SearchSourceBuilder source) {_        if (source == null || source.query() == null || source.query() instanceof MatchAllQueryBuilder || source.suggest() != null) {_            return false__        } else {_            AggregatorFactories.Builder aggregations = source.aggregations()__            if (aggregations != null) {_                if (aggregations.mustVisitAllDocs()) {_                    return false__                }_            }_        }_        return true__    };returns,true,iff,the,given,search,source,builder,can,be,early,terminated,by,rewriting,to,a,match,none,query,or,in,other,words,if,the,execution,of,a,the,search,request,can,be,early,terminated,without,executing,it,this,is,for,instance,not,possible,if,a,global,aggregation,is,part,of,this,request,or,if,there,is,a,suggest,builder,present;public,static,boolean,can,rewrite,to,match,none,search,source,builder,source,if,source,null,source,query,null,source,query,instanceof,match,all,query,builder,source,suggest,null,return,false,else,aggregator,factories,builder,aggregations,source,aggregations,if,aggregations,null,if,aggregations,must,visit,all,docs,return,false,return,true
SearchService -> public static boolean canRewriteToMatchNone(SearchSourceBuilder source);1543047942;Returns true iff the given search source builder can be early terminated by rewriting to a match none query. Or in other words_if the execution of a the search request can be early terminated without executing it. This is for instance not possible if_a global aggregation is part of this request or if there is a suggest builder present.;public static boolean canRewriteToMatchNone(SearchSourceBuilder source) {_        if (source == null || source.query() == null || source.query() instanceof MatchAllQueryBuilder || source.suggest() != null) {_            return false__        } else {_            AggregatorFactories.Builder aggregations = source.aggregations()__            if (aggregations != null) {_                if (aggregations.mustVisitAllDocs()) {_                    return false__                }_            }_        }_        return true__    };returns,true,iff,the,given,search,source,builder,can,be,early,terminated,by,rewriting,to,a,match,none,query,or,in,other,words,if,the,execution,of,a,the,search,request,can,be,early,terminated,without,executing,it,this,is,for,instance,not,possible,if,a,global,aggregation,is,part,of,this,request,or,if,there,is,a,suggest,builder,present;public,static,boolean,can,rewrite,to,match,none,search,source,builder,source,if,source,null,source,query,null,source,query,instanceof,match,all,query,builder,source,suggest,null,return,false,else,aggregator,factories,builder,aggregations,source,aggregations,if,aggregations,null,if,aggregations,must,visit,all,docs,return,false,return,true
SearchService -> public static boolean canRewriteToMatchNone(SearchSourceBuilder source);1543236161;Returns true iff the given search source builder can be early terminated by rewriting to a match none query. Or in other words_if the execution of the search request can be early terminated without executing it. This is for instance not possible if_a global aggregation is part of this request or if there is a suggest builder present.;public static boolean canRewriteToMatchNone(SearchSourceBuilder source) {_        if (source == null || source.query() == null || source.query() instanceof MatchAllQueryBuilder || source.suggest() != null) {_            return false__        }_        AggregatorFactories.Builder aggregations = source.aggregations()__        return aggregations == null || aggregations.mustVisitAllDocs() == false__    };returns,true,iff,the,given,search,source,builder,can,be,early,terminated,by,rewriting,to,a,match,none,query,or,in,other,words,if,the,execution,of,the,search,request,can,be,early,terminated,without,executing,it,this,is,for,instance,not,possible,if,a,global,aggregation,is,part,of,this,request,or,if,there,is,a,suggest,builder,present;public,static,boolean,can,rewrite,to,match,none,search,source,builder,source,if,source,null,source,query,null,source,query,instanceof,match,all,query,builder,source,suggest,null,return,false,aggregator,factories,builder,aggregations,source,aggregations,return,aggregations,null,aggregations,must,visit,all,docs,false
SearchService -> public static boolean canRewriteToMatchNone(SearchSourceBuilder source);1543841718;Returns true iff the given search source builder can be early terminated by rewriting to a match none query. Or in other words_if the execution of the search request can be early terminated without executing it. This is for instance not possible if_a global aggregation is part of this request or if there is a suggest builder present.;public static boolean canRewriteToMatchNone(SearchSourceBuilder source) {_        if (source == null || source.query() == null || source.query() instanceof MatchAllQueryBuilder || source.suggest() != null) {_            return false__        }_        AggregatorFactories.Builder aggregations = source.aggregations()__        return aggregations == null || aggregations.mustVisitAllDocs() == false__    };returns,true,iff,the,given,search,source,builder,can,be,early,terminated,by,rewriting,to,a,match,none,query,or,in,other,words,if,the,execution,of,the,search,request,can,be,early,terminated,without,executing,it,this,is,for,instance,not,possible,if,a,global,aggregation,is,part,of,this,request,or,if,there,is,a,suggest,builder,present;public,static,boolean,can,rewrite,to,match,none,search,source,builder,source,if,source,null,source,query,null,source,query,instanceof,match,all,query,builder,source,suggest,null,return,false,aggregator,factories,builder,aggregations,source,aggregations,return,aggregations,null,aggregations,must,visit,all,docs,false
SearchService -> public static boolean canRewriteToMatchNone(SearchSourceBuilder source);1543863430;Returns true iff the given search source builder can be early terminated by rewriting to a match none query. Or in other words_if the execution of the search request can be early terminated without executing it. This is for instance not possible if_a global aggregation is part of this request or if there is a suggest builder present.;public static boolean canRewriteToMatchNone(SearchSourceBuilder source) {_        if (source == null || source.query() == null || source.query() instanceof MatchAllQueryBuilder || source.suggest() != null) {_            return false__        }_        AggregatorFactories.Builder aggregations = source.aggregations()__        return aggregations == null || aggregations.mustVisitAllDocs() == false__    };returns,true,iff,the,given,search,source,builder,can,be,early,terminated,by,rewriting,to,a,match,none,query,or,in,other,words,if,the,execution,of,the,search,request,can,be,early,terminated,without,executing,it,this,is,for,instance,not,possible,if,a,global,aggregation,is,part,of,this,request,or,if,there,is,a,suggest,builder,present;public,static,boolean,can,rewrite,to,match,none,search,source,builder,source,if,source,null,source,query,null,source,query,instanceof,match,all,query,builder,source,suggest,null,return,false,aggregator,factories,builder,aggregations,source,aggregations,return,aggregations,null,aggregations,must,visit,all,docs,false
SearchService -> public static boolean canRewriteToMatchNone(SearchSourceBuilder source);1545997405;Returns true iff the given search source builder can be early terminated by rewriting to a match none query. Or in other words_if the execution of the search request can be early terminated without executing it. This is for instance not possible if_a global aggregation is part of this request or if there is a suggest builder present.;public static boolean canRewriteToMatchNone(SearchSourceBuilder source) {_        if (source == null || source.query() == null || source.query() instanceof MatchAllQueryBuilder || source.suggest() != null) {_            return false__        }_        AggregatorFactories.Builder aggregations = source.aggregations()__        return aggregations == null || aggregations.mustVisitAllDocs() == false__    };returns,true,iff,the,given,search,source,builder,can,be,early,terminated,by,rewriting,to,a,match,none,query,or,in,other,words,if,the,execution,of,the,search,request,can,be,early,terminated,without,executing,it,this,is,for,instance,not,possible,if,a,global,aggregation,is,part,of,this,request,or,if,there,is,a,suggest,builder,present;public,static,boolean,can,rewrite,to,match,none,search,source,builder,source,if,source,null,source,query,null,source,query,instanceof,match,all,query,builder,source,suggest,null,return,false,aggregator,factories,builder,aggregations,source,aggregations,return,aggregations,null,aggregations,must,visit,all,docs,false
SearchService -> public static boolean canRewriteToMatchNone(SearchSourceBuilder source);1546434630;Returns true iff the given search source builder can be early terminated by rewriting to a match none query. Or in other words_if the execution of the search request can be early terminated without executing it. This is for instance not possible if_a global aggregation is part of this request or if there is a suggest builder present.;public static boolean canRewriteToMatchNone(SearchSourceBuilder source) {_        if (source == null || source.query() == null || source.query() instanceof MatchAllQueryBuilder || source.suggest() != null) {_            return false__        }_        AggregatorFactories.Builder aggregations = source.aggregations()__        return aggregations == null || aggregations.mustVisitAllDocs() == false__    };returns,true,iff,the,given,search,source,builder,can,be,early,terminated,by,rewriting,to,a,match,none,query,or,in,other,words,if,the,execution,of,the,search,request,can,be,early,terminated,without,executing,it,this,is,for,instance,not,possible,if,a,global,aggregation,is,part,of,this,request,or,if,there,is,a,suggest,builder,present;public,static,boolean,can,rewrite,to,match,none,search,source,builder,source,if,source,null,source,query,null,source,query,instanceof,match,all,query,builder,source,suggest,null,return,false,aggregator,factories,builder,aggregations,source,aggregations,return,aggregations,null,aggregations,must,visit,all,docs,false
SearchService -> public static boolean canRewriteToMatchNone(SearchSourceBuilder source);1546630609;Returns true iff the given search source builder can be early terminated by rewriting to a match none query. Or in other words_if the execution of the search request can be early terminated without executing it. This is for instance not possible if_a global aggregation is part of this request or if there is a suggest builder present.;public static boolean canRewriteToMatchNone(SearchSourceBuilder source) {_        if (source == null || source.query() == null || source.query() instanceof MatchAllQueryBuilder || source.suggest() != null) {_            return false__        }_        AggregatorFactories.Builder aggregations = source.aggregations()__        return aggregations == null || aggregations.mustVisitAllDocs() == false__    };returns,true,iff,the,given,search,source,builder,can,be,early,terminated,by,rewriting,to,a,match,none,query,or,in,other,words,if,the,execution,of,the,search,request,can,be,early,terminated,without,executing,it,this,is,for,instance,not,possible,if,a,global,aggregation,is,part,of,this,request,or,if,there,is,a,suggest,builder,present;public,static,boolean,can,rewrite,to,match,none,search,source,builder,source,if,source,null,source,query,null,source,query,instanceof,match,all,query,builder,source,suggest,null,return,false,aggregator,factories,builder,aggregations,source,aggregations,return,aggregations,null,aggregations,must,visit,all,docs,false
SearchService -> public static boolean canRewriteToMatchNone(SearchSourceBuilder source);1547625930;Returns true iff the given search source builder can be early terminated by rewriting to a match none query. Or in other words_if the execution of the search request can be early terminated without executing it. This is for instance not possible if_a global aggregation is part of this request or if there is a suggest builder present.;public static boolean canRewriteToMatchNone(SearchSourceBuilder source) {_        if (source == null || source.query() == null || source.query() instanceof MatchAllQueryBuilder || source.suggest() != null) {_            return false__        }_        AggregatorFactories.Builder aggregations = source.aggregations()__        return aggregations == null || aggregations.mustVisitAllDocs() == false__    };returns,true,iff,the,given,search,source,builder,can,be,early,terminated,by,rewriting,to,a,match,none,query,or,in,other,words,if,the,execution,of,the,search,request,can,be,early,terminated,without,executing,it,this,is,for,instance,not,possible,if,a,global,aggregation,is,part,of,this,request,or,if,there,is,a,suggest,builder,present;public,static,boolean,can,rewrite,to,match,none,search,source,builder,source,if,source,null,source,query,null,source,query,instanceof,match,all,query,builder,source,suggest,null,return,false,aggregator,factories,builder,aggregations,source,aggregations,return,aggregations,null,aggregations,must,visit,all,docs,false
SearchService -> public static boolean canRewriteToMatchNone(SearchSourceBuilder source);1548230518;Returns true iff the given search source builder can be early terminated by rewriting to a match none query. Or in other words_if the execution of the search request can be early terminated without executing it. This is for instance not possible if_a global aggregation is part of this request or if there is a suggest builder present.;public static boolean canRewriteToMatchNone(SearchSourceBuilder source) {_        if (source == null || source.query() == null || source.query() instanceof MatchAllQueryBuilder || source.suggest() != null) {_            return false__        }_        AggregatorFactories.Builder aggregations = source.aggregations()__        return aggregations == null || aggregations.mustVisitAllDocs() == false__    };returns,true,iff,the,given,search,source,builder,can,be,early,terminated,by,rewriting,to,a,match,none,query,or,in,other,words,if,the,execution,of,the,search,request,can,be,early,terminated,without,executing,it,this,is,for,instance,not,possible,if,a,global,aggregation,is,part,of,this,request,or,if,there,is,a,suggest,builder,present;public,static,boolean,can,rewrite,to,match,none,search,source,builder,source,if,source,null,source,query,null,source,query,instanceof,match,all,query,builder,source,suggest,null,return,false,aggregator,factories,builder,aggregations,source,aggregations,return,aggregations,null,aggregations,must,visit,all,docs,false
SearchService -> public static boolean canRewriteToMatchNone(SearchSourceBuilder source);1548243524;Returns true iff the given search source builder can be early terminated by rewriting to a match none query. Or in other words_if the execution of the search request can be early terminated without executing it. This is for instance not possible if_a global aggregation is part of this request or if there is a suggest builder present.;public static boolean canRewriteToMatchNone(SearchSourceBuilder source) {_        if (source == null || source.query() == null || source.query() instanceof MatchAllQueryBuilder || source.suggest() != null) {_            return false__        }_        AggregatorFactories.Builder aggregations = source.aggregations()__        return aggregations == null || aggregations.mustVisitAllDocs() == false__    };returns,true,iff,the,given,search,source,builder,can,be,early,terminated,by,rewriting,to,a,match,none,query,or,in,other,words,if,the,execution,of,the,search,request,can,be,early,terminated,without,executing,it,this,is,for,instance,not,possible,if,a,global,aggregation,is,part,of,this,request,or,if,there,is,a,suggest,builder,present;public,static,boolean,can,rewrite,to,match,none,search,source,builder,source,if,source,null,source,query,null,source,query,instanceof,match,all,query,builder,source,suggest,null,return,false,aggregator,factories,builder,aggregations,source,aggregations,return,aggregations,null,aggregations,must,visit,all,docs,false
SearchService -> public static boolean canRewriteToMatchNone(SearchSourceBuilder source);1548420339;Returns true iff the given search source builder can be early terminated by rewriting to a match none query. Or in other words_if the execution of the search request can be early terminated without executing it. This is for instance not possible if_a global aggregation is part of this request or if there is a suggest builder present.;public static boolean canRewriteToMatchNone(SearchSourceBuilder source) {_        if (source == null || source.query() == null || source.query() instanceof MatchAllQueryBuilder || source.suggest() != null) {_            return false__        }_        AggregatorFactories.Builder aggregations = source.aggregations()__        return aggregations == null || aggregations.mustVisitAllDocs() == false__    };returns,true,iff,the,given,search,source,builder,can,be,early,terminated,by,rewriting,to,a,match,none,query,or,in,other,words,if,the,execution,of,the,search,request,can,be,early,terminated,without,executing,it,this,is,for,instance,not,possible,if,a,global,aggregation,is,part,of,this,request,or,if,there,is,a,suggest,builder,present;public,static,boolean,can,rewrite,to,match,none,search,source,builder,source,if,source,null,source,query,null,source,query,instanceof,match,all,query,builder,source,suggest,null,return,false,aggregator,factories,builder,aggregations,source,aggregations,return,aggregations,null,aggregations,must,visit,all,docs,false
SearchService -> public static boolean canRewriteToMatchNone(SearchSourceBuilder source);1548943934;Returns true iff the given search source builder can be early terminated by rewriting to a match none query. Or in other words_if the execution of the search request can be early terminated without executing it. This is for instance not possible if_a global aggregation is part of this request or if there is a suggest builder present.;public static boolean canRewriteToMatchNone(SearchSourceBuilder source) {_        if (source == null || source.query() == null || source.query() instanceof MatchAllQueryBuilder || source.suggest() != null) {_            return false__        }_        AggregatorFactories.Builder aggregations = source.aggregations()__        return aggregations == null || aggregations.mustVisitAllDocs() == false__    };returns,true,iff,the,given,search,source,builder,can,be,early,terminated,by,rewriting,to,a,match,none,query,or,in,other,words,if,the,execution,of,the,search,request,can,be,early,terminated,without,executing,it,this,is,for,instance,not,possible,if,a,global,aggregation,is,part,of,this,request,or,if,there,is,a,suggest,builder,present;public,static,boolean,can,rewrite,to,match,none,search,source,builder,source,if,source,null,source,query,null,source,query,instanceof,match,all,query,builder,source,suggest,null,return,false,aggregator,factories,builder,aggregations,source,aggregations,return,aggregations,null,aggregations,must,visit,all,docs,false
SearchService -> public static boolean canRewriteToMatchNone(SearchSourceBuilder source);1550737421;Returns true iff the given search source builder can be early terminated by rewriting to a match none query. Or in other words_if the execution of the search request can be early terminated without executing it. This is for instance not possible if_a global aggregation is part of this request or if there is a suggest builder present.;public static boolean canRewriteToMatchNone(SearchSourceBuilder source) {_        if (source == null || source.query() == null || source.query() instanceof MatchAllQueryBuilder || source.suggest() != null) {_            return false__        }_        AggregatorFactories.Builder aggregations = source.aggregations()__        return aggregations == null || aggregations.mustVisitAllDocs() == false__    };returns,true,iff,the,given,search,source,builder,can,be,early,terminated,by,rewriting,to,a,match,none,query,or,in,other,words,if,the,execution,of,the,search,request,can,be,early,terminated,without,executing,it,this,is,for,instance,not,possible,if,a,global,aggregation,is,part,of,this,request,or,if,there,is,a,suggest,builder,present;public,static,boolean,can,rewrite,to,match,none,search,source,builder,source,if,source,null,source,query,null,source,query,instanceof,match,all,query,builder,source,suggest,null,return,false,aggregator,factories,builder,aggregations,source,aggregations,return,aggregations,null,aggregations,must,visit,all,docs,false
SearchService -> public boolean canMatch(ShardSearchRequest request) throws IOException;1524684173;This method does a very quick rewrite of the query and returns true if the query can potentially match any documents._This method can have false positives while if it returns <code>false</code> the query won't match any documents on the current_shard.;public boolean canMatch(ShardSearchRequest request) throws IOException {_        assert request.searchType() == SearchType.QUERY_THEN_FETCH : "unexpected search type: " + request.searchType()__        try (DefaultSearchContext context = createSearchContext(request, defaultSearchTimeout, false)) {_            SearchSourceBuilder source = context.request().source()__            if (canRewriteToMatchNone(source)) {_                QueryBuilder queryBuilder = source.query()__                return queryBuilder instanceof MatchNoneQueryBuilder == false__            }_            return true_ _        }_    };this,method,does,a,very,quick,rewrite,of,the,query,and,returns,true,if,the,query,can,potentially,match,any,documents,this,method,can,have,false,positives,while,if,it,returns,code,false,code,the,query,won,t,match,any,documents,on,the,current,shard;public,boolean,can,match,shard,search,request,request,throws,ioexception,assert,request,search,type,search,type,unexpected,search,type,request,search,type,try,default,search,context,context,create,search,context,request,default,search,timeout,false,search,source,builder,source,context,request,source,if,can,rewrite,to,match,none,source,query,builder,query,builder,source,query,return,query,builder,instanceof,match,none,query,builder,false,return,true
SearchService -> public boolean canMatch(ShardSearchRequest request) throws IOException;1524780945;This method does a very quick rewrite of the query and returns true if the query can potentially match any documents._This method can have false positives while if it returns <code>false</code> the query won't match any documents on the current_shard.;public boolean canMatch(ShardSearchRequest request) throws IOException {_        assert request.searchType() == SearchType.QUERY_THEN_FETCH : "unexpected search type: " + request.searchType()__        try (DefaultSearchContext context = createSearchContext(request, defaultSearchTimeout, false)) {_            SearchSourceBuilder source = context.request().source()__            if (canRewriteToMatchNone(source)) {_                QueryBuilder queryBuilder = source.query()__                return queryBuilder instanceof MatchNoneQueryBuilder == false__            }_            return true_ _        }_    };this,method,does,a,very,quick,rewrite,of,the,query,and,returns,true,if,the,query,can,potentially,match,any,documents,this,method,can,have,false,positives,while,if,it,returns,code,false,code,the,query,won,t,match,any,documents,on,the,current,shard;public,boolean,can,match,shard,search,request,request,throws,ioexception,assert,request,search,type,search,type,unexpected,search,type,request,search,type,try,default,search,context,context,create,search,context,request,default,search,timeout,false,search,source,builder,source,context,request,source,if,can,rewrite,to,match,none,source,query,builder,query,builder,source,query,return,query,builder,instanceof,match,none,query,builder,false,return,true
SearchService -> public boolean canMatch(ShardSearchRequest request) throws IOException;1525334055;This method does a very quick rewrite of the query and returns true if the query can potentially match any documents._This method can have false positives while if it returns <code>false</code> the query won't match any documents on the current_shard.;public boolean canMatch(ShardSearchRequest request) throws IOException {_        assert request.searchType() == SearchType.QUERY_THEN_FETCH : "unexpected search type: " + request.searchType()__        try (DefaultSearchContext context = createSearchContext(request, defaultSearchTimeout, false)) {_            SearchSourceBuilder source = context.request().source()__            if (canRewriteToMatchNone(source)) {_                QueryBuilder queryBuilder = source.query()__                return queryBuilder instanceof MatchNoneQueryBuilder == false__            }_            return true_ _        }_    };this,method,does,a,very,quick,rewrite,of,the,query,and,returns,true,if,the,query,can,potentially,match,any,documents,this,method,can,have,false,positives,while,if,it,returns,code,false,code,the,query,won,t,match,any,documents,on,the,current,shard;public,boolean,can,match,shard,search,request,request,throws,ioexception,assert,request,search,type,search,type,unexpected,search,type,request,search,type,try,default,search,context,context,create,search,context,request,default,search,timeout,false,search,source,builder,source,context,request,source,if,can,rewrite,to,match,none,source,query,builder,query,builder,source,query,return,query,builder,instanceof,match,none,query,builder,false,return,true
SearchService -> public boolean canMatch(ShardSearchRequest request) throws IOException;1527583663;This method does a very quick rewrite of the query and returns true if the query can potentially match any documents._This method can have false positives while if it returns <code>false</code> the query won't match any documents on the current_shard.;public boolean canMatch(ShardSearchRequest request) throws IOException {_        assert request.searchType() == SearchType.QUERY_THEN_FETCH : "unexpected search type: " + request.searchType()__        try (DefaultSearchContext context = createSearchContext(request, defaultSearchTimeout, false)) {_            SearchSourceBuilder source = context.request().source()__            if (canRewriteToMatchNone(source)) {_                QueryBuilder queryBuilder = source.query()__                return queryBuilder instanceof MatchNoneQueryBuilder == false__            }_            return true_ _        }_    };this,method,does,a,very,quick,rewrite,of,the,query,and,returns,true,if,the,query,can,potentially,match,any,documents,this,method,can,have,false,positives,while,if,it,returns,code,false,code,the,query,won,t,match,any,documents,on,the,current,shard;public,boolean,can,match,shard,search,request,request,throws,ioexception,assert,request,search,type,search,type,unexpected,search,type,request,search,type,try,default,search,context,context,create,search,context,request,default,search,timeout,false,search,source,builder,source,context,request,source,if,can,rewrite,to,match,none,source,query,builder,query,builder,source,query,return,query,builder,instanceof,match,none,query,builder,false,return,true
SearchService -> public boolean canMatch(ShardSearchRequest request) throws IOException;1533641732;This method does a very quick rewrite of the query and returns true if the query can potentially match any documents._This method can have false positives while if it returns <code>false</code> the query won't match any documents on the current_shard.;public boolean canMatch(ShardSearchRequest request) throws IOException {_        assert request.searchType() == SearchType.QUERY_THEN_FETCH : "unexpected search type: " + request.searchType()__        try (DefaultSearchContext context = createSearchContext(request, defaultSearchTimeout, false)) {_            SearchSourceBuilder source = context.request().source()__            if (canRewriteToMatchNone(source)) {_                QueryBuilder queryBuilder = source.query()__                return queryBuilder instanceof MatchNoneQueryBuilder == false__            }_            return true_ _        }_    };this,method,does,a,very,quick,rewrite,of,the,query,and,returns,true,if,the,query,can,potentially,match,any,documents,this,method,can,have,false,positives,while,if,it,returns,code,false,code,the,query,won,t,match,any,documents,on,the,current,shard;public,boolean,can,match,shard,search,request,request,throws,ioexception,assert,request,search,type,search,type,unexpected,search,type,request,search,type,try,default,search,context,context,create,search,context,request,default,search,timeout,false,search,source,builder,source,context,request,source,if,can,rewrite,to,match,none,source,query,builder,query,builder,source,query,return,query,builder,instanceof,match,none,query,builder,false,return,true
SearchService -> public boolean canMatch(ShardSearchRequest request) throws IOException;1535046779;This method does a very quick rewrite of the query and returns true if the query can potentially match any documents._This method can have false positives while if it returns <code>false</code> the query won't match any documents on the current_shard.;public boolean canMatch(ShardSearchRequest request) throws IOException {_        assert request.searchType() == SearchType.QUERY_THEN_FETCH : "unexpected search type: " + request.searchType()__        try (DefaultSearchContext context = createSearchContext(request, defaultSearchTimeout, false)) {_            SearchSourceBuilder source = context.request().source()__            if (canRewriteToMatchNone(source)) {_                QueryBuilder queryBuilder = source.query()__                return queryBuilder instanceof MatchNoneQueryBuilder == false__            }_            return true_ _        }_    };this,method,does,a,very,quick,rewrite,of,the,query,and,returns,true,if,the,query,can,potentially,match,any,documents,this,method,can,have,false,positives,while,if,it,returns,code,false,code,the,query,won,t,match,any,documents,on,the,current,shard;public,boolean,can,match,shard,search,request,request,throws,ioexception,assert,request,search,type,search,type,unexpected,search,type,request,search,type,try,default,search,context,context,create,search,context,request,default,search,timeout,false,search,source,builder,source,context,request,source,if,can,rewrite,to,match,none,source,query,builder,query,builder,source,query,return,query,builder,instanceof,match,none,query,builder,false,return,true
SearchService -> public boolean canMatch(ShardSearchRequest request) throws IOException;1536314350;This method does a very quick rewrite of the query and returns true if the query can potentially match any documents._This method can have false positives while if it returns <code>false</code> the query won't match any documents on the current_shard.;public boolean canMatch(ShardSearchRequest request) throws IOException {_        assert request.searchType() == SearchType.QUERY_THEN_FETCH : "unexpected search type: " + request.searchType()__        try (DefaultSearchContext context = createSearchContext(request, defaultSearchTimeout, false)) {_            SearchSourceBuilder source = context.request().source()__            if (canRewriteToMatchNone(source)) {_                QueryBuilder queryBuilder = source.query()__                return queryBuilder instanceof MatchNoneQueryBuilder == false__            }_            return true_ _        }_    };this,method,does,a,very,quick,rewrite,of,the,query,and,returns,true,if,the,query,can,potentially,match,any,documents,this,method,can,have,false,positives,while,if,it,returns,code,false,code,the,query,won,t,match,any,documents,on,the,current,shard;public,boolean,can,match,shard,search,request,request,throws,ioexception,assert,request,search,type,search,type,unexpected,search,type,request,search,type,try,default,search,context,context,create,search,context,request,default,search,timeout,false,search,source,builder,source,context,request,source,if,can,rewrite,to,match,none,source,query,builder,query,builder,source,query,return,query,builder,instanceof,match,none,query,builder,false,return,true
SearchService -> public boolean canMatch(ShardSearchRequest request) throws IOException;1537806831;This method does a very quick rewrite of the query and returns true if the query can potentially match any documents._This method can have false positives while if it returns <code>false</code> the query won't match any documents on the current_shard.;public boolean canMatch(ShardSearchRequest request) throws IOException {_        assert request.searchType() == SearchType.QUERY_THEN_FETCH : "unexpected search type: " + request.searchType()__        try (DefaultSearchContext context = createSearchContext(request, defaultSearchTimeout, false)) {_            SearchSourceBuilder source = context.request().source()__            if (canRewriteToMatchNone(source)) {_                QueryBuilder queryBuilder = source.query()__                return queryBuilder instanceof MatchNoneQueryBuilder == false__            }_            return true_ _        }_    };this,method,does,a,very,quick,rewrite,of,the,query,and,returns,true,if,the,query,can,potentially,match,any,documents,this,method,can,have,false,positives,while,if,it,returns,code,false,code,the,query,won,t,match,any,documents,on,the,current,shard;public,boolean,can,match,shard,search,request,request,throws,ioexception,assert,request,search,type,search,type,unexpected,search,type,request,search,type,try,default,search,context,context,create,search,context,request,default,search,timeout,false,search,source,builder,source,context,request,source,if,can,rewrite,to,match,none,source,query,builder,query,builder,source,query,return,query,builder,instanceof,match,none,query,builder,false,return,true
SearchService -> public boolean canMatch(ShardSearchRequest request) throws IOException;1540238977;This method does a very quick rewrite of the query and returns true if the query can potentially match any documents._This method can have false positives while if it returns <code>false</code> the query won't match any documents on the current_shard.;public boolean canMatch(ShardSearchRequest request) throws IOException {_        assert request.searchType() == SearchType.QUERY_THEN_FETCH : "unexpected search type: " + request.searchType()__        try (DefaultSearchContext context = createSearchContext(request, defaultSearchTimeout, false)) {_            SearchSourceBuilder source = context.request().source()__            if (canRewriteToMatchNone(source)) {_                QueryBuilder queryBuilder = source.query()__                return queryBuilder instanceof MatchNoneQueryBuilder == false__            }_            return true_ _        }_    };this,method,does,a,very,quick,rewrite,of,the,query,and,returns,true,if,the,query,can,potentially,match,any,documents,this,method,can,have,false,positives,while,if,it,returns,code,false,code,the,query,won,t,match,any,documents,on,the,current,shard;public,boolean,can,match,shard,search,request,request,throws,ioexception,assert,request,search,type,search,type,unexpected,search,type,request,search,type,try,default,search,context,context,create,search,context,request,default,search,timeout,false,search,source,builder,source,context,request,source,if,can,rewrite,to,match,none,source,query,builder,query,builder,source,query,return,query,builder,instanceof,match,none,query,builder,false,return,true
SearchService -> public boolean canMatch(ShardSearchRequest request) throws IOException;1540583181;This method does a very quick rewrite of the query and returns true if the query can potentially match any documents._This method can have false positives while if it returns <code>false</code> the query won't match any documents on the current_shard.;public boolean canMatch(ShardSearchRequest request) throws IOException {_        assert request.searchType() == SearchType.QUERY_THEN_FETCH : "unexpected search type: " + request.searchType()__        try (DefaultSearchContext context = createSearchContext(request, defaultSearchTimeout, false)) {_            SearchSourceBuilder source = context.request().source()__            if (canRewriteToMatchNone(source)) {_                QueryBuilder queryBuilder = source.query()__                return queryBuilder instanceof MatchNoneQueryBuilder == false__            }_            return true_ _        }_    };this,method,does,a,very,quick,rewrite,of,the,query,and,returns,true,if,the,query,can,potentially,match,any,documents,this,method,can,have,false,positives,while,if,it,returns,code,false,code,the,query,won,t,match,any,documents,on,the,current,shard;public,boolean,can,match,shard,search,request,request,throws,ioexception,assert,request,search,type,search,type,unexpected,search,type,request,search,type,try,default,search,context,context,create,search,context,request,default,search,timeout,false,search,source,builder,source,context,request,source,if,can,rewrite,to,match,none,source,query,builder,query,builder,source,query,return,query,builder,instanceof,match,none,query,builder,false,return,true
SearchService -> public boolean canMatch(ShardSearchRequest request) throws IOException;1541008027;This method does a very quick rewrite of the query and returns true if the query can potentially match any documents._This method can have false positives while if it returns <code>false</code> the query won't match any documents on the current_shard.;public boolean canMatch(ShardSearchRequest request) throws IOException {_        assert request.searchType() == SearchType.QUERY_THEN_FETCH : "unexpected search type: " + request.searchType()__        try (DefaultSearchContext context = createSearchContext(request, defaultSearchTimeout, false)) {_            SearchSourceBuilder source = context.request().source()__            if (canRewriteToMatchNone(source)) {_                QueryBuilder queryBuilder = source.query()__                return queryBuilder instanceof MatchNoneQueryBuilder == false__            }_            return true_ _        }_    };this,method,does,a,very,quick,rewrite,of,the,query,and,returns,true,if,the,query,can,potentially,match,any,documents,this,method,can,have,false,positives,while,if,it,returns,code,false,code,the,query,won,t,match,any,documents,on,the,current,shard;public,boolean,can,match,shard,search,request,request,throws,ioexception,assert,request,search,type,search,type,unexpected,search,type,request,search,type,try,default,search,context,context,create,search,context,request,default,search,timeout,false,search,source,builder,source,context,request,source,if,can,rewrite,to,match,none,source,query,builder,query,builder,source,query,return,query,builder,instanceof,match,none,query,builder,false,return,true
SearchService -> public boolean canMatch(ShardSearchRequest request) throws IOException;1541092382;This method does a very quick rewrite of the query and returns true if the query can potentially match any documents._This method can have false positives while if it returns <code>false</code> the query won't match any documents on the current_shard.;public boolean canMatch(ShardSearchRequest request) throws IOException {_        assert request.searchType() == SearchType.QUERY_THEN_FETCH : "unexpected search type: " + request.searchType()__        try (DefaultSearchContext context = createSearchContext(request, defaultSearchTimeout, false)) {_            SearchSourceBuilder source = context.request().source()__            if (canRewriteToMatchNone(source)) {_                QueryBuilder queryBuilder = source.query()__                return queryBuilder instanceof MatchNoneQueryBuilder == false__            }_            return true_ _        }_    };this,method,does,a,very,quick,rewrite,of,the,query,and,returns,true,if,the,query,can,potentially,match,any,documents,this,method,can,have,false,positives,while,if,it,returns,code,false,code,the,query,won,t,match,any,documents,on,the,current,shard;public,boolean,can,match,shard,search,request,request,throws,ioexception,assert,request,search,type,search,type,unexpected,search,type,request,search,type,try,default,search,context,context,create,search,context,request,default,search,timeout,false,search,source,builder,source,context,request,source,if,can,rewrite,to,match,none,source,query,builder,query,builder,source,query,return,query,builder,instanceof,match,none,query,builder,false,return,true
SearchService -> public boolean canMatch(ShardSearchRequest request) throws IOException;1542117235;This method does a very quick rewrite of the query and returns true if the query can potentially match any documents._This method can have false positives while if it returns <code>false</code> the query won't match any documents on the current_shard.;public boolean canMatch(ShardSearchRequest request) throws IOException {_        assert request.searchType() == SearchType.QUERY_THEN_FETCH : "unexpected search type: " + request.searchType()__        try (DefaultSearchContext context = createSearchContext(request, defaultSearchTimeout, false, "can_match")) {_            SearchSourceBuilder source = context.request().source()__            if (canRewriteToMatchNone(source)) {_                QueryBuilder queryBuilder = source.query()__                return queryBuilder instanceof MatchNoneQueryBuilder == false__            }_            return true_ _        }_    };this,method,does,a,very,quick,rewrite,of,the,query,and,returns,true,if,the,query,can,potentially,match,any,documents,this,method,can,have,false,positives,while,if,it,returns,code,false,code,the,query,won,t,match,any,documents,on,the,current,shard;public,boolean,can,match,shard,search,request,request,throws,ioexception,assert,request,search,type,search,type,unexpected,search,type,request,search,type,try,default,search,context,context,create,search,context,request,default,search,timeout,false,search,source,builder,source,context,request,source,if,can,rewrite,to,match,none,source,query,builder,query,builder,source,query,return,query,builder,instanceof,match,none,query,builder,false,return,true
SearchService -> public boolean canMatch(ShardSearchRequest request) throws IOException;1542646292;This method does a very quick rewrite of the query and returns true if the query can potentially match any documents._This method can have false positives while if it returns <code>false</code> the query won't match any documents on the current_shard.;public boolean canMatch(ShardSearchRequest request) throws IOException {_        assert request.searchType() == SearchType.QUERY_THEN_FETCH : "unexpected search type: " + request.searchType()__        try (DefaultSearchContext context = createSearchContext(request, defaultSearchTimeout, false, "can_match")) {_            SearchSourceBuilder source = context.request().source()__            if (canRewriteToMatchNone(source)) {_                QueryBuilder queryBuilder = source.query()__                return queryBuilder instanceof MatchNoneQueryBuilder == false__            }_            return true_ _        }_    };this,method,does,a,very,quick,rewrite,of,the,query,and,returns,true,if,the,query,can,potentially,match,any,documents,this,method,can,have,false,positives,while,if,it,returns,code,false,code,the,query,won,t,match,any,documents,on,the,current,shard;public,boolean,can,match,shard,search,request,request,throws,ioexception,assert,request,search,type,search,type,unexpected,search,type,request,search,type,try,default,search,context,context,create,search,context,request,default,search,timeout,false,search,source,builder,source,context,request,source,if,can,rewrite,to,match,none,source,query,builder,query,builder,source,query,return,query,builder,instanceof,match,none,query,builder,false,return,true
SearchService -> public boolean canMatch(ShardSearchRequest request) throws IOException;1543047942;This method does a very quick rewrite of the query and returns true if the query can potentially match any documents._This method can have false positives while if it returns <code>false</code> the query won't match any documents on the current_shard.;public boolean canMatch(ShardSearchRequest request) throws IOException {_        assert request.searchType() == SearchType.QUERY_THEN_FETCH : "unexpected search type: " + request.searchType()__        try (DefaultSearchContext context = createSearchContext(request, defaultSearchTimeout, false, "can_match")) {_            SearchSourceBuilder source = context.request().source()__            if (canRewriteToMatchNone(source)) {_                QueryBuilder queryBuilder = source.query()__                return queryBuilder instanceof MatchNoneQueryBuilder == false__            }_            return true_ _        }_    };this,method,does,a,very,quick,rewrite,of,the,query,and,returns,true,if,the,query,can,potentially,match,any,documents,this,method,can,have,false,positives,while,if,it,returns,code,false,code,the,query,won,t,match,any,documents,on,the,current,shard;public,boolean,can,match,shard,search,request,request,throws,ioexception,assert,request,search,type,search,type,unexpected,search,type,request,search,type,try,default,search,context,context,create,search,context,request,default,search,timeout,false,search,source,builder,source,context,request,source,if,can,rewrite,to,match,none,source,query,builder,query,builder,source,query,return,query,builder,instanceof,match,none,query,builder,false,return,true
SearchService -> public boolean canMatch(ShardSearchRequest request) throws IOException;1543236161;This method does a very quick rewrite of the query and returns true if the query can potentially match any documents._This method can have false positives while if it returns <code>false</code> the query won't match any documents on the current_shard.;public boolean canMatch(ShardSearchRequest request) throws IOException {_        assert request.searchType() == SearchType.QUERY_THEN_FETCH : "unexpected search type: " + request.searchType()__        try (DefaultSearchContext context = createSearchContext(request, defaultSearchTimeout, false, "can_match")) {_            SearchSourceBuilder source = context.request().source()__            if (canRewriteToMatchNone(source)) {_                QueryBuilder queryBuilder = source.query()__                return queryBuilder instanceof MatchNoneQueryBuilder == false__            }_            return true_ _        }_    };this,method,does,a,very,quick,rewrite,of,the,query,and,returns,true,if,the,query,can,potentially,match,any,documents,this,method,can,have,false,positives,while,if,it,returns,code,false,code,the,query,won,t,match,any,documents,on,the,current,shard;public,boolean,can,match,shard,search,request,request,throws,ioexception,assert,request,search,type,search,type,unexpected,search,type,request,search,type,try,default,search,context,context,create,search,context,request,default,search,timeout,false,search,source,builder,source,context,request,source,if,can,rewrite,to,match,none,source,query,builder,query,builder,source,query,return,query,builder,instanceof,match,none,query,builder,false,return,true
SearchService -> public boolean canMatch(ShardSearchRequest request) throws IOException;1543841718;This method does a very quick rewrite of the query and returns true if the query can potentially match any documents._This method can have false positives while if it returns <code>false</code> the query won't match any documents on the current_shard.;public boolean canMatch(ShardSearchRequest request) throws IOException {_        assert request.searchType() == SearchType.QUERY_THEN_FETCH : "unexpected search type: " + request.searchType()__        try (DefaultSearchContext context = createSearchContext(request, defaultSearchTimeout, false, "can_match")) {_            SearchSourceBuilder source = context.request().source()__            if (canRewriteToMatchNone(source)) {_                QueryBuilder queryBuilder = source.query()__                return queryBuilder instanceof MatchNoneQueryBuilder == false__            }_            return true_ _        }_    };this,method,does,a,very,quick,rewrite,of,the,query,and,returns,true,if,the,query,can,potentially,match,any,documents,this,method,can,have,false,positives,while,if,it,returns,code,false,code,the,query,won,t,match,any,documents,on,the,current,shard;public,boolean,can,match,shard,search,request,request,throws,ioexception,assert,request,search,type,search,type,unexpected,search,type,request,search,type,try,default,search,context,context,create,search,context,request,default,search,timeout,false,search,source,builder,source,context,request,source,if,can,rewrite,to,match,none,source,query,builder,query,builder,source,query,return,query,builder,instanceof,match,none,query,builder,false,return,true
SearchService -> public boolean canMatch(ShardSearchRequest request) throws IOException;1543863430;This method does a very quick rewrite of the query and returns true if the query can potentially match any documents._This method can have false positives while if it returns <code>false</code> the query won't match any documents on the current_shard.;public boolean canMatch(ShardSearchRequest request) throws IOException {_        assert request.searchType() == SearchType.QUERY_THEN_FETCH : "unexpected search type: " + request.searchType()__        try (DefaultSearchContext context = createSearchContext(request, defaultSearchTimeout, false, "can_match")) {_            SearchSourceBuilder source = context.request().source()__            if (canRewriteToMatchNone(source)) {_                QueryBuilder queryBuilder = source.query()__                return queryBuilder instanceof MatchNoneQueryBuilder == false__            }_            return true_ _        }_    };this,method,does,a,very,quick,rewrite,of,the,query,and,returns,true,if,the,query,can,potentially,match,any,documents,this,method,can,have,false,positives,while,if,it,returns,code,false,code,the,query,won,t,match,any,documents,on,the,current,shard;public,boolean,can,match,shard,search,request,request,throws,ioexception,assert,request,search,type,search,type,unexpected,search,type,request,search,type,try,default,search,context,context,create,search,context,request,default,search,timeout,false,search,source,builder,source,context,request,source,if,can,rewrite,to,match,none,source,query,builder,query,builder,source,query,return,query,builder,instanceof,match,none,query,builder,false,return,true
SearchService -> public boolean canMatch(ShardSearchRequest request) throws IOException;1545997405;This method does a very quick rewrite of the query and returns true if the query can potentially match any documents._This method can have false positives while if it returns <code>false</code> the query won't match any documents on the current_shard.;public boolean canMatch(ShardSearchRequest request) throws IOException {_        assert request.searchType() == SearchType.QUERY_THEN_FETCH : "unexpected search type: " + request.searchType()__        try (DefaultSearchContext context = createSearchContext(request, defaultSearchTimeout, false, "can_match")) {_            SearchSourceBuilder source = context.request().source()__            if (canRewriteToMatchNone(source)) {_                QueryBuilder queryBuilder = source.query()__                return queryBuilder instanceof MatchNoneQueryBuilder == false__            }_            return true_ _        }_    };this,method,does,a,very,quick,rewrite,of,the,query,and,returns,true,if,the,query,can,potentially,match,any,documents,this,method,can,have,false,positives,while,if,it,returns,code,false,code,the,query,won,t,match,any,documents,on,the,current,shard;public,boolean,can,match,shard,search,request,request,throws,ioexception,assert,request,search,type,search,type,unexpected,search,type,request,search,type,try,default,search,context,context,create,search,context,request,default,search,timeout,false,search,source,builder,source,context,request,source,if,can,rewrite,to,match,none,source,query,builder,query,builder,source,query,return,query,builder,instanceof,match,none,query,builder,false,return,true
SearchService -> public boolean canMatch(ShardSearchRequest request) throws IOException;1546434630;This method does a very quick rewrite of the query and returns true if the query can potentially match any documents._This method can have false positives while if it returns <code>false</code> the query won't match any documents on the current_shard.;public boolean canMatch(ShardSearchRequest request) throws IOException {_        assert request.searchType() == SearchType.QUERY_THEN_FETCH : "unexpected search type: " + request.searchType()__        try (DefaultSearchContext context = createSearchContext(request, defaultSearchTimeout, false, "can_match")) {_            SearchSourceBuilder source = context.request().source()__            if (canRewriteToMatchNone(source)) {_                QueryBuilder queryBuilder = source.query()__                return queryBuilder instanceof MatchNoneQueryBuilder == false__            }_            return true_ _        }_    };this,method,does,a,very,quick,rewrite,of,the,query,and,returns,true,if,the,query,can,potentially,match,any,documents,this,method,can,have,false,positives,while,if,it,returns,code,false,code,the,query,won,t,match,any,documents,on,the,current,shard;public,boolean,can,match,shard,search,request,request,throws,ioexception,assert,request,search,type,search,type,unexpected,search,type,request,search,type,try,default,search,context,context,create,search,context,request,default,search,timeout,false,search,source,builder,source,context,request,source,if,can,rewrite,to,match,none,source,query,builder,query,builder,source,query,return,query,builder,instanceof,match,none,query,builder,false,return,true
SearchService -> public boolean canMatch(ShardSearchRequest request) throws IOException;1546630609;This method does a very quick rewrite of the query and returns true if the query can potentially match any documents._This method can have false positives while if it returns <code>false</code> the query won't match any documents on the current_shard.;public boolean canMatch(ShardSearchRequest request) throws IOException {_        assert request.searchType() == SearchType.QUERY_THEN_FETCH : "unexpected search type: " + request.searchType()__        try (DefaultSearchContext context = createSearchContext(request, defaultSearchTimeout, false, "can_match")) {_            SearchSourceBuilder source = context.request().source()__            if (canRewriteToMatchNone(source)) {_                QueryBuilder queryBuilder = source.query()__                return queryBuilder instanceof MatchNoneQueryBuilder == false__            }_            return true_ _        }_    };this,method,does,a,very,quick,rewrite,of,the,query,and,returns,true,if,the,query,can,potentially,match,any,documents,this,method,can,have,false,positives,while,if,it,returns,code,false,code,the,query,won,t,match,any,documents,on,the,current,shard;public,boolean,can,match,shard,search,request,request,throws,ioexception,assert,request,search,type,search,type,unexpected,search,type,request,search,type,try,default,search,context,context,create,search,context,request,default,search,timeout,false,search,source,builder,source,context,request,source,if,can,rewrite,to,match,none,source,query,builder,query,builder,source,query,return,query,builder,instanceof,match,none,query,builder,false,return,true
SearchService -> public boolean canMatch(ShardSearchRequest request) throws IOException;1547625930;This method does a very quick rewrite of the query and returns true if the query can potentially match any documents._This method can have false positives while if it returns <code>false</code> the query won't match any documents on the current_shard.;public boolean canMatch(ShardSearchRequest request) throws IOException {_        assert request.searchType() == SearchType.QUERY_THEN_FETCH : "unexpected search type: " + request.searchType()__        try (DefaultSearchContext context = createSearchContext(request, defaultSearchTimeout, false, "can_match")) {_            SearchSourceBuilder source = context.request().source()__            if (canRewriteToMatchNone(source)) {_                QueryBuilder queryBuilder = source.query()__                return queryBuilder instanceof MatchNoneQueryBuilder == false__            }_            return true_ _        }_    };this,method,does,a,very,quick,rewrite,of,the,query,and,returns,true,if,the,query,can,potentially,match,any,documents,this,method,can,have,false,positives,while,if,it,returns,code,false,code,the,query,won,t,match,any,documents,on,the,current,shard;public,boolean,can,match,shard,search,request,request,throws,ioexception,assert,request,search,type,search,type,unexpected,search,type,request,search,type,try,default,search,context,context,create,search,context,request,default,search,timeout,false,search,source,builder,source,context,request,source,if,can,rewrite,to,match,none,source,query,builder,query,builder,source,query,return,query,builder,instanceof,match,none,query,builder,false,return,true
SearchService -> public boolean canMatch(ShardSearchRequest request) throws IOException;1548230518;This method does a very quick rewrite of the query and returns true if the query can potentially match any documents._This method can have false positives while if it returns <code>false</code> the query won't match any documents on the current_shard.;public boolean canMatch(ShardSearchRequest request) throws IOException {_        assert request.searchType() == SearchType.QUERY_THEN_FETCH : "unexpected search type: " + request.searchType()__        try (DefaultSearchContext context = createSearchContext(request, defaultSearchTimeout, false, "can_match")) {_            SearchSourceBuilder source = context.request().source()__            if (canRewriteToMatchNone(source)) {_                QueryBuilder queryBuilder = source.query()__                return queryBuilder instanceof MatchNoneQueryBuilder == false__            }_            return true_ _        }_    };this,method,does,a,very,quick,rewrite,of,the,query,and,returns,true,if,the,query,can,potentially,match,any,documents,this,method,can,have,false,positives,while,if,it,returns,code,false,code,the,query,won,t,match,any,documents,on,the,current,shard;public,boolean,can,match,shard,search,request,request,throws,ioexception,assert,request,search,type,search,type,unexpected,search,type,request,search,type,try,default,search,context,context,create,search,context,request,default,search,timeout,false,search,source,builder,source,context,request,source,if,can,rewrite,to,match,none,source,query,builder,query,builder,source,query,return,query,builder,instanceof,match,none,query,builder,false,return,true
SearchService -> public boolean canMatch(ShardSearchRequest request) throws IOException;1548243524;This method does a very quick rewrite of the query and returns true if the query can potentially match any documents._This method can have false positives while if it returns <code>false</code> the query won't match any documents on the current_shard.;public boolean canMatch(ShardSearchRequest request) throws IOException {_        assert request.searchType() == SearchType.QUERY_THEN_FETCH : "unexpected search type: " + request.searchType()__        try (DefaultSearchContext context = createSearchContext(request, defaultSearchTimeout, false, "can_match")) {_            SearchSourceBuilder source = context.request().source()__            if (canRewriteToMatchNone(source)) {_                QueryBuilder queryBuilder = source.query()__                return queryBuilder instanceof MatchNoneQueryBuilder == false__            }_            return true_ _        }_    };this,method,does,a,very,quick,rewrite,of,the,query,and,returns,true,if,the,query,can,potentially,match,any,documents,this,method,can,have,false,positives,while,if,it,returns,code,false,code,the,query,won,t,match,any,documents,on,the,current,shard;public,boolean,can,match,shard,search,request,request,throws,ioexception,assert,request,search,type,search,type,unexpected,search,type,request,search,type,try,default,search,context,context,create,search,context,request,default,search,timeout,false,search,source,builder,source,context,request,source,if,can,rewrite,to,match,none,source,query,builder,query,builder,source,query,return,query,builder,instanceof,match,none,query,builder,false,return,true
SearchService -> public boolean canMatch(ShardSearchRequest request) throws IOException;1548420339;This method does a very quick rewrite of the query and returns true if the query can potentially match any documents._This method can have false positives while if it returns <code>false</code> the query won't match any documents on the current_shard.;public boolean canMatch(ShardSearchRequest request) throws IOException {_        assert request.searchType() == SearchType.QUERY_THEN_FETCH : "unexpected search type: " + request.searchType()__        try (DefaultSearchContext context = createSearchContext(request, defaultSearchTimeout, false, "can_match")) {_            SearchSourceBuilder source = context.request().source()__            if (canRewriteToMatchNone(source)) {_                QueryBuilder queryBuilder = source.query()__                return queryBuilder instanceof MatchNoneQueryBuilder == false__            }_            return true_ _        }_    };this,method,does,a,very,quick,rewrite,of,the,query,and,returns,true,if,the,query,can,potentially,match,any,documents,this,method,can,have,false,positives,while,if,it,returns,code,false,code,the,query,won,t,match,any,documents,on,the,current,shard;public,boolean,can,match,shard,search,request,request,throws,ioexception,assert,request,search,type,search,type,unexpected,search,type,request,search,type,try,default,search,context,context,create,search,context,request,default,search,timeout,false,search,source,builder,source,context,request,source,if,can,rewrite,to,match,none,source,query,builder,query,builder,source,query,return,query,builder,instanceof,match,none,query,builder,false,return,true
SearchService -> public boolean canMatch(ShardSearchRequest request) throws IOException;1548943934;This method does a very quick rewrite of the query and returns true if the query can potentially match any documents._This method can have false positives while if it returns <code>false</code> the query won't match any documents on the current_shard.;public boolean canMatch(ShardSearchRequest request) throws IOException {_        assert request.searchType() == SearchType.QUERY_THEN_FETCH : "unexpected search type: " + request.searchType()__        try (DefaultSearchContext context = createSearchContext(request, defaultSearchTimeout, false, "can_match")) {_            SearchSourceBuilder source = context.request().source()__            if (canRewriteToMatchNone(source)) {_                QueryBuilder queryBuilder = source.query()__                return queryBuilder instanceof MatchNoneQueryBuilder == false__            }_            return true_ _        }_    };this,method,does,a,very,quick,rewrite,of,the,query,and,returns,true,if,the,query,can,potentially,match,any,documents,this,method,can,have,false,positives,while,if,it,returns,code,false,code,the,query,won,t,match,any,documents,on,the,current,shard;public,boolean,can,match,shard,search,request,request,throws,ioexception,assert,request,search,type,search,type,unexpected,search,type,request,search,type,try,default,search,context,context,create,search,context,request,default,search,timeout,false,search,source,builder,source,context,request,source,if,can,rewrite,to,match,none,source,query,builder,query,builder,source,query,return,query,builder,instanceof,match,none,query,builder,false,return,true
SearchService -> public boolean canMatch(ShardSearchRequest request) throws IOException;1550737421;This method does a very quick rewrite of the query and returns true if the query can potentially match any documents._This method can have false positives while if it returns <code>false</code> the query won't match any documents on the current_shard.;public boolean canMatch(ShardSearchRequest request) throws IOException {_        assert request.searchType() == SearchType.QUERY_THEN_FETCH : "unexpected search type: " + request.searchType()__        try (DefaultSearchContext context = createSearchContext(request, defaultSearchTimeout, false, "can_match")) {_            SearchSourceBuilder source = context.request().source()__            if (canRewriteToMatchNone(source)) {_                QueryBuilder queryBuilder = source.query()__                return queryBuilder instanceof MatchNoneQueryBuilder == false__            }_            return true_ _        }_    };this,method,does,a,very,quick,rewrite,of,the,query,and,returns,true,if,the,query,can,potentially,match,any,documents,this,method,can,have,false,positives,while,if,it,returns,code,false,code,the,query,won,t,match,any,documents,on,the,current,shard;public,boolean,can,match,shard,search,request,request,throws,ioexception,assert,request,search,type,search,type,unexpected,search,type,request,search,type,try,default,search,context,context,create,search,context,request,default,search,timeout,false,search,source,builder,source,context,request,source,if,can,rewrite,to,match,none,source,query,builder,query,builder,source,query,return,query,builder,instanceof,match,none,query,builder,false,return,true
SearchService -> private void loadOrExecuteQueryPhase(final ShardSearchRequest request, final SearchContext context) throws Exception;1524684173;Try to load the query results from the cache or execute the query phase directly if the cache cannot be used.;private void loadOrExecuteQueryPhase(final ShardSearchRequest request, final SearchContext context) throws Exception {_        final boolean canCache = indicesService.canCache(request, context)__        context.getQueryShardContext().freezeContext()__        if (canCache) {_            indicesService.loadIntoContext(request, context, queryPhase)__        } else {_            queryPhase.execute(context)__        }_    };try,to,load,the,query,results,from,the,cache,or,execute,the,query,phase,directly,if,the,cache,cannot,be,used;private,void,load,or,execute,query,phase,final,shard,search,request,request,final,search,context,context,throws,exception,final,boolean,can,cache,indices,service,can,cache,request,context,context,get,query,shard,context,freeze,context,if,can,cache,indices,service,load,into,context,request,context,query,phase,else,query,phase,execute,context
SearchService -> private void loadOrExecuteQueryPhase(final ShardSearchRequest request, final SearchContext context) throws Exception;1524780945;Try to load the query results from the cache or execute the query phase directly if the cache cannot be used.;private void loadOrExecuteQueryPhase(final ShardSearchRequest request, final SearchContext context) throws Exception {_        final boolean canCache = indicesService.canCache(request, context)__        context.getQueryShardContext().freezeContext()__        if (canCache) {_            indicesService.loadIntoContext(request, context, queryPhase)__        } else {_            queryPhase.execute(context)__        }_    };try,to,load,the,query,results,from,the,cache,or,execute,the,query,phase,directly,if,the,cache,cannot,be,used;private,void,load,or,execute,query,phase,final,shard,search,request,request,final,search,context,context,throws,exception,final,boolean,can,cache,indices,service,can,cache,request,context,context,get,query,shard,context,freeze,context,if,can,cache,indices,service,load,into,context,request,context,query,phase,else,query,phase,execute,context
SearchService -> private void loadOrExecuteQueryPhase(final ShardSearchRequest request, final SearchContext context) throws Exception;1525334055;Try to load the query results from the cache or execute the query phase directly if the cache cannot be used.;private void loadOrExecuteQueryPhase(final ShardSearchRequest request, final SearchContext context) throws Exception {_        final boolean canCache = indicesService.canCache(request, context)__        context.getQueryShardContext().freezeContext()__        if (canCache) {_            indicesService.loadIntoContext(request, context, queryPhase)__        } else {_            queryPhase.execute(context)__        }_    };try,to,load,the,query,results,from,the,cache,or,execute,the,query,phase,directly,if,the,cache,cannot,be,used;private,void,load,or,execute,query,phase,final,shard,search,request,request,final,search,context,context,throws,exception,final,boolean,can,cache,indices,service,can,cache,request,context,context,get,query,shard,context,freeze,context,if,can,cache,indices,service,load,into,context,request,context,query,phase,else,query,phase,execute,context
SearchService -> private void loadOrExecuteQueryPhase(final ShardSearchRequest request, final SearchContext context) throws Exception;1527583663;Try to load the query results from the cache or execute the query phase directly if the cache cannot be used.;private void loadOrExecuteQueryPhase(final ShardSearchRequest request, final SearchContext context) throws Exception {_        final boolean canCache = indicesService.canCache(request, context)__        context.getQueryShardContext().freezeContext()__        if (canCache) {_            indicesService.loadIntoContext(request, context, queryPhase)__        } else {_            queryPhase.execute(context)__        }_    };try,to,load,the,query,results,from,the,cache,or,execute,the,query,phase,directly,if,the,cache,cannot,be,used;private,void,load,or,execute,query,phase,final,shard,search,request,request,final,search,context,context,throws,exception,final,boolean,can,cache,indices,service,can,cache,request,context,context,get,query,shard,context,freeze,context,if,can,cache,indices,service,load,into,context,request,context,query,phase,else,query,phase,execute,context
SearchService -> private void loadOrExecuteQueryPhase(final ShardSearchRequest request, final SearchContext context) throws Exception;1533641732;Try to load the query results from the cache or execute the query phase directly if the cache cannot be used.;private void loadOrExecuteQueryPhase(final ShardSearchRequest request, final SearchContext context) throws Exception {_        final boolean canCache = indicesService.canCache(request, context)__        context.getQueryShardContext().freezeContext()__        if (canCache) {_            indicesService.loadIntoContext(request, context, queryPhase)__        } else {_            queryPhase.execute(context)__        }_    };try,to,load,the,query,results,from,the,cache,or,execute,the,query,phase,directly,if,the,cache,cannot,be,used;private,void,load,or,execute,query,phase,final,shard,search,request,request,final,search,context,context,throws,exception,final,boolean,can,cache,indices,service,can,cache,request,context,context,get,query,shard,context,freeze,context,if,can,cache,indices,service,load,into,context,request,context,query,phase,else,query,phase,execute,context
SearchService -> private void loadOrExecuteQueryPhase(final ShardSearchRequest request, final SearchContext context) throws Exception;1535046779;Try to load the query results from the cache or execute the query phase directly if the cache cannot be used.;private void loadOrExecuteQueryPhase(final ShardSearchRequest request, final SearchContext context) throws Exception {_        final boolean canCache = indicesService.canCache(request, context)__        context.getQueryShardContext().freezeContext()__        if (canCache) {_            indicesService.loadIntoContext(request, context, queryPhase)__        } else {_            queryPhase.execute(context)__        }_    };try,to,load,the,query,results,from,the,cache,or,execute,the,query,phase,directly,if,the,cache,cannot,be,used;private,void,load,or,execute,query,phase,final,shard,search,request,request,final,search,context,context,throws,exception,final,boolean,can,cache,indices,service,can,cache,request,context,context,get,query,shard,context,freeze,context,if,can,cache,indices,service,load,into,context,request,context,query,phase,else,query,phase,execute,context
SearchService -> private void loadOrExecuteQueryPhase(final ShardSearchRequest request, final SearchContext context) throws Exception;1536314350;Try to load the query results from the cache or execute the query phase directly if the cache cannot be used.;private void loadOrExecuteQueryPhase(final ShardSearchRequest request, final SearchContext context) throws Exception {_        final boolean canCache = indicesService.canCache(request, context)__        context.getQueryShardContext().freezeContext()__        if (canCache) {_            indicesService.loadIntoContext(request, context, queryPhase)__        } else {_            queryPhase.execute(context)__        }_    };try,to,load,the,query,results,from,the,cache,or,execute,the,query,phase,directly,if,the,cache,cannot,be,used;private,void,load,or,execute,query,phase,final,shard,search,request,request,final,search,context,context,throws,exception,final,boolean,can,cache,indices,service,can,cache,request,context,context,get,query,shard,context,freeze,context,if,can,cache,indices,service,load,into,context,request,context,query,phase,else,query,phase,execute,context
SearchService -> private void loadOrExecuteQueryPhase(final ShardSearchRequest request, final SearchContext context) throws Exception;1537806831;Try to load the query results from the cache or execute the query phase directly if the cache cannot be used.;private void loadOrExecuteQueryPhase(final ShardSearchRequest request, final SearchContext context) throws Exception {_        final boolean canCache = indicesService.canCache(request, context)__        context.getQueryShardContext().freezeContext()__        if (canCache) {_            indicesService.loadIntoContext(request, context, queryPhase)__        } else {_            queryPhase.execute(context)__        }_    };try,to,load,the,query,results,from,the,cache,or,execute,the,query,phase,directly,if,the,cache,cannot,be,used;private,void,load,or,execute,query,phase,final,shard,search,request,request,final,search,context,context,throws,exception,final,boolean,can,cache,indices,service,can,cache,request,context,context,get,query,shard,context,freeze,context,if,can,cache,indices,service,load,into,context,request,context,query,phase,else,query,phase,execute,context
SearchService -> private void loadOrExecuteQueryPhase(final ShardSearchRequest request, final SearchContext context) throws Exception;1540238977;Try to load the query results from the cache or execute the query phase directly if the cache cannot be used.;private void loadOrExecuteQueryPhase(final ShardSearchRequest request, final SearchContext context) throws Exception {_        final boolean canCache = indicesService.canCache(request, context)__        context.getQueryShardContext().freezeContext()__        if (canCache) {_            indicesService.loadIntoContext(request, context, queryPhase)__        } else {_            queryPhase.execute(context)__        }_    };try,to,load,the,query,results,from,the,cache,or,execute,the,query,phase,directly,if,the,cache,cannot,be,used;private,void,load,or,execute,query,phase,final,shard,search,request,request,final,search,context,context,throws,exception,final,boolean,can,cache,indices,service,can,cache,request,context,context,get,query,shard,context,freeze,context,if,can,cache,indices,service,load,into,context,request,context,query,phase,else,query,phase,execute,context
SearchService -> private void loadOrExecuteQueryPhase(final ShardSearchRequest request, final SearchContext context) throws Exception;1540583181;Try to load the query results from the cache or execute the query phase directly if the cache cannot be used.;private void loadOrExecuteQueryPhase(final ShardSearchRequest request, final SearchContext context) throws Exception {_        final boolean canCache = indicesService.canCache(request, context)__        context.getQueryShardContext().freezeContext()__        if (canCache) {_            indicesService.loadIntoContext(request, context, queryPhase)__        } else {_            queryPhase.execute(context)__        }_    };try,to,load,the,query,results,from,the,cache,or,execute,the,query,phase,directly,if,the,cache,cannot,be,used;private,void,load,or,execute,query,phase,final,shard,search,request,request,final,search,context,context,throws,exception,final,boolean,can,cache,indices,service,can,cache,request,context,context,get,query,shard,context,freeze,context,if,can,cache,indices,service,load,into,context,request,context,query,phase,else,query,phase,execute,context
SearchService -> private void loadOrExecuteQueryPhase(final ShardSearchRequest request, final SearchContext context) throws Exception;1541008027;Try to load the query results from the cache or execute the query phase directly if the cache cannot be used.;private void loadOrExecuteQueryPhase(final ShardSearchRequest request, final SearchContext context) throws Exception {_        final boolean canCache = indicesService.canCache(request, context)__        context.getQueryShardContext().freezeContext()__        if (canCache) {_            indicesService.loadIntoContext(request, context, queryPhase)__        } else {_            queryPhase.execute(context)__        }_    };try,to,load,the,query,results,from,the,cache,or,execute,the,query,phase,directly,if,the,cache,cannot,be,used;private,void,load,or,execute,query,phase,final,shard,search,request,request,final,search,context,context,throws,exception,final,boolean,can,cache,indices,service,can,cache,request,context,context,get,query,shard,context,freeze,context,if,can,cache,indices,service,load,into,context,request,context,query,phase,else,query,phase,execute,context
SearchService -> private void loadOrExecuteQueryPhase(final ShardSearchRequest request, final SearchContext context) throws Exception;1541092382;Try to load the query results from the cache or execute the query phase directly if the cache cannot be used.;private void loadOrExecuteQueryPhase(final ShardSearchRequest request, final SearchContext context) throws Exception {_        final boolean canCache = indicesService.canCache(request, context)__        context.getQueryShardContext().freezeContext()__        if (canCache) {_            indicesService.loadIntoContext(request, context, queryPhase)__        } else {_            queryPhase.execute(context)__        }_    };try,to,load,the,query,results,from,the,cache,or,execute,the,query,phase,directly,if,the,cache,cannot,be,used;private,void,load,or,execute,query,phase,final,shard,search,request,request,final,search,context,context,throws,exception,final,boolean,can,cache,indices,service,can,cache,request,context,context,get,query,shard,context,freeze,context,if,can,cache,indices,service,load,into,context,request,context,query,phase,else,query,phase,execute,context
SearchService -> private void loadOrExecuteQueryPhase(final ShardSearchRequest request, final SearchContext context) throws Exception;1542117235;Try to load the query results from the cache or execute the query phase directly if the cache cannot be used.;private void loadOrExecuteQueryPhase(final ShardSearchRequest request, final SearchContext context) throws Exception {_        final boolean canCache = indicesService.canCache(request, context)__        context.getQueryShardContext().freezeContext()__        if (canCache) {_            indicesService.loadIntoContext(request, context, queryPhase)__        } else {_            queryPhase.execute(context)__        }_    };try,to,load,the,query,results,from,the,cache,or,execute,the,query,phase,directly,if,the,cache,cannot,be,used;private,void,load,or,execute,query,phase,final,shard,search,request,request,final,search,context,context,throws,exception,final,boolean,can,cache,indices,service,can,cache,request,context,context,get,query,shard,context,freeze,context,if,can,cache,indices,service,load,into,context,request,context,query,phase,else,query,phase,execute,context
SearchService -> private void loadOrExecuteQueryPhase(final ShardSearchRequest request, final SearchContext context) throws Exception;1542646292;Try to load the query results from the cache or execute the query phase directly if the cache cannot be used.;private void loadOrExecuteQueryPhase(final ShardSearchRequest request, final SearchContext context) throws Exception {_        final boolean canCache = indicesService.canCache(request, context)__        context.getQueryShardContext().freezeContext()__        if (canCache) {_            indicesService.loadIntoContext(request, context, queryPhase)__        } else {_            queryPhase.execute(context)__        }_    };try,to,load,the,query,results,from,the,cache,or,execute,the,query,phase,directly,if,the,cache,cannot,be,used;private,void,load,or,execute,query,phase,final,shard,search,request,request,final,search,context,context,throws,exception,final,boolean,can,cache,indices,service,can,cache,request,context,context,get,query,shard,context,freeze,context,if,can,cache,indices,service,load,into,context,request,context,query,phase,else,query,phase,execute,context
SearchService -> private void loadOrExecuteQueryPhase(final ShardSearchRequest request, final SearchContext context) throws Exception;1543047942;Try to load the query results from the cache or execute the query phase directly if the cache cannot be used.;private void loadOrExecuteQueryPhase(final ShardSearchRequest request, final SearchContext context) throws Exception {_        final boolean canCache = indicesService.canCache(request, context)__        context.getQueryShardContext().freezeContext()__        if (canCache) {_            indicesService.loadIntoContext(request, context, queryPhase)__        } else {_            queryPhase.execute(context)__        }_    };try,to,load,the,query,results,from,the,cache,or,execute,the,query,phase,directly,if,the,cache,cannot,be,used;private,void,load,or,execute,query,phase,final,shard,search,request,request,final,search,context,context,throws,exception,final,boolean,can,cache,indices,service,can,cache,request,context,context,get,query,shard,context,freeze,context,if,can,cache,indices,service,load,into,context,request,context,query,phase,else,query,phase,execute,context
SearchService -> private void loadOrExecuteQueryPhase(final ShardSearchRequest request, final SearchContext context) throws Exception;1543236161;Try to load the query results from the cache or execute the query phase directly if the cache cannot be used.;private void loadOrExecuteQueryPhase(final ShardSearchRequest request, final SearchContext context) throws Exception {_        final boolean canCache = indicesService.canCache(request, context)__        context.getQueryShardContext().freezeContext()__        if (canCache) {_            indicesService.loadIntoContext(request, context, queryPhase)__        } else {_            queryPhase.execute(context)__        }_    };try,to,load,the,query,results,from,the,cache,or,execute,the,query,phase,directly,if,the,cache,cannot,be,used;private,void,load,or,execute,query,phase,final,shard,search,request,request,final,search,context,context,throws,exception,final,boolean,can,cache,indices,service,can,cache,request,context,context,get,query,shard,context,freeze,context,if,can,cache,indices,service,load,into,context,request,context,query,phase,else,query,phase,execute,context
SearchService -> private void loadOrExecuteQueryPhase(final ShardSearchRequest request, final SearchContext context) throws Exception;1543841718;Try to load the query results from the cache or execute the query phase directly if the cache cannot be used.;private void loadOrExecuteQueryPhase(final ShardSearchRequest request, final SearchContext context) throws Exception {_        final boolean canCache = indicesService.canCache(request, context)__        context.getQueryShardContext().freezeContext()__        if (canCache) {_            indicesService.loadIntoContext(request, context, queryPhase)__        } else {_            queryPhase.execute(context)__        }_    };try,to,load,the,query,results,from,the,cache,or,execute,the,query,phase,directly,if,the,cache,cannot,be,used;private,void,load,or,execute,query,phase,final,shard,search,request,request,final,search,context,context,throws,exception,final,boolean,can,cache,indices,service,can,cache,request,context,context,get,query,shard,context,freeze,context,if,can,cache,indices,service,load,into,context,request,context,query,phase,else,query,phase,execute,context
SearchService -> private void loadOrExecuteQueryPhase(final ShardSearchRequest request, final SearchContext context) throws Exception;1543863430;Try to load the query results from the cache or execute the query phase directly if the cache cannot be used.;private void loadOrExecuteQueryPhase(final ShardSearchRequest request, final SearchContext context) throws Exception {_        final boolean canCache = indicesService.canCache(request, context)__        context.getQueryShardContext().freezeContext()__        if (canCache) {_            indicesService.loadIntoContext(request, context, queryPhase)__        } else {_            queryPhase.execute(context)__        }_    };try,to,load,the,query,results,from,the,cache,or,execute,the,query,phase,directly,if,the,cache,cannot,be,used;private,void,load,or,execute,query,phase,final,shard,search,request,request,final,search,context,context,throws,exception,final,boolean,can,cache,indices,service,can,cache,request,context,context,get,query,shard,context,freeze,context,if,can,cache,indices,service,load,into,context,request,context,query,phase,else,query,phase,execute,context
SearchService -> private void loadOrExecuteQueryPhase(final ShardSearchRequest request, final SearchContext context) throws Exception;1545997405;Try to load the query results from the cache or execute the query phase directly if the cache cannot be used.;private void loadOrExecuteQueryPhase(final ShardSearchRequest request, final SearchContext context) throws Exception {_        final boolean canCache = indicesService.canCache(request, context)__        context.getQueryShardContext().freezeContext()__        if (canCache) {_            indicesService.loadIntoContext(request, context, queryPhase)__        } else {_            queryPhase.execute(context)__        }_    };try,to,load,the,query,results,from,the,cache,or,execute,the,query,phase,directly,if,the,cache,cannot,be,used;private,void,load,or,execute,query,phase,final,shard,search,request,request,final,search,context,context,throws,exception,final,boolean,can,cache,indices,service,can,cache,request,context,context,get,query,shard,context,freeze,context,if,can,cache,indices,service,load,into,context,request,context,query,phase,else,query,phase,execute,context
SearchService -> private void loadOrExecuteQueryPhase(final ShardSearchRequest request, final SearchContext context) throws Exception;1546434630;Try to load the query results from the cache or execute the query phase directly if the cache cannot be used.;private void loadOrExecuteQueryPhase(final ShardSearchRequest request, final SearchContext context) throws Exception {_        final boolean canCache = indicesService.canCache(request, context)__        context.getQueryShardContext().freezeContext()__        if (canCache) {_            indicesService.loadIntoContext(request, context, queryPhase)__        } else {_            queryPhase.execute(context)__        }_    };try,to,load,the,query,results,from,the,cache,or,execute,the,query,phase,directly,if,the,cache,cannot,be,used;private,void,load,or,execute,query,phase,final,shard,search,request,request,final,search,context,context,throws,exception,final,boolean,can,cache,indices,service,can,cache,request,context,context,get,query,shard,context,freeze,context,if,can,cache,indices,service,load,into,context,request,context,query,phase,else,query,phase,execute,context
SearchService -> private void loadOrExecuteQueryPhase(final ShardSearchRequest request, final SearchContext context) throws Exception;1546630609;Try to load the query results from the cache or execute the query phase directly if the cache cannot be used.;private void loadOrExecuteQueryPhase(final ShardSearchRequest request, final SearchContext context) throws Exception {_        final boolean canCache = indicesService.canCache(request, context)__        context.getQueryShardContext().freezeContext()__        if (canCache) {_            indicesService.loadIntoContext(request, context, queryPhase)__        } else {_            queryPhase.execute(context)__        }_    };try,to,load,the,query,results,from,the,cache,or,execute,the,query,phase,directly,if,the,cache,cannot,be,used;private,void,load,or,execute,query,phase,final,shard,search,request,request,final,search,context,context,throws,exception,final,boolean,can,cache,indices,service,can,cache,request,context,context,get,query,shard,context,freeze,context,if,can,cache,indices,service,load,into,context,request,context,query,phase,else,query,phase,execute,context
SearchService -> private void loadOrExecuteQueryPhase(final ShardSearchRequest request, final SearchContext context) throws Exception;1547625930;Try to load the query results from the cache or execute the query phase directly if the cache cannot be used.;private void loadOrExecuteQueryPhase(final ShardSearchRequest request, final SearchContext context) throws Exception {_        final boolean canCache = indicesService.canCache(request, context)__        context.getQueryShardContext().freezeContext()__        if (canCache) {_            indicesService.loadIntoContext(request, context, queryPhase)__        } else {_            queryPhase.execute(context)__        }_    };try,to,load,the,query,results,from,the,cache,or,execute,the,query,phase,directly,if,the,cache,cannot,be,used;private,void,load,or,execute,query,phase,final,shard,search,request,request,final,search,context,context,throws,exception,final,boolean,can,cache,indices,service,can,cache,request,context,context,get,query,shard,context,freeze,context,if,can,cache,indices,service,load,into,context,request,context,query,phase,else,query,phase,execute,context
SearchService -> private void loadOrExecuteQueryPhase(final ShardSearchRequest request, final SearchContext context) throws Exception;1548230518;Try to load the query results from the cache or execute the query phase directly if the cache cannot be used.;private void loadOrExecuteQueryPhase(final ShardSearchRequest request, final SearchContext context) throws Exception {_        final boolean canCache = indicesService.canCache(request, context)__        context.getQueryShardContext().freezeContext()__        if (canCache) {_            indicesService.loadIntoContext(request, context, queryPhase)__        } else {_            queryPhase.execute(context)__        }_    };try,to,load,the,query,results,from,the,cache,or,execute,the,query,phase,directly,if,the,cache,cannot,be,used;private,void,load,or,execute,query,phase,final,shard,search,request,request,final,search,context,context,throws,exception,final,boolean,can,cache,indices,service,can,cache,request,context,context,get,query,shard,context,freeze,context,if,can,cache,indices,service,load,into,context,request,context,query,phase,else,query,phase,execute,context
SearchService -> private void loadOrExecuteQueryPhase(final ShardSearchRequest request, final SearchContext context) throws Exception;1548243524;Try to load the query results from the cache or execute the query phase directly if the cache cannot be used.;private void loadOrExecuteQueryPhase(final ShardSearchRequest request, final SearchContext context) throws Exception {_        final boolean canCache = indicesService.canCache(request, context)__        context.getQueryShardContext().freezeContext()__        if (canCache) {_            indicesService.loadIntoContext(request, context, queryPhase)__        } else {_            queryPhase.execute(context)__        }_    };try,to,load,the,query,results,from,the,cache,or,execute,the,query,phase,directly,if,the,cache,cannot,be,used;private,void,load,or,execute,query,phase,final,shard,search,request,request,final,search,context,context,throws,exception,final,boolean,can,cache,indices,service,can,cache,request,context,context,get,query,shard,context,freeze,context,if,can,cache,indices,service,load,into,context,request,context,query,phase,else,query,phase,execute,context
SearchService -> private void loadOrExecuteQueryPhase(final ShardSearchRequest request, final SearchContext context) throws Exception;1548420339;Try to load the query results from the cache or execute the query phase directly if the cache cannot be used.;private void loadOrExecuteQueryPhase(final ShardSearchRequest request, final SearchContext context) throws Exception {_        final boolean canCache = indicesService.canCache(request, context)__        context.getQueryShardContext().freezeContext()__        if (canCache) {_            indicesService.loadIntoContext(request, context, queryPhase)__        } else {_            queryPhase.execute(context)__        }_    };try,to,load,the,query,results,from,the,cache,or,execute,the,query,phase,directly,if,the,cache,cannot,be,used;private,void,load,or,execute,query,phase,final,shard,search,request,request,final,search,context,context,throws,exception,final,boolean,can,cache,indices,service,can,cache,request,context,context,get,query,shard,context,freeze,context,if,can,cache,indices,service,load,into,context,request,context,query,phase,else,query,phase,execute,context
SearchService -> private void loadOrExecuteQueryPhase(final ShardSearchRequest request, final SearchContext context) throws Exception;1548943934;Try to load the query results from the cache or execute the query phase directly if the cache cannot be used.;private void loadOrExecuteQueryPhase(final ShardSearchRequest request, final SearchContext context) throws Exception {_        final boolean canCache = indicesService.canCache(request, context)__        context.getQueryShardContext().freezeContext()__        if (canCache) {_            indicesService.loadIntoContext(request, context, queryPhase)__        } else {_            queryPhase.execute(context)__        }_    };try,to,load,the,query,results,from,the,cache,or,execute,the,query,phase,directly,if,the,cache,cannot,be,used;private,void,load,or,execute,query,phase,final,shard,search,request,request,final,search,context,context,throws,exception,final,boolean,can,cache,indices,service,can,cache,request,context,context,get,query,shard,context,freeze,context,if,can,cache,indices,service,load,into,context,request,context,query,phase,else,query,phase,execute,context
SearchService -> private void loadOrExecuteQueryPhase(final ShardSearchRequest request, final SearchContext context) throws Exception;1550737421;Try to load the query results from the cache or execute the query phase directly if the cache cannot be used.;private void loadOrExecuteQueryPhase(final ShardSearchRequest request, final SearchContext context) throws Exception {_        final boolean canCache = indicesService.canCache(request, context)__        context.getQueryShardContext().freezeContext()__        if (canCache) {_            indicesService.loadIntoContext(request, context, queryPhase)__        } else {_            queryPhase.execute(context)__        }_    };try,to,load,the,query,results,from,the,cache,or,execute,the,query,phase,directly,if,the,cache,cannot,be,used;private,void,load,or,execute,query,phase,final,shard,search,request,request,final,search,context,context,throws,exception,final,boolean,can,cache,indices,service,can,cache,request,context,context,get,query,shard,context,freeze,context,if,can,cache,indices,service,load,into,context,request,context,query,phase,else,query,phase,execute,context
