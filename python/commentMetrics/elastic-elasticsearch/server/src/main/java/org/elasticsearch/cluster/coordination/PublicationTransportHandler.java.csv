commented;modifiers;parameterAmount;loc;comment;code
false;public;1;8;;@Override public void onResponse(Void aVoid) {     try {         channel.sendResponse(TransportResponse.Empty.INSTANCE).     } catch (IOException e) {         logger.debug("failed to send response on commit", e).     } }
false;public;1;9;;@Override public void onFailure(Exception e) {     try {         channel.sendResponse(e).     } catch (IOException ie) {         e.addSuppressed(ie).         logger.debug("failed to send response on commit", e).     } }
false;private;1;23;;private ActionListener<Void> transportCommitCallback(TransportChannel channel) {     return new ActionListener<Void>() {          @Override         public void onResponse(Void aVoid) {             try {                 channel.sendResponse(TransportResponse.Empty.INSTANCE).             } catch (IOException e) {                 logger.debug("failed to send response on commit", e).             }         }          @Override         public void onFailure(Exception e) {             try {                 channel.sendResponse(e).             } catch (IOException ie) {                 e.addSuppressed(ie).                 logger.debug("failed to send response on commit", e).             }         }     }. }
false;public;0;6;;public PublishClusterStateStats stats() {     return new PublishClusterStateStats(fullClusterStateReceivedCount.get(), incompatibleClusterStateDiffReceivedCount.get(), compatibleClusterStateDiffReceivedCount.get()). }
false;;3;2;;void sendPublishRequest(DiscoveryNode destination, PublishRequest publishRequest, ActionListener<PublishWithJoinResponse> responseActionListener).
false;;3;2;;void sendApplyCommit(DiscoveryNode destination, ApplyCommitRequest applyCommitRequest, ActionListener<TransportResponse.Empty> responseActionListener).
false;public;1;5;;@Override public void onFailure(Exception e) {     // wrap into fake TransportException, as that's what we expect in Publication     responseActionListener.onFailure(new TransportException(e)). }
false;protected;0;4;;@Override protected void doRun() {     responseActionListener.onResponse(handlePublishRequest.apply(publishRequest)). }
false;public;0;4;;@Override public String toString() {     return "publish to self of " + publishRequest. }
false;public;3;36;;@Override public void sendPublishRequest(DiscoveryNode destination, PublishRequest publishRequest, ActionListener<PublishWithJoinResponse> responseActionListener) {     assert publishRequest.getAcceptedState() == clusterChangedEvent.state() : "state got switched on us".     if (destination.equals(nodes.getLocalNode())) {         // the master needs the original non-serialized state as the cluster state contains some volatile information that we         // don't want to be replicated because it's not usable on another node (e.g. UnassignedInfo.unassignedTimeNanos) or         // because it's mostly just debugging info that would unnecessarily blow up CS updates (I think there was one in         // snapshot code).         // TODO: look into these and check how to get rid of them         transportService.getThreadPool().generic().execute(new AbstractRunnable() {              @Override             public void onFailure(Exception e) {                 // wrap into fake TransportException, as that's what we expect in Publication                 responseActionListener.onFailure(new TransportException(e)).             }              @Override             protected void doRun() {                 responseActionListener.onResponse(handlePublishRequest.apply(publishRequest)).             }              @Override             public String toString() {                 return "publish to self of " + publishRequest.             }         }).     } else if (sendFullVersion || !previousState.nodes().nodeExists(destination)) {         logger.trace("sending full cluster state version {} to {}", newState.version(), destination).         PublicationTransportHandler.this.sendFullClusterState(newState, serializedStates, destination, responseActionListener).     } else {         logger.trace("sending cluster state diff for version {} to {}", newState.version(), destination).         PublicationTransportHandler.this.sendClusterStateDiff(newState, serializedDiffs, serializedStates, destination, responseActionListener).     } }
false;public;1;4;;@Override public TransportResponse.Empty read(StreamInput in) {     return TransportResponse.Empty.INSTANCE. }
false;public;1;4;;@Override public void handleResponse(TransportResponse.Empty response) {     responseActionListener.onResponse(response). }
false;public;1;4;;@Override public void handleException(TransportException exp) {     responseActionListener.onFailure(exp). }
false;public;0;4;;@Override public String executor() {     return ThreadPool.Names.GENERIC. }
false;public;3;36;;@Override public void sendApplyCommit(DiscoveryNode destination, ApplyCommitRequest applyCommitRequest, ActionListener<TransportResponse.Empty> responseActionListener) {     final String actionName.     final TransportRequest transportRequest.     if (Coordinator.isZen1Node(destination)) {         actionName = PublishClusterStateAction.COMMIT_ACTION_NAME.         transportRequest = new PublishClusterStateAction.CommitClusterStateRequest(newState.stateUUID()).     } else {         actionName = COMMIT_STATE_ACTION_NAME.         transportRequest = applyCommitRequest.     }     transportService.sendRequest(destination, actionName, transportRequest, stateRequestOptions, new TransportResponseHandler<TransportResponse.Empty>() {          @Override         public TransportResponse.Empty read(StreamInput in) {             return TransportResponse.Empty.INSTANCE.         }          @Override         public void handleResponse(TransportResponse.Empty response) {             responseActionListener.onResponse(response).         }          @Override         public void handleException(TransportException exp) {             responseActionListener.onFailure(exp).         }          @Override         public String executor() {             return ThreadPool.Names.GENERIC.         }     }). }
false;public;1;91;;public PublicationContext newPublicationContext(ClusterChangedEvent clusterChangedEvent) {     final DiscoveryNodes nodes = clusterChangedEvent.state().nodes().     final ClusterState newState = clusterChangedEvent.state().     final ClusterState previousState = clusterChangedEvent.previousState().     final boolean sendFullVersion = clusterChangedEvent.previousState().getBlocks().disableStatePersistence().     final Map<Version, BytesReference> serializedStates = new HashMap<>().     final Map<Version, BytesReference> serializedDiffs = new HashMap<>().     // we build these early as a best effort not to commit in the case of error.     // sadly this is not water tight as it may that a failed diff based publishing to a node     // will cause a full serialization based on an older version, which may fail after the     // change has been committed.     buildDiffAndSerializeStates(clusterChangedEvent.state(), clusterChangedEvent.previousState(), nodes, sendFullVersion, serializedStates, serializedDiffs).     return new PublicationContext() {          @Override         public void sendPublishRequest(DiscoveryNode destination, PublishRequest publishRequest, ActionListener<PublishWithJoinResponse> responseActionListener) {             assert publishRequest.getAcceptedState() == clusterChangedEvent.state() : "state got switched on us".             if (destination.equals(nodes.getLocalNode())) {                 // the master needs the original non-serialized state as the cluster state contains some volatile information that we                 // don't want to be replicated because it's not usable on another node (e.g. UnassignedInfo.unassignedTimeNanos) or                 // because it's mostly just debugging info that would unnecessarily blow up CS updates (I think there was one in                 // snapshot code).                 // TODO: look into these and check how to get rid of them                 transportService.getThreadPool().generic().execute(new AbstractRunnable() {                      @Override                     public void onFailure(Exception e) {                         // wrap into fake TransportException, as that's what we expect in Publication                         responseActionListener.onFailure(new TransportException(e)).                     }                      @Override                     protected void doRun() {                         responseActionListener.onResponse(handlePublishRequest.apply(publishRequest)).                     }                      @Override                     public String toString() {                         return "publish to self of " + publishRequest.                     }                 }).             } else if (sendFullVersion || !previousState.nodes().nodeExists(destination)) {                 logger.trace("sending full cluster state version {} to {}", newState.version(), destination).                 PublicationTransportHandler.this.sendFullClusterState(newState, serializedStates, destination, responseActionListener).             } else {                 logger.trace("sending cluster state diff for version {} to {}", newState.version(), destination).                 PublicationTransportHandler.this.sendClusterStateDiff(newState, serializedDiffs, serializedStates, destination, responseActionListener).             }         }          @Override         public void sendApplyCommit(DiscoveryNode destination, ApplyCommitRequest applyCommitRequest, ActionListener<TransportResponse.Empty> responseActionListener) {             final String actionName.             final TransportRequest transportRequest.             if (Coordinator.isZen1Node(destination)) {                 actionName = PublishClusterStateAction.COMMIT_ACTION_NAME.                 transportRequest = new PublishClusterStateAction.CommitClusterStateRequest(newState.stateUUID()).             } else {                 actionName = COMMIT_STATE_ACTION_NAME.                 transportRequest = applyCommitRequest.             }             transportService.sendRequest(destination, actionName, transportRequest, stateRequestOptions, new TransportResponseHandler<TransportResponse.Empty>() {                  @Override                 public TransportResponse.Empty read(StreamInput in) {                     return TransportResponse.Empty.INSTANCE.                 }                  @Override                 public void handleResponse(TransportResponse.Empty response) {                     responseActionListener.onResponse(response).                 }                  @Override                 public void handleException(TransportException exp) {                     responseActionListener.onFailure(exp).                 }                  @Override                 public String executor() {                     return ThreadPool.Names.GENERIC.                 }             }).         }     }. }
false;public;1;4;;@Override public PublishWithJoinResponse read(StreamInput in) throws IOException {     return new PublishWithJoinResponse(in). }
false;public;1;4;;@Override public void handleResponse(PublishWithJoinResponse response) {     responseActionListener.onResponse(response). }
false;public;1;4;;@Override public void handleException(TransportException exp) {     transportExceptionHandler.accept(exp). }
false;public;0;4;;@Override public String executor() {     return ThreadPool.Names.GENERIC. }
false;private;6;55;;private void sendClusterStateToNode(ClusterState clusterState, BytesReference bytes, DiscoveryNode node, ActionListener<PublishWithJoinResponse> responseActionListener, boolean sendDiffs, Map<Version, BytesReference> serializedStates) {     try {         final BytesTransportRequest request = new BytesTransportRequest(bytes, node.getVersion()).         final Consumer<TransportException> transportExceptionHandler = exp -> {             if (sendDiffs && exp.unwrapCause() instanceof IncompatibleClusterStateVersionException) {                 logger.debug("resending full cluster state to node {} reason {}", node, exp.getDetailedMessage()).                 sendFullClusterState(clusterState, serializedStates, node, responseActionListener).             } else {                 logger.debug(() -> new ParameterizedMessage("failed to send cluster state to {}", node), exp).                 responseActionListener.onFailure(exp).             }         }.         final TransportResponseHandler<PublishWithJoinResponse> publishWithJoinResponseHandler = new TransportResponseHandler<PublishWithJoinResponse>() {              @Override             public PublishWithJoinResponse read(StreamInput in) throws IOException {                 return new PublishWithJoinResponse(in).             }              @Override             public void handleResponse(PublishWithJoinResponse response) {                 responseActionListener.onResponse(response).             }              @Override             public void handleException(TransportException exp) {                 transportExceptionHandler.accept(exp).             }              @Override             public String executor() {                 return ThreadPool.Names.GENERIC.             }         }.         final String actionName.         final TransportResponseHandler<?> transportResponseHandler.         if (Coordinator.isZen1Node(node)) {             actionName = PublishClusterStateAction.SEND_ACTION_NAME.             transportResponseHandler = publishWithJoinResponseHandler.wrap(empty -> new PublishWithJoinResponse(new PublishResponse(clusterState.term(), clusterState.version()), Optional.of(new Join(node, transportService.getLocalNode(), clusterState.term(), clusterState.term(), clusterState.version()))), in -> TransportResponse.Empty.INSTANCE).         } else {             actionName = PUBLISH_STATE_ACTION_NAME.             transportResponseHandler = publishWithJoinResponseHandler.         }         transportService.sendRequest(node, actionName, request, stateRequestOptions, transportResponseHandler).     } catch (Exception e) {         logger.warn(() -> new ParameterizedMessage("error sending cluster state to {}", node), e).         responseActionListener.onFailure(e).     } }
false;private,static;6;24;;private static void buildDiffAndSerializeStates(ClusterState clusterState, ClusterState previousState, DiscoveryNodes discoveryNodes, boolean sendFullVersion, Map<Version, BytesReference> serializedStates, Map<Version, BytesReference> serializedDiffs) {     Diff<ClusterState> diff = null.     for (DiscoveryNode node : discoveryNodes) {         if (node.equals(discoveryNodes.getLocalNode())) {             // ignore, see newPublicationContext             continue.         }         try {             if (sendFullVersion || !previousState.nodes().nodeExists(node)) {                 serializedStates.putIfAbsent(node.getVersion(), serializeFullClusterState(clusterState, node.getVersion())).             } else {                 // will send a diff                 if (diff == null) {                     diff = clusterState.diff(previousState).                 }                 serializedDiffs.putIfAbsent(node.getVersion(), serializeDiffClusterState(diff, node.getVersion())).             }         } catch (IOException e) {             throw new ElasticsearchException("failed to serialize cluster state for publishing to node {}", e, node).         }     } }
false;private;4;15;;private void sendFullClusterState(ClusterState clusterState, Map<Version, BytesReference> serializedStates, DiscoveryNode node, ActionListener<PublishWithJoinResponse> responseActionListener) {     BytesReference bytes = serializedStates.get(node.getVersion()).     if (bytes == null) {         try {             bytes = serializeFullClusterState(clusterState, node.getVersion()).             serializedStates.put(node.getVersion(), bytes).         } catch (Exception e) {             logger.warn(() -> new ParameterizedMessage("failed to serialize cluster state before publishing it to node {}", node), e).             responseActionListener.onFailure(e).             return.         }     }     sendClusterStateToNode(clusterState, bytes, node, responseActionListener, false, serializedStates). }
false;private;5;7;;private void sendClusterStateDiff(ClusterState clusterState, Map<Version, BytesReference> serializedDiffs, Map<Version, BytesReference> serializedStates, DiscoveryNode node, ActionListener<PublishWithJoinResponse> responseActionListener) {     final BytesReference bytes = serializedDiffs.get(node.getVersion()).     assert bytes != null : "failed to find serialized diff for node " + node + " of version [" + node.getVersion() + "]".     sendClusterStateToNode(clusterState, bytes, node, responseActionListener, true, serializedStates). }
false;public,static;2;9;;public static BytesReference serializeFullClusterState(ClusterState clusterState, Version nodeVersion) throws IOException {     final BytesStreamOutput bStream = new BytesStreamOutput().     try (StreamOutput stream = CompressorFactory.COMPRESSOR.streamOutput(bStream)) {         stream.setVersion(nodeVersion).         stream.writeBoolean(true).         clusterState.writeTo(stream).     }     return bStream.bytes(). }
false;public,static;2;9;;public static BytesReference serializeDiffClusterState(Diff diff, Version nodeVersion) throws IOException {     final BytesStreamOutput bStream = new BytesStreamOutput().     try (StreamOutput stream = CompressorFactory.COMPRESSOR.streamOutput(bStream)) {         stream.setVersion(nodeVersion).         stream.writeBoolean(false).         diff.writeTo(stream).     }     return bStream.bytes(). }
false;private;1;54;;private PublishWithJoinResponse handleIncomingPublishRequest(BytesTransportRequest request) throws IOException {     final Compressor compressor = CompressorFactory.compressor(request.bytes()).     StreamInput in = request.bytes().streamInput().     try {         if (compressor != null) {             in = compressor.streamInput(in).         }         in = new NamedWriteableAwareStreamInput(in, namedWriteableRegistry).         in.setVersion(request.version()).         // If true we received full cluster state - otherwise diffs         if (in.readBoolean()) {             final ClusterState incomingState.             try {                 incomingState = ClusterState.readFrom(in, transportService.getLocalNode()).             } catch (Exception e) {                 logger.warn("unexpected error while deserializing an incoming cluster state", e).                 throw e.             }             fullClusterStateReceivedCount.incrementAndGet().             logger.debug("received full cluster state version [{}] with size [{}]", incomingState.version(), request.bytes().length()).             final PublishWithJoinResponse response = handlePublishRequest.apply(new PublishRequest(incomingState)).             lastSeenClusterState.set(incomingState).             return response.         } else {             final ClusterState lastSeen = lastSeenClusterState.get().             if (lastSeen == null) {                 logger.debug("received diff for but don't have any local cluster state - requesting full state").                 incompatibleClusterStateDiffReceivedCount.incrementAndGet().                 throw new IncompatibleClusterStateVersionException("have no local cluster state").             } else {                 final ClusterState incomingState.                 try {                     Diff<ClusterState> diff = ClusterState.readDiffFrom(in, lastSeen.nodes().getLocalNode()).                     // might throw IncompatibleClusterStateVersionException                     incomingState = diff.apply(lastSeen).                 } catch (IncompatibleClusterStateVersionException e) {                     incompatibleClusterStateDiffReceivedCount.incrementAndGet().                     throw e.                 } catch (Exception e) {                     logger.warn("unexpected error while deserializing an incoming cluster state", e).                     throw e.                 }                 compatibleClusterStateDiffReceivedCount.incrementAndGet().                 logger.debug("received diff cluster state version [{}] with uuid [{}], diff size [{}]", incomingState.version(), incomingState.stateUUID(), request.bytes().length()).                 final PublishWithJoinResponse response = handlePublishRequest.apply(new PublishRequest(incomingState)).                 lastSeenClusterState.compareAndSet(lastSeen, incomingState).                 return response.             }         }     } finally {         IOUtils.close(in).     } }
