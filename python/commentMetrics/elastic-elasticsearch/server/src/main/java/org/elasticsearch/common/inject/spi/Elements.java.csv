commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;3;/**  * Records the elements executed by {@code modules}.  */ ;/**  * Records the elements executed by {@code modules}.  */ public static List<Element> getElements(Module... modules) {     return getElements(Stage.DEVELOPMENT, Arrays.asList(modules)). }
true;public,static;1;3;/**  * Records the elements executed by {@code modules}.  */ ;/**  * Records the elements executed by {@code modules}.  */ public static List<Element> getElements(Iterable<? extends Module> modules) {     return getElements(Stage.DEVELOPMENT, modules). }
true;public,static;2;7;/**  * Records the elements executed by {@code modules}.  */ ;/**  * Records the elements executed by {@code modules}.  */ public static List<Element> getElements(Stage stage, Iterable<? extends Module> modules) {     RecordingBinder binder = new RecordingBinder(stage).     for (Module module : modules) {         binder.install(module).     }     return Collections.unmodifiableList(binder.elements). }
false;public;1;6;;@Override public void configure(Binder binder) {     for (Element element : elements) {         element.applyTo(binder).     } }
true;public,static;1;10;/**  * Returns the module composed of {@code elements}.  */ ;/**  * Returns the module composed of {@code elements}.  */ public static Module getModule(final Iterable<? extends Element> elements) {     return new Module() {          @Override         public void configure(Binder binder) {             for (Element element : elements) {                 element.applyTo(binder).             }         }     }. }
false;public;2;4;;@Override public void bindScope(Class<? extends Annotation> annotationType, Scope scope) {     elements.add(new ScopeBinding(getSource(), annotationType, scope)). }
false;public;1;5;;@Override // it is safe to use the type literal for the raw type @SuppressWarnings("unchecked") public void requestInjection(Object instance) {     requestInjection((TypeLiteral) TypeLiteral.get(instance.getClass()), instance). }
false;public;2;4;;@Override public <T> void requestInjection(TypeLiteral<T> type, T instance) {     elements.add(new InjectionRequest<>(getSource(), type, instance)). }
false;public;1;7;;@Override public <T> MembersInjector<T> getMembersInjector(final TypeLiteral<T> typeLiteral) {     final MembersInjectorLookup<T> element = new MembersInjectorLookup<>(getSource(), typeLiteral).     elements.add(element).     return element.getMembersInjector(). }
false;public;1;4;;@Override public <T> MembersInjector<T> getMembersInjector(Class<T> type) {     return getMembersInjector(TypeLiteral.get(type)). }
false;public;2;4;;@Override public void bindListener(Matcher<? super TypeLiteral<?>> typeMatcher, TypeListener listener) {     elements.add(new TypeListenerBinding(getSource(), listener, typeMatcher)). }
false;public;1;6;;@Override public void requestStaticInjection(Class<?>... types) {     for (Class<?> type : types) {         elements.add(new StaticInjectionRequest(getSource(), type)).     } }
false;public;1;24;;@Override public void install(Module module) {     if (modules.add(module)) {         Binder binder = this.         if (module instanceof PrivateModule) {             binder = binder.newPrivateBinder().         }         try {             module.configure(binder).         } catch (IllegalArgumentException e) {             // NOTE: This is not in the original guice. We rethrow here to expose any explicit errors in configure()             throw e.         } catch (RuntimeException e) {             Collection<Message> messages = Errors.getMessagesFromThrowable(e).             if (!messages.isEmpty()) {                 elements.addAll(messages).             } else {                 addError(e).             }         }         binder.install(ProviderMethodsModule.forModule(module)).     } }
false;public;0;4;;@Override public Stage currentStage() {     return stage. }
false;public;2;4;;@Override public void addError(String message, Object... arguments) {     elements.add(new Message(getSource(), Errors.format(message, arguments))). }
false;public;1;5;;@Override public void addError(Throwable t) {     String message = "An exception was caught and reported. Message: " + t.getMessage().     elements.add(new Message(Collections.singletonList(getSource()), message, t)). }
false;public;1;4;;@Override public void addError(Message message) {     elements.add(message). }
false;public;1;4;;@Override public <T> AnnotatedBindingBuilder<T> bind(Key<T> key) {     return new BindingBuilder<>(this, elements, getSource(), key). }
false;public;1;4;;@Override public <T> AnnotatedBindingBuilder<T> bind(TypeLiteral<T> typeLiteral) {     return bind(Key.get(typeLiteral)). }
false;public;1;4;;@Override public <T> AnnotatedBindingBuilder<T> bind(Class<T> type) {     return bind(Key.get(type)). }
false;public;0;4;;@Override public AnnotatedConstantBindingBuilder bindConstant() {     return new ConstantBindingBuilderImpl<Void>(this, elements, getSource()). }
false;public;1;6;;@Override public <T> Provider<T> getProvider(final Key<T> key) {     final ProviderLookup<T> element = new ProviderLookup<>(getSource(), key).     elements.add(element).     return element.getProvider(). }
false;public;1;4;;@Override public <T> Provider<T> getProvider(Class<T> type) {     return getProvider(Key.get(type)). }
false;public;2;5;;@Override public void convertToTypes(Matcher<? super TypeLiteral<?>> typeMatcher, TypeConverter converter) {     elements.add(new TypeConverterBinding(getSource(), typeMatcher, converter)). }
false;public;1;4;;@Override public RecordingBinder withSource(final Object source) {     return new RecordingBinder(this, source, null). }
false;public;1;10;;@Override public RecordingBinder skipSources(Class... classesToSkip) {     // if a source is specified explicitly, we don't need to skip sources     if (source != null) {         return this.     }     SourceProvider newSourceProvider = sourceProvider.plusSkippedClasses(classesToSkip).     return new RecordingBinder(this, null, newSourceProvider). }
false;public;0;6;;@Override public PrivateBinder newPrivateBinder() {     PrivateElementsImpl privateElements = new PrivateElementsImpl(getSource()).     elements.add(privateElements).     return new RecordingBinder(this, privateElements). }
false;public;1;4;;@Override public void expose(Key<?> key) {     exposeInternal(key). }
false;public;1;4;;@Override public AnnotatedElementBuilder expose(Class<?> type) {     return exposeInternal(Key.get(type)). }
false;public;1;4;;@Override public AnnotatedElementBuilder expose(TypeLiteral<?> type) {     return exposeInternal(Key.get(type)). }
false;public;1;3;;@Override public void annotatedWith(Class<? extends Annotation> annotationType) { }
false;public;1;3;;@Override public void annotatedWith(Annotation annotation) { }
false;private;1;19;;private <T> AnnotatedElementBuilder exposeInternal(Key<T> key) {     if (privateElements == null) {         addError("Cannot expose %s on a standard binder. " + "Exposed bindings are only applicable to private binders.", key).         return new AnnotatedElementBuilder() {              @Override             public void annotatedWith(Class<? extends Annotation> annotationType) {             }              @Override             public void annotatedWith(Annotation annotation) {             }         }.     }     ExposureBuilder<T> builder = new ExposureBuilder<>(this, getSource(), key).     privateElements.addExposureBuilder(builder).     return builder. }
false;protected;0;11;;protected Object getSource() {     Object ret.     if (logger.isDebugEnabled()) {         ret = sourceProvider != null ? sourceProvider.get() : source.     } else {         ret = source.     }     return ret == null ? "_unknown_" : ret. }
false;public;0;4;;@Override public String toString() {     return "Binder". }
