commented;modifiers;parameterAmount;loc;comment;code
false;public;3;5;;@Override public void list(ShardId shardId, DiscoveryNode[] nodes, ActionListener<NodesGatewayStartedShards> listener) {     execute(new Request(shardId, nodes), listener). }
false;protected;2;4;;@Override protected NodeRequest newNodeRequest(String nodeId, Request request) {     return new NodeRequest(nodeId, request). }
false;protected;0;4;;@Override protected NodeGatewayStartedShards newNodeResponse() {     return new NodeGatewayStartedShards(). }
false;protected;3;5;;@Override protected NodesGatewayStartedShards newResponse(Request request, List<NodeGatewayStartedShards> responses, List<FailedNodeException> failures) {     return new NodesGatewayStartedShards(clusterService.getClusterName(), responses, failures). }
false;protected;1;58;;@Override protected NodeGatewayStartedShards nodeOperation(NodeRequest request) {     try {         final ShardId shardId = request.getShardId().         logger.trace("{} loading local shard state info", shardId).         ShardStateMetaData shardStateMetaData = ShardStateMetaData.FORMAT.loadLatestState(logger, namedXContentRegistry, nodeEnv.availableShardPaths(request.shardId)).         if (shardStateMetaData != null) {             IndexMetaData metaData = clusterService.state().metaData().index(shardId.getIndex()).             if (metaData == null) {                 // we may send this requests while processing the cluster state that recovered the index                 // sometimes the request comes in before the local node processed that cluster state                 // in such cases we can load it from disk                 metaData = IndexMetaData.FORMAT.loadLatestState(logger, namedXContentRegistry, nodeEnv.indexPaths(shardId.getIndex())).             }             if (metaData == null) {                 ElasticsearchException e = new ElasticsearchException("failed to find local IndexMetaData").                 e.setShard(request.shardId).                 throw e.             }             if (indicesService.getShardOrNull(shardId) == null) {                 // we don't have an open shard on the store, validate the files on disk are openable                 ShardPath shardPath = null.                 try {                     IndexSettings indexSettings = new IndexSettings(metaData, settings).                     shardPath = ShardPath.loadShardPath(logger, nodeEnv, shardId, indexSettings).                     if (shardPath == null) {                         throw new IllegalStateException(shardId + " no shard path found").                     }                     Store.tryOpenIndex(shardPath.resolveIndex(), shardId, nodeEnv::shardLock, logger).                 } catch (Exception exception) {                     final ShardPath finalShardPath = shardPath.                     logger.trace(() -> new ParameterizedMessage("{} can't open index for shard [{}] in path [{}]", shardId, shardStateMetaData, (finalShardPath != null) ? finalShardPath.resolveIndex() : ""), exception).                     String allocationId = shardStateMetaData.allocationId != null ? shardStateMetaData.allocationId.getId() : null.                     return new NodeGatewayStartedShards(clusterService.localNode(), allocationId, shardStateMetaData.primary, exception).                 }             }             logger.debug("{} shard state info found: [{}]", shardId, shardStateMetaData).             String allocationId = shardStateMetaData.allocationId != null ? shardStateMetaData.allocationId.getId() : null.             return new NodeGatewayStartedShards(clusterService.localNode(), allocationId, shardStateMetaData.primary).         }         logger.trace("{} no local shard info found", shardId).         return new NodeGatewayStartedShards(clusterService.localNode(), null, false).     } catch (Exception e) {         throw new ElasticsearchException("failed to load started shards", e).     } }
false;public;0;3;;public ShardId shardId() {     return this.shardId. }
false;public;1;5;;@Override public void readFrom(StreamInput in) throws IOException {     super.readFrom(in).     shardId = ShardId.readShardId(in). }
false;public;1;5;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     shardId.writeTo(out). }
false;protected;1;4;;@Override protected List<NodeGatewayStartedShards> readNodesFrom(StreamInput in) throws IOException {     return in.readStreamableList(NodeGatewayStartedShards::new). }
false;protected;2;4;;@Override protected void writeNodesTo(StreamOutput out, List<NodeGatewayStartedShards> nodes) throws IOException {     out.writeStreamableList(nodes). }
false;public;1;5;;@Override public void readFrom(StreamInput in) throws IOException {     super.readFrom(in).     shardId = ShardId.readShardId(in). }
false;public;1;5;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     shardId.writeTo(out). }
false;public;0;3;;public ShardId getShardId() {     return shardId. }
false;public;0;3;;public String allocationId() {     return this.allocationId. }
false;public;0;3;;public boolean primary() {     return this.primary. }
false;public;0;3;;public Exception storeException() {     return this.storeException. }
false;public;1;13;;@Override public void readFrom(StreamInput in) throws IOException {     super.readFrom(in).     if (in.getVersion().before(Version.V_6_0_0_alpha1)) {         // legacy version         in.readLong().     }     allocationId = in.readOptionalString().     primary = in.readBoolean().     if (in.readBoolean()) {         storeException = in.readException().     } }
false;public;1;16;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     if (out.getVersion().before(Version.V_6_0_0_alpha1)) {         // legacy version         out.writeLong(-1L).     }     out.writeOptionalString(allocationId).     out.writeBoolean(primary).     if (storeException != null) {         out.writeBoolean(true).         out.writeException(storeException).     } else {         out.writeBoolean(false).     } }
false;public;1;20;;@Override public boolean equals(Object o) {     if (this == o) {         return true.     }     if (o == null || getClass() != o.getClass()) {         return false.     }     NodeGatewayStartedShards that = (NodeGatewayStartedShards) o.     if (primary != that.primary) {         return false.     }     if (allocationId != null ? !allocationId.equals(that.allocationId) : that.allocationId != null) {         return false.     }     return storeException != null ? storeException.equals(that.storeException) : that.storeException == null. }
false;public;0;7;;@Override public int hashCode() {     int result = (allocationId != null ? allocationId.hashCode() : 0).     result = 31 * result + (primary ? 1 : 0).     result = 31 * result + (storeException != null ? storeException.hashCode() : 0).     return result. }
false;public;0;12;;@Override public String toString() {     StringBuilder buf = new StringBuilder().     buf.append("NodeGatewayStartedShards[").append("allocationId=").append(allocationId).append(",primary=").append(primary).     if (storeException != null) {         buf.append(",storeException=").append(storeException).     }     buf.append("]").     return buf.toString(). }
