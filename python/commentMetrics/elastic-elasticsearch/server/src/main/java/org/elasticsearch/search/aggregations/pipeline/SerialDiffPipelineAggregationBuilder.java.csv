commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;6;;@Override protected void doWriteTo(StreamOutput out) throws IOException {     out.writeOptionalString(format).     gapPolicy.writeTo(out).     out.writeVInt(lag). }
true;public;1;7;/**  * Sets the lag to use when calculating the serial difference.  */ ;/**  * Sets the lag to use when calculating the serial difference.  */ public SerialDiffPipelineAggregationBuilder lag(int lag) {     if (lag <= 0) {         throw new IllegalArgumentException("[lag] must be a positive integer: [" + name + "]").     }     this.lag = lag.     return this. }
true;public;0;3;/**  * Gets the lag to use when calculating the serial difference.  */ ;/**  * Gets the lag to use when calculating the serial difference.  */ public int lag() {     return lag. }
true;public;1;7;/**  * Sets the format to use on the output of this aggregation.  */ ;/**  * Sets the format to use on the output of this aggregation.  */ public SerialDiffPipelineAggregationBuilder format(String format) {     if (format == null) {         throw new IllegalArgumentException("[format] must not be null: [" + name + "]").     }     this.format = format.     return this. }
true;public;0;3;/**  * Gets the format to use on the output of this aggregation.  */ ;/**  * Gets the format to use on the output of this aggregation.  */ public String format() {     return format. }
true;public;1;7;/**  * Sets the GapPolicy to use on the output of this aggregation.  */ ;/**  * Sets the GapPolicy to use on the output of this aggregation.  */ public SerialDiffPipelineAggregationBuilder gapPolicy(GapPolicy gapPolicy) {     if (gapPolicy == null) {         throw new IllegalArgumentException("[gapPolicy] must not be null: [" + name + "]").     }     this.gapPolicy = gapPolicy.     return this. }
true;public;0;3;/**  * Gets the GapPolicy to use on the output of this aggregation.  */ ;/**  * Gets the GapPolicy to use on the output of this aggregation.  */ public GapPolicy gapPolicy() {     return gapPolicy. }
false;protected;0;7;;protected DocValueFormat formatter() {     if (format != null) {         return new DocValueFormat.Decimal(format).     } else {         return DocValueFormat.RAW.     } }
false;protected;1;4;;@Override protected PipelineAggregator createInternal(Map<String, Object> metaData) throws IOException {     return new SerialDiffPipelineAggregator(name, bucketsPaths, formatter(), gapPolicy, lag, metaData). }
false;public;3;5;;@Override public void doValidate(AggregatorFactory<?> parent, Collection<AggregationBuilder> aggFactories, Collection<PipelineAggregationBuilder> pipelineAggregatoractories) {     validateSequentiallyOrderedParentAggs(parent, NAME, name). }
false;protected;2;9;;@Override protected XContentBuilder internalXContent(XContentBuilder builder, Params params) throws IOException {     if (format != null) {         builder.field(FORMAT.getPreferredName(), format).     }     builder.field(GAP_POLICY.getPreferredName(), gapPolicy.getName()).     builder.field(LAG.getPreferredName(), lag).     return builder. }
false;public,static;2;71;;public static SerialDiffPipelineAggregationBuilder parse(String reducerName, XContentParser parser) throws IOException {     XContentParser.Token token.     String currentFieldName = null.     String[] bucketsPaths = null.     String format = null.     GapPolicy gapPolicy = null.     Integer lag = null.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (token == XContentParser.Token.VALUE_STRING) {             if (FORMAT.match(currentFieldName, parser.getDeprecationHandler())) {                 format = parser.text().             } else if (BUCKETS_PATH.match(currentFieldName, parser.getDeprecationHandler())) {                 bucketsPaths = new String[] { parser.text() }.             } else if (GAP_POLICY.match(currentFieldName, parser.getDeprecationHandler())) {                 gapPolicy = GapPolicy.parse(parser.text(), parser.getTokenLocation()).             } else {                 throw new ParsingException(parser.getTokenLocation(), "Unknown key for a " + token + " in [" + reducerName + "]: [" + currentFieldName + "].").             }         } else if (token == XContentParser.Token.VALUE_NUMBER) {             if (LAG.match(currentFieldName, parser.getDeprecationHandler())) {                 lag = parser.intValue(true).                 if (lag <= 0) {                     throw new ParsingException(parser.getTokenLocation(), "Lag must be a positive, non-zero integer.  Value supplied was" + lag + " in [" + reducerName + "]: [" + currentFieldName + "].").                 }             } else {                 throw new ParsingException(parser.getTokenLocation(), "Unknown key for a " + token + " in [" + reducerName + "]: [" + currentFieldName + "].").             }         } else if (token == XContentParser.Token.START_ARRAY) {             if (BUCKETS_PATH.match(currentFieldName, parser.getDeprecationHandler())) {                 List<String> paths = new ArrayList<>().                 while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {                     String path = parser.text().                     paths.add(path).                 }                 bucketsPaths = paths.toArray(new String[paths.size()]).             } else {                 throw new ParsingException(parser.getTokenLocation(), "Unknown key for a " + token + " in [" + reducerName + "]: [" + currentFieldName + "].").             }         } else {             throw new ParsingException(parser.getTokenLocation(), "Unexpected token " + token + " in [" + reducerName + "].", parser.getTokenLocation()).         }     }     if (bucketsPaths == null) {         throw new ParsingException(parser.getTokenLocation(), "Missing required field [" + BUCKETS_PATH.getPreferredName() + "] for derivative aggregation [" + reducerName + "]").     }     SerialDiffPipelineAggregationBuilder factory = new SerialDiffPipelineAggregationBuilder(reducerName, bucketsPaths[0]).     if (lag != null) {         factory.lag(lag).     }     if (format != null) {         factory.format(format).     }     if (gapPolicy != null) {         factory.gapPolicy(gapPolicy).     }     return factory. }
false;protected;0;4;;@Override protected int doHashCode() {     return Objects.hash(format, gapPolicy, lag). }
false;protected;1;7;;@Override protected boolean doEquals(Object obj) {     SerialDiffPipelineAggregationBuilder other = (SerialDiffPipelineAggregationBuilder) obj.     return Objects.equals(format, other.format) && Objects.equals(gapPolicy, other.gapPolicy) && Objects.equals(lag, other.lag). }
false;public;0;4;;@Override public String getWriteableName() {     return NAME. }
