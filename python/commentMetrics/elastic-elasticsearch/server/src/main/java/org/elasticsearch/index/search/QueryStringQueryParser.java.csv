commented;modifiers;parameterAmount;loc;comment;code
false;public;1;5;;@Override public void setDefaultOperator(Operator op) {     super.setDefaultOperator(op).     queryBuilder.setOccur(op == Operator.AND ? BooleanClause.Occur.MUST : BooleanClause.Occur.SHOULD). }
false;public;1;5;;@Override public void setPhraseSlop(int phraseSlop) {     super.setPhraseSlop(phraseSlop).     queryBuilder.setPhraseSlop(phraseSlop). }
true;public;1;3;/**  * @param type Sets how multiple fields should be combined to build textual part queries.  */ ;/**  * @param type Sets how multiple fields should be combined to build textual part queries.  */ public void setType(MultiMatchQueryBuilder.Type type) {     this.type = type. }
true;public;1;3;/**  * @param fuzziness Sets the default {@link Fuzziness} for fuzzy query.  * Defaults to {@link Fuzziness#AUTO}.  */ ;/**  * @param fuzziness Sets the default {@link Fuzziness} for fuzzy query.  * Defaults to {@link Fuzziness#AUTO}.  */ public void setFuzziness(Fuzziness fuzziness) {     this.fuzziness = fuzziness. }
true;public;1;3;/**  * @param fuzzyRewriteMethod Sets the default rewrite method for fuzzy query.  */ ;/**  * @param fuzzyRewriteMethod Sets the default rewrite method for fuzzy query.  */ public void setFuzzyRewriteMethod(MultiTermQuery.RewriteMethod fuzzyRewriteMethod) {     this.fuzzyRewriteMethod = fuzzyRewriteMethod. }
true;public;1;3;/**  * @param fuzzyMaxExpansions Sets the maximum number of expansions allowed in a fuzzy query.  * Defaults to {@link FuzzyQuery#defaultMaxExpansions}.  */ ;/**  * @param fuzzyMaxExpansions Sets the maximum number of expansions allowed in a fuzzy query.  * Defaults to {@link FuzzyQuery#defaultMaxExpansions}.  */ public void setFuzzyMaxExpansions(int fuzzyMaxExpansions) {     this.fuzzyMaxExpansions = fuzzyMaxExpansions. }
true;public;1;3;/**  * @param analyzer Force the provided analyzer to be used for all query analysis regardless of the field.  */ ;/**  * @param analyzer Force the provided analyzer to be used for all query analysis regardless of the field.  */ public void setForceAnalyzer(Analyzer analyzer) {     this.forceAnalyzer = analyzer. }
true;public;1;3;/**  * @param analyzer Force the provided analyzer to be used for all phrase query analysis regardless of the field.  */ ;/**  * @param analyzer Force the provided analyzer to be used for all phrase query analysis regardless of the field.  */ public void setForceQuoteAnalyzer(Analyzer analyzer) {     this.forceQuoteAnalyzer = analyzer. }
true;public;1;3;/**  * @param quoteFieldSuffix The suffix to append to fields for quoted parts of the query string.  */ ;/**  * @param quoteFieldSuffix The suffix to append to fields for quoted parts of the query string.  */ public void setQuoteFieldSuffix(String quoteFieldSuffix) {     this.quoteFieldSuffix = quoteFieldSuffix. }
true;public;1;3;/**  * @param analyzeWildcard If true, the wildcard operator analyzes the term to build a wildcard query.  *                        Otherwise the query terms are only normalized.  */ ;/**  * @param analyzeWildcard If true, the wildcard operator analyzes the term to build a wildcard query.  *                        Otherwise the query terms are only normalized.  */ public void setAnalyzeWildcard(boolean analyzeWildcard) {     this.analyzeWildcard = analyzeWildcard. }
true;public;1;3;/**  * @param timeZone Time Zone to be applied to any range query related to dates.  */ ;/**  * @param timeZone Time Zone to be applied to any range query related to dates.  */ public void setTimeZone(ZoneId timeZone) {     this.timeZone = timeZone. }
true;public;1;5;/**  * @param groupTieBreaker The tie breaker to apply when multiple fields are used.  */ ;/**  * @param groupTieBreaker The tie breaker to apply when multiple fields are used.  */ public void setGroupTieBreaker(float groupTieBreaker) {     // Force the tie breaker in the query builder too     queryBuilder.setTieBreaker(groupTieBreaker).     this.groupTieBreaker = groupTieBreaker. }
false;public;1;4;;@Override public void setAutoGenerateMultiTermSynonymsPhraseQuery(boolean enable) {     queryBuilder.setAutoGenerateSynonymsPhraseQuery(enable). }
true;public;1;3;/**  * @param fuzzyTranspositions Sets whether transpositions are supported in fuzzy queries.  * Defaults to {@link FuzzyQuery#defaultTranspositions}.  */ ;/**  * @param fuzzyTranspositions Sets whether transpositions are supported in fuzzy queries.  * Defaults to {@link FuzzyQuery#defaultTranspositions}.  */ public void setFuzzyTranspositions(boolean fuzzyTranspositions) {     this.fuzzyTranspositions = fuzzyTranspositions. }
false;private;2;6;;private Query applyBoost(Query q, Float boost) {     if (boost != null && boost != 1f) {         return new BoostQuery(q, boost).     }     return q. }
false;private;2;17;;private Map<String, Float> extractMultiFields(String field, boolean quoted) {     if (field != null) {         boolean allFields = Regex.isMatchAllPattern(field).         if (allFields && this.field != null && this.field.equals(field)) {             // "*" is the default field             return fieldsAndWeights.         }         boolean multiFields = Regex.isSimpleMatchPattern(field).         // Filters metadata fields if all fields are requested         return resolveMappingField(context, field, 1.0f, !allFields, !multiFields, quoted ? quoteFieldSuffix : null).     } else if (quoted && quoteFieldSuffix != null) {         return resolveMappingFields(context, fieldsAndWeights, quoteFieldSuffix).     } else {         return fieldsAndWeights.     } }
false;protected;0;4;;@Override protected Query newMatchAllDocsQuery() {     return Queries.newMatchAllQuery(). }
false;public;3;52;;@Override public Query getFieldQuery(String field, String queryText, boolean quoted) throws ParseException {     if (field != null && EXISTS_FIELD.equals(field)) {         return existsQuery(queryText).     }     if (quoted) {         return getFieldQuery(field, queryText, getPhraseSlop()).     }     // as logical operator by the query parser (e.g. age:>=10).     if (field != null) {         if (queryText.length() > 1) {             if (queryText.charAt(0) == '>') {                 if (queryText.length() > 2) {                     if (queryText.charAt(1) == '=') {                         return getRangeQuery(field, queryText.substring(2), null, true, true).                     }                 }                 return getRangeQuery(field, queryText.substring(1), null, false, true).             } else if (queryText.charAt(0) == '<') {                 if (queryText.length() > 2) {                     if (queryText.charAt(1) == '=') {                         return getRangeQuery(field, null, queryText.substring(2), true, true).                     }                 }                 return getRangeQuery(field, null, queryText.substring(1), true, false).             }         }     }     Map<String, Float> fields = extractMultiFields(field, quoted).     if (fields.isEmpty()) {         // if there is no match in the mappings.         return newUnmappedFieldQuery(field).     }     Analyzer oldAnalyzer = queryBuilder.analyzer.     try {         if (forceAnalyzer != null) {             queryBuilder.setAnalyzer(forceAnalyzer).         }         return queryBuilder.parse(type, fields, queryText, null).     } catch (IOException e) {         throw new ParseException(e.getMessage()).     } finally {         queryBuilder.setAnalyzer(oldAnalyzer).     } }
false;protected;3;31;;@Override protected Query getFieldQuery(String field, String queryText, int slop) throws ParseException {     if (field != null && EXISTS_FIELD.equals(field)) {         return existsQuery(queryText).     }     Map<String, Float> fields = extractMultiFields(field, true).     if (fields.isEmpty()) {         return newUnmappedFieldQuery(field).     }     Analyzer oldAnalyzer = queryBuilder.analyzer.     int oldSlop = queryBuilder.phraseSlop.     try {         if (forceQuoteAnalyzer != null) {             queryBuilder.setAnalyzer(forceQuoteAnalyzer).         } else if (forceAnalyzer != null) {             queryBuilder.setAnalyzer(forceAnalyzer).         }         queryBuilder.setPhraseSlop(slop).         Query query = queryBuilder.parse(MultiMatchQueryBuilder.Type.PHRASE, fields, queryText, null).         if (query == null) {             return null.         }         return applySlop(query, slop).     } catch (IOException e) {         throw new ParseException(e.getMessage()).     } finally {         queryBuilder.setAnalyzer(oldAnalyzer).         queryBuilder.setPhraseSlop(oldSlop).     } }
false;protected;5;28;;@Override protected Query getRangeQuery(String field, String part1, String part2, boolean startInclusive, boolean endInclusive) throws ParseException {     if ("*".equals(part1)) {         part1 = null.     }     if ("*".equals(part2)) {         part2 = null.     }     Map<String, Float> fields = extractMultiFields(field, false).     if (fields.isEmpty()) {         return newUnmappedFieldQuery(field).     }     List<Query> queries = new ArrayList<>().     for (Map.Entry<String, Float> entry : fields.entrySet()) {         Query q = getRangeQuerySingle(entry.getKey(), part1, part2, startInclusive, endInclusive, context).         assert q != null.         queries.add(applyBoost(q, entry.getValue())).     }     if (queries.size() == 1) {         return queries.get(0).     }     float tiebreaker = groupTieBreaker == null ? type.tieBreaker() : groupTieBreaker.     return new DisjunctionMaxQuery(queries, tiebreaker). }
false;private;6;20;;private Query getRangeQuerySingle(String field, String part1, String part2, boolean startInclusive, boolean endInclusive, QueryShardContext context) {     currentFieldType = context.fieldMapper(field).     if (currentFieldType == null) {         return newUnmappedFieldQuery(field).     }     try {         Analyzer normalizer = forceAnalyzer == null ? queryBuilder.context.getSearchAnalyzer(currentFieldType) : forceAnalyzer.         BytesRef part1Binary = part1 == null ? null : normalizer.normalize(field, part1).         BytesRef part2Binary = part2 == null ? null : normalizer.normalize(field, part2).         Query rangeQuery = currentFieldType.rangeQuery(part1Binary, part2Binary, startInclusive, endInclusive, null, timeZone, null, context).         return rangeQuery.     } catch (RuntimeException e) {         if (lenient) {             return newLenientFieldQuery(field, e).         }         throw e.     } }
false;protected;3;7;;@Override protected Query handleBareFuzzy(String field, Token fuzzySlop, String termImage) throws ParseException {     if (fuzzySlop.image.length() == 1) {         return getFuzzyQuery(field, termImage, fuzziness.asDistance(termImage)).     }     return getFuzzyQuery(field, termImage, Fuzziness.build(fuzzySlop.image.substring(1)).asFloat()). }
false;protected;3;20;;@Override protected Query getFuzzyQuery(String field, String termStr, float minSimilarity) throws ParseException {     Map<String, Float> fields = extractMultiFields(field, false).     if (fields.isEmpty()) {         return newUnmappedFieldQuery(field).     }     List<Query> queries = new ArrayList<>().     for (Map.Entry<String, Float> entry : fields.entrySet()) {         Query q = getFuzzyQuerySingle(entry.getKey(), termStr, minSimilarity).         assert q != null.         queries.add(applyBoost(q, entry.getValue())).     }     if (queries.size() == 1) {         return queries.get(0).     } else {         float tiebreaker = groupTieBreaker == null ? type.tieBreaker() : groupTieBreaker.         return new DisjunctionMaxQuery(queries, tiebreaker).     } }
false;private;3;17;;private Query getFuzzyQuerySingle(String field, String termStr, float minSimilarity) throws ParseException {     currentFieldType = context.fieldMapper(field).     if (currentFieldType == null) {         return newUnmappedFieldQuery(field).     }     try {         Analyzer normalizer = forceAnalyzer == null ? queryBuilder.context.getSearchAnalyzer(currentFieldType) : forceAnalyzer.         BytesRef term = termStr == null ? null : normalizer.normalize(field, termStr).         return currentFieldType.fuzzyQuery(term, Fuzziness.fromEdits((int) minSimilarity), getFuzzyPrefixLength(), fuzzyMaxExpansions, fuzzyTranspositions).     } catch (RuntimeException e) {         if (lenient) {             return newLenientFieldQuery(field, e).         }         throw e.     } }
false;protected;3;8;;@Override protected Query newFuzzyQuery(Term term, float minimumSimilarity, int prefixLength) {     int numEdits = Fuzziness.build(minimumSimilarity).asDistance(term.text()).     FuzzyQuery query = new FuzzyQuery(term, numEdits, prefixLength, fuzzyMaxExpansions, fuzzyTranspositions).     QueryParsers.setRewriteMethod(query, fuzzyRewriteMethod).     return query. }
false;protected;2;22;;@Override protected Query getPrefixQuery(String field, String termStr) throws ParseException {     Map<String, Float> fields = extractMultiFields(field, false).     if (fields.isEmpty()) {         return newUnmappedFieldQuery(termStr).     }     List<Query> queries = new ArrayList<>().     for (Map.Entry<String, Float> entry : fields.entrySet()) {         Query q = getPrefixQuerySingle(entry.getKey(), termStr).         if (q != null) {             queries.add(applyBoost(q, entry.getValue())).         }     }     if (queries.isEmpty()) {         return null.     } else if (queries.size() == 1) {         return queries.get(0).     } else {         float tiebreaker = groupTieBreaker == null ? type.tieBreaker() : groupTieBreaker.         return new DisjunctionMaxQuery(queries, tiebreaker).     } }
false;private;2;24;;private Query getPrefixQuerySingle(String field, String termStr) throws ParseException {     Analyzer oldAnalyzer = getAnalyzer().     try {         currentFieldType = context.fieldMapper(field).         if (currentFieldType == null) {             return newUnmappedFieldQuery(field).         }         setAnalyzer(forceAnalyzer == null ? queryBuilder.context.getSearchAnalyzer(currentFieldType) : forceAnalyzer).         Query query = null.         if (currentFieldType.tokenized() == false) {             query = currentFieldType.prefixQuery(termStr, getMultiTermRewriteMethod(), context).         } else {             query = getPossiblyAnalyzedPrefixQuery(currentFieldType.name(), termStr).         }         return query.     } catch (RuntimeException e) {         if (lenient) {             return newLenientFieldQuery(field, e).         }         throw e.     } finally {         setAnalyzer(oldAnalyzer).     } }
false;private;2;81;;private Query getPossiblyAnalyzedPrefixQuery(String field, String termStr) throws ParseException {     if (analyzeWildcard == false) {         return currentFieldType.prefixQuery(getAnalyzer().normalize(field, termStr).utf8ToString(), getMultiTermRewriteMethod(), context).     }     List<List<String>> tlist.     // get Analyzer from superclass and tokenize the term     TokenStream source = null.     try {         try {             source = getAnalyzer().tokenStream(field, termStr).             source.reset().         } catch (IOException e) {             return super.getPrefixQuery(field, termStr).         }         tlist = new ArrayList<>().         List<String> currentPos = new ArrayList<>().         CharTermAttribute termAtt = source.addAttribute(CharTermAttribute.class).         PositionIncrementAttribute posAtt = source.addAttribute(PositionIncrementAttribute.class).         while (true) {             try {                 if (!source.incrementToken())                     break.             } catch (IOException e) {                 break.             }             if (currentPos.isEmpty() == false && posAtt.getPositionIncrement() > 0) {                 tlist.add(currentPos).                 currentPos = new ArrayList<>().             }             currentPos.add(termAtt.toString()).         }         if (currentPos.isEmpty() == false) {             tlist.add(currentPos).         }     } finally {         if (source != null) {             IOUtils.closeWhileHandlingException(source).         }     }     if (tlist.size() == 0) {         return null.     }     if (tlist.size() == 1 && tlist.get(0).size() == 1) {         return currentFieldType.prefixQuery(tlist.get(0).get(0), getMultiTermRewriteMethod(), context).     }     // build a boolean query with prefix on the last position only.     List<BooleanClause> clauses = new ArrayList<>().     for (int pos = 0. pos < tlist.size(). pos++) {         List<String> plist = tlist.get(pos).         boolean isLastPos = (pos == tlist.size() - 1).         Query posQuery.         if (plist.size() == 1) {             if (isLastPos) {                 posQuery = currentFieldType.prefixQuery(plist.get(0), getMultiTermRewriteMethod(), context).             } else {                 posQuery = newTermQuery(new Term(field, plist.get(0))).             }         } else if (isLastPos == false) {             // build a synonym query for terms in the same position.             Term[] terms = new Term[plist.size()].             for (int i = 0. i < plist.size(). i++) {                 terms[i] = new Term(field, plist.get(i)).             }             posQuery = new SynonymQuery(terms).         } else {             List<BooleanClause> innerClauses = new ArrayList<>().             for (String token : plist) {                 innerClauses.add(new BooleanClause(super.getPrefixQuery(field, token), BooleanClause.Occur.SHOULD)).             }             posQuery = getBooleanQuery(innerClauses).         }         clauses.add(new BooleanClause(posQuery, getDefaultOperator() == Operator.AND ? BooleanClause.Occur.MUST : BooleanClause.Occur.SHOULD)).     }     return getBooleanQuery(clauses). }
false;private;1;13;;private Query existsQuery(String fieldName) {     final FieldNamesFieldMapper.FieldNamesFieldType fieldNamesFieldType = (FieldNamesFieldMapper.FieldNamesFieldType) context.getMapperService().fullName(FieldNamesFieldMapper.NAME).     if (fieldNamesFieldType == null) {         return new MatchNoDocsQuery("No mappings yet").     }     if (fieldNamesFieldType.isEnabled() == false) {         // The field_names_field is disabled so we switch to a wildcard query that matches all terms         return new WildcardQuery(new Term(fieldName, "*")).     }     return ExistsQueryBuilder.newFilter(context, fieldName). }
false;protected;2;28;;@Override protected Query getWildcardQuery(String field, String termStr) throws ParseException {     String actualField = field != null ? field : this.field.     if (termStr.equals("*") && actualField != null) {         if (Regex.isMatchAllPattern(actualField)) {             return newMatchAllDocsQuery().         }         // effectively, we check if a field exists or not         return existsQuery(actualField).     }     Map<String, Float> fields = extractMultiFields(field, false).     if (fields.isEmpty()) {         return newUnmappedFieldQuery(termStr).     }     List<Query> queries = new ArrayList<>().     for (Map.Entry<String, Float> entry : fields.entrySet()) {         Query q = getWildcardQuerySingle(entry.getKey(), termStr).         assert q != null.         queries.add(applyBoost(q, entry.getValue())).     }     if (queries.size() == 1) {         return queries.get(0).     } else {         float tiebreaker = groupTieBreaker == null ? type.tieBreaker() : groupTieBreaker.         return new DisjunctionMaxQuery(queries, tiebreaker).     } }
false;private;2;24;;private Query getWildcardQuerySingle(String field, String termStr) throws ParseException {     if ("*".equals(termStr)) {         // effectively, we check if a field exists or not         return existsQuery(field).     }     String indexedNameField = field.     currentFieldType = null.     Analyzer oldAnalyzer = getAnalyzer().     try {         currentFieldType = queryBuilder.context.fieldMapper(field).         if (currentFieldType != null) {             setAnalyzer(forceAnalyzer == null ? queryBuilder.context.getSearchAnalyzer(currentFieldType) : forceAnalyzer).             indexedNameField = currentFieldType.name().         }         return super.getWildcardQuery(indexedNameField, termStr).     } catch (RuntimeException e) {         if (lenient) {             return newLenientFieldQuery(field, e).         }         throw e.     } finally {         setAnalyzer(oldAnalyzer).     } }
false;protected;2;26;;@Override protected Query getRegexpQuery(String field, String termStr) throws ParseException {     final int maxAllowedRegexLength = context.getIndexSettings().getMaxRegexLength().     if (termStr.length() > maxAllowedRegexLength) {         throw new IllegalArgumentException("The length of regex [" + termStr.length() + "] used in the [query_string] has exceeded " + "the allowed maximum of [" + maxAllowedRegexLength + "]. This maximum can be set by changing the [" + IndexSettings.MAX_REGEX_LENGTH_SETTING.getKey() + "] index level setting.").     }     Map<String, Float> fields = extractMultiFields(field, false).     if (fields.isEmpty()) {         return newUnmappedFieldQuery(termStr).     }     List<Query> queries = new ArrayList<>().     for (Map.Entry<String, Float> entry : fields.entrySet()) {         Query q = getRegexpQuerySingle(entry.getKey(), termStr).         assert q != null.         queries.add(applyBoost(q, entry.getValue())).     }     if (queries.size() == 1) {         return queries.get(0).     } else {         float tiebreaker = groupTieBreaker == null ? type.tieBreaker() : groupTieBreaker.         return new DisjunctionMaxQuery(queries, tiebreaker).     } }
false;private;2;20;;private Query getRegexpQuerySingle(String field, String termStr) throws ParseException {     currentFieldType = null.     Analyzer oldAnalyzer = getAnalyzer().     try {         currentFieldType = queryBuilder.context.fieldMapper(field).         if (currentFieldType == null) {             return newUnmappedFieldQuery(field).         }         setAnalyzer(forceAnalyzer == null ? queryBuilder.context.getSearchAnalyzer(currentFieldType) : forceAnalyzer).         Query query = super.getRegexpQuery(field, termStr).         return query.     } catch (RuntimeException e) {         if (lenient) {             return newLenientFieldQuery(field, e).         }         throw e.     } finally {         setAnalyzer(oldAnalyzer).     } }
false;protected;1;8;;@Override protected Query getBooleanQuery(List<BooleanClause> clauses) throws ParseException {     Query q = super.getBooleanQuery(clauses).     if (q == null) {         return null.     }     return fixNegativeQueryIfNeeded(q). }
false;private;2;15;;private Query applySlop(Query q, int slop) {     if (q instanceof PhraseQuery) {         // make sure that the boost hasn't been set beforehand, otherwise we'd lose it         assert q instanceof BoostQuery == false.         return addSlopToPhrase((PhraseQuery) q, slop).     } else if (q instanceof MultiPhraseQuery) {         MultiPhraseQuery.Builder builder = new MultiPhraseQuery.Builder((MultiPhraseQuery) q).         builder.setSlop(slop).         return builder.build().     } else if (q instanceof SpanQuery) {         return addSlopToSpan((SpanQuery) q, slop).     } else {         return q.     } }
false;private;2;15;;private Query addSlopToSpan(SpanQuery query, int slop) {     if (query instanceof SpanNearQuery) {         return new SpanNearQuery(((SpanNearQuery) query).getClauses(), slop, ((SpanNearQuery) query).isInOrder()).     } else if (query instanceof SpanOrQuery) {         SpanQuery[] clauses = new SpanQuery[((SpanOrQuery) query).getClauses().length].         int pos = 0.         for (SpanQuery clause : ((SpanOrQuery) query).getClauses()) {             clauses[pos++] = (SpanQuery) addSlopToSpan(clause, slop).         }         return new SpanOrQuery(clauses).     } else {         return query.     } }
true;private;2;11;/**  * Rebuild a phrase query with a slop value  */ ;/**  * Rebuild a phrase query with a slop value  */ private PhraseQuery addSlopToPhrase(PhraseQuery query, int slop) {     PhraseQuery.Builder builder = new PhraseQuery.Builder().     builder.setSlop(slop).     final Term[] terms = query.getTerms().     final int[] positions = query.getPositions().     for (int i = 0. i < terms.length. ++i) {         builder.add(terms[i], positions[i]).     }     return builder.build(). }
false;public;1;7;;@Override public Query parse(String query) throws ParseException {     if (query.trim().isEmpty()) {         return Queries.newMatchNoDocsQuery("Matching no documents because no terms present").     }     return super.parse(query). }
