commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public ScoreMode scoreMode() {     return valuesSource != null && valuesSource.needsScores() ? ScoreMode.COMPLETE : ScoreMode.COMPLETE_NO_SCORES. }
false;public;2;29;;@Override public void collect(int doc, long bucket) throws IOException {     counts = bigArrays.grow(counts, bucket + 1).     sums = bigArrays.grow(sums, bucket + 1).     compensations = bigArrays.grow(compensations, bucket + 1).     if (values.advanceExact(doc)) {         final int valueCount = values.docValueCount().         counts.increment(bucket, valueCount).         // Compute the sum of double values with Kahan summation algorithm which is more         // accurate than naive summation.         double sum = sums.get(bucket).         double compensation = compensations.get(bucket).         for (int i = 0. i < valueCount. i++) {             double value = values.nextValue().             if (Double.isFinite(value) == false) {                 sum += value.             } else if (Double.isFinite(sum)) {                 double corrected = value - compensation.                 double newSum = sum + corrected.                 compensation = (newSum - sum) - corrected.                 sum = newSum.             }         }         sums.set(bucket, sum).         compensations.set(bucket, compensation).     } }
false;public;2;40;;@Override public LeafBucketCollector getLeafCollector(LeafReaderContext ctx, final LeafBucketCollector sub) throws IOException {     if (valuesSource == null) {         return LeafBucketCollector.NO_OP_COLLECTOR.     }     final BigArrays bigArrays = context.bigArrays().     final SortedNumericDoubleValues values = valuesSource.doubleValues(ctx).     return new LeafBucketCollectorBase(sub, values) {          @Override         public void collect(int doc, long bucket) throws IOException {             counts = bigArrays.grow(counts, bucket + 1).             sums = bigArrays.grow(sums, bucket + 1).             compensations = bigArrays.grow(compensations, bucket + 1).             if (values.advanceExact(doc)) {                 final int valueCount = values.docValueCount().                 counts.increment(bucket, valueCount).                 // Compute the sum of double values with Kahan summation algorithm which is more                 // accurate than naive summation.                 double sum = sums.get(bucket).                 double compensation = compensations.get(bucket).                 for (int i = 0. i < valueCount. i++) {                     double value = values.nextValue().                     if (Double.isFinite(value) == false) {                         sum += value.                     } else if (Double.isFinite(sum)) {                         double corrected = value - compensation.                         double newSum = sum + corrected.                         compensation = (newSum - sum) - corrected.                         sum = newSum.                     }                 }                 sums.set(bucket, sum).                 compensations.set(bucket, compensation).             }         }     }. }
false;public;1;7;;@Override public double metric(long owningBucketOrd) {     if (valuesSource == null || owningBucketOrd >= sums.size()) {         return Double.NaN.     }     return sums.get(owningBucketOrd) / counts.get(owningBucketOrd). }
false;public;1;7;;@Override public InternalAggregation buildAggregation(long bucket) {     if (valuesSource == null || bucket >= sums.size()) {         return buildEmptyAggregation().     }     return new InternalAvg(name, sums.get(bucket), counts.get(bucket), format, pipelineAggregators(), metaData()). }
false;public;0;4;;@Override public InternalAggregation buildEmptyAggregation() {     return new InternalAvg(name, 0.0, 0L, format, pipelineAggregators(), metaData()). }
false;public;0;4;;@Override public void doClose() {     Releasables.close(counts, sums, compensations). }
