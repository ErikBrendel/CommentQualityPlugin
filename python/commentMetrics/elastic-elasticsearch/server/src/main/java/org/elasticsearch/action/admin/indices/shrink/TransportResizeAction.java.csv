commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;5;;@Override protected String executor() {     // we go async right away     return ThreadPool.Names.SAME. }
false;protected;0;4;;@Override protected ResizeResponse newResponse() {     return new ResizeResponse(). }
false;protected;2;4;;@Override protected ClusterBlockException checkBlock(ResizeRequest request, ClusterState state) {     return state.blocks().indexBlockedException(ClusterBlockLevel.METADATA_WRITE, request.getTargetIndexRequest().index()). }
false;public;1;15;;@Override public void onResponse(IndicesStatsResponse indicesStatsResponse) {     CreateIndexClusterStateUpdateRequest updateRequest = prepareCreateIndexRequest(resizeRequest, state, (i) -> {         IndexShardStats shard = indicesStatsResponse.getIndex(sourceIndex).getIndexShards().get(i).         return shard == null ? null : shard.getPrimary().getDocs().     }, sourceIndex, targetIndex).     createIndexService.createIndex(updateRequest, ActionListener.wrap(response -> listener.onResponse(new ResizeResponse(response.isAcknowledged(), response.isShardsAcknowledged(), updateRequest.index())), listener::onFailure)). }
false;public;1;4;;@Override public void onFailure(Exception e) {     listener.onFailure(e). }
false;protected;3;31;;@Override protected void masterOperation(final ResizeRequest resizeRequest, final ClusterState state, final ActionListener<ResizeResponse> listener) {     // there is no need to fetch docs stats for split but we keep it simple and do it anyway for simplicity of the code     final String sourceIndex = indexNameExpressionResolver.resolveDateMathExpression(resizeRequest.getSourceIndex()).     final String targetIndex = indexNameExpressionResolver.resolveDateMathExpression(resizeRequest.getTargetIndexRequest().index()).     client.admin().indices().prepareStats(sourceIndex).clear().setDocs(true).execute(new ActionListener<IndicesStatsResponse>() {          @Override         public void onResponse(IndicesStatsResponse indicesStatsResponse) {             CreateIndexClusterStateUpdateRequest updateRequest = prepareCreateIndexRequest(resizeRequest, state, (i) -> {                 IndexShardStats shard = indicesStatsResponse.getIndex(sourceIndex).getIndexShards().get(i).                 return shard == null ? null : shard.getPrimary().getDocs().             }, sourceIndex, targetIndex).             createIndexService.createIndex(updateRequest, ActionListener.wrap(response -> listener.onResponse(new ResizeResponse(response.isAcknowledged(), response.isShardsAcknowledged(), updateRequest.index())), listener::onFailure)).         }          @Override         public void onFailure(Exception e) {             listener.onFailure(e).         }     }). }
true;static;5;72;// static for unittesting this method ;// static for unittesting this method static CreateIndexClusterStateUpdateRequest prepareCreateIndexRequest(final ResizeRequest resizeRequest, final ClusterState state, final IntFunction<DocsStats> perShardDocStats, String sourceIndexName, String targetIndexName) {     final CreateIndexRequest targetIndex = resizeRequest.getTargetIndexRequest().     final IndexMetaData metaData = state.metaData().index(sourceIndexName).     if (metaData == null) {         throw new IndexNotFoundException(sourceIndexName).     }     final Settings targetIndexSettings = Settings.builder().put(targetIndex.settings()).normalizePrefix(IndexMetaData.INDEX_SETTING_PREFIX).build().     final int numShards.     if (IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.exists(targetIndexSettings)) {         numShards = IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.get(targetIndexSettings).     } else {         assert resizeRequest.getResizeType() == ResizeType.SHRINK : "split must specify the number of shards explicitly".         numShards = 1.     }     for (int i = 0. i < numShards. i++) {         if (resizeRequest.getResizeType() == ResizeType.SHRINK) {             Set<ShardId> shardIds = IndexMetaData.selectShrinkShards(i, metaData, numShards).             long count = 0.             for (ShardId id : shardIds) {                 DocsStats docsStats = perShardDocStats.apply(id.id()).                 if (docsStats != null) {                     count += docsStats.getCount().                 }                 if (count > IndexWriter.MAX_DOCS) {                     throw new IllegalStateException("Can't merge index with more than [" + IndexWriter.MAX_DOCS + "] docs - too many documents in shards " + shardIds).                 }             }         } else {             Objects.requireNonNull(IndexMetaData.selectSplitShard(i, metaData, numShards)).         // we just execute this to ensure we get the right exceptions if the number of shards is wrong or less then etc.         }     }     if (IndexMetaData.INDEX_ROUTING_PARTITION_SIZE_SETTING.exists(targetIndexSettings)) {         throw new IllegalArgumentException("cannot provide a routing partition size value when resizing an index").     }     if (IndexMetaData.INDEX_NUMBER_OF_ROUTING_SHARDS_SETTING.exists(targetIndexSettings)) {         // if we have a source index with 1 shards it's legal to set this         final boolean splitFromSingleShards = resizeRequest.getResizeType() == ResizeType.SPLIT && metaData.getNumberOfShards() == 1.         if (splitFromSingleShards == false) {             throw new IllegalArgumentException("cannot provide index.number_of_routing_shards on resize").         }     }     if (IndexSettings.INDEX_SOFT_DELETES_SETTING.get(metaData.getSettings()) && IndexSettings.INDEX_SOFT_DELETES_SETTING.exists(targetIndexSettings) && IndexSettings.INDEX_SOFT_DELETES_SETTING.get(targetIndexSettings) == false) {         throw new IllegalArgumentException("Can't disable [index.soft_deletes.enabled] setting on resize").     }     String cause = resizeRequest.getResizeType().name().toLowerCase(Locale.ROOT) + "_index".     targetIndex.cause(cause).     Settings.Builder settingsBuilder = Settings.builder().put(targetIndexSettings).     settingsBuilder.put("index.number_of_shards", numShards).     targetIndex.settings(settingsBuilder).     return new CreateIndexClusterStateUpdateRequest(targetIndex, cause, targetIndex.index(), targetIndexName).ackTimeout(targetIndex.timeout()).masterNodeTimeout(targetIndex.masterNodeTimeout()).settings(targetIndex.settings()).aliases(targetIndex.aliases()).waitForActiveShards(targetIndex.waitForActiveShards()).recoverFrom(metaData.getIndex()).resizeType(resizeRequest.getResizeType()).copySettings(resizeRequest.getCopySettings() == null ? false : resizeRequest.getCopySettings()). }
false;protected;1;10;;@Override protected String getMasterActionName(DiscoveryNode node) {     if (node.getVersion().onOrAfter(ResizeAction.COMPATIBILITY_VERSION)) {         return super.getMasterActionName(node).     } else {         // we have to send to shrink instead.         return ShrinkAction.NAME.     } }
