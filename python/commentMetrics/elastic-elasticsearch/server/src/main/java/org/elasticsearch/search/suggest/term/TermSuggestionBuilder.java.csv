commented;modifiers;parameterAmount;loc;comment;code
false;public;1;13;;@Override public void doWriteTo(StreamOutput out) throws IOException {     suggestMode.writeTo(out).     out.writeFloat(accuracy).     sort.writeTo(out).     stringDistance.writeTo(out).     out.writeVInt(maxEdits).     out.writeVInt(maxInspections).     out.writeFloat(maxTermFreq).     out.writeVInt(prefixLength).     out.writeVInt(minWordLength).     out.writeFloat(minDocFreq). }
true;public;1;5;/**  * The global suggest mode controls what suggested terms are included or  * controls for what suggest text tokens, terms should be suggested for.  * Three possible values can be specified:  * <ol>  * <li><code>missing</code> - Only suggest terms in the suggest text that  * aren't in the index. This is the default.  * <li><code>popular</code> - Only suggest terms that occur in more docs  * then the original suggest text term.  * <li><code>always</code> - Suggest any matching suggest terms based on  * tokens in the suggest text.  * </ol>  */ ;/**  * The global suggest mode controls what suggested terms are included or  * controls for what suggest text tokens, terms should be suggested for.  * Three possible values can be specified:  * <ol>  * <li><code>missing</code> - Only suggest terms in the suggest text that  * aren't in the index. This is the default.  * <li><code>popular</code> - Only suggest terms that occur in more docs  * then the original suggest text term.  * <li><code>always</code> - Suggest any matching suggest terms based on  * tokens in the suggest text.  * </ol>  */ public TermSuggestionBuilder suggestMode(SuggestMode suggestMode) {     Objects.requireNonNull(suggestMode, "suggestMode must not be null").     this.suggestMode = suggestMode.     return this. }
true;public;0;3;/**  * Get the suggest mode setting.  */ ;/**  * Get the suggest mode setting.  */ public SuggestMode suggestMode() {     return suggestMode. }
true;public;1;7;/**  * s how similar the suggested terms at least need to be compared to the  * original suggest text tokens. A value between 0 and 1 can be specified.  * This value will be compared to the string distance result of each  * candidate spelling correction.  * <p>  * Default is {@code 0.5}  */ ;/**  * s how similar the suggested terms at least need to be compared to the  * original suggest text tokens. A value between 0 and 1 can be specified.  * This value will be compared to the string distance result of each  * candidate spelling correction.  * <p>  * Default is {@code 0.5}  */ public TermSuggestionBuilder accuracy(float accuracy) {     if (accuracy < 0.0f || accuracy > 1.0f) {         throw new IllegalArgumentException("accuracy must be between 0 and 1").     }     this.accuracy = accuracy.     return this. }
true;public;0;3;/**  * Get the accuracy setting.  */ ;/**  * Get the accuracy setting.  */ public float accuracy() {     return accuracy. }
true;public;1;5;/**  * Sets how to sort the suggest terms per suggest text token. Two possible  * values:  * <ol>  * <li><code>score</code> - Sort should first be based on score, then  * document frequency and then the term itself.  * <li><code>frequency</code> - Sort should first be based on document  * frequency, then score and then the term itself.  * </ol>  * <p>  * What the score is depends on the suggester being used.  */ ;/**  * Sets how to sort the suggest terms per suggest text token. Two possible  * values:  * <ol>  * <li><code>score</code> - Sort should first be based on score, then  * document frequency and then the term itself.  * <li><code>frequency</code> - Sort should first be based on document  * frequency, then score and then the term itself.  * </ol>  * <p>  * What the score is depends on the suggester being used.  */ public TermSuggestionBuilder sort(SortBy sort) {     Objects.requireNonNull(sort, "sort must not be null").     this.sort = sort.     return this. }
true;public;0;3;/**  * Get the sort setting.  */ ;/**  * Get the sort setting.  */ public SortBy sort() {     return sort. }
true;public;1;5;/**  * Sets what string distance implementation to use for comparing how similar  * suggested terms are. Five possible values can be specified:  * <ol>  * <li><code>internal</code> - This is the default and is based on  * <code>damerau_levenshtein</code>, but highly optimized for comparing  * string distance for terms inside the index.  * <li><code>damerau_levenshtein</code> - String distance algorithm based on  * Damerau-Levenshtein algorithm.  * <li><code>levenshtein</code> - String distance algorithm based on  * Levenshtein edit distance algorithm.  * <li><code>jaro_winkler</code> - String distance algorithm based on  * Jaro-Winkler algorithm.  * <li><code>ngram</code> - String distance algorithm based on character  * n-grams.  * </ol>  */ ;/**  * Sets what string distance implementation to use for comparing how similar  * suggested terms are. Five possible values can be specified:  * <ol>  * <li><code>internal</code> - This is the default and is based on  * <code>damerau_levenshtein</code>, but highly optimized for comparing  * string distance for terms inside the index.  * <li><code>damerau_levenshtein</code> - String distance algorithm based on  * Damerau-Levenshtein algorithm.  * <li><code>levenshtein</code> - String distance algorithm based on  * Levenshtein edit distance algorithm.  * <li><code>jaro_winkler</code> - String distance algorithm based on  * Jaro-Winkler algorithm.  * <li><code>ngram</code> - String distance algorithm based on character  * n-grams.  * </ol>  */ public TermSuggestionBuilder stringDistance(StringDistanceImpl stringDistance) {     Objects.requireNonNull(stringDistance, "stringDistance must not be null").     this.stringDistance = stringDistance.     return this. }
true;public;0;3;/**  * Get the string distance implementation setting.  */ ;/**  * Get the string distance implementation setting.  */ public StringDistanceImpl stringDistance() {     return stringDistance. }
true;public;1;7;/**  * Sets the maximum edit distance candidate suggestions can have in order to  * be considered as a suggestion. Can only be a value between 1 and 2. Any  * other value result in an bad request error being thrown. Defaults to  * {@code 2}.  */ ;/**  * Sets the maximum edit distance candidate suggestions can have in order to  * be considered as a suggestion. Can only be a value between 1 and 2. Any  * other value result in an bad request error being thrown. Defaults to  * {@code 2}.  */ public TermSuggestionBuilder maxEdits(int maxEdits) {     if (maxEdits < 1 || maxEdits > 2) {         throw new IllegalArgumentException("maxEdits must be between 1 and 2").     }     this.maxEdits = maxEdits.     return this. }
true;public;0;3;/**  * Get the maximum edit distance setting.  */ ;/**  * Get the maximum edit distance setting.  */ public int maxEdits() {     return maxEdits. }
true;public;1;7;/**  * A factor that is used to multiply with the size in order to inspect more  * candidate suggestions. Can improve accuracy at the cost of performance.  * Defaults to {@code 5}.  */ ;/**  * A factor that is used to multiply with the size in order to inspect more  * candidate suggestions. Can improve accuracy at the cost of performance.  * Defaults to {@code 5}.  */ public TermSuggestionBuilder maxInspections(int maxInspections) {     if (maxInspections < 0) {         throw new IllegalArgumentException("maxInspections must be positive").     }     this.maxInspections = maxInspections.     return this. }
true;public;0;3;/**  * Get the factor for inspecting more candidate suggestions setting.  */ ;/**  * Get the factor for inspecting more candidate suggestions setting.  */ public int maxInspections() {     return maxInspections. }
true;public;1;10;/**  * Sets a maximum threshold in number of documents a suggest text token can  * exist in order to be corrected. Can be a relative percentage number (e.g  * 0.4) or an absolute number to represent document frequencies. If an value  * higher than 1 is specified then fractional can not be specified. Defaults  * to {@code 0.01}.  * <p>  * This can be used to exclude high frequency terms from being suggested.  * High frequency terms are usually spelled correctly on top of this this  * also improves the suggest performance.  */ ;/**  * Sets a maximum threshold in number of documents a suggest text token can  * exist in order to be corrected. Can be a relative percentage number (e.g  * 0.4) or an absolute number to represent document frequencies. If an value  * higher than 1 is specified then fractional can not be specified. Defaults  * to {@code 0.01}.  * <p>  * This can be used to exclude high frequency terms from being suggested.  * High frequency terms are usually spelled correctly on top of this this  * also improves the suggest performance.  */ public TermSuggestionBuilder maxTermFreq(float maxTermFreq) {     if (maxTermFreq < 0.0f) {         throw new IllegalArgumentException("maxTermFreq must be positive").     }     if (maxTermFreq > 1.0f && maxTermFreq != Math.floor(maxTermFreq)) {         throw new IllegalArgumentException("if maxTermFreq is greater than 1, it must not be a fraction").     }     this.maxTermFreq = maxTermFreq.     return this. }
true;public;0;3;/**  * Get the maximum term frequency threshold setting.  */ ;/**  * Get the maximum term frequency threshold setting.  */ public float maxTermFreq() {     return maxTermFreq. }
true;public;1;7;/**  * Sets the number of minimal prefix characters that must match in order be  * a candidate suggestion. Defaults to 1. Increasing this number improves  * suggest performance. Usually misspellings don't occur in the beginning of  * terms.  */ ;/**  * Sets the number of minimal prefix characters that must match in order be  * a candidate suggestion. Defaults to 1. Increasing this number improves  * suggest performance. Usually misspellings don't occur in the beginning of  * terms.  */ public TermSuggestionBuilder prefixLength(int prefixLength) {     if (prefixLength < 0) {         throw new IllegalArgumentException("prefixLength must be positive").     }     this.prefixLength = prefixLength.     return this. }
true;public;0;3;/**  * Get the minimum prefix length that must match setting.  */ ;/**  * Get the minimum prefix length that must match setting.  */ public int prefixLength() {     return prefixLength. }
true;public;1;7;/**  * The minimum length a suggest text term must have in order to be  * corrected. Defaults to {@code 4}.  */ ;/**  * The minimum length a suggest text term must have in order to be  * corrected. Defaults to {@code 4}.  */ public TermSuggestionBuilder minWordLength(int minWordLength) {     if (minWordLength < 1) {         throw new IllegalArgumentException("minWordLength must be greater or equal to 1").     }     this.minWordLength = minWordLength.     return this. }
true;public;0;3;/**  * Get the minimum length of a text term to be corrected setting.  */ ;/**  * Get the minimum length of a text term to be corrected setting.  */ public int minWordLength() {     return minWordLength. }
true;public;1;10;/**  * Sets a minimal threshold in number of documents a suggested term should  * appear in. This can be specified as an absolute number or as a relative  * percentage of number of documents. This can improve quality by only  * suggesting high frequency terms. Defaults to 0f and is not enabled. If a  * value higher than 1 is specified then the number cannot be fractional.  */ ;/**  * Sets a minimal threshold in number of documents a suggested term should  * appear in. This can be specified as an absolute number or as a relative  * percentage of number of documents. This can improve quality by only  * suggesting high frequency terms. Defaults to 0f and is not enabled. If a  * value higher than 1 is specified then the number cannot be fractional.  */ public TermSuggestionBuilder minDocFreq(float minDocFreq) {     if (minDocFreq < 0.0f) {         throw new IllegalArgumentException("minDocFreq must be positive").     }     if (minDocFreq > 1.0f && minDocFreq != Math.floor(minDocFreq)) {         throw new IllegalArgumentException("if minDocFreq is greater than 1, it must not be a fraction").     }     this.minDocFreq = minDocFreq.     return this. }
true;public;0;3;/**  * Get the minimal threshold for the frequency of a term appearing in the  * document set setting.  */ ;/**  * Get the minimal threshold for the frequency of a term appearing in the  * document set setting.  */ public float minDocFreq() {     return minDocFreq. }
false;public;2;14;;@Override public XContentBuilder innerToXContent(XContentBuilder builder, Params params) throws IOException {     builder.field(SUGGESTMODE_FIELD.getPreferredName(), suggestMode).     builder.field(ACCURACY_FIELD.getPreferredName(), accuracy).     builder.field(SORT_FIELD.getPreferredName(), sort).     builder.field(STRING_DISTANCE_FIELD.getPreferredName(), stringDistance).     builder.field(MAX_EDITS_FIELD.getPreferredName(), maxEdits).     builder.field(MAX_INSPECTIONS_FIELD.getPreferredName(), maxInspections).     builder.field(MAX_TERM_FREQ_FIELD.getPreferredName(), maxTermFreq).     builder.field(PREFIX_LENGTH_FIELD.getPreferredName(), prefixLength).     builder.field(MIN_WORD_LENGTH_FIELD.getPreferredName(), minWordLength).     builder.field(MIN_DOC_FREQ_FIELD.getPreferredName(), minDocFreq).     return builder. }
false;public,static;1;53;;public static TermSuggestionBuilder fromXContent(XContentParser parser) throws IOException {     TermSuggestionBuilder tmpSuggestion = new TermSuggestionBuilder("_na_").     XContentParser.Token token.     String currentFieldName = null.     String fieldname = null.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (token.isValue()) {             if (SuggestionBuilder.ANALYZER_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 tmpSuggestion.analyzer(parser.text()).             } else if (SuggestionBuilder.FIELDNAME_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 fieldname = parser.text().             } else if (SuggestionBuilder.SIZE_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 tmpSuggestion.size(parser.intValue()).             } else if (SuggestionBuilder.SHARDSIZE_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 tmpSuggestion.shardSize(parser.intValue()).             } else if (SUGGESTMODE_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 tmpSuggestion.suggestMode(SuggestMode.resolve(parser.text())).             } else if (ACCURACY_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 tmpSuggestion.accuracy(parser.floatValue()).             } else if (SORT_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 tmpSuggestion.sort(SortBy.resolve(parser.text())).             } else if (STRING_DISTANCE_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 tmpSuggestion.stringDistance(StringDistanceImpl.resolve(parser.text())).             } else if (MAX_EDITS_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 tmpSuggestion.maxEdits(parser.intValue()).             } else if (MAX_INSPECTIONS_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 tmpSuggestion.maxInspections(parser.intValue()).             } else if (MAX_TERM_FREQ_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 tmpSuggestion.maxTermFreq(parser.floatValue()).             } else if (PREFIX_LENGTH_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 tmpSuggestion.prefixLength(parser.intValue()).             } else if (MIN_WORD_LENGTH_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 tmpSuggestion.minWordLength(parser.intValue()).             } else if (MIN_DOC_FREQ_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 tmpSuggestion.minDocFreq(parser.floatValue()).             } else {                 throw new ParsingException(parser.getTokenLocation(), "suggester[term] doesn't support field [" + currentFieldName + "]").             }         } else {             throw new ParsingException(parser.getTokenLocation(), "suggester[term] parsing failed on [" + currentFieldName + "]").         }     }     // now we should have field name, check and copy fields over to the suggestion builder we return     if (fieldname == null) {         throw new ElasticsearchParseException("the required field option [" + FIELDNAME_FIELD.getPreferredName() + "] is missing").     }     return new TermSuggestionBuilder(fieldname, tmpSuggestion). }
false;public;1;19;;@Override public SuggestionContext build(QueryShardContext context) throws IOException {     TermSuggestionContext suggestionContext = new TermSuggestionContext(context).     // copy over common settings to each suggestion builder     populateCommonFields(context.getMapperService(), suggestionContext).     // Transfers the builder settings to the target TermSuggestionContext     DirectSpellcheckerSettings settings = suggestionContext.getDirectSpellCheckerSettings().     settings.accuracy(accuracy).     settings.maxEdits(maxEdits).     settings.maxInspections(maxInspections).     settings.maxTermFreq(maxTermFreq).     settings.minDocFreq(minDocFreq).     settings.minWordLength(minWordLength).     settings.prefixLength(prefixLength).     settings.sort(sort).     settings.stringDistance(stringDistance.toLucene()).     settings.suggestMode(suggestMode.toLucene()).     return suggestionContext. }
false;public;0;4;;@Override public String getWriteableName() {     return SUGGESTION_NAME. }
false;protected;1;13;;@Override protected boolean doEquals(TermSuggestionBuilder other) {     return Objects.equals(suggestMode, other.suggestMode) && Objects.equals(accuracy, other.accuracy) && Objects.equals(sort, other.sort) && Objects.equals(stringDistance, other.stringDistance) && Objects.equals(maxEdits, other.maxEdits) && Objects.equals(maxInspections, other.maxInspections) && Objects.equals(maxTermFreq, other.maxTermFreq) && Objects.equals(prefixLength, other.prefixLength) && Objects.equals(minWordLength, other.minWordLength) && Objects.equals(minDocFreq, other.minDocFreq). }
false;protected;0;5;;@Override protected int doHashCode() {     return Objects.hash(suggestMode, accuracy, sort, stringDistance, maxEdits, maxInspections, maxTermFreq, prefixLength, minWordLength, minDocFreq). }
false;public;0;4;;@Override public org.apache.lucene.search.spell.SuggestMode toLucene() {     return org.apache.lucene.search.spell.SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX. }
false;public;0;4;;@Override public org.apache.lucene.search.spell.SuggestMode toLucene() {     return org.apache.lucene.search.spell.SuggestMode.SUGGEST_MORE_POPULAR. }
false;public;0;4;;@Override public org.apache.lucene.search.spell.SuggestMode toLucene() {     return org.apache.lucene.search.spell.SuggestMode.SUGGEST_ALWAYS. }
false;public;1;4;;@Override public void writeTo(final StreamOutput out) throws IOException {     out.writeEnum(this). }
false;public,static;1;3;;public static SuggestMode readFromStream(final StreamInput in) throws IOException {     return in.readEnum(SuggestMode.class). }
false;public,static;1;4;;public static SuggestMode resolve(final String str) {     Objects.requireNonNull(str, "Input string is null").     return valueOf(str.toUpperCase(Locale.ROOT)). }
false;public,abstract;0;1;;public abstract org.apache.lucene.search.spell.SuggestMode toLucene().
false;public;0;4;;@Override public StringDistance toLucene() {     return DirectSpellChecker.INTERNAL_LEVENSHTEIN. }
false;public;0;4;;@Override public StringDistance toLucene() {     return new LuceneLevenshteinDistance(). }
false;public;0;4;;@Override public StringDistance toLucene() {     return new LevenshteinDistance(). }
false;public;0;4;;@Override public StringDistance toLucene() {     return new JaroWinklerDistance(). }
false;public;0;4;;@Override public StringDistance toLucene() {     return new NGramDistance(). }
false;public;1;4;;@Override public void writeTo(final StreamOutput out) throws IOException {     out.writeEnum(this). }
false;public,static;1;3;;public static StringDistanceImpl readFromStream(final StreamInput in) throws IOException {     return in.readEnum(StringDistanceImpl.class). }
false;public,static;1;17;;public static StringDistanceImpl resolve(final String str) {     Objects.requireNonNull(str, "Input string is null").     final String distanceVal = str.toLowerCase(Locale.ROOT).     switch(distanceVal) {         case "internal":             return INTERNAL.         case "damerau_levenshtein":             return DAMERAU_LEVENSHTEIN.         case "levenshtein":             return LEVENSHTEIN.         case "ngram":             return NGRAM.         case "jaro_winkler":             return JARO_WINKLER.         default:             throw new IllegalArgumentException("Illegal distance option " + str).     } }
false;public,abstract;0;1;;public abstract StringDistance toLucene().
