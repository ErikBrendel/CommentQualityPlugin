commented;modifiers;parameterAmount;loc;comment;code
false;public,static;1;7;;public static long bytesToLong(BytesRef bytes) {     int high = (bytes.bytes[bytes.offset + 0] << 24) | ((bytes.bytes[bytes.offset + 1] & 0xff) << 16) | ((bytes.bytes[bytes.offset + 2] & 0xff) << 8) | (bytes.bytes[bytes.offset + 3] & 0xff).     int low = (bytes.bytes[bytes.offset + 4] << 24) | ((bytes.bytes[bytes.offset + 5] & 0xff) << 16) | ((bytes.bytes[bytes.offset + 6] & 0xff) << 8) | (bytes.bytes[bytes.offset + 7] & 0xff).     return (((long) high) << 32) | (low & 0x0ffffffffL). }
false;public,static;1;8;;public static byte[] intToBytes(int val) {     byte[] arr = new byte[4].     arr[0] = (byte) (val >>> 24).     arr[1] = (byte) (val >>> 16).     arr[2] = (byte) (val >>> 8).     arr[3] = (byte) (val).     return arr. }
true;public,static;1;6;/**  * Converts an int to a byte array.  *  * @param val The int to convert to a byte array  * @return The byte array converted  */ ;/**  * Converts an int to a byte array.  *  * @param val The int to convert to a byte array  * @return The byte array converted  */ public static byte[] shortToBytes(int val) {     byte[] arr = new byte[2].     arr[0] = (byte) (val >>> 8).     arr[1] = (byte) (val).     return arr. }
true;public,static;1;12;/**  * Converts a long to a byte array.  *  * @param val The long to convert to a byte array  * @return The byte array converted  */ ;/**  * Converts a long to a byte array.  *  * @param val The long to convert to a byte array  * @return The byte array converted  */ public static byte[] longToBytes(long val) {     byte[] arr = new byte[8].     arr[0] = (byte) (val >>> 56).     arr[1] = (byte) (val >>> 48).     arr[2] = (byte) (val >>> 40).     arr[3] = (byte) (val >>> 32).     arr[4] = (byte) (val >>> 24).     arr[5] = (byte) (val >>> 16).     arr[6] = (byte) (val >>> 8).     arr[7] = (byte) (val).     return arr. }
true;public,static;1;3;/**  * Converts a double to a byte array.  *  * @param val The double to convert to a byte array  * @return The byte array converted  */ ;/**  * Converts a double to a byte array.  *  * @param val The double to convert to a byte array  * @return The byte array converted  */ public static byte[] doubleToBytes(double val) {     return longToBytes(Double.doubleToRawLongBits(val)). }
true;public,static;1;6;/**  * Returns true if value is neither NaN nor infinite.  */ ;/**  * Returns true if value is neither NaN nor infinite.  */ public static boolean isValidDouble(double value) {     if (Double.isNaN(value) || Double.isInfinite(value)) {         return false.     }     return true. }
true;public,static;1;19;/**  * Return the long that {@code n} stores, or throws an exception if the  *  stored value cannot be converted to a long that stores the exact same  *  value.  */ ;/**  * Return the long that {@code n} stores, or throws an exception if the  *  stored value cannot be converted to a long that stores the exact same  *  value.  */ public static long toLongExact(Number n) {     if (n instanceof Byte || n instanceof Short || n instanceof Integer || n instanceof Long) {         return n.longValue().     } else if (n instanceof Float || n instanceof Double) {         double d = n.doubleValue().         if (d != Math.round(d)) {             throw new IllegalArgumentException(n + " is not an integer value").         }         return n.longValue().     } else if (n instanceof BigDecimal) {         return ((BigDecimal) n).toBigIntegerExact().longValueExact().     } else if (n instanceof BigInteger) {         return ((BigInteger) n).longValueExact().     } else {         throw new IllegalArgumentException("Cannot check whether [" + n + "] of class [" + n.getClass().getName() + "] is actually a long").     } }
true;public,static;2;23;/**  * Return the long that {@code stringValue} stores or throws an exception if the  *  stored value cannot be converted to a long that stores the exact same  *  value and {@code coerce} is false.  */ ;/**  * Return the long that {@code stringValue} stores or throws an exception if the  *  stored value cannot be converted to a long that stores the exact same  *  value and {@code coerce} is false.  */ public static long toLong(String stringValue, boolean coerce) {     try {         return Long.parseLong(stringValue).     } catch (NumberFormatException e) {     // we will try again with BigDecimal     }     final BigInteger bigIntegerValue.     try {         BigDecimal bigDecimalValue = new BigDecimal(stringValue).         bigIntegerValue = coerce ? bigDecimalValue.toBigInteger() : bigDecimalValue.toBigIntegerExact().     } catch (ArithmeticException e) {         throw new IllegalArgumentException("Value [" + stringValue + "] has a decimal part").     } catch (NumberFormatException e) {         throw new IllegalArgumentException("For input string: \"" + stringValue + "\"").     }     if (bigIntegerValue.compareTo(MAX_LONG_VALUE) > 0 || bigIntegerValue.compareTo(MIN_LONG_VALUE) < 0) {         throw new IllegalArgumentException("Value [" + stringValue + "] is out of range for a long").     }     return bigIntegerValue.longValue(). }
true;public,static;1;3;/**  * Return the int that {@code n} stores, or throws an exception if the  *  stored value cannot be converted to an int that stores the exact same  *  value.  */ ;/**  * Return the int that {@code n} stores, or throws an exception if the  *  stored value cannot be converted to an int that stores the exact same  *  value.  */ public static int toIntExact(Number n) {     return Math.toIntExact(toLongExact(n)). }
true;public,static;1;7;/**  * Return the short that {@code n} stores, or throws an exception if the  *  stored value cannot be converted to a short that stores the exact same  *  value.  */ ;/**  * Return the short that {@code n} stores, or throws an exception if the  *  stored value cannot be converted to a short that stores the exact same  *  value.  */ public static short toShortExact(Number n) {     long l = toLongExact(n).     if (l != (short) l) {         throw new ArithmeticException("short overflow: " + l).     }     return (short) l. }
true;public,static;1;7;/**  * Return the byte that {@code n} stores, or throws an exception if the  *  stored value cannot be converted to a byte that stores the exact same  *  value.  */ ;/**  * Return the byte that {@code n} stores, or throws an exception if the  *  stored value cannot be converted to a byte that stores the exact same  *  value.  */ public static byte toByteExact(Number n) {     long l = toLongExact(n).     if (l != (byte) l) {         throw new ArithmeticException("byte overflow: " + l).     }     return (byte) l. }
