commented;modifiers;parameterAmount;loc;comment;code
false;public;2;19;;@Override public Decision canRebalance(ShardRouting shardRouting, RoutingAllocation allocation) {     Decision.Multi ret = new Decision.Multi().     for (AllocationDecider allocationDecider : allocations) {         Decision decision = allocationDecider.canRebalance(shardRouting, allocation).         // short track if a NO is returned.         if (decision == Decision.NO) {             if (!allocation.debugDecision()) {                 return decision.             } else {                 ret.add(decision).             }         } else if (decision != Decision.ALWAYS && (allocation.getDebugMode() != EXCLUDE_YES_DECISIONS || decision.type() != Decision.Type.YES)) {             ret.add(decision).         }     }     return ret. }
false;public;3;29;;@Override public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {     if (allocation.shouldIgnoreShardForNode(shardRouting.shardId(), node.nodeId())) {         return Decision.NO.     }     Decision.Multi ret = new Decision.Multi().     for (AllocationDecider allocationDecider : allocations) {         Decision decision = allocationDecider.canAllocate(shardRouting, node, allocation).         // short track if a NO is returned.         if (decision == Decision.NO) {             if (logger.isTraceEnabled()) {                 logger.trace("Can not allocate [{}] on node [{}] due to [{}]", shardRouting, node.node(), allocationDecider.getClass().getSimpleName()).             }             // short circuit only if debugging is not enabled             if (!allocation.debugDecision()) {                 return decision.             } else {                 ret.add(decision).             }         } else if (decision != Decision.ALWAYS && (allocation.getDebugMode() != EXCLUDE_YES_DECISIONS || decision.type() != Decision.Type.YES)) {             // the assumption is that a decider that returns the static instance Decision#ALWAYS             // does not really implements canAllocate             ret.add(decision).         }     }     return ret. }
false;public;3;29;;@Override public Decision canRemain(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {     if (allocation.shouldIgnoreShardForNode(shardRouting.shardId(), node.nodeId())) {         if (logger.isTraceEnabled()) {             logger.trace("Shard [{}] should be ignored for node [{}]", shardRouting, node.nodeId()).         }         return Decision.NO.     }     Decision.Multi ret = new Decision.Multi().     for (AllocationDecider allocationDecider : allocations) {         Decision decision = allocationDecider.canRemain(shardRouting, node, allocation).         // short track if a NO is returned.         if (decision == Decision.NO) {             if (logger.isTraceEnabled()) {                 logger.trace("Shard [{}] can not remain on node [{}] due to [{}]", shardRouting, node.nodeId(), allocationDecider.getClass().getSimpleName()).             }             if (!allocation.debugDecision()) {                 return decision.             } else {                 ret.add(decision).             }         } else if (decision != Decision.ALWAYS && (allocation.getDebugMode() != EXCLUDE_YES_DECISIONS || decision.type() != Decision.Type.YES)) {             ret.add(decision).         }     }     return ret. }
false;public;3;19;;@Override public Decision canAllocate(IndexMetaData indexMetaData, RoutingNode node, RoutingAllocation allocation) {     Decision.Multi ret = new Decision.Multi().     for (AllocationDecider allocationDecider : allocations) {         Decision decision = allocationDecider.canAllocate(indexMetaData, node, allocation).         // short track if a NO is returned.         if (decision == Decision.NO) {             if (!allocation.debugDecision()) {                 return decision.             } else {                 ret.add(decision).             }         } else if (decision != Decision.ALWAYS && (allocation.getDebugMode() != EXCLUDE_YES_DECISIONS || decision.type() != Decision.Type.YES)) {             ret.add(decision).         }     }     return ret. }
false;public;2;19;;@Override public Decision canAllocate(ShardRouting shardRouting, RoutingAllocation allocation) {     Decision.Multi ret = new Decision.Multi().     for (AllocationDecider allocationDecider : allocations) {         Decision decision = allocationDecider.canAllocate(shardRouting, allocation).         // short track if a NO is returned.         if (decision == Decision.NO) {             if (!allocation.debugDecision()) {                 return decision.             } else {                 ret.add(decision).             }         } else if (decision != Decision.ALWAYS && (allocation.getDebugMode() != EXCLUDE_YES_DECISIONS || decision.type() != Decision.Type.YES)) {             ret.add(decision).         }     }     return ret. }
false;public;2;19;;@Override public Decision canAllocate(RoutingNode node, RoutingAllocation allocation) {     Decision.Multi ret = new Decision.Multi().     for (AllocationDecider allocationDecider : allocations) {         Decision decision = allocationDecider.canAllocate(node, allocation).         // short track if a NO is returned.         if (decision == Decision.NO) {             if (!allocation.debugDecision()) {                 return decision.             } else {                 ret.add(decision).             }         } else if (decision != Decision.ALWAYS && (allocation.getDebugMode() != EXCLUDE_YES_DECISIONS || decision.type() != Decision.Type.YES)) {             ret.add(decision).         }     }     return ret. }
false;public;1;19;;@Override public Decision canRebalance(RoutingAllocation allocation) {     Decision.Multi ret = new Decision.Multi().     for (AllocationDecider allocationDecider : allocations) {         Decision decision = allocationDecider.canRebalance(allocation).         // short track if a NO is returned.         if (decision == Decision.NO) {             if (!allocation.debugDecision()) {                 return decision.             } else {                 ret.add(decision).             }         } else if (decision != Decision.ALWAYS && (allocation.getDebugMode() != EXCLUDE_YES_DECISIONS || decision.type() != Decision.Type.YES)) {             ret.add(decision).         }     }     return ret. }
false;public;3;28;;@Override public Decision canForceAllocatePrimary(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {     assert shardRouting.primary() : "must not call canForceAllocatePrimary on a non-primary shard routing " + shardRouting.     if (allocation.shouldIgnoreShardForNode(shardRouting.shardId(), node.nodeId())) {         return Decision.NO.     }     Decision.Multi ret = new Decision.Multi().     for (AllocationDecider decider : allocations) {         Decision decision = decider.canForceAllocatePrimary(shardRouting, node, allocation).         // short track if a NO is returned.         if (decision == Decision.NO) {             if (logger.isTraceEnabled()) {                 logger.trace("Shard [{}] can not be forcefully allocated to node [{}] due to [{}].", shardRouting.shardId(), node.nodeId(), decider.getClass().getSimpleName()).             }             if (!allocation.debugDecision()) {                 return decision.             } else {                 ret.add(decision).             }         } else if (decision != Decision.ALWAYS && (allocation.getDebugMode() != EXCLUDE_YES_DECISIONS || decision.type() != Decision.Type.YES)) {             ret.add(decision).         }     }     return ret. }
