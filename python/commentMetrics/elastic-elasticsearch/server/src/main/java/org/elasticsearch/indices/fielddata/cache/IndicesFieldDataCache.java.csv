commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public void close() {     cache.invalidateAll(). }
false;public;3;3;;public IndexFieldDataCache buildIndexFieldDataCache(IndexFieldDataCache.Listener listener, Index index, String fieldName) {     return new IndexFieldCache(logger, cache, index, fieldName, indicesFieldDataCacheListener, listener). }
false;public;0;3;;public Cache<Key, Accountable> getCache() {     return cache. }
false;public;1;18;;@Override public void onRemoval(RemovalNotification<Key, Accountable> notification) {     Key key = notification.getKey().     assert key != null && key.listeners != null.     IndexFieldCache indexCache = key.indexCache.     final Accountable value = notification.getValue().     for (IndexFieldDataCache.Listener listener : key.listeners) {         try {             listener.onRemoval(key.shardId, indexCache.fieldName, notification.getRemovalReason() == RemovalNotification.RemovalReason.EVICTED, value.ramBytesUsed()).         } catch (Exception e) {             // load anyway since listeners should not throw exceptions             logger.error("Failed to call listener on field data cache unloading", e).         }     } }
false;public;2;5;;@Override public long applyAsLong(Key key, Accountable ramUsage) {     int weight = (int) Math.min(ramUsage.ramBytesUsed(), Integer.MAX_VALUE).     return weight == 0 ? 1 : weight. }
false;public;2;26;;@Override public <FD extends AtomicFieldData, IFD extends IndexFieldData<FD>> FD load(final LeafReaderContext context, final IFD indexFieldData) throws Exception {     final ShardId shardId = ShardUtils.extractShardId(context.reader()).     final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper().     if (cacheHelper == null) {         throw new IllegalArgumentException("Reader " + context.reader() + " does not support caching").     }     final Key key = new Key(this, cacheHelper.getKey(), shardId).     // noinspection unchecked     final Accountable accountable = cache.computeIfAbsent(key, k -> {         cacheHelper.addClosedListener(IndexFieldCache.this).         Collections.addAll(k.listeners, this.listeners).         final AtomicFieldData fieldData = indexFieldData.loadDirect(context).         for (Listener listener : k.listeners) {             try {                 listener.onCache(shardId, fieldName, fieldData).             } catch (Exception e) {                 // load anyway since listeners should not throw exceptions                 logger.error("Failed to call listener on atomic field data loading", e).             }         }         return fieldData.     }).     return (FD) accountable. }
false;public;2;26;;@Override public <FD extends AtomicFieldData, IFD extends IndexFieldData.Global<FD>> IFD load(final DirectoryReader indexReader, final IFD indexFieldData) throws Exception {     final ShardId shardId = ShardUtils.extractShardId(indexReader).     final IndexReader.CacheHelper cacheHelper = indexReader.getReaderCacheHelper().     if (cacheHelper == null) {         throw new IllegalArgumentException("Reader " + indexReader + " does not support caching").     }     final Key key = new Key(this, cacheHelper.getKey(), shardId).     // noinspection unchecked     final Accountable accountable = cache.computeIfAbsent(key, k -> {         ElasticsearchDirectoryReader.addReaderCloseListener(indexReader, IndexFieldCache.this).         Collections.addAll(k.listeners, this.listeners).         final Accountable ifd = (Accountable) indexFieldData.localGlobalDirect(indexReader).         for (Listener listener : k.listeners) {             try {                 listener.onCache(shardId, fieldName, ifd).             } catch (Exception e) {                 // load anyway since listeners should not throw exceptions                 logger.error("Failed to call listener on global ordinals loading", e).             }         }         return ifd.     }).     return (IFD) accountable. }
false;public;1;5;;@Override public void onClose(CacheKey key) throws IOException {     cache.invalidate(new Key(this, key, null)). // don't call cache.cleanUp here as it would have bad performance implications }
false;public;0;10;;@Override public void clear() {     for (Key key : cache.keys()) {         if (key.indexCache.index.equals(index)) {             cache.invalidate(key).         }     }     // force eviction     cache.refresh(). }
false;public;1;14;;@Override public void clear(String fieldName) {     for (Key key : cache.keys()) {         if (key.indexCache.index.equals(index)) {             if (key.indexCache.fieldName.equals(fieldName)) {                 cache.invalidate(key).             }         }     }     // we call refresh because this is a manual operation, should happen     // rarely and probably means the user wants to see memory returned as     // soon as possible     cache.refresh(). }
false;public;1;9;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     Key key = (Key) o.     if (!indexCache.equals(key.indexCache))         return false.     if (!readerKey.equals(key.readerKey))         return false.     return true. }
false;public;0;6;;@Override public int hashCode() {     int result = indexCache.hashCode().     result = 31 * result + readerKey.hashCode().     return result. }
