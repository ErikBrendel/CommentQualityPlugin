commented;modifiers;parameterAmount;loc;comment;code
false;public;0;9;;@Override public String toString() {     return "GcThreshold{" + "name='" + name + '\'' + ", warnThreshold=" + warnThreshold + ", infoThreshold=" + infoThreshold + ", debugThreshold=" + debugThreshold + '}'. }
false;private,static;3;10;;private static TimeValue getValidThreshold(Settings settings, String key, String level) {     TimeValue threshold = settings.getAsTime(level, null).     if (threshold == null) {         throw new IllegalArgumentException("missing gc_threshold for [" + getThresholdName(key, level) + "]").     }     if (threshold.nanos() <= 0) {         throw new IllegalArgumentException("invalid gc_threshold [" + threshold + "] for [" + getThresholdName(key, level) + "]").     }     return threshold. }
false;private,static;2;3;;private static String getThresholdName(String key, String level) {     return GC_COLLECTOR_PREFIX + key + "." + level. }
false;;1;4;;@Override void onMonitorFailure(Exception e) {     logger.debug("failed to monitor", e). }
false;;3;4;;@Override void onSlowGc(final Threshold threshold, final long seq, final SlowGcEvent slowGcEvent) {     logSlowGc(logger, threshold, seq, slowGcEvent, JvmGcMonitorService::buildPools). }
false;;4;4;;@Override void onGcOverhead(final Threshold threshold, final long current, final long elapsed, final long seq) {     logGcOverhead(logger, threshold, current, elapsed, seq). }
false;protected;0;22;;@Override protected void doStart() {     if (!enabled) {         return.     }     scheduledFuture = threadPool.scheduleWithFixedDelay(new JvmMonitor(gcThresholds, gcOverheadThreshold) {          @Override         void onMonitorFailure(Exception e) {             logger.debug("failed to monitor", e).         }          @Override         void onSlowGc(final Threshold threshold, final long seq, final SlowGcEvent slowGcEvent) {             logSlowGc(logger, threshold, seq, slowGcEvent, JvmGcMonitorService::buildPools).         }          @Override         void onGcOverhead(final Threshold threshold, final long current, final long elapsed, final long seq) {             logGcOverhead(logger, threshold, current, elapsed, seq).         }     }, interval, Names.SAME). }
false;static;5;74;;static void logSlowGc(final Logger logger, final JvmMonitor.Threshold threshold, final long seq, final JvmMonitor.SlowGcEvent slowGcEvent, BiFunction<JvmStats, JvmStats, String> pools) {     final String name = slowGcEvent.currentGc.getName().     final long elapsed = slowGcEvent.elapsed.     final long totalGcCollectionCount = slowGcEvent.currentGc.getCollectionCount().     final long currentGcCollectionCount = slowGcEvent.collectionCount.     final TimeValue totalGcCollectionTime = slowGcEvent.currentGc.getCollectionTime().     final TimeValue currentGcCollectionTime = slowGcEvent.collectionTime.     final JvmStats lastJvmStats = slowGcEvent.lastJvmStats.     final JvmStats currentJvmStats = slowGcEvent.currentJvmStats.     final ByteSizeValue maxHeapUsed = slowGcEvent.maxHeapUsed.     switch(threshold) {         case WARN:             if (logger.isWarnEnabled()) {                 logger.warn(SLOW_GC_LOG_MESSAGE, name, seq, totalGcCollectionCount, currentGcCollectionTime, currentGcCollectionCount, TimeValue.timeValueMillis(elapsed), currentGcCollectionTime, totalGcCollectionTime, lastJvmStats.getMem().getHeapUsed(), currentJvmStats.getMem().getHeapUsed(), maxHeapUsed, pools.apply(lastJvmStats, currentJvmStats)).             }             break.         case INFO:             if (logger.isInfoEnabled()) {                 logger.info(SLOW_GC_LOG_MESSAGE, name, seq, totalGcCollectionCount, currentGcCollectionTime, currentGcCollectionCount, TimeValue.timeValueMillis(elapsed), currentGcCollectionTime, totalGcCollectionTime, lastJvmStats.getMem().getHeapUsed(), currentJvmStats.getMem().getHeapUsed(), maxHeapUsed, pools.apply(lastJvmStats, currentJvmStats)).             }             break.         case DEBUG:             if (logger.isDebugEnabled()) {                 logger.debug(SLOW_GC_LOG_MESSAGE, name, seq, totalGcCollectionCount, currentGcCollectionTime, currentGcCollectionCount, TimeValue.timeValueMillis(elapsed), currentGcCollectionTime, totalGcCollectionTime, lastJvmStats.getMem().getHeapUsed(), currentJvmStats.getMem().getHeapUsed(), maxHeapUsed, pools.apply(lastJvmStats, currentJvmStats)).             }             break.     } }
false;static;2;22;;static String buildPools(JvmStats last, JvmStats current) {     StringBuilder sb = new StringBuilder().     for (JvmStats.MemoryPool currentPool : current.getMem()) {         JvmStats.MemoryPool prevPool = null.         for (JvmStats.MemoryPool pool : last.getMem()) {             if (pool.getName().equals(currentPool.getName())) {                 prevPool = pool.                 break.             }         }         sb.append("{[").append(currentPool.getName()).append("] [").append(prevPool == null ? "?" : prevPool.getUsed()).append("]->[").append(currentPool.getUsed()).append("]/[").append(currentPool.getMax()).append("]}").     }     return sb.toString(). }
false;static;5;24;;static void logGcOverhead(final Logger logger, final JvmMonitor.Threshold threshold, final long current, final long elapsed, final long seq) {     switch(threshold) {         case WARN:             if (logger.isWarnEnabled()) {                 logger.warn(OVERHEAD_LOG_MESSAGE, seq, TimeValue.timeValueMillis(current), TimeValue.timeValueMillis(elapsed)).             }             break.         case INFO:             if (logger.isInfoEnabled()) {                 logger.info(OVERHEAD_LOG_MESSAGE, seq, TimeValue.timeValueMillis(current), TimeValue.timeValueMillis(elapsed)).             }             break.         case DEBUG:             if (logger.isDebugEnabled()) {                 logger.debug(OVERHEAD_LOG_MESSAGE, seq, TimeValue.timeValueMillis(current), TimeValue.timeValueMillis(elapsed)).             }             break.     } }
false;protected;0;7;;@Override protected void doStop() {     if (!enabled) {         return.     }     scheduledFuture.cancel(). }
false;protected;0;3;;@Override protected void doClose() { }
false;public;0;8;;@Override public void run() {     try {         monitorGc().     } catch (Exception e) {         onMonitorFailure(e).     } }
false;abstract;1;1;;abstract void onMonitorFailure(Exception e).
false;synchronized;0;13;;synchronized void monitorGc() {     seq++.     final long currentTime = now().     JvmStats currentJvmStats = jvmStats().     final long elapsed = TimeUnit.NANOSECONDS.toMillis(currentTime - lastTime).     monitorSlowGc(currentJvmStats, elapsed).     monitorGcOverhead(currentJvmStats, elapsed).     lastTime = currentTime.     lastJvmStats = currentJvmStats. }
false;final;2;42;;final void monitorSlowGc(JvmStats currentJvmStats, long elapsed) {     for (int i = 0. i < currentJvmStats.getGc().getCollectors().length. i++) {         GarbageCollector gc = currentJvmStats.getGc().getCollectors()[i].         GarbageCollector prevGc = lastJvmStats.getGc().getCollectors()[i].         // no collection has happened         long collections = gc.getCollectionCount() - prevGc.getCollectionCount().         if (collections == 0) {             continue.         }         long collectionTime = gc.getCollectionTime().millis() - prevGc.getCollectionTime().millis().         if (collectionTime == 0) {             continue.         }         GcThreshold gcThreshold = gcThresholds.get(gc.getName()).         if (gcThreshold == null) {             gcThreshold = gcThresholds.get("default").         }         long avgCollectionTime = collectionTime / collections.         Threshold threshold = null.         if (avgCollectionTime > gcThreshold.warnThreshold) {             threshold = Threshold.WARN.         } else if (avgCollectionTime > gcThreshold.infoThreshold) {             threshold = Threshold.INFO.         } else if (avgCollectionTime > gcThreshold.debugThreshold) {             threshold = Threshold.DEBUG.         }         if (threshold != null) {             onSlowGc(threshold, seq, new SlowGcEvent(gc, collections, TimeValue.timeValueMillis(collectionTime), elapsed, lastJvmStats, currentJvmStats, JvmInfo.jvmInfo().getMem().getHeapMax())).         }     } }
false;final;2;9;;final void monitorGcOverhead(final JvmStats currentJvmStats, final long elapsed) {     long current = 0.     for (int i = 0. i < currentJvmStats.getGc().getCollectors().length. i++) {         GarbageCollector gc = currentJvmStats.getGc().getCollectors()[i].         GarbageCollector prevGc = lastJvmStats.getGc().getCollectors()[i].         current += gc.getCollectionTime().millis() - prevGc.getCollectionTime().millis().     }     checkGcOverhead(current, elapsed, seq). }
false;;3;14;;void checkGcOverhead(final long current, final long elapsed, final long seq) {     final int fraction = (int) ((100 * current) / (double) elapsed).     Threshold overheadThreshold = null.     if (fraction >= gcOverheadThreshold.warnThreshold) {         overheadThreshold = Threshold.WARN.     } else if (fraction >= gcOverheadThreshold.infoThreshold) {         overheadThreshold = Threshold.INFO.     } else if (fraction >= gcOverheadThreshold.debugThreshold) {         overheadThreshold = Threshold.DEBUG.     }     if (overheadThreshold != null) {         onGcOverhead(overheadThreshold, current, elapsed, seq).     } }
false;;0;3;;JvmStats jvmStats() {     return JvmStats.jvmStats(). }
false;;0;3;;long now() {     return System.nanoTime(). }
false;abstract;3;1;;abstract void onSlowGc(Threshold threshold, long seq, SlowGcEvent slowGcEvent).
false;abstract;4;1;;abstract void onGcOverhead(Threshold threshold, long total, long elapsed, long seq).
