commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public String displayName() {     return displayName. }
false;public,static;1;12;;public static Flavor fromDisplayName(final String displayName) {     switch(displayName) {         case "default":             return Flavor.DEFAULT.         case "oss":             return Flavor.OSS.         case "unknown":             return Flavor.UNKNOWN.         default:             throw new IllegalStateException("unexpected distribution flavor [" + displayName + "]. your distribution is broken").     } }
false;public;0;3;;public String displayName() {     return displayName. }
false;public,static;1;16;;public static Type fromDisplayName(final String displayName) {     switch(displayName) {         case "deb":             return Type.DEB.         case "rpm":             return Type.RPM.         case "tar":             return Type.TAR.         case "zip":             return Type.ZIP.         case "unknown":             return Type.UNKNOWN.         default:             throw new IllegalStateException("unexpected distribution type [" + displayName + "]. your distribution is broken").     } }
true;static;0;4;/**  * The location of the code source for Elasticsearch  *  * @return the location of the code source for Elasticsearch which may be null  */ ;/**  * The location of the code source for Elasticsearch  *  * @return the location of the code source for Elasticsearch which may be null  */ static URL getElasticsearchCodeSourceLocation() {     final CodeSource codeSource = Build.class.getProtectionDomain().getCodeSource().     return codeSource == null ? null : codeSource.getLocation(). }
false;public;0;3;;public String shortHash() {     return shortHash. }
false;public;0;3;;public String date() {     return date. }
false;public,static;1;25;;public static Build readBuild(StreamInput in) throws IOException {     final Flavor flavor.     final Type type.     if (in.getVersion().onOrAfter(Version.V_6_3_0)) {         flavor = Flavor.fromDisplayName(in.readString()).     } else {         flavor = Flavor.OSS.     }     if (in.getVersion().onOrAfter(Version.V_6_3_0)) {         type = Type.fromDisplayName(in.readString()).     } else {         type = Type.UNKNOWN.     }     String hash = in.readString().     String date = in.readString().     boolean snapshot = in.readBoolean().     final String version.     if (in.getVersion().onOrAfter(Version.V_7_0_0)) {         version = in.readString().     } else {         version = in.getVersion().toString().     }     return new Build(flavor, type, hash, date, snapshot, version). }
false;public,static;2;14;;public static void writeBuild(Build build, StreamOutput out) throws IOException {     if (out.getVersion().onOrAfter(Version.V_6_3_0)) {         out.writeString(build.flavor().displayName()).     }     if (out.getVersion().onOrAfter(Version.V_6_3_0)) {         out.writeString(build.type().displayName()).     }     out.writeString(build.shortHash()).     out.writeString(build.date()).     out.writeBoolean(build.isSnapshot()).     if (out.getVersion().onOrAfter(Version.V_7_0_0)) {         out.writeString(build.getQualifiedVersion()).     } }
true;public;0;3;/**  * Get the version as considered at build time  *  * Offers a way to get the fully qualified version as configured by the build.  * This will be the same as {@link Version} for production releases, but may include on of the qualifier ( e.x alpha1 )  * or -SNAPSHOT for others.  *  * @return the fully qualified build  */ ;/**  * Get the version as considered at build time  *  * Offers a way to get the fully qualified version as configured by the build.  * This will be the same as {@link Version} for production releases, but may include on of the qualifier ( e.x alpha1 )  * or -SNAPSHOT for others.  *  * @return the fully qualified build  */ public String getQualifiedVersion() {     return version. }
false;public;0;3;;public Flavor flavor() {     return flavor. }
false;public;0;3;;public Type type() {     return type. }
false;public;0;3;;public boolean isSnapshot() {     return isSnapshot. }
true;public;0;3;/**  * Provides information about the intent of the build  *  * @return true if the build is intended for production use  */ ;/**  * Provides information about the intent of the build  *  * @return true if the build is intended for production use  */ public boolean isProductionRelease() {     return version.matches("[0-9]+\\.[0-9]+\\.[0-9]+"). }
false;public;0;4;;@Override public String toString() {     return "[" + flavor.displayName() + "][" + type.displayName + "][" + shortHash + "][" + date + "][" + version + "]". }
false;public;1;30;;@Override public boolean equals(Object o) {     if (this == o) {         return true.     }     if (o == null || getClass() != o.getClass()) {         return false.     }     Build build = (Build) o.     if (!flavor.equals(build.flavor)) {         return false.     }     if (!type.equals(build.type)) {         return false.     }     if (isSnapshot != build.isSnapshot) {         return false.     }     if (!shortHash.equals(build.shortHash)) {         return false.     }     if (version.equals(build.version) == false) {         return false.     }     return date.equals(build.date). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(flavor, type, isSnapshot, shortHash, date, version). }
