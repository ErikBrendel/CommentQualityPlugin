commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;public Builder enabled(boolean enabled) {     this.enabled = enabled.     return this. }
false;public;1;4;;public Builder includes(String[] includes) {     this.includes = includes.     return this. }
false;public;1;4;;public Builder excludes(String[] excludes) {     this.excludes = excludes.     return this. }
false;public;1;4;;@Override public SourceFieldMapper build(BuilderContext context) {     return new SourceFieldMapper(enabled, includes, excludes, context.indexSettings()). }
false;public;3;32;;@Override public MetadataFieldMapper.Builder<?, ?> parse(String name, Map<String, Object> node, ParserContext parserContext) throws MapperParsingException {     Builder builder = new Builder().     for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(). iterator.hasNext(). ) {         Map.Entry<String, Object> entry = iterator.next().         String fieldName = entry.getKey().         Object fieldNode = entry.getValue().         if (fieldName.equals("enabled")) {             builder.enabled(XContentMapValues.nodeBooleanValue(fieldNode, name + ".enabled")).             iterator.remove().         } else if (fieldName.equals("includes")) {             List<Object> values = (List<Object>) fieldNode.             String[] includes = new String[values.size()].             for (int i = 0. i < includes.length. i++) {                 includes[i] = values.get(i).toString().             }             builder.includes(includes).             iterator.remove().         } else if (fieldName.equals("excludes")) {             List<Object> values = (List<Object>) fieldNode.             String[] excludes = new String[values.size()].             for (int i = 0. i < excludes.length. i++) {                 excludes[i] = values.get(i).toString().             }             builder.excludes(excludes).             iterator.remove().         }     }     return builder. }
false;public;2;5;;@Override public MetadataFieldMapper getDefault(MappedFieldType fieldType, ParserContext context) {     final Settings indexSettings = context.mapperService().getIndexSettings().getSettings().     return new SourceFieldMapper(indexSettings). }
false;public;0;4;;@Override public MappedFieldType clone() {     return new SourceFieldType(this). }
false;public;0;4;;@Override public String typeName() {     return CONTENT_TYPE. }
false;public;1;4;;@Override public Query existsQuery(QueryShardContext context) {     throw new QueryShardException(context, "The _source field is not searchable"). }
false;public;2;4;;@Override public Query termQuery(Object value, QueryShardContext context) {     throw new QueryShardException(context, "The _source field is not searchable"). }
false;public;0;3;;public boolean enabled() {     return enabled. }
false;public;0;4;;public String[] excludes() {     return this.excludes != null ? this.excludes : Strings.EMPTY_ARRAY. }
false;public;0;3;;public String[] includes() {     return this.includes != null ? this.includes : Strings.EMPTY_ARRAY. }
false;public;0;3;;public boolean isComplete() {     return complete. }
false;public;1;4;;@Override public void preParse(ParseContext context) throws IOException {     super.parse(context). }
false;public;1;4;;@Override public void parse(ParseContext context) throws IOException { // nothing to do here, we will call it in pre parse }
false;protected;2;30;;@Override protected void parseCreateField(ParseContext context, List<IndexableField> fields) throws IOException {     BytesReference originalSource = context.sourceToParse().source().     BytesReference source = originalSource.     if (enabled && fieldType().stored() && source != null) {         // Percolate and tv APIs may not set the source and that is ok, because these APIs will not index any data         if (filter != null) {             // we don't update the context source if we filter, we want to keep it as is...             Tuple<XContentType, Map<String, Object>> mapTuple = XContentHelper.convertToMap(source, true, context.sourceToParse().getXContentType()).             Map<String, Object> filteredSource = filter.apply(mapTuple.v2()).             BytesStreamOutput bStream = new BytesStreamOutput().             XContentType contentType = mapTuple.v1().             XContentBuilder builder = XContentFactory.contentBuilder(contentType, bStream).map(filteredSource).             builder.close().             source = bStream.bytes().         }         BytesRef ref = source.toBytesRef().         fields.add(new StoredField(fieldType().name(), ref.bytes, ref.offset, ref.length)).     } else {         source = null.     }     if (originalSource != null && source != originalSource && context.indexSettings().isSoftDeleteEnabled()) {         // if we omitted source or modified it we add the _recovery_source to ensure we have it for ops based recovery         BytesRef ref = originalSource.toBytesRef().         fields.add(new StoredField(RECOVERY_SOURCE_NAME, ref.bytes, ref.offset, ref.length)).         fields.add(new NumericDocValuesField(RECOVERY_SOURCE_NAME, 1)).     } }
false;protected;0;4;;@Override protected String contentType() {     return CONTENT_TYPE. }
false;public;2;28;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     boolean includeDefaults = params.paramAsBoolean("include_defaults", false).     // all are defaults, no need to write it at all     if (!includeDefaults && enabled == Defaults.ENABLED && includes == null && excludes == null) {         return builder.     }     builder.startObject(contentType()).     if (includeDefaults || enabled != Defaults.ENABLED) {         builder.field("enabled", enabled).     }     if (includes != null) {         builder.array("includes", includes).     } else if (includeDefaults) {         builder.array("includes", Strings.EMPTY_ARRAY).     }     if (excludes != null) {         builder.array("excludes", excludes).     } else if (includeDefaults) {         builder.array("excludes", Strings.EMPTY_ARRAY).     }     builder.endObject().     return builder. }
false;protected;1;17;;@Override protected void doMerge(Mapper mergeWith) {     SourceFieldMapper sourceMergeWith = (SourceFieldMapper) mergeWith.     List<String> conflicts = new ArrayList<>().     if (this.enabled != sourceMergeWith.enabled) {         conflicts.add("Cannot update enabled setting for [_source]").     }     if (Arrays.equals(includes(), sourceMergeWith.includes()) == false) {         conflicts.add("Cannot update includes setting for [_source]").     }     if (Arrays.equals(excludes(), sourceMergeWith.excludes()) == false) {         conflicts.add("Cannot update excludes setting for [_source]").     }     if (conflicts.isEmpty() == false) {         throw new IllegalArgumentException("Can't merge because of conflicts: " + conflicts).     } }
