commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String getName() {     return "create_index_action". }
false;public;2;23;;@Override public RestChannelConsumer prepareRequest(final RestRequest request, final NodeClient client) throws IOException {     final boolean includeTypeName = request.paramAsBoolean(INCLUDE_TYPE_NAME_PARAMETER, DEFAULT_INCLUDE_TYPE_NAME_POLICY).     if (request.hasParam(INCLUDE_TYPE_NAME_PARAMETER)) {         deprecationLogger.deprecatedAndMaybeLog("create_index_with_types", TYPES_DEPRECATION_MESSAGE).     }     CreateIndexRequest createIndexRequest = new CreateIndexRequest(request.param("index")).     if (request.hasContent()) {         Map<String, Object> sourceAsMap = XContentHelper.convertToMap(request.requiredContent(), false, request.getXContentType()).v2().         sourceAsMap = prepareMappings(sourceAsMap, includeTypeName).         createIndexRequest.source(sourceAsMap, LoggingDeprecationHandler.INSTANCE).     }     createIndexRequest.timeout(request.paramAsTime("timeout", createIndexRequest.timeout())).     createIndexRequest.masterNodeTimeout(request.paramAsTime("master_timeout", createIndexRequest.masterNodeTimeout())).     createIndexRequest.waitForActiveShards(ActiveShardCount.parseString(request.param("wait_for_active_shards"))).     return channel -> client.admin().indices().create(createIndexRequest, new RestToXContentListener<>(channel)). }
false;static;2;19;;static Map<String, Object> prepareMappings(Map<String, Object> source, boolean includeTypeName) {     if (includeTypeName || source.containsKey("mappings") == false || (source.get("mappings") instanceof Map) == false) {         return source.     }     Map<String, Object> newSource = new HashMap<>(source).     @SuppressWarnings("unchecked")     Map<String, Object> mappings = (Map<String, Object>) source.get("mappings").     if (MapperService.isMappingSourceTyped(MapperService.SINGLE_MAPPING_NAME, mappings)) {         throw new IllegalArgumentException("The mapping definition cannot be nested under a type " + "[" + MapperService.SINGLE_MAPPING_NAME + "] unless include_type_name is set to true.").     }     newSource.put("mappings", Collections.singletonMap(MapperService.SINGLE_MAPPING_NAME, mappings)).     return newSource. }
