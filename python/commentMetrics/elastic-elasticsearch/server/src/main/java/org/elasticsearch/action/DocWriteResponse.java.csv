commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public byte getOp() {     return op. }
false;public;0;3;;public String getLowercase() {     return lowercase. }
false;public,static;1;17;;public static Result readFrom(StreamInput in) throws IOException {     Byte opcode = in.readByte().     switch(opcode) {         case 0:             return CREATED.         case 1:             return UPDATED.         case 2:             return DELETED.         case 3:             return NOT_FOUND.         case 4:             return NOOP.         default:             throw new IllegalArgumentException("Unknown result code: " + opcode).     } }
false;public;1;4;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeByte(op). }
true;public;0;3;/**  * The change that occurred to the document.  */ ;/**  * The change that occurred to the document.  */ public Result getResult() {     return result. }
true;public;0;3;/**  * The index the document was changed in.  */ ;/**  * The index the document was changed in.  */ public String getIndex() {     return this.shardId.getIndexName(). }
true;public;0;3;/**  * The exact shard the document was changed in.  */ ;/**  * The exact shard the document was changed in.  */ public ShardId getShardId() {     return this.shardId. }
true;public;0;4;/**  * The type of the document changed.  *  * @deprecated Types are in the process of being removed.  */ ;/**  * The type of the document changed.  *  * @deprecated Types are in the process of being removed.  */ @Deprecated public String getType() {     return this.type. }
true;public;0;3;/**  * The id of the document changed.  */ ;/**  * The id of the document changed.  */ public String getId() {     return this.id. }
true;public;0;3;/**  * Returns the current version of the doc.  */ ;/**  * Returns the current version of the doc.  */ public long getVersion() {     return this.version. }
true;public;0;3;/**  * Returns the sequence number assigned for this change. Returns {@link SequenceNumbers#UNASSIGNED_SEQ_NO} if the operation  * wasn't performed (i.e., an update operation that resulted in a NOOP).  */ ;/**  * Returns the sequence number assigned for this change. Returns {@link SequenceNumbers#UNASSIGNED_SEQ_NO} if the operation  * wasn't performed (i.e., an update operation that resulted in a NOOP).  */ public long getSeqNo() {     return seqNo. }
true;public;0;3;/**  * The primary term for this change.  *  * @return the primary term  */ ;/**  * The primary term for this change.  *  * @return the primary term  */ public long getPrimaryTerm() {     return primaryTerm. }
true;public;0;3;/**  * Did this request force a refresh? Requests that set {@link WriteRequest#setRefreshPolicy(RefreshPolicy)} to  * {@link RefreshPolicy#IMMEDIATE} will always return true for this. Requests that set it to {@link RefreshPolicy#WAIT_UNTIL} will  * only return true here if they run out of refresh listener slots (see {@link IndexSettings#MAX_REFRESH_LISTENERS_PER_SHARD}).  */ ;/**  * Did this request force a refresh? Requests that set {@link WriteRequest#setRefreshPolicy(RefreshPolicy)} to  * {@link RefreshPolicy#IMMEDIATE} will always return true for this. Requests that set it to {@link RefreshPolicy#WAIT_UNTIL} will  * only return true here if they run out of refresh listener slots (see {@link IndexSettings#MAX_REFRESH_LISTENERS_PER_SHARD}).  */ public boolean forcedRefresh() {     return forcedRefresh. }
false;public;1;4;;@Override public void setForcedRefresh(boolean forcedRefresh) {     this.forcedRefresh = forcedRefresh. }
true;public;0;4;/**  * returns the rest status for this response (based on {@link ShardInfo#status()}  */ ;/**  * returns the rest status for this response (based on {@link ShardInfo#status()}  */ @Override public RestStatus status() {     return getShardInfo().status(). }
true;public;1;32;/**  * Return the relative URI for the location of the document suitable for use in the {@code Location} header. The use of relative URIs is  * permitted as of HTTP/1.1 (cf. https://tools.ietf.org/html/rfc7231#section-7.1.2).  *  * @param routing custom routing or {@code null} if custom routing is not used  * @return the relative URI for the location of the document  */ ;/**  * Return the relative URI for the location of the document suitable for use in the {@code Location} header. The use of relative URIs is  * permitted as of HTTP/1.1 (cf. https://tools.ietf.org/html/rfc7231#section-7.1.2).  *  * @param routing custom routing or {@code null} if custom routing is not used  * @return the relative URI for the location of the document  */ public String getLocation(@Nullable String routing) {     final String encodedIndex.     final String encodedType.     final String encodedId.     final String encodedRouting.     try {         // encode the path components separately otherwise the path separators will be encoded         encodedIndex = URLEncoder.encode(getIndex(), "UTF-8").         encodedType = URLEncoder.encode(getType(), "UTF-8").         encodedId = URLEncoder.encode(getId(), "UTF-8").         encodedRouting = routing == null ? null : URLEncoder.encode(routing, "UTF-8").     } catch (final UnsupportedEncodingException e) {         throw new AssertionError(e).     }     final String routingStart = "?routing=".     final int bufferSizeExcludingRouting = 3 + encodedIndex.length() + encodedType.length() + encodedId.length().     final int bufferSize.     if (encodedRouting == null) {         bufferSize = bufferSizeExcludingRouting.     } else {         bufferSize = bufferSizeExcludingRouting + routingStart.length() + encodedRouting.length().     }     final StringBuilder location = new StringBuilder(bufferSize).     location.append('/').append(encodedIndex).     location.append('/').append(encodedType).     location.append('/').append(encodedId).     if (encodedRouting != null) {         location.append(routingStart).append(encodedRouting).     }     return location.toString(). }
false;public;1;17;;@Override public void readFrom(StreamInput in) throws IOException {     super.readFrom(in).     shardId = ShardId.readShardId(in).     type = in.readString().     id = in.readString().     version = in.readZLong().     if (in.getVersion().onOrAfter(Version.V_6_0_0_alpha1)) {         seqNo = in.readZLong().         primaryTerm = in.readVLong().     } else {         seqNo = UNASSIGNED_SEQ_NO.         primaryTerm = UNASSIGNED_PRIMARY_TERM.     }     forcedRefresh = in.readBoolean().     result = Result.readFrom(in). }
false;public;1;14;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     shardId.writeTo(out).     out.writeString(type).     out.writeString(id).     out.writeZLong(version).     if (out.getVersion().onOrAfter(Version.V_6_0_0_alpha1)) {         out.writeZLong(seqNo).         out.writeVLong(primaryTerm).     }     out.writeBoolean(forcedRefresh).     result.writeTo(out). }
false;public,final;2;7;;@Override public final XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     innerToXContent(builder, params).     builder.endObject().     return builder. }
false;public;2;17;;public XContentBuilder innerToXContent(XContentBuilder builder, Params params) throws IOException {     ReplicationResponse.ShardInfo shardInfo = getShardInfo().     builder.field(_INDEX, shardId.getIndexName()).     builder.field(_TYPE, type).     builder.field(_ID, id).field(_VERSION, version).field(RESULT, getResult().getLowercase()).     if (forcedRefresh) {         builder.field(FORCED_REFRESH, true).     }     builder.field(_SHARDS, shardInfo).     if (getSeqNo() >= 0) {         builder.field(_SEQ_NO, getSeqNo()).         builder.field(_PRIMARY_TERM, getPrimaryTerm()).     }     return builder. }
true;protected,static;2;42;/**  * Parse the output of the {@link #innerToXContent(XContentBuilder, Params)} method.  *  * This method is intended to be called by subclasses and must be called multiple times to parse all the information concerning  * {@link DocWriteResponse} objects. It always parses the current token, updates the given parsing context accordingly  * if needed and then immediately returns.  */ ;/**  * Parse the output of the {@link #innerToXContent(XContentBuilder, Params)} method.  *  * This method is intended to be called by subclasses and must be called multiple times to parse all the information concerning  * {@link DocWriteResponse} objects. It always parses the current token, updates the given parsing context accordingly  * if needed and then immediately returns.  */ protected static void parseInnerToXContent(XContentParser parser, Builder context) throws IOException {     XContentParser.Token token = parser.currentToken().     ensureExpectedToken(XContentParser.Token.FIELD_NAME, token, parser::getTokenLocation).     String currentFieldName = parser.currentName().     token = parser.nextToken().     if (token.isValue()) {         if (_INDEX.equals(currentFieldName)) {             // index uuid and shard id are unknown and can't be parsed back for now.             context.setShardId(new ShardId(new Index(parser.text(), IndexMetaData.INDEX_UUID_NA_VALUE), -1)).         } else if (_TYPE.equals(currentFieldName)) {             context.setType(parser.text()).         } else if (_ID.equals(currentFieldName)) {             context.setId(parser.text()).         } else if (_VERSION.equals(currentFieldName)) {             context.setVersion(parser.longValue()).         } else if (RESULT.equals(currentFieldName)) {             String result = parser.text().             for (Result r : Result.values()) {                 if (r.getLowercase().equals(result)) {                     context.setResult(r).                     break.                 }             }         } else if (FORCED_REFRESH.equals(currentFieldName)) {             context.setForcedRefresh(parser.booleanValue()).         } else if (_SEQ_NO.equals(currentFieldName)) {             context.setSeqNo(parser.longValue()).         } else if (_PRIMARY_TERM.equals(currentFieldName)) {             context.setPrimaryTerm(parser.longValue()).         }     } else if (token == XContentParser.Token.START_OBJECT) {         if (_SHARDS.equals(currentFieldName)) {             context.setShardInfo(ShardInfo.fromXContent(parser)).         } else {             // skip potential inner objects for forward compatibility             parser.skipChildren().         }     } else if (token == XContentParser.Token.START_ARRAY) {         // skip potential inner arrays for forward compatibility         parser.skipChildren().     } }
false;public;0;3;;public ShardId getShardId() {     return shardId. }
false;public;1;3;;public void setShardId(ShardId shardId) {     this.shardId = shardId. }
false;public;0;3;;public String getType() {     return type. }
false;public;1;3;;public void setType(String type) {     this.type = type. }
false;public;0;3;;public String getId() {     return id. }
false;public;1;3;;public void setId(String id) {     this.id = id. }
false;public;1;3;;public void setVersion(Long version) {     this.version = version. }
false;public;1;3;;public void setResult(Result result) {     this.result = result. }
false;public;1;3;;public void setForcedRefresh(boolean forcedRefresh) {     this.forcedRefresh = forcedRefresh. }
false;public;1;3;;public void setShardInfo(ShardInfo shardInfo) {     this.shardInfo = shardInfo. }
false;public;1;3;;public void setSeqNo(Long seqNo) {     this.seqNo = seqNo. }
false;public;1;3;;public void setPrimaryTerm(Long primaryTerm) {     this.primaryTerm = primaryTerm. }
false;public,abstract;0;1;;public abstract DocWriteResponse build().
