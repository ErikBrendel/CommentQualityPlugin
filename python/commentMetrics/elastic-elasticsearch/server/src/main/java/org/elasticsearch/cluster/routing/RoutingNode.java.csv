commented;modifiers;parameterAmount;loc;comment;code
false;private,static;1;11;;private static LinkedHashMap<ShardId, ShardRouting> buildShardRoutingMap(ShardRouting... shardRoutings) {     final LinkedHashMap<ShardId, ShardRouting> shards = new LinkedHashMap<>().     for (ShardRouting shardRouting : shardRoutings) {         ShardRouting previousValue = shards.put(shardRouting.shardId(), shardRouting).         if (previousValue != null) {             throw new IllegalArgumentException("Cannot have two different shards with same shard id " + shardRouting.shardId() + " on same node ").         }     }     return shards. }
false;public;0;4;;@Override public Iterator<ShardRouting> iterator() {     return Collections.unmodifiableCollection(shards.values()).iterator(). }
true;public;0;3;/**  * Returns the nodes {@link DiscoveryNode}.  *  * @return discoveryNode of this node  */ ;/**  * Returns the nodes {@link DiscoveryNode}.  *  * @return discoveryNode of this node  */ public DiscoveryNode node() {     return this.node. }
false;public;1;4;;@Nullable public ShardRouting getByShardId(ShardId id) {     return shards.get(id). }
true;public;0;3;/**  * Get the id of this node  * @return id of the node  */ ;/**  * Get the id of this node  * @return id of the node  */ public String nodeId() {     return this.nodeId. }
false;public;0;3;;public int size() {     return shards.size(). }
true;;1;7;/**  * Add a new shard to this node  * @param shard Shard to crate on this Node  */ ;/**  * Add a new shard to this node  * @param shard Shard to crate on this Node  */ void add(ShardRouting shard) {     if (shards.containsKey(shard.shardId())) {         throw new IllegalStateException("Trying to add a shard " + shard.shardId() + " to a node [" + nodeId + "] where it already exists. current [" + shards.get(shard.shardId()) + "]. new [" + shard + "]").     }     shards.put(shard.shardId(), shard). }
false;;2;9;;void update(ShardRouting oldShard, ShardRouting newShard) {     if (shards.containsKey(oldShard.shardId()) == false) {         // TODO: change caller logic in RoutingNodes so that this check can go away         return.     }     ShardRouting previousValue = shards.put(newShard.shardId(), newShard).     assert previousValue == oldShard : "expected shard " + previousValue + " but was " + oldShard. }
false;;1;4;;void remove(ShardRouting shard) {     ShardRouting previousValue = shards.remove(shard.shardId()).     assert previousValue == shard : "expected shard " + previousValue + " but was " + shard. }
true;public;1;11;/**  * Determine the number of shards with a specific state  * @param states set of states which should be counted  * @return number of shards  */ ;/**  * Determine the number of shards with a specific state  * @param states set of states which should be counted  * @return number of shards  */ public int numberOfShardsWithState(ShardRoutingState... states) {     int count = 0.     for (ShardRouting shardEntry : this) {         for (ShardRoutingState state : states) {             if (shardEntry.state() == state) {                 count++.             }         }     }     return count. }
true;public;1;11;/**  * Determine the shards with a specific state  * @param states set of states which should be listed  * @return List of shards  */ ;/**  * Determine the shards with a specific state  * @param states set of states which should be listed  * @return List of shards  */ public List<ShardRouting> shardsWithState(ShardRoutingState... states) {     List<ShardRouting> shards = new ArrayList<>().     for (ShardRouting shardEntry : this) {         for (ShardRoutingState state : states) {             if (shardEntry.state() == state) {                 shards.add(shardEntry).             }         }     }     return shards. }
true;public;2;15;/**  * Determine the shards of an index with a specific state  * @param index id of the index  * @param states set of states which should be listed  * @return a list of shards  */ ;/**  * Determine the shards of an index with a specific state  * @param index id of the index  * @param states set of states which should be listed  * @return a list of shards  */ public List<ShardRouting> shardsWithState(String index, ShardRoutingState... states) {     List<ShardRouting> shards = new ArrayList<>().     for (ShardRouting shardEntry : this) {         if (!shardEntry.getIndexName().equals(index)) {             continue.         }         for (ShardRoutingState state : states) {             if (shardEntry.state() == state) {                 shards.add(shardEntry).             }         }     }     return shards. }
true;public;0;10;/**  * The number of shards on this node that will not be eventually relocated.  */ ;/**  * The number of shards on this node that will not be eventually relocated.  */ public int numberOfOwningShards() {     int count = 0.     for (ShardRouting shardEntry : this) {         if (shardEntry.state() != ShardRoutingState.RELOCATING) {             count++.         }     }     return count. }
false;public;0;8;;public String prettyPrint() {     StringBuilder sb = new StringBuilder().     sb.append("-----node_id[").append(nodeId).append("][").append(node == null ? "X" : "V").append("]\n").     for (ShardRouting entry : shards.values()) {         sb.append("--------").append(entry.shortSummary()).append('\n').     }     return sb.toString(). }
false;public;0;15;;public String toString() {     StringBuilder sb = new StringBuilder().     sb.append("routingNode ([").     sb.append(node.getName()).     sb.append("][").     sb.append(node.getId()).     sb.append("][").     sb.append(node.getHostName()).     sb.append("][").     sb.append(node.getHostAddress()).     sb.append("], [").     sb.append(shards.size()).     sb.append(" assigned shards])").     return sb.toString(). }
false;public;0;3;;public List<ShardRouting> copyShards() {     return new ArrayList<>(shards.values()). }
false;public;0;3;;public boolean isEmpty() {     return shards.isEmpty(). }
