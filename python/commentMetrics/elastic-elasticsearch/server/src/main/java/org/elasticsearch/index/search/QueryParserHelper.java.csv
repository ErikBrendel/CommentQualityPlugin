# id;timestamp;commentText;codeText;commentWords;codeWords
QueryParserHelper -> public static FieldMapper getFieldMapper(MapperService mapperService, String field);1524684173;Get a {@link FieldMapper} associated with a field name or null._@param mapperService The mapper service where to find the mapping._@param field The field name to search.;public static FieldMapper getFieldMapper(MapperService mapperService, String field) {_        DocumentMapper mapper = mapperService.documentMapper()__        if (mapper != null) {_            FieldMapper fieldMapper = mapper.mappers().smartNameFieldMapper(field)__            if (fieldMapper != null) {_                return fieldMapper__            }_        }_        return null__    };get,a,link,field,mapper,associated,with,a,field,name,or,null,param,mapper,service,the,mapper,service,where,to,find,the,mapping,param,field,the,field,name,to,search;public,static,field,mapper,get,field,mapper,mapper,service,mapper,service,string,field,document,mapper,mapper,mapper,service,document,mapper,if,mapper,null,field,mapper,field,mapper,mapper,mappers,smart,name,field,mapper,field,if,field,mapper,null,return,field,mapper,return,null
QueryParserHelper -> public static FieldMapper getFieldMapper(MapperService mapperService, String field);1528706846;Get a {@link FieldMapper} associated with a field name or null._@param mapperService The mapper service where to find the mapping._@param field The field name to search.;public static FieldMapper getFieldMapper(MapperService mapperService, String field) {_        DocumentMapper mapper = mapperService.documentMapper()__        if (mapper != null) {_            FieldMapper fieldMapper = mapper.mappers().getMapper(field)__            if (fieldMapper != null) {_                return fieldMapper__            }_        }_        return null__    };get,a,link,field,mapper,associated,with,a,field,name,or,null,param,mapper,service,the,mapper,service,where,to,find,the,mapping,param,field,the,field,name,to,search;public,static,field,mapper,get,field,mapper,mapper,service,mapper,service,string,field,document,mapper,mapper,mapper,service,document,mapper,if,mapper,null,field,mapper,field,mapper,mapper,mappers,get,mapper,field,if,field,mapper,null,return,field,mapper,return,null
QueryParserHelper -> public static Map<String, Float> parseFieldsAndWeights(List<String> fields);1524684173;Convert a list of field names encoded with optional boosts to a map that associates_the field name and its boost._@param fields The list of fields encoded with optional boosts (e.g. ^0.35)._@return The converted map with field names and associated boosts.;public static Map<String, Float> parseFieldsAndWeights(List<String> fields) {_        final Map<String, Float> fieldsAndWeights = new HashMap<>()__        for (String field : fields) {_            int boostIndex = field.indexOf('^')__            String fieldName__            float boost = 1.0f__            if (boostIndex != -1) {_                fieldName = field.substring(0, boostIndex)__                boost = Float.parseFloat(field.substring(boostIndex+1, field.length()))__            } else {_                fieldName = field__            }_            fieldsAndWeights.put(fieldName, boost)__        }_        return fieldsAndWeights__    };convert,a,list,of,field,names,encoded,with,optional,boosts,to,a,map,that,associates,the,field,name,and,its,boost,param,fields,the,list,of,fields,encoded,with,optional,boosts,e,g,0,35,return,the,converted,map,with,field,names,and,associated,boosts;public,static,map,string,float,parse,fields,and,weights,list,string,fields,final,map,string,float,fields,and,weights,new,hash,map,for,string,field,fields,int,boost,index,field,index,of,string,field,name,float,boost,1,0f,if,boost,index,1,field,name,field,substring,0,boost,index,boost,float,parse,float,field,substring,boost,index,1,field,length,else,field,name,field,fields,and,weights,put,field,name,boost,return,fields,and,weights
QueryParserHelper -> public static Map<String, Float> parseFieldsAndWeights(List<String> fields);1528706846;Convert a list of field names encoded with optional boosts to a map that associates_the field name and its boost._@param fields The list of fields encoded with optional boosts (e.g. ^0.35)._@return The converted map with field names and associated boosts.;public static Map<String, Float> parseFieldsAndWeights(List<String> fields) {_        final Map<String, Float> fieldsAndWeights = new HashMap<>()__        for (String field : fields) {_            int boostIndex = field.indexOf('^')__            String fieldName__            float boost = 1.0f__            if (boostIndex != -1) {_                fieldName = field.substring(0, boostIndex)__                boost = Float.parseFloat(field.substring(boostIndex+1, field.length()))__            } else {_                fieldName = field__            }_            fieldsAndWeights.put(fieldName, boost)__        }_        return fieldsAndWeights__    };convert,a,list,of,field,names,encoded,with,optional,boosts,to,a,map,that,associates,the,field,name,and,its,boost,param,fields,the,list,of,fields,encoded,with,optional,boosts,e,g,0,35,return,the,converted,map,with,field,names,and,associated,boosts;public,static,map,string,float,parse,fields,and,weights,list,string,fields,final,map,string,float,fields,and,weights,new,hash,map,for,string,field,fields,int,boost,index,field,index,of,string,field,name,float,boost,1,0f,if,boost,index,1,field,name,field,substring,0,boost,index,boost,float,parse,float,field,substring,boost,index,1,field,length,else,field,name,field,fields,and,weights,put,field,name,boost,return,fields,and,weights
QueryParserHelper -> public static Map<String, Float> parseFieldsAndWeights(List<String> fields);1531937412;Convert a list of field names encoded with optional boosts to a map that associates_the field name and its boost._@param fields The list of fields encoded with optional boosts (e.g. ^0.35)._@return The converted map with field names and associated boosts.;public static Map<String, Float> parseFieldsAndWeights(List<String> fields) {_        final Map<String, Float> fieldsAndWeights = new HashMap<>()__        for (String field : fields) {_            int boostIndex = field.indexOf('^')__            String fieldName__            float boost = 1.0f__            if (boostIndex != -1) {_                fieldName = field.substring(0, boostIndex)__                boost = Float.parseFloat(field.substring(boostIndex+1, field.length()))__            } else {_                fieldName = field__            }_            fieldsAndWeights.put(fieldName, boost)__        }_        return fieldsAndWeights__    };convert,a,list,of,field,names,encoded,with,optional,boosts,to,a,map,that,associates,the,field,name,and,its,boost,param,fields,the,list,of,fields,encoded,with,optional,boosts,e,g,0,35,return,the,converted,map,with,field,names,and,associated,boosts;public,static,map,string,float,parse,fields,and,weights,list,string,fields,final,map,string,float,fields,and,weights,new,hash,map,for,string,field,fields,int,boost,index,field,index,of,string,field,name,float,boost,1,0f,if,boost,index,1,field,name,field,substring,0,boost,index,boost,float,parse,float,field,substring,boost,index,1,field,length,else,field,name,field,fields,and,weights,put,field,name,boost,return,fields,and,weights
QueryParserHelper -> public static Map<String, Float> parseFieldsAndWeights(List<String> fields);1535046779;Convert a list of field names encoded with optional boosts to a map that associates_the field name and its boost._@param fields The list of fields encoded with optional boosts (e.g. ^0.35)._@return The converted map with field names and associated boosts.;public static Map<String, Float> parseFieldsAndWeights(List<String> fields) {_        final Map<String, Float> fieldsAndWeights = new HashMap<>()__        for (String field : fields) {_            int boostIndex = field.indexOf('^')__            String fieldName__            float boost = 1.0f__            if (boostIndex != -1) {_                fieldName = field.substring(0, boostIndex)__                boost = Float.parseFloat(field.substring(boostIndex+1, field.length()))__            } else {_                fieldName = field__            }_            fieldsAndWeights.put(fieldName, boost)__        }_        return fieldsAndWeights__    };convert,a,list,of,field,names,encoded,with,optional,boosts,to,a,map,that,associates,the,field,name,and,its,boost,param,fields,the,list,of,fields,encoded,with,optional,boosts,e,g,0,35,return,the,converted,map,with,field,names,and,associated,boosts;public,static,map,string,float,parse,fields,and,weights,list,string,fields,final,map,string,float,fields,and,weights,new,hash,map,for,string,field,fields,int,boost,index,field,index,of,string,field,name,float,boost,1,0f,if,boost,index,1,field,name,field,substring,0,boost,index,boost,float,parse,float,field,substring,boost,index,1,field,length,else,field,name,field,fields,and,weights,put,field,name,boost,return,fields,and,weights
QueryParserHelper -> public static Map<String, Float> parseFieldsAndWeights(List<String> fields);1541693080;Convert a list of field names encoded with optional boosts to a map that associates_the field name and its boost._@param fields The list of fields encoded with optional boosts (e.g. ^0.35)._@return The converted map with field names and associated boosts.;public static Map<String, Float> parseFieldsAndWeights(List<String> fields) {_        final Map<String, Float> fieldsAndWeights = new HashMap<>()__        for (String field : fields) {_            int boostIndex = field.indexOf('^')__            String fieldName__            float boost = 1.0f__            if (boostIndex != -1) {_                fieldName = field.substring(0, boostIndex)__                boost = Float.parseFloat(field.substring(boostIndex+1, field.length()))__            } else {_                fieldName = field__            }_            fieldsAndWeights.put(fieldName, boost)__        }_        return fieldsAndWeights__    };convert,a,list,of,field,names,encoded,with,optional,boosts,to,a,map,that,associates,the,field,name,and,its,boost,param,fields,the,list,of,fields,encoded,with,optional,boosts,e,g,0,35,return,the,converted,map,with,field,names,and,associated,boosts;public,static,map,string,float,parse,fields,and,weights,list,string,fields,final,map,string,float,fields,and,weights,new,hash,map,for,string,field,fields,int,boost,index,field,index,of,string,field,name,float,boost,1,0f,if,boost,index,1,field,name,field,substring,0,boost,index,boost,float,parse,float,field,substring,boost,index,1,field,length,else,field,name,field,fields,and,weights,put,field,name,boost,return,fields,and,weights
QueryParserHelper -> public static Map<String, Float> parseFieldsAndWeights(List<String> fields);1544600864;Convert a list of field names encoded with optional boosts to a map that associates_the field name and its boost._@param fields The list of fields encoded with optional boosts (e.g. ^0.35)._@return The converted map with field names and associated boosts.;public static Map<String, Float> parseFieldsAndWeights(List<String> fields) {_        final Map<String, Float> fieldsAndWeights = new HashMap<>()__        for (String field : fields) {_            int boostIndex = field.indexOf('^')__            String fieldName__            float boost = 1.0f__            if (boostIndex != -1) {_                fieldName = field.substring(0, boostIndex)__                boost = Float.parseFloat(field.substring(boostIndex+1, field.length()))__            } else {_                fieldName = field__            }_            fieldsAndWeights.put(fieldName, boost)__        }_        return fieldsAndWeights__    };convert,a,list,of,field,names,encoded,with,optional,boosts,to,a,map,that,associates,the,field,name,and,its,boost,param,fields,the,list,of,fields,encoded,with,optional,boosts,e,g,0,35,return,the,converted,map,with,field,names,and,associated,boosts;public,static,map,string,float,parse,fields,and,weights,list,string,fields,final,map,string,float,fields,and,weights,new,hash,map,for,string,field,fields,int,boost,index,field,index,of,string,field,name,float,boost,1,0f,if,boost,index,1,field,name,field,substring,0,boost,index,boost,float,parse,float,field,substring,boost,index,1,field,length,else,field,name,field,fields,and,weights,put,field,name,boost,return,fields,and,weights
QueryParserHelper -> public static Map<String, Float> resolveMappingField(QueryShardContext context, String fieldOrPattern, float weight,                                                          boolean acceptAllTypes, boolean acceptMetadataField, String fieldSuffix);1524684173;Resolves the provided pattern or field name from the {@link QueryShardContext} and return a map of_the expanded fields with their original boost._@param context The context of the query_@param fieldOrPattern The field name or the pattern to resolve_@param weight The weight for the field_@param acceptAllTypes Whether all field type should be added when a pattern is expanded._If false, only {@link #ALLOWED_QUERY_MAPPER_TYPES} are accepted and other field types_are discarded from the query._@param acceptMetadataField Whether metadata fields should be added when a pattern is expanded._@param fieldSuffix The suffix name to add to the expanded field names if a mapping exists for that name._The original name of the field is kept if adding the suffix to the field name does not point to a valid field_in the mapping.;public static Map<String, Float> resolveMappingField(QueryShardContext context, String fieldOrPattern, float weight,_                                                         boolean acceptAllTypes, boolean acceptMetadataField, String fieldSuffix) {_        Collection<String> allFields = context.simpleMatchToIndexNames(fieldOrPattern)__        Map<String, Float> fields = new HashMap<>()__        for (String fieldName : allFields) {_            if (fieldSuffix != null && context.fieldMapper(fieldName + fieldSuffix) != null) {_                fieldName = fieldName + fieldSuffix__            }_            FieldMapper mapper = getFieldMapper(context.getMapperService(), fieldName)__            if (mapper == null) {_                _                fields.put(fieldOrPattern, weight)__                continue__            }_            if (acceptMetadataField == false && mapper instanceof MetadataFieldMapper) {_                _                continue__            }_            _            _            _            String mappingType = mapper.fieldType().typeName()__            if (acceptAllTypes == false && ALLOWED_QUERY_MAPPER_TYPES.contains(mappingType) == false) {_                continue__            }_            fields.put(fieldName, weight)__        }_        checkForTooManyFields(fields)__        return fields__    };resolves,the,provided,pattern,or,field,name,from,the,link,query,shard,context,and,return,a,map,of,the,expanded,fields,with,their,original,boost,param,context,the,context,of,the,query,param,field,or,pattern,the,field,name,or,the,pattern,to,resolve,param,weight,the,weight,for,the,field,param,accept,all,types,whether,all,field,type,should,be,added,when,a,pattern,is,expanded,if,false,only,link,are,accepted,and,other,field,types,are,discarded,from,the,query,param,accept,metadata,field,whether,metadata,fields,should,be,added,when,a,pattern,is,expanded,param,field,suffix,the,suffix,name,to,add,to,the,expanded,field,names,if,a,mapping,exists,for,that,name,the,original,name,of,the,field,is,kept,if,adding,the,suffix,to,the,field,name,does,not,point,to,a,valid,field,in,the,mapping;public,static,map,string,float,resolve,mapping,field,query,shard,context,context,string,field,or,pattern,float,weight,boolean,accept,all,types,boolean,accept,metadata,field,string,field,suffix,collection,string,all,fields,context,simple,match,to,index,names,field,or,pattern,map,string,float,fields,new,hash,map,for,string,field,name,all,fields,if,field,suffix,null,context,field,mapper,field,name,field,suffix,null,field,name,field,name,field,suffix,field,mapper,mapper,get,field,mapper,context,get,mapper,service,field,name,if,mapper,null,fields,put,field,or,pattern,weight,continue,if,accept,metadata,field,false,mapper,instanceof,metadata,field,mapper,continue,string,mapping,type,mapper,field,type,type,name,if,accept,all,types,false,contains,mapping,type,false,continue,fields,put,field,name,weight,check,for,too,many,fields,fields,return,fields
QueryParserHelper -> public static Map<String, Float> resolveMappingField(QueryShardContext context, String fieldOrPattern, float weight,                                                          boolean acceptAllTypes, boolean acceptMetadataField, String fieldSuffix);1528706846;Resolves the provided pattern or field name from the {@link QueryShardContext} and return a map of_the expanded fields with their original boost._@param context The context of the query_@param fieldOrPattern The field name or the pattern to resolve_@param weight The weight for the field_@param acceptAllTypes Whether all field type should be added when a pattern is expanded._If false, only {@link #ALLOWED_QUERY_MAPPER_TYPES} are accepted and other field types_are discarded from the query._@param acceptMetadataField Whether metadata fields should be added when a pattern is expanded._@param fieldSuffix The suffix name to add to the expanded field names if a mapping exists for that name._The original name of the field is kept if adding the suffix to the field name does not point to a valid field_in the mapping.;public static Map<String, Float> resolveMappingField(QueryShardContext context, String fieldOrPattern, float weight,_                                                         boolean acceptAllTypes, boolean acceptMetadataField, String fieldSuffix) {_        Collection<String> allFields = context.simpleMatchToIndexNames(fieldOrPattern)__        Map<String, Float> fields = new HashMap<>()__        for (String fieldName : allFields) {_            if (fieldSuffix != null && context.fieldMapper(fieldName + fieldSuffix) != null) {_                fieldName = fieldName + fieldSuffix__            }_            FieldMapper mapper = getFieldMapper(context.getMapperService(), fieldName)__            if (mapper == null) {_                _                fields.put(fieldOrPattern, weight)__                continue__            }_            if (acceptMetadataField == false && mapper instanceof MetadataFieldMapper) {_                _                continue__            }_            _            _            _            String mappingType = mapper.fieldType().typeName()__            if (acceptAllTypes == false && ALLOWED_QUERY_MAPPER_TYPES.contains(mappingType) == false) {_                continue__            }_            fields.put(fieldName, weight)__        }_        checkForTooManyFields(fields)__        return fields__    };resolves,the,provided,pattern,or,field,name,from,the,link,query,shard,context,and,return,a,map,of,the,expanded,fields,with,their,original,boost,param,context,the,context,of,the,query,param,field,or,pattern,the,field,name,or,the,pattern,to,resolve,param,weight,the,weight,for,the,field,param,accept,all,types,whether,all,field,type,should,be,added,when,a,pattern,is,expanded,if,false,only,link,are,accepted,and,other,field,types,are,discarded,from,the,query,param,accept,metadata,field,whether,metadata,fields,should,be,added,when,a,pattern,is,expanded,param,field,suffix,the,suffix,name,to,add,to,the,expanded,field,names,if,a,mapping,exists,for,that,name,the,original,name,of,the,field,is,kept,if,adding,the,suffix,to,the,field,name,does,not,point,to,a,valid,field,in,the,mapping;public,static,map,string,float,resolve,mapping,field,query,shard,context,context,string,field,or,pattern,float,weight,boolean,accept,all,types,boolean,accept,metadata,field,string,field,suffix,collection,string,all,fields,context,simple,match,to,index,names,field,or,pattern,map,string,float,fields,new,hash,map,for,string,field,name,all,fields,if,field,suffix,null,context,field,mapper,field,name,field,suffix,null,field,name,field,name,field,suffix,field,mapper,mapper,get,field,mapper,context,get,mapper,service,field,name,if,mapper,null,fields,put,field,or,pattern,weight,continue,if,accept,metadata,field,false,mapper,instanceof,metadata,field,mapper,continue,string,mapping,type,mapper,field,type,type,name,if,accept,all,types,false,contains,mapping,type,false,continue,fields,put,field,name,weight,check,for,too,many,fields,fields,return,fields
QueryParserHelper -> public static Map<String, Float> resolveMappingField(QueryShardContext context, String fieldOrPattern, float weight,                                                          boolean acceptAllTypes, boolean acceptMetadataField, String fieldSuffix);1531937412;Resolves the provided pattern or field name from the {@link QueryShardContext} and return a map of_the expanded fields with their original boost._@param context The context of the query_@param fieldOrPattern The field name or the pattern to resolve_@param weight The weight for the field_@param acceptAllTypes Whether all field type should be added when a pattern is expanded._If false, only {@link #ALLOWED_QUERY_MAPPER_TYPES} are accepted and other field types_are discarded from the query._@param acceptMetadataField Whether metadata fields should be added when a pattern is expanded._@param fieldSuffix The suffix name to add to the expanded field names if a mapping exists for that name._The original name of the field is kept if adding the suffix to the field name does not point to a valid field_in the mapping.;public static Map<String, Float> resolveMappingField(QueryShardContext context, String fieldOrPattern, float weight,_                                                         boolean acceptAllTypes, boolean acceptMetadataField, String fieldSuffix) {_        Collection<String> allFields = context.simpleMatchToIndexNames(fieldOrPattern)__        Map<String, Float> fields = new HashMap<>()__        for (String fieldName : allFields) {_            if (fieldSuffix != null && context.fieldMapper(fieldName + fieldSuffix) != null) {_                fieldName = fieldName + fieldSuffix__            }__            MappedFieldType fieldType = context.getMapperService().fullName(fieldName)__            if (fieldType == null) {_                _                fields.put(fieldName, weight)__                continue__            }__            _            _            _            String mappingType = fieldType.typeName()__            if (acceptAllTypes == false && ALLOWED_QUERY_MAPPER_TYPES.contains(mappingType) == false) {_                continue__            }__            _            Mapper mapper = getFieldMapper(context.getMapperService(), fieldName)__            if (acceptMetadataField == false && mapper instanceof MetadataFieldMapper) {_                continue__            }_            fields.put(fieldName, weight)__        }_        checkForTooManyFields(fields)__        return fields__    };resolves,the,provided,pattern,or,field,name,from,the,link,query,shard,context,and,return,a,map,of,the,expanded,fields,with,their,original,boost,param,context,the,context,of,the,query,param,field,or,pattern,the,field,name,or,the,pattern,to,resolve,param,weight,the,weight,for,the,field,param,accept,all,types,whether,all,field,type,should,be,added,when,a,pattern,is,expanded,if,false,only,link,are,accepted,and,other,field,types,are,discarded,from,the,query,param,accept,metadata,field,whether,metadata,fields,should,be,added,when,a,pattern,is,expanded,param,field,suffix,the,suffix,name,to,add,to,the,expanded,field,names,if,a,mapping,exists,for,that,name,the,original,name,of,the,field,is,kept,if,adding,the,suffix,to,the,field,name,does,not,point,to,a,valid,field,in,the,mapping;public,static,map,string,float,resolve,mapping,field,query,shard,context,context,string,field,or,pattern,float,weight,boolean,accept,all,types,boolean,accept,metadata,field,string,field,suffix,collection,string,all,fields,context,simple,match,to,index,names,field,or,pattern,map,string,float,fields,new,hash,map,for,string,field,name,all,fields,if,field,suffix,null,context,field,mapper,field,name,field,suffix,null,field,name,field,name,field,suffix,mapped,field,type,field,type,context,get,mapper,service,full,name,field,name,if,field,type,null,fields,put,field,name,weight,continue,string,mapping,type,field,type,type,name,if,accept,all,types,false,contains,mapping,type,false,continue,mapper,mapper,get,field,mapper,context,get,mapper,service,field,name,if,accept,metadata,field,false,mapper,instanceof,metadata,field,mapper,continue,fields,put,field,name,weight,check,for,too,many,fields,fields,return,fields
QueryParserHelper -> public static Map<String, Float> resolveMappingField(QueryShardContext context, String fieldOrPattern, float weight,                                                          boolean acceptAllTypes, boolean acceptMetadataField, String fieldSuffix);1535046779;Resolves the provided pattern or field name from the {@link QueryShardContext} and return a map of_the expanded fields with their original boost._@param context The context of the query_@param fieldOrPattern The field name or the pattern to resolve_@param weight The weight for the field_@param acceptAllTypes Whether all field type should be added when a pattern is expanded._If false, only searchable field types are added._@param acceptMetadataField Whether metadata fields should be added when a pattern is expanded._@param fieldSuffix The suffix name to add to the expanded field names if a mapping exists for that name._The original name of the field is kept if adding the suffix to the field name does not point to a valid field_in the mapping.;public static Map<String, Float> resolveMappingField(QueryShardContext context, String fieldOrPattern, float weight,_                                                         boolean acceptAllTypes, boolean acceptMetadataField, String fieldSuffix) {_        Collection<String> allFields = context.simpleMatchToIndexNames(fieldOrPattern)__        Map<String, Float> fields = new HashMap<>()__        for (String fieldName : allFields) {_            if (fieldSuffix != null && context.fieldMapper(fieldName + fieldSuffix) != null) {_                fieldName = fieldName + fieldSuffix__            }__            MappedFieldType fieldType = context.getMapperService().fullName(fieldName)__            if (fieldType == null) {_                _                fields.put(fieldName, weight)__                continue__            }__            if (acceptMetadataField == false && fieldType.name().startsWith("_")) {_                _                continue__            }__            if (acceptAllTypes == false) {_                try {_                    fieldType.termQuery("", context)__                } catch (QueryShardException |UnsupportedOperationException e) {_                    _                    continue__                } catch (IllegalArgumentException |ElasticsearchParseException e) {_                    _                }_            }_            fields.put(fieldName, weight)__        }_        checkForTooManyFields(fields)__        return fields__    };resolves,the,provided,pattern,or,field,name,from,the,link,query,shard,context,and,return,a,map,of,the,expanded,fields,with,their,original,boost,param,context,the,context,of,the,query,param,field,or,pattern,the,field,name,or,the,pattern,to,resolve,param,weight,the,weight,for,the,field,param,accept,all,types,whether,all,field,type,should,be,added,when,a,pattern,is,expanded,if,false,only,searchable,field,types,are,added,param,accept,metadata,field,whether,metadata,fields,should,be,added,when,a,pattern,is,expanded,param,field,suffix,the,suffix,name,to,add,to,the,expanded,field,names,if,a,mapping,exists,for,that,name,the,original,name,of,the,field,is,kept,if,adding,the,suffix,to,the,field,name,does,not,point,to,a,valid,field,in,the,mapping;public,static,map,string,float,resolve,mapping,field,query,shard,context,context,string,field,or,pattern,float,weight,boolean,accept,all,types,boolean,accept,metadata,field,string,field,suffix,collection,string,all,fields,context,simple,match,to,index,names,field,or,pattern,map,string,float,fields,new,hash,map,for,string,field,name,all,fields,if,field,suffix,null,context,field,mapper,field,name,field,suffix,null,field,name,field,name,field,suffix,mapped,field,type,field,type,context,get,mapper,service,full,name,field,name,if,field,type,null,fields,put,field,name,weight,continue,if,accept,metadata,field,false,field,type,name,starts,with,continue,if,accept,all,types,false,try,field,type,term,query,context,catch,query,shard,exception,unsupported,operation,exception,e,continue,catch,illegal,argument,exception,elasticsearch,parse,exception,e,fields,put,field,name,weight,check,for,too,many,fields,fields,return,fields
QueryParserHelper -> public static Map<String, Float> resolveMappingField(QueryShardContext context, String fieldOrPattern, float weight,                                                          boolean acceptAllTypes, boolean acceptMetadataField, String fieldSuffix);1541693080;Resolves the provided pattern or field name from the {@link QueryShardContext} and return a map of_the expanded fields with their original boost._@param context The context of the query_@param fieldOrPattern The field name or the pattern to resolve_@param weight The weight for the field_@param acceptAllTypes Whether all field type should be added when a pattern is expanded._If false, only searchable field types are added._@param acceptMetadataField Whether metadata fields should be added when a pattern is expanded._@param fieldSuffix The suffix name to add to the expanded field names if a mapping exists for that name._The original name of the field is kept if adding the suffix to the field name does not point to a valid field_in the mapping.;public static Map<String, Float> resolveMappingField(QueryShardContext context, String fieldOrPattern, float weight,_                                                         boolean acceptAllTypes, boolean acceptMetadataField, String fieldSuffix) {_        Collection<String> allFields = context.simpleMatchToIndexNames(fieldOrPattern)__        Map<String, Float> fields = new HashMap<>()__        for (String fieldName : allFields) {_            if (fieldSuffix != null && context.fieldMapper(fieldName + fieldSuffix) != null) {_                fieldName = fieldName + fieldSuffix__            }__            MappedFieldType fieldType = context.getMapperService().fullName(fieldName)__            if (fieldType == null) {_                _                fields.put(fieldName, weight)__                continue__            }__            if (acceptMetadataField == false && fieldType.name().startsWith("_")) {_                _                continue__            }__            if (acceptAllTypes == false) {_                try {_                    fieldType.termQuery("", context)__                } catch (QueryShardException | UnsupportedOperationException e) {_                    _                    continue__                } catch (IllegalArgumentException |ElasticsearchParseException e) {_                    _                }_            }_            fields.put(fieldName, weight)__        }_        checkForTooManyFields(fields, context)__        return fields__    };resolves,the,provided,pattern,or,field,name,from,the,link,query,shard,context,and,return,a,map,of,the,expanded,fields,with,their,original,boost,param,context,the,context,of,the,query,param,field,or,pattern,the,field,name,or,the,pattern,to,resolve,param,weight,the,weight,for,the,field,param,accept,all,types,whether,all,field,type,should,be,added,when,a,pattern,is,expanded,if,false,only,searchable,field,types,are,added,param,accept,metadata,field,whether,metadata,fields,should,be,added,when,a,pattern,is,expanded,param,field,suffix,the,suffix,name,to,add,to,the,expanded,field,names,if,a,mapping,exists,for,that,name,the,original,name,of,the,field,is,kept,if,adding,the,suffix,to,the,field,name,does,not,point,to,a,valid,field,in,the,mapping;public,static,map,string,float,resolve,mapping,field,query,shard,context,context,string,field,or,pattern,float,weight,boolean,accept,all,types,boolean,accept,metadata,field,string,field,suffix,collection,string,all,fields,context,simple,match,to,index,names,field,or,pattern,map,string,float,fields,new,hash,map,for,string,field,name,all,fields,if,field,suffix,null,context,field,mapper,field,name,field,suffix,null,field,name,field,name,field,suffix,mapped,field,type,field,type,context,get,mapper,service,full,name,field,name,if,field,type,null,fields,put,field,name,weight,continue,if,accept,metadata,field,false,field,type,name,starts,with,continue,if,accept,all,types,false,try,field,type,term,query,context,catch,query,shard,exception,unsupported,operation,exception,e,continue,catch,illegal,argument,exception,elasticsearch,parse,exception,e,fields,put,field,name,weight,check,for,too,many,fields,fields,context,return,fields
QueryParserHelper -> public static Map<String, Float> resolveMappingField(QueryShardContext context, String fieldOrPattern, float weight,                                                          boolean acceptAllTypes, boolean acceptMetadataField, String fieldSuffix);1544600864;Resolves the provided pattern or field name from the {@link QueryShardContext} and return a map of_the expanded fields with their original boost._@param context The context of the query_@param fieldOrPattern The field name or the pattern to resolve_@param weight The weight for the field_@param acceptAllTypes Whether all field type should be added when a pattern is expanded._If false, only searchable field types are added._@param acceptMetadataField Whether metadata fields should be added when a pattern is expanded._@param fieldSuffix The suffix name to add to the expanded field names if a mapping exists for that name._The original name of the field is kept if adding the suffix to the field name does not point to a valid field_in the mapping.;public static Map<String, Float> resolveMappingField(QueryShardContext context, String fieldOrPattern, float weight,_                                                         boolean acceptAllTypes, boolean acceptMetadataField, String fieldSuffix) {_        Collection<String> allFields = context.simpleMatchToIndexNames(fieldOrPattern)__        Map<String, Float> fields = new HashMap<>()__        for (String fieldName : allFields) {_            if (fieldSuffix != null && context.fieldMapper(fieldName + fieldSuffix) != null) {_                fieldName = fieldName + fieldSuffix__            }__            MappedFieldType fieldType = context.getMapperService().fullName(fieldName)__            if (fieldType == null) {_                _                fields.put(fieldName, weight)__                continue__            }__            if (acceptMetadataField == false && fieldType.name().startsWith("_")) {_                _                continue__            }__            if (acceptAllTypes == false) {_                try {_                    fieldType.termQuery("", context)__                } catch (QueryShardException | UnsupportedOperationException e) {_                    _                    continue__                } catch (IllegalArgumentException | ElasticsearchParseException e) {_                    _                }_            }_            fields.put(fieldName, weight)__        }_        checkForTooManyFields(fields, context)__        return fields__    };resolves,the,provided,pattern,or,field,name,from,the,link,query,shard,context,and,return,a,map,of,the,expanded,fields,with,their,original,boost,param,context,the,context,of,the,query,param,field,or,pattern,the,field,name,or,the,pattern,to,resolve,param,weight,the,weight,for,the,field,param,accept,all,types,whether,all,field,type,should,be,added,when,a,pattern,is,expanded,if,false,only,searchable,field,types,are,added,param,accept,metadata,field,whether,metadata,fields,should,be,added,when,a,pattern,is,expanded,param,field,suffix,the,suffix,name,to,add,to,the,expanded,field,names,if,a,mapping,exists,for,that,name,the,original,name,of,the,field,is,kept,if,adding,the,suffix,to,the,field,name,does,not,point,to,a,valid,field,in,the,mapping;public,static,map,string,float,resolve,mapping,field,query,shard,context,context,string,field,or,pattern,float,weight,boolean,accept,all,types,boolean,accept,metadata,field,string,field,suffix,collection,string,all,fields,context,simple,match,to,index,names,field,or,pattern,map,string,float,fields,new,hash,map,for,string,field,name,all,fields,if,field,suffix,null,context,field,mapper,field,name,field,suffix,null,field,name,field,name,field,suffix,mapped,field,type,field,type,context,get,mapper,service,full,name,field,name,if,field,type,null,fields,put,field,name,weight,continue,if,accept,metadata,field,false,field,type,name,starts,with,continue,if,accept,all,types,false,try,field,type,term,query,context,catch,query,shard,exception,unsupported,operation,exception,e,continue,catch,illegal,argument,exception,elasticsearch,parse,exception,e,fields,put,field,name,weight,check,for,too,many,fields,fields,context,return,fields
QueryParserHelper -> public static Map<String, Float> resolveMappingFields(QueryShardContext context,                                                           Map<String, Float> fieldsAndWeights,                                                           String fieldSuffix);1524684173;Resolve all the field names and patterns present in the provided map with the_{@link QueryShardContext} and returns a new map containing all the expanded fields with their original boost._@param context The context of the query._@param fieldsAndWeights The map of fields and weights to expand._@param fieldSuffix The suffix name to add to the expanded field names if a mapping exists for that name._The original name of the field is kept if adding the suffix to the field name does not point to a valid field_in the mapping.;public static Map<String, Float> resolveMappingFields(QueryShardContext context,_                                                          Map<String, Float> fieldsAndWeights,_                                                          String fieldSuffix) {_        Map<String, Float> resolvedFields = new HashMap<>()__        for (Map.Entry<String, Float> fieldEntry : fieldsAndWeights.entrySet()) {_            boolean allField = Regex.isMatchAllPattern(fieldEntry.getKey())__            boolean multiField = Regex.isSimpleMatchPattern(fieldEntry.getKey())__            float weight = fieldEntry.getValue() == null ? 1.0f : fieldEntry.getValue()__            Map<String, Float> fieldMap = resolveMappingField(context, fieldEntry.getKey(), weight,_                !multiField, !allField, fieldSuffix)__            resolvedFields.putAll(fieldMap)__        }_        checkForTooManyFields(resolvedFields)__        return resolvedFields__    };resolve,all,the,field,names,and,patterns,present,in,the,provided,map,with,the,link,query,shard,context,and,returns,a,new,map,containing,all,the,expanded,fields,with,their,original,boost,param,context,the,context,of,the,query,param,fields,and,weights,the,map,of,fields,and,weights,to,expand,param,field,suffix,the,suffix,name,to,add,to,the,expanded,field,names,if,a,mapping,exists,for,that,name,the,original,name,of,the,field,is,kept,if,adding,the,suffix,to,the,field,name,does,not,point,to,a,valid,field,in,the,mapping;public,static,map,string,float,resolve,mapping,fields,query,shard,context,context,map,string,float,fields,and,weights,string,field,suffix,map,string,float,resolved,fields,new,hash,map,for,map,entry,string,float,field,entry,fields,and,weights,entry,set,boolean,all,field,regex,is,match,all,pattern,field,entry,get,key,boolean,multi,field,regex,is,simple,match,pattern,field,entry,get,key,float,weight,field,entry,get,value,null,1,0f,field,entry,get,value,map,string,float,field,map,resolve,mapping,field,context,field,entry,get,key,weight,multi,field,all,field,field,suffix,resolved,fields,put,all,field,map,check,for,too,many,fields,resolved,fields,return,resolved,fields
QueryParserHelper -> public static Map<String, Float> resolveMappingFields(QueryShardContext context,                                                           Map<String, Float> fieldsAndWeights,                                                           String fieldSuffix);1528706846;Resolve all the field names and patterns present in the provided map with the_{@link QueryShardContext} and returns a new map containing all the expanded fields with their original boost._@param context The context of the query._@param fieldsAndWeights The map of fields and weights to expand._@param fieldSuffix The suffix name to add to the expanded field names if a mapping exists for that name._The original name of the field is kept if adding the suffix to the field name does not point to a valid field_in the mapping.;public static Map<String, Float> resolveMappingFields(QueryShardContext context,_                                                          Map<String, Float> fieldsAndWeights,_                                                          String fieldSuffix) {_        Map<String, Float> resolvedFields = new HashMap<>()__        for (Map.Entry<String, Float> fieldEntry : fieldsAndWeights.entrySet()) {_            boolean allField = Regex.isMatchAllPattern(fieldEntry.getKey())__            boolean multiField = Regex.isSimpleMatchPattern(fieldEntry.getKey())__            float weight = fieldEntry.getValue() == null ? 1.0f : fieldEntry.getValue()__            Map<String, Float> fieldMap = resolveMappingField(context, fieldEntry.getKey(), weight,_                !multiField, !allField, fieldSuffix)__            resolvedFields.putAll(fieldMap)__        }_        checkForTooManyFields(resolvedFields)__        return resolvedFields__    };resolve,all,the,field,names,and,patterns,present,in,the,provided,map,with,the,link,query,shard,context,and,returns,a,new,map,containing,all,the,expanded,fields,with,their,original,boost,param,context,the,context,of,the,query,param,fields,and,weights,the,map,of,fields,and,weights,to,expand,param,field,suffix,the,suffix,name,to,add,to,the,expanded,field,names,if,a,mapping,exists,for,that,name,the,original,name,of,the,field,is,kept,if,adding,the,suffix,to,the,field,name,does,not,point,to,a,valid,field,in,the,mapping;public,static,map,string,float,resolve,mapping,fields,query,shard,context,context,map,string,float,fields,and,weights,string,field,suffix,map,string,float,resolved,fields,new,hash,map,for,map,entry,string,float,field,entry,fields,and,weights,entry,set,boolean,all,field,regex,is,match,all,pattern,field,entry,get,key,boolean,multi,field,regex,is,simple,match,pattern,field,entry,get,key,float,weight,field,entry,get,value,null,1,0f,field,entry,get,value,map,string,float,field,map,resolve,mapping,field,context,field,entry,get,key,weight,multi,field,all,field,field,suffix,resolved,fields,put,all,field,map,check,for,too,many,fields,resolved,fields,return,resolved,fields
QueryParserHelper -> public static Map<String, Float> resolveMappingFields(QueryShardContext context,                                                           Map<String, Float> fieldsAndWeights,                                                           String fieldSuffix);1531937412;Resolve all the field names and patterns present in the provided map with the_{@link QueryShardContext} and returns a new map containing all the expanded fields with their original boost._@param context The context of the query._@param fieldsAndWeights The map of fields and weights to expand._@param fieldSuffix The suffix name to add to the expanded field names if a mapping exists for that name._The original name of the field is kept if adding the suffix to the field name does not point to a valid field_in the mapping.;public static Map<String, Float> resolveMappingFields(QueryShardContext context,_                                                          Map<String, Float> fieldsAndWeights,_                                                          String fieldSuffix) {_        Map<String, Float> resolvedFields = new HashMap<>()__        for (Map.Entry<String, Float> fieldEntry : fieldsAndWeights.entrySet()) {_            boolean allField = Regex.isMatchAllPattern(fieldEntry.getKey())__            boolean multiField = Regex.isSimpleMatchPattern(fieldEntry.getKey())__            float weight = fieldEntry.getValue() == null ? 1.0f : fieldEntry.getValue()__            Map<String, Float> fieldMap = resolveMappingField(context, fieldEntry.getKey(), weight,_                !multiField, !allField, fieldSuffix)__            resolvedFields.putAll(fieldMap)__        }_        checkForTooManyFields(resolvedFields)__        return resolvedFields__    };resolve,all,the,field,names,and,patterns,present,in,the,provided,map,with,the,link,query,shard,context,and,returns,a,new,map,containing,all,the,expanded,fields,with,their,original,boost,param,context,the,context,of,the,query,param,fields,and,weights,the,map,of,fields,and,weights,to,expand,param,field,suffix,the,suffix,name,to,add,to,the,expanded,field,names,if,a,mapping,exists,for,that,name,the,original,name,of,the,field,is,kept,if,adding,the,suffix,to,the,field,name,does,not,point,to,a,valid,field,in,the,mapping;public,static,map,string,float,resolve,mapping,fields,query,shard,context,context,map,string,float,fields,and,weights,string,field,suffix,map,string,float,resolved,fields,new,hash,map,for,map,entry,string,float,field,entry,fields,and,weights,entry,set,boolean,all,field,regex,is,match,all,pattern,field,entry,get,key,boolean,multi,field,regex,is,simple,match,pattern,field,entry,get,key,float,weight,field,entry,get,value,null,1,0f,field,entry,get,value,map,string,float,field,map,resolve,mapping,field,context,field,entry,get,key,weight,multi,field,all,field,field,suffix,resolved,fields,put,all,field,map,check,for,too,many,fields,resolved,fields,return,resolved,fields
QueryParserHelper -> public static Map<String, Float> resolveMappingFields(QueryShardContext context,                                                           Map<String, Float> fieldsAndWeights,                                                           String fieldSuffix);1535046779;Resolve all the field names and patterns present in the provided map with the_{@link QueryShardContext} and returns a new map containing all the expanded fields with their original boost._@param context The context of the query._@param fieldsAndWeights The map of fields and weights to expand._@param fieldSuffix The suffix name to add to the expanded field names if a mapping exists for that name._The original name of the field is kept if adding the suffix to the field name does not point to a valid field_in the mapping.;public static Map<String, Float> resolveMappingFields(QueryShardContext context,_                                                          Map<String, Float> fieldsAndWeights,_                                                          String fieldSuffix) {_        Map<String, Float> resolvedFields = new HashMap<>()__        for (Map.Entry<String, Float> fieldEntry : fieldsAndWeights.entrySet()) {_            boolean allField = Regex.isMatchAllPattern(fieldEntry.getKey())__            boolean multiField = Regex.isSimpleMatchPattern(fieldEntry.getKey())__            float weight = fieldEntry.getValue() == null ? 1.0f : fieldEntry.getValue()__            Map<String, Float> fieldMap = resolveMappingField(context, fieldEntry.getKey(), weight,_                !multiField, !allField, fieldSuffix)__            resolvedFields.putAll(fieldMap)__        }_        checkForTooManyFields(resolvedFields)__        return resolvedFields__    };resolve,all,the,field,names,and,patterns,present,in,the,provided,map,with,the,link,query,shard,context,and,returns,a,new,map,containing,all,the,expanded,fields,with,their,original,boost,param,context,the,context,of,the,query,param,fields,and,weights,the,map,of,fields,and,weights,to,expand,param,field,suffix,the,suffix,name,to,add,to,the,expanded,field,names,if,a,mapping,exists,for,that,name,the,original,name,of,the,field,is,kept,if,adding,the,suffix,to,the,field,name,does,not,point,to,a,valid,field,in,the,mapping;public,static,map,string,float,resolve,mapping,fields,query,shard,context,context,map,string,float,fields,and,weights,string,field,suffix,map,string,float,resolved,fields,new,hash,map,for,map,entry,string,float,field,entry,fields,and,weights,entry,set,boolean,all,field,regex,is,match,all,pattern,field,entry,get,key,boolean,multi,field,regex,is,simple,match,pattern,field,entry,get,key,float,weight,field,entry,get,value,null,1,0f,field,entry,get,value,map,string,float,field,map,resolve,mapping,field,context,field,entry,get,key,weight,multi,field,all,field,field,suffix,resolved,fields,put,all,field,map,check,for,too,many,fields,resolved,fields,return,resolved,fields
QueryParserHelper -> public static Map<String, Float> resolveMappingFields(QueryShardContext context,                                                           Map<String, Float> fieldsAndWeights,                                                           String fieldSuffix);1541693080;Resolve all the field names and patterns present in the provided map with the_{@link QueryShardContext} and returns a new map containing all the expanded fields with their original boost._@param context The context of the query._@param fieldsAndWeights The map of fields and weights to expand._@param fieldSuffix The suffix name to add to the expanded field names if a mapping exists for that name._The original name of the field is kept if adding the suffix to the field name does not point to a valid field_in the mapping.;public static Map<String, Float> resolveMappingFields(QueryShardContext context,_                                                          Map<String, Float> fieldsAndWeights,_                                                          String fieldSuffix) {_        Map<String, Float> resolvedFields = new HashMap<>()__        for (Map.Entry<String, Float> fieldEntry : fieldsAndWeights.entrySet()) {_            boolean allField = Regex.isMatchAllPattern(fieldEntry.getKey())__            boolean multiField = Regex.isSimpleMatchPattern(fieldEntry.getKey())__            float weight = fieldEntry.getValue() == null ? 1.0f : fieldEntry.getValue()__            Map<String, Float> fieldMap = resolveMappingField(context, fieldEntry.getKey(), weight,_                !multiField, !allField, fieldSuffix)__            resolvedFields.putAll(fieldMap)__        }_        checkForTooManyFields(resolvedFields, context)__        return resolvedFields__    };resolve,all,the,field,names,and,patterns,present,in,the,provided,map,with,the,link,query,shard,context,and,returns,a,new,map,containing,all,the,expanded,fields,with,their,original,boost,param,context,the,context,of,the,query,param,fields,and,weights,the,map,of,fields,and,weights,to,expand,param,field,suffix,the,suffix,name,to,add,to,the,expanded,field,names,if,a,mapping,exists,for,that,name,the,original,name,of,the,field,is,kept,if,adding,the,suffix,to,the,field,name,does,not,point,to,a,valid,field,in,the,mapping;public,static,map,string,float,resolve,mapping,fields,query,shard,context,context,map,string,float,fields,and,weights,string,field,suffix,map,string,float,resolved,fields,new,hash,map,for,map,entry,string,float,field,entry,fields,and,weights,entry,set,boolean,all,field,regex,is,match,all,pattern,field,entry,get,key,boolean,multi,field,regex,is,simple,match,pattern,field,entry,get,key,float,weight,field,entry,get,value,null,1,0f,field,entry,get,value,map,string,float,field,map,resolve,mapping,field,context,field,entry,get,key,weight,multi,field,all,field,field,suffix,resolved,fields,put,all,field,map,check,for,too,many,fields,resolved,fields,context,return,resolved,fields
QueryParserHelper -> public static Map<String, Float> resolveMappingFields(QueryShardContext context,                                                           Map<String, Float> fieldsAndWeights,                                                           String fieldSuffix);1544600864;Resolve all the field names and patterns present in the provided map with the_{@link QueryShardContext} and returns a new map containing all the expanded fields with their original boost._@param context The context of the query._@param fieldsAndWeights The map of fields and weights to expand._@param fieldSuffix The suffix name to add to the expanded field names if a mapping exists for that name._The original name of the field is kept if adding the suffix to the field name does not point to a valid field_in the mapping.;public static Map<String, Float> resolveMappingFields(QueryShardContext context,_                                                          Map<String, Float> fieldsAndWeights,_                                                          String fieldSuffix) {_        Map<String, Float> resolvedFields = new HashMap<>()__        for (Map.Entry<String, Float> fieldEntry : fieldsAndWeights.entrySet()) {_            boolean allField = Regex.isMatchAllPattern(fieldEntry.getKey())__            boolean multiField = Regex.isSimpleMatchPattern(fieldEntry.getKey())__            float weight = fieldEntry.getValue() == null ? 1.0f : fieldEntry.getValue()__            Map<String, Float> fieldMap = resolveMappingField(context, fieldEntry.getKey(), weight,_                !multiField, !allField, fieldSuffix)__            resolvedFields.putAll(fieldMap)__        }_        checkForTooManyFields(resolvedFields, context)__        return resolvedFields__    };resolve,all,the,field,names,and,patterns,present,in,the,provided,map,with,the,link,query,shard,context,and,returns,a,new,map,containing,all,the,expanded,fields,with,their,original,boost,param,context,the,context,of,the,query,param,fields,and,weights,the,map,of,fields,and,weights,to,expand,param,field,suffix,the,suffix,name,to,add,to,the,expanded,field,names,if,a,mapping,exists,for,that,name,the,original,name,of,the,field,is,kept,if,adding,the,suffix,to,the,field,name,does,not,point,to,a,valid,field,in,the,mapping;public,static,map,string,float,resolve,mapping,fields,query,shard,context,context,map,string,float,fields,and,weights,string,field,suffix,map,string,float,resolved,fields,new,hash,map,for,map,entry,string,float,field,entry,fields,and,weights,entry,set,boolean,all,field,regex,is,match,all,pattern,field,entry,get,key,boolean,multi,field,regex,is,simple,match,pattern,field,entry,get,key,float,weight,field,entry,get,value,null,1,0f,field,entry,get,value,map,string,float,field,map,resolve,mapping,field,context,field,entry,get,key,weight,multi,field,all,field,field,suffix,resolved,fields,put,all,field,map,check,for,too,many,fields,resolved,fields,context,return,resolved,fields
QueryParserHelper -> public static Map<String, Float> resolveMappingField(QueryShardContext context, String fieldOrPattern, float weight,                                                          boolean acceptAllTypes, boolean acceptMetadataField);1524684173;Resolves the provided pattern or field name from the {@link QueryShardContext} and return a map of_the expanded fields with their original boost._@param context The context of the query_@param fieldOrPattern The field name or the pattern to resolve_@param weight The weight for the field_@param acceptAllTypes Whether all field type should be added when a pattern is expanded._If false, only {@link #ALLOWED_QUERY_MAPPER_TYPES} are accepted and other field types_are discarded from the query._@param acceptMetadataField Whether metadata fields should be added when a pattern is expanded.;public static Map<String, Float> resolveMappingField(QueryShardContext context, String fieldOrPattern, float weight,_                                                         boolean acceptAllTypes, boolean acceptMetadataField) {_        return resolveMappingField(context, fieldOrPattern, weight, acceptAllTypes, acceptMetadataField, null)__    };resolves,the,provided,pattern,or,field,name,from,the,link,query,shard,context,and,return,a,map,of,the,expanded,fields,with,their,original,boost,param,context,the,context,of,the,query,param,field,or,pattern,the,field,name,or,the,pattern,to,resolve,param,weight,the,weight,for,the,field,param,accept,all,types,whether,all,field,type,should,be,added,when,a,pattern,is,expanded,if,false,only,link,are,accepted,and,other,field,types,are,discarded,from,the,query,param,accept,metadata,field,whether,metadata,fields,should,be,added,when,a,pattern,is,expanded;public,static,map,string,float,resolve,mapping,field,query,shard,context,context,string,field,or,pattern,float,weight,boolean,accept,all,types,boolean,accept,metadata,field,return,resolve,mapping,field,context,field,or,pattern,weight,accept,all,types,accept,metadata,field,null
QueryParserHelper -> public static Map<String, Float> resolveMappingField(QueryShardContext context, String fieldOrPattern, float weight,                                                          boolean acceptAllTypes, boolean acceptMetadataField);1528706846;Resolves the provided pattern or field name from the {@link QueryShardContext} and return a map of_the expanded fields with their original boost._@param context The context of the query_@param fieldOrPattern The field name or the pattern to resolve_@param weight The weight for the field_@param acceptAllTypes Whether all field type should be added when a pattern is expanded._If false, only {@link #ALLOWED_QUERY_MAPPER_TYPES} are accepted and other field types_are discarded from the query._@param acceptMetadataField Whether metadata fields should be added when a pattern is expanded.;public static Map<String, Float> resolveMappingField(QueryShardContext context, String fieldOrPattern, float weight,_                                                         boolean acceptAllTypes, boolean acceptMetadataField) {_        return resolveMappingField(context, fieldOrPattern, weight, acceptAllTypes, acceptMetadataField, null)__    };resolves,the,provided,pattern,or,field,name,from,the,link,query,shard,context,and,return,a,map,of,the,expanded,fields,with,their,original,boost,param,context,the,context,of,the,query,param,field,or,pattern,the,field,name,or,the,pattern,to,resolve,param,weight,the,weight,for,the,field,param,accept,all,types,whether,all,field,type,should,be,added,when,a,pattern,is,expanded,if,false,only,link,are,accepted,and,other,field,types,are,discarded,from,the,query,param,accept,metadata,field,whether,metadata,fields,should,be,added,when,a,pattern,is,expanded;public,static,map,string,float,resolve,mapping,field,query,shard,context,context,string,field,or,pattern,float,weight,boolean,accept,all,types,boolean,accept,metadata,field,return,resolve,mapping,field,context,field,or,pattern,weight,accept,all,types,accept,metadata,field,null
QueryParserHelper -> public static Map<String, Float> resolveMappingField(QueryShardContext context, String fieldOrPattern, float weight,                                                          boolean acceptAllTypes, boolean acceptMetadataField);1531937412;Resolves the provided pattern or field name from the {@link QueryShardContext} and return a map of_the expanded fields with their original boost._@param context The context of the query_@param fieldOrPattern The field name or the pattern to resolve_@param weight The weight for the field_@param acceptAllTypes Whether all field type should be added when a pattern is expanded._If false, only {@link #ALLOWED_QUERY_MAPPER_TYPES} are accepted and other field types_are discarded from the query._@param acceptMetadataField Whether metadata fields should be added when a pattern is expanded.;public static Map<String, Float> resolveMappingField(QueryShardContext context, String fieldOrPattern, float weight,_                                                         boolean acceptAllTypes, boolean acceptMetadataField) {_        return resolveMappingField(context, fieldOrPattern, weight, acceptAllTypes, acceptMetadataField, null)__    };resolves,the,provided,pattern,or,field,name,from,the,link,query,shard,context,and,return,a,map,of,the,expanded,fields,with,their,original,boost,param,context,the,context,of,the,query,param,field,or,pattern,the,field,name,or,the,pattern,to,resolve,param,weight,the,weight,for,the,field,param,accept,all,types,whether,all,field,type,should,be,added,when,a,pattern,is,expanded,if,false,only,link,are,accepted,and,other,field,types,are,discarded,from,the,query,param,accept,metadata,field,whether,metadata,fields,should,be,added,when,a,pattern,is,expanded;public,static,map,string,float,resolve,mapping,field,query,shard,context,context,string,field,or,pattern,float,weight,boolean,accept,all,types,boolean,accept,metadata,field,return,resolve,mapping,field,context,field,or,pattern,weight,accept,all,types,accept,metadata,field,null
QueryParserHelper -> public static Map<String, Float> resolveMappingField(QueryShardContext context, String fieldOrPattern, float weight,                                                          boolean acceptAllTypes, boolean acceptMetadataField);1535046779;Resolves the provided pattern or field name from the {@link QueryShardContext} and return a map of_the expanded fields with their original boost._@param context The context of the query_@param fieldOrPattern The field name or the pattern to resolve_@param weight The weight for the field_@param acceptAllTypes Whether all field type should be added when a pattern is expanded._If false, only searchable field types are added._@param acceptMetadataField Whether metadata fields should be added when a pattern is expanded.;public static Map<String, Float> resolveMappingField(QueryShardContext context, String fieldOrPattern, float weight,_                                                         boolean acceptAllTypes, boolean acceptMetadataField) {_        return resolveMappingField(context, fieldOrPattern, weight, acceptAllTypes, acceptMetadataField, null)__    };resolves,the,provided,pattern,or,field,name,from,the,link,query,shard,context,and,return,a,map,of,the,expanded,fields,with,their,original,boost,param,context,the,context,of,the,query,param,field,or,pattern,the,field,name,or,the,pattern,to,resolve,param,weight,the,weight,for,the,field,param,accept,all,types,whether,all,field,type,should,be,added,when,a,pattern,is,expanded,if,false,only,searchable,field,types,are,added,param,accept,metadata,field,whether,metadata,fields,should,be,added,when,a,pattern,is,expanded;public,static,map,string,float,resolve,mapping,field,query,shard,context,context,string,field,or,pattern,float,weight,boolean,accept,all,types,boolean,accept,metadata,field,return,resolve,mapping,field,context,field,or,pattern,weight,accept,all,types,accept,metadata,field,null
QueryParserHelper -> public static Map<String, Float> resolveMappingField(QueryShardContext context, String fieldOrPattern, float weight,                                                          boolean acceptAllTypes, boolean acceptMetadataField);1541693080;Resolves the provided pattern or field name from the {@link QueryShardContext} and return a map of_the expanded fields with their original boost._@param context The context of the query_@param fieldOrPattern The field name or the pattern to resolve_@param weight The weight for the field_@param acceptAllTypes Whether all field type should be added when a pattern is expanded._If false, only searchable field types are added._@param acceptMetadataField Whether metadata fields should be added when a pattern is expanded.;public static Map<String, Float> resolveMappingField(QueryShardContext context, String fieldOrPattern, float weight,_                                                         boolean acceptAllTypes, boolean acceptMetadataField) {_        return resolveMappingField(context, fieldOrPattern, weight, acceptAllTypes, acceptMetadataField, null)__    };resolves,the,provided,pattern,or,field,name,from,the,link,query,shard,context,and,return,a,map,of,the,expanded,fields,with,their,original,boost,param,context,the,context,of,the,query,param,field,or,pattern,the,field,name,or,the,pattern,to,resolve,param,weight,the,weight,for,the,field,param,accept,all,types,whether,all,field,type,should,be,added,when,a,pattern,is,expanded,if,false,only,searchable,field,types,are,added,param,accept,metadata,field,whether,metadata,fields,should,be,added,when,a,pattern,is,expanded;public,static,map,string,float,resolve,mapping,field,query,shard,context,context,string,field,or,pattern,float,weight,boolean,accept,all,types,boolean,accept,metadata,field,return,resolve,mapping,field,context,field,or,pattern,weight,accept,all,types,accept,metadata,field,null
QueryParserHelper -> public static Map<String, Float> resolveMappingField(QueryShardContext context, String fieldOrPattern, float weight,                                                          boolean acceptAllTypes, boolean acceptMetadataField);1544600864;Resolves the provided pattern or field name from the {@link QueryShardContext} and return a map of_the expanded fields with their original boost._@param context The context of the query_@param fieldOrPattern The field name or the pattern to resolve_@param weight The weight for the field_@param acceptAllTypes Whether all field type should be added when a pattern is expanded._If false, only searchable field types are added._@param acceptMetadataField Whether metadata fields should be added when a pattern is expanded.;public static Map<String, Float> resolveMappingField(QueryShardContext context, String fieldOrPattern, float weight,_                                                         boolean acceptAllTypes, boolean acceptMetadataField) {_        return resolveMappingField(context, fieldOrPattern, weight, acceptAllTypes, acceptMetadataField, null)__    };resolves,the,provided,pattern,or,field,name,from,the,link,query,shard,context,and,return,a,map,of,the,expanded,fields,with,their,original,boost,param,context,the,context,of,the,query,param,field,or,pattern,the,field,name,or,the,pattern,to,resolve,param,weight,the,weight,for,the,field,param,accept,all,types,whether,all,field,type,should,be,added,when,a,pattern,is,expanded,if,false,only,searchable,field,types,are,added,param,accept,metadata,field,whether,metadata,fields,should,be,added,when,a,pattern,is,expanded;public,static,map,string,float,resolve,mapping,field,query,shard,context,context,string,field,or,pattern,float,weight,boolean,accept,all,types,boolean,accept,metadata,field,return,resolve,mapping,field,context,field,or,pattern,weight,accept,all,types,accept,metadata,field,null
