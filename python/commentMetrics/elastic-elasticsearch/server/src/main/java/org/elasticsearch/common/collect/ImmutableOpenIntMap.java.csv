commented;modifiers;parameterAmount;loc;comment;code
true;public;1;3;/**  * @return Returns the value associated with the given key or the default value  * for the key type, if the key is not associated with any value.  * <p>  * <b>Important note:</b> For primitive type values, the value returned for a non-existing  * key may not be the default value of the primitive type (it may be any value previously  * assigned to that slot).  */ ;/**  * @return Returns the value associated with the given key or the default value  * for the key type, if the key is not associated with any value.  * <p>  * <b>Important note:</b> For primitive type values, the value returned for a non-existing  * key may not be the default value of the primitive type (it may be any value previously  * assigned to that slot).  */ public VType get(int key) {     return map.get(key). }
true;public;1;3;/**  * Returns <code>true</code> if this container has an association to a value for  * the given key.  */ ;/**  * Returns <code>true</code> if this container has an association to a value for  * the given key.  */ public boolean containsKey(int key) {     return map.containsKey(key). }
true;public;0;3;/**  * @return Returns the current size (number of assigned keys) in the container.  */ ;/**  * @return Returns the current size (number of assigned keys) in the container.  */ public int size() {     return map.size(). }
true;public;0;3;/**  * @return Return <code>true</code> if this hash map contains no assigned keys.  */ ;/**  * @return Return <code>true</code> if this hash map contains no assigned keys.  */ public boolean isEmpty() {     return map.isEmpty(). }
true;public;0;4;/**  * Returns a cursor over the entries (key-value pairs) in this map. The iterator is  * implemented as a cursor and it returns <b>the same cursor instance</b> on every  * call to {@link java.util.Iterator#next()}. To read the current key and value use the cursor's  * public fields. An example is shown below.  * <pre>  * for (IntShortCursor c : intShortMap)  * {  *     System.out.println(&quot.index=&quot. + c.index  *       + &quot. key=&quot. + c.key  *       + &quot. value=&quot. + c.value).  * }  * </pre>  * <p>  * The <code>index</code> field inside the cursor gives the internal index inside  * the container's implementation. The interpretation of this index depends on  * to the container.  */ ;/**  * Returns a cursor over the entries (key-value pairs) in this map. The iterator is  * implemented as a cursor and it returns <b>the same cursor instance</b> on every  * call to {@link java.util.Iterator#next()}. To read the current key and value use the cursor's  * public fields. An example is shown below.  * <pre>  * for (IntShortCursor c : intShortMap)  * {  *     System.out.println(&quot.index=&quot. + c.index  *       + &quot. key=&quot. + c.key  *       + &quot. value=&quot. + c.value).  * }  * </pre>  * <p>  * The <code>index</code> field inside the cursor gives the internal index inside  * the container's implementation. The interpretation of this index depends on  * to the container.  */ @Override public Iterator<IntObjectCursor<VType>> iterator() {     return map.iterator(). }
true;public;0;3;/**  * Returns a specialized view of the keys of this associated container.  * The view additionally implements {@link com.carrotsearch.hppc.ObjectLookupContainer}.  */ ;/**  * Returns a specialized view of the keys of this associated container.  * The view additionally implements {@link com.carrotsearch.hppc.ObjectLookupContainer}.  */ public IntLookupContainer keys() {     return map.keys(). }
false;public;0;4;;@Override public boolean hasNext() {     return iterator.hasNext(). }
false;public;0;4;;@Override public Integer next() {     return iterator.next().value. }
false;public;0;4;;@Override public void remove() {     throw new UnsupportedOperationException(). }
true;public;0;19;/**  * Returns a direct iterator over the keys.  */ ;/**  * Returns a direct iterator over the keys.  */ public Iterator<Integer> keysIt() {     final Iterator<IntCursor> iterator = map.keys().iterator().     return new Iterator<Integer>() {          @Override         public boolean hasNext() {             return iterator.hasNext().         }          @Override         public Integer next() {             return iterator.next().value.         }          @Override         public void remove() {             throw new UnsupportedOperationException().         }     }. }
true;public;0;3;/**  * @return Returns a container with all values stored in this map.  */ ;/**  * @return Returns a container with all values stored in this map.  */ public ObjectContainer<VType> values() {     return map.values(). }
false;public;0;4;;@Override public boolean hasNext() {     return iterator.hasNext(). }
false;public;0;4;;@Override public VType next() {     return iterator.next().value. }
false;public;0;4;;@Override public void remove() {     throw new UnsupportedOperationException(). }
true;public;0;19;/**  * Returns a direct iterator over the keys.  */ ;/**  * Returns a direct iterator over the keys.  */ public Iterator<VType> valuesIt() {     final Iterator<ObjectCursor<VType>> iterator = map.values().iterator().     return new Iterator<VType>() {          @Override         public boolean hasNext() {             return iterator.hasNext().         }          @Override         public VType next() {             return iterator.next().value.         }          @Override         public void remove() {             throw new UnsupportedOperationException().         }     }. }
false;public;0;4;;@Override public String toString() {     return map.toString(). }
false;public;1;11;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     ImmutableOpenIntMap that = (ImmutableOpenIntMap) o.     if (!map.equals(that.map))         return false.     return true. }
false;public;0;4;;@Override public int hashCode() {     return map.hashCode(). }
false;public,static;0;4;;@SuppressWarnings("unchecked") public static <VType> ImmutableOpenIntMap<VType> of() {     return EMPTY. }
false;public,static;0;3;;public static <VType> Builder<VType> builder() {     return new Builder<>(). }
false;public,static;1;3;;public static <VType> Builder<VType> builder(int size) {     return new Builder<>(size). }
false;public,static;1;3;;public static <VType> Builder<VType> builder(ImmutableOpenIntMap<VType> map) {     return new Builder<>(map). }
true;public;0;5;/**  * Builds a new instance of the  */ ;/**  * Builds a new instance of the  */ public ImmutableOpenIntMap<VType> build() {     IntObjectHashMap<VType> map = this.map.     // nullify the map, so any operation post build will fail! (hackish, but safest)     this.map = null.     return new ImmutableOpenIntMap<>(map). }
true;public;1;6;/**  * Puts all the entries in the map to the builder.  */ ;/**  * Puts all the entries in the map to the builder.  */ public Builder<VType> putAll(Map<Integer, VType> map) {     for (Map.Entry<Integer, VType> entry : map.entrySet()) {         this.map.put(entry.getKey(), entry.getValue()).     }     return this. }
true;public;2;4;/**  * A put operation that can be used in the fluent pattern.  */ ;/**  * A put operation that can be used in the fluent pattern.  */ public Builder<VType> fPut(int key, VType value) {     map.put(key, value).     return this. }
false;public;2;4;;@Override public VType put(int key, VType value) {     return map.put(key, value). }
false;public;1;4;;@Override public VType get(int key) {     return map.get(key). }
false;public;2;4;;@Override public VType getOrDefault(int kType, VType vType) {     return map.getOrDefault(kType, vType). }
true;public;1;4;/**  * Remove that can be used in the fluent pattern.  */ ;/**  * Remove that can be used in the fluent pattern.  */ public Builder<VType> fRemove(int key) {     map.remove(key).     return this. }
false;public;1;4;;@Override public VType remove(int key) {     return map.remove(key). }
false;public;0;4;;@Override public Iterator<IntObjectCursor<VType>> iterator() {     return map.iterator(). }
false;public;1;4;;@Override public boolean containsKey(int key) {     return map.containsKey(key). }
false;public;0;4;;@Override public int size() {     return map.size(). }
false;public;0;4;;@Override public boolean isEmpty() {     return map.isEmpty(). }
false;public;0;4;;@Override public void clear() {     map.clear(). }
false;public;1;4;;@Override public int putAll(IntObjectAssociativeContainer<? extends VType> container) {     return map.putAll(container). }
false;public;1;4;;@Override public int putAll(Iterable<? extends IntObjectCursor<? extends VType>> iterable) {     return map.putAll(iterable). }
false;public;1;4;;@Override public int removeAll(IntContainer container) {     return map.removeAll(container). }
false;public;1;4;;@Override public int removeAll(IntPredicate predicate) {     return map.removeAll(predicate). }
false;public;1;4;;@Override public <T extends IntObjectProcedure<? super VType>> T forEach(T procedure) {     return map.forEach(procedure). }
false;public;0;4;;@Override public IntCollection keys() {     return map.keys(). }
false;public;0;4;;@Override public ObjectContainer<VType> values() {     return map.values(). }
false;public;1;4;;@Override public int removeAll(IntObjectPredicate<? super VType> predicate) {     return map.removeAll(predicate). }
false;public;1;4;;@Override public <T extends IntObjectPredicate<? super VType>> T forEach(T predicate) {     return map.forEach(predicate). }
false;public;1;4;;@Override public int indexOf(int key) {     return map.indexOf(key). }
false;public;1;4;;@Override public boolean indexExists(int index) {     return map.indexExists(index). }
false;public;1;4;;@Override public VType indexGet(int index) {     return map.indexGet(index). }
false;public;2;4;;@Override public VType indexReplace(int index, VType newValue) {     return map.indexReplace(index, newValue). }
false;public;3;4;;@Override public void indexInsert(int index, int key, VType value) {     map.indexInsert(index, key, value). }
false;public;0;4;;@Override public void release() {     map.release(). }
false;public;1;4;;@Override public String visualizeKeyDistribution(int characters) {     return map.visualizeKeyDistribution(characters). }
