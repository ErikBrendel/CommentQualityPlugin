commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public long getGeneration() {     return this.generation. }
false;public,abstract;0;1;;public abstract long sizeInBytes().
false;public,abstract;0;1;;public abstract int totalOperations().
false;abstract;0;1;;abstract Checkpoint getCheckpoint().
false;public,final;0;3;;public final long getFirstOperationOffset() {     return header.sizeInBytes(). }
true;public,final;0;3;/**  * Returns the primary term associated with this translog reader.  */ ;/**  * Returns the primary term associated with this translog reader.  */ public final long getPrimaryTerm() {     return header.getPrimaryTerm(). }
true;protected,final;2;18;/**  * read the size of the op (i.e., number of bytes, including the op size) written at the given position  */ ;/**  * read the size of the op (i.e., number of bytes, including the op size) written at the given position  */ protected final int readSize(ByteBuffer reusableBuffer, long position) throws IOException {     // read op size from disk     assert reusableBuffer.capacity() >= 4 : "reusable buffer must have capacity >=4 when reading opSize. got [" + reusableBuffer.capacity() + "]".     reusableBuffer.clear().     reusableBuffer.limit(4).     readBytes(reusableBuffer, position).     reusableBuffer.flip().     // Add an extra 4 to account for the operation size integer itself     final int size = reusableBuffer.getInt() + 4.     final long maxSize = sizeInBytes() - position.     if (size < 0 || size > maxSize) {         throw new TranslogCorruptedException(path.toString(), "operation size is corrupted must be [0.." + maxSize + "] but was: " + size).     }     return size. }
false;public;0;3;;public TranslogSnapshot newSnapshot() {     return new TranslogSnapshot(this, sizeInBytes()). }
true;protected,final;4;14;/**  * reads an operation at the given position and returns it. The buffer length is equal to the number  * of bytes reads.  */ ;/**  * reads an operation at the given position and returns it. The buffer length is equal to the number  * of bytes reads.  */ protected final BufferedChecksumStreamInput checksummedStream(ByteBuffer reusableBuffer, long position, int opSize, BufferedChecksumStreamInput reuse) throws IOException {     final ByteBuffer buffer.     if (reusableBuffer.capacity() >= opSize) {         buffer = reusableBuffer.     } else {         buffer = ByteBuffer.allocate(opSize).     }     buffer.clear().     buffer.limit(opSize).     readBytes(buffer, position).     buffer.flip().     return new BufferedChecksumStreamInput(new ByteBufferStreamInput(buffer), path.toString(), reuse). }
false;protected;1;10;;protected Translog.Operation read(BufferedChecksumStreamInput inStream) throws IOException {     final Translog.Operation op = Translog.readOperation(inStream).     if (op.primaryTerm() > getPrimaryTerm() && getPrimaryTerm() != SequenceNumbers.UNASSIGNED_PRIMARY_TERM) {         throw new TranslogCorruptedException(path.toString(), "operation's term is newer than translog header term. " + "operation term[" + op.primaryTerm() + "], translog header term [" + getPrimaryTerm() + "]").     }     return op. }
true;protected,abstract;2;1;/**  * reads bytes at position into the given buffer, filling it.  */ ;/**  * reads bytes at position into the given buffer, filling it.  */ protected abstract void readBytes(ByteBuffer buffer, long position) throws IOException.
false;public;0;4;;@Override public String toString() {     return "translog [" + generation + "][" + path + "]". }
false;public;1;4;;@Override public int compareTo(BaseTranslogReader o) {     return Long.compare(getGeneration(), o.getGeneration()). }
false;public;0;3;;public Path path() {     return path. }
false;public;0;3;;public long getLastModifiedTime() throws IOException {     return Files.getLastModifiedTime(path).toMillis(). }
true;;1;5;/**  * Reads a single opertation from the given location.  */ ;/**  * Reads a single opertation from the given location.  */ Translog.Operation read(Translog.Location location) throws IOException {     assert location.generation == this.generation : "generation mismatch expected: " + generation + " got: " + location.generation.     ByteBuffer buffer = ByteBuffer.allocate(location.size).     return read(checksummedStream(buffer, location.translogLocation, location.size, null)). }
