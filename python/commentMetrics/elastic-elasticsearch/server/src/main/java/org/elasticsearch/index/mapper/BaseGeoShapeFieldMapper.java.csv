commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;public Builder coerce(boolean coerce) {     this.coerce = coerce.     return this. }
false;protected;1;9;;protected Explicit<Boolean> coerce(BuilderContext context) {     if (coerce != null) {         return new Explicit<>(coerce, true).     }     if (context.indexSettings() != null) {         return new Explicit<>(COERCE_SETTING.get(context.indexSettings()), false).     }     return Defaults.COERCE. }
false;public;1;4;;public Builder orientation(Orientation orientation) {     this.orientation = orientation.     return this. }
false;protected;0;6;;protected Explicit<Orientation> orientation() {     if (orientation != null) {         return new Explicit<>(orientation, true).     }     return Defaults.ORIENTATION. }
false;protected;1;4;;@Override protected boolean defaultDocValues(Version indexCreated) {     return false. }
false;public;1;4;;public Builder ignoreMalformed(boolean ignoreMalformed) {     this.ignoreMalformed = ignoreMalformed.     return this. }
false;protected;1;9;;protected Explicit<Boolean> ignoreMalformed(BuilderContext context) {     if (ignoreMalformed != null) {         return new Explicit<>(ignoreMalformed, true).     }     if (context.indexSettings() != null) {         return new Explicit<>(IGNORE_MALFORMED_SETTING.get(context.indexSettings()), false).     }     return Defaults.IGNORE_MALFORMED. }
false;protected;0;6;;protected Explicit<Boolean> ignoreZValue() {     if (ignoreZValue != null) {         return new Explicit<>(ignoreZValue, true).     }     return Defaults.IGNORE_Z_VALUE. }
false;public;1;4;;public Builder ignoreZValue(final boolean ignoreZValue) {     this.ignoreZValue = ignoreZValue.     return this. }
false;protected;1;13;;@Override protected void setupFieldType(BuilderContext context) {     super.setupFieldType(context).     // but prefix tree strategies require a name, so throw a similar exception     if (name().isEmpty()) {         throw new IllegalArgumentException("name cannot be empty string").     }     BaseGeoShapeFieldType ft = (BaseGeoShapeFieldType) fieldType().     ft.setOrientation(orientation().value()). }
false;public;3;57;;@Override public Mapper.Builder parse(String name, Map<String, Object> node, ParserContext parserContext) throws MapperParsingException {     Boolean coerce = null.     Boolean ignoreZ = null.     Boolean ignoreMalformed = null.     Orientation orientation = null.     DeprecatedParameters deprecatedParameters = new DeprecatedParameters().     boolean parsedDeprecatedParams = false.     for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(). iterator.hasNext(). ) {         Map.Entry<String, Object> entry = iterator.next().         String fieldName = entry.getKey().         Object fieldNode = entry.getValue().         if (DeprecatedParameters.parse(name, fieldName, fieldNode, deprecatedParameters)) {             parsedDeprecatedParams = true.             iterator.remove().         } else if (Names.ORIENTATION.match(fieldName, LoggingDeprecationHandler.INSTANCE)) {             orientation = ShapeBuilder.Orientation.fromString(fieldNode.toString()).             iterator.remove().         } else if (IGNORE_MALFORMED.equals(fieldName)) {             ignoreMalformed = XContentMapValues.nodeBooleanValue(fieldNode, name + ".ignore_malformed").             iterator.remove().         } else if (Names.COERCE.match(fieldName, LoggingDeprecationHandler.INSTANCE)) {             coerce = XContentMapValues.nodeBooleanValue(fieldNode, name + "." + Names.COERCE.getPreferredName()).             iterator.remove().         } else if (GeoPointFieldMapper.Names.IGNORE_Z_VALUE.getPreferredName().equals(fieldName)) {             ignoreZ = XContentMapValues.nodeBooleanValue(fieldNode, name + "." + GeoPointFieldMapper.Names.IGNORE_Z_VALUE.getPreferredName()).             iterator.remove().         }     }     final Builder builder.     if (parsedDeprecatedParams || parserContext.indexVersionCreated().before(Version.V_6_6_0)) {         // Legacy index-based shape         builder = new LegacyGeoShapeFieldMapper.Builder(name, deprecatedParameters).     } else {         // BKD-based shape         builder = new GeoShapeFieldMapper.Builder(name).     }     if (coerce != null) {         builder.coerce(coerce).     }     if (ignoreZ != null) {         builder.ignoreZValue(ignoreZ).     }     if (ignoreMalformed != null) {         builder.ignoreMalformed(ignoreMalformed).     }     if (orientation != null) {         builder.orientation(orientation).     }     return builder. }
false;public;1;6;;@Override public boolean equals(Object o) {     if (!super.equals(o))         return false.     BaseGeoShapeFieldType that = (BaseGeoShapeFieldType) o.     return orientation == that.orientation. }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(super.hashCode(), orientation). }
false;public;0;4;;@Override public String typeName() {     return CONTENT_TYPE. }
false;public;2;4;;@Override public void checkCompatibility(MappedFieldType fieldType, List<String> conflicts) {     super.checkCompatibility(fieldType, conflicts). }
false;public;0;1;;public Orientation orientation() {     return this.orientation. }
false;public;1;4;;public void setOrientation(Orientation orientation) {     checkIfFrozen().     this.orientation = orientation. }
false;public;1;4;;@Override public Query existsQuery(QueryShardContext context) {     return new TermQuery(new Term(FieldNamesFieldMapper.NAME, name())). }
false;public;2;4;;@Override public Query termQuery(Object value, QueryShardContext context) {     throw new QueryShardException(context, "Geo fields do not support exact searching, use dedicated geo queries instead"). }
false;protected;1;14;;@Override protected void doMerge(Mapper mergeWith) {     super.doMerge(mergeWith).     BaseGeoShapeFieldMapper gsfm = (BaseGeoShapeFieldMapper) mergeWith.     if (gsfm.coerce.explicit()) {         this.coerce = gsfm.coerce.     }     if (gsfm.ignoreMalformed.explicit()) {         this.ignoreMalformed = gsfm.ignoreMalformed.     }     if (gsfm.ignoreZValue.explicit()) {         this.ignoreZValue = gsfm.ignoreZValue.     } }
false;protected;2;3;;@Override protected void parseCreateField(ParseContext context, List<IndexableField> fields) throws IOException { }
false;protected;3;17;;@Override protected void doXContentBody(XContentBuilder builder, boolean includeDefaults, Params params) throws IOException {     builder.field("type", contentType()).     BaseGeoShapeFieldType ft = (BaseGeoShapeFieldType) fieldType().     if (includeDefaults || ft.orientation() != Defaults.ORIENTATION.value()) {         builder.field(Names.ORIENTATION.getPreferredName(), ft.orientation()).     }     if (includeDefaults || coerce.explicit()) {         builder.field(Names.COERCE.getPreferredName(), coerce.value()).     }     if (includeDefaults || ignoreMalformed.explicit()) {         builder.field(IGNORE_MALFORMED, ignoreMalformed.value()).     }     if (includeDefaults || ignoreZValue.explicit()) {         builder.field(GeoPointFieldMapper.Names.IGNORE_Z_VALUE.getPreferredName(), ignoreZValue.value()).     } }
false;public;0;3;;public Explicit<Boolean> coerce() {     return coerce. }
false;public;0;3;;public Explicit<Boolean> ignoreMalformed() {     return ignoreMalformed. }
false;public;0;3;;public Explicit<Boolean> ignoreZValue() {     return ignoreZValue. }
false;public;0;3;;public Orientation orientation() {     return ((BaseGeoShapeFieldType) fieldType).orientation(). }
false;protected;0;4;;@Override protected String contentType() {     return CONTENT_TYPE. }
