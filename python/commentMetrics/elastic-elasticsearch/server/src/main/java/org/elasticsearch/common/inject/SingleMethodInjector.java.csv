commented;modifiers;parameterAmount;loc;comment;code
false;public;2;5;;@Override public Object invoke(Object target, Object... parameters) throws IllegalAccessException, InvocationTargetException {     return method.invoke(target, parameters). }
false;private;1;15;;private MethodInvoker createMethodInvoker(final Method method) {     // We can't use FastMethod if the method is private.     int modifiers = method.getModifiers().     if (!Modifier.isPrivate(modifiers) && !Modifier.isProtected(modifiers)) {     }     return new MethodInvoker() {          @Override         public Object invoke(Object target, Object... parameters) throws IllegalAccessException, InvocationTargetException {             return method.invoke(target, parameters).         }     }. }
false;public;0;4;;@Override public InjectionPoint getInjectionPoint() {     return injectionPoint. }
false;public;3;21;;@Override public void inject(Errors errors, InternalContext context, Object o) {     Object[] parameters.     try {         parameters = SingleParameterInjector.getAll(errors, context, parameterInjectors).     } catch (ErrorsException e) {         errors.merge(e.getErrors()).         return.     }     try {         methodInvoker.invoke(o, parameters).     } catch (IllegalAccessException e) {         // a security manager is blocking us, we're hosed         throw new AssertionError(e).     } catch (InvocationTargetException userException) {         Throwable cause = userException.getCause() != null ? userException.getCause() : userException.         errors.withSource(injectionPoint).errorInjectingMethod(cause).     } }
