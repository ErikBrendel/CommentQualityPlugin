# id;timestamp;commentText;codeText;commentWords;codeWords
StoreRecovery -> boolean recoverFromRepository(final IndexShard indexShard, Repository repository);1524684173;Recovers an index from a given {@link Repository}. This method restores a_previously created index snapshot into an existing initializing shard._@param indexShard the index shard instance to recovery the snapshot from_@param repository the repository holding the physical files the shard should be recovered from_@return <code>true</code> if the shard has been recovered successfully, <code>false</code> if the recovery_has been ignored due to a concurrent modification of if the clusters state has changed due to async updates.;boolean recoverFromRepository(final IndexShard indexShard, Repository repository) {_        if (canRecover(indexShard)) {_            RecoverySource.Type recoveryType = indexShard.recoveryState().getRecoverySource().getType()__            assert recoveryType == RecoverySource.Type.SNAPSHOT : "expected snapshot recovery type: " + recoveryType__            SnapshotRecoverySource recoverySource = (SnapshotRecoverySource) indexShard.recoveryState().getRecoverySource()__            return executeRecovery(indexShard, () -> {_                logger.debug("restoring from {} ...", indexShard.recoveryState().getRecoverySource())__                restore(indexShard, repository, recoverySource)__            })__        }_        return false___    };recovers,an,index,from,a,given,link,repository,this,method,restores,a,previously,created,index,snapshot,into,an,existing,initializing,shard,param,index,shard,the,index,shard,instance,to,recovery,the,snapshot,from,param,repository,the,repository,holding,the,physical,files,the,shard,should,be,recovered,from,return,code,true,code,if,the,shard,has,been,recovered,successfully,code,false,code,if,the,recovery,has,been,ignored,due,to,a,concurrent,modification,of,if,the,clusters,state,has,changed,due,to,async,updates;boolean,recover,from,repository,final,index,shard,index,shard,repository,repository,if,can,recover,index,shard,recovery,source,type,recovery,type,index,shard,recovery,state,get,recovery,source,get,type,assert,recovery,type,recovery,source,type,snapshot,expected,snapshot,recovery,type,recovery,type,snapshot,recovery,source,recovery,source,snapshot,recovery,source,index,shard,recovery,state,get,recovery,source,return,execute,recovery,index,shard,logger,debug,restoring,from,index,shard,recovery,state,get,recovery,source,restore,index,shard,repository,recovery,source,return,false
StoreRecovery -> boolean recoverFromRepository(final IndexShard indexShard, Repository repository);1533295538;Recovers an index from a given {@link Repository}. This method restores a_previously created index snapshot into an existing initializing shard._@param indexShard the index shard instance to recovery the snapshot from_@param repository the repository holding the physical files the shard should be recovered from_@return <code>true</code> if the shard has been recovered successfully, <code>false</code> if the recovery_has been ignored due to a concurrent modification of if the clusters state has changed due to async updates.;boolean recoverFromRepository(final IndexShard indexShard, Repository repository) {_        if (canRecover(indexShard)) {_            RecoverySource.Type recoveryType = indexShard.recoveryState().getRecoverySource().getType()__            assert recoveryType == RecoverySource.Type.SNAPSHOT : "expected snapshot recovery type: " + recoveryType__            SnapshotRecoverySource recoverySource = (SnapshotRecoverySource) indexShard.recoveryState().getRecoverySource()__            return executeRecovery(indexShard, () -> {_                logger.debug("restoring from {} ...", indexShard.recoveryState().getRecoverySource())__                restore(indexShard, repository, recoverySource)__            })__        }_        return false___    };recovers,an,index,from,a,given,link,repository,this,method,restores,a,previously,created,index,snapshot,into,an,existing,initializing,shard,param,index,shard,the,index,shard,instance,to,recovery,the,snapshot,from,param,repository,the,repository,holding,the,physical,files,the,shard,should,be,recovered,from,return,code,true,code,if,the,shard,has,been,recovered,successfully,code,false,code,if,the,recovery,has,been,ignored,due,to,a,concurrent,modification,of,if,the,clusters,state,has,changed,due,to,async,updates;boolean,recover,from,repository,final,index,shard,index,shard,repository,repository,if,can,recover,index,shard,recovery,source,type,recovery,type,index,shard,recovery,state,get,recovery,source,get,type,assert,recovery,type,recovery,source,type,snapshot,expected,snapshot,recovery,type,recovery,type,snapshot,recovery,source,recovery,source,snapshot,recovery,source,index,shard,recovery,state,get,recovery,source,return,execute,recovery,index,shard,logger,debug,restoring,from,index,shard,recovery,state,get,recovery,source,restore,index,shard,repository,recovery,source,return,false
StoreRecovery -> boolean recoverFromRepository(final IndexShard indexShard, Repository repository);1535723122;Recovers an index from a given {@link Repository}. This method restores a_previously created index snapshot into an existing initializing shard._@param indexShard the index shard instance to recovery the snapshot from_@param repository the repository holding the physical files the shard should be recovered from_@return <code>true</code> if the shard has been recovered successfully, <code>false</code> if the recovery_has been ignored due to a concurrent modification of if the clusters state has changed due to async updates.;boolean recoverFromRepository(final IndexShard indexShard, Repository repository) {_        if (canRecover(indexShard)) {_            RecoverySource.Type recoveryType = indexShard.recoveryState().getRecoverySource().getType()__            assert recoveryType == RecoverySource.Type.SNAPSHOT : "expected snapshot recovery type: " + recoveryType__            SnapshotRecoverySource recoverySource = (SnapshotRecoverySource) indexShard.recoveryState().getRecoverySource()__            return executeRecovery(indexShard, () -> {_                logger.debug("restoring from {} ...", indexShard.recoveryState().getRecoverySource())__                restore(indexShard, repository, recoverySource)__            })__        }_        return false___    };recovers,an,index,from,a,given,link,repository,this,method,restores,a,previously,created,index,snapshot,into,an,existing,initializing,shard,param,index,shard,the,index,shard,instance,to,recovery,the,snapshot,from,param,repository,the,repository,holding,the,physical,files,the,shard,should,be,recovered,from,return,code,true,code,if,the,shard,has,been,recovered,successfully,code,false,code,if,the,recovery,has,been,ignored,due,to,a,concurrent,modification,of,if,the,clusters,state,has,changed,due,to,async,updates;boolean,recover,from,repository,final,index,shard,index,shard,repository,repository,if,can,recover,index,shard,recovery,source,type,recovery,type,index,shard,recovery,state,get,recovery,source,get,type,assert,recovery,type,recovery,source,type,snapshot,expected,snapshot,recovery,type,recovery,type,snapshot,recovery,source,recovery,source,snapshot,recovery,source,index,shard,recovery,state,get,recovery,source,return,execute,recovery,index,shard,logger,debug,restoring,from,index,shard,recovery,state,get,recovery,source,restore,index,shard,repository,recovery,source,return,false
StoreRecovery -> boolean recoverFromRepository(final IndexShard indexShard, Repository repository);1536611444;Recovers an index from a given {@link Repository}. This method restores a_previously created index snapshot into an existing initializing shard._@param indexShard the index shard instance to recovery the snapshot from_@param repository the repository holding the physical files the shard should be recovered from_@return <code>true</code> if the shard has been recovered successfully, <code>false</code> if the recovery_has been ignored due to a concurrent modification of if the clusters state has changed due to async updates.;boolean recoverFromRepository(final IndexShard indexShard, Repository repository) {_        if (canRecover(indexShard)) {_            RecoverySource.Type recoveryType = indexShard.recoveryState().getRecoverySource().getType()__            assert recoveryType == RecoverySource.Type.SNAPSHOT : "expected snapshot recovery type: " + recoveryType__            SnapshotRecoverySource recoverySource = (SnapshotRecoverySource) indexShard.recoveryState().getRecoverySource()__            return executeRecovery(indexShard, () -> {_                logger.debug("restoring from {} ...", indexShard.recoveryState().getRecoverySource())__                restore(indexShard, repository, recoverySource)__            })__        }_        return false___    };recovers,an,index,from,a,given,link,repository,this,method,restores,a,previously,created,index,snapshot,into,an,existing,initializing,shard,param,index,shard,the,index,shard,instance,to,recovery,the,snapshot,from,param,repository,the,repository,holding,the,physical,files,the,shard,should,be,recovered,from,return,code,true,code,if,the,shard,has,been,recovered,successfully,code,false,code,if,the,recovery,has,been,ignored,due,to,a,concurrent,modification,of,if,the,clusters,state,has,changed,due,to,async,updates;boolean,recover,from,repository,final,index,shard,index,shard,repository,repository,if,can,recover,index,shard,recovery,source,type,recovery,type,index,shard,recovery,state,get,recovery,source,get,type,assert,recovery,type,recovery,source,type,snapshot,expected,snapshot,recovery,type,recovery,type,snapshot,recovery,source,recovery,source,snapshot,recovery,source,index,shard,recovery,state,get,recovery,source,return,execute,recovery,index,shard,logger,debug,restoring,from,index,shard,recovery,state,get,recovery,source,restore,index,shard,repository,recovery,source,return,false
StoreRecovery -> boolean recoverFromRepository(final IndexShard indexShard, Repository repository);1538067637;Recovers an index from a given {@link Repository}. This method restores a_previously created index snapshot into an existing initializing shard._@param indexShard the index shard instance to recovery the snapshot from_@param repository the repository holding the physical files the shard should be recovered from_@return <code>true</code> if the shard has been recovered successfully, <code>false</code> if the recovery_has been ignored due to a concurrent modification of if the clusters state has changed due to async updates.;boolean recoverFromRepository(final IndexShard indexShard, Repository repository) {_        if (canRecover(indexShard)) {_            RecoverySource.Type recoveryType = indexShard.recoveryState().getRecoverySource().getType()__            assert recoveryType == RecoverySource.Type.SNAPSHOT : "expected snapshot recovery type: " + recoveryType__            SnapshotRecoverySource recoverySource = (SnapshotRecoverySource) indexShard.recoveryState().getRecoverySource()__            return executeRecovery(indexShard, () -> {_                logger.debug("restoring from {} ...", indexShard.recoveryState().getRecoverySource())__                restore(indexShard, repository, recoverySource)__            })__        }_        return false___    };recovers,an,index,from,a,given,link,repository,this,method,restores,a,previously,created,index,snapshot,into,an,existing,initializing,shard,param,index,shard,the,index,shard,instance,to,recovery,the,snapshot,from,param,repository,the,repository,holding,the,physical,files,the,shard,should,be,recovered,from,return,code,true,code,if,the,shard,has,been,recovered,successfully,code,false,code,if,the,recovery,has,been,ignored,due,to,a,concurrent,modification,of,if,the,clusters,state,has,changed,due,to,async,updates;boolean,recover,from,repository,final,index,shard,index,shard,repository,repository,if,can,recover,index,shard,recovery,source,type,recovery,type,index,shard,recovery,state,get,recovery,source,get,type,assert,recovery,type,recovery,source,type,snapshot,expected,snapshot,recovery,type,recovery,type,snapshot,recovery,source,recovery,source,snapshot,recovery,source,index,shard,recovery,state,get,recovery,source,return,execute,recovery,index,shard,logger,debug,restoring,from,index,shard,recovery,state,get,recovery,source,restore,index,shard,repository,recovery,source,return,false
StoreRecovery -> boolean recoverFromRepository(final IndexShard indexShard, Repository repository);1542697754;Recovers an index from a given {@link Repository}. This method restores a_previously created index snapshot into an existing initializing shard._@param indexShard the index shard instance to recovery the snapshot from_@param repository the repository holding the physical files the shard should be recovered from_@return <code>true</code> if the shard has been recovered successfully, <code>false</code> if the recovery_has been ignored due to a concurrent modification of if the clusters state has changed due to async updates.;boolean recoverFromRepository(final IndexShard indexShard, Repository repository) {_        if (canRecover(indexShard)) {_            RecoverySource.Type recoveryType = indexShard.recoveryState().getRecoverySource().getType()__            assert recoveryType == RecoverySource.Type.SNAPSHOT : "expected snapshot recovery type: " + recoveryType__            SnapshotRecoverySource recoverySource = (SnapshotRecoverySource) indexShard.recoveryState().getRecoverySource()__            return executeRecovery(indexShard, () -> {_                logger.debug("restoring from {} ...", indexShard.recoveryState().getRecoverySource())__                restore(indexShard, repository, recoverySource)__            })__        }_        return false___    };recovers,an,index,from,a,given,link,repository,this,method,restores,a,previously,created,index,snapshot,into,an,existing,initializing,shard,param,index,shard,the,index,shard,instance,to,recovery,the,snapshot,from,param,repository,the,repository,holding,the,physical,files,the,shard,should,be,recovered,from,return,code,true,code,if,the,shard,has,been,recovered,successfully,code,false,code,if,the,recovery,has,been,ignored,due,to,a,concurrent,modification,of,if,the,clusters,state,has,changed,due,to,async,updates;boolean,recover,from,repository,final,index,shard,index,shard,repository,repository,if,can,recover,index,shard,recovery,source,type,recovery,type,index,shard,recovery,state,get,recovery,source,get,type,assert,recovery,type,recovery,source,type,snapshot,expected,snapshot,recovery,type,recovery,type,snapshot,recovery,source,recovery,source,snapshot,recovery,source,index,shard,recovery,state,get,recovery,source,return,execute,recovery,index,shard,logger,debug,restoring,from,index,shard,recovery,state,get,recovery,source,restore,index,shard,repository,recovery,source,return,false
StoreRecovery -> boolean recoverFromRepository(final IndexShard indexShard, Repository repository);1543942400;Recovers an index from a given {@link Repository}. This method restores a_previously created index snapshot into an existing initializing shard._@param indexShard the index shard instance to recovery the snapshot from_@param repository the repository holding the physical files the shard should be recovered from_@return <code>true</code> if the shard has been recovered successfully, <code>false</code> if the recovery_has been ignored due to a concurrent modification of if the clusters state has changed due to async updates.;boolean recoverFromRepository(final IndexShard indexShard, Repository repository) {_        if (canRecover(indexShard)) {_            RecoverySource.Type recoveryType = indexShard.recoveryState().getRecoverySource().getType()__            assert recoveryType == RecoverySource.Type.SNAPSHOT : "expected snapshot recovery type: " + recoveryType__            SnapshotRecoverySource recoverySource = (SnapshotRecoverySource) indexShard.recoveryState().getRecoverySource()__            return executeRecovery(indexShard, () -> {_                logger.debug("restoring from {} ...", indexShard.recoveryState().getRecoverySource())__                restore(indexShard, repository, recoverySource)__            })__        }_        return false___    };recovers,an,index,from,a,given,link,repository,this,method,restores,a,previously,created,index,snapshot,into,an,existing,initializing,shard,param,index,shard,the,index,shard,instance,to,recovery,the,snapshot,from,param,repository,the,repository,holding,the,physical,files,the,shard,should,be,recovered,from,return,code,true,code,if,the,shard,has,been,recovered,successfully,code,false,code,if,the,recovery,has,been,ignored,due,to,a,concurrent,modification,of,if,the,clusters,state,has,changed,due,to,async,updates;boolean,recover,from,repository,final,index,shard,index,shard,repository,repository,if,can,recover,index,shard,recovery,source,type,recovery,type,index,shard,recovery,state,get,recovery,source,get,type,assert,recovery,type,recovery,source,type,snapshot,expected,snapshot,recovery,type,recovery,type,snapshot,recovery,source,recovery,source,snapshot,recovery,source,index,shard,recovery,state,get,recovery,source,return,execute,recovery,index,shard,logger,debug,restoring,from,index,shard,recovery,state,get,recovery,source,restore,index,shard,repository,recovery,source,return,false
StoreRecovery -> boolean recoverFromRepository(final IndexShard indexShard, Repository repository);1549395161;Recovers an index from a given {@link Repository}. This method restores a_previously created index snapshot into an existing initializing shard._@param indexShard the index shard instance to recovery the snapshot from_@param repository the repository holding the physical files the shard should be recovered from_@return <code>true</code> if the shard has been recovered successfully, <code>false</code> if the recovery_has been ignored due to a concurrent modification of if the clusters state has changed due to async updates.;boolean recoverFromRepository(final IndexShard indexShard, Repository repository) {_        if (canRecover(indexShard)) {_            RecoverySource.Type recoveryType = indexShard.recoveryState().getRecoverySource().getType()__            assert recoveryType == RecoverySource.Type.SNAPSHOT : "expected snapshot recovery type: " + recoveryType__            SnapshotRecoverySource recoverySource = (SnapshotRecoverySource) indexShard.recoveryState().getRecoverySource()__            return executeRecovery(indexShard, () -> {_                logger.debug("restoring from {} ...", indexShard.recoveryState().getRecoverySource())__                restore(indexShard, repository, recoverySource)__            })__        }_        return false___    };recovers,an,index,from,a,given,link,repository,this,method,restores,a,previously,created,index,snapshot,into,an,existing,initializing,shard,param,index,shard,the,index,shard,instance,to,recovery,the,snapshot,from,param,repository,the,repository,holding,the,physical,files,the,shard,should,be,recovered,from,return,code,true,code,if,the,shard,has,been,recovered,successfully,code,false,code,if,the,recovery,has,been,ignored,due,to,a,concurrent,modification,of,if,the,clusters,state,has,changed,due,to,async,updates;boolean,recover,from,repository,final,index,shard,index,shard,repository,repository,if,can,recover,index,shard,recovery,source,type,recovery,type,index,shard,recovery,state,get,recovery,source,get,type,assert,recovery,type,recovery,source,type,snapshot,expected,snapshot,recovery,type,recovery,type,snapshot,recovery,source,recovery,source,snapshot,recovery,source,index,shard,recovery,state,get,recovery,source,return,execute,recovery,index,shard,logger,debug,restoring,from,index,shard,recovery,state,get,recovery,source,restore,index,shard,repository,recovery,source,return,false
StoreRecovery -> private boolean executeRecovery(final IndexShard indexShard, Runnable recoveryRunnable) throws IndexShardRecoveryException;1524684173;Recovers the state of the shard from the store.;private boolean executeRecovery(final IndexShard indexShard, Runnable recoveryRunnable) throws IndexShardRecoveryException {_        try {_            recoveryRunnable.run()__            _            _            final IndexShardState shardState = indexShard.state()__            final RecoveryState recoveryState = indexShard.recoveryState()__            assert shardState != IndexShardState.CREATED && shardState != IndexShardState.RECOVERING : "recovery process of " + shardId + " didn't get to post_recovery. shardState [" + shardState + "]"___            if (logger.isTraceEnabled()) {_                RecoveryState.Index index = recoveryState.getIndex()__                StringBuilder sb = new StringBuilder()__                sb.append("    index    : files           [").append(index.totalFileCount()).append("] with total_size [")_                        .append(new ByteSizeValue(index.totalBytes())).append("], took[")_                        .append(TimeValue.timeValueMillis(index.time())).append("]\n")__                sb.append("             : recovered_files [").append(index.recoveredFileCount()).append("] with total_size [")_                        .append(new ByteSizeValue(index.recoveredBytes())).append("]\n")__                sb.append("             : reusing_files   [").append(index.reusedFileCount()).append("] with total_size [")_                        .append(new ByteSizeValue(index.reusedBytes())).append("]\n")__                sb.append("    verify_index    : took [").append(TimeValue.timeValueMillis(recoveryState.getVerifyIndex().time())).append("], check_index [")_                        .append(timeValueMillis(recoveryState.getVerifyIndex().checkIndexTime())).append("]\n")__                sb.append("    translog : number_of_operations [").append(recoveryState.getTranslog().recoveredOperations())_                        .append("], took [").append(TimeValue.timeValueMillis(recoveryState.getTranslog().time())).append("]")__                logger.trace("recovery completed from [shard_store], took [{}]\n{}", timeValueMillis(recoveryState.getTimer().time()), sb)__            } else if (logger.isDebugEnabled()) {_                logger.debug("recovery completed from [shard_store], took [{}]", timeValueMillis(recoveryState.getTimer().time()))__            }_            return true__        } catch (IndexShardRecoveryException e) {_            if (indexShard.state() == IndexShardState.CLOSED) {_                _                return false__            }_            if ((e.getCause() instanceof IndexShardClosedException) || (e.getCause() instanceof IndexShardNotStartedException)) {_                _                return false__            }_            throw e__        } catch (IndexShardClosedException | IndexShardNotStartedException e) {_        } catch (Exception e) {_            if (indexShard.state() == IndexShardState.CLOSED) {_                _                return false__            }_            throw new IndexShardRecoveryException(shardId, "failed recovery", e)__        }_        return false__    };recovers,the,state,of,the,shard,from,the,store;private,boolean,execute,recovery,final,index,shard,index,shard,runnable,recovery,runnable,throws,index,shard,recovery,exception,try,recovery,runnable,run,final,index,shard,state,shard,state,index,shard,state,final,recovery,state,recovery,state,index,shard,recovery,state,assert,shard,state,index,shard,state,created,shard,state,index,shard,state,recovering,recovery,process,of,shard,id,didn,t,get,to,shard,state,shard,state,if,logger,is,trace,enabled,recovery,state,index,index,recovery,state,get,index,string,builder,sb,new,string,builder,sb,append,index,files,append,index,total,file,count,append,with,append,new,byte,size,value,index,total,bytes,append,took,append,time,value,time,value,millis,index,time,append,n,sb,append,append,index,recovered,file,count,append,with,append,new,byte,size,value,index,recovered,bytes,append,n,sb,append,append,index,reused,file,count,append,with,append,new,byte,size,value,index,reused,bytes,append,n,sb,append,took,append,time,value,time,value,millis,recovery,state,get,verify,index,time,append,append,time,value,millis,recovery,state,get,verify,index,check,index,time,append,n,sb,append,translog,append,recovery,state,get,translog,recovered,operations,append,took,append,time,value,time,value,millis,recovery,state,get,translog,time,append,logger,trace,recovery,completed,from,took,n,time,value,millis,recovery,state,get,timer,time,sb,else,if,logger,is,debug,enabled,logger,debug,recovery,completed,from,took,time,value,millis,recovery,state,get,timer,time,return,true,catch,index,shard,recovery,exception,e,if,index,shard,state,index,shard,state,closed,return,false,if,e,get,cause,instanceof,index,shard,closed,exception,e,get,cause,instanceof,index,shard,not,started,exception,return,false,throw,e,catch,index,shard,closed,exception,index,shard,not,started,exception,e,catch,exception,e,if,index,shard,state,index,shard,state,closed,return,false,throw,new,index,shard,recovery,exception,shard,id,failed,recovery,e,return,false
StoreRecovery -> private boolean executeRecovery(final IndexShard indexShard, Runnable recoveryRunnable) throws IndexShardRecoveryException;1533295538;Recovers the state of the shard from the store.;private boolean executeRecovery(final IndexShard indexShard, Runnable recoveryRunnable) throws IndexShardRecoveryException {_        try {_            recoveryRunnable.run()__            _            _            final IndexShardState shardState = indexShard.state()__            final RecoveryState recoveryState = indexShard.recoveryState()__            assert shardState != IndexShardState.CREATED && shardState != IndexShardState.RECOVERING : "recovery process of " + shardId + " didn't get to post_recovery. shardState [" + shardState + "]"___            if (logger.isTraceEnabled()) {_                RecoveryState.Index index = recoveryState.getIndex()__                StringBuilder sb = new StringBuilder()__                sb.append("    index    : files           [").append(index.totalFileCount()).append("] with total_size [")_                        .append(new ByteSizeValue(index.totalBytes())).append("], took[")_                        .append(TimeValue.timeValueMillis(index.time())).append("]\n")__                sb.append("             : recovered_files [").append(index.recoveredFileCount()).append("] with total_size [")_                        .append(new ByteSizeValue(index.recoveredBytes())).append("]\n")__                sb.append("             : reusing_files   [").append(index.reusedFileCount()).append("] with total_size [")_                        .append(new ByteSizeValue(index.reusedBytes())).append("]\n")__                sb.append("    verify_index    : took [").append(TimeValue.timeValueMillis(recoveryState.getVerifyIndex().time())).append("], check_index [")_                        .append(timeValueMillis(recoveryState.getVerifyIndex().checkIndexTime())).append("]\n")__                sb.append("    translog : number_of_operations [").append(recoveryState.getTranslog().recoveredOperations())_                        .append("], took [").append(TimeValue.timeValueMillis(recoveryState.getTranslog().time())).append("]")__                logger.trace("recovery completed from [shard_store], took [{}]\n{}", timeValueMillis(recoveryState.getTimer().time()), sb)__            } else if (logger.isDebugEnabled()) {_                logger.debug("recovery completed from [shard_store], took [{}]", timeValueMillis(recoveryState.getTimer().time()))__            }_            return true__        } catch (IndexShardRecoveryException e) {_            if (indexShard.state() == IndexShardState.CLOSED) {_                _                return false__            }_            if ((e.getCause() instanceof IndexShardClosedException) || (e.getCause() instanceof IndexShardNotStartedException)) {_                _                return false__            }_            throw e__        } catch (IndexShardClosedException | IndexShardNotStartedException e) {_        } catch (Exception e) {_            if (indexShard.state() == IndexShardState.CLOSED) {_                _                return false__            }_            throw new IndexShardRecoveryException(shardId, "failed recovery", e)__        }_        return false__    };recovers,the,state,of,the,shard,from,the,store;private,boolean,execute,recovery,final,index,shard,index,shard,runnable,recovery,runnable,throws,index,shard,recovery,exception,try,recovery,runnable,run,final,index,shard,state,shard,state,index,shard,state,final,recovery,state,recovery,state,index,shard,recovery,state,assert,shard,state,index,shard,state,created,shard,state,index,shard,state,recovering,recovery,process,of,shard,id,didn,t,get,to,shard,state,shard,state,if,logger,is,trace,enabled,recovery,state,index,index,recovery,state,get,index,string,builder,sb,new,string,builder,sb,append,index,files,append,index,total,file,count,append,with,append,new,byte,size,value,index,total,bytes,append,took,append,time,value,time,value,millis,index,time,append,n,sb,append,append,index,recovered,file,count,append,with,append,new,byte,size,value,index,recovered,bytes,append,n,sb,append,append,index,reused,file,count,append,with,append,new,byte,size,value,index,reused,bytes,append,n,sb,append,took,append,time,value,time,value,millis,recovery,state,get,verify,index,time,append,append,time,value,millis,recovery,state,get,verify,index,check,index,time,append,n,sb,append,translog,append,recovery,state,get,translog,recovered,operations,append,took,append,time,value,time,value,millis,recovery,state,get,translog,time,append,logger,trace,recovery,completed,from,took,n,time,value,millis,recovery,state,get,timer,time,sb,else,if,logger,is,debug,enabled,logger,debug,recovery,completed,from,took,time,value,millis,recovery,state,get,timer,time,return,true,catch,index,shard,recovery,exception,e,if,index,shard,state,index,shard,state,closed,return,false,if,e,get,cause,instanceof,index,shard,closed,exception,e,get,cause,instanceof,index,shard,not,started,exception,return,false,throw,e,catch,index,shard,closed,exception,index,shard,not,started,exception,e,catch,exception,e,if,index,shard,state,index,shard,state,closed,return,false,throw,new,index,shard,recovery,exception,shard,id,failed,recovery,e,return,false
StoreRecovery -> private boolean executeRecovery(final IndexShard indexShard, Runnable recoveryRunnable) throws IndexShardRecoveryException;1535723122;Recovers the state of the shard from the store.;private boolean executeRecovery(final IndexShard indexShard, Runnable recoveryRunnable) throws IndexShardRecoveryException {_        try {_            recoveryRunnable.run()__            _            _            final IndexShardState shardState = indexShard.state()__            final RecoveryState recoveryState = indexShard.recoveryState()__            assert shardState != IndexShardState.CREATED && shardState != IndexShardState.RECOVERING : "recovery process of " + shardId + " didn't get to post_recovery. shardState [" + shardState + "]"___            if (logger.isTraceEnabled()) {_                RecoveryState.Index index = recoveryState.getIndex()__                StringBuilder sb = new StringBuilder()__                sb.append("    index    : files           [").append(index.totalFileCount()).append("] with total_size [")_                        .append(new ByteSizeValue(index.totalBytes())).append("], took[")_                        .append(TimeValue.timeValueMillis(index.time())).append("]\n")__                sb.append("             : recovered_files [").append(index.recoveredFileCount()).append("] with total_size [")_                        .append(new ByteSizeValue(index.recoveredBytes())).append("]\n")__                sb.append("             : reusing_files   [").append(index.reusedFileCount()).append("] with total_size [")_                        .append(new ByteSizeValue(index.reusedBytes())).append("]\n")__                sb.append("    verify_index    : took [").append(TimeValue.timeValueMillis(recoveryState.getVerifyIndex().time())).append("], check_index [")_                        .append(timeValueMillis(recoveryState.getVerifyIndex().checkIndexTime())).append("]\n")__                sb.append("    translog : number_of_operations [").append(recoveryState.getTranslog().recoveredOperations())_                        .append("], took [").append(TimeValue.timeValueMillis(recoveryState.getTranslog().time())).append("]")__                logger.trace("recovery completed from [shard_store], took [{}]\n{}", timeValueMillis(recoveryState.getTimer().time()), sb)__            } else if (logger.isDebugEnabled()) {_                logger.debug("recovery completed from [shard_store], took [{}]", timeValueMillis(recoveryState.getTimer().time()))__            }_            return true__        } catch (IndexShardRecoveryException e) {_            if (indexShard.state() == IndexShardState.CLOSED) {_                _                return false__            }_            if ((e.getCause() instanceof IndexShardClosedException) || (e.getCause() instanceof IndexShardNotStartedException)) {_                _                return false__            }_            throw e__        } catch (IndexShardClosedException | IndexShardNotStartedException e) {_        } catch (Exception e) {_            if (indexShard.state() == IndexShardState.CLOSED) {_                _                return false__            }_            throw new IndexShardRecoveryException(shardId, "failed recovery", e)__        }_        return false__    };recovers,the,state,of,the,shard,from,the,store;private,boolean,execute,recovery,final,index,shard,index,shard,runnable,recovery,runnable,throws,index,shard,recovery,exception,try,recovery,runnable,run,final,index,shard,state,shard,state,index,shard,state,final,recovery,state,recovery,state,index,shard,recovery,state,assert,shard,state,index,shard,state,created,shard,state,index,shard,state,recovering,recovery,process,of,shard,id,didn,t,get,to,shard,state,shard,state,if,logger,is,trace,enabled,recovery,state,index,index,recovery,state,get,index,string,builder,sb,new,string,builder,sb,append,index,files,append,index,total,file,count,append,with,append,new,byte,size,value,index,total,bytes,append,took,append,time,value,time,value,millis,index,time,append,n,sb,append,append,index,recovered,file,count,append,with,append,new,byte,size,value,index,recovered,bytes,append,n,sb,append,append,index,reused,file,count,append,with,append,new,byte,size,value,index,reused,bytes,append,n,sb,append,took,append,time,value,time,value,millis,recovery,state,get,verify,index,time,append,append,time,value,millis,recovery,state,get,verify,index,check,index,time,append,n,sb,append,translog,append,recovery,state,get,translog,recovered,operations,append,took,append,time,value,time,value,millis,recovery,state,get,translog,time,append,logger,trace,recovery,completed,from,took,n,time,value,millis,recovery,state,get,timer,time,sb,else,if,logger,is,debug,enabled,logger,debug,recovery,completed,from,took,time,value,millis,recovery,state,get,timer,time,return,true,catch,index,shard,recovery,exception,e,if,index,shard,state,index,shard,state,closed,return,false,if,e,get,cause,instanceof,index,shard,closed,exception,e,get,cause,instanceof,index,shard,not,started,exception,return,false,throw,e,catch,index,shard,closed,exception,index,shard,not,started,exception,e,catch,exception,e,if,index,shard,state,index,shard,state,closed,return,false,throw,new,index,shard,recovery,exception,shard,id,failed,recovery,e,return,false
StoreRecovery -> private boolean executeRecovery(final IndexShard indexShard, Runnable recoveryRunnable) throws IndexShardRecoveryException;1536611444;Recovers the state of the shard from the store.;private boolean executeRecovery(final IndexShard indexShard, Runnable recoveryRunnable) throws IndexShardRecoveryException {_        try {_            recoveryRunnable.run()__            _            _            final IndexShardState shardState = indexShard.state()__            final RecoveryState recoveryState = indexShard.recoveryState()__            assert shardState != IndexShardState.CREATED && shardState != IndexShardState.RECOVERING : "recovery process of " + shardId + " didn't get to post_recovery. shardState [" + shardState + "]"___            if (logger.isTraceEnabled()) {_                RecoveryState.Index index = recoveryState.getIndex()__                StringBuilder sb = new StringBuilder()__                sb.append("    index    : files           [").append(index.totalFileCount()).append("] with total_size [")_                        .append(new ByteSizeValue(index.totalBytes())).append("], took[")_                        .append(TimeValue.timeValueMillis(index.time())).append("]\n")__                sb.append("             : recovered_files [").append(index.recoveredFileCount()).append("] with total_size [")_                        .append(new ByteSizeValue(index.recoveredBytes())).append("]\n")__                sb.append("             : reusing_files   [").append(index.reusedFileCount()).append("] with total_size [")_                        .append(new ByteSizeValue(index.reusedBytes())).append("]\n")__                sb.append("    verify_index    : took [").append(TimeValue.timeValueMillis(recoveryState.getVerifyIndex().time())).append("], check_index [")_                        .append(timeValueMillis(recoveryState.getVerifyIndex().checkIndexTime())).append("]\n")__                sb.append("    translog : number_of_operations [").append(recoveryState.getTranslog().recoveredOperations())_                        .append("], took [").append(TimeValue.timeValueMillis(recoveryState.getTranslog().time())).append("]")__                logger.trace("recovery completed from [shard_store], took [{}]\n{}", timeValueMillis(recoveryState.getTimer().time()), sb)__            } else if (logger.isDebugEnabled()) {_                logger.debug("recovery completed from [shard_store], took [{}]", timeValueMillis(recoveryState.getTimer().time()))__            }_            return true__        } catch (IndexShardRecoveryException e) {_            if (indexShard.state() == IndexShardState.CLOSED) {_                _                return false__            }_            if ((e.getCause() instanceof IndexShardClosedException) || (e.getCause() instanceof IndexShardNotStartedException)) {_                _                return false__            }_            throw e__        } catch (IndexShardClosedException | IndexShardNotStartedException e) {_        } catch (Exception e) {_            if (indexShard.state() == IndexShardState.CLOSED) {_                _                return false__            }_            throw new IndexShardRecoveryException(shardId, "failed recovery", e)__        }_        return false__    };recovers,the,state,of,the,shard,from,the,store;private,boolean,execute,recovery,final,index,shard,index,shard,runnable,recovery,runnable,throws,index,shard,recovery,exception,try,recovery,runnable,run,final,index,shard,state,shard,state,index,shard,state,final,recovery,state,recovery,state,index,shard,recovery,state,assert,shard,state,index,shard,state,created,shard,state,index,shard,state,recovering,recovery,process,of,shard,id,didn,t,get,to,shard,state,shard,state,if,logger,is,trace,enabled,recovery,state,index,index,recovery,state,get,index,string,builder,sb,new,string,builder,sb,append,index,files,append,index,total,file,count,append,with,append,new,byte,size,value,index,total,bytes,append,took,append,time,value,time,value,millis,index,time,append,n,sb,append,append,index,recovered,file,count,append,with,append,new,byte,size,value,index,recovered,bytes,append,n,sb,append,append,index,reused,file,count,append,with,append,new,byte,size,value,index,reused,bytes,append,n,sb,append,took,append,time,value,time,value,millis,recovery,state,get,verify,index,time,append,append,time,value,millis,recovery,state,get,verify,index,check,index,time,append,n,sb,append,translog,append,recovery,state,get,translog,recovered,operations,append,took,append,time,value,time,value,millis,recovery,state,get,translog,time,append,logger,trace,recovery,completed,from,took,n,time,value,millis,recovery,state,get,timer,time,sb,else,if,logger,is,debug,enabled,logger,debug,recovery,completed,from,took,time,value,millis,recovery,state,get,timer,time,return,true,catch,index,shard,recovery,exception,e,if,index,shard,state,index,shard,state,closed,return,false,if,e,get,cause,instanceof,index,shard,closed,exception,e,get,cause,instanceof,index,shard,not,started,exception,return,false,throw,e,catch,index,shard,closed,exception,index,shard,not,started,exception,e,catch,exception,e,if,index,shard,state,index,shard,state,closed,return,false,throw,new,index,shard,recovery,exception,shard,id,failed,recovery,e,return,false
StoreRecovery -> private boolean executeRecovery(final IndexShard indexShard, Runnable recoveryRunnable) throws IndexShardRecoveryException;1538067637;Recovers the state of the shard from the store.;private boolean executeRecovery(final IndexShard indexShard, Runnable recoveryRunnable) throws IndexShardRecoveryException {_        try {_            recoveryRunnable.run()__            _            _            final IndexShardState shardState = indexShard.state()__            final RecoveryState recoveryState = indexShard.recoveryState()__            assert shardState != IndexShardState.CREATED && shardState != IndexShardState.RECOVERING : "recovery process of " + shardId + " didn't get to post_recovery. shardState [" + shardState + "]"___            if (logger.isTraceEnabled()) {_                RecoveryState.Index index = recoveryState.getIndex()__                StringBuilder sb = new StringBuilder()__                sb.append("    index    : files           [").append(index.totalFileCount()).append("] with total_size [")_                        .append(new ByteSizeValue(index.totalBytes())).append("], took[")_                        .append(TimeValue.timeValueMillis(index.time())).append("]\n")__                sb.append("             : recovered_files [").append(index.recoveredFileCount()).append("] with total_size [")_                        .append(new ByteSizeValue(index.recoveredBytes())).append("]\n")__                sb.append("             : reusing_files   [").append(index.reusedFileCount()).append("] with total_size [")_                        .append(new ByteSizeValue(index.reusedBytes())).append("]\n")__                sb.append("    verify_index    : took [").append(TimeValue.timeValueMillis(recoveryState.getVerifyIndex().time())).append("], check_index [")_                        .append(timeValueMillis(recoveryState.getVerifyIndex().checkIndexTime())).append("]\n")__                sb.append("    translog : number_of_operations [").append(recoveryState.getTranslog().recoveredOperations())_                        .append("], took [").append(TimeValue.timeValueMillis(recoveryState.getTranslog().time())).append("]")__                logger.trace("recovery completed from [shard_store], took [{}]\n{}", timeValueMillis(recoveryState.getTimer().time()), sb)__            } else if (logger.isDebugEnabled()) {_                logger.debug("recovery completed from [shard_store], took [{}]", timeValueMillis(recoveryState.getTimer().time()))__            }_            return true__        } catch (IndexShardRecoveryException e) {_            if (indexShard.state() == IndexShardState.CLOSED) {_                _                return false__            }_            if ((e.getCause() instanceof IndexShardClosedException) || (e.getCause() instanceof IndexShardNotStartedException)) {_                _                return false__            }_            throw e__        } catch (IndexShardClosedException | IndexShardNotStartedException e) {_        } catch (Exception e) {_            if (indexShard.state() == IndexShardState.CLOSED) {_                _                return false__            }_            throw new IndexShardRecoveryException(shardId, "failed recovery", e)__        }_        return false__    };recovers,the,state,of,the,shard,from,the,store;private,boolean,execute,recovery,final,index,shard,index,shard,runnable,recovery,runnable,throws,index,shard,recovery,exception,try,recovery,runnable,run,final,index,shard,state,shard,state,index,shard,state,final,recovery,state,recovery,state,index,shard,recovery,state,assert,shard,state,index,shard,state,created,shard,state,index,shard,state,recovering,recovery,process,of,shard,id,didn,t,get,to,shard,state,shard,state,if,logger,is,trace,enabled,recovery,state,index,index,recovery,state,get,index,string,builder,sb,new,string,builder,sb,append,index,files,append,index,total,file,count,append,with,append,new,byte,size,value,index,total,bytes,append,took,append,time,value,time,value,millis,index,time,append,n,sb,append,append,index,recovered,file,count,append,with,append,new,byte,size,value,index,recovered,bytes,append,n,sb,append,append,index,reused,file,count,append,with,append,new,byte,size,value,index,reused,bytes,append,n,sb,append,took,append,time,value,time,value,millis,recovery,state,get,verify,index,time,append,append,time,value,millis,recovery,state,get,verify,index,check,index,time,append,n,sb,append,translog,append,recovery,state,get,translog,recovered,operations,append,took,append,time,value,time,value,millis,recovery,state,get,translog,time,append,logger,trace,recovery,completed,from,took,n,time,value,millis,recovery,state,get,timer,time,sb,else,if,logger,is,debug,enabled,logger,debug,recovery,completed,from,took,time,value,millis,recovery,state,get,timer,time,return,true,catch,index,shard,recovery,exception,e,if,index,shard,state,index,shard,state,closed,return,false,if,e,get,cause,instanceof,index,shard,closed,exception,e,get,cause,instanceof,index,shard,not,started,exception,return,false,throw,e,catch,index,shard,closed,exception,index,shard,not,started,exception,e,catch,exception,e,if,index,shard,state,index,shard,state,closed,return,false,throw,new,index,shard,recovery,exception,shard,id,failed,recovery,e,return,false
StoreRecovery -> private boolean executeRecovery(final IndexShard indexShard, Runnable recoveryRunnable) throws IndexShardRecoveryException;1542697754;Recovers the state of the shard from the store.;private boolean executeRecovery(final IndexShard indexShard, Runnable recoveryRunnable) throws IndexShardRecoveryException {_        try {_            recoveryRunnable.run()__            _            _            final IndexShardState shardState = indexShard.state()__            final RecoveryState recoveryState = indexShard.recoveryState()__            assert shardState != IndexShardState.CREATED && shardState != IndexShardState.RECOVERING :_                "recovery process of " + shardId + " didn't get to post_recovery. shardState [" + shardState + "]"___            if (logger.isTraceEnabled()) {_                RecoveryState.Index index = recoveryState.getIndex()__                StringBuilder sb = new StringBuilder()__                sb.append("    index    : files           [").append(index.totalFileCount()).append("] with total_size [")_                        .append(new ByteSizeValue(index.totalBytes())).append("], took[")_                        .append(TimeValue.timeValueMillis(index.time())).append("]\n")__                sb.append("             : recovered_files [").append(index.recoveredFileCount()).append("] with total_size [")_                        .append(new ByteSizeValue(index.recoveredBytes())).append("]\n")__                sb.append("             : reusing_files   [").append(index.reusedFileCount()).append("] with total_size [")_                        .append(new ByteSizeValue(index.reusedBytes())).append("]\n")__                sb.append("    verify_index    : took [")_                    .append(TimeValue.timeValueMillis(recoveryState.getVerifyIndex().time())).append("], check_index [")_                    .append(timeValueMillis(recoveryState.getVerifyIndex().checkIndexTime())).append("]\n")__                sb.append("    translog : number_of_operations [").append(recoveryState.getTranslog().recoveredOperations())_                        .append("], took [").append(TimeValue.timeValueMillis(recoveryState.getTranslog().time())).append("]")__                logger.trace("recovery completed from [shard_store], took [{}]\n{}",_                    timeValueMillis(recoveryState.getTimer().time()), sb)__            } else if (logger.isDebugEnabled()) {_                logger.debug("recovery completed from [shard_store], took [{}]", timeValueMillis(recoveryState.getTimer().time()))__            }_            return true__        } catch (IndexShardRecoveryException e) {_            if (indexShard.state() == IndexShardState.CLOSED) {_                _                return false__            }_            if ((e.getCause() instanceof IndexShardClosedException) || (e.getCause() instanceof IndexShardNotStartedException)) {_                _                return false__            }_            throw e__        } catch (IndexShardClosedException | IndexShardNotStartedException e) {_        } catch (Exception e) {_            if (indexShard.state() == IndexShardState.CLOSED) {_                _                return false__            }_            throw new IndexShardRecoveryException(shardId, "failed recovery", e)__        }_        return false__    };recovers,the,state,of,the,shard,from,the,store;private,boolean,execute,recovery,final,index,shard,index,shard,runnable,recovery,runnable,throws,index,shard,recovery,exception,try,recovery,runnable,run,final,index,shard,state,shard,state,index,shard,state,final,recovery,state,recovery,state,index,shard,recovery,state,assert,shard,state,index,shard,state,created,shard,state,index,shard,state,recovering,recovery,process,of,shard,id,didn,t,get,to,shard,state,shard,state,if,logger,is,trace,enabled,recovery,state,index,index,recovery,state,get,index,string,builder,sb,new,string,builder,sb,append,index,files,append,index,total,file,count,append,with,append,new,byte,size,value,index,total,bytes,append,took,append,time,value,time,value,millis,index,time,append,n,sb,append,append,index,recovered,file,count,append,with,append,new,byte,size,value,index,recovered,bytes,append,n,sb,append,append,index,reused,file,count,append,with,append,new,byte,size,value,index,reused,bytes,append,n,sb,append,took,append,time,value,time,value,millis,recovery,state,get,verify,index,time,append,append,time,value,millis,recovery,state,get,verify,index,check,index,time,append,n,sb,append,translog,append,recovery,state,get,translog,recovered,operations,append,took,append,time,value,time,value,millis,recovery,state,get,translog,time,append,logger,trace,recovery,completed,from,took,n,time,value,millis,recovery,state,get,timer,time,sb,else,if,logger,is,debug,enabled,logger,debug,recovery,completed,from,took,time,value,millis,recovery,state,get,timer,time,return,true,catch,index,shard,recovery,exception,e,if,index,shard,state,index,shard,state,closed,return,false,if,e,get,cause,instanceof,index,shard,closed,exception,e,get,cause,instanceof,index,shard,not,started,exception,return,false,throw,e,catch,index,shard,closed,exception,index,shard,not,started,exception,e,catch,exception,e,if,index,shard,state,index,shard,state,closed,return,false,throw,new,index,shard,recovery,exception,shard,id,failed,recovery,e,return,false
StoreRecovery -> private boolean executeRecovery(final IndexShard indexShard, Runnable recoveryRunnable) throws IndexShardRecoveryException;1543942400;Recovers the state of the shard from the store.;private boolean executeRecovery(final IndexShard indexShard, Runnable recoveryRunnable) throws IndexShardRecoveryException {_        try {_            recoveryRunnable.run()__            _            _            final IndexShardState shardState = indexShard.state()__            final RecoveryState recoveryState = indexShard.recoveryState()__            assert shardState != IndexShardState.CREATED && shardState != IndexShardState.RECOVERING :_                "recovery process of " + shardId + " didn't get to post_recovery. shardState [" + shardState + "]"___            if (logger.isTraceEnabled()) {_                RecoveryState.Index index = recoveryState.getIndex()__                StringBuilder sb = new StringBuilder()__                sb.append("    index    : files           [").append(index.totalFileCount()).append("] with total_size [")_                        .append(new ByteSizeValue(index.totalBytes())).append("], took[")_                        .append(TimeValue.timeValueMillis(index.time())).append("]\n")__                sb.append("             : recovered_files [").append(index.recoveredFileCount()).append("] with total_size [")_                        .append(new ByteSizeValue(index.recoveredBytes())).append("]\n")__                sb.append("             : reusing_files   [").append(index.reusedFileCount()).append("] with total_size [")_                        .append(new ByteSizeValue(index.reusedBytes())).append("]\n")__                sb.append("    verify_index    : took [")_                    .append(TimeValue.timeValueMillis(recoveryState.getVerifyIndex().time())).append("], check_index [")_                    .append(timeValueMillis(recoveryState.getVerifyIndex().checkIndexTime())).append("]\n")__                sb.append("    translog : number_of_operations [").append(recoveryState.getTranslog().recoveredOperations())_                        .append("], took [").append(TimeValue.timeValueMillis(recoveryState.getTranslog().time())).append("]")__                logger.trace("recovery completed from [shard_store], took [{}]\n{}",_                    timeValueMillis(recoveryState.getTimer().time()), sb)__            } else if (logger.isDebugEnabled()) {_                logger.debug("recovery completed from [shard_store], took [{}]", timeValueMillis(recoveryState.getTimer().time()))__            }_            return true__        } catch (IndexShardRecoveryException e) {_            if (indexShard.state() == IndexShardState.CLOSED) {_                _                return false__            }_            if ((e.getCause() instanceof IndexShardClosedException) || (e.getCause() instanceof IndexShardNotStartedException)) {_                _                return false__            }_            throw e__        } catch (IndexShardClosedException | IndexShardNotStartedException e) {_        } catch (Exception e) {_            if (indexShard.state() == IndexShardState.CLOSED) {_                _                return false__            }_            throw new IndexShardRecoveryException(shardId, "failed recovery", e)__        }_        return false__    };recovers,the,state,of,the,shard,from,the,store;private,boolean,execute,recovery,final,index,shard,index,shard,runnable,recovery,runnable,throws,index,shard,recovery,exception,try,recovery,runnable,run,final,index,shard,state,shard,state,index,shard,state,final,recovery,state,recovery,state,index,shard,recovery,state,assert,shard,state,index,shard,state,created,shard,state,index,shard,state,recovering,recovery,process,of,shard,id,didn,t,get,to,shard,state,shard,state,if,logger,is,trace,enabled,recovery,state,index,index,recovery,state,get,index,string,builder,sb,new,string,builder,sb,append,index,files,append,index,total,file,count,append,with,append,new,byte,size,value,index,total,bytes,append,took,append,time,value,time,value,millis,index,time,append,n,sb,append,append,index,recovered,file,count,append,with,append,new,byte,size,value,index,recovered,bytes,append,n,sb,append,append,index,reused,file,count,append,with,append,new,byte,size,value,index,reused,bytes,append,n,sb,append,took,append,time,value,time,value,millis,recovery,state,get,verify,index,time,append,append,time,value,millis,recovery,state,get,verify,index,check,index,time,append,n,sb,append,translog,append,recovery,state,get,translog,recovered,operations,append,took,append,time,value,time,value,millis,recovery,state,get,translog,time,append,logger,trace,recovery,completed,from,took,n,time,value,millis,recovery,state,get,timer,time,sb,else,if,logger,is,debug,enabled,logger,debug,recovery,completed,from,took,time,value,millis,recovery,state,get,timer,time,return,true,catch,index,shard,recovery,exception,e,if,index,shard,state,index,shard,state,closed,return,false,if,e,get,cause,instanceof,index,shard,closed,exception,e,get,cause,instanceof,index,shard,not,started,exception,return,false,throw,e,catch,index,shard,closed,exception,index,shard,not,started,exception,e,catch,exception,e,if,index,shard,state,index,shard,state,closed,return,false,throw,new,index,shard,recovery,exception,shard,id,failed,recovery,e,return,false
StoreRecovery -> private boolean executeRecovery(final IndexShard indexShard, Runnable recoveryRunnable) throws IndexShardRecoveryException;1549395161;Recovers the state of the shard from the store.;private boolean executeRecovery(final IndexShard indexShard, Runnable recoveryRunnable) throws IndexShardRecoveryException {_        try {_            recoveryRunnable.run()__            _            _            final IndexShardState shardState = indexShard.state()__            final RecoveryState recoveryState = indexShard.recoveryState()__            assert shardState != IndexShardState.CREATED && shardState != IndexShardState.RECOVERING :_                "recovery process of " + shardId + " didn't get to post_recovery. shardState [" + shardState + "]"___            if (logger.isTraceEnabled()) {_                RecoveryState.Index index = recoveryState.getIndex()__                StringBuilder sb = new StringBuilder()__                sb.append("    index    : files           [").append(index.totalFileCount()).append("] with total_size [")_                        .append(new ByteSizeValue(index.totalBytes())).append("], took[")_                        .append(TimeValue.timeValueMillis(index.time())).append("]\n")__                sb.append("             : recovered_files [").append(index.recoveredFileCount()).append("] with total_size [")_                        .append(new ByteSizeValue(index.recoveredBytes())).append("]\n")__                sb.append("             : reusing_files   [").append(index.reusedFileCount()).append("] with total_size [")_                        .append(new ByteSizeValue(index.reusedBytes())).append("]\n")__                sb.append("    verify_index    : took [")_                    .append(TimeValue.timeValueMillis(recoveryState.getVerifyIndex().time())).append("], check_index [")_                    .append(timeValueMillis(recoveryState.getVerifyIndex().checkIndexTime())).append("]\n")__                sb.append("    translog : number_of_operations [").append(recoveryState.getTranslog().recoveredOperations())_                        .append("], took [").append(TimeValue.timeValueMillis(recoveryState.getTranslog().time())).append("]")__                logger.trace("recovery completed from [shard_store], took [{}]\n{}",_                    timeValueMillis(recoveryState.getTimer().time()), sb)__            } else if (logger.isDebugEnabled()) {_                logger.debug("recovery completed from [shard_store], took [{}]", timeValueMillis(recoveryState.getTimer().time()))__            }_            return true__        } catch (IndexShardRecoveryException e) {_            if (indexShard.state() == IndexShardState.CLOSED) {_                _                return false__            }_            if ((e.getCause() instanceof IndexShardClosedException) || (e.getCause() instanceof IndexShardNotStartedException)) {_                _                return false__            }_            throw e__        } catch (IndexShardClosedException | IndexShardNotStartedException e) {_        } catch (Exception e) {_            if (indexShard.state() == IndexShardState.CLOSED) {_                _                return false__            }_            throw new IndexShardRecoveryException(shardId, "failed recovery", e)__        }_        return false__    };recovers,the,state,of,the,shard,from,the,store;private,boolean,execute,recovery,final,index,shard,index,shard,runnable,recovery,runnable,throws,index,shard,recovery,exception,try,recovery,runnable,run,final,index,shard,state,shard,state,index,shard,state,final,recovery,state,recovery,state,index,shard,recovery,state,assert,shard,state,index,shard,state,created,shard,state,index,shard,state,recovering,recovery,process,of,shard,id,didn,t,get,to,shard,state,shard,state,if,logger,is,trace,enabled,recovery,state,index,index,recovery,state,get,index,string,builder,sb,new,string,builder,sb,append,index,files,append,index,total,file,count,append,with,append,new,byte,size,value,index,total,bytes,append,took,append,time,value,time,value,millis,index,time,append,n,sb,append,append,index,recovered,file,count,append,with,append,new,byte,size,value,index,recovered,bytes,append,n,sb,append,append,index,reused,file,count,append,with,append,new,byte,size,value,index,reused,bytes,append,n,sb,append,took,append,time,value,time,value,millis,recovery,state,get,verify,index,time,append,append,time,value,millis,recovery,state,get,verify,index,check,index,time,append,n,sb,append,translog,append,recovery,state,get,translog,recovered,operations,append,took,append,time,value,time,value,millis,recovery,state,get,translog,time,append,logger,trace,recovery,completed,from,took,n,time,value,millis,recovery,state,get,timer,time,sb,else,if,logger,is,debug,enabled,logger,debug,recovery,completed,from,took,time,value,millis,recovery,state,get,timer,time,return,true,catch,index,shard,recovery,exception,e,if,index,shard,state,index,shard,state,closed,return,false,if,e,get,cause,instanceof,index,shard,closed,exception,e,get,cause,instanceof,index,shard,not,started,exception,return,false,throw,e,catch,index,shard,closed,exception,index,shard,not,started,exception,e,catch,exception,e,if,index,shard,state,index,shard,state,closed,return,false,throw,new,index,shard,recovery,exception,shard,id,failed,recovery,e,return,false
StoreRecovery -> private void internalRecoverFromStore(IndexShard indexShard) throws IndexShardRecoveryException;1524684173;Recovers the state of the shard from the store.;private void internalRecoverFromStore(IndexShard indexShard) throws IndexShardRecoveryException {_        final RecoveryState recoveryState = indexShard.recoveryState()__        final boolean indexShouldExists = recoveryState.getRecoverySource().getType() != RecoverySource.Type.EMPTY_STORE__        indexShard.prepareForIndexRecovery()__        long version = -1__        SegmentInfos si = null__        final Store store = indexShard.store()__        store.incRef()__        try {_            try {_                store.failIfCorrupted()__                try {_                    si = store.readLastCommittedSegmentsInfo()__                } catch (Exception e) {_                    String files = "_unknown_"__                    try {_                        files = Arrays.toString(store.directory().listAll())__                    } catch (Exception inner) {_                        inner.addSuppressed(e)__                        files += " (failure=" + ExceptionsHelper.detailedMessage(inner) + ")"__                    }_                    if (indexShouldExists) {_                        throw new IndexShardRecoveryException(shardId, "shard allocated for local recovery (post api), should exist, but doesn't, current files: " + files, e)__                    }_                }_                if (si != null) {_                    if (indexShouldExists) {_                        version = si.getVersion()__                    } else {_                        _                        _                        logger.trace("cleaning existing shard, shouldn't exists")__                        Lucene.cleanLuceneIndex(store.directory())__                        si = null__                    }_                }_            } catch (Exception e) {_                throw new IndexShardRecoveryException(shardId, "failed to fetch index version after copying it over", e)__            }_            recoveryState.getIndex().updateVersion(version)__            if (recoveryState.getRecoverySource().getType() == RecoverySource.Type.LOCAL_SHARDS) {_                assert indexShouldExists__                store.bootstrapNewHistory()__                final SegmentInfos segmentInfos = store.readLastCommittedSegmentsInfo()__                final long maxSeqNo = Long.parseLong(segmentInfos.userData.get(SequenceNumbers.MAX_SEQ_NO))__                final String translogUUID = Translog.createEmptyTranslog(_                    indexShard.shardPath().resolveTranslog(), maxSeqNo, shardId, indexShard.getPrimaryTerm())__                store.associateIndexWithNewTranslog(translogUUID)__            } else if (indexShouldExists) {_                _                try {_                    final RecoveryState.Index index = recoveryState.getIndex()__                    if (si != null) {_                        addRecoveredFileDetails(si, store, index)__                    }_                } catch (IOException e) {_                    logger.debug("failed to list file details", e)__                }_            } else {_                store.createEmpty()__                final String translogUUID = Translog.createEmptyTranslog(_                    indexShard.shardPath().resolveTranslog(), SequenceNumbers.NO_OPS_PERFORMED, shardId, indexShard.getPrimaryTerm())__                store.associateIndexWithNewTranslog(translogUUID)__            }_            indexShard.openEngineAndRecoverFromTranslog()__            indexShard.getEngine().fillSeqNoGaps(indexShard.getPrimaryTerm())__            indexShard.finalizeRecovery()__            indexShard.postRecovery("post recovery from shard_store")__        } catch (EngineException | IOException e) {_            throw new IndexShardRecoveryException(shardId, "failed to recover from gateway", e)__        } finally {_            store.decRef()__        }_    };recovers,the,state,of,the,shard,from,the,store;private,void,internal,recover,from,store,index,shard,index,shard,throws,index,shard,recovery,exception,final,recovery,state,recovery,state,index,shard,recovery,state,final,boolean,index,should,exists,recovery,state,get,recovery,source,get,type,recovery,source,type,index,shard,prepare,for,index,recovery,long,version,1,segment,infos,si,null,final,store,store,index,shard,store,store,inc,ref,try,try,store,fail,if,corrupted,try,si,store,read,last,committed,segments,info,catch,exception,e,string,files,try,files,arrays,to,string,store,directory,list,all,catch,exception,inner,inner,add,suppressed,e,files,failure,exceptions,helper,detailed,message,inner,if,index,should,exists,throw,new,index,shard,recovery,exception,shard,id,shard,allocated,for,local,recovery,post,api,should,exist,but,doesn,t,current,files,files,e,if,si,null,if,index,should,exists,version,si,get,version,else,logger,trace,cleaning,existing,shard,shouldn,t,exists,lucene,clean,lucene,index,store,directory,si,null,catch,exception,e,throw,new,index,shard,recovery,exception,shard,id,failed,to,fetch,index,version,after,copying,it,over,e,recovery,state,get,index,update,version,version,if,recovery,state,get,recovery,source,get,type,recovery,source,type,assert,index,should,exists,store,bootstrap,new,history,final,segment,infos,segment,infos,store,read,last,committed,segments,info,final,long,max,seq,no,long,parse,long,segment,infos,user,data,get,sequence,numbers,final,string,translog,uuid,translog,create,empty,translog,index,shard,shard,path,resolve,translog,max,seq,no,shard,id,index,shard,get,primary,term,store,associate,index,with,new,translog,translog,uuid,else,if,index,should,exists,try,final,recovery,state,index,index,recovery,state,get,index,if,si,null,add,recovered,file,details,si,store,index,catch,ioexception,e,logger,debug,failed,to,list,file,details,e,else,store,create,empty,final,string,translog,uuid,translog,create,empty,translog,index,shard,shard,path,resolve,translog,sequence,numbers,shard,id,index,shard,get,primary,term,store,associate,index,with,new,translog,translog,uuid,index,shard,open,engine,and,recover,from,translog,index,shard,get,engine,fill,seq,no,gaps,index,shard,get,primary,term,index,shard,finalize,recovery,index,shard,post,recovery,post,recovery,from,catch,engine,exception,ioexception,e,throw,new,index,shard,recovery,exception,shard,id,failed,to,recover,from,gateway,e,finally,store,dec,ref
StoreRecovery -> private void internalRecoverFromStore(IndexShard indexShard) throws IndexShardRecoveryException;1533295538;Recovers the state of the shard from the store.;private void internalRecoverFromStore(IndexShard indexShard) throws IndexShardRecoveryException {_        final RecoveryState recoveryState = indexShard.recoveryState()__        final boolean indexShouldExists = recoveryState.getRecoverySource().getType() != RecoverySource.Type.EMPTY_STORE__        indexShard.prepareForIndexRecovery()__        long version = -1__        SegmentInfos si = null__        final Store store = indexShard.store()__        store.incRef()__        try {_            try {_                store.failIfCorrupted()__                try {_                    si = store.readLastCommittedSegmentsInfo()__                } catch (Exception e) {_                    String files = "_unknown_"__                    try {_                        files = Arrays.toString(store.directory().listAll())__                    } catch (Exception inner) {_                        inner.addSuppressed(e)__                        files += " (failure=" + ExceptionsHelper.detailedMessage(inner) + ")"__                    }_                    if (indexShouldExists) {_                        throw new IndexShardRecoveryException(shardId, "shard allocated for local recovery (post api), should exist, but doesn't, current files: " + files, e)__                    }_                }_                if (si != null) {_                    if (indexShouldExists) {_                        version = si.getVersion()__                    } else {_                        _                        _                        logger.trace("cleaning existing shard, shouldn't exists")__                        Lucene.cleanLuceneIndex(store.directory())__                        si = null__                    }_                }_            } catch (Exception e) {_                throw new IndexShardRecoveryException(shardId, "failed to fetch index version after copying it over", e)__            }_            recoveryState.getIndex().updateVersion(version)__            if (recoveryState.getRecoverySource().getType() == RecoverySource.Type.LOCAL_SHARDS) {_                assert indexShouldExists__                store.bootstrapNewHistory()__                final SegmentInfos segmentInfos = store.readLastCommittedSegmentsInfo()__                final long maxSeqNo = Long.parseLong(segmentInfos.userData.get(SequenceNumbers.MAX_SEQ_NO))__                final String translogUUID = Translog.createEmptyTranslog(_                    indexShard.shardPath().resolveTranslog(), maxSeqNo, shardId, indexShard.getPendingPrimaryTerm())__                store.associateIndexWithNewTranslog(translogUUID)__            } else if (indexShouldExists) {_                _                try {_                    final RecoveryState.Index index = recoveryState.getIndex()__                    if (si != null) {_                        addRecoveredFileDetails(si, store, index)__                    }_                } catch (IOException e) {_                    logger.debug("failed to list file details", e)__                }_            } else {_                store.createEmpty()__                final String translogUUID = Translog.createEmptyTranslog(_                    indexShard.shardPath().resolveTranslog(), SequenceNumbers.NO_OPS_PERFORMED, shardId,_                    indexShard.getPendingPrimaryTerm())__                store.associateIndexWithNewTranslog(translogUUID)__            }_            indexShard.openEngineAndRecoverFromTranslog()__            indexShard.getEngine().fillSeqNoGaps(indexShard.getPendingPrimaryTerm())__            indexShard.finalizeRecovery()__            indexShard.postRecovery("post recovery from shard_store")__        } catch (EngineException | IOException e) {_            throw new IndexShardRecoveryException(shardId, "failed to recover from gateway", e)__        } finally {_            store.decRef()__        }_    };recovers,the,state,of,the,shard,from,the,store;private,void,internal,recover,from,store,index,shard,index,shard,throws,index,shard,recovery,exception,final,recovery,state,recovery,state,index,shard,recovery,state,final,boolean,index,should,exists,recovery,state,get,recovery,source,get,type,recovery,source,type,index,shard,prepare,for,index,recovery,long,version,1,segment,infos,si,null,final,store,store,index,shard,store,store,inc,ref,try,try,store,fail,if,corrupted,try,si,store,read,last,committed,segments,info,catch,exception,e,string,files,try,files,arrays,to,string,store,directory,list,all,catch,exception,inner,inner,add,suppressed,e,files,failure,exceptions,helper,detailed,message,inner,if,index,should,exists,throw,new,index,shard,recovery,exception,shard,id,shard,allocated,for,local,recovery,post,api,should,exist,but,doesn,t,current,files,files,e,if,si,null,if,index,should,exists,version,si,get,version,else,logger,trace,cleaning,existing,shard,shouldn,t,exists,lucene,clean,lucene,index,store,directory,si,null,catch,exception,e,throw,new,index,shard,recovery,exception,shard,id,failed,to,fetch,index,version,after,copying,it,over,e,recovery,state,get,index,update,version,version,if,recovery,state,get,recovery,source,get,type,recovery,source,type,assert,index,should,exists,store,bootstrap,new,history,final,segment,infos,segment,infos,store,read,last,committed,segments,info,final,long,max,seq,no,long,parse,long,segment,infos,user,data,get,sequence,numbers,final,string,translog,uuid,translog,create,empty,translog,index,shard,shard,path,resolve,translog,max,seq,no,shard,id,index,shard,get,pending,primary,term,store,associate,index,with,new,translog,translog,uuid,else,if,index,should,exists,try,final,recovery,state,index,index,recovery,state,get,index,if,si,null,add,recovered,file,details,si,store,index,catch,ioexception,e,logger,debug,failed,to,list,file,details,e,else,store,create,empty,final,string,translog,uuid,translog,create,empty,translog,index,shard,shard,path,resolve,translog,sequence,numbers,shard,id,index,shard,get,pending,primary,term,store,associate,index,with,new,translog,translog,uuid,index,shard,open,engine,and,recover,from,translog,index,shard,get,engine,fill,seq,no,gaps,index,shard,get,pending,primary,term,index,shard,finalize,recovery,index,shard,post,recovery,post,recovery,from,catch,engine,exception,ioexception,e,throw,new,index,shard,recovery,exception,shard,id,failed,to,recover,from,gateway,e,finally,store,dec,ref
StoreRecovery -> private void internalRecoverFromStore(IndexShard indexShard) throws IndexShardRecoveryException;1535723122;Recovers the state of the shard from the store.;private void internalRecoverFromStore(IndexShard indexShard) throws IndexShardRecoveryException {_        final RecoveryState recoveryState = indexShard.recoveryState()__        final boolean indexShouldExists = recoveryState.getRecoverySource().getType() != RecoverySource.Type.EMPTY_STORE__        indexShard.prepareForIndexRecovery()__        long version = -1__        SegmentInfos si = null__        final Store store = indexShard.store()__        store.incRef()__        try {_            try {_                store.failIfCorrupted()__                try {_                    si = store.readLastCommittedSegmentsInfo()__                } catch (Exception e) {_                    String files = "_unknown_"__                    try {_                        files = Arrays.toString(store.directory().listAll())__                    } catch (Exception inner) {_                        inner.addSuppressed(e)__                        files += " (failure=" + ExceptionsHelper.detailedMessage(inner) + ")"__                    }_                    if (indexShouldExists) {_                        throw new IndexShardRecoveryException(shardId, "shard allocated for local recovery (post api), should exist, but doesn't, current files: " + files, e)__                    }_                }_                if (si != null) {_                    if (indexShouldExists) {_                        version = si.getVersion()__                    } else {_                        _                        _                        logger.trace("cleaning existing shard, shouldn't exists")__                        Lucene.cleanLuceneIndex(store.directory())__                        si = null__                    }_                }_            } catch (Exception e) {_                throw new IndexShardRecoveryException(shardId, "failed to fetch index version after copying it over", e)__            }_            recoveryState.getIndex().updateVersion(version)__            if (recoveryState.getRecoverySource().getType() == RecoverySource.Type.LOCAL_SHARDS) {_                assert indexShouldExists__                store.bootstrapNewHistory()__                final SegmentInfos segmentInfos = store.readLastCommittedSegmentsInfo()__                final long maxSeqNo = Long.parseLong(segmentInfos.userData.get(SequenceNumbers.MAX_SEQ_NO))__                final String translogUUID = Translog.createEmptyTranslog(_                    indexShard.shardPath().resolveTranslog(), maxSeqNo, shardId, indexShard.getPendingPrimaryTerm())__                store.associateIndexWithNewTranslog(translogUUID)__            } else if (indexShouldExists) {_                _                try {_                    final RecoveryState.Index index = recoveryState.getIndex()__                    if (si != null) {_                        addRecoveredFileDetails(si, store, index)__                    }_                } catch (IOException e) {_                    logger.debug("failed to list file details", e)__                }_            } else {_                store.createEmpty()__                final String translogUUID = Translog.createEmptyTranslog(_                    indexShard.shardPath().resolveTranslog(), SequenceNumbers.NO_OPS_PERFORMED, shardId,_                    indexShard.getPendingPrimaryTerm())__                store.associateIndexWithNewTranslog(translogUUID)__            }_            indexShard.openEngineAndRecoverFromTranslog()__            indexShard.getEngine().fillSeqNoGaps(indexShard.getPendingPrimaryTerm())__            indexShard.finalizeRecovery()__            indexShard.postRecovery("post recovery from shard_store")__        } catch (EngineException | IOException e) {_            throw new IndexShardRecoveryException(shardId, "failed to recover from gateway", e)__        } finally {_            store.decRef()__        }_    };recovers,the,state,of,the,shard,from,the,store;private,void,internal,recover,from,store,index,shard,index,shard,throws,index,shard,recovery,exception,final,recovery,state,recovery,state,index,shard,recovery,state,final,boolean,index,should,exists,recovery,state,get,recovery,source,get,type,recovery,source,type,index,shard,prepare,for,index,recovery,long,version,1,segment,infos,si,null,final,store,store,index,shard,store,store,inc,ref,try,try,store,fail,if,corrupted,try,si,store,read,last,committed,segments,info,catch,exception,e,string,files,try,files,arrays,to,string,store,directory,list,all,catch,exception,inner,inner,add,suppressed,e,files,failure,exceptions,helper,detailed,message,inner,if,index,should,exists,throw,new,index,shard,recovery,exception,shard,id,shard,allocated,for,local,recovery,post,api,should,exist,but,doesn,t,current,files,files,e,if,si,null,if,index,should,exists,version,si,get,version,else,logger,trace,cleaning,existing,shard,shouldn,t,exists,lucene,clean,lucene,index,store,directory,si,null,catch,exception,e,throw,new,index,shard,recovery,exception,shard,id,failed,to,fetch,index,version,after,copying,it,over,e,recovery,state,get,index,update,version,version,if,recovery,state,get,recovery,source,get,type,recovery,source,type,assert,index,should,exists,store,bootstrap,new,history,final,segment,infos,segment,infos,store,read,last,committed,segments,info,final,long,max,seq,no,long,parse,long,segment,infos,user,data,get,sequence,numbers,final,string,translog,uuid,translog,create,empty,translog,index,shard,shard,path,resolve,translog,max,seq,no,shard,id,index,shard,get,pending,primary,term,store,associate,index,with,new,translog,translog,uuid,else,if,index,should,exists,try,final,recovery,state,index,index,recovery,state,get,index,if,si,null,add,recovered,file,details,si,store,index,catch,ioexception,e,logger,debug,failed,to,list,file,details,e,else,store,create,empty,final,string,translog,uuid,translog,create,empty,translog,index,shard,shard,path,resolve,translog,sequence,numbers,shard,id,index,shard,get,pending,primary,term,store,associate,index,with,new,translog,translog,uuid,index,shard,open,engine,and,recover,from,translog,index,shard,get,engine,fill,seq,no,gaps,index,shard,get,pending,primary,term,index,shard,finalize,recovery,index,shard,post,recovery,post,recovery,from,catch,engine,exception,ioexception,e,throw,new,index,shard,recovery,exception,shard,id,failed,to,recover,from,gateway,e,finally,store,dec,ref
StoreRecovery -> private void internalRecoverFromStore(IndexShard indexShard) throws IndexShardRecoveryException;1536611444;Recovers the state of the shard from the store.;private void internalRecoverFromStore(IndexShard indexShard) throws IndexShardRecoveryException {_        final RecoveryState recoveryState = indexShard.recoveryState()__        final boolean indexShouldExists = recoveryState.getRecoverySource().getType() != RecoverySource.Type.EMPTY_STORE__        indexShard.prepareForIndexRecovery()__        long version = -1__        SegmentInfos si = null__        final Store store = indexShard.store()__        store.incRef()__        try {_            try {_                store.failIfCorrupted()__                try {_                    si = store.readLastCommittedSegmentsInfo()__                } catch (Exception e) {_                    String files = "_unknown_"__                    try {_                        files = Arrays.toString(store.directory().listAll())__                    } catch (Exception inner) {_                        inner.addSuppressed(e)__                        files += " (failure=" + ExceptionsHelper.detailedMessage(inner) + ")"__                    }_                    if (indexShouldExists) {_                        throw new IndexShardRecoveryException(shardId, "shard allocated for local recovery (post api), should exist, but doesn't, current files: " + files, e)__                    }_                }_                if (si != null) {_                    if (indexShouldExists) {_                        version = si.getVersion()__                    } else {_                        _                        _                        logger.trace("cleaning existing shard, shouldn't exists")__                        Lucene.cleanLuceneIndex(store.directory())__                        si = null__                    }_                }_            } catch (Exception e) {_                throw new IndexShardRecoveryException(shardId, "failed to fetch index version after copying it over", e)__            }_            recoveryState.getIndex().updateVersion(version)__            if (recoveryState.getRecoverySource().getType() == RecoverySource.Type.LOCAL_SHARDS) {_                assert indexShouldExists__                store.bootstrapNewHistory()__                final SegmentInfos segmentInfos = store.readLastCommittedSegmentsInfo()__                final long maxSeqNo = Long.parseLong(segmentInfos.userData.get(SequenceNumbers.MAX_SEQ_NO))__                final String translogUUID = Translog.createEmptyTranslog(_                    indexShard.shardPath().resolveTranslog(), maxSeqNo, shardId, indexShard.getPendingPrimaryTerm())__                store.associateIndexWithNewTranslog(translogUUID)__            } else if (indexShouldExists) {_                if (recoveryState.getRecoverySource().shouldBootstrapNewHistoryUUID()) {_                    store.bootstrapNewHistory()__                }_                _                try {_                    final RecoveryState.Index index = recoveryState.getIndex()__                    if (si != null) {_                        addRecoveredFileDetails(si, store, index)__                    }_                } catch (IOException e) {_                    logger.debug("failed to list file details", e)__                }_            } else {_                store.createEmpty()__                final String translogUUID = Translog.createEmptyTranslog(_                    indexShard.shardPath().resolveTranslog(), SequenceNumbers.NO_OPS_PERFORMED, shardId,_                    indexShard.getPendingPrimaryTerm())__                store.associateIndexWithNewTranslog(translogUUID)__            }_            indexShard.openEngineAndRecoverFromTranslog()__            indexShard.getEngine().fillSeqNoGaps(indexShard.getPendingPrimaryTerm())__            indexShard.finalizeRecovery()__            indexShard.postRecovery("post recovery from shard_store")__        } catch (EngineException | IOException e) {_            throw new IndexShardRecoveryException(shardId, "failed to recover from gateway", e)__        } finally {_            store.decRef()__        }_    };recovers,the,state,of,the,shard,from,the,store;private,void,internal,recover,from,store,index,shard,index,shard,throws,index,shard,recovery,exception,final,recovery,state,recovery,state,index,shard,recovery,state,final,boolean,index,should,exists,recovery,state,get,recovery,source,get,type,recovery,source,type,index,shard,prepare,for,index,recovery,long,version,1,segment,infos,si,null,final,store,store,index,shard,store,store,inc,ref,try,try,store,fail,if,corrupted,try,si,store,read,last,committed,segments,info,catch,exception,e,string,files,try,files,arrays,to,string,store,directory,list,all,catch,exception,inner,inner,add,suppressed,e,files,failure,exceptions,helper,detailed,message,inner,if,index,should,exists,throw,new,index,shard,recovery,exception,shard,id,shard,allocated,for,local,recovery,post,api,should,exist,but,doesn,t,current,files,files,e,if,si,null,if,index,should,exists,version,si,get,version,else,logger,trace,cleaning,existing,shard,shouldn,t,exists,lucene,clean,lucene,index,store,directory,si,null,catch,exception,e,throw,new,index,shard,recovery,exception,shard,id,failed,to,fetch,index,version,after,copying,it,over,e,recovery,state,get,index,update,version,version,if,recovery,state,get,recovery,source,get,type,recovery,source,type,assert,index,should,exists,store,bootstrap,new,history,final,segment,infos,segment,infos,store,read,last,committed,segments,info,final,long,max,seq,no,long,parse,long,segment,infos,user,data,get,sequence,numbers,final,string,translog,uuid,translog,create,empty,translog,index,shard,shard,path,resolve,translog,max,seq,no,shard,id,index,shard,get,pending,primary,term,store,associate,index,with,new,translog,translog,uuid,else,if,index,should,exists,if,recovery,state,get,recovery,source,should,bootstrap,new,history,uuid,store,bootstrap,new,history,try,final,recovery,state,index,index,recovery,state,get,index,if,si,null,add,recovered,file,details,si,store,index,catch,ioexception,e,logger,debug,failed,to,list,file,details,e,else,store,create,empty,final,string,translog,uuid,translog,create,empty,translog,index,shard,shard,path,resolve,translog,sequence,numbers,shard,id,index,shard,get,pending,primary,term,store,associate,index,with,new,translog,translog,uuid,index,shard,open,engine,and,recover,from,translog,index,shard,get,engine,fill,seq,no,gaps,index,shard,get,pending,primary,term,index,shard,finalize,recovery,index,shard,post,recovery,post,recovery,from,catch,engine,exception,ioexception,e,throw,new,index,shard,recovery,exception,shard,id,failed,to,recover,from,gateway,e,finally,store,dec,ref
StoreRecovery -> private void internalRecoverFromStore(IndexShard indexShard) throws IndexShardRecoveryException;1538067637;Recovers the state of the shard from the store.;private void internalRecoverFromStore(IndexShard indexShard) throws IndexShardRecoveryException {_        final RecoveryState recoveryState = indexShard.recoveryState()__        final boolean indexShouldExists = recoveryState.getRecoverySource().getType() != RecoverySource.Type.EMPTY_STORE__        indexShard.prepareForIndexRecovery()__        long version = -1__        SegmentInfos si = null__        final Store store = indexShard.store()__        store.incRef()__        try {_            try {_                store.failIfCorrupted()__                try {_                    si = store.readLastCommittedSegmentsInfo()__                } catch (Exception e) {_                    String files = "_unknown_"__                    try {_                        files = Arrays.toString(store.directory().listAll())__                    } catch (Exception inner) {_                        inner.addSuppressed(e)__                        files += " (failure=" + ExceptionsHelper.detailedMessage(inner) + ")"__                    }_                    if (indexShouldExists) {_                        throw new IndexShardRecoveryException(shardId, "shard allocated for local recovery (post api), should exist, but doesn't, current files: " + files, e)__                    }_                }_                if (si != null) {_                    if (indexShouldExists) {_                        version = si.getVersion()__                    } else {_                        _                        _                        logger.trace("cleaning existing shard, shouldn't exists")__                        Lucene.cleanLuceneIndex(store.directory())__                        si = null__                    }_                }_            } catch (Exception e) {_                throw new IndexShardRecoveryException(shardId, "failed to fetch index version after copying it over", e)__            }_            recoveryState.getIndex().updateVersion(version)__            if (recoveryState.getRecoverySource().getType() == RecoverySource.Type.LOCAL_SHARDS) {_                assert indexShouldExists__                store.bootstrapNewHistory()__                final SegmentInfos segmentInfos = store.readLastCommittedSegmentsInfo()__                final long maxSeqNo = Long.parseLong(segmentInfos.userData.get(SequenceNumbers.MAX_SEQ_NO))__                final String translogUUID = Translog.createEmptyTranslog(_                    indexShard.shardPath().resolveTranslog(), maxSeqNo, shardId, indexShard.getPendingPrimaryTerm())__                store.associateIndexWithNewTranslog(translogUUID)__            } else if (indexShouldExists) {_                if (recoveryState.getRecoverySource().shouldBootstrapNewHistoryUUID()) {_                    store.bootstrapNewHistory()__                }_                _                try {_                    final RecoveryState.Index index = recoveryState.getIndex()__                    if (si != null) {_                        addRecoveredFileDetails(si, store, index)__                    }_                } catch (IOException e) {_                    logger.debug("failed to list file details", e)__                }_            } else {_                store.createEmpty()__                final String translogUUID = Translog.createEmptyTranslog(_                    indexShard.shardPath().resolveTranslog(), SequenceNumbers.NO_OPS_PERFORMED, shardId,_                    indexShard.getPendingPrimaryTerm())__                store.associateIndexWithNewTranslog(translogUUID)__            }_            indexShard.openEngineAndRecoverFromTranslog()__            indexShard.getEngine().fillSeqNoGaps(indexShard.getPendingPrimaryTerm())__            indexShard.finalizeRecovery()__            indexShard.postRecovery("post recovery from shard_store")__        } catch (EngineException | IOException e) {_            throw new IndexShardRecoveryException(shardId, "failed to recover from gateway", e)__        } finally {_            store.decRef()__        }_    };recovers,the,state,of,the,shard,from,the,store;private,void,internal,recover,from,store,index,shard,index,shard,throws,index,shard,recovery,exception,final,recovery,state,recovery,state,index,shard,recovery,state,final,boolean,index,should,exists,recovery,state,get,recovery,source,get,type,recovery,source,type,index,shard,prepare,for,index,recovery,long,version,1,segment,infos,si,null,final,store,store,index,shard,store,store,inc,ref,try,try,store,fail,if,corrupted,try,si,store,read,last,committed,segments,info,catch,exception,e,string,files,try,files,arrays,to,string,store,directory,list,all,catch,exception,inner,inner,add,suppressed,e,files,failure,exceptions,helper,detailed,message,inner,if,index,should,exists,throw,new,index,shard,recovery,exception,shard,id,shard,allocated,for,local,recovery,post,api,should,exist,but,doesn,t,current,files,files,e,if,si,null,if,index,should,exists,version,si,get,version,else,logger,trace,cleaning,existing,shard,shouldn,t,exists,lucene,clean,lucene,index,store,directory,si,null,catch,exception,e,throw,new,index,shard,recovery,exception,shard,id,failed,to,fetch,index,version,after,copying,it,over,e,recovery,state,get,index,update,version,version,if,recovery,state,get,recovery,source,get,type,recovery,source,type,assert,index,should,exists,store,bootstrap,new,history,final,segment,infos,segment,infos,store,read,last,committed,segments,info,final,long,max,seq,no,long,parse,long,segment,infos,user,data,get,sequence,numbers,final,string,translog,uuid,translog,create,empty,translog,index,shard,shard,path,resolve,translog,max,seq,no,shard,id,index,shard,get,pending,primary,term,store,associate,index,with,new,translog,translog,uuid,else,if,index,should,exists,if,recovery,state,get,recovery,source,should,bootstrap,new,history,uuid,store,bootstrap,new,history,try,final,recovery,state,index,index,recovery,state,get,index,if,si,null,add,recovered,file,details,si,store,index,catch,ioexception,e,logger,debug,failed,to,list,file,details,e,else,store,create,empty,final,string,translog,uuid,translog,create,empty,translog,index,shard,shard,path,resolve,translog,sequence,numbers,shard,id,index,shard,get,pending,primary,term,store,associate,index,with,new,translog,translog,uuid,index,shard,open,engine,and,recover,from,translog,index,shard,get,engine,fill,seq,no,gaps,index,shard,get,pending,primary,term,index,shard,finalize,recovery,index,shard,post,recovery,post,recovery,from,catch,engine,exception,ioexception,e,throw,new,index,shard,recovery,exception,shard,id,failed,to,recover,from,gateway,e,finally,store,dec,ref
StoreRecovery -> private void internalRecoverFromStore(IndexShard indexShard) throws IndexShardRecoveryException;1542697754;Recovers the state of the shard from the store.;private void internalRecoverFromStore(IndexShard indexShard) throws IndexShardRecoveryException {_        final RecoveryState recoveryState = indexShard.recoveryState()__        final boolean indexShouldExists = recoveryState.getRecoverySource().getType() != RecoverySource.Type.EMPTY_STORE__        indexShard.prepareForIndexRecovery()__        long version = -1__        SegmentInfos si = null__        final Store store = indexShard.store()__        store.incRef()__        try {_            try {_                store.failIfCorrupted()__                try {_                    si = store.readLastCommittedSegmentsInfo()__                } catch (Exception e) {_                    String files = "_unknown_"__                    try {_                        files = Arrays.toString(store.directory().listAll())__                    } catch (Exception inner) {_                        inner.addSuppressed(e)__                        files += " (failure=" + ExceptionsHelper.detailedMessage(inner) + ")"__                    }_                    if (indexShouldExists) {_                        throw new IndexShardRecoveryException(shardId,_                            "shard allocated for local recovery (post api), should exist, but doesn't, current files: " + files, e)__                    }_                }_                if (si != null) {_                    if (indexShouldExists) {_                        version = si.getVersion()__                    } else {_                        _                        _                        logger.trace("cleaning existing shard, shouldn't exists")__                        Lucene.cleanLuceneIndex(store.directory())__                        si = null__                    }_                }_            } catch (Exception e) {_                throw new IndexShardRecoveryException(shardId, "failed to fetch index version after copying it over", e)__            }_            recoveryState.getIndex().updateVersion(version)__            if (recoveryState.getRecoverySource().getType() == RecoverySource.Type.LOCAL_SHARDS) {_                assert indexShouldExists__                store.bootstrapNewHistory()__                final SegmentInfos segmentInfos = store.readLastCommittedSegmentsInfo()__                final long maxSeqNo = Long.parseLong(segmentInfos.userData.get(SequenceNumbers.MAX_SEQ_NO))__                final String translogUUID = Translog.createEmptyTranslog(_                    indexShard.shardPath().resolveTranslog(), maxSeqNo, shardId, indexShard.getPendingPrimaryTerm())__                store.associateIndexWithNewTranslog(translogUUID)__            } else if (indexShouldExists) {_                if (recoveryState.getRecoverySource().shouldBootstrapNewHistoryUUID()) {_                    store.bootstrapNewHistory()__                }_                _                try {_                    final RecoveryState.Index index = recoveryState.getIndex()__                    if (si != null) {_                        addRecoveredFileDetails(si, store, index)__                    }_                } catch (IOException e) {_                    logger.debug("failed to list file details", e)__                }_            } else {_                store.createEmpty()__                final String translogUUID = Translog.createEmptyTranslog(_                    indexShard.shardPath().resolveTranslog(), SequenceNumbers.NO_OPS_PERFORMED, shardId,_                    indexShard.getPendingPrimaryTerm())__                store.associateIndexWithNewTranslog(translogUUID)__            }_            indexShard.openEngineAndRecoverFromTranslog()__            indexShard.getEngine().fillSeqNoGaps(indexShard.getPendingPrimaryTerm())__            indexShard.finalizeRecovery()__            indexShard.postRecovery("post recovery from shard_store")__        } catch (EngineException | IOException e) {_            throw new IndexShardRecoveryException(shardId, "failed to recover from gateway", e)__        } finally {_            store.decRef()__        }_    };recovers,the,state,of,the,shard,from,the,store;private,void,internal,recover,from,store,index,shard,index,shard,throws,index,shard,recovery,exception,final,recovery,state,recovery,state,index,shard,recovery,state,final,boolean,index,should,exists,recovery,state,get,recovery,source,get,type,recovery,source,type,index,shard,prepare,for,index,recovery,long,version,1,segment,infos,si,null,final,store,store,index,shard,store,store,inc,ref,try,try,store,fail,if,corrupted,try,si,store,read,last,committed,segments,info,catch,exception,e,string,files,try,files,arrays,to,string,store,directory,list,all,catch,exception,inner,inner,add,suppressed,e,files,failure,exceptions,helper,detailed,message,inner,if,index,should,exists,throw,new,index,shard,recovery,exception,shard,id,shard,allocated,for,local,recovery,post,api,should,exist,but,doesn,t,current,files,files,e,if,si,null,if,index,should,exists,version,si,get,version,else,logger,trace,cleaning,existing,shard,shouldn,t,exists,lucene,clean,lucene,index,store,directory,si,null,catch,exception,e,throw,new,index,shard,recovery,exception,shard,id,failed,to,fetch,index,version,after,copying,it,over,e,recovery,state,get,index,update,version,version,if,recovery,state,get,recovery,source,get,type,recovery,source,type,assert,index,should,exists,store,bootstrap,new,history,final,segment,infos,segment,infos,store,read,last,committed,segments,info,final,long,max,seq,no,long,parse,long,segment,infos,user,data,get,sequence,numbers,final,string,translog,uuid,translog,create,empty,translog,index,shard,shard,path,resolve,translog,max,seq,no,shard,id,index,shard,get,pending,primary,term,store,associate,index,with,new,translog,translog,uuid,else,if,index,should,exists,if,recovery,state,get,recovery,source,should,bootstrap,new,history,uuid,store,bootstrap,new,history,try,final,recovery,state,index,index,recovery,state,get,index,if,si,null,add,recovered,file,details,si,store,index,catch,ioexception,e,logger,debug,failed,to,list,file,details,e,else,store,create,empty,final,string,translog,uuid,translog,create,empty,translog,index,shard,shard,path,resolve,translog,sequence,numbers,shard,id,index,shard,get,pending,primary,term,store,associate,index,with,new,translog,translog,uuid,index,shard,open,engine,and,recover,from,translog,index,shard,get,engine,fill,seq,no,gaps,index,shard,get,pending,primary,term,index,shard,finalize,recovery,index,shard,post,recovery,post,recovery,from,catch,engine,exception,ioexception,e,throw,new,index,shard,recovery,exception,shard,id,failed,to,recover,from,gateway,e,finally,store,dec,ref
StoreRecovery -> private void internalRecoverFromStore(IndexShard indexShard) throws IndexShardRecoveryException;1543942400;Recovers the state of the shard from the store.;private void internalRecoverFromStore(IndexShard indexShard) throws IndexShardRecoveryException {_        final RecoveryState recoveryState = indexShard.recoveryState()__        final boolean indexShouldExists = recoveryState.getRecoverySource().getType() != RecoverySource.Type.EMPTY_STORE__        indexShard.prepareForIndexRecovery()__        long version = -1__        SegmentInfos si = null__        final Store store = indexShard.store()__        store.incRef()__        try {_            try {_                store.failIfCorrupted()__                try {_                    si = store.readLastCommittedSegmentsInfo()__                } catch (Exception e) {_                    String files = "_unknown_"__                    try {_                        files = Arrays.toString(store.directory().listAll())__                    } catch (Exception inner) {_                        inner.addSuppressed(e)__                        files += " (failure=" + ExceptionsHelper.detailedMessage(inner) + ")"__                    }_                    if (indexShouldExists) {_                        throw new IndexShardRecoveryException(shardId,_                            "shard allocated for local recovery (post api), should exist, but doesn't, current files: " + files, e)__                    }_                }_                if (si != null) {_                    if (indexShouldExists) {_                        version = si.getVersion()__                    } else {_                        _                        _                        logger.trace("cleaning existing shard, shouldn't exists")__                        Lucene.cleanLuceneIndex(store.directory())__                        si = null__                    }_                }_            } catch (Exception e) {_                throw new IndexShardRecoveryException(shardId, "failed to fetch index version after copying it over", e)__            }_            recoveryState.getIndex().updateVersion(version)__            if (recoveryState.getRecoverySource().getType() == RecoverySource.Type.LOCAL_SHARDS) {_                assert indexShouldExists__                store.bootstrapNewHistory()__                final SegmentInfos segmentInfos = store.readLastCommittedSegmentsInfo()__                final long maxSeqNo = Long.parseLong(segmentInfos.userData.get(SequenceNumbers.MAX_SEQ_NO))__                final String translogUUID = Translog.createEmptyTranslog(_                    indexShard.shardPath().resolveTranslog(), maxSeqNo, shardId, indexShard.getPendingPrimaryTerm())__                store.associateIndexWithNewTranslog(translogUUID)__            } else if (indexShouldExists) {_                if (recoveryState.getRecoverySource().shouldBootstrapNewHistoryUUID()) {_                    store.bootstrapNewHistory()__                }_                _                try {_                    final RecoveryState.Index index = recoveryState.getIndex()__                    if (si != null) {_                        addRecoveredFileDetails(si, store, index)__                    }_                } catch (IOException e) {_                    logger.debug("failed to list file details", e)__                }_            } else {_                store.createEmpty(indexShard.indexSettings().getIndexVersionCreated().luceneVersion)__                final String translogUUID = Translog.createEmptyTranslog(_                    indexShard.shardPath().resolveTranslog(), SequenceNumbers.NO_OPS_PERFORMED, shardId,_                    indexShard.getPendingPrimaryTerm())__                store.associateIndexWithNewTranslog(translogUUID)__            }_            indexShard.openEngineAndRecoverFromTranslog()__            indexShard.getEngine().fillSeqNoGaps(indexShard.getPendingPrimaryTerm())__            indexShard.finalizeRecovery()__            indexShard.postRecovery("post recovery from shard_store")__        } catch (EngineException | IOException e) {_            throw new IndexShardRecoveryException(shardId, "failed to recover from gateway", e)__        } finally {_            store.decRef()__        }_    };recovers,the,state,of,the,shard,from,the,store;private,void,internal,recover,from,store,index,shard,index,shard,throws,index,shard,recovery,exception,final,recovery,state,recovery,state,index,shard,recovery,state,final,boolean,index,should,exists,recovery,state,get,recovery,source,get,type,recovery,source,type,index,shard,prepare,for,index,recovery,long,version,1,segment,infos,si,null,final,store,store,index,shard,store,store,inc,ref,try,try,store,fail,if,corrupted,try,si,store,read,last,committed,segments,info,catch,exception,e,string,files,try,files,arrays,to,string,store,directory,list,all,catch,exception,inner,inner,add,suppressed,e,files,failure,exceptions,helper,detailed,message,inner,if,index,should,exists,throw,new,index,shard,recovery,exception,shard,id,shard,allocated,for,local,recovery,post,api,should,exist,but,doesn,t,current,files,files,e,if,si,null,if,index,should,exists,version,si,get,version,else,logger,trace,cleaning,existing,shard,shouldn,t,exists,lucene,clean,lucene,index,store,directory,si,null,catch,exception,e,throw,new,index,shard,recovery,exception,shard,id,failed,to,fetch,index,version,after,copying,it,over,e,recovery,state,get,index,update,version,version,if,recovery,state,get,recovery,source,get,type,recovery,source,type,assert,index,should,exists,store,bootstrap,new,history,final,segment,infos,segment,infos,store,read,last,committed,segments,info,final,long,max,seq,no,long,parse,long,segment,infos,user,data,get,sequence,numbers,final,string,translog,uuid,translog,create,empty,translog,index,shard,shard,path,resolve,translog,max,seq,no,shard,id,index,shard,get,pending,primary,term,store,associate,index,with,new,translog,translog,uuid,else,if,index,should,exists,if,recovery,state,get,recovery,source,should,bootstrap,new,history,uuid,store,bootstrap,new,history,try,final,recovery,state,index,index,recovery,state,get,index,if,si,null,add,recovered,file,details,si,store,index,catch,ioexception,e,logger,debug,failed,to,list,file,details,e,else,store,create,empty,index,shard,index,settings,get,index,version,created,lucene,version,final,string,translog,uuid,translog,create,empty,translog,index,shard,shard,path,resolve,translog,sequence,numbers,shard,id,index,shard,get,pending,primary,term,store,associate,index,with,new,translog,translog,uuid,index,shard,open,engine,and,recover,from,translog,index,shard,get,engine,fill,seq,no,gaps,index,shard,get,pending,primary,term,index,shard,finalize,recovery,index,shard,post,recovery,post,recovery,from,catch,engine,exception,ioexception,e,throw,new,index,shard,recovery,exception,shard,id,failed,to,recover,from,gateway,e,finally,store,dec,ref
StoreRecovery -> private void internalRecoverFromStore(IndexShard indexShard) throws IndexShardRecoveryException;1549395161;Recovers the state of the shard from the store.;private void internalRecoverFromStore(IndexShard indexShard) throws IndexShardRecoveryException {_        final RecoveryState recoveryState = indexShard.recoveryState()__        final boolean indexShouldExists = recoveryState.getRecoverySource().getType() != RecoverySource.Type.EMPTY_STORE__        indexShard.prepareForIndexRecovery()__        long version = -1__        SegmentInfos si = null__        final Store store = indexShard.store()__        store.incRef()__        try {_            try {_                store.failIfCorrupted()__                try {_                    si = store.readLastCommittedSegmentsInfo()__                } catch (Exception e) {_                    String files = "_unknown_"__                    try {_                        files = Arrays.toString(store.directory().listAll())__                    } catch (Exception inner) {_                        inner.addSuppressed(e)__                        files += " (failure=" + ExceptionsHelper.detailedMessage(inner) + ")"__                    }_                    if (indexShouldExists) {_                        throw new IndexShardRecoveryException(shardId,_                            "shard allocated for local recovery (post api), should exist, but doesn't, current files: " + files, e)__                    }_                }_                if (si != null) {_                    if (indexShouldExists) {_                        version = si.getVersion()__                    } else {_                        _                        _                        logger.trace("cleaning existing shard, shouldn't exists")__                        Lucene.cleanLuceneIndex(store.directory())__                        si = null__                    }_                }_            } catch (Exception e) {_                throw new IndexShardRecoveryException(shardId, "failed to fetch index version after copying it over", e)__            }_            recoveryState.getIndex().updateVersion(version)__            if (recoveryState.getRecoverySource().getType() == RecoverySource.Type.LOCAL_SHARDS) {_                assert indexShouldExists__                store.bootstrapNewHistory()__                final SegmentInfos segmentInfos = store.readLastCommittedSegmentsInfo()__                final long localCheckpoint = Long.parseLong(segmentInfos.userData.get(SequenceNumbers.LOCAL_CHECKPOINT_KEY))__                final String translogUUID = Translog.createEmptyTranslog(_                    indexShard.shardPath().resolveTranslog(), localCheckpoint, shardId, indexShard.getPendingPrimaryTerm())__                store.associateIndexWithNewTranslog(translogUUID)__            } else if (indexShouldExists) {_                if (recoveryState.getRecoverySource().shouldBootstrapNewHistoryUUID()) {_                    store.bootstrapNewHistory()__                }_                _                try {_                    final RecoveryState.Index index = recoveryState.getIndex()__                    if (si != null) {_                        addRecoveredFileDetails(si, store, index)__                    }_                } catch (IOException e) {_                    logger.debug("failed to list file details", e)__                }_            } else {_                store.createEmpty(indexShard.indexSettings().getIndexVersionCreated().luceneVersion)__                final String translogUUID = Translog.createEmptyTranslog(_                    indexShard.shardPath().resolveTranslog(), SequenceNumbers.NO_OPS_PERFORMED, shardId,_                    indexShard.getPendingPrimaryTerm())__                store.associateIndexWithNewTranslog(translogUUID)__            }_            indexShard.openEngineAndRecoverFromTranslog()__            indexShard.getEngine().fillSeqNoGaps(indexShard.getPendingPrimaryTerm())__            indexShard.finalizeRecovery()__            indexShard.postRecovery("post recovery from shard_store")__        } catch (EngineException | IOException e) {_            throw new IndexShardRecoveryException(shardId, "failed to recover from gateway", e)__        } finally {_            store.decRef()__        }_    };recovers,the,state,of,the,shard,from,the,store;private,void,internal,recover,from,store,index,shard,index,shard,throws,index,shard,recovery,exception,final,recovery,state,recovery,state,index,shard,recovery,state,final,boolean,index,should,exists,recovery,state,get,recovery,source,get,type,recovery,source,type,index,shard,prepare,for,index,recovery,long,version,1,segment,infos,si,null,final,store,store,index,shard,store,store,inc,ref,try,try,store,fail,if,corrupted,try,si,store,read,last,committed,segments,info,catch,exception,e,string,files,try,files,arrays,to,string,store,directory,list,all,catch,exception,inner,inner,add,suppressed,e,files,failure,exceptions,helper,detailed,message,inner,if,index,should,exists,throw,new,index,shard,recovery,exception,shard,id,shard,allocated,for,local,recovery,post,api,should,exist,but,doesn,t,current,files,files,e,if,si,null,if,index,should,exists,version,si,get,version,else,logger,trace,cleaning,existing,shard,shouldn,t,exists,lucene,clean,lucene,index,store,directory,si,null,catch,exception,e,throw,new,index,shard,recovery,exception,shard,id,failed,to,fetch,index,version,after,copying,it,over,e,recovery,state,get,index,update,version,version,if,recovery,state,get,recovery,source,get,type,recovery,source,type,assert,index,should,exists,store,bootstrap,new,history,final,segment,infos,segment,infos,store,read,last,committed,segments,info,final,long,local,checkpoint,long,parse,long,segment,infos,user,data,get,sequence,numbers,final,string,translog,uuid,translog,create,empty,translog,index,shard,shard,path,resolve,translog,local,checkpoint,shard,id,index,shard,get,pending,primary,term,store,associate,index,with,new,translog,translog,uuid,else,if,index,should,exists,if,recovery,state,get,recovery,source,should,bootstrap,new,history,uuid,store,bootstrap,new,history,try,final,recovery,state,index,index,recovery,state,get,index,if,si,null,add,recovered,file,details,si,store,index,catch,ioexception,e,logger,debug,failed,to,list,file,details,e,else,store,create,empty,index,shard,index,settings,get,index,version,created,lucene,version,final,string,translog,uuid,translog,create,empty,translog,index,shard,shard,path,resolve,translog,sequence,numbers,shard,id,index,shard,get,pending,primary,term,store,associate,index,with,new,translog,translog,uuid,index,shard,open,engine,and,recover,from,translog,index,shard,get,engine,fill,seq,no,gaps,index,shard,get,pending,primary,term,index,shard,finalize,recovery,index,shard,post,recovery,post,recovery,from,catch,engine,exception,ioexception,e,throw,new,index,shard,recovery,exception,shard,id,failed,to,recover,from,gateway,e,finally,store,dec,ref
StoreRecovery -> boolean recoverFromStore(final IndexShard indexShard);1524684173;Recovers a shard from it's local file system store. This method required pre-knowledge about if the shard should_exist on disk ie. has been previously allocated or if the shard is a brand new allocation without pre-existing index_files / transaction logs. This_@param indexShard the index shard instance to recovery the shard into_@return  <code>true</code> if the shard has been recovered successfully, <code>false</code> if the recovery_has been ignored due to a concurrent modification of if the clusters state has changed due to async updates._@see Store;boolean recoverFromStore(final IndexShard indexShard) {_        if (canRecover(indexShard)) {_            RecoverySource.Type recoveryType = indexShard.recoveryState().getRecoverySource().getType()__            assert recoveryType == RecoverySource.Type.EMPTY_STORE || recoveryType == RecoverySource.Type.EXISTING_STORE :_                "expected store recovery type but was: " + recoveryType__            return executeRecovery(indexShard, () -> {_                logger.debug("starting recovery from store ...")__                internalRecoverFromStore(indexShard)__            })__        }_        return false__    };recovers,a,shard,from,it,s,local,file,system,store,this,method,required,pre,knowledge,about,if,the,shard,should,exist,on,disk,ie,has,been,previously,allocated,or,if,the,shard,is,a,brand,new,allocation,without,pre,existing,index,files,transaction,logs,this,param,index,shard,the,index,shard,instance,to,recovery,the,shard,into,return,code,true,code,if,the,shard,has,been,recovered,successfully,code,false,code,if,the,recovery,has,been,ignored,due,to,a,concurrent,modification,of,if,the,clusters,state,has,changed,due,to,async,updates,see,store;boolean,recover,from,store,final,index,shard,index,shard,if,can,recover,index,shard,recovery,source,type,recovery,type,index,shard,recovery,state,get,recovery,source,get,type,assert,recovery,type,recovery,source,type,recovery,type,recovery,source,type,expected,store,recovery,type,but,was,recovery,type,return,execute,recovery,index,shard,logger,debug,starting,recovery,from,store,internal,recover,from,store,index,shard,return,false
StoreRecovery -> boolean recoverFromStore(final IndexShard indexShard);1533295538;Recovers a shard from it's local file system store. This method required pre-knowledge about if the shard should_exist on disk ie. has been previously allocated or if the shard is a brand new allocation without pre-existing index_files / transaction logs. This_@param indexShard the index shard instance to recovery the shard into_@return  <code>true</code> if the shard has been recovered successfully, <code>false</code> if the recovery_has been ignored due to a concurrent modification of if the clusters state has changed due to async updates._@see Store;boolean recoverFromStore(final IndexShard indexShard) {_        if (canRecover(indexShard)) {_            RecoverySource.Type recoveryType = indexShard.recoveryState().getRecoverySource().getType()__            assert recoveryType == RecoverySource.Type.EMPTY_STORE || recoveryType == RecoverySource.Type.EXISTING_STORE :_                "expected store recovery type but was: " + recoveryType__            return executeRecovery(indexShard, () -> {_                logger.debug("starting recovery from store ...")__                internalRecoverFromStore(indexShard)__            })__        }_        return false__    };recovers,a,shard,from,it,s,local,file,system,store,this,method,required,pre,knowledge,about,if,the,shard,should,exist,on,disk,ie,has,been,previously,allocated,or,if,the,shard,is,a,brand,new,allocation,without,pre,existing,index,files,transaction,logs,this,param,index,shard,the,index,shard,instance,to,recovery,the,shard,into,return,code,true,code,if,the,shard,has,been,recovered,successfully,code,false,code,if,the,recovery,has,been,ignored,due,to,a,concurrent,modification,of,if,the,clusters,state,has,changed,due,to,async,updates,see,store;boolean,recover,from,store,final,index,shard,index,shard,if,can,recover,index,shard,recovery,source,type,recovery,type,index,shard,recovery,state,get,recovery,source,get,type,assert,recovery,type,recovery,source,type,recovery,type,recovery,source,type,expected,store,recovery,type,but,was,recovery,type,return,execute,recovery,index,shard,logger,debug,starting,recovery,from,store,internal,recover,from,store,index,shard,return,false
StoreRecovery -> boolean recoverFromStore(final IndexShard indexShard);1535723122;Recovers a shard from it's local file system store. This method required pre-knowledge about if the shard should_exist on disk ie. has been previously allocated or if the shard is a brand new allocation without pre-existing index_files / transaction logs. This_@param indexShard the index shard instance to recovery the shard into_@return  <code>true</code> if the shard has been recovered successfully, <code>false</code> if the recovery_has been ignored due to a concurrent modification of if the clusters state has changed due to async updates._@see Store;boolean recoverFromStore(final IndexShard indexShard) {_        if (canRecover(indexShard)) {_            RecoverySource.Type recoveryType = indexShard.recoveryState().getRecoverySource().getType()__            assert recoveryType == RecoverySource.Type.EMPTY_STORE || recoveryType == RecoverySource.Type.EXISTING_STORE :_                "expected store recovery type but was: " + recoveryType__            return executeRecovery(indexShard, () -> {_                logger.debug("starting recovery from store ...")__                internalRecoverFromStore(indexShard)__            })__        }_        return false__    };recovers,a,shard,from,it,s,local,file,system,store,this,method,required,pre,knowledge,about,if,the,shard,should,exist,on,disk,ie,has,been,previously,allocated,or,if,the,shard,is,a,brand,new,allocation,without,pre,existing,index,files,transaction,logs,this,param,index,shard,the,index,shard,instance,to,recovery,the,shard,into,return,code,true,code,if,the,shard,has,been,recovered,successfully,code,false,code,if,the,recovery,has,been,ignored,due,to,a,concurrent,modification,of,if,the,clusters,state,has,changed,due,to,async,updates,see,store;boolean,recover,from,store,final,index,shard,index,shard,if,can,recover,index,shard,recovery,source,type,recovery,type,index,shard,recovery,state,get,recovery,source,get,type,assert,recovery,type,recovery,source,type,recovery,type,recovery,source,type,expected,store,recovery,type,but,was,recovery,type,return,execute,recovery,index,shard,logger,debug,starting,recovery,from,store,internal,recover,from,store,index,shard,return,false
StoreRecovery -> boolean recoverFromStore(final IndexShard indexShard);1536611444;Recovers a shard from it's local file system store. This method required pre-knowledge about if the shard should_exist on disk ie. has been previously allocated or if the shard is a brand new allocation without pre-existing index_files / transaction logs. This_@param indexShard the index shard instance to recovery the shard into_@return  <code>true</code> if the shard has been recovered successfully, <code>false</code> if the recovery_has been ignored due to a concurrent modification of if the clusters state has changed due to async updates._@see Store;boolean recoverFromStore(final IndexShard indexShard) {_        if (canRecover(indexShard)) {_            RecoverySource.Type recoveryType = indexShard.recoveryState().getRecoverySource().getType()__            assert recoveryType == RecoverySource.Type.EMPTY_STORE || recoveryType == RecoverySource.Type.EXISTING_STORE :_                "expected store recovery type but was: " + recoveryType__            return executeRecovery(indexShard, () -> {_                logger.debug("starting recovery from store ...")__                internalRecoverFromStore(indexShard)__            })__        }_        return false__    };recovers,a,shard,from,it,s,local,file,system,store,this,method,required,pre,knowledge,about,if,the,shard,should,exist,on,disk,ie,has,been,previously,allocated,or,if,the,shard,is,a,brand,new,allocation,without,pre,existing,index,files,transaction,logs,this,param,index,shard,the,index,shard,instance,to,recovery,the,shard,into,return,code,true,code,if,the,shard,has,been,recovered,successfully,code,false,code,if,the,recovery,has,been,ignored,due,to,a,concurrent,modification,of,if,the,clusters,state,has,changed,due,to,async,updates,see,store;boolean,recover,from,store,final,index,shard,index,shard,if,can,recover,index,shard,recovery,source,type,recovery,type,index,shard,recovery,state,get,recovery,source,get,type,assert,recovery,type,recovery,source,type,recovery,type,recovery,source,type,expected,store,recovery,type,but,was,recovery,type,return,execute,recovery,index,shard,logger,debug,starting,recovery,from,store,internal,recover,from,store,index,shard,return,false
StoreRecovery -> boolean recoverFromStore(final IndexShard indexShard);1538067637;Recovers a shard from it's local file system store. This method required pre-knowledge about if the shard should_exist on disk ie. has been previously allocated or if the shard is a brand new allocation without pre-existing index_files / transaction logs. This_@param indexShard the index shard instance to recovery the shard into_@return  <code>true</code> if the shard has been recovered successfully, <code>false</code> if the recovery_has been ignored due to a concurrent modification of if the clusters state has changed due to async updates._@see Store;boolean recoverFromStore(final IndexShard indexShard) {_        if (canRecover(indexShard)) {_            RecoverySource.Type recoveryType = indexShard.recoveryState().getRecoverySource().getType()__            assert recoveryType == RecoverySource.Type.EMPTY_STORE || recoveryType == RecoverySource.Type.EXISTING_STORE :_                "expected store recovery type but was: " + recoveryType__            return executeRecovery(indexShard, () -> {_                logger.debug("starting recovery from store ...")__                internalRecoverFromStore(indexShard)__            })__        }_        return false__    };recovers,a,shard,from,it,s,local,file,system,store,this,method,required,pre,knowledge,about,if,the,shard,should,exist,on,disk,ie,has,been,previously,allocated,or,if,the,shard,is,a,brand,new,allocation,without,pre,existing,index,files,transaction,logs,this,param,index,shard,the,index,shard,instance,to,recovery,the,shard,into,return,code,true,code,if,the,shard,has,been,recovered,successfully,code,false,code,if,the,recovery,has,been,ignored,due,to,a,concurrent,modification,of,if,the,clusters,state,has,changed,due,to,async,updates,see,store;boolean,recover,from,store,final,index,shard,index,shard,if,can,recover,index,shard,recovery,source,type,recovery,type,index,shard,recovery,state,get,recovery,source,get,type,assert,recovery,type,recovery,source,type,recovery,type,recovery,source,type,expected,store,recovery,type,but,was,recovery,type,return,execute,recovery,index,shard,logger,debug,starting,recovery,from,store,internal,recover,from,store,index,shard,return,false
StoreRecovery -> boolean recoverFromStore(final IndexShard indexShard);1542697754;Recovers a shard from it's local file system store. This method required pre-knowledge about if the shard should_exist on disk ie. has been previously allocated or if the shard is a brand new allocation without pre-existing index_files / transaction logs. This_@param indexShard the index shard instance to recovery the shard into_@return  <code>true</code> if the shard has been recovered successfully, <code>false</code> if the recovery_has been ignored due to a concurrent modification of if the clusters state has changed due to async updates._@see Store;boolean recoverFromStore(final IndexShard indexShard) {_        if (canRecover(indexShard)) {_            RecoverySource.Type recoveryType = indexShard.recoveryState().getRecoverySource().getType()__            assert recoveryType == RecoverySource.Type.EMPTY_STORE || recoveryType == RecoverySource.Type.EXISTING_STORE :_                "expected store recovery type but was: " + recoveryType__            return executeRecovery(indexShard, () -> {_                logger.debug("starting recovery from store ...")__                internalRecoverFromStore(indexShard)__            })__        }_        return false__    };recovers,a,shard,from,it,s,local,file,system,store,this,method,required,pre,knowledge,about,if,the,shard,should,exist,on,disk,ie,has,been,previously,allocated,or,if,the,shard,is,a,brand,new,allocation,without,pre,existing,index,files,transaction,logs,this,param,index,shard,the,index,shard,instance,to,recovery,the,shard,into,return,code,true,code,if,the,shard,has,been,recovered,successfully,code,false,code,if,the,recovery,has,been,ignored,due,to,a,concurrent,modification,of,if,the,clusters,state,has,changed,due,to,async,updates,see,store;boolean,recover,from,store,final,index,shard,index,shard,if,can,recover,index,shard,recovery,source,type,recovery,type,index,shard,recovery,state,get,recovery,source,get,type,assert,recovery,type,recovery,source,type,recovery,type,recovery,source,type,expected,store,recovery,type,but,was,recovery,type,return,execute,recovery,index,shard,logger,debug,starting,recovery,from,store,internal,recover,from,store,index,shard,return,false
StoreRecovery -> boolean recoverFromStore(final IndexShard indexShard);1543942400;Recovers a shard from it's local file system store. This method required pre-knowledge about if the shard should_exist on disk ie. has been previously allocated or if the shard is a brand new allocation without pre-existing index_files / transaction logs. This_@param indexShard the index shard instance to recovery the shard into_@return  <code>true</code> if the shard has been recovered successfully, <code>false</code> if the recovery_has been ignored due to a concurrent modification of if the clusters state has changed due to async updates._@see Store;boolean recoverFromStore(final IndexShard indexShard) {_        if (canRecover(indexShard)) {_            RecoverySource.Type recoveryType = indexShard.recoveryState().getRecoverySource().getType()__            assert recoveryType == RecoverySource.Type.EMPTY_STORE || recoveryType == RecoverySource.Type.EXISTING_STORE :_                "expected store recovery type but was: " + recoveryType__            return executeRecovery(indexShard, () -> {_                logger.debug("starting recovery from store ...")__                internalRecoverFromStore(indexShard)__            })__        }_        return false__    };recovers,a,shard,from,it,s,local,file,system,store,this,method,required,pre,knowledge,about,if,the,shard,should,exist,on,disk,ie,has,been,previously,allocated,or,if,the,shard,is,a,brand,new,allocation,without,pre,existing,index,files,transaction,logs,this,param,index,shard,the,index,shard,instance,to,recovery,the,shard,into,return,code,true,code,if,the,shard,has,been,recovered,successfully,code,false,code,if,the,recovery,has,been,ignored,due,to,a,concurrent,modification,of,if,the,clusters,state,has,changed,due,to,async,updates,see,store;boolean,recover,from,store,final,index,shard,index,shard,if,can,recover,index,shard,recovery,source,type,recovery,type,index,shard,recovery,state,get,recovery,source,get,type,assert,recovery,type,recovery,source,type,recovery,type,recovery,source,type,expected,store,recovery,type,but,was,recovery,type,return,execute,recovery,index,shard,logger,debug,starting,recovery,from,store,internal,recover,from,store,index,shard,return,false
StoreRecovery -> boolean recoverFromStore(final IndexShard indexShard);1549395161;Recovers a shard from it's local file system store. This method required pre-knowledge about if the shard should_exist on disk ie. has been previously allocated or if the shard is a brand new allocation without pre-existing index_files / transaction logs. This_@param indexShard the index shard instance to recovery the shard into_@return  <code>true</code> if the shard has been recovered successfully, <code>false</code> if the recovery_has been ignored due to a concurrent modification of if the clusters state has changed due to async updates._@see Store;boolean recoverFromStore(final IndexShard indexShard) {_        if (canRecover(indexShard)) {_            RecoverySource.Type recoveryType = indexShard.recoveryState().getRecoverySource().getType()__            assert recoveryType == RecoverySource.Type.EMPTY_STORE || recoveryType == RecoverySource.Type.EXISTING_STORE :_                "expected store recovery type but was: " + recoveryType__            return executeRecovery(indexShard, () -> {_                logger.debug("starting recovery from store ...")__                internalRecoverFromStore(indexShard)__            })__        }_        return false__    };recovers,a,shard,from,it,s,local,file,system,store,this,method,required,pre,knowledge,about,if,the,shard,should,exist,on,disk,ie,has,been,previously,allocated,or,if,the,shard,is,a,brand,new,allocation,without,pre,existing,index,files,transaction,logs,this,param,index,shard,the,index,shard,instance,to,recovery,the,shard,into,return,code,true,code,if,the,shard,has,been,recovered,successfully,code,false,code,if,the,recovery,has,been,ignored,due,to,a,concurrent,modification,of,if,the,clusters,state,has,changed,due,to,async,updates,see,store;boolean,recover,from,store,final,index,shard,index,shard,if,can,recover,index,shard,recovery,source,type,recovery,type,index,shard,recovery,state,get,recovery,source,get,type,assert,recovery,type,recovery,source,type,recovery,type,recovery,source,type,expected,store,recovery,type,but,was,recovery,type,return,execute,recovery,index,shard,logger,debug,starting,recovery,from,store,internal,recover,from,store,index,shard,return,false
StoreRecovery -> private void restore(final IndexShard indexShard, final Repository repository, final SnapshotRecoverySource restoreSource);1524684173;Restores shard from {@link SnapshotRecoverySource} associated with this shard in routing table;private void restore(final IndexShard indexShard, final Repository repository, final SnapshotRecoverySource restoreSource) {_        final RecoveryState.Translog translogState = indexShard.recoveryState().getTranslog()__        if (restoreSource == null) {_            throw new IndexShardRestoreFailedException(shardId, "empty restore source")__        }_        if (logger.isTraceEnabled()) {_            logger.trace("[{}] restoring shard [{}]", restoreSource.snapshot(), shardId)__        }_        try {_            translogState.totalOperations(0)__            translogState.totalOperationsOnStart(0)__            indexShard.prepareForIndexRecovery()__            ShardId snapshotShardId = shardId__            final String indexName = restoreSource.index()__            if (!shardId.getIndexName().equals(indexName)) {_                snapshotShardId = new ShardId(indexName, IndexMetaData.INDEX_UUID_NA_VALUE, shardId.id())__            }_            final IndexId indexId = repository.getRepositoryData().resolveIndexId(indexName)__            repository.restoreShard(indexShard, restoreSource.snapshot().getSnapshotId(), restoreSource.version(), indexId, snapshotShardId, indexShard.recoveryState())__            final Store store = indexShard.store()__            store.bootstrapNewHistory()__            final SegmentInfos segmentInfos = store.readLastCommittedSegmentsInfo()__            final long maxSeqNo = Long.parseLong(segmentInfos.userData.get(SequenceNumbers.MAX_SEQ_NO))__            final String translogUUID = Translog.createEmptyTranslog(_                indexShard.shardPath().resolveTranslog(), maxSeqNo, shardId, indexShard.getPrimaryTerm())__            store.associateIndexWithNewTranslog(translogUUID)__            assert indexShard.shardRouting.primary() : "only primary shards can recover from store"__            indexShard.openEngineAndRecoverFromTranslog()__            indexShard.getEngine().fillSeqNoGaps(indexShard.getPrimaryTerm())__            indexShard.finalizeRecovery()__            indexShard.postRecovery("restore done")__        } catch (Exception e) {_            throw new IndexShardRestoreFailedException(shardId, "restore failed", e)__        }_    };restores,shard,from,link,snapshot,recovery,source,associated,with,this,shard,in,routing,table;private,void,restore,final,index,shard,index,shard,final,repository,repository,final,snapshot,recovery,source,restore,source,final,recovery,state,translog,translog,state,index,shard,recovery,state,get,translog,if,restore,source,null,throw,new,index,shard,restore,failed,exception,shard,id,empty,restore,source,if,logger,is,trace,enabled,logger,trace,restoring,shard,restore,source,snapshot,shard,id,try,translog,state,total,operations,0,translog,state,total,operations,on,start,0,index,shard,prepare,for,index,recovery,shard,id,snapshot,shard,id,shard,id,final,string,index,name,restore,source,index,if,shard,id,get,index,name,equals,index,name,snapshot,shard,id,new,shard,id,index,name,index,meta,data,shard,id,id,final,index,id,index,id,repository,get,repository,data,resolve,index,id,index,name,repository,restore,shard,index,shard,restore,source,snapshot,get,snapshot,id,restore,source,version,index,id,snapshot,shard,id,index,shard,recovery,state,final,store,store,index,shard,store,store,bootstrap,new,history,final,segment,infos,segment,infos,store,read,last,committed,segments,info,final,long,max,seq,no,long,parse,long,segment,infos,user,data,get,sequence,numbers,final,string,translog,uuid,translog,create,empty,translog,index,shard,shard,path,resolve,translog,max,seq,no,shard,id,index,shard,get,primary,term,store,associate,index,with,new,translog,translog,uuid,assert,index,shard,shard,routing,primary,only,primary,shards,can,recover,from,store,index,shard,open,engine,and,recover,from,translog,index,shard,get,engine,fill,seq,no,gaps,index,shard,get,primary,term,index,shard,finalize,recovery,index,shard,post,recovery,restore,done,catch,exception,e,throw,new,index,shard,restore,failed,exception,shard,id,restore,failed,e
StoreRecovery -> private void restore(final IndexShard indexShard, final Repository repository, final SnapshotRecoverySource restoreSource);1533295538;Restores shard from {@link SnapshotRecoverySource} associated with this shard in routing table;private void restore(final IndexShard indexShard, final Repository repository, final SnapshotRecoverySource restoreSource) {_        final RecoveryState.Translog translogState = indexShard.recoveryState().getTranslog()__        if (restoreSource == null) {_            throw new IndexShardRestoreFailedException(shardId, "empty restore source")__        }_        if (logger.isTraceEnabled()) {_            logger.trace("[{}] restoring shard [{}]", restoreSource.snapshot(), shardId)__        }_        try {_            translogState.totalOperations(0)__            translogState.totalOperationsOnStart(0)__            indexShard.prepareForIndexRecovery()__            ShardId snapshotShardId = shardId__            final String indexName = restoreSource.index()__            if (!shardId.getIndexName().equals(indexName)) {_                snapshotShardId = new ShardId(indexName, IndexMetaData.INDEX_UUID_NA_VALUE, shardId.id())__            }_            final IndexId indexId = repository.getRepositoryData().resolveIndexId(indexName)__            repository.restoreShard(indexShard, restoreSource.snapshot().getSnapshotId(), restoreSource.version(), indexId, snapshotShardId, indexShard.recoveryState())__            final Store store = indexShard.store()__            store.bootstrapNewHistory()__            final SegmentInfos segmentInfos = store.readLastCommittedSegmentsInfo()__            final long maxSeqNo = Long.parseLong(segmentInfos.userData.get(SequenceNumbers.MAX_SEQ_NO))__            final String translogUUID = Translog.createEmptyTranslog(_                indexShard.shardPath().resolveTranslog(), maxSeqNo, shardId, indexShard.getPendingPrimaryTerm())__            store.associateIndexWithNewTranslog(translogUUID)__            assert indexShard.shardRouting.primary() : "only primary shards can recover from store"__            indexShard.openEngineAndRecoverFromTranslog()__            indexShard.getEngine().fillSeqNoGaps(indexShard.getPendingPrimaryTerm())__            indexShard.finalizeRecovery()__            indexShard.postRecovery("restore done")__        } catch (Exception e) {_            throw new IndexShardRestoreFailedException(shardId, "restore failed", e)__        }_    };restores,shard,from,link,snapshot,recovery,source,associated,with,this,shard,in,routing,table;private,void,restore,final,index,shard,index,shard,final,repository,repository,final,snapshot,recovery,source,restore,source,final,recovery,state,translog,translog,state,index,shard,recovery,state,get,translog,if,restore,source,null,throw,new,index,shard,restore,failed,exception,shard,id,empty,restore,source,if,logger,is,trace,enabled,logger,trace,restoring,shard,restore,source,snapshot,shard,id,try,translog,state,total,operations,0,translog,state,total,operations,on,start,0,index,shard,prepare,for,index,recovery,shard,id,snapshot,shard,id,shard,id,final,string,index,name,restore,source,index,if,shard,id,get,index,name,equals,index,name,snapshot,shard,id,new,shard,id,index,name,index,meta,data,shard,id,id,final,index,id,index,id,repository,get,repository,data,resolve,index,id,index,name,repository,restore,shard,index,shard,restore,source,snapshot,get,snapshot,id,restore,source,version,index,id,snapshot,shard,id,index,shard,recovery,state,final,store,store,index,shard,store,store,bootstrap,new,history,final,segment,infos,segment,infos,store,read,last,committed,segments,info,final,long,max,seq,no,long,parse,long,segment,infos,user,data,get,sequence,numbers,final,string,translog,uuid,translog,create,empty,translog,index,shard,shard,path,resolve,translog,max,seq,no,shard,id,index,shard,get,pending,primary,term,store,associate,index,with,new,translog,translog,uuid,assert,index,shard,shard,routing,primary,only,primary,shards,can,recover,from,store,index,shard,open,engine,and,recover,from,translog,index,shard,get,engine,fill,seq,no,gaps,index,shard,get,pending,primary,term,index,shard,finalize,recovery,index,shard,post,recovery,restore,done,catch,exception,e,throw,new,index,shard,restore,failed,exception,shard,id,restore,failed,e
StoreRecovery -> private void restore(final IndexShard indexShard, final Repository repository, final SnapshotRecoverySource restoreSource);1535723122;Restores shard from {@link SnapshotRecoverySource} associated with this shard in routing table;private void restore(final IndexShard indexShard, final Repository repository, final SnapshotRecoverySource restoreSource) {_        final RecoveryState.Translog translogState = indexShard.recoveryState().getTranslog()__        if (restoreSource == null) {_            throw new IndexShardRestoreFailedException(shardId, "empty restore source")__        }_        if (logger.isTraceEnabled()) {_            logger.trace("[{}] restoring shard [{}]", restoreSource.snapshot(), shardId)__        }_        try {_            translogState.totalOperations(0)__            translogState.totalOperationsOnStart(0)__            indexShard.prepareForIndexRecovery()__            ShardId snapshotShardId = shardId__            final String indexName = restoreSource.index()__            if (!shardId.getIndexName().equals(indexName)) {_                snapshotShardId = new ShardId(indexName, IndexMetaData.INDEX_UUID_NA_VALUE, shardId.id())__            }_            final IndexId indexId = repository.getRepositoryData().resolveIndexId(indexName)__            repository.restoreShard(indexShard, restoreSource.snapshot().getSnapshotId(), restoreSource.version(), indexId, snapshotShardId, indexShard.recoveryState())__            final Store store = indexShard.store()__            store.bootstrapNewHistory()__            final SegmentInfos segmentInfos = store.readLastCommittedSegmentsInfo()__            final long maxSeqNo = Long.parseLong(segmentInfos.userData.get(SequenceNumbers.MAX_SEQ_NO))__            final String translogUUID = Translog.createEmptyTranslog(_                indexShard.shardPath().resolveTranslog(), maxSeqNo, shardId, indexShard.getPendingPrimaryTerm())__            store.associateIndexWithNewTranslog(translogUUID)__            assert indexShard.shardRouting.primary() : "only primary shards can recover from store"__            indexShard.openEngineAndRecoverFromTranslog()__            indexShard.getEngine().fillSeqNoGaps(indexShard.getPendingPrimaryTerm())__            indexShard.finalizeRecovery()__            indexShard.postRecovery("restore done")__        } catch (Exception e) {_            throw new IndexShardRestoreFailedException(shardId, "restore failed", e)__        }_    };restores,shard,from,link,snapshot,recovery,source,associated,with,this,shard,in,routing,table;private,void,restore,final,index,shard,index,shard,final,repository,repository,final,snapshot,recovery,source,restore,source,final,recovery,state,translog,translog,state,index,shard,recovery,state,get,translog,if,restore,source,null,throw,new,index,shard,restore,failed,exception,shard,id,empty,restore,source,if,logger,is,trace,enabled,logger,trace,restoring,shard,restore,source,snapshot,shard,id,try,translog,state,total,operations,0,translog,state,total,operations,on,start,0,index,shard,prepare,for,index,recovery,shard,id,snapshot,shard,id,shard,id,final,string,index,name,restore,source,index,if,shard,id,get,index,name,equals,index,name,snapshot,shard,id,new,shard,id,index,name,index,meta,data,shard,id,id,final,index,id,index,id,repository,get,repository,data,resolve,index,id,index,name,repository,restore,shard,index,shard,restore,source,snapshot,get,snapshot,id,restore,source,version,index,id,snapshot,shard,id,index,shard,recovery,state,final,store,store,index,shard,store,store,bootstrap,new,history,final,segment,infos,segment,infos,store,read,last,committed,segments,info,final,long,max,seq,no,long,parse,long,segment,infos,user,data,get,sequence,numbers,final,string,translog,uuid,translog,create,empty,translog,index,shard,shard,path,resolve,translog,max,seq,no,shard,id,index,shard,get,pending,primary,term,store,associate,index,with,new,translog,translog,uuid,assert,index,shard,shard,routing,primary,only,primary,shards,can,recover,from,store,index,shard,open,engine,and,recover,from,translog,index,shard,get,engine,fill,seq,no,gaps,index,shard,get,pending,primary,term,index,shard,finalize,recovery,index,shard,post,recovery,restore,done,catch,exception,e,throw,new,index,shard,restore,failed,exception,shard,id,restore,failed,e
StoreRecovery -> private void restore(final IndexShard indexShard, final Repository repository, final SnapshotRecoverySource restoreSource);1536611444;Restores shard from {@link SnapshotRecoverySource} associated with this shard in routing table;private void restore(final IndexShard indexShard, final Repository repository, final SnapshotRecoverySource restoreSource) {_        final RecoveryState.Translog translogState = indexShard.recoveryState().getTranslog()__        if (restoreSource == null) {_            throw new IndexShardRestoreFailedException(shardId, "empty restore source")__        }_        if (logger.isTraceEnabled()) {_            logger.trace("[{}] restoring shard [{}]", restoreSource.snapshot(), shardId)__        }_        try {_            translogState.totalOperations(0)__            translogState.totalOperationsOnStart(0)__            indexShard.prepareForIndexRecovery()__            ShardId snapshotShardId = shardId__            final String indexName = restoreSource.index()__            if (!shardId.getIndexName().equals(indexName)) {_                snapshotShardId = new ShardId(indexName, IndexMetaData.INDEX_UUID_NA_VALUE, shardId.id())__            }_            final IndexId indexId = repository.getRepositoryData().resolveIndexId(indexName)__            repository.restoreShard(indexShard, restoreSource.snapshot().getSnapshotId(), restoreSource.version(), indexId, snapshotShardId, indexShard.recoveryState())__            final Store store = indexShard.store()__            store.bootstrapNewHistory()__            final SegmentInfos segmentInfos = store.readLastCommittedSegmentsInfo()__            final long maxSeqNo = Long.parseLong(segmentInfos.userData.get(SequenceNumbers.MAX_SEQ_NO))__            final String translogUUID = Translog.createEmptyTranslog(_                indexShard.shardPath().resolveTranslog(), maxSeqNo, shardId, indexShard.getPendingPrimaryTerm())__            store.associateIndexWithNewTranslog(translogUUID)__            assert indexShard.shardRouting.primary() : "only primary shards can recover from store"__            indexShard.openEngineAndRecoverFromTranslog()__            indexShard.getEngine().fillSeqNoGaps(indexShard.getPendingPrimaryTerm())__            indexShard.finalizeRecovery()__            indexShard.postRecovery("restore done")__        } catch (Exception e) {_            throw new IndexShardRestoreFailedException(shardId, "restore failed", e)__        }_    };restores,shard,from,link,snapshot,recovery,source,associated,with,this,shard,in,routing,table;private,void,restore,final,index,shard,index,shard,final,repository,repository,final,snapshot,recovery,source,restore,source,final,recovery,state,translog,translog,state,index,shard,recovery,state,get,translog,if,restore,source,null,throw,new,index,shard,restore,failed,exception,shard,id,empty,restore,source,if,logger,is,trace,enabled,logger,trace,restoring,shard,restore,source,snapshot,shard,id,try,translog,state,total,operations,0,translog,state,total,operations,on,start,0,index,shard,prepare,for,index,recovery,shard,id,snapshot,shard,id,shard,id,final,string,index,name,restore,source,index,if,shard,id,get,index,name,equals,index,name,snapshot,shard,id,new,shard,id,index,name,index,meta,data,shard,id,id,final,index,id,index,id,repository,get,repository,data,resolve,index,id,index,name,repository,restore,shard,index,shard,restore,source,snapshot,get,snapshot,id,restore,source,version,index,id,snapshot,shard,id,index,shard,recovery,state,final,store,store,index,shard,store,store,bootstrap,new,history,final,segment,infos,segment,infos,store,read,last,committed,segments,info,final,long,max,seq,no,long,parse,long,segment,infos,user,data,get,sequence,numbers,final,string,translog,uuid,translog,create,empty,translog,index,shard,shard,path,resolve,translog,max,seq,no,shard,id,index,shard,get,pending,primary,term,store,associate,index,with,new,translog,translog,uuid,assert,index,shard,shard,routing,primary,only,primary,shards,can,recover,from,store,index,shard,open,engine,and,recover,from,translog,index,shard,get,engine,fill,seq,no,gaps,index,shard,get,pending,primary,term,index,shard,finalize,recovery,index,shard,post,recovery,restore,done,catch,exception,e,throw,new,index,shard,restore,failed,exception,shard,id,restore,failed,e
StoreRecovery -> private void restore(final IndexShard indexShard, final Repository repository, final SnapshotRecoverySource restoreSource);1538067637;Restores shard from {@link SnapshotRecoverySource} associated with this shard in routing table;private void restore(final IndexShard indexShard, final Repository repository, final SnapshotRecoverySource restoreSource) {_        final RecoveryState.Translog translogState = indexShard.recoveryState().getTranslog()__        if (restoreSource == null) {_            throw new IndexShardRestoreFailedException(shardId, "empty restore source")__        }_        if (logger.isTraceEnabled()) {_            logger.trace("[{}] restoring shard [{}]", restoreSource.snapshot(), shardId)__        }_        try {_            translogState.totalOperations(0)__            translogState.totalOperationsOnStart(0)__            indexShard.prepareForIndexRecovery()__            ShardId snapshotShardId = shardId__            final String indexName = restoreSource.index()__            if (!shardId.getIndexName().equals(indexName)) {_                snapshotShardId = new ShardId(indexName, IndexMetaData.INDEX_UUID_NA_VALUE, shardId.id())__            }_            final IndexId indexId = repository.getRepositoryData().resolveIndexId(indexName)__            repository.restoreShard(indexShard, restoreSource.snapshot().getSnapshotId(), restoreSource.version(), indexId, snapshotShardId, indexShard.recoveryState())__            final Store store = indexShard.store()__            store.bootstrapNewHistory()__            final SegmentInfos segmentInfos = store.readLastCommittedSegmentsInfo()__            final long maxSeqNo = Long.parseLong(segmentInfos.userData.get(SequenceNumbers.MAX_SEQ_NO))__            final String translogUUID = Translog.createEmptyTranslog(_                indexShard.shardPath().resolveTranslog(), maxSeqNo, shardId, indexShard.getPendingPrimaryTerm())__            store.associateIndexWithNewTranslog(translogUUID)__            assert indexShard.shardRouting.primary() : "only primary shards can recover from store"__            indexShard.openEngineAndRecoverFromTranslog()__            indexShard.getEngine().fillSeqNoGaps(indexShard.getPendingPrimaryTerm())__            indexShard.finalizeRecovery()__            indexShard.postRecovery("restore done")__        } catch (Exception e) {_            throw new IndexShardRestoreFailedException(shardId, "restore failed", e)__        }_    };restores,shard,from,link,snapshot,recovery,source,associated,with,this,shard,in,routing,table;private,void,restore,final,index,shard,index,shard,final,repository,repository,final,snapshot,recovery,source,restore,source,final,recovery,state,translog,translog,state,index,shard,recovery,state,get,translog,if,restore,source,null,throw,new,index,shard,restore,failed,exception,shard,id,empty,restore,source,if,logger,is,trace,enabled,logger,trace,restoring,shard,restore,source,snapshot,shard,id,try,translog,state,total,operations,0,translog,state,total,operations,on,start,0,index,shard,prepare,for,index,recovery,shard,id,snapshot,shard,id,shard,id,final,string,index,name,restore,source,index,if,shard,id,get,index,name,equals,index,name,snapshot,shard,id,new,shard,id,index,name,index,meta,data,shard,id,id,final,index,id,index,id,repository,get,repository,data,resolve,index,id,index,name,repository,restore,shard,index,shard,restore,source,snapshot,get,snapshot,id,restore,source,version,index,id,snapshot,shard,id,index,shard,recovery,state,final,store,store,index,shard,store,store,bootstrap,new,history,final,segment,infos,segment,infos,store,read,last,committed,segments,info,final,long,max,seq,no,long,parse,long,segment,infos,user,data,get,sequence,numbers,final,string,translog,uuid,translog,create,empty,translog,index,shard,shard,path,resolve,translog,max,seq,no,shard,id,index,shard,get,pending,primary,term,store,associate,index,with,new,translog,translog,uuid,assert,index,shard,shard,routing,primary,only,primary,shards,can,recover,from,store,index,shard,open,engine,and,recover,from,translog,index,shard,get,engine,fill,seq,no,gaps,index,shard,get,pending,primary,term,index,shard,finalize,recovery,index,shard,post,recovery,restore,done,catch,exception,e,throw,new,index,shard,restore,failed,exception,shard,id,restore,failed,e
StoreRecovery -> private void restore(final IndexShard indexShard, final Repository repository, final SnapshotRecoverySource restoreSource);1542697754;Restores shard from {@link SnapshotRecoverySource} associated with this shard in routing table;private void restore(final IndexShard indexShard, final Repository repository, final SnapshotRecoverySource restoreSource) {_        final RecoveryState.Translog translogState = indexShard.recoveryState().getTranslog()__        if (restoreSource == null) {_            throw new IndexShardRestoreFailedException(shardId, "empty restore source")__        }_        if (logger.isTraceEnabled()) {_            logger.trace("[{}] restoring shard [{}]", restoreSource.snapshot(), shardId)__        }_        try {_            translogState.totalOperations(0)__            translogState.totalOperationsOnStart(0)__            indexShard.prepareForIndexRecovery()__            ShardId snapshotShardId = shardId__            final String indexName = restoreSource.index()__            if (!shardId.getIndexName().equals(indexName)) {_                snapshotShardId = new ShardId(indexName, IndexMetaData.INDEX_UUID_NA_VALUE, shardId.id())__            }_            final IndexId indexId = repository.getRepositoryData().resolveIndexId(indexName)__            repository.restoreShard(indexShard, restoreSource.snapshot().getSnapshotId(),_                restoreSource.version(), indexId, snapshotShardId, indexShard.recoveryState())__            final Store store = indexShard.store()__            store.bootstrapNewHistory()__            final SegmentInfos segmentInfos = store.readLastCommittedSegmentsInfo()__            final long maxSeqNo = Long.parseLong(segmentInfos.userData.get(SequenceNumbers.MAX_SEQ_NO))__            final String translogUUID = Translog.createEmptyTranslog(_                indexShard.shardPath().resolveTranslog(), maxSeqNo, shardId, indexShard.getPendingPrimaryTerm())__            store.associateIndexWithNewTranslog(translogUUID)__            assert indexShard.shardRouting.primary() : "only primary shards can recover from store"__            indexShard.openEngineAndRecoverFromTranslog()__            indexShard.getEngine().fillSeqNoGaps(indexShard.getPendingPrimaryTerm())__            indexShard.finalizeRecovery()__            indexShard.postRecovery("restore done")__        } catch (Exception e) {_            throw new IndexShardRestoreFailedException(shardId, "restore failed", e)__        }_    };restores,shard,from,link,snapshot,recovery,source,associated,with,this,shard,in,routing,table;private,void,restore,final,index,shard,index,shard,final,repository,repository,final,snapshot,recovery,source,restore,source,final,recovery,state,translog,translog,state,index,shard,recovery,state,get,translog,if,restore,source,null,throw,new,index,shard,restore,failed,exception,shard,id,empty,restore,source,if,logger,is,trace,enabled,logger,trace,restoring,shard,restore,source,snapshot,shard,id,try,translog,state,total,operations,0,translog,state,total,operations,on,start,0,index,shard,prepare,for,index,recovery,shard,id,snapshot,shard,id,shard,id,final,string,index,name,restore,source,index,if,shard,id,get,index,name,equals,index,name,snapshot,shard,id,new,shard,id,index,name,index,meta,data,shard,id,id,final,index,id,index,id,repository,get,repository,data,resolve,index,id,index,name,repository,restore,shard,index,shard,restore,source,snapshot,get,snapshot,id,restore,source,version,index,id,snapshot,shard,id,index,shard,recovery,state,final,store,store,index,shard,store,store,bootstrap,new,history,final,segment,infos,segment,infos,store,read,last,committed,segments,info,final,long,max,seq,no,long,parse,long,segment,infos,user,data,get,sequence,numbers,final,string,translog,uuid,translog,create,empty,translog,index,shard,shard,path,resolve,translog,max,seq,no,shard,id,index,shard,get,pending,primary,term,store,associate,index,with,new,translog,translog,uuid,assert,index,shard,shard,routing,primary,only,primary,shards,can,recover,from,store,index,shard,open,engine,and,recover,from,translog,index,shard,get,engine,fill,seq,no,gaps,index,shard,get,pending,primary,term,index,shard,finalize,recovery,index,shard,post,recovery,restore,done,catch,exception,e,throw,new,index,shard,restore,failed,exception,shard,id,restore,failed,e
StoreRecovery -> private void restore(final IndexShard indexShard, final Repository repository, final SnapshotRecoverySource restoreSource);1543942400;Restores shard from {@link SnapshotRecoverySource} associated with this shard in routing table;private void restore(final IndexShard indexShard, final Repository repository, final SnapshotRecoverySource restoreSource) {_        final RecoveryState.Translog translogState = indexShard.recoveryState().getTranslog()__        if (restoreSource == null) {_            throw new IndexShardRestoreFailedException(shardId, "empty restore source")__        }_        if (logger.isTraceEnabled()) {_            logger.trace("[{}] restoring shard [{}]", restoreSource.snapshot(), shardId)__        }_        try {_            translogState.totalOperations(0)__            translogState.totalOperationsOnStart(0)__            indexShard.prepareForIndexRecovery()__            ShardId snapshotShardId = shardId__            final String indexName = restoreSource.index()__            if (!shardId.getIndexName().equals(indexName)) {_                snapshotShardId = new ShardId(indexName, IndexMetaData.INDEX_UUID_NA_VALUE, shardId.id())__            }_            final IndexId indexId = repository.getRepositoryData().resolveIndexId(indexName)__            repository.restoreShard(indexShard, restoreSource.snapshot().getSnapshotId(),_                restoreSource.version(), indexId, snapshotShardId, indexShard.recoveryState())__            final Store store = indexShard.store()__            store.bootstrapNewHistory()__            final SegmentInfos segmentInfos = store.readLastCommittedSegmentsInfo()__            final long maxSeqNo = Long.parseLong(segmentInfos.userData.get(SequenceNumbers.MAX_SEQ_NO))__            final String translogUUID = Translog.createEmptyTranslog(_                indexShard.shardPath().resolveTranslog(), maxSeqNo, shardId, indexShard.getPendingPrimaryTerm())__            store.associateIndexWithNewTranslog(translogUUID)__            assert indexShard.shardRouting.primary() : "only primary shards can recover from store"__            indexShard.openEngineAndRecoverFromTranslog()__            indexShard.getEngine().fillSeqNoGaps(indexShard.getPendingPrimaryTerm())__            indexShard.finalizeRecovery()__            indexShard.postRecovery("restore done")__        } catch (Exception e) {_            throw new IndexShardRestoreFailedException(shardId, "restore failed", e)__        }_    };restores,shard,from,link,snapshot,recovery,source,associated,with,this,shard,in,routing,table;private,void,restore,final,index,shard,index,shard,final,repository,repository,final,snapshot,recovery,source,restore,source,final,recovery,state,translog,translog,state,index,shard,recovery,state,get,translog,if,restore,source,null,throw,new,index,shard,restore,failed,exception,shard,id,empty,restore,source,if,logger,is,trace,enabled,logger,trace,restoring,shard,restore,source,snapshot,shard,id,try,translog,state,total,operations,0,translog,state,total,operations,on,start,0,index,shard,prepare,for,index,recovery,shard,id,snapshot,shard,id,shard,id,final,string,index,name,restore,source,index,if,shard,id,get,index,name,equals,index,name,snapshot,shard,id,new,shard,id,index,name,index,meta,data,shard,id,id,final,index,id,index,id,repository,get,repository,data,resolve,index,id,index,name,repository,restore,shard,index,shard,restore,source,snapshot,get,snapshot,id,restore,source,version,index,id,snapshot,shard,id,index,shard,recovery,state,final,store,store,index,shard,store,store,bootstrap,new,history,final,segment,infos,segment,infos,store,read,last,committed,segments,info,final,long,max,seq,no,long,parse,long,segment,infos,user,data,get,sequence,numbers,final,string,translog,uuid,translog,create,empty,translog,index,shard,shard,path,resolve,translog,max,seq,no,shard,id,index,shard,get,pending,primary,term,store,associate,index,with,new,translog,translog,uuid,assert,index,shard,shard,routing,primary,only,primary,shards,can,recover,from,store,index,shard,open,engine,and,recover,from,translog,index,shard,get,engine,fill,seq,no,gaps,index,shard,get,pending,primary,term,index,shard,finalize,recovery,index,shard,post,recovery,restore,done,catch,exception,e,throw,new,index,shard,restore,failed,exception,shard,id,restore,failed,e
StoreRecovery -> private void restore(final IndexShard indexShard, final Repository repository, final SnapshotRecoverySource restoreSource);1549395161;Restores shard from {@link SnapshotRecoverySource} associated with this shard in routing table;private void restore(final IndexShard indexShard, final Repository repository, final SnapshotRecoverySource restoreSource) {_        final RecoveryState.Translog translogState = indexShard.recoveryState().getTranslog()__        if (restoreSource == null) {_            throw new IndexShardRestoreFailedException(shardId, "empty restore source")__        }_        if (logger.isTraceEnabled()) {_            logger.trace("[{}] restoring shard [{}]", restoreSource.snapshot(), shardId)__        }_        try {_            translogState.totalOperations(0)__            translogState.totalOperationsOnStart(0)__            indexShard.prepareForIndexRecovery()__            ShardId snapshotShardId = shardId__            final String indexName = restoreSource.index()__            if (!shardId.getIndexName().equals(indexName)) {_                snapshotShardId = new ShardId(indexName, IndexMetaData.INDEX_UUID_NA_VALUE, shardId.id())__            }_            final IndexId indexId = repository.getRepositoryData().resolveIndexId(indexName)__            repository.restoreShard(indexShard, restoreSource.snapshot().getSnapshotId(),_                restoreSource.version(), indexId, snapshotShardId, indexShard.recoveryState())__            final Store store = indexShard.store()__            store.bootstrapNewHistory()__            final SegmentInfos segmentInfos = store.readLastCommittedSegmentsInfo()__            final long localCheckpoint = Long.parseLong(segmentInfos.userData.get(SequenceNumbers.LOCAL_CHECKPOINT_KEY))__            final String translogUUID = Translog.createEmptyTranslog(_                indexShard.shardPath().resolveTranslog(), localCheckpoint, shardId, indexShard.getPendingPrimaryTerm())__            store.associateIndexWithNewTranslog(translogUUID)__            assert indexShard.shardRouting.primary() : "only primary shards can recover from store"__            indexShard.openEngineAndRecoverFromTranslog()__            indexShard.getEngine().fillSeqNoGaps(indexShard.getPendingPrimaryTerm())__            indexShard.finalizeRecovery()__            indexShard.postRecovery("restore done")__        } catch (Exception e) {_            throw new IndexShardRestoreFailedException(shardId, "restore failed", e)__        }_    };restores,shard,from,link,snapshot,recovery,source,associated,with,this,shard,in,routing,table;private,void,restore,final,index,shard,index,shard,final,repository,repository,final,snapshot,recovery,source,restore,source,final,recovery,state,translog,translog,state,index,shard,recovery,state,get,translog,if,restore,source,null,throw,new,index,shard,restore,failed,exception,shard,id,empty,restore,source,if,logger,is,trace,enabled,logger,trace,restoring,shard,restore,source,snapshot,shard,id,try,translog,state,total,operations,0,translog,state,total,operations,on,start,0,index,shard,prepare,for,index,recovery,shard,id,snapshot,shard,id,shard,id,final,string,index,name,restore,source,index,if,shard,id,get,index,name,equals,index,name,snapshot,shard,id,new,shard,id,index,name,index,meta,data,shard,id,id,final,index,id,index,id,repository,get,repository,data,resolve,index,id,index,name,repository,restore,shard,index,shard,restore,source,snapshot,get,snapshot,id,restore,source,version,index,id,snapshot,shard,id,index,shard,recovery,state,final,store,store,index,shard,store,store,bootstrap,new,history,final,segment,infos,segment,infos,store,read,last,committed,segments,info,final,long,local,checkpoint,long,parse,long,segment,infos,user,data,get,sequence,numbers,final,string,translog,uuid,translog,create,empty,translog,index,shard,shard,path,resolve,translog,local,checkpoint,shard,id,index,shard,get,pending,primary,term,store,associate,index,with,new,translog,translog,uuid,assert,index,shard,shard,routing,primary,only,primary,shards,can,recover,from,store,index,shard,open,engine,and,recover,from,translog,index,shard,get,engine,fill,seq,no,gaps,index,shard,get,pending,primary,term,index,shard,finalize,recovery,index,shard,post,recovery,restore,done,catch,exception,e,throw,new,index,shard,restore,failed,exception,shard,id,restore,failed,e
