commented;modifiers;parameterAmount;loc;comment;code
false;public;1;10;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeOptionalString(globalText).     final int size = suggestions.size().     out.writeVInt(size).     for (Entry<String, SuggestionBuilder<?>> suggestion : suggestions.entrySet()) {         out.writeString(suggestion.getKey()).         out.writeNamedWriteable(suggestion.getValue()).     } }
true;public;1;4;/**  * Sets the text to provide suggestions for. The suggest text is a required option that needs  * to be set either via this setter or via the {@link org.elasticsearch.search.suggest.SuggestionBuilder#text(String)} method.  * <p>  * The suggest text gets analyzed by the suggest analyzer or the suggest field search analyzer.  * For each analyzed token, suggested terms are suggested if possible.  */ ;/**  * Sets the text to provide suggestions for. The suggest text is a required option that needs  * to be set either via this setter or via the {@link org.elasticsearch.search.suggest.SuggestionBuilder#text(String)} method.  * <p>  * The suggest text gets analyzed by the suggest analyzer or the suggest field search analyzer.  * For each analyzed token, suggested terms are suggested if possible.  */ public SuggestBuilder setGlobalText(@Nullable String globalText) {     this.globalText = globalText.     return this. }
true;public;0;4;/**  * Gets the global suggest text  */ ;/**  * Gets the global suggest text  */ @Nullable public String getGlobalText() {     return globalText. }
true;public;2;9;/**  * Adds an {@link org.elasticsearch.search.suggest.SuggestionBuilder} instance under a user defined name.  * The order in which the <code>Suggestions</code> are added, is the same as in the response.  * @throws IllegalArgumentException if two suggestions added have the same name  */ ;/**  * Adds an {@link org.elasticsearch.search.suggest.SuggestionBuilder} instance under a user defined name.  * The order in which the <code>Suggestions</code> are added, is the same as in the response.  * @throws IllegalArgumentException if two suggestions added have the same name  */ public SuggestBuilder addSuggestion(String name, SuggestionBuilder<?> suggestion) {     Objects.requireNonNull(name, "every suggestion needs a name").     if (suggestions.get(name) == null) {         suggestions.put(name, suggestion).     } else {         throw new IllegalArgumentException("already added another suggestion with name [" + name + "]").     }     return this. }
true;public;0;3;/**  * Get all the <code>Suggestions</code> that were added to the global {@link SuggestBuilder},  * together with their names  */ ;/**  * Get all the <code>Suggestions</code> that were added to the global {@link SuggestBuilder},  * together with their names  */ public Map<String, SuggestionBuilder<?>> getSuggestions() {     return suggestions. }
false;public;2;14;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     if (globalText != null) {         builder.field("text", globalText).     }     for (Entry<String, SuggestionBuilder<?>> suggestion : suggestions.entrySet()) {         builder.startObject(suggestion.getKey()).         suggestion.getValue().toXContent(builder, params).         builder.endObject().     }     builder.endObject().     return builder. }
false;public,static;1;31;;public static SuggestBuilder fromXContent(XContentParser parser) throws IOException {     SuggestBuilder suggestBuilder = new SuggestBuilder().     String fieldName = null.     if (parser.currentToken() == null) {         // when we parse from RestSuggestAction the current token is null, advance the token         parser.nextToken().     }     assert parser.currentToken() == XContentParser.Token.START_OBJECT : "current token must be a start object".     XContentParser.Token token.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             fieldName = parser.currentName().         } else if (token.isValue()) {             if (GLOBAL_TEXT_FIELD.match(fieldName, parser.getDeprecationHandler())) {                 suggestBuilder.setGlobalText(parser.text()).             } else {                 throw new IllegalArgumentException("[suggest] does not support [" + fieldName + "]").             }         } else if (token == XContentParser.Token.START_OBJECT) {             String suggestionName = fieldName.             if (suggestionName == null) {                 throw new IllegalArgumentException("suggestion must have name").             }             suggestBuilder.addSuggestion(suggestionName, SuggestionBuilder.fromXContent(parser)).         } else {             throw new ParsingException(parser.getTokenLocation(), "unexpected token [" + token + "] after [" + fieldName + "]").         }     }     return suggestBuilder. }
false;public;1;14;;public SuggestionSearchContext build(QueryShardContext context) throws IOException {     SuggestionSearchContext suggestionSearchContext = new SuggestionSearchContext().     for (Entry<String, SuggestionBuilder<?>> suggestion : suggestions.entrySet()) {         SuggestionContext suggestionContext = suggestion.getValue().build(context).         if (suggestionContext.getText() == null) {             if (globalText == null) {                 throw new IllegalArgumentException("The required text option is missing").             }             suggestionContext.setText(BytesRefs.toBytesRef(globalText)).         }         suggestionSearchContext.addSuggestion(suggestion.getKey(), suggestionContext).     }     return suggestionSearchContext. }
false;public;1;12;;@Override public boolean equals(Object other) {     if (this == other) {         return true.     }     if (other == null || getClass() != other.getClass()) {         return false.     }     SuggestBuilder o = (SuggestBuilder) other.     return Objects.equals(globalText, o.globalText) && Objects.equals(suggestions, o.suggestions). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(globalText, suggestions). }
false;public;0;4;;@Override public String toString() {     return Strings.toString(this, true, true). }
