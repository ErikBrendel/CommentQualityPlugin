commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Is it a failed search?  */ ;/**  * Is it a failed search?  */ public boolean isFailure() {     return exception != null. }
true;public;0;4;/**  * The actual failure message, null if its not a failure.  */ ;/**  * The actual failure message, null if its not a failure.  */ @Nullable public String getFailureMessage() {     return exception == null ? null : exception.getMessage(). }
true;public;0;4;/**  * The actual search response, null if its a failure.  */ ;/**  * The actual search response, null if its a failure.  */ @Nullable public SearchResponse getResponse() {     return this.response. }
false;public,static;1;5;;public static Item readItem(StreamInput in) throws IOException {     Item item = new Item().     item.readFrom(in).     return item. }
false;public;1;9;;@Override public void readFrom(StreamInput in) throws IOException {     if (in.readBoolean()) {         this.response = new SearchResponse().         response.readFrom(in).     } else {         exception = in.readException().     } }
false;public;1;10;;@Override public void writeTo(StreamOutput out) throws IOException {     if (response != null) {         out.writeBoolean(true).         response.writeTo(out).     } else {         out.writeBoolean(false).         out.writeException(exception).     } }
false;public;0;3;;public Exception getFailure() {     return exception. }
false;public;0;4;;@Override public Iterator<Item> iterator() {     return Arrays.stream(items).iterator(). }
true;public;0;3;/**  * The list of responses, the order is the same as the one provided in the request.  */ ;/**  * The list of responses, the order is the same as the one provided in the request.  */ public Item[] getResponses() {     return this.items. }
true;public;0;3;/**  * How long the msearch took.  */ ;/**  * How long the msearch took.  */ public TimeValue getTook() {     return new TimeValue(tookInMillis). }
false;public;1;11;;@Override public void readFrom(StreamInput in) throws IOException {     super.readFrom(in).     items = new Item[in.readVInt()].     for (int i = 0. i < items.length. i++) {         items[i] = Item.readItem(in).     }     if (in.getVersion().onOrAfter(Version.V_7_0_0)) {         tookInMillis = in.readVLong().     } }
false;public;1;11;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeVInt(items.length).     for (Item item : items) {         item.writeTo(out).     }     if (out.getVersion().onOrAfter(Version.V_7_0_0)) {         out.writeVLong(tookInMillis).     } }
false;public;2;20;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     builder.field("took", tookInMillis).     builder.startArray(Fields.RESPONSES).     for (Item item : items) {         builder.startObject().         if (item.isFailure()) {             ElasticsearchException.generateFailureXContent(builder, params, item.getFailure(), true).             builder.field(Fields.STATUS, ExceptionsHelper.status(item.getFailure()).getStatus()).         } else {             item.getResponse().innerToXContent(builder, params).             builder.field(Fields.STATUS, item.getResponse().status().getStatus()).         }         builder.endObject().     }     builder.endArray().     builder.endObject().     return builder. }
false;public,static;1;3;;public static MultiSearchResponse fromXContext(XContentParser parser) {     return PARSER.apply(parser, null). }
false;private,static;1;34;;private static MultiSearchResponse.Item itemFromXContent(XContentParser parser) throws IOException {     // This parsing logic is a bit tricky here, because the multi search response itself is tricky:     // 1) The json objects inside the responses array are either a search response or a serialized exception     // 2) Each response json object gets a status field injected that ElasticsearchException.failureFromXContent(...) does not parse,     // but SearchResponse.innerFromXContent(...) parses and then ignores. The status field is not needed to parse     // the response item. However in both cases this method does need to parse the 'status' field otherwise the parsing of     // the response item in the next json array element will fail due to parsing errors.     Item item = null.     String fieldName = null.     Token token = parser.nextToken().     assert token == Token.FIELD_NAME.     outer: for (. token != Token.END_OBJECT. token = parser.nextToken()) {         switch(token) {             case FIELD_NAME:                 fieldName = parser.currentName().                 if ("error".equals(fieldName)) {                     item = new Item(null, ElasticsearchException.failureFromXContent(parser)).                 } else if ("status".equals(fieldName) == false) {                     item = new Item(SearchResponse.innerFromXContent(parser), null).                     break outer.                 }                 break.             case VALUE_NUMBER:                 if ("status".equals(fieldName)) {                 // Ignore the status value                 }                 break.         }     }     assert parser.currentToken() == Token.END_OBJECT.     return item. }
false;public;0;4;;@Override public String toString() {     return Strings.toString(this). }
