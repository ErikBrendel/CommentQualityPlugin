commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public ScoreMode scoreMode() {     return valuesSource != null && valuesSource.needsScores() ? ScoreMode.COMPLETE : ScoreMode.COMPLETE_NO_SCORES. }
false;public;2;14;;@Override public void collect(int doc, long bucket) throws IOException {     if (bucket >= maxes.size()) {         long from = maxes.size().         maxes = bigArrays.grow(maxes, bucket + 1).         maxes.fill(from, maxes.size(), Double.NEGATIVE_INFINITY).     }     if (values.advanceExact(doc)) {         final double value = values.doubleValue().         double max = maxes.get(bucket).         max = Math.max(max, value).         maxes.set(bucket, max).     } }
false;public;2;48;;@Override public LeafBucketCollector getLeafCollector(LeafReaderContext ctx, final LeafBucketCollector sub) throws IOException {     if (valuesSource == null) {         if (parent != null) {             return LeafBucketCollector.NO_OP_COLLECTOR.         } else {             // we have no parent and the values source is empty so we can skip collecting hits.             throw new CollectionTerminatedException().         }     }     if (pointConverter != null) {         Number segMax = findLeafMaxValue(ctx.reader(), pointField, pointConverter).         if (segMax != null) {             /**              * There is no parent aggregator (see {@link MinAggregator#getPointReaderOrNull}              * so the ordinal for the bucket is always 0.              */             assert maxes.size() == 1.             double max = maxes.get(0).             max = Math.max(max, segMax.doubleValue()).             maxes.set(0, max).             // the maximum value has been extracted, we don't need to collect hits on this segment.             throw new CollectionTerminatedException().         }     }     final BigArrays bigArrays = context.bigArrays().     final SortedNumericDoubleValues allValues = valuesSource.doubleValues(ctx).     final NumericDoubleValues values = MultiValueMode.MAX.select(allValues).     return new LeafBucketCollectorBase(sub, allValues) {          @Override         public void collect(int doc, long bucket) throws IOException {             if (bucket >= maxes.size()) {                 long from = maxes.size().                 maxes = bigArrays.grow(maxes, bucket + 1).                 maxes.fill(from, maxes.size(), Double.NEGATIVE_INFINITY).             }             if (values.advanceExact(doc)) {                 final double value = values.doubleValue().                 double max = maxes.get(bucket).                 max = Math.max(max, value).                 maxes.set(bucket, max).             }         }     }. }
false;public;1;7;;@Override public double metric(long owningBucketOrd) {     if (valuesSource == null || owningBucketOrd >= maxes.size()) {         return Double.NEGATIVE_INFINITY.     }     return maxes.get(owningBucketOrd). }
false;public;1;7;;@Override public InternalAggregation buildAggregation(long bucket) {     if (valuesSource == null || bucket >= maxes.size()) {         return buildEmptyAggregation().     }     return new InternalMax(name, maxes.get(bucket), formatter, pipelineAggregators(), metaData()). }
false;public;0;4;;@Override public InternalAggregation buildEmptyAggregation() {     return new InternalMax(name, Double.NEGATIVE_INFINITY, formatter, pipelineAggregators(), metaData()). }
false;public;0;4;;@Override public void doClose() {     Releasables.close(maxes). }
false;public;1;4;;@Override public void visit(int docID) {     throw new UnsupportedOperationException(). }
false;public;2;8;;@Override public void visit(int docID, byte[] packedValue) {     if (liveDocs.get(docID)) {         // we need to collect all values in this leaf (the sort is ascending) where         // the last live doc is guaranteed to contain the max value for the segment.         result[0] = converter.apply(packedValue).     } }
false;public;2;9;;@Override public PointValues.Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {     if (FutureArrays.equals(maxValue, 0, numBytes, maxPackedValue, 0, numBytes)) {         // we only check leaves that contain the max value for the segment.         return PointValues.Relation.CELL_CROSSES_QUERY.     } else {         return PointValues.Relation.CELL_OUTSIDE_QUERY.     } }
true;static;3;39;/**  * Returns the maximum value indexed in the <code>fieldName</code> field or <code>null</code>  * if the value cannot be inferred from the indexed {@link PointValues}.  */ ;/**  * Returns the maximum value indexed in the <code>fieldName</code> field or <code>null</code>  * if the value cannot be inferred from the indexed {@link PointValues}.  */ static Number findLeafMaxValue(LeafReader reader, String fieldName, Function<byte[], Number> converter) throws IOException {     final PointValues pointValues = reader.getPointValues(fieldName).     if (pointValues == null) {         return null.     }     final Bits liveDocs = reader.getLiveDocs().     if (liveDocs == null) {         return converter.apply(pointValues.getMaxPackedValue()).     }     int numBytes = pointValues.getBytesPerDimension().     final byte[] maxValue = pointValues.getMaxPackedValue().     final Number[] result = new Number[1].     pointValues.intersect(new PointValues.IntersectVisitor() {          @Override         public void visit(int docID) {             throw new UnsupportedOperationException().         }          @Override         public void visit(int docID, byte[] packedValue) {             if (liveDocs.get(docID)) {                 // we need to collect all values in this leaf (the sort is ascending) where                 // the last live doc is guaranteed to contain the max value for the segment.                 result[0] = converter.apply(packedValue).             }         }          @Override         public PointValues.Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {             if (FutureArrays.equals(maxValue, 0, numBytes, maxPackedValue, 0, numBytes)) {                 // we only check leaves that contain the max value for the segment.                 return PointValues.Relation.CELL_CROSSES_QUERY.             } else {                 return PointValues.Relation.CELL_OUTSIDE_QUERY.             }         }     }).     return result[0]. }
