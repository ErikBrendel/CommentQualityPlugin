commented;modifiers;parameterAmount;loc;comment;code
true;public,static;2;24;/**  * takes a {@link ConnectionProfile} resolves it to a fully specified (i.e., no nulls) profile  */ ;/**  * takes a {@link ConnectionProfile} resolves it to a fully specified (i.e., no nulls) profile  */ public static ConnectionProfile resolveConnectionProfile(@Nullable ConnectionProfile profile, ConnectionProfile fallbackProfile) {     Objects.requireNonNull(fallbackProfile).     if (profile == null) {         return fallbackProfile.     } else if (profile.getConnectTimeout() != null && profile.getHandshakeTimeout() != null && profile.getPingInterval() != null && profile.getCompressionEnabled() != null) {         return profile.     } else {         ConnectionProfile.Builder builder = new ConnectionProfile.Builder(profile).         if (profile.getConnectTimeout() == null) {             builder.setConnectTimeout(fallbackProfile.getConnectTimeout()).         }         if (profile.getHandshakeTimeout() == null) {             builder.setHandshakeTimeout(fallbackProfile.getHandshakeTimeout()).         }         if (profile.getPingInterval() == null) {             builder.setPingInterval(fallbackProfile.getPingInterval()).         }         if (profile.getCompressionEnabled() == null) {             builder.setCompressionEnabled(fallbackProfile.getCompressionEnabled()).         }         return builder.build().     } }
true;public,static;1;20;/**  * Builds a default connection profile based on the provided settings.  *  * @param settings to build the connection profile from  * @return the connection profile  */ ;/**  * Builds a default connection profile based on the provided settings.  *  * @param settings to build the connection profile from  * @return the connection profile  */ public static ConnectionProfile buildDefaultConnectionProfile(Settings settings) {     int connectionsPerNodeRecovery = TransportSettings.CONNECTIONS_PER_NODE_RECOVERY.get(settings).     int connectionsPerNodeBulk = TransportSettings.CONNECTIONS_PER_NODE_BULK.get(settings).     int connectionsPerNodeReg = TransportSettings.CONNECTIONS_PER_NODE_REG.get(settings).     int connectionsPerNodeState = TransportSettings.CONNECTIONS_PER_NODE_STATE.get(settings).     int connectionsPerNodePing = TransportSettings.CONNECTIONS_PER_NODE_PING.get(settings).     Builder builder = new Builder().     builder.setConnectTimeout(TransportSettings.CONNECT_TIMEOUT.get(settings)).     builder.setHandshakeTimeout(TransportSettings.CONNECT_TIMEOUT.get(settings)).     builder.setPingInterval(TransportSettings.PING_SCHEDULE.get(settings)).     builder.setCompressionEnabled(TransportSettings.TRANSPORT_COMPRESS.get(settings)).     builder.addConnections(connectionsPerNodeBulk, TransportRequestOptions.Type.BULK).     builder.addConnections(connectionsPerNodePing, TransportRequestOptions.Type.PING).     // if we are not master eligible we don't need a dedicated channel to publish the state     builder.addConnections(DiscoveryNode.isMasterNode(settings) ? connectionsPerNodeState : 0, TransportRequestOptions.Type.STATE).     // if we are not a data-node we don't need any dedicated channels for recovery     builder.addConnections(DiscoveryNode.isDataNode(settings) ? connectionsPerNodeRecovery : 0, TransportRequestOptions.Type.RECOVERY).     builder.addConnections(connectionsPerNodeReg, TransportRequestOptions.Type.REG).     return builder.build(). }
true;public,static;1;3;/**  * Builds a connection profile that is dedicated to a single channel type. Use this  * when opening single use connections  */ ;/**  * Builds a connection profile that is dedicated to a single channel type. Use this  * when opening single use connections  */ public static ConnectionProfile buildSingleChannelProfile(TransportRequestOptions.Type channelType) {     return buildSingleChannelProfile(channelType, null, null, null, null). }
true;public,static;5;22;/**  * Builds a connection profile that is dedicated to a single channel type. Allows passing connection and  * handshake timeouts and compression settings.  */ ;/**  * Builds a connection profile that is dedicated to a single channel type. Allows passing connection and  * handshake timeouts and compression settings.  */ public static ConnectionProfile buildSingleChannelProfile(TransportRequestOptions.Type channelType, @Nullable TimeValue connectTimeout, @Nullable TimeValue handshakeTimeout, @Nullable TimeValue pingInterval, @Nullable Boolean compressionEnabled) {     Builder builder = new Builder().     builder.addConnections(1, channelType).     final EnumSet<TransportRequestOptions.Type> otherTypes = EnumSet.allOf(TransportRequestOptions.Type.class).     otherTypes.remove(channelType).     builder.addConnections(0, otherTypes.toArray(new TransportRequestOptions.Type[0])).     if (connectTimeout != null) {         builder.setConnectTimeout(connectTimeout).     }     if (handshakeTimeout != null) {         builder.setHandshakeTimeout(handshakeTimeout).     }     if (pingInterval != null) {         builder.setPingInterval(pingInterval).     }     if (compressionEnabled != null) {         builder.setCompressionEnabled(compressionEnabled).     }     return builder.build(). }
true;public;1;7;/**  * Sets a connect timeout for this connection profile  */ ;/**  * Sets a connect timeout for this connection profile  */ public Builder setConnectTimeout(TimeValue connectTimeout) {     if (connectTimeout.millis() < 0) {         throw new IllegalArgumentException("connectTimeout must be non-negative but was: " + connectTimeout).     }     this.connectTimeout = connectTimeout.     return this. }
true;public;1;7;/**  * Sets a handshake timeout for this connection profile  */ ;/**  * Sets a handshake timeout for this connection profile  */ public Builder setHandshakeTimeout(TimeValue handshakeTimeout) {     if (handshakeTimeout.millis() < 0) {         throw new IllegalArgumentException("handshakeTimeout must be non-negative but was: " + handshakeTimeout).     }     this.handshakeTimeout = handshakeTimeout.     return this. }
true;public;1;4;/**  * Sets a ping interval for this connection profile  */ ;/**  * Sets a ping interval for this connection profile  */ public Builder setPingInterval(TimeValue pingInterval) {     this.pingInterval = pingInterval.     return this. }
true;public;1;4;/**  * Sets compression enabled for this connection profile  */ ;/**  * Sets compression enabled for this connection profile  */ public Builder setCompressionEnabled(boolean compressionEnabled) {     this.compressionEnabled = compressionEnabled.     return this. }
true;public;2;14;/**  * Adds a number of connections for one or more types. Each type can only be added once.  * @param numConnections the number of connections to use in the pool for the given connection types  * @param types a set of types that should share the given number of connections  */ ;/**  * Adds a number of connections for one or more types. Each type can only be added once.  * @param numConnections the number of connections to use in the pool for the given connection types  * @param types a set of types that should share the given number of connections  */ public Builder addConnections(int numConnections, TransportRequestOptions.Type... types) {     if (types == null || types.length == 0) {         throw new IllegalArgumentException("types must not be null").     }     for (TransportRequestOptions.Type type : types) {         if (addedTypes.contains(type)) {             throw new IllegalArgumentException("type [" + type + "] is already registered").         }     }     addedTypes.addAll(Arrays.asList(types)).     handles.add(new ConnectionTypeHandle(this.numConnections, numConnections, EnumSet.copyOf(Arrays.asList(types)))).     this.numConnections += numConnections.     return this. }
true;public;0;9;/**  * Creates a new {@link ConnectionProfile} based on the added connections.  * @throws IllegalStateException if any of the {@link org.elasticsearch.transport.TransportRequestOptions.Type} enum is missing  */ ;/**  * Creates a new {@link ConnectionProfile} based on the added connections.  * @throws IllegalStateException if any of the {@link org.elasticsearch.transport.TransportRequestOptions.Type} enum is missing  */ public ConnectionProfile build() {     EnumSet<TransportRequestOptions.Type> types = EnumSet.allOf(TransportRequestOptions.Type.class).     types.removeAll(addedTypes).     if (types.isEmpty() == false) {         throw new IllegalStateException("not all types are added for this connection profile - missing types: " + types).     }     return new ConnectionProfile(Collections.unmodifiableList(handles), numConnections, connectTimeout, handshakeTimeout, pingInterval, compressionEnabled). }
true;public;0;3;/**  * Returns the connect timeout or <code>null</code> if no explicit timeout is set on this profile.  */ ;/**  * Returns the connect timeout or <code>null</code> if no explicit timeout is set on this profile.  */ public TimeValue getConnectTimeout() {     return connectTimeout. }
true;public;0;3;/**  * Returns the handshake timeout or <code>null</code> if no explicit timeout is set on this profile.  */ ;/**  * Returns the handshake timeout or <code>null</code> if no explicit timeout is set on this profile.  */ public TimeValue getHandshakeTimeout() {     return handshakeTimeout. }
true;public;0;3;/**  * Returns the ping interval or <code>null</code> if no explicit ping interval is set on this profile.  */ ;/**  * Returns the ping interval or <code>null</code> if no explicit ping interval is set on this profile.  */ public TimeValue getPingInterval() {     return pingInterval. }
true;public;0;3;/**  * Returns boolean indicating if compression is enabled or <code>null</code> if no explicit compression  * is set on this profile.  */ ;/**  * Returns boolean indicating if compression is enabled or <code>null</code> if no explicit compression  * is set on this profile.  */ public Boolean getCompressionEnabled() {     return compressionEnabled. }
true;public;0;3;/**  * Returns the total number of connections for this profile  */ ;/**  * Returns the total number of connections for this profile  */ public int getNumConnections() {     return numConnections. }
true;public;1;8;/**  * Returns the number of connections per type for this profile. This might return a count that is shared with other types such  * that the sum of all connections per type might be higher than {@link #getNumConnections()}. For instance if  * {@link org.elasticsearch.transport.TransportRequestOptions.Type#BULK} shares connections with  * {@link org.elasticsearch.transport.TransportRequestOptions.Type#REG} they will return both the same number of connections from  * this method but the connections are not distinct.  */ ;/**  * Returns the number of connections per type for this profile. This might return a count that is shared with other types such  * that the sum of all connections per type might be higher than {@link #getNumConnections()}. For instance if  * {@link org.elasticsearch.transport.TransportRequestOptions.Type#BULK} shares connections with  * {@link org.elasticsearch.transport.TransportRequestOptions.Type#REG} they will return both the same number of connections from  * this method but the connections are not distinct.  */ public int getNumConnectionsPerType(TransportRequestOptions.Type type) {     for (ConnectionTypeHandle handle : handles) {         if (handle.getTypes().contains(type)) {             return handle.length.         }     }     throw new AssertionError("no handle found for type: " + type). }
true;;0;3;/**  * Returns the type handles for this connection profile  */ ;/**  * Returns the type handles for this connection profile  */ List<ConnectionTypeHandle> getHandles() {     return Collections.unmodifiableList(handles). }
true;;1;7;/**  * Returns one of the channels out configured for this handle. The channel is selected in a round-robin  * fashion.  */ ;/**  * Returns one of the channels out configured for this handle. The channel is selected in a round-robin  * fashion.  */ <T> T getChannel(List<T> channels) {     if (length == 0) {         throw new IllegalStateException("can't select channel size is 0 for types: " + types).     }     assert channels.size() >= offset + length : "illegal size: " + channels.size() + " expected >= " + (offset + length).     return channels.get(offset + Math.floorMod(counter.incrementAndGet(), length)). }
true;;0;3;/**  * Returns all types for this handle  */ ;/**  * Returns all types for this handle  */ Set<TransportRequestOptions.Type> getTypes() {     return types. }
