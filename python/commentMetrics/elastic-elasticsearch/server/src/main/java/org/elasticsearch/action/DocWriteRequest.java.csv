commented;modifiers;parameterAmount;loc;comment;code
true;;1;1;/**  * Set the index for this request  * @return the Request  */ ;/**  * Set the index for this request  * @return the Request  */ T index(String index).
true;;0;1;/**  * Get the index that this request operates on  * @return the index  */ ;/**  * Get the index that this request operates on  * @return the index  */ String index().
true;;1;1;/**  * Set the type for this request  * @return the Request  */ ;/**  * Set the type for this request  * @return the Request  */ T type(String type).
true;;0;1;/**  * Get the type that this request operates on  * @return the type  */ ;/**  * Get the type that this request operates on  * @return the type  */ String type().
true;;1;1;/**  * Set the default type supplied to a bulk  * request if this individual request's type is null  * or empty  * @return the Request  */ ;/**  * Set the default type supplied to a bulk  * request if this individual request's type is null  * or empty  * @return the Request  */ T defaultTypeIfNull(String defaultType).
true;;0;1;/**  * Get the id of the document for this request  * @return the id  */ ;/**  * Get the id of the document for this request  * @return the id  */ String id().
true;;0;2;/**  * Get the options for this request  * @return the indices options  */ ;/**  * Get the options for this request  * @return the indices options  */ @Override IndicesOptions indicesOptions().
true;;1;1;/**  * Set the routing for this request  * @return the Request  */ ;/**  * Set the routing for this request  * @return the Request  */ T routing(String routing).
true;;0;1;/**  * Get the routing for this request  * @return the Routing  */ ;/**  * Get the routing for this request  * @return the Routing  */ String routing().
true;;0;1;/**  * Get the document version for this request  * @return the document version  */ ;/**  * Get the document version for this request  * @return the document version  */ long version().
true;;1;1;/**  * Sets the version, which will perform the operation only if a matching  * version exists and no changes happened on the doc since then.  */ ;/**  * Sets the version, which will perform the operation only if a matching  * version exists and no changes happened on the doc since then.  */ T version(long version).
true;;0;1;/**  * Get the document version type for this request  * @return the document version type  */ ;/**  * Get the document version type for this request  * @return the document version type  */ VersionType versionType().
true;;1;1;/**  * Sets the versioning type. Defaults to {@link VersionType#INTERNAL}.  */ ;/**  * Sets the versioning type. Defaults to {@link VersionType#INTERNAL}.  */ T versionType(VersionType versionType).
true;;1;1;/**  * only perform this request if the document was last modification was assigned the given  * sequence number. Must be used in combination with {@link #setIfPrimaryTerm(long)}  *  * If the document last modification was assigned a different sequence number a  * {@link org.elasticsearch.index.engine.VersionConflictEngineException} will be thrown.  */ ;/**  * only perform this request if the document was last modification was assigned the given  * sequence number. Must be used in combination with {@link #setIfPrimaryTerm(long)}  *  * If the document last modification was assigned a different sequence number a  * {@link org.elasticsearch.index.engine.VersionConflictEngineException} will be thrown.  */ T setIfSeqNo(long seqNo).
true;;1;1;/**  * only performs this request if the document was last modification was assigned the given  * primary term. Must be used in combination with {@link #setIfSeqNo(long)}  *  * If the document last modification was assigned a different term a  * {@link org.elasticsearch.index.engine.VersionConflictEngineException} will be thrown.  */ ;/**  * only performs this request if the document was last modification was assigned the given  * primary term. Must be used in combination with {@link #setIfSeqNo(long)}  *  * If the document last modification was assigned a different term a  * {@link org.elasticsearch.index.engine.VersionConflictEngineException} will be thrown.  */ T setIfPrimaryTerm(long term).
true;;0;1;/**  * If set, only perform this request if the document was last modification was assigned this sequence number.  * If the document last modification was assigned a different sequence number a  * {@link org.elasticsearch.index.engine.VersionConflictEngineException} will be thrown.  */ ;/**  * If set, only perform this request if the document was last modification was assigned this sequence number.  * If the document last modification was assigned a different sequence number a  * {@link org.elasticsearch.index.engine.VersionConflictEngineException} will be thrown.  */ long ifSeqNo().
true;;0;1;/**  * If set, only perform this request if the document was last modification was assigned this primary term.  *  * If the document last modification was assigned a different term a  * {@link org.elasticsearch.index.engine.VersionConflictEngineException} will be thrown.  */ ;/**  * If set, only perform this request if the document was last modification was assigned this primary term.  *  * If the document last modification was assigned a different term a  * {@link org.elasticsearch.index.engine.VersionConflictEngineException} will be thrown.  */ long ifPrimaryTerm().
true;;0;1;/**  * Get the requested document operation type of the request  * @return the operation type {@link OpType}  */ ;/**  * Get the requested document operation type of the request  * @return the operation type {@link OpType}  */ OpType opType().
false;public;0;3;;public byte getId() {     return op. }
false;public;0;3;;public String getLowercase() {     return lowercase. }
false;public,static;1;9;;public static OpType fromId(byte id) {     switch(id) {         case 0:             return INDEX.         case 1:             return CREATE.         case 2:             return UPDATE.         case 3:             return DELETE.         default:             throw new IllegalArgumentException("Unknown opType: [" + id + "]").     } }
false;public,static;1;9;;public static OpType fromString(String sOpType) {     String lowerCase = sOpType.toLowerCase(Locale.ROOT).     for (OpType opType : OpType.values()) {         if (opType.getLowercase().equals(lowerCase)) {             return opType.         }     }     throw new IllegalArgumentException("Unknown opType: [" + sOpType + "]"). }
true;static;1;20;/**  * read a document write (index/delete/update) request  */ ;/**  * read a document write (index/delete/update) request  */ static DocWriteRequest<?> readDocumentRequest(StreamInput in) throws IOException {     byte type = in.readByte().     DocWriteRequest<?> docWriteRequest.     if (type == 0) {         IndexRequest indexRequest = new IndexRequest().         indexRequest.readFrom(in).         docWriteRequest = indexRequest.     } else if (type == 1) {         DeleteRequest deleteRequest = new DeleteRequest().         deleteRequest.readFrom(in).         docWriteRequest = deleteRequest.     } else if (type == 2) {         UpdateRequest updateRequest = new UpdateRequest().         updateRequest.readFrom(in).         docWriteRequest = updateRequest.     } else {         throw new IllegalStateException("invalid request type [" + type + " ]").     }     return docWriteRequest. }
true;static;2;14;/**  * write a document write (index/delete/update) request  */ ;/**  * write a document write (index/delete/update) request  */ static void writeDocumentRequest(StreamOutput out, DocWriteRequest<?> request) throws IOException {     if (request instanceof IndexRequest) {         out.writeByte((byte) 0).         ((IndexRequest) request).writeTo(out).     } else if (request instanceof DeleteRequest) {         out.writeByte((byte) 1).         ((DeleteRequest) request).writeTo(out).     } else if (request instanceof UpdateRequest) {         out.writeByte((byte) 2).         ((UpdateRequest) request).writeTo(out).     } else {         throw new IllegalStateException("invalid request [" + request.getClass().getSimpleName() + " ]").     } }
false;static;2;32;;static ActionRequestValidationException validateSeqNoBasedCASParams(DocWriteRequest request, ActionRequestValidationException validationException) {     final long version = request.version().     final VersionType versionType = request.versionType().     if (versionType.validateVersionForWrites(version) == false) {         validationException = addValidationError("illegal version value [" + version + "] for version type [" + versionType.name() + "]", validationException).     }     if (versionType == VersionType.FORCE) {         validationException = addValidationError("version type [force] may no longer be used", validationException).     }     if (versionType == VersionType.INTERNAL && version != Versions.MATCH_ANY && version != Versions.MATCH_DELETED) {         validationException = addValidationError("internal versioning can not be used for optimistic concurrency control. " + "Please use `if_seq_no` and `if_primary_term` instead", validationException).     }     if (request.ifSeqNo() != UNASSIGNED_SEQ_NO && (versionType != VersionType.INTERNAL || version != Versions.MATCH_ANY)) {         validationException = addValidationError("compare and write operations can not use versioning", validationException).     }     if (request.ifPrimaryTerm() == UNASSIGNED_PRIMARY_TERM && request.ifSeqNo() != UNASSIGNED_SEQ_NO) {         validationException = addValidationError("ifSeqNo is set, but primary term is [0]", validationException).     }     if (request.ifPrimaryTerm() != UNASSIGNED_PRIMARY_TERM && request.ifSeqNo() == UNASSIGNED_SEQ_NO) {         validationException = addValidationError("ifSeqNo is unassigned, but primary term is [" + request.ifPrimaryTerm() + "]", validationException).     }     return validationException. }
