commented;modifiers;parameterAmount;loc;comment;code
false;public;1;3;;public void setSlowTaskLoggingThreshold(TimeValue slowTaskLoggingThreshold) {     this.slowTaskLoggingThreshold = slowTaskLoggingThreshold. }
false;public,synchronized;1;3;;public synchronized void setClusterStatePublisher(ClusterStatePublisher publisher) {     clusterStatePublisher = publisher. }
false;public,synchronized;1;3;;public synchronized void setClusterStateSupplier(java.util.function.Supplier<ClusterState> clusterStateSupplier) {     this.clusterStateSupplier = clusterStateSupplier. }
false;protected,synchronized;0;7;;@Override protected synchronized void doStart() {     Objects.requireNonNull(clusterStatePublisher, "please set a cluster state publisher before starting").     Objects.requireNonNull(clusterStateSupplier, "please set a cluster state supplier before starting").     threadPoolExecutor = createThreadPoolExecutor().     taskBatcher = new Batcher(logger, threadPoolExecutor). }
false;protected;0;7;;protected PrioritizedEsThreadPoolExecutor createThreadPoolExecutor() {     return EsExecutors.newSinglePrioritizing(nodeName + "/" + MASTER_UPDATE_THREAD_NAME, daemonThreadFactory(nodeName, MASTER_UPDATE_THREAD_NAME), threadPool.getThreadContext(), threadPool.scheduler()). }
false;protected;2;7;;@Override protected void onTimeout(List<? extends BatchedTask> tasks, TimeValue timeout) {     threadPool.generic().execute(() -> tasks.forEach(task -> ((UpdateTask) task).listener.onFailure(task.source, new ProcessClusterEventTimeoutException(timeout, task.source)))). }
false;protected;3;6;;@Override protected void run(Object batchingKey, List<? extends BatchedTask> tasks, String tasksSummary) {     ClusterStateTaskExecutor<Object> taskExecutor = (ClusterStateTaskExecutor<Object>) batchingKey.     List<UpdateTask> updateTasks = (List<UpdateTask>) tasks.     runTasks(new TaskInputs(taskExecutor, updateTasks, tasksSummary)). }
false;public;1;5;;@Override public String describeTasks(List<? extends BatchedTask> tasks) {     return ((ClusterStateTaskExecutor<Object>) batchingKey).describeTasks(tasks.stream().map(BatchedTask::getTask).collect(Collectors.toList())). }
false;protected,synchronized;0;4;;@Override protected synchronized void doStop() {     ThreadPool.terminate(threadPoolExecutor, 10, TimeUnit.SECONDS). }
false;protected,synchronized;0;3;;@Override protected synchronized void doClose() { }
true;;0;3;/**  * The current cluster state exposed by the discovery layer. Package-visible for tests.  */ ;/**  * The current cluster state exposed by the discovery layer. Package-visible for tests.  */ ClusterState state() {     return clusterStateSupplier.get(). }
false;private,static;0;3;;private static boolean isMasterUpdateThread() {     return Thread.currentThread().getName().contains(MASTER_UPDATE_THREAD_NAME). }
false;public,static;0;4;;public static boolean assertMasterUpdateThread() {     assert isMasterUpdateThread() : "not called from the master service thread".     return true. }
false;public,static;1;5;;public static boolean assertNotMasterUpdateThread(String reason) {     assert isMasterUpdateThread() == false : "Expected current thread [" + Thread.currentThread() + "] to not be the master service thread. Reason: [" + reason + "]".     return true. }
false;protected;1;51;;protected void runTasks(TaskInputs taskInputs) {     final String summary = taskInputs.summary.     if (!lifecycle.started()) {         logger.debug("processing [{}]: ignoring, master service not started", summary).         return.     }     logger.debug("processing [{}]: execute", summary).     final ClusterState previousClusterState = state().     if (!previousClusterState.nodes().isLocalNodeElectedMaster() && taskInputs.runOnlyWhenMaster()) {         logger.debug("failing [{}]: local node is no longer master", summary).         taskInputs.onNoLongerMaster().         return.     }     long startTimeNS = currentTimeInNanos().     TaskOutputs taskOutputs = calculateTaskOutputs(taskInputs, previousClusterState, startTimeNS).     taskOutputs.notifyFailedTasks().     if (taskOutputs.clusterStateUnchanged()) {         taskOutputs.notifySuccessfulTasksOnUnchangedClusterState().         TimeValue executionTime = TimeValue.timeValueMillis(Math.max(0, TimeValue.nsecToMSec(currentTimeInNanos() - startTimeNS))).         logger.debug("processing [{}]: took [{}] no change in cluster state", summary, executionTime).         warnAboutSlowTaskIfNeeded(executionTime, summary).     } else {         ClusterState newClusterState = taskOutputs.newClusterState.         if (logger.isTraceEnabled()) {             logger.trace("cluster state updated, source [{}]\n{}", summary, newClusterState).         } else if (logger.isDebugEnabled()) {             logger.debug("cluster state updated, version [{}], source [{}]", newClusterState.version(), summary).         }         try {             ClusterChangedEvent clusterChangedEvent = new ClusterChangedEvent(summary, newClusterState, previousClusterState).             // new cluster state, notify all listeners             final DiscoveryNodes.Delta nodesDelta = clusterChangedEvent.nodesDelta().             if (nodesDelta.hasChanges() && logger.isInfoEnabled()) {                 String nodeSummary = nodesDelta.shortSummary().                 if (nodeSummary.length() > 0) {                     logger.info("{}, term: {}, version: {}, reason: {}", summary, newClusterState.term(), newClusterState.version(), nodeSummary).                 }             }             logger.debug("publishing cluster state version [{}]", newClusterState.version()).             publish(clusterChangedEvent, taskOutputs, startTimeNS).         } catch (Exception e) {             handleException(summary, startTimeNS, newClusterState, e).         }     } }
false;protected;0;4;;@Override protected boolean blockingAllowed() {     return isMasterUpdateThread() || super.blockingAllowed(). }
false;protected;3;17;;protected void publish(ClusterChangedEvent clusterChangedEvent, TaskOutputs taskOutputs, long startTimeNS) {     final PlainActionFuture<Void> fut = new PlainActionFuture<Void>() {          @Override         protected boolean blockingAllowed() {             return isMasterUpdateThread() || super.blockingAllowed().         }     }.     clusterStatePublisher.publish(clusterChangedEvent, fut, taskOutputs.createAckListener(threadPool, clusterChangedEvent.state())).     // indefinitely wait for publication to complete     try {         FutureUtils.get(fut).         onPublicationSuccess(clusterChangedEvent, taskOutputs, startTimeNS).     } catch (Exception e) {         onPublicationFailed(clusterChangedEvent, taskOutputs, startTimeNS, e).     } }
false;protected;3;17;;protected void onPublicationSuccess(ClusterChangedEvent clusterChangedEvent, TaskOutputs taskOutputs, long startTimeNS) {     taskOutputs.processedDifferentClusterState(clusterChangedEvent.previousState(), clusterChangedEvent.state()).     try {         taskOutputs.clusterStatePublished(clusterChangedEvent).     } catch (Exception e) {         logger.error(() -> new ParameterizedMessage("exception thrown while notifying executor of new cluster state publication [{}]", clusterChangedEvent.source()), e).     }     TimeValue executionTime = TimeValue.timeValueMillis(Math.max(0, TimeValue.nsecToMSec(currentTimeInNanos() - startTimeNS))).     logger.debug("processing [{}]: took [{}] done publishing updated cluster state (version: {}, uuid: {})", clusterChangedEvent.source(), executionTime, clusterChangedEvent.state().version(), clusterChangedEvent.state().stateUUID()).     warnAboutSlowTaskIfNeeded(executionTime, clusterChangedEvent.source()). }
false;protected;4;11;;protected void onPublicationFailed(ClusterChangedEvent clusterChangedEvent, TaskOutputs taskOutputs, long startTimeNS, Exception exception) {     if (exception instanceof FailedToCommitClusterStateException) {         final long version = clusterChangedEvent.state().version().         logger.warn(() -> new ParameterizedMessage("failing [{}]: failed to commit cluster state version [{}]", clusterChangedEvent.source(), version), exception).         taskOutputs.publishingFailed((FailedToCommitClusterStateException) exception).     } else {         handleException(clusterChangedEvent.source(), startTimeNS, clusterChangedEvent.state(), exception).     } }
false;private;4;15;;private void handleException(String summary, long startTimeNS, ClusterState newClusterState, Exception e) {     TimeValue executionTime = TimeValue.timeValueMillis(Math.max(0, TimeValue.nsecToMSec(currentTimeInNanos() - startTimeNS))).     final long version = newClusterState.version().     final String stateUUID = newClusterState.stateUUID().     final String fullState = newClusterState.toString().     logger.warn(() -> new ParameterizedMessage("failed to publish updated cluster state in [{}]:\nversion [{}], uuid [{}], source [{}]\n{}", executionTime, version, stateUUID, summary, fullState), e). // TODO: do we want to call updateTask.onFailure here? }
false;public;3;6;;public TaskOutputs calculateTaskOutputs(TaskInputs taskInputs, ClusterState previousClusterState, long startTimeNS) {     ClusterTasksResult<Object> clusterTasksResult = executeTasks(taskInputs, startTimeNS, previousClusterState).     ClusterState newClusterState = patchVersions(previousClusterState, clusterTasksResult).     return new TaskOutputs(taskInputs, previousClusterState, newClusterState, getNonFailedTasks(taskInputs, clusterTasksResult), clusterTasksResult.executionResults). }
false;private;2;19;;private ClusterState patchVersions(ClusterState previousClusterState, ClusterTasksResult<?> executionResult) {     ClusterState newClusterState = executionResult.resultingState.     if (previousClusterState != newClusterState) {         // only the master controls the version numbers         Builder builder = incrementVersion(newClusterState).         if (previousClusterState.routingTable() != newClusterState.routingTable()) {             builder.routingTable(RoutingTable.builder(newClusterState.routingTable()).version(newClusterState.routingTable().version() + 1).build()).         }         if (previousClusterState.metaData() != newClusterState.metaData()) {             builder.metaData(MetaData.builder(newClusterState.metaData()).version(newClusterState.metaData().version() + 1)).         }         newClusterState = builder.build().     }     return newClusterState. }
false;public;1;3;;public Builder incrementVersion(ClusterState clusterState) {     return ClusterState.builder(clusterState).incrementVersion(). }
true;public;2;5;/**  * Submits a cluster state update task. unlike {@link #submitStateUpdateTask(String, Object, ClusterStateTaskConfig,  * ClusterStateTaskExecutor, ClusterStateTaskListener)}, submitted updates will not be batched.  *  * @param source     the source of the cluster state update task  * @param updateTask the full context for the cluster state update  *                   task  */ ;/**  * Submits a cluster state update task. unlike {@link #submitStateUpdateTask(String, Object, ClusterStateTaskConfig,  * ClusterStateTaskExecutor, ClusterStateTaskListener)}, submitted updates will not be batched.  *  * @param source     the source of the cluster state update task  * @param updateTask the full context for the cluster state update  *                   task  */ public <T extends ClusterStateTaskConfig & ClusterStateTaskExecutor<T> & ClusterStateTaskListener> void submitStateUpdateTask(String source, T updateTask) {     submitStateUpdateTask(source, updateTask, updateTask, updateTask, updateTask). }
true;public;5;6;/**  * Submits a cluster state update task. submitted updates will be  * batched across the same instance of executor. The exact batching  * semantics depend on the underlying implementation but a rough  * guideline is that if the update task is submitted while there  * are pending update tasks for the same executor, these update  * tasks will all be executed on the executor in a single batch  *  * @param source   the source of the cluster state update task  * @param task     the state needed for the cluster state update task  * @param config   the cluster state update task configuration  * @param executor the cluster state update task executor. tasks  *                 that share the same executor will be executed  *                 batches on this executor  * @param listener callback after the cluster state update task  *                 completes  * @param <T>      the type of the cluster state update task state  */ ;/**  * Submits a cluster state update task. submitted updates will be  * batched across the same instance of executor. The exact batching  * semantics depend on the underlying implementation but a rough  * guideline is that if the update task is submitted while there  * are pending update tasks for the same executor, these update  * tasks will all be executed on the executor in a single batch  *  * @param source   the source of the cluster state update task  * @param task     the state needed for the cluster state update task  * @param config   the cluster state update task configuration  * @param executor the cluster state update task executor. tasks  *                 that share the same executor will be executed  *                 batches on this executor  * @param listener callback after the cluster state update task  *                 completes  * @param <T>      the type of the cluster state update task state  */ public <T> void submitStateUpdateTask(String source, T task, ClusterStateTaskConfig config, ClusterStateTaskExecutor<T> executor, ClusterStateTaskListener listener) {     submitStateUpdateTasks(source, Collections.singletonMap(task, listener), config, executor). }
false;public;1;3;;public void publishingFailed(FailedToCommitClusterStateException t) {     nonFailedTasks.forEach(task -> task.listener.onFailure(task.source(), t)). }
false;public;2;3;;public void processedDifferentClusterState(ClusterState previousClusterState, ClusterState newClusterState) {     nonFailedTasks.forEach(task -> task.listener.clusterStateProcessed(task.source(), previousClusterState, newClusterState)). }
false;public;1;3;;public void clusterStatePublished(ClusterChangedEvent clusterChangedEvent) {     taskInputs.executor.clusterStatePublished(clusterChangedEvent). }
false;public;2;7;;public Discovery.AckListener createAckListener(ThreadPool threadPool, ClusterState newClusterState) {     return new DelegatingAckListener(nonFailedTasks.stream().filter(task -> task.listener instanceof AckedClusterStateTaskListener).map(task -> new AckCountDownListener((AckedClusterStateTaskListener) task.listener, newClusterState.version(), newClusterState.nodes(), threadPool)).collect(Collectors.toList())). }
false;public;0;3;;public boolean clusterStateUnchanged() {     return previousClusterState == newClusterState. }
false;public;0;10;;public void notifyFailedTasks() {     // fail all tasks that have failed     for (Batcher.UpdateTask updateTask : taskInputs.updateTasks) {         assert executionResults.containsKey(updateTask.task) : "missing " + updateTask.         final ClusterStateTaskExecutor.TaskResult taskResult = executionResults.get(updateTask.task).         if (taskResult.isSuccess() == false) {             updateTask.listener.onFailure(updateTask.source(), taskResult.getFailure()).         }     } }
false;public;0;9;;public void notifySuccessfulTasksOnUnchangedClusterState() {     nonFailedTasks.forEach(task -> {         if (task.listener instanceof AckedClusterStateTaskListener) {             // no need to wait for ack if nothing changed, the update can be counted as acknowledged             ((AckedClusterStateTaskListener) task.listener).onAllNodesAcked(null).         }         task.listener.clusterStateProcessed(task.source(), newClusterState, newClusterState).     }). }
true;public;0;9;/**  * Returns the tasks that are pending.  */ ;/**  * Returns the tasks that are pending.  */ public List<PendingClusterTask> pendingTasks() {     return Arrays.stream(threadPoolExecutor.getPending()).map(pending -> {         assert pending.task instanceof SourcePrioritizedRunnable : "thread pool executor should only use SourcePrioritizedRunnable instances but found: " + pending.task.getClass().getName().         SourcePrioritizedRunnable task = (SourcePrioritizedRunnable) pending.task.         return new PendingClusterTask(pending.insertionOrder, pending.priority, new Text(task.source()), task.getAgeInMillis(), pending.executing).     }).collect(Collectors.toList()). }
true;public;0;3;/**  * Returns the number of currently pending tasks.  */ ;/**  * Returns the number of currently pending tasks.  */ public int numberOfPendingTasks() {     return threadPoolExecutor.getNumberOfPendingTasks(). }
true;public;0;3;/**  * Returns the maximum wait time for tasks in the queue  *  * @return A zero time value if the queue is empty, otherwise the time value oldest task waiting in the queue  */ ;/**  * Returns the maximum wait time for tasks in the queue  *  * @return A zero time value if the queue is empty, otherwise the time value oldest task waiting in the queue  */ public TimeValue getMaxTaskWaitTime() {     return threadPoolExecutor.getMaxTaskWaitTime(). }
false;private;2;7;;private SafeClusterStateTaskListener safe(ClusterStateTaskListener listener, Supplier<ThreadContext.StoredContext> contextSupplier) {     if (listener instanceof AckedClusterStateTaskListener) {         return new SafeAckedClusterStateTaskListener((AckedClusterStateTaskListener) listener, contextSupplier, logger).     } else {         return new SafeClusterStateTaskListener(listener, contextSupplier, logger).     } }
false;public;2;10;;@Override public void onFailure(String source, Exception e) {     try (ThreadContext.StoredContext ignore = context.get()) {         listener.onFailure(source, e).     } catch (Exception inner) {         inner.addSuppressed(e).         logger.error(() -> new ParameterizedMessage("exception thrown by listener notifying of failure from [{}]", source), inner).     } }
false;public;1;9;;@Override public void onNoLongerMaster(String source) {     try (ThreadContext.StoredContext ignore = context.get()) {         listener.onNoLongerMaster(source).     } catch (Exception e) {         logger.error(() -> new ParameterizedMessage("exception thrown by listener while notifying no longer master from [{}]", source), e).     } }
false;public;3;10;;@Override public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {     try (ThreadContext.StoredContext ignore = context.get()) {         listener.clusterStateProcessed(source, oldState, newState).     } catch (Exception e) {         logger.error(() -> new ParameterizedMessage("exception thrown by listener while notifying of cluster state processed from [{}], old cluster state:\n" + "{}\nnew cluster state:\n{}", source, oldState, newState), e).     } }
false;public;1;4;;@Override public boolean mustAck(DiscoveryNode discoveryNode) {     return listener.mustAck(discoveryNode). }
false;public;1;9;;@Override public void onAllNodesAcked(@Nullable Exception e) {     try (ThreadContext.StoredContext ignore = context.get()) {         listener.onAllNodesAcked(e).     } catch (Exception inner) {         inner.addSuppressed(e).         logger.error("exception thrown by listener while notifying on all nodes acked", inner).     } }
false;public;0;8;;@Override public void onAckTimeout() {     try (ThreadContext.StoredContext ignore = context.get()) {         listener.onAckTimeout().     } catch (Exception e) {         logger.error("exception thrown by listener while notifying on ack timeout", e).     } }
false;public;0;4;;@Override public TimeValue ackTimeout() {     return listener.ackTimeout(). }
false;protected;2;6;;protected void warnAboutSlowTaskIfNeeded(TimeValue executionTime, String source) {     if (executionTime.getMillis() > slowTaskLoggingThreshold.getMillis()) {         logger.warn("cluster state update task [{}] took [{}] which is above the warn threshold of {}", source, executionTime, slowTaskLoggingThreshold).     } }
false;public;1;6;;@Override public void onCommit(TimeValue commitTime) {     for (Discovery.AckListener listener : listeners) {         listener.onCommit(commitTime).     } }
false;public;2;6;;@Override public void onNodeAck(DiscoveryNode node, @Nullable Exception e) {     for (Discovery.AckListener listener : listeners) {         listener.onNodeAck(node, e).     } }
false;public;1;19;;@Override public void onCommit(TimeValue commitTime) {     TimeValue ackTimeout = ackedTaskListener.ackTimeout().     if (ackTimeout == null) {         ackTimeout = TimeValue.ZERO.     }     final TimeValue timeLeft = TimeValue.timeValueNanos(Math.max(0, ackTimeout.nanos() - commitTime.nanos())).     if (timeLeft.nanos() == 0L) {         onTimeout().     } else if (countDown.countDown()) {         finish().     } else {         this.ackTimeoutCallback = threadPool.schedule(this::onTimeout, timeLeft, ThreadPool.Names.GENERIC).         // re-check if onNodeAck has not completed while we were scheduling the timeout         if (countDown.isCountedDown()) {             ackTimeoutCallback.cancel().         }     } }
false;public;2;17;;@Override public void onNodeAck(DiscoveryNode node, @Nullable Exception e) {     if (node.equals(masterNode) == false && ackedTaskListener.mustAck(node) == false) {         return.     }     if (e == null) {         logger.trace("ack received from node [{}], cluster_state update (version: {})", node, clusterStateVersion).     } else {         this.lastFailure = e.         logger.debug(() -> new ParameterizedMessage("ack received from node [{}], cluster_state update (version: {})", node, clusterStateVersion), e).     }     if (countDown.countDown()) {         finish().     } }
false;private;0;7;;private void finish() {     logger.trace("all expected nodes acknowledged cluster_state update (version: {})", clusterStateVersion).     if (ackTimeoutCallback != null) {         ackTimeoutCallback.cancel().     }     ackedTaskListener.onAllNodesAcked(lastFailure). }
false;public;0;6;;public void onTimeout() {     if (countDown.fastForward()) {         logger.trace("timeout waiting for acknowledgement for cluster_state update (version: {})", clusterStateVersion).         ackedTaskListener.onAckTimeout().     } }
false;protected;3;44;;protected ClusterTasksResult<Object> executeTasks(TaskInputs taskInputs, long startTimeNS, ClusterState previousClusterState) {     ClusterTasksResult<Object> clusterTasksResult.     try {         List<Object> inputs = taskInputs.updateTasks.stream().map(tUpdateTask -> tUpdateTask.task).collect(Collectors.toList()).         clusterTasksResult = taskInputs.executor.execute(previousClusterState, inputs).         if (previousClusterState != clusterTasksResult.resultingState && previousClusterState.nodes().isLocalNodeElectedMaster() && (clusterTasksResult.resultingState.nodes().isLocalNodeElectedMaster() == false)) {             throw new AssertionError("update task submitted to MasterService cannot remove master").         }     } catch (Exception e) {         TimeValue executionTime = TimeValue.timeValueMillis(Math.max(0, TimeValue.nsecToMSec(currentTimeInNanos() - startTimeNS))).         if (logger.isTraceEnabled()) {             logger.trace(() -> new ParameterizedMessage("failed to execute cluster state update in [{}], state:\nversion [{}], source [{}]\n{}{}{}", executionTime, previousClusterState.version(), taskInputs.summary, previousClusterState.nodes(), previousClusterState.routingTable(), previousClusterState.getRoutingNodes()), e).         }         warnAboutSlowTaskIfNeeded(executionTime, taskInputs.summary).         clusterTasksResult = ClusterTasksResult.builder().failures(taskInputs.updateTasks.stream().map(updateTask -> updateTask.task)::iterator, e).build(previousClusterState).     }     assert clusterTasksResult.executionResults != null.     assert clusterTasksResult.executionResults.size() == taskInputs.updateTasks.size() : String.format(Locale.ROOT, "expected [%d] task result%s but was [%d]", taskInputs.updateTasks.size(), taskInputs.updateTasks.size() == 1 ? "" : "s", clusterTasksResult.executionResults.size()).     if (Assertions.ENABLED) {         ClusterTasksResult<Object> finalClusterTasksResult = clusterTasksResult.         taskInputs.updateTasks.forEach(updateTask -> {             assert finalClusterTasksResult.executionResults.containsKey(updateTask.task) : "missing task result for " + updateTask.         }).     }     return clusterTasksResult. }
false;public;2;9;;public List<Batcher.UpdateTask> getNonFailedTasks(TaskInputs taskInputs, ClusterTasksResult<Object> clusterTasksResult) {     return taskInputs.updateTasks.stream().filter(updateTask -> {         assert clusterTasksResult.executionResults.containsKey(updateTask.task) : "missing " + updateTask.         final ClusterStateTaskExecutor.TaskResult taskResult = clusterTasksResult.executionResults.get(updateTask.task).         return taskResult.isSuccess().     }).collect(Collectors.toList()). }
false;public;0;3;;public boolean runOnlyWhenMaster() {     return executor.runOnlyOnMaster(). }
false;public;0;3;;public void onNoLongerMaster() {     updateTasks.forEach(task -> task.listener.onNoLongerMaster(task.source())). }
true;public;4;23;/**  * Submits a batch of cluster state update tasks. submitted updates are guaranteed to be processed together,  * potentially with more tasks of the same executor.  *  * @param source   the source of the cluster state update task  * @param tasks    a map of update tasks and their corresponding listeners  * @param config   the cluster state update task configuration  * @param executor the cluster state update task executor. tasks  *                 that share the same executor will be executed  *                 batches on this executor  * @param <T>      the type of the cluster state update task state  */ ;/**  * Submits a batch of cluster state update tasks. submitted updates are guaranteed to be processed together,  * potentially with more tasks of the same executor.  *  * @param source   the source of the cluster state update task  * @param tasks    a map of update tasks and their corresponding listeners  * @param config   the cluster state update task configuration  * @param executor the cluster state update task executor. tasks  *                 that share the same executor will be executed  *                 batches on this executor  * @param <T>      the type of the cluster state update task state  */ public <T> void submitStateUpdateTasks(final String source, final Map<T, ClusterStateTaskListener> tasks, final ClusterStateTaskConfig config, final ClusterStateTaskExecutor<T> executor) {     if (!lifecycle.started()) {         return.     }     final ThreadContext threadContext = threadPool.getThreadContext().     final Supplier<ThreadContext.StoredContext> supplier = threadContext.newRestorableContext(true).     try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {         threadContext.markAsSystemContext().         List<Batcher.UpdateTask> safeTasks = tasks.entrySet().stream().map(e -> taskBatcher.new UpdateTask(config.priority(), source, e.getKey(), safe(e.getValue(), supplier), executor)).collect(Collectors.toList()).         taskBatcher.submitTasks(safeTasks, config.timeout()).     } catch (EsRejectedExecutionException e) {         // to be done here...         if (!lifecycle.stoppedOrClosed()) {             throw e.         }     } }
true;protected;0;3;// this one is overridden in tests so we can control time ;// this one is overridden in tests so we can control time protected long currentTimeInNanos() {     return System.nanoTime(). }
