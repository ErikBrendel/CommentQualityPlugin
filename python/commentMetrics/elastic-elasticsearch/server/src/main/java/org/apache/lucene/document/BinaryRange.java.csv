commented;modifiers;parameterAmount;loc;comment;code
true;public,static;2;3;/**  * Create a query for matching indexed ip ranges that {@code INTERSECT} the defined range.  * @param field         field name. must not be null.  * @param encodedRange  Encoded range  * @return query for matching intersecting encoded ranges (overlap, within, crosses, or contains)  * @throws IllegalArgumentException if {@code field} is null, {@code min} or {@code max} is invalid  */ ;/**  * Create a query for matching indexed ip ranges that {@code INTERSECT} the defined range.  * @param field         field name. must not be null.  * @param encodedRange  Encoded range  * @return query for matching intersecting encoded ranges (overlap, within, crosses, or contains)  * @throws IllegalArgumentException if {@code field} is null, {@code min} or {@code max} is invalid  */ public static Query newIntersectsQuery(String field, byte[] encodedRange) {     return newRelationQuery(field, encodedRange, RangeFieldQuery.QueryType.INTERSECTS). }
false;protected;2;4;;@Override protected String toString(byte[] ranges, int dimension) {     return "[" + new BytesRef(ranges, 0, BYTES) + " TO " + new BytesRef(ranges, BYTES, BYTES) + "]". }
false;static;3;8;;static Query newRelationQuery(String field, byte[] encodedRange, RangeFieldQuery.QueryType relation) {     return new RangeFieldQuery(field, encodedRange, 1, relation) {          @Override         protected String toString(byte[] ranges, int dimension) {             return "[" + new BytesRef(ranges, 0, BYTES) + " TO " + new BytesRef(ranges, BYTES, BYTES) + "]".         }     }. }
