commented;modifiers;parameterAmount;loc;comment;code
false;private;1;4;;private void setSlowTaskLoggingThreshold(TimeValue slowTaskLoggingThreshold) {     masterService.setSlowTaskLoggingThreshold(slowTaskLoggingThreshold).     clusterApplierService.setSlowTaskLoggingThreshold(slowTaskLoggingThreshold). }
false;public,synchronized;1;3;;public synchronized void setNodeConnectionsService(NodeConnectionsService nodeConnectionsService) {     clusterApplierService.setNodeConnectionsService(nodeConnectionsService). }
false;protected,synchronized;0;5;;@Override protected synchronized void doStart() {     clusterApplierService.start().     masterService.start(). }
false;protected,synchronized;0;5;;@Override protected synchronized void doStop() {     masterService.stop().     clusterApplierService.stop(). }
false;protected,synchronized;0;5;;@Override protected synchronized void doClose() {     masterService.close().     clusterApplierService.close(). }
true;public;0;7;/**  * The local node.  */ ;/**  * The local node.  */ public DiscoveryNode localNode() {     DiscoveryNode localNode = state().getNodes().getLocalNode().     if (localNode == null) {         throw new IllegalStateException("No local node found. Is the node started?").     }     return localNode. }
false;public;0;3;;public OperationRouting operationRouting() {     return operationRouting. }
true;public;0;3;/**  * The currently applied cluster state.  * TODO: Should be renamed to appliedState / appliedClusterState  */ ;/**  * The currently applied cluster state.  * TODO: Should be renamed to appliedState / appliedClusterState  */ public ClusterState state() {     return clusterApplierService.state(). }
true;public;1;3;/**  * Adds a high priority applier of updated cluster states.  */ ;/**  * Adds a high priority applier of updated cluster states.  */ public void addHighPriorityApplier(ClusterStateApplier applier) {     clusterApplierService.addHighPriorityApplier(applier). }
true;public;1;3;/**  * Adds an applier which will be called after all high priority and normal appliers have been called.  */ ;/**  * Adds an applier which will be called after all high priority and normal appliers have been called.  */ public void addLowPriorityApplier(ClusterStateApplier applier) {     clusterApplierService.addLowPriorityApplier(applier). }
true;public;1;3;/**  * Adds a applier of updated cluster states.  */ ;/**  * Adds a applier of updated cluster states.  */ public void addStateApplier(ClusterStateApplier applier) {     clusterApplierService.addStateApplier(applier). }
true;public;1;3;/**  * Removes an applier of updated cluster states.  */ ;/**  * Removes an applier of updated cluster states.  */ public void removeApplier(ClusterStateApplier applier) {     clusterApplierService.removeApplier(applier). }
true;public;1;3;/**  * Add a listener for updated cluster states  */ ;/**  * Add a listener for updated cluster states  */ public void addListener(ClusterStateListener listener) {     clusterApplierService.addListener(listener). }
true;public;1;3;/**  * Removes a listener for updated cluster states.  */ ;/**  * Removes a listener for updated cluster states.  */ public void removeListener(ClusterStateListener listener) {     clusterApplierService.removeListener(listener). }
true;public;1;3;/**  * Add a listener for on/off local node master events  */ ;/**  * Add a listener for on/off local node master events  */ public void addLocalNodeMasterListener(LocalNodeMasterListener listener) {     clusterApplierService.addLocalNodeMasterListener(listener). }
false;public;0;3;;public MasterService getMasterService() {     return masterService. }
false;public;0;3;;public ClusterApplierService getClusterApplierService() {     return clusterApplierService. }
false;public,static;0;6;;public static boolean assertClusterOrMasterStateThread() {     assert Thread.currentThread().getName().contains(ClusterApplierService.CLUSTER_UPDATE_THREAD_NAME) || Thread.currentThread().getName().contains(MasterService.MASTER_UPDATE_THREAD_NAME) : "not called from the master/cluster state update thread".     return true. }
false;public;0;3;;public ClusterName getClusterName() {     return clusterName. }
false;public;0;3;;public ClusterSettings getClusterSettings() {     return clusterSettings. }
true;public;0;3;/**  * The node's settings.  */ ;/**  * The node's settings.  */ public Settings getSettings() {     return settings. }
true;public,final;0;3;/**  * The name of this node.  */ ;/**  * The name of this node.  */ public final String getNodeName() {     return nodeName. }
true;public;2;4;/**  * Submits a cluster state update task. unlike {@link #submitStateUpdateTask(String, Object, ClusterStateTaskConfig,  * ClusterStateTaskExecutor, ClusterStateTaskListener)}, submitted updates will not be batched.  *  * @param source     the source of the cluster state update task  * @param updateTask the full context for the cluster state update  *                   task  */ ;/**  * Submits a cluster state update task. unlike {@link #submitStateUpdateTask(String, Object, ClusterStateTaskConfig,  * ClusterStateTaskExecutor, ClusterStateTaskListener)}, submitted updates will not be batched.  *  * @param source     the source of the cluster state update task  * @param updateTask the full context for the cluster state update  *                   task  */ public <T extends ClusterStateTaskConfig & ClusterStateTaskExecutor<T> & ClusterStateTaskListener> void submitStateUpdateTask(String source, T updateTask) {     submitStateUpdateTask(source, updateTask, updateTask, updateTask, updateTask). }
true;public;5;6;/**  * Submits a cluster state update task. submitted updates will be  * batched across the same instance of executor. The exact batching  * semantics depend on the underlying implementation but a rough  * guideline is that if the update task is submitted while there  * are pending update tasks for the same executor, these update  * tasks will all be executed on the executor in a single batch  *  * @param source   the source of the cluster state update task  * @param task     the state needed for the cluster state update task  * @param config   the cluster state update task configuration  * @param executor the cluster state update task executor. tasks  *                 that share the same executor will be executed  *                 batches on this executor  * @param listener callback after the cluster state update task  *                 completes  * @param <T>      the type of the cluster state update task state  */ ;/**  * Submits a cluster state update task. submitted updates will be  * batched across the same instance of executor. The exact batching  * semantics depend on the underlying implementation but a rough  * guideline is that if the update task is submitted while there  * are pending update tasks for the same executor, these update  * tasks will all be executed on the executor in a single batch  *  * @param source   the source of the cluster state update task  * @param task     the state needed for the cluster state update task  * @param config   the cluster state update task configuration  * @param executor the cluster state update task executor. tasks  *                 that share the same executor will be executed  *                 batches on this executor  * @param listener callback after the cluster state update task  *                 completes  * @param <T>      the type of the cluster state update task state  */ public <T> void submitStateUpdateTask(String source, T task, ClusterStateTaskConfig config, ClusterStateTaskExecutor<T> executor, ClusterStateTaskListener listener) {     submitStateUpdateTasks(source, Collections.singletonMap(task, listener), config, executor). }
true;public;4;5;/**  * Submits a batch of cluster state update tasks. submitted updates are guaranteed to be processed together,  * potentially with more tasks of the same executor.  *  * @param source   the source of the cluster state update task  * @param tasks    a map of update tasks and their corresponding listeners  * @param config   the cluster state update task configuration  * @param executor the cluster state update task executor. tasks  *                 that share the same executor will be executed  *                 batches on this executor  * @param <T>      the type of the cluster state update task state  */ ;/**  * Submits a batch of cluster state update tasks. submitted updates are guaranteed to be processed together,  * potentially with more tasks of the same executor.  *  * @param source   the source of the cluster state update task  * @param tasks    a map of update tasks and their corresponding listeners  * @param config   the cluster state update task configuration  * @param executor the cluster state update task executor. tasks  *                 that share the same executor will be executed  *                 batches on this executor  * @param <T>      the type of the cluster state update task state  */ public <T> void submitStateUpdateTasks(final String source, final Map<T, ClusterStateTaskListener> tasks, final ClusterStateTaskConfig config, final ClusterStateTaskExecutor<T> executor) {     masterService.submitStateUpdateTasks(source, tasks, config, executor). }
