commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;6;;@Override protected void doWriteTo(StreamOutput out) throws IOException {     script.writeTo(out).     gapPolicy.writeTo(out).     out.writeGenericValue(bucketsPathsMap). }
false;public;0;4;;@Override public String getWriteableName() {     return BucketSelectorPipelineAggregationBuilder.NAME. }
false;public;2;28;;@Override public InternalAggregation reduce(InternalAggregation aggregation, ReduceContext reduceContext) {     InternalMultiBucketAggregation<InternalMultiBucketAggregation, InternalMultiBucketAggregation.InternalBucket> originalAgg = (InternalMultiBucketAggregation<InternalMultiBucketAggregation, InternalMultiBucketAggregation.InternalBucket>) aggregation.     List<? extends InternalMultiBucketAggregation.InternalBucket> buckets = originalAgg.getBuckets().     BucketAggregationSelectorScript.Factory factory = reduceContext.scriptService().compile(script, BucketAggregationSelectorScript.CONTEXT).     List<InternalMultiBucketAggregation.InternalBucket> newBuckets = new ArrayList<>().     for (InternalMultiBucketAggregation.InternalBucket bucket : buckets) {         Map<String, Object> vars = new HashMap<>().         if (script.getParams() != null) {             vars.putAll(script.getParams()).         }         for (Map.Entry<String, String> entry : bucketsPathsMap.entrySet()) {             String varName = entry.getKey().             String bucketsPath = entry.getValue().             Double value = resolveBucketValue(originalAgg, bucket, bucketsPath, gapPolicy).             vars.put(varName, value).         }         // TODO: can we use one instance of the script for all buckets? it should be stateless?         BucketAggregationSelectorScript executableScript = factory.newInstance(vars).         if (executableScript.execute()) {             newBuckets.add(bucket).         }     }     return originalAgg.create(newBuckets). }
