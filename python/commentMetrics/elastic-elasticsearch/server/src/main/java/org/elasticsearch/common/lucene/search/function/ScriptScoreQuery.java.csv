commented;modifiers;parameterAmount;loc;comment;code
false;public;1;9;;@Override public Query rewrite(IndexReader reader) throws IOException {     Query newQ = subQuery.rewrite(reader).     ScriptScoreFunction newFunction = (ScriptScoreFunction) function.rewrite(reader).     if ((newQ != subQuery) || (newFunction != function)) {         return new ScriptScoreQuery(newQ, newFunction, minScore).     }     return super.rewrite(reader). }
false;public;1;4;;@Override public void extractTerms(Set<Term> terms) {     subQueryWeight.extractTerms(terms). }
false;public;0;11;;@Override public float score() throws IOException {     int docId = docID().     float subQueryScore = subQueryScoreMode == ScoreMode.COMPLETE ? subQueryScorer.score() : 0f.     float score = (float) leafFunction.score(docId, subQueryScore).     if (score == Float.NEGATIVE_INFINITY || Float.isNaN(score)) {         throw new ElasticsearchException("script score query returned an invalid score: " + score + " for doc: " + docId).     }     return score. }
false;public;0;4;;@Override public int docID() {     return subQueryScorer.docID(). }
false;public;0;4;;@Override public DocIdSetIterator iterator() {     return subQueryScorer.iterator(). }
false;public;1;4;;@Override public float getMaxScore(int upTo) {     // TODO: what would be a good upper bound?     return Float.MAX_VALUE. }
false;public;1;40;;@Override public Scorer scorer(LeafReaderContext context) throws IOException {     Scorer subQueryScorer = subQueryWeight.scorer(context).     if (subQueryScorer == null) {         return null.     }     final LeafScoreFunction leafFunction = function.getLeafScoreFunction(context).     Scorer scriptScorer = new Scorer(this) {          @Override         public float score() throws IOException {             int docId = docID().             float subQueryScore = subQueryScoreMode == ScoreMode.COMPLETE ? subQueryScorer.score() : 0f.             float score = (float) leafFunction.score(docId, subQueryScore).             if (score == Float.NEGATIVE_INFINITY || Float.isNaN(score)) {                 throw new ElasticsearchException("script score query returned an invalid score: " + score + " for doc: " + docId).             }             return score.         }          @Override         public int docID() {             return subQueryScorer.docID().         }          @Override         public DocIdSetIterator iterator() {             return subQueryScorer.iterator().         }          @Override         public float getMaxScore(int upTo) {             // TODO: what would be a good upper bound?             return Float.MAX_VALUE.         }     }.     if (minScore != null) {         scriptScorer = new MinScoreScorer(this, scriptScorer, minScore).     }     return scriptScorer. }
false;public;2;13;;@Override public Explanation explain(LeafReaderContext context, int doc) throws IOException {     Explanation queryExplanation = subQueryWeight.explain(context, doc).     if (queryExplanation.isMatch() == false) {         return queryExplanation.     }     Explanation explanation = function.getLeafScoreFunction(context).explainScore(doc, queryExplanation).     if (minScore != null && minScore > explanation.getValue().floatValue()) {         explanation = Explanation.noMatch("Score value is too low, expected at least " + minScore + " but got " + explanation.getValue(), explanation).     }     return explanation. }
false;public;1;5;;@Override public boolean isCacheable(LeafReaderContext ctx) {     // If minScore is not null, then matches depend on statistics of the top-level reader.     return minScore == null. }
false;public;3;76;;@Override public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {     if (scoreMode == ScoreMode.COMPLETE_NO_SCORES && minScore == null) {         return subQuery.createWeight(searcher, scoreMode, boost).     }     ScoreMode subQueryScoreMode = function.needsScores() ? ScoreMode.COMPLETE : ScoreMode.COMPLETE_NO_SCORES.     Weight subQueryWeight = subQuery.createWeight(searcher, subQueryScoreMode, boost).     return new Weight(this) {          @Override         public void extractTerms(Set<Term> terms) {             subQueryWeight.extractTerms(terms).         }          @Override         public Scorer scorer(LeafReaderContext context) throws IOException {             Scorer subQueryScorer = subQueryWeight.scorer(context).             if (subQueryScorer == null) {                 return null.             }             final LeafScoreFunction leafFunction = function.getLeafScoreFunction(context).             Scorer scriptScorer = new Scorer(this) {                  @Override                 public float score() throws IOException {                     int docId = docID().                     float subQueryScore = subQueryScoreMode == ScoreMode.COMPLETE ? subQueryScorer.score() : 0f.                     float score = (float) leafFunction.score(docId, subQueryScore).                     if (score == Float.NEGATIVE_INFINITY || Float.isNaN(score)) {                         throw new ElasticsearchException("script score query returned an invalid score: " + score + " for doc: " + docId).                     }                     return score.                 }                  @Override                 public int docID() {                     return subQueryScorer.docID().                 }                  @Override                 public DocIdSetIterator iterator() {                     return subQueryScorer.iterator().                 }                  @Override                 public float getMaxScore(int upTo) {                     // TODO: what would be a good upper bound?                     return Float.MAX_VALUE.                 }             }.             if (minScore != null) {                 scriptScorer = new MinScoreScorer(this, scriptScorer, minScore).             }             return scriptScorer.         }          @Override         public Explanation explain(LeafReaderContext context, int doc) throws IOException {             Explanation queryExplanation = subQueryWeight.explain(context, doc).             if (queryExplanation.isMatch() == false) {                 return queryExplanation.             }             Explanation explanation = function.getLeafScoreFunction(context).explainScore(doc, queryExplanation).             if (minScore != null && minScore > explanation.getValue().floatValue()) {                 explanation = Explanation.noMatch("Score value is too low, expected at least " + minScore + " but got " + explanation.getValue(), explanation).             }             return explanation.         }          @Override         public boolean isCacheable(LeafReaderContext ctx) {             // If minScore is not null, then matches depend on statistics of the top-level reader.             return minScore == null.         }     }. }
false;public;1;7;;@Override public String toString(String field) {     StringBuilder sb = new StringBuilder().     sb.append("script score (").append(subQuery.toString(field)).append(", function: ").     sb.append("{" + (function == null ? "" : function.toString()) + "}").     return sb.toString(). }
false;public;1;13;;@Override public boolean equals(Object o) {     if (this == o) {         return true.     }     if (sameClassAs(o) == false) {         return false.     }     ScriptScoreQuery other = (ScriptScoreQuery) o.     return Objects.equals(this.subQuery, other.subQuery) && Objects.equals(this.minScore, other.minScore) && Objects.equals(this.function, other.function). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(classHash(), subQuery, minScore, function). }
