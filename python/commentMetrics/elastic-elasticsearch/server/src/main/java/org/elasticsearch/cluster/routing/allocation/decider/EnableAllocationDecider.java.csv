commented;modifiers;parameterAmount;loc;comment;code
false;public;1;3;;public void setEnableRebalance(Rebalance enableRebalance) {     this.enableRebalance = enableRebalance. }
false;public;1;3;;public void setEnableAllocation(Allocation enableAllocation) {     this.enableAllocation = enableAllocation. }
false;public;3;41;;@Override public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {     if (allocation.ignoreDisable()) {         return allocation.decision(Decision.YES, NAME, "explicitly ignoring any disabling of allocation due to manual allocation commands via the reroute API").     }     final IndexMetaData indexMetaData = allocation.metaData().getIndexSafe(shardRouting.index()).     final Allocation enable.     final boolean usedIndexSetting.     if (INDEX_ROUTING_ALLOCATION_ENABLE_SETTING.exists(indexMetaData.getSettings())) {         enable = INDEX_ROUTING_ALLOCATION_ENABLE_SETTING.get(indexMetaData.getSettings()).         usedIndexSetting = true.     } else {         enable = this.enableAllocation.         usedIndexSetting = false.     }     switch(enable) {         case ALL:             return allocation.decision(Decision.YES, NAME, "all allocations are allowed").         case NONE:             return allocation.decision(Decision.NO, NAME, "no allocations are allowed due to %s", setting(enable, usedIndexSetting)).         case NEW_PRIMARIES:             if (shardRouting.primary() && shardRouting.active() == false && shardRouting.recoverySource().getType() != RecoverySource.Type.EXISTING_STORE) {                 return allocation.decision(Decision.YES, NAME, "new primary allocations are allowed").             } else {                 return allocation.decision(Decision.NO, NAME, "non-new primary allocations are forbidden due to %s", setting(enable, usedIndexSetting)).             }         case PRIMARIES:             if (shardRouting.primary()) {                 return allocation.decision(Decision.YES, NAME, "primary allocations are allowed").             } else {                 return allocation.decision(Decision.NO, NAME, "replica allocations are forbidden due to %s", setting(enable, usedIndexSetting)).             }         default:             throw new IllegalStateException("Unknown allocation option").     } }
false;public;2;39;;@Override public Decision canRebalance(ShardRouting shardRouting, RoutingAllocation allocation) {     if (allocation.ignoreDisable()) {         return allocation.decision(Decision.YES, NAME, "allocation is explicitly ignoring any disabling of relocation").     }     Settings indexSettings = allocation.metaData().getIndexSafe(shardRouting.index()).getSettings().     final Rebalance enable.     final boolean usedIndexSetting.     if (INDEX_ROUTING_REBALANCE_ENABLE_SETTING.exists(indexSettings)) {         enable = INDEX_ROUTING_REBALANCE_ENABLE_SETTING.get(indexSettings).         usedIndexSetting = true.     } else {         enable = this.enableRebalance.         usedIndexSetting = false.     }     switch(enable) {         case ALL:             return allocation.decision(Decision.YES, NAME, "all rebalancing is allowed").         case NONE:             return allocation.decision(Decision.NO, NAME, "no rebalancing is allowed due to %s", setting(enable, usedIndexSetting)).         case PRIMARIES:             if (shardRouting.primary()) {                 return allocation.decision(Decision.YES, NAME, "primary rebalancing is allowed").             } else {                 return allocation.decision(Decision.NO, NAME, "replica rebalancing is forbidden due to %s", setting(enable, usedIndexSetting)).             }         case REPLICAS:             if (shardRouting.primary() == false) {                 return allocation.decision(Decision.YES, NAME, "replica rebalancing is allowed").             } else {                 return allocation.decision(Decision.NO, NAME, "primary rebalancing is forbidden due to %s", setting(enable, usedIndexSetting)).             }         default:             throw new IllegalStateException("Unknown rebalance option").     } }
false;private,static;2;12;;private static String setting(Allocation allocation, boolean usedIndexSetting) {     StringBuilder buf = new StringBuilder().     if (usedIndexSetting) {         buf.append("index setting [").         buf.append(INDEX_ROUTING_ALLOCATION_ENABLE_SETTING.getKey()).     } else {         buf.append("cluster setting [").         buf.append(CLUSTER_ROUTING_ALLOCATION_ENABLE_SETTING.getKey()).     }     buf.append("=").append(allocation.toString().toLowerCase(Locale.ROOT)).append("]").     return buf.toString(). }
false;private,static;2;12;;private static String setting(Rebalance rebalance, boolean usedIndexSetting) {     StringBuilder buf = new StringBuilder().     if (usedIndexSetting) {         buf.append("index setting [").         buf.append(INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey()).     } else {         buf.append("cluster setting [").         buf.append(CLUSTER_ROUTING_REBALANCE_ENABLE_SETTING.getKey()).     }     buf.append("=").append(rebalance.toString().toLowerCase(Locale.ROOT)).append("]").     return buf.toString(). }
false;public,static;1;12;;public static Allocation parse(String strValue) {     if (strValue == null) {         return null.     } else {         strValue = strValue.toUpperCase(Locale.ROOT).         try {             return Allocation.valueOf(strValue).         } catch (IllegalArgumentException e) {             throw new IllegalArgumentException("Illegal allocation.enable value [" + strValue + "]").         }     } }
false;public;0;4;;@Override public String toString() {     return name().toLowerCase(Locale.ROOT). }
false;public,static;1;12;;public static Rebalance parse(String strValue) {     if (strValue == null) {         return null.     } else {         strValue = strValue.toUpperCase(Locale.ROOT).         try {             return Rebalance.valueOf(strValue).         } catch (IllegalArgumentException e) {             throw new IllegalArgumentException("Illegal rebalance.enable value [" + strValue + "]").         }     } }
false;public;0;4;;@Override public String toString() {     return name().toLowerCase(Locale.ROOT). }
