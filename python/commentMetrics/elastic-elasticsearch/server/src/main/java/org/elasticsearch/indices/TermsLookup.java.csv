commented;modifiers;parameterAmount;loc;comment;code
false;public;1;21;;@Override public void writeTo(StreamOutput out) throws IOException {     if (out.getVersion().onOrAfter(Version.V_7_0_0)) {         out.writeOptionalString(type).     } else {         if (type == null) {             throw new IllegalArgumentException("Typeless [terms] lookup queries are not supported if any " + "node is running a version before 7.0.").         }         out.writeString(type).     }     out.writeString(id).     out.writeString(path).     if (out.getVersion().onOrAfter(Version.V_6_0_0_beta1)) {         out.writeString(index).     } else {         out.writeOptionalString(index).     }     out.writeOptionalString(routing). }
false;public;0;3;;public String index() {     return index. }
true;public;0;4;/**  * @deprecated Types are in the process of being removed.  */ ;/**  * @deprecated Types are in the process of being removed.  */ @Deprecated public String type() {     return type. }
false;public;0;3;;public String id() {     return id. }
false;public;0;3;;public String path() {     return path. }
false;public;0;3;;public String routing() {     return routing. }
false;public;1;4;;public TermsLookup routing(String routing) {     this.routing = routing.     return this. }
false;public,static;1;43;;public static TermsLookup parseTermsLookup(XContentParser parser) throws IOException {     String index = null.     String type = null.     String id = null.     String path = null.     String routing = null.     XContentParser.Token token.     String currentFieldName = "".     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (token.isValue()) {             switch(currentFieldName) {                 case "index":                     index = parser.text().                     break.                 case "type":                     type = parser.text().                     break.                 case "id":                     id = parser.text().                     break.                 case "routing":                     routing = parser.textOrNull().                     break.                 case "path":                     path = parser.text().                     break.                 default:                     throw new ParsingException(parser.getTokenLocation(), "[" + TermsQueryBuilder.NAME + "] query does not support [" + currentFieldName + "] within lookup element").             }         } else {             throw new ParsingException(parser.getTokenLocation(), "[" + TermsQueryBuilder.NAME + "] unknown token [" + token + "] after [" + currentFieldName + "]").         }     }     if (type == null) {         return new TermsLookup(index, id, path).routing(routing).     } else {         return new TermsLookup(index, type, id, path).routing(routing).     } }
false;public;0;8;;@Override public String toString() {     if (type == null) {         return index + "/" + id + "/" + path.     } else {         return index + "/" + type + "/" + id + "/" + path.     } }
false;public;2;13;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.field("index", index).     if (type != null) {         builder.field("type", type).     }     builder.field("id", id).     builder.field("path", path).     if (routing != null) {         builder.field("routing", routing).     }     return builder. }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(index, type, id, path, routing). }
false;public;1;15;;@Override public boolean equals(Object obj) {     if (this == obj) {         return true.     }     if (obj == null || getClass() != obj.getClass()) {         return false.     }     TermsLookup other = (TermsLookup) obj.     return Objects.equals(index, other.index) && Objects.equals(type, other.type) && Objects.equals(id, other.id) && Objects.equals(path, other.path) && Objects.equals(routing, other.routing). }
