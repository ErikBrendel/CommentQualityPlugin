commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Returns <code>true</code> iff the current reduce phase is the final reduce phase. This indicates if operations like  * pipeline aggregations should be applied or if specific features like {@code minDocCount} should be taken into account.  * Operations that are potentially loosing information can only be applied during the final reduce phase.  */ ;/**  * Returns <code>true</code> iff the current reduce phase is the final reduce phase. This indicates if operations like  * pipeline aggregations should be applied or if specific features like {@code minDocCount} should be taken into account.  * Operations that are potentially loosing information can only be applied during the final reduce phase.  */ public boolean isFinalReduce() {     return isFinalReduce. }
false;public;0;3;;public BigArrays bigArrays() {     return bigArrays. }
false;public;0;3;;public ScriptService scriptService() {     return scriptService. }
true;public;1;3;/**  * Adds {@code count} buckets to the global count for the request and fails if this number is greater than  * the maximum number of buckets allowed in a response  */ ;/**  * Adds {@code count} buckets to the global count for the request and fails if this number is greater than  * the maximum number of buckets allowed in a response  */ public void consumeBucketsAndMaybeBreak(int size) {     multiBucketConsumer.accept(size). }
false;public,final;1;7;;@Override public final void writeTo(StreamOutput out) throws IOException {     out.writeString(name).     out.writeGenericValue(metaData).     out.writeNamedWriteableList(pipelineAggregators).     doWriteTo(out). }
false;protected,abstract;1;1;;protected abstract void doWriteTo(StreamOutput out) throws IOException.
false;public;0;4;;@Override public String getName() {     return name. }
true;public,final;2;9;/**  * Reduces the given aggregations to a single one and returns it. In <b>most</b> cases, the assumption will be the all given  * aggregations are of the same type (the same type as this aggregation). For best efficiency, when implementing,  * try reusing an existing instance (typically the first in the given list) to save on redundant object  * construction.  */ ;/**  * Reduces the given aggregations to a single one and returns it. In <b>most</b> cases, the assumption will be the all given  * aggregations are of the same type (the same type as this aggregation). For best efficiency, when implementing,  * try reusing an existing instance (typically the first in the given list) to save on redundant object  * construction.  */ public final InternalAggregation reduce(List<InternalAggregation> aggregations, ReduceContext reduceContext) {     InternalAggregation aggResult = doReduce(aggregations, reduceContext).     if (reduceContext.isFinalReduce()) {         for (PipelineAggregator pipelineAggregator : pipelineAggregators) {             aggResult = pipelineAggregator.reduce(aggResult, reduceContext).         }     }     return aggResult. }
false;public,abstract;2;1;;public abstract InternalAggregation doReduce(List<InternalAggregation> aggregations, ReduceContext reduceContext).
true;public;0;3;/**  * Return true if this aggregation is mapped, and can lead a reduction.  If this agg returns  * false, it should return itself if asked to lead a reduction  */ ;/**  * Return true if this aggregation is mapped, and can lead a reduction.  If this agg returns  * false, it should return itself if asked to lead a reduction  */ public boolean isMapped() {     return true. }
true;public;1;4;/**  * Get the value of specified path in the aggregation.  *  * @param path  *            the path to the property in the aggregation tree  * @return the value of the property  */ ;/**  * Get the value of specified path in the aggregation.  *  * @param path  *            the path to the property in the aggregation tree  * @return the value of the property  */ public Object getProperty(String path) {     AggregationPath aggPath = AggregationPath.parse(path).     return getProperty(aggPath.getPathElementsAsStringList()). }
false;public,abstract;1;1;;public abstract Object getProperty(List<String> path).
true;protected,static;1;4;/**  * Read a size under the assumption that a value of 0 means unlimited.  */ ;/**  * Read a size under the assumption that a value of 0 means unlimited.  */ protected static int readSize(StreamInput in) throws IOException {     final int size = in.readVInt().     return size == 0 ? Integer.MAX_VALUE : size. }
true;protected,static;2;6;/**  * Write a size under the assumption that a value of 0 means unlimited.  */ ;/**  * Write a size under the assumption that a value of 0 means unlimited.  */ protected static void writeSize(int size, StreamOutput out) throws IOException {     if (size == Integer.MAX_VALUE) {         size = 0.     }     out.writeVInt(size). }
false;public;0;4;;@Override public Map<String, Object> getMetaData() {     return metaData. }
false;public;0;3;;public List<PipelineAggregator> pipelineAggregators() {     return pipelineAggregators. }
false;public;0;4;;@Override public String getType() {     return getWriteableName(). }
false;public,final;2;16;;@Override public final XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     if (params.paramAsBoolean(RestSearchAction.TYPED_KEYS_PARAM, false)) {         // Concatenates the type and the name of the aggregation (ex: top_hits#foo)         builder.startObject(String.join(TYPED_KEYS_DELIMITER, getType(), getName())).     } else {         builder.startObject(getName()).     }     if (this.metaData != null) {         builder.field(CommonFields.META.getPreferredName()).         builder.map(this.metaData).     }     doXContentBody(builder, params).     builder.endObject().     return builder. }
false;public,abstract;2;1;;public abstract XContentBuilder doXContentBody(XContentBuilder builder, Params params) throws IOException.
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(name, metaData, pipelineAggregators, doHashCode()). }
true;protected,abstract;0;1;/**  * Opportunity for subclasses to the {@link #hashCode()} for this  * class.  */ ;/**  * Opportunity for subclasses to the {@link #hashCode()} for this  * class.  */ protected abstract int doHashCode().
false;public;1;14;;@Override public boolean equals(Object obj) {     if (obj == null) {         return false.     }     if (obj.getClass() != getClass()) {         return false.     }     InternalAggregation other = (InternalAggregation) obj.     return Objects.equals(name, other.name) && Objects.equals(pipelineAggregators, other.pipelineAggregators) && Objects.equals(metaData, other.metaData) && doEquals(obj). }
true;protected,abstract;1;1;/**  * Opportunity for subclasses to add criteria to the {@link #equals(Object)}  * method for this class.  *  * This method can safely cast <code>obj</code> to the subclass since the  * {@link #equals(Object)} method checks that <code>obj</code> is the same  * class as <code>this</code>  */ ;/**  * Opportunity for subclasses to add criteria to the {@link #equals(Object)}  * method for this class.  *  * This method can safely cast <code>obj</code> to the subclass since the  * {@link #equals(Object)} method checks that <code>obj</code> is the same  * class as <code>this</code>  */ protected abstract boolean doEquals(Object obj).
false;public;0;4;;@Override public String toString() {     return Strings.toString(this). }
