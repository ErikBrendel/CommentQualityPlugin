commented;modifiers;parameterAmount;loc;comment;code
false;public,static;2;3;;public static CompositeAggregationBuilder parse(String aggregationName, XContentParser parser) throws IOException {     return PARSER.parse(parser, new CompositeAggregationBuilder(aggregationName), null). }
false;protected;2;4;;@Override protected AggregationBuilder shallowCopy(AggregatorFactories.Builder factoriesBuilder, Map<String, Object> metaData) {     return new CompositeAggregationBuilder(this, factoriesBuilder, metaData). }
false;protected;1;12;;@Override protected void doWriteTo(StreamOutput out) throws IOException {     out.writeVInt(sources.size()).     for (CompositeValuesSourceBuilder<?> builder : sources) {         CompositeValuesSourceParserHelper.writeTo(builder, out).     }     out.writeVInt(size).     out.writeBoolean(after != null).     if (after != null) {         out.writeMap(after).     } }
false;public;0;4;;@Override public String getType() {     return NAME. }
false;private;1;4;;private CompositeAggregationBuilder setSources(List<CompositeValuesSourceBuilder<?>> sources) {     this.sources = sources.     return this. }
true;public;0;3;/**  * Gets the list of {@link CompositeValuesSourceBuilder} for this aggregation.  */ ;/**  * Gets the list of {@link CompositeValuesSourceBuilder} for this aggregation.  */ public List<CompositeValuesSourceBuilder<?>> sources() {     return sources. }
true;public;1;4;/**  * Sets the values that indicates which composite bucket this request should "aggregate after".  * Defaults to {@code null}.  */ ;/**  * Sets the values that indicates which composite bucket this request should "aggregate after".  * Defaults to {@code null}.  */ public CompositeAggregationBuilder aggregateAfter(Map<String, Object> afterKey) {     this.after = afterKey.     return this. }
true;public;1;4;/**  * The number of composite buckets to return. Defaults to {@code 10}.  */ ;/**  * The number of composite buckets to return. Defaults to {@code 10}.  */ public CompositeAggregationBuilder size(int size) {     this.size = size.     return this. }
true;public;0;3;/**  * @return the number of composite buckets. Defaults to {@code 10}.  */ ;/**  * @return the number of composite buckets. Defaults to {@code 10}.  */ public int size() {     return size. }
true;private;1;9;/**  * Returns null if the provided factory and his parents are compatible with  * this aggregator or the instance of the parent's factory that is incompatible with  * the composite aggregation.  */ ;/**  * Returns null if the provided factory and his parents are compatible with  * this aggregator or the instance of the parent's factory that is incompatible with  * the composite aggregation.  */ private AggregatorFactory<?> checkParentIsNullOrNested(AggregatorFactory<?> factory) {     if (factory == null) {         return null.     } else if (factory instanceof NestedAggregatorFactory) {         return checkParentIsNullOrNested(factory.getParent()).     } else {         return factory.     } }
false;protected;3;43;;@Override protected AggregatorFactory<?> doBuild(SearchContext context, AggregatorFactory<?> parent, AggregatorFactories.Builder subfactoriesBuilder) throws IOException {     AggregatorFactory<?> invalid = checkParentIsNullOrNested(parent).     if (invalid != null) {         throw new IllegalArgumentException("[composite] aggregation cannot be used with a parent aggregation of" + " type: [" + invalid.getClass().getSimpleName() + "]").     }     CompositeValuesSourceConfig[] configs = new CompositeValuesSourceConfig[sources.size()].     for (int i = 0. i < configs.length. i++) {         configs[i] = sources.get(i).build(context).         if (configs[i].valuesSource().needsScores()) {             throw new IllegalArgumentException("[sources] cannot access _score").         }     }     final CompositeKey afterKey.     if (after != null) {         if (after.size() != configs.length) {             throw new IllegalArgumentException("[after] has " + after.size() + " value(s) but [sources] has " + sources.size()).         }         Comparable[] values = new Comparable[sources.size()].         for (int i = 0. i < sources.size(). i++) {             String sourceName = sources.get(i).name().             if (after.containsKey(sourceName) == false) {                 throw new IllegalArgumentException("Missing value for [after." + sources.get(i).name() + "]").             }             Object obj = after.get(sourceName).             if (configs[i].missingBucket() && obj == null) {                 values[i] = null.             } else if (obj instanceof Comparable) {                 values[i] = (Comparable) obj.             } else {                 throw new IllegalArgumentException("Invalid value for [after." + sources.get(i).name() + "], expected comparable, got [" + (obj == null ? "null" : obj.getClass().getSimpleName()) + "]").             }         }         afterKey = new CompositeKey(values).     } else {         afterKey = null.     }     return new CompositeAggregationFactory(name, context, parent, subfactoriesBuilder, metaData, size, configs, afterKey). }
false;protected;2;15;;@Override protected XContentBuilder internalXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     builder.field(SIZE_FIELD_NAME.getPreferredName(), size).     builder.startArray(SOURCES_FIELD_NAME.getPreferredName()).     for (CompositeValuesSourceBuilder<?> source : sources) {         CompositeValuesSourceParserHelper.toXContent(source, builder, params).     }     builder.endArray().     if (after != null) {         CompositeAggregation.buildCompositeMap(AFTER_FIELD_NAME.getPreferredName(), after, builder).     }     builder.endObject().     return builder. }
false;protected;0;4;;@Override protected int doHashCode() {     return Objects.hash(sources, size, after). }
false;protected;1;7;;@Override protected boolean doEquals(Object obj) {     CompositeAggregationBuilder other = (CompositeAggregationBuilder) obj.     return size == other.size && Objects.equals(sources, other.sources) && Objects.equals(after, other.after). }
