commented;modifiers;parameterAmount;loc;comment;code
true;public;3;3;/**  * Allows to validate an {@link org.elasticsearch.action.admin.indices.alias.Alias} and make sure  * it's valid before it gets added to the index metadata. Doesn't validate the alias filter.  * @throws IllegalArgumentException if the alias is not valid  */ ;/**  * Allows to validate an {@link org.elasticsearch.action.admin.indices.alias.Alias} and make sure  * it's valid before it gets added to the index metadata. Doesn't validate the alias filter.  * @throws IllegalArgumentException if the alias is not valid  */ public void validateAlias(Alias alias, String index, MetaData metaData) {     validateAlias(alias.name(), index, alias.indexRouting(), metaData::index). }
true;public;3;3;/**  * Allows to validate an {@link org.elasticsearch.cluster.metadata.AliasMetaData} and make sure  * it's valid before it gets added to the index metadata. Doesn't validate the alias filter.  * @throws IllegalArgumentException if the alias is not valid  */ ;/**  * Allows to validate an {@link org.elasticsearch.cluster.metadata.AliasMetaData} and make sure  * it's valid before it gets added to the index metadata. Doesn't validate the alias filter.  * @throws IllegalArgumentException if the alias is not valid  */ public void validateAliasMetaData(AliasMetaData aliasMetaData, String index, MetaData metaData) {     validateAlias(aliasMetaData.alias(), index, aliasMetaData.indexRouting(), metaData::index). }
true;public;1;10;/**  * Allows to partially validate an alias, without knowing which index it'll get applied to.  * Useful with index templates containing aliases. Checks also that it is possible to parse  * the alias filter via {@link org.elasticsearch.common.xcontent.XContentParser},  * without validating it as a filter though.  * @throws IllegalArgumentException if the alias is not valid  */ ;/**  * Allows to partially validate an alias, without knowing which index it'll get applied to.  * Useful with index templates containing aliases. Checks also that it is possible to parse  * the alias filter via {@link org.elasticsearch.common.xcontent.XContentParser},  * without validating it as a filter though.  * @throws IllegalArgumentException if the alias is not valid  */ public void validateAliasStandalone(Alias alias) {     validateAliasStandalone(alias.name(), alias.indexRouting()).     if (Strings.hasLength(alias.filter())) {         try {             XContentHelper.convertToMap(XContentFactory.xContent(alias.filter()), alias.filter(), false).         } catch (Exception e) {             throw new IllegalArgumentException("failed to parse filter for alias [" + alias.name() + "]", e).         }     } }
true;public;4;12;/**  * Validate a proposed alias.  */ ;/**  * Validate a proposed alias.  */ public void validateAlias(String alias, String index, @Nullable String indexRouting, Function<String, IndexMetaData> indexLookup) {     validateAliasStandalone(alias, indexRouting).     if (!Strings.hasText(index)) {         throw new IllegalArgumentException("index name is required").     }     IndexMetaData indexNamedSameAsAlias = indexLookup.apply(alias).     if (indexNamedSameAsAlias != null) {         throw new InvalidAliasNameException(indexNamedSameAsAlias.getIndex(), alias, "an index exists with the same name as the alias").     } }
false;;2;9;;void validateAliasStandalone(String alias, String indexRouting) {     if (!Strings.hasText(alias)) {         throw new IllegalArgumentException("alias name is required").     }     MetaDataCreateIndexService.validateIndexOrAliasName(alias, InvalidAliasNameException::new).     if (indexRouting != null && indexRouting.indexOf(',') != -1) {         throw new IllegalArgumentException("alias [" + alias + "] has several index routing values associated with it").     } }
true;public;4;10;/**  * Validates an alias filter by parsing it using the  * provided {@link org.elasticsearch.index.query.QueryShardContext}  * @throws IllegalArgumentException if the filter is not valid  */ ;/**  * Validates an alias filter by parsing it using the  * provided {@link org.elasticsearch.index.query.QueryShardContext}  * @throws IllegalArgumentException if the filter is not valid  */ public void validateAliasFilter(String alias, String filter, QueryShardContext queryShardContext, NamedXContentRegistry xContentRegistry) {     assert queryShardContext != null.     try (XContentParser parser = XContentFactory.xContent(filter).createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, filter)) {         validateAliasFilter(parser, queryShardContext).     } catch (Exception e) {         throw new IllegalArgumentException("failed to parse filter for alias [" + alias + "]", e).     } }
true;public;4;10;/**  * Validates an alias filter by parsing it using the  * provided {@link org.elasticsearch.index.query.QueryShardContext}  * @throws IllegalArgumentException if the filter is not valid  */ ;/**  * Validates an alias filter by parsing it using the  * provided {@link org.elasticsearch.index.query.QueryShardContext}  * @throws IllegalArgumentException if the filter is not valid  */ public void validateAliasFilter(String alias, byte[] filter, QueryShardContext queryShardContext, NamedXContentRegistry xContentRegistry) {     assert queryShardContext != null.     try (XContentParser parser = XContentFactory.xContent(filter).createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, filter)) {         validateAliasFilter(parser, queryShardContext).     } catch (Exception e) {         throw new IllegalArgumentException("failed to parse filter for alias [" + alias + "]", e).     } }
false;private,static;2;5;;private static void validateAliasFilter(XContentParser parser, QueryShardContext queryShardContext) throws IOException {     QueryBuilder parseInnerQueryBuilder = parseInnerQueryBuilder(parser).     QueryBuilder queryBuilder = Rewriteable.rewrite(parseInnerQueryBuilder, queryShardContext, true).     queryBuilder.toQuery(queryShardContext). }
