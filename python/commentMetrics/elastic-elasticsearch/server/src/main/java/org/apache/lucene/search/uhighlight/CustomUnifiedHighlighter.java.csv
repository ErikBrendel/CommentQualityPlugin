commented;modifiers;parameterAmount;loc;comment;code
true;public;4;14;/**  * Highlights terms extracted from the provided query within the content of the provided field name  */ ;/**  * Highlights terms extracted from the provided query within the content of the provided field name  */ public Snippet[] highlightField(String field, Query query, int docId, int maxPassages) throws IOException {     Map<String, Object[]> fieldsAsObjects = super.highlightFieldsAsObjects(new String[] { field }, query, new int[] { docId }, new int[] { maxPassages }).     Object[] snippetObjects = fieldsAsObjects.get(field).     if (snippetObjects != null) {         // one single document at a time         assert snippetObjects.length == 1.         Object snippetObject = snippetObjects[0].         if (snippetObject != null && snippetObject instanceof Snippet[]) {             return (Snippet[]) snippetObject.         }     }     return EMPTY_SNIPPET. }
false;protected;3;6;;@Override protected List<CharSequence[]> loadFieldValues(String[] fields, DocIdSetIterator docIter, int cacheCharsThreshold) throws IOException {     // we only highlight one field, one document at a time     return Collections.singletonList(new String[] { fieldValue }). }
false;protected;1;4;;@Override protected BreakIterator getBreakIterator(String field) {     return breakIterator. }
false;protected;1;4;;@Override protected PassageFormatter getFormatter(String field) {     return passageFormatter. }
false;protected;4;15;;@Override protected FieldHighlighter getFieldHighlighter(String field, Query query, Set<Term> allTerms, int maxPassages) {     Predicate<String> fieldMatcher = getFieldMatcher(field).     BytesRef[] terms = filterExtractedTerms(fieldMatcher, allTerms).     Set<HighlightFlag> highlightFlags = getFlags(field).     PhraseHelper phraseHelper = getPhraseHelper(field, query, highlightFlags).     CharacterRunAutomaton[] automata = getAutomata(field, query, highlightFlags).     OffsetSource offsetSource = getOptimizedOffsetSource(field, terms, phraseHelper, automata).     BreakIterator breakIterator = new SplittingBreakIterator(getBreakIterator(field), UnifiedHighlighter.MULTIVAL_SEP_CHAR).     UHComponents components = new UHComponents(field, fieldMatcher, query, terms, phraseHelper, automata, highlightFlags).     FieldOffsetStrategy strategy = getOffsetStrategy(offsetSource, components).     return new CustomFieldHighlighter(field, strategy, breakIteratorLocale, breakIterator, getScorer(field), maxPassages, (noMatchSize > 0 ? 1 : 0), getFormatter(field), noMatchSize, fieldValue). }
false;protected;1;4;;@Override protected Collection<Query> preMultiTermQueryRewrite(Query query) {     return rewriteCustomQuery(query). }
false;protected;1;4;;@Override protected Collection<Query> preSpanQueryRewrite(Query query) {     return rewriteCustomQuery(query). }
true;private;1;51;/**  * Translate custom queries in queries that are supported by the unified highlighter.  */ ;/**  * Translate custom queries in queries that are supported by the unified highlighter.  */ private Collection<Query> rewriteCustomQuery(Query query) {     if (query instanceof MultiPhrasePrefixQuery) {         MultiPhrasePrefixQuery mpq = (MultiPhrasePrefixQuery) query.         Term[][] terms = mpq.getTerms().         int[] positions = mpq.getPositions().         SpanQuery[] positionSpanQueries = new SpanQuery[positions.length].         int sizeMinus1 = terms.length - 1.         for (int i = 0. i < positions.length. i++) {             SpanQuery[] innerQueries = new SpanQuery[terms[i].length].             for (int j = 0. j < terms[i].length. j++) {                 if (i == sizeMinus1) {                     innerQueries[j] = new SpanMultiTermQueryWrapper<PrefixQuery>(new PrefixQuery(terms[i][j])).                 } else {                     innerQueries[j] = new SpanTermQuery(terms[i][j]).                 }             }             if (innerQueries.length > 1) {                 positionSpanQueries[i] = new SpanOrQuery(innerQueries).             } else {                 positionSpanQueries[i] = innerQueries[0].             }         }         if (positionSpanQueries.length == 1) {             return Collections.singletonList(positionSpanQueries[0]).         }         // sum position increments beyond 1         int positionGaps = 0.         if (positions.length >= 2) {             // positions are in increasing order.   max(0,...) is just a safeguard.             positionGaps = Math.max(0, positions[positions.length - 1] - positions[0] - positions.length + 1).         }         // if original slop is 0 then require inOrder         boolean inorder = (mpq.getSlop() == 0).         return Collections.singletonList(new SpanNearQuery(positionSpanQueries, mpq.getSlop() + positionGaps, inorder)).     } else if (query instanceof CommonTermsQuery) {         CommonTermsQuery ctq = (CommonTermsQuery) query.         List<Query> tqs = new ArrayList<>().         for (Term term : ctq.getTerms()) {             tqs.add(new TermQuery(term)).         }         return tqs.     } else if (query instanceof FunctionScoreQuery) {         return Collections.singletonList(((FunctionScoreQuery) query).getSubQuery()).     } else if (query instanceof ESToParentBlockJoinQuery) {         return Collections.singletonList(((ESToParentBlockJoinQuery) query).getChildQuery()).     } else {         return null.     } }
true;protected;1;7;/**  * Forces the offset source for this highlighter  */ ;/**  * Forces the offset source for this highlighter  */ @Override protected OffsetSource getOffsetSource(String field) {     if (offsetSource == null) {         return super.getOffsetSource(field).     }     return offsetSource. }
