commented;modifiers;parameterAmount;loc;comment;code
false;public;1;5;;@Override public IndexFieldMapper build(BuilderContext context) {     setupFieldType(context).     return new IndexFieldMapper(fieldType, context.indexSettings()). }
false;public;3;5;;@Override public MetadataFieldMapper.Builder<?, ?> parse(String name, Map<String, Object> node, ParserContext parserContext) throws MapperParsingException {     throw new MapperParsingException(NAME + " is not configurable"). }
false;public;2;5;;@Override public MetadataFieldMapper getDefault(MappedFieldType fieldType, ParserContext context) {     final Settings indexSettings = context.mapperService().getIndexSettings().getSettings().     return new IndexFieldMapper(indexSettings, fieldType). }
false;public;0;4;;@Override public MappedFieldType clone() {     return new IndexFieldType(this). }
false;public;0;4;;@Override public String typeName() {     return CONTENT_TYPE. }
false;public;0;5;;@Override public boolean isSearchable() {     // The _index field is always searchable.     return true. }
false;public;1;4;;@Override public Query existsQuery(QueryShardContext context) {     return new MatchAllDocsQuery(). }
true;public;2;9;/**  * This termQuery impl looks at the context to determine the index that  * is being queried and then returns a MATCH_ALL_QUERY or MATCH_NO_QUERY  * if the value matches this index. This can be useful if aliases or  * wildcards are used but the aim is to restrict the query to specific  * indices  */ ;/**  * This termQuery impl looks at the context to determine the index that  * is being queried and then returns a MATCH_ALL_QUERY or MATCH_NO_QUERY  * if the value matches this index. This can be useful if aliases or  * wildcards are used but the aim is to restrict the query to specific  * indices  */ @Override public Query termQuery(Object value, @Nullable QueryShardContext context) {     if (isSameIndex(value, context.getFullyQualifiedIndex().getName())) {         return Queries.newMatchAllQuery().     } else {         return Queries.newMatchNoDocsQuery("Index didn't match. Index queried: " + context.index().getName() + " vs. " + value).     } }
false;public;2;16;;@Override public Query termsQuery(List values, QueryShardContext context) {     if (context == null) {         return super.termsQuery(values, context).     }     for (Object value : values) {         if (isSameIndex(value, context.getFullyQualifiedIndex().getName())) {             // running in the context of just one of these index names.             return Queries.newMatchAllQuery().         }     }     // None of the listed index names are this one     return Queries.newMatchNoDocsQuery("Index didn't match. Index queried: " + context.getFullyQualifiedIndex().getName() + " vs. " + values). }
false;public;3;12;;@Override public Query prefixQuery(String value, @Nullable MultiTermQuery.RewriteMethod method, QueryShardContext context) {     String indexName = context.getFullyQualifiedIndex().getName().     if (indexName.startsWith(value)) {         return Queries.newMatchAllQuery().     } else {         return Queries.newMatchNoDocsQuery("The index [" + indexName + "] doesn't match the provided prefix [" + value + "].").     } }
false;public;5;13;;@Override public Query regexpQuery(String value, int flags, int maxDeterminizedStates, MultiTermQuery.RewriteMethod method, QueryShardContext context) {     String indexName = context.getFullyQualifiedIndex().getName().     Pattern pattern = Regex.compile(value, Regex.flagsToString(flags)).     if (pattern.matcher(indexName).matches()) {         return Queries.newMatchAllQuery().     } else {         return Queries.newMatchNoDocsQuery("The index [" + indexName + "] doesn't match the provided pattern [" + value + "].").     } }
false;public;3;12;;@Override public Query wildcardQuery(String value, @Nullable MultiTermQuery.RewriteMethod method, QueryShardContext context) {     String indexName = context.getFullyQualifiedIndex().getName().     if (isSameIndex(value, indexName)) {         return Queries.newMatchAllQuery().     } else {         return Queries.newMatchNoDocsQuery("The index [" + indexName + "] doesn't match the provided pattern [" + value + "].").     } }
false;private;2;4;;private boolean isSameIndex(Object value, String indexName) {     String pattern = value instanceof BytesRef ? ((BytesRef) value).utf8ToString() : value.toString().     return Regex.simpleMatch(pattern, indexName). }
false;public;1;4;;@Override public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName) {     return new ConstantIndexFieldData.Builder(mapperService -> fullyQualifiedIndexName). }
false;public;1;2;;@Override public void preParse(ParseContext context) throws IOException { }
false;protected;2;2;;@Override protected void parseCreateField(ParseContext context, List<IndexableField> fields) throws IOException { }
false;protected;0;4;;@Override protected String contentType() {     return CONTENT_TYPE. }
false;public;2;4;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     return builder. }
false;protected;1;4;;@Override protected void doMerge(Mapper mergeWith) { // nothing to do }
