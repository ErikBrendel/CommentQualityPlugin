commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;21;/**  * Parse a string SeasonalityType into the byte enum  *  * @param text                SeasonalityType in string format (e.g. "add")  * @return                    SeasonalityType enum  */ ;/**  * Parse a string SeasonalityType into the byte enum  *  * @param text                SeasonalityType in string format (e.g. "add")  * @return                    SeasonalityType enum  */ @Nullable public static SeasonalityType parse(String text) {     if (text == null) {         return null.     }     SeasonalityType result = null.     for (SeasonalityType policy : values()) {         if (policy.parseField.match(text, LoggingDeprecationHandler.INSTANCE)) {             result = policy.             break.         }     }     if (result == null) {         final List<String> validNames = new ArrayList<>().         for (SeasonalityType policy : values()) {             validNames.add(policy.getName()).         }         throw new ElasticsearchParseException("failed to parse seasonality type [{}]. accepted values are [{}]", text, validNames).     }     return result. }
true;public;1;3;/**  * Serialize the SeasonalityType to the output stream  */ ;/**  * Serialize the SeasonalityType to the output stream  */ public void writeTo(StreamOutput out) throws IOException {     out.writeByte(id). }
true;public,static;1;9;/**  * Deserialize the SeasonalityType from the input stream  *  * @param in  the input stream  * @return    SeasonalityType Enum  */ ;/**  * Deserialize the SeasonalityType from the input stream  *  * @param in  the input stream  * @return    SeasonalityType Enum  */ public static SeasonalityType readFrom(StreamInput in) throws IOException {     byte id = in.readByte().     for (SeasonalityType seasonalityType : values()) {         if (id == seasonalityType.id) {             return seasonalityType.         }     }     throw new IllegalStateException("Unknown Seasonality Type with id [" + id + "]"). }
true;public;0;3;/**  * Return the english-formatted name of the SeasonalityType  *  * @return English representation of SeasonalityType  */ ;/**  * Return the english-formatted name of the SeasonalityType  *  * @return English representation of SeasonalityType  */ public String getName() {     return parseField.getPreferredName(). }
true;private;0;3;/**  * Only pad if we are multiplicative and padding is enabled. the padding amount is not currently user-configurable.  */ ;/**  * Only pad if we are multiplicative and padding is enabled. the padding amount is not currently user-configurable.  */ private double inferPadding() {     return seasonalityType.equals(SeasonalityType.MULTIPLICATIVE) && pad ? 0.0000000001 : 0. }
false;public;1;9;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeDouble(alpha).     out.writeDouble(beta).     out.writeDouble(gamma).     out.writeVInt(period).     seasonalityType.writeTo(out).     out.writeBoolean(pad). }
false;public;0;4;;@Override public String getWriteableName() {     return NAME. }
false;public;0;4;;@Override public boolean minimizeByDefault() {     return true. }
false;public;0;4;;@Override public boolean canBeMinimized() {     return true. }
false;public;0;15;;@Override public MovAvgModel neighboringModel() {     double newValue = Math.random().     switch((int) (Math.random() * 3)) {         case 0:             return new HoltWintersModel(newValue, beta, gamma, period, seasonalityType, pad).         case 1:             return new HoltWintersModel(alpha, newValue, gamma, period, seasonalityType, pad).         case 2:             return new HoltWintersModel(alpha, beta, newValue, period, seasonalityType, pad).         default:             assert (false) : "Random value fell outside of range [0-2]".             // This should never technically happen...             return new HoltWintersModel(newValue, beta, gamma, period, seasonalityType, pad).     } }
false;public;0;4;;@Override public MovAvgModel clone() {     return new HoltWintersModel(alpha, beta, gamma, period, seasonalityType, pad). }
false;public;1;5;;@Override public boolean hasValue(int valuesAvailable) {     // We need at least (period * 2) data-points (e.g. two "seasons")     return valuesAvailable >= period * 2. }
true;protected;2;4;/**  * Predicts the next `n` values in the series, using the smoothing model to generate new values.  * Unlike the other moving averages, HoltWinters has forecasting/prediction built into the algorithm.  * Prediction is more than simply adding the next prediction to the window and repeating.  HoltWinters  * will extrapolate into the future by applying the trend and seasonal information to the smoothed data.  *  * @param values            Collection of numerics to movingAvg, usually windowed  * @param numPredictions    Number of newly generated predictions to return  * @return                  Returns an array of doubles, since most smoothing methods operate on floating points  */ ;/**  * Predicts the next `n` values in the series, using the smoothing model to generate new values.  * Unlike the other moving averages, HoltWinters has forecasting/prediction built into the algorithm.  * Prediction is more than simply adding the next prediction to the window and repeating.  HoltWinters  * will extrapolate into the future by applying the trend and seasonal information to the smoothed data.  *  * @param values            Collection of numerics to movingAvg, usually windowed  * @param numPredictions    Number of newly generated predictions to return  * @return                  Returns an array of doubles, since most smoothing methods operate on floating points  */ @Override protected double[] doPredict(Collection<Double> values, int numPredictions) {     return next(values, numPredictions). }
false;public;1;4;;@Override public double next(Collection<Double> values) {     return next(values, 1)[0]. }
true;public;2;4;/**  * Calculate a doubly exponential weighted moving average  *  * @param values Collection of values to calculate avg for  * @param numForecasts number of forecasts into the future to return  *  * @return       Returns a Double containing the moving avg for the window  */ ;/**  * Calculate a doubly exponential weighted moving average  *  * @param values Collection of values to calculate avg for  * @param numForecasts number of forecasts into the future to return  *  * @return       Returns a Double containing the moving avg for the window  */ public double[] next(Collection<Double> values, int numForecasts) {     return MovingFunctions.holtWintersForecast(values.stream().mapToDouble(Double::doubleValue).toArray(), alpha, beta, gamma, period, padding, seasonalityType.equals(SeasonalityType.MULTIPLICATIVE), numForecasts). }
false;public;2;13;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.field(MovAvgPipelineAggregationBuilder.MODEL.getPreferredName(), NAME).     builder.startObject(MovAvgPipelineAggregationBuilder.SETTINGS.getPreferredName()).     builder.field("alpha", alpha).     builder.field("beta", beta).     builder.field("gamma", gamma).     builder.field("period", period).     builder.field("pad", pad).     builder.field("type", seasonalityType.getName()).     builder.endObject().     return builder. }
false;public;3;34;;@Override public MovAvgModel parse(@Nullable Map<String, Object> settings, String pipelineName, int windowSize) throws ParseException {     double alpha = parseDoubleParam(settings, "alpha", DEFAULT_ALPHA).     double beta = parseDoubleParam(settings, "beta", DEFAULT_BETA).     double gamma = parseDoubleParam(settings, "gamma", DEFAULT_GAMMA).     int period = parseIntegerParam(settings, "period", DEFAULT_PERIOD).     if (windowSize < 2 * period) {         throw new ParseException("Field [window] must be at least twice as large as the period when " + "using Holt-Winters.  Value provided was [" + windowSize + "], which is less than (2*period) == " + (2 * period), 0).     }     SeasonalityType seasonalityType = DEFAULT_SEASONALITY_TYPE.     if (settings != null) {         Object value = settings.get("type").         if (value != null) {             if (value instanceof String) {                 seasonalityType = SeasonalityType.parse((String) value).                 settings.remove("type").             } else {                 throw new ParseException("Parameter [type] must be a String, type `" + value.getClass().getSimpleName() + "` provided instead", 0).             }         }     }     boolean pad = parseBoolParam(settings, "pad", seasonalityType.equals(SeasonalityType.MULTIPLICATIVE)).     checkUnrecognizedParams(settings).     return new HoltWintersModel(alpha, beta, gamma, period, seasonalityType, pad). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(alpha, beta, gamma, period, seasonalityType, pad). }
false;public;1;16;;@Override public boolean equals(Object obj) {     if (obj == null) {         return false.     }     if (getClass() != obj.getClass()) {         return false.     }     HoltWintersModel other = (HoltWintersModel) obj.     return Objects.equals(alpha, other.alpha) && Objects.equals(beta, other.beta) && Objects.equals(gamma, other.gamma) && Objects.equals(period, other.period) && Objects.equals(seasonalityType, other.seasonalityType) && Objects.equals(pad, other.pad). }
true;public;1;4;/**  * Alpha controls the smoothing of the data.  Alpha = 1 retains no memory of past values  * (e.g. a random walk), while alpha = 0 retains infinite memory of past values (e.g.  * the series mean).  Useful values are somewhere in between.  Defaults to 0.5.  *  * @param alpha A double between 0-1 inclusive, controls data smoothing  *  * @return The builder to continue chaining  */ ;/**  * Alpha controls the smoothing of the data.  Alpha = 1 retains no memory of past values  * (e.g. a random walk), while alpha = 0 retains infinite memory of past values (e.g.  * the series mean).  Useful values are somewhere in between.  Defaults to 0.5.  *  * @param alpha A double between 0-1 inclusive, controls data smoothing  *  * @return The builder to continue chaining  */ public HoltWintersModelBuilder alpha(double alpha) {     this.alpha = alpha.     return this. }
true;public;1;4;/**  * Equivalent to <code>alpha</code>, but controls the smoothing of the trend instead of the data  *  * @param beta a double between 0-1 inclusive, controls trend smoothing  *  * @return The builder to continue chaining  */ ;/**  * Equivalent to <code>alpha</code>, but controls the smoothing of the trend instead of the data  *  * @param beta a double between 0-1 inclusive, controls trend smoothing  *  * @return The builder to continue chaining  */ public HoltWintersModelBuilder beta(double beta) {     this.beta = beta.     return this. }
false;public;1;4;;public HoltWintersModelBuilder gamma(double gamma) {     this.gamma = gamma.     return this. }
false;public;1;4;;public HoltWintersModelBuilder period(int period) {     this.period = period.     return this. }
false;public;1;4;;public HoltWintersModelBuilder seasonalityType(SeasonalityType type) {     this.seasonalityType = type.     return this. }
false;public;1;4;;public HoltWintersModelBuilder pad(boolean pad) {     this.pad = pad.     return this. }
false;public;2;16;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.field(MovAvgPipelineAggregationBuilder.MODEL.getPreferredName(), NAME).     builder.startObject(MovAvgPipelineAggregationBuilder.SETTINGS.getPreferredName()).     builder.field("alpha", alpha).     builder.field("beta", beta).     builder.field("gamma", gamma).     builder.field("period", period).     if (pad != null) {         builder.field("pad", pad).     }     builder.field("type", seasonalityType.getName()).     builder.endObject().     return builder. }
false;public;0;5;;@Override public MovAvgModel build() {     boolean pad = this.pad == null ? (seasonalityType == SeasonalityType.MULTIPLICATIVE) : this.pad.     return new HoltWintersModel(alpha, beta, gamma, period, seasonalityType, pad). }
