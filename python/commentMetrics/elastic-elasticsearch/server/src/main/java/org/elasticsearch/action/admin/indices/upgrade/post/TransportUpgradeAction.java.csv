commented;modifiers;parameterAmount;loc;comment;code
false;protected;7;49;;@Override protected UpgradeResponse newResponse(UpgradeRequest request, int totalShards, int successfulShards, int failedShards, List<ShardUpgradeResult> shardUpgradeResults, List<DefaultShardOperationFailedException> shardFailures, ClusterState clusterState) {     Map<String, Integer> successfulPrimaryShards = new HashMap<>().     Map<String, Tuple<Version, org.apache.lucene.util.Version>> versions = new HashMap<>().     for (ShardUpgradeResult result : shardUpgradeResults) {         successfulShards++.         String index = result.getShardId().getIndex().getName().         if (result.primary()) {             Integer count = successfulPrimaryShards.get(index).             successfulPrimaryShards.put(index, count == null ? 1 : count + 1).         }         Tuple<Version, org.apache.lucene.util.Version> versionTuple = versions.get(index).         if (versionTuple == null) {             versions.put(index, new Tuple<>(result.upgradeVersion(), result.oldestLuceneSegment())).         } else {             // We already have versions for this index - let's see if we need to update them based on the current shard             Version version = versionTuple.v1().             org.apache.lucene.util.Version luceneVersion = versionTuple.v2().             // Since we rewrite the mapping during upgrade the metadata is always rewritten by the latest version             if (result.upgradeVersion().after(versionTuple.v1())) {                 version = result.upgradeVersion().             }             // oldest version that we need to support             if (result.oldestLuceneSegment().onOrAfter(versionTuple.v2()) == false) {                 luceneVersion = result.oldestLuceneSegment().             }             versions.put(index, new Tuple<>(version, luceneVersion)).         }     }     Map<String, Tuple<org.elasticsearch.Version, String>> updatedVersions = new HashMap<>().     MetaData metaData = clusterState.metaData().     for (Map.Entry<String, Tuple<Version, org.apache.lucene.util.Version>> versionEntry : versions.entrySet()) {         String index = versionEntry.getKey().         Integer primaryCount = successfulPrimaryShards.get(index).         int expectedPrimaryCount = metaData.index(index).getNumberOfShards().         if (primaryCount == metaData.index(index).getNumberOfShards()) {             updatedVersions.put(index, new Tuple<>(versionEntry.getValue().v1(), versionEntry.getValue().v2().toString())).         } else {             logger.warn("Not updating settings for the index [{}] because upgraded of some primary shards failed - " + "expected[{}], received[{}]", index, expectedPrimaryCount, primaryCount == null ? 0 : primaryCount).         }     }     return new UpgradeResponse(updatedVersions, totalShards, successfulShards, failedShards, shardFailures). }
false;protected;2;7;;@Override protected ShardUpgradeResult shardOperation(UpgradeRequest request, ShardRouting shardRouting) throws IOException {     IndexShard indexShard = indicesService.indexServiceSafe(shardRouting.shardId().getIndex()).getShard(shardRouting.shardId().id()).     org.apache.lucene.util.Version oldestLuceneSegment = indexShard.upgrade(request).     // We are using the current version of Elasticsearch as upgrade version since we update mapping to match the current version     return new ShardUpgradeResult(shardRouting.shardId(), indexShard.routingEntry().primary(), Version.CURRENT, oldestLuceneSegment). }
false;protected;1;6;;@Override protected ShardUpgradeResult readShardResult(StreamInput in) throws IOException {     ShardUpgradeResult result = new ShardUpgradeResult().     result.readFrom(in).     return result. }
false;protected;1;6;;@Override protected UpgradeRequest readRequestFrom(StreamInput in) throws IOException {     UpgradeRequest request = new UpgradeRequest().     request.readFrom(in).     return request. }
true;protected;3;11;/**  * The upgrade request works against *all* shards.  */ ;/**  * The upgrade request works against *all* shards.  */ @Override protected ShardsIterator shards(ClusterState clusterState, UpgradeRequest request, String[] concreteIndices) {     ShardsIterator iterator = clusterState.routingTable().allShards(concreteIndices).     Set<String> indicesWithMissingPrimaries = indicesWithMissingPrimaries(clusterState, concreteIndices).     if (indicesWithMissingPrimaries.isEmpty()) {         return iterator.     }     // If some primary shards are not available the request should fail.     throw new PrimaryMissingActionException("Cannot upgrade indices because the following indices are missing primary shards " + indicesWithMissingPrimaries). }
true;private;2;11;/**  * Finds all indices that have not all primaries available  */ ;/**  * Finds all indices that have not all primaries available  */ private Set<String> indicesWithMissingPrimaries(ClusterState clusterState, String[] concreteIndices) {     Set<String> indices = new HashSet<>().     RoutingTable routingTable = clusterState.routingTable().     for (String index : concreteIndices) {         IndexRoutingTable indexRoutingTable = routingTable.index(index).         if (indexRoutingTable.allPrimaryShardsActive() == false) {             indices.add(index).         }     }     return indices. }
false;protected;2;4;;@Override protected ClusterBlockException checkGlobalBlock(ClusterState state, UpgradeRequest request) {     return state.blocks().globalBlockedException(ClusterBlockLevel.METADATA_WRITE). }
false;protected;3;4;;@Override protected ClusterBlockException checkRequestBlock(ClusterState state, UpgradeRequest request, String[] concreteIndices) {     return state.blocks().indicesBlockedException(ClusterBlockLevel.METADATA_WRITE, concreteIndices). }
false;public;1;12;;@Override public void onResponse(UpgradeResponse upgradeResponse) {     try {         if (upgradeResponse.versions().isEmpty()) {             listener.onResponse(upgradeResponse).         } else {             updateSettings(upgradeResponse, listener).         }     } catch (Exception e) {         listener.onFailure(e).     } }
false;public;1;4;;@Override public void onFailure(Exception e) {     listener.onFailure(e). }
false;protected;3;23;;@Override protected void doExecute(Task task, UpgradeRequest request, final ActionListener<UpgradeResponse> listener) {     ActionListener<UpgradeResponse> settingsUpdateListener = new ActionListener<UpgradeResponse>() {          @Override         public void onResponse(UpgradeResponse upgradeResponse) {             try {                 if (upgradeResponse.versions().isEmpty()) {                     listener.onResponse(upgradeResponse).                 } else {                     updateSettings(upgradeResponse, listener).                 }             } catch (Exception e) {                 listener.onFailure(e).             }         }          @Override         public void onFailure(Exception e) {             listener.onFailure(e).         }     }.     super.doExecute(task, request, settingsUpdateListener). }
false;public;1;4;;@Override public void onResponse(AcknowledgedResponse updateSettingsResponse) {     listener.onResponse(upgradeResponse). }
false;public;1;4;;@Override public void onFailure(Exception e) {     listener.onFailure(e). }
false;private;2;14;;private void updateSettings(final UpgradeResponse upgradeResponse, final ActionListener<UpgradeResponse> listener) {     UpgradeSettingsRequest upgradeSettingsRequest = new UpgradeSettingsRequest(upgradeResponse.versions()).     client.executeLocally(UpgradeSettingsAction.INSTANCE, upgradeSettingsRequest, new ActionListener<AcknowledgedResponse>() {          @Override         public void onResponse(AcknowledgedResponse updateSettingsResponse) {             listener.onResponse(upgradeResponse).         }          @Override         public void onFailure(Exception e) {             listener.onFailure(e).         }     }). }
