commented;modifiers;parameterAmount;loc;comment;code
true;public,static;2;7;/**  * Returns a new multibinder that collects instances of {@code type} in a {@link Set} that is  * itself bound with no binding annotation.  */ ;/**  * Returns a new multibinder that collects instances of {@code type} in a {@link Set} that is  * itself bound with no binding annotation.  */ public static <T> Multibinder<T> newSetBinder(Binder binder, TypeLiteral<T> type) {     binder = binder.skipSources(RealMultibinder.class, Multibinder.class).     RealMultibinder<T> result = new RealMultibinder<>(binder, type, "", Key.get(Multibinder.<T>setOf(type))).     binder.install(result).     return result. }
true;public,static;2;3;/**  * Returns a new multibinder that collects instances of {@code type} in a {@link Set} that is  * itself bound with no binding annotation.  */ ;/**  * Returns a new multibinder that collects instances of {@code type} in a {@link Set} that is  * itself bound with no binding annotation.  */ public static <T> Multibinder<T> newSetBinder(Binder binder, Class<T> type) {     return newSetBinder(binder, TypeLiteral.get(type)). }
true;public,static;3;8;/**  * Returns a new multibinder that collects instances of {@code type} in a {@link Set} that is  * itself bound with {@code annotation}.  */ ;/**  * Returns a new multibinder that collects instances of {@code type} in a {@link Set} that is  * itself bound with {@code annotation}.  */ public static <T> Multibinder<T> newSetBinder(Binder binder, TypeLiteral<T> type, Annotation annotation) {     binder = binder.skipSources(RealMultibinder.class, Multibinder.class).     RealMultibinder<T> result = new RealMultibinder<>(binder, type, annotation.toString(), Key.get(Multibinder.<T>setOf(type), annotation)).     binder.install(result).     return result. }
true;public,static;3;4;/**  * Returns a new multibinder that collects instances of {@code type} in a {@link Set} that is  * itself bound with {@code annotation}.  */ ;/**  * Returns a new multibinder that collects instances of {@code type} in a {@link Set} that is  * itself bound with {@code annotation}.  */ public static <T> Multibinder<T> newSetBinder(Binder binder, Class<T> type, Annotation annotation) {     return newSetBinder(binder, TypeLiteral.get(type), annotation). }
true;public,static;3;8;/**  * Returns a new multibinder that collects instances of {@code type} in a {@link Set} that is  * itself bound with {@code annotationType}.  */ ;/**  * Returns a new multibinder that collects instances of {@code type} in a {@link Set} that is  * itself bound with {@code annotationType}.  */ public static <T> Multibinder<T> newSetBinder(Binder binder, TypeLiteral<T> type, Class<? extends Annotation> annotationType) {     binder = binder.skipSources(RealMultibinder.class, Multibinder.class).     RealMultibinder<T> result = new RealMultibinder<>(binder, type, "@" + annotationType.getName(), Key.get(Multibinder.<T>setOf(type), annotationType)).     binder.install(result).     return result. }
true;public,static;3;4;/**  * Returns a new multibinder that collects instances of {@code type} in a {@link Set} that is  * itself bound with {@code annotationType}.  */ ;/**  * Returns a new multibinder that collects instances of {@code type} in a {@link Set} that is  * itself bound with {@code annotationType}.  */ public static <T> Multibinder<T> newSetBinder(Binder binder, Class<T> type, Class<? extends Annotation> annotationType) {     return newSetBinder(binder, TypeLiteral.get(type), annotationType). }
false;private,static;1;5;;// wrapping a T in a Set safely returns a Set<T> @SuppressWarnings("unchecked") private static <T> TypeLiteral<Set<T>> setOf(TypeLiteral<T> elementType) {     Type type = Types.setOf(elementType.getType()).     return (TypeLiteral<Set<T>>) TypeLiteral.get(type). }
true;public,abstract;0;1;/**  * Returns a binding builder used to add a new element in the set. Each  * bound element must have a distinct value. Bound providers will be  * evaluated each time the set is injected.  * <p>  * It is an error to call this method without also calling one of the  * {@code to} methods on the returned binding builder.  * <p>  * Scoping elements independently is supported. Use the {@code in} method  * to specify a binding scope.  */ ;/**  * Returns a binding builder used to add a new element in the set. Each  * bound element must have a distinct value. Bound providers will be  * evaluated each time the set is injected.  * <p>  * It is an error to call this method without also calling one of the  * {@code to} methods on the returned binding builder.  * <p>  * Scoping elements independently is supported. Use the {@code in} method  * to specify a binding scope.  */ public abstract LinkedBindingBuilder<T> addBinding().
false;public;1;6;;@Override public void configure(Binder binder) {     checkConfiguration(!isInitialized(), "Multibinder was already initialized").     binder.bind(setKey).toProvider(this). }
false;public;0;6;;@Override public LinkedBindingBuilder<T> addBinding() {     checkConfiguration(!isInitialized(), "Multibinder was already initialized").     return binder.bind(Key.get(elementType, new RealElement(setName))). }
true;public;1;16;/**  * Invoked by Guice at Injector-creation time to prepare providers for each  * element in this set. At this time the set's size is known, but its  * contents are only evaluated when get() is invoked.  */ ;/**  * Invoked by Guice at Injector-creation time to prepare providers for each  * element in this set. At this time the set's size is known, but its  * contents are only evaluated when get() is invoked.  */ @Inject public void initialize(Injector injector) {     providers = new ArrayList<>().     Set<Dependency<?>> dependencies = new HashSet<>().     for (Binding<?> entry : injector.findBindingsByType(elementType)) {         if (keyMatches(entry.getKey())) {             // protected by findBindingsByType()             @SuppressWarnings("unchecked")             Binding<T> binding = (Binding<T>) entry.             providers.add(binding.getProvider()).             dependencies.add(Dependency.get(binding.getKey())).         }     }     this.dependencies = unmodifiableSet(dependencies).     this.binder = null. }
false;private;1;5;;private boolean keyMatches(Key<?> key) {     return key.getTypeLiteral().equals(elementType) && key.getAnnotation() instanceof Element && ((Element) key.getAnnotation()).setName().equals(setName). }
false;private;0;3;;private boolean isInitialized() {     return binder == null. }
false;public;0;13;;@Override public Set<T> get() {     checkConfiguration(isInitialized(), "Multibinder is not initialized").     Set<T> result = new LinkedHashSet<>().     for (Provider<T> provider : providers) {         final T newValue = provider.get().         checkConfiguration(newValue != null, "Set injection failed due to null element").         checkConfiguration(result.add(newValue), "Set injection failed due to duplicated element \"%s\"", newValue).     }     return Collections.unmodifiableSet(result). }
false;;0;3;;String getSetName() {     return setName. }
false;;0;3;;Key<Set<T>> getSetKey() {     return setKey. }
false;public;0;4;;@Override public Set<Dependency<?>> getDependencies() {     return dependencies. }
false;public;1;5;;@Override public boolean equals(Object o) {     return o instanceof RealMultibinder && ((RealMultibinder<?>) o).setKey.equals(setKey). }
false;public;0;4;;@Override public int hashCode() {     return setKey.hashCode(). }
false;public;0;10;;@Override public String toString() {     return new StringBuilder().append(setName).append(setName.length() > 0 ? " " : "").append("Multibinder<").append(elementType).append(">").toString(). }
false;static;3;7;;static void checkConfiguration(boolean condition, String format, Object... args) {     if (condition) {         return.     }     throw new ConfigurationException(singleton(new Message(Errors.format(format, args)))). }
false;static;2;9;;static <T> T checkNotNull(T reference, String name) {     if (reference != null) {         return reference.     }     NullPointerException npe = new NullPointerException(name).     throw new ConfigurationException(singleton(new Message(emptyList(), npe))). }
