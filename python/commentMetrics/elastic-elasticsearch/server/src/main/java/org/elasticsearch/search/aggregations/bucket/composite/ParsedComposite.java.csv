commented;modifiers;parameterAmount;loc;comment;code
false;public,static;2;12;;public static ParsedComposite fromXContent(XContentParser parser, String name) throws IOException {     ParsedComposite aggregation = PARSER.parse(parser, null).     aggregation.setName(name).     if (aggregation.afterKey == null && aggregation.getBuckets().size() > 0) {         /**          * Previous versions (< 6.3) don't send <code>afterKey</code>          * in the response so we set it as the last returned buckets.          */         aggregation.setAfterKey(aggregation.getBuckets().get(aggregation.getBuckets().size() - 1).key).     }     return aggregation. }
false;public;0;4;;@Override public String getType() {     return CompositeAggregationBuilder.NAME. }
false;public;0;4;;@Override public List<ParsedBucket> getBuckets() {     return buckets. }
false;public;0;7;;@Override public Map<String, Object> afterKey() {     if (afterKey != null) {         return afterKey.     }     return buckets.size() > 0 ? buckets.get(buckets.size() - 1).getKey() : null. }
false;private;1;3;;private void setAfterKey(Map<String, Object> afterKey) {     this.afterKey = afterKey. }
false;protected;2;4;;@Override protected XContentBuilder doXContentBody(XContentBuilder builder, Params params) throws IOException {     return CompositeAggregation.toXContentFragment(this, builder, params). }
false;public;0;4;;@Override public String getKeyAsString() {     return key.toString(). }
false;public;0;4;;@Override public Map<String, Object> getKey() {     return key. }
false;;1;3;;void setKey(Map<String, Object> key) {     this.key = key. }
false;public,final;2;7;;@Override public final XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     /**      * See {@link CompositeAggregation#bucketToXContent}      */     throw new UnsupportedOperationException("not implemented"). }
false;static;1;4;;static ParsedComposite.ParsedBucket fromXContent(XContentParser parser) throws IOException {     return parseXContent(parser, false, ParsedBucket::new, (p, bucket) -> bucket.setKey(p.mapOrdered())). }
