commented;modifiers;parameterAmount;loc;comment;code
false;private,static;3;5;;private static int compare(BytesRef a, BytesRef b, int m) {     return a == null ? b == null ? 0 : -m : b == null ? m : a.compareTo(b). }
false;public;0;7;;@Override public ScoreMode scoreMode() {     if (valuesSource != null && valuesSource.needsScores()) {         return ScoreMode.COMPLETE.     }     return super.scoreMode(). }
false;protected;3;5;;@Override protected void doCollect(LeafBucketCollector sub, int doc, long bucket) throws IOException {     collectBucket(sub, doc, bucket). }
false;protected;3;4;;@Override protected void doCollect(LeafBucketCollector sub, int doc, long bucket) throws IOException {     collectBucket(sub, doc, bucket). }
false;protected;2;24;;@Override protected LeafBucketCollector getLeafCollector(LeafReaderContext ctx, LeafBucketCollector sub) throws IOException {     if (valuesSource == null) {         return LeafBucketCollector.NO_OP_COLLECTOR.     }     if (valuesSource instanceof ValuesSource.Bytes.WithOrdinals) {         SortedSetDocValues values = ((ValuesSource.Bytes.WithOrdinals) valuesSource).ordinalsValues(ctx).         return new SortedSetRangeLeafCollector(values, ranges, sub) {              @Override             protected void doCollect(LeafBucketCollector sub, int doc, long bucket) throws IOException {                 collectBucket(sub, doc, bucket).             }         }.     } else {         SortedBinaryDocValues values = valuesSource.bytesValues(ctx).         return new SortedBinaryRangeLeafCollector(values, ranges, sub) {              @Override             protected void doCollect(LeafBucketCollector sub, int doc, long bucket) throws IOException {                 collectBucket(sub, doc, bucket).             }         }.     } }
false;public;2;11;;@Override public void collect(int doc, long bucket) throws IOException {     if (values.advanceExact(doc)) {         int lo = 0.         for (long ord = values.nextOrd(). ord != SortedSetDocValues.NO_MORE_ORDS. ord = values.nextOrd()) {             lo = collect(doc, ord, bucket, lo).         }     } }
false;private;4;48;;private int collect(int doc, long ord, long bucket, int lowBound) throws IOException {     // all candidates are between these indexes     int lo = lowBound, hi = froms.length - 1.     int mid = (lo + hi) >>> 1.     while (lo <= hi) {         if (ord < froms[mid]) {             hi = mid - 1.         } else if (ord > maxTos[mid]) {             lo = mid + 1.         } else {             break.         }         mid = (lo + hi) >>> 1.     }     // no potential candidate     if (lo > hi)         return lo.     // binary search the lower bound     int startLo = lo, startHi = mid.     while (startLo <= startHi) {         final int startMid = (startLo + startHi) >>> 1.         if (ord > maxTos[startMid]) {             startLo = startMid + 1.         } else {             startHi = startMid - 1.         }     }     // binary search the upper bound     int endLo = mid, endHi = hi.     while (endLo <= endHi) {         final int endMid = (endLo + endHi) >>> 1.         if (ord < froms[endMid]) {             endHi = endMid - 1.         } else {             endLo = endMid + 1.         }     }     assert startLo == lowBound || ord > maxTos[startLo - 1].     assert endHi == froms.length - 1 || ord < froms[endHi + 1].     for (int i = startLo. i <= endHi. ++i) {         if (ord <= tos[i]) {             doCollect(sub, doc, bucket * froms.length + i).         }     }     return endHi + 1. }
false;protected,abstract;3;1;;protected abstract void doCollect(LeafBucketCollector sub, int doc, long bucket) throws IOException.
false;public;2;10;;@Override public void collect(int doc, long bucket) throws IOException {     if (values.advanceExact(doc)) {         final int valuesCount = values.docValueCount().         for (int i = 0, lo = 0. i < valuesCount. ++i) {             final BytesRef value = values.nextValue().             lo = collect(doc, value, bucket, lo).         }     } }
false;private;4;48;;private int collect(int doc, BytesRef value, long bucket, int lowBound) throws IOException {     // all candidates are between these indexes     int lo = lowBound, hi = ranges.length - 1.     int mid = (lo + hi) >>> 1.     while (lo <= hi) {         if (compare(value, ranges[mid].from, 1) < 0) {             hi = mid - 1.         } else if (compare(value, maxTos[mid], -1) >= 0) {             lo = mid + 1.         } else {             break.         }         mid = (lo + hi) >>> 1.     }     // no potential candidate     if (lo > hi)         return lo.     // binary search the lower bound     int startLo = lo, startHi = mid.     while (startLo <= startHi) {         final int startMid = (startLo + startHi) >>> 1.         if (compare(value, maxTos[startMid], -1) >= 0) {             startLo = startMid + 1.         } else {             startHi = startMid - 1.         }     }     // binary search the upper bound     int endLo = mid, endHi = hi.     while (endLo <= endHi) {         final int endMid = (endLo + endHi) >>> 1.         if (compare(value, ranges[endMid].from, 1) < 0) {             endHi = endMid - 1.         } else {             endLo = endMid + 1.         }     }     assert startLo == lowBound || compare(value, maxTos[startLo - 1], -1) >= 0.     assert endHi == ranges.length - 1 || compare(value, ranges[endHi + 1].from, 1) < 0.     for (int i = startLo. i <= endHi. ++i) {         if (compare(value, ranges[i].to, -1) < 0) {             doCollect(sub, doc, bucket * ranges.length + i).         }     }     return endHi + 1. }
false;protected,abstract;3;1;;protected abstract void doCollect(LeafBucketCollector sub, int doc, long bucket) throws IOException.
false;public;1;12;;@Override public InternalAggregation buildAggregation(long bucket) throws IOException {     consumeBucketsAndMaybeBreak(ranges.length).     List<InternalBinaryRange.Bucket> buckets = new ArrayList<>(ranges.length).     for (int i = 0. i < ranges.length. ++i) {         long bucketOrd = bucket * ranges.length + i.         buckets.add(new InternalBinaryRange.Bucket(format, keyed, ranges[i].key, ranges[i].from, ranges[i].to, bucketDocCount(bucketOrd), bucketAggregations(bucketOrd))).     }     return new InternalBinaryRange(name, format, keyed, buckets, pipelineAggregators(), metaData()). }
false;public;0;4;;@Override public InternalAggregation buildEmptyAggregation() {     return new InternalBinaryRange(name, format, keyed, emptyList(), pipelineAggregators(), metaData()). }
