commented;modifiers;parameterAmount;loc;comment;code
false;public;0;19;;@Override public ActionRequestValidationException validate() {     ActionRequestValidationException validationException = null.     if (type == null) {         validationException = addValidationError("mapping type is missing", validationException).     } else if (type.isEmpty()) {         validationException = addValidationError("mapping type is empty", validationException).     }     if (source == null) {         validationException = addValidationError("mapping source is missing", validationException).     } else if (source.isEmpty()) {         validationException = addValidationError("mapping source is empty", validationException).     }     if (concreteIndex != null && (indices != null && indices.length > 0)) {         validationException = addValidationError("either concrete index or unresolved indices can be set, concrete index: [" + concreteIndex + "] and indices: " + Arrays.asList(indices), validationException).     }     return validationException. }
true;public;1;5;/**  * Sets the indices this put mapping operation will execute on.  */ ;/**  * Sets the indices this put mapping operation will execute on.  */ @Override public PutMappingRequest indices(String... indices) {     this.indices = indices.     return this. }
true;public;1;5;/**  * Sets a concrete index for this put mapping request.  */ ;/**  * Sets a concrete index for this put mapping request.  */ public PutMappingRequest setConcreteIndex(Index index) {     Objects.requireNonNull(indices, "index must not be null").     this.concreteIndex = index.     return this. }
true;public;0;3;/**  * Returns a concrete index for this mapping or <code>null</code> if no concrete index is defined  */ ;/**  * Returns a concrete index for this mapping or <code>null</code> if no concrete index is defined  */ public Index getConcreteIndex() {     return concreteIndex. }
true;public;0;4;/**  * The indices the mappings will be put.  */ ;/**  * The indices the mappings will be put.  */ @Override public String[] indices() {     return indices. }
false;public;0;4;;@Override public IndicesOptions indicesOptions() {     return indicesOptions. }
false;public;1;4;;public PutMappingRequest indicesOptions(IndicesOptions indicesOptions) {     this.indicesOptions = indicesOptions.     return this. }
true;public;0;3;/**  * The mapping type.  */ ;/**  * The mapping type.  */ public String type() {     return type. }
true;public;1;4;/**  * The type of the mappings.  */ ;/**  * The type of the mappings.  */ public PutMappingRequest type(String type) {     this.type = type.     return this. }
true;public;0;3;/**  * The mapping source definition.  */ ;/**  * The mapping source definition.  */ public String source() {     return source. }
true;public;1;3;/**  * A specialized simplified mapping source method, takes the form of simple properties definition:  * ("field1", "type=string,store=true").  *  * Also supports metadata mapping fields such as `_all` and `_parent` as property definition, these metadata  * mapping fields will automatically be put on the top level mapping object.  */ ;/**  * A specialized simplified mapping source method, takes the form of simple properties definition:  * ("field1", "type=string,store=true").  *  * Also supports metadata mapping fields such as `_all` and `_parent` as property definition, these metadata  * mapping fields will automatically be put on the top level mapping object.  */ public PutMappingRequest source(Object... source) {     return source(buildFromSimplifiedDef(type, source)). }
false;public;0;3;;public String origin() {     return origin. }
false;public;1;5;;public PutMappingRequest origin(String origin) {     // reserve "null" for bwc.     this.origin = Objects.requireNonNull(origin).     return this. }
true;public,static;2;55;/**  * @param type  *            the mapping type  * @param source  *            consisting of field/properties pairs (e.g. "field1",  *            "type=string,store=true")  * @throws IllegalArgumentException  *             if the number of the source arguments is not divisible by two  * @return the mappings definition  */ ;/**  * @param type  *            the mapping type  * @param source  *            consisting of field/properties pairs (e.g. "field1",  *            "type=string,store=true")  * @throws IllegalArgumentException  *             if the number of the source arguments is not divisible by two  * @return the mappings definition  */ public static XContentBuilder buildFromSimplifiedDef(String type, Object... source) {     if (source.length % 2 != 0) {         throw new IllegalArgumentException("mapping source must be pairs of fieldnames and properties definition.").     }     try {         XContentBuilder builder = XContentFactory.jsonBuilder().         builder.startObject().         if (type != null) {             builder.startObject(type).         }         for (int i = 0. i < source.length. i++) {             String fieldName = source[i++].toString().             if (RESERVED_FIELDS.contains(fieldName)) {                 builder.startObject(fieldName).                 String[] s1 = Strings.splitStringByCommaToArray(source[i].toString()).                 for (String s : s1) {                     String[] s2 = Strings.split(s, "=").                     if (s2.length != 2) {                         throw new IllegalArgumentException("malformed " + s).                     }                     builder.field(s2[0], s2[1]).                 }                 builder.endObject().             }         }         builder.startObject("properties").         for (int i = 0. i < source.length. i++) {             String fieldName = source[i++].toString().             if (RESERVED_FIELDS.contains(fieldName)) {                 continue.             }             builder.startObject(fieldName).             String[] s1 = Strings.splitStringByCommaToArray(source[i].toString()).             for (String s : s1) {                 String[] s2 = Strings.split(s, "=").                 if (s2.length != 2) {                     throw new IllegalArgumentException("malformed " + s).                 }                 builder.field(s2[0], s2[1]).             }             builder.endObject().         }         builder.endObject().         if (type != null) {             builder.endObject().         }         builder.endObject().         return builder.     } catch (Exception e) {         throw new IllegalArgumentException("failed to generate simplified mapping definition", e).     } }
true;public;1;3;/**  * The mapping source definition.  */ ;/**  * The mapping source definition.  */ public PutMappingRequest source(XContentBuilder mappingBuilder) {     return source(BytesReference.bytes(mappingBuilder), mappingBuilder.contentType()). }
true;public;1;9;/**  * The mapping source definition.  */ ;/**  * The mapping source definition.  */ public PutMappingRequest source(Map<String, ?> mappingSource) {     try {         XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON).         builder.map(mappingSource).         return source(BytesReference.bytes(builder), builder.contentType()).     } catch (IOException e) {         throw new ElasticsearchGenerationException("Failed to generate [" + mappingSource + "]", e).     } }
true;public;2;3;/**  * The mapping source definition.  */ ;/**  * The mapping source definition.  */ public PutMappingRequest source(String mappingSource, XContentType xContentType) {     return source(new BytesArray(mappingSource), xContentType). }
true;public;2;9;/**  * The mapping source definition.  */ ;/**  * The mapping source definition.  */ public PutMappingRequest source(BytesReference mappingSource, XContentType xContentType) {     Objects.requireNonNull(xContentType).     try {         this.source = XContentHelper.convertToJson(mappingSource, false, false, xContentType).         return this.     } catch (IOException e) {         throw new UncheckedIOException("failed to convert source to json", e).     } }
false;public;1;17;;@Override public void readFrom(StreamInput in) throws IOException {     super.readFrom(in).     indices = in.readStringArray().     indicesOptions = IndicesOptions.readIndicesOptions(in).     type = in.readOptionalString().     source = in.readString().     if (in.getVersion().before(Version.V_7_0_0)) {         // updateAllTypes         in.readBoolean().     }     concreteIndex = in.readOptionalWriteable(Index::new).     if (in.getVersion().onOrAfter(Version.V_6_7_0)) {         origin = in.readOptionalString().     } else {         origin = null.     } }
false;public;1;15;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeStringArrayNullable(indices).     indicesOptions.writeIndicesOptions(out).     out.writeOptionalString(type).     out.writeString(source).     if (out.getVersion().before(Version.V_7_0_0)) {         // updateAllTypes         out.writeBoolean(true).     }     out.writeOptionalWriteable(concreteIndex).     if (out.getVersion().onOrAfter(Version.V_6_7_0)) {         out.writeOptionalString(origin).     } }
false;public;2;11;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     if (source != null) {         try (InputStream stream = new BytesArray(source).streamInput()) {             builder.rawValue(stream, XContentType.JSON).         }     } else {         builder.startObject().endObject().     }     return builder. }
