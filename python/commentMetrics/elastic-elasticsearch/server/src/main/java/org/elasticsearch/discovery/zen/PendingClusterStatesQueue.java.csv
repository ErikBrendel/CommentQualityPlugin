commented;modifiers;parameterAmount;loc;comment;code
false;;0;1;;void onNewClusterStateProcessed().
false;;1;1;;void onNewClusterStateFailed(Exception e).
true;public,synchronized;1;11;/**  * Add an incoming, not yet committed cluster state  */ ;/**  * Add an incoming, not yet committed cluster state  */ public synchronized void addPending(ClusterState state) {     pendingStates.add(new ClusterStateContext(state)).     if (pendingStates.size() > maxQueueSize) {         ClusterStateContext context = pendingStates.remove(0).         logger.warn("dropping pending state [{}]. more than [{}] pending states.", context, maxQueueSize).         if (context.committed()) {             context.listener.onNewClusterStateFailed(new ElasticsearchException("too many pending states ([{}] pending)", maxQueueSize)).         }     } }
true;public,synchronized;2;15;/**  * Mark a previously added cluster state as committed. This will make it available via {@link #getNextClusterStateToProcess()}  * When the cluster state is processed (or failed), the supplied listener will be called  */ ;/**  * Mark a previously added cluster state as committed. This will make it available via {@link #getNextClusterStateToProcess()}  * When the cluster state is processed (or failed), the supplied listener will be called  */ public synchronized ClusterState markAsCommitted(String stateUUID, StateProcessedListener listener) {     final ClusterStateContext context = findState(stateUUID).     if (context == null) {         listener.onNewClusterStateFailed(new IllegalStateException("can't resolve cluster state with uuid" + " [" + stateUUID + "] to commit")).         return null.     }     if (context.committed()) {         listener.onNewClusterStateFailed(new IllegalStateException("cluster state with uuid" + " [" + stateUUID + "] is already committed")).         return null.     }     context.markAsCommitted(listener).     return context.state. }
true;public,synchronized;2;30;/**  * mark that the processing of the given state has failed. All committed states that are  * {@link ClusterState#supersedes(ClusterState)}-ed by this failed state, will be failed as well  */ ;/**  * mark that the processing of the given state has failed. All committed states that are  * {@link ClusterState#supersedes(ClusterState)}-ed by this failed state, will be failed as well  */ public synchronized void markAsFailed(ClusterState state, Exception reason) {     final ClusterStateContext failedContext = findState(state.stateUUID()).     if (failedContext == null) {         throw new IllegalArgumentException("can't resolve failed cluster state with uuid [" + state.stateUUID() + "], version [" + state.version() + "]").     }     if (failedContext.committed() == false) {         throw new IllegalArgumentException("failed cluster state is not committed " + state).     }     // fail all committed states which are batch together with the failed state     ArrayList<ClusterStateContext> statesToRemove = new ArrayList<>().     for (int index = 0. index < pendingStates.size(). index++) {         final ClusterStateContext pendingContext = pendingStates.get(index).         if (pendingContext.committed() == false) {             continue.         }         final ClusterState pendingState = pendingContext.state.         if (pendingContext.equals(failedContext)) {             statesToRemove.add(pendingContext).             pendingContext.listener.onNewClusterStateFailed(reason).         } else if (state.supersedes(pendingState)) {             statesToRemove.add(pendingContext).             logger.debug("failing committed state {} together with state {}", pendingContext, failedContext).             pendingContext.listener.onNewClusterStateFailed(reason).         }     }     pendingStates.removeAll(statesToRemove).     assert findState(state.stateUUID()) == null : "state was marked as processed but can still be found in pending list " + state. }
true;public,synchronized;1;49;/**  * indicates that a cluster state was successfully processed. Any committed state that is  * {@link ClusterState#supersedes(ClusterState)}-ed by the processed state will be marked as processed as well.  * <p>  * NOTE: successfully processing a state indicates we are following the master it came from. Any committed state  * from another master will be failed by this method  */ ;/**  * indicates that a cluster state was successfully processed. Any committed state that is  * {@link ClusterState#supersedes(ClusterState)}-ed by the processed state will be marked as processed as well.  * <p>  * NOTE: successfully processing a state indicates we are following the master it came from. Any committed state  * from another master will be failed by this method  */ public synchronized void markAsProcessed(ClusterState state) {     if (findState(state.stateUUID()) == null) {         throw new IllegalStateException("can't resolve processed cluster state with uuid [" + state.stateUUID() + "], version [" + state.version() + "]").     }     final DiscoveryNode currentMaster = state.nodes().getMasterNode().     assert currentMaster != null : "processed cluster state mast have a master. " + state.     // fail or remove any incoming state from a different master     // respond to any committed state from the same master with same or lower version (we processed a higher version)     ArrayList<ClusterStateContext> contextsToRemove = new ArrayList<>().     for (int index = 0. index < pendingStates.size(). index++) {         final ClusterStateContext pendingContext = pendingStates.get(index).         final ClusterState pendingState = pendingContext.state.         final DiscoveryNode pendingMasterNode = pendingState.nodes().getMasterNode().         if (Objects.equals(currentMaster, pendingMasterNode) == false) {             contextsToRemove.add(pendingContext).             if (pendingContext.committed()) {                 // this is a committed state , warn                 logger.warn("received a cluster state (uuid[{}]/v[{}]) from a different master than the current one," + " rejecting (received {}, current {})", pendingState.stateUUID(), pendingState.version(), pendingMasterNode, currentMaster).                 pendingContext.listener.onNewClusterStateFailed(new IllegalStateException("cluster state from a different master than the current one," + " rejecting (received " + pendingMasterNode + ", current " + currentMaster + ")")).             } else {                 logger.trace("removing non-committed state with uuid[{}]/v[{}] from [{}] - a state from" + " [{}] was successfully processed", pendingState.stateUUID(), pendingState.version(), pendingMasterNode, currentMaster).             }         } else if (pendingState.stateUUID().equals(state.stateUUID())) {             assert pendingContext.committed() : "processed cluster state is not committed " + state.             contextsToRemove.add(pendingContext).             pendingContext.listener.onNewClusterStateProcessed().         } else if (state.version() >= pendingState.version()) {             logger.trace("processing pending state uuid[{}]/v[{}] together with state uuid[{}]/v[{}]", pendingState.stateUUID(), pendingState.version(), state.stateUUID(), state.version()).             contextsToRemove.add(pendingContext).             if (pendingContext.committed()) {                 pendingContext.listener.onNewClusterStateProcessed().             }         }     }     // now ack the processed state     pendingStates.removeAll(contextsToRemove).     assert findState(state.stateUUID()) == null : "state was marked as processed but can still be found in pending list " + state. }
false;;1;9;;ClusterStateContext findState(String stateUUID) {     for (int i = 0. i < pendingStates.size(). i++) {         final ClusterStateContext context = pendingStates.get(i).         if (context.stateUUID().equals(stateUUID)) {             return context.         }     }     return null. }
true;public,synchronized;1;8;/**  * clear the incoming queue. any committed state will be failed  */ ;/**  * clear the incoming queue. any committed state will be failed  */ public synchronized void failAllStatesAndClear(Exception reason) {     for (ClusterStateContext pendingState : pendingStates) {         if (pendingState.committed()) {             pendingState.listener.onNewClusterStateFailed(reason).         }     }     pendingStates.clear(). }
true;public,synchronized;0;30;/**  * Gets the next committed state to process.  * <p>  * The method tries to batch operation by getting the cluster state the highest possible committed states  * which succeeds the first committed state in queue (i.e., it comes from the same master).  */ ;/**  * Gets the next committed state to process.  * <p>  * The method tries to batch operation by getting the cluster state the highest possible committed states  * which succeeds the first committed state in queue (i.e., it comes from the same master).  */ public synchronized ClusterState getNextClusterStateToProcess() {     if (pendingStates.isEmpty()) {         return null.     }     ClusterStateContext stateToProcess = null.     int index = 0.     for (. index < pendingStates.size(). index++) {         ClusterStateContext potentialState = pendingStates.get(index).         if (potentialState.committed()) {             stateToProcess = potentialState.             break.         }     }     if (stateToProcess == null) {         return null.     }     // now try to find the highest committed state from the same master     for (. index < pendingStates.size(). index++) {         ClusterStateContext potentialState = pendingStates.get(index).         if (potentialState.state.supersedes(stateToProcess.state) && potentialState.committed()) {             // we found a new one             stateToProcess = potentialState.         }     }     assert stateToProcess.committed() : "should only return committed cluster state. found " + stateToProcess.state.     return stateToProcess.state. }
true;public,synchronized;0;7;/**  * returns all pending states, committed or not  */ ;/**  * returns all pending states, committed or not  */ public synchronized ClusterState[] pendingClusterStates() {     ArrayList<ClusterState> states = new ArrayList<>().     for (ClusterStateContext context : pendingStates) {         states.add(context.state).     }     return states.toArray(new ClusterState[states.size()]). }
false;;1;6;;void markAsCommitted(StateProcessedListener listener) {     if (this.listener != null) {         throw new IllegalStateException(toString() + "is already committed").     }     this.listener = listener. }
false;;0;3;;boolean committed() {     return listener != null. }
false;public;0;3;;public String stateUUID() {     return state.stateUUID(). }
false;public;0;10;;@Override public String toString() {     return String.format(Locale.ROOT, "[uuid[%s], v[%d], m[%s]]", stateUUID(), state.version(), state.nodes().getMasterNodeId()). }
false;public,synchronized;0;12;;public synchronized PendingClusterStateStats stats() {     // calculate committed cluster state     int committed = 0.     for (ClusterStateContext clusterStatsContext : pendingStates) {         if (clusterStatsContext.committed()) {             committed += 1.         }     }     return new PendingClusterStateStats(pendingStates.size(), pendingStates.size() - committed, committed). }
