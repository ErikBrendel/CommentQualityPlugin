commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected String executor() {     return ThreadPool.Names.GENERIC. }
false;protected;0;4;;@Override protected GetSnapshotsResponse newResponse() {     return new GetSnapshotsResponse(). }
false;protected;2;4;;@Override protected ClusterBlockException checkBlock(GetSnapshotsRequest request, ClusterState state) {     return state.blocks().globalBlockedException(ClusterBlockLevel.METADATA_READ). }
false;protected;3;71;;@Override protected void masterOperation(final GetSnapshotsRequest request, final ClusterState state, final ActionListener<GetSnapshotsResponse> listener) {     try {         final String repository = request.repository().         final Map<String, SnapshotId> allSnapshotIds = new HashMap<>().         final List<SnapshotInfo> currentSnapshots = new ArrayList<>().         for (SnapshotInfo snapshotInfo : snapshotsService.currentSnapshots(repository)) {             SnapshotId snapshotId = snapshotInfo.snapshotId().             allSnapshotIds.put(snapshotId.getName(), snapshotId).             currentSnapshots.add(snapshotInfo).         }         final RepositoryData repositoryData.         if (isCurrentSnapshotsOnly(request.snapshots()) == false) {             repositoryData = snapshotsService.getRepositoryData(repository).             for (SnapshotId snapshotId : repositoryData.getAllSnapshotIds()) {                 allSnapshotIds.put(snapshotId.getName(), snapshotId).             }         } else {             repositoryData = null.         }         final Set<SnapshotId> toResolve = new HashSet<>().         if (isAllSnapshots(request.snapshots())) {             toResolve.addAll(allSnapshotIds.values()).         } else {             for (String snapshotOrPattern : request.snapshots()) {                 if (GetSnapshotsRequest.CURRENT_SNAPSHOT.equalsIgnoreCase(snapshotOrPattern)) {                     toResolve.addAll(currentSnapshots.stream().map(SnapshotInfo::snapshotId).collect(Collectors.toList())).                 } else if (Regex.isSimpleMatchPattern(snapshotOrPattern) == false) {                     if (allSnapshotIds.containsKey(snapshotOrPattern)) {                         toResolve.add(allSnapshotIds.get(snapshotOrPattern)).                     } else if (request.ignoreUnavailable() == false) {                         throw new SnapshotMissingException(repository, snapshotOrPattern).                     }                 } else {                     for (Map.Entry<String, SnapshotId> entry : allSnapshotIds.entrySet()) {                         if (Regex.simpleMatch(snapshotOrPattern, entry.getKey())) {                             toResolve.add(entry.getValue()).                         }                     }                 }             }             if (toResolve.isEmpty() && request.ignoreUnavailable() == false && isCurrentSnapshotsOnly(request.snapshots()) == false) {                 throw new SnapshotMissingException(repository, request.snapshots()[0]).             }         }         final List<SnapshotInfo> snapshotInfos.         if (request.verbose()) {             final Set<SnapshotId> incompatibleSnapshots = repositoryData != null ? new HashSet<>(repositoryData.getIncompatibleSnapshotIds()) : Collections.emptySet().             snapshotInfos = snapshotsService.snapshots(repository, new ArrayList<>(toResolve), incompatibleSnapshots, request.ignoreUnavailable()).         } else {             if (repositoryData != null) {                 // want non-current snapshots as well, which are found in the repository data                 snapshotInfos = buildSimpleSnapshotInfos(toResolve, repositoryData, currentSnapshots).             } else {                 // only want current snapshots                 snapshotInfos = currentSnapshots.stream().map(SnapshotInfo::basic).collect(Collectors.toList()).                 CollectionUtil.timSort(snapshotInfos).             }         }         listener.onResponse(new GetSnapshotsResponse(snapshotInfos)).     } catch (Exception e) {         listener.onFailure(e).     } }
false;private;1;3;;private boolean isAllSnapshots(String[] snapshots) {     return (snapshots.length == 0) || (snapshots.length == 1 && GetSnapshotsRequest.ALL_SNAPSHOTS.equalsIgnoreCase(snapshots[0])). }
false;private;1;3;;private boolean isCurrentSnapshotsOnly(String[] snapshots) {     return (snapshots.length == 1 && GetSnapshotsRequest.CURRENT_SNAPSHOT.equalsIgnoreCase(snapshots[0])). }
false;private;3;27;;private List<SnapshotInfo> buildSimpleSnapshotInfos(final Set<SnapshotId> toResolve, final RepositoryData repositoryData, final List<SnapshotInfo> currentSnapshots) {     List<SnapshotInfo> snapshotInfos = new ArrayList<>().     for (SnapshotInfo snapshotInfo : currentSnapshots) {         if (toResolve.remove(snapshotInfo.snapshotId())) {             snapshotInfos.add(snapshotInfo.basic()).         }     }     Map<SnapshotId, List<String>> snapshotsToIndices = new HashMap<>().     for (IndexId indexId : repositoryData.getIndices().values()) {         for (SnapshotId snapshotId : repositoryData.getSnapshots(indexId)) {             if (toResolve.contains(snapshotId)) {                 snapshotsToIndices.computeIfAbsent(snapshotId, (k) -> new ArrayList<>()).add(indexId.getName()).             }         }     }     for (Map.Entry<SnapshotId, List<String>> entry : snapshotsToIndices.entrySet()) {         final List<String> indices = entry.getValue().         CollectionUtil.timSort(indices).         final SnapshotId snapshotId = entry.getKey().         snapshotInfos.add(new SnapshotInfo(snapshotId, indices, repositoryData.getSnapshotState(snapshotId))).     }     CollectionUtil.timSort(snapshotInfos).     return Collections.unmodifiableList(snapshotInfos). }
