# id;timestamp;commentText;codeText;commentWords;codeWords
RepositoryData -> public RepositoryData removeSnapshot(final SnapshotId snapshotId);1524684173;Remove a snapshot and remove any indices that no longer exist in the repository due to the deletion of the snapshot.;public RepositoryData removeSnapshot(final SnapshotId snapshotId) {_        Map<String, SnapshotId> newSnapshotIds = snapshotIds.values().stream()_            .filter(id -> !snapshotId.equals(id))_            .collect(Collectors.toMap(SnapshotId::getUUID, Function.identity()))__        if (newSnapshotIds.size() == snapshotIds.size()) {_            throw new ResourceNotFoundException("Attempting to remove non-existent snapshot [{}] from repository data", snapshotId)__        }_        Map<String, SnapshotState> newSnapshotStates = new HashMap<>(snapshotStates)__        newSnapshotStates.remove(snapshotId.getUUID())__        Map<IndexId, Set<SnapshotId>> indexSnapshots = new HashMap<>()__        for (final IndexId indexId : indices.values()) {_            Set<SnapshotId> set__            Set<SnapshotId> snapshotIds = this.indexSnapshots.get(indexId)__            assert snapshotIds != null__            if (snapshotIds.contains(snapshotId)) {_                if (snapshotIds.size() == 1) {_                    _                    _                    continue__                }_                set = new LinkedHashSet<>(snapshotIds)__                set.remove(snapshotId)__            } else {_                set = snapshotIds__            }_            indexSnapshots.put(indexId, set)__        }__        return new RepositoryData(genId, newSnapshotIds, newSnapshotStates, indexSnapshots, incompatibleSnapshotIds)__    };remove,a,snapshot,and,remove,any,indices,that,no,longer,exist,in,the,repository,due,to,the,deletion,of,the,snapshot;public,repository,data,remove,snapshot,final,snapshot,id,snapshot,id,map,string,snapshot,id,new,snapshot,ids,snapshot,ids,values,stream,filter,id,snapshot,id,equals,id,collect,collectors,to,map,snapshot,id,get,uuid,function,identity,if,new,snapshot,ids,size,snapshot,ids,size,throw,new,resource,not,found,exception,attempting,to,remove,non,existent,snapshot,from,repository,data,snapshot,id,map,string,snapshot,state,new,snapshot,states,new,hash,map,snapshot,states,new,snapshot,states,remove,snapshot,id,get,uuid,map,index,id,set,snapshot,id,index,snapshots,new,hash,map,for,final,index,id,index,id,indices,values,set,snapshot,id,set,set,snapshot,id,snapshot,ids,this,index,snapshots,get,index,id,assert,snapshot,ids,null,if,snapshot,ids,contains,snapshot,id,if,snapshot,ids,size,1,continue,set,new,linked,hash,set,snapshot,ids,set,remove,snapshot,id,else,set,snapshot,ids,index,snapshots,put,index,id,set,return,new,repository,data,gen,id,new,snapshot,ids,new,snapshot,states,index,snapshots,incompatible,snapshot,ids
RepositoryData -> public RepositoryData removeSnapshot(final SnapshotId snapshotId);1524839522;Remove a snapshot and remove any indices that no longer exist in the repository due to the deletion of the snapshot.;public RepositoryData removeSnapshot(final SnapshotId snapshotId) {_        Map<String, SnapshotId> newSnapshotIds = snapshotIds.values().stream()_            .filter(id -> !snapshotId.equals(id))_            .collect(Collectors.toMap(SnapshotId::getUUID, Function.identity()))__        if (newSnapshotIds.size() == snapshotIds.size()) {_            throw new ResourceNotFoundException("Attempting to remove non-existent snapshot [{}] from repository data", snapshotId)__        }_        Map<String, SnapshotState> newSnapshotStates = new HashMap<>(snapshotStates)__        newSnapshotStates.remove(snapshotId.getUUID())__        Map<IndexId, Set<SnapshotId>> indexSnapshots = new HashMap<>()__        for (final IndexId indexId : indices.values()) {_            Set<SnapshotId> set__            Set<SnapshotId> snapshotIds = this.indexSnapshots.get(indexId)__            assert snapshotIds != null__            if (snapshotIds.contains(snapshotId)) {_                if (snapshotIds.size() == 1) {_                    _                    _                    continue__                }_                set = new LinkedHashSet<>(snapshotIds)__                set.remove(snapshotId)__            } else {_                set = snapshotIds__            }_            indexSnapshots.put(indexId, set)__        }__        return new RepositoryData(genId, newSnapshotIds, newSnapshotStates, indexSnapshots, incompatibleSnapshotIds)__    };remove,a,snapshot,and,remove,any,indices,that,no,longer,exist,in,the,repository,due,to,the,deletion,of,the,snapshot;public,repository,data,remove,snapshot,final,snapshot,id,snapshot,id,map,string,snapshot,id,new,snapshot,ids,snapshot,ids,values,stream,filter,id,snapshot,id,equals,id,collect,collectors,to,map,snapshot,id,get,uuid,function,identity,if,new,snapshot,ids,size,snapshot,ids,size,throw,new,resource,not,found,exception,attempting,to,remove,non,existent,snapshot,from,repository,data,snapshot,id,map,string,snapshot,state,new,snapshot,states,new,hash,map,snapshot,states,new,snapshot,states,remove,snapshot,id,get,uuid,map,index,id,set,snapshot,id,index,snapshots,new,hash,map,for,final,index,id,index,id,indices,values,set,snapshot,id,set,set,snapshot,id,snapshot,ids,this,index,snapshots,get,index,id,assert,snapshot,ids,null,if,snapshot,ids,contains,snapshot,id,if,snapshot,ids,size,1,continue,set,new,linked,hash,set,snapshot,ids,set,remove,snapshot,id,else,set,snapshot,ids,index,snapshots,put,index,id,set,return,new,repository,data,gen,id,new,snapshot,ids,new,snapshot,states,index,snapshots,incompatible,snapshot,ids
RepositoryData -> public RepositoryData removeSnapshot(final SnapshotId snapshotId);1532353780;Remove a snapshot and remove any indices that no longer exist in the repository due to the deletion of the snapshot.;public RepositoryData removeSnapshot(final SnapshotId snapshotId) {_        Map<String, SnapshotId> newSnapshotIds = snapshotIds.values().stream()_            .filter(id -> !snapshotId.equals(id))_            .collect(Collectors.toMap(SnapshotId::getUUID, Function.identity()))__        if (newSnapshotIds.size() == snapshotIds.size()) {_            throw new ResourceNotFoundException("Attempting to remove non-existent snapshot [{}] from repository data", snapshotId)__        }_        Map<String, SnapshotState> newSnapshotStates = new HashMap<>(snapshotStates)__        newSnapshotStates.remove(snapshotId.getUUID())__        Map<IndexId, Set<SnapshotId>> indexSnapshots = new HashMap<>()__        for (final IndexId indexId : indices.values()) {_            Set<SnapshotId> set__            Set<SnapshotId> snapshotIds = this.indexSnapshots.get(indexId)__            assert snapshotIds != null__            if (snapshotIds.contains(snapshotId)) {_                if (snapshotIds.size() == 1) {_                    _                    _                    continue__                }_                set = new LinkedHashSet<>(snapshotIds)__                set.remove(snapshotId)__            } else {_                set = snapshotIds__            }_            indexSnapshots.put(indexId, set)__        }__        return new RepositoryData(genId, newSnapshotIds, newSnapshotStates, indexSnapshots, incompatibleSnapshotIds)__    };remove,a,snapshot,and,remove,any,indices,that,no,longer,exist,in,the,repository,due,to,the,deletion,of,the,snapshot;public,repository,data,remove,snapshot,final,snapshot,id,snapshot,id,map,string,snapshot,id,new,snapshot,ids,snapshot,ids,values,stream,filter,id,snapshot,id,equals,id,collect,collectors,to,map,snapshot,id,get,uuid,function,identity,if,new,snapshot,ids,size,snapshot,ids,size,throw,new,resource,not,found,exception,attempting,to,remove,non,existent,snapshot,from,repository,data,snapshot,id,map,string,snapshot,state,new,snapshot,states,new,hash,map,snapshot,states,new,snapshot,states,remove,snapshot,id,get,uuid,map,index,id,set,snapshot,id,index,snapshots,new,hash,map,for,final,index,id,index,id,indices,values,set,snapshot,id,set,set,snapshot,id,snapshot,ids,this,index,snapshots,get,index,id,assert,snapshot,ids,null,if,snapshot,ids,contains,snapshot,id,if,snapshot,ids,size,1,continue,set,new,linked,hash,set,snapshot,ids,set,remove,snapshot,id,else,set,snapshot,ids,index,snapshots,put,index,id,set,return,new,repository,data,gen,id,new,snapshot,ids,new,snapshot,states,index,snapshots,incompatible,snapshot,ids
RepositoryData -> public IndexId resolveIndexId(final String indexName);1524684173;Resolve the index name to the index id specific to the repository,_throwing an exception if the index could not be resolved.;public IndexId resolveIndexId(final String indexName) {_        if (indices.containsKey(indexName)) {_            return indices.get(indexName)__        } else {_            _            _            _            _            return new IndexId(indexName, indexName)__        }_    };resolve,the,index,name,to,the,index,id,specific,to,the,repository,throwing,an,exception,if,the,index,could,not,be,resolved;public,index,id,resolve,index,id,final,string,index,name,if,indices,contains,key,index,name,return,indices,get,index,name,else,return,new,index,id,index,name,index,name
RepositoryData -> public IndexId resolveIndexId(final String indexName);1524839522;Resolve the index name to the index id specific to the repository,_throwing an exception if the index could not be resolved.;public IndexId resolveIndexId(final String indexName) {_        if (indices.containsKey(indexName)) {_            return indices.get(indexName)__        } else {_            _            _            _            _            return new IndexId(indexName, indexName)__        }_    };resolve,the,index,name,to,the,index,id,specific,to,the,repository,throwing,an,exception,if,the,index,could,not,be,resolved;public,index,id,resolve,index,id,final,string,index,name,if,indices,contains,key,index,name,return,indices,get,index,name,else,return,new,index,id,index,name,index,name
RepositoryData -> public IndexId resolveIndexId(final String indexName);1532353780;Resolve the index name to the index id specific to the repository,_throwing an exception if the index could not be resolved.;public IndexId resolveIndexId(final String indexName) {_        if (indices.containsKey(indexName)) {_            return indices.get(indexName)__        } else {_            _            _            _            _            return new IndexId(indexName, indexName)__        }_    };resolve,the,index,name,to,the,index,id,specific,to,the,repository,throwing,an,exception,if,the,index,could,not,be,resolved;public,index,id,resolve,index,id,final,string,index,name,if,indices,contains,key,index,name,return,indices,get,index,name,else,return,new,index,id,index,name,index,name
RepositoryData -> public Collection<SnapshotId> getAllSnapshotIds();1524684173;Returns an immutable collection of all the snapshot ids in the repository, both active and_incompatible snapshots.;public Collection<SnapshotId> getAllSnapshotIds() {_        List<SnapshotId> allSnapshotIds = new ArrayList<>(snapshotIds.size() + incompatibleSnapshotIds.size())__        allSnapshotIds.addAll(snapshotIds.values())__        allSnapshotIds.addAll(incompatibleSnapshotIds)__        return Collections.unmodifiableList(allSnapshotIds)__    };returns,an,immutable,collection,of,all,the,snapshot,ids,in,the,repository,both,active,and,incompatible,snapshots;public,collection,snapshot,id,get,all,snapshot,ids,list,snapshot,id,all,snapshot,ids,new,array,list,snapshot,ids,size,incompatible,snapshot,ids,size,all,snapshot,ids,add,all,snapshot,ids,values,all,snapshot,ids,add,all,incompatible,snapshot,ids,return,collections,unmodifiable,list,all,snapshot,ids
RepositoryData -> public Collection<SnapshotId> getAllSnapshotIds();1524839522;Returns an immutable collection of all the snapshot ids in the repository, both active and_incompatible snapshots.;public Collection<SnapshotId> getAllSnapshotIds() {_        List<SnapshotId> allSnapshotIds = new ArrayList<>(snapshotIds.size() + incompatibleSnapshotIds.size())__        allSnapshotIds.addAll(snapshotIds.values())__        allSnapshotIds.addAll(incompatibleSnapshotIds)__        return Collections.unmodifiableList(allSnapshotIds)__    };returns,an,immutable,collection,of,all,the,snapshot,ids,in,the,repository,both,active,and,incompatible,snapshots;public,collection,snapshot,id,get,all,snapshot,ids,list,snapshot,id,all,snapshot,ids,new,array,list,snapshot,ids,size,incompatible,snapshot,ids,size,all,snapshot,ids,add,all,snapshot,ids,values,all,snapshot,ids,add,all,incompatible,snapshot,ids,return,collections,unmodifiable,list,all,snapshot,ids
RepositoryData -> public Collection<SnapshotId> getAllSnapshotIds();1532353780;Returns an immutable collection of all the snapshot ids in the repository, both active and_incompatible snapshots.;public Collection<SnapshotId> getAllSnapshotIds() {_        List<SnapshotId> allSnapshotIds = new ArrayList<>(snapshotIds.size() + incompatibleSnapshotIds.size())__        allSnapshotIds.addAll(snapshotIds.values())__        allSnapshotIds.addAll(incompatibleSnapshotIds)__        return Collections.unmodifiableList(allSnapshotIds)__    };returns,an,immutable,collection,of,all,the,snapshot,ids,in,the,repository,both,active,and,incompatible,snapshots;public,collection,snapshot,id,get,all,snapshot,ids,list,snapshot,id,all,snapshot,ids,new,array,list,snapshot,ids,size,incompatible,snapshot,ids,size,all,snapshot,ids,add,all,snapshot,ids,values,all,snapshot,ids,add,all,incompatible,snapshot,ids,return,collections,unmodifiable,list,all,snapshot,ids
RepositoryData -> public XContentBuilder incompatibleSnapshotsToXContent(final XContentBuilder builder, final ToXContent.Params params)         throws IOException;1524684173;Writes the incompatible snapshot ids to x-content.;public XContentBuilder incompatibleSnapshotsToXContent(final XContentBuilder builder, final ToXContent.Params params)_        throws IOException {__        builder.startObject()__        _        builder.startArray(INCOMPATIBLE_SNAPSHOTS)__        for (final SnapshotId snapshot : getIncompatibleSnapshotIds()) {_            snapshot.toXContent(builder, params)__        }_        builder.endArray()__        builder.endObject()__        return builder__    };writes,the,incompatible,snapshot,ids,to,x,content;public,xcontent,builder,incompatible,snapshots,to,xcontent,final,xcontent,builder,builder,final,to,xcontent,params,params,throws,ioexception,builder,start,object,builder,start,array,for,final,snapshot,id,snapshot,get,incompatible,snapshot,ids,snapshot,to,xcontent,builder,params,builder,end,array,builder,end,object,return,builder
RepositoryData -> public XContentBuilder incompatibleSnapshotsToXContent(final XContentBuilder builder, final ToXContent.Params params)         throws IOException;1524839522;Writes the incompatible snapshot ids to x-content.;public XContentBuilder incompatibleSnapshotsToXContent(final XContentBuilder builder, final ToXContent.Params params)_        throws IOException {__        builder.startObject()__        _        builder.startArray(INCOMPATIBLE_SNAPSHOTS)__        for (final SnapshotId snapshot : getIncompatibleSnapshotIds()) {_            snapshot.toXContent(builder, params)__        }_        builder.endArray()__        builder.endObject()__        return builder__    };writes,the,incompatible,snapshot,ids,to,x,content;public,xcontent,builder,incompatible,snapshots,to,xcontent,final,xcontent,builder,builder,final,to,xcontent,params,params,throws,ioexception,builder,start,object,builder,start,array,for,final,snapshot,id,snapshot,get,incompatible,snapshot,ids,snapshot,to,xcontent,builder,params,builder,end,array,builder,end,object,return,builder
RepositoryData -> public XContentBuilder incompatibleSnapshotsToXContent(final XContentBuilder builder, final ToXContent.Params params)         throws IOException;1532353780;Writes the incompatible snapshot ids to x-content.;public XContentBuilder incompatibleSnapshotsToXContent(final XContentBuilder builder, final ToXContent.Params params)_        throws IOException {__        builder.startObject()__        _        builder.startArray(INCOMPATIBLE_SNAPSHOTS)__        for (final SnapshotId snapshot : getIncompatibleSnapshotIds()) {_            snapshot.toXContent(builder, params)__        }_        builder.endArray()__        builder.endObject()__        return builder__    };writes,the,incompatible,snapshot,ids,to,x,content;public,xcontent,builder,incompatible,snapshots,to,xcontent,final,xcontent,builder,builder,final,to,xcontent,params,params,throws,ioexception,builder,start,object,builder,start,array,for,final,snapshot,id,snapshot,get,incompatible,snapshot,ids,snapshot,to,xcontent,builder,params,builder,end,array,builder,end,object,return,builder
RepositoryData -> public Collection<SnapshotId> getIncompatibleSnapshotIds();1524684173;Returns an immutable collection of the snapshot ids in the repository that are incompatible with the_current ES version.;public Collection<SnapshotId> getIncompatibleSnapshotIds() {_        return incompatibleSnapshotIds__    };returns,an,immutable,collection,of,the,snapshot,ids,in,the,repository,that,are,incompatible,with,the,current,es,version;public,collection,snapshot,id,get,incompatible,snapshot,ids,return,incompatible,snapshot,ids
RepositoryData -> public Collection<SnapshotId> getIncompatibleSnapshotIds();1524839522;Returns an immutable collection of the snapshot ids in the repository that are incompatible with the_current ES version.;public Collection<SnapshotId> getIncompatibleSnapshotIds() {_        return incompatibleSnapshotIds__    };returns,an,immutable,collection,of,the,snapshot,ids,in,the,repository,that,are,incompatible,with,the,current,es,version;public,collection,snapshot,id,get,incompatible,snapshot,ids,return,incompatible,snapshot,ids
RepositoryData -> public Collection<SnapshotId> getIncompatibleSnapshotIds();1532353780;Returns an immutable collection of the snapshot ids in the repository that are incompatible with the_current ES version.;public Collection<SnapshotId> getIncompatibleSnapshotIds() {_        return incompatibleSnapshotIds__    };returns,an,immutable,collection,of,the,snapshot,ids,in,the,repository,that,are,incompatible,with,the,current,es,version;public,collection,snapshot,id,get,incompatible,snapshot,ids,return,incompatible,snapshot,ids
RepositoryData -> public long getGenId();1524684173;Gets the generational index file id from which this instance was read.;public long getGenId() {_        return genId__    };gets,the,generational,index,file,id,from,which,this,instance,was,read;public,long,get,gen,id,return,gen,id
RepositoryData -> public long getGenId();1524839522;Gets the generational index file id from which this instance was read.;public long getGenId() {_        return genId__    };gets,the,generational,index,file,id,from,which,this,instance,was,read;public,long,get,gen,id,return,gen,id
RepositoryData -> public long getGenId();1532353780;Gets the generational index file id from which this instance was read.;public long getGenId() {_        return genId__    };gets,the,generational,index,file,id,from,which,this,instance,was,read;public,long,get,gen,id,return,gen,id
RepositoryData -> public static RepositoryData snapshotsFromXContent(final XContentParser parser, long genId) throws IOException;1524684173;Reads an instance of {@link RepositoryData} from x-content, loading the snapshots and indices metadata.;public static RepositoryData snapshotsFromXContent(final XContentParser parser, long genId) throws IOException {_        Map<String, SnapshotId> snapshots = new HashMap<>()__        Map<String, SnapshotState> snapshotStates = new HashMap<>()__        Map<IndexId, Set<SnapshotId>> indexSnapshots = new HashMap<>()__        if (parser.nextToken() == XContentParser.Token.START_OBJECT) {_            while (parser.nextToken() == XContentParser.Token.FIELD_NAME) {_                String field = parser.currentName()__                if (SNAPSHOTS.equals(field)) {_                    if (parser.nextToken() == XContentParser.Token.START_ARRAY) {_                        while (parser.nextToken() != XContentParser.Token.END_ARRAY) {_                            final SnapshotId snapshotId__                            _                            if (parser.currentToken() == XContentParser.Token.START_OBJECT) {_                                String name = null__                                String uuid = null__                                SnapshotState state = null__                                while (parser.nextToken() != XContentParser.Token.END_OBJECT) {_                                    String currentFieldName = parser.currentName()__                                    parser.nextToken()__                                    if (NAME.equals(currentFieldName)) {_                                        name = parser.text()__                                    } else if (UUID.equals(currentFieldName)) {_                                        uuid = parser.text()__                                    } else if (STATE.equals(currentFieldName)) {_                                        state = SnapshotState.fromValue(parser.numberValue().byteValue())__                                    }_                                }_                                snapshotId = new SnapshotId(name, uuid)__                                if (state != null) {_                                    snapshotStates.put(uuid, state)__                                }_                            } else {_                                _                                final String name = parser.text()__                                snapshotId = new SnapshotId(name, name)__                            }_                            snapshots.put(snapshotId.getUUID(), snapshotId)__                        }_                    } else {_                        throw new ElasticsearchParseException("expected array for [" + field + "]")__                    }_                } else if (INDICES.equals(field)) {_                    if (parser.nextToken() != XContentParser.Token.START_OBJECT) {_                        throw new ElasticsearchParseException("start object expected [indices]")__                    }_                    while (parser.nextToken() != XContentParser.Token.END_OBJECT) {_                        String indexName = parser.currentName()__                        String indexId = null__                        Set<SnapshotId> snapshotIds = new LinkedHashSet<>()__                        if (parser.nextToken() != XContentParser.Token.START_OBJECT) {_                            throw new ElasticsearchParseException("start object expected index[" + indexName + "]")__                        }_                        while (parser.nextToken() != XContentParser.Token.END_OBJECT) {_                            String indexMetaFieldName = parser.currentName()__                            parser.nextToken()__                            if (INDEX_ID.equals(indexMetaFieldName)) {_                                indexId = parser.text()__                            } else if (SNAPSHOTS.equals(indexMetaFieldName)) {_                                if (parser.currentToken() != XContentParser.Token.START_ARRAY) {_                                    throw new ElasticsearchParseException("start array expected [snapshots]")__                                }_                                while (parser.nextToken() != XContentParser.Token.END_ARRAY) {_                                    String uuid = null__                                    _                                    if (parser.currentToken() == XContentParser.Token.START_OBJECT) {_                                        while (parser.nextToken() != XContentParser.Token.END_OBJECT) {_                                            String currentFieldName = parser.currentName()__                                            parser.nextToken()__                                            if (UUID.equals(currentFieldName)) {_                                                uuid = parser.text()__                                            }_                                        }_                                    } else {_                                        _                                        _                                        uuid = parser.text()__                                    }_                                    snapshotIds.add(snapshots.get(uuid))__                                }_                            }_                        }_                        assert indexId != null__                        indexSnapshots.put(new IndexId(indexName, indexId), snapshotIds)__                    }_                } else {_                    throw new ElasticsearchParseException("unknown field name  [" + field + "]")__                }_            }_        } else {_            throw new ElasticsearchParseException("start object expected")__        }_        return new RepositoryData(genId, snapshots, snapshotStates, indexSnapshots, Collections.emptyList())__    };reads,an,instance,of,link,repository,data,from,x,content,loading,the,snapshots,and,indices,metadata;public,static,repository,data,snapshots,from,xcontent,final,xcontent,parser,parser,long,gen,id,throws,ioexception,map,string,snapshot,id,snapshots,new,hash,map,map,string,snapshot,state,snapshot,states,new,hash,map,map,index,id,set,snapshot,id,index,snapshots,new,hash,map,if,parser,next,token,xcontent,parser,token,while,parser,next,token,xcontent,parser,token,string,field,parser,current,name,if,snapshots,equals,field,if,parser,next,token,xcontent,parser,token,while,parser,next,token,xcontent,parser,token,final,snapshot,id,snapshot,id,if,parser,current,token,xcontent,parser,token,string,name,null,string,uuid,null,snapshot,state,state,null,while,parser,next,token,xcontent,parser,token,string,current,field,name,parser,current,name,parser,next,token,if,name,equals,current,field,name,name,parser,text,else,if,uuid,equals,current,field,name,uuid,parser,text,else,if,state,equals,current,field,name,state,snapshot,state,from,value,parser,number,value,byte,value,snapshot,id,new,snapshot,id,name,uuid,if,state,null,snapshot,states,put,uuid,state,else,final,string,name,parser,text,snapshot,id,new,snapshot,id,name,name,snapshots,put,snapshot,id,get,uuid,snapshot,id,else,throw,new,elasticsearch,parse,exception,expected,array,for,field,else,if,indices,equals,field,if,parser,next,token,xcontent,parser,token,throw,new,elasticsearch,parse,exception,start,object,expected,indices,while,parser,next,token,xcontent,parser,token,string,index,name,parser,current,name,string,index,id,null,set,snapshot,id,snapshot,ids,new,linked,hash,set,if,parser,next,token,xcontent,parser,token,throw,new,elasticsearch,parse,exception,start,object,expected,index,index,name,while,parser,next,token,xcontent,parser,token,string,index,meta,field,name,parser,current,name,parser,next,token,if,equals,index,meta,field,name,index,id,parser,text,else,if,snapshots,equals,index,meta,field,name,if,parser,current,token,xcontent,parser,token,throw,new,elasticsearch,parse,exception,start,array,expected,snapshots,while,parser,next,token,xcontent,parser,token,string,uuid,null,if,parser,current,token,xcontent,parser,token,while,parser,next,token,xcontent,parser,token,string,current,field,name,parser,current,name,parser,next,token,if,uuid,equals,current,field,name,uuid,parser,text,else,uuid,parser,text,snapshot,ids,add,snapshots,get,uuid,assert,index,id,null,index,snapshots,put,new,index,id,index,name,index,id,snapshot,ids,else,throw,new,elasticsearch,parse,exception,unknown,field,name,field,else,throw,new,elasticsearch,parse,exception,start,object,expected,return,new,repository,data,gen,id,snapshots,snapshot,states,index,snapshots,collections,empty,list
RepositoryData -> public static RepositoryData snapshotsFromXContent(final XContentParser parser, long genId) throws IOException;1524839522;Reads an instance of {@link RepositoryData} from x-content, loading the snapshots and indices metadata.;public static RepositoryData snapshotsFromXContent(final XContentParser parser, long genId) throws IOException {_        final Map<String, SnapshotId> snapshots = new HashMap<>()__        final Map<String, SnapshotState> snapshotStates = new HashMap<>()__        final Map<IndexId, Set<SnapshotId>> indexSnapshots = new HashMap<>()___        if (parser.nextToken() == XContentParser.Token.START_OBJECT) {_            while (parser.nextToken() == XContentParser.Token.FIELD_NAME) {_                String field = parser.currentName()__                if (SNAPSHOTS.equals(field)) {_                    if (parser.nextToken() == XContentParser.Token.START_ARRAY) {_                        while (parser.nextToken() != XContentParser.Token.END_ARRAY) {_                            final SnapshotId snapshotId__                            _                            if (parser.currentToken() == XContentParser.Token.START_OBJECT) {_                                String name = null__                                String uuid = null__                                SnapshotState state = null__                                while (parser.nextToken() != XContentParser.Token.END_OBJECT) {_                                    String currentFieldName = parser.currentName()__                                    parser.nextToken()__                                    if (NAME.equals(currentFieldName)) {_                                        name = parser.text()__                                    } else if (UUID.equals(currentFieldName)) {_                                        uuid = parser.text()__                                    } else if (STATE.equals(currentFieldName)) {_                                        state = SnapshotState.fromValue(parser.numberValue().byteValue())__                                    }_                                }_                                snapshotId = new SnapshotId(name, uuid)__                                if (state != null) {_                                    snapshotStates.put(uuid, state)__                                }_                            } else {_                                _                                final String name = parser.text()__                                snapshotId = new SnapshotId(name, name)__                            }_                            snapshots.put(snapshotId.getUUID(), snapshotId)__                        }_                    } else {_                        throw new ElasticsearchParseException("expected array for [" + field + "]")__                    }_                } else if (INDICES.equals(field)) {_                    if (parser.nextToken() != XContentParser.Token.START_OBJECT) {_                        throw new ElasticsearchParseException("start object expected [indices]")__                    }_                    while (parser.nextToken() != XContentParser.Token.END_OBJECT) {_                        final String indexName = parser.currentName()__                        final Set<SnapshotId> snapshotIds = new LinkedHashSet<>()___                        IndexId indexId = null__                        if (parser.nextToken() != XContentParser.Token.START_OBJECT) {_                            throw new ElasticsearchParseException("start object expected index[" + indexName + "]")__                        }_                        while (parser.nextToken() != XContentParser.Token.END_OBJECT) {_                            final String indexMetaFieldName = parser.currentName()__                            parser.nextToken()__                            if (INDEX_ID.equals(indexMetaFieldName)) {_                                indexId = new IndexId(indexName, parser.text())__                            } else if (SNAPSHOTS.equals(indexMetaFieldName)) {_                                if (parser.currentToken() != XContentParser.Token.START_ARRAY) {_                                    throw new ElasticsearchParseException("start array expected [snapshots]")__                                }_                                while (parser.nextToken() != XContentParser.Token.END_ARRAY) {_                                    String uuid = null__                                    _                                    if (parser.currentToken() == XContentParser.Token.START_OBJECT) {_                                        while (parser.nextToken() != XContentParser.Token.END_OBJECT) {_                                            String currentFieldName = parser.currentName()__                                            parser.nextToken()__                                            if (UUID.equals(currentFieldName)) {_                                                uuid = parser.text()__                                            }_                                        }_                                    } else {_                                        _                                        _                                        uuid = parser.text()__                                    }__                                    SnapshotId snapshotId = snapshots.get(uuid)__                                    if (snapshotId != null) {_                                        snapshotIds.add(snapshotId)__                                    } else {_                                        _                                        _                                        _                                        throw new ElasticsearchParseException("Detected a corrupted repository, index " + indexId_                                            + " references an unknown snapshot uuid [" + uuid + "]")__                                    }_                                }_                            }_                        }_                        assert indexId != null__                        indexSnapshots.put(indexId, snapshotIds)__                    }_                } else {_                    throw new ElasticsearchParseException("unknown field name  [" + field + "]")__                }_            }_        } else {_            throw new ElasticsearchParseException("start object expected")__        }_        return new RepositoryData(genId, snapshots, snapshotStates, indexSnapshots, Collections.emptyList())__    };reads,an,instance,of,link,repository,data,from,x,content,loading,the,snapshots,and,indices,metadata;public,static,repository,data,snapshots,from,xcontent,final,xcontent,parser,parser,long,gen,id,throws,ioexception,final,map,string,snapshot,id,snapshots,new,hash,map,final,map,string,snapshot,state,snapshot,states,new,hash,map,final,map,index,id,set,snapshot,id,index,snapshots,new,hash,map,if,parser,next,token,xcontent,parser,token,while,parser,next,token,xcontent,parser,token,string,field,parser,current,name,if,snapshots,equals,field,if,parser,next,token,xcontent,parser,token,while,parser,next,token,xcontent,parser,token,final,snapshot,id,snapshot,id,if,parser,current,token,xcontent,parser,token,string,name,null,string,uuid,null,snapshot,state,state,null,while,parser,next,token,xcontent,parser,token,string,current,field,name,parser,current,name,parser,next,token,if,name,equals,current,field,name,name,parser,text,else,if,uuid,equals,current,field,name,uuid,parser,text,else,if,state,equals,current,field,name,state,snapshot,state,from,value,parser,number,value,byte,value,snapshot,id,new,snapshot,id,name,uuid,if,state,null,snapshot,states,put,uuid,state,else,final,string,name,parser,text,snapshot,id,new,snapshot,id,name,name,snapshots,put,snapshot,id,get,uuid,snapshot,id,else,throw,new,elasticsearch,parse,exception,expected,array,for,field,else,if,indices,equals,field,if,parser,next,token,xcontent,parser,token,throw,new,elasticsearch,parse,exception,start,object,expected,indices,while,parser,next,token,xcontent,parser,token,final,string,index,name,parser,current,name,final,set,snapshot,id,snapshot,ids,new,linked,hash,set,index,id,index,id,null,if,parser,next,token,xcontent,parser,token,throw,new,elasticsearch,parse,exception,start,object,expected,index,index,name,while,parser,next,token,xcontent,parser,token,final,string,index,meta,field,name,parser,current,name,parser,next,token,if,equals,index,meta,field,name,index,id,new,index,id,index,name,parser,text,else,if,snapshots,equals,index,meta,field,name,if,parser,current,token,xcontent,parser,token,throw,new,elasticsearch,parse,exception,start,array,expected,snapshots,while,parser,next,token,xcontent,parser,token,string,uuid,null,if,parser,current,token,xcontent,parser,token,while,parser,next,token,xcontent,parser,token,string,current,field,name,parser,current,name,parser,next,token,if,uuid,equals,current,field,name,uuid,parser,text,else,uuid,parser,text,snapshot,id,snapshot,id,snapshots,get,uuid,if,snapshot,id,null,snapshot,ids,add,snapshot,id,else,throw,new,elasticsearch,parse,exception,detected,a,corrupted,repository,index,index,id,references,an,unknown,snapshot,uuid,uuid,assert,index,id,null,index,snapshots,put,index,id,snapshot,ids,else,throw,new,elasticsearch,parse,exception,unknown,field,name,field,else,throw,new,elasticsearch,parse,exception,start,object,expected,return,new,repository,data,gen,id,snapshots,snapshot,states,index,snapshots,collections,empty,list
RepositoryData -> public static RepositoryData snapshotsFromXContent(final XContentParser parser, long genId) throws IOException;1532353780;Reads an instance of {@link RepositoryData} from x-content, loading the snapshots and indices metadata.;public static RepositoryData snapshotsFromXContent(final XContentParser parser, long genId) throws IOException {_        final Map<String, SnapshotId> snapshots = new HashMap<>()__        final Map<String, SnapshotState> snapshotStates = new HashMap<>()__        final Map<IndexId, Set<SnapshotId>> indexSnapshots = new HashMap<>()___        if (parser.nextToken() == XContentParser.Token.START_OBJECT) {_            while (parser.nextToken() == XContentParser.Token.FIELD_NAME) {_                String field = parser.currentName()__                if (SNAPSHOTS.equals(field)) {_                    if (parser.nextToken() == XContentParser.Token.START_ARRAY) {_                        while (parser.nextToken() != XContentParser.Token.END_ARRAY) {_                            final SnapshotId snapshotId__                            _                            if (parser.currentToken() == XContentParser.Token.START_OBJECT) {_                                String name = null__                                String uuid = null__                                SnapshotState state = null__                                while (parser.nextToken() != XContentParser.Token.END_OBJECT) {_                                    String currentFieldName = parser.currentName()__                                    parser.nextToken()__                                    if (NAME.equals(currentFieldName)) {_                                        name = parser.text()__                                    } else if (UUID.equals(currentFieldName)) {_                                        uuid = parser.text()__                                    } else if (STATE.equals(currentFieldName)) {_                                        state = SnapshotState.fromValue(parser.numberValue().byteValue())__                                    }_                                }_                                snapshotId = new SnapshotId(name, uuid)__                                if (state != null) {_                                    snapshotStates.put(uuid, state)__                                }_                            } else {_                                _                                final String name = parser.text()__                                snapshotId = new SnapshotId(name, name)__                            }_                            snapshots.put(snapshotId.getUUID(), snapshotId)__                        }_                    } else {_                        throw new ElasticsearchParseException("expected array for [" + field + "]")__                    }_                } else if (INDICES.equals(field)) {_                    if (parser.nextToken() != XContentParser.Token.START_OBJECT) {_                        throw new ElasticsearchParseException("start object expected [indices]")__                    }_                    while (parser.nextToken() != XContentParser.Token.END_OBJECT) {_                        final String indexName = parser.currentName()__                        final Set<SnapshotId> snapshotIds = new LinkedHashSet<>()___                        IndexId indexId = null__                        if (parser.nextToken() != XContentParser.Token.START_OBJECT) {_                            throw new ElasticsearchParseException("start object expected index[" + indexName + "]")__                        }_                        while (parser.nextToken() != XContentParser.Token.END_OBJECT) {_                            final String indexMetaFieldName = parser.currentName()__                            parser.nextToken()__                            if (INDEX_ID.equals(indexMetaFieldName)) {_                                indexId = new IndexId(indexName, parser.text())__                            } else if (SNAPSHOTS.equals(indexMetaFieldName)) {_                                if (parser.currentToken() != XContentParser.Token.START_ARRAY) {_                                    throw new ElasticsearchParseException("start array expected [snapshots]")__                                }_                                while (parser.nextToken() != XContentParser.Token.END_ARRAY) {_                                    String uuid = null__                                    _                                    if (parser.currentToken() == XContentParser.Token.START_OBJECT) {_                                        while (parser.nextToken() != XContentParser.Token.END_OBJECT) {_                                            String currentFieldName = parser.currentName()__                                            parser.nextToken()__                                            if (UUID.equals(currentFieldName)) {_                                                uuid = parser.text()__                                            }_                                        }_                                    } else {_                                        _                                        _                                        uuid = parser.text()__                                    }__                                    SnapshotId snapshotId = snapshots.get(uuid)__                                    if (snapshotId != null) {_                                        snapshotIds.add(snapshotId)__                                    } else {_                                        _                                        _                                        _                                        throw new ElasticsearchParseException("Detected a corrupted repository, index " + indexId_                                            + " references an unknown snapshot uuid [" + uuid + "]")__                                    }_                                }_                            }_                        }_                        assert indexId != null__                        indexSnapshots.put(indexId, snapshotIds)__                    }_                } else {_                    throw new ElasticsearchParseException("unknown field name  [" + field + "]")__                }_            }_        } else {_            throw new ElasticsearchParseException("start object expected")__        }_        return new RepositoryData(genId, snapshots, snapshotStates, indexSnapshots, Collections.emptyList())__    };reads,an,instance,of,link,repository,data,from,x,content,loading,the,snapshots,and,indices,metadata;public,static,repository,data,snapshots,from,xcontent,final,xcontent,parser,parser,long,gen,id,throws,ioexception,final,map,string,snapshot,id,snapshots,new,hash,map,final,map,string,snapshot,state,snapshot,states,new,hash,map,final,map,index,id,set,snapshot,id,index,snapshots,new,hash,map,if,parser,next,token,xcontent,parser,token,while,parser,next,token,xcontent,parser,token,string,field,parser,current,name,if,snapshots,equals,field,if,parser,next,token,xcontent,parser,token,while,parser,next,token,xcontent,parser,token,final,snapshot,id,snapshot,id,if,parser,current,token,xcontent,parser,token,string,name,null,string,uuid,null,snapshot,state,state,null,while,parser,next,token,xcontent,parser,token,string,current,field,name,parser,current,name,parser,next,token,if,name,equals,current,field,name,name,parser,text,else,if,uuid,equals,current,field,name,uuid,parser,text,else,if,state,equals,current,field,name,state,snapshot,state,from,value,parser,number,value,byte,value,snapshot,id,new,snapshot,id,name,uuid,if,state,null,snapshot,states,put,uuid,state,else,final,string,name,parser,text,snapshot,id,new,snapshot,id,name,name,snapshots,put,snapshot,id,get,uuid,snapshot,id,else,throw,new,elasticsearch,parse,exception,expected,array,for,field,else,if,indices,equals,field,if,parser,next,token,xcontent,parser,token,throw,new,elasticsearch,parse,exception,start,object,expected,indices,while,parser,next,token,xcontent,parser,token,final,string,index,name,parser,current,name,final,set,snapshot,id,snapshot,ids,new,linked,hash,set,index,id,index,id,null,if,parser,next,token,xcontent,parser,token,throw,new,elasticsearch,parse,exception,start,object,expected,index,index,name,while,parser,next,token,xcontent,parser,token,final,string,index,meta,field,name,parser,current,name,parser,next,token,if,equals,index,meta,field,name,index,id,new,index,id,index,name,parser,text,else,if,snapshots,equals,index,meta,field,name,if,parser,current,token,xcontent,parser,token,throw,new,elasticsearch,parse,exception,start,array,expected,snapshots,while,parser,next,token,xcontent,parser,token,string,uuid,null,if,parser,current,token,xcontent,parser,token,while,parser,next,token,xcontent,parser,token,string,current,field,name,parser,current,name,parser,next,token,if,uuid,equals,current,field,name,uuid,parser,text,else,uuid,parser,text,snapshot,id,snapshot,id,snapshots,get,uuid,if,snapshot,id,null,snapshot,ids,add,snapshot,id,else,throw,new,elasticsearch,parse,exception,detected,a,corrupted,repository,index,index,id,references,an,unknown,snapshot,uuid,uuid,assert,index,id,null,index,snapshots,put,index,id,snapshot,ids,else,throw,new,elasticsearch,parse,exception,unknown,field,name,field,else,throw,new,elasticsearch,parse,exception,start,object,expected,return,new,repository,data,gen,id,snapshots,snapshot,states,index,snapshots,collections,empty,list
RepositoryData -> public List<IndexId> resolveNewIndices(final List<String> indicesToResolve);1524684173;Resolve the given index names to index ids, creating new index ids for_new indices in the repository.;public List<IndexId> resolveNewIndices(final List<String> indicesToResolve) {_        List<IndexId> snapshotIndices = new ArrayList<>()__        for (String index : indicesToResolve) {_            final IndexId indexId__            if (indices.containsKey(index)) {_                indexId = indices.get(index)__            } else {_                indexId = new IndexId(index, UUIDs.randomBase64UUID())__            }_            snapshotIndices.add(indexId)__        }_        return snapshotIndices__    };resolve,the,given,index,names,to,index,ids,creating,new,index,ids,for,new,indices,in,the,repository;public,list,index,id,resolve,new,indices,final,list,string,indices,to,resolve,list,index,id,snapshot,indices,new,array,list,for,string,index,indices,to,resolve,final,index,id,index,id,if,indices,contains,key,index,index,id,indices,get,index,else,index,id,new,index,id,index,uuids,random,base64uuid,snapshot,indices,add,index,id,return,snapshot,indices
RepositoryData -> public List<IndexId> resolveNewIndices(final List<String> indicesToResolve);1524839522;Resolve the given index names to index ids, creating new index ids for_new indices in the repository.;public List<IndexId> resolveNewIndices(final List<String> indicesToResolve) {_        List<IndexId> snapshotIndices = new ArrayList<>()__        for (String index : indicesToResolve) {_            final IndexId indexId__            if (indices.containsKey(index)) {_                indexId = indices.get(index)__            } else {_                indexId = new IndexId(index, UUIDs.randomBase64UUID())__            }_            snapshotIndices.add(indexId)__        }_        return snapshotIndices__    };resolve,the,given,index,names,to,index,ids,creating,new,index,ids,for,new,indices,in,the,repository;public,list,index,id,resolve,new,indices,final,list,string,indices,to,resolve,list,index,id,snapshot,indices,new,array,list,for,string,index,indices,to,resolve,final,index,id,index,id,if,indices,contains,key,index,index,id,indices,get,index,else,index,id,new,index,id,index,uuids,random,base64uuid,snapshot,indices,add,index,id,return,snapshot,indices
RepositoryData -> public List<IndexId> resolveNewIndices(final List<String> indicesToResolve);1532353780;Resolve the given index names to index ids, creating new index ids for_new indices in the repository.;public List<IndexId> resolveNewIndices(final List<String> indicesToResolve) {_        List<IndexId> snapshotIndices = new ArrayList<>()__        for (String index : indicesToResolve) {_            final IndexId indexId__            if (indices.containsKey(index)) {_                indexId = indices.get(index)__            } else {_                indexId = new IndexId(index, UUIDs.randomBase64UUID())__            }_            snapshotIndices.add(indexId)__        }_        return snapshotIndices__    };resolve,the,given,index,names,to,index,ids,creating,new,index,ids,for,new,indices,in,the,repository;public,list,index,id,resolve,new,indices,final,list,string,indices,to,resolve,list,index,id,snapshot,indices,new,array,list,for,string,index,indices,to,resolve,final,index,id,index,id,if,indices,contains,key,index,index,id,indices,get,index,else,index,id,new,index,id,index,uuids,random,base64uuid,snapshot,indices,add,index,id,return,snapshot,indices
RepositoryData -> public RepositoryData incompatibleSnapshotsFromXContent(final XContentParser parser) throws IOException;1524684173;Reads the incompatible snapshot ids from x-content, loading them into a new instance of {@link RepositoryData}_that is created from the invoking instance, plus the incompatible snapshots that are read from x-content.;public RepositoryData incompatibleSnapshotsFromXContent(final XContentParser parser) throws IOException {_        List<SnapshotId> incompatibleSnapshotIds = new ArrayList<>()__        if (parser.nextToken() == XContentParser.Token.START_OBJECT) {_            while (parser.nextToken() == XContentParser.Token.FIELD_NAME) {_                String currentFieldName = parser.currentName()__                if (INCOMPATIBLE_SNAPSHOTS.equals(currentFieldName)) {_                    if (parser.nextToken() == XContentParser.Token.START_ARRAY) {_                        while (parser.nextToken() != XContentParser.Token.END_ARRAY) {_                            incompatibleSnapshotIds.add(SnapshotId.fromXContent(parser))__                        }_                    } else {_                        throw new ElasticsearchParseException("expected array for [" + currentFieldName + "]")__                    }_                } else {_                    throw new ElasticsearchParseException("unknown field name  [" + currentFieldName + "]")__                }_            }_        } else {_            throw new ElasticsearchParseException("start object expected")__        }_        return new RepositoryData(this.genId, this.snapshotIds, this.snapshotStates, this.indexSnapshots, incompatibleSnapshotIds)__    };reads,the,incompatible,snapshot,ids,from,x,content,loading,them,into,a,new,instance,of,link,repository,data,that,is,created,from,the,invoking,instance,plus,the,incompatible,snapshots,that,are,read,from,x,content;public,repository,data,incompatible,snapshots,from,xcontent,final,xcontent,parser,parser,throws,ioexception,list,snapshot,id,incompatible,snapshot,ids,new,array,list,if,parser,next,token,xcontent,parser,token,while,parser,next,token,xcontent,parser,token,string,current,field,name,parser,current,name,if,equals,current,field,name,if,parser,next,token,xcontent,parser,token,while,parser,next,token,xcontent,parser,token,incompatible,snapshot,ids,add,snapshot,id,from,xcontent,parser,else,throw,new,elasticsearch,parse,exception,expected,array,for,current,field,name,else,throw,new,elasticsearch,parse,exception,unknown,field,name,current,field,name,else,throw,new,elasticsearch,parse,exception,start,object,expected,return,new,repository,data,this,gen,id,this,snapshot,ids,this,snapshot,states,this,index,snapshots,incompatible,snapshot,ids
RepositoryData -> public RepositoryData incompatibleSnapshotsFromXContent(final XContentParser parser) throws IOException;1524839522;Reads the incompatible snapshot ids from x-content, loading them into a new instance of {@link RepositoryData}_that is created from the invoking instance, plus the incompatible snapshots that are read from x-content.;public RepositoryData incompatibleSnapshotsFromXContent(final XContentParser parser) throws IOException {_        List<SnapshotId> incompatibleSnapshotIds = new ArrayList<>()__        if (parser.nextToken() == XContentParser.Token.START_OBJECT) {_            while (parser.nextToken() == XContentParser.Token.FIELD_NAME) {_                String currentFieldName = parser.currentName()__                if (INCOMPATIBLE_SNAPSHOTS.equals(currentFieldName)) {_                    if (parser.nextToken() == XContentParser.Token.START_ARRAY) {_                        while (parser.nextToken() != XContentParser.Token.END_ARRAY) {_                            incompatibleSnapshotIds.add(SnapshotId.fromXContent(parser))__                        }_                    } else {_                        throw new ElasticsearchParseException("expected array for [" + currentFieldName + "]")__                    }_                } else {_                    throw new ElasticsearchParseException("unknown field name  [" + currentFieldName + "]")__                }_            }_        } else {_            throw new ElasticsearchParseException("start object expected")__        }_        return new RepositoryData(this.genId, this.snapshotIds, this.snapshotStates, this.indexSnapshots, incompatibleSnapshotIds)__    };reads,the,incompatible,snapshot,ids,from,x,content,loading,them,into,a,new,instance,of,link,repository,data,that,is,created,from,the,invoking,instance,plus,the,incompatible,snapshots,that,are,read,from,x,content;public,repository,data,incompatible,snapshots,from,xcontent,final,xcontent,parser,parser,throws,ioexception,list,snapshot,id,incompatible,snapshot,ids,new,array,list,if,parser,next,token,xcontent,parser,token,while,parser,next,token,xcontent,parser,token,string,current,field,name,parser,current,name,if,equals,current,field,name,if,parser,next,token,xcontent,parser,token,while,parser,next,token,xcontent,parser,token,incompatible,snapshot,ids,add,snapshot,id,from,xcontent,parser,else,throw,new,elasticsearch,parse,exception,expected,array,for,current,field,name,else,throw,new,elasticsearch,parse,exception,unknown,field,name,current,field,name,else,throw,new,elasticsearch,parse,exception,start,object,expected,return,new,repository,data,this,gen,id,this,snapshot,ids,this,snapshot,states,this,index,snapshots,incompatible,snapshot,ids
RepositoryData -> public RepositoryData incompatibleSnapshotsFromXContent(final XContentParser parser) throws IOException;1532353780;Reads the incompatible snapshot ids from x-content, loading them into a new instance of {@link RepositoryData}_that is created from the invoking instance, plus the incompatible snapshots that are read from x-content.;public RepositoryData incompatibleSnapshotsFromXContent(final XContentParser parser) throws IOException {_        List<SnapshotId> incompatibleSnapshotIds = new ArrayList<>()__        if (parser.nextToken() == XContentParser.Token.START_OBJECT) {_            while (parser.nextToken() == XContentParser.Token.FIELD_NAME) {_                String currentFieldName = parser.currentName()__                if (INCOMPATIBLE_SNAPSHOTS.equals(currentFieldName)) {_                    if (parser.nextToken() == XContentParser.Token.START_ARRAY) {_                        while (parser.nextToken() != XContentParser.Token.END_ARRAY) {_                            incompatibleSnapshotIds.add(SnapshotId.fromXContent(parser))__                        }_                    } else {_                        throw new ElasticsearchParseException("expected array for [" + currentFieldName + "]")__                    }_                } else {_                    throw new ElasticsearchParseException("unknown field name  [" + currentFieldName + "]")__                }_            }_        } else {_            throw new ElasticsearchParseException("start object expected")__        }_        return new RepositoryData(this.genId, this.snapshotIds, this.snapshotStates, this.indexSnapshots, incompatibleSnapshotIds)__    };reads,the,incompatible,snapshot,ids,from,x,content,loading,them,into,a,new,instance,of,link,repository,data,that,is,created,from,the,invoking,instance,plus,the,incompatible,snapshots,that,are,read,from,x,content;public,repository,data,incompatible,snapshots,from,xcontent,final,xcontent,parser,parser,throws,ioexception,list,snapshot,id,incompatible,snapshot,ids,new,array,list,if,parser,next,token,xcontent,parser,token,while,parser,next,token,xcontent,parser,token,string,current,field,name,parser,current,name,if,equals,current,field,name,if,parser,next,token,xcontent,parser,token,while,parser,next,token,xcontent,parser,token,incompatible,snapshot,ids,add,snapshot,id,from,xcontent,parser,else,throw,new,elasticsearch,parse,exception,expected,array,for,current,field,name,else,throw,new,elasticsearch,parse,exception,unknown,field,name,current,field,name,else,throw,new,elasticsearch,parse,exception,start,object,expected,return,new,repository,data,this,gen,id,this,snapshot,ids,this,snapshot,states,this,index,snapshots,incompatible,snapshot,ids
RepositoryData -> public Map<String, IndexId> getIndices();1524684173;Returns an unmodifiable map of the index names to {@link IndexId} in the repository.;public Map<String, IndexId> getIndices() {_        return indices__    };returns,an,unmodifiable,map,of,the,index,names,to,link,index,id,in,the,repository;public,map,string,index,id,get,indices,return,indices
RepositoryData -> public Map<String, IndexId> getIndices();1524839522;Returns an unmodifiable map of the index names to {@link IndexId} in the repository.;public Map<String, IndexId> getIndices() {_        return indices__    };returns,an,unmodifiable,map,of,the,index,names,to,link,index,id,in,the,repository;public,map,string,index,id,get,indices,return,indices
RepositoryData -> public Map<String, IndexId> getIndices();1532353780;Returns an unmodifiable map of the index names to {@link IndexId} in the repository.;public Map<String, IndexId> getIndices() {_        return indices__    };returns,an,unmodifiable,map,of,the,index,names,to,link,index,id,in,the,repository;public,map,string,index,id,get,indices,return,indices
RepositoryData -> public Collection<SnapshotId> getSnapshotIds();1524684173;Returns an unmodifiable collection of the snapshot ids.;public Collection<SnapshotId> getSnapshotIds() {_        return Collections.unmodifiableCollection(snapshotIds.values())__    };returns,an,unmodifiable,collection,of,the,snapshot,ids;public,collection,snapshot,id,get,snapshot,ids,return,collections,unmodifiable,collection,snapshot,ids,values
RepositoryData -> public Collection<SnapshotId> getSnapshotIds();1524839522;Returns an unmodifiable collection of the snapshot ids.;public Collection<SnapshotId> getSnapshotIds() {_        return Collections.unmodifiableCollection(snapshotIds.values())__    };returns,an,unmodifiable,collection,of,the,snapshot,ids;public,collection,snapshot,id,get,snapshot,ids,return,collections,unmodifiable,collection,snapshot,ids,values
RepositoryData -> public Collection<SnapshotId> getSnapshotIds();1532353780;Returns an unmodifiable collection of the snapshot ids.;public Collection<SnapshotId> getSnapshotIds() {_        return Collections.unmodifiableCollection(snapshotIds.values())__    };returns,an,unmodifiable,collection,of,the,snapshot,ids;public,collection,snapshot,id,get,snapshot,ids,return,collections,unmodifiable,collection,snapshot,ids,values
RepositoryData -> public XContentBuilder snapshotsToXContent(final XContentBuilder builder, final ToXContent.Params params) throws IOException;1524684173;Writes the snapshots metadata and the related indices metadata to x-content, omitting the_incompatible snapshots.;public XContentBuilder snapshotsToXContent(final XContentBuilder builder, final ToXContent.Params params) throws IOException {_        builder.startObject()__        _        builder.startArray(SNAPSHOTS)__        for (final SnapshotId snapshot : getSnapshotIds()) {_            builder.startObject()__            builder.field(NAME, snapshot.getName())__            builder.field(UUID, snapshot.getUUID())__            if (snapshotStates.containsKey(snapshot.getUUID())) {_                builder.field(STATE, snapshotStates.get(snapshot.getUUID()).value())__            }_            builder.endObject()__        }_        builder.endArray()__        _        builder.startObject(INDICES)__        for (final IndexId indexId : getIndices().values()) {_            builder.startObject(indexId.getName())__            builder.field(INDEX_ID, indexId.getId())__            builder.startArray(SNAPSHOTS)__            Set<SnapshotId> snapshotIds = indexSnapshots.get(indexId)__            assert snapshotIds != null__            for (final SnapshotId snapshotId : snapshotIds) {_                builder.value(snapshotId.getUUID())__            }_            builder.endArray()__            builder.endObject()__        }_        builder.endObject()__        builder.endObject()__        return builder__    };writes,the,snapshots,metadata,and,the,related,indices,metadata,to,x,content,omitting,the,incompatible,snapshots;public,xcontent,builder,snapshots,to,xcontent,final,xcontent,builder,builder,final,to,xcontent,params,params,throws,ioexception,builder,start,object,builder,start,array,snapshots,for,final,snapshot,id,snapshot,get,snapshot,ids,builder,start,object,builder,field,name,snapshot,get,name,builder,field,uuid,snapshot,get,uuid,if,snapshot,states,contains,key,snapshot,get,uuid,builder,field,state,snapshot,states,get,snapshot,get,uuid,value,builder,end,object,builder,end,array,builder,start,object,indices,for,final,index,id,index,id,get,indices,values,builder,start,object,index,id,get,name,builder,field,index,id,get,id,builder,start,array,snapshots,set,snapshot,id,snapshot,ids,index,snapshots,get,index,id,assert,snapshot,ids,null,for,final,snapshot,id,snapshot,id,snapshot,ids,builder,value,snapshot,id,get,uuid,builder,end,array,builder,end,object,builder,end,object,builder,end,object,return,builder
RepositoryData -> public XContentBuilder snapshotsToXContent(final XContentBuilder builder, final ToXContent.Params params) throws IOException;1524839522;Writes the snapshots metadata and the related indices metadata to x-content, omitting the_incompatible snapshots.;public XContentBuilder snapshotsToXContent(final XContentBuilder builder, final ToXContent.Params params) throws IOException {_        builder.startObject()__        _        builder.startArray(SNAPSHOTS)__        for (final SnapshotId snapshot : getSnapshotIds()) {_            builder.startObject()__            builder.field(NAME, snapshot.getName())__            builder.field(UUID, snapshot.getUUID())__            if (snapshotStates.containsKey(snapshot.getUUID())) {_                builder.field(STATE, snapshotStates.get(snapshot.getUUID()).value())__            }_            builder.endObject()__        }_        builder.endArray()__        _        builder.startObject(INDICES)__        for (final IndexId indexId : getIndices().values()) {_            builder.startObject(indexId.getName())__            builder.field(INDEX_ID, indexId.getId())__            builder.startArray(SNAPSHOTS)__            Set<SnapshotId> snapshotIds = indexSnapshots.get(indexId)__            assert snapshotIds != null__            for (final SnapshotId snapshotId : snapshotIds) {_                builder.value(snapshotId.getUUID())__            }_            builder.endArray()__            builder.endObject()__        }_        builder.endObject()__        builder.endObject()__        return builder__    };writes,the,snapshots,metadata,and,the,related,indices,metadata,to,x,content,omitting,the,incompatible,snapshots;public,xcontent,builder,snapshots,to,xcontent,final,xcontent,builder,builder,final,to,xcontent,params,params,throws,ioexception,builder,start,object,builder,start,array,snapshots,for,final,snapshot,id,snapshot,get,snapshot,ids,builder,start,object,builder,field,name,snapshot,get,name,builder,field,uuid,snapshot,get,uuid,if,snapshot,states,contains,key,snapshot,get,uuid,builder,field,state,snapshot,states,get,snapshot,get,uuid,value,builder,end,object,builder,end,array,builder,start,object,indices,for,final,index,id,index,id,get,indices,values,builder,start,object,index,id,get,name,builder,field,index,id,get,id,builder,start,array,snapshots,set,snapshot,id,snapshot,ids,index,snapshots,get,index,id,assert,snapshot,ids,null,for,final,snapshot,id,snapshot,id,snapshot,ids,builder,value,snapshot,id,get,uuid,builder,end,array,builder,end,object,builder,end,object,builder,end,object,return,builder
RepositoryData -> public XContentBuilder snapshotsToXContent(final XContentBuilder builder, final ToXContent.Params params) throws IOException;1532353780;Writes the snapshots metadata and the related indices metadata to x-content, omitting the_incompatible snapshots.;public XContentBuilder snapshotsToXContent(final XContentBuilder builder, final ToXContent.Params params) throws IOException {_        builder.startObject()__        _        builder.startArray(SNAPSHOTS)__        for (final SnapshotId snapshot : getSnapshotIds()) {_            builder.startObject()__            builder.field(NAME, snapshot.getName())__            builder.field(UUID, snapshot.getUUID())__            if (snapshotStates.containsKey(snapshot.getUUID())) {_                builder.field(STATE, snapshotStates.get(snapshot.getUUID()).value())__            }_            builder.endObject()__        }_        builder.endArray()__        _        builder.startObject(INDICES)__        for (final IndexId indexId : getIndices().values()) {_            builder.startObject(indexId.getName())__            builder.field(INDEX_ID, indexId.getId())__            builder.startArray(SNAPSHOTS)__            Set<SnapshotId> snapshotIds = indexSnapshots.get(indexId)__            assert snapshotIds != null__            for (final SnapshotId snapshotId : snapshotIds) {_                builder.value(snapshotId.getUUID())__            }_            builder.endArray()__            builder.endObject()__        }_        builder.endObject()__        builder.endObject()__        return builder__    };writes,the,snapshots,metadata,and,the,related,indices,metadata,to,x,content,omitting,the,incompatible,snapshots;public,xcontent,builder,snapshots,to,xcontent,final,xcontent,builder,builder,final,to,xcontent,params,params,throws,ioexception,builder,start,object,builder,start,array,snapshots,for,final,snapshot,id,snapshot,get,snapshot,ids,builder,start,object,builder,field,name,snapshot,get,name,builder,field,uuid,snapshot,get,uuid,if,snapshot,states,contains,key,snapshot,get,uuid,builder,field,state,snapshot,states,get,snapshot,get,uuid,value,builder,end,object,builder,end,array,builder,start,object,indices,for,final,index,id,index,id,get,indices,values,builder,start,object,index,id,get,name,builder,field,index,id,get,id,builder,start,array,snapshots,set,snapshot,id,snapshot,ids,index,snapshots,get,index,id,assert,snapshot,ids,null,for,final,snapshot,id,snapshot,id,snapshot,ids,builder,value,snapshot,id,get,uuid,builder,end,array,builder,end,object,builder,end,object,builder,end,object,return,builder
RepositoryData -> @Nullable     public SnapshotState getSnapshotState(final SnapshotId snapshotId);1524684173;Returns the {@link SnapshotState} for the given snapshot.  Returns {@code null} if_there is no state for the snapshot.;@Nullable_    public SnapshotState getSnapshotState(final SnapshotId snapshotId) {_        return snapshotStates.get(snapshotId.getUUID())__    };returns,the,link,snapshot,state,for,the,given,snapshot,returns,code,null,if,there,is,no,state,for,the,snapshot;nullable,public,snapshot,state,get,snapshot,state,final,snapshot,id,snapshot,id,return,snapshot,states,get,snapshot,id,get,uuid
RepositoryData -> @Nullable     public SnapshotState getSnapshotState(final SnapshotId snapshotId);1524839522;Returns the {@link SnapshotState} for the given snapshot.  Returns {@code null} if_there is no state for the snapshot.;@Nullable_    public SnapshotState getSnapshotState(final SnapshotId snapshotId) {_        return snapshotStates.get(snapshotId.getUUID())__    };returns,the,link,snapshot,state,for,the,given,snapshot,returns,code,null,if,there,is,no,state,for,the,snapshot;nullable,public,snapshot,state,get,snapshot,state,final,snapshot,id,snapshot,id,return,snapshot,states,get,snapshot,id,get,uuid
RepositoryData -> @Nullable     public SnapshotState getSnapshotState(final SnapshotId snapshotId);1532353780;Returns the {@link SnapshotState} for the given snapshot.  Returns {@code null} if_there is no state for the snapshot.;@Nullable_    public SnapshotState getSnapshotState(final SnapshotId snapshotId) {_        return snapshotStates.get(snapshotId.getUUID())__    };returns,the,link,snapshot,state,for,the,given,snapshot,returns,code,null,if,there,is,no,state,for,the,snapshot;nullable,public,snapshot,state,get,snapshot,state,final,snapshot,id,snapshot,id,return,snapshot,states,get,snapshot,id,get,uuid
RepositoryData -> public Set<SnapshotId> getSnapshots(final IndexId indexId);1524684173;Returns an immutable collection of the snapshot ids for the snapshots that contain the given index.;public Set<SnapshotId> getSnapshots(final IndexId indexId) {_        Set<SnapshotId> snapshotIds = indexSnapshots.get(indexId)__        if (snapshotIds == null) {_            throw new IllegalArgumentException("unknown snapshot index " + indexId)__        }_        return snapshotIds__    };returns,an,immutable,collection,of,the,snapshot,ids,for,the,snapshots,that,contain,the,given,index;public,set,snapshot,id,get,snapshots,final,index,id,index,id,set,snapshot,id,snapshot,ids,index,snapshots,get,index,id,if,snapshot,ids,null,throw,new,illegal,argument,exception,unknown,snapshot,index,index,id,return,snapshot,ids
RepositoryData -> public Set<SnapshotId> getSnapshots(final IndexId indexId);1524839522;Returns an immutable collection of the snapshot ids for the snapshots that contain the given index.;public Set<SnapshotId> getSnapshots(final IndexId indexId) {_        Set<SnapshotId> snapshotIds = indexSnapshots.get(indexId)__        if (snapshotIds == null) {_            throw new IllegalArgumentException("unknown snapshot index " + indexId)__        }_        return snapshotIds__    };returns,an,immutable,collection,of,the,snapshot,ids,for,the,snapshots,that,contain,the,given,index;public,set,snapshot,id,get,snapshots,final,index,id,index,id,set,snapshot,id,snapshot,ids,index,snapshots,get,index,id,if,snapshot,ids,null,throw,new,illegal,argument,exception,unknown,snapshot,index,index,id,return,snapshot,ids
RepositoryData -> public Set<SnapshotId> getSnapshots(final IndexId indexId);1532353780;Returns an immutable collection of the snapshot ids for the snapshots that contain the given index.;public Set<SnapshotId> getSnapshots(final IndexId indexId) {_        Set<SnapshotId> snapshotIds = indexSnapshots.get(indexId)__        if (snapshotIds == null) {_            throw new IllegalArgumentException("unknown snapshot index " + indexId)__        }_        return snapshotIds__    };returns,an,immutable,collection,of,the,snapshot,ids,for,the,snapshots,that,contain,the,given,index;public,set,snapshot,id,get,snapshots,final,index,id,index,id,set,snapshot,id,snapshot,ids,index,snapshots,get,index,id,if,snapshot,ids,null,throw,new,illegal,argument,exception,unknown,snapshot,index,index,id,return,snapshot,ids
RepositoryData -> public RepositoryData addSnapshot(final SnapshotId snapshotId,                                       final SnapshotState snapshotState,                                       final List<IndexId> snapshottedIndices);1524684173;Add a snapshot and its indices to the repository_ returns a new instance.  If the snapshot_already exists in the repository data, this method throws an IllegalArgumentException.;public RepositoryData addSnapshot(final SnapshotId snapshotId,_                                      final SnapshotState snapshotState,_                                      final List<IndexId> snapshottedIndices) {_        if (snapshotIds.containsKey(snapshotId.getUUID())) {_            _            _            _            return this__        }_        Map<String, SnapshotId> snapshots = new HashMap<>(snapshotIds)__        snapshots.put(snapshotId.getUUID(), snapshotId)__        Map<String, SnapshotState> newSnapshotStates = new HashMap<>(snapshotStates)__        newSnapshotStates.put(snapshotId.getUUID(), snapshotState)__        Map<IndexId, Set<SnapshotId>> allIndexSnapshots = new HashMap<>(indexSnapshots)__        for (final IndexId indexId : snapshottedIndices) {_            if (allIndexSnapshots.containsKey(indexId)) {_                Set<SnapshotId> ids = allIndexSnapshots.get(indexId)__                if (ids == null) {_                    ids = new LinkedHashSet<>()__                    allIndexSnapshots.put(indexId, ids)__                }_                ids.add(snapshotId)__            } else {_                Set<SnapshotId> ids = new LinkedHashSet<>()__                ids.add(snapshotId)__                allIndexSnapshots.put(indexId, ids)__            }_        }_        return new RepositoryData(genId, snapshots, newSnapshotStates, allIndexSnapshots, incompatibleSnapshotIds)__    };add,a,snapshot,and,its,indices,to,the,repository,returns,a,new,instance,if,the,snapshot,already,exists,in,the,repository,data,this,method,throws,an,illegal,argument,exception;public,repository,data,add,snapshot,final,snapshot,id,snapshot,id,final,snapshot,state,snapshot,state,final,list,index,id,snapshotted,indices,if,snapshot,ids,contains,key,snapshot,id,get,uuid,return,this,map,string,snapshot,id,snapshots,new,hash,map,snapshot,ids,snapshots,put,snapshot,id,get,uuid,snapshot,id,map,string,snapshot,state,new,snapshot,states,new,hash,map,snapshot,states,new,snapshot,states,put,snapshot,id,get,uuid,snapshot,state,map,index,id,set,snapshot,id,all,index,snapshots,new,hash,map,index,snapshots,for,final,index,id,index,id,snapshotted,indices,if,all,index,snapshots,contains,key,index,id,set,snapshot,id,ids,all,index,snapshots,get,index,id,if,ids,null,ids,new,linked,hash,set,all,index,snapshots,put,index,id,ids,ids,add,snapshot,id,else,set,snapshot,id,ids,new,linked,hash,set,ids,add,snapshot,id,all,index,snapshots,put,index,id,ids,return,new,repository,data,gen,id,snapshots,new,snapshot,states,all,index,snapshots,incompatible,snapshot,ids
RepositoryData -> public RepositoryData addSnapshot(final SnapshotId snapshotId,                                       final SnapshotState snapshotState,                                       final List<IndexId> snapshottedIndices);1524839522;Add a snapshot and its indices to the repository_ returns a new instance.  If the snapshot_already exists in the repository data, this method throws an IllegalArgumentException.;public RepositoryData addSnapshot(final SnapshotId snapshotId,_                                      final SnapshotState snapshotState,_                                      final List<IndexId> snapshottedIndices) {_        if (snapshotIds.containsKey(snapshotId.getUUID())) {_            _            _            _            return this__        }_        Map<String, SnapshotId> snapshots = new HashMap<>(snapshotIds)__        snapshots.put(snapshotId.getUUID(), snapshotId)__        Map<String, SnapshotState> newSnapshotStates = new HashMap<>(snapshotStates)__        newSnapshotStates.put(snapshotId.getUUID(), snapshotState)__        Map<IndexId, Set<SnapshotId>> allIndexSnapshots = new HashMap<>(indexSnapshots)__        for (final IndexId indexId : snapshottedIndices) {_            if (allIndexSnapshots.containsKey(indexId)) {_                Set<SnapshotId> ids = allIndexSnapshots.get(indexId)__                if (ids == null) {_                    ids = new LinkedHashSet<>()__                    allIndexSnapshots.put(indexId, ids)__                }_                ids.add(snapshotId)__            } else {_                Set<SnapshotId> ids = new LinkedHashSet<>()__                ids.add(snapshotId)__                allIndexSnapshots.put(indexId, ids)__            }_        }_        return new RepositoryData(genId, snapshots, newSnapshotStates, allIndexSnapshots, incompatibleSnapshotIds)__    };add,a,snapshot,and,its,indices,to,the,repository,returns,a,new,instance,if,the,snapshot,already,exists,in,the,repository,data,this,method,throws,an,illegal,argument,exception;public,repository,data,add,snapshot,final,snapshot,id,snapshot,id,final,snapshot,state,snapshot,state,final,list,index,id,snapshotted,indices,if,snapshot,ids,contains,key,snapshot,id,get,uuid,return,this,map,string,snapshot,id,snapshots,new,hash,map,snapshot,ids,snapshots,put,snapshot,id,get,uuid,snapshot,id,map,string,snapshot,state,new,snapshot,states,new,hash,map,snapshot,states,new,snapshot,states,put,snapshot,id,get,uuid,snapshot,state,map,index,id,set,snapshot,id,all,index,snapshots,new,hash,map,index,snapshots,for,final,index,id,index,id,snapshotted,indices,if,all,index,snapshots,contains,key,index,id,set,snapshot,id,ids,all,index,snapshots,get,index,id,if,ids,null,ids,new,linked,hash,set,all,index,snapshots,put,index,id,ids,ids,add,snapshot,id,else,set,snapshot,id,ids,new,linked,hash,set,ids,add,snapshot,id,all,index,snapshots,put,index,id,ids,return,new,repository,data,gen,id,snapshots,new,snapshot,states,all,index,snapshots,incompatible,snapshot,ids
RepositoryData -> public RepositoryData addSnapshot(final SnapshotId snapshotId,                                       final SnapshotState snapshotState,                                       final List<IndexId> snapshottedIndices);1532353780;Add a snapshot and its indices to the repository_ returns a new instance.  If the snapshot_already exists in the repository data, this method throws an IllegalArgumentException.;public RepositoryData addSnapshot(final SnapshotId snapshotId,_                                      final SnapshotState snapshotState,_                                      final List<IndexId> snapshottedIndices) {_        if (snapshotIds.containsKey(snapshotId.getUUID())) {_            _            _            _            return this__        }_        Map<String, SnapshotId> snapshots = new HashMap<>(snapshotIds)__        snapshots.put(snapshotId.getUUID(), snapshotId)__        Map<String, SnapshotState> newSnapshotStates = new HashMap<>(snapshotStates)__        newSnapshotStates.put(snapshotId.getUUID(), snapshotState)__        Map<IndexId, Set<SnapshotId>> allIndexSnapshots = new HashMap<>(indexSnapshots)__        for (final IndexId indexId : snapshottedIndices) {_            if (allIndexSnapshots.containsKey(indexId)) {_                Set<SnapshotId> ids = allIndexSnapshots.get(indexId)__                if (ids == null) {_                    ids = new LinkedHashSet<>()__                    allIndexSnapshots.put(indexId, ids)__                }_                ids.add(snapshotId)__            } else {_                Set<SnapshotId> ids = new LinkedHashSet<>()__                ids.add(snapshotId)__                allIndexSnapshots.put(indexId, ids)__            }_        }_        return new RepositoryData(genId, snapshots, newSnapshotStates, allIndexSnapshots, incompatibleSnapshotIds)__    };add,a,snapshot,and,its,indices,to,the,repository,returns,a,new,instance,if,the,snapshot,already,exists,in,the,repository,data,this,method,throws,an,illegal,argument,exception;public,repository,data,add,snapshot,final,snapshot,id,snapshot,id,final,snapshot,state,snapshot,state,final,list,index,id,snapshotted,indices,if,snapshot,ids,contains,key,snapshot,id,get,uuid,return,this,map,string,snapshot,id,snapshots,new,hash,map,snapshot,ids,snapshots,put,snapshot,id,get,uuid,snapshot,id,map,string,snapshot,state,new,snapshot,states,new,hash,map,snapshot,states,new,snapshot,states,put,snapshot,id,get,uuid,snapshot,state,map,index,id,set,snapshot,id,all,index,snapshots,new,hash,map,index,snapshots,for,final,index,id,index,id,snapshotted,indices,if,all,index,snapshots,contains,key,index,id,set,snapshot,id,ids,all,index,snapshots,get,index,id,if,ids,null,ids,new,linked,hash,set,all,index,snapshots,put,index,id,ids,ids,add,snapshot,id,else,set,snapshot,id,ids,new,linked,hash,set,ids,add,snapshot,id,all,index,snapshots,put,index,id,ids,return,new,repository,data,gen,id,snapshots,new,snapshot,states,all,index,snapshots,incompatible,snapshot,ids
RepositoryData -> public List<IndexId> resolveIndices(final List<String> indices);1524684173;Resolve the given index names to index ids.;public List<IndexId> resolveIndices(final List<String> indices) {_        List<IndexId> resolvedIndices = new ArrayList<>(indices.size())__        for (final String indexName : indices) {_            resolvedIndices.add(resolveIndexId(indexName))__        }_        return resolvedIndices__    };resolve,the,given,index,names,to,index,ids;public,list,index,id,resolve,indices,final,list,string,indices,list,index,id,resolved,indices,new,array,list,indices,size,for,final,string,index,name,indices,resolved,indices,add,resolve,index,id,index,name,return,resolved,indices
RepositoryData -> public List<IndexId> resolveIndices(final List<String> indices);1524839522;Resolve the given index names to index ids.;public List<IndexId> resolveIndices(final List<String> indices) {_        List<IndexId> resolvedIndices = new ArrayList<>(indices.size())__        for (final String indexName : indices) {_            resolvedIndices.add(resolveIndexId(indexName))__        }_        return resolvedIndices__    };resolve,the,given,index,names,to,index,ids;public,list,index,id,resolve,indices,final,list,string,indices,list,index,id,resolved,indices,new,array,list,indices,size,for,final,string,index,name,indices,resolved,indices,add,resolve,index,id,index,name,return,resolved,indices
RepositoryData -> public List<IndexId> resolveIndices(final List<String> indices);1532353780;Resolve the given index names to index ids.;public List<IndexId> resolveIndices(final List<String> indices) {_        List<IndexId> resolvedIndices = new ArrayList<>(indices.size())__        for (final String indexName : indices) {_            resolvedIndices.add(resolveIndexId(indexName))__        }_        return resolvedIndices__    };resolve,the,given,index,names,to,index,ids;public,list,index,id,resolve,indices,final,list,string,indices,list,index,id,resolved,indices,new,array,list,indices,size,for,final,string,index,name,indices,resolved,indices,add,resolve,index,id,index,name,return,resolved,indices
