commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;3;;protected RepositoryData copy() {     return new RepositoryData(genId, snapshotIds, snapshotStates, indexSnapshots, incompatibleSnapshotIds). }
true;public;0;3;/**  * Gets the generational index file id from which this instance was read.  */ ;/**  * Gets the generational index file id from which this instance was read.  */ public long getGenId() {     return genId. }
true;public;0;3;/**  * Returns an unmodifiable collection of the snapshot ids.  */ ;/**  * Returns an unmodifiable collection of the snapshot ids.  */ public Collection<SnapshotId> getSnapshotIds() {     return Collections.unmodifiableCollection(snapshotIds.values()). }
true;public;0;3;/**  * Returns an immutable collection of the snapshot ids in the repository that are incompatible with the  * current ES version.  */ ;/**  * Returns an immutable collection of the snapshot ids in the repository that are incompatible with the  * current ES version.  */ public Collection<SnapshotId> getIncompatibleSnapshotIds() {     return incompatibleSnapshotIds. }
true;public;0;6;/**  * Returns an immutable collection of all the snapshot ids in the repository, both active and  * incompatible snapshots.  */ ;/**  * Returns an immutable collection of all the snapshot ids in the repository, both active and  * incompatible snapshots.  */ public Collection<SnapshotId> getAllSnapshotIds() {     List<SnapshotId> allSnapshotIds = new ArrayList<>(snapshotIds.size() + incompatibleSnapshotIds.size()).     allSnapshotIds.addAll(snapshotIds.values()).     allSnapshotIds.addAll(incompatibleSnapshotIds).     return Collections.unmodifiableList(allSnapshotIds). }
true;public;1;4;/**  * Returns the {@link SnapshotState} for the given snapshot.  Returns {@code null} if  * there is no state for the snapshot.  */ ;/**  * Returns the {@link SnapshotState} for the given snapshot.  Returns {@code null} if  * there is no state for the snapshot.  */ @Nullable public SnapshotState getSnapshotState(final SnapshotId snapshotId) {     return snapshotStates.get(snapshotId.getUUID()). }
true;public;0;3;/**  * Returns an unmodifiable map of the index names to {@link IndexId} in the repository.  */ ;/**  * Returns an unmodifiable map of the index names to {@link IndexId} in the repository.  */ public Map<String, IndexId> getIndices() {     return indices. }
true;public;3;30;/**  * Add a snapshot and its indices to the repository. returns a new instance.  If the snapshot  * already exists in the repository data, this method throws an IllegalArgumentException.  */ ;/**  * Add a snapshot and its indices to the repository. returns a new instance.  If the snapshot  * already exists in the repository data, this method throws an IllegalArgumentException.  */ public RepositoryData addSnapshot(final SnapshotId snapshotId, final SnapshotState snapshotState, final List<IndexId> snapshottedIndices) {     if (snapshotIds.containsKey(snapshotId.getUUID())) {         // the new master, so we make the operation idempotent         return this.     }     Map<String, SnapshotId> snapshots = new HashMap<>(snapshotIds).     snapshots.put(snapshotId.getUUID(), snapshotId).     Map<String, SnapshotState> newSnapshotStates = new HashMap<>(snapshotStates).     newSnapshotStates.put(snapshotId.getUUID(), snapshotState).     Map<IndexId, Set<SnapshotId>> allIndexSnapshots = new HashMap<>(indexSnapshots).     for (final IndexId indexId : snapshottedIndices) {         if (allIndexSnapshots.containsKey(indexId)) {             Set<SnapshotId> ids = allIndexSnapshots.get(indexId).             if (ids == null) {                 ids = new LinkedHashSet<>().                 allIndexSnapshots.put(indexId, ids).             }             ids.add(snapshotId).         } else {             Set<SnapshotId> ids = new LinkedHashSet<>().             ids.add(snapshotId).             allIndexSnapshots.put(indexId, ids).         }     }     return new RepositoryData(genId, snapshots, newSnapshotStates, allIndexSnapshots, incompatibleSnapshotIds). }
true;public;1;30;/**  * Remove a snapshot and remove any indices that no longer exist in the repository due to the deletion of the snapshot.  */ ;/**  * Remove a snapshot and remove any indices that no longer exist in the repository due to the deletion of the snapshot.  */ public RepositoryData removeSnapshot(final SnapshotId snapshotId) {     Map<String, SnapshotId> newSnapshotIds = snapshotIds.values().stream().filter(id -> !snapshotId.equals(id)).collect(Collectors.toMap(SnapshotId::getUUID, Function.identity())).     if (newSnapshotIds.size() == snapshotIds.size()) {         throw new ResourceNotFoundException("Attempting to remove non-existent snapshot [{}] from repository data", snapshotId).     }     Map<String, SnapshotState> newSnapshotStates = new HashMap<>(snapshotStates).     newSnapshotStates.remove(snapshotId.getUUID()).     Map<IndexId, Set<SnapshotId>> indexSnapshots = new HashMap<>().     for (final IndexId indexId : indices.values()) {         Set<SnapshotId> set.         Set<SnapshotId> snapshotIds = this.indexSnapshots.get(indexId).         assert snapshotIds != null.         if (snapshotIds.contains(snapshotId)) {             if (snapshotIds.size() == 1) {                 // have this index, so just skip over it                 continue.             }             set = new LinkedHashSet<>(snapshotIds).             set.remove(snapshotId).         } else {             set = snapshotIds.         }         indexSnapshots.put(indexId, set).     }     return new RepositoryData(genId, newSnapshotIds, newSnapshotStates, indexSnapshots, incompatibleSnapshotIds). }
true;public;1;7;/**  * Returns an immutable collection of the snapshot ids for the snapshots that contain the given index.  */ ;/**  * Returns an immutable collection of the snapshot ids for the snapshots that contain the given index.  */ public Set<SnapshotId> getSnapshots(final IndexId indexId) {     Set<SnapshotId> snapshotIds = indexSnapshots.get(indexId).     if (snapshotIds == null) {         throw new IllegalArgumentException("unknown snapshot index " + indexId).     }     return snapshotIds. }
false;public;1;15;;@Override public boolean equals(Object obj) {     if (this == obj) {         return true.     }     if (obj == null || getClass() != obj.getClass()) {         return false.     }     RepositoryData that = (RepositoryData) obj.     return snapshotIds.equals(that.snapshotIds) && snapshotStates.equals(that.snapshotStates) && indices.equals(that.indices) && indexSnapshots.equals(that.indexSnapshots) && incompatibleSnapshotIds.equals(that.incompatibleSnapshotIds). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(snapshotIds, snapshotStates, indices, indexSnapshots, incompatibleSnapshotIds). }
true;public;1;11;/**  * Resolve the index name to the index id specific to the repository,  * throwing an exception if the index could not be resolved.  */ ;/**  * Resolve the index name to the index id specific to the repository,  * throwing an exception if the index could not be resolved.  */ public IndexId resolveIndexId(final String indexName) {     if (indices.containsKey(indexName)) {         return indices.get(indexName).     } else {         // in this case, the index id is just the index name         return new IndexId(indexName, indexName).     } }
true;public;1;7;/**  * Resolve the given index names to index ids.  */ ;/**  * Resolve the given index names to index ids.  */ public List<IndexId> resolveIndices(final List<String> indices) {     List<IndexId> resolvedIndices = new ArrayList<>(indices.size()).     for (final String indexName : indices) {         resolvedIndices.add(resolveIndexId(indexName)).     }     return resolvedIndices. }
true;public;1;13;/**  * Resolve the given index names to index ids, creating new index ids for  * new indices in the repository.  */ ;/**  * Resolve the given index names to index ids, creating new index ids for  * new indices in the repository.  */ public List<IndexId> resolveNewIndices(final List<String> indicesToResolve) {     List<IndexId> snapshotIndices = new ArrayList<>().     for (String index : indicesToResolve) {         final IndexId indexId.         if (indices.containsKey(index)) {             indexId = indices.get(index).         } else {             indexId = new IndexId(index, UUIDs.randomBase64UUID()).         }         snapshotIndices.add(indexId).     }     return snapshotIndices. }
true;public;2;32;/**  * Writes the snapshots metadata and the related indices metadata to x-content, omitting the  * incompatible snapshots.  */ ;/**  * Writes the snapshots metadata and the related indices metadata to x-content, omitting the  * incompatible snapshots.  */ public XContentBuilder snapshotsToXContent(final XContentBuilder builder, final ToXContent.Params params) throws IOException {     builder.startObject().     // write the snapshots list     builder.startArray(SNAPSHOTS).     for (final SnapshotId snapshot : getSnapshotIds()) {         builder.startObject().         builder.field(NAME, snapshot.getName()).         builder.field(UUID, snapshot.getUUID()).         if (snapshotStates.containsKey(snapshot.getUUID())) {             builder.field(STATE, snapshotStates.get(snapshot.getUUID()).value()).         }         builder.endObject().     }     builder.endArray().     // write the indices map     builder.startObject(INDICES).     for (final IndexId indexId : getIndices().values()) {         builder.startObject(indexId.getName()).         builder.field(INDEX_ID, indexId.getId()).         builder.startArray(SNAPSHOTS).         Set<SnapshotId> snapshotIds = indexSnapshots.get(indexId).         assert snapshotIds != null.         for (final SnapshotId snapshotId : snapshotIds) {             builder.value(snapshotId.getUUID()).         }         builder.endArray().         builder.endObject().     }     builder.endObject().     builder.endObject().     return builder. }
true;public,static;2;105;/**  * Reads an instance of {@link RepositoryData} from x-content, loading the snapshots and indices metadata.  */ ;/**  * Reads an instance of {@link RepositoryData} from x-content, loading the snapshots and indices metadata.  */ public static RepositoryData snapshotsFromXContent(final XContentParser parser, long genId) throws IOException {     final Map<String, SnapshotId> snapshots = new HashMap<>().     final Map<String, SnapshotState> snapshotStates = new HashMap<>().     final Map<IndexId, Set<SnapshotId>> indexSnapshots = new HashMap<>().     if (parser.nextToken() == XContentParser.Token.START_OBJECT) {         while (parser.nextToken() == XContentParser.Token.FIELD_NAME) {             String field = parser.currentName().             if (SNAPSHOTS.equals(field)) {                 if (parser.nextToken() == XContentParser.Token.START_ARRAY) {                     while (parser.nextToken() != XContentParser.Token.END_ARRAY) {                         final SnapshotId snapshotId.                         // the new format from 5.0 which contains the snapshot name and uuid                         if (parser.currentToken() == XContentParser.Token.START_OBJECT) {                             String name = null.                             String uuid = null.                             SnapshotState state = null.                             while (parser.nextToken() != XContentParser.Token.END_OBJECT) {                                 String currentFieldName = parser.currentName().                                 parser.nextToken().                                 if (NAME.equals(currentFieldName)) {                                     name = parser.text().                                 } else if (UUID.equals(currentFieldName)) {                                     uuid = parser.text().                                 } else if (STATE.equals(currentFieldName)) {                                     state = SnapshotState.fromValue(parser.numberValue().byteValue()).                                 }                             }                             snapshotId = new SnapshotId(name, uuid).                             if (state != null) {                                 snapshotStates.put(uuid, state).                             }                         } else {                             // the old format pre 5.0 that only contains the snapshot name, use the name as the uuid too                             final String name = parser.text().                             snapshotId = new SnapshotId(name, name).                         }                         snapshots.put(snapshotId.getUUID(), snapshotId).                     }                 } else {                     throw new ElasticsearchParseException("expected array for [" + field + "]").                 }             } else if (INDICES.equals(field)) {                 if (parser.nextToken() != XContentParser.Token.START_OBJECT) {                     throw new ElasticsearchParseException("start object expected [indices]").                 }                 while (parser.nextToken() != XContentParser.Token.END_OBJECT) {                     final String indexName = parser.currentName().                     final Set<SnapshotId> snapshotIds = new LinkedHashSet<>().                     IndexId indexId = null.                     if (parser.nextToken() != XContentParser.Token.START_OBJECT) {                         throw new ElasticsearchParseException("start object expected index[" + indexName + "]").                     }                     while (parser.nextToken() != XContentParser.Token.END_OBJECT) {                         final String indexMetaFieldName = parser.currentName().                         parser.nextToken().                         if (INDEX_ID.equals(indexMetaFieldName)) {                             indexId = new IndexId(indexName, parser.text()).                         } else if (SNAPSHOTS.equals(indexMetaFieldName)) {                             if (parser.currentToken() != XContentParser.Token.START_ARRAY) {                                 throw new ElasticsearchParseException("start array expected [snapshots]").                             }                             while (parser.nextToken() != XContentParser.Token.END_ARRAY) {                                 String uuid = null.                                 // the old format pre 5.4.1 which contains the snapshot name and uuid                                 if (parser.currentToken() == XContentParser.Token.START_OBJECT) {                                     while (parser.nextToken() != XContentParser.Token.END_OBJECT) {                                         String currentFieldName = parser.currentName().                                         parser.nextToken().                                         if (UUID.equals(currentFieldName)) {                                             uuid = parser.text().                                         }                                     }                                 } else {                                     // the new format post 5.4.1 that only contains the snapshot uuid,                                     // since we already have the name/uuid combo in the snapshots array                                     uuid = parser.text().                                 }                                 SnapshotId snapshotId = snapshots.get(uuid).                                 if (snapshotId != null) {                                     snapshotIds.add(snapshotId).                                 } else {                                     // different versions create or delete snapshot in the same repository.                                     throw new ElasticsearchParseException("Detected a corrupted repository, index " + indexId + " references an unknown snapshot uuid [" + uuid + "]").                                 }                             }                         }                     }                     assert indexId != null.                     indexSnapshots.put(indexId, snapshotIds).                 }             } else {                 throw new ElasticsearchParseException("unknown field name  [" + field + "]").             }         }     } else {         throw new ElasticsearchParseException("start object expected").     }     return new RepositoryData(genId, snapshots, snapshotStates, indexSnapshots, Collections.emptyList()). }
true;public;2;13;/**  * Writes the incompatible snapshot ids to x-content.  */ ;/**  * Writes the incompatible snapshot ids to x-content.  */ public XContentBuilder incompatibleSnapshotsToXContent(final XContentBuilder builder, final ToXContent.Params params) throws IOException {     builder.startObject().     // write the incompatible snapshots list     builder.startArray(INCOMPATIBLE_SNAPSHOTS).     for (final SnapshotId snapshot : getIncompatibleSnapshotIds()) {         snapshot.toXContent(builder, params).     }     builder.endArray().     builder.endObject().     return builder. }
true;public;1;22;/**  * Reads the incompatible snapshot ids from x-content, loading them into a new instance of {@link RepositoryData}  * that is created from the invoking instance, plus the incompatible snapshots that are read from x-content.  */ ;/**  * Reads the incompatible snapshot ids from x-content, loading them into a new instance of {@link RepositoryData}  * that is created from the invoking instance, plus the incompatible snapshots that are read from x-content.  */ public RepositoryData incompatibleSnapshotsFromXContent(final XContentParser parser) throws IOException {     List<SnapshotId> incompatibleSnapshotIds = new ArrayList<>().     if (parser.nextToken() == XContentParser.Token.START_OBJECT) {         while (parser.nextToken() == XContentParser.Token.FIELD_NAME) {             String currentFieldName = parser.currentName().             if (INCOMPATIBLE_SNAPSHOTS.equals(currentFieldName)) {                 if (parser.nextToken() == XContentParser.Token.START_ARRAY) {                     while (parser.nextToken() != XContentParser.Token.END_ARRAY) {                         incompatibleSnapshotIds.add(SnapshotId.fromXContent(parser)).                     }                 } else {                     throw new ElasticsearchParseException("expected array for [" + currentFieldName + "]").                 }             } else {                 throw new ElasticsearchParseException("unknown field name  [" + currentFieldName + "]").             }         }     } else {         throw new ElasticsearchParseException("start object expected").     }     return new RepositoryData(this.genId, this.snapshotIds, this.snapshotStates, this.indexSnapshots, incompatibleSnapshotIds). }
