commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;public Mapper.TypeParser.ParserContext parserContext(String type) {     return new Mapper.TypeParser.ParserContext(type, indexAnalyzers, similarityService::getSimilarity, mapperService, typeParsers::get, indexVersionCreated, queryShardContextSupplier). }
false;public;2;3;;public DocumentMapper parse(@Nullable String type, CompressedXContent source) throws MapperParsingException {     return parse(type, source, null). }
false;public;3;13;;public DocumentMapper parse(@Nullable String type, CompressedXContent source, String defaultSource) throws MapperParsingException {     Map<String, Object> mapping = null.     if (source != null) {         Map<String, Object> root = XContentHelper.convertToMap(source.compressedReference(), true, XContentType.JSON).v2().         Tuple<String, Map<String, Object>> t = extractMapping(type, root).         type = t.v1().         mapping = t.v2().     }     if (mapping == null) {         mapping = new HashMap<>().     }     return parse(type, mapping, defaultSource). }
false;private;3;49;;@SuppressWarnings({ "unchecked" }) private DocumentMapper parse(String type, Map<String, Object> mapping, String defaultSource) throws MapperParsingException {     if (type == null) {         throw new MapperParsingException("Failed to derive type").     }     if (defaultSource != null) {         Tuple<String, Map<String, Object>> t = extractMapping(MapperService.DEFAULT_MAPPING, defaultSource).         if (t.v2() != null) {             XContentHelper.mergeDefaults(mapping, t.v2()).         }     }     Mapper.TypeParser.ParserContext parserContext = parserContext(type).     // parse RootObjectMapper     DocumentMapper.Builder docBuilder = new DocumentMapper.Builder((RootObjectMapper.Builder) rootObjectTypeParser.parse(type, mapping, parserContext), mapperService).     Iterator<Map.Entry<String, Object>> iterator = mapping.entrySet().iterator().     // parse DocumentMapper     while (iterator.hasNext()) {         Map.Entry<String, Object> entry = iterator.next().         String fieldName = entry.getKey().         Object fieldNode = entry.getValue().         MetadataFieldMapper.TypeParser typeParser = rootTypeParsers.get(fieldName).         if (typeParser != null) {             iterator.remove().             if (false == fieldNode instanceof Map) {                 throw new IllegalArgumentException("[_parent] must be an object containing [type]").             }             Map<String, Object> fieldNodeMap = (Map<String, Object>) fieldNode.             docBuilder.put(typeParser.parse(fieldName, fieldNodeMap, parserContext)).             fieldNodeMap.remove("type").             checkNoRemainingFields(fieldName, fieldNodeMap, parserContext.indexVersionCreated()).         }     }     Map<String, Object> meta = (Map<String, Object>) mapping.remove("_meta").     if (meta != null) {         // It may not be required to copy meta here to maintain immutability         // but the cost is pretty low here.         docBuilder.meta(unmodifiableMap(new HashMap<>(meta))).     }     checkNoRemainingFields(mapping, parserContext.indexVersionCreated(), "Root mapping definition has unsupported parameters: ").     return docBuilder.build(mapperService). }
false;public,static;3;4;;public static void checkNoRemainingFields(String fieldName, Map<?, ?> fieldNodeMap, Version indexVersionCreated) {     checkNoRemainingFields(fieldNodeMap, indexVersionCreated, "Mapping definition for [" + fieldName + "] has unsupported parameters: "). }
false;public,static;3;5;;public static void checkNoRemainingFields(Map<?, ?> fieldNodeMap, Version indexVersionCreated, String message) {     if (!fieldNodeMap.isEmpty()) {         throw new MapperParsingException(message + getRemainingFields(fieldNodeMap)).     } }
false;private,static;1;7;;private static String getRemainingFields(Map<?, ?> map) {     StringBuilder remainingFields = new StringBuilder().     for (Object key : map.keySet()) {         remainingFields.append(" [").append(key).append(" : ").append(map.get(key)).append("]").     }     return remainingFields.toString(). }
false;private;2;10;;private Tuple<String, Map<String, Object>> extractMapping(String type, String source) throws MapperParsingException {     Map<String, Object> root.     try (XContentParser parser = XContentType.JSON.xContent().createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, source)) {         root = parser.mapOrdered().     } catch (Exception e) {         throw new MapperParsingException("failed to parse mapping definition", e).     }     return extractMapping(type, root). }
true;private;2;19;/**  * Given an optional type name and mapping definition, returns the type and a normalized form of the mappings.  *  * The provided mapping definition may or may not contain the type name as the root key in the map. This method  * attempts to unwrap the mappings, so that they no longer contain a type name at the root. If no type name can  * be found, through either the 'type' parameter or by examining the provided mappings, then an exception will be  * thrown.  *  * @param type An optional type name.  * @param root The mapping definition.  *  * @return A tuple of the form (type, normalized mappings).  */ ;/**  * Given an optional type name and mapping definition, returns the type and a normalized form of the mappings.  *  * The provided mapping definition may or may not contain the type name as the root key in the map. This method  * attempts to unwrap the mappings, so that they no longer contain a type name at the root. If no type name can  * be found, through either the 'type' parameter or by examining the provided mappings, then an exception will be  * thrown.  *  * @param type An optional type name.  * @param root The mapping definition.  *  * @return A tuple of the form (type, normalized mappings).  */ @SuppressWarnings({ "unchecked" }) private Tuple<String, Map<String, Object>> extractMapping(String type, Map<String, Object> root) throws MapperParsingException {     if (root.size() == 0) {         if (type != null) {             return new Tuple<>(type, root).         } else {             throw new MapperParsingException("malformed mapping, no type name found").         }     }     String rootName = root.keySet().iterator().next().     Tuple<String, Map<String, Object>> mapping.     if (type == null || type.equals(rootName) || mapperService.resolveDocumentType(type).equals(rootName)) {         mapping = new Tuple<>(rootName, (Map<String, Object>) root.get(rootName)).     } else {         mapping = new Tuple<>(type, root).     }     return mapping. }
false;;0;3;;NamedXContentRegistry getXContentRegistry() {     return xContentRegistry. }
