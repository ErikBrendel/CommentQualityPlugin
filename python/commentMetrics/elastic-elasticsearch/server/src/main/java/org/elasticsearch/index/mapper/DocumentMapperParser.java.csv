# id;timestamp;commentText;codeText;commentWords;codeWords
DocumentMapperParser -> @SuppressWarnings({"unchecked"})     private Tuple<String, Map<String, Object>> extractMapping(String type, Map<String, Object> root) throws MapperParsingException;1546545188;Given an optional type name and mapping definition, returns the type and a normalized form of the mappings.__The provided mapping definition may or may not contain the type name as the root key in the map. This method_attempts to unwrap the mappings, so that they no longer contain a type name at the root. If no type name can_be found, through either the 'type' parameter or by examining the provided mappings, then an exception will be_thrown.__@param type An optional type name._@param root The mapping definition.__@return A tuple of the form (type, normalized mappings).;@SuppressWarnings({"unchecked"})_    private Tuple<String, Map<String, Object>> extractMapping(String type, Map<String, Object> root) throws MapperParsingException {_        if (root.size() == 0) {_            if (type != null) {_                return new Tuple<>(type, root)__            } else {_                throw new MapperParsingException("malformed mapping, no type name found")__            }_        }__        String rootName = root.keySet().iterator().next()__        Tuple<String, Map<String, Object>> mapping__        if (type == null || type.equals(rootName)) {_            mapping = new Tuple<>(rootName, (Map<String, Object>) root.get(rootName))__        } else {_            mapping = new Tuple<>(type, root)__        }_        return mapping__    };given,an,optional,type,name,and,mapping,definition,returns,the,type,and,a,normalized,form,of,the,mappings,the,provided,mapping,definition,may,or,may,not,contain,the,type,name,as,the,root,key,in,the,map,this,method,attempts,to,unwrap,the,mappings,so,that,they,no,longer,contain,a,type,name,at,the,root,if,no,type,name,can,be,found,through,either,the,type,parameter,or,by,examining,the,provided,mappings,then,an,exception,will,be,thrown,param,type,an,optional,type,name,param,root,the,mapping,definition,return,a,tuple,of,the,form,type,normalized,mappings;suppress,warnings,unchecked,private,tuple,string,map,string,object,extract,mapping,string,type,map,string,object,root,throws,mapper,parsing,exception,if,root,size,0,if,type,null,return,new,tuple,type,root,else,throw,new,mapper,parsing,exception,malformed,mapping,no,type,name,found,string,root,name,root,key,set,iterator,next,tuple,string,map,string,object,mapping,if,type,null,type,equals,root,name,mapping,new,tuple,root,name,map,string,object,root,get,root,name,else,mapping,new,tuple,type,root,return,mapping
DocumentMapperParser -> @SuppressWarnings({"unchecked"})     private Tuple<String, Map<String, Object>> extractMapping(String type, Map<String, Object> root) throws MapperParsingException;1547566367;Given an optional type name and mapping definition, returns the type and a normalized form of the mappings.__The provided mapping definition may or may not contain the type name as the root key in the map. This method_attempts to unwrap the mappings, so that they no longer contain a type name at the root. If no type name can_be found, through either the 'type' parameter or by examining the provided mappings, then an exception will be_thrown.__@param type An optional type name._@param root The mapping definition.__@return A tuple of the form (type, normalized mappings).;@SuppressWarnings({"unchecked"})_    private Tuple<String, Map<String, Object>> extractMapping(String type, Map<String, Object> root) throws MapperParsingException {_        if (root.size() == 0) {_            if (type != null) {_                return new Tuple<>(type, root)__            } else {_                throw new MapperParsingException("malformed mapping, no type name found")__            }_        }__        String rootName = root.keySet().iterator().next()__        Tuple<String, Map<String, Object>> mapping__        if (type == null || type.equals(rootName) || mapperService.resolveDocumentType(type).equals(rootName)) {_            mapping = new Tuple<>(rootName, (Map<String, Object>) root.get(rootName))__        } else {_            mapping = new Tuple<>(type, root)__        }_        return mapping__    };given,an,optional,type,name,and,mapping,definition,returns,the,type,and,a,normalized,form,of,the,mappings,the,provided,mapping,definition,may,or,may,not,contain,the,type,name,as,the,root,key,in,the,map,this,method,attempts,to,unwrap,the,mappings,so,that,they,no,longer,contain,a,type,name,at,the,root,if,no,type,name,can,be,found,through,either,the,type,parameter,or,by,examining,the,provided,mappings,then,an,exception,will,be,thrown,param,type,an,optional,type,name,param,root,the,mapping,definition,return,a,tuple,of,the,form,type,normalized,mappings;suppress,warnings,unchecked,private,tuple,string,map,string,object,extract,mapping,string,type,map,string,object,root,throws,mapper,parsing,exception,if,root,size,0,if,type,null,return,new,tuple,type,root,else,throw,new,mapper,parsing,exception,malformed,mapping,no,type,name,found,string,root,name,root,key,set,iterator,next,tuple,string,map,string,object,mapping,if,type,null,type,equals,root,name,mapper,service,resolve,document,type,type,equals,root,name,mapping,new,tuple,root,name,map,string,object,root,get,root,name,else,mapping,new,tuple,type,root,return,mapping
DocumentMapperParser -> @SuppressWarnings({"unchecked"})     private Tuple<String, Map<String, Object>> extractMapping(String type, Map<String, Object> root) throws MapperParsingException;1548834350;Given an optional type name and mapping definition, returns the type and a normalized form of the mappings.__The provided mapping definition may or may not contain the type name as the root key in the map. This method_attempts to unwrap the mappings, so that they no longer contain a type name at the root. If no type name can_be found, through either the 'type' parameter or by examining the provided mappings, then an exception will be_thrown.__@param type An optional type name._@param root The mapping definition.__@return A tuple of the form (type, normalized mappings).;@SuppressWarnings({"unchecked"})_    private Tuple<String, Map<String, Object>> extractMapping(String type, Map<String, Object> root) throws MapperParsingException {_        if (root.size() == 0) {_            if (type != null) {_                return new Tuple<>(type, root)__            } else {_                throw new MapperParsingException("malformed mapping, no type name found")__            }_        }__        String rootName = root.keySet().iterator().next()__        Tuple<String, Map<String, Object>> mapping__        if (type == null || type.equals(rootName) || mapperService.resolveDocumentType(type).equals(rootName)) {_            mapping = new Tuple<>(rootName, (Map<String, Object>) root.get(rootName))__        } else {_            mapping = new Tuple<>(type, root)__        }_        return mapping__    };given,an,optional,type,name,and,mapping,definition,returns,the,type,and,a,normalized,form,of,the,mappings,the,provided,mapping,definition,may,or,may,not,contain,the,type,name,as,the,root,key,in,the,map,this,method,attempts,to,unwrap,the,mappings,so,that,they,no,longer,contain,a,type,name,at,the,root,if,no,type,name,can,be,found,through,either,the,type,parameter,or,by,examining,the,provided,mappings,then,an,exception,will,be,thrown,param,type,an,optional,type,name,param,root,the,mapping,definition,return,a,tuple,of,the,form,type,normalized,mappings;suppress,warnings,unchecked,private,tuple,string,map,string,object,extract,mapping,string,type,map,string,object,root,throws,mapper,parsing,exception,if,root,size,0,if,type,null,return,new,tuple,type,root,else,throw,new,mapper,parsing,exception,malformed,mapping,no,type,name,found,string,root,name,root,key,set,iterator,next,tuple,string,map,string,object,mapping,if,type,null,type,equals,root,name,mapper,service,resolve,document,type,type,equals,root,name,mapping,new,tuple,root,name,map,string,object,root,get,root,name,else,mapping,new,tuple,type,root,return,mapping
