commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;10;;@Override protected void doWriteTo(StreamOutput out) throws IOException {     out.writeString(fieldName).     out.writeVInt(shell.size()).     for (GeoPoint point : shell) {         out.writeGeoPoint(point).     }     validationMethod.writeTo(out).     out.writeBoolean(ignoreUnmapped). }
false;public;0;3;;public String fieldName() {     return fieldName. }
false;public;0;3;;public List<GeoPoint> points() {     return shell. }
true;public;1;4;/**  * Sets the validation method to use for geo coordinates.  */ ;/**  * Sets the validation method to use for geo coordinates.  */ public GeoPolygonQueryBuilder setValidationMethod(GeoValidationMethod method) {     this.validationMethod = method.     return this. }
true;public;0;3;/**  * Returns the validation method to use for geo coordinates.  */ ;/**  * Returns the validation method to use for geo coordinates.  */ public GeoValidationMethod getValidationMethod() {     return this.validationMethod. }
true;public;1;4;/**  * Sets whether the query builder should ignore unmapped fields (and run a  * {@link MatchNoDocsQuery} in place of this query) or throw an exception if  * the field is unmapped.  */ ;/**  * Sets whether the query builder should ignore unmapped fields (and run a  * {@link MatchNoDocsQuery} in place of this query) or throw an exception if  * the field is unmapped.  */ public GeoPolygonQueryBuilder ignoreUnmapped(boolean ignoreUnmapped) {     this.ignoreUnmapped = ignoreUnmapped.     return this. }
true;public;0;3;/**  * Gets whether the query builder will ignore unmapped fields (and run a  * {@link MatchNoDocsQuery} in place of this query) or throw an exception if  * the field is unmapped.  */ ;/**  * Gets whether the query builder will ignore unmapped fields (and run a  * {@link MatchNoDocsQuery} in place of this query) or throw an exception if  * the field is unmapped.  */ public boolean ignoreUnmapped() {     return ignoreUnmapped. }
false;protected;1;52;;@Override protected Query doToQuery(QueryShardContext context) throws IOException {     MappedFieldType fieldType = context.fieldMapper(fieldName).     if (fieldType == null) {         if (ignoreUnmapped) {             return new MatchNoDocsQuery().         } else {             throw new QueryShardException(context, "failed to find geo_point field [" + fieldName + "]").         }     }     if (!(fieldType instanceof GeoPointFieldType)) {         throw new QueryShardException(context, "field [" + fieldName + "] is not a geo_point field").     }     List<GeoPoint> shell = new ArrayList<>(this.shell.size()).     for (GeoPoint geoPoint : this.shell) {         shell.add(new GeoPoint(geoPoint)).     }     final int shellSize = shell.size().     // percolation queries we only ignore_malformed on 2.x created indexes     if (!GeoValidationMethod.isIgnoreMalformed(validationMethod)) {         for (GeoPoint point : shell) {             if (!GeoUtils.isValidLatitude(point.lat())) {                 throw new QueryShardException(context, "illegal latitude value [{}] for [{}]", point.lat(), GeoPolygonQueryBuilder.NAME).             }             if (!GeoUtils.isValidLongitude(point.lon())) {                 throw new QueryShardException(context, "illegal longitude value [{}] for [{}]", point.lon(), GeoPolygonQueryBuilder.NAME).             }         }     }     if (GeoValidationMethod.isCoerce(validationMethod)) {         for (GeoPoint point : shell) {             GeoUtils.normalizePoint(point, true, true).         }     }     double[] lats = new double[shellSize].     double[] lons = new double[shellSize].     GeoPoint p.     for (int i = 0. i < shellSize. ++i) {         p = shell.get(i).         lats[i] = p.lat().         lons[i] = p.lon().     }     return LatLonPoint.newPolygonQuery(fieldType.name(), new Polygon(lats, lons)). }
false;protected;2;18;;@Override protected void doXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject(NAME).     builder.startObject(fieldName).     builder.startArray(POINTS_FIELD.getPreferredName()).     for (GeoPoint point : shell) {         builder.startArray().value(point.lon()).value(point.lat()).endArray().     }     builder.endArray().     builder.endObject().     builder.field(VALIDATION_METHOD.getPreferredName(), validationMethod).     builder.field(IGNORE_UNMAPPED_FIELD.getPreferredName(), ignoreUnmapped).     printBoostAndQueryName(builder).     builder.endObject(). }
false;public,static;1;68;;public static GeoPolygonQueryBuilder fromXContent(XContentParser parser) throws IOException {     String fieldName = null.     List<GeoPoint> shell = null.     Float boost = null.     GeoValidationMethod validationMethod = null.     String queryName = null.     String currentFieldName = null.     XContentParser.Token token.     boolean ignoreUnmapped = DEFAULT_IGNORE_UNMAPPED.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (token == XContentParser.Token.START_OBJECT) {             fieldName = currentFieldName.             while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {                 if (token == XContentParser.Token.FIELD_NAME) {                     currentFieldName = parser.currentName().                 } else if (token == XContentParser.Token.START_ARRAY) {                     if (POINTS_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                         shell = new ArrayList<>().                         while ((token = parser.nextToken()) != Token.END_ARRAY) {                             shell.add(GeoUtils.parseGeoPoint(parser)).                         }                     } else {                         throw new ParsingException(parser.getTokenLocation(), "[geo_polygon] query does not support [" + currentFieldName + "]").                     }                 } else {                     throw new ParsingException(parser.getTokenLocation(), "[geo_polygon] query does not support token type [" + token.name() + "] under [" + currentFieldName + "]").                 }             }         } else if (token.isValue()) {             if ("_name".equals(currentFieldName)) {                 queryName = parser.text().             } else if ("boost".equals(currentFieldName)) {                 boost = parser.floatValue().             } else if (IGNORE_UNMAPPED_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 ignoreUnmapped = parser.booleanValue().             } else if (VALIDATION_METHOD.match(currentFieldName, parser.getDeprecationHandler())) {                 validationMethod = GeoValidationMethod.fromString(parser.text()).             } else {                 throw new ParsingException(parser.getTokenLocation(), "[geo_polygon] query does not support [" + currentFieldName + "]").             }         } else {             throw new ParsingException(parser.getTokenLocation(), "[geo_polygon] unexpected token type [" + token.name() + "]").         }     }     GeoPolygonQueryBuilder builder = new GeoPolygonQueryBuilder(fieldName, shell).     if (validationMethod != null) {         // if GeoValidationMethod was explicitly set ignore deprecated coerce and ignoreMalformed settings         builder.setValidationMethod(validationMethod).     }     if (queryName != null) {         builder.queryName(queryName).     }     if (boost != null) {         builder.boost(boost).     }     builder.ignoreUnmapped(ignoreUnmapped).     return builder. }
false;protected;1;7;;@Override protected boolean doEquals(GeoPolygonQueryBuilder other) {     return Objects.equals(validationMethod, other.validationMethod) && Objects.equals(fieldName, other.fieldName) && Objects.equals(shell, other.shell) && Objects.equals(ignoreUnmapped, other.ignoreUnmapped). }
false;protected;0;4;;@Override protected int doHashCode() {     return Objects.hash(validationMethod, fieldName, shell, ignoreUnmapped). }
false;public;0;4;;@Override public String getWriteableName() {     return NAME. }
