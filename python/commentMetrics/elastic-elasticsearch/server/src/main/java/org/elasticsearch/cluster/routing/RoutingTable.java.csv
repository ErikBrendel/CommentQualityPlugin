commented;modifiers;parameterAmount;loc;comment;code
true;public,static;2;7;/**  * Get's the {@link IndexShardRoutingTable} for the given shard id from the given {@link IndexRoutingTable}  * or throws a {@link ShardNotFoundException} if no shard by the given id is found in the IndexRoutingTable.  *  * @param indexRouting IndexRoutingTable  * @param shardId ShardId  * @return IndexShardRoutingTable  */ ;/**  * Get's the {@link IndexShardRoutingTable} for the given shard id from the given {@link IndexRoutingTable}  * or throws a {@link ShardNotFoundException} if no shard by the given id is found in the IndexRoutingTable.  *  * @param indexRouting IndexRoutingTable  * @param shardId ShardId  * @return IndexShardRoutingTable  */ public static IndexShardRoutingTable shardRoutingTable(IndexRoutingTable indexRouting, int shardId) {     IndexShardRoutingTable indexShard = indexRouting.shard(shardId).     if (indexShard == null) {         throw new ShardNotFoundException(new ShardId(indexRouting.getIndex(), shardId)).     }     return indexShard. }
true;public;0;3;/**  * Returns the version of the {@link RoutingTable}.  *  * @return version of the {@link RoutingTable}  */ ;/**  * Returns the version of the {@link RoutingTable}.  *  * @return version of the {@link RoutingTable}  */ public long version() {     return this.version. }
false;public;0;4;;@Override public Iterator<IndexRoutingTable> iterator() {     return indicesRouting.valuesIt(). }
false;public;1;3;;public boolean hasIndex(String index) {     return indicesRouting.containsKey(index). }
false;public;1;4;;public boolean hasIndex(Index index) {     IndexRoutingTable indexRouting = index(index.getName()).     return indexRouting != null && indexRouting.getIndex().equals(index). }
false;public;1;3;;public IndexRoutingTable index(String index) {     return indicesRouting.get(index). }
false;public;1;3;;public IndexRoutingTable index(Index index) {     return indicesRouting.get(index.getName()). }
false;public;0;3;;public ImmutableOpenMap<String, IndexRoutingTable> indicesRouting() {     return indicesRouting. }
false;public;0;3;;public ImmutableOpenMap<String, IndexRoutingTable> getIndicesRouting() {     return indicesRouting(). }
true;public;2;7;/**  * All shards for the provided index and shard id  * @return All the shard routing entries for the given index and shard id  * @throws IndexNotFoundException if provided index does not exist  * @throws ShardNotFoundException if provided shard id is unknown  */ ;/**  * All shards for the provided index and shard id  * @return All the shard routing entries for the given index and shard id  * @throws IndexNotFoundException if provided index does not exist  * @throws ShardNotFoundException if provided shard id is unknown  */ public IndexShardRoutingTable shardRoutingTable(String index, int shardId) {     IndexRoutingTable indexRouting = index(index).     if (indexRouting == null) {         throw new IndexNotFoundException(index).     }     return shardRoutingTable(indexRouting, shardId). }
true;public;1;11;/**  * All shards for the provided {@link ShardId}  * @return All the shard routing entries for the given index and shard id  * @throws IndexNotFoundException if provided index does not exist  * @throws ShardNotFoundException if provided shard id is unknown  */ ;/**  * All shards for the provided {@link ShardId}  * @return All the shard routing entries for the given index and shard id  * @throws IndexNotFoundException if provided index does not exist  * @throws ShardNotFoundException if provided shard id is unknown  */ public IndexShardRoutingTable shardRoutingTable(ShardId shardId) {     IndexRoutingTable indexRouting = index(shardId.getIndexName()).     if (indexRouting == null || indexRouting.getIndex().equals(shardId.getIndex()) == false) {         throw new IndexNotFoundException(shardId.getIndex()).     }     IndexShardRoutingTable shard = indexRouting.shard(shardId.id()).     if (shard == null) {         throw new ShardNotFoundException(shardId).     }     return shard. }
false;public;2;9;;@Nullable public ShardRouting getByAllocationId(ShardId shardId, String allocationId) {     final IndexRoutingTable indexRoutingTable = index(shardId.getIndexName()).     if (indexRoutingTable == null) {         return null.     }     final IndexShardRoutingTable shardRoutingTable = indexRoutingTable.shard(shardId.getId()).     return shardRoutingTable == null ? null : shardRoutingTable.getByAllocationId(allocationId). }
false;public;1;8;;public boolean validate(MetaData metaData) {     for (IndexRoutingTable indexRoutingTable : this) {         if (indexRoutingTable.validate(metaData) == false) {             return false.         }     }     return true. }
false;public;1;7;;public List<ShardRouting> shardsWithState(ShardRoutingState state) {     List<ShardRouting> shards = new ArrayList<>().     for (IndexRoutingTable indexRoutingTable : this) {         shards.addAll(indexRoutingTable.shardsWithState(state)).     }     return shards. }
true;public;0;9;/**  * All the shards (replicas) for all indices in this routing table.  *  * @return All the shards  */ ;/**  * All the shards (replicas) for all indices in this routing table.  *  * @return All the shards  */ public List<ShardRouting> allShards() {     List<ShardRouting> shards = new ArrayList<>().     String[] indices = indicesRouting.keys().toArray(String.class).     for (String index : indices) {         List<ShardRouting> allShardsIndex = allShards(index).         shards.addAll(allShardsIndex).     }     return shards. }
true;public;1;13;/**  * All the shards (replicas) for the provided index.  *  * @param index The index to return all the shards (replicas).  * @return All the shards matching the specific index  * @throws IndexNotFoundException If the index passed does not exists  */ ;/**  * All the shards (replicas) for the provided index.  *  * @param index The index to return all the shards (replicas).  * @return All the shards matching the specific index  * @throws IndexNotFoundException If the index passed does not exists  */ public List<ShardRouting> allShards(String index) {     List<ShardRouting> shards = new ArrayList<>().     IndexRoutingTable indexRoutingTable = index(index).     if (indexRoutingTable == null) {         throw new IndexNotFoundException(index).     }     for (IndexShardRoutingTable indexShardRoutingTable : indexRoutingTable) {         for (ShardRouting shardRouting : indexShardRoutingTable) {             shards.add(shardRouting).         }     }     return shards. }
true;public;2;3;/**  * Return GroupShardsIterator where each active shard routing has it's own shard iterator.  *  * @param includeEmpty             if true, a shard iterator will be added for non-assigned shards as well  */ ;/**  * Return GroupShardsIterator where each active shard routing has it's own shard iterator.  *  * @param includeEmpty             if true, a shard iterator will be added for non-assigned shards as well  */ public GroupShardsIterator<ShardIterator> allActiveShardsGrouped(String[] indices, boolean includeEmpty) {     return allSatisfyingPredicateShardsGrouped(indices, includeEmpty, ACTIVE_PREDICATE). }
true;public;2;3;/**  * Return GroupShardsIterator where each assigned shard routing has it's own shard iterator.  *  * @param includeEmpty if true, a shard iterator will be added for non-assigned shards as well  */ ;/**  * Return GroupShardsIterator where each assigned shard routing has it's own shard iterator.  *  * @param includeEmpty if true, a shard iterator will be added for non-assigned shards as well  */ public GroupShardsIterator<ShardIterator> allAssignedShardsGrouped(String[] indices, boolean includeEmpty) {     return allSatisfyingPredicateShardsGrouped(indices, includeEmpty, ASSIGNED_PREDICATE). }
false;private;3;22;;private GroupShardsIterator<ShardIterator> allSatisfyingPredicateShardsGrouped(String[] indices, boolean includeEmpty, Predicate<ShardRouting> predicate) {     // use list here since we need to maintain identity across shards     ArrayList<ShardIterator> set = new ArrayList<>().     for (String index : indices) {         IndexRoutingTable indexRoutingTable = index(index).         if (indexRoutingTable == null) {             continue.         // we simply ignore indices that don't exists (make sense for operations that use it currently)         }         for (IndexShardRoutingTable indexShardRoutingTable : indexRoutingTable) {             for (ShardRouting shardRouting : indexShardRoutingTable) {                 if (predicate.test(shardRouting)) {                     set.add(shardRouting.shardsIt()).                 } else if (includeEmpty) {                     // we need this for counting properly, just make it an empty one                     set.add(new PlainShardIterator(shardRouting.shardId(), Collections.emptyList())).                 }             }         }     }     return new GroupShardsIterator<>(set). }
false;public;1;3;;public ShardsIterator allShards(String[] indices) {     return allShardsSatisfyingPredicate(indices, shardRouting -> true, false). }
false;public;1;3;;public ShardsIterator allShardsIncludingRelocationTargets(String[] indices) {     return allShardsSatisfyingPredicate(indices, shardRouting -> true, true). }
false;private;3;23;;private ShardsIterator allShardsSatisfyingPredicate(String[] indices, Predicate<ShardRouting> predicate, boolean includeRelocationTargets) {     // use list here since we need to maintain identity across shards     List<ShardRouting> shards = new ArrayList<>().     for (String index : indices) {         IndexRoutingTable indexRoutingTable = index(index).         if (indexRoutingTable == null) {             continue.         // we simply ignore indices that don't exists (make sense for operations that use it currently)         }         for (IndexShardRoutingTable indexShardRoutingTable : indexRoutingTable) {             for (ShardRouting shardRouting : indexShardRoutingTable) {                 if (predicate.test(shardRouting)) {                     shards.add(shardRouting).                     if (includeRelocationTargets && shardRouting.relocating()) {                         shards.add(shardRouting.getTargetRelocatingShard()).                     }                 }             }         }     }     return new PlainShardsIterator(shards). }
true;public;2;19;/**  * All the *active* primary shards for the provided indices grouped (each group is a single element, consisting  * of the primary shard). This is handy for components that expect to get group iterators, but still want in some  * cases to iterate over all primary shards (and not just one shard in replication group).  *  * @param indices The indices to return all the shards (replicas)  * @return All the primary shards grouped into a single shard element group each  * @throws IndexNotFoundException If an index passed does not exists  */ ;/**  * All the *active* primary shards for the provided indices grouped (each group is a single element, consisting  * of the primary shard). This is handy for components that expect to get group iterators, but still want in some  * cases to iterate over all primary shards (and not just one shard in replication group).  *  * @param indices The indices to return all the shards (replicas)  * @return All the primary shards grouped into a single shard element group each  * @throws IndexNotFoundException If an index passed does not exists  */ public GroupShardsIterator<ShardIterator> activePrimaryShardsGrouped(String[] indices, boolean includeEmpty) {     // use list here since we need to maintain identity across shards     ArrayList<ShardIterator> set = new ArrayList<>().     for (String index : indices) {         IndexRoutingTable indexRoutingTable = index(index).         if (indexRoutingTable == null) {             throw new IndexNotFoundException(index).         }         for (IndexShardRoutingTable indexShardRoutingTable : indexRoutingTable) {             ShardRouting primary = indexShardRoutingTable.primaryShard().             if (primary.active()) {                 set.add(primary.shardsIt()).             } else if (includeEmpty) {                 // we need this for counting properly, just make it an empty one                 set.add(new PlainShardIterator(primary.shardId(), Collections.emptyList())).             }         }     }     return new GroupShardsIterator<>(set). }
false;public;1;4;;@Override public Diff<RoutingTable> diff(RoutingTable previousState) {     return new RoutingTableDiff(previousState, this). }
false;public,static;1;3;;public static Diff<RoutingTable> readDiffFrom(StreamInput in) throws IOException {     return new RoutingTableDiff(in). }
false;public,static;1;11;;public static RoutingTable readFrom(StreamInput in) throws IOException {     Builder builder = new Builder().     builder.version = in.readLong().     int size = in.readVInt().     for (int i = 0. i < size. i++) {         IndexRoutingTable index = IndexRoutingTable.readFrom(in).         builder.add(index).     }     return builder.build(). }
false;public;1;8;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeLong(version).     out.writeVInt(indicesRouting.size()).     for (ObjectCursor<IndexRoutingTable> index : indicesRouting.values()) {         index.value.writeTo(out).     } }
false;public;1;4;;@Override public RoutingTable apply(RoutingTable part) {     return new RoutingTable(version, indicesRouting.apply(part.indicesRouting)). }
false;public;1;5;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeLong(version).     indicesRouting.writeTo(out). }
false;public,static;0;3;;public static Builder builder() {     return new Builder(). }
false;public,static;1;3;;public static Builder builder(RoutingTable routingTable) {     return new Builder(routingTable). }
false;public;2;26;;public Builder updateNodes(long version, RoutingNodes routingNodes) {     // this is being called without pre initializing the routing table, so we must copy over the version as well     this.version = version.     Map<String, IndexRoutingTable.Builder> indexRoutingTableBuilders = new HashMap<>().     for (RoutingNode routingNode : routingNodes) {         for (ShardRouting shardRoutingEntry : routingNode) {             // every relocating shard has a double entry, ignore the target one.             if (shardRoutingEntry.initializing() && shardRoutingEntry.relocatingNodeId() != null)                 continue.             addShard(indexRoutingTableBuilders, shardRoutingEntry).         }     }     Iterable<ShardRouting> shardRoutingEntries = Iterables.concat(routingNodes.unassigned(), routingNodes.unassigned().ignored()).     for (ShardRouting shardRoutingEntry : shardRoutingEntries) {         addShard(indexRoutingTableBuilders, shardRoutingEntry).     }     for (IndexRoutingTable.Builder indexBuilder : indexRoutingTableBuilders.values()) {         add(indexBuilder).     }     return this. }
false;private,static;2;10;;private static void addShard(final Map<String, IndexRoutingTable.Builder> indexRoutingTableBuilders, final ShardRouting shardRoutingEntry) {     Index index = shardRoutingEntry.index().     IndexRoutingTable.Builder indexBuilder = indexRoutingTableBuilders.get(index.getName()).     if (indexBuilder == null) {         indexBuilder = new IndexRoutingTable.Builder(index).         indexRoutingTableBuilders.put(index.getName(), indexBuilder).     }     indexBuilder.addShard(shardRoutingEntry). }
true;public;2;35;/**  * Update the number of replicas for the specified indices.  *  * @param numberOfReplicas the number of replicas  * @param indices          the indices to update the number of replicas for  * @return the builder  */ ;/**  * Update the number of replicas for the specified indices.  *  * @param numberOfReplicas the number of replicas  * @param indices          the indices to update the number of replicas for  * @return the builder  */ public Builder updateNumberOfReplicas(final int numberOfReplicas, final String[] indices) {     if (indicesRouting == null) {         throw new IllegalStateException("once build is called the builder cannot be reused").     }     for (String index : indices) {         IndexRoutingTable indexRoutingTable = indicesRouting.get(index).         if (indexRoutingTable == null) {             // ignore index missing failure, its closed...             continue.         }         // remove the required primary         int currentNumberOfReplicas = indexRoutingTable.shards().get(0).size() - 1.         IndexRoutingTable.Builder builder = new IndexRoutingTable.Builder(indexRoutingTable.getIndex()).         // re-add all the shards         for (IndexShardRoutingTable indexShardRoutingTable : indexRoutingTable) {             builder.addIndexShard(indexShardRoutingTable).         }         if (currentNumberOfReplicas < numberOfReplicas) {             // now, add "empty" ones             for (int i = 0. i < (numberOfReplicas - currentNumberOfReplicas). i++) {                 builder.addReplica().             }         } else if (currentNumberOfReplicas > numberOfReplicas) {             int delta = currentNumberOfReplicas - numberOfReplicas.             if (delta <= 0) {             // ignore, can't remove below the current one...             } else {                 for (int i = 0. i < delta. i++) {                     builder.removeReplica().                 }             }         }         indicesRouting.put(index, builder.build()).     }     return this. }
false;public;1;8;;public Builder addAsNew(IndexMetaData indexMetaData) {     if (indexMetaData.getState() == IndexMetaData.State.OPEN) {         IndexRoutingTable.Builder indexRoutingBuilder = new IndexRoutingTable.Builder(indexMetaData.getIndex()).initializeAsNew(indexMetaData).         add(indexRoutingBuilder).     }     return this. }
false;public;1;8;;public Builder addAsRecovery(IndexMetaData indexMetaData) {     if (indexMetaData.getState() == IndexMetaData.State.OPEN || isIndexVerifiedBeforeClosed(indexMetaData)) {         IndexRoutingTable.Builder indexRoutingBuilder = new IndexRoutingTable.Builder(indexMetaData.getIndex()).initializeAsRecovery(indexMetaData).         add(indexRoutingBuilder).     }     return this. }
false;public;1;8;;public Builder addAsFromDangling(IndexMetaData indexMetaData) {     if (indexMetaData.getState() == IndexMetaData.State.OPEN) {         IndexRoutingTable.Builder indexRoutingBuilder = new IndexRoutingTable.Builder(indexMetaData.getIndex()).initializeAsFromDangling(indexMetaData).         add(indexRoutingBuilder).     }     return this. }
false;public;1;8;;public Builder addAsFromCloseToOpen(IndexMetaData indexMetaData) {     if (indexMetaData.getState() == IndexMetaData.State.OPEN) {         IndexRoutingTable.Builder indexRoutingBuilder = new IndexRoutingTable.Builder(indexMetaData.getIndex()).initializeAsFromCloseToOpen(indexMetaData).         add(indexRoutingBuilder).     }     return this. }
false;public;1;6;;public Builder addAsFromOpenToClose(IndexMetaData indexMetaData) {     assert isIndexVerifiedBeforeClosed(indexMetaData).     IndexRoutingTable.Builder indexRoutingBuilder = new IndexRoutingTable.Builder(indexMetaData.getIndex()).initializeAsFromOpenToClose(indexMetaData).     return add(indexRoutingBuilder). }
false;public;2;6;;public Builder addAsRestore(IndexMetaData indexMetaData, SnapshotRecoverySource recoverySource) {     IndexRoutingTable.Builder indexRoutingBuilder = new IndexRoutingTable.Builder(indexMetaData.getIndex()).initializeAsRestore(indexMetaData, recoverySource).     add(indexRoutingBuilder).     return this. }
false;public;3;6;;public Builder addAsNewRestore(IndexMetaData indexMetaData, SnapshotRecoverySource recoverySource, IntSet ignoreShards) {     IndexRoutingTable.Builder indexRoutingBuilder = new IndexRoutingTable.Builder(indexMetaData.getIndex()).initializeAsNewRestore(indexMetaData, recoverySource, ignoreShards).     add(indexRoutingBuilder).     return this. }
false;public;1;7;;public Builder add(IndexRoutingTable indexRoutingTable) {     if (indicesRouting == null) {         throw new IllegalStateException("once build is called the builder cannot be reused").     }     indicesRouting.put(indexRoutingTable.getIndex().getName(), indexRoutingTable).     return this. }
false;public;1;4;;public Builder add(IndexRoutingTable.Builder indexRoutingTableBuilder) {     add(indexRoutingTableBuilder.build()).     return this. }
false;public;1;7;;public Builder remove(String index) {     if (indicesRouting == null) {         throw new IllegalStateException("once build is called the builder cannot be reused").     }     indicesRouting.remove(index).     return this. }
false;public;1;4;;public Builder version(long version) {     this.version = version.     return this. }
true;public;0;8;/**  * Builds the routing table. Note that once this is called the builder  * must be thrown away. If you need to build a new RoutingTable as a  * copy of this one you'll need to build a new RoutingTable.Builder.  */ ;/**  * Builds the routing table. Note that once this is called the builder  * must be thrown away. If you need to build a new RoutingTable as a  * copy of this one you'll need to build a new RoutingTable.Builder.  */ public RoutingTable build() {     if (indicesRouting == null) {         throw new IllegalStateException("once build is called the builder cannot be reused").     }     RoutingTable table = new RoutingTable(version, indicesRouting.build()).     indicesRouting = null.     return table. }
false;public;0;8;;@Override public String toString() {     StringBuilder sb = new StringBuilder("routing_table (version ").append(version).append("):\n").     for (ObjectObjectCursor<String, IndexRoutingTable> entry : indicesRouting) {         sb.append(entry.value.prettyPrint()).append('\n').     }     return sb.toString(). }
