# id;timestamp;commentText;codeText;commentWords;codeWords
RoutingTable -> public IndexShardRoutingTable shardRoutingTable(String index, int shardId);1524684173;All shards for the provided index and shard id_@return All the shard routing entries for the given index and shard id_@throws IndexNotFoundException if provided index does not exist_@throws ShardNotFoundException if provided shard id is unknown;public IndexShardRoutingTable shardRoutingTable(String index, int shardId) {_        IndexRoutingTable indexRouting = index(index)__        if (indexRouting == null) {_            throw new IndexNotFoundException(index)__        }_        IndexShardRoutingTable shard = indexRouting.shard(shardId)__        if (shard == null) {_            throw new ShardNotFoundException(new ShardId(indexRouting.getIndex(), shardId))__        }_        return shard__    };all,shards,for,the,provided,index,and,shard,id,return,all,the,shard,routing,entries,for,the,given,index,and,shard,id,throws,index,not,found,exception,if,provided,index,does,not,exist,throws,shard,not,found,exception,if,provided,shard,id,is,unknown;public,index,shard,routing,table,shard,routing,table,string,index,int,shard,id,index,routing,table,index,routing,index,index,if,index,routing,null,throw,new,index,not,found,exception,index,index,shard,routing,table,shard,index,routing,shard,shard,id,if,shard,null,throw,new,shard,not,found,exception,new,shard,id,index,routing,get,index,shard,id,return,shard
RoutingTable -> public IndexShardRoutingTable shardRoutingTable(String index, int shardId);1539723533;All shards for the provided index and shard id_@return All the shard routing entries for the given index and shard id_@throws IndexNotFoundException if provided index does not exist_@throws ShardNotFoundException if provided shard id is unknown;public IndexShardRoutingTable shardRoutingTable(String index, int shardId) {_        IndexRoutingTable indexRouting = index(index)__        if (indexRouting == null) {_            throw new IndexNotFoundException(index)__        }_        IndexShardRoutingTable shard = indexRouting.shard(shardId)__        if (shard == null) {_            throw new ShardNotFoundException(new ShardId(indexRouting.getIndex(), shardId))__        }_        return shard__    };all,shards,for,the,provided,index,and,shard,id,return,all,the,shard,routing,entries,for,the,given,index,and,shard,id,throws,index,not,found,exception,if,provided,index,does,not,exist,throws,shard,not,found,exception,if,provided,shard,id,is,unknown;public,index,shard,routing,table,shard,routing,table,string,index,int,shard,id,index,routing,table,index,routing,index,index,if,index,routing,null,throw,new,index,not,found,exception,index,index,shard,routing,table,shard,index,routing,shard,shard,id,if,shard,null,throw,new,shard,not,found,exception,new,shard,id,index,routing,get,index,shard,id,return,shard
RoutingTable -> public IndexShardRoutingTable shardRoutingTable(String index, int shardId);1540847035;All shards for the provided index and shard id_@return All the shard routing entries for the given index and shard id_@throws IndexNotFoundException if provided index does not exist_@throws ShardNotFoundException if provided shard id is unknown;public IndexShardRoutingTable shardRoutingTable(String index, int shardId) {_        IndexRoutingTable indexRouting = index(index)__        if (indexRouting == null) {_            throw new IndexNotFoundException(index)__        }_        IndexShardRoutingTable shard = indexRouting.shard(shardId)__        if (shard == null) {_            throw new ShardNotFoundException(new ShardId(indexRouting.getIndex(), shardId))__        }_        return shard__    };all,shards,for,the,provided,index,and,shard,id,return,all,the,shard,routing,entries,for,the,given,index,and,shard,id,throws,index,not,found,exception,if,provided,index,does,not,exist,throws,shard,not,found,exception,if,provided,shard,id,is,unknown;public,index,shard,routing,table,shard,routing,table,string,index,int,shard,id,index,routing,table,index,routing,index,index,if,index,routing,null,throw,new,index,not,found,exception,index,index,shard,routing,table,shard,index,routing,shard,shard,id,if,shard,null,throw,new,shard,not,found,exception,new,shard,id,index,routing,get,index,shard,id,return,shard
RoutingTable -> public IndexShardRoutingTable shardRoutingTable(String index, int shardId);1541446827;All shards for the provided index and shard id_@return All the shard routing entries for the given index and shard id_@throws IndexNotFoundException if provided index does not exist_@throws ShardNotFoundException if provided shard id is unknown;public IndexShardRoutingTable shardRoutingTable(String index, int shardId) {_        IndexRoutingTable indexRouting = index(index)__        if (indexRouting == null) {_            throw new IndexNotFoundException(index)__        }_        IndexShardRoutingTable shard = indexRouting.shard(shardId)__        if (shard == null) {_            throw new ShardNotFoundException(new ShardId(indexRouting.getIndex(), shardId))__        }_        return shard__    };all,shards,for,the,provided,index,and,shard,id,return,all,the,shard,routing,entries,for,the,given,index,and,shard,id,throws,index,not,found,exception,if,provided,index,does,not,exist,throws,shard,not,found,exception,if,provided,shard,id,is,unknown;public,index,shard,routing,table,shard,routing,table,string,index,int,shard,id,index,routing,table,index,routing,index,index,if,index,routing,null,throw,new,index,not,found,exception,index,index,shard,routing,table,shard,index,routing,shard,shard,id,if,shard,null,throw,new,shard,not,found,exception,new,shard,id,index,routing,get,index,shard,id,return,shard
RoutingTable -> public IndexShardRoutingTable shardRoutingTable(String index, int shardId);1549912434;All shards for the provided index and shard id_@return All the shard routing entries for the given index and shard id_@throws IndexNotFoundException if provided index does not exist_@throws ShardNotFoundException if provided shard id is unknown;public IndexShardRoutingTable shardRoutingTable(String index, int shardId) {_        IndexRoutingTable indexRouting = index(index)__        if (indexRouting == null) {_            throw new IndexNotFoundException(index)__        }_        return shardRoutingTable(indexRouting, shardId)__    };all,shards,for,the,provided,index,and,shard,id,return,all,the,shard,routing,entries,for,the,given,index,and,shard,id,throws,index,not,found,exception,if,provided,index,does,not,exist,throws,shard,not,found,exception,if,provided,shard,id,is,unknown;public,index,shard,routing,table,shard,routing,table,string,index,int,shard,id,index,routing,table,index,routing,index,index,if,index,routing,null,throw,new,index,not,found,exception,index,return,shard,routing,table,index,routing,shard,id
RoutingTable -> public List<ShardRouting> allShards();1524684173;All the shards (replicas) for all indices in this routing table.__@return All the shards;public List<ShardRouting> allShards() {_        List<ShardRouting> shards = new ArrayList<>()__        String[] indices = indicesRouting.keys().toArray(String.class)__        for (String index : indices) {_            List<ShardRouting> allShardsIndex = allShards(index)__            shards.addAll(allShardsIndex)__        }_        return shards__    };all,the,shards,replicas,for,all,indices,in,this,routing,table,return,all,the,shards;public,list,shard,routing,all,shards,list,shard,routing,shards,new,array,list,string,indices,indices,routing,keys,to,array,string,class,for,string,index,indices,list,shard,routing,all,shards,index,all,shards,index,shards,add,all,all,shards,index,return,shards
RoutingTable -> public List<ShardRouting> allShards();1539723533;All the shards (replicas) for all indices in this routing table.__@return All the shards;public List<ShardRouting> allShards() {_        List<ShardRouting> shards = new ArrayList<>()__        String[] indices = indicesRouting.keys().toArray(String.class)__        for (String index : indices) {_            List<ShardRouting> allShardsIndex = allShards(index)__            shards.addAll(allShardsIndex)__        }_        return shards__    };all,the,shards,replicas,for,all,indices,in,this,routing,table,return,all,the,shards;public,list,shard,routing,all,shards,list,shard,routing,shards,new,array,list,string,indices,indices,routing,keys,to,array,string,class,for,string,index,indices,list,shard,routing,all,shards,index,all,shards,index,shards,add,all,all,shards,index,return,shards
RoutingTable -> public List<ShardRouting> allShards();1540847035;All the shards (replicas) for all indices in this routing table.__@return All the shards;public List<ShardRouting> allShards() {_        List<ShardRouting> shards = new ArrayList<>()__        String[] indices = indicesRouting.keys().toArray(String.class)__        for (String index : indices) {_            List<ShardRouting> allShardsIndex = allShards(index)__            shards.addAll(allShardsIndex)__        }_        return shards__    };all,the,shards,replicas,for,all,indices,in,this,routing,table,return,all,the,shards;public,list,shard,routing,all,shards,list,shard,routing,shards,new,array,list,string,indices,indices,routing,keys,to,array,string,class,for,string,index,indices,list,shard,routing,all,shards,index,all,shards,index,shards,add,all,all,shards,index,return,shards
RoutingTable -> public List<ShardRouting> allShards();1541446827;All the shards (replicas) for all indices in this routing table.__@return All the shards;public List<ShardRouting> allShards() {_        List<ShardRouting> shards = new ArrayList<>()__        String[] indices = indicesRouting.keys().toArray(String.class)__        for (String index : indices) {_            List<ShardRouting> allShardsIndex = allShards(index)__            shards.addAll(allShardsIndex)__        }_        return shards__    };all,the,shards,replicas,for,all,indices,in,this,routing,table,return,all,the,shards;public,list,shard,routing,all,shards,list,shard,routing,shards,new,array,list,string,indices,indices,routing,keys,to,array,string,class,for,string,index,indices,list,shard,routing,all,shards,index,all,shards,index,shards,add,all,all,shards,index,return,shards
RoutingTable -> public List<ShardRouting> allShards();1549912434;All the shards (replicas) for all indices in this routing table.__@return All the shards;public List<ShardRouting> allShards() {_        List<ShardRouting> shards = new ArrayList<>()__        String[] indices = indicesRouting.keys().toArray(String.class)__        for (String index : indices) {_            List<ShardRouting> allShardsIndex = allShards(index)__            shards.addAll(allShardsIndex)__        }_        return shards__    };all,the,shards,replicas,for,all,indices,in,this,routing,table,return,all,the,shards;public,list,shard,routing,all,shards,list,shard,routing,shards,new,array,list,string,indices,indices,routing,keys,to,array,string,class,for,string,index,indices,list,shard,routing,all,shards,index,all,shards,index,shards,add,all,all,shards,index,return,shards
RoutingTable -> public GroupShardsIterator<ShardIterator> allAssignedShardsGrouped(String[] indices, boolean includeEmpty,                                                                        boolean includeRelocationTargets);1540847035;Return GroupShardsIterator where each assigned shard routing has it's own shard iterator.__@param includeEmpty             if true, a shard iterator will be added for non-assigned shards as well_@param includeRelocationTargets if true, an <b>extra</b> shard iterator will be added for relocating shards. The extra_iterator contains a single ShardRouting pointing at the relocating target;public GroupShardsIterator<ShardIterator> allAssignedShardsGrouped(String[] indices, boolean includeEmpty,_                                                                       boolean includeRelocationTargets) {_        return allSatisfyingPredicateShardsGrouped(indices, includeEmpty, includeRelocationTargets, ASSIGNED_PREDICATE)__    };return,group,shards,iterator,where,each,assigned,shard,routing,has,it,s,own,shard,iterator,param,include,empty,if,true,a,shard,iterator,will,be,added,for,non,assigned,shards,as,well,param,include,relocation,targets,if,true,an,b,extra,b,shard,iterator,will,be,added,for,relocating,shards,the,extra,iterator,contains,a,single,shard,routing,pointing,at,the,relocating,target;public,group,shards,iterator,shard,iterator,all,assigned,shards,grouped,string,indices,boolean,include,empty,boolean,include,relocation,targets,return,all,satisfying,predicate,shards,grouped,indices,include,empty,include,relocation,targets
RoutingTable -> public GroupShardsIterator<ShardIterator> allAssignedShardsGrouped(String[] indices, boolean includeEmpty,                                                                        boolean includeRelocationTargets);1541446827;Return GroupShardsIterator where each assigned shard routing has it's own shard iterator.__@param includeEmpty             if true, a shard iterator will be added for non-assigned shards as well_@param includeRelocationTargets if true, an <b>extra</b> shard iterator will be added for relocating shards. The extra_iterator contains a single ShardRouting pointing at the relocating target;public GroupShardsIterator<ShardIterator> allAssignedShardsGrouped(String[] indices, boolean includeEmpty,_                                                                       boolean includeRelocationTargets) {_        return allSatisfyingPredicateShardsGrouped(indices, includeEmpty, includeRelocationTargets, ASSIGNED_PREDICATE)__    };return,group,shards,iterator,where,each,assigned,shard,routing,has,it,s,own,shard,iterator,param,include,empty,if,true,a,shard,iterator,will,be,added,for,non,assigned,shards,as,well,param,include,relocation,targets,if,true,an,b,extra,b,shard,iterator,will,be,added,for,relocating,shards,the,extra,iterator,contains,a,single,shard,routing,pointing,at,the,relocating,target;public,group,shards,iterator,shard,iterator,all,assigned,shards,grouped,string,indices,boolean,include,empty,boolean,include,relocation,targets,return,all,satisfying,predicate,shards,grouped,indices,include,empty,include,relocation,targets
RoutingTable -> public GroupShardsIterator<ShardIterator> allAssignedShardsGrouped(String[] indices, boolean includeEmpty, boolean includeRelocationTargets);1524684173;Return GroupShardsIterator where each assigned shard routing has it's own shard iterator.__@param includeEmpty             if true, a shard iterator will be added for non-assigned shards as well_@param includeRelocationTargets if true, an <b>extra</b> shard iterator will be added for relocating shards. The extra_iterator contains a single ShardRouting pointing at the relocating target;public GroupShardsIterator<ShardIterator> allAssignedShardsGrouped(String[] indices, boolean includeEmpty, boolean includeRelocationTargets) {_        return allSatisfyingPredicateShardsGrouped(indices, includeEmpty, includeRelocationTargets, ASSIGNED_PREDICATE)__    };return,group,shards,iterator,where,each,assigned,shard,routing,has,it,s,own,shard,iterator,param,include,empty,if,true,a,shard,iterator,will,be,added,for,non,assigned,shards,as,well,param,include,relocation,targets,if,true,an,b,extra,b,shard,iterator,will,be,added,for,relocating,shards,the,extra,iterator,contains,a,single,shard,routing,pointing,at,the,relocating,target;public,group,shards,iterator,shard,iterator,all,assigned,shards,grouped,string,indices,boolean,include,empty,boolean,include,relocation,targets,return,all,satisfying,predicate,shards,grouped,indices,include,empty,include,relocation,targets
RoutingTable -> public GroupShardsIterator<ShardIterator> allAssignedShardsGrouped(String[] indices, boolean includeEmpty, boolean includeRelocationTargets);1539723533;Return GroupShardsIterator where each assigned shard routing has it's own shard iterator.__@param includeEmpty             if true, a shard iterator will be added for non-assigned shards as well_@param includeRelocationTargets if true, an <b>extra</b> shard iterator will be added for relocating shards. The extra_iterator contains a single ShardRouting pointing at the relocating target;public GroupShardsIterator<ShardIterator> allAssignedShardsGrouped(String[] indices, boolean includeEmpty, boolean includeRelocationTargets) {_        return allSatisfyingPredicateShardsGrouped(indices, includeEmpty, includeRelocationTargets, ASSIGNED_PREDICATE)__    };return,group,shards,iterator,where,each,assigned,shard,routing,has,it,s,own,shard,iterator,param,include,empty,if,true,a,shard,iterator,will,be,added,for,non,assigned,shards,as,well,param,include,relocation,targets,if,true,an,b,extra,b,shard,iterator,will,be,added,for,relocating,shards,the,extra,iterator,contains,a,single,shard,routing,pointing,at,the,relocating,target;public,group,shards,iterator,shard,iterator,all,assigned,shards,grouped,string,indices,boolean,include,empty,boolean,include,relocation,targets,return,all,satisfying,predicate,shards,grouped,indices,include,empty,include,relocation,targets
RoutingTable -> Builder -> public RoutingTable build();1524684173;Builds the routing table. Note that once this is called the builder_must be thrown away. If you need to build a new RoutingTable as a_copy of this one you'll need to build a new RoutingTable.Builder.;public RoutingTable build() {_            if (indicesRouting == null) {_                throw new IllegalStateException("once build is called the builder cannot be reused")__            }_            RoutingTable table = new RoutingTable(version, indicesRouting.build())__            indicesRouting = null__            return table__        };builds,the,routing,table,note,that,once,this,is,called,the,builder,must,be,thrown,away,if,you,need,to,build,a,new,routing,table,as,a,copy,of,this,one,you,ll,need,to,build,a,new,routing,table,builder;public,routing,table,build,if,indices,routing,null,throw,new,illegal,state,exception,once,build,is,called,the,builder,cannot,be,reused,routing,table,table,new,routing,table,version,indices,routing,build,indices,routing,null,return,table
RoutingTable -> Builder -> public RoutingTable build();1539723533;Builds the routing table. Note that once this is called the builder_must be thrown away. If you need to build a new RoutingTable as a_copy of this one you'll need to build a new RoutingTable.Builder.;public RoutingTable build() {_            if (indicesRouting == null) {_                throw new IllegalStateException("once build is called the builder cannot be reused")__            }_            RoutingTable table = new RoutingTable(version, indicesRouting.build())__            indicesRouting = null__            return table__        };builds,the,routing,table,note,that,once,this,is,called,the,builder,must,be,thrown,away,if,you,need,to,build,a,new,routing,table,as,a,copy,of,this,one,you,ll,need,to,build,a,new,routing,table,builder;public,routing,table,build,if,indices,routing,null,throw,new,illegal,state,exception,once,build,is,called,the,builder,cannot,be,reused,routing,table,table,new,routing,table,version,indices,routing,build,indices,routing,null,return,table
RoutingTable -> Builder -> public RoutingTable build();1540847035;Builds the routing table. Note that once this is called the builder_must be thrown away. If you need to build a new RoutingTable as a_copy of this one you'll need to build a new RoutingTable.Builder.;public RoutingTable build() {_            if (indicesRouting == null) {_                throw new IllegalStateException("once build is called the builder cannot be reused")__            }_            RoutingTable table = new RoutingTable(version, indicesRouting.build())__            indicesRouting = null__            return table__        };builds,the,routing,table,note,that,once,this,is,called,the,builder,must,be,thrown,away,if,you,need,to,build,a,new,routing,table,as,a,copy,of,this,one,you,ll,need,to,build,a,new,routing,table,builder;public,routing,table,build,if,indices,routing,null,throw,new,illegal,state,exception,once,build,is,called,the,builder,cannot,be,reused,routing,table,table,new,routing,table,version,indices,routing,build,indices,routing,null,return,table
RoutingTable -> Builder -> public RoutingTable build();1541446827;Builds the routing table. Note that once this is called the builder_must be thrown away. If you need to build a new RoutingTable as a_copy of this one you'll need to build a new RoutingTable.Builder.;public RoutingTable build() {_            if (indicesRouting == null) {_                throw new IllegalStateException("once build is called the builder cannot be reused")__            }_            RoutingTable table = new RoutingTable(version, indicesRouting.build())__            indicesRouting = null__            return table__        };builds,the,routing,table,note,that,once,this,is,called,the,builder,must,be,thrown,away,if,you,need,to,build,a,new,routing,table,as,a,copy,of,this,one,you,ll,need,to,build,a,new,routing,table,builder;public,routing,table,build,if,indices,routing,null,throw,new,illegal,state,exception,once,build,is,called,the,builder,cannot,be,reused,routing,table,table,new,routing,table,version,indices,routing,build,indices,routing,null,return,table
RoutingTable -> Builder -> public RoutingTable build();1549912434;Builds the routing table. Note that once this is called the builder_must be thrown away. If you need to build a new RoutingTable as a_copy of this one you'll need to build a new RoutingTable.Builder.;public RoutingTable build() {_            if (indicesRouting == null) {_                throw new IllegalStateException("once build is called the builder cannot be reused")__            }_            RoutingTable table = new RoutingTable(version, indicesRouting.build())__            indicesRouting = null__            return table__        };builds,the,routing,table,note,that,once,this,is,called,the,builder,must,be,thrown,away,if,you,need,to,build,a,new,routing,table,as,a,copy,of,this,one,you,ll,need,to,build,a,new,routing,table,builder;public,routing,table,build,if,indices,routing,null,throw,new,illegal,state,exception,once,build,is,called,the,builder,cannot,be,reused,routing,table,table,new,routing,table,version,indices,routing,build,indices,routing,null,return,table
RoutingTable -> public GroupShardsIterator allActiveShardsGrouped(String[] indices, boolean includeEmpty, boolean includeRelocationTargets);1524684173;Return GroupShardsIterator where each active shard routing has it's own shard iterator.__@param includeEmpty             if true, a shard iterator will be added for non-assigned shards as well_@param includeRelocationTargets if true, an <b>extra</b> shard iterator will be added for relocating shards. The extra_iterator contains a single ShardRouting pointing at the relocating target;public GroupShardsIterator allActiveShardsGrouped(String[] indices, boolean includeEmpty, boolean includeRelocationTargets) {_        return allSatisfyingPredicateShardsGrouped(indices, includeEmpty, includeRelocationTargets, ACTIVE_PREDICATE)__    };return,group,shards,iterator,where,each,active,shard,routing,has,it,s,own,shard,iterator,param,include,empty,if,true,a,shard,iterator,will,be,added,for,non,assigned,shards,as,well,param,include,relocation,targets,if,true,an,b,extra,b,shard,iterator,will,be,added,for,relocating,shards,the,extra,iterator,contains,a,single,shard,routing,pointing,at,the,relocating,target;public,group,shards,iterator,all,active,shards,grouped,string,indices,boolean,include,empty,boolean,include,relocation,targets,return,all,satisfying,predicate,shards,grouped,indices,include,empty,include,relocation,targets
RoutingTable -> public GroupShardsIterator allActiveShardsGrouped(String[] indices, boolean includeEmpty, boolean includeRelocationTargets);1539723533;Return GroupShardsIterator where each active shard routing has it's own shard iterator.__@param includeEmpty             if true, a shard iterator will be added for non-assigned shards as well_@param includeRelocationTargets if true, an <b>extra</b> shard iterator will be added for relocating shards. The extra_iterator contains a single ShardRouting pointing at the relocating target;public GroupShardsIterator allActiveShardsGrouped(String[] indices, boolean includeEmpty, boolean includeRelocationTargets) {_        return allSatisfyingPredicateShardsGrouped(indices, includeEmpty, includeRelocationTargets, ACTIVE_PREDICATE)__    };return,group,shards,iterator,where,each,active,shard,routing,has,it,s,own,shard,iterator,param,include,empty,if,true,a,shard,iterator,will,be,added,for,non,assigned,shards,as,well,param,include,relocation,targets,if,true,an,b,extra,b,shard,iterator,will,be,added,for,relocating,shards,the,extra,iterator,contains,a,single,shard,routing,pointing,at,the,relocating,target;public,group,shards,iterator,all,active,shards,grouped,string,indices,boolean,include,empty,boolean,include,relocation,targets,return,all,satisfying,predicate,shards,grouped,indices,include,empty,include,relocation,targets
RoutingTable -> public GroupShardsIterator allActiveShardsGrouped(String[] indices, boolean includeEmpty, boolean includeRelocationTargets);1540847035;Return GroupShardsIterator where each active shard routing has it's own shard iterator.__@param includeEmpty             if true, a shard iterator will be added for non-assigned shards as well_@param includeRelocationTargets if true, an <b>extra</b> shard iterator will be added for relocating shards. The extra_iterator contains a single ShardRouting pointing at the relocating target;public GroupShardsIterator allActiveShardsGrouped(String[] indices, boolean includeEmpty, boolean includeRelocationTargets) {_        return allSatisfyingPredicateShardsGrouped(indices, includeEmpty, includeRelocationTargets, ACTIVE_PREDICATE)__    };return,group,shards,iterator,where,each,active,shard,routing,has,it,s,own,shard,iterator,param,include,empty,if,true,a,shard,iterator,will,be,added,for,non,assigned,shards,as,well,param,include,relocation,targets,if,true,an,b,extra,b,shard,iterator,will,be,added,for,relocating,shards,the,extra,iterator,contains,a,single,shard,routing,pointing,at,the,relocating,target;public,group,shards,iterator,all,active,shards,grouped,string,indices,boolean,include,empty,boolean,include,relocation,targets,return,all,satisfying,predicate,shards,grouped,indices,include,empty,include,relocation,targets
RoutingTable -> public GroupShardsIterator allActiveShardsGrouped(String[] indices, boolean includeEmpty, boolean includeRelocationTargets);1541446827;Return GroupShardsIterator where each active shard routing has it's own shard iterator.__@param includeEmpty             if true, a shard iterator will be added for non-assigned shards as well_@param includeRelocationTargets if true, an <b>extra</b> shard iterator will be added for relocating shards. The extra_iterator contains a single ShardRouting pointing at the relocating target;public GroupShardsIterator allActiveShardsGrouped(String[] indices, boolean includeEmpty, boolean includeRelocationTargets) {_        return allSatisfyingPredicateShardsGrouped(indices, includeEmpty, includeRelocationTargets, ACTIVE_PREDICATE)__    };return,group,shards,iterator,where,each,active,shard,routing,has,it,s,own,shard,iterator,param,include,empty,if,true,a,shard,iterator,will,be,added,for,non,assigned,shards,as,well,param,include,relocation,targets,if,true,an,b,extra,b,shard,iterator,will,be,added,for,relocating,shards,the,extra,iterator,contains,a,single,shard,routing,pointing,at,the,relocating,target;public,group,shards,iterator,all,active,shards,grouped,string,indices,boolean,include,empty,boolean,include,relocation,targets,return,all,satisfying,predicate,shards,grouped,indices,include,empty,include,relocation,targets
RoutingTable -> public long version();1524684173;Returns the version of the {@link RoutingTable}.__@return version of the {@link RoutingTable};public long version() {_        return this.version__    };returns,the,version,of,the,link,routing,table,return,version,of,the,link,routing,table;public,long,version,return,this,version
RoutingTable -> public long version();1539723533;Returns the version of the {@link RoutingTable}.__@return version of the {@link RoutingTable};public long version() {_        return this.version__    };returns,the,version,of,the,link,routing,table,return,version,of,the,link,routing,table;public,long,version,return,this,version
RoutingTable -> public long version();1540847035;Returns the version of the {@link RoutingTable}.__@return version of the {@link RoutingTable};public long version() {_        return this.version__    };returns,the,version,of,the,link,routing,table,return,version,of,the,link,routing,table;public,long,version,return,this,version
RoutingTable -> public long version();1541446827;Returns the version of the {@link RoutingTable}.__@return version of the {@link RoutingTable};public long version() {_        return this.version__    };returns,the,version,of,the,link,routing,table,return,version,of,the,link,routing,table;public,long,version,return,this,version
RoutingTable -> public long version();1549912434;Returns the version of the {@link RoutingTable}.__@return version of the {@link RoutingTable};public long version() {_        return this.version__    };returns,the,version,of,the,link,routing,table,return,version,of,the,link,routing,table;public,long,version,return,this,version
RoutingTable -> public GroupShardsIterator<ShardIterator> activePrimaryShardsGrouped(String[] indices, boolean includeEmpty);1524684173;All the *active* primary shards for the provided indices grouped (each group is a single element, consisting_of the primary shard). This is handy for components that expect to get group iterators, but still want in some_cases to iterate over all primary shards (and not just one shard in replication group).__@param indices The indices to return all the shards (replicas)_@return All the primary shards grouped into a single shard element group each_@throws IndexNotFoundException If an index passed does not exists;public GroupShardsIterator<ShardIterator> activePrimaryShardsGrouped(String[] indices, boolean includeEmpty) {_        _        ArrayList<ShardIterator> set = new ArrayList<>()__        for (String index : indices) {_            IndexRoutingTable indexRoutingTable = index(index)__            if (indexRoutingTable == null) {_                throw new IndexNotFoundException(index)__            }_            for (IndexShardRoutingTable indexShardRoutingTable : indexRoutingTable) {_                ShardRouting primary = indexShardRoutingTable.primaryShard()__                if (primary.active()) {_                    set.add(primary.shardsIt())__                } else if (includeEmpty) { _                    set.add(new PlainShardIterator(primary.shardId(), Collections.<ShardRouting>emptyList()))__                }_            }_        }_        return new GroupShardsIterator<>(set)__    };all,the,active,primary,shards,for,the,provided,indices,grouped,each,group,is,a,single,element,consisting,of,the,primary,shard,this,is,handy,for,components,that,expect,to,get,group,iterators,but,still,want,in,some,cases,to,iterate,over,all,primary,shards,and,not,just,one,shard,in,replication,group,param,indices,the,indices,to,return,all,the,shards,replicas,return,all,the,primary,shards,grouped,into,a,single,shard,element,group,each,throws,index,not,found,exception,if,an,index,passed,does,not,exists;public,group,shards,iterator,shard,iterator,active,primary,shards,grouped,string,indices,boolean,include,empty,array,list,shard,iterator,set,new,array,list,for,string,index,indices,index,routing,table,index,routing,table,index,index,if,index,routing,table,null,throw,new,index,not,found,exception,index,for,index,shard,routing,table,index,shard,routing,table,index,routing,table,shard,routing,primary,index,shard,routing,table,primary,shard,if,primary,active,set,add,primary,shards,it,else,if,include,empty,set,add,new,plain,shard,iterator,primary,shard,id,collections,shard,routing,empty,list,return,new,group,shards,iterator,set
RoutingTable -> public GroupShardsIterator<ShardIterator> activePrimaryShardsGrouped(String[] indices, boolean includeEmpty);1539723533;All the *active* primary shards for the provided indices grouped (each group is a single element, consisting_of the primary shard). This is handy for components that expect to get group iterators, but still want in some_cases to iterate over all primary shards (and not just one shard in replication group).__@param indices The indices to return all the shards (replicas)_@return All the primary shards grouped into a single shard element group each_@throws IndexNotFoundException If an index passed does not exists;public GroupShardsIterator<ShardIterator> activePrimaryShardsGrouped(String[] indices, boolean includeEmpty) {_        _        ArrayList<ShardIterator> set = new ArrayList<>()__        for (String index : indices) {_            IndexRoutingTable indexRoutingTable = index(index)__            if (indexRoutingTable == null) {_                throw new IndexNotFoundException(index)__            }_            for (IndexShardRoutingTable indexShardRoutingTable : indexRoutingTable) {_                ShardRouting primary = indexShardRoutingTable.primaryShard()__                if (primary.active()) {_                    set.add(primary.shardsIt())__                } else if (includeEmpty) { _                    set.add(new PlainShardIterator(primary.shardId(), Collections.<ShardRouting>emptyList()))__                }_            }_        }_        return new GroupShardsIterator<>(set)__    };all,the,active,primary,shards,for,the,provided,indices,grouped,each,group,is,a,single,element,consisting,of,the,primary,shard,this,is,handy,for,components,that,expect,to,get,group,iterators,but,still,want,in,some,cases,to,iterate,over,all,primary,shards,and,not,just,one,shard,in,replication,group,param,indices,the,indices,to,return,all,the,shards,replicas,return,all,the,primary,shards,grouped,into,a,single,shard,element,group,each,throws,index,not,found,exception,if,an,index,passed,does,not,exists;public,group,shards,iterator,shard,iterator,active,primary,shards,grouped,string,indices,boolean,include,empty,array,list,shard,iterator,set,new,array,list,for,string,index,indices,index,routing,table,index,routing,table,index,index,if,index,routing,table,null,throw,new,index,not,found,exception,index,for,index,shard,routing,table,index,shard,routing,table,index,routing,table,shard,routing,primary,index,shard,routing,table,primary,shard,if,primary,active,set,add,primary,shards,it,else,if,include,empty,set,add,new,plain,shard,iterator,primary,shard,id,collections,shard,routing,empty,list,return,new,group,shards,iterator,set
RoutingTable -> public GroupShardsIterator<ShardIterator> activePrimaryShardsGrouped(String[] indices, boolean includeEmpty);1540847035;All the *active* primary shards for the provided indices grouped (each group is a single element, consisting_of the primary shard). This is handy for components that expect to get group iterators, but still want in some_cases to iterate over all primary shards (and not just one shard in replication group).__@param indices The indices to return all the shards (replicas)_@return All the primary shards grouped into a single shard element group each_@throws IndexNotFoundException If an index passed does not exists;public GroupShardsIterator<ShardIterator> activePrimaryShardsGrouped(String[] indices, boolean includeEmpty) {_        _        ArrayList<ShardIterator> set = new ArrayList<>()__        for (String index : indices) {_            IndexRoutingTable indexRoutingTable = index(index)__            if (indexRoutingTable == null) {_                throw new IndexNotFoundException(index)__            }_            for (IndexShardRoutingTable indexShardRoutingTable : indexRoutingTable) {_                ShardRouting primary = indexShardRoutingTable.primaryShard()__                if (primary.active()) {_                    set.add(primary.shardsIt())__                } else if (includeEmpty) { _                    set.add(new PlainShardIterator(primary.shardId(), Collections.<ShardRouting>emptyList()))__                }_            }_        }_        return new GroupShardsIterator<>(set)__    };all,the,active,primary,shards,for,the,provided,indices,grouped,each,group,is,a,single,element,consisting,of,the,primary,shard,this,is,handy,for,components,that,expect,to,get,group,iterators,but,still,want,in,some,cases,to,iterate,over,all,primary,shards,and,not,just,one,shard,in,replication,group,param,indices,the,indices,to,return,all,the,shards,replicas,return,all,the,primary,shards,grouped,into,a,single,shard,element,group,each,throws,index,not,found,exception,if,an,index,passed,does,not,exists;public,group,shards,iterator,shard,iterator,active,primary,shards,grouped,string,indices,boolean,include,empty,array,list,shard,iterator,set,new,array,list,for,string,index,indices,index,routing,table,index,routing,table,index,index,if,index,routing,table,null,throw,new,index,not,found,exception,index,for,index,shard,routing,table,index,shard,routing,table,index,routing,table,shard,routing,primary,index,shard,routing,table,primary,shard,if,primary,active,set,add,primary,shards,it,else,if,include,empty,set,add,new,plain,shard,iterator,primary,shard,id,collections,shard,routing,empty,list,return,new,group,shards,iterator,set
RoutingTable -> public GroupShardsIterator<ShardIterator> activePrimaryShardsGrouped(String[] indices, boolean includeEmpty);1541446827;All the *active* primary shards for the provided indices grouped (each group is a single element, consisting_of the primary shard). This is handy for components that expect to get group iterators, but still want in some_cases to iterate over all primary shards (and not just one shard in replication group).__@param indices The indices to return all the shards (replicas)_@return All the primary shards grouped into a single shard element group each_@throws IndexNotFoundException If an index passed does not exists;public GroupShardsIterator<ShardIterator> activePrimaryShardsGrouped(String[] indices, boolean includeEmpty) {_        _        ArrayList<ShardIterator> set = new ArrayList<>()__        for (String index : indices) {_            IndexRoutingTable indexRoutingTable = index(index)__            if (indexRoutingTable == null) {_                throw new IndexNotFoundException(index)__            }_            for (IndexShardRoutingTable indexShardRoutingTable : indexRoutingTable) {_                ShardRouting primary = indexShardRoutingTable.primaryShard()__                if (primary.active()) {_                    set.add(primary.shardsIt())__                } else if (includeEmpty) { _                    set.add(new PlainShardIterator(primary.shardId(), Collections.emptyList()))__                }_            }_        }_        return new GroupShardsIterator<>(set)__    };all,the,active,primary,shards,for,the,provided,indices,grouped,each,group,is,a,single,element,consisting,of,the,primary,shard,this,is,handy,for,components,that,expect,to,get,group,iterators,but,still,want,in,some,cases,to,iterate,over,all,primary,shards,and,not,just,one,shard,in,replication,group,param,indices,the,indices,to,return,all,the,shards,replicas,return,all,the,primary,shards,grouped,into,a,single,shard,element,group,each,throws,index,not,found,exception,if,an,index,passed,does,not,exists;public,group,shards,iterator,shard,iterator,active,primary,shards,grouped,string,indices,boolean,include,empty,array,list,shard,iterator,set,new,array,list,for,string,index,indices,index,routing,table,index,routing,table,index,index,if,index,routing,table,null,throw,new,index,not,found,exception,index,for,index,shard,routing,table,index,shard,routing,table,index,routing,table,shard,routing,primary,index,shard,routing,table,primary,shard,if,primary,active,set,add,primary,shards,it,else,if,include,empty,set,add,new,plain,shard,iterator,primary,shard,id,collections,empty,list,return,new,group,shards,iterator,set
RoutingTable -> public GroupShardsIterator<ShardIterator> activePrimaryShardsGrouped(String[] indices, boolean includeEmpty);1549912434;All the *active* primary shards for the provided indices grouped (each group is a single element, consisting_of the primary shard). This is handy for components that expect to get group iterators, but still want in some_cases to iterate over all primary shards (and not just one shard in replication group).__@param indices The indices to return all the shards (replicas)_@return All the primary shards grouped into a single shard element group each_@throws IndexNotFoundException If an index passed does not exists;public GroupShardsIterator<ShardIterator> activePrimaryShardsGrouped(String[] indices, boolean includeEmpty) {_        _        ArrayList<ShardIterator> set = new ArrayList<>()__        for (String index : indices) {_            IndexRoutingTable indexRoutingTable = index(index)__            if (indexRoutingTable == null) {_                throw new IndexNotFoundException(index)__            }_            for (IndexShardRoutingTable indexShardRoutingTable : indexRoutingTable) {_                ShardRouting primary = indexShardRoutingTable.primaryShard()__                if (primary.active()) {_                    set.add(primary.shardsIt())__                } else if (includeEmpty) { _                    set.add(new PlainShardIterator(primary.shardId(), Collections.emptyList()))__                }_            }_        }_        return new GroupShardsIterator<>(set)__    };all,the,active,primary,shards,for,the,provided,indices,grouped,each,group,is,a,single,element,consisting,of,the,primary,shard,this,is,handy,for,components,that,expect,to,get,group,iterators,but,still,want,in,some,cases,to,iterate,over,all,primary,shards,and,not,just,one,shard,in,replication,group,param,indices,the,indices,to,return,all,the,shards,replicas,return,all,the,primary,shards,grouped,into,a,single,shard,element,group,each,throws,index,not,found,exception,if,an,index,passed,does,not,exists;public,group,shards,iterator,shard,iterator,active,primary,shards,grouped,string,indices,boolean,include,empty,array,list,shard,iterator,set,new,array,list,for,string,index,indices,index,routing,table,index,routing,table,index,index,if,index,routing,table,null,throw,new,index,not,found,exception,index,for,index,shard,routing,table,index,shard,routing,table,index,routing,table,shard,routing,primary,index,shard,routing,table,primary,shard,if,primary,active,set,add,primary,shards,it,else,if,include,empty,set,add,new,plain,shard,iterator,primary,shard,id,collections,empty,list,return,new,group,shards,iterator,set
RoutingTable -> public IndexShardRoutingTable shardRoutingTable(ShardId shardId);1524684173;All shards for the provided {@link ShardId}_@return All the shard routing entries for the given index and shard id_@throws IndexNotFoundException if provided index does not exist_@throws ShardNotFoundException if provided shard id is unknown;public IndexShardRoutingTable shardRoutingTable(ShardId shardId) {_        IndexRoutingTable indexRouting = index(shardId.getIndexName())__        if (indexRouting == null || indexRouting.getIndex().equals(shardId.getIndex()) == false) {_            throw new IndexNotFoundException(shardId.getIndex())__        }_        IndexShardRoutingTable shard = indexRouting.shard(shardId.id())__        if (shard == null) {_            throw new ShardNotFoundException(shardId)__        }_        return shard__    };all,shards,for,the,provided,link,shard,id,return,all,the,shard,routing,entries,for,the,given,index,and,shard,id,throws,index,not,found,exception,if,provided,index,does,not,exist,throws,shard,not,found,exception,if,provided,shard,id,is,unknown;public,index,shard,routing,table,shard,routing,table,shard,id,shard,id,index,routing,table,index,routing,index,shard,id,get,index,name,if,index,routing,null,index,routing,get,index,equals,shard,id,get,index,false,throw,new,index,not,found,exception,shard,id,get,index,index,shard,routing,table,shard,index,routing,shard,shard,id,id,if,shard,null,throw,new,shard,not,found,exception,shard,id,return,shard
RoutingTable -> public IndexShardRoutingTable shardRoutingTable(ShardId shardId);1539723533;All shards for the provided {@link ShardId}_@return All the shard routing entries for the given index and shard id_@throws IndexNotFoundException if provided index does not exist_@throws ShardNotFoundException if provided shard id is unknown;public IndexShardRoutingTable shardRoutingTable(ShardId shardId) {_        IndexRoutingTable indexRouting = index(shardId.getIndexName())__        if (indexRouting == null || indexRouting.getIndex().equals(shardId.getIndex()) == false) {_            throw new IndexNotFoundException(shardId.getIndex())__        }_        IndexShardRoutingTable shard = indexRouting.shard(shardId.id())__        if (shard == null) {_            throw new ShardNotFoundException(shardId)__        }_        return shard__    };all,shards,for,the,provided,link,shard,id,return,all,the,shard,routing,entries,for,the,given,index,and,shard,id,throws,index,not,found,exception,if,provided,index,does,not,exist,throws,shard,not,found,exception,if,provided,shard,id,is,unknown;public,index,shard,routing,table,shard,routing,table,shard,id,shard,id,index,routing,table,index,routing,index,shard,id,get,index,name,if,index,routing,null,index,routing,get,index,equals,shard,id,get,index,false,throw,new,index,not,found,exception,shard,id,get,index,index,shard,routing,table,shard,index,routing,shard,shard,id,id,if,shard,null,throw,new,shard,not,found,exception,shard,id,return,shard
RoutingTable -> public IndexShardRoutingTable shardRoutingTable(ShardId shardId);1540847035;All shards for the provided {@link ShardId}_@return All the shard routing entries for the given index and shard id_@throws IndexNotFoundException if provided index does not exist_@throws ShardNotFoundException if provided shard id is unknown;public IndexShardRoutingTable shardRoutingTable(ShardId shardId) {_        IndexRoutingTable indexRouting = index(shardId.getIndexName())__        if (indexRouting == null || indexRouting.getIndex().equals(shardId.getIndex()) == false) {_            throw new IndexNotFoundException(shardId.getIndex())__        }_        IndexShardRoutingTable shard = indexRouting.shard(shardId.id())__        if (shard == null) {_            throw new ShardNotFoundException(shardId)__        }_        return shard__    };all,shards,for,the,provided,link,shard,id,return,all,the,shard,routing,entries,for,the,given,index,and,shard,id,throws,index,not,found,exception,if,provided,index,does,not,exist,throws,shard,not,found,exception,if,provided,shard,id,is,unknown;public,index,shard,routing,table,shard,routing,table,shard,id,shard,id,index,routing,table,index,routing,index,shard,id,get,index,name,if,index,routing,null,index,routing,get,index,equals,shard,id,get,index,false,throw,new,index,not,found,exception,shard,id,get,index,index,shard,routing,table,shard,index,routing,shard,shard,id,id,if,shard,null,throw,new,shard,not,found,exception,shard,id,return,shard
RoutingTable -> public IndexShardRoutingTable shardRoutingTable(ShardId shardId);1541446827;All shards for the provided {@link ShardId}_@return All the shard routing entries for the given index and shard id_@throws IndexNotFoundException if provided index does not exist_@throws ShardNotFoundException if provided shard id is unknown;public IndexShardRoutingTable shardRoutingTable(ShardId shardId) {_        IndexRoutingTable indexRouting = index(shardId.getIndexName())__        if (indexRouting == null || indexRouting.getIndex().equals(shardId.getIndex()) == false) {_            throw new IndexNotFoundException(shardId.getIndex())__        }_        IndexShardRoutingTable shard = indexRouting.shard(shardId.id())__        if (shard == null) {_            throw new ShardNotFoundException(shardId)__        }_        return shard__    };all,shards,for,the,provided,link,shard,id,return,all,the,shard,routing,entries,for,the,given,index,and,shard,id,throws,index,not,found,exception,if,provided,index,does,not,exist,throws,shard,not,found,exception,if,provided,shard,id,is,unknown;public,index,shard,routing,table,shard,routing,table,shard,id,shard,id,index,routing,table,index,routing,index,shard,id,get,index,name,if,index,routing,null,index,routing,get,index,equals,shard,id,get,index,false,throw,new,index,not,found,exception,shard,id,get,index,index,shard,routing,table,shard,index,routing,shard,shard,id,id,if,shard,null,throw,new,shard,not,found,exception,shard,id,return,shard
RoutingTable -> public IndexShardRoutingTable shardRoutingTable(ShardId shardId);1549912434;All shards for the provided {@link ShardId}_@return All the shard routing entries for the given index and shard id_@throws IndexNotFoundException if provided index does not exist_@throws ShardNotFoundException if provided shard id is unknown;public IndexShardRoutingTable shardRoutingTable(ShardId shardId) {_        IndexRoutingTable indexRouting = index(shardId.getIndexName())__        if (indexRouting == null || indexRouting.getIndex().equals(shardId.getIndex()) == false) {_            throw new IndexNotFoundException(shardId.getIndex())__        }_        IndexShardRoutingTable shard = indexRouting.shard(shardId.id())__        if (shard == null) {_            throw new ShardNotFoundException(shardId)__        }_        return shard__    };all,shards,for,the,provided,link,shard,id,return,all,the,shard,routing,entries,for,the,given,index,and,shard,id,throws,index,not,found,exception,if,provided,index,does,not,exist,throws,shard,not,found,exception,if,provided,shard,id,is,unknown;public,index,shard,routing,table,shard,routing,table,shard,id,shard,id,index,routing,table,index,routing,index,shard,id,get,index,name,if,index,routing,null,index,routing,get,index,equals,shard,id,get,index,false,throw,new,index,not,found,exception,shard,id,get,index,index,shard,routing,table,shard,index,routing,shard,shard,id,id,if,shard,null,throw,new,shard,not,found,exception,shard,id,return,shard
RoutingTable -> public List<ShardRouting> allShards(String index);1524684173;All the shards (replicas) for the provided index.__@param index The index to return all the shards (replicas)._@return All the shards matching the specific index_@throws IndexNotFoundException If the index passed does not exists;public List<ShardRouting> allShards(String index)  {_        List<ShardRouting> shards = new ArrayList<>()__        IndexRoutingTable indexRoutingTable = index(index)__        if (indexRoutingTable == null) {_            throw new IndexNotFoundException(index)__        }_        for (IndexShardRoutingTable indexShardRoutingTable : indexRoutingTable) {_            for (ShardRouting shardRouting : indexShardRoutingTable) {_                shards.add(shardRouting)__            }_        }_        return shards__    };all,the,shards,replicas,for,the,provided,index,param,index,the,index,to,return,all,the,shards,replicas,return,all,the,shards,matching,the,specific,index,throws,index,not,found,exception,if,the,index,passed,does,not,exists;public,list,shard,routing,all,shards,string,index,list,shard,routing,shards,new,array,list,index,routing,table,index,routing,table,index,index,if,index,routing,table,null,throw,new,index,not,found,exception,index,for,index,shard,routing,table,index,shard,routing,table,index,routing,table,for,shard,routing,shard,routing,index,shard,routing,table,shards,add,shard,routing,return,shards
RoutingTable -> public List<ShardRouting> allShards(String index);1539723533;All the shards (replicas) for the provided index.__@param index The index to return all the shards (replicas)._@return All the shards matching the specific index_@throws IndexNotFoundException If the index passed does not exists;public List<ShardRouting> allShards(String index)  {_        List<ShardRouting> shards = new ArrayList<>()__        IndexRoutingTable indexRoutingTable = index(index)__        if (indexRoutingTable == null) {_            throw new IndexNotFoundException(index)__        }_        for (IndexShardRoutingTable indexShardRoutingTable : indexRoutingTable) {_            for (ShardRouting shardRouting : indexShardRoutingTable) {_                shards.add(shardRouting)__            }_        }_        return shards__    };all,the,shards,replicas,for,the,provided,index,param,index,the,index,to,return,all,the,shards,replicas,return,all,the,shards,matching,the,specific,index,throws,index,not,found,exception,if,the,index,passed,does,not,exists;public,list,shard,routing,all,shards,string,index,list,shard,routing,shards,new,array,list,index,routing,table,index,routing,table,index,index,if,index,routing,table,null,throw,new,index,not,found,exception,index,for,index,shard,routing,table,index,shard,routing,table,index,routing,table,for,shard,routing,shard,routing,index,shard,routing,table,shards,add,shard,routing,return,shards
RoutingTable -> public List<ShardRouting> allShards(String index);1540847035;All the shards (replicas) for the provided index.__@param index The index to return all the shards (replicas)._@return All the shards matching the specific index_@throws IndexNotFoundException If the index passed does not exists;public List<ShardRouting> allShards(String index)  {_        List<ShardRouting> shards = new ArrayList<>()__        IndexRoutingTable indexRoutingTable = index(index)__        if (indexRoutingTable == null) {_            throw new IndexNotFoundException(index)__        }_        for (IndexShardRoutingTable indexShardRoutingTable : indexRoutingTable) {_            for (ShardRouting shardRouting : indexShardRoutingTable) {_                shards.add(shardRouting)__            }_        }_        return shards__    };all,the,shards,replicas,for,the,provided,index,param,index,the,index,to,return,all,the,shards,replicas,return,all,the,shards,matching,the,specific,index,throws,index,not,found,exception,if,the,index,passed,does,not,exists;public,list,shard,routing,all,shards,string,index,list,shard,routing,shards,new,array,list,index,routing,table,index,routing,table,index,index,if,index,routing,table,null,throw,new,index,not,found,exception,index,for,index,shard,routing,table,index,shard,routing,table,index,routing,table,for,shard,routing,shard,routing,index,shard,routing,table,shards,add,shard,routing,return,shards
RoutingTable -> public List<ShardRouting> allShards(String index);1541446827;All the shards (replicas) for the provided index.__@param index The index to return all the shards (replicas)._@return All the shards matching the specific index_@throws IndexNotFoundException If the index passed does not exists;public List<ShardRouting> allShards(String index)  {_        List<ShardRouting> shards = new ArrayList<>()__        IndexRoutingTable indexRoutingTable = index(index)__        if (indexRoutingTable == null) {_            throw new IndexNotFoundException(index)__        }_        for (IndexShardRoutingTable indexShardRoutingTable : indexRoutingTable) {_            for (ShardRouting shardRouting : indexShardRoutingTable) {_                shards.add(shardRouting)__            }_        }_        return shards__    };all,the,shards,replicas,for,the,provided,index,param,index,the,index,to,return,all,the,shards,replicas,return,all,the,shards,matching,the,specific,index,throws,index,not,found,exception,if,the,index,passed,does,not,exists;public,list,shard,routing,all,shards,string,index,list,shard,routing,shards,new,array,list,index,routing,table,index,routing,table,index,index,if,index,routing,table,null,throw,new,index,not,found,exception,index,for,index,shard,routing,table,index,shard,routing,table,index,routing,table,for,shard,routing,shard,routing,index,shard,routing,table,shards,add,shard,routing,return,shards
RoutingTable -> public List<ShardRouting> allShards(String index);1549912434;All the shards (replicas) for the provided index.__@param index The index to return all the shards (replicas)._@return All the shards matching the specific index_@throws IndexNotFoundException If the index passed does not exists;public List<ShardRouting> allShards(String index)  {_        List<ShardRouting> shards = new ArrayList<>()__        IndexRoutingTable indexRoutingTable = index(index)__        if (indexRoutingTable == null) {_            throw new IndexNotFoundException(index)__        }_        for (IndexShardRoutingTable indexShardRoutingTable : indexRoutingTable) {_            for (ShardRouting shardRouting : indexShardRoutingTable) {_                shards.add(shardRouting)__            }_        }_        return shards__    };all,the,shards,replicas,for,the,provided,index,param,index,the,index,to,return,all,the,shards,replicas,return,all,the,shards,matching,the,specific,index,throws,index,not,found,exception,if,the,index,passed,does,not,exists;public,list,shard,routing,all,shards,string,index,list,shard,routing,shards,new,array,list,index,routing,table,index,routing,table,index,index,if,index,routing,table,null,throw,new,index,not,found,exception,index,for,index,shard,routing,table,index,shard,routing,table,index,routing,table,for,shard,routing,shard,routing,index,shard,routing,table,shards,add,shard,routing,return,shards
RoutingTable -> Builder -> public Builder updateNumberOfReplicas(final int numberOfReplicas, final String[] indices);1539723533;Update the number of replicas for the specified indices.__@param numberOfReplicas the number of replicas_@param indices          the indices to update the number of replicas for_@return the builder;public Builder updateNumberOfReplicas(final int numberOfReplicas, final String[] indices) {_            if (indicesRouting == null) {_                throw new IllegalStateException("once build is called the builder cannot be reused")__            }_            for (String index : indices) {_                IndexRoutingTable indexRoutingTable = indicesRouting.get(index)__                if (indexRoutingTable == null) {_                    _                    continue__                }_                int currentNumberOfReplicas = indexRoutingTable.shards().get(0).size() - 1_ _                IndexRoutingTable.Builder builder = new IndexRoutingTable.Builder(indexRoutingTable.getIndex())__                _                for (IndexShardRoutingTable indexShardRoutingTable : indexRoutingTable) {_                    builder.addIndexShard(indexShardRoutingTable)__                }_                if (currentNumberOfReplicas < numberOfReplicas) {_                    _                    for (int i = 0_ i < (numberOfReplicas - currentNumberOfReplicas)_ i++) {_                        builder.addReplica()__                    }_                } else if (currentNumberOfReplicas > numberOfReplicas) {_                    int delta = currentNumberOfReplicas - numberOfReplicas__                    if (delta <= 0) {_                        _                    } else {_                        for (int i = 0_ i < delta_ i++) {_                            builder.removeReplica()__                        }_                    }_                }_                indicesRouting.put(index, builder.build())__            }_            return this__        };update,the,number,of,replicas,for,the,specified,indices,param,number,of,replicas,the,number,of,replicas,param,indices,the,indices,to,update,the,number,of,replicas,for,return,the,builder;public,builder,update,number,of,replicas,final,int,number,of,replicas,final,string,indices,if,indices,routing,null,throw,new,illegal,state,exception,once,build,is,called,the,builder,cannot,be,reused,for,string,index,indices,index,routing,table,index,routing,table,indices,routing,get,index,if,index,routing,table,null,continue,int,current,number,of,replicas,index,routing,table,shards,get,0,size,1,index,routing,table,builder,builder,new,index,routing,table,builder,index,routing,table,get,index,for,index,shard,routing,table,index,shard,routing,table,index,routing,table,builder,add,index,shard,index,shard,routing,table,if,current,number,of,replicas,number,of,replicas,for,int,i,0,i,number,of,replicas,current,number,of,replicas,i,builder,add,replica,else,if,current,number,of,replicas,number,of,replicas,int,delta,current,number,of,replicas,number,of,replicas,if,delta,0,else,for,int,i,0,i,delta,i,builder,remove,replica,indices,routing,put,index,builder,build,return,this
RoutingTable -> Builder -> public Builder updateNumberOfReplicas(final int numberOfReplicas, final String[] indices);1540847035;Update the number of replicas for the specified indices.__@param numberOfReplicas the number of replicas_@param indices          the indices to update the number of replicas for_@return the builder;public Builder updateNumberOfReplicas(final int numberOfReplicas, final String[] indices) {_            if (indicesRouting == null) {_                throw new IllegalStateException("once build is called the builder cannot be reused")__            }_            for (String index : indices) {_                IndexRoutingTable indexRoutingTable = indicesRouting.get(index)__                if (indexRoutingTable == null) {_                    _                    continue__                }_                int currentNumberOfReplicas = indexRoutingTable.shards().get(0).size() - 1_ _                IndexRoutingTable.Builder builder = new IndexRoutingTable.Builder(indexRoutingTable.getIndex())__                _                for (IndexShardRoutingTable indexShardRoutingTable : indexRoutingTable) {_                    builder.addIndexShard(indexShardRoutingTable)__                }_                if (currentNumberOfReplicas < numberOfReplicas) {_                    _                    for (int i = 0_ i < (numberOfReplicas - currentNumberOfReplicas)_ i++) {_                        builder.addReplica()__                    }_                } else if (currentNumberOfReplicas > numberOfReplicas) {_                    int delta = currentNumberOfReplicas - numberOfReplicas__                    if (delta <= 0) {_                        _                    } else {_                        for (int i = 0_ i < delta_ i++) {_                            builder.removeReplica()__                        }_                    }_                }_                indicesRouting.put(index, builder.build())__            }_            return this__        };update,the,number,of,replicas,for,the,specified,indices,param,number,of,replicas,the,number,of,replicas,param,indices,the,indices,to,update,the,number,of,replicas,for,return,the,builder;public,builder,update,number,of,replicas,final,int,number,of,replicas,final,string,indices,if,indices,routing,null,throw,new,illegal,state,exception,once,build,is,called,the,builder,cannot,be,reused,for,string,index,indices,index,routing,table,index,routing,table,indices,routing,get,index,if,index,routing,table,null,continue,int,current,number,of,replicas,index,routing,table,shards,get,0,size,1,index,routing,table,builder,builder,new,index,routing,table,builder,index,routing,table,get,index,for,index,shard,routing,table,index,shard,routing,table,index,routing,table,builder,add,index,shard,index,shard,routing,table,if,current,number,of,replicas,number,of,replicas,for,int,i,0,i,number,of,replicas,current,number,of,replicas,i,builder,add,replica,else,if,current,number,of,replicas,number,of,replicas,int,delta,current,number,of,replicas,number,of,replicas,if,delta,0,else,for,int,i,0,i,delta,i,builder,remove,replica,indices,routing,put,index,builder,build,return,this
RoutingTable -> Builder -> public Builder updateNumberOfReplicas(final int numberOfReplicas, final String[] indices);1541446827;Update the number of replicas for the specified indices.__@param numberOfReplicas the number of replicas_@param indices          the indices to update the number of replicas for_@return the builder;public Builder updateNumberOfReplicas(final int numberOfReplicas, final String[] indices) {_            if (indicesRouting == null) {_                throw new IllegalStateException("once build is called the builder cannot be reused")__            }_            for (String index : indices) {_                IndexRoutingTable indexRoutingTable = indicesRouting.get(index)__                if (indexRoutingTable == null) {_                    _                    continue__                }_                int currentNumberOfReplicas = indexRoutingTable.shards().get(0).size() - 1_ _                IndexRoutingTable.Builder builder = new IndexRoutingTable.Builder(indexRoutingTable.getIndex())__                _                for (IndexShardRoutingTable indexShardRoutingTable : indexRoutingTable) {_                    builder.addIndexShard(indexShardRoutingTable)__                }_                if (currentNumberOfReplicas < numberOfReplicas) {_                    _                    for (int i = 0_ i < (numberOfReplicas - currentNumberOfReplicas)_ i++) {_                        builder.addReplica()__                    }_                } else if (currentNumberOfReplicas > numberOfReplicas) {_                    int delta = currentNumberOfReplicas - numberOfReplicas__                    if (delta <= 0) {_                        _                    } else {_                        for (int i = 0_ i < delta_ i++) {_                            builder.removeReplica()__                        }_                    }_                }_                indicesRouting.put(index, builder.build())__            }_            return this__        };update,the,number,of,replicas,for,the,specified,indices,param,number,of,replicas,the,number,of,replicas,param,indices,the,indices,to,update,the,number,of,replicas,for,return,the,builder;public,builder,update,number,of,replicas,final,int,number,of,replicas,final,string,indices,if,indices,routing,null,throw,new,illegal,state,exception,once,build,is,called,the,builder,cannot,be,reused,for,string,index,indices,index,routing,table,index,routing,table,indices,routing,get,index,if,index,routing,table,null,continue,int,current,number,of,replicas,index,routing,table,shards,get,0,size,1,index,routing,table,builder,builder,new,index,routing,table,builder,index,routing,table,get,index,for,index,shard,routing,table,index,shard,routing,table,index,routing,table,builder,add,index,shard,index,shard,routing,table,if,current,number,of,replicas,number,of,replicas,for,int,i,0,i,number,of,replicas,current,number,of,replicas,i,builder,add,replica,else,if,current,number,of,replicas,number,of,replicas,int,delta,current,number,of,replicas,number,of,replicas,if,delta,0,else,for,int,i,0,i,delta,i,builder,remove,replica,indices,routing,put,index,builder,build,return,this
RoutingTable -> Builder -> public Builder updateNumberOfReplicas(final int numberOfReplicas, final String[] indices);1549912434;Update the number of replicas for the specified indices.__@param numberOfReplicas the number of replicas_@param indices          the indices to update the number of replicas for_@return the builder;public Builder updateNumberOfReplicas(final int numberOfReplicas, final String[] indices) {_            if (indicesRouting == null) {_                throw new IllegalStateException("once build is called the builder cannot be reused")__            }_            for (String index : indices) {_                IndexRoutingTable indexRoutingTable = indicesRouting.get(index)__                if (indexRoutingTable == null) {_                    _                    continue__                }_                int currentNumberOfReplicas = indexRoutingTable.shards().get(0).size() - 1_ _                IndexRoutingTable.Builder builder = new IndexRoutingTable.Builder(indexRoutingTable.getIndex())__                _                for (IndexShardRoutingTable indexShardRoutingTable : indexRoutingTable) {_                    builder.addIndexShard(indexShardRoutingTable)__                }_                if (currentNumberOfReplicas < numberOfReplicas) {_                    _                    for (int i = 0_ i < (numberOfReplicas - currentNumberOfReplicas)_ i++) {_                        builder.addReplica()__                    }_                } else if (currentNumberOfReplicas > numberOfReplicas) {_                    int delta = currentNumberOfReplicas - numberOfReplicas__                    if (delta <= 0) {_                        _                    } else {_                        for (int i = 0_ i < delta_ i++) {_                            builder.removeReplica()__                        }_                    }_                }_                indicesRouting.put(index, builder.build())__            }_            return this__        };update,the,number,of,replicas,for,the,specified,indices,param,number,of,replicas,the,number,of,replicas,param,indices,the,indices,to,update,the,number,of,replicas,for,return,the,builder;public,builder,update,number,of,replicas,final,int,number,of,replicas,final,string,indices,if,indices,routing,null,throw,new,illegal,state,exception,once,build,is,called,the,builder,cannot,be,reused,for,string,index,indices,index,routing,table,index,routing,table,indices,routing,get,index,if,index,routing,table,null,continue,int,current,number,of,replicas,index,routing,table,shards,get,0,size,1,index,routing,table,builder,builder,new,index,routing,table,builder,index,routing,table,get,index,for,index,shard,routing,table,index,shard,routing,table,index,routing,table,builder,add,index,shard,index,shard,routing,table,if,current,number,of,replicas,number,of,replicas,for,int,i,0,i,number,of,replicas,current,number,of,replicas,i,builder,add,replica,else,if,current,number,of,replicas,number,of,replicas,int,delta,current,number,of,replicas,number,of,replicas,if,delta,0,else,for,int,i,0,i,delta,i,builder,remove,replica,indices,routing,put,index,builder,build,return,this
