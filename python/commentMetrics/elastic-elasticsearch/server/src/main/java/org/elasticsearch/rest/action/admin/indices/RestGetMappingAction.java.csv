commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String getName() {     return "get_mapping_action". }
false;public;2;50;;@Override public RestResponse buildResponse(final GetMappingsResponse response, final XContentBuilder builder) throws Exception {     final ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> mappingsByIndex = response.getMappings().     if (mappingsByIndex.isEmpty() && types.length != 0) {         builder.close().         return new BytesRestResponse(channel, new TypeMissingException("_all", String.join(",", types))).     }     final Set<String> typeNames = new HashSet<>().     for (final ObjectCursor<ImmutableOpenMap<String, MappingMetaData>> cursor : mappingsByIndex.values()) {         for (final ObjectCursor<String> inner : cursor.value.keys()) {             typeNames.add(inner.value).         }     }     final SortedSet<String> difference = Sets.sortedDifference(Arrays.stream(types).collect(Collectors.toSet()), typeNames).     // now remove requested aliases that contain wildcards that are simple matches     final List<String> matches = new ArrayList<>().     outer: for (final String pattern : difference) {         if (pattern.contains("*")) {             for (final String typeName : typeNames) {                 if (Regex.simpleMatch(pattern, typeName)) {                     matches.add(pattern).                     continue outer.                 }             }         }     }     difference.removeAll(matches).     final RestStatus status.     builder.startObject().     {         if (difference.isEmpty()) {             status = RestStatus.OK.         } else {             status = RestStatus.NOT_FOUND.             final String message = String.format(Locale.ROOT, "type" + (difference.size() == 1 ? "" : "s") + " [%s] missing", Strings.collectionToCommaDelimitedString(difference)).             builder.field("error", message).             builder.field("status", status.getStatus()).         }         response.toXContent(builder, request).     }     builder.endObject().     return new BytesRestResponse(status, builder). }
false;public;2;74;;@Override public RestChannelConsumer prepareRequest(final RestRequest request, final NodeClient client) throws IOException {     final String[] indices = Strings.splitStringByCommaToArray(request.param("index")).     final String[] types = request.paramAsStringArrayOrEmptyIfAll("type").     boolean includeTypeName = request.paramAsBoolean(INCLUDE_TYPE_NAME_PARAMETER, DEFAULT_INCLUDE_TYPE_NAME_POLICY).     if (request.method().equals(HEAD)) {         deprecationLogger.deprecated("Type exists requests are deprecated, as types have been deprecated.").     } else if (includeTypeName == false && types.length > 0) {         throw new IllegalArgumentException("Types cannot be provided in get mapping requests, unless" + " include_type_name is set to true.").     }     if (request.hasParam(INCLUDE_TYPE_NAME_PARAMETER)) {         deprecationLogger.deprecatedAndMaybeLog("get_mapping_with_types", TYPES_DEPRECATION_MESSAGE).     }     final GetMappingsRequest getMappingsRequest = new GetMappingsRequest().     getMappingsRequest.indices(indices).types(types).     getMappingsRequest.indicesOptions(IndicesOptions.fromRequest(request, getMappingsRequest.indicesOptions())).     getMappingsRequest.masterNodeTimeout(request.paramAsTime("master_timeout", getMappingsRequest.masterNodeTimeout())).     getMappingsRequest.local(request.paramAsBoolean("local", getMappingsRequest.local())).     return channel -> client.admin().indices().getMappings(getMappingsRequest, new RestBuilderListener<GetMappingsResponse>(channel) {          @Override         public RestResponse buildResponse(final GetMappingsResponse response, final XContentBuilder builder) throws Exception {             final ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> mappingsByIndex = response.getMappings().             if (mappingsByIndex.isEmpty() && types.length != 0) {                 builder.close().                 return new BytesRestResponse(channel, new TypeMissingException("_all", String.join(",", types))).             }             final Set<String> typeNames = new HashSet<>().             for (final ObjectCursor<ImmutableOpenMap<String, MappingMetaData>> cursor : mappingsByIndex.values()) {                 for (final ObjectCursor<String> inner : cursor.value.keys()) {                     typeNames.add(inner.value).                 }             }             final SortedSet<String> difference = Sets.sortedDifference(Arrays.stream(types).collect(Collectors.toSet()), typeNames).             // now remove requested aliases that contain wildcards that are simple matches             final List<String> matches = new ArrayList<>().             outer: for (final String pattern : difference) {                 if (pattern.contains("*")) {                     for (final String typeName : typeNames) {                         if (Regex.simpleMatch(pattern, typeName)) {                             matches.add(pattern).                             continue outer.                         }                     }                 }             }             difference.removeAll(matches).             final RestStatus status.             builder.startObject().             {                 if (difference.isEmpty()) {                     status = RestStatus.OK.                 } else {                     status = RestStatus.NOT_FOUND.                     final String message = String.format(Locale.ROOT, "type" + (difference.size() == 1 ? "" : "s") + " [%s] missing", Strings.collectionToCommaDelimitedString(difference)).                     builder.field("error", message).                     builder.field("status", status.getStatus()).                 }                 response.toXContent(builder, request).             }             builder.endObject().             return new BytesRestResponse(status, builder).         }     }). }
