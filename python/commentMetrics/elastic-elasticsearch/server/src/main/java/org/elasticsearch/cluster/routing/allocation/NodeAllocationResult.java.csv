commented;modifiers;parameterAmount;loc;comment;code
false;public;1;8;;@Override public void writeTo(StreamOutput out) throws IOException {     node.writeTo(out).     out.writeOptionalWriteable(shardStoreInfo).     out.writeOptionalWriteable(canAllocateDecision).     nodeDecision.writeTo(out).     out.writeVInt(weightRanking). }
true;public;0;3;/**  * Get the node that this decision is for.  */ ;/**  * Get the node that this decision is for.  */ public DiscoveryNode getNode() {     return node. }
true;public;0;4;/**  * Get the shard store information for the node, if it exists.  */ ;/**  * Get the shard store information for the node, if it exists.  */ @Nullable public ShardStoreInfo getShardStoreInfo() {     return shardStoreInfo. }
true;public;0;4;/**  * The decision details for allocating to this node.  Returns {@code null} if  * no allocation decision was taken on the node. in this case, {@link #getNodeDecision()}  * will return {@link AllocationDecision#NO}.  */ ;/**  * The decision details for allocating to this node.  Returns {@code null} if  * no allocation decision was taken on the node. in this case, {@link #getNodeDecision()}  * will return {@link AllocationDecision#NO}.  */ @Nullable public Decision getCanAllocateDecision() {     return canAllocateDecision. }
true;public;0;3;/**  * Is the weight assigned for the node?  */ ;/**  * Is the weight assigned for the node?  */ public boolean isWeightRanked() {     return weightRanking > 0. }
true;public;0;3;/**  * The weight ranking for allocating a shard to the node.  Each node will have  * a unique weight ranking that is relative to the other nodes against which the  * deciders ran.  For example, suppose there are 3 nodes which the allocation deciders  * decided upon: node1, node2, and node3.  If node2 had the best weight for holding the  * shard, followed by node3, followed by node1, then node2's weight will be 1, node3's  * weight will be 2, and node1's weight will be 1.  A value of 0 means the weight was  * not calculated or factored into the decision.  */ ;/**  * The weight ranking for allocating a shard to the node.  Each node will have  * a unique weight ranking that is relative to the other nodes against which the  * deciders ran.  For example, suppose there are 3 nodes which the allocation deciders  * decided upon: node1, node2, and node3.  If node2 had the best weight for holding the  * shard, followed by node3, followed by node1, then node2's weight will be 1, node3's  * weight will be 2, and node1's weight will be 1.  A value of 0 means the weight was  * not calculated or factored into the decision.  */ public int getWeightRanking() {     return weightRanking. }
true;public;0;3;/**  * Gets the {@link AllocationDecision} for allocating to this node.  */ ;/**  * Gets the {@link AllocationDecision} for allocating to this node.  */ public AllocationDecision getNodeDecision() {     return nodeDecision. }
false;public;2;21;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     {         discoveryNodeToXContent(node, false, builder).         builder.field("node_decision", nodeDecision).         if (shardStoreInfo != null) {             shardStoreInfo.toXContent(builder, params).         }         if (isWeightRanked()) {             builder.field("weight_ranking", getWeightRanking()).         }         if (canAllocateDecision != null && canAllocateDecision.getDecisions().isEmpty() == false) {             builder.startArray("deciders").             canAllocateDecision.toXContent(builder, params).             builder.endArray().         }     }     builder.endObject().     return builder. }
false;public;1;4;;@Override public int compareTo(NodeAllocationResult other) {     return nodeResultComparator.compare(this, other). }
true;public;0;3;/**  * Returns {@code true} if the shard copy is in-sync and contains the latest data.  * Returns {@code false} if the shard copy is stale or if the shard copy being examined  * is for a replica shard allocation.  */ ;/**  * Returns {@code true} if the shard copy is in-sync and contains the latest data.  * Returns {@code false} if the shard copy is stale or if the shard copy being examined  * is for a replica shard allocation.  */ public boolean isInSync() {     return inSync. }
true;public;0;4;/**  * Gets the allocation id for the shard copy, if it exists.  */ ;/**  * Gets the allocation id for the shard copy, if it exists.  */ @Nullable public String getAllocationId() {     return allocationId. }
true;public;0;3;/**  * Returns {@code true} if the shard copy has a matching sync id with the primary shard.  * Returns {@code false} if the shard copy does not have a matching sync id with the primary  * shard, or this explanation pertains to the allocation of a primary shard, in which case  * matching sync ids are irrelevant.  */ ;/**  * Returns {@code true} if the shard copy has a matching sync id with the primary shard.  * Returns {@code false} if the shard copy does not have a matching sync id with the primary  * shard, or this explanation pertains to the allocation of a primary shard, in which case  * matching sync ids are irrelevant.  */ public boolean hasMatchingSyncId() {     return matchingBytes == Long.MAX_VALUE. }
true;public;0;3;/**  * Gets the number of matching bytes the shard copy has with the primary shard.  * Returns {@code Long.MAX_VALUE} if {@link #hasMatchingSyncId()} returns {@code true}.  * Returns -1 if not applicable (this value only applies to assigning replica shards).  */ ;/**  * Gets the number of matching bytes the shard copy has with the primary shard.  * Returns {@code Long.MAX_VALUE} if {@link #hasMatchingSyncId()} returns {@code true}.  * Returns -1 if not applicable (this value only applies to assigning replica shards).  */ public long getMatchingBytes() {     return matchingBytes. }
true;public;0;4;/**  * Gets the store exception when trying to read the store, if there was an error.  If  * there was no error, returns {@code null}.  */ ;/**  * Gets the store exception when trying to read the store, if there was an error.  If  * there was no error, returns {@code null}.  */ @Nullable public Exception getStoreException() {     return storeException. }
false;public;1;7;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeBoolean(inSync).     out.writeOptionalString(allocationId).     out.writeLong(matchingBytes).     out.writeException(storeException). }
false;public;2;32;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject("store").     {         if (matchingBytes < 0) {             // dealing with a primary shard             if (allocationId == null && storeException == null) {                 // there was no information we could obtain of any shard data on the node                 builder.field("found", false).             } else {                 builder.field("in_sync", inSync).             }         }         if (allocationId != null) {             builder.field("allocation_id", allocationId).         }         if (matchingBytes >= 0) {             if (hasMatchingSyncId()) {                 builder.field("matching_sync_id", true).             } else {                 builder.humanReadableField("matching_size_in_bytes", "matching_size", new ByteSizeValue(matchingBytes)).             }         }         if (storeException != null) {             builder.startObject("store_exception").             ElasticsearchException.generateThrowableXContent(builder, params, storeException).             builder.endObject().         }     }     builder.endObject().     return builder. }
