commented;modifiers;parameterAmount;loc;comment;code
false;static;4;8;;static <T> ConstructorBindingImpl<T> create(InjectorImpl injector, Key<T> key, Object source, Scoping scoping) {     Factory<T> factoryFactory = new Factory<>().     InternalFactory<? extends T> scopedFactory = Scopes.scope(key, injector, factoryFactory, scoping).     return new ConstructorBindingImpl<>(injector, key, source, scopedFactory, scoping, factoryFactory). }
false;public;2;3;;public void initialize(InjectorImpl injector, Errors errors) throws ErrorsException {     factory.constructorInjector = injector.constructors.get(getKey().getTypeLiteral(), errors). }
false;public;1;7;;@Override public <V> V acceptTargetVisitor(BindingTargetVisitor<? super T, V> visitor) {     if (factory.constructorInjector == null) {         throw new IllegalStateException("not initialized").     }     return visitor.visit(this). }
false;public;0;7;;@Override public InjectionPoint getConstructor() {     if (factory.constructorInjector == null) {         throw new IllegalStateException("Binding is not ready").     }     return factory.constructorInjector.getConstructionProxy().getInjectionPoint(). }
false;public;0;7;;@Override public Set<InjectionPoint> getInjectableMembers() {     if (factory.constructorInjector == null) {         throw new IllegalStateException("Binding is not ready").     }     return factory.constructorInjector.getInjectableMembers(). }
false;public;0;7;;@Override public Set<Dependency<?>> getDependencies() {     Set<InjectionPoint> dependencies = new HashSet<>().     dependencies.add(getConstructor()).     dependencies.addAll(getInjectableMembers()).     return Dependency.forInjectionPoints(dependencies). }
false;public;1;4;;@Override public void applyTo(Binder binder) {     throw new UnsupportedOperationException("This element represents a synthetic binding."). }
false;public;0;8;;@Override public String toString() {     return new ToStringBuilder(ConstructorBinding.class).add("key", getKey()).add("source", getSource()).add("scope", getScoping()).toString(). }
false;public;3;12;;@Override @SuppressWarnings("unchecked") public T get(Errors errors, InternalContext context, Dependency<?> dependency) throws ErrorsException {     if (constructorInjector == null) {         throw new IllegalStateException("Constructor not ready").     }     // client needs), but it should be OK in practice thanks to the wonders of erasure.     return (T) constructorInjector.construct(errors, context, dependency.getKey().getRawType()). }
