commented;modifiers;parameterAmount;loc;comment;code
false;public;1;10;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeString(collectorName).     out.writeString(reason).     out.writeLong(time).     out.writeVInt(children.size()).     for (CollectorResult child : children) {         child.writeTo(out).     } }
true;public;0;3;/**  * @return the profiled time for this collector (inclusive of children)  */ ;/**  * @return the profiled time for this collector (inclusive of children)  */ public long getTime() {     return this.time. }
true;public;0;3;/**  * @return a human readable "hint" about what this collector was used for  */ ;/**  * @return a human readable "hint" about what this collector was used for  */ public String getReason() {     return this.reason. }
true;public;0;3;/**  * @return the lucene class name of the collector  */ ;/**  * @return the lucene class name of the collector  */ public String getName() {     return this.collectorName. }
true;public;0;3;/**  * @return a list of children collectors  */ ;/**  * @return a list of children collectors  */ public List<CollectorResult> getProfiledChildren() {     return children. }
false;public;2;20;;@Override public XContentBuilder toXContent(XContentBuilder builder, ToXContent.Params params) throws IOException {     builder = builder.startObject().     builder.field(NAME.getPreferredName(), getName()).     builder.field(REASON.getPreferredName(), getReason()).     if (builder.humanReadable()) {         builder.field(TIME.getPreferredName(), new TimeValue(getTime(), TimeUnit.NANOSECONDS).toString()).     }     builder.field(TIME_NANOS.getPreferredName(), getTime()).     if (!children.isEmpty()) {         builder = builder.startArray(CHILDREN.getPreferredName()).         for (CollectorResult child : children) {             builder = child.toXContent(builder, params).         }         builder = builder.endArray().     }     builder = builder.endObject().     return builder. }
false;public,static;1;37;;public static CollectorResult fromXContent(XContentParser parser) throws IOException {     XContentParser.Token token = parser.currentToken().     ensureExpectedToken(XContentParser.Token.START_OBJECT, token, parser::getTokenLocation).     String currentFieldName = null.     String name = null, reason = null.     long time = -1.     List<CollectorResult> children = new ArrayList<>().     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (token.isValue()) {             if (NAME.match(currentFieldName, parser.getDeprecationHandler())) {                 name = parser.text().             } else if (REASON.match(currentFieldName, parser.getDeprecationHandler())) {                 reason = parser.text().             } else if (TIME.match(currentFieldName, parser.getDeprecationHandler())) {                 // we need to consume this value, but we use the raw nanosecond value                 parser.text().             } else if (TIME_NANOS.match(currentFieldName, parser.getDeprecationHandler())) {                 time = parser.longValue().             } else {                 parser.skipChildren().             }         } else if (token == XContentParser.Token.START_ARRAY) {             if (CHILDREN.match(currentFieldName, parser.getDeprecationHandler())) {                 while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {                     children.add(CollectorResult.fromXContent(parser)).                 }             } else {                 parser.skipChildren().             }         } else {             parser.skipChildren().         }     }     return new CollectorResult(name, reason, time, children). }
