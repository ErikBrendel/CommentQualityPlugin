commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Name of the field to get contexts from at index-time  */ ;/**  * Name of the field to get contexts from at index-time  */ public String getFieldName() {     return fieldName. }
true;protected,static;2;9;/**  * Loads a <code>name</code>d {@link CategoryContextMapping} instance  * from a map.  * see {@link ContextMappings#load(Object, Version)}  *  * Acceptable map param: <code>path</code>  */ ;/**  * Loads a <code>name</code>d {@link CategoryContextMapping} instance  * from a map.  * see {@link ContextMappings#load(Object, Version)}  *  * Acceptable map param: <code>path</code>  */ protected static CategoryContextMapping load(String name, Map<String, Object> config) throws ElasticsearchParseException {     CategoryContextMapping.Builder mapping = new CategoryContextMapping.Builder(name).     Object fieldName = config.get(FIELD_FIELDNAME).     if (fieldName != null) {         mapping.field(fieldName.toString()).         config.remove(FIELD_FIELDNAME).     }     return mapping.build(). }
false;protected;2;7;;@Override protected XContentBuilder toInnerXContent(XContentBuilder builder, Params params) throws IOException {     if (fieldName != null) {         builder.field(FIELD_FIELDNAME, fieldName).     }     return builder. }
true;public;2;22;/**  * Parse a set of {@link CharSequence} contexts at index-time.  * Acceptable formats:  *  *  <ul>  *     <li>Array: <pre>[<i>&lt.string&gt.</i>, ..]</pre></li>  *     <li>String: <pre>&quot.string&quot.</pre></li>  *  </ul>  */ ;/**  * Parse a set of {@link CharSequence} contexts at index-time.  * Acceptable formats:  *  *  <ul>  *     <li>Array: <pre>[<i>&lt.string&gt.</i>, ..]</pre></li>  *     <li>String: <pre>&quot.string&quot.</pre></li>  *  </ul>  */ @Override public Set<String> parseContext(ParseContext parseContext, XContentParser parser) throws IOException, ElasticsearchParseException {     final Set<String> contexts = new HashSet<>().     Token token = parser.currentToken().     if (token == Token.VALUE_STRING || token == Token.VALUE_NUMBER || token == Token.VALUE_BOOLEAN) {         contexts.add(parser.text()).     } else if (token == Token.START_ARRAY) {         while ((token = parser.nextToken()) != Token.END_ARRAY) {             if (token == Token.VALUE_STRING || token == Token.VALUE_NUMBER || token == Token.VALUE_BOOLEAN) {                 contexts.add(parser.text()).             } else {                 throw new ElasticsearchParseException("context array must have string, number or boolean values, but was [" + token + "]").             }         }     } else {         throw new ElasticsearchParseException("contexts must be a string, number or boolean or a list of string, number or boolean, but was [" + token + "]").     }     return contexts. }
false;public;1;23;;@Override public Set<String> parseContext(Document document) {     Set<String> values = null.     if (fieldName != null) {         IndexableField[] fields = document.getFields(fieldName).         values = new HashSet<>(fields.length).         for (IndexableField field : fields) {             if (field instanceof SortedDocValuesField || field instanceof SortedSetDocValuesField || field instanceof StoredField) {             // Ignore doc values and stored fields             } else if (field.fieldType() instanceof KeywordFieldMapper.KeywordFieldType) {                 values.add(field.binaryValue().utf8ToString()).             } else if (field.fieldType() instanceof StringFieldType) {                 values.add(field.stringValue()).             } else {                 throw new IllegalArgumentException("Failed to parse context field [" + fieldName + "], only keyword and text fields are accepted").             }         }     }     return (values == null) ? Collections.emptySet() : values. }
false;protected;1;4;;@Override protected CategoryQueryContext fromXContent(XContentParser parser) throws IOException {     return CategoryQueryContext.fromXContent(parser). }
true;public;1;9;/**  * Parse a list of {@link CategoryQueryContext}  * using <code>parser</code>. A QueryContexts accepts one of the following forms:  *  * <ul>  *     <li>Object: CategoryQueryContext</li>  *     <li>String: CategoryQueryContext value with prefix=false and boost=1</li>  *     <li>Array: <pre>[CategoryQueryContext, ..]</pre></li>  * </ul>  *  *  A CategoryQueryContext has one of the following forms:  *  <ul>  *     <li>Object: <pre>{&quot.context&quot.: <i>&lt.string&gt.</i>, &quot.boost&quot.: <i>&lt.int&gt.</i>, &quot.prefix&quot.:  *     <i>&lt.boolean&gt.</i>}</pre></li>  *     <li>String: <pre>&quot.string&quot.</pre></li>  *  </ul>  */ ;/**  * Parse a list of {@link CategoryQueryContext}  * using <code>parser</code>. A QueryContexts accepts one of the following forms:  *  * <ul>  *     <li>Object: CategoryQueryContext</li>  *     <li>String: CategoryQueryContext value with prefix=false and boost=1</li>  *     <li>Array: <pre>[CategoryQueryContext, ..]</pre></li>  * </ul>  *  *  A CategoryQueryContext has one of the following forms:  *  <ul>  *     <li>Object: <pre>{&quot.context&quot.: <i>&lt.string&gt.</i>, &quot.boost&quot.: <i>&lt.int&gt.</i>, &quot.prefix&quot.:  *     <i>&lt.boolean&gt.</i>}</pre></li>  *     <li>String: <pre>&quot.string&quot.</pre></li>  *  </ul>  */ @Override public List<InternalQueryContext> toInternalQueryContexts(List<CategoryQueryContext> queryContexts) {     List<InternalQueryContext> internalInternalQueryContexts = new ArrayList<>(queryContexts.size()).     internalInternalQueryContexts.addAll(queryContexts.stream().map(queryContext -> new InternalQueryContext(queryContext.getCategory(), queryContext.getBoost(), queryContext.isPrefix())).collect(Collectors.toList())).     return internalInternalQueryContexts. }
false;public;1;8;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     if (!super.equals(o))         return false.     CategoryContextMapping mapping = (CategoryContextMapping) o.     return !(fieldName != null ? !fieldName.equals(mapping.fieldName) : mapping.fieldName != null). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(super.hashCode(), fieldName). }
true;public;1;4;/**  * Set the name of the field to use  */ ;/**  * Set the name of the field to use  */ public Builder field(String fieldName) {     this.fieldName = fieldName.     return this. }
false;public;0;4;;@Override public CategoryContextMapping build() {     return new CategoryContextMapping(name, fieldName). }
