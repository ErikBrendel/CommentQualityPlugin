commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String toString() {     return "Correction [score=" + score + ", candidates=" + Arrays.toString(candidates) + "]". }
false;public;1;3;;public BytesRef join(BytesRef separator) {     return join(separator, null, null). }
false;public;3;3;;public BytesRef join(BytesRef separator, BytesRef preTag, BytesRef postTag) {     return join(separator, new BytesRefBuilder(), preTag, postTag). }
false;public;4;25;;public BytesRef join(BytesRef separator, BytesRefBuilder result, BytesRef preTag, BytesRef postTag) {     BytesRef[] toJoin = new BytesRef[this.candidates.length].     int len = separator.length * this.candidates.length - 1.     for (int i = 0. i < toJoin.length. i++) {         Candidate candidate = candidates[i].         if (preTag == null || candidate.userInput) {             toJoin[i] = candidate.term.         } else {             final int maxLen = preTag.length + postTag.length + candidate.term.length.             // just allocate once             final BytesRefBuilder highlighted = new BytesRefBuilder().             highlighted.grow(maxLen).             if (i == 0 || candidates[i - 1].userInput) {                 highlighted.append(preTag).             }             highlighted.append(candidate.term).             if (toJoin.length == i + 1 || candidates[i + 1].userInput) {                 highlighted.append(postTag).             }             toJoin[i] = highlighted.get().         }         len += toJoin[i].length.     }     result.grow(len).     return WordScorer.join(separator, result, toJoin). }
true;public;1;4;/**  * Lower scores sorts first. if scores are equal,  *  than later terms (zzz) sort first .  */ ;/**  * Lower scores sorts first. if scores are equal,  *  than later terms (zzz) sort first .  */ @Override public int compareTo(Correction other) {     return compareTo(other.score, other.candidates). }
false;;2;16;;int compareTo(double otherScore, Candidate[] otherCandidates) {     if (score == otherScore) {         int limit = Math.min(candidates.length, otherCandidates.length).         for (int i = 0. i < limit. i++) {             int cmp = candidates[i].term.compareTo(otherCandidates[i].term).             if (cmp != 0) {                 // Later (zzz) terms sort before (are weaker than) earlier (aaa) terms:                 return -cmp.             }         }         return candidates.length - otherCandidates.length.     } else {         return Double.compare(score, otherScore).     } }
