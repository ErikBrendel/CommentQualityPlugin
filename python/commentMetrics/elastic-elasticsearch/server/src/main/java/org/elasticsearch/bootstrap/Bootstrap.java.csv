commented;modifiers;parameterAmount;loc;comment;code
false;public;0;8;;@Override public void run() {     try {         keepAliveLatch.await().     } catch (InterruptedException e) {     // bail out     } }
false;public;0;4;;@Override public void run() {     keepAliveLatch.countDown(). }
false;public;1;13;;@Override public boolean handle(int code) {     if (CTRL_CLOSE_EVENT == code) {         logger.info("running graceful exit on windows").         try {             Bootstrap.stop().         } catch (IOException e) {             throw new ElasticsearchException("failed to stop node", e).         }         return true.     }     return false. }
true;public,static;4;55;/**  * initialize native resources  */ ;/**  * initialize native resources  */ public static void initializeNatives(Path tmpFile, boolean mlockAll, boolean systemCallFilter, boolean ctrlHandler) {     final Logger logger = LogManager.getLogger(Bootstrap.class).     // check if the user is running as root, and bail     if (Natives.definitelyRunningAsRoot()) {         throw new RuntimeException("can not run elasticsearch as root").     }     // enable system call filter     if (systemCallFilter) {         Natives.tryInstallSystemCallFilter(tmpFile).     }     // mlockall if requested     if (mlockAll) {         if (Constants.WINDOWS) {             Natives.tryVirtualLock().         } else {             Natives.tryMlockall().         }     }     // listener for windows close event     if (ctrlHandler) {         Natives.addConsoleCtrlHandler(new ConsoleCtrlHandler() {              @Override             public boolean handle(int code) {                 if (CTRL_CLOSE_EVENT == code) {                     logger.info("running graceful exit on windows").                     try {                         Bootstrap.stop().                     } catch (IOException e) {                         throw new ElasticsearchException("failed to stop node", e).                     }                     return true.                 }                 return false.             }         }).     }     // force remainder of JNA to be loaded (if available).     try {         JNAKernel32Library.getInstance().     } catch (Exception ignored) {     // we've already logged this.     }     Natives.trySetMaxNumberOfThreads().     Natives.trySetMaxSizeVirtualMemory().     Natives.trySetMaxFileSize().     // init lucene random seed. it will use /dev/urandom where available:     StringHelper.randomId(). }
false;static;0;6;;static void initializeProbes() {     // Force probes to be loaded     ProcessProbe.getInstance().     OsProbe.getInstance().     JvmInfo.jvmInfo(). }
false;public;0;10;;@Override public void run() {     try {         IOUtils.close(node, spawner).         LoggerContext context = (LoggerContext) LogManager.getContext(false).         Configurator.shutdown(context).     } catch (IOException ex) {         throw new ElasticsearchException("failed to stop node", ex).     } }
false;protected;3;6;;@Override protected void validateNodeBeforeAcceptingRequests(final BootstrapContext context, final BoundTransportAddress boundTransportAddress, List<BootstrapCheck> checks) throws NodeValidationException {     BootstrapChecks.check(context, boundTransportAddress, checks). }
false;private;2;60;;private void setup(boolean addShutdownHook, Environment environment) throws BootstrapException {     Settings settings = environment.settings().     try {         spawner.spawnNativeControllers(environment).     } catch (IOException e) {         throw new BootstrapException(e).     }     initializeNatives(environment.tmpFile(), BootstrapSettings.MEMORY_LOCK_SETTING.get(settings), BootstrapSettings.SYSTEM_CALL_FILTER_SETTING.get(settings), BootstrapSettings.CTRLHANDLER_SETTING.get(settings)).     // initialize probes before the security manager is installed     initializeProbes().     if (addShutdownHook) {         Runtime.getRuntime().addShutdownHook(new Thread() {              @Override             public void run() {                 try {                     IOUtils.close(node, spawner).                     LoggerContext context = (LoggerContext) LogManager.getContext(false).                     Configurator.shutdown(context).                 } catch (IOException ex) {                     throw new ElasticsearchException("failed to stop node", ex).                 }             }         }).     }     try {         // look for jar hell         final Logger logger = LogManager.getLogger(JarHell.class).         JarHell.checkJarHell(logger::debug).     } catch (IOException | URISyntaxException e) {         throw new BootstrapException(e).     }     // Log ifconfig output before SecurityManager is installed     IfConfig.logIfNecessary().     // install SM after natives, shutdown hooks, etc.     try {         Security.configure(environment, BootstrapSettings.SECURITY_FILTER_BAD_DEFAULTS_SETTING.get(settings)).     } catch (IOException | NoSuchAlgorithmException e) {         throw new BootstrapException(e).     }     node = new Node(environment) {          @Override         protected void validateNodeBeforeAcceptingRequests(final BootstrapContext context, final BoundTransportAddress boundTransportAddress, List<BootstrapCheck> checks) throws NodeValidationException {             BootstrapChecks.check(context, boundTransportAddress, checks).         }     }. }
false;static;1;22;;static SecureSettings loadSecureSettings(Environment initialEnv) throws BootstrapException {     final KeyStoreWrapper keystore.     try {         keystore = KeyStoreWrapper.load(initialEnv.configFile()).     } catch (IOException e) {         throw new BootstrapException(e).     }     try {         if (keystore == null) {             final KeyStoreWrapper keyStoreWrapper = KeyStoreWrapper.create().             keyStoreWrapper.save(initialEnv.configFile(), new char[0]).             return keyStoreWrapper.         } else {             keystore.decrypt(new char[0]).             KeyStoreWrapper.upgrade(keystore, initialEnv.configFile(), new char[0]).         }     } catch (Exception e) {         throw new BootstrapException(e).     }     return keystore. }
false;private,static;4;17;;private static Environment createEnvironment(final Path pidFile, final SecureSettings secureSettings, final Settings initialSettings, final Path configPath) {     Settings.Builder builder = Settings.builder().     if (pidFile != null) {         builder.put(Environment.PIDFILE_SETTING.getKey(), pidFile).     }     builder.put(initialSettings).     if (secureSettings != null) {         builder.setSecureSettings(secureSettings).     }     return InternalSettingsPreparer.prepareEnvironment(builder.build(), Collections.emptyMap(), configPath, // HOSTNAME is set by elasticsearch-env and elasticsearch-env.bat so it is always available     () -> System.getenv("HOSTNAME")). }
false;private;0;4;;private void start() throws NodeValidationException {     node.start().     keepAliveThread.start(). }
false;static;0;7;;static void stop() throws IOException {     try {         IOUtils.close(INSTANCE.node, INSTANCE.spawner).     } finally {         INSTANCE.keepAliveLatch.countDown().     } }
true;static;4;102;/**  * This method is invoked by {@link Elasticsearch#main(String[])} to startup elasticsearch.  */ ;/**  * This method is invoked by {@link Elasticsearch#main(String[])} to startup elasticsearch.  */ static void init(final boolean foreground, final Path pidFile, final boolean quiet, final Environment initialEnv) throws BootstrapException, NodeValidationException, UserException {     // force the class initializer for BootstrapInfo to run before     // the security manager is installed     BootstrapInfo.init().     INSTANCE = new Bootstrap().     final SecureSettings keystore = loadSecureSettings(initialEnv).     final Environment environment = createEnvironment(pidFile, keystore, initialEnv.settings(), initialEnv.configFile()).     LogConfigurator.setNodeName(Node.NODE_NAME_SETTING.get(environment.settings())).     try {         LogConfigurator.configure(environment).     } catch (IOException e) {         throw new BootstrapException(e).     }     if (environment.pidFile() != null) {         try {             PidFile.create(environment.pidFile(), true).         } catch (IOException e) {             throw new BootstrapException(e).         }     }     final boolean closeStandardStreams = (foreground == false) || quiet.     try {         if (closeStandardStreams) {             final Logger rootLogger = LogManager.getRootLogger().             final Appender maybeConsoleAppender = Loggers.findAppender(rootLogger, ConsoleAppender.class).             if (maybeConsoleAppender != null) {                 Loggers.removeAppender(rootLogger, maybeConsoleAppender).             }             closeSystOut().         }         // fail if somebody replaced the lucene jars         checkLucene().         // install the default uncaught exception handler. must be done before security is         // initialized as we do not want to grant the runtime permission         // setDefaultUncaughtExceptionHandler         Thread.setDefaultUncaughtExceptionHandler(new ElasticsearchUncaughtExceptionHandler()).         INSTANCE.setup(true, environment).         try {             // any secure settings must be read during node construction             IOUtils.close(keystore).         } catch (IOException e) {             throw new BootstrapException(e).         }         INSTANCE.start().         if (closeStandardStreams) {             closeSysError().         }     } catch (NodeValidationException | RuntimeException e) {         // disable console logging, so user does not see the exception twice (jvm will show it already)         final Logger rootLogger = LogManager.getRootLogger().         final Appender maybeConsoleAppender = Loggers.findAppender(rootLogger, ConsoleAppender.class).         if (foreground && maybeConsoleAppender != null) {             Loggers.removeAppender(rootLogger, maybeConsoleAppender).         }         Logger logger = LogManager.getLogger(Bootstrap.class).         // HACK, it sucks to do this, but we will run users out of disk space otherwise         if (e instanceof CreationException) {             // guice: log the shortened exc to the log file             ByteArrayOutputStream os = new ByteArrayOutputStream().             PrintStream ps = null.             try {                 ps = new PrintStream(os, false, "UTF-8").             } catch (UnsupportedEncodingException uee) {                 assert false.                 e.addSuppressed(uee).             }             new StartupException(e).printStackTrace(ps).             ps.flush().             try {                 logger.error("Guice Exception: {}", os.toString("UTF-8")).             } catch (UnsupportedEncodingException uee) {                 assert false.                 e.addSuppressed(uee).             }         } else if (e instanceof NodeValidationException) {             logger.error("node validation exception\n{}", e.getMessage()).         } else {             // full exception             logger.error("Exception", e).         }         // re-enable it if appropriate, so they can see any logging during the shutdown process         if (foreground && maybeConsoleAppender != null) {             Loggers.addAppender(rootLogger, maybeConsoleAppender).         }         throw e.     } }
false;private,static;0;4;;@SuppressForbidden(reason = "System#out") private static void closeSystOut() {     System.out.close(). }
false;private,static;0;4;;@SuppressForbidden(reason = "System#err") private static void closeSysError() {     System.err.close(). }
false;private,static;0;6;;private static void checkLucene() {     if (Version.CURRENT.luceneVersion.equals(org.apache.lucene.util.Version.LATEST) == false) {         throw new AssertionError("Lucene version mismatch this version of Elasticsearch requires lucene version [" + Version.CURRENT.luceneVersion + "]  but the current lucene version is [" + org.apache.lucene.util.Version.LATEST + "]").     } }
