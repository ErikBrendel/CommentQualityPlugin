commented;modifiers;parameterAmount;loc;comment;code
false;public;0;11;;@Override public Directory newDirectory() throws IOException {     final Path location = path.resolveIndex().     final LockFactory lockFactory = indexSettings.getValue(INDEX_LOCK_FACTOR_SETTING).     Files.createDirectories(location).     Directory wrapped = newFSDirectory(location, lockFactory).     Set<String> preLoadExtensions = new HashSet<>(indexSettings.getValue(IndexModule.INDEX_STORE_PRE_LOAD_SETTING)).     wrapped = setPreload(wrapped, location, lockFactory, preLoadExtensions).     return wrapped. }
false;protected;2;28;;protected Directory newFSDirectory(Path location, LockFactory lockFactory) throws IOException {     final String storeType = indexSettings.getSettings().get(IndexModule.INDEX_STORE_TYPE_SETTING.getKey(), IndexModule.Type.FS.getSettingsKey()).     IndexModule.Type type.     if (IndexModule.Type.FS.match(storeType)) {         type = IndexModule.defaultStoreType(IndexModule.NODE_STORE_ALLOW_MMAP.get(indexSettings.getNodeSettings())).     } else {         type = IndexModule.Type.fromSettingsKey(storeType).     }     switch(type) {         case HYBRIDFS:             // Use Lucene defaults             final FSDirectory primaryDirectory = FSDirectory.open(location, lockFactory).             if (primaryDirectory instanceof MMapDirectory) {                 return new HybridDirectory(location, lockFactory, primaryDirectory).             } else {                 return primaryDirectory.             }         case MMAPFS:             return new MMapDirectory(location, lockFactory).         case SIMPLEFS:             return new SimpleFSDirectory(location, lockFactory).         case NIOFS:             return new NIOFSDirectory(location, lockFactory).         default:             throw new AssertionError("unexpected built-in store type [" + type + "]").     } }
false;public;0;5;;@Override public String[] listAll() throws IOException {     // avoid listing twice     return primary.listAll(). }
false;private,static;4;21;;private static Directory setPreload(Directory directory, Path location, LockFactory lockFactory, Set<String> preLoadExtensions) throws IOException {     if (preLoadExtensions.isEmpty() == false && directory instanceof MMapDirectory && ((MMapDirectory) directory).getPreload() == false) {         if (preLoadExtensions.contains("*")) {             ((MMapDirectory) directory).setPreload(true).             return directory.         }         MMapDirectory primary = new MMapDirectory(location, lockFactory).         primary.setPreload(true).         return new FileSwitchDirectory(preLoadExtensions, primary, directory, true) {              @Override             public String[] listAll() throws IOException {                 // avoid listing twice                 return primary.listAll().             }         }.     }     return directory. }
false;public;2;22;;@Override public IndexInput openInput(String name, IOContext context) throws IOException {     String extension = FileSwitchDirectory.getExtension(name).     switch(extension) {         // this provides good random access performance and does not lead to page cache thrashing.         case "nvd":         case "dvd":         case "tim":         case "cfs":             // we need to do these checks on the outer directory since the inner doesn't know about pending deletes             ensureOpen().             ensureCanRead(name).             // and intersect for perf reasons.             return randomAccessDirectory.openInput(name, context).         default:             return super.openInput(name, context).     } }
false;public;0;4;;@Override public void close() throws IOException {     IOUtils.close(super::close, randomAccessDirectory). }
false;;0;3;;Directory getRandomAccessDirectory() {     return randomAccessDirectory. }
