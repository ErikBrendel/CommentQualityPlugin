commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;3;/**  * Returns a new map with the given number of expected elements.  *  * @param expectedElements  *          The expected number of elements guaranteed not to cause buffer  *          expansion (inclusive).  */ ;/**  * Returns a new map with the given number of expected elements.  *  * @param expectedElements  *          The expected number of elements guaranteed not to cause buffer  *          expansion (inclusive).  */ public static <K, V> ObjectObjectHashMap<K, V> newMap(int expectedElements) {     return new ObjectObjectHashMap<>(expectedElements). }
true;public,static;0;3;/**  * Returns a new map with a default initial capacity.  */ ;/**  * Returns a new map with a default initial capacity.  */ public static <K, V> ObjectObjectHashMap<K, V> newMap() {     return newMap(16). }
true;public,static;0;3;/**  * Returns a map like {@link #newMap()} that does not accept <code>null</code> keys  */ ;/**  * Returns a map like {@link #newMap()} that does not accept <code>null</code> keys  */ public static <K, V> ObjectObjectHashMap<K, V> newNoNullKeysMap() {     return ensureNoNullKeys(16). }
true;public,static;1;3;/**  * Returns a map like {@link #newMap(int)} that does not accept <code>null</code> keys  *  * @param expectedElements  *          The expected number of elements guaranteed not to cause buffer  *          expansion (inclusive).  */ ;/**  * Returns a map like {@link #newMap(int)} that does not accept <code>null</code> keys  *  * @param expectedElements  *          The expected number of elements guaranteed not to cause buffer  *          expansion (inclusive).  */ public static <K, V> ObjectObjectHashMap<K, V> newNoNullKeysMap(int expectedElements) {     return ensureNoNullKeys(expectedElements). }
false;public;2;7;;@Override public V put(K key, V value) {     if (key == null) {         throw new IllegalArgumentException("Map key must not be null").     }     return super.put(key, value). }
true;public,static;1;11;/**  * Wraps the given map and prevent adding of <code>null</code> keys.  *  * @param expectedElements  *          The expected number of elements guaranteed not to cause buffer  *          expansion (inclusive).  */ ;/**  * Wraps the given map and prevent adding of <code>null</code> keys.  *  * @param expectedElements  *          The expected number of elements guaranteed not to cause buffer  *          expansion (inclusive).  */ public static <K, V> ObjectObjectHashMap<K, V> ensureNoNullKeys(int expectedElements) {     return new ObjectObjectHashMap<K, V>(expectedElements) {          @Override         public V put(K key, V value) {             if (key == null) {                 throw new IllegalArgumentException("Map key must not be null").             }             return super.put(key, value).         }     }. }
false;public;0;13;;@Override public boolean hasNext() {     if (iterator.hasNext()) {         do {             T next = iterator.next().value.             if (container2.contains(next)) {                 current = next.                 return true.             }         } while (iterator.hasNext()).     }     return false. }
false;public;0;4;;@Override public T next() {     return current. }
false;public;0;4;;@Override public void remove() {     throw new UnsupportedOperationException(). }
false;public;0;4;;@Override public Iterator<T> iterator() {     return intersection. }
true;public,static;2;38;// over each unique value without creating a third set. ;/**  * @return an intersection view over the two specified containers (which can be KeyContainer or ObjectHashSet).  */ // Hppc has forEach, but this means we need to build an intermediate set, with this method we just iterate // over each unique value without creating a third set. public static <T> Iterable<T> intersection(ObjectLookupContainer<T> container1, final ObjectLookupContainer<T> container2) {     assert container1 != null && container2 != null.     final Iterator<ObjectCursor<T>> iterator = container1.iterator().     final Iterator<T> intersection = new Iterator<T>() {          T current.          @Override         public boolean hasNext() {             if (iterator.hasNext()) {                 do {                     T next = iterator.next().value.                     if (container2.contains(next)) {                         current = next.                         return true.                     }                 } while (iterator.hasNext()).             }             return false.         }          @Override         public T next() {             return current.         }          @Override         public void remove() {             throw new UnsupportedOperationException().         }     }.     return new Iterable<T>() {          @Override         public Iterator<T> iterator() {             return intersection.         }     }. }
false;public;2;7;;@Override public int put(V key, int value) {     if (key == null) {         throw new IllegalArgumentException("Map key must not be null").     }     return super.put(key, value). }
false;public,static;2;11;;public static <V> ObjectIntHashMap<V> ensureNoNullKeys(int capacity, float loadFactor) {     return new ObjectIntHashMap<V>(capacity, loadFactor) {          @Override         public int put(V key, int value) {             if (key == null) {                 throw new IllegalArgumentException("Map key must not be null").             }             return super.put(key, value).         }     }. }
