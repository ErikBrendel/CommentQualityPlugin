commented;modifiers;parameterAmount;loc;comment;code
false;public;1;5;;@Override public CodecReader wrapForMerge(CodecReader reader) throws IOException {     CodecReader wrapped = toWrap.wrapForMerge(reader).     return wrapReader(recoverySourceField, wrapped, retainSourceQuerySupplier). }
true;static;3;22;// pkg private for testing ;// pkg private for testing static CodecReader wrapReader(String recoverySourceField, CodecReader reader, Supplier<Query> retainSourceQuerySupplier) throws IOException {     NumericDocValues recoverySource = reader.getNumericDocValues(recoverySourceField).     if (recoverySource == null || recoverySource.nextDoc() == DocIdSetIterator.NO_MORE_DOCS) {         // early terminate - nothing to do here since non of the docs has a recovery source anymore.         return reader.     }     IndexSearcher s = new IndexSearcher(reader).     s.setQueryCache(null).     Weight weight = s.createWeight(s.rewrite(retainSourceQuerySupplier.get()), ScoreMode.COMPLETE_NO_SCORES, 1.0f).     Scorer scorer = weight.scorer(reader.getContext()).     if (scorer != null) {         BitSet recoverySourceToKeep = BitSet.of(scorer.iterator(), reader.maxDoc()).         // if retentions are high we keep most of it         if (recoverySourceToKeep.cardinality() == reader.maxDoc()) {             // keep all source             return reader.         }         return new SourcePruningFilterCodecReader(recoverySourceField, reader, recoverySourceToKeep).     } else {         return new SourcePruningFilterCodecReader(recoverySourceField, reader, null).     } }
false;public;0;4;;@Override public int nextDoc() throws IOException {     return intersection.nextDoc(). }
false;public;1;4;;@Override public int advance(int target) {     throw new UnsupportedOperationException(). }
false;public;1;4;;@Override public boolean advanceExact(int target) {     throw new UnsupportedOperationException(). }
false;public;1;33;;@Override public NumericDocValues getNumeric(FieldInfo field) throws IOException {     NumericDocValues numeric = super.getNumeric(field).     if (recoverySourceField.equals(field.name)) {         assert numeric != null : recoverySourceField + " must have numeric DV but was null".         final DocIdSetIterator intersection.         if (recoverySourceToKeep == null) {             // we can't return null here lucenes DocIdMerger expects an instance             intersection = DocIdSetIterator.empty().         } else {             intersection = ConjunctionDISI.intersectIterators(Arrays.asList(numeric, new BitSetIterator(recoverySourceToKeep, recoverySourceToKeep.length()))).         }         return new FilterNumericDocValues(numeric) {              @Override             public int nextDoc() throws IOException {                 return intersection.nextDoc().             }              @Override             public int advance(int target) {                 throw new UnsupportedOperationException().             }              @Override             public boolean advanceExact(int target) {                 throw new UnsupportedOperationException().             }         }.     }     return numeric. }
false;public;0;39;;@Override public DocValuesProducer getDocValuesReader() {     DocValuesProducer docValuesReader = super.getDocValuesReader().     return new FilterDocValuesProducer(docValuesReader) {          @Override         public NumericDocValues getNumeric(FieldInfo field) throws IOException {             NumericDocValues numeric = super.getNumeric(field).             if (recoverySourceField.equals(field.name)) {                 assert numeric != null : recoverySourceField + " must have numeric DV but was null".                 final DocIdSetIterator intersection.                 if (recoverySourceToKeep == null) {                     // we can't return null here lucenes DocIdMerger expects an instance                     intersection = DocIdSetIterator.empty().                 } else {                     intersection = ConjunctionDISI.intersectIterators(Arrays.asList(numeric, new BitSetIterator(recoverySourceToKeep, recoverySourceToKeep.length()))).                 }                 return new FilterNumericDocValues(numeric) {                      @Override                     public int nextDoc() throws IOException {                         return intersection.nextDoc().                     }                      @Override                     public int advance(int target) {                         throw new UnsupportedOperationException().                     }                      @Override                     public boolean advanceExact(int target) {                         throw new UnsupportedOperationException().                     }                 }.             }             return numeric.         }     }. }
false;public;1;7;;@Override public Status needsField(FieldInfo fieldInfo) throws IOException {     if (recoverySourceField.equals(fieldInfo.name)) {         return Status.NO.     }     return super.needsField(fieldInfo). }
false;public;2;16;;@Override public void visitDocument(int docID, StoredFieldVisitor visitor) throws IOException {     if (recoverySourceToKeep != null && recoverySourceToKeep.get(docID)) {         super.visitDocument(docID, visitor).     } else {         super.visitDocument(docID, new FilterStoredFieldVisitor(visitor) {              @Override             public Status needsField(FieldInfo fieldInfo) throws IOException {                 if (recoverySourceField.equals(fieldInfo.name)) {                     return Status.NO.                 }                 return super.needsField(fieldInfo).             }         }).     } }
false;public;0;22;;@Override public StoredFieldsReader getFieldsReader() {     StoredFieldsReader fieldsReader = super.getFieldsReader().     return new FilterStoredFieldsReader(fieldsReader) {          @Override         public void visitDocument(int docID, StoredFieldVisitor visitor) throws IOException {             if (recoverySourceToKeep != null && recoverySourceToKeep.get(docID)) {                 super.visitDocument(docID, visitor).             } else {                 super.visitDocument(docID, new FilterStoredFieldVisitor(visitor) {                      @Override                     public Status needsField(FieldInfo fieldInfo) throws IOException {                         if (recoverySourceField.equals(fieldInfo.name)) {                             return Status.NO.                         }                         return super.needsField(fieldInfo).                     }                 }).             }         }     }. }
false;public;0;4;;@Override public CacheHelper getCoreCacheHelper() {     return null. }
false;public;0;4;;@Override public CacheHelper getReaderCacheHelper() {     return null. }
false;public;1;4;;@Override public NumericDocValues getNumeric(FieldInfo field) throws IOException {     return in.getNumeric(field). }
false;public;1;4;;@Override public BinaryDocValues getBinary(FieldInfo field) throws IOException {     return in.getBinary(field). }
false;public;1;4;;@Override public SortedDocValues getSorted(FieldInfo field) throws IOException {     return in.getSorted(field). }
false;public;1;4;;@Override public SortedNumericDocValues getSortedNumeric(FieldInfo field) throws IOException {     return in.getSortedNumeric(field). }
false;public;1;4;;@Override public SortedSetDocValues getSortedSet(FieldInfo field) throws IOException {     return in.getSortedSet(field). }
false;public;0;4;;@Override public void checkIntegrity() throws IOException {     in.checkIntegrity(). }
false;public;0;4;;@Override public void close() throws IOException {     in.close(). }
false;public;0;4;;@Override public long ramBytesUsed() {     return in.ramBytesUsed(). }
false;public;0;4;;@Override public long ramBytesUsed() {     return fieldsReader.ramBytesUsed(). }
false;public;0;4;;@Override public void close() throws IOException {     fieldsReader.close(). }
false;public;2;4;;@Override public void visitDocument(int docID, StoredFieldVisitor visitor) throws IOException {     fieldsReader.visitDocument(docID, visitor). }
false;public;0;4;;@Override public StoredFieldsReader clone() {     return fieldsReader.clone(). }
false;public;0;4;;@Override public void checkIntegrity() throws IOException {     fieldsReader.checkIntegrity(). }
false;public;2;4;;@Override public void binaryField(FieldInfo fieldInfo, byte[] value) throws IOException {     visitor.binaryField(fieldInfo, value). }
false;public;2;4;;@Override public void stringField(FieldInfo fieldInfo, byte[] value) throws IOException {     visitor.stringField(fieldInfo, value). }
false;public;2;4;;@Override public void intField(FieldInfo fieldInfo, int value) throws IOException {     visitor.intField(fieldInfo, value). }
false;public;2;4;;@Override public void longField(FieldInfo fieldInfo, long value) throws IOException {     visitor.longField(fieldInfo, value). }
false;public;2;4;;@Override public void floatField(FieldInfo fieldInfo, float value) throws IOException {     visitor.floatField(fieldInfo, value). }
false;public;2;4;;@Override public void doubleField(FieldInfo fieldInfo, double value) throws IOException {     visitor.doubleField(fieldInfo, value). }
false;public;1;4;;@Override public Status needsField(FieldInfo fieldInfo) throws IOException {     return visitor.needsField(fieldInfo). }
