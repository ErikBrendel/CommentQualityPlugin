# id;timestamp;commentText;codeText;commentWords;codeWords
RootObjectMapper -> Builder -> private static void fixRedundantIncludes(ObjectMapper.Builder omb, boolean parentIncluded);1524684173;Removes redundant root includes in {@link ObjectMapper.Nested} trees to avoid duplicate_fields on the root mapper when {@code isIncludeInRoot} is {@code true} for a node that is_itself included into a parent node, for which either {@code isIncludeInRoot} is_{@code true} or which is transitively included in root by a chain of nodes with_{@code isIncludeInParent} returning {@code true}._@param omb Builder whose children to check._@param parentIncluded True iff node is a child of root or a node that is included in_root;private static void fixRedundantIncludes(ObjectMapper.Builder omb, boolean parentIncluded) {_            for (Object mapper : omb.mappersBuilders) {_                if (mapper instanceof ObjectMapper.Builder) {_                    ObjectMapper.Builder child = (ObjectMapper.Builder) mapper__                    Nested nested = child.nested__                    boolean isNested = nested.isNested()__                    boolean includeInRootViaParent = parentIncluded && isNested && nested.isIncludeInParent()__                    boolean includedInRoot = isNested && nested.isIncludeInRoot()__                    if (includeInRootViaParent && includedInRoot) {_                        child.nested = Nested.newNested(true, false)__                    }_                    fixRedundantIncludes(child, includeInRootViaParent || includedInRoot)__                }_            }_        };removes,redundant,root,includes,in,link,object,mapper,nested,trees,to,avoid,duplicate,fields,on,the,root,mapper,when,code,is,include,in,root,is,code,true,for,a,node,that,is,itself,included,into,a,parent,node,for,which,either,code,is,include,in,root,is,code,true,or,which,is,transitively,included,in,root,by,a,chain,of,nodes,with,code,is,include,in,parent,returning,code,true,param,omb,builder,whose,children,to,check,param,parent,included,true,iff,node,is,a,child,of,root,or,a,node,that,is,included,in,root;private,static,void,fix,redundant,includes,object,mapper,builder,omb,boolean,parent,included,for,object,mapper,omb,mappers,builders,if,mapper,instanceof,object,mapper,builder,object,mapper,builder,child,object,mapper,builder,mapper,nested,nested,child,nested,boolean,is,nested,nested,is,nested,boolean,include,in,root,via,parent,parent,included,is,nested,nested,is,include,in,parent,boolean,included,in,root,is,nested,nested,is,include,in,root,if,include,in,root,via,parent,included,in,root,child,nested,nested,new,nested,true,false,fix,redundant,includes,child,include,in,root,via,parent,included,in,root
RootObjectMapper -> Builder -> private static void fixRedundantIncludes(ObjectMapper.Builder omb, boolean parentIncluded);1541008027;Removes redundant root includes in {@link ObjectMapper.Nested} trees to avoid duplicate_fields on the root mapper when {@code isIncludeInRoot} is {@code true} for a node that is_itself included into a parent node, for which either {@code isIncludeInRoot} is_{@code true} or which is transitively included in root by a chain of nodes with_{@code isIncludeInParent} returning {@code true}._@param omb Builder whose children to check._@param parentIncluded True iff node is a child of root or a node that is included in_root;private static void fixRedundantIncludes(ObjectMapper.Builder omb, boolean parentIncluded) {_            for (Object mapper : omb.mappersBuilders) {_                if (mapper instanceof ObjectMapper.Builder) {_                    ObjectMapper.Builder child = (ObjectMapper.Builder) mapper__                    Nested nested = child.nested__                    boolean isNested = nested.isNested()__                    boolean includeInRootViaParent = parentIncluded && isNested && nested.isIncludeInParent()__                    boolean includedInRoot = isNested && nested.isIncludeInRoot()__                    if (includeInRootViaParent && includedInRoot) {_                        child.nested = Nested.newNested(true, false)__                    }_                    fixRedundantIncludes(child, includeInRootViaParent || includedInRoot)__                }_            }_        };removes,redundant,root,includes,in,link,object,mapper,nested,trees,to,avoid,duplicate,fields,on,the,root,mapper,when,code,is,include,in,root,is,code,true,for,a,node,that,is,itself,included,into,a,parent,node,for,which,either,code,is,include,in,root,is,code,true,or,which,is,transitively,included,in,root,by,a,chain,of,nodes,with,code,is,include,in,parent,returning,code,true,param,omb,builder,whose,children,to,check,param,parent,included,true,iff,node,is,a,child,of,root,or,a,node,that,is,included,in,root;private,static,void,fix,redundant,includes,object,mapper,builder,omb,boolean,parent,included,for,object,mapper,omb,mappers,builders,if,mapper,instanceof,object,mapper,builder,object,mapper,builder,child,object,mapper,builder,mapper,nested,nested,child,nested,boolean,is,nested,nested,is,nested,boolean,include,in,root,via,parent,parent,included,is,nested,nested,is,include,in,parent,boolean,included,in,root,is,nested,nested,is,include,in,root,if,include,in,root,via,parent,included,in,root,child,nested,nested,new,nested,true,false,fix,redundant,includes,child,include,in,root,via,parent,included,in,root
RootObjectMapper -> Builder -> private static void fixRedundantIncludes(ObjectMapper.Builder omb, boolean parentIncluded);1544232221;Removes redundant root includes in {@link ObjectMapper.Nested} trees to avoid duplicate_fields on the root mapper when {@code isIncludeInRoot} is {@code true} for a node that is_itself included into a parent node, for which either {@code isIncludeInRoot} is_{@code true} or which is transitively included in root by a chain of nodes with_{@code isIncludeInParent} returning {@code true}._@param omb Builder whose children to check._@param parentIncluded True iff node is a child of root or a node that is included in_root;private static void fixRedundantIncludes(ObjectMapper.Builder omb, boolean parentIncluded) {_            for (Object mapper : omb.mappersBuilders) {_                if (mapper instanceof ObjectMapper.Builder) {_                    ObjectMapper.Builder child = (ObjectMapper.Builder) mapper__                    Nested nested = child.nested__                    boolean isNested = nested.isNested()__                    boolean includeInRootViaParent = parentIncluded && isNested && nested.isIncludeInParent()__                    boolean includedInRoot = isNested && nested.isIncludeInRoot()__                    if (includeInRootViaParent && includedInRoot) {_                        child.nested = Nested.newNested(true, false)__                    }_                    fixRedundantIncludes(child, includeInRootViaParent || includedInRoot)__                }_            }_        };removes,redundant,root,includes,in,link,object,mapper,nested,trees,to,avoid,duplicate,fields,on,the,root,mapper,when,code,is,include,in,root,is,code,true,for,a,node,that,is,itself,included,into,a,parent,node,for,which,either,code,is,include,in,root,is,code,true,or,which,is,transitively,included,in,root,by,a,chain,of,nodes,with,code,is,include,in,parent,returning,code,true,param,omb,builder,whose,children,to,check,param,parent,included,true,iff,node,is,a,child,of,root,or,a,node,that,is,included,in,root;private,static,void,fix,redundant,includes,object,mapper,builder,omb,boolean,parent,included,for,object,mapper,omb,mappers,builders,if,mapper,instanceof,object,mapper,builder,object,mapper,builder,child,object,mapper,builder,mapper,nested,nested,child,nested,boolean,is,nested,nested,is,nested,boolean,include,in,root,via,parent,parent,included,is,nested,nested,is,include,in,parent,boolean,included,in,root,is,nested,nested,is,include,in,root,if,include,in,root,via,parent,included,in,root,child,nested,nested,new,nested,true,false,fix,redundant,includes,child,include,in,root,via,parent,included,in,root
RootObjectMapper -> Builder -> private static void fixRedundantIncludes(ObjectMapper.Builder omb, boolean parentIncluded);1544458001;Removes redundant root includes in {@link ObjectMapper.Nested} trees to avoid duplicate_fields on the root mapper when {@code isIncludeInRoot} is {@code true} for a node that is_itself included into a parent node, for which either {@code isIncludeInRoot} is_{@code true} or which is transitively included in root by a chain of nodes with_{@code isIncludeInParent} returning {@code true}._@param omb Builder whose children to check._@param parentIncluded True iff node is a child of root or a node that is included in_root;private static void fixRedundantIncludes(ObjectMapper.Builder omb, boolean parentIncluded) {_            for (Object mapper : omb.mappersBuilders) {_                if (mapper instanceof ObjectMapper.Builder) {_                    ObjectMapper.Builder child = (ObjectMapper.Builder) mapper__                    Nested nested = child.nested__                    boolean isNested = nested.isNested()__                    boolean includeInRootViaParent = parentIncluded && isNested && nested.isIncludeInParent()__                    boolean includedInRoot = isNested && nested.isIncludeInRoot()__                    if (includeInRootViaParent && includedInRoot) {_                        child.nested = Nested.newNested(true, false)__                    }_                    fixRedundantIncludes(child, includeInRootViaParent || includedInRoot)__                }_            }_        };removes,redundant,root,includes,in,link,object,mapper,nested,trees,to,avoid,duplicate,fields,on,the,root,mapper,when,code,is,include,in,root,is,code,true,for,a,node,that,is,itself,included,into,a,parent,node,for,which,either,code,is,include,in,root,is,code,true,or,which,is,transitively,included,in,root,by,a,chain,of,nodes,with,code,is,include,in,parent,returning,code,true,param,omb,builder,whose,children,to,check,param,parent,included,true,iff,node,is,a,child,of,root,or,a,node,that,is,included,in,root;private,static,void,fix,redundant,includes,object,mapper,builder,omb,boolean,parent,included,for,object,mapper,omb,mappers,builders,if,mapper,instanceof,object,mapper,builder,object,mapper,builder,child,object,mapper,builder,mapper,nested,nested,child,nested,boolean,is,nested,nested,is,nested,boolean,include,in,root,via,parent,parent,included,is,nested,nested,is,include,in,parent,boolean,included,in,root,is,nested,nested,is,include,in,root,if,include,in,root,via,parent,included,in,root,child,nested,nested,new,nested,true,false,fix,redundant,includes,child,include,in,root,via,parent,included,in,root
RootObjectMapper -> Builder -> private static void fixRedundantIncludes(ObjectMapper.Builder omb, boolean parentIncluded);1548236405;Removes redundant root includes in {@link ObjectMapper.Nested} trees to avoid duplicate_fields on the root mapper when {@code isIncludeInRoot} is {@code true} for a node that is_itself included into a parent node, for which either {@code isIncludeInRoot} is_{@code true} or which is transitively included in root by a chain of nodes with_{@code isIncludeInParent} returning {@code true}._@param omb Builder whose children to check._@param parentIncluded True iff node is a child of root or a node that is included in_root;private static void fixRedundantIncludes(ObjectMapper.Builder omb, boolean parentIncluded) {_            for (Object mapper : omb.mappersBuilders) {_                if (mapper instanceof ObjectMapper.Builder) {_                    ObjectMapper.Builder child = (ObjectMapper.Builder) mapper__                    Nested nested = child.nested__                    boolean isNested = nested.isNested()__                    boolean includeInRootViaParent = parentIncluded && isNested && nested.isIncludeInParent()__                    boolean includedInRoot = isNested && nested.isIncludeInRoot()__                    if (includeInRootViaParent && includedInRoot) {_                        child.nested = Nested.newNested(true, false)__                    }_                    fixRedundantIncludes(child, includeInRootViaParent || includedInRoot)__                }_            }_        };removes,redundant,root,includes,in,link,object,mapper,nested,trees,to,avoid,duplicate,fields,on,the,root,mapper,when,code,is,include,in,root,is,code,true,for,a,node,that,is,itself,included,into,a,parent,node,for,which,either,code,is,include,in,root,is,code,true,or,which,is,transitively,included,in,root,by,a,chain,of,nodes,with,code,is,include,in,parent,returning,code,true,param,omb,builder,whose,children,to,check,param,parent,included,true,iff,node,is,a,child,of,root,or,a,node,that,is,included,in,root;private,static,void,fix,redundant,includes,object,mapper,builder,omb,boolean,parent,included,for,object,mapper,omb,mappers,builders,if,mapper,instanceof,object,mapper,builder,object,mapper,builder,child,object,mapper,builder,mapper,nested,nested,child,nested,boolean,is,nested,nested,is,nested,boolean,include,in,root,via,parent,parent,included,is,nested,nested,is,include,in,parent,boolean,included,in,root,is,nested,nested,is,include,in,root,if,include,in,root,via,parent,included,in,root,child,nested,nested,new,nested,true,false,fix,redundant,includes,child,include,in,root,via,parent,included,in,root
RootObjectMapper -> public Mapper.Builder findTemplateBuilder(ParseContext context, String name, String dynamicType, XContentFieldType matchType);1524684173;Find a template. Returns {@code null} if no template could be found._@param name        the field name_@param dynamicType the field type to give the field if the template does not define one_@param matchType   the type of the field in the json document or null if unknown_@return a mapper builder, or null if there is no template for such a field;public Mapper.Builder findTemplateBuilder(ParseContext context, String name, String dynamicType, XContentFieldType matchType) {_        DynamicTemplate dynamicTemplate = findTemplate(context.path(), name, matchType)__        if (dynamicTemplate == null) {_            return null__        }_        Mapper.TypeParser.ParserContext parserContext = context.docMapperParser().parserContext(name)__        String mappingType = dynamicTemplate.mappingType(dynamicType)__        Mapper.TypeParser typeParser = parserContext.typeParser(mappingType)__        if (typeParser == null) {_            throw new MapperParsingException("failed to find type parsed [" + mappingType + "] for [" + name + "]")__        }_        return typeParser.parse(name, dynamicTemplate.mappingForName(name, dynamicType), parserContext)__    };find,a,template,returns,code,null,if,no,template,could,be,found,param,name,the,field,name,param,dynamic,type,the,field,type,to,give,the,field,if,the,template,does,not,define,one,param,match,type,the,type,of,the,field,in,the,json,document,or,null,if,unknown,return,a,mapper,builder,or,null,if,there,is,no,template,for,such,a,field;public,mapper,builder,find,template,builder,parse,context,context,string,name,string,dynamic,type,xcontent,field,type,match,type,dynamic,template,dynamic,template,find,template,context,path,name,match,type,if,dynamic,template,null,return,null,mapper,type,parser,parser,context,parser,context,context,doc,mapper,parser,parser,context,name,string,mapping,type,dynamic,template,mapping,type,dynamic,type,mapper,type,parser,type,parser,parser,context,type,parser,mapping,type,if,type,parser,null,throw,new,mapper,parsing,exception,failed,to,find,type,parsed,mapping,type,for,name,return,type,parser,parse,name,dynamic,template,mapping,for,name,name,dynamic,type,parser,context
RootObjectMapper -> public Mapper.Builder findTemplateBuilder(ParseContext context, String name, String dynamicType, XContentFieldType matchType);1541008027;Find a template. Returns {@code null} if no template could be found._@param name        the field name_@param dynamicType the field type to give the field if the template does not define one_@param matchType   the type of the field in the json document or null if unknown_@return a mapper builder, or null if there is no template for such a field;public Mapper.Builder findTemplateBuilder(ParseContext context, String name, String dynamicType, XContentFieldType matchType) {_        DynamicTemplate dynamicTemplate = findTemplate(context.path(), name, matchType)__        if (dynamicTemplate == null) {_            return null__        }_        Mapper.TypeParser.ParserContext parserContext = context.docMapperParser().parserContext(name)__        String mappingType = dynamicTemplate.mappingType(dynamicType)__        Mapper.TypeParser typeParser = parserContext.typeParser(mappingType)__        if (typeParser == null) {_            throw new MapperParsingException("failed to find type parsed [" + mappingType + "] for [" + name + "]")__        }_        return typeParser.parse(name, dynamicTemplate.mappingForName(name, dynamicType), parserContext)__    };find,a,template,returns,code,null,if,no,template,could,be,found,param,name,the,field,name,param,dynamic,type,the,field,type,to,give,the,field,if,the,template,does,not,define,one,param,match,type,the,type,of,the,field,in,the,json,document,or,null,if,unknown,return,a,mapper,builder,or,null,if,there,is,no,template,for,such,a,field;public,mapper,builder,find,template,builder,parse,context,context,string,name,string,dynamic,type,xcontent,field,type,match,type,dynamic,template,dynamic,template,find,template,context,path,name,match,type,if,dynamic,template,null,return,null,mapper,type,parser,parser,context,parser,context,context,doc,mapper,parser,parser,context,name,string,mapping,type,dynamic,template,mapping,type,dynamic,type,mapper,type,parser,type,parser,parser,context,type,parser,mapping,type,if,type,parser,null,throw,new,mapper,parsing,exception,failed,to,find,type,parsed,mapping,type,for,name,return,type,parser,parse,name,dynamic,template,mapping,for,name,name,dynamic,type,parser,context
RootObjectMapper -> public Mapper.Builder findTemplateBuilder(ParseContext context, String name, String dynamicType, XContentFieldType matchType);1544232221;Find a template. Returns {@code null} if no template could be found._@param name        the field name_@param dynamicType the field type to give the field if the template does not define one_@param matchType   the type of the field in the json document or null if unknown_@return a mapper builder, or null if there is no template for such a field;public Mapper.Builder findTemplateBuilder(ParseContext context, String name, String dynamicType, XContentFieldType matchType) {_        DynamicTemplate dynamicTemplate = findTemplate(context.path(), name, matchType)__        if (dynamicTemplate == null) {_            return null__        }_        Mapper.TypeParser.ParserContext parserContext = context.docMapperParser().parserContext(name)__        String mappingType = dynamicTemplate.mappingType(dynamicType)__        Mapper.TypeParser typeParser = parserContext.typeParser(mappingType)__        if (typeParser == null) {_            throw new MapperParsingException("failed to find type parsed [" + mappingType + "] for [" + name + "]")__        }_        return typeParser.parse(name, dynamicTemplate.mappingForName(name, dynamicType), parserContext)__    };find,a,template,returns,code,null,if,no,template,could,be,found,param,name,the,field,name,param,dynamic,type,the,field,type,to,give,the,field,if,the,template,does,not,define,one,param,match,type,the,type,of,the,field,in,the,json,document,or,null,if,unknown,return,a,mapper,builder,or,null,if,there,is,no,template,for,such,a,field;public,mapper,builder,find,template,builder,parse,context,context,string,name,string,dynamic,type,xcontent,field,type,match,type,dynamic,template,dynamic,template,find,template,context,path,name,match,type,if,dynamic,template,null,return,null,mapper,type,parser,parser,context,parser,context,context,doc,mapper,parser,parser,context,name,string,mapping,type,dynamic,template,mapping,type,dynamic,type,mapper,type,parser,type,parser,parser,context,type,parser,mapping,type,if,type,parser,null,throw,new,mapper,parsing,exception,failed,to,find,type,parsed,mapping,type,for,name,return,type,parser,parse,name,dynamic,template,mapping,for,name,name,dynamic,type,parser,context
RootObjectMapper -> public Mapper.Builder findTemplateBuilder(ParseContext context, String name, String dynamicType, XContentFieldType matchType);1544458001;Find a template. Returns {@code null} if no template could be found._@param name        the field name_@param dynamicType the field type to give the field if the template does not define one_@param matchType   the type of the field in the json document or null if unknown_@return a mapper builder, or null if there is no template for such a field;public Mapper.Builder findTemplateBuilder(ParseContext context, String name, String dynamicType, XContentFieldType matchType) {_        DynamicTemplate dynamicTemplate = findTemplate(context.path(), name, matchType)__        if (dynamicTemplate == null) {_            return null__        }_        Mapper.TypeParser.ParserContext parserContext = context.docMapperParser().parserContext(name)__        String mappingType = dynamicTemplate.mappingType(dynamicType)__        Mapper.TypeParser typeParser = parserContext.typeParser(mappingType)__        if (typeParser == null) {_            throw new MapperParsingException("failed to find type parsed [" + mappingType + "] for [" + name + "]")__        }_        return typeParser.parse(name, dynamicTemplate.mappingForName(name, dynamicType), parserContext)__    };find,a,template,returns,code,null,if,no,template,could,be,found,param,name,the,field,name,param,dynamic,type,the,field,type,to,give,the,field,if,the,template,does,not,define,one,param,match,type,the,type,of,the,field,in,the,json,document,or,null,if,unknown,return,a,mapper,builder,or,null,if,there,is,no,template,for,such,a,field;public,mapper,builder,find,template,builder,parse,context,context,string,name,string,dynamic,type,xcontent,field,type,match,type,dynamic,template,dynamic,template,find,template,context,path,name,match,type,if,dynamic,template,null,return,null,mapper,type,parser,parser,context,parser,context,context,doc,mapper,parser,parser,context,name,string,mapping,type,dynamic,template,mapping,type,dynamic,type,mapper,type,parser,type,parser,parser,context,type,parser,mapping,type,if,type,parser,null,throw,new,mapper,parsing,exception,failed,to,find,type,parsed,mapping,type,for,name,return,type,parser,parse,name,dynamic,template,mapping,for,name,name,dynamic,type,parser,context
RootObjectMapper -> public Mapper.Builder findTemplateBuilder(ParseContext context, String name, String dynamicType, XContentFieldType matchType);1548236405;Find a template. Returns {@code null} if no template could be found._@param name        the field name_@param dynamicType the field type to give the field if the template does not define one_@param matchType   the type of the field in the json document or null if unknown_@return a mapper builder, or null if there is no template for such a field;public Mapper.Builder findTemplateBuilder(ParseContext context, String name, String dynamicType, XContentFieldType matchType) {_        DynamicTemplate dynamicTemplate = findTemplate(context.path(), name, matchType)__        if (dynamicTemplate == null) {_            return null__        }_        Mapper.TypeParser.ParserContext parserContext = context.docMapperParser().parserContext(name)__        String mappingType = dynamicTemplate.mappingType(dynamicType)__        Mapper.TypeParser typeParser = parserContext.typeParser(mappingType)__        if (typeParser == null) {_            throw new MapperParsingException("failed to find type parsed [" + mappingType + "] for [" + name + "]")__        }_        return typeParser.parse(name, dynamicTemplate.mappingForName(name, dynamicType), parserContext)__    };find,a,template,returns,code,null,if,no,template,could,be,found,param,name,the,field,name,param,dynamic,type,the,field,type,to,give,the,field,if,the,template,does,not,define,one,param,match,type,the,type,of,the,field,in,the,json,document,or,null,if,unknown,return,a,mapper,builder,or,null,if,there,is,no,template,for,such,a,field;public,mapper,builder,find,template,builder,parse,context,context,string,name,string,dynamic,type,xcontent,field,type,match,type,dynamic,template,dynamic,template,find,template,context,path,name,match,type,if,dynamic,template,null,return,null,mapper,type,parser,parser,context,parser,context,context,doc,mapper,parser,parser,context,name,string,mapping,type,dynamic,template,mapping,type,dynamic,type,mapper,type,parser,type,parser,parser,context,type,parser,mapping,type,if,type,parser,null,throw,new,mapper,parsing,exception,failed,to,find,type,parsed,mapping,type,for,name,return,type,parser,parse,name,dynamic,template,mapping,for,name,name,dynamic,type,parser,context
