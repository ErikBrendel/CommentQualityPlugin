commented;modifiers;parameterAmount;loc;comment;code
false;private;0;11;;private void checkDeclaredExceptionsMatch() {     for (Map.Entry<Method, AssistedConstructor<?>> entry : factoryMethodToConstructor.entrySet()) {         for (Class<?> constructorException : entry.getValue().getDeclaredExceptions()) {             if (!isConstructorExceptionCompatibleWithFactoryExeception(constructorException, entry.getKey().getExceptionTypes())) {                 throw newConfigurationException("Constructor %s declares an exception, but no compatible " + "exception is thrown by the factory method %s", entry.getValue(), entry.getKey()).             }         }     } }
false;private;2;9;;private boolean isConstructorExceptionCompatibleWithFactoryExeception(Class<?> constructorException, Class<?>[] factoryExceptions) {     for (Class<?> factoryException : factoryExceptions) {         if (factoryException.isAssignableFrom(constructorException)) {             return true.         }     }     return false. }
false;public;0;12;;@Override public Set<Dependency<?>> getDependencies() {     Set<Dependency<?>> dependencies = new HashSet<>().     for (AssistedConstructor<?> constructor : factoryMethodToConstructor.values()) {         for (Parameter parameter : constructor.getAllParameters()) {             if (!parameter.isProvidedByFactory()) {                 dependencies.add(Dependency.get(parameter.getPrimaryBindingKey())).             }         }     }     return unmodifiableSet(dependencies). }
false;public;3;13;;@Override public Object invoke(Object proxy, Method method, Object[] creationArgs) throws Throwable {     // pass methods from Object.class to the proxy     if (method.getDeclaringClass().equals(Object.class)) {         return method.invoke(this, creationArgs).     }     AssistedConstructor<?> constructor = factoryMethodToConstructor.get(method).     Object[] constructorArgs = gatherArgsForConstructor(constructor, creationArgs).     Object objectToReturn = constructor.newInstance(constructorArgs).     injector.injectMembers(objectToReturn).     return objectToReturn. }
false;public;2;18;;public Object[] gatherArgsForConstructor(AssistedConstructor<?> constructor, Object[] factoryArgs) {     int numParams = constructor.getAllParameters().size().     int argPosition = 0.     Object[] result = new Object[numParams].     for (int i = 0. i < numParams. i++) {         Parameter parameter = constructor.getAllParameters().get(i).         if (parameter.isProvidedByFactory()) {             result[i] = factoryArgs[argPosition].             argPosition++.         } else {             result[i] = parameter.getValue(injector).         }     }     return result. }
false;public;0;42;;@Override public F get() {     InvocationHandler invocationHandler = new InvocationHandler() {          @Override         public Object invoke(Object proxy, Method method, Object[] creationArgs) throws Throwable {             // pass methods from Object.class to the proxy             if (method.getDeclaringClass().equals(Object.class)) {                 return method.invoke(this, creationArgs).             }             AssistedConstructor<?> constructor = factoryMethodToConstructor.get(method).             Object[] constructorArgs = gatherArgsForConstructor(constructor, creationArgs).             Object objectToReturn = constructor.newInstance(constructorArgs).             injector.injectMembers(objectToReturn).             return objectToReturn.         }          public Object[] gatherArgsForConstructor(AssistedConstructor<?> constructor, Object[] factoryArgs) {             int numParams = constructor.getAllParameters().size().             int argPosition = 0.             Object[] result = new Object[numParams].             for (int i = 0. i < numParams. i++) {                 Parameter parameter = constructor.getAllParameters().get(i).                 if (parameter.isProvidedByFactory()) {                     result[i] = factoryArgs[argPosition].                     argPosition++.                 } else {                     result[i] = parameter.getValue(injector).                 }             }             return result.         }     }.     // we imprecisely treat the class literal of T as a Class<T>     @SuppressWarnings("unchecked")     Class<F> factoryRawType = (Class) factoryType.getRawType().     return factoryRawType.cast(Proxy.newProxyInstance(factoryRawType.getClassLoader(), new Class[] { factoryRawType }, invocationHandler)). }
false;private,static;2;3;;private static ConfigurationException newConfigurationException(String format, Object... args) {     return new ConfigurationException(singleton(new Message(Errors.format(format, args)))). }
