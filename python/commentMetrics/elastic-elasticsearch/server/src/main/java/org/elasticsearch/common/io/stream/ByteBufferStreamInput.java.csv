commented;modifiers;parameterAmount;loc;comment;code
false;public;0;7;;@Override public int read() throws IOException {     if (!buffer.hasRemaining()) {         return -1.     }     return buffer.get() & 0xFF. }
false;public;0;7;;@Override public byte readByte() throws IOException {     if (!buffer.hasRemaining()) {         throw new EOFException().     }     return buffer.get(). }
false;public;3;10;;@Override public int read(byte[] b, int off, int len) throws IOException {     if (!buffer.hasRemaining()) {         return -1.     }     len = Math.min(len, buffer.remaining()).     buffer.get(b, off, len).     return len. }
false;public;1;10;;@Override public long skip(long n) throws IOException {     if (n > buffer.remaining()) {         int ret = buffer.position().         buffer.position(buffer.limit()).         return ret.     }     buffer.position((int) (buffer.position() + n)).     return n. }
false;public;3;7;;@Override public void readBytes(byte[] b, int offset, int len) throws IOException {     if (buffer.remaining() < len) {         throw new EOFException().     }     buffer.get(b, offset, len). }
false;public;0;4;;@Override public void reset() throws IOException {     buffer.reset(). }
false;public;0;4;;@Override public int available() throws IOException {     return buffer.remaining(). }
false;protected;1;6;;@Override protected void ensureCanReadBytes(int length) throws EOFException {     if (buffer.remaining() < length) {         throw new EOFException("tried to read: " + length + " bytes but only " + buffer.remaining() + " remaining").     } }
false;public;1;4;;@Override public void mark(int readlimit) {     buffer.mark(). }
false;public;0;4;;@Override public boolean markSupported() {     return true. }
false;public;0;3;;@Override public void close() throws IOException { }
