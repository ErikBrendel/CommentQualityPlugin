commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;6;;@Override protected void doWriteTo(StreamOutput out) throws IOException {     out.writeOptionalString(encoder).     out.writeBoolean(useExplicitFieldOrder).     out.writeList(fields). }
true;public;1;3;/**  * Adds a field to be highlighted with default fragment size of 100 characters, and  * default number of fragments of 5 using the default encoder  *  * @param name The field to highlight  */ ;/**  * Adds a field to be highlighted with default fragment size of 100 characters, and  * default number of fragments of 5 using the default encoder  *  * @param name The field to highlight  */ public HighlightBuilder field(String name) {     return field(new Field(name)). }
true;public;2;3;/**  * Adds a field to be highlighted with a provided fragment size (in characters), and  * default number of fragments of 5.  *  * @param name         The field to highlight  * @param fragmentSize The size of a fragment in characters  */ ;/**  * Adds a field to be highlighted with a provided fragment size (in characters), and  * default number of fragments of 5.  *  * @param name         The field to highlight  * @param fragmentSize The size of a fragment in characters  */ public HighlightBuilder field(String name, int fragmentSize) {     return field(new Field(name).fragmentSize(fragmentSize)). }
true;public;3;3;/**  * Adds a field to be highlighted with a provided fragment size (in characters), and  * a provided (maximum) number of fragments.  *  * @param name              The field to highlight  * @param fragmentSize      The size of a fragment in characters  * @param numberOfFragments The (maximum) number of fragments  */ ;/**  * Adds a field to be highlighted with a provided fragment size (in characters), and  * a provided (maximum) number of fragments.  *  * @param name              The field to highlight  * @param fragmentSize      The size of a fragment in characters  * @param numberOfFragments The (maximum) number of fragments  */ public HighlightBuilder field(String name, int fragmentSize, int numberOfFragments) {     return field(new Field(name).fragmentSize(fragmentSize).numOfFragments(numberOfFragments)). }
true;public;4;4;/**  * Adds a field to be highlighted with a provided fragment size (in characters), and  * a provided (maximum) number of fragments.  *  * @param name              The field to highlight  * @param fragmentSize      The size of a fragment in characters  * @param numberOfFragments The (maximum) number of fragments  * @param fragmentOffset    The offset from the start of the fragment to the start of the highlight  */ ;/**  * Adds a field to be highlighted with a provided fragment size (in characters), and  * a provided (maximum) number of fragments.  *  * @param name              The field to highlight  * @param fragmentSize      The size of a fragment in characters  * @param numberOfFragments The (maximum) number of fragments  * @param fragmentOffset    The offset from the start of the fragment to the start of the highlight  */ public HighlightBuilder field(String name, int fragmentSize, int numberOfFragments, int fragmentOffset) {     return field(new Field(name).fragmentSize(fragmentSize).numOfFragments(numberOfFragments).fragmentOffset(fragmentOffset)). }
false;public;1;4;;public HighlightBuilder field(Field field) {     fields.add(field).     return this. }
false;;1;3;;void fields(List<Field> fields) {     this.fields.addAll(fields). }
false;public;0;3;;public List<Field> fields() {     return this.fields. }
true;public;1;15;/**  * Set a tag scheme that encapsulates a built in pre and post tags. The allowed schemes  * are {@code styled} and {@code default}.  *  * @param schemaName The tag scheme name  */ ;/**  * Set a tag scheme that encapsulates a built in pre and post tags. The allowed schemes  * are {@code styled} and {@code default}.  *  * @param schemaName The tag scheme name  */ public HighlightBuilder tagsSchema(String schemaName) {     switch(schemaName) {         case "default":             preTags(DEFAULT_PRE_TAGS).             postTags(DEFAULT_POST_TAGS).             break.         case "styled":             preTags(DEFAULT_STYLED_PRE_TAG).             postTags(DEFAULT_STYLED_POST_TAGS).             break.         default:             throw new IllegalArgumentException("Unknown tag schema [" + schemaName + "]").     }     return this. }
true;public;1;4;/**  * Set encoder for the highlighting  * are {@code html} and {@code default}.  *  * @param encoder name  */ ;/**  * Set encoder for the highlighting  * are {@code html} and {@code default}.  *  * @param encoder name  */ public HighlightBuilder encoder(String encoder) {     this.encoder = encoder.     return this. }
true;public;0;3;/**  * Getter for {@link #encoder(String)}  */ ;/**  * Getter for {@link #encoder(String)}  */ public String encoder() {     return this.encoder. }
true;public;1;4;/**  * Send the fields to be highlighted using a syntax that is specific about the order in which they should be highlighted.  * @return this for chaining  */ ;/**  * Send the fields to be highlighted using a syntax that is specific about the order in which they should be highlighted.  * @return this for chaining  */ public HighlightBuilder useExplicitFieldOrder(boolean useExplicitFieldOrder) {     this.useExplicitFieldOrder = useExplicitFieldOrder.     return this. }
true;public;0;3;/**  * Gets value set with {@link #useExplicitFieldOrder(boolean)}  */ ;/**  * Gets value set with {@link #useExplicitFieldOrder(boolean)}  */ public Boolean useExplicitFieldOrder() {     return this.useExplicitFieldOrder. }
false;public;2;7;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     innerXContent(builder).     builder.endObject().     return builder. }
false;public,static;1;3;;public static HighlightBuilder fromXContent(XContentParser p) {     return PARSER.apply(p, new HighlightBuilder()). }
false;public;1;25;;public SearchContextHighlight build(QueryShardContext context) throws IOException {     // create template global options that are later merged with any partial field options     final SearchContextHighlight.FieldOptions.Builder globalOptionsBuilder = new SearchContextHighlight.FieldOptions.Builder().     globalOptionsBuilder.encoder(this.encoder).     transferOptions(this, globalOptionsBuilder, context).     // overwrite unset global options by default values     globalOptionsBuilder.merge(defaultOptions).     // create field options     Collection<org.elasticsearch.search.fetch.subphase.highlight.SearchContextHighlight.Field> fieldOptions = new ArrayList<>().     for (Field field : this.fields) {         final SearchContextHighlight.FieldOptions.Builder fieldOptionsBuilder = new SearchContextHighlight.FieldOptions.Builder().         fieldOptionsBuilder.fragmentOffset(field.fragmentOffset).         if (field.matchedFields != null) {             Set<String> matchedFields = new HashSet<>(field.matchedFields.length).             Collections.addAll(matchedFields, field.matchedFields).             fieldOptionsBuilder.matchedFields(matchedFields).         }         transferOptions(field, fieldOptionsBuilder, context).         fieldOptions.add(new SearchContextHighlight.Field(field.name(), fieldOptionsBuilder.merge(globalOptionsBuilder.build()).build())).     }     return new SearchContextHighlight(fieldOptions). }
true;private,static;3;58;/**  * Transfers field options present in the input {@link AbstractHighlighterBuilder} to the receiving  * {@link FieldOptions.Builder}, effectively overwriting existing settings  * @param targetOptionsBuilder the receiving options builder  * @param highlighterBuilder highlight builder with the input options  * @param context needed to convert {@link QueryBuilder} to {@link Query}  * @throws IOException on errors parsing any optional nested highlight query  */ ;/**  * Transfers field options present in the input {@link AbstractHighlighterBuilder} to the receiving  * {@link FieldOptions.Builder}, effectively overwriting existing settings  * @param targetOptionsBuilder the receiving options builder  * @param highlighterBuilder highlight builder with the input options  * @param context needed to convert {@link QueryBuilder} to {@link Query}  * @throws IOException on errors parsing any optional nested highlight query  */ @SuppressWarnings({ "rawtypes", "unchecked" }) private static void transferOptions(AbstractHighlighterBuilder highlighterBuilder, SearchContextHighlight.FieldOptions.Builder targetOptionsBuilder, QueryShardContext context) throws IOException {     if (highlighterBuilder.preTags != null) {         targetOptionsBuilder.preTags(highlighterBuilder.preTags).     }     if (highlighterBuilder.postTags != null) {         targetOptionsBuilder.postTags(highlighterBuilder.postTags).     }     if (highlighterBuilder.order != null) {         targetOptionsBuilder.scoreOrdered(highlighterBuilder.order == Order.SCORE).     }     if (highlighterBuilder.highlightFilter != null) {         targetOptionsBuilder.highlightFilter(highlighterBuilder.highlightFilter).     }     if (highlighterBuilder.fragmentSize != null) {         targetOptionsBuilder.fragmentCharSize(highlighterBuilder.fragmentSize).     }     if (highlighterBuilder.numOfFragments != null) {         targetOptionsBuilder.numberOfFragments(highlighterBuilder.numOfFragments).     }     if (highlighterBuilder.requireFieldMatch != null) {         targetOptionsBuilder.requireFieldMatch(highlighterBuilder.requireFieldMatch).     }     if (highlighterBuilder.boundaryScannerType != null) {         targetOptionsBuilder.boundaryScannerType(highlighterBuilder.boundaryScannerType).     }     if (highlighterBuilder.boundaryMaxScan != null) {         targetOptionsBuilder.boundaryMaxScan(highlighterBuilder.boundaryMaxScan).     }     if (highlighterBuilder.boundaryChars != null) {         targetOptionsBuilder.boundaryChars(convertCharArray(highlighterBuilder.boundaryChars)).     }     if (highlighterBuilder.boundaryScannerLocale != null) {         targetOptionsBuilder.boundaryScannerLocale(highlighterBuilder.boundaryScannerLocale).     }     if (highlighterBuilder.highlighterType != null) {         targetOptionsBuilder.highlighterType(highlighterBuilder.highlighterType).     }     if (highlighterBuilder.fragmenter != null) {         targetOptionsBuilder.fragmenter(highlighterBuilder.fragmenter).     }     if (highlighterBuilder.noMatchSize != null) {         targetOptionsBuilder.noMatchSize(highlighterBuilder.noMatchSize).     }     if (highlighterBuilder.forceSource != null) {         targetOptionsBuilder.forceSource(highlighterBuilder.forceSource).     }     if (highlighterBuilder.phraseLimit != null) {         targetOptionsBuilder.phraseLimit(highlighterBuilder.phraseLimit).     }     if (highlighterBuilder.options != null) {         targetOptionsBuilder.options(highlighterBuilder.options).     }     if (highlighterBuilder.highlightQuery != null) {         targetOptionsBuilder.highlightQuery(highlighterBuilder.highlightQuery.toQuery(context)).     } }
false;static;1;10;;static Character[] convertCharArray(char[] array) {     if (array == null) {         return null.     }     Character[] charArray = new Character[array.length].     for (int i = 0. i < array.length. i++) {         charArray[i] = array[i].     }     return charArray. }
false;public;1;30;;@Override public void innerXContent(XContentBuilder builder) throws IOException {     // first write common options     commonOptionsToXContent(builder).     // special options for top-level highlighter     if (encoder != null) {         builder.field(ENCODER_FIELD.getPreferredName(), encoder).     }     if (fields.size() > 0) {         if (useExplicitFieldOrder) {             builder.startArray(FIELDS_FIELD.getPreferredName()).         } else {             builder.startObject(FIELDS_FIELD.getPreferredName()).         }         for (Field field : fields) {             if (useExplicitFieldOrder) {                 builder.startObject().             }             field.innerXContent(builder).             if (useExplicitFieldOrder) {                 builder.endObject().             }         }         if (useExplicitFieldOrder) {             builder.endArray().         } else {             builder.endObject().         }     } }
false;protected;0;4;;@Override protected int doHashCode() {     return Objects.hash(encoder, useExplicitFieldOrder, fields). }
false;protected;1;6;;@Override protected boolean doEquals(HighlightBuilder other) {     return Objects.equals(encoder, other.encoder) && Objects.equals(useExplicitFieldOrder, other.useExplicitFieldOrder) && Objects.equals(fields, other.fields). }
false;public;1;13;;@Override public HighlightBuilder rewrite(QueryRewriteContext ctx) throws IOException {     QueryBuilder highlightQuery = this.highlightQuery.     if (highlightQuery != null) {         highlightQuery = this.highlightQuery.rewrite(ctx).     }     List<Field> fields = Rewriteable.rewrite(this.fields, ctx).     if (highlightQuery == this.highlightQuery && fields == this.fields) {         return this.     }     return new HighlightBuilder(this, highlightQuery, fields). }
false;protected;1;6;;@Override protected void doWriteTo(StreamOutput out) throws IOException {     out.writeString(name).     out.writeVInt(fragmentOffset).     out.writeOptionalStringArray(matchedFields). }
false;public;0;3;;public String name() {     return name. }
false;public;1;4;;public Field fragmentOffset(int fragmentOffset) {     this.fragmentOffset = fragmentOffset.     return this. }
true;public;1;4;/**  * Set the matched fields to highlight against this field data.  Default to null, meaning just  * the named field.  If you provide a list of fields here then don't forget to include name as  * it is not automatically included.  */ ;/**  * Set the matched fields to highlight against this field data.  Default to null, meaning just  * the named field.  If you provide a list of fields here then don't forget to include name as  * it is not automatically included.  */ public Field matchedFields(String... matchedFields) {     this.matchedFields = matchedFields.     return this. }
false;public;1;14;;@Override public void innerXContent(XContentBuilder builder) throws IOException {     builder.startObject(name).     // write common options     commonOptionsToXContent(builder).     // write special field-highlighter options     if (fragmentOffset != -1) {         builder.field(FRAGMENT_OFFSET_FIELD.getPreferredName(), fragmentOffset).     }     if (matchedFields != null) {         builder.array(MATCHED_FIELDS_FIELD.getPreferredName(), matchedFields).     }     builder.endObject(). }
false;protected;0;4;;@Override protected int doHashCode() {     return Objects.hash(name, fragmentOffset, Arrays.hashCode(matchedFields)). }
false;protected;1;6;;@Override protected boolean doEquals(Field other) {     return Objects.equals(name, other.name) && Objects.equals(fragmentOffset, other.fragmentOffset) && Arrays.equals(matchedFields, other.matchedFields). }
false;public;1;10;;@Override public Field rewrite(QueryRewriteContext ctx) throws IOException {     if (highlightQuery != null) {         QueryBuilder rewrite = highlightQuery.rewrite(ctx).         if (rewrite != highlightQuery) {             return new Field(this, rewrite).         }     }     return this. }
false;public,static;1;3;;public static Order readFromStream(StreamInput in) throws IOException {     return in.readEnum(Order.class). }
false;public;1;4;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeEnum(this). }
false;public,static;1;6;;public static Order fromString(String order) {     if (order.toUpperCase(Locale.ROOT).equals(SCORE.name())) {         return Order.SCORE.     }     return NONE. }
false;public;0;4;;@Override public String toString() {     return name().toLowerCase(Locale.ROOT). }
false;public,static;1;3;;public static BoundaryScannerType readFromStream(StreamInput in) throws IOException {     return in.readEnum(BoundaryScannerType.class). }
false;public;1;4;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeEnum(this). }
false;public,static;1;3;;public static BoundaryScannerType fromString(String boundaryScannerType) {     return valueOf(boundaryScannerType.toUpperCase(Locale.ROOT)). }
false;public;0;4;;@Override public String toString() {     return name().toLowerCase(Locale.ROOT). }
