commented;modifiers;parameterAmount;loc;comment;code
true;public,static;0;3;/**  * Returns a matcher which matches any input.  */ ;/**  * Returns a matcher which matches any input.  */ public static Matcher<Object> any() {     return ANY. }
false;public;1;4;;@Override public boolean matches(Object o) {     return true. }
false;public;0;4;;@Override public String toString() {     return "any()". }
false;public;0;3;;public Object readResolve() {     return any(). }
true;public,static;1;3;/**  * Inverts the given matcher.  */ ;/**  * Inverts the given matcher.  */ public static <T> Matcher<T> not(final Matcher<? super T> p) {     return new Not<>(p). }
false;public;1;4;;@Override public boolean matches(T t) {     return !delegate.matches(t). }
false;public;1;5;;@Override public boolean equals(Object other) {     return other instanceof Not && ((Not) other).delegate.equals(delegate). }
false;public;0;4;;@Override public int hashCode() {     return -delegate.hashCode(). }
false;public;0;4;;@Override public String toString() {     return "not(" + delegate + ")". }
false;private,static;1;7;;private static void checkForRuntimeRetention(Class<? extends Annotation> annotationType) {     Retention retention = annotationType.getAnnotation(Retention.class).     if (retention == null || retention.value() != RetentionPolicy.RUNTIME) {         throw new IllegalArgumentException("Annotation " + annotationType.getSimpleName() + " is missing RUNTIME retention").     } }
true;public,static;1;4;/**  * Returns a matcher which matches elements (methods, classes, etc.)  * with a given annotation.  */ ;/**  * Returns a matcher which matches elements (methods, classes, etc.)  * with a given annotation.  */ public static Matcher<AnnotatedElement> annotatedWith(final Class<? extends Annotation> annotationType) {     return new AnnotatedWithType(annotationType). }
false;public;1;4;;@Override public boolean matches(AnnotatedElement element) {     return element.getAnnotation(annotationType) != null. }
false;public;1;5;;@Override public boolean equals(Object other) {     return other instanceof AnnotatedWithType && ((AnnotatedWithType) other).annotationType.equals(annotationType). }
false;public;0;4;;@Override public int hashCode() {     return 37 * annotationType.hashCode(). }
false;public;0;4;;@Override public String toString() {     return "annotatedWith(" + annotationType.getSimpleName() + ".class)". }
true;public,static;1;4;/**  * Returns a matcher which matches elements (methods, classes, etc.)  * with a given annotation.  */ ;/**  * Returns a matcher which matches elements (methods, classes, etc.)  * with a given annotation.  */ public static Matcher<AnnotatedElement> annotatedWith(final Annotation annotation) {     return new AnnotatedWith(annotation). }
false;public;1;5;;@Override public boolean matches(AnnotatedElement element) {     Annotation fromElement = element.getAnnotation(annotation.annotationType()).     return fromElement != null && annotation.equals(fromElement). }
false;public;1;5;;@Override public boolean equals(Object other) {     return other instanceof AnnotatedWith && ((AnnotatedWith) other).annotation.equals(annotation). }
false;public;0;4;;@Override public int hashCode() {     return 37 * annotation.hashCode(). }
false;public;0;4;;@Override public String toString() {     return "annotatedWith(" + annotation + ")". }
true;public,static;1;3;/**  * Returns a matcher which matches subclasses of the given type (as well as  * the given type).  */ ;/**  * Returns a matcher which matches subclasses of the given type (as well as  * the given type).  */ public static Matcher<Class> subclassesOf(final Class<?> superclass) {     return new SubclassesOf(superclass). }
false;public;1;4;;@Override public boolean matches(Class subclass) {     return superclass.isAssignableFrom(subclass). }
false;public;1;5;;@Override public boolean equals(Object other) {     return other instanceof SubclassesOf && ((SubclassesOf) other).superclass.equals(superclass). }
false;public;0;4;;@Override public int hashCode() {     return 37 * superclass.hashCode(). }
false;public;0;4;;@Override public String toString() {     return "subclassesOf(" + superclass.getSimpleName() + ".class)". }
true;public,static;1;3;/**  * Returns a matcher which matches objects equal to the given object.  */ ;/**  * Returns a matcher which matches objects equal to the given object.  */ public static Matcher<Object> only(Object value) {     return new Only(value). }
false;public;1;4;;@Override public boolean matches(Object other) {     return value.equals(other). }
false;public;1;5;;@Override public boolean equals(Object other) {     return other instanceof Only && ((Only) other).value.equals(value). }
false;public;0;4;;@Override public int hashCode() {     return 37 * value.hashCode(). }
false;public;0;4;;@Override public String toString() {     return "only(" + value + ")". }
true;public,static;1;3;/**  * Returns a matcher which matches only the given object.  */ ;/**  * Returns a matcher which matches only the given object.  */ public static Matcher<Object> identicalTo(final Object value) {     return new IdenticalTo(value). }
false;public;1;4;;@Override public boolean matches(Object other) {     return value == other. }
false;public;1;5;;@Override public boolean equals(Object other) {     return other instanceof IdenticalTo && ((IdenticalTo) other).value == value. }
false;public;0;4;;@Override public int hashCode() {     return 37 * System.identityHashCode(value). }
false;public;0;4;;@Override public String toString() {     return "identicalTo(" + value + ")". }
true;public,static;1;3;/**  * Returns a matcher which matches classes in the given package. Packages are specific to their  * classloader, so classes with the same package name may not have the same package at runtime.  */ ;/**  * Returns a matcher which matches classes in the given package. Packages are specific to their  * classloader, so classes with the same package name may not have the same package at runtime.  */ public static Matcher<Class> inPackage(final Package targetPackage) {     return new InPackage(targetPackage). }
false;public;1;4;;@Override public boolean matches(Class c) {     return c.getPackage().equals(targetPackage). }
false;public;1;5;;@Override public boolean equals(Object other) {     return other instanceof InPackage && ((InPackage) other).targetPackage.equals(targetPackage). }
false;public;0;4;;@Override public int hashCode() {     return 37 * targetPackage.hashCode(). }
false;public;0;4;;@Override public String toString() {     return "inPackage(" + targetPackage.getName() + ")". }
false;public;0;5;;@SuppressForbidden(reason = "ClassLoader.getDefinedPackage not available yet") public Object readResolve() {     // TODO minJava >= 9 : use ClassLoader.getDefinedPackage and remove @SuppressForbidden     return inPackage(Package.getPackage(packageName)). }
true;public,static;1;3;/**  * Returns a matcher which matches classes in the given package and its subpackages. Unlike  * {@link #inPackage(Package) inPackage()}, this matches classes from any classloader.  *  * @since 2.0  */ ;/**  * Returns a matcher which matches classes in the given package and its subpackages. Unlike  * {@link #inPackage(Package) inPackage()}, this matches classes from any classloader.  *  * @since 2.0  */ public static Matcher<Class> inSubpackage(final String targetPackageName) {     return new InSubpackage(targetPackageName). }
false;public;1;6;;@Override public boolean matches(Class c) {     String classPackageName = c.getPackage().getName().     return classPackageName.equals(targetPackageName) || classPackageName.startsWith(targetPackageName + "."). }
false;public;1;5;;@Override public boolean equals(Object other) {     return other instanceof InSubpackage && ((InSubpackage) other).targetPackageName.equals(targetPackageName). }
false;public;0;4;;@Override public int hashCode() {     return 37 * targetPackageName.hashCode(). }
false;public;0;4;;@Override public String toString() {     return "inSubpackage(" + targetPackageName + ")". }
true;public,static;1;4;/**  * Returns a matcher which matches methods with matching return types.  */ ;/**  * Returns a matcher which matches methods with matching return types.  */ public static Matcher<Method> returns(final Matcher<? super Class<?>> returnType) {     return new Returns(returnType). }
false;public;1;4;;@Override public boolean matches(Method m) {     return returnType.matches(m.getReturnType()). }
false;public;1;5;;@Override public boolean equals(Object other) {     return other instanceof Returns && ((Returns) other).returnType.equals(returnType). }
false;public;0;4;;@Override public int hashCode() {     return 37 * returnType.hashCode(). }
false;public;0;4;;@Override public String toString() {     return "returns(" + returnType + ")". }
