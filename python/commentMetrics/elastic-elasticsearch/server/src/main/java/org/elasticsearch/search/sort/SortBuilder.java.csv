commented;modifiers;parameterAmount;loc;comment;code
true;protected,abstract;1;1;/**  * Create a @link {@link SortFieldAndFormat} from this builder.  */ ;/**  * Create a @link {@link SortFieldAndFormat} from this builder.  */ protected abstract SortFieldAndFormat build(QueryShardContext context) throws IOException.
true;public;1;6;/**  * Set the order of sorting.  */ ;/**  * Set the order of sorting.  */ @SuppressWarnings("unchecked") public T order(SortOrder order) {     Objects.requireNonNull(order, "sort order cannot be null.").     this.order = order.     return (T) this. }
true;public;0;3;/**  * Return the {@link SortOrder} used for this {@link SortBuilder}.  */ ;/**  * Return the {@link SortOrder} used for this {@link SortBuilder}.  */ public SortOrder order() {     return this.order. }
false;public,static;1;25;;public static List<SortBuilder<?>> fromXContent(XContentParser parser) throws IOException {     List<SortBuilder<?>> sortFields = new ArrayList<>(2).     XContentParser.Token token = parser.currentToken().     if (token == XContentParser.Token.START_ARRAY) {         while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {             if (token == XContentParser.Token.START_OBJECT) {                 parseCompoundSortField(parser, sortFields).             } else if (token == XContentParser.Token.VALUE_STRING) {                 String fieldName = parser.text().                 sortFields.add(fieldOrScoreSort(fieldName)).             } else {                 throw new IllegalArgumentException("malformed sort format, " + "within the sort array, an object, or an actual string are allowed").             }         }     } else if (token == XContentParser.Token.VALUE_STRING) {         String fieldName = parser.text().         sortFields.add(fieldOrScoreSort(fieldName)).     } else if (token == XContentParser.Token.START_OBJECT) {         parseCompoundSortField(parser, sortFields).     } else {         throw new IllegalArgumentException("malformed sort format, either start with array, object, or an actual string").     }     return sortFields. }
false;private,static;1;7;;private static SortBuilder<?> fieldOrScoreSort(String fieldName) {     if (fieldName.equals(ScoreSortBuilder.NAME)) {         return new ScoreSortBuilder().     } else {         return new FieldSortBuilder(fieldName).     } }
false;private,static;2;20;;private static void parseCompoundSortField(XContentParser parser, List<SortBuilder<?>> sortFields) throws IOException {     XContentParser.Token token.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             String fieldName = parser.currentName().             token = parser.nextToken().             if (token == XContentParser.Token.VALUE_STRING) {                 SortOrder order = SortOrder.fromString(parser.text()).                 sortFields.add(fieldOrScoreSort(fieldName).order(order)).             } else {                 if (PARSERS.containsKey(fieldName)) {                     sortFields.add(PARSERS.get(fieldName).fromXContent(parser, fieldName)).                 } else {                     sortFields.add(FieldSortBuilder.fromXContent(parser, fieldName)).                 }             }         }     } }
false;public,static;2;30;;public static Optional<SortAndFormats> buildSort(List<SortBuilder<?>> sortBuilders, QueryShardContext context) throws IOException {     List<SortField> sortFields = new ArrayList<>(sortBuilders.size()).     List<DocValueFormat> sortFormats = new ArrayList<>(sortBuilders.size()).     for (SortBuilder<?> builder : sortBuilders) {         SortFieldAndFormat sf = builder.build(context).         sortFields.add(sf.field).         sortFormats.add(sf.format).     }     if (!sortFields.isEmpty()) {         // optimize if we just sort on score non reversed, we don't really         // need sorting         boolean sort.         if (sortFields.size() > 1) {             sort = true.         } else {             SortField sortField = sortFields.get(0).             if (sortField.getType() == SortField.Type.SCORE && !sortField.getReverse()) {                 sort = false.             } else {                 sort = true.             }         }         if (sort) {             return Optional.of(new SortAndFormats(new Sort(sortFields.toArray(new SortField[sortFields.size()])), sortFormats.toArray(new DocValueFormat[sortFormats.size()]))).         }     }     return Optional.empty(). }
false;protected,static;3;5;;protected static Nested resolveNested(QueryShardContext context, String nestedPath, QueryBuilder nestedFilter) throws IOException {     NestedSortBuilder nestedSortBuilder = new NestedSortBuilder(nestedPath).     nestedSortBuilder.setFilter(nestedFilter).     return resolveNested(context, nestedSortBuilder). }
false;protected,static;2;14;;protected static Nested resolveNested(QueryShardContext context, NestedSortBuilder nestedSort) throws IOException {     final Query childQuery = resolveNestedQuery(context, nestedSort, null).     if (childQuery == null) {         return null.     }     final ObjectMapper objectMapper = context.nestedScope().getObjectMapper().     final Query parentQuery.     if (objectMapper == null) {         parentQuery = Queries.newNonNestedFilter(context.indexVersionCreated()).     } else {         parentQuery = objectMapper.nestedTypeFilter().     }     return new Nested(context.bitsetFilter(parentQuery), childQuery, nestedSort). }
false;private,static;3;59;;private static Query resolveNestedQuery(QueryShardContext context, NestedSortBuilder nestedSort, Query parentQuery) throws IOException {     if (nestedSort == null || nestedSort.getPath() == null) {         return null.     }     String nestedPath = nestedSort.getPath().     QueryBuilder nestedFilter = nestedSort.getFilter().     NestedSortBuilder nestedNestedSort = nestedSort.getNestedSort().     // verify our nested path     ObjectMapper nestedObjectMapper = context.getObjectMapper(nestedPath).     if (nestedObjectMapper == null) {         throw new QueryShardException(context, "[nested] failed to find nested object under path [" + nestedPath + "]").     }     if (!nestedObjectMapper.nested().isNested()) {         throw new QueryShardException(context, "[nested] nested object under path [" + nestedPath + "] is not of nested type").     }     ObjectMapper objectMapper = context.nestedScope().getObjectMapper().     // get our child query, potentially applying a users filter     Query childQuery.     try {         context.nestedScope().nextLevel(nestedObjectMapper).         if (nestedFilter != null) {             assert nestedFilter == Rewriteable.rewrite(nestedFilter, context) : "nested filter is not rewritten".             if (parentQuery == null) {                 // this is for back-compat, original single level nested sorting never applied a nested type filter                 childQuery = nestedFilter.toQuery(context).             } else {                 childQuery = Queries.filtered(nestedObjectMapper.nestedTypeFilter(), nestedFilter.toQuery(context)).             }         } else {             childQuery = nestedObjectMapper.nestedTypeFilter().         }     } finally {         context.nestedScope().previousLevel().     }     // apply filters from the previous nested level     if (parentQuery != null) {         if (objectMapper != null) {             childQuery = Queries.filtered(childQuery, new ToChildBlockJoinQuery(parentQuery, context.bitsetFilter(objectMapper.nestedTypeFilter()))).         }     }     // wrap up our parent and child and either process the next level of nesting or return     if (nestedNestedSort != null) {         try {             context.nestedScope().nextLevel(nestedObjectMapper).             return resolveNestedQuery(context, nestedNestedSort, childQuery).         } finally {             context.nestedScope().previousLevel().         }     } else {         return childQuery.     } }
false;protected,static;1;7;;protected static QueryBuilder parseNestedFilter(XContentParser parser) {     try {         return parseInnerQueryBuilder(parser).     } catch (Exception e) {         throw new ParsingException(parser.getTokenLocation(), "Expected " + NESTED_FILTER_FIELD.getPreferredName() + " element.", e).     } }
false;;2;1;;T fromXContent(XContentParser parser, String elementName) throws IOException.
false;public;0;4;;@Override public String toString() {     return Strings.toString(this, true, true). }
