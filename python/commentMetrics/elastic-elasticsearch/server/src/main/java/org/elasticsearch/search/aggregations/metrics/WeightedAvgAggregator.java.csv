commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public ScoreMode scoreMode() {     return valuesSources != null && valuesSources.needsScores() ? ScoreMode.COMPLETE : ScoreMode.COMPLETE_NO_SCORES. }
false;public;2;26;;@Override public void collect(int doc, long bucket) throws IOException {     weights = bigArrays.grow(weights, bucket + 1).     sums = bigArrays.grow(sums, bucket + 1).     sumCompensations = bigArrays.grow(sumCompensations, bucket + 1).     weightCompensations = bigArrays.grow(weightCompensations, bucket + 1).     if (docValues.advanceExact(doc) && docWeights.advanceExact(doc)) {         if (docWeights.docValueCount() > 1) {             throw new AggregationExecutionException("Encountered more than one weight for a " + "single document. Use a script to combine multiple weights-per-doc into a single value.").         }         // a real weight or a `missing` weight         assert docWeights.docValueCount() == 1.         final double weight = docWeights.nextValue().         final int numValues = docValues.docValueCount().         assert numValues > 0.         for (int i = 0. i < numValues. i++) {             kahanSum(docValues.nextValue() * weight, sums, sumCompensations, bucket).             kahanSum(weight, weights, weightCompensations, bucket).         }     } }
false;public;2;39;;@Override public LeafBucketCollector getLeafCollector(LeafReaderContext ctx, final LeafBucketCollector sub) throws IOException {     if (valuesSources == null) {         return LeafBucketCollector.NO_OP_COLLECTOR.     }     final BigArrays bigArrays = context.bigArrays().     final SortedNumericDoubleValues docValues = valuesSources.getField(VALUE_FIELD.getPreferredName(), ctx).     final SortedNumericDoubleValues docWeights = valuesSources.getField(WEIGHT_FIELD.getPreferredName(), ctx).     return new LeafBucketCollectorBase(sub, docValues) {          @Override         public void collect(int doc, long bucket) throws IOException {             weights = bigArrays.grow(weights, bucket + 1).             sums = bigArrays.grow(sums, bucket + 1).             sumCompensations = bigArrays.grow(sumCompensations, bucket + 1).             weightCompensations = bigArrays.grow(weightCompensations, bucket + 1).             if (docValues.advanceExact(doc) && docWeights.advanceExact(doc)) {                 if (docWeights.docValueCount() > 1) {                     throw new AggregationExecutionException("Encountered more than one weight for a " + "single document. Use a script to combine multiple weights-per-doc into a single value.").                 }                 // a real weight or a `missing` weight                 assert docWeights.docValueCount() == 1.                 final double weight = docWeights.nextValue().                 final int numValues = docValues.docValueCount().                 assert numValues > 0.                 for (int i = 0. i < numValues. i++) {                     kahanSum(docValues.nextValue() * weight, sums, sumCompensations, bucket).                     kahanSum(weight, weights, weightCompensations, bucket).                 }             }         }     }. }
false;private,static;4;17;;private static void kahanSum(double value, DoubleArray values, DoubleArray compensations, long bucket) {     // Compute the sum of double values with Kahan summation algorithm which is more     // accurate than naive summation.     double sum = values.get(bucket).     double compensation = compensations.get(bucket).     if (Double.isFinite(value) == false) {         sum += value.     } else if (Double.isFinite(sum)) {         double corrected = value - compensation.         double newSum = sum + corrected.         compensation = (newSum - sum) - corrected.         sum = newSum.     }     values.set(bucket, sum).     compensations.set(bucket, compensation). }
false;public;1;7;;@Override public double metric(long owningBucketOrd) {     if (valuesSources == null || owningBucketOrd >= sums.size()) {         return Double.NaN.     }     return sums.get(owningBucketOrd) / weights.get(owningBucketOrd). }
false;public;1;7;;@Override public InternalAggregation buildAggregation(long bucket) {     if (valuesSources == null || bucket >= sums.size()) {         return buildEmptyAggregation().     }     return new InternalWeightedAvg(name, sums.get(bucket), weights.get(bucket), format, pipelineAggregators(), metaData()). }
false;public;0;4;;@Override public InternalAggregation buildEmptyAggregation() {     return new InternalWeightedAvg(name, 0.0, 0L, format, pipelineAggregators(), metaData()). }
false;public;0;4;;@Override public void doClose() {     Releasables.close(weights, sums, sumCompensations, weightCompensations). }
