commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * The name of the field.  */ ;/**  * The name of the field.  */ public String getName() {     return name. }
true;public;0;6;/**  * The first value of the hit.  */ ;/**  * The first value of the hit.  */ public <V> V getValue() {     if (values == null || values.isEmpty()) {         return null.     }     return (V) values.get(0). }
true;public;0;3;/**  * The field values.  */ ;/**  * The field values.  */ public List<Object> getValues() {     return values. }
true;public;0;3;/**  * @return The field is a metadata field  */ ;/**  * @return The field is a metadata field  */ public boolean isMetadataField() {     return MapperService.isMetadataField(name). }
false;public;0;4;;@Override public Iterator<Object> iterator() {     return values.iterator(). }
false;public,static;1;5;;public static DocumentField readDocumentField(StreamInput in) throws IOException {     DocumentField result = new DocumentField().     result.readFrom(in).     return result. }
false;public;1;9;;@Override public void readFrom(StreamInput in) throws IOException {     name = in.readString().     int size = in.readVInt().     values = new ArrayList<>(size).     for (int i = 0. i < size. i++) {         values.add(in.readGenericValue()).     } }
false;public;1;8;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeString(name).     out.writeVInt(values.size()).     for (Object obj : values) {         out.writeGenericValue(obj).     } }
false;public;2;13;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startArray(name).     for (Object value : values) {         // this call doesn't really need to support writing any kind of object.         // Stored fields values are converted using MappedFieldType#valueForDisplay.         // As a result they can either be Strings, Numbers, or Booleans, that's         // all.         builder.value(value).     }     builder.endArray().     return builder. }
false;public,static;1;11;;public static DocumentField fromXContent(XContentParser parser) throws IOException {     ensureExpectedToken(XContentParser.Token.FIELD_NAME, parser.currentToken(), parser::getTokenLocation).     String fieldName = parser.currentName().     XContentParser.Token token = parser.nextToken().     ensureExpectedToken(XContentParser.Token.START_ARRAY, token, parser::getTokenLocation).     List<Object> values = new ArrayList<>().     while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {         values.add(parseFieldsValue(parser)).     }     return new DocumentField(fieldName, values). }
false;public;1;11;;@Override public boolean equals(Object o) {     if (this == o) {         return true.     }     if (o == null || getClass() != o.getClass()) {         return false.     }     DocumentField objects = (DocumentField) o.     return Objects.equals(name, objects.name) && Objects.equals(values, objects.values). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(name, values). }
false;public;0;7;;@Override public String toString() {     return "DocumentField{" + "name='" + name + '\'' + ", values=" + values + '}'. }
