commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;3;/**  * Return a {@link Recycler} that never recycles entries.  */ ;/**  * Return a {@link Recycler} that never recycles entries.  */ public static <T> Recycler<T> none(Recycler.C<T> c) {     return new NoneRecycler<>(c). }
true;public,static;2;3;/**  * Return a concurrent recycler based on a deque.  */ ;/**  * Return a concurrent recycler based on a deque.  */ public static <T> Recycler<T> concurrentDeque(Recycler.C<T> c, int limit) {     return new ConcurrentDequeRecycler<>(c, limit). }
true;public,static;2;3;/**  * Return a recycler based on a deque.  */ ;/**  * Return a recycler based on a deque.  */ public static <T> Recycler<T> deque(Recycler.C<T> c, int limit) {     return new DequeRecycler<>(c, new ArrayDeque<>(), limit). }
false;public;0;4;;@Override public Recycler<T> build() {     return deque(c, limit). }
true;public,static;2;8;/**  * Return a recycler based on a deque.  */ ;/**  * Return a recycler based on a deque.  */ public static <T> Recycler.Factory<T> dequeFactory(final Recycler.C<T> c, final int limit) {     return new Recycler.Factory<T>() {          @Override         public Recycler<T> build() {             return deque(c, limit).         }     }. }
false;protected;0;4;;@Override protected Recycler<T> getDelegate() {     return defaultRecycler. }
false;public;1;7;;@Override public Recycler.V<T> obtain(int sizing) {     if (sizing > 0 && sizing < minSize) {         return smallObjectRecycler.obtain(sizing).     }     return super.obtain(sizing). }
false;public;0;5;;@Override public void close() {     defaultRecycler.close().     smallObjectRecycler.close(). }
true;public,static;3;24;/**  * Wrap two recyclers and forward to calls to <code>smallObjectRecycler</code> when <code>size &lt. minSize</code> and to  * <code>defaultRecycler</code> otherwise.  */ ;/**  * Wrap two recyclers and forward to calls to <code>smallObjectRecycler</code> when <code>size &lt. minSize</code> and to  * <code>defaultRecycler</code> otherwise.  */ public static <T> Recycler<T> sizing(final Recycler<T> defaultRecycler, final Recycler<T> smallObjectRecycler, final int minSize) {     return new FilterRecycler<T>() {          @Override         protected Recycler<T> getDelegate() {             return defaultRecycler.         }          @Override         public Recycler.V<T> obtain(int sizing) {             if (sizing > 0 && sizing < minSize) {                 return smallObjectRecycler.obtain(sizing).             }             return super.obtain(sizing).         }          @Override         public void close() {             defaultRecycler.close().             smallObjectRecycler.close().         }     }. }
false;protected;0;4;;@Override protected Recycler<T> getDelegate() {     return recycler. }
false;public;1;6;;@Override public org.elasticsearch.common.recycler.Recycler.V<T> obtain(int sizing) {     synchronized (lock) {         return super.obtain(sizing).     } }
false;public;0;6;;@Override public org.elasticsearch.common.recycler.Recycler.V<T> obtain() {     synchronized (lock) {         return super.obtain().     } }
false;public;0;6;;@Override public void close() {     synchronized (lock) {         delegate.close().     } }
false;public;0;4;;@Override public T v() {     return delegate.v(). }
false;public;0;4;;@Override public boolean isRecycled() {     return delegate.isRecycled(). }
false;protected;1;23;;@Override protected Recycler.V<T> wrap(final Recycler.V<T> delegate) {     return new Recycler.V<T>() {          @Override         public void close() {             synchronized (lock) {                 delegate.close().             }         }          @Override         public T v() {             return delegate.v().         }          @Override         public boolean isRecycled() {             return delegate.isRecycled().         }     }. }
true;public,static;1;54;/**  * Wrap the provided recycler so that calls to {@link Recycler#obtain()} and {@link Recycler.V#close()} are protected by  * a lock.  */ ;/**  * Wrap the provided recycler so that calls to {@link Recycler#obtain()} and {@link Recycler.V#close()} are protected by  * a lock.  */ public static <T> Recycler<T> locked(final Recycler<T> recycler) {     return new FilterRecycler<T>() {          private final Object lock.          {             this.lock = new Object().         }          @Override         protected Recycler<T> getDelegate() {             return recycler.         }          @Override         public org.elasticsearch.common.recycler.Recycler.V<T> obtain(int sizing) {             synchronized (lock) {                 return super.obtain(sizing).             }         }          @Override         public org.elasticsearch.common.recycler.Recycler.V<T> obtain() {             synchronized (lock) {                 return super.obtain().             }         }          @Override         protected Recycler.V<T> wrap(final Recycler.V<T> delegate) {             return new Recycler.V<T>() {                  @Override                 public void close() {                     synchronized (lock) {                         delegate.close().                     }                 }                  @Override                 public T v() {                     return delegate.v().                 }                  @Override                 public boolean isRecycled() {                     return delegate.isRecycled().                 }             }.         }     }. }
false;;0;9;;int slot() {     final long id = Thread.currentThread().getId().     // don't trust Thread.hashCode to have equiprobable low bits     int slot = (int) BitMixer.mix64(id).     // make positive, otherwise % may return negative numbers     slot &= 0x7FFFFFFF.     slot %= concurrencyLevel.     return slot. }
false;protected;0;4;;@Override protected Recycler<T> getDelegate() {     return recyclers[slot()]. }
false;public;0;6;;@Override public void close() {     for (Recycler<T> recycler : recyclers) {         recycler.close().     } }
true;public,static;2;44;/**  * Create a concurrent implementation that can support concurrent access from  * <code>concurrencyLevel</code> threads with little contention.  */ ;/**  * Create a concurrent implementation that can support concurrent access from  * <code>concurrencyLevel</code> threads with little contention.  */ public static <T> Recycler<T> concurrent(final Recycler.Factory<T> factory, final int concurrencyLevel) {     if (concurrencyLevel < 1) {         throw new IllegalArgumentException("concurrencyLevel must be >= 1").     }     if (concurrencyLevel == 1) {         return locked(factory.build()).     }     return new FilterRecycler<T>() {          private final Recycler<T>[] recyclers.          {             @SuppressWarnings("unchecked")             final Recycler<T>[] recyclers = new Recycler[concurrencyLevel].             this.recyclers = recyclers.             for (int i = 0. i < concurrencyLevel. ++i) {                 recyclers[i] = locked(factory.build()).             }         }          int slot() {             final long id = Thread.currentThread().getId().             // don't trust Thread.hashCode to have equiprobable low bits             int slot = (int) BitMixer.mix64(id).             // make positive, otherwise % may return negative numbers             slot &= 0x7FFFFFFF.             slot %= concurrencyLevel.             return slot.         }          @Override         protected Recycler<T> getDelegate() {             return recyclers[slot()].         }          @Override         public void close() {             for (Recycler<T> recycler : recyclers) {                 recycler.close().             }         }     }. }
false;public,static;1;3;;public static <T> Recycler<T> concurrent(final Recycler.Factory<T> factory) {     return concurrent(factory, Runtime.getRuntime().availableProcessors()). }
