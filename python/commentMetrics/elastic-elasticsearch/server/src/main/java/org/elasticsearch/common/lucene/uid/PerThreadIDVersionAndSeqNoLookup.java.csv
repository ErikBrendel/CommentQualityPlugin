commented;modifiers;parameterAmount;loc;comment;code
true;public;3;40;/**  * Return null if id is not found.  * We pass the {@link LeafReaderContext} as an argument so that things  * still work with reader wrappers that hide some documents while still  * using the same cache key. Otherwise we'd have to disable caching  * entirely for these readers.  */ ;/**  * Return null if id is not found.  * We pass the {@link LeafReaderContext} as an argument so that things  * still work with reader wrappers that hide some documents while still  * using the same cache key. Otherwise we'd have to disable caching  * entirely for these readers.  */ public DocIdAndVersion lookupVersion(BytesRef id, boolean loadSeqNo, LeafReaderContext context) throws IOException {     assert context.reader().getCoreCacheHelper().getKey().equals(readerKey) : "context's reader is not the same as the reader class was initialized on.".     int docID = getDocID(id, context.reader().getLiveDocs()).     if (docID != DocIdSetIterator.NO_MORE_DOCS) {         final NumericDocValues versions = context.reader().getNumericDocValues(VersionFieldMapper.NAME).         if (versions == null) {             throw new IllegalArgumentException("reader misses the [" + VersionFieldMapper.NAME + "] field").         }         if (versions.advanceExact(docID) == false) {             throw new IllegalArgumentException("Document [" + docID + "] misses the [" + VersionFieldMapper.NAME + "] field").         }         final long seqNo.         final long term.         if (loadSeqNo) {             NumericDocValues seqNos = context.reader().getNumericDocValues(SeqNoFieldMapper.NAME).             // remove the null check in 7.0 once we can't read indices with no seq#             if (seqNos != null && seqNos.advanceExact(docID)) {                 seqNo = seqNos.longValue().             } else {                 seqNo = UNASSIGNED_SEQ_NO.             }             NumericDocValues terms = context.reader().getNumericDocValues(SeqNoFieldMapper.PRIMARY_TERM_NAME).             if (terms != null && terms.advanceExact(docID)) {                 term = terms.longValue().             } else {                 term = UNASSIGNED_PRIMARY_TERM.             }         } else {             seqNo = UNASSIGNED_SEQ_NO.             term = UNASSIGNED_PRIMARY_TERM.         }         return new DocIdAndVersion(docID, versions.longValue(), seqNo, term, context.reader(), context.docBase).     } else {         return null.     } }
true;private;2;17;/**  * returns the internal lucene doc id for the given id bytes.  * {@link DocIdSetIterator#NO_MORE_DOCS} is returned if not found  */ ;/**  * returns the internal lucene doc id for the given id bytes.  * {@link DocIdSetIterator#NO_MORE_DOCS} is returned if not found  */ private int getDocID(BytesRef id, Bits liveDocs) throws IOException {     // termsEnum can possibly be null here if this leaf contains only no-ops.     if (termsEnum != null && termsEnum.seekExact(id)) {         int docID = DocIdSetIterator.NO_MORE_DOCS.         // there may be more than one matching docID, in the case of nested docs, so we want the last one:         docsEnum = termsEnum.postings(docsEnum, 0).         for (int d = docsEnum.nextDoc(). d != DocIdSetIterator.NO_MORE_DOCS. d = docsEnum.nextDoc()) {             if (liveDocs != null && liveDocs.get(d) == false) {                 continue.             }             docID = d.         }         return docID.     } else {         return DocIdSetIterator.NO_MORE_DOCS.     } }
true;;2;38;/**  * Return null if id is not found.  */ ;/**  * Return null if id is not found.  */ DocIdAndSeqNo lookupSeqNo(BytesRef id, LeafReaderContext context) throws IOException {     assert context.reader().getCoreCacheHelper().getKey().equals(readerKey) : "context's reader is not the same as the reader class was initialized on.".     // termsEnum can possibly be null here if this leaf contains only no-ops.     if (termsEnum != null && termsEnum.seekExact(id)) {         docsEnum = termsEnum.postings(docsEnum, 0).         final Bits liveDocs = context.reader().getLiveDocs().         DocIdAndSeqNo result = null.         int docID = docsEnum.nextDoc().         if (docID != DocIdSetIterator.NO_MORE_DOCS) {             final NumericDocValues seqNoDV = context.reader().getNumericDocValues(SeqNoFieldMapper.NAME).             for (. docID != DocIdSetIterator.NO_MORE_DOCS. docID = docsEnum.nextDoc()) {                 final long seqNo.                 // remove the null check in 7.0 once we can't read indices with no seq#                 if (seqNoDV != null && seqNoDV.advanceExact(docID)) {                     seqNo = seqNoDV.longValue().                 } else {                     seqNo = UNASSIGNED_SEQ_NO.                 }                 final boolean isLive = (liveDocs == null || liveDocs.get(docID)).                 if (isLive) {                     // This should not be an issue since we no longer use primary term as tier breaker when comparing operations.                     assert result == null || result.seqNo <= seqNo : "the live doc does not have the highest seq_no. live_seq_no=" + seqNo + " < deleted_seq_no=" + result.seqNo.                     return new DocIdAndSeqNo(docID, seqNo, context, isLive).                 }                 if (result == null || result.seqNo < seqNo) {                     result = new DocIdAndSeqNo(docID, seqNo, context, isLive).                 }             }         }         return result.     } else {         return null.     } }
