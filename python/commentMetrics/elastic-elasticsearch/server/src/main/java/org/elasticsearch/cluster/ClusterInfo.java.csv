commented;modifiers;parameterAmount;loc;comment;code
false;public;1;27;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeVInt(this.leastAvailableSpaceUsage.size()).     for (ObjectObjectCursor<String, DiskUsage> c : this.leastAvailableSpaceUsage) {         out.writeString(c.key).         c.value.writeTo(out).     }     out.writeVInt(this.mostAvailableSpaceUsage.size()).     for (ObjectObjectCursor<String, DiskUsage> c : this.mostAvailableSpaceUsage) {         out.writeString(c.key).         c.value.writeTo(out).     }     out.writeVInt(this.shardSizes.size()).     for (ObjectObjectCursor<String, Long> c : this.shardSizes) {         out.writeString(c.key).         if (c.value == null) {             out.writeLong(-1).         } else {             out.writeLong(c.value).         }     }     out.writeVInt(this.routingToDataPath.size()).     for (ObjectObjectCursor<ShardRouting, String> c : this.routingToDataPath) {         c.key.writeTo(out).         out.writeString(c.value).     } }
false;public;2;35;;public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject("nodes").     {         for (ObjectObjectCursor<String, DiskUsage> c : this.leastAvailableSpaceUsage) {             builder.startObject(c.key).             {                 // node                 builder.field("node_name", c.value.getNodeName()).                 builder.startObject("least_available").                 {                     c.value.toShortXContent(builder).                 }                 // end "least_available"                 builder.endObject().                 builder.startObject("most_available").                 {                     DiskUsage most = this.mostAvailableSpaceUsage.get(c.key).                     if (most != null) {                         most.toShortXContent(builder).                     }                 }                 // end "most_available"                 builder.endObject().             }             // end $nodename             builder.endObject().         }     }     // end "nodes"     builder.endObject().     builder.startObject("shard_sizes").     {         for (ObjectObjectCursor<String, Long> c : this.shardSizes) {             builder.humanReadableField(c.key + "_bytes", c.key, new ByteSizeValue(c.value)).         }     }     // end "shard_sizes"     builder.endObject().     builder.startObject("shard_paths").     {         for (ObjectObjectCursor<ShardRouting, String> c : this.routingToDataPath) {             builder.field(c.key.toString(), c.value).         }     }     // end "shard_paths"     builder.endObject().     return builder. }
true;public;0;3;/**  * Returns a node id to disk usage mapping for the path that has the least available space on the node.  */ ;/**  * Returns a node id to disk usage mapping for the path that has the least available space on the node.  */ public ImmutableOpenMap<String, DiskUsage> getNodeLeastAvailableDiskUsages() {     return this.leastAvailableSpaceUsage. }
true;public;0;3;/**  * Returns a node id to disk usage mapping for the path that has the most available space on the node.  */ ;/**  * Returns a node id to disk usage mapping for the path that has the most available space on the node.  */ public ImmutableOpenMap<String, DiskUsage> getNodeMostAvailableDiskUsages() {     return this.mostAvailableSpaceUsage. }
true;public;1;3;/**  * Returns the shard size for the given shard routing or <code>null</code> it that metric is not available.  */ ;/**  * Returns the shard size for the given shard routing or <code>null</code> it that metric is not available.  */ public Long getShardSize(ShardRouting shardRouting) {     return shardSizes.get(shardIdentifierFromRouting(shardRouting)). }
true;public;1;3;/**  * Returns the nodes absolute data-path the given shard is allocated on or <code>null</code> if the information is not available.  */ ;/**  * Returns the nodes absolute data-path the given shard is allocated on or <code>null</code> if the information is not available.  */ public String getDataPath(ShardRouting shardRouting) {     return routingToDataPath.get(shardRouting). }
true;public;2;4;/**  * Returns the shard size for the given shard routing or <code>defaultValue</code> it that metric is not available.  */ ;/**  * Returns the shard size for the given shard routing or <code>defaultValue</code> it that metric is not available.  */ public long getShardSize(ShardRouting shardRouting, long defaultValue) {     Long shardSize = getShardSize(shardRouting).     return shardSize == null ? defaultValue : shardSize. }
true;static;1;3;/**  * Method that incorporates the ShardId for the shard into a string that  * includes a 'p' or 'r' depending on whether the shard is a primary.  */ ;/**  * Method that incorporates the ShardId for the shard into a string that  * includes a 'p' or 'r' depending on whether the shard is a primary.  */ static String shardIdentifierFromRouting(ShardRouting shardRouting) {     return shardRouting.shardId().toString() + "[" + (shardRouting.primary() ? "p" : "r") + "]". }
