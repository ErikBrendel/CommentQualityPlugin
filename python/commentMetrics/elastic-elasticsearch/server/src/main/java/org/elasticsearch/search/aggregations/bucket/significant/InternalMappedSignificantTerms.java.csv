commented;modifiers;parameterAmount;loc;comment;code
false;protected,final;1;8;;@Override protected final void writeTermTypeInfoTo(StreamOutput out) throws IOException {     out.writeNamedWriteable(format).     out.writeVLong(subsetSize).     out.writeVLong(supersetSize).     out.writeNamedWriteable(significanceHeuristic).     out.writeList(buckets). }
false;public;0;4;;@Override public Iterator<SignificantTerms.Bucket> iterator() {     return buckets.stream().map(bucket -> (SignificantTerms.Bucket) bucket).collect(Collectors.toList()).iterator(). }
false;public;0;4;;@Override public List<B> getBuckets() {     return buckets. }
false;public;1;7;;@Override public B getBucketByKey(String term) {     if (bucketMap == null) {         bucketMap = buckets.stream().collect(Collectors.toMap(InternalSignificantTerms.Bucket::getKeyAsString, Function.identity())).     }     return bucketMap.get(term). }
false;protected;0;4;;@Override protected long getSubsetSize() {     return subsetSize. }
false;protected;0;4;;@Override protected long getSupersetSize() {     return supersetSize. }
false;protected;0;4;;@Override protected SignificanceHeuristic getSignificanceHeuristic() {     return significanceHeuristic. }
false;protected;1;11;;@Override protected boolean doEquals(Object obj) {     InternalMappedSignificantTerms<?, ?> that = (InternalMappedSignificantTerms<?, ?>) obj.     return super.doEquals(obj) && Objects.equals(format, that.format) && subsetSize == that.subsetSize && supersetSize == that.supersetSize && Objects.equals(significanceHeuristic, that.significanceHeuristic) && Objects.equals(buckets, that.buckets) && Objects.equals(bucketMap, that.bucketMap). }
false;protected;0;4;;@Override protected int doHashCode() {     return Objects.hash(super.doHashCode(), format, subsetSize, supersetSize, significanceHeuristic, buckets, bucketMap). }
false;public;2;15;;@Override public XContentBuilder doXContentBody(XContentBuilder builder, Params params) throws IOException {     builder.field(CommonFields.DOC_COUNT.getPreferredName(), subsetSize).     builder.field(BG_COUNT, supersetSize).     builder.startArray(CommonFields.BUCKETS.getPreferredName()).     for (Bucket bucket : buckets) {         // and I end up with buckets that contravene the user's min_doc_count criteria in my reducer         if (bucket.subsetDf >= minDocCount) {             bucket.toXContent(builder, params).         }     }     builder.endArray().     return builder. }
