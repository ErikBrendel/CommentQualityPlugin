commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public void onNodeDisconnected(DiscoveryNode node) {     handleDisconnectedNode(node). }
false;public;0;4;;public DiscoveryNode leader() {     CheckScheduler checkScheduler = currentChecker.get().     return checkScheduler == null ? null : checkScheduler.leader. }
true;public;1;16;/**  * Starts and / or stops a leader checker for the given leader. Should only be called after successfully joining this leader.  *  * @param leader the node to be checked as leader, or null if checks should be disabled  */ ;/**  * Starts and / or stops a leader checker for the given leader. Should only be called after successfully joining this leader.  *  * @param leader the node to be checked as leader, or null if checks should be disabled  */ public void updateLeader(@Nullable final DiscoveryNode leader) {     assert transportService.getLocalNode().equals(leader) == false.     final CheckScheduler checkScheduler.     if (leader != null) {         checkScheduler = new CheckScheduler(leader).     } else {         checkScheduler = null.     }     CheckScheduler previousChecker = currentChecker.getAndSet(checkScheduler).     if (previousChecker != null) {         previousChecker.close().     }     if (checkScheduler != null) {         checkScheduler.handleWakeUp().     } }
true;public;1;4;/**  * Update the "known" discovery nodes. Should be called on the leader before a new cluster state is published to reflect the new  * publication targets, and also called if a leader becomes a non-leader.  * TODO if heartbeats can make nodes become followers then this needs to be called before a heartbeat is sent to a new node too.  * <p>  * isLocalNodeElectedMaster() should reflect whether this node is a leader, and nodeExists()  * should indicate whether nodes are known publication targets or not.  */ ;/**  * Update the "known" discovery nodes. Should be called on the leader before a new cluster state is published to reflect the new  * publication targets, and also called if a leader becomes a non-leader.  * TODO if heartbeats can make nodes become followers then this needs to be called before a heartbeat is sent to a new node too.  * <p>  * isLocalNodeElectedMaster() should reflect whether this node is a leader, and nodeExists()  * should indicate whether nodes are known publication targets or not.  */ public void setCurrentNodes(DiscoveryNodes discoveryNodes) {     logger.trace("setCurrentNodes: {}", discoveryNodes).     this.discoveryNodes = discoveryNodes. }
true;;0;3;// For assertions ;// For assertions boolean currentNodeIsMaster() {     return discoveryNodes.isLocalNodeElectedMaster(). }
false;private;1;14;;private void handleLeaderCheck(LeaderCheckRequest request) {     final DiscoveryNodes discoveryNodes = this.discoveryNodes.     assert discoveryNodes != null.     if (discoveryNodes.isLocalNodeElectedMaster() == false) {         logger.debug("non-master handling {}", request).         throw new CoordinationStateRejectedException("non-leader rejecting leader check").     } else if (discoveryNodes.nodeExists(request.getSender()) == false) {         logger.debug("leader check from unknown node: {}", request).         throw new CoordinationStateRejectedException("leader check from unknown node").     } else {         logger.trace("handling {}", request).     } }
false;private;1;8;;private void handleDisconnectedNode(DiscoveryNode discoveryNode) {     CheckScheduler checkScheduler = currentChecker.get().     if (checkScheduler != null) {         checkScheduler.handleDisconnectedNode(discoveryNode).     } else {         logger.trace("disconnect event ignored for {}, no check scheduler", discoveryNode).     } }
false;public;0;8;;@Override public void close() {     if (isClosed.compareAndSet(false, true) == false) {         logger.trace("already closed, doing nothing").     } else {         logger.debug("closed").     } }
false;public;1;4;;@Override public Empty read(StreamInput in) {     return Empty.INSTANCE. }
false;public;1;10;;@Override public void handleResponse(Empty response) {     if (isClosed.get()) {         logger.debug("closed check scheduler received a response, doing nothing").         return.     }     failureCountSinceLastSuccess.set(0).     // logs trace message indicating success     scheduleNextWakeUp(). }
false;public;1;25;;@Override public void handleException(TransportException exp) {     if (isClosed.get()) {         logger.debug("closed check scheduler received a response, doing nothing").         return.     }     if (exp instanceof ConnectTransportException || exp.getCause() instanceof ConnectTransportException) {         logger.debug(new ParameterizedMessage("leader [{}] disconnected, failing immediately", leader), exp).         leaderFailed().         return.     }     long failureCount = failureCountSinceLastSuccess.incrementAndGet().     if (failureCount >= leaderCheckRetryCount) {         logger.debug(new ParameterizedMessage("{} consecutive failures (limit [{}] is {}) so leader [{}] has failed", failureCount, LEADER_CHECK_RETRY_COUNT_SETTING.getKey(), leaderCheckRetryCount, leader), exp).         leaderFailed().         return.     }     logger.debug(new ParameterizedMessage("{} consecutive failures (limit [{}] is {}) with leader [{}]", failureCount, LEADER_CHECK_RETRY_COUNT_SETTING.getKey(), leaderCheckRetryCount, leader), exp).     scheduleNextWakeUp(). }
false;public;0;4;;@Override public String executor() {     return Names.SAME. }
false;;0;75;;void handleWakeUp() {     if (isClosed.get()) {         logger.trace("closed check scheduler woken up, doing nothing").         return.     }     logger.trace("checking {} with [{}] = {}", leader, LEADER_CHECK_TIMEOUT_SETTING.getKey(), leaderCheckTimeout).     final String actionName.     final TransportRequest transportRequest.     if (Coordinator.isZen1Node(leader)) {         actionName = MasterFaultDetection.MASTER_PING_ACTION_NAME.         transportRequest = new MasterFaultDetection.MasterPingRequest(transportService.getLocalNode(), leader, ClusterName.CLUSTER_NAME_SETTING.get(settings)).     } else {         actionName = LEADER_CHECK_ACTION_NAME.         transportRequest = new LeaderCheckRequest(transportService.getLocalNode()).     }     // TODO lag detection:     // In the PoC, the leader sent its current version to the follower in the response to a LeaderCheck, so the follower     // could detect if it was lagging. We'd prefer this to be implemented on the leader, so the response is just     // TransportResponse.Empty here.     transportService.sendRequest(leader, actionName, transportRequest, TransportRequestOptions.builder().withTimeout(leaderCheckTimeout).withType(Type.PING).build(), new TransportResponseHandler<TransportResponse.Empty>() {          @Override         public Empty read(StreamInput in) {             return Empty.INSTANCE.         }          @Override         public void handleResponse(Empty response) {             if (isClosed.get()) {                 logger.debug("closed check scheduler received a response, doing nothing").                 return.             }             failureCountSinceLastSuccess.set(0).             // logs trace message indicating success             scheduleNextWakeUp().         }          @Override         public void handleException(TransportException exp) {             if (isClosed.get()) {                 logger.debug("closed check scheduler received a response, doing nothing").                 return.             }             if (exp instanceof ConnectTransportException || exp.getCause() instanceof ConnectTransportException) {                 logger.debug(new ParameterizedMessage("leader [{}] disconnected, failing immediately", leader), exp).                 leaderFailed().                 return.             }             long failureCount = failureCountSinceLastSuccess.incrementAndGet().             if (failureCount >= leaderCheckRetryCount) {                 logger.debug(new ParameterizedMessage("{} consecutive failures (limit [{}] is {}) so leader [{}] has failed", failureCount, LEADER_CHECK_RETRY_COUNT_SETTING.getKey(), leaderCheckRetryCount, leader), exp).                 leaderFailed().                 return.             }             logger.debug(new ParameterizedMessage("{} consecutive failures (limit [{}] is {}) with leader [{}]", failureCount, LEADER_CHECK_RETRY_COUNT_SETTING.getKey(), leaderCheckRetryCount, leader), exp).             scheduleNextWakeUp().         }          @Override         public String executor() {             return Names.SAME.         }     }). }
false;;0;7;;void leaderFailed() {     if (isClosed.compareAndSet(false, true)) {         transportService.getThreadPool().generic().execute(onLeaderFailure).     } else {         logger.trace("already closed, not failing leader").     } }
false;;1;5;;void handleDisconnectedNode(DiscoveryNode discoveryNode) {     if (discoveryNode.equals(leader)) {         leaderFailed().     } }
false;public;0;4;;@Override public void run() {     handleWakeUp(). }
false;public;0;4;;@Override public String toString() {     return "scheduled check of leader " + leader. }
false;private;0;14;;private void scheduleNextWakeUp() {     logger.trace("scheduling next check of {} for [{}] = {}", leader, LEADER_CHECK_INTERVAL_SETTING.getKey(), leaderCheckInterval).     transportService.getThreadPool().schedule(new Runnable() {          @Override         public void run() {             handleWakeUp().         }          @Override         public String toString() {             return "scheduled check of leader " + leader.         }     }, leaderCheckInterval, Names.SAME). }
false;public;1;5;;@Override public void writeTo(final StreamOutput out) throws IOException {     super.writeTo(out).     sender.writeTo(out). }
false;public;0;3;;public DiscoveryNode getSender() {     return sender. }
false;public;1;7;;@Override public boolean equals(final Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     final LeaderCheckRequest that = (LeaderCheckRequest) o.     return Objects.equals(sender, that.sender). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(sender). }
false;public;0;6;;@Override public String toString() {     return "LeaderCheckRequest{" + "sender=" + sender + '}'. }
