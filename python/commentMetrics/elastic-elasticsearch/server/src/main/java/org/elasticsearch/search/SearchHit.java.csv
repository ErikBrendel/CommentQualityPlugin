commented;modifiers;parameterAmount;loc;comment;code
false;public;1;55;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeFloat(score).     out.writeOptionalText(id).     out.writeOptionalText(type).     out.writeOptionalWriteable(nestedIdentity).     out.writeLong(version).     if (out.getVersion().onOrAfter(Version.V_6_7_0)) {         out.writeZLong(seqNo).         out.writeVLong(primaryTerm).     }     out.writeBytesReference(source).     if (explanation == null) {         out.writeBoolean(false).     } else {         out.writeBoolean(true).         writeExplanation(out, explanation).     }     if (fields == null) {         out.writeVInt(0).     } else {         out.writeVInt(fields.size()).         for (DocumentField hitField : getFields().values()) {             hitField.writeTo(out).         }     }     if (highlightFields == null) {         out.writeVInt(0).     } else {         out.writeVInt(highlightFields.size()).         for (HighlightField highlightField : highlightFields.values()) {             highlightField.writeTo(out).         }     }     sortValues.writeTo(out).     if (matchedQueries.length == 0) {         out.writeVInt(0).     } else {         out.writeVInt(matchedQueries.length).         for (String matchedFilter : matchedQueries) {             out.writeString(matchedFilter).         }     }     out.writeOptionalWriteable(shard).     if (innerHits == null) {         out.writeVInt(0).     } else {         out.writeVInt(innerHits.size()).         for (Map.Entry<String, SearchHits> entry : innerHits.entrySet()) {             out.writeString(entry.getKey()).             entry.getValue().writeTo(out).         }     } }
false;public;0;3;;public int docId() {     return this.docId. }
false;public;1;3;;public void score(float score) {     this.score = score. }
true;public;0;3;/**  * The score.  */ ;/**  * The score.  */ public float getScore() {     return this.score. }
false;public;1;3;;public void version(long version) {     this.version = version. }
true;public;0;3;/**  * The version of the hit.  */ ;/**  * The version of the hit.  */ public long getVersion() {     return this.version. }
false;public;1;3;;public void setSeqNo(long seqNo) {     this.seqNo = seqNo. }
false;public;1;3;;public void setPrimaryTerm(long primaryTerm) {     this.primaryTerm = primaryTerm. }
true;public;0;3;/**  * returns the sequence number of the last modification to the document, or {@link SequenceNumbers#UNASSIGNED_SEQ_NO}  * if not requested.  */ ;/**  * returns the sequence number of the last modification to the document, or {@link SequenceNumbers#UNASSIGNED_SEQ_NO}  * if not requested.  */ public long getSeqNo() {     return this.seqNo. }
true;public;0;3;/**  * returns the primary term of the last modification to the document, or {@link SequenceNumbers#UNASSIGNED_PRIMARY_TERM}  * if not requested.  */ ;/**  * returns the primary term of the last modification to the document, or {@link SequenceNumbers#UNASSIGNED_PRIMARY_TERM}  * if not requested.  */ public long getPrimaryTerm() {     return this.primaryTerm. }
true;public;0;3;/**  * The index of the hit.  */ ;/**  * The index of the hit.  */ public String getIndex() {     return this.index. }
true;public;0;3;/**  * The id of the document.  */ ;/**  * The id of the document.  */ public String getId() {     return id != null ? id.string() : null. }
true;public;0;4;/**  * The type of the document.  *  * @deprecated Types are in the process of being removed. Instead of using a type, prefer to  * filter on a field on the document.  */ ;/**  * The type of the document.  *  * @deprecated Types are in the process of being removed. Instead of using a type, prefer to  * filter on a field on the document.  */ @Deprecated public String getType() {     return type != null ? type.string() : null. }
true;public;0;3;/**  * If this is a nested hit then nested reference information is returned otherwise <code>null</code> is returned.  */ ;/**  * If this is a nested hit then nested reference information is returned otherwise <code>null</code> is returned.  */ public NestedIdentity getNestedIdentity() {     return nestedIdentity. }
true;public;0;12;/**  * Returns bytes reference, also uncompress the source if needed.  */ ;/**  * Returns bytes reference, also uncompress the source if needed.  */ public BytesReference getSourceRef() {     if (this.source == null) {         return null.     }     try {         this.source = CompressorFactory.uncompressIfNeeded(this.source).         return this.source.     } catch (IOException e) {         throw new ElasticsearchParseException("failed to decompress source", e).     } }
true;public;1;5;/**  * Sets representation, might be compressed....  */ ;/**  * Sets representation, might be compressed....  */ public SearchHit sourceRef(BytesReference source) {     this.source = source.     this.sourceAsMap = null.     return this. }
true;public;0;3;/**  * Is the source available or not. A source with no fields will return true. This will return false if {@code fields} doesn't contain  * {@code _source} or if source is disabled in the mapping.  */ ;/**  * Is the source available or not. A source with no fields will return true. This will return false if {@code fields} doesn't contain  * {@code _source} or if source is disabled in the mapping.  */ public boolean hasSource() {     return source != null. }
true;public;0;10;/**  * The source of the document as string (can be {@code null}).  */ ;/**  * The source of the document as string (can be {@code null}).  */ public String getSourceAsString() {     if (source == null) {         return null.     }     try {         return XContentHelper.convertToJson(getSourceRef(), false).     } catch (IOException e) {         throw new ElasticsearchParseException("failed to convert source to a json string").     } }
true;public;0;11;/**  * The source of the document as a map (can be {@code null}).  */ ;/**  * The source of the document as a map (can be {@code null}).  */ public Map<String, Object> getSourceAsMap() {     if (source == null) {         return null.     }     if (sourceAsMap != null) {         return sourceAsMap.     }     sourceAsMap = SourceLookup.sourceAsMap(source).     return sourceAsMap. }
false;public;0;4;;@Override public Iterator<DocumentField> iterator() {     return fields.values().iterator(). }
true;public;1;3;/**  * The hit field matching the given field name.  */ ;/**  * The hit field matching the given field name.  */ public DocumentField field(String fieldName) {     return getFields().get(fieldName). }
true;public;0;3;/**  * A map of hit fields (from field name to hit fields) if additional fields  * were required to be loaded.  */ ;/**  * A map of hit fields (from field name to hit fields) if additional fields  * were required to be loaded.  */ public Map<String, DocumentField> getFields() {     return fields == null ? emptyMap() : fields. }
true;public;0;3;// returns the fields without handling null cases ;// returns the fields without handling null cases public Map<String, DocumentField> fieldsOrNull() {     return fields. }
false;public;1;3;;public void fields(Map<String, DocumentField> fields) {     this.fields = fields. }
true;public;0;3;/**  * A map of highlighted fields.  */ ;/**  * A map of highlighted fields.  */ public Map<String, HighlightField> getHighlightFields() {     return highlightFields == null ? emptyMap() : highlightFields. }
false;public;1;3;;public void highlightFields(Map<String, HighlightField> highlightFields) {     this.highlightFields = highlightFields. }
false;public;2;3;;public void sortValues(Object[] sortValues, DocValueFormat[] sortValueFormats) {     sortValues(new SearchSortValues(sortValues, sortValueFormats)). }
false;public;1;3;;public void sortValues(SearchSortValues sortValues) {     this.sortValues = sortValues. }
true;public;0;3;/**  * An array of the (formatted) sort values used.  */ ;/**  * An array of the (formatted) sort values used.  */ public Object[] getSortValues() {     return sortValues.getFormattedSortValues(). }
true;public;0;3;/**  * An array of the (raw) sort values used.  */ ;/**  * An array of the (raw) sort values used.  */ public Object[] getRawSortValues() {     return sortValues.getRawSortValues(). }
true;public;0;3;/**  * If enabled, the explanation of the search hit.  */ ;/**  * If enabled, the explanation of the search hit.  */ public Explanation getExplanation() {     return explanation. }
false;public;1;3;;public void explanation(Explanation explanation) {     this.explanation = explanation. }
true;public;0;3;/**  * The shard of the search hit.  */ ;/**  * The shard of the search hit.  */ public SearchShardTarget getShard() {     return shard. }
false;public;1;15;;public void shard(SearchShardTarget target) {     if (innerHits != null) {         for (SearchHits innerHits : innerHits.values()) {             for (SearchHit innerHit : innerHits) {                 innerHit.shard(target).             }         }     }     this.shard = target.     if (target != null) {         this.index = target.getIndex().         this.clusterAlias = target.getClusterAlias().     } }
true;public;0;3;/**  * Returns the cluster alias this hit comes from or null if it comes from a local cluster  */ ;/**  * Returns the cluster alias this hit comes from or null if it comes from a local cluster  */ public String getClusterAlias() {     return clusterAlias. }
false;public;1;3;;public void matchedQueries(String[] matchedQueries) {     this.matchedQueries = matchedQueries. }
true;public;0;3;/**  * The set of query and filter names the query matched with. Mainly makes sense for compound filters and queries.  */ ;/**  * The set of query and filter names the query matched with. Mainly makes sense for compound filters and queries.  */ public String[] getMatchedQueries() {     return this.matchedQueries. }
true;public;0;3;/**  * @return Inner hits or <code>null</code> if there are none  */ ;/**  * @return Inner hits or <code>null</code> if there are none  */ public Map<String, SearchHits> getInnerHits() {     return innerHits. }
false;public;1;3;;public void setInnerHits(Map<String, SearchHits> innerHits) {     this.innerHits = innerHits. }
false;public;2;7;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     toInnerXContent(builder, params).     builder.endObject().     return builder. }
true;public;2;97;// public because we render hit as part of completion suggestion option ;// public because we render hit as part of completion suggestion option public XContentBuilder toInnerXContent(XContentBuilder builder, Params params) throws IOException {     List<DocumentField> metaFields = new ArrayList<>().     List<DocumentField> otherFields = new ArrayList<>().     if (fields != null && !fields.isEmpty()) {         for (DocumentField field : fields.values()) {             if (field.getValues().isEmpty()) {                 continue.             }             if (field.isMetadataField()) {                 metaFields.add(field).             } else {                 otherFields.add(field).             }         }     }     // Even if this was included in the inner_hit hits this would be the same, so better leave it out.     if (getExplanation() != null && shard != null) {         builder.field(Fields._SHARD, shard.getShardId()).         builder.field(Fields._NODE, shard.getNodeIdText()).     }     if (index != null) {         builder.field(Fields._INDEX, RemoteClusterAware.buildRemoteIndexName(clusterAlias, index)).     }     if (type != null) {         builder.field(Fields._TYPE, type).     }     if (id != null) {         builder.field(Fields._ID, id).     }     if (nestedIdentity != null) {         nestedIdentity.toXContent(builder, params).     }     if (version != -1) {         builder.field(Fields._VERSION, version).     }     if (seqNo != SequenceNumbers.UNASSIGNED_SEQ_NO) {         builder.field(Fields._SEQ_NO, seqNo).         builder.field(Fields._PRIMARY_TERM, primaryTerm).     }     if (Float.isNaN(score)) {         builder.nullField(Fields._SCORE).     } else {         builder.field(Fields._SCORE, score).     }     for (DocumentField field : metaFields) {         // TODO: can we avoid having an exception here?         if (field.getName().equals(IgnoredFieldMapper.NAME)) {             builder.field(field.getName(), field.getValues()).         } else {             builder.field(field.getName(), field.<Object>getValue()).         }     }     if (source != null) {         XContentHelper.writeRawField(SourceFieldMapper.NAME, source, builder, params).     }     if (!otherFields.isEmpty()) {         builder.startObject(Fields.FIELDS).         for (DocumentField field : otherFields) {             field.toXContent(builder, params).         }         builder.endObject().     }     if (highlightFields != null && !highlightFields.isEmpty()) {         builder.startObject(Fields.HIGHLIGHT).         for (HighlightField field : highlightFields.values()) {             field.toXContent(builder, params).         }         builder.endObject().     }     sortValues.toXContent(builder, params).     if (matchedQueries.length > 0) {         builder.startArray(Fields.MATCHED_QUERIES).         for (String matchedFilter : matchedQueries) {             builder.value(matchedFilter).         }         builder.endArray().     }     if (getExplanation() != null) {         builder.field(Fields._EXPLANATION).         buildExplanation(builder, getExplanation()).     }     if (innerHits != null) {         builder.startObject(Fields.INNER_HITS).         for (Map.Entry<String, SearchHits> entry : innerHits.entrySet()) {             builder.startObject(entry.getKey()).             entry.getValue().toXContent(builder, params).             builder.endObject().         }         builder.endObject().     }     return builder. }
false;public,static;1;3;;public static SearchHit fromXContent(XContentParser parser) {     return createFromMap(MAP_PARSER.apply(parser, null)). }
false;public,static;1;32;;public static void declareInnerHitsParseFields(ObjectParser<Map<String, Object>, Void> parser) {     declareMetaDataFields(parser).     parser.declareString((map, value) -> map.put(Fields._TYPE, new Text(value)), new ParseField(Fields._TYPE)).     parser.declareString((map, value) -> map.put(Fields._INDEX, value), new ParseField(Fields._INDEX)).     parser.declareString((map, value) -> map.put(Fields._ID, value), new ParseField(Fields._ID)).     parser.declareString((map, value) -> map.put(Fields._NODE, value), new ParseField(Fields._NODE)).     parser.declareField((map, value) -> map.put(Fields._SCORE, value), SearchHit::parseScore, new ParseField(Fields._SCORE), ValueType.FLOAT_OR_NULL).     parser.declareLong((map, value) -> map.put(Fields._VERSION, value), new ParseField(Fields._VERSION)).     parser.declareLong((map, value) -> map.put(Fields._SEQ_NO, value), new ParseField(Fields._SEQ_NO)).     parser.declareLong((map, value) -> map.put(Fields._PRIMARY_TERM, value), new ParseField(Fields._PRIMARY_TERM)).     parser.declareField((map, value) -> map.put(Fields._SHARD, value), (p, c) -> ShardId.fromString(p.text()), new ParseField(Fields._SHARD), ValueType.STRING).     parser.declareObject((map, value) -> map.put(SourceFieldMapper.NAME, value), (p, c) -> parseSourceBytes(p), new ParseField(SourceFieldMapper.NAME)).     parser.declareObject((map, value) -> map.put(Fields.HIGHLIGHT, value), (p, c) -> parseHighlightFields(p), new ParseField(Fields.HIGHLIGHT)).     parser.declareObject((map, value) -> {         Map<String, DocumentField> fieldMap = get(Fields.FIELDS, map, new HashMap<String, DocumentField>()).         fieldMap.putAll(value).         map.put(Fields.FIELDS, fieldMap).     }, (p, c) -> parseFields(p), new ParseField(Fields.FIELDS)).     parser.declareObject((map, value) -> map.put(Fields._EXPLANATION, value), (p, c) -> parseExplanation(p), new ParseField(Fields._EXPLANATION)).     parser.declareObject((map, value) -> map.put(NestedIdentity._NESTED, value), NestedIdentity::fromXContent, new ParseField(NestedIdentity._NESTED)).     parser.declareObject((map, value) -> map.put(Fields.INNER_HITS, value), (p, c) -> parseInnerHits(p), new ParseField(Fields.INNER_HITS)).     parser.declareStringArray((map, list) -> map.put(Fields.MATCHED_QUERIES, list), new ParseField(Fields.MATCHED_QUERIES)).     parser.declareField((map, list) -> map.put(Fields.SORT, list), SearchSortValues::fromXContent, new ParseField(Fields.SORT), ValueType.OBJECT_ARRAY). }
false;public,static;1;42;;public static SearchHit createFromMap(Map<String, Object> values) {     String id = get(Fields._ID, values, null).     Text type = get(Fields._TYPE, values, null).     NestedIdentity nestedIdentity = get(NestedIdentity._NESTED, values, null).     Map<String, DocumentField> fields = get(Fields.FIELDS, values, Collections.emptyMap()).     SearchHit searchHit = new SearchHit(-1, id, type, nestedIdentity, fields).     String index = get(Fields._INDEX, values, null).     String clusterAlias = null.     if (index != null) {         int indexOf = index.indexOf(RemoteClusterAware.REMOTE_CLUSTER_INDEX_SEPARATOR).         if (indexOf > 0) {             clusterAlias = index.substring(0, indexOf).             index = index.substring(indexOf + 1).         }     }     ShardId shardId = get(Fields._SHARD, values, null).     String nodeId = get(Fields._NODE, values, null).     if (shardId != null && nodeId != null) {         assert shardId.getIndexName().equals(index).         searchHit.shard(new SearchShardTarget(nodeId, shardId, clusterAlias, OriginalIndices.NONE)).     } else {         // these fields get set anyways when setting the shard target,         // but we set them explicitly when we don't have enough info to rebuild the shard target         searchHit.index = index.         searchHit.clusterAlias = clusterAlias.     }     searchHit.score(get(Fields._SCORE, values, DEFAULT_SCORE)).     searchHit.version(get(Fields._VERSION, values, -1L)).     searchHit.setSeqNo(get(Fields._SEQ_NO, values, SequenceNumbers.UNASSIGNED_SEQ_NO)).     searchHit.setPrimaryTerm(get(Fields._PRIMARY_TERM, values, SequenceNumbers.UNASSIGNED_PRIMARY_TERM)).     searchHit.sortValues(get(Fields.SORT, values, SearchSortValues.EMPTY)).     searchHit.highlightFields(get(Fields.HIGHLIGHT, values, null)).     searchHit.sourceRef(get(SourceFieldMapper.NAME, values, null)).     searchHit.explanation(get(Fields._EXPLANATION, values, null)).     searchHit.setInnerHits(get(Fields.INNER_HITS, values, null)).     List<String> matchedQueries = get(Fields.MATCHED_QUERIES, values, null).     if (matchedQueries != null) {         searchHit.matchedQueries(matchedQueries.toArray(new String[0])).     }     return searchHit. }
false;private,static;3;4;;@SuppressWarnings("unchecked") private static <T> T get(String key, Map<String, Object> map, T defaultValue) {     return (T) map.getOrDefault(key, defaultValue). }
false;private,static;1;7;;private static float parseScore(XContentParser parser) throws IOException {     if (parser.currentToken() == XContentParser.Token.VALUE_NUMBER || parser.currentToken() == XContentParser.Token.VALUE_STRING) {         return parser.floatValue().     } else {         return Float.NaN.     } }
false;private,static;1;9;;private static BytesReference parseSourceBytes(XContentParser parser) throws IOException {     try (XContentBuilder builder = XContentBuilder.builder(parser.contentType().xContent())) {         // the original document gets slightly modified: whitespaces or         // pretty printing are not preserved,         // it all depends on the current builder settings         builder.copyCurrentStructure(parser).         return BytesReference.bytes(builder).     } }
true;private,static;1;25;/**  * we need to declare parse fields for each metadata field, except for _ID, _INDEX and _TYPE which are  * handled individually. All other fields are parsed to an entry in the fields map  */ ;/**  * we need to declare parse fields for each metadata field, except for _ID, _INDEX and _TYPE which are  * handled individually. All other fields are parsed to an entry in the fields map  */ private static void declareMetaDataFields(ObjectParser<Map<String, Object>, Void> parser) {     for (String metadatafield : MapperService.getAllMetaFields()) {         if (metadatafield.equals(Fields._ID) == false && metadatafield.equals(Fields._INDEX) == false && metadatafield.equals(Fields._TYPE) == false) {             if (metadatafield.equals(IgnoredFieldMapper.NAME)) {                 parser.declareObjectArray((map, list) -> {                     @SuppressWarnings("unchecked")                     Map<String, DocumentField> fieldMap = (Map<String, DocumentField>) map.computeIfAbsent(Fields.FIELDS, v -> new HashMap<String, DocumentField>()).                     DocumentField field = new DocumentField(metadatafield, list).                     fieldMap.put(field.getName(), field).                 }, (p, c) -> parseFieldsValue(p), new ParseField(metadatafield)).             } else {                 parser.declareField((map, field) -> {                     @SuppressWarnings("unchecked")                     Map<String, DocumentField> fieldMap = (Map<String, DocumentField>) map.computeIfAbsent(Fields.FIELDS, v -> new HashMap<String, DocumentField>()).                     fieldMap.put(field.getName(), field).                 }, (p, c) -> new DocumentField(metadatafield, Collections.singletonList(parseFieldsValue(p))), new ParseField(metadatafield), ValueType.VALUE).             }         }     } }
false;private,static;1;8;;private static Map<String, DocumentField> parseFields(XContentParser parser) throws IOException {     Map<String, DocumentField> fields = new HashMap<>().     while (parser.nextToken() != XContentParser.Token.END_OBJECT) {         DocumentField field = DocumentField.fromXContent(parser).         fields.put(field.getName(), field).     }     return fields. }
false;private,static;1;12;;private static Map<String, SearchHits> parseInnerHits(XContentParser parser) throws IOException {     Map<String, SearchHits> innerHits = new HashMap<>().     while ((parser.nextToken()) != XContentParser.Token.END_OBJECT) {         ensureExpectedToken(XContentParser.Token.FIELD_NAME, parser.currentToken(), parser::getTokenLocation).         String name = parser.currentName().         ensureExpectedToken(Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation).         ensureFieldName(parser, parser.nextToken(), SearchHits.Fields.HITS).         innerHits.put(name, SearchHits.fromXContent(parser)).         ensureExpectedToken(XContentParser.Token.END_OBJECT, parser.nextToken(), parser::getTokenLocation).     }     return innerHits. }
false;private,static;1;8;;private static Map<String, HighlightField> parseHighlightFields(XContentParser parser) throws IOException {     Map<String, HighlightField> highlightFields = new HashMap<>().     while ((parser.nextToken()) != XContentParser.Token.END_OBJECT) {         HighlightField highlightField = HighlightField.fromXContent(parser).         highlightFields.put(highlightField.getName(), highlightField).     }     return highlightFields. }
false;private,static;1;31;;private static Explanation parseExplanation(XContentParser parser) throws IOException {     ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.currentToken(), parser::getTokenLocation).     XContentParser.Token token.     Float value = null.     String description = null.     List<Explanation> details = new ArrayList<>().     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         ensureExpectedToken(XContentParser.Token.FIELD_NAME, token, parser::getTokenLocation).         String currentFieldName = parser.currentName().         token = parser.nextToken().         if (Fields.VALUE.equals(currentFieldName)) {             value = parser.floatValue().         } else if (Fields.DESCRIPTION.equals(currentFieldName)) {             description = parser.textOrNull().         } else if (Fields.DETAILS.equals(currentFieldName)) {             ensureExpectedToken(XContentParser.Token.START_ARRAY, token, parser::getTokenLocation).             while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {                 details.add(parseExplanation(parser)).             }         } else {             parser.skipChildren().         }     }     if (value == null) {         throw new ParsingException(parser.getTokenLocation(), "missing explanation value").     }     if (description == null) {         throw new ParsingException(parser.getTokenLocation(), "missing explanation description").     }     return Explanation.match(value, description, details). }
false;private;2;14;;private void buildExplanation(XContentBuilder builder, Explanation explanation) throws IOException {     builder.startObject().     builder.field(Fields.VALUE, explanation.getValue()).     builder.field(Fields.DESCRIPTION, explanation.getDescription()).     Explanation[] innerExps = explanation.getDetails().     if (innerExps != null) {         builder.startArray(Fields.DETAILS).         for (Explanation exp : innerExps) {             buildExplanation(builder, exp).         }         builder.endArray().     }     builder.endObject(). }
false;public;1;22;;@Override public boolean equals(Object obj) {     if (obj == null || getClass() != obj.getClass()) {         return false.     }     SearchHit other = (SearchHit) obj.     return Objects.equals(id, other.id) && Objects.equals(type, other.type) && Objects.equals(nestedIdentity, other.nestedIdentity) && Objects.equals(version, other.version) && Objects.equals(seqNo, other.seqNo) && Objects.equals(primaryTerm, other.primaryTerm) && Objects.equals(source, other.source) && Objects.equals(fields, other.fields) && Objects.equals(getHighlightFields(), other.getHighlightFields()) && Arrays.equals(matchedQueries, other.matchedQueries) && Objects.equals(explanation, other.explanation) && Objects.equals(shard, other.shard) && Objects.equals(innerHits, other.innerHits) && Objects.equals(index, other.index) && Objects.equals(clusterAlias, other.clusterAlias). }
false;public;0;5;;@Override public int hashCode() {     return Objects.hash(id, type, nestedIdentity, version, seqNo, primaryTerm, source, fields, getHighlightFields(), Arrays.hashCode(matchedQueries), explanation, shard, innerHits, index, clusterAlias). }
true;public;0;3;/**  * Returns the nested field in the source this hit originates from  */ ;/**  * Returns the nested field in the source this hit originates from  */ public Text getField() {     return field. }
true;public;0;3;/**  * Returns the offset in the nested array of objects in the source this hit  */ ;/**  * Returns the offset in the nested array of objects in the source this hit  */ public int getOffset() {     return offset. }
true;public;0;3;/**  * Returns the next child nested level if there is any, otherwise <code>null</code> is returned.  *  * In the case of mappings with multiple levels of nested object fields  */ ;/**  * Returns the next child nested level if there is any, otherwise <code>null</code> is returned.  *  * In the case of mappings with multiple levels of nested object fields  */ public NestedIdentity getChild() {     return child. }
false;public;1;6;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeOptionalText(field).     out.writeInt(offset).     out.writeOptionalWriteable(child). }
false;public;2;5;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.field(_NESTED).     return innerToXContent(builder, params). }
true;;2;14;/**  * Rendering of the inner XContent object without the leading field name. This way the structure innerToXContent renders and  * fromXContent parses correspond to each other.  */ ;/**  * Rendering of the inner XContent object without the leading field name. This way the structure innerToXContent renders and  * fromXContent parses correspond to each other.  */ XContentBuilder innerToXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     if (field != null) {         builder.field(FIELD, field).     }     if (offset != -1) {         builder.field(OFFSET, offset).     }     if (child != null) {         builder = child.toXContent(builder, params).     }     builder.endObject().     return builder. }
false;static;2;3;;static NestedIdentity fromXContent(XContentParser parser, Void context) {     return fromXContent(parser). }
false;public,static;1;3;;public static NestedIdentity fromXContent(XContentParser parser) {     return PARSER.apply(parser, null). }
false;public;1;13;;@Override public boolean equals(Object obj) {     if (this == obj) {         return true.     }     if (obj == null || getClass() != obj.getClass()) {         return false.     }     NestedIdentity other = (NestedIdentity) obj.     return Objects.equals(field, other.field) && Objects.equals(offset, other.offset) && Objects.equals(child, other.child). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(field, offset, child). }
false;public;0;4;;@Override public String toString() {     return Strings.toString(this, true, true). }
