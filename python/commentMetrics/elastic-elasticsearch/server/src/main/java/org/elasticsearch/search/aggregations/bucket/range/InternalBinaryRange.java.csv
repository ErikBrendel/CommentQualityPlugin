commented;modifiers;parameterAmount;loc;comment;code
false;private,static;3;7;;private static String generateKey(BytesRef from, BytesRef to, DocValueFormat format) {     StringBuilder builder = new StringBuilder().append(from == null ? "*" : format.format(from)).append("-").append(to == null ? "*" : format.format(to)).     return builder.toString(). }
false;private,static;3;12;;private static Bucket createFromStream(StreamInput in, DocValueFormat format, boolean keyed) throws IOException {     String key = in.getVersion().onOrAfter(Version.V_6_4_0) ? in.readString() : in.readOptionalString().     BytesRef from = in.readBoolean() ? in.readBytesRef() : null.     BytesRef to = in.readBoolean() ? in.readBytesRef() : null.     long docCount = in.readLong().     InternalAggregations aggregations = InternalAggregations.readAggregations(in).     return new Bucket(format, keyed, key, from, to, docCount, aggregations). }
false;public;1;18;;@Override public void writeTo(StreamOutput out) throws IOException {     if (out.getVersion().onOrAfter(Version.V_6_4_0)) {         out.writeString(key).     } else {         out.writeOptionalString(key).     }     out.writeBoolean(from != null).     if (from != null) {         out.writeBytesRef(from).     }     out.writeBoolean(to != null).     if (to != null) {         out.writeBytesRef(to).     }     out.writeLong(docCount).     aggregations.writeTo(out). }
false;public;0;4;;@Override public Object getKey() {     return key. }
false;public;0;4;;@Override public String getKeyAsString() {     return key. }
false;public;0;4;;@Override public long getDocCount() {     return docCount. }
false;public;0;4;;@Override public Aggregations getAggregations() {     return aggregations. }
false;public;2;20;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     String key = this.key.     if (keyed) {         builder.startObject(key).     } else {         builder.startObject().         builder.field(CommonFields.KEY.getPreferredName(), key).     }     if (from != null) {         builder.field(CommonFields.FROM.getPreferredName(), getFrom()).     }     if (to != null) {         builder.field(CommonFields.TO.getPreferredName(), getTo()).     }     builder.field(CommonFields.DOC_COUNT.getPreferredName(), docCount).     aggregations.toXContentInternal(builder, params).     builder.endObject().     return builder. }
false;public;0;4;;@Override public Object getFrom() {     return getFromAsString(). }
false;public;0;4;;@Override public String getFromAsString() {     return from == null ? null : format.format(from).toString(). }
false;public;0;4;;@Override public Object getTo() {     return getToAsString(). }
false;public;0;4;;@Override public String getToAsString() {     return to == null ? null : format.format(to).toString(). }
false;public;1;14;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     Bucket bucket = (Bucket) o.     if (docCount != bucket.docCount)         return false.     // keyed and format are ignored since they are already tested on the InternalBinaryRange object     return Objects.equals(key, bucket.key) && Objects.equals(from, bucket.from) && Objects.equals(to, bucket.to) && Objects.equals(aggregations, bucket.aggregations). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(getClass(), docCount, key, from, to, aggregations). }
false;protected;1;6;;@Override protected void doWriteTo(StreamOutput out) throws IOException {     out.writeNamedWriteable(format).     out.writeBoolean(keyed).     out.writeList(buckets). }
false;public;0;4;;@Override public String getWriteableName() {     return IpRangeAggregationBuilder.NAME. }
false;public;0;4;;@Override public List<InternalBinaryRange.Bucket> getBuckets() {     return unmodifiableList(buckets). }
false;public;1;4;;@Override public InternalBinaryRange create(List<Bucket> buckets) {     return new InternalBinaryRange(name, format, keyed, buckets, pipelineAggregators(), metaData). }
false;public;2;4;;@Override public Bucket createBucket(InternalAggregations aggregations, Bucket prototype) {     return new Bucket(format, keyed, prototype.key, prototype.from, prototype.to, prototype.docCount, aggregations). }
false;public;2;27;;@Override public InternalAggregation doReduce(List<InternalAggregation> aggregations, ReduceContext reduceContext) {     reduceContext.consumeBucketsAndMaybeBreak(buckets.size()).     long[] docCounts = new long[buckets.size()].     InternalAggregations[][] aggs = new InternalAggregations[buckets.size()][].     for (int i = 0. i < aggs.length. ++i) {         aggs[i] = new InternalAggregations[aggregations.size()].     }     for (int i = 0. i < aggregations.size(). ++i) {         InternalBinaryRange range = (InternalBinaryRange) aggregations.get(i).         if (range.buckets.size() != buckets.size()) {             throw new IllegalStateException("Expected [" + buckets.size() + "] buckets, but got [" + range.buckets.size() + "]").         }         for (int j = 0. j < buckets.size(). ++j) {             Bucket bucket = range.buckets.get(j).             docCounts[j] += bucket.docCount.             aggs[j][i] = bucket.aggregations.         }     }     List<Bucket> buckets = new ArrayList<>(this.buckets.size()).     for (int i = 0. i < this.buckets.size(). ++i) {         Bucket b = this.buckets.get(i).         buckets.add(new Bucket(format, keyed, b.key, b.from, b.to, docCounts[i], InternalAggregations.reduce(Arrays.asList(aggs[i]), reduceContext))).     }     return new InternalBinaryRange(name, format, keyed, buckets, pipelineAggregators(), metaData). }
false;public;2;18;;@Override public XContentBuilder doXContentBody(XContentBuilder builder, Params params) throws IOException {     if (keyed) {         builder.startObject(CommonFields.BUCKETS.getPreferredName()).     } else {         builder.startArray(CommonFields.BUCKETS.getPreferredName()).     }     for (Bucket range : buckets) {         range.toXContent(builder, params).     }     if (keyed) {         builder.endObject().     } else {         builder.endArray().     }     return builder. }
false;public;1;7;;@Override public boolean doEquals(Object obj) {     InternalBinaryRange that = (InternalBinaryRange) obj.     return Objects.equals(buckets, that.buckets) && Objects.equals(format, that.format) && Objects.equals(keyed, that.keyed). }
false;public;0;4;;@Override public int doHashCode() {     return Objects.hash(buckets, format, keyed). }
