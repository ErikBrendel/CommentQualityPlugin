commented;modifiers;parameterAmount;loc;comment;code
false;public;1;8;;@Override public void clusterChanged(ClusterChangedEvent event) {     if (event.nodesRemoved()) {         for (DiscoveryNode removedNode : event.nodesDelta().removedNodes()) {             removeNode(removedNode.getId()).         }     } }
false;;1;3;;void removeNode(String nodeId) {     nodeIdToStats.remove(nodeId). }
false;public;4;14;;public void addNodeStatistics(String nodeId, int queueSize, long responseTimeNanos, long avgServiceTimeNanos) {     nodeIdToStats.compute(nodeId, (id, ns) -> {         if (ns == null) {             ExponentiallyWeightedMovingAverage queueEWMA = new ExponentiallyWeightedMovingAverage(ALPHA, queueSize).             ExponentiallyWeightedMovingAverage responseEWMA = new ExponentiallyWeightedMovingAverage(ALPHA, responseTimeNanos).             return new NodeStatistics(nodeId, queueEWMA, responseEWMA, avgServiceTimeNanos).         } else {             ns.queueSize.addValue((double) queueSize).             ns.responseTime.addValue((double) responseTimeNanos).             ns.serviceTime = avgServiceTimeNanos.             return ns.         }     }). }
false;public;0;9;;public Map<String, ComputedNodeStats> getAllNodeStatistics() {     final int clientNum = nodeIdToStats.size().     // Transform the mutable object internally used for accounting into the computed version     Map<String, ComputedNodeStats> nodeStats = new HashMap<>(nodeIdToStats.size()).     nodeIdToStats.forEach((k, v) -> {         nodeStats.put(k, new ComputedNodeStats(clientNum, v)).     }).     return nodeStats. }
false;public;1;3;;public AdaptiveSelectionStats getAdaptiveStats(Map<String, Long> clientSearchConnections) {     return new AdaptiveSelectionStats(clientSearchConnections, getAllNodeStatistics()). }
true;public;1;4;/**  * Optionally return a {@code NodeStatistics} for the given nodeid, if  * response information exists for the given node. Returns an empty  * {@code Optional} if the node was not found.  */ ;/**  * Optionally return a {@code NodeStatistics} for the given nodeid, if  * response information exists for the given node. Returns an empty  * {@code Optional} if the node was not found.  */ public Optional<ComputedNodeStats> getNodeStatistics(final String nodeId) {     final int clientNum = nodeIdToStats.size().     return Optional.ofNullable(nodeIdToStats.get(nodeId)).map(ns -> new ComputedNodeStats(clientNum, ns)). }
false;public;1;8;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeString(this.nodeId).     out.writeInt(this.clientNum).     out.writeInt(this.queueSize).     out.writeDouble(this.responseTime).     out.writeDouble(this.serviceTime). }
true;private;1;23;/**  * Rank this copy of the data, according to the adaptive replica selection formula from the C3 paper  * https://www.usenix.org/system/files/conference/nsdi15/nsdi15-paper-suresh.pdf  */ ;/**  * Rank this copy of the data, according to the adaptive replica selection formula from the C3 paper  * https://www.usenix.org/system/files/conference/nsdi15/nsdi15-paper-suresh.pdf  */ private double innerRank(long outstandingRequests) {     // the concurrency compensation is defined as the number of     // outstanding requests from the client to the node times the number     // of clients in the system     double concurrencyCompensation = outstandingRequests * clientNum.     // Cubic queue adjustment factor. The paper chose 3 though we could     // potentially make this configurable if desired.     int queueAdjustmentFactor = 3.     // EWMA of queue size     double qBar = queueSize.     double qHatS = 1 + concurrencyCompensation + qBar.     // EWMA of response time     double rS = responseTime / FACTOR.     // EWMA of service time     double muBarS = serviceTime / FACTOR.     // The final formula     double rank = rS - (1.0 / muBarS) + (Math.pow(qHatS, queueAdjustmentFactor) / muBarS).     return rank. }
false;public;1;6;;public double rank(long outstandingRequests) {     if (cachedRank == 0) {         cachedRank = innerRank(outstandingRequests).     }     return cachedRank. }
false;public;0;12;;@Override public String toString() {     StringBuilder sb = new StringBuilder("ComputedNodeStats[").     sb.append(nodeId).append("](").     sb.append("nodes: ").append(clientNum).     sb.append(", queue: ").append(queueSize).     sb.append(", response time: ").append(String.format(Locale.ROOT, "%.1f", responseTime)).     sb.append(", service time: ").append(String.format(Locale.ROOT, "%.1f", serviceTime)).     sb.append(", rank: ").append(String.format(Locale.ROOT, "%.1f", rank(1))).     sb.append(")").     return sb.toString(). }
