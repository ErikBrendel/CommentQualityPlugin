commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;3;;protected Logger getLogger() {     return LOGGER. }
true;public;3;23;/**  * Sync the specified retention leases for the specified shard. The callback is invoked when the sync succeeds or fails.  *  * @param shardId         the shard to sync  * @param retentionLeases the retention leases to sync  * @param listener        the callback to invoke when the sync completes normally or abnormally  */ ;/**  * Sync the specified retention leases for the specified shard. The callback is invoked when the sync succeeds or fails.  *  * @param shardId         the shard to sync  * @param retentionLeases the retention leases to sync  * @param listener        the callback to invoke when the sync completes normally or abnormally  */ public void sync(final ShardId shardId, final RetentionLeases retentionLeases, final ActionListener<ReplicationResponse> listener) {     Objects.requireNonNull(shardId).     Objects.requireNonNull(retentionLeases).     Objects.requireNonNull(listener).     final ThreadContext threadContext = threadPool.getThreadContext().     try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {         // we have to execute under the system context so that if security is enabled the sync is authorized         threadContext.markAsSystemContext().         execute(new RetentionLeaseSyncAction.Request(shardId, retentionLeases), ActionListener.wrap(listener::onResponse, e -> {             if (ExceptionsHelper.unwrap(e, AlreadyClosedException.class, IndexShardClosedException.class) == null) {                 getLogger().warn(new ParameterizedMessage("{} retention lease sync failed", shardId), e).             }             listener.onFailure(e).         })).     } }
false;protected;2;10;;@Override protected WritePrimaryResult<Request, Response> shardOperationOnPrimary(final Request request, final IndexShard primary) throws WriteStateException {     assert request.waitForActiveShards().equals(ActiveShardCount.NONE) : request.waitForActiveShards().     Objects.requireNonNull(request).     Objects.requireNonNull(primary).     primary.persistRetentionLeases().     return new WritePrimaryResult<>(request, new Response(), null, null, primary, getLogger()). }
false;protected;2;10;;@Override protected WriteReplicaResult<Request> shardOperationOnReplica(final Request request, final IndexShard replica) throws WriteStateException {     Objects.requireNonNull(request).     Objects.requireNonNull(replica).     replica.updateRetentionLeasesOnReplica(request.getRetentionLeases()).     replica.persistRetentionLeases().     return new WriteReplicaResult<>(request, null, null, replica, getLogger()). }
false;public;0;4;;@Override public ClusterBlockLevel indexBlockLevel() {     return null. }
false;public;0;3;;public RetentionLeases getRetentionLeases() {     return retentionLeases. }
false;public;1;5;;@Override public void readFrom(final StreamInput in) throws IOException {     super.readFrom(in).     retentionLeases = new RetentionLeases(in). }
false;public;1;5;;@Override public void writeTo(final StreamOutput out) throws IOException {     super.writeTo(Objects.requireNonNull(out)).     retentionLeases.writeTo(out). }
false;public;0;10;;@Override public String toString() {     return "Request{" + "retentionLeases=" + retentionLeases + ", shardId=" + shardId + ", timeout=" + timeout + ", index='" + index + '\'' + ", waitForActiveShards=" + waitForActiveShards + '}'. }
false;public;1;4;;@Override public void setForcedRefresh(final boolean forcedRefresh) { // ignore }
false;protected;0;4;;@Override protected Response newResponseInstance() {     return new Response(). }
