commented;modifiers;parameterAmount;loc;comment;code
false;protected;7;6;;protected TransportService newTransportService(Settings settings, Transport transport, ThreadPool threadPool, TransportInterceptor interceptor, Function<BoundTransportAddress, DiscoveryNode> localNodeFactory, ClusterSettings clusterSettings, Set<String> taskHeaders) {     return new TransportService(settings, transport, threadPool, interceptor, localNodeFactory, clusterSettings, taskHeaders). }
false;protected;2;3;;protected void processRecoverySettings(ClusterSettings clusterSettings, RecoverySettings recoverySettings) { // Noop in production, overridden by tests }
true;public;0;3;/**  * The settings that are used by this node. Contains original settings as well as additional settings provided by plugins.  */ ;/**  * The settings that are used by this node. Contains original settings as well as additional settings provided by plugins.  */ public Settings settings() {     return this.settings. }
true;public;0;3;/**  * A client that can be used to execute actions (operations) against the cluster.  */ ;/**  * A client that can be used to execute actions (operations) against the cluster.  */ public Client client() {     return client. }
true;public;0;3;/**  * Returns the environment of the node  */ ;/**  * Returns the environment of the node  */ public Environment getEnvironment() {     return environment. }
true;public;0;3;/**  * Returns the {@link NodeEnvironment} instance of this node  */ ;/**  * Returns the {@link NodeEnvironment} instance of this node  */ public NodeEnvironment getNodeEnvironment() {     return nodeEnvironment. }
false;public;1;2;;@Override public void onNewClusterState(ClusterState state) {     latch.countDown(). }
false;public;0;4;;@Override public void onClusterServiceClose() {     latch.countDown(). }
false;public;1;6;;@Override public void onTimeout(TimeValue timeout) {     logger.warn("timed out while waiting for initial discovery state - timeout: {}", initialStateTimeout).     latch.countDown(). }
true;public;0;108;/**  * Start the node. If the node is already started, this method is no-op.  */ ;/**  * Start the node. If the node is already started, this method is no-op.  */ public Node start() throws NodeValidationException {     if (!lifecycle.moveToStarted()) {         return this.     }     logger.info("starting ...").     pluginLifecycleComponents.forEach(LifecycleComponent::start).     injector.getInstance(MappingUpdatedAction.class).setClient(client).     injector.getInstance(IndicesService.class).start().     injector.getInstance(IndicesClusterStateService.class).start().     injector.getInstance(SnapshotsService.class).start().     injector.getInstance(SnapshotShardsService.class).start().     injector.getInstance(RoutingService.class).start().     injector.getInstance(SearchService.class).start().     nodeService.getMonitorService().start().     final ClusterService clusterService = injector.getInstance(ClusterService.class).     final NodeConnectionsService nodeConnectionsService = injector.getInstance(NodeConnectionsService.class).     nodeConnectionsService.start().     clusterService.setNodeConnectionsService(nodeConnectionsService).     injector.getInstance(ResourceWatcherService.class).start().     injector.getInstance(GatewayService.class).start().     Discovery discovery = injector.getInstance(Discovery.class).     clusterService.getMasterService().setClusterStatePublisher(discovery::publish).     // Start the transport service now so the publish address will be added to the local disco node in ClusterService     TransportService transportService = injector.getInstance(TransportService.class).     transportService.getTaskManager().setTaskResultsService(injector.getInstance(TaskResultsService.class)).     transportService.start().     assert localNodeFactory.getNode() != null.     assert transportService.getLocalNode().equals(localNodeFactory.getNode()) : "transportService has a different local node than the factory provided".     final MetaData onDiskMetadata.     // pass it to the bootstrap checks to allow plugins to enforce certain preconditions based on the recovered state.     if (DiscoveryNode.isMasterNode(settings) || DiscoveryNode.isDataNode(settings)) {         onDiskMetadata = injector.getInstance(GatewayMetaState.class).getMetaData().     } else {         onDiskMetadata = MetaData.EMPTY_META_DATA.     }     // this is never null     assert onDiskMetadata != null : "metadata is null but shouldn't".     validateNodeBeforeAcceptingRequests(new BootstrapContext(environment, onDiskMetadata), transportService.boundAddress(), pluginsService.filterPlugins(Plugin.class).stream().flatMap(p -> p.getBootstrapChecks().stream()).collect(Collectors.toList())).     clusterService.addStateApplier(transportService.getTaskManager()).     // start after transport service so the local disco is known     // start before cluster service so that it can set initial state on ClusterApplierService     discovery.start().     clusterService.start().     assert clusterService.localNode().equals(localNodeFactory.getNode()) : "clusterService has a different local node than the factory provided".     transportService.acceptIncomingRequests().     discovery.startInitialJoin().     final TimeValue initialStateTimeout = DiscoverySettings.INITIAL_STATE_TIMEOUT_SETTING.get(settings).     configureNodeAndClusterIdStateListener(clusterService).     if (initialStateTimeout.millis() > 0) {         final ThreadPool thread = injector.getInstance(ThreadPool.class).         ClusterState clusterState = clusterService.state().         ClusterStateObserver observer = new ClusterStateObserver(clusterState, clusterService, null, logger, thread.getThreadContext()).         if (clusterState.nodes().getMasterNodeId() == null) {             logger.debug("waiting to join the cluster. timeout [{}]", initialStateTimeout).             final CountDownLatch latch = new CountDownLatch(1).             observer.waitForNextChange(new ClusterStateObserver.Listener() {                  @Override                 public void onNewClusterState(ClusterState state) {                     latch.countDown().                 }                  @Override                 public void onClusterServiceClose() {                     latch.countDown().                 }                  @Override                 public void onTimeout(TimeValue timeout) {                     logger.warn("timed out while waiting for initial discovery state - timeout: {}", initialStateTimeout).                     latch.countDown().                 }             }, state -> state.nodes().getMasterNodeId() != null, initialStateTimeout).             try {                 latch.await().             } catch (InterruptedException e) {                 throw new ElasticsearchTimeoutException("Interrupted while waiting for initial discovery state").             }         }     }     injector.getInstance(HttpServerTransport.class).start().     if (WRITE_PORTS_FILE_SETTING.get(settings)) {         TransportService transport = injector.getInstance(TransportService.class).         writePortsFile("transport", transport.boundAddress()).         HttpServerTransport http = injector.getInstance(HttpServerTransport.class).         writePortsFile("http", http.boundAddress()).     }     logger.info("started").     pluginsService.filterPlugins(ClusterPlugin.class).forEach(ClusterPlugin::onNodeStarted).     return this. }
false;protected;1;4;;protected void configureNodeAndClusterIdStateListener(ClusterService clusterService) {     NodeAndClusterIdStateListener.getAndSetNodeIdAndClusterId(clusterService, injector.getInstance(ThreadPool.class).getThreadContext()). }
false;private;0;33;;private Node stop() {     if (!lifecycle.moveToStopped()) {         return this.     }     logger.info("stopping ...").     injector.getInstance(ResourceWatcherService.class).stop().     injector.getInstance(HttpServerTransport.class).stop().     injector.getInstance(SnapshotsService.class).stop().     injector.getInstance(SnapshotShardsService.class).stop().     // stop any changes happening as a result of cluster state changes     injector.getInstance(IndicesClusterStateService.class).stop().     // close discovery early to not react to pings anymore.     // This can confuse other nodes and delay things - mostly if we're the master and we're running tests.     injector.getInstance(Discovery.class).stop().     // we close indices first, so operations won't be allowed on it     injector.getInstance(RoutingService.class).stop().     injector.getInstance(ClusterService.class).stop().     injector.getInstance(NodeConnectionsService.class).stop().     nodeService.getMonitorService().stop().     injector.getInstance(GatewayService.class).stop().     injector.getInstance(SearchService.class).stop().     injector.getInstance(TransportService.class).stop().     pluginLifecycleComponents.forEach(LifecycleComponent::stop).     // we should stop this last since it waits for resources to get released     // if we had scroll searchers etc or recovery going on we wait for to finish.     injector.getInstance(IndicesService.class).stop().     logger.info("stopped").     return this. }
true;public,synchronized;0;78;// In this case the process will be terminated even if the first call to close() has not finished yet. ;// During concurrent close() calls we want to make sure that all of them return after the node has completed it's shutdown cycle. // If not, the hook that is added in Bootstrap#setup() will be useless: // close() might not be executed, in case another (for example api) call to close() has already set some lifecycles to stopped. // In this case the process will be terminated even if the first call to close() has not finished yet. @Override public synchronized void close() throws IOException {     if (lifecycle.started()) {         stop().     }     if (!lifecycle.moveToClosed()) {         return.     }     logger.info("closing ...").     List<Closeable> toClose = new ArrayList<>().     StopWatch stopWatch = new StopWatch("node_close").     toClose.add(() -> stopWatch.start("node_service")).     toClose.add(nodeService).     toClose.add(() -> stopWatch.stop().start("http")).     toClose.add(injector.getInstance(HttpServerTransport.class)).     toClose.add(() -> stopWatch.stop().start("snapshot_service")).     toClose.add(injector.getInstance(SnapshotsService.class)).     toClose.add(injector.getInstance(SnapshotShardsService.class)).     toClose.add(() -> stopWatch.stop().start("client")).     Releasables.close(injector.getInstance(Client.class)).     toClose.add(() -> stopWatch.stop().start("indices_cluster")).     toClose.add(injector.getInstance(IndicesClusterStateService.class)).     toClose.add(() -> stopWatch.stop().start("indices")).     toClose.add(injector.getInstance(IndicesService.class)).     // close filter/fielddata caches after indices     toClose.add(injector.getInstance(IndicesStore.class)).     toClose.add(() -> stopWatch.stop().start("routing")).     toClose.add(injector.getInstance(RoutingService.class)).     toClose.add(() -> stopWatch.stop().start("cluster")).     toClose.add(injector.getInstance(ClusterService.class)).     toClose.add(() -> stopWatch.stop().start("node_connections_service")).     toClose.add(injector.getInstance(NodeConnectionsService.class)).     toClose.add(() -> stopWatch.stop().start("discovery")).     toClose.add(injector.getInstance(Discovery.class)).     toClose.add(() -> stopWatch.stop().start("monitor")).     toClose.add(nodeService.getMonitorService()).     toClose.add(() -> stopWatch.stop().start("gateway")).     toClose.add(injector.getInstance(GatewayService.class)).     toClose.add(() -> stopWatch.stop().start("search")).     toClose.add(injector.getInstance(SearchService.class)).     toClose.add(() -> stopWatch.stop().start("transport")).     toClose.add(injector.getInstance(TransportService.class)).     for (LifecycleComponent plugin : pluginLifecycleComponents) {         toClose.add(() -> stopWatch.stop().start("plugin(" + plugin.getClass().getName() + ")")).         toClose.add(plugin).     }     toClose.addAll(pluginsService.filterPlugins(Plugin.class)).     toClose.add(() -> stopWatch.stop().start("script")).     toClose.add(injector.getInstance(ScriptService.class)).     toClose.add(() -> stopWatch.stop().start("thread_pool")).     // TODO this should really use ThreadPool.terminate()     toClose.add(() -> injector.getInstance(ThreadPool.class).shutdown()).     toClose.add(() -> {         try {             injector.getInstance(ThreadPool.class).awaitTermination(10, TimeUnit.SECONDS).         } catch (InterruptedException e) {         // ignore         }     }).     toClose.add(() -> stopWatch.stop().start("thread_pool_force_shutdown")).     toClose.add(() -> injector.getInstance(ThreadPool.class).shutdownNow()).     toClose.add(() -> stopWatch.stop()).     toClose.add(injector.getInstance(NodeEnvironment.class)).     toClose.add(injector.getInstance(PageCacheRecycler.class)).     if (logger.isTraceEnabled()) {         logger.trace("Close times for each service:\n{}", stopWatch.prettyPrint()).     }     IOUtils.close(toClose).     logger.info("closed"). }
true;public;0;3;/**  * Returns {@code true} if the node is closed.  */ ;/**  * Returns {@code true} if the node is closed.  */ public boolean isClosed() {     return lifecycle.closed(). }
false;public;0;3;;public Injector injector() {     return this.injector. }
true;protected;3;5;/**  * Hook for validating the node after network  * services are started but before the cluster service is started  * and before the network service starts accepting incoming network  * requests.  *  * @param context               the bootstrap context for this node  * @param boundTransportAddress the network addresses the node is  *                              bound and publishing to  */ ;/**  * Hook for validating the node after network  * services are started but before the cluster service is started  * and before the network service starts accepting incoming network  * requests.  *  * @param context               the bootstrap context for this node  * @param boundTransportAddress the network addresses the node is  *                              bound and publishing to  */ @SuppressWarnings("unused") protected void validateNodeBeforeAcceptingRequests(final BootstrapContext context, final BoundTransportAddress boundTransportAddress, List<BootstrapCheck> bootstrapChecks) throws NodeValidationException { }
true;private;2;17;/**  * Writes a file to the logs dir containing the ports for the given transport type  */ ;/**  * Writes a file to the logs dir containing the ports for the given transport type  */ private void writePortsFile(String type, BoundTransportAddress boundAddress) {     Path tmpPortsFile = environment.logsFile().resolve(type + ".ports.tmp").     try (BufferedWriter writer = Files.newBufferedWriter(tmpPortsFile, Charset.forName("UTF-8"))) {         for (TransportAddress address : boundAddress.boundAddresses()) {             InetAddress inetAddress = InetAddress.getByName(address.getAddress()).             writer.write(NetworkAddress.format(new InetSocketAddress(inetAddress, address.getPort())) + "\n").         }     } catch (IOException e) {         throw new RuntimeException("Failed to write ports file", e).     }     Path portsFile = environment.logsFile().resolve(type + ".ports").     try {         Files.move(tmpPortsFile, portsFile, StandardCopyOption.ATOMIC_MOVE).     } catch (IOException e) {         throw new RuntimeException("Failed to rename ports file", e).     } }
true;protected;0;3;/**  * The {@link PluginsService} used to build this node's components.  */ ;/**  * The {@link PluginsService} used to build this node's components.  */ protected PluginsService getPluginsService() {     return pluginsService. }
true;public,static;2;10;/**  * Creates a new {@link CircuitBreakerService} based on the settings provided.  * @see #BREAKER_TYPE_KEY  */ ;/**  * Creates a new {@link CircuitBreakerService} based on the settings provided.  * @see #BREAKER_TYPE_KEY  */ public static CircuitBreakerService createCircuitBreakerService(Settings settings, ClusterSettings clusterSettings) {     String type = BREAKER_TYPE_KEY.get(settings).     if (type.equals("hierarchy")) {         return new HierarchyCircuitBreakerService(settings, clusterSettings).     } else if (type.equals("none")) {         return new NoneCircuitBreakerService().     } else {         throw new IllegalArgumentException("Unknown circuit breaker type [" + type + "]").     } }
true;;2;3;/**  * Creates a new {@link BigArrays} instance used for this node.  * This method can be overwritten by subclasses to change their {@link BigArrays} implementation for instance for testing  */ ;/**  * Creates a new {@link BigArrays} instance used for this node.  * This method can be overwritten by subclasses to change their {@link BigArrays} implementation for instance for testing  */ BigArrays createBigArrays(PageCacheRecycler pageCacheRecycler, CircuitBreakerService circuitBreakerService) {     return new BigArrays(pageCacheRecycler, circuitBreakerService, CircuitBreaker.REQUEST). }
true;;1;3;/**  * Creates a new {@link BigArrays} instance used for this node.  * This method can be overwritten by subclasses to change their {@link BigArrays} implementation for instance for testing  */ ;/**  * Creates a new {@link BigArrays} instance used for this node.  * This method can be overwritten by subclasses to change their {@link BigArrays} implementation for instance for testing  */ PageCacheRecycler createPageCacheRecycler(Settings settings) {     return new PageCacheRecycler(settings). }
true;protected;7;6;/**  * Creates a new the SearchService. This method can be overwritten by tests to inject mock implementations.  */ ;/**  * Creates a new the SearchService. This method can be overwritten by tests to inject mock implementations.  */ protected SearchService newSearchService(ClusterService clusterService, IndicesService indicesService, ThreadPool threadPool, ScriptService scriptService, BigArrays bigArrays, FetchPhase fetchPhase, ResponseCollectorService responseCollectorService) {     return new SearchService(clusterService, indicesService, threadPool, scriptService, bigArrays, fetchPhase, responseCollectorService). }
true;private;1;10;/**  * Get Custom Name Resolvers list based on a Discovery Plugins list  * @param discoveryPlugins Discovery plugins list  */ ;/**  * Get Custom Name Resolvers list based on a Discovery Plugins list  * @param discoveryPlugins Discovery plugins list  */ private List<NetworkService.CustomNameResolver> getCustomNameResolvers(List<DiscoveryPlugin> discoveryPlugins) {     List<NetworkService.CustomNameResolver> customNameResolvers = new ArrayList<>().     for (DiscoveryPlugin discoveryPlugin : discoveryPlugins) {         NetworkService.CustomNameResolver customNameResolver = discoveryPlugin.getCustomNameResolver(settings).         if (customNameResolver != null) {             customNameResolvers.add(customNameResolver).         }     }     return customNameResolvers. }
true;protected;5;4;/**  * Constructs a ClusterInfoService which may be mocked for tests.  */ ;/**  * Constructs a ClusterInfoService which may be mocked for tests.  */ protected ClusterInfoService newClusterInfoService(Settings settings, ClusterService clusterService, ThreadPool threadPool, NodeClient client, Consumer<ClusterInfo> listeners) {     return new InternalClusterInfoService(settings, clusterService, threadPool, client, listeners). }
true;protected;1;3;/**  * Constructs a {@link org.elasticsearch.http.HttpServerTransport} which may be mocked for tests.  */ ;/**  * Constructs a {@link org.elasticsearch.http.HttpServerTransport} which may be mocked for tests.  */ protected HttpServerTransport newHttpTransport(NetworkModule networkModule) {     return networkModule.getHttpServerTransportSupplier().get(). }
false;public;1;5;;@Override public DiscoveryNode apply(BoundTransportAddress boundTransportAddress) {     localNode.set(DiscoveryNode.createLocal(settings, boundTransportAddress.publishAddress(), persistentNodeId)).     return localNode.get(). }
false;;0;4;;DiscoveryNode getNode() {     assert localNode.get() != null.     return localNode.get(). }
