commented;modifiers;parameterAmount;loc;comment;code
true;public;2;4;/**  * Returns a {@link Decision} whether the given shard routing can be  * re-balanced to the given allocation. The default is  * {@link Decision#ALWAYS}.  */ ;/**  * Returns a {@link Decision} whether the given shard routing can be  * re-balanced to the given allocation. The default is  * {@link Decision#ALWAYS}.  */ @Override public Decision canRebalance(ShardRouting shardRouting, RoutingAllocation allocation) {     return canMove(shardRouting, allocation). }
true;public;3;4;/**  * Returns a {@link Decision} whether the given shard routing can be  * allocated on the given node. The default is {@link Decision#ALWAYS}.  */ ;/**  * Returns a {@link Decision} whether the given shard routing can be  * allocated on the given node. The default is {@link Decision#ALWAYS}.  */ @Override public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {     return canMove(shardRouting, allocation). }
false;private;2;26;;private Decision canMove(ShardRouting shardRouting, RoutingAllocation allocation) {     if (shardRouting.primary()) {         // Only primary shards are snapshotted         SnapshotsInProgress snapshotsInProgress = allocation.custom(SnapshotsInProgress.TYPE).         if (snapshotsInProgress == null || snapshotsInProgress.entries().isEmpty()) {             // Snapshots are not running             return allocation.decision(Decision.YES, NAME, "no snapshots are currently running").         }         for (SnapshotsInProgress.Entry snapshot : snapshotsInProgress.entries()) {             SnapshotsInProgress.ShardSnapshotStatus shardSnapshotStatus = snapshot.shards().get(shardRouting.shardId()).             if (shardSnapshotStatus != null && !shardSnapshotStatus.state().completed() && shardSnapshotStatus.nodeId() != null && shardSnapshotStatus.nodeId().equals(shardRouting.currentNodeId())) {                 if (logger.isTraceEnabled()) {                     logger.trace("Preventing snapshotted shard [{}] from being moved away from node [{}]", shardRouting.shardId(), shardSnapshotStatus.nodeId()).                 }                 return allocation.decision(Decision.THROTTLE, NAME, "waiting for snapshotting of shard [%s] to complete on this node [%s]", shardRouting.shardId(), shardSnapshotStatus.nodeId()).             }         }     }     return allocation.decision(Decision.YES, NAME, "the shard is not being snapshotted"). }
