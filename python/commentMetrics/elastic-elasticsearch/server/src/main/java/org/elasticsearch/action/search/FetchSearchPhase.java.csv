commented;modifiers;parameterAmount;loc;comment;code
false;public;0;7;;@Override public void doRun() throws IOException {     // we do the heavy lifting in this inner run method where we reduce aggs etc. that's why we fork this phase     // off immediately instead of forking when we send back the response to the user since there we only need     // to merge together the fetched results which is a linear operation.     innerRun(). }
false;public;1;4;;@Override public void onFailure(Exception e) {     context.onPhaseFailure(FetchSearchPhase.this, "", e). }
false;public;0;17;;@Override public void run() throws IOException {     context.execute(new ActionRunnable<SearchResponse>(context) {          @Override         public void doRun() throws IOException {             // we do the heavy lifting in this inner run method where we reduce aggs etc. that's why we fork this phase             // off immediately instead of forking when we send back the response to the user since there we only need             // to merge together the fetched results which is a linear operation.             innerRun().         }          @Override         public void onFailure(Exception e) {             context.onPhaseFailure(FetchSearchPhase.this, "", e).         }     }). }
false;private;0;55;;private void innerRun() throws IOException {     final int numShards = context.getNumShards().     final boolean isScrollSearch = context.getRequest().scroll() != null.     List<SearchPhaseResult> phaseResults = queryResults.asList().     String scrollId = isScrollSearch ? TransportSearchHelper.buildScrollId(queryResults) : null.     final SearchPhaseController.ReducedQueryPhase reducedQueryPhase = resultConsumer.reduce().     final boolean queryAndFetchOptimization = queryResults.length() == 1.     final Runnable finishPhase = () -> moveToNextPhase(searchPhaseController, scrollId, reducedQueryPhase, queryAndFetchOptimization ? queryResults : fetchResults).     if (queryAndFetchOptimization) {         assert phaseResults.isEmpty() || phaseResults.get(0).fetchResult() != null : "phaseResults empty [" + phaseResults.isEmpty() + "], single result: " + phaseResults.get(0).fetchResult().         // query AND fetch optimization         finishPhase.run().     } else {         ScoreDoc[] scoreDocs = reducedQueryPhase.sortedTopDocs.scoreDocs.         final IntArrayList[] docIdsToLoad = searchPhaseController.fillDocIdsToLoad(numShards, scoreDocs).         if (scoreDocs.length == 0) {             // no docs to fetch -- sidestep everything and return             phaseResults.stream().map(SearchPhaseResult::queryResult).forEach(// we have to release contexts here to free up resources             this::releaseIrrelevantSearchContext).             finishPhase.run().         } else {             final ScoreDoc[] lastEmittedDocPerShard = isScrollSearch ? searchPhaseController.getLastEmittedDocPerShard(reducedQueryPhase, numShards) : null.             final CountedCollector<FetchSearchResult> counter = new CountedCollector<>(r -> fetchResults.set(r.getShardIndex(), r), // we count down every shard in the result no matter if we got any results or not             docIdsToLoad.length, finishPhase, context).             for (int i = 0. i < docIdsToLoad.length. i++) {                 IntArrayList entry = docIdsToLoad[i].                 SearchPhaseResult queryResult = queryResults.get(i).                 if (entry == null) {                     // no results for this shard ID                     if (queryResult != null) {                         // if we got some hits from this shard we have to release the context there                         // we do this as we go since it will free up resources and passing on the request on the                         // transport layer is cheap.                         releaseIrrelevantSearchContext(queryResult.queryResult()).                     }                     // in any case we count down this result since we don't talk to this shard anymore                     counter.countDown().                 } else {                     SearchShardTarget searchShardTarget = queryResult.getSearchShardTarget().                     Transport.Connection connection = context.getConnection(searchShardTarget.getClusterAlias(), searchShardTarget.getNodeId()).                     ShardFetchSearchRequest fetchSearchRequest = createFetchRequest(queryResult.queryResult().getRequestId(), i, entry, lastEmittedDocPerShard, searchShardTarget.getOriginalIndices()).                     executeFetch(i, searchShardTarget, counter, fetchSearchRequest, queryResult.queryResult(), connection).                 }             }         }     } }
false;protected;5;5;;protected ShardFetchSearchRequest createFetchRequest(long queryId, int index, IntArrayList entry, ScoreDoc[] lastEmittedDocPerShard, OriginalIndices originalIndices) {     final ScoreDoc lastEmittedDoc = (lastEmittedDocPerShard != null) ? lastEmittedDocPerShard[index] : null.     return new ShardFetchSearchRequest(originalIndices, queryId, entry, lastEmittedDoc). }
false;public;1;4;;@Override public void innerOnResponse(FetchSearchResult result) {     counter.onResult(result). }
false;public;1;12;;@Override public void onFailure(Exception e) {     try {         logger.debug(() -> new ParameterizedMessage("[{}] Failed to execute fetch phase", fetchSearchRequest.id()), e).         counter.onFailure(shardIndex, shardTarget, e).     } finally {         // the search context might not be cleared on the node where the fetch was executed for example         // because the action was rejected by the thread pool. in this case we need to send a dedicated         // request to clear the search context.         releaseIrrelevantSearchContext(querySearchResult).     } }
false;private;6;25;;private void executeFetch(final int shardIndex, final SearchShardTarget shardTarget, final CountedCollector<FetchSearchResult> counter, final ShardFetchSearchRequest fetchSearchRequest, final QuerySearchResult querySearchResult, final Transport.Connection connection) {     context.getSearchTransport().sendExecuteFetch(connection, fetchSearchRequest, context.getTask(), new SearchActionListener<FetchSearchResult>(shardTarget, shardIndex) {          @Override         public void innerOnResponse(FetchSearchResult result) {             counter.onResult(result).         }          @Override         public void onFailure(Exception e) {             try {                 logger.debug(() -> new ParameterizedMessage("[{}] Failed to execute fetch phase", fetchSearchRequest.id()), e).                 counter.onFailure(shardIndex, shardTarget, e).             } finally {                 // the search context might not be cleared on the node where the fetch was executed for example                 // because the action was rejected by the thread pool. in this case we need to send a dedicated                 // request to clear the search context.                 releaseIrrelevantSearchContext(querySearchResult).             }         }     }). }
true;private;1;13;/**  * Releases shard targets that are not used in the docsIdsToLoad.  */ ;/**  * Releases shard targets that are not used in the docsIdsToLoad.  */ private void releaseIrrelevantSearchContext(QuerySearchResult queryResult) {     // and if it has at lease one hit that didn't make it to the global topDocs     if (context.getRequest().scroll() == null && queryResult.hasSearchContext()) {         try {             SearchShardTarget searchShardTarget = queryResult.getSearchShardTarget().             Transport.Connection connection = context.getConnection(searchShardTarget.getClusterAlias(), searchShardTarget.getNodeId()).             context.sendReleaseSearchContext(queryResult.getRequestId(), connection, searchShardTarget.getOriginalIndices()).         } catch (Exception e) {             context.getLogger().trace("failed to release context", e).         }     } }
false;private;4;7;;private void moveToNextPhase(SearchPhaseController searchPhaseController, String scrollId, SearchPhaseController.ReducedQueryPhase reducedQueryPhase, AtomicArray<? extends SearchPhaseResult> fetchResultsArr) {     final InternalSearchResponse internalResponse = searchPhaseController.merge(context.getRequest().scroll() != null, reducedQueryPhase, fetchResultsArr.asList(), fetchResultsArr::get).     context.executeNextPhase(this, nextPhaseFactory.apply(internalResponse, scrollId)). }
false;public;0;4;;@Override public void run() throws IOException {     context.onResponse(context.buildSearchResponse(response, scrollId)). }
false;private,static;3;8;;private static SearchPhase sendResponsePhase(InternalSearchResponse response, String scrollId, SearchPhaseContext context) {     return new SearchPhase("response") {          @Override         public void run() throws IOException {             context.onResponse(context.buildSearchResponse(response, scrollId)).         }     }. }
