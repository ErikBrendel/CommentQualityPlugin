commented;modifiers;parameterAmount;loc;comment;code
false;;1;13;;@Override void copyCurrent(int slot) {     values = bigArrays.grow(values, slot + 1).     if (missingBucket && missingCurrentValue) {         bits.clear(slot).     } else {         assert missingCurrentValue == false.         if (missingBucket) {             bits.set(slot).         }         values.set(slot, currentValue).     } }
false;;2;11;;@Override int compare(int from, int to) {     if (missingBucket) {         if (bits.get(from) == false) {             return bits.get(to) ? -1 * reverseMul : 0.         } else if (bits.get(to) == false) {             return reverseMul.         }     }     return compareValues(values.get(from), values.get(to)). }
false;;1;11;;@Override int compareCurrent(int slot) {     if (missingBucket) {         if (missingCurrentValue) {             return bits.get(slot) ? -1 * reverseMul : 0.         } else if (bits.get(slot) == false) {             return reverseMul.         }     }     return compareValues(currentValue, values.get(slot)). }
false;;0;11;;@Override int compareCurrentWithAfter() {     if (missingBucket) {         if (missingCurrentValue) {             return afterValue != null ? -1 * reverseMul : 0.         } else if (afterValue == null) {             return reverseMul.         }     }     return compareValues(currentValue, afterValue). }
false;;1;8;;@Override int hashCode(int slot) {     if (missingBucket && bits.get(slot) == false) {         return 0.     } else {         return Long.hashCode(values.get(slot)).     } }
false;;0;8;;@Override int hashCodeCurrent() {     if (missingCurrentValue) {         return 0.     } else {         return Long.hashCode(currentValue).     } }
false;private;2;3;;private int compareValues(long v1, long v2) {     return Long.compare(v1, v2) * reverseMul. }
false;;1;14;;@Override void setAfter(Comparable value) {     if (missingBucket && value == null) {         afterValue = null.     } else if (value instanceof Number) {         afterValue = ((Number) value).longValue().     } else {         // for date histogram source with "format", the after value is formatted         // as a string so we need to retrieve the original value in milliseconds.         afterValue = format.parseLong(value.toString(), false, () -> {             throw new IllegalArgumentException("now() is not supported in [after] key").         }).     } }
false;;1;7;;@Override Long toComparable(int slot) {     if (missingBucket && bits.get(slot) == false) {         return null.     }     return values.get(slot). }
false;public;2;14;;@Override public void collect(int doc, long bucket) throws IOException {     if (dvs.advanceExact(doc)) {         int num = dvs.docValueCount().         for (int i = 0. i < num. i++) {             currentValue = dvs.nextValue().             missingCurrentValue = false.             next.collect(doc, bucket).         }     } else if (missingBucket) {         missingCurrentValue = true.         next.collect(doc, bucket).     } }
false;;2;20;;@Override LeafBucketCollector getLeafCollector(LeafReaderContext context, LeafBucketCollector next) throws IOException {     final SortedNumericDocValues dvs = docValuesFunc.apply(context).     return new LeafBucketCollector() {          @Override         public void collect(int doc, long bucket) throws IOException {             if (dvs.advanceExact(doc)) {                 int num = dvs.docValueCount().                 for (int i = 0. i < num. i++) {                     currentValue = dvs.nextValue().                     missingCurrentValue = false.                     next.collect(doc, bucket).                 }             } else if (missingBucket) {                 missingCurrentValue = true.                 next.collect(doc, bucket).             }         }     }. }
false;public;2;4;;@Override public void collect(int doc, long bucket) throws IOException {     next.collect(doc, bucket). }
false;;3;13;;@Override LeafBucketCollector getLeafCollector(Comparable value, LeafReaderContext context, LeafBucketCollector next) {     if (value.getClass() != Long.class) {         throw new IllegalArgumentException("Expected Long, got " + value.getClass()).     }     currentValue = (Long) value.     return new LeafBucketCollector() {          @Override         public void collect(int doc, long bucket) throws IOException {             next.collect(doc, bucket).         }     }. }
false;private,static;1;11;;private static Query extractQuery(Query query) {     if (query instanceof BoostQuery) {         return extractQuery(((BoostQuery) query).getQuery()).     } else if (query instanceof IndexOrDocValuesQuery) {         return extractQuery(((IndexOrDocValuesQuery) query).getIndexQuery()).     } else if (query instanceof ConstantScoreQuery) {         return extractQuery(((ConstantScoreQuery) query).getQuery()).     } else {         return query.     } }
true;private,static;2;15;/**  * Returns true if we can use <code>query</code> with a {@link SortedDocsProducer} on <code>fieldName</code>.  */ ;/**  * Returns true if we can use <code>query</code> with a {@link SortedDocsProducer} on <code>fieldName</code>.  */ private static boolean checkMatchAllOrRangeQuery(Query query, String fieldName) {     if (query == null) {         return true.     } else if (query.getClass() == MatchAllDocsQuery.class) {         return true.     } else if (query instanceof PointRangeQuery) {         PointRangeQuery pointQuery = (PointRangeQuery) query.         return fieldName.equals(pointQuery.getField()).     } else if (query instanceof DocValuesFieldExistsQuery) {         DocValuesFieldExistsQuery existsQuery = (DocValuesFieldExistsQuery) query.         return fieldName.equals(existsQuery.getField()).     } else {         return false.     } }
false;;2;44;;@Override SortedDocsProducer createSortedDocsProducerOrNull(IndexReader reader, Query query) {     query = extractQuery(query).     if (checkIfSortedDocsIsApplicable(reader, fieldType) == false || checkMatchAllOrRangeQuery(query, fieldType.name()) == false) {         return null.     }     final byte[] lowerPoint.     final byte[] upperPoint.     if (query instanceof PointRangeQuery) {         final PointRangeQuery rangeQuery = (PointRangeQuery) query.         lowerPoint = rangeQuery.getLowerPoint().         upperPoint = rangeQuery.getUpperPoint().     } else {         lowerPoint = null.         upperPoint = null.     }     if (fieldType instanceof NumberFieldMapper.NumberFieldType) {         NumberFieldMapper.NumberFieldType ft = (NumberFieldMapper.NumberFieldType) fieldType.         final ToLongFunction<byte[]> toBucketFunction.         switch(ft.typeName()) {             case "long":                 toBucketFunction = (value) -> rounding.applyAsLong(LongPoint.decodeDimension(value, 0)).                 break.             case "int":             case "short":             case "byte":                 toBucketFunction = (value) -> rounding.applyAsLong(IntPoint.decodeDimension(value, 0)).                 break.             default:                 return null.         }         return new PointsSortedDocsProducer(fieldType.name(), toBucketFunction, lowerPoint, upperPoint).     } else if (fieldType instanceof DateFieldMapper.DateFieldType) {         final ToLongFunction<byte[]> toBucketFunction = (value) -> rounding.applyAsLong(LongPoint.decodeDimension(value, 0)).         return new PointsSortedDocsProducer(fieldType.name(), toBucketFunction, lowerPoint, upperPoint).     } else {         return null.     } }
false;public;0;4;;@Override public void close() {     Releasables.close(values, bits). }
