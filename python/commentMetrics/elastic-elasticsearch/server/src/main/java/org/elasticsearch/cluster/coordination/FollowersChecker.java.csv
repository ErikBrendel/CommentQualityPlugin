# id;timestamp;commentText;codeText;commentWords;codeWords
FollowersChecker -> public void setCurrentNodes(DiscoveryNodes discoveryNodes);1544081506;Update the set of known nodes, starting to check any new ones and stopping checking any previously-known-but-now-unknown ones.;public void setCurrentNodes(DiscoveryNodes discoveryNodes) {_        synchronized (mutex) {_            final Predicate<DiscoveryNode> isUnknownNode = n -> discoveryNodes.nodeExists(n) == false__            followerCheckers.keySet().removeIf(isUnknownNode)__            faultyNodes.removeIf(isUnknownNode)___            for (final DiscoveryNode discoveryNode : discoveryNodes) {_                if (discoveryNode.equals(discoveryNodes.getLocalNode()) == false_                    && followerCheckers.containsKey(discoveryNode) == false_                    && faultyNodes.contains(discoveryNode) == false) {__                    final FollowerChecker followerChecker = new FollowerChecker(discoveryNode)__                    followerCheckers.put(discoveryNode, followerChecker)__                    followerChecker.start()__                }_            }_        }_    };update,the,set,of,known,nodes,starting,to,check,any,new,ones,and,stopping,checking,any,previously,known,but,now,unknown,ones;public,void,set,current,nodes,discovery,nodes,discovery,nodes,synchronized,mutex,final,predicate,discovery,node,is,unknown,node,n,discovery,nodes,node,exists,n,false,follower,checkers,key,set,remove,if,is,unknown,node,faulty,nodes,remove,if,is,unknown,node,for,final,discovery,node,discovery,node,discovery,nodes,if,discovery,node,equals,discovery,nodes,get,local,node,false,follower,checkers,contains,key,discovery,node,false,faulty,nodes,contains,discovery,node,false,final,follower,checker,follower,checker,new,follower,checker,discovery,node,follower,checkers,put,discovery,node,follower,checker,follower,checker,start
FollowersChecker -> public void setCurrentNodes(DiscoveryNodes discoveryNodes);1548161590;Update the set of known nodes, starting to check any new ones and stopping checking any previously-known-but-now-unknown ones.;public void setCurrentNodes(DiscoveryNodes discoveryNodes) {_        synchronized (mutex) {_            final Predicate<DiscoveryNode> isUnknownNode = n -> discoveryNodes.nodeExists(n) == false__            followerCheckers.keySet().removeIf(isUnknownNode)__            faultyNodes.removeIf(isUnknownNode)___            discoveryNodes.mastersFirstStream().forEach(discoveryNode -> {_                if (discoveryNode.equals(discoveryNodes.getLocalNode()) == false_                    && followerCheckers.containsKey(discoveryNode) == false_                    && faultyNodes.contains(discoveryNode) == false) {__                    final FollowerChecker followerChecker = new FollowerChecker(discoveryNode)__                    followerCheckers.put(discoveryNode, followerChecker)__                    followerChecker.start()__                }_            })__        }_    };update,the,set,of,known,nodes,starting,to,check,any,new,ones,and,stopping,checking,any,previously,known,but,now,unknown,ones;public,void,set,current,nodes,discovery,nodes,discovery,nodes,synchronized,mutex,final,predicate,discovery,node,is,unknown,node,n,discovery,nodes,node,exists,n,false,follower,checkers,key,set,remove,if,is,unknown,node,faulty,nodes,remove,if,is,unknown,node,discovery,nodes,masters,first,stream,for,each,discovery,node,if,discovery,node,equals,discovery,nodes,get,local,node,false,follower,checkers,contains,key,discovery,node,false,faulty,nodes,contains,discovery,node,false,final,follower,checker,follower,checker,new,follower,checker,discovery,node,follower,checkers,put,discovery,node,follower,checker,follower,checker,start
FollowersChecker -> public void setCurrentNodes(DiscoveryNodes discoveryNodes);1548952864;Update the set of known nodes, starting to check any new ones and stopping checking any previously-known-but-now-unknown ones.;public void setCurrentNodes(DiscoveryNodes discoveryNodes) {_        synchronized (mutex) {_            final Predicate<DiscoveryNode> isUnknownNode = n -> discoveryNodes.nodeExists(n) == false__            followerCheckers.keySet().removeIf(isUnknownNode)__            faultyNodes.removeIf(isUnknownNode)___            discoveryNodes.mastersFirstStream().forEach(discoveryNode -> {_                if (discoveryNode.equals(discoveryNodes.getLocalNode()) == false_                    && followerCheckers.containsKey(discoveryNode) == false_                    && faultyNodes.contains(discoveryNode) == false) {__                    final FollowerChecker followerChecker = new FollowerChecker(discoveryNode)__                    followerCheckers.put(discoveryNode, followerChecker)__                    followerChecker.start()__                }_            })__        }_    };update,the,set,of,known,nodes,starting,to,check,any,new,ones,and,stopping,checking,any,previously,known,but,now,unknown,ones;public,void,set,current,nodes,discovery,nodes,discovery,nodes,synchronized,mutex,final,predicate,discovery,node,is,unknown,node,n,discovery,nodes,node,exists,n,false,follower,checkers,key,set,remove,if,is,unknown,node,faulty,nodes,remove,if,is,unknown,node,discovery,nodes,masters,first,stream,for,each,discovery,node,if,discovery,node,equals,discovery,nodes,get,local,node,false,follower,checkers,contains,key,discovery,node,false,faulty,nodes,contains,discovery,node,false,final,follower,checker,follower,checker,new,follower,checker,discovery,node,follower,checkers,put,discovery,node,follower,checker,follower,checker,start
FollowersChecker -> public void setCurrentNodes(DiscoveryNodes discoveryNodes);1548953505;Update the set of known nodes, starting to check any new ones and stopping checking any previously-known-but-now-unknown ones.;public void setCurrentNodes(DiscoveryNodes discoveryNodes) {_        synchronized (mutex) {_            final Predicate<DiscoveryNode> isUnknownNode = n -> discoveryNodes.nodeExists(n) == false__            followerCheckers.keySet().removeIf(isUnknownNode)__            faultyNodes.removeIf(isUnknownNode)___            discoveryNodes.mastersFirstStream().forEach(discoveryNode -> {_                if (discoveryNode.equals(discoveryNodes.getLocalNode()) == false_                    && followerCheckers.containsKey(discoveryNode) == false_                    && faultyNodes.contains(discoveryNode) == false) {__                    final FollowerChecker followerChecker = new FollowerChecker(discoveryNode)__                    followerCheckers.put(discoveryNode, followerChecker)__                    followerChecker.start()__                }_            })__        }_    };update,the,set,of,known,nodes,starting,to,check,any,new,ones,and,stopping,checking,any,previously,known,but,now,unknown,ones;public,void,set,current,nodes,discovery,nodes,discovery,nodes,synchronized,mutex,final,predicate,discovery,node,is,unknown,node,n,discovery,nodes,node,exists,n,false,follower,checkers,key,set,remove,if,is,unknown,node,faulty,nodes,remove,if,is,unknown,node,discovery,nodes,masters,first,stream,for,each,discovery,node,if,discovery,node,equals,discovery,nodes,get,local,node,false,follower,checkers,contains,key,discovery,node,false,faulty,nodes,contains,discovery,node,false,final,follower,checker,follower,checker,new,follower,checker,discovery,node,follower,checkers,put,discovery,node,follower,checker,follower,checker,start
FollowersChecker -> public void setCurrentNodes(DiscoveryNodes discoveryNodes);1549289472;Update the set of known nodes, starting to check any new ones and stopping checking any previously-known-but-now-unknown ones.;public void setCurrentNodes(DiscoveryNodes discoveryNodes) {_        synchronized (mutex) {_            final Predicate<DiscoveryNode> isUnknownNode = n -> discoveryNodes.nodeExists(n) == false__            followerCheckers.keySet().removeIf(isUnknownNode)__            faultyNodes.removeIf(isUnknownNode)___            discoveryNodes.mastersFirstStream().forEach(discoveryNode -> {_                if (discoveryNode.equals(discoveryNodes.getLocalNode()) == false_                    && followerCheckers.containsKey(discoveryNode) == false_                    && faultyNodes.contains(discoveryNode) == false) {__                    final FollowerChecker followerChecker = new FollowerChecker(discoveryNode)__                    followerCheckers.put(discoveryNode, followerChecker)__                    followerChecker.start()__                }_            })__        }_    };update,the,set,of,known,nodes,starting,to,check,any,new,ones,and,stopping,checking,any,previously,known,but,now,unknown,ones;public,void,set,current,nodes,discovery,nodes,discovery,nodes,synchronized,mutex,final,predicate,discovery,node,is,unknown,node,n,discovery,nodes,node,exists,n,false,follower,checkers,key,set,remove,if,is,unknown,node,faulty,nodes,remove,if,is,unknown,node,discovery,nodes,masters,first,stream,for,each,discovery,node,if,discovery,node,equals,discovery,nodes,get,local,node,false,follower,checkers,contains,key,discovery,node,false,faulty,nodes,contains,discovery,node,false,final,follower,checker,follower,checker,new,follower,checker,discovery,node,follower,checkers,put,discovery,node,follower,checker,follower,checker,start
FollowersChecker -> public Set<DiscoveryNode> getFaultyNodes();1544081506;@return nodes in the current cluster state which have failed their follower checks.;public Set<DiscoveryNode> getFaultyNodes() {_        synchronized (mutex) {_            return new HashSet<>(this.faultyNodes)__        }_    };return,nodes,in,the,current,cluster,state,which,have,failed,their,follower,checks;public,set,discovery,node,get,faulty,nodes,synchronized,mutex,return,new,hash,set,this,faulty,nodes
FollowersChecker -> public Set<DiscoveryNode> getFaultyNodes();1548161590;@return nodes in the current cluster state which have failed their follower checks.;public Set<DiscoveryNode> getFaultyNodes() {_        synchronized (mutex) {_            return new HashSet<>(this.faultyNodes)__        }_    };return,nodes,in,the,current,cluster,state,which,have,failed,their,follower,checks;public,set,discovery,node,get,faulty,nodes,synchronized,mutex,return,new,hash,set,this,faulty,nodes
FollowersChecker -> public Set<DiscoveryNode> getFaultyNodes();1548952864;@return nodes in the current cluster state which have failed their follower checks.;public Set<DiscoveryNode> getFaultyNodes() {_        synchronized (mutex) {_            return new HashSet<>(this.faultyNodes)__        }_    };return,nodes,in,the,current,cluster,state,which,have,failed,their,follower,checks;public,set,discovery,node,get,faulty,nodes,synchronized,mutex,return,new,hash,set,this,faulty,nodes
FollowersChecker -> public Set<DiscoveryNode> getFaultyNodes();1548953505;@return nodes in the current cluster state which have failed their follower checks.;public Set<DiscoveryNode> getFaultyNodes() {_        synchronized (mutex) {_            return new HashSet<>(this.faultyNodes)__        }_    };return,nodes,in,the,current,cluster,state,which,have,failed,their,follower,checks;public,set,discovery,node,get,faulty,nodes,synchronized,mutex,return,new,hash,set,this,faulty,nodes
FollowersChecker -> public Set<DiscoveryNode> getFaultyNodes();1549289472;@return nodes in the current cluster state which have failed their follower checks.;public Set<DiscoveryNode> getFaultyNodes() {_        synchronized (mutex) {_            return new HashSet<>(this.faultyNodes)__        }_    };return,nodes,in,the,current,cluster,state,which,have,failed,their,follower,checks;public,set,discovery,node,get,faulty,nodes,synchronized,mutex,return,new,hash,set,this,faulty,nodes
FollowersChecker -> public void updateFastResponseState(final long term, final Mode mode);1544081506;The system is normally in a state in which every follower remains a follower of a stable leader in a single term for an extended_period of time, and therefore our response to every follower check is the same. We handle this case with a single volatile read_entirely on the network thread, and only if the fast path fails do we perform some work in the background, by notifying the_FollowersChecker whenever our term or mode changes here.;public void updateFastResponseState(final long term, final Mode mode) {_        fastResponseState = new FastResponseState(term, mode)__    };the,system,is,normally,in,a,state,in,which,every,follower,remains,a,follower,of,a,stable,leader,in,a,single,term,for,an,extended,period,of,time,and,therefore,our,response,to,every,follower,check,is,the,same,we,handle,this,case,with,a,single,volatile,read,entirely,on,the,network,thread,and,only,if,the,fast,path,fails,do,we,perform,some,work,in,the,background,by,notifying,the,followers,checker,whenever,our,term,or,mode,changes,here;public,void,update,fast,response,state,final,long,term,final,mode,mode,fast,response,state,new,fast,response,state,term,mode
FollowersChecker -> public void updateFastResponseState(final long term, final Mode mode);1548161590;The system is normally in a state in which every follower remains a follower of a stable leader in a single term for an extended_period of time, and therefore our response to every follower check is the same. We handle this case with a single volatile read_entirely on the network thread, and only if the fast path fails do we perform some work in the background, by notifying the_FollowersChecker whenever our term or mode changes here.;public void updateFastResponseState(final long term, final Mode mode) {_        fastResponseState = new FastResponseState(term, mode)__    };the,system,is,normally,in,a,state,in,which,every,follower,remains,a,follower,of,a,stable,leader,in,a,single,term,for,an,extended,period,of,time,and,therefore,our,response,to,every,follower,check,is,the,same,we,handle,this,case,with,a,single,volatile,read,entirely,on,the,network,thread,and,only,if,the,fast,path,fails,do,we,perform,some,work,in,the,background,by,notifying,the,followers,checker,whenever,our,term,or,mode,changes,here;public,void,update,fast,response,state,final,long,term,final,mode,mode,fast,response,state,new,fast,response,state,term,mode
FollowersChecker -> public void updateFastResponseState(final long term, final Mode mode);1548952864;The system is normally in a state in which every follower remains a follower of a stable leader in a single term for an extended_period of time, and therefore our response to every follower check is the same. We handle this case with a single volatile read_entirely on the network thread, and only if the fast path fails do we perform some work in the background, by notifying the_FollowersChecker whenever our term or mode changes here.;public void updateFastResponseState(final long term, final Mode mode) {_        fastResponseState = new FastResponseState(term, mode)__    };the,system,is,normally,in,a,state,in,which,every,follower,remains,a,follower,of,a,stable,leader,in,a,single,term,for,an,extended,period,of,time,and,therefore,our,response,to,every,follower,check,is,the,same,we,handle,this,case,with,a,single,volatile,read,entirely,on,the,network,thread,and,only,if,the,fast,path,fails,do,we,perform,some,work,in,the,background,by,notifying,the,followers,checker,whenever,our,term,or,mode,changes,here;public,void,update,fast,response,state,final,long,term,final,mode,mode,fast,response,state,new,fast,response,state,term,mode
FollowersChecker -> public void updateFastResponseState(final long term, final Mode mode);1548953505;The system is normally in a state in which every follower remains a follower of a stable leader in a single term for an extended_period of time, and therefore our response to every follower check is the same. We handle this case with a single volatile read_entirely on the network thread, and only if the fast path fails do we perform some work in the background, by notifying the_FollowersChecker whenever our term or mode changes here.;public void updateFastResponseState(final long term, final Mode mode) {_        fastResponseState = new FastResponseState(term, mode)__    };the,system,is,normally,in,a,state,in,which,every,follower,remains,a,follower,of,a,stable,leader,in,a,single,term,for,an,extended,period,of,time,and,therefore,our,response,to,every,follower,check,is,the,same,we,handle,this,case,with,a,single,volatile,read,entirely,on,the,network,thread,and,only,if,the,fast,path,fails,do,we,perform,some,work,in,the,background,by,notifying,the,followers,checker,whenever,our,term,or,mode,changes,here;public,void,update,fast,response,state,final,long,term,final,mode,mode,fast,response,state,new,fast,response,state,term,mode
FollowersChecker -> public void updateFastResponseState(final long term, final Mode mode);1549289472;The system is normally in a state in which every follower remains a follower of a stable leader in a single term for an extended_period of time, and therefore our response to every follower check is the same. We handle this case with a single volatile read_entirely on the network thread, and only if the fast path fails do we perform some work in the background, by notifying the_FollowersChecker whenever our term or mode changes here.;public void updateFastResponseState(final long term, final Mode mode) {_        fastResponseState = new FastResponseState(term, mode)__    };the,system,is,normally,in,a,state,in,which,every,follower,remains,a,follower,of,a,stable,leader,in,a,single,term,for,an,extended,period,of,time,and,therefore,our,response,to,every,follower,check,is,the,same,we,handle,this,case,with,a,single,volatile,read,entirely,on,the,network,thread,and,only,if,the,fast,path,fails,do,we,perform,some,work,in,the,background,by,notifying,the,followers,checker,whenever,our,term,or,mode,changes,here;public,void,update,fast,response,state,final,long,term,final,mode,mode,fast,response,state,new,fast,response,state,term,mode
FollowersChecker -> public void clearCurrentNodes();1544081506;Clear the set of known nodes, stopping all checks.;public void clearCurrentNodes() {_        setCurrentNodes(DiscoveryNodes.EMPTY_NODES)__    };clear,the,set,of,known,nodes,stopping,all,checks;public,void,clear,current,nodes,set,current,nodes,discovery,nodes
FollowersChecker -> public void clearCurrentNodes();1548161590;Clear the set of known nodes, stopping all checks.;public void clearCurrentNodes() {_        setCurrentNodes(DiscoveryNodes.EMPTY_NODES)__    };clear,the,set,of,known,nodes,stopping,all,checks;public,void,clear,current,nodes,set,current,nodes,discovery,nodes
FollowersChecker -> public void clearCurrentNodes();1548952864;Clear the set of known nodes, stopping all checks.;public void clearCurrentNodes() {_        setCurrentNodes(DiscoveryNodes.EMPTY_NODES)__    };clear,the,set,of,known,nodes,stopping,all,checks;public,void,clear,current,nodes,set,current,nodes,discovery,nodes
FollowersChecker -> public void clearCurrentNodes();1548953505;Clear the set of known nodes, stopping all checks.;public void clearCurrentNodes() {_        setCurrentNodes(DiscoveryNodes.EMPTY_NODES)__    };clear,the,set,of,known,nodes,stopping,all,checks;public,void,clear,current,nodes,set,current,nodes,discovery,nodes
FollowersChecker -> public void clearCurrentNodes();1549289472;Clear the set of known nodes, stopping all checks.;public void clearCurrentNodes() {_        setCurrentNodes(DiscoveryNodes.EMPTY_NODES)__    };clear,the,set,of,known,nodes,stopping,all,checks;public,void,clear,current,nodes,set,current,nodes,discovery,nodes
