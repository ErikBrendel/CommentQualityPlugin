commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public void onNodeDisconnected(DiscoveryNode node) {     handleDisconnectedNode(node). }
true;public;1;18;/**  * Update the set of known nodes, starting to check any new ones and stopping checking any previously-known-but-now-unknown ones.  */ ;/**  * Update the set of known nodes, starting to check any new ones and stopping checking any previously-known-but-now-unknown ones.  */ public void setCurrentNodes(DiscoveryNodes discoveryNodes) {     synchronized (mutex) {         final Predicate<DiscoveryNode> isUnknownNode = n -> discoveryNodes.nodeExists(n) == false.         followerCheckers.keySet().removeIf(isUnknownNode).         faultyNodes.removeIf(isUnknownNode).         discoveryNodes.mastersFirstStream().forEach(discoveryNode -> {             if (discoveryNode.equals(discoveryNodes.getLocalNode()) == false && followerCheckers.containsKey(discoveryNode) == false && faultyNodes.contains(discoveryNode) == false) {                 final FollowerChecker followerChecker = new FollowerChecker(discoveryNode).                 followerCheckers.put(discoveryNode, followerChecker).                 followerChecker.start().             }         }).     } }
true;public;0;3;/**  * Clear the set of known nodes, stopping all checks.  */ ;/**  * Clear the set of known nodes, stopping all checks.  */ public void clearCurrentNodes() {     setCurrentNodes(DiscoveryNodes.EMPTY_NODES). }
true;public;2;3;/**  * The system is normally in a state in which every follower remains a follower of a stable leader in a single term for an extended  * period of time, and therefore our response to every follower check is the same. We handle this case with a single volatile read  * entirely on the network thread, and only if the fast path fails do we perform some work in the background, by notifying the  * FollowersChecker whenever our term or mode changes here.  */ ;/**  * The system is normally in a state in which every follower remains a follower of a stable leader in a single term for an extended  * period of time, and therefore our response to every follower check is the same. We handle this case with a single volatile read  * entirely on the network thread, and only if the fast path fails do we perform some work in the background, by notifying the  * FollowersChecker whenever our term or mode changes here.  */ public void updateFastResponseState(final long term, final Mode mode) {     fastResponseState = new FastResponseState(term, mode). }
false;protected;0;11;;@Override protected void doRun() throws IOException {     logger.trace("responding to {} on slow path", request).     try {         handleRequestAndUpdateState.accept(request).     } catch (Exception e) {         transportChannel.sendResponse(e).         return.     }     transportChannel.sendResponse(Empty.INSTANCE). }
false;public;1;4;;@Override public void onFailure(Exception e) {     logger.debug(new ParameterizedMessage("exception while responding to {}", request), e). }
false;public;0;4;;@Override public String toString() {     return "slow path response to " + request. }
false;private;2;38;;private void handleFollowerCheck(FollowerCheckRequest request, TransportChannel transportChannel) throws IOException {     FastResponseState responder = this.fastResponseState.     if (responder.mode == Mode.FOLLOWER && responder.term == request.term) {         // TODO trigger a term bump if we voted for a different leader in this term         logger.trace("responding to {} on fast path", request).         transportChannel.sendResponse(Empty.INSTANCE).         return.     }     if (request.term < responder.term) {         throw new CoordinationStateRejectedException("rejecting " + request + " since local state is " + this).     }     transportService.getThreadPool().generic().execute(new AbstractRunnable() {          @Override         protected void doRun() throws IOException {             logger.trace("responding to {} on slow path", request).             try {                 handleRequestAndUpdateState.accept(request).             } catch (Exception e) {                 transportChannel.sendResponse(e).                 return.             }             transportChannel.sendResponse(Empty.INSTANCE).         }          @Override         public void onFailure(Exception e) {             logger.debug(new ParameterizedMessage("exception while responding to {}", request), e).         }          @Override         public String toString() {             return "slow path response to " + request.         }     }). }
true;public;0;5;/**  * @return nodes in the current cluster state which have failed their follower checks.  */ ;// TODO in the PoC a faulty node was considered non-faulty again if it sent us a PeersRequest: // - node disconnects, detected faulty, removal is enqueued // - node reconnects, pings us, finds we are master, requests to join, all before removal is applied // - join is processed before removal, but we do not publish to known-faulty nodes so the joining node does not receive this publication // - it doesn't start its leader checker since it receives nothing to cause it to become a follower // Apparently this meant that it remained a candidate for too long, leading to a test failure.  At the time this logic was added, we did // not have gossip-based discovery which would (I think) have retried this joining process a short time later. It's therefore possible // that this is no longer required, so it's omitted here until we can be sure if it's necessary or not. /**  * @return nodes in the current cluster state which have failed their follower checks.  */ public Set<DiscoveryNode> getFaultyNodes() {     synchronized (mutex) {         return new HashSet<>(this.faultyNodes).     } }
false;public;0;11;;@Override public String toString() {     return "FollowersChecker{" + "followerCheckInterval=" + followerCheckInterval + ", followerCheckTimeout=" + followerCheckTimeout + ", followerCheckRetryCount=" + followerCheckRetryCount + ", followerCheckers=" + followerCheckers + ", faultyNodes=" + faultyNodes + ", fastResponseState=" + fastResponseState + '}'. }
true;;0;3;// For assertions ;// For assertions FastResponseState getFastResponseState() {     return fastResponseState. }
true;;0;7;// For assertions ;// For assertions Set<DiscoveryNode> getKnownFollowers() {     synchronized (mutex) {         final Set<DiscoveryNode> knownFollowers = new HashSet<>(faultyNodes).         knownFollowers.addAll(followerCheckers.keySet()).         return knownFollowers.     } }
false;private;1;8;;private void handleDisconnectedNode(DiscoveryNode discoveryNode) {     synchronized (mutex) {         FollowerChecker followerChecker = followerCheckers.get(discoveryNode).         if (followerChecker != null && followerChecker.running()) {             followerChecker.failNode("disconnected").         }     } }
false;public;0;7;;@Override public String toString() {     return "FastResponseState{" + "term=" + term + ", mode=" + mode + '}'. }
false;private;0;3;;private boolean running() {     return this == followerCheckers.get(discoveryNode). }
false;;0;4;;void start() {     assert running().     handleWakeUp(). }
false;public;1;4;;@Override public Empty read(StreamInput in) {     return Empty.INSTANCE. }
false;public;1;11;;@Override public void handleResponse(Empty response) {     if (running() == false) {         logger.trace("{} no longer running", FollowerChecker.this).         return.     }     failureCountSinceLastSuccess = 0.     logger.trace("{} check successful", FollowerChecker.this).     scheduleNextWakeUp(). }
false;public;1;25;;@Override public void handleException(TransportException exp) {     if (running() == false) {         logger.debug(new ParameterizedMessage("{} no longer running", FollowerChecker.this), exp).         return.     }     failureCountSinceLastSuccess++.     final String reason.     if (failureCountSinceLastSuccess >= followerCheckRetryCount) {         logger.debug(() -> new ParameterizedMessage("{} failed too many times", FollowerChecker.this), exp).         reason = "followers check retry count exceeded".     } else if (exp instanceof ConnectTransportException || exp.getCause() instanceof ConnectTransportException) {         logger.debug(() -> new ParameterizedMessage("{} disconnected", FollowerChecker.this), exp).         reason = "disconnected".     } else {         logger.debug(() -> new ParameterizedMessage("{} failed, retrying", FollowerChecker.this), exp).         scheduleNextWakeUp().         return.     }     failNode(reason). }
false;public;0;4;;@Override public String executor() {     return Names.SAME. }
false;private;0;72;;private void handleWakeUp() {     if (running() == false) {         logger.trace("handleWakeUp: not running").         return.     }     final FollowerCheckRequest request = new FollowerCheckRequest(fastResponseState.term, transportService.getLocalNode()).     logger.trace("handleWakeUp: checking {} with {}", discoveryNode, request).     final String actionName.     final TransportRequest transportRequest.     if (Coordinator.isZen1Node(discoveryNode)) {         actionName = NodesFaultDetection.PING_ACTION_NAME.         transportRequest = new NodesFaultDetection.PingRequest(discoveryNode, ClusterName.CLUSTER_NAME_SETTING.get(settings), transportService.getLocalNode(), ClusterState.UNKNOWN_VERSION).     } else {         actionName = FOLLOWER_CHECK_ACTION_NAME.         transportRequest = request.     }     transportService.sendRequest(discoveryNode, actionName, transportRequest, TransportRequestOptions.builder().withTimeout(followerCheckTimeout).withType(Type.PING).build(), new TransportResponseHandler<Empty>() {          @Override         public Empty read(StreamInput in) {             return Empty.INSTANCE.         }          @Override         public void handleResponse(Empty response) {             if (running() == false) {                 logger.trace("{} no longer running", FollowerChecker.this).                 return.             }             failureCountSinceLastSuccess = 0.             logger.trace("{} check successful", FollowerChecker.this).             scheduleNextWakeUp().         }          @Override         public void handleException(TransportException exp) {             if (running() == false) {                 logger.debug(new ParameterizedMessage("{} no longer running", FollowerChecker.this), exp).                 return.             }             failureCountSinceLastSuccess++.             final String reason.             if (failureCountSinceLastSuccess >= followerCheckRetryCount) {                 logger.debug(() -> new ParameterizedMessage("{} failed too many times", FollowerChecker.this), exp).                 reason = "followers check retry count exceeded".             } else if (exp instanceof ConnectTransportException || exp.getCause() instanceof ConnectTransportException) {                 logger.debug(() -> new ParameterizedMessage("{} disconnected", FollowerChecker.this), exp).                 reason = "disconnected".             } else {                 logger.debug(() -> new ParameterizedMessage("{} failed, retrying", FollowerChecker.this), exp).                 scheduleNextWakeUp().                 return.             }             failNode(reason).         }          @Override         public String executor() {             return Names.SAME.         }     }). }
false;public;0;13;;@Override public void run() {     synchronized (mutex) {         if (running() == false) {             logger.trace("{} no longer running, not marking faulty", FollowerChecker.this).             return.         }         logger.debug("{} marking node as faulty", FollowerChecker.this).         faultyNodes.add(discoveryNode).         followerCheckers.remove(discoveryNode).     }     onNodeFailure.accept(discoveryNode, reason). }
false;public;0;4;;@Override public String toString() {     return "detected failure of " + discoveryNode. }
false;;1;22;;void failNode(String reason) {     transportService.getThreadPool().generic().execute(new Runnable() {          @Override         public void run() {             synchronized (mutex) {                 if (running() == false) {                     logger.trace("{} no longer running, not marking faulty", FollowerChecker.this).                     return.                 }                 logger.debug("{} marking node as faulty", FollowerChecker.this).                 faultyNodes.add(discoveryNode).                 followerCheckers.remove(discoveryNode).             }             onNodeFailure.accept(discoveryNode, reason).         }          @Override         public String toString() {             return "detected failure of " + discoveryNode.         }     }). }
false;public;0;4;;@Override public void run() {     handleWakeUp(). }
false;public;0;4;;@Override public String toString() {     return FollowerChecker.this + "::handleWakeUp". }
false;private;0;13;;private void scheduleNextWakeUp() {     transportService.getThreadPool().schedule(new Runnable() {          @Override         public void run() {             handleWakeUp().         }          @Override         public String toString() {             return FollowerChecker.this + "::handleWakeUp".         }     }, followerCheckInterval, Names.SAME). }
false;public;0;8;;@Override public String toString() {     return "FollowerChecker{" + "discoveryNode=" + discoveryNode + ", failureCountSinceLastSuccess=" + failureCountSinceLastSuccess + ", [" + FOLLOWER_CHECK_RETRY_COUNT_SETTING.getKey() + "]=" + followerCheckRetryCount + '}'. }
false;public;0;3;;public long getTerm() {     return term. }
false;public;0;3;;public DiscoveryNode getSender() {     return sender. }
false;public;1;6;;@Override public void writeTo(final StreamOutput out) throws IOException {     super.writeTo(out).     out.writeLong(term).     sender.writeTo(out). }
false;public;1;8;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     FollowerCheckRequest that = (FollowerCheckRequest) o.     return term == that.term && Objects.equals(sender, that.sender). }
false;public;0;7;;@Override public String toString() {     return "FollowerCheckRequest{" + "term=" + term + ", sender=" + sender + '}'. }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(term, sender). }
