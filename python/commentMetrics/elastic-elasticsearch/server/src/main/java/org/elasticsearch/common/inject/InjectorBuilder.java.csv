commented;modifiers;parameterAmount;loc;comment;code
true;;1;5;/**  * Sets the stage for the created injector. If the stage is {@link Stage#PRODUCTION}, this class  * will eagerly load singletons.  */ ;/**  * Sets the stage for the created injector. If the stage is {@link Stage#PRODUCTION}, this class  * will eagerly load singletons.  */ InjectorBuilder stage(Stage stage) {     shellBuilder.stage(stage).     this.stage = stage.     return this. }
false;;1;4;;InjectorBuilder addModules(Iterable<? extends Module> modules) {     shellBuilder.addModules(modules).     return this. }
false;;0;18;;Injector build() {     if (shellBuilder == null) {         throw new AssertionError("Already built, builders are not reusable.").     }     // the JIT bindings in the parent injector don't change while we're being built     synchronized (shellBuilder.lock()) {         shells = shellBuilder.build(initializer, bindingProcesor, stopwatch, errors).         stopwatch.resetAndLog("Injector construction").         initializeStatically().     }     injectDynamically().     return primaryInjector(). }
true;private;0;35;/**  * Initialize and validate everything.  */ ;/**  * Initialize and validate everything.  */ private void initializeStatically() {     bindingProcesor.initializeBindings().     stopwatch.resetAndLog("Binding initialization").     for (InjectorShell shell : shells) {         shell.getInjector().index().     }     stopwatch.resetAndLog("Binding indexing").     injectionRequestProcessor.process(shells).     stopwatch.resetAndLog("Collecting injection requests").     bindingProcesor.runCreationListeners().     stopwatch.resetAndLog("Binding validation").     injectionRequestProcessor.validate().     stopwatch.resetAndLog("Static validation").     initializer.validateOustandingInjections(errors).     stopwatch.resetAndLog("Instance member validation").     new LookupProcessor(errors).process(shells).     for (InjectorShell shell : shells) {         ((DeferredLookups) shell.getInjector().lookups).initialize(errors).     }     stopwatch.resetAndLog("Provider verification").     for (InjectorShell shell : shells) {         if (!shell.getElements().isEmpty()) {             throw new AssertionError("Failed to execute " + shell.getElements()).         }     }     errors.throwCreationExceptionIfErrorsExist(). }
true;private;0;3;/**  * Returns the injector being constructed. This is not necessarily the root injector.  */ ;/**  * Returns the injector being constructed. This is not necessarily the root injector.  */ private Injector primaryInjector() {     return shells.get(0).getInjector(). }
true;private;0;14;/**  * Inject everything that can be injected. This method is intentionally not synchronized. If we  * locked while injecting members (ie. running user code), things would deadlock should the user  * code build a just-in-time binding from another thread.  */ ;/**  * Inject everything that can be injected. This method is intentionally not synchronized. If we  * locked while injecting members (ie. running user code), things would deadlock should the user  * code build a just-in-time binding from another thread.  */ private void injectDynamically() {     injectionRequestProcessor.injectMembers().     stopwatch.resetAndLog("Static member injection").     initializer.injectAll(errors).     stopwatch.resetAndLog("Instance injection").     errors.throwCreationExceptionIfErrorsExist().     for (InjectorShell shell : shells) {         loadEagerSingletons(shell.getInjector(), stage, errors).     }     stopwatch.resetAndLog("Preloading singletons").     errors.throwCreationExceptionIfErrorsExist(). }
true;public;3;8;/**  * Loads eager singletons, or all singletons if we're in Stage.PRODUCTION. Bindings discovered  * while we're binding these singletons are not be eager.  */ ;/**  * Loads eager singletons, or all singletons if we're in Stage.PRODUCTION. Bindings discovered  * while we're binding these singletons are not be eager.  */ public void loadEagerSingletons(InjectorImpl injector, Stage stage, Errors errors) {     for (final Binding<?> binding : injector.state.getExplicitBindingsThisLevel().values()) {         loadEagerSingletons(injector, stage, errors, (BindingImpl<?>) binding).     }     for (final Binding<?> binding : injector.jitBindings.values()) {         loadEagerSingletons(injector, stage, errors, (BindingImpl<?>) binding).     } }
false;public;1;14;;@Override public Void call(InternalContext context) {     context.setDependency(dependency).     Errors errorsForBinding = errors.withSource(dependency).     try {         binding.getInternalFactory().get(errorsForBinding, context, dependency).     } catch (ErrorsException e) {         errorsForBinding.merge(e.getErrors()).     } finally {         context.setDependency(null).     }     return null. }
false;private;4;26;;private void loadEagerSingletons(InjectorImpl injector, Stage stage, final Errors errors, BindingImpl<?> binding) {     if (binding.getScoping().isEagerSingleton(stage)) {         try {             injector.callInContext(new ContextualCallable<Void>() {                  Dependency<?> dependency = Dependency.get(binding.getKey()).                  @Override                 public Void call(InternalContext context) {                     context.setDependency(dependency).                     Errors errorsForBinding = errors.withSource(dependency).                     try {                         binding.getInternalFactory().get(errorsForBinding, context, dependency).                     } catch (ErrorsException e) {                         errorsForBinding.merge(e.getErrors()).                     } finally {                         context.setDependency(null).                     }                     return null.                 }             }).         } catch (ErrorsException e) {             throw new AssertionError().         }     } }
