commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * returns the retrieved field mapping. The return map keys are index, type, field (as specified in the request).  */ ;/**  * returns the retrieved field mapping. The return map keys are index, type, field (as specified in the request).  */ public Map<String, Map<String, Map<String, FieldMappingMetaData>>> mappings() {     return mappings. }
true;public;3;11;/**  * Returns the mappings of a specific field.  *  * @param field field name as specified in the {@link GetFieldMappingsRequest}  * @return FieldMappingMetaData for the requested field or null if not found.  */ ;/**  * Returns the mappings of a specific field.  *  * @param field field name as specified in the {@link GetFieldMappingsRequest}  * @return FieldMappingMetaData for the requested field or null if not found.  */ public FieldMappingMetaData fieldMappings(String index, String type, String field) {     Map<String, Map<String, FieldMappingMetaData>> indexMapping = mappings.get(index).     if (indexMapping == null) {         return null.     }     Map<String, FieldMappingMetaData> typeMapping = indexMapping.get(type).     if (typeMapping == null) {         return null.     }     return typeMapping.get(field). }
false;public;2;35;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     boolean includeTypeName = params.paramAsBoolean(BaseRestHandler.INCLUDE_TYPE_NAME_PARAMETER, DEFAULT_INCLUDE_TYPE_NAME_POLICY).     builder.startObject().     for (Map.Entry<String, Map<String, Map<String, FieldMappingMetaData>>> indexEntry : mappings.entrySet()) {         builder.startObject(indexEntry.getKey()).         builder.startObject(MAPPINGS.getPreferredName()).         if (includeTypeName == false) {             Map<String, FieldMappingMetaData> mappings = null.             for (Map.Entry<String, Map<String, FieldMappingMetaData>> typeEntry : indexEntry.getValue().entrySet()) {                 if (typeEntry.getKey().equals(MapperService.DEFAULT_MAPPING) == false) {                     assert mappings == null.                     mappings = typeEntry.getValue().                 }             }             if (mappings != null) {                 addFieldMappingsToBuilder(builder, params, mappings).             }         } else {             for (Map.Entry<String, Map<String, FieldMappingMetaData>> typeEntry : indexEntry.getValue().entrySet()) {                 builder.startObject(typeEntry.getKey()).                 addFieldMappingsToBuilder(builder, params, typeEntry.getValue()).                 builder.endObject().             }         }         builder.endObject().         builder.endObject().     }     builder.endObject().     return builder. }
false;private;3;9;;private void addFieldMappingsToBuilder(XContentBuilder builder, Params params, Map<String, FieldMappingMetaData> mappings) throws IOException {     for (Map.Entry<String, FieldMappingMetaData> fieldEntry : mappings.entrySet()) {         builder.startObject(fieldEntry.getKey()).         fieldEntry.getValue().toXContent(builder, params).         builder.endObject().     } }
false;public,static;1;17;;public static GetFieldMappingsResponse fromXContent(XContentParser parser) throws IOException {     ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation).     final Map<String, Map<String, Map<String, FieldMappingMetaData>>> mappings = new HashMap<>().     if (parser.nextToken() == XContentParser.Token.FIELD_NAME) {         while (parser.currentToken() == XContentParser.Token.FIELD_NAME) {             final String index = parser.currentName().             final Map<String, Map<String, FieldMappingMetaData>> typeMappings = PARSER.parse(parser, index).             mappings.put(index, typeMappings).             parser.nextToken().         }     }     return new GetFieldMappingsResponse(mappings). }
false;public;0;3;;public String fullName() {     return fullName. }
true;public;0;3;/**  * Returns the mappings as a map. Note that the returned map has a single key which is always the field's {@link Mapper#name}.  */ ;/**  * Returns the mappings as a map. Note that the returned map has a single key which is always the field's {@link Mapper#name}.  */ public Map<String, Object> sourceAsMap() {     return XContentHelper.convertToMap(source, true, XContentType.JSON).v2(). }
false;public;0;3;;public boolean isNull() {     return NULL.fullName().equals(fullName) && NULL.source.length() == source.length(). }
true;;0;3;// pkg-private for testing ;// pkg-private for testing BytesReference getSource() {     return source. }
false;public,static;1;3;;public static FieldMappingMetaData fromXContent(XContentParser parser) throws IOException {     return PARSER.parse(parser, null). }
false;public;2;12;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.field(FULL_NAME.getPreferredName(), fullName).     if (params.paramAsBoolean("pretty", false)) {         builder.field("mapping", sourceAsMap()).     } else {         try (InputStream stream = source.streamInput()) {             builder.rawField(MAPPING.getPreferredName(), stream, XContentType.JSON).         }     }     return builder. }
false;public;0;4;;@Override public String toString() {     return "FieldMappingMetaData{fullName='" + fullName + '\'' + ", source=" + source + '}'. }
false;public;1;8;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (!(o instanceof FieldMappingMetaData))         return false.     FieldMappingMetaData that = (FieldMappingMetaData) o.     return Objects.equals(fullName, that.fullName) && Objects.equals(source, that.source). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(fullName, source). }
false;public;1;22;;@Override public void readFrom(StreamInput in) throws IOException {     super.readFrom(in).     int size = in.readVInt().     Map<String, Map<String, Map<String, FieldMappingMetaData>>> indexMapBuilder = new HashMap<>(size).     for (int i = 0. i < size. i++) {         String index = in.readString().         int typesSize = in.readVInt().         Map<String, Map<String, FieldMappingMetaData>> typeMapBuilder = new HashMap<>(typesSize).         for (int j = 0. j < typesSize. j++) {             String type = in.readString().             int fieldSize = in.readVInt().             Map<String, FieldMappingMetaData> fieldMapBuilder = new HashMap<>(fieldSize).             for (int k = 0. k < fieldSize. k++) {                 fieldMapBuilder.put(in.readString(), new FieldMappingMetaData(in.readString(), in.readBytesReference())).             }             typeMapBuilder.put(type, unmodifiableMap(fieldMapBuilder)).         }         indexMapBuilder.put(index, unmodifiableMap(typeMapBuilder)).     }     mappings = unmodifiableMap(indexMapBuilder). }
false;public;1;19;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeVInt(mappings.size()).     for (Map.Entry<String, Map<String, Map<String, FieldMappingMetaData>>> indexEntry : mappings.entrySet()) {         out.writeString(indexEntry.getKey()).         out.writeVInt(indexEntry.getValue().size()).         for (Map.Entry<String, Map<String, FieldMappingMetaData>> typeEntry : indexEntry.getValue().entrySet()) {             out.writeString(typeEntry.getKey()).             out.writeVInt(typeEntry.getValue().size()).             for (Map.Entry<String, FieldMappingMetaData> fieldEntry : typeEntry.getValue().entrySet()) {                 out.writeString(fieldEntry.getKey()).                 FieldMappingMetaData fieldMapping = fieldEntry.getValue().                 out.writeString(fieldMapping.fullName()).                 out.writeBytesReference(fieldMapping.source).             }         }     } }
false;public;0;6;;@Override public String toString() {     return "GetFieldMappingsResponse{" + "mappings=" + mappings + '}'. }
false;public;1;7;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (!(o instanceof GetFieldMappingsResponse))         return false.     GetFieldMappingsResponse that = (GetFieldMappingsResponse) o.     return Objects.equals(mappings, that.mappings). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(mappings). }
