commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public String name() {     return this.name. }
false;public;0;3;;public int order() {     return this.order. }
false;public;0;3;;public int getOrder() {     return order(). }
false;public;0;4;;@Nullable public Integer getVersion() {     return version(). }
false;public;0;4;;@Nullable public Integer version() {     return version. }
false;public;0;3;;public String getName() {     return this.name. }
false;public;0;3;;public List<String> patterns() {     return this.patterns. }
false;public;0;3;;public Settings settings() {     return this.settings. }
false;public;0;3;;public ImmutableOpenMap<String, CompressedXContent> mappings() {     return this.mappings. }
false;public;0;3;;public ImmutableOpenMap<String, CompressedXContent> getMappings() {     return this.mappings. }
false;public;0;3;;public ImmutableOpenMap<String, AliasMetaData> aliases() {     return this.aliases. }
false;public;0;3;;public ImmutableOpenMap<String, AliasMetaData> getAliases() {     return this.aliases. }
false;public,static;1;3;;public static Builder builder(String name) {     return new Builder(name). }
false;public;1;15;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     IndexTemplateMetaData that = (IndexTemplateMetaData) o.     if (order != that.order)         return false.     if (!mappings.equals(that.mappings))         return false.     if (!name.equals(that.name))         return false.     if (!settings.equals(that.settings))         return false.     if (!patterns.equals(that.patterns))         return false.     return Objects.equals(version, that.version). }
false;public;0;10;;@Override public int hashCode() {     int result = name.hashCode().     result = 31 * result + order.     result = 31 * result + Objects.hashCode(version).     result = 31 * result + patterns.hashCode().     result = 31 * result + settings.hashCode().     result = 31 * result + mappings.hashCode().     return result. }
false;public,static;1;29;;public static IndexTemplateMetaData readFrom(StreamInput in) throws IOException {     Builder builder = new Builder(in.readString()).     builder.order(in.readInt()).     if (in.getVersion().onOrAfter(Version.V_6_0_0_alpha1)) {         builder.patterns(in.readStringList()).     } else {         builder.patterns(Collections.singletonList(in.readString())).     }     builder.settings(Settings.readSettingsFromStream(in)).     int mappingsSize = in.readVInt().     for (int i = 0. i < mappingsSize. i++) {         builder.putMapping(in.readString(), CompressedXContent.readCompressedString(in)).     }     int aliasesSize = in.readVInt().     for (int i = 0. i < aliasesSize. i++) {         AliasMetaData aliasMd = new AliasMetaData(in).         builder.putAlias(aliasMd).     }     if (in.getVersion().before(Version.V_6_5_0)) {         // Previously we allowed custom metadata         int customSize = in.readVInt().         assert customSize == 0 : "expected no custom metadata".         if (customSize > 0) {             throw new IllegalStateException("unexpected custom metadata when none is supported").         }     }     builder.version(in.readOptionalVInt()).     return builder.build(). }
false;public,static;1;3;;public static Diff<IndexTemplateMetaData> readDiffFrom(StreamInput in) throws IOException {     return readDiffFrom(IndexTemplateMetaData::readFrom, in). }
false;public;1;24;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeString(name).     out.writeInt(order).     if (out.getVersion().onOrAfter(Version.V_6_0_0_alpha1)) {         out.writeStringCollection(patterns).     } else {         out.writeString(patterns.get(0)).     }     Settings.writeSettingsToStream(settings, out).     out.writeVInt(mappings.size()).     for (ObjectObjectCursor<String, CompressedXContent> cursor : mappings) {         out.writeString(cursor.key).         cursor.value.writeTo(out).     }     out.writeVInt(aliases.size()).     for (ObjectCursor<AliasMetaData> cursor : aliases.values()) {         cursor.value.writeTo(out).     }     if (out.getVersion().before(Version.V_6_5_0)) {         out.writeVInt(0).     }     out.writeOptionalVInt(version). }
false;public;1;4;;public Builder order(int order) {     this.order = order.     return this. }
false;public;1;4;;public Builder version(Integer version) {     this.version = version.     return this. }
false;public;1;4;;public Builder patterns(List<String> indexPatterns) {     this.indexPatterns = indexPatterns.     return this. }
false;public;1;4;;public Builder settings(Settings.Builder settings) {     this.settings = settings.build().     return this. }
false;public;1;4;;public Builder settings(Settings settings) {     this.settings = settings.     return this. }
false;public;2;4;;public Builder putMapping(String mappingType, CompressedXContent mappingSource) {     mappings.put(mappingType, mappingSource).     return this. }
false;public;2;4;;public Builder putMapping(String mappingType, String mappingSource) throws IOException {     mappings.put(mappingType, new CompressedXContent(mappingSource)).     return this. }
false;public;1;4;;public Builder putAlias(AliasMetaData aliasMetaData) {     aliases.put(aliasMetaData.alias(), aliasMetaData).     return this. }
false;public;1;4;;public Builder putAlias(AliasMetaData.Builder aliasMetaData) {     aliases.put(aliasMetaData.alias(), aliasMetaData.build()).     return this. }
false;public;0;3;;public IndexTemplateMetaData build() {     return new IndexTemplateMetaData(name, order, version, indexPatterns, settings, mappings.build(), aliases.build()). }
true;public,static;3;7;/**  * Serializes the template to xContent, using the legacy format where the mappings are  * nested under the type name.  *  * This method is used for serializing templates before storing them in the cluster metadata,  * and also in the REST layer when returning a deprecated typed response.  */ ;/**  * Serializes the template to xContent, using the legacy format where the mappings are  * nested under the type name.  *  * This method is used for serializing templates before storing them in the cluster metadata,  * and also in the REST layer when returning a deprecated typed response.  */ public static void toXContentWithTypes(IndexTemplateMetaData indexTemplateMetaData, XContentBuilder builder, ToXContent.Params params) throws IOException {     builder.startObject(indexTemplateMetaData.name()).     toInnerXContent(indexTemplateMetaData, builder, params, true).     builder.endObject(). }
true;public,static;3;7;/**  * Serializes the template to xContent, making sure not to nest mappings under the  * type name.  *  * Note that this method should currently only be used for creating REST responses,  * and not when directly updating stored templates. Index templates are still stored  * in the old, typed format, and have yet to be migrated to be typeless.  */ ;/**  * Serializes the template to xContent, making sure not to nest mappings under the  * type name.  *  * Note that this method should currently only be used for creating REST responses,  * and not when directly updating stored templates. Index templates are still stored  * in the old, typed format, and have yet to be migrated to be typeless.  */ public static void toXContent(IndexTemplateMetaData indexTemplateMetaData, XContentBuilder builder, ToXContent.Params params) throws IOException {     builder.startObject(indexTemplateMetaData.name()).     toInnerXContent(indexTemplateMetaData, builder, params, false).     builder.endObject(). }
false;static;3;5;;static void toInnerXContentWithTypes(IndexTemplateMetaData indexTemplateMetaData, XContentBuilder builder, ToXContent.Params params) throws IOException {     toInnerXContent(indexTemplateMetaData, builder, params, true). }
false;private,static;4;60;;private static void toInnerXContent(IndexTemplateMetaData indexTemplateMetaData, XContentBuilder builder, ToXContent.Params params, boolean includeTypeName) throws IOException {     builder.field("order", indexTemplateMetaData.order()).     if (indexTemplateMetaData.version() != null) {         builder.field("version", indexTemplateMetaData.version()).     }     builder.field("index_patterns", indexTemplateMetaData.patterns()).     builder.startObject("settings").     indexTemplateMetaData.settings().toXContent(builder, params).     builder.endObject().     if (params.paramAsBoolean("reduce_mappings", false)) {         // always set to true. We therefore only check for include_type_name in this branch.         if (includeTypeName == false) {             Map<String, Object> documentMapping = null.             for (ObjectObjectCursor<String, CompressedXContent> cursor : indexTemplateMetaData.mappings()) {                 if (!cursor.key.equals(MapperService.DEFAULT_MAPPING)) {                     assert documentMapping == null.                     byte[] mappingSource = cursor.value.uncompressed().                     Map<String, Object> mapping = XContentHelper.convertToMap(new BytesArray(mappingSource), true).v2().                     documentMapping = reduceMapping(cursor.key, mapping).                 }             }             if (documentMapping != null) {                 builder.field("mappings", documentMapping).             } else {                 builder.startObject("mappings").endObject().             }         } else {             builder.startObject("mappings").             for (ObjectObjectCursor<String, CompressedXContent> cursor : indexTemplateMetaData.mappings()) {                 byte[] mappingSource = cursor.value.uncompressed().                 Map<String, Object> mapping = XContentHelper.convertToMap(new BytesArray(mappingSource), true).v2().                 mapping = reduceMapping(cursor.key, mapping).                 builder.field(cursor.key).                 builder.map(mapping).             }             builder.endObject().         }     } else {         builder.startArray("mappings").         for (ObjectObjectCursor<String, CompressedXContent> cursor : indexTemplateMetaData.mappings()) {             byte[] data = cursor.value.uncompressed().             builder.map(XContentHelper.convertToMap(new BytesArray(data), true).v2()).         }         builder.endArray().     }     builder.startObject("aliases").     for (ObjectCursor<AliasMetaData> cursor : indexTemplateMetaData.aliases().values()) {         AliasMetaData.Builder.toXContent(cursor.value, builder, params).     }     builder.endObject(). }
false;private,static;2;9;;@SuppressWarnings("unchecked") private static Map<String, Object> reduceMapping(String type, Map<String, Object> mapping) {     if (mapping.size() == 1 && mapping.containsKey(type)) {         // the type name is the root value, reduce it         return (Map<String, Object>) mapping.get(type).     } else {         return mapping.     } }
false;public,static;2;68;;public static IndexTemplateMetaData fromXContent(XContentParser parser, String templateName) throws IOException {     Builder builder = new Builder(templateName).     String currentFieldName = skipTemplateName(parser).     XContentParser.Token token.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (token == XContentParser.Token.START_OBJECT) {             if ("settings".equals(currentFieldName)) {                 Settings.Builder templateSettingsBuilder = Settings.builder().                 templateSettingsBuilder.put(Settings.fromXContent(parser)).                 templateSettingsBuilder.normalizePrefix(IndexMetaData.INDEX_SETTING_PREFIX).                 builder.settings(templateSettingsBuilder.build()).             } else if ("mappings".equals(currentFieldName)) {                 while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {                     if (token == XContentParser.Token.FIELD_NAME) {                         currentFieldName = parser.currentName().                     } else if (token == XContentParser.Token.START_OBJECT) {                         String mappingType = currentFieldName.                         Map<String, Object> mappingSource = MapBuilder.<String, Object>newMapBuilder().put(mappingType, parser.mapOrdered()).map().                         builder.putMapping(mappingType, Strings.toString(XContentFactory.jsonBuilder().map(mappingSource))).                     }                 }             } else if ("aliases".equals(currentFieldName)) {                 while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {                     builder.putAlias(AliasMetaData.Builder.fromXContent(parser)).                 }             } else {                 throw new ElasticsearchParseException("unknown key [{}] for index template", currentFieldName).             }         } else if (token == XContentParser.Token.START_ARRAY) {             if ("mappings".equals(currentFieldName)) {                 while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {                     Map<String, Object> mapping = parser.mapOrdered().                     if (mapping.size() == 1) {                         String mappingType = mapping.keySet().iterator().next().                         String mappingSource = Strings.toString(XContentFactory.jsonBuilder().map(mapping)).                         if (mappingSource == null) {                         // crap, no mapping source, warn?                         } else {                             builder.putMapping(mappingType, mappingSource).                         }                     }                 }             } else if ("index_patterns".equals(currentFieldName)) {                 List<String> index_patterns = new ArrayList<>().                 while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {                     index_patterns.add(parser.text()).                 }                 builder.patterns(index_patterns).             }         } else if (token.isValue()) {             // Prior to 5.1.0, elasticsearch only supported a single index pattern called `template` (#21009)             if ("template".equals(currentFieldName)) {                 deprecationLogger.deprecated("Deprecated field [template] used, replaced by [index_patterns]").                 builder.patterns(Collections.singletonList(parser.text())).             } else if ("order".equals(currentFieldName)) {                 builder.order(parser.intValue()).             } else if ("version".equals(currentFieldName)) {                 builder.version(parser.intValue()).             }         }     }     return builder.build(). }
false;private,static;1;17;;private static String skipTemplateName(XContentParser parser) throws IOException {     XContentParser.Token token = parser.nextToken().     if (token == XContentParser.Token.START_OBJECT) {         token = parser.nextToken().         if (token == XContentParser.Token.FIELD_NAME) {             String currentFieldName = parser.currentName().             if (VALID_FIELDS.contains(currentFieldName)) {                 return currentFieldName.             } else {                 // we just hit the template name, which should be ignored and we move on                 parser.nextToken().             }         }     }     return null. }
