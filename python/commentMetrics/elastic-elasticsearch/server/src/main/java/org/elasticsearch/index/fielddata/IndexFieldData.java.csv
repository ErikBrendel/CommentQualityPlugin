commented;modifiers;parameterAmount;loc;comment;code
true;;0;1;/**  * The field name.  */ ;/**  * The field name.  */ String getFieldName().
true;;1;1;/**  * Loads the atomic field data for the reader, possibly cached.  */ ;/**  * Loads the atomic field data for the reader, possibly cached.  */ FD load(LeafReaderContext context).
true;;1;1;/**  * Loads directly the atomic field data for the reader, ignoring any caching involved.  */ ;/**  * Loads directly the atomic field data for the reader, ignoring any caching involved.  */ FD loadDirect(LeafReaderContext context) throws Exception.
true;;4;1;/**  * Returns the {@link SortField} to used for sorting.  */ ;/**  * Returns the {@link SortField} to used for sorting.  */ SortField sortField(@Nullable Object missingValue, MultiValueMode sortMode, Nested nested, boolean reverse).
true;;0;1;/**  * Clears any resources associated with this field data.  */ ;/**  * Clears any resources associated with this field data.  */ void clear().
false;public;0;3;;public MultiValueMode sortMode() {     return this.sortMode. }
false;public;0;3;;public Nested nested() {     return this.nested. }
false;public;0;3;;public Query getInnerQuery() {     return innerQuery. }
false;public;0;3;;public BitSetProducer getRootFilter() {     return rootFilter. }
false;public;0;1;;public NestedSortBuilder getNestedSort() {     return nestedSort. }
true;public;1;3;/**  * Get a {@link BitDocIdSet} that matches the root documents.  */ ;/**  * Get a {@link BitDocIdSet} that matches the root documents.  */ public BitSet rootDocs(LeafReaderContext ctx) throws IOException {     return rootFilter.getBitSet(ctx). }
true;public;1;7;/**  * Get a {@link DocIdSet} that matches the inner documents.  */ ;/**  * Get a {@link DocIdSet} that matches the inner documents.  */ public DocIdSetIterator innerDocs(LeafReaderContext ctx) throws IOException {     final IndexReaderContext topLevelCtx = ReaderUtil.getTopLevelContext(ctx).     IndexSearcher indexSearcher = new IndexSearcher(topLevelCtx).     Weight weight = indexSearcher.createWeight(indexSearcher.rewrite(innerQuery), ScoreMode.COMPLETE_NO_SCORES, 1f).     Scorer s = weight.scorer(ctx).     return s == null ? null : s.iterator(). }
true;public,final;1;3;/**  * Whether missing values should be sorted first.  */ ;/**  * Whether missing values should be sorted first.  */ public final boolean sortMissingFirst(Object missingValue) {     return "_first".equals(missingValue). }
true;public,final;1;3;/**  * Whether missing values should be sorted last, this is the default.  */ ;/**  * Whether missing values should be sorted last, this is the default.  */ public final boolean sortMissingLast(Object missingValue) {     return missingValue == null || "_last".equals(missingValue). }
true;public,final;2;58;/**  * Return the missing object value according to the reduced type of the comparator.  */ ;/**  * Return the missing object value according to the reduced type of the comparator.  */ public final Object missingObject(Object missingValue, boolean reversed) {     if (sortMissingFirst(missingValue) || sortMissingLast(missingValue)) {         final boolean min = sortMissingFirst(missingValue) ^ reversed.         switch(reducedType()) {             case INT:                 return min ? Integer.MIN_VALUE : Integer.MAX_VALUE.             case LONG:                 return min ? Long.MIN_VALUE : Long.MAX_VALUE.             case FLOAT:                 return min ? Float.NEGATIVE_INFINITY : Float.POSITIVE_INFINITY.             case DOUBLE:                 return min ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY.             case STRING:             case STRING_VAL:                 return null.             default:                 throw new UnsupportedOperationException("Unsupported reduced type: " + reducedType()).         }     } else {         switch(reducedType()) {             case INT:                 if (missingValue instanceof Number) {                     return ((Number) missingValue).intValue().                 } else {                     return Integer.parseInt(missingValue.toString()).                 }             case LONG:                 if (missingValue instanceof Number) {                     return ((Number) missingValue).longValue().                 } else {                     return Long.parseLong(missingValue.toString()).                 }             case FLOAT:                 if (missingValue instanceof Number) {                     return ((Number) missingValue).floatValue().                 } else {                     return Float.parseFloat(missingValue.toString()).                 }             case DOUBLE:                 if (missingValue instanceof Number) {                     return ((Number) missingValue).doubleValue().                 } else {                     return Double.parseDouble(missingValue.toString()).                 }             case STRING:             case STRING_VAL:                 if (missingValue instanceof BytesRef) {                     return (BytesRef) missingValue.                 } else if (missingValue instanceof byte[]) {                     return new BytesRef((byte[]) missingValue).                 } else {                     return new BytesRef(missingValue.toString()).                 }             default:                 throw new UnsupportedOperationException("Unsupported reduced type: " + reducedType()).         }     } }
false;public,abstract;0;1;;public abstract SortField.Type reducedType().
true;public;1;3;/**  * Return a missing value that is understandable by {@link SortField#setMissingValue(Object)}.  * Most implementations return null because they already replace the value at the fielddata level.  * However this can't work in case of strings since there is no such thing as a string which  * compares greater than any other string, so in that case we need to return  * {@link SortField#STRING_FIRST} or {@link SortField#STRING_LAST} so that the coordinating node  * knows how to deal with null values.  */ ;/**  * Return a missing value that is understandable by {@link SortField#setMissingValue(Object)}.  * Most implementations return null because they already replace the value at the fielddata level.  * However this can't work in case of strings since there is no such thing as a string which  * compares greater than any other string, so in that case we need to return  * {@link SortField#STRING_FIRST} or {@link SortField#STRING_LAST} so that the coordinating node  * knows how to deal with null values.  */ public Object missingValue(boolean reversed) {     return null. }
false;;5;2;;IndexFieldData<?> build(IndexSettings indexSettings, MappedFieldType fieldType, IndexFieldDataCache cache, CircuitBreakerService breakerService, MapperService mapperService).
false;;1;1;;IndexFieldData<FD> loadGlobal(DirectoryReader indexReader).
false;;1;1;;IndexFieldData<FD> localGlobalDirect(DirectoryReader indexReader) throws Exception.
