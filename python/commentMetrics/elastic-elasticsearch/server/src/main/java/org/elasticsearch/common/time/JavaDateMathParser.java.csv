commented;modifiers;parameterAmount;loc;comment;code
false;public;4;23;;@Override public Instant parse(String text, LongSupplier now, boolean roundUp, ZoneId timeZone) {     Instant time.     String mathString.     if (text.startsWith("now")) {         try {             // TODO only millisecond granularity here!             time = Instant.ofEpochMilli(now.getAsLong()).         } catch (Exception e) {             throw new ElasticsearchParseException("could not read the current timestamp", e).         }         mathString = text.substring("now".length()).     } else {         int index = text.indexOf("||").         if (index == -1) {             return parseDateTime(text, timeZone, roundUp).         }         time = parseDateTime(text.substring(0, index), timeZone, false).         mathString = text.substring(index + 2).     }     return parseMath(mathString, time, roundUp, timeZone). }
false;private;4;128;;private Instant parseMath(final String mathString, final Instant time, final boolean roundUp, ZoneId timeZone) throws ElasticsearchParseException {     if (timeZone == null) {         timeZone = ZoneOffset.UTC.     }     ZonedDateTime dateTime = ZonedDateTime.ofInstant(time, timeZone).     for (int i = 0. i < mathString.length(). ) {         char c = mathString.charAt(i++).         final boolean round.         final int sign.         if (c == '/') {             round = true.             sign = 1.         } else {             round = false.             if (c == '+') {                 sign = 1.             } else if (c == '-') {                 sign = -1.             } else {                 throw new ElasticsearchParseException("operator not supported for date math [{}]", mathString).             }         }         if (i >= mathString.length()) {             throw new ElasticsearchParseException("truncated date math [{}]", mathString).         }         final int num.         if (!Character.isDigit(mathString.charAt(i))) {             num = 1.         } else {             int numFrom = i.             while (i < mathString.length() && Character.isDigit(mathString.charAt(i))) {                 i++.             }             if (i >= mathString.length()) {                 throw new ElasticsearchParseException("truncated date math [{}]", mathString).             }             num = Integer.parseInt(mathString.substring(numFrom, i)).         }         if (round) {             if (num != 1) {                 throw new ElasticsearchParseException("rounding `/` can only be used on single unit types [{}]", mathString).             }         }         char unit = mathString.charAt(i++).         switch(unit) {             case 'y':                 if (round) {                     dateTime = dateTime.withDayOfYear(1).with(LocalTime.MIN).                 } else {                     dateTime = dateTime.plusYears(sign * num).                 }                 if (roundUp) {                     dateTime = dateTime.plusYears(1).                 }                 break.             case 'M':                 if (round) {                     dateTime = dateTime.withDayOfMonth(1).with(LocalTime.MIN).                 } else {                     dateTime = dateTime.plusMonths(sign * num).                 }                 if (roundUp) {                     dateTime = dateTime.plusMonths(1).                 }                 break.             case 'w':                 if (round) {                     dateTime = dateTime.with(TemporalAdjusters.previousOrSame(DayOfWeek.MONDAY)).with(LocalTime.MIN).                 } else {                     dateTime = dateTime.plusWeeks(sign * num).                 }                 if (roundUp) {                     dateTime = dateTime.plusWeeks(1).                 }                 break.             case 'd':                 if (round) {                     dateTime = dateTime.with(LocalTime.MIN).                 } else {                     dateTime = dateTime.plusDays(sign * num).                 }                 if (roundUp) {                     dateTime = dateTime.plusDays(1).                 }                 break.             case 'h':             case 'H':                 if (round) {                     dateTime = dateTime.withMinute(0).withSecond(0).withNano(0).                 } else {                     dateTime = dateTime.plusHours(sign * num).                 }                 if (roundUp) {                     dateTime = dateTime.plusHours(1).                 }                 break.             case 'm':                 if (round) {                     dateTime = dateTime.withSecond(0).withNano(0).                 } else {                     dateTime = dateTime.plusMinutes(sign * num).                 }                 if (roundUp) {                     dateTime = dateTime.plusMinutes(1).                 }                 break.             case 's':                 if (round) {                     dateTime = dateTime.withNano(0).                 } else {                     dateTime = dateTime.plusSeconds(sign * num).                 }                 if (roundUp) {                     dateTime = dateTime.plusSeconds(1).                 }                 break.             default:                 throw new ElasticsearchParseException("unit [{}] not supported for date math [{}]", unit, mathString).         }         if (roundUp) {             dateTime = dateTime.minus(1, ChronoField.MILLI_OF_SECOND.getBaseUnit()).         }     }     return dateTime.toInstant(). }
false;private;3;23;;private Instant parseDateTime(String value, ZoneId timeZone, boolean roundUpIfNoTime) {     if (Strings.isNullOrEmpty(value)) {         throw new ElasticsearchParseException("cannot parse empty date").     }     DateTimeFormatter formatter = roundUpIfNoTime ? this.roundUpFormatter : this.formatter.     try {         if (timeZone == null) {             return DateFormatters.from(formatter.parse(value)).toInstant().         } else {             TemporalAccessor accessor = formatter.parse(value).             ZoneId zoneId = TemporalQueries.zone().queryFrom(accessor).             if (zoneId != null) {                 timeZone = zoneId.             }             return DateFormatters.from(accessor).withZoneSameLocal(timeZone).toInstant().         }     } catch (DateTimeParseException e) {         throw new ElasticsearchParseException("failed to parse date field [{}] with format [{}]: [{}]", e, value, format, e.getMessage()).     } }
