commented;modifiers;parameterAmount;loc;comment;code
true;public;3;31;/**  * Return a new instance that contains the union of this instance and the field types  * from the provided mappers. If a field already exists, its field type will be updated  * to use the new type from the given field mapper. Similarly if an alias already  * exists, it will be updated to reference the field type from the new mapper.  */ ;/**  * Return a new instance that contains the union of this instance and the field types  * from the provided mappers. If a field already exists, its field type will be updated  * to use the new type from the given field mapper. Similarly if an alias already  * exists, it will be updated to reference the field type from the new mapper.  */ public FieldTypeLookup copyAndAddAll(String type, Collection<FieldMapper> fieldMappers, Collection<FieldAliasMapper> fieldAliasMappers) {     Objects.requireNonNull(type, "type must not be null").     if (MapperService.DEFAULT_MAPPING.equals(type)) {         throw new IllegalArgumentException("Default mappings should not be added to the lookup").     }     CopyOnWriteHashMap<String, MappedFieldType> fullName = this.fullNameToFieldType.     CopyOnWriteHashMap<String, String> aliases = this.aliasToConcreteName.     for (FieldMapper fieldMapper : fieldMappers) {         MappedFieldType fieldType = fieldMapper.fieldType().         MappedFieldType fullNameFieldType = fullName.get(fieldType.name()).         if (!Objects.equals(fieldType, fullNameFieldType)) {             validateField(fullNameFieldType, fieldType, aliases).             fullName = fullName.copyAndPut(fieldType.name(), fieldType).         }     }     for (FieldAliasMapper fieldAliasMapper : fieldAliasMappers) {         String aliasName = fieldAliasMapper.name().         String path = fieldAliasMapper.path().         validateAlias(aliasName, path, aliases, fullName).         aliases = aliases.copyAndPut(aliasName, path).     }     return new FieldTypeLookup(fullName, aliases). }
true;private;3;18;/**  * Checks that the new field type is valid.  */ ;/**  * Checks that the new field type is valid.  */ private void validateField(MappedFieldType existingFieldType, MappedFieldType newFieldType, CopyOnWriteHashMap<String, String> aliasToConcreteName) {     String fieldName = newFieldType.name().     if (aliasToConcreteName.containsKey(fieldName)) {         throw new IllegalArgumentException("The name for field [" + fieldName + "] has already" + " been used to define a field alias.").     }     if (existingFieldType != null) {         List<String> conflicts = new ArrayList<>().         existingFieldType.checkCompatibility(newFieldType, conflicts).         if (conflicts.isEmpty() == false) {             throw new IllegalArgumentException("Mapper for [" + fieldName + "] conflicts with existing mapping:\n" + conflicts.toString()).         }     } }
true;private;4;24;/**  * Checks that the new field alias is valid.  *  * Note that this method assumes that new concrete fields have already been processed, so that it  * can verify that an alias refers to an existing concrete field.  */ ;/**  * Checks that the new field alias is valid.  *  * Note that this method assumes that new concrete fields have already been processed, so that it  * can verify that an alias refers to an existing concrete field.  */ private void validateAlias(String aliasName, String path, CopyOnWriteHashMap<String, String> aliasToConcreteName, CopyOnWriteHashMap<String, MappedFieldType> fullNameToFieldType) {     if (fullNameToFieldType.containsKey(aliasName)) {         throw new IllegalArgumentException("The name for field alias [" + aliasName + "] has already" + " been used to define a concrete field.").     }     if (path.equals(aliasName)) {         throw new IllegalArgumentException("Invalid [path] value [" + path + "] for field alias [" + aliasName + "]: an alias cannot refer to itself.").     }     if (aliasToConcreteName.containsKey(path)) {         throw new IllegalArgumentException("Invalid [path] value [" + path + "] for field alias [" + aliasName + "]: an alias cannot refer to another alias.").     }     if (!fullNameToFieldType.containsKey(path)) {         throw new IllegalArgumentException("Invalid [path] value [" + path + "] for field alias [" + aliasName + "]: an alias must refer to an existing field in the mappings.").     } }
true;public;1;4;/**  * Returns the field for the given field  */ ;/**  * Returns the field for the given field  */ public MappedFieldType get(String field) {     String concreteField = aliasToConcreteName.getOrDefault(field, field).     return fullNameToFieldType.get(concreteField). }
true;public;1;14;/**  * Returns a list of the full names of a simple match regex like pattern against full name and index name.  */ ;/**  * Returns a list of the full names of a simple match regex like pattern against full name and index name.  */ public Collection<String> simpleMatchToFullName(String pattern) {     Set<String> fields = new HashSet<>().     for (MappedFieldType fieldType : this) {         if (Regex.simpleMatch(pattern, fieldType.name())) {             fields.add(fieldType.name()).         }     }     for (String aliasName : aliasToConcreteName.keySet()) {         if (Regex.simpleMatch(pattern, aliasName)) {             fields.add(aliasName).         }     }     return fields. }
false;public;0;4;;@Override public Iterator<MappedFieldType> iterator() {     return fullNameToFieldType.values().iterator(). }
