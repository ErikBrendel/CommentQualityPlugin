commented;modifiers;parameterAmount;loc;comment;code
false;public;1;6;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeDouble(trigramLambda).     out.writeDouble(bigramLambda).     out.writeDouble(unigramLambda). }
false;public;0;3;;public double getTrigramLambda() {     return this.trigramLambda. }
false;public;0;3;;public double getBigramLambda() {     return this.bigramLambda. }
false;public;0;3;;public double getUnigramLambda() {     return this.unigramLambda. }
false;protected;2;7;;@Override protected XContentBuilder innerToXContent(XContentBuilder builder, Params params) throws IOException {     builder.field(TRIGRAM_FIELD.getPreferredName(), trigramLambda).     builder.field(BIGRAM_FIELD.getPreferredName(), bigramLambda).     builder.field(UNIGRAM_FIELD.getPreferredName(), unigramLambda).     return builder. }
false;public;0;4;;@Override public String getWriteableName() {     return NAME. }
false;protected;1;7;;@Override protected boolean doEquals(SmoothingModel other) {     final LinearInterpolation otherModel = (LinearInterpolation) other.     return Objects.equals(trigramLambda, otherModel.trigramLambda) && Objects.equals(bigramLambda, otherModel.bigramLambda) && Objects.equals(unigramLambda, otherModel.unigramLambda). }
false;protected;0;4;;@Override protected int doHashCode() {     return Objects.hash(trigramLambda, bigramLambda, unigramLambda). }
false;public,static;1;36;;public static LinearInterpolation fromXContent(XContentParser parser) throws IOException {     XContentParser.Token token.     String fieldName = null.     double trigramLambda = 0.0.     double bigramLambda = 0.0.     double unigramLambda = 0.0.     while ((token = parser.nextToken()) != Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             fieldName = parser.currentName().         } else if (token.isValue()) {             if (TRIGRAM_FIELD.match(fieldName, parser.getDeprecationHandler())) {                 trigramLambda = parser.doubleValue().                 if (trigramLambda < 0) {                     throw new IllegalArgumentException("trigram_lambda must be positive").                 }             } else if (BIGRAM_FIELD.match(fieldName, parser.getDeprecationHandler())) {                 bigramLambda = parser.doubleValue().                 if (bigramLambda < 0) {                     throw new IllegalArgumentException("bigram_lambda must be positive").                 }             } else if (UNIGRAM_FIELD.match(fieldName, parser.getDeprecationHandler())) {                 unigramLambda = parser.doubleValue().                 if (unigramLambda < 0) {                     throw new IllegalArgumentException("unigram_lambda must be positive").                 }             } else {                 throw new IllegalArgumentException("suggester[phrase][smoothing][linear] doesn't support field [" + fieldName + "]").             }         } else {             throw new ParsingException(parser.getTokenLocation(), "[" + NAME + "] unknown token [" + token + "] after [" + fieldName + "]").         }     }     return new LinearInterpolation(trigramLambda, bigramLambda, unigramLambda). }
false;public;0;6;;@Override public WordScorerFactory buildWordScorerFactory() {     return (IndexReader reader, Terms terms, String field, double realWordLikelihood, BytesRef separator) -> new LinearInterpolatingScorer(reader, terms, field, realWordLikelihood, separator, trigramLambda, bigramLambda, unigramLambda). }
