commented;modifiers;parameterAmount;loc;comment;code
false;;1;3;;VersionValue get(BytesRef key) {     return map.get(key). }
false;;2;3;;VersionValue put(BytesRef key, VersionValue value) {     return map.put(key, value). }
false;;0;3;;boolean isEmpty() {     return map.isEmpty(). }
false;;0;3;;int size() {     return map.size(). }
false;;0;3;;boolean isUnsafe() {     return unsafe. }
false;;0;3;;void markAsUnsafe() {     unsafe = true. }
false;public;1;3;;public VersionValue remove(BytesRef uid) {     return map.remove(uid). }
false;public;1;4;;public void updateMinDeletedTimestamp(DeleteVersionValue delete) {     long time = delete.time.     minDeleteTimestamp.updateAndGet(prev -> Math.min(time, prev)). }
false;;0;3;;boolean isSafeAccessMode() {     return needsSafeAccess || previousMapsNeededSafeAccess. }
false;;0;6;;boolean shouldInheritSafeAccess() {     final boolean mapHasNotSeenAnyOperations = current.isEmpty() && current.isUnsafe() == false.     return needsSafeAccess || // we haven't seen any ops and map before needed it so we maintain it     (mapHasNotSeenAnyOperations && previousMapsNeededSafeAccess). }
true;;0;4;/**  * Builds a new map for the refresh transition this should be called in beforeRefresh()  */ ;/**  * Builds a new map for the refresh transition this should be called in beforeRefresh()  */ Maps buildTransitionMap() {     return new Maps(new VersionLookup(ConcurrentCollections.newConcurrentMapWithAggressiveConcurrency(current.size())), current, shouldInheritSafeAccess()). }
true;;0;3;/**  * builds a new map that invalidates the old map but maintains the current. This should be called in afterRefresh()  */ ;/**  * builds a new map that invalidates the old map but maintains the current. This should be called in afterRefresh()  */ Maps invalidateOldMap() {     return new Maps(current, VersionLookup.EMPTY, previousMapsNeededSafeAccess). }
false;;2;7;;void put(BytesRef uid, VersionValue version) {     long uidRAMBytesUsed = BASE_BYTES_PER_BYTESREF + uid.bytes.length.     long ramAccounting = BASE_BYTES_PER_CHM_ENTRY + version.ramBytesUsed() + uidRAMBytesUsed.     VersionValue previousValue = current.put(uid, version).     ramAccounting += previousValue == null ? 0 : -(BASE_BYTES_PER_CHM_ENTRY + previousValue.ramBytesUsed() + uidRAMBytesUsed).     adjustRam(ramAccounting). }
false;;1;6;;void adjustRam(long value) {     if (value != 0) {         long v = current.ramBytesUsed.addAndGet(value).         assert v >= 0 : "bytes=" + v.     } }
false;;2;13;;void remove(BytesRef uid, DeleteVersionValue deleted) {     VersionValue previousValue = current.remove(uid).     current.updateMinDeletedTimestamp(deleted).     if (previousValue != null) {         long uidRAMBytesUsed = BASE_BYTES_PER_BYTESREF + uid.bytes.length.         adjustRam(-(BASE_BYTES_PER_CHM_ENTRY + previousValue.ramBytesUsed() + uidRAMBytesUsed)).     }     if (old != VersionLookup.EMPTY) {         // we also need to remove it from the old map here to make sure we don't read this stale value while         // we are in the middle of a refresh. Most of the time the old map is an empty map so we can skip it there.         old.remove(uid).     } }
false;;0;3;;long getMinDeleteTimestamp() {     return Math.min(current.minDeleteTimestamp.get(), old.minDeleteTimestamp.get()). }
false;public;0;11;;@Override public void beforeRefresh() throws IOException {     // Start sending all updates after this point to the new     // map.  While reopen is running, any lookup will first     // try this new map, then fallback to old, then to the     // current searcher:     maps = maps.buildTransitionMap().     assert (unsafeKeysMap = unsafeKeysMap.buildTransitionMap()) != null. // This is not 100% correct, since concurrent indexing ops can change these counters in between our execution of the previous // line and this one, but that should be minor, and the error won't accumulate over time: }
false;public;1;13;;@Override public void afterRefresh(boolean didRefresh) throws IOException {     // We can now drop old because these operations are now visible via the newly opened searcher.  Even if didRefresh is false, which     // means Lucene did not actually open a new reader because it detected no changes, it's possible old has some entries in it, which     // is fine: it means they were actually already included in the previously opened reader, so we can still safely drop them in that     // case.  This is because we assign new maps (in beforeRefresh) slightly before Lucene actually flushes any segments for the     // reopen, and so any concurrent indexing requests can still sneak in a few additions to that current map that are in fact     // reflected in the previous reader.   We don't touch tombstones here: they expire on their own index.gc_deletes timeframe:     maps = maps.invalidateOldMap().     assert (unsafeKeysMap = unsafeKeysMap.invalidateOldMap()) != null. }
true;;1;3;/**  * Returns the live version (add or delete) for this uid.  */ ;/**  * Returns the live version (add or delete) for this uid.  */ VersionValue getUnderLock(final BytesRef uid) {     return getUnderLock(uid, maps). }
false;private;2;15;;private VersionValue getUnderLock(final BytesRef uid, Maps currentMaps) {     assert assertKeyedLockHeldByCurrentThread(uid).     // First try to get the "live" value:     VersionValue value = currentMaps.current.get(uid).     if (value != null) {         return value.     }     value = currentMaps.old.get(uid).     if (value != null) {         return value.     }     return tombstones.get(uid). }
false;;1;7;;VersionValue getVersionForAssert(final BytesRef uid) {     VersionValue value = getUnderLock(uid, maps).     if (value == null) {         value = getUnderLock(uid, unsafeKeysMap).     }     return value. }
false;;0;3;;boolean isUnsafe() {     return maps.current.isUnsafe() || maps.old.isUnsafe(). }
false;;0;3;;void enforceSafeAccess() {     maps.needsSafeAccess = true. }
false;;0;3;;boolean isSafeAccessRequired() {     return maps.isSafeAccessMode(). }
true;;2;14;/**  * Adds this uid/version to the pending adds map iff the map needs safe access.  */ ;/**  * Adds this uid/version to the pending adds map iff the map needs safe access.  */ void maybePutIndexUnderLock(BytesRef uid, IndexVersionValue version) {     assert assertKeyedLockHeldByCurrentThread(uid).     Maps maps = this.maps.     if (maps.isSafeAccessMode()) {         putIndexUnderLock(uid, version).     } else {         // Even though we don't store a record of the indexing operation (and mark as unsafe),         // we should still remove any previous delete for this uuid (avoid accidental accesses).         // Not this should not hurt performance because the tombstone is small (or empty) when unsafe is relevant.         removeTombstoneUnderLock(uid).         maps.current.markAsUnsafe().         assert putAssertionMap(uid, version).     } }
false;;2;6;;void putIndexUnderLock(BytesRef uid, IndexVersionValue version) {     assert assertKeyedLockHeldByCurrentThread(uid).     assert uid.bytes.length == uid.length : "Oversized _uid! UID length: " + uid.length + ", bytes length: " + uid.bytes.length.     maps.put(uid, version).     removeTombstoneUnderLock(uid). }
false;private;2;6;;private boolean putAssertionMap(BytesRef uid, IndexVersionValue version) {     assert assertKeyedLockHeldByCurrentThread(uid).     assert uid.bytes.length == uid.length : "Oversized _uid! UID length: " + uid.length + ", bytes length: " + uid.bytes.length.     unsafeKeysMap.put(uid, version).     return true. }
false;;2;6;;void putDeleteUnderLock(BytesRef uid, DeleteVersionValue version) {     assert assertKeyedLockHeldByCurrentThread(uid).     assert uid.bytes.length == uid.length : "Oversized _uid! UID length: " + uid.length + ", bytes length: " + uid.bytes.length.     putTombstone(uid, version).     maps.remove(uid, version). }
false;private;2;14;;private void putTombstone(BytesRef uid, DeleteVersionValue version) {     long uidRAMBytesUsed = BASE_BYTES_PER_BYTESREF + uid.bytes.length.     // Also enroll the delete into tombstones, and account for its RAM too:     final VersionValue prevTombstone = tombstones.put(uid, version).     long accountRam = (BASE_BYTES_PER_CHM_ENTRY + version.ramBytesUsed() + uidRAMBytesUsed).     // Deduct tombstones bytes used for the version we just removed or replaced:     if (prevTombstone != null) {         accountRam -= (BASE_BYTES_PER_CHM_ENTRY + prevTombstone.ramBytesUsed() + uidRAMBytesUsed).     }     if (accountRam != 0) {         long v = ramBytesUsedTombstones.addAndGet(accountRam).         assert v >= 0 : "bytes=" + v.     } }
true;;1;10;/**  * Removes this uid from the pending deletes map.  */ ;/**  * Removes this uid from the pending deletes map.  */ void removeTombstoneUnderLock(BytesRef uid) {     assert assertKeyedLockHeldByCurrentThread(uid).     long uidRAMBytesUsed = BASE_BYTES_PER_BYTESREF + uid.bytes.length.     final VersionValue prev = tombstones.remove(uid).     if (prev != null) {         assert prev.isDelete().         long v = ramBytesUsedTombstones.addAndGet(-(BASE_BYTES_PER_CHM_ENTRY + prev.ramBytesUsed() + uidRAMBytesUsed)).         assert v >= 0 : "bytes=" + v.     } }
false;private;3;9;;private boolean canRemoveTombstone(long maxTimestampToPrune, long maxSeqNoToPrune, DeleteVersionValue versionValue) {     // check if the value is old enough and safe to be removed     final boolean isTooOld = versionValue.time < maxTimestampToPrune.     final boolean isSafeToPrune = versionValue.seqNo <= maxSeqNoToPrune.     // version value can't be removed it's     // not yet flushed to lucene ie. it's part of this current maps object     final boolean isNotTrackedByCurrentMaps = versionValue.time < maps.getMinDeleteTimestamp().     return isTooOld && isSafeToPrune && isNotTrackedByCurrentMaps. }
true;;2;24;/**  * Try to prune tombstones whose timestamp is less than maxTimestampToPrune and seqno at most the maxSeqNoToPrune.  */ ;/**  * Try to prune tombstones whose timestamp is less than maxTimestampToPrune and seqno at most the maxSeqNoToPrune.  */ void pruneTombstones(long maxTimestampToPrune, long maxSeqNoToPrune) {     for (Map.Entry<BytesRef, DeleteVersionValue> entry : tombstones.entrySet()) {         // we won't collect the tombstone below since it must be newer than this one.         if (canRemoveTombstone(maxTimestampToPrune, maxSeqNoToPrune, entry.getValue())) {             final BytesRef uid = entry.getKey().             try (Releasable lock = keyedLock.tryAcquire(uid)) {                 // if we do use a blocking acquire. see #28714                 if (lock != null) {                     // did we get the lock?                     // Must re-get it here, vs using entry.getValue(), in case the uid was indexed/deleted since we pulled the iterator:                     final DeleteVersionValue versionValue = tombstones.get(uid).                     if (versionValue != null) {                         if (canRemoveTombstone(maxTimestampToPrune, maxSeqNoToPrune, versionValue)) {                             removeTombstoneUnderLock(uid).                         }                     }                 }             }         }     } }
true;synchronized;0;8;/**  * Called when this index is closed.  */ ;/**  * Called when this index is closed.  */ synchronized void clear() {     maps = new Maps().     tombstones.clear(). // NOTE: we can't zero this here, because a refresh thread could be calling InternalEngine.pruneDeletedTombstones at the same time, // and this will lead to an assert trip.  Presumably it's fine if our ramBytesUsedTombstones is non-zero after clear since the // index is being closed: // ramBytesUsedTombstones.set(0). }
false;public;0;4;;@Override public long ramBytesUsed() {     return maps.current.ramBytesUsed.get() + ramBytesUsedTombstones.get(). }
true;;0;3;/**  * Returns how much RAM would be freed up by refreshing. This is {@link #ramBytesUsed} except does not include tombstones because they  * don't clear on refresh.  */ ;/**  * Returns how much RAM would be freed up by refreshing. This is {@link #ramBytesUsed} except does not include tombstones because they  * don't clear on refresh.  */ long ramBytesUsedForRefresh() {     return maps.current.ramBytesUsed.get(). }
true;;0;3;/**  * Returns how much RAM is current being freed up by refreshing.  This is {@link #ramBytesUsed()}  * except does not include tombstones because they don't clear on refresh.  */ ;/**  * Returns how much RAM is current being freed up by refreshing.  This is {@link #ramBytesUsed()}  * except does not include tombstones because they don't clear on refresh.  */ long getRefreshingBytes() {     return maps.old.ramBytesUsed.get(). }
false;public;0;5;;@Override public Collection<Accountable> getChildResources() {     // TODO: useful to break down RAM usage here?     return Collections.emptyList(). }
true;;0;3;/**  * Returns the current internal versions as a point in time snapshot  */ ;/**  * Returns the current internal versions as a point in time snapshot  */ Map<BytesRef, VersionValue> getAllCurrent() {     return maps.current.map. }
true;;0;3;/**  * Iterates over all deleted versions, including new ones (not yet exposed via reader) and old ones  *  (exposed via reader but not yet GC'd).  */ ;/**  * Iterates over all deleted versions, including new ones (not yet exposed via reader) and old ones  *  (exposed via reader but not yet GC'd).  */ Map<BytesRef, DeleteVersionValue> getAllTombstones() {     return tombstones. }
true;;1;3;/**  * Acquires a releaseable lock for the given uId. All *UnderLock methods require  * this lock to be hold by the caller otherwise the visibility guarantees of this version  * map are broken. We assert on this lock to be hold when calling these methods.  * @see KeyedLock  */ ;/**  * Acquires a releaseable lock for the given uId. All *UnderLock methods require  * this lock to be hold by the caller otherwise the visibility guarantees of this version  * map are broken. We assert on this lock to be hold when calling these methods.  * @see KeyedLock  */ Releasable acquireLock(BytesRef uid) {     return keyedLock.acquire(uid). }
false;;1;5;;boolean assertKeyedLockHeldByCurrentThread(BytesRef uid) {     assert keyedLock.isHeldByCurrentThread(uid) : "Thread [" + Thread.currentThread().getName() + "], uid [" + uid.utf8ToString() + "]".     return true. }
