# id;timestamp;commentText;codeText;commentWords;codeWords
LiveVersionMap -> VersionValue getUnderLock(final BytesRef uid);1524684173;Returns the live version (add or delete) for this uid.;VersionValue getUnderLock(final BytesRef uid) {_        return getUnderLock(uid, maps)__    };returns,the,live,version,add,or,delete,for,this,uid;version,value,get,under,lock,final,bytes,ref,uid,return,get,under,lock,uid,maps
LiveVersionMap -> VersionValue getUnderLock(final BytesRef uid);1536828374;Returns the live version (add or delete) for this uid.;VersionValue getUnderLock(final BytesRef uid) {_        return getUnderLock(uid, maps)__    };returns,the,live,version,add,or,delete,for,this,uid;version,value,get,under,lock,final,bytes,ref,uid,return,get,under,lock,uid,maps
LiveVersionMap -> VersionValue getUnderLock(final BytesRef uid);1538424609;Returns the live version (add or delete) for this uid.;VersionValue getUnderLock(final BytesRef uid) {_        return getUnderLock(uid, maps)__    };returns,the,live,version,add,or,delete,for,this,uid;version,value,get,under,lock,final,bytes,ref,uid,return,get,under,lock,uid,maps
LiveVersionMap -> VersionValue getUnderLock(final BytesRef uid);1542697754;Returns the live version (add or delete) for this uid.;VersionValue getUnderLock(final BytesRef uid) {_        return getUnderLock(uid, maps)__    };returns,the,live,version,add,or,delete,for,this,uid;version,value,get,under,lock,final,bytes,ref,uid,return,get,under,lock,uid,maps
LiveVersionMap -> void pruneTombstones(long maxTimestampToPrune, long maxSeqNoToPrune);1524684173;Try to prune tombstones whose timestamp is less than maxTimestampToPrune and seqno at most the maxSeqNoToPrune.;void pruneTombstones(long maxTimestampToPrune, long maxSeqNoToPrune) {_        for (Map.Entry<BytesRef, DeleteVersionValue> entry : tombstones.entrySet()) {_            _            _            _            if (canRemoveTombstone(maxTimestampToPrune, maxSeqNoToPrune, entry.getValue())) {_                final BytesRef uid = entry.getKey()__                try (Releasable lock = keyedLock.tryAcquire(uid)) {_                    _                    _                    _                    if (lock != null) { _                        _                        final DeleteVersionValue versionValue = tombstones.get(uid)__                        if (versionValue != null) {_                            if (canRemoveTombstone(maxTimestampToPrune, maxSeqNoToPrune, versionValue)) {_                                removeTombstoneUnderLock(uid)__                            }_                        }_                    }_                }_            }_        }_    };try,to,prune,tombstones,whose,timestamp,is,less,than,max,timestamp,to,prune,and,seqno,at,most,the,max,seq,no,to,prune;void,prune,tombstones,long,max,timestamp,to,prune,long,max,seq,no,to,prune,for,map,entry,bytes,ref,delete,version,value,entry,tombstones,entry,set,if,can,remove,tombstone,max,timestamp,to,prune,max,seq,no,to,prune,entry,get,value,final,bytes,ref,uid,entry,get,key,try,releasable,lock,keyed,lock,try,acquire,uid,if,lock,null,final,delete,version,value,version,value,tombstones,get,uid,if,version,value,null,if,can,remove,tombstone,max,timestamp,to,prune,max,seq,no,to,prune,version,value,remove,tombstone,under,lock,uid
LiveVersionMap -> void pruneTombstones(long maxTimestampToPrune, long maxSeqNoToPrune);1536828374;Try to prune tombstones whose timestamp is less than maxTimestampToPrune and seqno at most the maxSeqNoToPrune.;void pruneTombstones(long maxTimestampToPrune, long maxSeqNoToPrune) {_        for (Map.Entry<BytesRef, DeleteVersionValue> entry : tombstones.entrySet()) {_            _            _            _            if (canRemoveTombstone(maxTimestampToPrune, maxSeqNoToPrune, entry.getValue())) {_                final BytesRef uid = entry.getKey()__                try (Releasable lock = keyedLock.tryAcquire(uid)) {_                    _                    _                    _                    if (lock != null) { _                        _                        final DeleteVersionValue versionValue = tombstones.get(uid)__                        if (versionValue != null) {_                            if (canRemoveTombstone(maxTimestampToPrune, maxSeqNoToPrune, versionValue)) {_                                removeTombstoneUnderLock(uid)__                            }_                        }_                    }_                }_            }_        }_    };try,to,prune,tombstones,whose,timestamp,is,less,than,max,timestamp,to,prune,and,seqno,at,most,the,max,seq,no,to,prune;void,prune,tombstones,long,max,timestamp,to,prune,long,max,seq,no,to,prune,for,map,entry,bytes,ref,delete,version,value,entry,tombstones,entry,set,if,can,remove,tombstone,max,timestamp,to,prune,max,seq,no,to,prune,entry,get,value,final,bytes,ref,uid,entry,get,key,try,releasable,lock,keyed,lock,try,acquire,uid,if,lock,null,final,delete,version,value,version,value,tombstones,get,uid,if,version,value,null,if,can,remove,tombstone,max,timestamp,to,prune,max,seq,no,to,prune,version,value,remove,tombstone,under,lock,uid
LiveVersionMap -> void pruneTombstones(long maxTimestampToPrune, long maxSeqNoToPrune);1538424609;Try to prune tombstones whose timestamp is less than maxTimestampToPrune and seqno at most the maxSeqNoToPrune.;void pruneTombstones(long maxTimestampToPrune, long maxSeqNoToPrune) {_        for (Map.Entry<BytesRef, DeleteVersionValue> entry : tombstones.entrySet()) {_            _            _            _            if (canRemoveTombstone(maxTimestampToPrune, maxSeqNoToPrune, entry.getValue())) {_                final BytesRef uid = entry.getKey()__                try (Releasable lock = keyedLock.tryAcquire(uid)) {_                    _                    _                    _                    if (lock != null) { _                        _                        final DeleteVersionValue versionValue = tombstones.get(uid)__                        if (versionValue != null) {_                            if (canRemoveTombstone(maxTimestampToPrune, maxSeqNoToPrune, versionValue)) {_                                removeTombstoneUnderLock(uid)__                            }_                        }_                    }_                }_            }_        }_    };try,to,prune,tombstones,whose,timestamp,is,less,than,max,timestamp,to,prune,and,seqno,at,most,the,max,seq,no,to,prune;void,prune,tombstones,long,max,timestamp,to,prune,long,max,seq,no,to,prune,for,map,entry,bytes,ref,delete,version,value,entry,tombstones,entry,set,if,can,remove,tombstone,max,timestamp,to,prune,max,seq,no,to,prune,entry,get,value,final,bytes,ref,uid,entry,get,key,try,releasable,lock,keyed,lock,try,acquire,uid,if,lock,null,final,delete,version,value,version,value,tombstones,get,uid,if,version,value,null,if,can,remove,tombstone,max,timestamp,to,prune,max,seq,no,to,prune,version,value,remove,tombstone,under,lock,uid
LiveVersionMap -> void pruneTombstones(long maxTimestampToPrune, long maxSeqNoToPrune);1542697754;Try to prune tombstones whose timestamp is less than maxTimestampToPrune and seqno at most the maxSeqNoToPrune.;void pruneTombstones(long maxTimestampToPrune, long maxSeqNoToPrune) {_        for (Map.Entry<BytesRef, DeleteVersionValue> entry : tombstones.entrySet()) {_            _            _            _            if (canRemoveTombstone(maxTimestampToPrune, maxSeqNoToPrune, entry.getValue())) {_                final BytesRef uid = entry.getKey()__                try (Releasable lock = keyedLock.tryAcquire(uid)) {_                    _                    _                    _                    if (lock != null) { _                        _                        final DeleteVersionValue versionValue = tombstones.get(uid)__                        if (versionValue != null) {_                            if (canRemoveTombstone(maxTimestampToPrune, maxSeqNoToPrune, versionValue)) {_                                removeTombstoneUnderLock(uid)__                            }_                        }_                    }_                }_            }_        }_    };try,to,prune,tombstones,whose,timestamp,is,less,than,max,timestamp,to,prune,and,seqno,at,most,the,max,seq,no,to,prune;void,prune,tombstones,long,max,timestamp,to,prune,long,max,seq,no,to,prune,for,map,entry,bytes,ref,delete,version,value,entry,tombstones,entry,set,if,can,remove,tombstone,max,timestamp,to,prune,max,seq,no,to,prune,entry,get,value,final,bytes,ref,uid,entry,get,key,try,releasable,lock,keyed,lock,try,acquire,uid,if,lock,null,final,delete,version,value,version,value,tombstones,get,uid,if,version,value,null,if,can,remove,tombstone,max,timestamp,to,prune,max,seq,no,to,prune,version,value,remove,tombstone,under,lock,uid
LiveVersionMap -> Releasable acquireLock(BytesRef uid);1524684173;Acquires a releaseable lock for the given uId. All *UnderLock methods require_this lock to be hold by the caller otherwise the visibility guarantees of this version_map are broken. We assert on this lock to be hold when calling these methods._@see KeyedLock;Releasable acquireLock(BytesRef uid) {_        return keyedLock.acquire(uid)__    };acquires,a,releaseable,lock,for,the,given,u,id,all,under,lock,methods,require,this,lock,to,be,hold,by,the,caller,otherwise,the,visibility,guarantees,of,this,version,map,are,broken,we,assert,on,this,lock,to,be,hold,when,calling,these,methods,see,keyed,lock;releasable,acquire,lock,bytes,ref,uid,return,keyed,lock,acquire,uid
LiveVersionMap -> Releasable acquireLock(BytesRef uid);1536828374;Acquires a releaseable lock for the given uId. All *UnderLock methods require_this lock to be hold by the caller otherwise the visibility guarantees of this version_map are broken. We assert on this lock to be hold when calling these methods._@see KeyedLock;Releasable acquireLock(BytesRef uid) {_        return keyedLock.acquire(uid)__    };acquires,a,releaseable,lock,for,the,given,u,id,all,under,lock,methods,require,this,lock,to,be,hold,by,the,caller,otherwise,the,visibility,guarantees,of,this,version,map,are,broken,we,assert,on,this,lock,to,be,hold,when,calling,these,methods,see,keyed,lock;releasable,acquire,lock,bytes,ref,uid,return,keyed,lock,acquire,uid
LiveVersionMap -> Releasable acquireLock(BytesRef uid);1538424609;Acquires a releaseable lock for the given uId. All *UnderLock methods require_this lock to be hold by the caller otherwise the visibility guarantees of this version_map are broken. We assert on this lock to be hold when calling these methods._@see KeyedLock;Releasable acquireLock(BytesRef uid) {_        return keyedLock.acquire(uid)__    };acquires,a,releaseable,lock,for,the,given,u,id,all,under,lock,methods,require,this,lock,to,be,hold,by,the,caller,otherwise,the,visibility,guarantees,of,this,version,map,are,broken,we,assert,on,this,lock,to,be,hold,when,calling,these,methods,see,keyed,lock;releasable,acquire,lock,bytes,ref,uid,return,keyed,lock,acquire,uid
LiveVersionMap -> Releasable acquireLock(BytesRef uid);1542697754;Acquires a releaseable lock for the given uId. All *UnderLock methods require_this lock to be hold by the caller otherwise the visibility guarantees of this version_map are broken. We assert on this lock to be hold when calling these methods._@see KeyedLock;Releasable acquireLock(BytesRef uid) {_        return keyedLock.acquire(uid)__    };acquires,a,releaseable,lock,for,the,given,u,id,all,under,lock,methods,require,this,lock,to,be,hold,by,the,caller,otherwise,the,visibility,guarantees,of,this,version,map,are,broken,we,assert,on,this,lock,to,be,hold,when,calling,these,methods,see,keyed,lock;releasable,acquire,lock,bytes,ref,uid,return,keyed,lock,acquire,uid
LiveVersionMap -> Map<BytesRef, DeleteVersionValue> getAllTombstones();1524684173;Iterates over all deleted versions, including new ones (not yet exposed via reader) and old ones (exposed via reader but not yet GC'd).;Map<BytesRef, DeleteVersionValue> getAllTombstones() {_        return tombstones__    };iterates,over,all,deleted,versions,including,new,ones,not,yet,exposed,via,reader,and,old,ones,exposed,via,reader,but,not,yet,gc,d;map,bytes,ref,delete,version,value,get,all,tombstones,return,tombstones
LiveVersionMap -> Map<BytesRef, DeleteVersionValue> getAllTombstones();1536828374;Iterates over all deleted versions, including new ones (not yet exposed via reader) and old ones (exposed via reader but not yet GC'd).;Map<BytesRef, DeleteVersionValue> getAllTombstones() {_        return tombstones__    };iterates,over,all,deleted,versions,including,new,ones,not,yet,exposed,via,reader,and,old,ones,exposed,via,reader,but,not,yet,gc,d;map,bytes,ref,delete,version,value,get,all,tombstones,return,tombstones
LiveVersionMap -> Map<BytesRef, DeleteVersionValue> getAllTombstones();1538424609;Iterates over all deleted versions, including new ones (not yet exposed via reader) and old ones (exposed via reader but not yet GC'd).;Map<BytesRef, DeleteVersionValue> getAllTombstones() {_        return tombstones__    };iterates,over,all,deleted,versions,including,new,ones,not,yet,exposed,via,reader,and,old,ones,exposed,via,reader,but,not,yet,gc,d;map,bytes,ref,delete,version,value,get,all,tombstones,return,tombstones
LiveVersionMap -> Map<BytesRef, DeleteVersionValue> getAllTombstones();1542697754;Iterates over all deleted versions, including new ones (not yet exposed via reader) and old ones_(exposed via reader but not yet GC'd).;Map<BytesRef, DeleteVersionValue> getAllTombstones() {_        return tombstones__    };iterates,over,all,deleted,versions,including,new,ones,not,yet,exposed,via,reader,and,old,ones,exposed,via,reader,but,not,yet,gc,d;map,bytes,ref,delete,version,value,get,all,tombstones,return,tombstones
LiveVersionMap -> synchronized void clear();1524684173;Called when this index is closed.;synchronized void clear() {_        maps = new Maps()__        tombstones.clear()__        _        _        _        _    };called,when,this,index,is,closed;synchronized,void,clear,maps,new,maps,tombstones,clear
LiveVersionMap -> synchronized void clear();1536828374;Called when this index is closed.;synchronized void clear() {_        maps = new Maps()__        tombstones.clear()__        _        _        _        _    };called,when,this,index,is,closed;synchronized,void,clear,maps,new,maps,tombstones,clear
LiveVersionMap -> synchronized void clear();1538424609;Called when this index is closed.;synchronized void clear() {_        maps = new Maps()__        tombstones.clear()__        _        _        _        _    };called,when,this,index,is,closed;synchronized,void,clear,maps,new,maps,tombstones,clear
LiveVersionMap -> synchronized void clear();1542697754;Called when this index is closed.;synchronized void clear() {_        maps = new Maps()__        tombstones.clear()__        _        _        _        _    };called,when,this,index,is,closed;synchronized,void,clear,maps,new,maps,tombstones,clear
LiveVersionMap -> Maps -> Maps invalidateOldMap();1524684173;builds a new map that invalidates the old map but maintains the current. This should be called in afterRefresh();Maps invalidateOldMap() {_            return new Maps(current, VersionLookup.EMPTY, previousMapsNeededSafeAccess)__        };builds,a,new,map,that,invalidates,the,old,map,but,maintains,the,current,this,should,be,called,in,after,refresh;maps,invalidate,old,map,return,new,maps,current,version,lookup,empty,previous,maps,needed,safe,access
LiveVersionMap -> Maps -> Maps invalidateOldMap();1536828374;builds a new map that invalidates the old map but maintains the current. This should be called in afterRefresh();Maps invalidateOldMap() {_            return new Maps(current, VersionLookup.EMPTY, previousMapsNeededSafeAccess)__        };builds,a,new,map,that,invalidates,the,old,map,but,maintains,the,current,this,should,be,called,in,after,refresh;maps,invalidate,old,map,return,new,maps,current,version,lookup,empty,previous,maps,needed,safe,access
LiveVersionMap -> Maps -> Maps invalidateOldMap();1538424609;builds a new map that invalidates the old map but maintains the current. This should be called in afterRefresh();Maps invalidateOldMap() {_            return new Maps(current, VersionLookup.EMPTY, previousMapsNeededSafeAccess)__        };builds,a,new,map,that,invalidates,the,old,map,but,maintains,the,current,this,should,be,called,in,after,refresh;maps,invalidate,old,map,return,new,maps,current,version,lookup,empty,previous,maps,needed,safe,access
LiveVersionMap -> Maps -> Maps invalidateOldMap();1542697754;builds a new map that invalidates the old map but maintains the current. This should be called in afterRefresh();Maps invalidateOldMap() {_            return new Maps(current, VersionLookup.EMPTY, previousMapsNeededSafeAccess)__        };builds,a,new,map,that,invalidates,the,old,map,but,maintains,the,current,this,should,be,called,in,after,refresh;maps,invalidate,old,map,return,new,maps,current,version,lookup,empty,previous,maps,needed,safe,access
LiveVersionMap -> void maybePutIndexUnderLock(BytesRef uid, IndexVersionValue version);1524684173;Adds this uid/version to the pending adds map iff the map needs safe access.;void maybePutIndexUnderLock(BytesRef uid, IndexVersionValue version) {_        assert assertKeyedLockHeldByCurrentThread(uid)__        Maps maps = this.maps__        if (maps.isSafeAccessMode()) {_            putIndexUnderLock(uid, version)__        } else {_            _            _            _            removeTombstoneUnderLock(uid)__            maps.current.markAsUnsafe()__            assert putAssertionMap(uid, version)__        }_    };adds,this,uid,version,to,the,pending,adds,map,iff,the,map,needs,safe,access;void,maybe,put,index,under,lock,bytes,ref,uid,index,version,value,version,assert,assert,keyed,lock,held,by,current,thread,uid,maps,maps,this,maps,if,maps,is,safe,access,mode,put,index,under,lock,uid,version,else,remove,tombstone,under,lock,uid,maps,current,mark,as,unsafe,assert,put,assertion,map,uid,version
LiveVersionMap -> void maybePutIndexUnderLock(BytesRef uid, IndexVersionValue version);1536828374;Adds this uid/version to the pending adds map iff the map needs safe access.;void maybePutIndexUnderLock(BytesRef uid, IndexVersionValue version) {_        assert assertKeyedLockHeldByCurrentThread(uid)__        Maps maps = this.maps__        if (maps.isSafeAccessMode()) {_            putIndexUnderLock(uid, version)__        } else {_            _            _            _            removeTombstoneUnderLock(uid)__            maps.current.markAsUnsafe()__            assert putAssertionMap(uid, version)__        }_    };adds,this,uid,version,to,the,pending,adds,map,iff,the,map,needs,safe,access;void,maybe,put,index,under,lock,bytes,ref,uid,index,version,value,version,assert,assert,keyed,lock,held,by,current,thread,uid,maps,maps,this,maps,if,maps,is,safe,access,mode,put,index,under,lock,uid,version,else,remove,tombstone,under,lock,uid,maps,current,mark,as,unsafe,assert,put,assertion,map,uid,version
LiveVersionMap -> void maybePutIndexUnderLock(BytesRef uid, IndexVersionValue version);1538424609;Adds this uid/version to the pending adds map iff the map needs safe access.;void maybePutIndexUnderLock(BytesRef uid, IndexVersionValue version) {_        assert assertKeyedLockHeldByCurrentThread(uid)__        Maps maps = this.maps__        if (maps.isSafeAccessMode()) {_            putIndexUnderLock(uid, version)__        } else {_            _            _            _            removeTombstoneUnderLock(uid)__            maps.current.markAsUnsafe()__            assert putAssertionMap(uid, version)__        }_    };adds,this,uid,version,to,the,pending,adds,map,iff,the,map,needs,safe,access;void,maybe,put,index,under,lock,bytes,ref,uid,index,version,value,version,assert,assert,keyed,lock,held,by,current,thread,uid,maps,maps,this,maps,if,maps,is,safe,access,mode,put,index,under,lock,uid,version,else,remove,tombstone,under,lock,uid,maps,current,mark,as,unsafe,assert,put,assertion,map,uid,version
LiveVersionMap -> void maybePutIndexUnderLock(BytesRef uid, IndexVersionValue version);1542697754;Adds this uid/version to the pending adds map iff the map needs safe access.;void maybePutIndexUnderLock(BytesRef uid, IndexVersionValue version) {_        assert assertKeyedLockHeldByCurrentThread(uid)__        Maps maps = this.maps__        if (maps.isSafeAccessMode()) {_            putIndexUnderLock(uid, version)__        } else {_            _            _            _            removeTombstoneUnderLock(uid)__            maps.current.markAsUnsafe()__            assert putAssertionMap(uid, version)__        }_    };adds,this,uid,version,to,the,pending,adds,map,iff,the,map,needs,safe,access;void,maybe,put,index,under,lock,bytes,ref,uid,index,version,value,version,assert,assert,keyed,lock,held,by,current,thread,uid,maps,maps,this,maps,if,maps,is,safe,access,mode,put,index,under,lock,uid,version,else,remove,tombstone,under,lock,uid,maps,current,mark,as,unsafe,assert,put,assertion,map,uid,version
LiveVersionMap -> void removeTombstoneUnderLock(BytesRef uid);1524684173;Removes this uid from the pending deletes map.;void removeTombstoneUnderLock(BytesRef uid) {_        assert assertKeyedLockHeldByCurrentThread(uid)__        long uidRAMBytesUsed = BASE_BYTES_PER_BYTESREF + uid.bytes.length__        final VersionValue prev = tombstones.remove(uid)__        if (prev != null) {_            assert prev.isDelete()__            long v = ramBytesUsedTombstones.addAndGet(-(BASE_BYTES_PER_CHM_ENTRY + prev.ramBytesUsed() + uidRAMBytesUsed))__            assert v >= 0 : "bytes=" + v__        }_    };removes,this,uid,from,the,pending,deletes,map;void,remove,tombstone,under,lock,bytes,ref,uid,assert,assert,keyed,lock,held,by,current,thread,uid,long,uid,rambytes,used,uid,bytes,length,final,version,value,prev,tombstones,remove,uid,if,prev,null,assert,prev,is,delete,long,v,ram,bytes,used,tombstones,add,and,get,prev,ram,bytes,used,uid,rambytes,used,assert,v,0,bytes,v
LiveVersionMap -> void removeTombstoneUnderLock(BytesRef uid);1536828374;Removes this uid from the pending deletes map.;void removeTombstoneUnderLock(BytesRef uid) {_        assert assertKeyedLockHeldByCurrentThread(uid)__        long uidRAMBytesUsed = BASE_BYTES_PER_BYTESREF + uid.bytes.length__        final VersionValue prev = tombstones.remove(uid)__        if (prev != null) {_            assert prev.isDelete()__            long v = ramBytesUsedTombstones.addAndGet(-(BASE_BYTES_PER_CHM_ENTRY + prev.ramBytesUsed() + uidRAMBytesUsed))__            assert v >= 0 : "bytes=" + v__        }_    };removes,this,uid,from,the,pending,deletes,map;void,remove,tombstone,under,lock,bytes,ref,uid,assert,assert,keyed,lock,held,by,current,thread,uid,long,uid,rambytes,used,uid,bytes,length,final,version,value,prev,tombstones,remove,uid,if,prev,null,assert,prev,is,delete,long,v,ram,bytes,used,tombstones,add,and,get,prev,ram,bytes,used,uid,rambytes,used,assert,v,0,bytes,v
LiveVersionMap -> void removeTombstoneUnderLock(BytesRef uid);1538424609;Removes this uid from the pending deletes map.;void removeTombstoneUnderLock(BytesRef uid) {_        assert assertKeyedLockHeldByCurrentThread(uid)__        long uidRAMBytesUsed = BASE_BYTES_PER_BYTESREF + uid.bytes.length__        final VersionValue prev = tombstones.remove(uid)__        if (prev != null) {_            assert prev.isDelete()__            long v = ramBytesUsedTombstones.addAndGet(-(BASE_BYTES_PER_CHM_ENTRY + prev.ramBytesUsed() + uidRAMBytesUsed))__            assert v >= 0 : "bytes=" + v__        }_    };removes,this,uid,from,the,pending,deletes,map;void,remove,tombstone,under,lock,bytes,ref,uid,assert,assert,keyed,lock,held,by,current,thread,uid,long,uid,rambytes,used,uid,bytes,length,final,version,value,prev,tombstones,remove,uid,if,prev,null,assert,prev,is,delete,long,v,ram,bytes,used,tombstones,add,and,get,prev,ram,bytes,used,uid,rambytes,used,assert,v,0,bytes,v
LiveVersionMap -> void removeTombstoneUnderLock(BytesRef uid);1542697754;Removes this uid from the pending deletes map.;void removeTombstoneUnderLock(BytesRef uid) {_        assert assertKeyedLockHeldByCurrentThread(uid)__        long uidRAMBytesUsed = BASE_BYTES_PER_BYTESREF + uid.bytes.length__        final VersionValue prev = tombstones.remove(uid)__        if (prev != null) {_            assert prev.isDelete()__            long v = ramBytesUsedTombstones.addAndGet(-(BASE_BYTES_PER_CHM_ENTRY + prev.ramBytesUsed() + uidRAMBytesUsed))__            assert v >= 0 : "bytes=" + v__        }_    };removes,this,uid,from,the,pending,deletes,map;void,remove,tombstone,under,lock,bytes,ref,uid,assert,assert,keyed,lock,held,by,current,thread,uid,long,uid,rambytes,used,uid,bytes,length,final,version,value,prev,tombstones,remove,uid,if,prev,null,assert,prev,is,delete,long,v,ram,bytes,used,tombstones,add,and,get,prev,ram,bytes,used,uid,rambytes,used,assert,v,0,bytes,v
LiveVersionMap -> long ramBytesUsedForRefresh();1524684173;Returns how much RAM would be freed up by refreshing. This is {@link #ramBytesUsed} except does not include tombstones because they_don't clear on refresh.;long ramBytesUsedForRefresh() {_        return maps.current.ramBytesUsed.get()__    };returns,how,much,ram,would,be,freed,up,by,refreshing,this,is,link,ram,bytes,used,except,does,not,include,tombstones,because,they,don,t,clear,on,refresh;long,ram,bytes,used,for,refresh,return,maps,current,ram,bytes,used,get
LiveVersionMap -> long ramBytesUsedForRefresh();1536828374;Returns how much RAM would be freed up by refreshing. This is {@link #ramBytesUsed} except does not include tombstones because they_don't clear on refresh.;long ramBytesUsedForRefresh() {_        return maps.current.ramBytesUsed.get()__    };returns,how,much,ram,would,be,freed,up,by,refreshing,this,is,link,ram,bytes,used,except,does,not,include,tombstones,because,they,don,t,clear,on,refresh;long,ram,bytes,used,for,refresh,return,maps,current,ram,bytes,used,get
LiveVersionMap -> long ramBytesUsedForRefresh();1538424609;Returns how much RAM would be freed up by refreshing. This is {@link #ramBytesUsed} except does not include tombstones because they_don't clear on refresh.;long ramBytesUsedForRefresh() {_        return maps.current.ramBytesUsed.get()__    };returns,how,much,ram,would,be,freed,up,by,refreshing,this,is,link,ram,bytes,used,except,does,not,include,tombstones,because,they,don,t,clear,on,refresh;long,ram,bytes,used,for,refresh,return,maps,current,ram,bytes,used,get
LiveVersionMap -> long ramBytesUsedForRefresh();1542697754;Returns how much RAM would be freed up by refreshing. This is {@link #ramBytesUsed} except does not include tombstones because they_don't clear on refresh.;long ramBytesUsedForRefresh() {_        return maps.current.ramBytesUsed.get()__    };returns,how,much,ram,would,be,freed,up,by,refreshing,this,is,link,ram,bytes,used,except,does,not,include,tombstones,because,they,don,t,clear,on,refresh;long,ram,bytes,used,for,refresh,return,maps,current,ram,bytes,used,get
LiveVersionMap -> Map<BytesRef, VersionValue> getAllCurrent();1524684173;Returns the current internal versions as a point in time snapshot;Map<BytesRef, VersionValue> getAllCurrent() {_        return maps.current.map__    };returns,the,current,internal,versions,as,a,point,in,time,snapshot;map,bytes,ref,version,value,get,all,current,return,maps,current,map
LiveVersionMap -> Map<BytesRef, VersionValue> getAllCurrent();1536828374;Returns the current internal versions as a point in time snapshot;Map<BytesRef, VersionValue> getAllCurrent() {_        return maps.current.map__    };returns,the,current,internal,versions,as,a,point,in,time,snapshot;map,bytes,ref,version,value,get,all,current,return,maps,current,map
LiveVersionMap -> Map<BytesRef, VersionValue> getAllCurrent();1538424609;Returns the current internal versions as a point in time snapshot;Map<BytesRef, VersionValue> getAllCurrent() {_        return maps.current.map__    };returns,the,current,internal,versions,as,a,point,in,time,snapshot;map,bytes,ref,version,value,get,all,current,return,maps,current,map
LiveVersionMap -> Map<BytesRef, VersionValue> getAllCurrent();1542697754;Returns the current internal versions as a point in time snapshot;Map<BytesRef, VersionValue> getAllCurrent() {_        return maps.current.map__    };returns,the,current,internal,versions,as,a,point,in,time,snapshot;map,bytes,ref,version,value,get,all,current,return,maps,current,map
LiveVersionMap -> long getRefreshingBytes();1536828374;Returns how much RAM is current being freed up by refreshing.  This is {@link #ramBytesUsed()}_except does not include tombstones because they don't clear on refresh.;long getRefreshingBytes() {_        return maps.old.ramBytesUsed.get()__    };returns,how,much,ram,is,current,being,freed,up,by,refreshing,this,is,link,ram,bytes,used,except,does,not,include,tombstones,because,they,don,t,clear,on,refresh;long,get,refreshing,bytes,return,maps,old,ram,bytes,used,get
LiveVersionMap -> long getRefreshingBytes();1538424609;Returns how much RAM is current being freed up by refreshing.  This is {@link #ramBytesUsed()}_except does not include tombstones because they don't clear on refresh.;long getRefreshingBytes() {_        return maps.old.ramBytesUsed.get()__    };returns,how,much,ram,is,current,being,freed,up,by,refreshing,this,is,link,ram,bytes,used,except,does,not,include,tombstones,because,they,don,t,clear,on,refresh;long,get,refreshing,bytes,return,maps,old,ram,bytes,used,get
LiveVersionMap -> long getRefreshingBytes();1542697754;Returns how much RAM is current being freed up by refreshing.  This is {@link #ramBytesUsed()}_except does not include tombstones because they don't clear on refresh.;long getRefreshingBytes() {_        return maps.old.ramBytesUsed.get()__    };returns,how,much,ram,is,current,being,freed,up,by,refreshing,this,is,link,ram,bytes,used,except,does,not,include,tombstones,because,they,don,t,clear,on,refresh;long,get,refreshing,bytes,return,maps,old,ram,bytes,used,get
LiveVersionMap -> Maps -> Maps buildTransitionMap();1524684173;Builds a new map for the refresh transition this should be called in beforeRefresh();Maps buildTransitionMap() {_            return new Maps(new VersionLookup(ConcurrentCollections.newConcurrentMapWithAggressiveConcurrency(current.size())), current,_                shouldInheritSafeAccess())__        };builds,a,new,map,for,the,refresh,transition,this,should,be,called,in,before,refresh;maps,build,transition,map,return,new,maps,new,version,lookup,concurrent,collections,new,concurrent,map,with,aggressive,concurrency,current,size,current,should,inherit,safe,access
LiveVersionMap -> Maps -> Maps buildTransitionMap();1536828374;Builds a new map for the refresh transition this should be called in beforeRefresh();Maps buildTransitionMap() {_            return new Maps(new VersionLookup(ConcurrentCollections.newConcurrentMapWithAggressiveConcurrency(current.size())), current,_                shouldInheritSafeAccess())__        };builds,a,new,map,for,the,refresh,transition,this,should,be,called,in,before,refresh;maps,build,transition,map,return,new,maps,new,version,lookup,concurrent,collections,new,concurrent,map,with,aggressive,concurrency,current,size,current,should,inherit,safe,access
LiveVersionMap -> Maps -> Maps buildTransitionMap();1538424609;Builds a new map for the refresh transition this should be called in beforeRefresh();Maps buildTransitionMap() {_            return new Maps(new VersionLookup(ConcurrentCollections.newConcurrentMapWithAggressiveConcurrency(current.size())), current,_                shouldInheritSafeAccess())__        };builds,a,new,map,for,the,refresh,transition,this,should,be,called,in,before,refresh;maps,build,transition,map,return,new,maps,new,version,lookup,concurrent,collections,new,concurrent,map,with,aggressive,concurrency,current,size,current,should,inherit,safe,access
LiveVersionMap -> Maps -> Maps buildTransitionMap();1542697754;Builds a new map for the refresh transition this should be called in beforeRefresh();Maps buildTransitionMap() {_            return new Maps(new VersionLookup(ConcurrentCollections.newConcurrentMapWithAggressiveConcurrency(current.size())), current,_                shouldInheritSafeAccess())__        };builds,a,new,map,for,the,refresh,transition,this,should,be,called,in,before,refresh;maps,build,transition,map,return,new,maps,new,version,lookup,concurrent,collections,new,concurrent,map,with,aggressive,concurrency,current,size,current,should,inherit,safe,access
