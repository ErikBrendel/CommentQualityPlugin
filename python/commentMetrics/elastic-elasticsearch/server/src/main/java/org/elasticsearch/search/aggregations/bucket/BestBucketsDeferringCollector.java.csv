# id;timestamp;commentText;codeText;commentWords;codeWords
BestBucketsDeferringCollector -> @Override     public Aggregator wrap(final Aggregator in);1524684173;Wrap the provided aggregator so that it behaves (almost) as if it had_been collected directly.;@Override_    public Aggregator wrap(final Aggregator in) {__        return new WrappedAggregator(in) {__            @Override_            public InternalAggregation buildAggregation(long bucket) throws IOException {_                if (selectedBuckets == null) {_                    throw new IllegalStateException("Collection has not been replayed yet.")__                }_                final long rebasedBucket = selectedBuckets.find(bucket)__                if (rebasedBucket == -1) {_                    throw new IllegalStateException("Cannot build for a bucket which has not been collected")__                }_                return in.buildAggregation(rebasedBucket)__            }__        }__    };wrap,the,provided,aggregator,so,that,it,behaves,almost,as,if,it,had,been,collected,directly;override,public,aggregator,wrap,final,aggregator,in,return,new,wrapped,aggregator,in,override,public,internal,aggregation,build,aggregation,long,bucket,throws,ioexception,if,selected,buckets,null,throw,new,illegal,state,exception,collection,has,not,been,replayed,yet,final,long,rebased,bucket,selected,buckets,find,bucket,if,rebased,bucket,1,throw,new,illegal,state,exception,cannot,build,for,a,bucket,which,has,not,been,collected,return,in,build,aggregation,rebased,bucket
BestBucketsDeferringCollector -> @Override     public Aggregator wrap(final Aggregator in);1535965276;Wrap the provided aggregator so that it behaves (almost) as if it had_been collected directly.;@Override_    public Aggregator wrap(final Aggregator in) {__        return new WrappedAggregator(in) {__            @Override_            public InternalAggregation buildAggregation(long bucket) throws IOException {_                if (selectedBuckets == null) {_                    throw new IllegalStateException("Collection has not been replayed yet.")__                }_                final long rebasedBucket = selectedBuckets.find(bucket)__                if (rebasedBucket == -1) {_                    throw new IllegalStateException("Cannot build for a bucket which has not been collected")__                }_                return in.buildAggregation(rebasedBucket)__            }__        }__    };wrap,the,provided,aggregator,so,that,it,behaves,almost,as,if,it,had,been,collected,directly;override,public,aggregator,wrap,final,aggregator,in,return,new,wrapped,aggregator,in,override,public,internal,aggregation,build,aggregation,long,bucket,throws,ioexception,if,selected,buckets,null,throw,new,illegal,state,exception,collection,has,not,been,replayed,yet,final,long,rebased,bucket,selected,buckets,find,bucket,if,rebased,bucket,1,throw,new,illegal,state,exception,cannot,build,for,a,bucket,which,has,not,been,collected,return,in,build,aggregation,rebased,bucket
BestBucketsDeferringCollector -> @Override     public Aggregator wrap(final Aggregator in);1536314350;Wrap the provided aggregator so that it behaves (almost) as if it had_been collected directly.;@Override_    public Aggregator wrap(final Aggregator in) {__        return new WrappedAggregator(in) {__            @Override_            public InternalAggregation buildAggregation(long bucket) throws IOException {_                if (selectedBuckets == null) {_                    throw new IllegalStateException("Collection has not been replayed yet.")__                }_                final long rebasedBucket = selectedBuckets.find(bucket)__                if (rebasedBucket == -1) {_                    throw new IllegalStateException("Cannot build for a bucket which has not been collected")__                }_                return in.buildAggregation(rebasedBucket)__            }__        }__    };wrap,the,provided,aggregator,so,that,it,behaves,almost,as,if,it,had,been,collected,directly;override,public,aggregator,wrap,final,aggregator,in,return,new,wrapped,aggregator,in,override,public,internal,aggregation,build,aggregation,long,bucket,throws,ioexception,if,selected,buckets,null,throw,new,illegal,state,exception,collection,has,not,been,replayed,yet,final,long,rebased,bucket,selected,buckets,find,bucket,if,rebased,bucket,1,throw,new,illegal,state,exception,cannot,build,for,a,bucket,which,has,not,been,collected,return,in,build,aggregation,rebased,bucket
BestBucketsDeferringCollector -> public BestBucketsDeferringCollector(SearchContext context, boolean isGlobal);1524684173;Sole constructor._@param context The search context_@param isGlobal Whether this collector visits all documents (global context);public BestBucketsDeferringCollector(SearchContext context, boolean isGlobal) {_        this.searchContext = context__        this.isGlobal = isGlobal__    };sole,constructor,param,context,the,search,context,param,is,global,whether,this,collector,visits,all,documents,global,context;public,best,buckets,deferring,collector,search,context,context,boolean,is,global,this,search,context,context,this,is,global,is,global
BestBucketsDeferringCollector -> public BestBucketsDeferringCollector(SearchContext context, boolean isGlobal);1535965276;Sole constructor._@param context The search context_@param isGlobal Whether this collector visits all documents (global context);public BestBucketsDeferringCollector(SearchContext context, boolean isGlobal) {_        this.searchContext = context__        this.isGlobal = isGlobal__    };sole,constructor,param,context,the,search,context,param,is,global,whether,this,collector,visits,all,documents,global,context;public,best,buckets,deferring,collector,search,context,context,boolean,is,global,this,search,context,context,this,is,global,is,global
BestBucketsDeferringCollector -> public BestBucketsDeferringCollector(SearchContext context, boolean isGlobal);1536314350;Sole constructor._@param context The search context_@param isGlobal Whether this collector visits all documents (global context);public BestBucketsDeferringCollector(SearchContext context, boolean isGlobal) {_        this.searchContext = context__        this.isGlobal = isGlobal__    };sole,constructor,param,context,the,search,context,param,is,global,whether,this,collector,visits,all,documents,global,context;public,best,buckets,deferring,collector,search,context,context,boolean,is,global,this,search,context,context,this,is,global,is,global
BestBucketsDeferringCollector -> @Override     public void prepareSelectedBuckets(long... selectedBuckets) throws IOException;1524684173;Replay the wrapped collector, but only on a selection of buckets.;@Override_    public void prepareSelectedBuckets(long... selectedBuckets) throws IOException {_        if (!finished) {_            throw new IllegalStateException("Cannot replay yet, collection is not finished: postCollect() has not been called")__        }_        if (this.selectedBuckets != null) {_            throw new IllegalStateException("Already been replayed")__        }__        final LongHash hash = new LongHash(selectedBuckets.length, BigArrays.NON_RECYCLING_INSTANCE)__        for (long bucket : selectedBuckets) {_            hash.add(bucket)__        }_        this.selectedBuckets = hash___        boolean needsScores = needsScores()__        Weight weight = null__        if (needsScores) {_            Query query = isGlobal ? new MatchAllDocsQuery() : searchContext.query()__            weight = searchContext.searcher().createNormalizedWeight(query, true)__        }_        for (Entry entry : entries) {_            final LeafBucketCollector leafCollector = collector.getLeafCollector(entry.context)__            DocIdSetIterator docIt = null__            if (needsScores && entry.docDeltas.size() > 0) {_                Scorer scorer = weight.scorer(entry.context)__                _                _                docIt = scorer.iterator()__                leafCollector.setScorer(scorer)__            }_            final PackedLongValues.Iterator docDeltaIterator = entry.docDeltas.iterator()__            final PackedLongValues.Iterator buckets = entry.buckets.iterator()__            int doc = 0__            for (long i = 0, end = entry.docDeltas.size()_ i < end_ ++i) {_                doc += docDeltaIterator.next()__                final long bucket = buckets.next()__                final long rebasedBucket = hash.find(bucket)__                if (rebasedBucket != -1) {_                    if (needsScores) {_                        if (docIt.docID() < doc) {_                            docIt.advance(doc)__                        }_                        _                        assert docIt.docID() == doc__                    }_                    leafCollector.collect(doc, rebasedBucket)__                }_            }_        }__        collector.postCollection()__    };replay,the,wrapped,collector,but,only,on,a,selection,of,buckets;override,public,void,prepare,selected,buckets,long,selected,buckets,throws,ioexception,if,finished,throw,new,illegal,state,exception,cannot,replay,yet,collection,is,not,finished,post,collect,has,not,been,called,if,this,selected,buckets,null,throw,new,illegal,state,exception,already,been,replayed,final,long,hash,hash,new,long,hash,selected,buckets,length,big,arrays,for,long,bucket,selected,buckets,hash,add,bucket,this,selected,buckets,hash,boolean,needs,scores,needs,scores,weight,weight,null,if,needs,scores,query,query,is,global,new,match,all,docs,query,search,context,query,weight,search,context,searcher,create,normalized,weight,query,true,for,entry,entry,entries,final,leaf,bucket,collector,leaf,collector,collector,get,leaf,collector,entry,context,doc,id,set,iterator,doc,it,null,if,needs,scores,entry,doc,deltas,size,0,scorer,scorer,weight,scorer,entry,context,doc,it,scorer,iterator,leaf,collector,set,scorer,scorer,final,packed,long,values,iterator,doc,delta,iterator,entry,doc,deltas,iterator,final,packed,long,values,iterator,buckets,entry,buckets,iterator,int,doc,0,for,long,i,0,end,entry,doc,deltas,size,i,end,i,doc,doc,delta,iterator,next,final,long,bucket,buckets,next,final,long,rebased,bucket,hash,find,bucket,if,rebased,bucket,1,if,needs,scores,if,doc,it,doc,id,doc,doc,it,advance,doc,assert,doc,it,doc,id,doc,leaf,collector,collect,doc,rebased,bucket,collector,post,collection
BestBucketsDeferringCollector -> @Override     public void prepareSelectedBuckets(long... selectedBuckets) throws IOException;1535965276;Replay the wrapped collector, but only on a selection of buckets.;@Override_    public void prepareSelectedBuckets(long... selectedBuckets) throws IOException {_        if (!finished) {_            throw new IllegalStateException("Cannot replay yet, collection is not finished: postCollect() has not been called")__        }_        if (this.selectedBuckets != null) {_            throw new IllegalStateException("Already been replayed")__        }__        final LongHash hash = new LongHash(selectedBuckets.length, BigArrays.NON_RECYCLING_INSTANCE)__        for (long bucket : selectedBuckets) {_            hash.add(bucket)__        }_        this.selectedBuckets = hash___        boolean needsScores = needsScores()__        Weight weight = null__        if (needsScores) {_            Query query = isGlobal ? new MatchAllDocsQuery() : searchContext.query()__            weight = searchContext.searcher().createNormalizedWeight(query, true)__        }_        for (Entry entry : entries) {_            final LeafBucketCollector leafCollector = collector.getLeafCollector(entry.context)__            DocIdSetIterator docIt = null__            if (needsScores && entry.docDeltas.size() > 0) {_                Scorer scorer = weight.scorer(entry.context)__                _                _                docIt = scorer.iterator()__                leafCollector.setScorer(scorer)__            }_            final PackedLongValues.Iterator docDeltaIterator = entry.docDeltas.iterator()__            final PackedLongValues.Iterator buckets = entry.buckets.iterator()__            int doc = 0__            for (long i = 0, end = entry.docDeltas.size()_ i < end_ ++i) {_                doc += docDeltaIterator.next()__                final long bucket = buckets.next()__                final long rebasedBucket = hash.find(bucket)__                if (rebasedBucket != -1) {_                    if (needsScores) {_                        if (docIt.docID() < doc) {_                            docIt.advance(doc)__                        }_                        _                        assert docIt.docID() == doc__                    }_                    leafCollector.collect(doc, rebasedBucket)__                }_            }_        }__        collector.postCollection()__    };replay,the,wrapped,collector,but,only,on,a,selection,of,buckets;override,public,void,prepare,selected,buckets,long,selected,buckets,throws,ioexception,if,finished,throw,new,illegal,state,exception,cannot,replay,yet,collection,is,not,finished,post,collect,has,not,been,called,if,this,selected,buckets,null,throw,new,illegal,state,exception,already,been,replayed,final,long,hash,hash,new,long,hash,selected,buckets,length,big,arrays,for,long,bucket,selected,buckets,hash,add,bucket,this,selected,buckets,hash,boolean,needs,scores,needs,scores,weight,weight,null,if,needs,scores,query,query,is,global,new,match,all,docs,query,search,context,query,weight,search,context,searcher,create,normalized,weight,query,true,for,entry,entry,entries,final,leaf,bucket,collector,leaf,collector,collector,get,leaf,collector,entry,context,doc,id,set,iterator,doc,it,null,if,needs,scores,entry,doc,deltas,size,0,scorer,scorer,weight,scorer,entry,context,doc,it,scorer,iterator,leaf,collector,set,scorer,scorer,final,packed,long,values,iterator,doc,delta,iterator,entry,doc,deltas,iterator,final,packed,long,values,iterator,buckets,entry,buckets,iterator,int,doc,0,for,long,i,0,end,entry,doc,deltas,size,i,end,i,doc,doc,delta,iterator,next,final,long,bucket,buckets,next,final,long,rebased,bucket,hash,find,bucket,if,rebased,bucket,1,if,needs,scores,if,doc,it,doc,id,doc,doc,it,advance,doc,assert,doc,it,doc,id,doc,leaf,collector,collect,doc,rebased,bucket,collector,post,collection
BestBucketsDeferringCollector -> @Override     public void prepareSelectedBuckets(long... selectedBuckets) throws IOException;1536314350;Replay the wrapped collector, but only on a selection of buckets.;@Override_    public void prepareSelectedBuckets(long... selectedBuckets) throws IOException {_        if (!finished) {_            throw new IllegalStateException("Cannot replay yet, collection is not finished: postCollect() has not been called")__        }_        if (this.selectedBuckets != null) {_            throw new IllegalStateException("Already been replayed")__        }__        final LongHash hash = new LongHash(selectedBuckets.length, BigArrays.NON_RECYCLING_INSTANCE)__        for (long bucket : selectedBuckets) {_            hash.add(bucket)__        }_        this.selectedBuckets = hash___        boolean needsScores = scoreMode().needsScores()__        Weight weight = null__        if (needsScores) {_            Query query = isGlobal ? new MatchAllDocsQuery() : searchContext.query()__            weight = searchContext.searcher().createWeight(searchContext.searcher().rewrite(query), ScoreMode.COMPLETE, 1f)__        }_        for (Entry entry : entries) {_            final LeafBucketCollector leafCollector = collector.getLeafCollector(entry.context)__            DocIdSetIterator docIt = null__            if (needsScores && entry.docDeltas.size() > 0) {_                Scorer scorer = weight.scorer(entry.context)__                _                _                docIt = scorer.iterator()__                leafCollector.setScorer(scorer)__            }_            final PackedLongValues.Iterator docDeltaIterator = entry.docDeltas.iterator()__            final PackedLongValues.Iterator buckets = entry.buckets.iterator()__            int doc = 0__            for (long i = 0, end = entry.docDeltas.size()_ i < end_ ++i) {_                doc += docDeltaIterator.next()__                final long bucket = buckets.next()__                final long rebasedBucket = hash.find(bucket)__                if (rebasedBucket != -1) {_                    if (needsScores) {_                        if (docIt.docID() < doc) {_                            docIt.advance(doc)__                        }_                        _                        assert docIt.docID() == doc__                    }_                    leafCollector.collect(doc, rebasedBucket)__                }_            }_        }__        collector.postCollection()__    };replay,the,wrapped,collector,but,only,on,a,selection,of,buckets;override,public,void,prepare,selected,buckets,long,selected,buckets,throws,ioexception,if,finished,throw,new,illegal,state,exception,cannot,replay,yet,collection,is,not,finished,post,collect,has,not,been,called,if,this,selected,buckets,null,throw,new,illegal,state,exception,already,been,replayed,final,long,hash,hash,new,long,hash,selected,buckets,length,big,arrays,for,long,bucket,selected,buckets,hash,add,bucket,this,selected,buckets,hash,boolean,needs,scores,score,mode,needs,scores,weight,weight,null,if,needs,scores,query,query,is,global,new,match,all,docs,query,search,context,query,weight,search,context,searcher,create,weight,search,context,searcher,rewrite,query,score,mode,complete,1f,for,entry,entry,entries,final,leaf,bucket,collector,leaf,collector,collector,get,leaf,collector,entry,context,doc,id,set,iterator,doc,it,null,if,needs,scores,entry,doc,deltas,size,0,scorer,scorer,weight,scorer,entry,context,doc,it,scorer,iterator,leaf,collector,set,scorer,scorer,final,packed,long,values,iterator,doc,delta,iterator,entry,doc,deltas,iterator,final,packed,long,values,iterator,buckets,entry,buckets,iterator,int,doc,0,for,long,i,0,end,entry,doc,deltas,size,i,end,i,doc,doc,delta,iterator,next,final,long,bucket,buckets,next,final,long,rebased,bucket,hash,find,bucket,if,rebased,bucket,1,if,needs,scores,if,doc,it,doc,id,doc,doc,it,advance,doc,assert,doc,it,doc,id,doc,leaf,collector,collect,doc,rebased,bucket,collector,post,collection
BestBucketsDeferringCollector -> @Override     public void setDeferredCollector(Iterable<BucketCollector> deferredCollectors);1524684173;Set the deferred collectors.;@Override_    public void setDeferredCollector(Iterable<BucketCollector> deferredCollectors) {_        this.collector = BucketCollector.wrap(deferredCollectors)__    };set,the,deferred,collectors;override,public,void,set,deferred,collector,iterable,bucket,collector,deferred,collectors,this,collector,bucket,collector,wrap,deferred,collectors
BestBucketsDeferringCollector -> @Override     public void setDeferredCollector(Iterable<BucketCollector> deferredCollectors);1535965276;Set the deferred collectors.;@Override_    public void setDeferredCollector(Iterable<BucketCollector> deferredCollectors) {_        this.collector = MultiBucketCollector.wrap(deferredCollectors)__    };set,the,deferred,collectors;override,public,void,set,deferred,collector,iterable,bucket,collector,deferred,collectors,this,collector,multi,bucket,collector,wrap,deferred,collectors
BestBucketsDeferringCollector -> @Override     public void setDeferredCollector(Iterable<BucketCollector> deferredCollectors);1536314350;Set the deferred collectors.;@Override_    public void setDeferredCollector(Iterable<BucketCollector> deferredCollectors) {_        this.collector = MultiBucketCollector.wrap(deferredCollectors)__    };set,the,deferred,collectors;override,public,void,set,deferred,collector,iterable,bucket,collector,deferred,collectors,this,collector,multi,bucket,collector,wrap,deferred,collectors
