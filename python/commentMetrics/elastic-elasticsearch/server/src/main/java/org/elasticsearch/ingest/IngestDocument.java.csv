commented;modifiers;parameterAmount;loc;comment;code
true;public;2;8;/**  * Returns the value contained in the document for the provided path  * @param path The path within the document in dot-notation  * @param clazz The expected class of the field value  * @return the value for the provided path if existing, null otherwise  * @throws IllegalArgumentException if the path is null, empty, invalid, if the field doesn't exist  * or if the field that is found at the provided path is not of the expected type.  */ ;/**  * Returns the value contained in the document for the provided path  * @param path The path within the document in dot-notation  * @param clazz The expected class of the field value  * @return the value for the provided path if existing, null otherwise  * @throws IllegalArgumentException if the path is null, empty, invalid, if the field doesn't exist  * or if the field that is found at the provided path is not of the expected type.  */ public <T> T getFieldValue(String path, Class<T> clazz) {     FieldPath fieldPath = new FieldPath(path).     Object context = fieldPath.initialContext.     for (String pathElement : fieldPath.pathElements) {         context = resolve(pathElement, path, context).     }     return cast(path, context, clazz). }
true;public;3;11;/**  * Returns the value contained in the document for the provided path  *  * @param path The path within the document in dot-notation  * @param clazz The expected class of the field value  * @param ignoreMissing The flag to determine whether to throw an exception when `path` is not found in the document.  * @return the value for the provided path if existing, null otherwise.  * @throws IllegalArgumentException only if ignoreMissing is false and the path is null, empty, invalid, if the field doesn't exist  * or if the field that is found at the provided path is not of the expected type.  */ ;/**  * Returns the value contained in the document for the provided path  *  * @param path The path within the document in dot-notation  * @param clazz The expected class of the field value  * @param ignoreMissing The flag to determine whether to throw an exception when `path` is not found in the document.  * @return the value for the provided path if existing, null otherwise.  * @throws IllegalArgumentException only if ignoreMissing is false and the path is null, empty, invalid, if the field doesn't exist  * or if the field that is found at the provided path is not of the expected type.  */ public <T> T getFieldValue(String path, Class<T> clazz, boolean ignoreMissing) {     try {         return getFieldValue(path, clazz).     } catch (IllegalArgumentException e) {         if (ignoreMissing && hasField(path) != true) {             return null.         } else {             throw e.         }     } }
true;public;2;3;/**  * Returns the value contained in the document with the provided templated path  * @param pathTemplate The path within the document in dot-notation  * @param clazz The expected class fo the field value  * @return the value fro the provided path if existing, null otherwise  * @throws IllegalArgumentException if the pathTemplate is null, empty, invalid, if the field doesn't exist,  * or if the field that is found at the provided path is not of the expected type.  */ ;/**  * Returns the value contained in the document with the provided templated path  * @param pathTemplate The path within the document in dot-notation  * @param clazz The expected class fo the field value  * @return the value fro the provided path if existing, null otherwise  * @throws IllegalArgumentException if the pathTemplate is null, empty, invalid, if the field doesn't exist,  * or if the field that is found at the provided path is not of the expected type.  */ public <T> T getFieldValue(TemplateScript.Factory pathTemplate, Class<T> clazz) {     return getFieldValue(renderTemplate(pathTemplate), clazz). }
true;public;1;3;/**  * Returns the value contained in the document for the provided path as a byte array.  * If the path value is a string, a base64 decode operation will happen.  * If the path value is a byte array, it is just returned  * @param path The path within the document in dot-notation  * @return the byte array for the provided path if existing  * @throws IllegalArgumentException if the path is null, empty, invalid, if the field doesn't exist  * or if the field that is found at the provided path is not of the expected type.  */ ;/**  * Returns the value contained in the document for the provided path as a byte array.  * If the path value is a string, a base64 decode operation will happen.  * If the path value is a byte array, it is just returned  * @param path The path within the document in dot-notation  * @return the byte array for the provided path if existing  * @throws IllegalArgumentException if the path is null, empty, invalid, if the field doesn't exist  * or if the field that is found at the provided path is not of the expected type.  */ public byte[] getFieldValueAsBytes(String path) {     return getFieldValueAsBytes(path, false). }
true;public;2;13;/**  * Returns the value contained in the document for the provided path as a byte array.  * If the path value is a string, a base64 decode operation will happen.  * If the path value is a byte array, it is just returned  * @param path The path within the document in dot-notation  * @param ignoreMissing The flag to determine whether to throw an exception when `path` is not found in the document.  * @return the byte array for the provided path if existing  * @throws IllegalArgumentException if the path is null, empty, invalid, if the field doesn't exist  * or if the field that is found at the provided path is not of the expected type.  */ ;/**  * Returns the value contained in the document for the provided path as a byte array.  * If the path value is a string, a base64 decode operation will happen.  * If the path value is a byte array, it is just returned  * @param path The path within the document in dot-notation  * @param ignoreMissing The flag to determine whether to throw an exception when `path` is not found in the document.  * @return the byte array for the provided path if existing  * @throws IllegalArgumentException if the path is null, empty, invalid, if the field doesn't exist  * or if the field that is found at the provided path is not of the expected type.  */ public byte[] getFieldValueAsBytes(String path, boolean ignoreMissing) {     Object object = getFieldValue(path, Object.class, ignoreMissing).     if (object == null) {         return null.     } else if (object instanceof byte[]) {         return (byte[]) object.     } else if (object instanceof String) {         return Base64.getDecoder().decode(object.toString()).     } else {         throw new IllegalArgumentException("Content field [" + path + "] of unknown type [" + object.getClass().getName() + "], must be string or byte array").     } }
true;public;1;3;/**  * Checks whether the document contains a value for the provided templated path  * @param fieldPathTemplate the template for the path within the document in dot-notation  * @return true if the document contains a value for the field, false otherwise  * @throws IllegalArgumentException if the path is null, empty or invalid  */ ;/**  * Checks whether the document contains a value for the provided templated path  * @param fieldPathTemplate the template for the path within the document in dot-notation  * @return true if the document contains a value for the field, false otherwise  * @throws IllegalArgumentException if the path is null, empty or invalid  */ public boolean hasField(TemplateScript.Factory fieldPathTemplate) {     return hasField(renderTemplate(fieldPathTemplate)). }
true;public;1;3;/**  * Checks whether the document contains a value for the provided path  * @param path The path within the document in dot-notation  * @return true if the document contains a value for the field, false otherwise  * @throws IllegalArgumentException if the path is null, empty or invalid.  */ ;/**  * Checks whether the document contains a value for the provided path  * @param path The path within the document in dot-notation  * @return true if the document contains a value for the field, false otherwise  * @throws IllegalArgumentException if the path is null, empty or invalid.  */ public boolean hasField(String path) {     return hasField(path, false). }
true;public;2;62;/**  * Checks whether the document contains a value for the provided path  * @param path The path within the document in dot-notation  * @param failOutOfRange Whether to throw an IllegalArgumentException if array is accessed outside of its range  * @return true if the document contains a value for the field, false otherwise  * @throws IllegalArgumentException if the path is null, empty or invalid.  */ ;/**  * Checks whether the document contains a value for the provided path  * @param path The path within the document in dot-notation  * @param failOutOfRange Whether to throw an IllegalArgumentException if array is accessed outside of its range  * @return true if the document contains a value for the field, false otherwise  * @throws IllegalArgumentException if the path is null, empty or invalid.  */ public boolean hasField(String path, boolean failOutOfRange) {     FieldPath fieldPath = new FieldPath(path).     Object context = fieldPath.initialContext.     for (int i = 0. i < fieldPath.pathElements.length - 1. i++) {         String pathElement = fieldPath.pathElements[i].         if (context == null) {             return false.         }         if (context instanceof Map) {             @SuppressWarnings("unchecked")             Map<String, Object> map = (Map<String, Object>) context.             context = map.get(pathElement).         } else if (context instanceof List) {             @SuppressWarnings("unchecked")             List<Object> list = (List<Object>) context.             try {                 int index = Integer.parseInt(pathElement).                 if (index < 0 || index >= list.size()) {                     if (failOutOfRange) {                         throw new IllegalArgumentException("[" + index + "] is out of bounds for array with length [" + list.size() + "] as part of path [" + path + "]").                     } else {                         return false.                     }                 }                 context = list.get(index).             } catch (NumberFormatException e) {                 return false.             }         } else {             return false.         }     }     String leafKey = fieldPath.pathElements[fieldPath.pathElements.length - 1].     if (context instanceof Map) {         @SuppressWarnings("unchecked")         Map<String, Object> map = (Map<String, Object>) context.         return map.containsKey(leafKey).     }     if (context instanceof List) {         @SuppressWarnings("unchecked")         List<Object> list = (List<Object>) context.         try {             int index = Integer.parseInt(leafKey).             if (index >= 0 && index < list.size()) {                 return true.             } else {                 if (failOutOfRange) {                     throw new IllegalArgumentException("[" + index + "] is out of bounds for array with length [" + list.size() + "] as part of path [" + path + "]").                 } else {                     return false.                 }             }         } catch (NumberFormatException e) {             return false.         }     }     return false. }
true;public;1;3;/**  * Removes the field identified by the provided path.  * @param fieldPathTemplate Resolves to the path with dot-notation within the document  * @throws IllegalArgumentException if the path is null, empty, invalid or if the field doesn't exist.  */ ;/**  * Removes the field identified by the provided path.  * @param fieldPathTemplate Resolves to the path with dot-notation within the document  * @throws IllegalArgumentException if the path is null, empty, invalid or if the field doesn't exist.  */ public void removeField(TemplateScript.Factory fieldPathTemplate) {     removeField(renderTemplate(fieldPathTemplate)). }
true;public;1;41;/**  * Removes the field identified by the provided path.  * @param path the path of the field to be removed  * @throws IllegalArgumentException if the path is null, empty, invalid or if the field doesn't exist.  */ ;/**  * Removes the field identified by the provided path.  * @param path the path of the field to be removed  * @throws IllegalArgumentException if the path is null, empty, invalid or if the field doesn't exist.  */ public void removeField(String path) {     FieldPath fieldPath = new FieldPath(path).     Object context = fieldPath.initialContext.     for (int i = 0. i < fieldPath.pathElements.length - 1. i++) {         context = resolve(fieldPath.pathElements[i], path, context).     }     String leafKey = fieldPath.pathElements[fieldPath.pathElements.length - 1].     if (context instanceof Map) {         @SuppressWarnings("unchecked")         Map<String, Object> map = (Map<String, Object>) context.         if (map.containsKey(leafKey)) {             map.remove(leafKey).             return.         }         throw new IllegalArgumentException("field [" + leafKey + "] not present as part of path [" + path + "]").     }     if (context instanceof List) {         @SuppressWarnings("unchecked")         List<Object> list = (List<Object>) context.         int index.         try {             index = Integer.parseInt(leafKey).         } catch (NumberFormatException e) {             throw new IllegalArgumentException("[" + leafKey + "] is not an integer, cannot be used as an index as part of path [" + path + "]", e).         }         if (index < 0 || index >= list.size()) {             throw new IllegalArgumentException("[" + index + "] is out of bounds for array with length [" + list.size() + "] as part of path [" + path + "]").         }         list.remove(index).         return.     }     if (context == null) {         throw new IllegalArgumentException("cannot remove [" + leafKey + "] from null as part of path [" + path + "]").     }     throw new IllegalArgumentException("cannot remove [" + leafKey + "] from object of type [" + context.getClass().getName() + "] as part of path [" + path + "]"). }
false;private,static;3;31;;private static Object resolve(String pathElement, String fullPath, Object context) {     if (context == null) {         throw new IllegalArgumentException("cannot resolve [" + pathElement + "] from null as part of path [" + fullPath + "]").     }     if (context instanceof Map) {         @SuppressWarnings("unchecked")         Map<String, Object> map = (Map<String, Object>) context.         if (map.containsKey(pathElement)) {             return map.get(pathElement).         }         throw new IllegalArgumentException("field [" + pathElement + "] not present as part of path [" + fullPath + "]").     }     if (context instanceof List) {         @SuppressWarnings("unchecked")         List<Object> list = (List<Object>) context.         int index.         try {             index = Integer.parseInt(pathElement).         } catch (NumberFormatException e) {             throw new IllegalArgumentException("[" + pathElement + "] is not an integer, cannot be used as an index as part of path [" + fullPath + "]", e).         }         if (index < 0 || index >= list.size()) {             throw new IllegalArgumentException("[" + index + "] is out of bounds for array with length [" + list.size() + "] as part of path [" + fullPath + "]").         }         return list.get(index).     }     throw new IllegalArgumentException("cannot resolve [" + pathElement + "] from object of type [" + context.getClass().getName() + "] as part of path [" + fullPath + "]"). }
true;public;2;3;/**  * Appends the provided value to the provided path in the document.  * Any non existing path element will be created.  * If the path identifies a list, the value will be appended to the existing list.  * If the path identifies a scalar, the scalar will be converted to a list and  * the provided value will be added to the newly created list.  * Supports multiple values too provided in forms of list, in that case all the values will be appended to the  * existing (or newly created) list.  * @param path The path within the document in dot-notation  * @param value The value or values to append to the existing ones  * @throws IllegalArgumentException if the path is null, empty or invalid.  */ ;/**  * Appends the provided value to the provided path in the document.  * Any non existing path element will be created.  * If the path identifies a list, the value will be appended to the existing list.  * If the path identifies a scalar, the scalar will be converted to a list and  * the provided value will be added to the newly created list.  * Supports multiple values too provided in forms of list, in that case all the values will be appended to the  * existing (or newly created) list.  * @param path The path within the document in dot-notation  * @param value The value or values to append to the existing ones  * @throws IllegalArgumentException if the path is null, empty or invalid.  */ public void appendFieldValue(String path, Object value) {     setFieldValue(path, value, true). }
true;public;2;4;/**  * Appends the provided value to the provided path in the document.  * Any non existing path element will be created.  * If the path identifies a list, the value will be appended to the existing list.  * If the path identifies a scalar, the scalar will be converted to a list and  * the provided value will be added to the newly created list.  * Supports multiple values too provided in forms of list, in that case all the values will be appended to the  * existing (or newly created) list.  * @param fieldPathTemplate Resolves to the path with dot-notation within the document  * @param valueSource The value source that will produce the value or values to append to the existing ones  * @throws IllegalArgumentException if the path is null, empty or invalid.  */ ;/**  * Appends the provided value to the provided path in the document.  * Any non existing path element will be created.  * If the path identifies a list, the value will be appended to the existing list.  * If the path identifies a scalar, the scalar will be converted to a list and  * the provided value will be added to the newly created list.  * Supports multiple values too provided in forms of list, in that case all the values will be appended to the  * existing (or newly created) list.  * @param fieldPathTemplate Resolves to the path with dot-notation within the document  * @param valueSource The value source that will produce the value or values to append to the existing ones  * @throws IllegalArgumentException if the path is null, empty or invalid.  */ public void appendFieldValue(TemplateScript.Factory fieldPathTemplate, ValueSource valueSource) {     Map<String, Object> model = createTemplateModel().     appendFieldValue(fieldPathTemplate.newInstance(model).execute(), valueSource.copyAndResolve(model)). }
true;public;2;3;/**  * Sets the provided value to the provided path in the document.  * Any non existing path element will be created.  * If the last item in the path is a list, the value will replace the existing list as a whole.  * Use {@link #appendFieldValue(String, Object)} to append values to lists instead.  * @param path The path within the document in dot-notation  * @param value The value to put in for the path key  * @throws IllegalArgumentException if the path is null, empty, invalid or if the value cannot be set to the  * item identified by the provided path.  */ ;/**  * Sets the provided value to the provided path in the document.  * Any non existing path element will be created.  * If the last item in the path is a list, the value will replace the existing list as a whole.  * Use {@link #appendFieldValue(String, Object)} to append values to lists instead.  * @param path The path within the document in dot-notation  * @param value The value to put in for the path key  * @throws IllegalArgumentException if the path is null, empty, invalid or if the value cannot be set to the  * item identified by the provided path.  */ public void setFieldValue(String path, Object value) {     setFieldValue(path, value, false). }
true;public;2;4;/**  * Sets the provided value to the provided path in the document.  * Any non existing path element will be created. If the last element is a list,  * the value will replace the existing list.  * @param fieldPathTemplate Resolves to the path with dot-notation within the document  * @param valueSource The value source that will produce the value to put in for the path key  * @throws IllegalArgumentException if the path is null, empty, invalid or if the value cannot be set to the  * item identified by the provided path.  */ ;/**  * Sets the provided value to the provided path in the document.  * Any non existing path element will be created. If the last element is a list,  * the value will replace the existing list.  * @param fieldPathTemplate Resolves to the path with dot-notation within the document  * @param valueSource The value source that will produce the value to put in for the path key  * @throws IllegalArgumentException if the path is null, empty, invalid or if the value cannot be set to the  * item identified by the provided path.  */ public void setFieldValue(TemplateScript.Factory fieldPathTemplate, ValueSource valueSource) {     Map<String, Object> model = createTemplateModel().     setFieldValue(fieldPathTemplate.newInstance(model).execute(), valueSource.copyAndResolve(model), false). }
false;private;3;89;;private void setFieldValue(String path, Object value, boolean append) {     FieldPath fieldPath = new FieldPath(path).     Object context = fieldPath.initialContext.     for (int i = 0. i < fieldPath.pathElements.length - 1. i++) {         String pathElement = fieldPath.pathElements[i].         if (context == null) {             throw new IllegalArgumentException("cannot resolve [" + pathElement + "] from null as part of path [" + path + "]").         }         if (context instanceof Map) {             @SuppressWarnings("unchecked")             Map<String, Object> map = (Map<String, Object>) context.             if (map.containsKey(pathElement)) {                 context = map.get(pathElement).             } else {                 HashMap<Object, Object> newMap = new HashMap<>().                 map.put(pathElement, newMap).                 context = newMap.             }         } else if (context instanceof List) {             @SuppressWarnings("unchecked")             List<Object> list = (List<Object>) context.             int index.             try {                 index = Integer.parseInt(pathElement).             } catch (NumberFormatException e) {                 throw new IllegalArgumentException("[" + pathElement + "] is not an integer, cannot be used as an index as part of path [" + path + "]", e).             }             if (index < 0 || index >= list.size()) {                 throw new IllegalArgumentException("[" + index + "] is out of bounds for array with length [" + list.size() + "] as part of path [" + path + "]").             }             context = list.get(index).         } else {             throw new IllegalArgumentException("cannot resolve [" + pathElement + "] from object of type [" + context.getClass().getName() + "] as part of path [" + path + "]").         }     }     String leafKey = fieldPath.pathElements[fieldPath.pathElements.length - 1].     if (context == null) {         throw new IllegalArgumentException("cannot set [" + leafKey + "] with null parent as part of path [" + path + "]").     }     if (context instanceof Map) {         @SuppressWarnings("unchecked")         Map<String, Object> map = (Map<String, Object>) context.         if (append) {             if (map.containsKey(leafKey)) {                 Object object = map.get(leafKey).                 List<Object> list = appendValues(object, value).                 if (list != object) {                     map.put(leafKey, list).                 }             } else {                 List<Object> list = new ArrayList<>().                 appendValues(list, value).                 map.put(leafKey, list).             }             return.         }         map.put(leafKey, value).     } else if (context instanceof List) {         @SuppressWarnings("unchecked")         List<Object> list = (List<Object>) context.         int index.         try {             index = Integer.parseInt(leafKey).         } catch (NumberFormatException e) {             throw new IllegalArgumentException("[" + leafKey + "] is not an integer, cannot be used as an index as part of path [" + path + "]", e).         }         if (index < 0 || index >= list.size()) {             throw new IllegalArgumentException("[" + index + "] is out of bounds for array with length [" + list.size() + "] as part of path [" + path + "]").         }         if (append) {             Object object = list.get(index).             List<Object> newList = appendValues(object, value).             if (newList != object) {                 list.set(index, newList).             }             return.         }         list.set(index, value).     } else {         throw new IllegalArgumentException("cannot set [" + leafKey + "] with parent object of type [" + context.getClass().getName() + "] as part of path [" + path + "]").     } }
false;private,static;2;14;;@SuppressWarnings("unchecked") private static List<Object> appendValues(Object maybeList, Object value) {     List<Object> list.     if (maybeList instanceof List) {         // maybeList is already a list, we append the provided values to it         list = (List<Object>) maybeList.     } else {         // maybeList is a scalar, we convert it to a list and append the provided values to it         list = new ArrayList<>().         list.add(maybeList).     }     appendValues(list, value).     return list. }
false;private,static;2;7;;private static void appendValues(List<Object> list, Object value) {     if (value instanceof List) {         list.addAll((List<?>) value).     } else {         list.add(value).     } }
false;private,static;3;10;;private static <T> T cast(String path, Object object, Class<T> clazz) {     if (object == null) {         return null.     }     if (clazz.isInstance(object)) {         return clazz.cast(object).     }     throw new IllegalArgumentException("field [" + path + "] of type [" + object.getClass().getName() + "] cannot be cast to [" + clazz.getName() + "]"). }
false;public;1;3;;public String renderTemplate(TemplateScript.Factory template) {     return template.newInstance(createTemplateModel()).execute(). }
false;private;0;8;;private Map<String, Object> createTemplateModel() {     Map<String, Object> model = new HashMap<>(sourceAndMetadata).     model.put(SourceFieldMapper.NAME, sourceAndMetadata).     // If there is a field in the source with the name '_ingest' it gets overwritten here,     // if access to that field is required then it get accessed via '_source._ingest'     model.put(INGEST_KEY, ingestMetadata).     return model. }
true;public;0;7;/**  * one time operation that extracts the metadata fields from the ingest document and returns them.  * Metadata fields that used to be accessible as ordinary top level fields will be removed as part of this call.  */ ;/**  * one time operation that extracts the metadata fields from the ingest document and returns them.  * Metadata fields that used to be accessible as ordinary top level fields will be removed as part of this call.  */ public Map<MetaData, Object> extractMetadata() {     Map<MetaData, Object> metadataMap = new EnumMap<>(MetaData.class).     for (MetaData metaData : MetaData.values()) {         metadataMap.put(metaData, sourceAndMetadata.remove(metaData.getFieldName())).     }     return metadataMap. }
true;public;0;7;/**  * Does the same thing as {@link #extractMetadata} but does not mutate the map.  */ ;/**  * Does the same thing as {@link #extractMetadata} but does not mutate the map.  */ public Map<MetaData, Object> getMetadata() {     Map<MetaData, Object> metadataMap = new EnumMap<>(MetaData.class).     for (MetaData metaData : MetaData.values()) {         metadataMap.put(metaData, sourceAndMetadata.get(metaData.getFieldName())).     }     return metadataMap. }
true;public;0;3;/**  * Returns the available ingest metadata fields, by default only timestamp, but it is possible to set additional ones.  * Use only for reading values, modify them instead using {@link #setFieldValue(String, Object)} and {@link #removeField(String)}  */ ;/**  * Returns the available ingest metadata fields, by default only timestamp, but it is possible to set additional ones.  * Use only for reading values, modify them instead using {@link #setFieldValue(String, Object)} and {@link #removeField(String)}  */ public Map<String, Object> getIngestMetadata() {     return this.ingestMetadata. }
true;public;0;3;/**  * Returns the document including its metadata fields, unless {@link #extractMetadata()} has been called, in which case the  * metadata fields will not be present anymore.  * Modify the document instead using {@link #setFieldValue(String, Object)} and {@link #removeField(String)}  */ ;/**  * Returns the document including its metadata fields, unless {@link #extractMetadata()} has been called, in which case the  * metadata fields will not be present anymore.  * Modify the document instead using {@link #setFieldValue(String, Object)} and {@link #removeField(String)}  */ public Map<String, Object> getSourceAndMetadata() {     return this.sourceAndMetadata. }
false;public,static;1;4;;@SuppressWarnings("unchecked") public static <K, V> Map<K, V> deepCopyMap(Map<K, V> source) {     return (Map<K, V>) deepCopy(source). }
false;private,static;1;29;;private static Object deepCopy(Object value) {     if (value instanceof Map) {         Map<?, ?> mapValue = (Map<?, ?>) value.         Map<Object, Object> copy = new HashMap<>(mapValue.size()).         for (Map.Entry<?, ?> entry : mapValue.entrySet()) {             copy.put(entry.getKey(), deepCopy(entry.getValue())).         }         return copy.     } else if (value instanceof List) {         List<?> listValue = (List<?>) value.         List<Object> copy = new ArrayList<>(listValue.size()).         for (Object itemValue : listValue) {             copy.add(deepCopy(itemValue)).         }         return copy.     } else if (value instanceof byte[]) {         byte[] bytes = (byte[]) value.         return Arrays.copyOf(bytes, bytes.length).     } else if (value == null || value instanceof String || value instanceof Integer || value instanceof Long || value instanceof Float || value instanceof Double || value instanceof Boolean || value instanceof ZonedDateTime) {         return value.     } else if (value instanceof Date) {         return ((Date) value).clone().     } else {         throw new IllegalArgumentException("unexpected value type [" + value.getClass() + "]").     } }
true;public;1;10;/**  * Executes the given pipeline with for this document unless the pipeline has already been executed  * for this document.  * @param pipeline Pipeline to execute  * @throws Exception On exception in pipeline execution  */ ;/**  * Executes the given pipeline with for this document unless the pipeline has already been executed  * for this document.  * @param pipeline Pipeline to execute  * @throws Exception On exception in pipeline execution  */ public IngestDocument executePipeline(Pipeline pipeline) throws Exception {     try {         if (this.executedPipelines.add(pipeline) == false) {             throw new IllegalStateException("Cycle detected for pipeline: " + pipeline.getId()).         }         return pipeline.execute(this).     } finally {         executedPipelines.remove(pipeline).     } }
false;public;1;11;;@Override public boolean equals(Object obj) {     if (obj == this) {         return true.     }     if (obj == null || getClass() != obj.getClass()) {         return false.     }     IngestDocument other = (IngestDocument) obj.     return Objects.equals(sourceAndMetadata, other.sourceAndMetadata) && Objects.equals(ingestMetadata, other.ingestMetadata). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(sourceAndMetadata, ingestMetadata). }
false;public;0;7;;@Override public String toString() {     return "IngestDocument{" + " sourceAndMetadata=" + sourceAndMetadata + ", ingestMetadata=" + ingestMetadata + '}'. }
false;public;0;3;;public String getFieldName() {     return fieldName. }
