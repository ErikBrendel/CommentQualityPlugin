commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;5;;@Override protected void doWriteTo(StreamOutput out) throws IOException {     out.writeStringArray(types).     out.writeStringArray(ids.toArray(new String[ids.size()])). }
true;public;1;8;/**  * Add types to query  *  * @deprecated Types are in the process of being removed, prefer to filter on a field instead.  */ ;/**  * Add types to query  *  * @deprecated Types are in the process of being removed, prefer to filter on a field instead.  */ @Deprecated public IdsQueryBuilder types(String... types) {     if (types == null) {         throw new IllegalArgumentException("[" + NAME + "] types cannot be null").     }     this.types = types.     return this. }
true;public;0;4;/**  * Returns the types used in this query  *  * @deprecated Types are in the process of being removed, prefer to filter on a field instead.  */ ;/**  * Returns the types used in this query  *  * @deprecated Types are in the process of being removed, prefer to filter on a field instead.  */ @Deprecated public String[] types() {     return this.types. }
true;public;1;7;/**  * Adds ids to the query.  */ ;/**  * Adds ids to the query.  */ public IdsQueryBuilder addIds(String... ids) {     if (ids == null) {         throw new IllegalArgumentException("[" + NAME + "] ids cannot be null").     }     Collections.addAll(this.ids, ids).     return this. }
true;public;0;3;/**  * Returns the ids for the query.  */ ;/**  * Returns the ids for the query.  */ public Set<String> ids() {     return this.ids. }
false;protected;2;14;;@Override protected void doXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject(NAME).     if (types.length > 0) {         builder.array(TYPE_FIELD.getPreferredName(), types).     }     builder.startArray(VALUES_FIELD.getPreferredName()).     for (String value : ids) {         builder.value(value).     }     builder.endArray().     printBoostAndQueryName(builder).     builder.endObject(). }
false;public,static;1;11;;public static IdsQueryBuilder fromXContent(XContentParser parser) {     try {         IdsQueryBuilder builder = PARSER.apply(parser, null).         if (builder.types().length > 0) {             deprecationLogger.deprecatedAndMaybeLog("ids_query_with_types", TYPES_DEPRECATION_MESSAGE).         }         return builder.     } catch (IllegalArgumentException e) {         throw new ParsingException(parser.getTokenLocation(), e.getMessage(), e).     } }
false;public;0;4;;@Override public String getWriteableName() {     return NAME. }
false;protected;1;27;;@Override protected Query doToQuery(QueryShardContext context) throws IOException {     MappedFieldType idField = context.fieldMapper(IdFieldMapper.NAME).     if (idField == null) {         return new MatchNoDocsQuery("No mappings").     }     if (this.ids.isEmpty()) {         return Queries.newMatchNoDocsQuery("Missing ids in \"" + this.getName() + "\" query.").     } else {         final DocumentMapper mapper = context.getMapperService().documentMapper().         Collection<String> typesForQuery.         if (types.length == 0) {             typesForQuery = context.queryTypes().         } else if (types.length == 1 && MetaData.ALL.equals(types[0])) {             typesForQuery = Collections.singleton(mapper.type()).         } else {             typesForQuery = new HashSet<>(Arrays.asList(types)).         }         if (typesForQuery.contains(mapper.type())) {             return idField.termsQuery(new ArrayList<>(ids), context).         } else {             return new MatchNoDocsQuery("Type mismatch").         }     } }
false;protected;0;4;;@Override protected int doHashCode() {     return Objects.hash(ids, Arrays.hashCode(types)). }
false;protected;1;5;;@Override protected boolean doEquals(IdsQueryBuilder other) {     return Objects.equals(ids, other.ids) && Arrays.equals(types, other.types). }
