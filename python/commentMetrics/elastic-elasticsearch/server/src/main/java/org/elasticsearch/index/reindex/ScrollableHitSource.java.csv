commented;modifiers;parameterAmount;loc;comment;code
false;public,final;1;7;;public final void start(Consumer<Response> onResponse) {     doStart(response -> {         setScroll(response.getScrollId()).         logger.debug("scroll returned [{}] documents with a scroll id of [{}]", response.getHits().size(), response.getScrollId()).         onResponse.accept(response).     }). }
false;protected,abstract;1;1;;protected abstract void doStart(Consumer<? super Response> onResponse).
false;public,final;2;6;;public final void startNextScroll(TimeValue extraKeepAlive, Consumer<Response> onResponse) {     doStartNextScroll(scrollId.get(), extraKeepAlive, response -> {         setScroll(response.getScrollId()).         onResponse.accept(response).     }). }
false;protected,abstract;3;1;;protected abstract void doStartNextScroll(String scrollId, TimeValue extraKeepAlive, Consumer<? super Response> onResponse).
false;public,final;1;8;;public final void close(Runnable onCompletion) {     String scrollId = this.scrollId.get().     if (Strings.hasLength(scrollId)) {         clearScroll(scrollId, () -> cleanup(onCompletion)).     } else {         cleanup(onCompletion).     } }
true;protected,abstract;2;1;/**  * Called to clear a scroll id.  *  * @param scrollId the id to clear  * @param onCompletion implementers must call this after completing the clear whether they are  *        successful or not  */ ;/**  * Called to clear a scroll id.  *  * @param scrollId the id to clear  * @param onCompletion implementers must call this after completing the clear whether they are  *        successful or not  */ protected abstract void clearScroll(String scrollId, Runnable onCompletion).
true;protected,abstract;1;1;/**  * Called after the process has been totally finished to clean up any resources the process  * needed like remote connections.  *  * @param onCompletion implementers must call this after completing the cleanup whether they are  *        successful or not  */ ;/**  * Called after the process has been totally finished to clean up any resources the process  * needed like remote connections.  *  * @param onCompletion implementers must call this after completing the cleanup whether they are  *        successful or not  */ protected abstract void cleanup(Runnable onCompletion).
true;public,final;1;3;/**  * Set the id of the last scroll. Used for debugging.  */ ;/**  * Set the id of the last scroll. Used for debugging.  */ public final void setScroll(String scrollId) {     this.scrollId.set(scrollId). }
true;public;0;3;/**  * Did this batch time out?  */ ;/**  * Did this batch time out?  */ public boolean isTimedOut() {     return timedOut. }
true;public,final;0;3;/**  * Where there any search failures?  */ ;/**  * Where there any search failures?  */ public final List<SearchFailure> getFailures() {     return failures. }
true;public;0;3;/**  * What were the total number of documents matching the search?  */ ;/**  * What were the total number of documents matching the search?  */ public long getTotalHits() {     return totalHits. }
true;public;0;3;/**  * The documents returned in this batch.  */ ;/**  * The documents returned in this batch.  */ public List<? extends Hit> getHits() {     return hits. }
true;public;0;3;/**  * The scroll id used to fetch the next set of documents.  */ ;/**  * The scroll id used to fetch the next set of documents.  */ public String getScrollId() {     return scrollId. }
true;;0;1;/**  * The index in which the hit is stored.  */ ;/**  * The index in which the hit is stored.  */ String getIndex().
true;;0;1;/**  * The type that the hit has.  */ ;/**  * The type that the hit has.  */ String getType().
true;;0;1;/**  * The document id of the hit.  */ ;/**  * The document id of the hit.  */ String getId().
true;;0;1;/**  * The version of the match or {@code -1} if the version wasn't requested. The {@code -1} keeps it inline with Elasticsearch's  * internal APIs.  */ ;/**  * The version of the match or {@code -1} if the version wasn't requested. The {@code -1} keeps it inline with Elasticsearch's  * internal APIs.  */ long getVersion().
true;;0;1;/**  * The sequence number of the match or {@link SequenceNumbers#UNASSIGNED_SEQ_NO} if sequence numbers weren't requested.  */ ;/**  * The sequence number of the match or {@link SequenceNumbers#UNASSIGNED_SEQ_NO} if sequence numbers weren't requested.  */ long getSeqNo().
true;;0;1;/**  * The primary term of the match or {@link SequenceNumbers#UNASSIGNED_PRIMARY_TERM} if sequence numbers weren't requested.  */ ;/**  * The primary term of the match or {@link SequenceNumbers#UNASSIGNED_PRIMARY_TERM} if sequence numbers weren't requested.  */ long getPrimaryTerm().
true;;0;1;/**  * The source of the hit. Returns null if the source didn't come back from the search, usually because it source wasn't stored at  * all.  */ ;/**  * The source of the hit. Returns null if the source didn't come back from the search, usually because it source wasn't stored at  * all.  */ @Nullable BytesReference getSource().
true;;0;1;/**  * The content type of the hit source. Returns null if the source didn't come back from the search.  */ ;/**  * The content type of the hit source. Returns null if the source didn't come back from the search.  */ @Nullable XContentType getXContentType().
true;;0;1;/**  * The routing on the hit if there is any or null if there isn't.  */ ;/**  * The routing on the hit if there is any or null if there isn't.  */ @Nullable String getRouting().
false;public;0;4;;@Override public String getIndex() {     return index. }
false;public;0;4;;@Override public String getType() {     return type. }
false;public;0;4;;@Override public String getId() {     return id. }
false;public;0;4;;@Override public long getVersion() {     return version. }
false;public;0;4;;@Override public long getSeqNo() {     return seqNo. }
false;public;0;4;;@Override public long getPrimaryTerm() {     return primaryTerm. }
false;public;0;4;;@Override public BytesReference getSource() {     return source. }
false;public;0;4;;@Override public XContentType getXContentType() {     return xContentType. }
false;public;2;5;;public BasicHit setSource(BytesReference source, XContentType xContentType) {     this.source = source.     this.xContentType = xContentType.     return this. }
false;public;0;4;;@Override public String getRouting() {     return routing. }
false;public;1;4;;public BasicHit setRouting(String routing) {     this.routing = routing.     return this. }
false;public;1;3;;public void setSeqNo(long seqNo) {     this.seqNo = seqNo. }
false;public;1;3;;public void setPrimaryTerm(long primaryTerm) {     this.primaryTerm = primaryTerm. }
false;public;1;7;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeException(reason).     out.writeOptionalString(index).     out.writeOptionalVInt(shardId).     out.writeOptionalString(nodeId). }
false;public;0;3;;public String getIndex() {     return index. }
false;public;0;3;;public Integer getShardId() {     return shardId. }
false;public;0;3;;public Throwable getReason() {     return reason. }
false;public;0;4;;@Nullable public String getNodeId() {     return nodeId. }
false;public;2;21;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     if (index != null) {         builder.field(INDEX_FIELD, index).     }     if (shardId != null) {         builder.field(SHARD_FIELD, shardId).     }     if (nodeId != null) {         builder.field(NODE_FIELD, nodeId).     }     builder.field(REASON_FIELD).     {         builder.startObject().         ElasticsearchException.generateThrowableXContent(builder, params, reason).         builder.endObject().     }     builder.endObject().     return builder. }
false;public;0;4;;@Override public String toString() {     return Strings.toString(this). }
