commented;modifiers;parameterAmount;loc;comment;code
true;;2;1;/**  * Callback before the bulk is executed.  */ ;/**  * Callback before the bulk is executed.  */ void beforeBulk(long executionId, BulkRequest request).
true;;3;1;/**  * Callback after a successful execution of bulk request.  */ ;/**  * Callback after a successful execution of bulk request.  */ void afterBulk(long executionId, BulkRequest request, BulkResponse response).
true;;3;1;/**  * Callback after a failed execution of bulk request.  * <p>  * Note that in case an instance of <code>InterruptedException</code> is passed, which means that request processing has been  * cancelled externally, the thread's interruption status has been restored prior to calling this method.  */ ;/**  * Callback after a failed execution of bulk request.  * <p>  * Note that in case an instance of <code>InterruptedException</code> is passed, which means that request processing has been  * cancelled externally, the thread's interruption status has been restored prior to calling this method.  */ void afterBulk(long executionId, BulkRequest request, Throwable failure).
true;public;1;4;/**  * Sets the number of concurrent requests allowed to be executed. A value of 0 means that only a single  * request will be allowed to be executed. A value of 1 means 1 concurrent request is allowed to be executed  * while accumulating new bulk requests. Defaults to {@code 1}.  */ ;/**  * Sets the number of concurrent requests allowed to be executed. A value of 0 means that only a single  * request will be allowed to be executed. A value of 1 means 1 concurrent request is allowed to be executed  * while accumulating new bulk requests. Defaults to {@code 1}.  */ public Builder setConcurrentRequests(int concurrentRequests) {     this.concurrentRequests = concurrentRequests.     return this. }
true;public;1;4;/**  * Sets when to flush a new bulk request based on the number of actions currently added. Defaults to  * {@code 1000}. Can be set to {@code -1} to disable it.  */ ;/**  * Sets when to flush a new bulk request based on the number of actions currently added. Defaults to  * {@code 1000}. Can be set to {@code -1} to disable it.  */ public Builder setBulkActions(int bulkActions) {     this.bulkActions = bulkActions.     return this. }
true;public;1;4;/**  * Sets when to flush a new bulk request based on the size of actions currently added. Defaults to  * {@code 5mb}. Can be set to {@code -1} to disable it.  */ ;/**  * Sets when to flush a new bulk request based on the size of actions currently added. Defaults to  * {@code 5mb}. Can be set to {@code -1} to disable it.  */ public Builder setBulkSize(ByteSizeValue bulkSize) {     this.bulkSize = bulkSize.     return this. }
true;public;1;4;/**  * Sets a flush interval flushing *any* bulk actions pending if the interval passes. Defaults to not set.  * <p>  * Note, both {@link #setBulkActions(int)} and {@link #setBulkSize(org.elasticsearch.common.unit.ByteSizeValue)}  * can be set to {@code -1} with the flush interval set allowing for complete async processing of bulk actions.  */ ;/**  * Sets a flush interval flushing *any* bulk actions pending if the interval passes. Defaults to not set.  * <p>  * Note, both {@link #setBulkActions(int)} and {@link #setBulkSize(org.elasticsearch.common.unit.ByteSizeValue)}  * can be set to {@code -1} with the flush interval set allowing for complete async processing of bulk actions.  */ public Builder setFlushInterval(TimeValue flushInterval) {     this.flushInterval = flushInterval.     return this. }
false;public;1;4;;public Builder setGlobalIndex(String globalIndex) {     this.globalIndex = globalIndex.     return this. }
false;public;1;4;;public Builder setGlobalType(String globalType) {     this.globalType = globalType.     return this. }
false;public;1;4;;public Builder setGlobalRouting(String globalRouting) {     this.globalRouting = globalRouting.     return this. }
false;public;1;4;;public Builder setGlobalPipeline(String globalPipeline) {     this.globalPipeline = globalPipeline.     return this. }
true;public;1;7;/**  * Sets a custom backoff policy. The backoff policy defines how the bulk processor should handle retries of bulk requests internally  * in case they have failed due to resource constraints (i.e. a thread pool was full).  *  * The default is to back off exponentially.  *  * @see org.elasticsearch.action.bulk.BackoffPolicy#exponentialBackoff()  */ ;/**  * Sets a custom backoff policy. The backoff policy defines how the bulk processor should handle retries of bulk requests internally  * in case they have failed due to resource constraints (i.e. a thread pool was full).  *  * The default is to back off exponentially.  *  * @see org.elasticsearch.action.bulk.BackoffPolicy#exponentialBackoff()  */ public Builder setBackoffPolicy(BackoffPolicy backoffPolicy) {     if (backoffPolicy == null) {         throw new NullPointerException("'backoffPolicy' must not be null. To disable backoff, pass BackoffPolicy.noBackoff()").     }     this.backoffPolicy = backoffPolicy.     return this. }
true;public;0;4;/**  * Builds a new bulk processor.  */ ;/**  * Builds a new bulk processor.  */ public BulkProcessor build() {     return new BulkProcessor(consumer, backoffPolicy, listener, concurrentRequests, bulkActions, bulkSize, flushInterval, scheduler, onClose, createBulkRequestWithGlobalDefaults()). }
false;private;0;5;;private Supplier<BulkRequest> createBulkRequestWithGlobalDefaults() {     return () -> new BulkRequest(globalIndex, globalType).pipeline(globalPipeline).routing(globalRouting). }
false;public,static;2;5;;public static Builder builder(Client client, Listener listener) {     Objects.requireNonNull(client, "client").     Objects.requireNonNull(listener, "listener").     return new Builder(client::bulk, listener, client.threadPool(), () -> {     }). }
false;public,static;2;8;;public static Builder builder(BiConsumer<BulkRequest, ActionListener<BulkResponse>> consumer, Listener listener) {     Objects.requireNonNull(consumer, "consumer").     Objects.requireNonNull(listener, "listener").     final ScheduledThreadPoolExecutor scheduledThreadPoolExecutor = Scheduler.initScheduler(Settings.EMPTY).     return new Builder(consumer, listener, buildScheduler(scheduledThreadPoolExecutor), () -> Scheduler.terminate(scheduledThreadPoolExecutor, 10, TimeUnit.SECONDS)). }
false;private,static;1;4;;private static Scheduler buildScheduler(ScheduledThreadPoolExecutor scheduledThreadPoolExecutor) {     return (command, delay, executor) -> Scheduler.wrapAsScheduledCancellable(scheduledThreadPoolExecutor.schedule(command, delay.millis(), TimeUnit.MILLISECONDS)). }
true;public;0;8;/**  * Closes the processor. If flushing by time is enabled, then it's shutdown. Any remaining bulk actions are flushed.  */ ;/**  * Closes the processor. If flushing by time is enabled, then it's shutdown. Any remaining bulk actions are flushed.  */ @Override public void close() {     try {         awaitClose(0, TimeUnit.NANOSECONDS).     } catch (InterruptedException exc) {         Thread.currentThread().interrupt().     } }
true;public,synchronized;2;17;/**  * Closes the processor. If flushing by time is enabled, then it's shutdown. Any remaining bulk actions are flushed.  * <p>  * If concurrent requests are not enabled, returns {@code true} immediately.  * If concurrent requests are enabled, waits for up to the specified timeout for all bulk requests to complete then returns {@code true}  * If the specified waiting time elapses before all bulk requests complete, {@code false} is returned.  *  * @param timeout The maximum time to wait for the bulk requests to complete  * @param unit    The time unit of the {@code timeout} argument  * @return {@code true} if all bulk requests completed and {@code false} if the waiting time elapsed before all the bulk requests  * completed  * @throws InterruptedException If the current thread is interrupted  */ ;/**  * Closes the processor. If flushing by time is enabled, then it's shutdown. Any remaining bulk actions are flushed.  * <p>  * If concurrent requests are not enabled, returns {@code true} immediately.  * If concurrent requests are enabled, waits for up to the specified timeout for all bulk requests to complete then returns {@code true}  * If the specified waiting time elapses before all bulk requests complete, {@code false} is returned.  *  * @param timeout The maximum time to wait for the bulk requests to complete  * @param unit    The time unit of the {@code timeout} argument  * @return {@code true} if all bulk requests completed and {@code false} if the waiting time elapsed before all the bulk requests  * completed  * @throws InterruptedException If the current thread is interrupted  */ public synchronized boolean awaitClose(long timeout, TimeUnit unit) throws InterruptedException {     if (closed) {         return true.     }     closed = true.     this.cancellableFlushTask.cancel().     if (bulkRequest.numberOfActions() > 0) {         execute().     }     try {         return this.bulkRequestHandler.awaitClose(timeout, unit).     } finally {         onClose.run().     } }
true;public;1;3;/**  * Adds an {@link IndexRequest} to the list of actions to execute. Follows the same behavior of {@link IndexRequest}  * (for example, if no id is provided, one will be generated, or usage of the create flag).  */ ;/**  * Adds an {@link IndexRequest} to the list of actions to execute. Follows the same behavior of {@link IndexRequest}  * (for example, if no id is provided, one will be generated, or usage of the create flag).  */ public BulkProcessor add(IndexRequest request) {     return add((DocWriteRequest<?>) request). }
true;public;1;3;/**  * Adds an {@link DeleteRequest} to the list of actions to execute.  */ ;/**  * Adds an {@link DeleteRequest} to the list of actions to execute.  */ public BulkProcessor add(DeleteRequest request) {     return add((DocWriteRequest<?>) request). }
true;public;1;3;/**  * Adds either a delete or an index request.  */ ;/**  * Adds either a delete or an index request.  */ public BulkProcessor add(DocWriteRequest<?> request) {     return add(request, null). }
false;public;2;4;;public BulkProcessor add(DocWriteRequest<?> request, @Nullable Object payload) {     internalAdd(request, payload).     return this. }
false;;0;3;;boolean isOpen() {     return closed == false. }
false;protected;0;5;;protected void ensureOpen() {     if (closed) {         throw new IllegalStateException("bulk process already closed").     } }
false;private,synchronized;2;5;;private synchronized void internalAdd(DocWriteRequest<?> request, @Nullable Object payload) {     ensureOpen().     bulkRequest.add(request, payload).     executeIfNeeded(). }
true;public;4;4;/**  * Adds the data from the bytes to be processed by the bulk processor  */ ;/**  * Adds the data from the bytes to be processed by the bulk processor  */ public BulkProcessor add(BytesReference data, @Nullable String defaultIndex, @Nullable String defaultType, XContentType xContentType) throws Exception {     return add(data, defaultIndex, defaultType, null, null, xContentType). }
true;public,synchronized;6;7;/**  * Adds the data from the bytes to be processed by the bulk processor  */ ;/**  * Adds the data from the bytes to be processed by the bulk processor  */ public synchronized BulkProcessor add(BytesReference data, @Nullable String defaultIndex, @Nullable String defaultType, @Nullable String defaultPipeline, @Nullable Object payload, XContentType xContentType) throws Exception {     bulkRequest.add(data, defaultIndex, defaultType, null, null, defaultPipeline, payload, true, xContentType).     executeIfNeeded().     return this. }
false;public;0;4;;@Override public boolean cancel() {     return false. }
false;public;0;4;;@Override public boolean isCancelled() {     return true. }
false;private;2;17;;private Scheduler.Cancellable startFlushTask(TimeValue flushInterval, Scheduler scheduler) {     if (flushInterval == null) {         return new Scheduler.Cancellable() {              @Override             public boolean cancel() {                 return false.             }              @Override             public boolean isCancelled() {                 return true.             }         }.     }     final Runnable flushRunnable = scheduler.preserveContext(new Flush()).     return scheduler.scheduleWithFixedDelay(flushRunnable, flushInterval, ThreadPool.Names.GENERIC). }
false;private;0;7;;private void executeIfNeeded() {     ensureOpen().     if (!isOverTheLimit()) {         return.     }     execute(). }
true;private;0;7;// (currently) needs to be executed under a lock ;// (currently) needs to be executed under a lock private void execute() {     final BulkRequest bulkRequest = this.bulkRequest.     final long executionId = executionIdGen.incrementAndGet().     this.bulkRequest = bulkRequestSupplier.get().     this.bulkRequestHandler.execute(bulkRequest, executionId). }
false;private;0;9;;private boolean isOverTheLimit() {     if (bulkActions != -1 && bulkRequest.numberOfActions() >= bulkActions) {         return true.     }     if (bulkSize != -1 && bulkRequest.estimatedSizeInBytes() >= bulkSize) {         return true.     }     return false. }
true;public,synchronized;0;6;/**  * Flush pending delete or index requests.  */ ;/**  * Flush pending delete or index requests.  */ public synchronized void flush() {     ensureOpen().     if (bulkRequest.numberOfActions() > 0) {         execute().     } }
false;public;0;12;;@Override public void run() {     synchronized (BulkProcessor.this) {         if (closed) {             return.         }         if (bulkRequest.numberOfActions() == 0) {             return.         }         execute().     } }
