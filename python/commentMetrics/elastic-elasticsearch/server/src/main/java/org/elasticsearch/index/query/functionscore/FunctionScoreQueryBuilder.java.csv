commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;9;;@Override protected void doWriteTo(StreamOutput out) throws IOException {     out.writeNamedWriteable(query).     out.writeList(Arrays.asList(filterFunctionBuilders)).     out.writeFloat(maxBoost).     out.writeOptionalFloat(minScore).     out.writeOptionalWriteable(boostMode).     scoreMode.writeTo(out). }
true;public;0;3;/**  * Returns the query that defines which documents the function_score query will be executed on.  */ ;/**  * Returns the query that defines which documents the function_score query will be executed on.  */ public QueryBuilder query() {     return this.query. }
true;public;0;3;/**  * Returns the filters and functions  */ ;/**  * Returns the filters and functions  */ public FilterFunctionBuilder[] filterFunctionBuilders() {     return this.filterFunctionBuilders. }
true;public;1;7;/**  * Score mode defines how results of individual score functions will be aggregated.  * @see FunctionScoreQuery.ScoreMode  */ ;/**  * Score mode defines how results of individual score functions will be aggregated.  * @see FunctionScoreQuery.ScoreMode  */ public FunctionScoreQueryBuilder scoreMode(FunctionScoreQuery.ScoreMode scoreMode) {     if (scoreMode == null) {         throw new IllegalArgumentException("[" + NAME + "]  requires 'score_mode' field").     }     this.scoreMode = scoreMode.     return this. }
true;public;0;3;/**  * Returns the score mode, meaning how results of individual score functions will be aggregated.  * @see FunctionScoreQuery.ScoreMode  */ ;/**  * Returns the score mode, meaning how results of individual score functions will be aggregated.  * @see FunctionScoreQuery.ScoreMode  */ public FunctionScoreQuery.ScoreMode scoreMode() {     return this.scoreMode. }
true;public;1;7;/**  * Boost mode defines how the combined result of score functions will influence the final score together with the sub query score.  * @see CombineFunction  */ ;/**  * Boost mode defines how the combined result of score functions will influence the final score together with the sub query score.  * @see CombineFunction  */ public FunctionScoreQueryBuilder boostMode(CombineFunction combineFunction) {     if (combineFunction == null) {         throw new IllegalArgumentException("[" + NAME + "]  requires 'boost_mode' field").     }     this.boostMode = combineFunction.     return this. }
true;public;0;3;/**  * Returns the boost mode, meaning how the combined result of score functions will influence the final score together with the sub query  * score.  *  * @see CombineFunction  */ ;/**  * Returns the boost mode, meaning how the combined result of score functions will influence the final score together with the sub query  * score.  *  * @see CombineFunction  */ public CombineFunction boostMode() {     return this.boostMode. }
true;public;1;4;/**  * Sets the maximum boost that will be applied by function score.  */ ;/**  * Sets the maximum boost that will be applied by function score.  */ public FunctionScoreQueryBuilder maxBoost(float maxBoost) {     this.maxBoost = maxBoost.     return this. }
true;public;0;3;/**  * Returns the maximum boost that will be applied by function score.  */ ;/**  * Returns the maximum boost that will be applied by function score.  */ public float maxBoost() {     return this.maxBoost. }
false;protected;2;24;;@Override protected void doXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject(NAME).     if (query != null) {         builder.field(QUERY_FIELD.getPreferredName()).         query.toXContent(builder, params).     }     builder.startArray(FUNCTIONS_FIELD.getPreferredName()).     for (FilterFunctionBuilder filterFunctionBuilder : filterFunctionBuilders) {         filterFunctionBuilder.toXContent(builder, params).     }     builder.endArray().     builder.field(SCORE_MODE_FIELD.getPreferredName(), scoreMode.name().toLowerCase(Locale.ROOT)).     if (boostMode != null) {         builder.field(BOOST_MODE_FIELD.getPreferredName(), boostMode.name().toLowerCase(Locale.ROOT)).     }     builder.field(MAX_BOOST_FIELD.getPreferredName(), maxBoost).     if (minScore != null) {         builder.field(MIN_SCORE_FIELD.getPreferredName(), minScore).     }     printBoostAndQueryName(builder).     builder.endObject(). }
false;public;1;4;;public FunctionScoreQueryBuilder setMinScore(float minScore) {     this.minScore = minScore.     return this. }
false;public;0;3;;public Float getMinScore() {     return this.minScore. }
false;public;0;4;;@Override public String getWriteableName() {     return NAME. }
false;protected;1;9;;@Override protected boolean doEquals(FunctionScoreQueryBuilder other) {     return Objects.equals(this.query, other.query) && Arrays.equals(this.filterFunctionBuilders, other.filterFunctionBuilders) && Objects.equals(this.boostMode, other.boostMode) && Objects.equals(this.scoreMode, other.scoreMode) && Objects.equals(this.minScore, other.minScore) && Objects.equals(this.maxBoost, other.maxBoost). }
false;protected;0;5;;@Override protected int doHashCode() {     return Objects.hash(this.query, Arrays.hashCode(this.filterFunctionBuilders), this.boostMode, this.scoreMode, this.minScore, this.maxBoost). }
false;protected;1;29;;@Override protected Query doToQuery(QueryShardContext context) throws IOException {     ScoreFunction[] filterFunctions = new ScoreFunction[filterFunctionBuilders.length].     int i = 0.     for (FilterFunctionBuilder filterFunctionBuilder : filterFunctionBuilders) {         ScoreFunction scoreFunction = filterFunctionBuilder.getScoreFunction().toFunction(context).         if (filterFunctionBuilder.getFilter().getName().equals(MatchAllQueryBuilder.NAME)) {             filterFunctions[i++] = scoreFunction.         } else {             Query filter = filterFunctionBuilder.getFilter().toQuery(context).             filterFunctions[i++] = new FunctionScoreQuery.FilterScoreFunction(filter, scoreFunction).         }     }     Query query = this.query.toQuery(context).     if (query == null) {         query = new MatchAllDocsQuery().     }     CombineFunction boostMode = this.boostMode == null ? DEFAULT_BOOST_MODE : this.boostMode.     // handle cases where only one score function and no filter was provided. In this case we create a FunctionScoreQuery.     if (filterFunctions.length == 0) {         return new FunctionScoreQuery(query, minScore, maxBoost).     } else if (filterFunctions.length == 1 && filterFunctions[0] instanceof FunctionScoreQuery.FilterScoreFunction == false) {         return new FunctionScoreQuery(query, filterFunctions[0], boostMode, minScore, maxBoost).     }     // in all other cases we create a FunctionScoreQuery with filters     return new FunctionScoreQuery(query, scoreMode, filterFunctions, boostMode, minScore, maxBoost). }
false;public;1;5;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeNamedWriteable(filter).     out.writeNamedWriteable(scoreFunction). }
false;public;0;3;;public QueryBuilder getFilter() {     return filter. }
false;public;0;3;;public ScoreFunctionBuilder<?> getScoreFunction() {     return scoreFunction. }
false;public;2;9;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     builder.field(FILTER_FIELD.getPreferredName()).     filter.toXContent(builder, params).     scoreFunction.toXContent(builder, params).     builder.endObject().     return builder. }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(filter, scoreFunction). }
false;public;1;12;;@Override public boolean equals(Object obj) {     if (this == obj) {         return true.     }     if (obj == null || getClass() != obj.getClass()) {         return false.     }     FilterFunctionBuilder that = (FilterFunctionBuilder) obj.     return Objects.equals(this.filter, that.filter) && Objects.equals(this.scoreFunction, that.scoreFunction). }
false;public;1;7;;public FilterFunctionBuilder rewrite(QueryRewriteContext context) throws IOException {     QueryBuilder rewrite = filter.rewrite(context).     if (rewrite != filter) {         return new FilterFunctionBuilder(rewrite, scoreFunction).     }     return this. }
false;protected;1;20;;@Override protected QueryBuilder doRewrite(QueryRewriteContext queryRewriteContext) throws IOException {     QueryBuilder queryBuilder = this.query.rewrite(queryRewriteContext).     FilterFunctionBuilder[] rewrittenBuilders = new FilterFunctionBuilder[this.filterFunctionBuilders.length].     boolean rewritten = false.     for (int i = 0. i < rewrittenBuilders.length. i++) {         FilterFunctionBuilder rewrite = filterFunctionBuilders[i].rewrite(queryRewriteContext).         rewritten |= rewrite != filterFunctionBuilders[i].         rewrittenBuilders[i] = rewrite.     }     if (queryBuilder != query || rewritten) {         FunctionScoreQueryBuilder newQueryBuilder = new FunctionScoreQueryBuilder(queryBuilder, rewrittenBuilders).         newQueryBuilder.scoreMode = scoreMode.         newQueryBuilder.minScore = minScore.         newQueryBuilder.maxBoost = maxBoost.         newQueryBuilder.boostMode = boostMode.         return newQueryBuilder.     }     return this. }
false;protected;1;4;;@Override protected void extractInnerHitBuilders(Map<String, InnerHitContextBuilder> innerHits) {     InnerHitContextBuilder.extractInnerHits(query(), innerHits). }
false;public,static;1;114;;public static FunctionScoreQueryBuilder fromXContent(XContentParser parser) throws IOException {     QueryBuilder query = null.     float boost = AbstractQueryBuilder.DEFAULT_BOOST.     String queryName = null.     FunctionScoreQuery.ScoreMode scoreMode = FunctionScoreQueryBuilder.DEFAULT_SCORE_MODE.     float maxBoost = FunctionScoreQuery.DEFAULT_MAX_BOOST.     Float minScore = null.     String currentFieldName = null.     XContentParser.Token token.     CombineFunction combineFunction = null.     // Either define array of functions and filters or only one function     boolean functionArrayFound = false.     boolean singleFunctionFound = false.     String singleFunctionName = null.     List<FunctionScoreQueryBuilder.FilterFunctionBuilder> filterFunctionBuilders = new ArrayList<>().     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (token == XContentParser.Token.START_OBJECT) {             if (QUERY_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 if (query != null) {                     throw new ParsingException(parser.getTokenLocation(), "failed to parse [{}] query. [query] is already defined.", NAME).                 }                 query = parseInnerQueryBuilder(parser).             } else {                 if (singleFunctionFound) {                     throw new ParsingException(parser.getTokenLocation(), "failed to parse [{}] query. already found function [{}], now encountering [{}]. use [functions] " + "array if you want to define several functions.", NAME, singleFunctionName, currentFieldName).                 }                 if (functionArrayFound) {                     String errorString = "already found [functions] array, now encountering [" + currentFieldName + "].".                     handleMisplacedFunctionsDeclaration(parser.getTokenLocation(), errorString).                 }                 singleFunctionFound = true.                 singleFunctionName = currentFieldName.                 ScoreFunctionBuilder<?> scoreFunction = parser.namedObject(ScoreFunctionBuilder.class, currentFieldName, null).                 filterFunctionBuilders.add(new FunctionScoreQueryBuilder.FilterFunctionBuilder(scoreFunction)).             }         } else if (token == XContentParser.Token.START_ARRAY) {             if (FUNCTIONS_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 if (singleFunctionFound) {                     String errorString = "already found [" + singleFunctionName + "], now encountering [functions].".                     handleMisplacedFunctionsDeclaration(parser.getTokenLocation(), errorString).                 }                 functionArrayFound = true.                 currentFieldName = parseFiltersAndFunctions(parser, filterFunctionBuilders).             } else {                 throw new ParsingException(parser.getTokenLocation(), "failed to parse [{}] query. array [{}] is not supported", NAME, currentFieldName).             }         } else if (token.isValue()) {             if (SCORE_MODE_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 scoreMode = FunctionScoreQuery.ScoreMode.fromString(parser.text()).             } else if (BOOST_MODE_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 combineFunction = CombineFunction.fromString(parser.text()).             } else if (MAX_BOOST_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 maxBoost = parser.floatValue().             } else if (AbstractQueryBuilder.BOOST_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 boost = parser.floatValue().             } else if (AbstractQueryBuilder.NAME_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 queryName = parser.text().             } else if (MIN_SCORE_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 minScore = parser.floatValue().             } else {                 if (singleFunctionFound) {                     throw new ParsingException(parser.getTokenLocation(), "failed to parse [{}] query. already found function [{}], now encountering [{}]. use [functions] array " + "if you want to define several functions.", NAME, singleFunctionName, currentFieldName).                 }                 if (functionArrayFound) {                     String errorString = "already found [functions] array, now encountering [" + currentFieldName + "].".                     handleMisplacedFunctionsDeclaration(parser.getTokenLocation(), errorString).                 }                 if (WEIGHT_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                     filterFunctionBuilders.add(new FunctionScoreQueryBuilder.FilterFunctionBuilder(new WeightBuilder().setWeight(parser.floatValue()))).                     singleFunctionFound = true.                     singleFunctionName = currentFieldName.                 } else {                     throw new ParsingException(parser.getTokenLocation(), "failed to parse [{}] query. field [{}] is not supported", NAME, currentFieldName).                 }             }         }     }     if (query == null) {         query = new MatchAllQueryBuilder().     }     FunctionScoreQueryBuilder functionScoreQueryBuilder = new FunctionScoreQueryBuilder(query, filterFunctionBuilders.toArray(new FunctionScoreQueryBuilder.FilterFunctionBuilder[filterFunctionBuilders.size()])).     if (combineFunction != null) {         functionScoreQueryBuilder.boostMode(combineFunction).     }     functionScoreQueryBuilder.scoreMode(scoreMode).     functionScoreQueryBuilder.maxBoost(maxBoost).     if (minScore != null) {         functionScoreQueryBuilder.setMinScore(minScore).     }     functionScoreQueryBuilder.boost(boost).     functionScoreQueryBuilder.queryName(queryName).     return functionScoreQueryBuilder. }
false;private,static;2;4;;private static void handleMisplacedFunctionsDeclaration(XContentLocation contentLocation, String errorString) {     throw new ParsingException(contentLocation, "failed to parse [{}] query. [{}]", NAME, MISPLACED_FUNCTION_MESSAGE_PREFIX + errorString). }
false;private,static;2;55;;private static String parseFiltersAndFunctions(XContentParser parser, List<FunctionScoreQueryBuilder.FilterFunctionBuilder> filterFunctionBuilders) throws IOException {     String currentFieldName = null.     XContentParser.Token token.     while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {         QueryBuilder filter = null.         ScoreFunctionBuilder<?> scoreFunction = null.         Float functionWeight = null.         if (token != XContentParser.Token.START_OBJECT) {             throw new ParsingException(parser.getTokenLocation(), "failed to parse [{}]. malformed query, expected a [{}] while parsing functions but got a [{}] instead", XContentParser.Token.START_OBJECT, token, NAME).         } else {             while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {                 if (token == XContentParser.Token.FIELD_NAME) {                     currentFieldName = parser.currentName().                 } else if (token == XContentParser.Token.START_OBJECT) {                     if (FILTER_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                         filter = parseInnerQueryBuilder(parser).                     } else {                         if (scoreFunction != null) {                             throw new ParsingException(parser.getTokenLocation(), "failed to parse function_score functions. already found [{}], now encountering [{}].", scoreFunction.getName(), currentFieldName).                         }                         scoreFunction = parser.namedObject(ScoreFunctionBuilder.class, currentFieldName, null).                     }                 } else if (token.isValue()) {                     if (WEIGHT_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                         functionWeight = parser.floatValue().                     } else {                         throw new ParsingException(parser.getTokenLocation(), "failed to parse [{}] query. field [{}] is not supported", NAME, currentFieldName).                     }                 }             }             if (functionWeight != null) {                 if (scoreFunction == null) {                     scoreFunction = new WeightBuilder().setWeight(functionWeight).                 } else {                     scoreFunction.setWeight(functionWeight).                 }             }         }         if (filter == null) {             filter = new MatchAllQueryBuilder().         }         if (scoreFunction == null) {             throw new ParsingException(parser.getTokenLocation(), "failed to parse [{}] query. an entry in functions list is missing a function.", NAME).         }         filterFunctionBuilders.add(new FunctionScoreQueryBuilder.FilterFunctionBuilder(filter, scoreFunction)).     }     return currentFieldName. }
