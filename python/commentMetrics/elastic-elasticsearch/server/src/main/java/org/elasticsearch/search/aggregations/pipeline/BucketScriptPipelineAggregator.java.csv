commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;7;;@Override protected void doWriteTo(StreamOutput out) throws IOException {     script.writeTo(out).     out.writeNamedWriteable(formatter).     gapPolicy.writeTo(out).     out.writeGenericValue(bucketsPathsMap). }
false;public;0;4;;@Override public String getWriteableName() {     return BucketScriptPipelineAggregationBuilder.NAME. }
false;public;2;46;;@Override public InternalAggregation reduce(InternalAggregation aggregation, ReduceContext reduceContext) {     InternalMultiBucketAggregation<InternalMultiBucketAggregation, InternalMultiBucketAggregation.InternalBucket> originalAgg = (InternalMultiBucketAggregation<InternalMultiBucketAggregation, InternalMultiBucketAggregation.InternalBucket>) aggregation.     List<? extends InternalMultiBucketAggregation.InternalBucket> buckets = originalAgg.getBuckets().     BucketAggregationScript.Factory factory = reduceContext.scriptService().compile(script, BucketAggregationScript.CONTEXT).     List<InternalMultiBucketAggregation.InternalBucket> newBuckets = new ArrayList<>().     for (InternalMultiBucketAggregation.InternalBucket bucket : buckets) {         Map<String, Object> vars = new HashMap<>().         if (script.getParams() != null) {             vars.putAll(script.getParams()).         }         boolean skipBucket = false.         for (Map.Entry<String, String> entry : bucketsPathsMap.entrySet()) {             String varName = entry.getKey().             String bucketsPath = entry.getValue().             Double value = resolveBucketValue(originalAgg, bucket, bucketsPath, gapPolicy).             if (GapPolicy.SKIP == gapPolicy && (value == null || Double.isNaN(value))) {                 skipBucket = true.                 break.             }             vars.put(varName, value).         }         if (skipBucket) {             newBuckets.add(bucket).         } else {             Number returned = factory.newInstance(vars).execute().             if (returned == null) {                 newBuckets.add(bucket).             } else {                 final List<InternalAggregation> aggs = StreamSupport.stream(bucket.getAggregations().spliterator(), false).map((p) -> (InternalAggregation) p).collect(Collectors.toList()).                 InternalSimpleValue simpleValue = new InternalSimpleValue(name(), returned.doubleValue(), formatter, new ArrayList<>(), metaData()).                 aggs.add(simpleValue).                 InternalMultiBucketAggregation.InternalBucket newBucket = originalAgg.createBucket(new InternalAggregations(aggs), bucket).                 newBuckets.add(newBucket).             }         }     }     return originalAgg.create(newBuckets). }
