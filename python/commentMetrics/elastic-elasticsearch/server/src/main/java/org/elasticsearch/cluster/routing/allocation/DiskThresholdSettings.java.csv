commented;modifiers;parameterAmount;loc;comment;code
false;public;1;3;;@Override public void validate(String value) { }
false;public;2;6;;@Override public void validate(String value, Map<Setting<String>, String> settings) {     final String highWatermarkRaw = settings.get(CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING).     final String floodStageRaw = settings.get(CLUSTER_ROUTING_ALLOCATION_DISK_FLOOD_STAGE_WATERMARK_SETTING).     doValidate(value, highWatermarkRaw, floodStageRaw). }
false;public;0;7;;@Override public Iterator<Setting<String>> settings() {     return Arrays.asList(CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING, CLUSTER_ROUTING_ALLOCATION_DISK_FLOOD_STAGE_WATERMARK_SETTING).iterator(). }
false;public;1;3;;@Override public void validate(String value) { }
false;public;2;6;;@Override public void validate(String value, Map<Setting<String>, String> settings) {     final String lowWatermarkRaw = settings.get(CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING).     final String floodStageRaw = settings.get(CLUSTER_ROUTING_ALLOCATION_DISK_FLOOD_STAGE_WATERMARK_SETTING).     doValidate(lowWatermarkRaw, value, floodStageRaw). }
false;public;0;7;;@Override public Iterator<Setting<String>> settings() {     return Arrays.asList(CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING, CLUSTER_ROUTING_ALLOCATION_DISK_FLOOD_STAGE_WATERMARK_SETTING).iterator(). }
false;public;1;3;;@Override public void validate(String value) { }
false;public;2;6;;@Override public void validate(String value, Map<Setting<String>, String> settings) {     final String lowWatermarkRaw = settings.get(CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING).     final String highWatermarkRaw = settings.get(CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING).     doValidate(lowWatermarkRaw, highWatermarkRaw, value). }
false;public;0;7;;@Override public Iterator<Setting<String>> settings() {     return Arrays.asList(CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING, CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING).iterator(). }
false;private,static;3;22;;private static void doValidate(String low, String high, String flood) {     try {         doValidateAsPercentage(low, high, flood).         // early return so that we do not try to parse as bytes         return.     } catch (final ElasticsearchParseException e) {     // swallow as we are now going to try to parse as bytes     }     try {         doValidateAsBytes(low, high, flood).     } catch (final ElasticsearchParseException e) {         final String message = String.format(Locale.ROOT, "unable to consistently parse [%s=%s], [%s=%s], and [%s=%s] as percentage or bytes", CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING.getKey(), low, CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(), high, CLUSTER_ROUTING_ALLOCATION_DISK_FLOOD_STAGE_WATERMARK_SETTING.getKey(), flood).         throw new IllegalArgumentException(message, e).     } }
false;private,static;3;13;;private static void doValidateAsPercentage(final String low, final String high, final String flood) {     final double lowWatermarkThreshold = thresholdPercentageFromWatermark(low, false).     final double highWatermarkThreshold = thresholdPercentageFromWatermark(high, false).     final double floodThreshold = thresholdPercentageFromWatermark(flood, false).     if (lowWatermarkThreshold > highWatermarkThreshold) {         throw new IllegalArgumentException("low disk watermark [" + low + "] more than high disk watermark [" + high + "]").     }     if (highWatermarkThreshold > floodThreshold) {         throw new IllegalArgumentException("high disk watermark [" + high + "] more than flood stage disk watermark [" + flood + "]").     } }
false;private,static;3;16;;private static void doValidateAsBytes(final String low, final String high, final String flood) {     final ByteSizeValue lowWatermarkBytes = thresholdBytesFromWatermark(low, CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING.getKey(), false).     final ByteSizeValue highWatermarkBytes = thresholdBytesFromWatermark(high, CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey(), false).     final ByteSizeValue floodStageBytes = thresholdBytesFromWatermark(flood, CLUSTER_ROUTING_ALLOCATION_DISK_FLOOD_STAGE_WATERMARK_SETTING.getKey(), false).     if (lowWatermarkBytes.getBytes() < highWatermarkBytes.getBytes()) {         throw new IllegalArgumentException("low disk watermark [" + low + "] less than high disk watermark [" + high + "]").     }     if (highWatermarkBytes.getBytes() < floodStageBytes.getBytes()) {         throw new IllegalArgumentException("high disk watermark [" + high + "] less than flood stage disk watermark [" + flood + "]").     } }
false;private;1;3;;private void setIncludeRelocations(boolean includeRelocations) {     this.includeRelocations = includeRelocations. }
false;private;1;3;;private void setRerouteInterval(TimeValue rerouteInterval) {     this.rerouteInterval = rerouteInterval. }
false;private;1;3;;private void setEnabled(boolean enabled) {     this.enabled = enabled. }
false;private;1;7;;private void setLowWatermark(String lowWatermark) {     // Watermark is expressed in terms of used data, but we need "free" data watermark     this.lowWatermarkRaw = lowWatermark.     this.freeDiskThresholdLow = 100.0 - thresholdPercentageFromWatermark(lowWatermark).     this.freeBytesThresholdLow = thresholdBytesFromWatermark(lowWatermark, CLUSTER_ROUTING_ALLOCATION_LOW_DISK_WATERMARK_SETTING.getKey()). }
false;private;1;7;;private void setHighWatermark(String highWatermark) {     // Watermark is expressed in terms of used data, but we need "free" data watermark     this.highWatermarkRaw = highWatermark.     this.freeDiskThresholdHigh = 100.0 - thresholdPercentageFromWatermark(highWatermark).     this.freeBytesThresholdHigh = thresholdBytesFromWatermark(highWatermark, CLUSTER_ROUTING_ALLOCATION_HIGH_DISK_WATERMARK_SETTING.getKey()). }
false;private;1;6;;private void setFloodStage(String floodStageRaw) {     // Watermark is expressed in terms of used data, but we need "free" data watermark     this.freeDiskThresholdFloodStage = 100.0 - thresholdPercentageFromWatermark(floodStageRaw).     this.freeBytesThresholdFloodStage = thresholdBytesFromWatermark(floodStageRaw, CLUSTER_ROUTING_ALLOCATION_DISK_FLOOD_STAGE_WATERMARK_SETTING.getKey()). }
true;public;0;3;/**  * Gets the raw (uninterpreted) low watermark value as found in the settings.  */ ;/**  * Gets the raw (uninterpreted) low watermark value as found in the settings.  */ public String getLowWatermarkRaw() {     return lowWatermarkRaw. }
true;public;0;3;/**  * Gets the raw (uninterpreted) high watermark value as found in the settings.  */ ;/**  * Gets the raw (uninterpreted) high watermark value as found in the settings.  */ public String getHighWatermarkRaw() {     return highWatermarkRaw. }
false;public;0;3;;public Double getFreeDiskThresholdLow() {     return freeDiskThresholdLow. }
false;public;0;3;;public Double getFreeDiskThresholdHigh() {     return freeDiskThresholdHigh. }
false;public;0;3;;public ByteSizeValue getFreeBytesThresholdLow() {     return freeBytesThresholdLow. }
false;public;0;3;;public ByteSizeValue getFreeBytesThresholdHigh() {     return freeBytesThresholdHigh. }
false;public;0;3;;public Double getFreeDiskThresholdFloodStage() {     return freeDiskThresholdFloodStage. }
false;public;0;3;;public ByteSizeValue getFreeBytesThresholdFloodStage() {     return freeBytesThresholdFloodStage. }
false;public;0;3;;public boolean includeRelocations() {     return includeRelocations. }
false;public;0;3;;public boolean isEnabled() {     return enabled. }
false;public;0;3;;public TimeValue getRerouteInterval() {     return rerouteInterval. }
true;private,static;1;3;/**  * Attempts to parse the watermark into a percentage, returning 100.0% if  * it cannot be parsed.  */ ;/**  * Attempts to parse the watermark into a percentage, returning 100.0% if  * it cannot be parsed.  */ private static double thresholdPercentageFromWatermark(String watermark) {     return thresholdPercentageFromWatermark(watermark, true). }
true;private,static;2;12;/**  * Attempts to parse the watermark into a percentage, returning 100.0% if it can not be parsed and the specified lenient parameter is  * true, otherwise throwing an {@link ElasticsearchParseException}.  *  * @param watermark the watermark to parse as a percentage  * @param lenient true if lenient parsing should be applied  * @return the parsed percentage  */ ;/**  * Attempts to parse the watermark into a percentage, returning 100.0% if it can not be parsed and the specified lenient parameter is  * true, otherwise throwing an {@link ElasticsearchParseException}.  *  * @param watermark the watermark to parse as a percentage  * @param lenient true if lenient parsing should be applied  * @return the parsed percentage  */ private static double thresholdPercentageFromWatermark(String watermark, boolean lenient) {     try {         return RatioValue.parseRatioValue(watermark).getAsPercent().     } catch (ElasticsearchParseException ex) {         // cases separately         if (lenient) {             return 100.0.         }         throw ex.     } }
true;private,static;2;3;/**  * Attempts to parse the watermark into a {@link ByteSizeValue}, returning  * a ByteSizeValue of 0 bytes if the value cannot be parsed.  */ ;/**  * Attempts to parse the watermark into a {@link ByteSizeValue}, returning  * a ByteSizeValue of 0 bytes if the value cannot be parsed.  */ private static ByteSizeValue thresholdBytesFromWatermark(String watermark, String settingName) {     return thresholdBytesFromWatermark(watermark, settingName, true). }
true;private,static;3;12;/**  * Attempts to parse the watermark into a {@link ByteSizeValue}, returning zero bytes if it can not be parsed and the specified lenient  * parameter is true, otherwise throwing an {@link ElasticsearchParseException}.  *  * @param watermark the watermark to parse as a byte size  * @param settingName the name of the setting  * @param lenient true if lenient parsing should be applied  * @return the parsed byte size value  */ ;/**  * Attempts to parse the watermark into a {@link ByteSizeValue}, returning zero bytes if it can not be parsed and the specified lenient  * parameter is true, otherwise throwing an {@link ElasticsearchParseException}.  *  * @param watermark the watermark to parse as a byte size  * @param settingName the name of the setting  * @param lenient true if lenient parsing should be applied  * @return the parsed byte size value  */ private static ByteSizeValue thresholdBytesFromWatermark(String watermark, String settingName, boolean lenient) {     try {         return ByteSizeValue.parseBytesSizeValue(watermark, settingName).     } catch (ElasticsearchParseException ex) {         // cases separately         if (lenient) {             return ByteSizeValue.parseBytesSizeValue("0b", settingName).         }         throw ex.     } }
true;private,static;2;13;/**  * Checks if a watermark string is a valid percentage or byte size value,  * @return the watermark value given  */ ;/**  * Checks if a watermark string is a valid percentage or byte size value,  * @return the watermark value given  */ private static String validWatermarkSetting(String watermark, String settingName) {     try {         RatioValue.parseRatioValue(watermark).     } catch (ElasticsearchParseException e) {         try {             ByteSizeValue.parseBytesSizeValue(watermark, settingName).         } catch (ElasticsearchParseException ex) {             ex.addSuppressed(e).             throw ex.         }     }     return watermark. }
