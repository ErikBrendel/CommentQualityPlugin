commented;modifiers;parameterAmount;loc;comment;code
false;public;2;5;;@Override public IndexSearcher newSearcher(IndexReader reader, IndexReader previousReader) throws IOException {     processReaders(reader, previousReader).     return super.newSearcher(reader, previousReader). }
false;public;2;33;;public void processReaders(IndexReader reader, IndexReader previousReader) {     final CircuitBreaker breaker = breakerService.getBreaker(CircuitBreaker.ACCOUNTING).     // Construct a list of the previous segment readers, we only want to track memory used     // by new readers, so these will be exempted from the circuit breaking accounting.     //      // The Core CacheKey is used as the key for the set so that deletions still keep the correct     // accounting, as using the Reader or Reader's CacheKey causes incorrect accounting.     final Set<IndexReader.CacheKey> prevReaders.     if (previousReader == null) {         prevReaders = Collections.emptySet().     } else {         final List<LeafReaderContext> previousReaderLeaves = previousReader.leaves().         prevReaders = new HashSet<>(previousReaderLeaves.size()).         for (LeafReaderContext lrc : previousReaderLeaves) {             prevReaders.add(Lucene.segmentReader(lrc.reader()).getCoreCacheHelper().getKey()).         }     }     for (LeafReaderContext lrc : reader.leaves()) {         final SegmentReader segmentReader = Lucene.segmentReader(lrc.reader()).         // (only new segments)         if (prevReaders.contains(segmentReader.getCoreCacheHelper().getKey()) == false) {             final long ramBytesUsed = segmentReader.ramBytesUsed().             // add the segment memory to the breaker (non-breaking)             breaker.addWithoutBreaking(ramBytesUsed).             // and register a listener for when the segment is closed to decrement the             // breaker accounting             segmentReader.getCoreCacheHelper().addClosedListener(k -> breaker.addWithoutBreaking(-ramBytesUsed)).         }     } }
