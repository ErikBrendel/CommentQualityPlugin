commented;modifiers;parameterAmount;loc;comment;code
true;public;0;32;/**  * Transform {@link FirstPassGroupingCollector#getTopGroups(int)} output in  * {@link CollapseTopFieldDocs}. The collapsing needs only one pass so we can get the final top docs at the end  * of the first pass.  */ ;/**  * Transform {@link FirstPassGroupingCollector#getTopGroups(int)} output in  * {@link CollapseTopFieldDocs}. The collapsing needs only one pass so we can get the final top docs at the end  * of the first pass.  */ public CollapseTopFieldDocs getTopDocs() throws IOException {     Collection<SearchGroup<T>> groups = super.getTopGroups(0).     if (groups == null) {         TotalHits totalHits = new TotalHits(0, TotalHits.Relation.EQUAL_TO).         return new CollapseTopFieldDocs(collapseField, totalHits, new ScoreDoc[0], sort.getSort(), new Object[0]).     }     FieldDoc[] docs = new FieldDoc[groups.size()].     Object[] collapseValues = new Object[groups.size()].     int scorePos = -1.     for (int index = 0. index < sort.getSort().length. index++) {         SortField sortField = sort.getSort()[index].         if (sortField.getType() == SCORE) {             scorePos = index.             break.         }     }     int pos = 0.     Iterator<CollectedSearchGroup<T>> it = orderedGroups.iterator().     for (SearchGroup<T> group : groups) {         assert it.hasNext().         CollectedSearchGroup<T> col = it.next().         float score = Float.NaN.         if (scorePos != -1) {             score = (float) group.sortValues[scorePos].         }         docs[pos] = new FieldDoc(col.topDoc, score, group.sortValues).         collapseValues[pos] = group.groupValue.         pos++.     }     TotalHits totalHits = new TotalHits(totalHitCount, TotalHits.Relation.EQUAL_TO).     return new CollapseTopFieldDocs(collapseField, totalHits, docs, sort.getSort(), collapseValues). }
false;public;0;8;;@Override public ScoreMode scoreMode() {     if (super.scoreMode().needsScores()) {         return ScoreMode.COMPLETE.     } else {         return ScoreMode.COMPLETE_NO_SCORES.     } }
false;public;1;5;;@Override public void setScorer(Scorable scorer) throws IOException {     super.setScorer(scorer).     this.scorer = scorer. }
false;public;1;5;;@Override public void collect(int doc) throws IOException {     super.collect(doc).     totalHitCount++. }
true;public,static;3;5;/**  * Create a collapsing top docs collector on a {@link org.apache.lucene.index.NumericDocValues} field.  * It accepts also {@link org.apache.lucene.index.SortedNumericDocValues} field but  * the collect will fail with an {@link IllegalStateException} if a document contains more than one value for the  * field.  *  * @param collapseField The sort field used to group  *                      documents.  * @param sort          The {@link Sort} used to sort the collapsed hits.  *                      The collapsing keeps only the top sorted document per collapsed key.  *                      This must be non-null, ie, if you want to groupSort by relevance  *                      use Sort.RELEVANCE.  * @param topN          How many top groups to keep.  */ ;/**  * Create a collapsing top docs collector on a {@link org.apache.lucene.index.NumericDocValues} field.  * It accepts also {@link org.apache.lucene.index.SortedNumericDocValues} field but  * the collect will fail with an {@link IllegalStateException} if a document contains more than one value for the  * field.  *  * @param collapseField The sort field used to group  *                      documents.  * @param sort          The {@link Sort} used to sort the collapsed hits.  *                      The collapsing keeps only the top sorted document per collapsed key.  *                      This must be non-null, ie, if you want to groupSort by relevance  *                      use Sort.RELEVANCE.  * @param topN          How many top groups to keep.  */ public static CollapsingTopDocsCollector<?> createNumeric(String collapseField, Sort sort, int topN) {     return new CollapsingTopDocsCollector<>(new CollapsingDocValuesSource.Numeric(collapseField), collapseField, sort, topN). }
true;public,static;3;5;/**  * Create a collapsing top docs collector on a {@link org.apache.lucene.index.SortedDocValues} field.  * It accepts also {@link org.apache.lucene.index.SortedSetDocValues} field but  * the collect will fail with an {@link IllegalStateException} if a document contains more than one value for the  * field.  *  * @param collapseField The sort field used to group  *                      documents.  * @param sort          The {@link Sort} used to sort the collapsed hits. The collapsing keeps only the top sorted  *                      document per collapsed key.  *                      This must be non-null, ie, if you want to groupSort by relevance use Sort.RELEVANCE.  * @param topN          How many top groups to keep.  */ ;/**  * Create a collapsing top docs collector on a {@link org.apache.lucene.index.SortedDocValues} field.  * It accepts also {@link org.apache.lucene.index.SortedSetDocValues} field but  * the collect will fail with an {@link IllegalStateException} if a document contains more than one value for the  * field.  *  * @param collapseField The sort field used to group  *                      documents.  * @param sort          The {@link Sort} used to sort the collapsed hits. The collapsing keeps only the top sorted  *                      document per collapsed key.  *                      This must be non-null, ie, if you want to groupSort by relevance use Sort.RELEVANCE.  * @param topN          How many top groups to keep.  */ public static CollapsingTopDocsCollector<?> createKeyword(String collapseField, Sort sort, int topN) {     return new CollapsingTopDocsCollector<>(new CollapsingDocValuesSource.Keyword(collapseField), collapseField, sort, topN). }
