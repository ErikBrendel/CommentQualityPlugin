# id;timestamp;commentText;codeText;commentWords;codeWords
CollapsingTopDocsCollector -> public static CollapsingTopDocsCollector<?> createNumeric(String collapseField, Sort sort,                                                               int topN);1536314350;Create a collapsing top docs collector on a {@link org.apache.lucene.index.NumericDocValues} field._It accepts also {@link org.apache.lucene.index.SortedNumericDocValues} field but_the collect will fail with an {@link IllegalStateException} if a document contains more than one value for the_field.__@param collapseField The sort field used to group_documents._@param sort          The {@link Sort} used to sort the collapsed hits._The collapsing keeps only the top sorted document per collapsed key._This must be non-null, ie, if you want to groupSort by relevance_use Sort.RELEVANCE._@param topN          How many top groups to keep.;public static CollapsingTopDocsCollector<?> createNumeric(String collapseField, Sort sort,_                                                              int topN)  {_        return new CollapsingTopDocsCollector<>(new CollapsingDocValuesSource.Numeric(collapseField),_                collapseField, sort, topN)__    };create,a,collapsing,top,docs,collector,on,a,link,org,apache,lucene,index,numeric,doc,values,field,it,accepts,also,link,org,apache,lucene,index,sorted,numeric,doc,values,field,but,the,collect,will,fail,with,an,link,illegal,state,exception,if,a,document,contains,more,than,one,value,for,the,field,param,collapse,field,the,sort,field,used,to,group,documents,param,sort,the,link,sort,used,to,sort,the,collapsed,hits,the,collapsing,keeps,only,the,top,sorted,document,per,collapsed,key,this,must,be,non,null,ie,if,you,want,to,group,sort,by,relevance,use,sort,relevance,param,top,n,how,many,top,groups,to,keep;public,static,collapsing,top,docs,collector,create,numeric,string,collapse,field,sort,sort,int,top,n,return,new,collapsing,top,docs,collector,new,collapsing,doc,values,source,numeric,collapse,field,collapse,field,sort,top,n
CollapsingTopDocsCollector -> public static CollapsingTopDocsCollector<?> createNumeric(String collapseField, Sort sort,                                                               int topN);1536611444;Create a collapsing top docs collector on a {@link org.apache.lucene.index.NumericDocValues} field._It accepts also {@link org.apache.lucene.index.SortedNumericDocValues} field but_the collect will fail with an {@link IllegalStateException} if a document contains more than one value for the_field.__@param collapseField The sort field used to group_documents._@param sort          The {@link Sort} used to sort the collapsed hits._The collapsing keeps only the top sorted document per collapsed key._This must be non-null, ie, if you want to groupSort by relevance_use Sort.RELEVANCE._@param topN          How many top groups to keep.;public static CollapsingTopDocsCollector<?> createNumeric(String collapseField, Sort sort,_                                                              int topN)  {_        return new CollapsingTopDocsCollector<>(new CollapsingDocValuesSource.Numeric(collapseField),_                collapseField, sort, topN)__    };create,a,collapsing,top,docs,collector,on,a,link,org,apache,lucene,index,numeric,doc,values,field,it,accepts,also,link,org,apache,lucene,index,sorted,numeric,doc,values,field,but,the,collect,will,fail,with,an,link,illegal,state,exception,if,a,document,contains,more,than,one,value,for,the,field,param,collapse,field,the,sort,field,used,to,group,documents,param,sort,the,link,sort,used,to,sort,the,collapsed,hits,the,collapsing,keeps,only,the,top,sorted,document,per,collapsed,key,this,must,be,non,null,ie,if,you,want,to,group,sort,by,relevance,use,sort,relevance,param,top,n,how,many,top,groups,to,keep;public,static,collapsing,top,docs,collector,create,numeric,string,collapse,field,sort,sort,int,top,n,return,new,collapsing,top,docs,collector,new,collapsing,doc,values,source,numeric,collapse,field,collapse,field,sort,top,n
CollapsingTopDocsCollector -> public CollapseTopFieldDocs getTopDocs() throws IOException;1524684173;Transform {@link FirstPassGroupingCollector#getTopGroups(int, boolean)} output in_{@link CollapseTopFieldDocs}. The collapsing needs only one pass so we can get the final top docs at the end_of the first pass.;public CollapseTopFieldDocs getTopDocs() throws IOException {_        Collection<SearchGroup<T>> groups = super.getTopGroups(0, true)__        if (groups == null) {_            return new CollapseTopFieldDocs(collapseField, totalHitCount, new ScoreDoc[0],_                sort.getSort(), new Object[0], Float.NaN)__        }_        FieldDoc[] docs = new FieldDoc[groups.size()]__        Object[] collapseValues = new Object[groups.size()]__        int scorePos = -1__        for (int index = 0_ index < sort.getSort().length_ index++) {_            SortField sortField = sort.getSort()[index]__            if (sortField.getType() == SCORE) {_                scorePos = index__                break__            }_        }_        int pos = 0__        Iterator<CollectedSearchGroup<T>> it = orderedGroups.iterator()__        for (SearchGroup<T> group : groups) {_            assert it.hasNext()__            CollectedSearchGroup<T> col = it.next()__            float score = Float.NaN__            if (scorePos != -1) {_                score = (float) group.sortValues[scorePos]__            }_            docs[pos] = new FieldDoc(col.topDoc, score, group.sortValues)__            collapseValues[pos] = group.groupValue__            pos++__        }_        return new CollapseTopFieldDocs(collapseField, totalHitCount, docs, sort.getSort(),_            collapseValues, maxScore)__    };transform,link,first,pass,grouping,collector,get,top,groups,int,boolean,output,in,link,collapse,top,field,docs,the,collapsing,needs,only,one,pass,so,we,can,get,the,final,top,docs,at,the,end,of,the,first,pass;public,collapse,top,field,docs,get,top,docs,throws,ioexception,collection,search,group,t,groups,super,get,top,groups,0,true,if,groups,null,return,new,collapse,top,field,docs,collapse,field,total,hit,count,new,score,doc,0,sort,get,sort,new,object,0,float,na,n,field,doc,docs,new,field,doc,groups,size,object,collapse,values,new,object,groups,size,int,score,pos,1,for,int,index,0,index,sort,get,sort,length,index,sort,field,sort,field,sort,get,sort,index,if,sort,field,get,type,score,score,pos,index,break,int,pos,0,iterator,collected,search,group,t,it,ordered,groups,iterator,for,search,group,t,group,groups,assert,it,has,next,collected,search,group,t,col,it,next,float,score,float,na,n,if,score,pos,1,score,float,group,sort,values,score,pos,docs,pos,new,field,doc,col,top,doc,score,group,sort,values,collapse,values,pos,group,group,value,pos,return,new,collapse,top,field,docs,collapse,field,total,hit,count,docs,sort,get,sort,collapse,values,max,score
CollapsingTopDocsCollector -> public CollapseTopFieldDocs getTopDocs() throws IOException;1536314350;Transform {@link FirstPassGroupingCollector#getTopGroups(int)} output in_{@link CollapseTopFieldDocs}. The collapsing needs only one pass so we can get the final top docs at the end_of the first pass.;public CollapseTopFieldDocs getTopDocs() throws IOException {_        Collection<SearchGroup<T>> groups = super.getTopGroups(0)__        if (groups == null) {_            TotalHits totalHits = new TotalHits(0, TotalHits.Relation.EQUAL_TO)__            return new CollapseTopFieldDocs(collapseField, totalHits, new ScoreDoc[0], sort.getSort(), new Object[0])__        }_        FieldDoc[] docs = new FieldDoc[groups.size()]__        Object[] collapseValues = new Object[groups.size()]__        int scorePos = -1__        for (int index = 0_ index < sort.getSort().length_ index++) {_            SortField sortField = sort.getSort()[index]__            if (sortField.getType() == SCORE) {_                scorePos = index__                break__            }_        }_        int pos = 0__        Iterator<CollectedSearchGroup<T>> it = orderedGroups.iterator()__        for (SearchGroup<T> group : groups) {_            assert it.hasNext()__            CollectedSearchGroup<T> col = it.next()__            float score = Float.NaN__            if (scorePos != -1) {_                score = (float) group.sortValues[scorePos]__            }_            docs[pos] = new FieldDoc(col.topDoc, score, group.sortValues)__            collapseValues[pos] = group.groupValue__            pos++__        }_        TotalHits totalHits = new TotalHits(totalHitCount, TotalHits.Relation.EQUAL_TO)__        return new CollapseTopFieldDocs(collapseField, totalHits, docs, sort.getSort(), collapseValues)__    };transform,link,first,pass,grouping,collector,get,top,groups,int,output,in,link,collapse,top,field,docs,the,collapsing,needs,only,one,pass,so,we,can,get,the,final,top,docs,at,the,end,of,the,first,pass;public,collapse,top,field,docs,get,top,docs,throws,ioexception,collection,search,group,t,groups,super,get,top,groups,0,if,groups,null,total,hits,total,hits,new,total,hits,0,total,hits,relation,return,new,collapse,top,field,docs,collapse,field,total,hits,new,score,doc,0,sort,get,sort,new,object,0,field,doc,docs,new,field,doc,groups,size,object,collapse,values,new,object,groups,size,int,score,pos,1,for,int,index,0,index,sort,get,sort,length,index,sort,field,sort,field,sort,get,sort,index,if,sort,field,get,type,score,score,pos,index,break,int,pos,0,iterator,collected,search,group,t,it,ordered,groups,iterator,for,search,group,t,group,groups,assert,it,has,next,collected,search,group,t,col,it,next,float,score,float,na,n,if,score,pos,1,score,float,group,sort,values,score,pos,docs,pos,new,field,doc,col,top,doc,score,group,sort,values,collapse,values,pos,group,group,value,pos,total,hits,total,hits,new,total,hits,total,hit,count,total,hits,relation,return,new,collapse,top,field,docs,collapse,field,total,hits,docs,sort,get,sort,collapse,values
CollapsingTopDocsCollector -> public CollapseTopFieldDocs getTopDocs() throws IOException;1536611444;Transform {@link FirstPassGroupingCollector#getTopGroups(int)} output in_{@link CollapseTopFieldDocs}. The collapsing needs only one pass so we can get the final top docs at the end_of the first pass.;public CollapseTopFieldDocs getTopDocs() throws IOException {_        Collection<SearchGroup<T>> groups = super.getTopGroups(0)__        if (groups == null) {_            TotalHits totalHits = new TotalHits(0, TotalHits.Relation.EQUAL_TO)__            return new CollapseTopFieldDocs(collapseField, totalHits, new ScoreDoc[0], sort.getSort(), new Object[0])__        }_        FieldDoc[] docs = new FieldDoc[groups.size()]__        Object[] collapseValues = new Object[groups.size()]__        int scorePos = -1__        for (int index = 0_ index < sort.getSort().length_ index++) {_            SortField sortField = sort.getSort()[index]__            if (sortField.getType() == SCORE) {_                scorePos = index__                break__            }_        }_        int pos = 0__        Iterator<CollectedSearchGroup<T>> it = orderedGroups.iterator()__        for (SearchGroup<T> group : groups) {_            assert it.hasNext()__            CollectedSearchGroup<T> col = it.next()__            float score = Float.NaN__            if (scorePos != -1) {_                score = (float) group.sortValues[scorePos]__            }_            docs[pos] = new FieldDoc(col.topDoc, score, group.sortValues)__            collapseValues[pos] = group.groupValue__            pos++__        }_        TotalHits totalHits = new TotalHits(totalHitCount, TotalHits.Relation.EQUAL_TO)__        return new CollapseTopFieldDocs(collapseField, totalHits, docs, sort.getSort(), collapseValues)__    };transform,link,first,pass,grouping,collector,get,top,groups,int,output,in,link,collapse,top,field,docs,the,collapsing,needs,only,one,pass,so,we,can,get,the,final,top,docs,at,the,end,of,the,first,pass;public,collapse,top,field,docs,get,top,docs,throws,ioexception,collection,search,group,t,groups,super,get,top,groups,0,if,groups,null,total,hits,total,hits,new,total,hits,0,total,hits,relation,return,new,collapse,top,field,docs,collapse,field,total,hits,new,score,doc,0,sort,get,sort,new,object,0,field,doc,docs,new,field,doc,groups,size,object,collapse,values,new,object,groups,size,int,score,pos,1,for,int,index,0,index,sort,get,sort,length,index,sort,field,sort,field,sort,get,sort,index,if,sort,field,get,type,score,score,pos,index,break,int,pos,0,iterator,collected,search,group,t,it,ordered,groups,iterator,for,search,group,t,group,groups,assert,it,has,next,collected,search,group,t,col,it,next,float,score,float,na,n,if,score,pos,1,score,float,group,sort,values,score,pos,docs,pos,new,field,doc,col,top,doc,score,group,sort,values,collapse,values,pos,group,group,value,pos,total,hits,total,hits,new,total,hits,total,hit,count,total,hits,relation,return,new,collapse,top,field,docs,collapse,field,total,hits,docs,sort,get,sort,collapse,values
CollapsingTopDocsCollector -> public static CollapsingTopDocsCollector<?> createKeyword(String collapseField, Sort sort,                                                               int topN);1536314350;Create a collapsing top docs collector on a {@link org.apache.lucene.index.SortedDocValues} field._It accepts also {@link org.apache.lucene.index.SortedSetDocValues} field but_the collect will fail with an {@link IllegalStateException} if a document contains more than one value for the_field.__@param collapseField The sort field used to group_documents._@param sort          The {@link Sort} used to sort the collapsed hits. The collapsing keeps only the top sorted_document per collapsed key._This must be non-null, ie, if you want to groupSort by relevance use Sort.RELEVANCE._@param topN          How many top groups to keep.;public static CollapsingTopDocsCollector<?> createKeyword(String collapseField, Sort sort,_                                                              int topN)  {_        return new CollapsingTopDocsCollector<>(new CollapsingDocValuesSource.Keyword(collapseField),_                collapseField, sort, topN)__    };create,a,collapsing,top,docs,collector,on,a,link,org,apache,lucene,index,sorted,doc,values,field,it,accepts,also,link,org,apache,lucene,index,sorted,set,doc,values,field,but,the,collect,will,fail,with,an,link,illegal,state,exception,if,a,document,contains,more,than,one,value,for,the,field,param,collapse,field,the,sort,field,used,to,group,documents,param,sort,the,link,sort,used,to,sort,the,collapsed,hits,the,collapsing,keeps,only,the,top,sorted,document,per,collapsed,key,this,must,be,non,null,ie,if,you,want,to,group,sort,by,relevance,use,sort,relevance,param,top,n,how,many,top,groups,to,keep;public,static,collapsing,top,docs,collector,create,keyword,string,collapse,field,sort,sort,int,top,n,return,new,collapsing,top,docs,collector,new,collapsing,doc,values,source,keyword,collapse,field,collapse,field,sort,top,n
CollapsingTopDocsCollector -> public static CollapsingTopDocsCollector<?> createKeyword(String collapseField, Sort sort,                                                               int topN);1536611444;Create a collapsing top docs collector on a {@link org.apache.lucene.index.SortedDocValues} field._It accepts also {@link org.apache.lucene.index.SortedSetDocValues} field but_the collect will fail with an {@link IllegalStateException} if a document contains more than one value for the_field.__@param collapseField The sort field used to group_documents._@param sort          The {@link Sort} used to sort the collapsed hits. The collapsing keeps only the top sorted_document per collapsed key._This must be non-null, ie, if you want to groupSort by relevance use Sort.RELEVANCE._@param topN          How many top groups to keep.;public static CollapsingTopDocsCollector<?> createKeyword(String collapseField, Sort sort,_                                                              int topN)  {_        return new CollapsingTopDocsCollector<>(new CollapsingDocValuesSource.Keyword(collapseField),_                collapseField, sort, topN)__    };create,a,collapsing,top,docs,collector,on,a,link,org,apache,lucene,index,sorted,doc,values,field,it,accepts,also,link,org,apache,lucene,index,sorted,set,doc,values,field,but,the,collect,will,fail,with,an,link,illegal,state,exception,if,a,document,contains,more,than,one,value,for,the,field,param,collapse,field,the,sort,field,used,to,group,documents,param,sort,the,link,sort,used,to,sort,the,collapsed,hits,the,collapsing,keeps,only,the,top,sorted,document,per,collapsed,key,this,must,be,non,null,ie,if,you,want,to,group,sort,by,relevance,use,sort,relevance,param,top,n,how,many,top,groups,to,keep;public,static,collapsing,top,docs,collector,create,keyword,string,collapse,field,sort,sort,int,top,n,return,new,collapsing,top,docs,collector,new,collapsing,doc,values,source,keyword,collapse,field,collapse,field,sort,top,n
