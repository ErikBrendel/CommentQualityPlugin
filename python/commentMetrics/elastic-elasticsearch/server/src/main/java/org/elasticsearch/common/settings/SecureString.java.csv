commented;modifiers;parameterAmount;loc;comment;code
true;public,synchronized;1;17;/**  * Constant time equality to avoid potential timing attacks.  */ ;/**  * Constant time equality to avoid potential timing attacks.  */ @Override public synchronized boolean equals(Object o) {     ensureNotClosed().     if (this == o)         return true.     if (o == null || o instanceof CharSequence == false)         return false.     CharSequence that = (CharSequence) o.     if (chars.length != that.length()) {         return false.     }     int equals = 0.     for (int i = 0. i < chars.length. i++) {         equals |= chars[i] ^ that.charAt(i).     }     return equals == 0. }
false;public,synchronized;0;4;;@Override public synchronized int hashCode() {     return Arrays.hashCode(chars). }
false;public,synchronized;0;5;;@Override public synchronized int length() {     ensureNotClosed().     return chars.length. }
false;public,synchronized;1;5;;@Override public synchronized char charAt(int index) {     ensureNotClosed().     return chars[index]. }
false;public;2;4;;@Override public SecureString subSequence(int start, int end) {     throw new UnsupportedOperationException("Cannot get subsequence of SecureString"). }
true;public,synchronized;0;4;/**  * Convert to a {@link String}. This should only be used with APIs that do not take {@link CharSequence}.  */ ;/**  * Convert to a {@link String}. This should only be used with APIs that do not take {@link CharSequence}.  */ @Override public synchronized String toString() {     return new String(chars). }
true;public,synchronized;0;7;/**  * Closes the string by clearing the underlying char array.  */ ;/**  * Closes the string by clearing the underlying char array.  */ @Override public synchronized void close() {     if (chars != null) {         Arrays.fill(chars, '\0').         chars = null.     } }
true;public,synchronized;0;5;/**  * Returns a new copy of this object that is backed by its own char array. Closing the new instance has no effect on the instance it  * was created from. This is useful for APIs which accept a char array and you want to be safe about the API potentially modifying the  * char array. For example:  *  * <pre>  *     try (SecureString copy = secureString.clone()) {  *         // pass thee char[] to a external API  *         PasswordAuthentication auth = new PasswordAuthentication(username, copy.getChars()).  *         ...  *     }  * </pre>  */ ;/**  * Returns a new copy of this object that is backed by its own char array. Closing the new instance has no effect on the instance it  * was created from. This is useful for APIs which accept a char array and you want to be safe about the API potentially modifying the  * char array. For example:  *  * <pre>  *     try (SecureString copy = secureString.clone()) {  *         // pass thee char[] to a external API  *         PasswordAuthentication auth = new PasswordAuthentication(username, copy.getChars()).  *         ...  *     }  * </pre>  */ @Override public synchronized SecureString clone() {     ensureNotClosed().     return new SecureString(Arrays.copyOf(chars, chars.length)). }
true;public,synchronized;0;4;/**  * Returns the underlying char[]. This is a dangerous operation as the array may be modified while it is being used by other threads  * or a consumer may modify the values in the array. For safety, it is preferable to use {@link #clone()} and pass its chars to the  * consumer when the chars are needed multiple times.  */ ;/**  * Returns the underlying char[]. This is a dangerous operation as the array may be modified while it is being used by other threads  * or a consumer may modify the values in the array. For safety, it is preferable to use {@link #clone()} and pass its chars to the  * consumer when the chars are needed multiple times.  */ public synchronized char[] getChars() {     ensureNotClosed().     return chars. }
true;private;0;5;/**  * Throw an exception if this string has been closed, indicating something is trying to access the data after being closed.  */ ;/**  * Throw an exception if this string has been closed, indicating something is trying to access the data after being closed.  */ private void ensureNotClosed() {     if (chars == null) {         throw new IllegalStateException("SecureString has already been closed").     } }
