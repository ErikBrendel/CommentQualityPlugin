commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;5;;@Override protected void doWriteTo(StreamOutput out) throws IOException {     out.writeNamedWriteable(queryBuilder).     out.writeString(fieldName). }
true;public;0;3;/**  * @return the field name for this query  */ ;/**  * @return the field name for this query  */ public String fieldName() {     return this.fieldName. }
true;public;0;3;/**  * @return the inner {@link QueryBuilder}  */ ;/**  * @return the inner {@link QueryBuilder}  */ public SpanQueryBuilder innerQuery() {     return this.queryBuilder. }
false;protected;2;9;;@Override protected void doXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject(NAME).     builder.field(QUERY_FIELD.getPreferredName()).     queryBuilder.toXContent(builder, params).     builder.field(FIELD_FIELD.getPreferredName(), fieldName).     printBoostAndQueryName(builder).     builder.endObject(). }
false;public,static;1;48;;public static FieldMaskingSpanQueryBuilder fromXContent(XContentParser parser) throws IOException {     float boost = AbstractQueryBuilder.DEFAULT_BOOST.     SpanQueryBuilder inner = null.     String field = null.     String queryName = null.     String currentFieldName = null.     XContentParser.Token token.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (token == XContentParser.Token.START_OBJECT) {             if (QUERY_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 QueryBuilder query = parseInnerQueryBuilder(parser).                 if (query instanceof SpanQueryBuilder == false) {                     throw new ParsingException(parser.getTokenLocation(), "[field_masking_span] query must be of type span query").                 }                 inner = (SpanQueryBuilder) query.             } else {                 throw new ParsingException(parser.getTokenLocation(), "[field_masking_span] query does not support [" + currentFieldName + "]").             }         } else {             if (AbstractQueryBuilder.BOOST_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 boost = parser.floatValue().             } else if (FIELD_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 field = parser.text().             } else if (AbstractQueryBuilder.NAME_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 queryName = parser.text().             } else {                 throw new ParsingException(parser.getTokenLocation(), "[field_masking_span] query does not support [" + currentFieldName + "]").             }         }     }     if (inner == null) {         throw new ParsingException(parser.getTokenLocation(), "field_masking_span must have [query] span query clause").     }     if (field == null) {         throw new ParsingException(parser.getTokenLocation(), "field_masking_span must have [field] set for it").     }     FieldMaskingSpanQueryBuilder queryBuilder = new FieldMaskingSpanQueryBuilder(inner, field).     queryBuilder.boost(boost).     queryBuilder.queryName(queryName).     return queryBuilder. }
false;protected;1;11;;@Override protected SpanQuery doToQuery(QueryShardContext context) throws IOException {     String fieldInQuery = fieldName.     MappedFieldType fieldType = context.fieldMapper(fieldName).     if (fieldType != null) {         fieldInQuery = fieldType.name().     }     Query innerQuery = queryBuilder.toQuery(context).     assert innerQuery instanceof SpanQuery.     return new FieldMaskingSpanQuery((SpanQuery) innerQuery, fieldInQuery). }
false;protected;0;4;;@Override protected int doHashCode() {     return Objects.hash(queryBuilder, fieldName). }
false;protected;1;5;;@Override protected boolean doEquals(FieldMaskingSpanQueryBuilder other) {     return Objects.equals(queryBuilder, other.queryBuilder) && Objects.equals(fieldName, other.fieldName). }
false;public;0;4;;@Override public String getWriteableName() {     return NAME. }
