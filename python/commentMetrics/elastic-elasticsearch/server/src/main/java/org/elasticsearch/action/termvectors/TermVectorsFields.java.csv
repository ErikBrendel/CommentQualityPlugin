commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public boolean hasNext() {     return iterator.hasNext(). }
false;public;0;4;;@Override public String next() {     return iterator.next().key. }
false;public;0;4;;@Override public void remove() {     throw new UnsupportedOperationException(). }
false;public;0;20;;@Override public Iterator<String> iterator() {     final Iterator<ObjectLongCursor<String>> iterator = fieldMap.iterator().     return new Iterator<String>() {          @Override         public boolean hasNext() {             return iterator.hasNext().         }          @Override         public String next() {             return iterator.next().key.         }          @Override         public void remove() {             throw new UnsupportedOperationException().         }     }. }
false;public;1;11;;@Override public Terms terms(String field) throws IOException {     // first, find where in the termVectors bytes the actual term vector for     // this field is stored     final int keySlot = fieldMap.indexOf(field).     if (keySlot < 0) {         // we don't have it.         return null.     }     long readOffset = fieldMap.indexGet(keySlot).     return new TermVector(termVectors, readOffset). }
false;public;0;4;;@Override public int size() {     return fieldMap.size(). }
false;private;0;15;;private void reset() throws IOException {     this.perFieldTermVectorInput.reset().     this.perFieldTermVectorInput.skip(readOffset).     // read how many terms....     this.numTerms = perFieldTermVectorInput.readVLong().     // ...if positions etc. were stored....     this.hasPositions = perFieldTermVectorInput.readBoolean().     this.hasOffsets = perFieldTermVectorInput.readBoolean().     this.hasPayloads = perFieldTermVectorInput.readBoolean().     // read the field statistics     this.sumTotalTermFreq = hasFieldStatistic ? readPotentiallyNegativeVLong(perFieldTermVectorInput) : -1.     this.sumDocFreq = hasFieldStatistic ? readPotentiallyNegativeVLong(perFieldTermVectorInput) : -1.     this.docCount = hasFieldStatistic ? readPotentiallyNegativeVInt(perFieldTermVectorInput) : -1. }
false;public;0;34;;@Override public BytesRef next() throws IOException {     if (currentTerm++ < numTerms) {         // term string. first the size...         int termVectorSize = perFieldTermVectorInput.readVInt().         spare.grow(termVectorSize).         // ...then the value.         perFieldTermVectorInput.readBytes(spare.bytes(), 0, termVectorSize).         spare.setLength(termVectorSize).         if (hasTermStatistic) {             docFreq = readPotentiallyNegativeVInt(perFieldTermVectorInput).             totalTermFrequency = readPotentiallyNegativeVLong(perFieldTermVectorInput).         }         freq = readPotentiallyNegativeVInt(perFieldTermVectorInput).         // grow the arrays to read the values. this is just         // for performance reasons. Re-use memory instead of         // realloc.         growBuffers().         // finally, read the values into the arrays         // currentPosition etc. so that we can just iterate         // later         writeInfos(perFieldTermVectorInput).         // read the score if available         if (hasScores) {             boostAtt.setBoost(perFieldTermVectorInput.readFloat()).         }         return spare.get().     } else {         return null.     } }
false;private;1;20;;private void writeInfos(final StreamInput input) throws IOException {     for (int i = 0. i < freq. i++) {         if (hasPositions) {             positions[i] = input.readVInt().         }         if (hasOffsets) {             startOffsets[i] = input.readVInt().             endOffsets[i] = input.readVInt().         }         if (hasPayloads) {             int payloadLength = input.readVInt().             if (payloads[i] == null) {                 payloads[i] = new BytesRefBuilder().             }             payloads[i].grow(payloadLength).             input.readBytes(payloads[i].bytes(), 0, payloadLength).             payloads[i].setLength(payloadLength).         }     } }
false;private;0;14;;private void growBuffers() {     if (hasPositions) {         positions = grow(positions, freq).     }     if (hasOffsets) {         startOffsets = grow(startOffsets, freq).         endOffsets = grow(endOffsets, freq).     }     if (hasPayloads) {         if (payloads.length < freq) {             payloads = Arrays.copyOf(payloads, ArrayUtil.oversize(freq, RamUsageEstimator.NUM_BYTES_OBJECT_REF)).         }     } }
false;public;1;4;;@Override public SeekStatus seekCeil(BytesRef text) throws IOException {     throw new UnsupportedOperationException(). }
false;public;1;4;;@Override public void seekExact(long ord) throws IOException {     throw new UnsupportedOperationException("Seek is not supported"). }
false;public;0;4;;@Override public BytesRef term() throws IOException {     return spare.get(). }
false;public;0;4;;@Override public long ord() throws IOException {     throw new UnsupportedOperationException("ordinals are not supported"). }
false;public;0;4;;@Override public int docFreq() throws IOException {     return docFreq. }
false;public;0;4;;@Override public long totalTermFreq() throws IOException {     return totalTermFrequency. }
false;public;2;7;;@Override public PostingsEnum postings(PostingsEnum reuse, int flags) throws IOException {     final TermVectorPostingsEnum retVal = (reuse instanceof TermVectorPostingsEnum ? (TermVectorPostingsEnum) reuse : new TermVectorPostingsEnum()).     return retVal.reset(hasPositions ? positions : null, hasOffsets ? startOffsets : null, hasOffsets ? endOffsets : null, hasPayloads ? payloads : null, freq). }
false;public;1;4;;@Override public ImpactsEnum impacts(int flags) throws IOException {     return new SlowImpactsEnum(postings(null, flags)). }
false;public;0;133;;@Override public TermsEnum iterator() throws IOException {     // reset before asking for an iterator     reset().     // convert bytes ref for the terms to actual data     return new BaseTermsEnum() {          int currentTerm = 0.          int freq = 0.          int docFreq = -1.          long totalTermFrequency = -1.          int[] positions = new int[1].          int[] startOffsets = new int[1].          int[] endOffsets = new int[1].          BytesRefBuilder[] payloads = new BytesRefBuilder[1].          final BytesRefBuilder spare = new BytesRefBuilder().          BoostAttribute boostAtt = this.attributes().addAttribute(BoostAttribute.class).          @Override         public BytesRef next() throws IOException {             if (currentTerm++ < numTerms) {                 // term string. first the size...                 int termVectorSize = perFieldTermVectorInput.readVInt().                 spare.grow(termVectorSize).                 // ...then the value.                 perFieldTermVectorInput.readBytes(spare.bytes(), 0, termVectorSize).                 spare.setLength(termVectorSize).                 if (hasTermStatistic) {                     docFreq = readPotentiallyNegativeVInt(perFieldTermVectorInput).                     totalTermFrequency = readPotentiallyNegativeVLong(perFieldTermVectorInput).                 }                 freq = readPotentiallyNegativeVInt(perFieldTermVectorInput).                 // grow the arrays to read the values. this is just                 // for performance reasons. Re-use memory instead of                 // realloc.                 growBuffers().                 // finally, read the values into the arrays                 // currentPosition etc. so that we can just iterate                 // later                 writeInfos(perFieldTermVectorInput).                 // read the score if available                 if (hasScores) {                     boostAtt.setBoost(perFieldTermVectorInput.readFloat()).                 }                 return spare.get().             } else {                 return null.             }         }          private void writeInfos(final StreamInput input) throws IOException {             for (int i = 0. i < freq. i++) {                 if (hasPositions) {                     positions[i] = input.readVInt().                 }                 if (hasOffsets) {                     startOffsets[i] = input.readVInt().                     endOffsets[i] = input.readVInt().                 }                 if (hasPayloads) {                     int payloadLength = input.readVInt().                     if (payloads[i] == null) {                         payloads[i] = new BytesRefBuilder().                     }                     payloads[i].grow(payloadLength).                     input.readBytes(payloads[i].bytes(), 0, payloadLength).                     payloads[i].setLength(payloadLength).                 }             }         }          private void growBuffers() {             if (hasPositions) {                 positions = grow(positions, freq).             }             if (hasOffsets) {                 startOffsets = grow(startOffsets, freq).                 endOffsets = grow(endOffsets, freq).             }             if (hasPayloads) {                 if (payloads.length < freq) {                     payloads = Arrays.copyOf(payloads, ArrayUtil.oversize(freq, RamUsageEstimator.NUM_BYTES_OBJECT_REF)).                 }             }         }          @Override         public SeekStatus seekCeil(BytesRef text) throws IOException {             throw new UnsupportedOperationException().         }          @Override         public void seekExact(long ord) throws IOException {             throw new UnsupportedOperationException("Seek is not supported").         }          @Override         public BytesRef term() throws IOException {             return spare.get().         }          @Override         public long ord() throws IOException {             throw new UnsupportedOperationException("ordinals are not supported").         }          @Override         public int docFreq() throws IOException {             return docFreq.         }          @Override         public long totalTermFreq() throws IOException {             return totalTermFrequency.         }          @Override         public PostingsEnum postings(PostingsEnum reuse, int flags) throws IOException {             final TermVectorPostingsEnum retVal = (reuse instanceof TermVectorPostingsEnum ? (TermVectorPostingsEnum) reuse : new TermVectorPostingsEnum()).             return retVal.reset(hasPositions ? positions : null, hasOffsets ? startOffsets : null, hasOffsets ? endOffsets : null, hasPayloads ? payloads : null, freq).         }          @Override         public ImpactsEnum impacts(int flags) throws IOException {             return new SlowImpactsEnum(postings(null, flags)).         }     }. }
false;public;0;4;;@Override public long size() throws IOException {     return numTerms. }
false;public;0;4;;@Override public long getSumTotalTermFreq() throws IOException {     return sumTotalTermFreq. }
false;public;0;4;;@Override public long getSumDocFreq() throws IOException {     return sumDocFreq. }
false;public;0;4;;@Override public int getDocCount() throws IOException {     return docCount. }
false;public;0;4;;@Override public boolean hasFreqs() {     return true. }
false;public;0;4;;@Override public boolean hasOffsets() {     return hasOffsets. }
false;public;0;4;;@Override public boolean hasPositions() {     return hasPositions. }
false;public;0;4;;@Override public boolean hasPayloads() {     return hasPayloads. }
false;private;5;13;;private PostingsEnum reset(int[] positions, int[] startOffsets, int[] endOffsets, BytesRefBuilder[] payloads, int freq) {     curPos = -1.     doc = -1.     this.hasPositions = positions != null.     this.hasOffsets = startOffsets != null.     this.hasPayloads = payloads != null.     this.freq = freq.     this.startOffsets = startOffsets.     this.endOffsets = endOffsets.     this.payloads = payloads.     this.positions = positions.     return this. }
false;public;0;4;;@Override public int nextDoc() throws IOException {     return doc = (doc == -1 ? 0 : NO_MORE_DOCS). }
false;public;0;4;;@Override public int docID() {     return doc. }
false;public;1;6;;@Override public int advance(int target) throws IOException {     while (nextDoc() < target && doc != NO_MORE_DOCS) {     }     return doc. }
false;public;0;4;;@Override public int freq() throws IOException {     return freq. }
true;public;0;6;// because else counter is not advanced ;// call nextPosition once before calling this one // because else counter is not advanced @Override public int startOffset() throws IOException {     assert curPos < freq && curPos >= 0.     return hasOffsets ? startOffsets[curPos] : -1. }
false;public;0;10;;@Override public // stored but offsets were stored and requested int nextPosition() throws IOException {     assert curPos + 1 < freq.     ++curPos.     // we safe lots fo space on the wire     return hasPositions ? positions[curPos] : -1. }
false;public;0;11;;@Override public BytesRef getPayload() throws IOException {     assert curPos < freq && curPos >= 0.     if (hasPayloads) {         final BytesRefBuilder payload = payloads[curPos].         if (payload != null) {             return payload.get().         }     }     return null. }
false;public;0;5;;@Override public int endOffset() throws IOException {     assert curPos < freq && curPos >= 0.     return hasOffsets ? endOffsets[curPos] : -1. }
false;public;0;4;;@Override public long cost() {     return 1. }
true;;1;3;// adds one to mock not existing term freq ;// read a vInt. this is used if the integer might be negative. In this case, // the writer writes a 0 for -1 or value +1 and accordingly we have to // subtract 1 again // adds one to mock not existing term freq int readPotentiallyNegativeVInt(StreamInput stream) throws IOException {     return stream.readVInt() - 1. }
true;;1;3;// adds one to mock not existing term freq ;// read a vLong. this is used if the integer might be negative. In this // case, the writer writes a 0 for -1 or value +1 and accordingly we have to // subtract 1 again // adds one to mock not existing term freq long readPotentiallyNegativeVLong(StreamInput stream) throws IOException {     return stream.readVLong() - 1. }
