commented;modifiers;parameterAmount;loc;comment;code
false;public;1;10;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeString(name).     out.writeString(type).     out.writeBoolean(isSearchable).     out.writeBoolean(isAggregatable).     out.writeOptionalStringArray(indices).     out.writeOptionalStringArray(nonSearchableIndices).     out.writeOptionalStringArray(nonAggregatableIndices). }
false;public;2;18;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     builder.field(TYPE_FIELD.getPreferredName(), type).     builder.field(SEARCHABLE_FIELD.getPreferredName(), isSearchable).     builder.field(AGGREGATABLE_FIELD.getPreferredName(), isAggregatable).     if (indices != null) {         builder.field(INDICES_FIELD.getPreferredName(), indices).     }     if (nonSearchableIndices != null) {         builder.field(NON_SEARCHABLE_INDICES_FIELD.getPreferredName(), nonSearchableIndices).     }     if (nonAggregatableIndices != null) {         builder.field(NON_AGGREGATABLE_INDICES_FIELD.getPreferredName(), nonAggregatableIndices).     }     builder.endObject().     return builder. }
false;public,static;2;3;;public static FieldCapabilities fromXContent(String name, XContentParser parser) throws IOException {     return PARSER.parse(parser, name). }
true;public;0;3;/**  * The name of the field.  */ ;/**  * The name of the field.  */ public String getName() {     return name. }
true;public;0;3;/**  * Whether this field can be aggregated on all indices.  */ ;/**  * Whether this field can be aggregated on all indices.  */ public boolean isAggregatable() {     return isAggregatable. }
true;public;0;3;/**  * Whether this field is indexed for search on all indices.  */ ;/**  * Whether this field is indexed for search on all indices.  */ public boolean isSearchable() {     return isSearchable. }
true;public;0;3;/**  * The type of the field.  */ ;/**  * The type of the field.  */ public String getType() {     return type. }
true;public;0;3;/**  * The list of indices where this field name is defined as {@code type},  * or null if all indices have the same {@code type} for the field.  */ ;/**  * The list of indices where this field name is defined as {@code type},  * or null if all indices have the same {@code type} for the field.  */ public String[] indices() {     return indices. }
true;public;0;3;/**  * The list of indices where this field is not searchable,  * or null if the field is searchable in all indices.  */ ;/**  * The list of indices where this field is not searchable,  * or null if the field is searchable in all indices.  */ public String[] nonSearchableIndices() {     return nonSearchableIndices. }
true;public;0;3;/**  * The list of indices where this field is not aggregatable,  * or null if the field is aggregatable in all indices.  */ ;/**  * The list of indices where this field is not aggregatable,  * or null if the field is aggregatable in all indices.  */ public String[] nonAggregatableIndices() {     return nonAggregatableIndices. }
false;public;1;15;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     FieldCapabilities that = (FieldCapabilities) o.     if (isSearchable != that.isSearchable)         return false.     if (isAggregatable != that.isAggregatable)         return false.     if (!name.equals(that.name))         return false.     if (!type.equals(that.type))         return false.     if (!Arrays.equals(indices, that.indices))         return false.     if (!Arrays.equals(nonSearchableIndices, that.nonSearchableIndices))         return false.     return Arrays.equals(nonAggregatableIndices, that.nonAggregatableIndices). }
false;public;0;11;;@Override public int hashCode() {     int result = name.hashCode().     result = 31 * result + type.hashCode().     result = 31 * result + (isSearchable ? 1 : 0).     result = 31 * result + (isAggregatable ? 1 : 0).     result = 31 * result + Arrays.hashCode(indices).     result = 31 * result + Arrays.hashCode(nonSearchableIndices).     result = 31 * result + Arrays.hashCode(nonAggregatableIndices).     return result. }
false;;3;6;;void add(String index, boolean search, boolean agg) {     IndexCaps indexCaps = new IndexCaps(index, search, agg).     indiceList.add(indexCaps).     this.isSearchable &= search.     this.isAggregatable &= agg. }
false;;1;41;;FieldCapabilities build(boolean withIndices) {     final String[] indices.     /* Eclipse can't deal with o -> o.name, maybe because of              * https://bugs.eclipse.org/bugs/show_bug.cgi?id=511750 */     Collections.sort(indiceList, Comparator.comparing((IndexCaps o) -> o.name)).     if (withIndices) {         indices = indiceList.stream().map(caps -> caps.name).toArray(String[]::new).     } else {         indices = null.     }     final String[] nonSearchableIndices.     if (isSearchable == false && indiceList.stream().anyMatch((caps) -> caps.isSearchable)) {         // Iff this field is searchable in some indices AND non-searchable in others         // we record the list of non-searchable indices         nonSearchableIndices = indiceList.stream().filter((caps) -> caps.isSearchable == false).map(caps -> caps.name).toArray(String[]::new).     } else {         nonSearchableIndices = null.     }     final String[] nonAggregatableIndices.     if (isAggregatable == false && indiceList.stream().anyMatch((caps) -> caps.isAggregatable)) {         // Iff this field is aggregatable in some indices AND non-searchable in others         // we keep the list of non-aggregatable indices         nonAggregatableIndices = indiceList.stream().filter((caps) -> caps.isAggregatable == false).map(caps -> caps.name).toArray(String[]::new).     } else {         nonAggregatableIndices = null.     }     return new FieldCapabilities(name, type, isSearchable, isAggregatable, indices, nonSearchableIndices, nonAggregatableIndices). }
