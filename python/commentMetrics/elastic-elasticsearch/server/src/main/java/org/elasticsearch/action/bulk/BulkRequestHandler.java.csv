commented;modifiers;parameterAmount;loc;comment;code
false;public;1;9;;@Override public void onResponse(BulkResponse response) {     try {         listener.afterBulk(executionId, bulkRequest, response).     } finally {         semaphore.release().         latch.countDown().     } }
false;public;1;9;;@Override public void onFailure(Exception e) {     try {         listener.afterBulk(executionId, bulkRequest, e).     } finally {         semaphore.release().         latch.countDown().     } }
false;public;2;46;;public void execute(BulkRequest bulkRequest, long executionId) {     Runnable toRelease = () -> {     }.     boolean bulkRequestSetupSuccessful = false.     try {         listener.beforeBulk(executionId, bulkRequest).         semaphore.acquire().         toRelease = semaphore::release.         CountDownLatch latch = new CountDownLatch(1).         retry.withBackoff(consumer, bulkRequest, new ActionListener<BulkResponse>() {              @Override             public void onResponse(BulkResponse response) {                 try {                     listener.afterBulk(executionId, bulkRequest, response).                 } finally {                     semaphore.release().                     latch.countDown().                 }             }              @Override             public void onFailure(Exception e) {                 try {                     listener.afterBulk(executionId, bulkRequest, e).                 } finally {                     semaphore.release().                     latch.countDown().                 }             }         }).         bulkRequestSetupSuccessful = true.         if (concurrentRequests == 0) {             latch.await().         }     } catch (InterruptedException e) {         Thread.currentThread().interrupt().         logger.info(() -> new ParameterizedMessage("Bulk request {} has been cancelled.", executionId), e).         listener.afterBulk(executionId, bulkRequest, e).     } catch (Exception e) {         logger.warn(() -> new ParameterizedMessage("Failed to execute bulk request {}.", executionId), e).         listener.afterBulk(executionId, bulkRequest, e).     } finally {         if (bulkRequestSetupSuccessful == false) {             // if we fail on client.bulk() release the semaphore             toRelease.run().         }     } }
false;;2;7;;boolean awaitClose(long timeout, TimeUnit unit) throws InterruptedException {     if (semaphore.tryAcquire(this.concurrentRequests, timeout, unit)) {         semaphore.release(this.concurrentRequests).         return true.     }     return false. }
