# id;timestamp;commentText;codeText;commentWords;codeWords
NetworkService -> public InetAddress[] resolveBindHostAddresses(String bindHosts[]) throws IOException;1524684173;Resolves {@code bindHosts} to a list of internet addresses. The list will_not contain duplicate addresses.__@param bindHosts list of hosts to bind to. this may contain special pseudo-hostnames_such as _local_ (see the documentation). if it is null, it will fall back to _local___@return unique set of internet addresses;public InetAddress[] resolveBindHostAddresses(String bindHosts[]) throws IOException {_        if (bindHosts == null || bindHosts.length == 0) {_            for (CustomNameResolver customNameResolver : customNameResolvers) {_                InetAddress addresses[] = customNameResolver.resolveDefault()__                if (addresses != null) {_                    return addresses__                }_            }_            _            bindHosts = new String[] {"_local_"}__        }__        InetAddress addresses[] = resolveInetAddresses(bindHosts)___        _        for (InetAddress address : addresses) {_            _            if (address.isMulticastAddress()) {_                throw new IllegalArgumentException("bind address: {" + NetworkAddress.format(address) + "} is invalid: multicast address")__            }_            _            if (address.isAnyLocalAddress() && addresses.length > 1) {_                throw new IllegalArgumentException("bind address: {" + NetworkAddress.format(address) + "} is wildcard, but multiple addresses specified: this makes no sense")__            }_        }_        return addresses__    };resolves,code,bind,hosts,to,a,list,of,internet,addresses,the,list,will,not,contain,duplicate,addresses,param,bind,hosts,list,of,hosts,to,bind,to,this,may,contain,special,pseudo,hostnames,such,as,see,the,documentation,if,it,is,null,it,will,fall,back,to,return,unique,set,of,internet,addresses;public,inet,address,resolve,bind,host,addresses,string,bind,hosts,throws,ioexception,if,bind,hosts,null,bind,hosts,length,0,for,custom,name,resolver,custom,name,resolver,custom,name,resolvers,inet,address,addresses,custom,name,resolver,resolve,default,if,addresses,null,return,addresses,bind,hosts,new,string,inet,address,addresses,resolve,inet,addresses,bind,hosts,for,inet,address,address,addresses,if,address,is,multicast,address,throw,new,illegal,argument,exception,bind,address,network,address,format,address,is,invalid,multicast,address,if,address,is,any,local,address,addresses,length,1,throw,new,illegal,argument,exception,bind,address,network,address,format,address,is,wildcard,but,multiple,addresses,specified,this,makes,no,sense,return,addresses
NetworkService -> public InetAddress[] resolveBindHostAddresses(String bindHosts[]) throws IOException;1525334055;Resolves {@code bindHosts} to a list of internet addresses. The list will_not contain duplicate addresses.__@param bindHosts list of hosts to bind to. this may contain special pseudo-hostnames_such as _local_ (see the documentation). if it is null, it will fall back to _local___@return unique set of internet addresses;public InetAddress[] resolveBindHostAddresses(String bindHosts[]) throws IOException {_        if (bindHosts == null || bindHosts.length == 0) {_            for (CustomNameResolver customNameResolver : customNameResolvers) {_                InetAddress addresses[] = customNameResolver.resolveDefault()__                if (addresses != null) {_                    return addresses__                }_            }_            _            bindHosts = new String[] {"_local_"}__        }__        InetAddress addresses[] = resolveInetAddresses(bindHosts)___        _        for (InetAddress address : addresses) {_            _            if (address.isMulticastAddress()) {_                throw new IllegalArgumentException("bind address: {" + NetworkAddress.format(address) + "} is invalid: multicast address")__            }_            _            if (address.isAnyLocalAddress() && addresses.length > 1) {_                throw new IllegalArgumentException("bind address: {" + NetworkAddress.format(address) + "} is wildcard, but multiple addresses specified: this makes no sense")__            }_        }_        return addresses__    };resolves,code,bind,hosts,to,a,list,of,internet,addresses,the,list,will,not,contain,duplicate,addresses,param,bind,hosts,list,of,hosts,to,bind,to,this,may,contain,special,pseudo,hostnames,such,as,see,the,documentation,if,it,is,null,it,will,fall,back,to,return,unique,set,of,internet,addresses;public,inet,address,resolve,bind,host,addresses,string,bind,hosts,throws,ioexception,if,bind,hosts,null,bind,hosts,length,0,for,custom,name,resolver,custom,name,resolver,custom,name,resolvers,inet,address,addresses,custom,name,resolver,resolve,default,if,addresses,null,return,addresses,bind,hosts,new,string,inet,address,addresses,resolve,inet,addresses,bind,hosts,for,inet,address,address,addresses,if,address,is,multicast,address,throw,new,illegal,argument,exception,bind,address,network,address,format,address,is,invalid,multicast,address,if,address,is,any,local,address,addresses,length,1,throw,new,illegal,argument,exception,bind,address,network,address,format,address,is,wildcard,but,multiple,addresses,specified,this,makes,no,sense,return,addresses
NetworkService -> public InetAddress[] resolveBindHostAddresses(String bindHosts[]) throws IOException;1540583181;Resolves {@code bindHosts} to a list of internet addresses. The list will_not contain duplicate addresses.__@param bindHosts list of hosts to bind to. this may contain special pseudo-hostnames_such as _local_ (see the documentation). if it is null, it will fall back to _local___@return unique set of internet addresses;public InetAddress[] resolveBindHostAddresses(String bindHosts[]) throws IOException {_        if (bindHosts == null || bindHosts.length == 0) {_            for (CustomNameResolver customNameResolver : customNameResolvers) {_                InetAddress addresses[] = customNameResolver.resolveDefault()__                if (addresses != null) {_                    return addresses__                }_            }_            _            bindHosts = new String[] {"_local_"}__        }__        InetAddress addresses[] = resolveInetAddresses(bindHosts)___        _        for (InetAddress address : addresses) {_            _            if (address.isMulticastAddress()) {_                throw new IllegalArgumentException("bind address: {" + NetworkAddress.format(address) + "} is invalid: multicast address")__            }_            _            if (address.isAnyLocalAddress() && addresses.length > 1) {_                throw new IllegalArgumentException("bind address: {" + NetworkAddress.format(address) +_                    "} is wildcard, but multiple addresses specified: this makes no sense")__            }_        }_        return addresses__    };resolves,code,bind,hosts,to,a,list,of,internet,addresses,the,list,will,not,contain,duplicate,addresses,param,bind,hosts,list,of,hosts,to,bind,to,this,may,contain,special,pseudo,hostnames,such,as,see,the,documentation,if,it,is,null,it,will,fall,back,to,return,unique,set,of,internet,addresses;public,inet,address,resolve,bind,host,addresses,string,bind,hosts,throws,ioexception,if,bind,hosts,null,bind,hosts,length,0,for,custom,name,resolver,custom,name,resolver,custom,name,resolvers,inet,address,addresses,custom,name,resolver,resolve,default,if,addresses,null,return,addresses,bind,hosts,new,string,inet,address,addresses,resolve,inet,addresses,bind,hosts,for,inet,address,address,addresses,if,address,is,multicast,address,throw,new,illegal,argument,exception,bind,address,network,address,format,address,is,invalid,multicast,address,if,address,is,any,local,address,addresses,length,1,throw,new,illegal,argument,exception,bind,address,network,address,format,address,is,wildcard,but,multiple,addresses,specified,this,makes,no,sense,return,addresses
NetworkService -> public InetAddress[] resolveBindHostAddresses(String bindHosts[]) throws IOException;1544823664;Resolves {@code bindHosts} to a list of internet addresses. The list will_not contain duplicate addresses.__@param bindHosts list of hosts to bind to. this may contain special pseudo-hostnames_such as _local_ (see the documentation). if it is null, it will fall back to _local___@return unique set of internet addresses;public InetAddress[] resolveBindHostAddresses(String bindHosts[]) throws IOException {_        if (bindHosts == null || bindHosts.length == 0) {_            for (CustomNameResolver customNameResolver : customNameResolvers) {_                InetAddress addresses[] = customNameResolver.resolveDefault()__                if (addresses != null) {_                    return addresses__                }_            }_            _            bindHosts = new String[] {"_local_"}__        }__        InetAddress addresses[] = resolveInetAddresses(bindHosts)___        _        for (InetAddress address : addresses) {_            _            if (address.isMulticastAddress()) {_                throw new IllegalArgumentException("bind address: {" + NetworkAddress.format(address) + "} is invalid: multicast address")__            }_            _            if (address.isAnyLocalAddress() && addresses.length > 1) {_                throw new IllegalArgumentException("bind address: {" + NetworkAddress.format(address) +_                    "} is wildcard, but multiple addresses specified: this makes no sense")__            }_        }_        return addresses__    };resolves,code,bind,hosts,to,a,list,of,internet,addresses,the,list,will,not,contain,duplicate,addresses,param,bind,hosts,list,of,hosts,to,bind,to,this,may,contain,special,pseudo,hostnames,such,as,see,the,documentation,if,it,is,null,it,will,fall,back,to,return,unique,set,of,internet,addresses;public,inet,address,resolve,bind,host,addresses,string,bind,hosts,throws,ioexception,if,bind,hosts,null,bind,hosts,length,0,for,custom,name,resolver,custom,name,resolver,custom,name,resolvers,inet,address,addresses,custom,name,resolver,resolve,default,if,addresses,null,return,addresses,bind,hosts,new,string,inet,address,addresses,resolve,inet,addresses,bind,hosts,for,inet,address,address,addresses,if,address,is,multicast,address,throw,new,illegal,argument,exception,bind,address,network,address,format,address,is,invalid,multicast,address,if,address,is,any,local,address,addresses,length,1,throw,new,illegal,argument,exception,bind,address,network,address,format,address,is,wildcard,but,multiple,addresses,specified,this,makes,no,sense,return,addresses
NetworkService -> public InetAddress resolvePublishHostAddresses(String publishHosts[]) throws IOException;1524684173;Resolves {@code publishHosts} to a single publish address. The fact that it returns_only one address is just a current limitation._<p>_If {@code publishHosts} resolves to more than one address, <b>then one is selected with magic</b>__@param publishHosts list of hosts to publish as. this may contain special pseudo-hostnames_such as _local_ (see the documentation). if it is null, it will fall back to _local__@return single internet address;public InetAddress resolvePublishHostAddresses(String publishHosts[]) throws IOException {_        if (publishHosts == null || publishHosts.length == 0) {_            for (CustomNameResolver customNameResolver : customNameResolvers) {_                InetAddress addresses[] = customNameResolver.resolveDefault()__                if (addresses != null) {_                    return addresses[0]__                }_            }_            _            publishHosts = new String[] {DEFAULT_NETWORK_HOST}__        }__        InetAddress addresses[] = resolveInetAddresses(publishHosts)__        _        __        _        if (addresses.length == 1 && addresses[0].isAnyLocalAddress()) {_            HashSet<InetAddress> all = new HashSet<>(Arrays.asList(NetworkUtils.getAllAddresses()))__            addresses = all.toArray(new InetAddress[all.size()])__        }__        _        for (InetAddress address : addresses) {_            _            if (address.isMulticastAddress()) {_                throw new IllegalArgumentException("publish address: {" + NetworkAddress.format(address) + "} is invalid: multicast address")__            }_            _            _            if (address.isAnyLocalAddress()) {_                throw new IllegalArgumentException("publish address: {" + NetworkAddress.format(address) + "} is wildcard, but multiple addresses specified: this makes no sense")__            }_        }__        _        _        if (addresses.length > 1) {_            List<InetAddress> sorted = new ArrayList<>(Arrays.asList(addresses))__            NetworkUtils.sortAddresses(sorted)__            addresses = new InetAddress[]{sorted.get(0)}__        }_        return addresses[0]__    };resolves,code,publish,hosts,to,a,single,publish,address,the,fact,that,it,returns,only,one,address,is,just,a,current,limitation,p,if,code,publish,hosts,resolves,to,more,than,one,address,b,then,one,is,selected,with,magic,b,param,publish,hosts,list,of,hosts,to,publish,as,this,may,contain,special,pseudo,hostnames,such,as,see,the,documentation,if,it,is,null,it,will,fall,back,to,return,single,internet,address;public,inet,address,resolve,publish,host,addresses,string,publish,hosts,throws,ioexception,if,publish,hosts,null,publish,hosts,length,0,for,custom,name,resolver,custom,name,resolver,custom,name,resolvers,inet,address,addresses,custom,name,resolver,resolve,default,if,addresses,null,return,addresses,0,publish,hosts,new,string,inet,address,addresses,resolve,inet,addresses,publish,hosts,if,addresses,length,1,addresses,0,is,any,local,address,hash,set,inet,address,all,new,hash,set,arrays,as,list,network,utils,get,all,addresses,addresses,all,to,array,new,inet,address,all,size,for,inet,address,address,addresses,if,address,is,multicast,address,throw,new,illegal,argument,exception,publish,address,network,address,format,address,is,invalid,multicast,address,if,address,is,any,local,address,throw,new,illegal,argument,exception,publish,address,network,address,format,address,is,wildcard,but,multiple,addresses,specified,this,makes,no,sense,if,addresses,length,1,list,inet,address,sorted,new,array,list,arrays,as,list,addresses,network,utils,sort,addresses,sorted,addresses,new,inet,address,sorted,get,0,return,addresses,0
NetworkService -> public InetAddress resolvePublishHostAddresses(String publishHosts[]) throws IOException;1525334055;Resolves {@code publishHosts} to a single publish address. The fact that it returns_only one address is just a current limitation._<p>_If {@code publishHosts} resolves to more than one address, <b>then one is selected with magic</b>__@param publishHosts list of hosts to publish as. this may contain special pseudo-hostnames_such as _local_ (see the documentation). if it is null, it will fall back to _local__@return single internet address;public InetAddress resolvePublishHostAddresses(String publishHosts[]) throws IOException {_        if (publishHosts == null || publishHosts.length == 0) {_            for (CustomNameResolver customNameResolver : customNameResolvers) {_                InetAddress addresses[] = customNameResolver.resolveDefault()__                if (addresses != null) {_                    return addresses[0]__                }_            }_            _            publishHosts = new String[] {DEFAULT_NETWORK_HOST}__        }__        InetAddress addresses[] = resolveInetAddresses(publishHosts)__        _        __        _        if (addresses.length == 1 && addresses[0].isAnyLocalAddress()) {_            HashSet<InetAddress> all = new HashSet<>(Arrays.asList(NetworkUtils.getAllAddresses()))__            addresses = all.toArray(new InetAddress[all.size()])__        }__        _        for (InetAddress address : addresses) {_            _            if (address.isMulticastAddress()) {_                throw new IllegalArgumentException("publish address: {" + NetworkAddress.format(address) + "} is invalid: multicast address")__            }_            _            _            if (address.isAnyLocalAddress()) {_                throw new IllegalArgumentException("publish address: {" + NetworkAddress.format(address) + "} is wildcard, but multiple addresses specified: this makes no sense")__            }_        }__        _        _        if (addresses.length > 1) {_            List<InetAddress> sorted = new ArrayList<>(Arrays.asList(addresses))__            NetworkUtils.sortAddresses(sorted)__            addresses = new InetAddress[]{sorted.get(0)}__        }_        return addresses[0]__    };resolves,code,publish,hosts,to,a,single,publish,address,the,fact,that,it,returns,only,one,address,is,just,a,current,limitation,p,if,code,publish,hosts,resolves,to,more,than,one,address,b,then,one,is,selected,with,magic,b,param,publish,hosts,list,of,hosts,to,publish,as,this,may,contain,special,pseudo,hostnames,such,as,see,the,documentation,if,it,is,null,it,will,fall,back,to,return,single,internet,address;public,inet,address,resolve,publish,host,addresses,string,publish,hosts,throws,ioexception,if,publish,hosts,null,publish,hosts,length,0,for,custom,name,resolver,custom,name,resolver,custom,name,resolvers,inet,address,addresses,custom,name,resolver,resolve,default,if,addresses,null,return,addresses,0,publish,hosts,new,string,inet,address,addresses,resolve,inet,addresses,publish,hosts,if,addresses,length,1,addresses,0,is,any,local,address,hash,set,inet,address,all,new,hash,set,arrays,as,list,network,utils,get,all,addresses,addresses,all,to,array,new,inet,address,all,size,for,inet,address,address,addresses,if,address,is,multicast,address,throw,new,illegal,argument,exception,publish,address,network,address,format,address,is,invalid,multicast,address,if,address,is,any,local,address,throw,new,illegal,argument,exception,publish,address,network,address,format,address,is,wildcard,but,multiple,addresses,specified,this,makes,no,sense,if,addresses,length,1,list,inet,address,sorted,new,array,list,arrays,as,list,addresses,network,utils,sort,addresses,sorted,addresses,new,inet,address,sorted,get,0,return,addresses,0
NetworkService -> public InetAddress resolvePublishHostAddresses(String publishHosts[]) throws IOException;1540583181;Resolves {@code publishHosts} to a single publish address. The fact that it returns_only one address is just a current limitation._<p>_If {@code publishHosts} resolves to more than one address, <b>then one is selected with magic</b>__@param publishHosts list of hosts to publish as. this may contain special pseudo-hostnames_such as _local_ (see the documentation). if it is null, it will fall back to _local__@return single internet address;public InetAddress resolvePublishHostAddresses(String publishHosts[]) throws IOException {_        if (publishHosts == null || publishHosts.length == 0) {_            for (CustomNameResolver customNameResolver : customNameResolvers) {_                InetAddress addresses[] = customNameResolver.resolveDefault()__                if (addresses != null) {_                    return addresses[0]__                }_            }_            _            publishHosts = new String[] {DEFAULT_NETWORK_HOST}__        }__        InetAddress addresses[] = resolveInetAddresses(publishHosts)__        _        __        _        if (addresses.length == 1 && addresses[0].isAnyLocalAddress()) {_            HashSet<InetAddress> all = new HashSet<>(Arrays.asList(NetworkUtils.getAllAddresses()))__            addresses = all.toArray(new InetAddress[all.size()])__        }__        _        for (InetAddress address : addresses) {_            _            if (address.isMulticastAddress()) {_                throw new IllegalArgumentException("publish address: {" + NetworkAddress.format(address) +_                    "} is invalid: multicast address")__            }_            _            _            if (address.isAnyLocalAddress()) {_                throw new IllegalArgumentException("publish address: {" + NetworkAddress.format(address) +_                    "} is wildcard, but multiple addresses specified: this makes no sense")__            }_        }__        _        _        if (addresses.length > 1) {_            List<InetAddress> sorted = new ArrayList<>(Arrays.asList(addresses))__            NetworkUtils.sortAddresses(sorted)__            addresses = new InetAddress[]{sorted.get(0)}__        }_        return addresses[0]__    };resolves,code,publish,hosts,to,a,single,publish,address,the,fact,that,it,returns,only,one,address,is,just,a,current,limitation,p,if,code,publish,hosts,resolves,to,more,than,one,address,b,then,one,is,selected,with,magic,b,param,publish,hosts,list,of,hosts,to,publish,as,this,may,contain,special,pseudo,hostnames,such,as,see,the,documentation,if,it,is,null,it,will,fall,back,to,return,single,internet,address;public,inet,address,resolve,publish,host,addresses,string,publish,hosts,throws,ioexception,if,publish,hosts,null,publish,hosts,length,0,for,custom,name,resolver,custom,name,resolver,custom,name,resolvers,inet,address,addresses,custom,name,resolver,resolve,default,if,addresses,null,return,addresses,0,publish,hosts,new,string,inet,address,addresses,resolve,inet,addresses,publish,hosts,if,addresses,length,1,addresses,0,is,any,local,address,hash,set,inet,address,all,new,hash,set,arrays,as,list,network,utils,get,all,addresses,addresses,all,to,array,new,inet,address,all,size,for,inet,address,address,addresses,if,address,is,multicast,address,throw,new,illegal,argument,exception,publish,address,network,address,format,address,is,invalid,multicast,address,if,address,is,any,local,address,throw,new,illegal,argument,exception,publish,address,network,address,format,address,is,wildcard,but,multiple,addresses,specified,this,makes,no,sense,if,addresses,length,1,list,inet,address,sorted,new,array,list,arrays,as,list,addresses,network,utils,sort,addresses,sorted,addresses,new,inet,address,sorted,get,0,return,addresses,0
NetworkService -> public InetAddress resolvePublishHostAddresses(String publishHosts[]) throws IOException;1544823664;Resolves {@code publishHosts} to a single publish address. The fact that it returns_only one address is just a current limitation._<p>_If {@code publishHosts} resolves to more than one address, <b>then one is selected with magic</b>__@param publishHosts list of hosts to publish as. this may contain special pseudo-hostnames_such as _local_ (see the documentation). if it is null, it will fall back to _local__@return single internet address;public InetAddress resolvePublishHostAddresses(String publishHosts[]) throws IOException {_        if (publishHosts == null || publishHosts.length == 0) {_            for (CustomNameResolver customNameResolver : customNameResolvers) {_                InetAddress addresses[] = customNameResolver.resolveDefault()__                if (addresses != null) {_                    return addresses[0]__                }_            }_            _            publishHosts = new String[] {DEFAULT_NETWORK_HOST}__        }__        InetAddress addresses[] = resolveInetAddresses(publishHosts)__        _        __        _        if (addresses.length == 1 && addresses[0].isAnyLocalAddress()) {_            HashSet<InetAddress> all = new HashSet<>(Arrays.asList(NetworkUtils.getAllAddresses()))__            addresses = all.toArray(new InetAddress[all.size()])__        }__        _        for (InetAddress address : addresses) {_            _            if (address.isMulticastAddress()) {_                throw new IllegalArgumentException("publish address: {" + NetworkAddress.format(address) +_                    "} is invalid: multicast address")__            }_            _            _            if (address.isAnyLocalAddress()) {_                throw new IllegalArgumentException("publish address: {" + NetworkAddress.format(address) +_                    "} is wildcard, but multiple addresses specified: this makes no sense")__            }_        }__        _        _        if (addresses.length > 1) {_            List<InetAddress> sorted = new ArrayList<>(Arrays.asList(addresses))__            NetworkUtils.sortAddresses(sorted)__            addresses = new InetAddress[]{sorted.get(0)}__        }_        return addresses[0]__    };resolves,code,publish,hosts,to,a,single,publish,address,the,fact,that,it,returns,only,one,address,is,just,a,current,limitation,p,if,code,publish,hosts,resolves,to,more,than,one,address,b,then,one,is,selected,with,magic,b,param,publish,hosts,list,of,hosts,to,publish,as,this,may,contain,special,pseudo,hostnames,such,as,see,the,documentation,if,it,is,null,it,will,fall,back,to,return,single,internet,address;public,inet,address,resolve,publish,host,addresses,string,publish,hosts,throws,ioexception,if,publish,hosts,null,publish,hosts,length,0,for,custom,name,resolver,custom,name,resolver,custom,name,resolvers,inet,address,addresses,custom,name,resolver,resolve,default,if,addresses,null,return,addresses,0,publish,hosts,new,string,inet,address,addresses,resolve,inet,addresses,publish,hosts,if,addresses,length,1,addresses,0,is,any,local,address,hash,set,inet,address,all,new,hash,set,arrays,as,list,network,utils,get,all,addresses,addresses,all,to,array,new,inet,address,all,size,for,inet,address,address,addresses,if,address,is,multicast,address,throw,new,illegal,argument,exception,publish,address,network,address,format,address,is,invalid,multicast,address,if,address,is,any,local,address,throw,new,illegal,argument,exception,publish,address,network,address,format,address,is,wildcard,but,multiple,addresses,specified,this,makes,no,sense,if,addresses,length,1,list,inet,address,sorted,new,array,list,arrays,as,list,addresses,network,utils,sort,addresses,sorted,addresses,new,inet,address,sorted,get,0,return,addresses,0
NetworkService -> CustomNameResolver -> InetAddress[] resolveDefault()_;1524684173;Resolves the default value if possible. If not, return <tt>null</tt>.;InetAddress[] resolveDefault()_;resolves,the,default,value,if,possible,if,not,return,tt,null,tt;inet,address,resolve,default
NetworkService -> CustomNameResolver -> InetAddress[] resolveDefault()_;1525334055;Resolves the default value if possible. If not, return {@code null}.;InetAddress[] resolveDefault()_;resolves,the,default,value,if,possible,if,not,return,code,null;inet,address,resolve,default
NetworkService -> CustomNameResolver -> InetAddress[] resolveDefault()_;1540583181;Resolves the default value if possible. If not, return {@code null}.;InetAddress[] resolveDefault()_;resolves,the,default,value,if,possible,if,not,return,code,null;inet,address,resolve,default
NetworkService -> CustomNameResolver -> InetAddress[] resolveDefault()_;1544823664;Resolves the default value if possible. If not, return {@code null}.;InetAddress[] resolveDefault()_;resolves,the,default,value,if,possible,if,not,return,code,null;inet,address,resolve,default
NetworkService -> private InetAddress[] resolveInternal(String host) throws IOException;1524684173;resolves a single host specification;private InetAddress[] resolveInternal(String host) throws IOException {_        if ((host.startsWith("#") && host.endsWith("#")) || (host.startsWith("_") && host.endsWith("_"))) {_            host = host.substring(1, host.length() - 1)__            _            if (customNameResolvers != null) {_                for (CustomNameResolver customNameResolver : customNameResolvers) {_                    InetAddress addresses[] = customNameResolver.resolveIfPossible(host)__                    if (addresses != null) {_                        return addresses__                    }_                }_            }_            switch (host) {_                case "local":_                    return NetworkUtils.getLoopbackAddresses()__                case "local:ipv4":_                    return NetworkUtils.filterIPV4(NetworkUtils.getLoopbackAddresses())__                case "local:ipv6":_                    return NetworkUtils.filterIPV6(NetworkUtils.getLoopbackAddresses())__                case "site":_                    return NetworkUtils.getSiteLocalAddresses()__                case "site:ipv4":_                    return NetworkUtils.filterIPV4(NetworkUtils.getSiteLocalAddresses())__                case "site:ipv6":_                    return NetworkUtils.filterIPV6(NetworkUtils.getSiteLocalAddresses())__                case "global":_                    return NetworkUtils.getGlobalAddresses()__                case "global:ipv4":_                    return NetworkUtils.filterIPV4(NetworkUtils.getGlobalAddresses())__                case "global:ipv6":_                    return NetworkUtils.filterIPV6(NetworkUtils.getGlobalAddresses())__                default:_                    _                    if (host.endsWith(":ipv4")) {_                        host = host.substring(0, host.length() - 5)__                        return NetworkUtils.filterIPV4(NetworkUtils.getAddressesForInterface(host))__                    } else if (host.endsWith(":ipv6")) {_                        host = host.substring(0, host.length() - 5)__                        return NetworkUtils.filterIPV6(NetworkUtils.getAddressesForInterface(host))__                    } else {_                        return NetworkUtils.getAddressesForInterface(host)__                    }_            }_        }_        return InetAddress.getAllByName(host)__    };resolves,a,single,host,specification;private,inet,address,resolve,internal,string,host,throws,ioexception,if,host,starts,with,host,ends,with,host,starts,with,host,ends,with,host,host,substring,1,host,length,1,if,custom,name,resolvers,null,for,custom,name,resolver,custom,name,resolver,custom,name,resolvers,inet,address,addresses,custom,name,resolver,resolve,if,possible,host,if,addresses,null,return,addresses,switch,host,case,local,return,network,utils,get,loopback,addresses,case,local,ipv4,return,network,utils,filter,ipv4,network,utils,get,loopback,addresses,case,local,ipv6,return,network,utils,filter,ipv6,network,utils,get,loopback,addresses,case,site,return,network,utils,get,site,local,addresses,case,site,ipv4,return,network,utils,filter,ipv4,network,utils,get,site,local,addresses,case,site,ipv6,return,network,utils,filter,ipv6,network,utils,get,site,local,addresses,case,global,return,network,utils,get,global,addresses,case,global,ipv4,return,network,utils,filter,ipv4,network,utils,get,global,addresses,case,global,ipv6,return,network,utils,filter,ipv6,network,utils,get,global,addresses,default,if,host,ends,with,ipv4,host,host,substring,0,host,length,5,return,network,utils,filter,ipv4,network,utils,get,addresses,for,interface,host,else,if,host,ends,with,ipv6,host,host,substring,0,host,length,5,return,network,utils,filter,ipv6,network,utils,get,addresses,for,interface,host,else,return,network,utils,get,addresses,for,interface,host,return,inet,address,get,all,by,name,host
NetworkService -> private InetAddress[] resolveInternal(String host) throws IOException;1525334055;resolves a single host specification;private InetAddress[] resolveInternal(String host) throws IOException {_        if ((host.startsWith("#") && host.endsWith("#")) || (host.startsWith("_") && host.endsWith("_"))) {_            host = host.substring(1, host.length() - 1)__            _            if (customNameResolvers != null) {_                for (CustomNameResolver customNameResolver : customNameResolvers) {_                    InetAddress addresses[] = customNameResolver.resolveIfPossible(host)__                    if (addresses != null) {_                        return addresses__                    }_                }_            }_            switch (host) {_                case "local":_                    return NetworkUtils.getLoopbackAddresses()__                case "local:ipv4":_                    return NetworkUtils.filterIPV4(NetworkUtils.getLoopbackAddresses())__                case "local:ipv6":_                    return NetworkUtils.filterIPV6(NetworkUtils.getLoopbackAddresses())__                case "site":_                    return NetworkUtils.getSiteLocalAddresses()__                case "site:ipv4":_                    return NetworkUtils.filterIPV4(NetworkUtils.getSiteLocalAddresses())__                case "site:ipv6":_                    return NetworkUtils.filterIPV6(NetworkUtils.getSiteLocalAddresses())__                case "global":_                    return NetworkUtils.getGlobalAddresses()__                case "global:ipv4":_                    return NetworkUtils.filterIPV4(NetworkUtils.getGlobalAddresses())__                case "global:ipv6":_                    return NetworkUtils.filterIPV6(NetworkUtils.getGlobalAddresses())__                default:_                    _                    if (host.endsWith(":ipv4")) {_                        host = host.substring(0, host.length() - 5)__                        return NetworkUtils.filterIPV4(NetworkUtils.getAddressesForInterface(host))__                    } else if (host.endsWith(":ipv6")) {_                        host = host.substring(0, host.length() - 5)__                        return NetworkUtils.filterIPV6(NetworkUtils.getAddressesForInterface(host))__                    } else {_                        return NetworkUtils.getAddressesForInterface(host)__                    }_            }_        }_        return InetAddress.getAllByName(host)__    };resolves,a,single,host,specification;private,inet,address,resolve,internal,string,host,throws,ioexception,if,host,starts,with,host,ends,with,host,starts,with,host,ends,with,host,host,substring,1,host,length,1,if,custom,name,resolvers,null,for,custom,name,resolver,custom,name,resolver,custom,name,resolvers,inet,address,addresses,custom,name,resolver,resolve,if,possible,host,if,addresses,null,return,addresses,switch,host,case,local,return,network,utils,get,loopback,addresses,case,local,ipv4,return,network,utils,filter,ipv4,network,utils,get,loopback,addresses,case,local,ipv6,return,network,utils,filter,ipv6,network,utils,get,loopback,addresses,case,site,return,network,utils,get,site,local,addresses,case,site,ipv4,return,network,utils,filter,ipv4,network,utils,get,site,local,addresses,case,site,ipv6,return,network,utils,filter,ipv6,network,utils,get,site,local,addresses,case,global,return,network,utils,get,global,addresses,case,global,ipv4,return,network,utils,filter,ipv4,network,utils,get,global,addresses,case,global,ipv6,return,network,utils,filter,ipv6,network,utils,get,global,addresses,default,if,host,ends,with,ipv4,host,host,substring,0,host,length,5,return,network,utils,filter,ipv4,network,utils,get,addresses,for,interface,host,else,if,host,ends,with,ipv6,host,host,substring,0,host,length,5,return,network,utils,filter,ipv6,network,utils,get,addresses,for,interface,host,else,return,network,utils,get,addresses,for,interface,host,return,inet,address,get,all,by,name,host
NetworkService -> private InetAddress[] resolveInternal(String host) throws IOException;1540583181;resolves a single host specification;private InetAddress[] resolveInternal(String host) throws IOException {_        if ((host.startsWith("#") && host.endsWith("#")) || (host.startsWith("_") && host.endsWith("_"))) {_            host = host.substring(1, host.length() - 1)__            _            if (customNameResolvers != null) {_                for (CustomNameResolver customNameResolver : customNameResolvers) {_                    InetAddress addresses[] = customNameResolver.resolveIfPossible(host)__                    if (addresses != null) {_                        return addresses__                    }_                }_            }_            switch (host) {_                case "local":_                    return NetworkUtils.getLoopbackAddresses()__                case "local:ipv4":_                    return NetworkUtils.filterIPV4(NetworkUtils.getLoopbackAddresses())__                case "local:ipv6":_                    return NetworkUtils.filterIPV6(NetworkUtils.getLoopbackAddresses())__                case "site":_                    return NetworkUtils.getSiteLocalAddresses()__                case "site:ipv4":_                    return NetworkUtils.filterIPV4(NetworkUtils.getSiteLocalAddresses())__                case "site:ipv6":_                    return NetworkUtils.filterIPV6(NetworkUtils.getSiteLocalAddresses())__                case "global":_                    return NetworkUtils.getGlobalAddresses()__                case "global:ipv4":_                    return NetworkUtils.filterIPV4(NetworkUtils.getGlobalAddresses())__                case "global:ipv6":_                    return NetworkUtils.filterIPV6(NetworkUtils.getGlobalAddresses())__                default:_                    _                    if (host.endsWith(":ipv4")) {_                        host = host.substring(0, host.length() - 5)__                        return NetworkUtils.filterIPV4(NetworkUtils.getAddressesForInterface(host))__                    } else if (host.endsWith(":ipv6")) {_                        host = host.substring(0, host.length() - 5)__                        return NetworkUtils.filterIPV6(NetworkUtils.getAddressesForInterface(host))__                    } else {_                        return NetworkUtils.getAddressesForInterface(host)__                    }_            }_        }_        return InetAddress.getAllByName(host)__    };resolves,a,single,host,specification;private,inet,address,resolve,internal,string,host,throws,ioexception,if,host,starts,with,host,ends,with,host,starts,with,host,ends,with,host,host,substring,1,host,length,1,if,custom,name,resolvers,null,for,custom,name,resolver,custom,name,resolver,custom,name,resolvers,inet,address,addresses,custom,name,resolver,resolve,if,possible,host,if,addresses,null,return,addresses,switch,host,case,local,return,network,utils,get,loopback,addresses,case,local,ipv4,return,network,utils,filter,ipv4,network,utils,get,loopback,addresses,case,local,ipv6,return,network,utils,filter,ipv6,network,utils,get,loopback,addresses,case,site,return,network,utils,get,site,local,addresses,case,site,ipv4,return,network,utils,filter,ipv4,network,utils,get,site,local,addresses,case,site,ipv6,return,network,utils,filter,ipv6,network,utils,get,site,local,addresses,case,global,return,network,utils,get,global,addresses,case,global,ipv4,return,network,utils,filter,ipv4,network,utils,get,global,addresses,case,global,ipv6,return,network,utils,filter,ipv6,network,utils,get,global,addresses,default,if,host,ends,with,ipv4,host,host,substring,0,host,length,5,return,network,utils,filter,ipv4,network,utils,get,addresses,for,interface,host,else,if,host,ends,with,ipv6,host,host,substring,0,host,length,5,return,network,utils,filter,ipv6,network,utils,get,addresses,for,interface,host,else,return,network,utils,get,addresses,for,interface,host,return,inet,address,get,all,by,name,host
NetworkService -> private InetAddress[] resolveInternal(String host) throws IOException;1544823664;resolves a single host specification;private InetAddress[] resolveInternal(String host) throws IOException {_        if ((host.startsWith("#") && host.endsWith("#")) || (host.startsWith("_") && host.endsWith("_"))) {_            host = host.substring(1, host.length() - 1)__            _            if (customNameResolvers != null) {_                for (CustomNameResolver customNameResolver : customNameResolvers) {_                    InetAddress addresses[] = customNameResolver.resolveIfPossible(host)__                    if (addresses != null) {_                        return addresses__                    }_                }_            }_            switch (host) {_                case "local":_                    return NetworkUtils.getLoopbackAddresses()__                case "local:ipv4":_                    return NetworkUtils.filterIPV4(NetworkUtils.getLoopbackAddresses())__                case "local:ipv6":_                    return NetworkUtils.filterIPV6(NetworkUtils.getLoopbackAddresses())__                case "site":_                    return NetworkUtils.getSiteLocalAddresses()__                case "site:ipv4":_                    return NetworkUtils.filterIPV4(NetworkUtils.getSiteLocalAddresses())__                case "site:ipv6":_                    return NetworkUtils.filterIPV6(NetworkUtils.getSiteLocalAddresses())__                case "global":_                    return NetworkUtils.getGlobalAddresses()__                case "global:ipv4":_                    return NetworkUtils.filterIPV4(NetworkUtils.getGlobalAddresses())__                case "global:ipv6":_                    return NetworkUtils.filterIPV6(NetworkUtils.getGlobalAddresses())__                default:_                    _                    if (host.endsWith(":ipv4")) {_                        host = host.substring(0, host.length() - 5)__                        return NetworkUtils.filterIPV4(NetworkUtils.getAddressesForInterface(host))__                    } else if (host.endsWith(":ipv6")) {_                        host = host.substring(0, host.length() - 5)__                        return NetworkUtils.filterIPV6(NetworkUtils.getAddressesForInterface(host))__                    } else {_                        return NetworkUtils.getAddressesForInterface(host)__                    }_            }_        }_        return InetAddress.getAllByName(host)__    };resolves,a,single,host,specification;private,inet,address,resolve,internal,string,host,throws,ioexception,if,host,starts,with,host,ends,with,host,starts,with,host,ends,with,host,host,substring,1,host,length,1,if,custom,name,resolvers,null,for,custom,name,resolver,custom,name,resolver,custom,name,resolvers,inet,address,addresses,custom,name,resolver,resolve,if,possible,host,if,addresses,null,return,addresses,switch,host,case,local,return,network,utils,get,loopback,addresses,case,local,ipv4,return,network,utils,filter,ipv4,network,utils,get,loopback,addresses,case,local,ipv6,return,network,utils,filter,ipv6,network,utils,get,loopback,addresses,case,site,return,network,utils,get,site,local,addresses,case,site,ipv4,return,network,utils,filter,ipv4,network,utils,get,site,local,addresses,case,site,ipv6,return,network,utils,filter,ipv6,network,utils,get,site,local,addresses,case,global,return,network,utils,get,global,addresses,case,global,ipv4,return,network,utils,filter,ipv4,network,utils,get,global,addresses,case,global,ipv6,return,network,utils,filter,ipv6,network,utils,get,global,addresses,default,if,host,ends,with,ipv4,host,host,substring,0,host,length,5,return,network,utils,filter,ipv4,network,utils,get,addresses,for,interface,host,else,if,host,ends,with,ipv6,host,host,substring,0,host,length,5,return,network,utils,filter,ipv6,network,utils,get,addresses,for,interface,host,else,return,network,utils,get,addresses,for,interface,host,return,inet,address,get,all,by,name,host
NetworkService -> CustomNameResolver -> InetAddress[] resolveIfPossible(String value) throws IOException_;1524684173;Resolves a custom value handling, return <tt>null</tt> if can't handle it.;InetAddress[] resolveIfPossible(String value) throws IOException_;resolves,a,custom,value,handling,return,tt,null,tt,if,can,t,handle,it;inet,address,resolve,if,possible,string,value,throws,ioexception
NetworkService -> CustomNameResolver -> InetAddress[] resolveIfPossible(String value) throws IOException_;1525334055;Resolves a custom value handling, return {@code null} if can't handle it.;InetAddress[] resolveIfPossible(String value) throws IOException_;resolves,a,custom,value,handling,return,code,null,if,can,t,handle,it;inet,address,resolve,if,possible,string,value,throws,ioexception
NetworkService -> CustomNameResolver -> InetAddress[] resolveIfPossible(String value) throws IOException_;1540583181;Resolves a custom value handling, return {@code null} if can't handle it.;InetAddress[] resolveIfPossible(String value) throws IOException_;resolves,a,custom,value,handling,return,code,null,if,can,t,handle,it;inet,address,resolve,if,possible,string,value,throws,ioexception
NetworkService -> CustomNameResolver -> InetAddress[] resolveIfPossible(String value) throws IOException_;1544823664;Resolves a custom value handling, return {@code null} if can't handle it.;InetAddress[] resolveIfPossible(String value) throws IOException_;resolves,a,custom,value,handling,return,code,null,if,can,t,handle,it;inet,address,resolve,if,possible,string,value,throws,ioexception
NetworkService -> private InetAddress[] resolveInetAddresses(String hosts[]) throws IOException;1524684173;resolves (and deduplicates) host specification;private InetAddress[] resolveInetAddresses(String hosts[]) throws IOException {_        if (hosts.length == 0) {_            throw new IllegalArgumentException("empty host specification")__        }_        _        _        HashSet<InetAddress> set = new HashSet<>()__        for (String host : hosts) {_            set.addAll(Arrays.asList(resolveInternal(host)))__        }_        return set.toArray(new InetAddress[set.size()])__    };resolves,and,deduplicates,host,specification;private,inet,address,resolve,inet,addresses,string,hosts,throws,ioexception,if,hosts,length,0,throw,new,illegal,argument,exception,empty,host,specification,hash,set,inet,address,set,new,hash,set,for,string,host,hosts,set,add,all,arrays,as,list,resolve,internal,host,return,set,to,array,new,inet,address,set,size
NetworkService -> private InetAddress[] resolveInetAddresses(String hosts[]) throws IOException;1525334055;resolves (and deduplicates) host specification;private InetAddress[] resolveInetAddresses(String hosts[]) throws IOException {_        if (hosts.length == 0) {_            throw new IllegalArgumentException("empty host specification")__        }_        _        _        HashSet<InetAddress> set = new HashSet<>()__        for (String host : hosts) {_            set.addAll(Arrays.asList(resolveInternal(host)))__        }_        return set.toArray(new InetAddress[set.size()])__    };resolves,and,deduplicates,host,specification;private,inet,address,resolve,inet,addresses,string,hosts,throws,ioexception,if,hosts,length,0,throw,new,illegal,argument,exception,empty,host,specification,hash,set,inet,address,set,new,hash,set,for,string,host,hosts,set,add,all,arrays,as,list,resolve,internal,host,return,set,to,array,new,inet,address,set,size
NetworkService -> private InetAddress[] resolveInetAddresses(String hosts[]) throws IOException;1540583181;resolves (and deduplicates) host specification;private InetAddress[] resolveInetAddresses(String hosts[]) throws IOException {_        if (hosts.length == 0) {_            throw new IllegalArgumentException("empty host specification")__        }_        _        _        HashSet<InetAddress> set = new HashSet<>()__        for (String host : hosts) {_            set.addAll(Arrays.asList(resolveInternal(host)))__        }_        return set.toArray(new InetAddress[set.size()])__    };resolves,and,deduplicates,host,specification;private,inet,address,resolve,inet,addresses,string,hosts,throws,ioexception,if,hosts,length,0,throw,new,illegal,argument,exception,empty,host,specification,hash,set,inet,address,set,new,hash,set,for,string,host,hosts,set,add,all,arrays,as,list,resolve,internal,host,return,set,to,array,new,inet,address,set,size
NetworkService -> private InetAddress[] resolveInetAddresses(String hosts[]) throws IOException;1544823664;resolves (and deduplicates) host specification;private InetAddress[] resolveInetAddresses(String hosts[]) throws IOException {_        if (hosts.length == 0) {_            throw new IllegalArgumentException("empty host specification")__        }_        _        _        HashSet<InetAddress> set = new HashSet<>()__        for (String host : hosts) {_            set.addAll(Arrays.asList(resolveInternal(host)))__        }_        return set.toArray(new InetAddress[set.size()])__    };resolves,and,deduplicates,host,specification;private,inet,address,resolve,inet,addresses,string,hosts,throws,ioexception,if,hosts,length,0,throw,new,illegal,argument,exception,empty,host,specification,hash,set,inet,address,set,new,hash,set,for,string,host,hosts,set,add,all,arrays,as,list,resolve,internal,host,return,set,to,array,new,inet,address,set,size
