commented;modifiers;parameterAmount;loc;comment;code
true;;0;1;/**  * Resolves the default value if possible. If not, return {@code null}.  */ ;/**  * Resolves the default value if possible. If not, return {@code null}.  */ InetAddress[] resolveDefault().
true;;1;1;/**  * Resolves a custom value handling, return {@code null} if can't handle it.  */ ;/**  * Resolves a custom value handling, return {@code null} if can't handle it.  */ InetAddress[] resolveIfPossible(String value) throws IOException.
true;public;1;28;/**  * Resolves {@code bindHosts} to a list of internet addresses. The list will  * not contain duplicate addresses.  *  * @param bindHosts list of hosts to bind to. this may contain special pseudo-hostnames  *                  such as _local_ (see the documentation). if it is null, it will fall back to _local_  *  * @return unique set of internet addresses  */ ;/**  * Resolves {@code bindHosts} to a list of internet addresses. The list will  * not contain duplicate addresses.  *  * @param bindHosts list of hosts to bind to. this may contain special pseudo-hostnames  *                  such as _local_ (see the documentation). if it is null, it will fall back to _local_  *  * @return unique set of internet addresses  */ public InetAddress[] resolveBindHostAddresses(String[] bindHosts) throws IOException {     if (bindHosts == null || bindHosts.length == 0) {         for (CustomNameResolver customNameResolver : customNameResolvers) {             InetAddress[] addresses = customNameResolver.resolveDefault().             if (addresses != null) {                 return addresses.             }         }         // we know it's not here. get the defaults         bindHosts = new String[] { "_local_" }.     }     InetAddress[] addresses = resolveInetAddresses(bindHosts).     // try to deal with some (mis)configuration     for (InetAddress address : addresses) {         // check if its multicast: flat out mistake         if (address.isMulticastAddress()) {             throw new IllegalArgumentException("bind address: {" + NetworkAddress.format(address) + "} is invalid: multicast address").         }         // check if its a wildcard address: this is only ok if its the only address!         if (address.isAnyLocalAddress() && addresses.length > 1) {             throw new IllegalArgumentException("bind address: {" + NetworkAddress.format(address) + "} is wildcard, but multiple addresses specified: this makes no sense").         }     }     return addresses. }
true;public;1;46;// TODO: needs to be InetAddress[] ;/**  * Resolves {@code publishHosts} to a single publish address. The fact that it returns  * only one address is just a current limitation.  * <p>  * If {@code publishHosts} resolves to more than one address, <b>then one is selected with magic</b>  *  * @param publishHosts list of hosts to publish as. this may contain special pseudo-hostnames  *                     such as _local_ (see the documentation). if it is null, it will fall back to _local_  * @return single internet address  */ // TODO: needs to be InetAddress[] public InetAddress resolvePublishHostAddresses(String[] publishHosts) throws IOException {     if (publishHosts == null || publishHosts.length == 0) {         for (CustomNameResolver customNameResolver : customNameResolvers) {             InetAddress[] addresses = customNameResolver.resolveDefault().             if (addresses != null) {                 return addresses[0].             }         }         // we know it's not here. get the defaults         publishHosts = new String[] { DEFAULT_NETWORK_HOST }.     }     InetAddress[] addresses = resolveInetAddresses(publishHosts).     // 1. single wildcard address, probably set by network.host: expand to all interface addresses.     if (addresses.length == 1 && addresses[0].isAnyLocalAddress()) {         HashSet<InetAddress> all = new HashSet<>(Arrays.asList(NetworkUtils.getAllAddresses())).         addresses = all.toArray(new InetAddress[all.size()]).     }     // 2. try to deal with some (mis)configuration     for (InetAddress address : addresses) {         // check if its multicast: flat out mistake         if (address.isMulticastAddress()) {             throw new IllegalArgumentException("publish address: {" + NetworkAddress.format(address) + "} is invalid: multicast address").         }         // (if it was a single wildcard address, it was replaced by step 1 above)         if (address.isAnyLocalAddress()) {             throw new IllegalArgumentException("publish address: {" + NetworkAddress.format(address) + "} is wildcard, but multiple addresses specified: this makes no sense").         }     }     // don't warn the user, or they will get confused by bind_host vs publish_host etc.     if (addresses.length > 1) {         List<InetAddress> sorted = new ArrayList<>(Arrays.asList(addresses)).         NetworkUtils.sortAddresses(sorted).         addresses = new InetAddress[] { sorted.get(0) }.     }     return addresses[0]. }
true;private;1;12;/**  * resolves (and deduplicates) host specification  */ ;/**  * resolves (and deduplicates) host specification  */ private InetAddress[] resolveInetAddresses(String[] hosts) throws IOException {     if (hosts.length == 0) {         throw new IllegalArgumentException("empty host specification").     }     // deduplicate, in case of resolver misconfiguration     // stuff like https://bugzilla.redhat.com/show_bug.cgi?id=496300     HashSet<InetAddress> set = new HashSet<>().     for (String host : hosts) {         set.addAll(Arrays.asList(resolveInternal(host))).     }     return set.toArray(new InetAddress[set.size()]). }
true;private;1;46;/**  * resolves a single host specification  */ ;/**  * resolves a single host specification  */ private InetAddress[] resolveInternal(String host) throws IOException {     if ((host.startsWith("#") && host.endsWith("#")) || (host.startsWith("_") && host.endsWith("_"))) {         host = host.substring(1, host.length() - 1).         // next check any registered custom resolvers if any         if (customNameResolvers != null) {             for (CustomNameResolver customNameResolver : customNameResolvers) {                 InetAddress[] addresses = customNameResolver.resolveIfPossible(host).                 if (addresses != null) {                     return addresses.                 }             }         }         switch(host) {             case "local":                 return NetworkUtils.getLoopbackAddresses().             case "local:ipv4":                 return NetworkUtils.filterIPV4(NetworkUtils.getLoopbackAddresses()).             case "local:ipv6":                 return NetworkUtils.filterIPV6(NetworkUtils.getLoopbackAddresses()).             case "site":                 return NetworkUtils.getSiteLocalAddresses().             case "site:ipv4":                 return NetworkUtils.filterIPV4(NetworkUtils.getSiteLocalAddresses()).             case "site:ipv6":                 return NetworkUtils.filterIPV6(NetworkUtils.getSiteLocalAddresses()).             case "global":                 return NetworkUtils.getGlobalAddresses().             case "global:ipv4":                 return NetworkUtils.filterIPV4(NetworkUtils.getGlobalAddresses()).             case "global:ipv6":                 return NetworkUtils.filterIPV6(NetworkUtils.getGlobalAddresses()).             default:                 /* an interface specification */                 if (host.endsWith(":ipv4")) {                     host = host.substring(0, host.length() - 5).                     return NetworkUtils.filterIPV4(NetworkUtils.getAddressesForInterface(host)).                 } else if (host.endsWith(":ipv6")) {                     host = host.substring(0, host.length() - 5).                     return NetworkUtils.filterIPV6(NetworkUtils.getAddressesForInterface(host)).                 } else {                     return NetworkUtils.getAddressesForInterface(host).                 }         }     }     return InetAddress.getAllByName(host). }
