commented;modifiers;parameterAmount;loc;comment;code
false;public;1;18;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeString(fieldName).     out.writeGenericValue(points).     geoDistance.writeTo(out).     unit.writeTo(out).     order.writeTo(out).     out.writeOptionalWriteable(sortMode).     out.writeOptionalNamedWriteable(nestedFilter).     out.writeOptionalString(nestedPath).     if (out.getVersion().onOrAfter(Version.V_6_1_0)) {         out.writeOptionalWriteable(nestedSort).     }     validation.writeTo(out).     if (out.getVersion().onOrAfter(Version.V_6_4_0)) {         out.writeBoolean(ignoreUnmapped).     } }
true;public;0;3;/**  * Returns the geo point like field the distance based sort operates on.  */ ;/**  * Returns the geo point like field the distance based sort operates on.  */ public String fieldName() {     return this.fieldName. }
true;public;2;4;/**  * The point to create the range distance facets from.  *  * @param lat latitude.  * @param lon longitude.  */ ;/**  * The point to create the range distance facets from.  *  * @param lat latitude.  * @param lon longitude.  */ public GeoDistanceSortBuilder point(double lat, double lon) {     points.add(new GeoPoint(lat, lon)).     return this. }
true;public;1;4;/**  * The point to create the range distance facets from.  *  * @param points reference points.  */ ;/**  * The point to create the range distance facets from.  *  * @param points reference points.  */ public GeoDistanceSortBuilder points(GeoPoint... points) {     this.points.addAll(Arrays.asList(points)).     return this. }
true;public;0;3;/**  * Returns the points to create the range distance facets from.  */ ;/**  * Returns the points to create the range distance facets from.  */ public GeoPoint[] points() {     return this.points.toArray(new GeoPoint[this.points.size()]). }
true;public;1;4;/**  * The geo distance type used to compute the distance.  */ ;/**  * The geo distance type used to compute the distance.  */ public GeoDistanceSortBuilder geoDistance(GeoDistance geoDistance) {     this.geoDistance = geoDistance.     return this. }
true;public;0;3;/**  * Returns the geo distance type used to compute the distance.  */ ;/**  * Returns the geo distance type used to compute the distance.  */ public GeoDistance geoDistance() {     return this.geoDistance. }
true;public;1;4;/**  * The distance unit to use. Defaults to {@link org.elasticsearch.common.unit.DistanceUnit#METERS}  */ ;/**  * The distance unit to use. Defaults to {@link org.elasticsearch.common.unit.DistanceUnit#METERS}  */ public GeoDistanceSortBuilder unit(DistanceUnit unit) {     this.unit = unit.     return this. }
true;public;0;3;/**  * Returns the distance unit to use. Defaults to {@link org.elasticsearch.common.unit.DistanceUnit#METERS}  */ ;/**  * Returns the distance unit to use. Defaults to {@link org.elasticsearch.common.unit.DistanceUnit#METERS}  */ public DistanceUnit unit() {     return this.unit. }
true;public;1;4;/**  * Sets validation method for this sort builder.  */ ;/**  * Sets validation method for this sort builder.  */ public GeoDistanceSortBuilder validation(GeoValidationMethod method) {     this.validation = method.     return this. }
true;public;0;3;/**  * Returns the validation method to use for this sort builder.  */ ;/**  * Returns the validation method to use for this sort builder.  */ public GeoValidationMethod validation() {     return validation. }
true;public;1;8;/**  * Defines which distance to use for sorting in the case a document contains multiple geo points.  * Possible values: min and max  */ ;/**  * Defines which distance to use for sorting in the case a document contains multiple geo points.  * Possible values: min and max  */ public GeoDistanceSortBuilder sortMode(SortMode sortMode) {     Objects.requireNonNull(sortMode, "sort mode cannot be null").     if (sortMode == SortMode.SUM) {         throw new IllegalArgumentException("sort_mode [sum] isn't supported for sorting by geo distance").     }     this.sortMode = sortMode.     return this. }
true;public;0;3;/**  * Returns which distance to use for sorting in the case a document contains multiple geo points.  */ ;/**  * Returns which distance to use for sorting in the case a document contains multiple geo points.  */ public SortMode sortMode() {     return this.sortMode. }
true;public;1;8;/**  * Sets the nested filter that the nested objects should match with in order to  * be taken into account for sorting.  *  * @deprecated set nested sort with {@link #setNestedSort(NestedSortBuilder)}  *             and retrieve with {@link #getNestedSort()}  */ ;/**  * Sets the nested filter that the nested objects should match with in order to  * be taken into account for sorting.  *  * @deprecated set nested sort with {@link #setNestedSort(NestedSortBuilder)}  *             and retrieve with {@link #getNestedSort()}  */ @Deprecated public GeoDistanceSortBuilder setNestedFilter(QueryBuilder nestedFilter) {     if (this.nestedSort != null) {         throw new IllegalArgumentException("Setting both nested_path/nested_filter and nested not allowed").     }     this.nestedFilter = nestedFilter.     return this. }
true;public;0;4;/**  * Returns the nested filter that the nested objects should match with in order to be taken into account  * for sorting.  * @deprecated set nested sort with {@link #setNestedSort(NestedSortBuilder)}  *             and retrieve with {@link #getNestedSort()}  */ ;/**  * Returns the nested filter that the nested objects should match with in order to be taken into account  * for sorting.  * @deprecated set nested sort with {@link #setNestedSort(NestedSortBuilder)}  *             and retrieve with {@link #getNestedSort()}  */ @Deprecated public QueryBuilder getNestedFilter() {     return this.nestedFilter. }
true;public;1;8;/**  * Sets the nested path if sorting occurs on a field that is inside a nested object. By default when sorting on a  * field inside a nested object, the nearest upper nested object is selected as nested path.  * @deprecated set nested sort with {@link #setNestedSort(NestedSortBuilder)}  *             and retrieve with {@link #getNestedSort()}  */ ;/**  * Sets the nested path if sorting occurs on a field that is inside a nested object. By default when sorting on a  * field inside a nested object, the nearest upper nested object is selected as nested path.  * @deprecated set nested sort with {@link #setNestedSort(NestedSortBuilder)}  *             and retrieve with {@link #getNestedSort()}  */ @Deprecated public GeoDistanceSortBuilder setNestedPath(String nestedPath) {     if (this.nestedSort != null) {         throw new IllegalArgumentException("Setting both nested_path/nested_filter and nested not allowed").     }     this.nestedPath = nestedPath.     return this. }
true;public;0;4;/**  * Returns the nested path if sorting occurs on a field that is inside a nested object. By default when sorting on a  * field inside a nested object, the nearest upper nested object is selected as nested path.  * @deprecated set nested sort with {@link #setNestedSort(NestedSortBuilder)}  *             and retrieve with {@link #getNestedSort()}  */ ;/**  * Returns the nested path if sorting occurs on a field that is inside a nested object. By default when sorting on a  * field inside a nested object, the nearest upper nested object is selected as nested path.  * @deprecated set nested sort with {@link #setNestedSort(NestedSortBuilder)}  *             and retrieve with {@link #getNestedSort()}  */ @Deprecated public String getNestedPath() {     return this.nestedPath. }
true;public;0;3;/**  * Returns the {@link NestedSortBuilder}  */ ;/**  * Returns the {@link NestedSortBuilder}  */ public NestedSortBuilder getNestedSort() {     return this.nestedSort. }
true;public;1;7;/**  * Sets the {@link NestedSortBuilder} to be used for fields that are inside a nested  * object. The {@link NestedSortBuilder} takes a `path` argument and an optional  * nested filter that the nested objects should match with in  * order to be taken into account for sorting.  */ ;/**  * Sets the {@link NestedSortBuilder} to be used for fields that are inside a nested  * object. The {@link NestedSortBuilder} takes a `path` argument and an optional  * nested filter that the nested objects should match with in  * order to be taken into account for sorting.  */ public GeoDistanceSortBuilder setNestedSort(final NestedSortBuilder nestedSort) {     if (this.nestedFilter != null || this.nestedPath != null) {         throw new IllegalArgumentException("Setting both nested_path/nested_filter and nested not allowed").     }     this.nestedSort = nestedSort.     return this. }
true;public;0;3;/**  * Returns true if unmapped geo fields should be treated as located at an infinite distance  */ ;/**  * Returns true if unmapped geo fields should be treated as located at an infinite distance  */ public boolean ignoreUnmapped() {     return ignoreUnmapped. }
false;public;1;4;;public GeoDistanceSortBuilder ignoreUnmapped(boolean ignoreUnmapped) {     this.ignoreUnmapped = ignoreUnmapped.     return this. }
false;public;2;35;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     builder.startObject(NAME).     builder.startArray(fieldName).     for (GeoPoint point : points) {         builder.value(point).     }     builder.endArray().     builder.field(UNIT_FIELD.getPreferredName(), unit).     builder.field(DISTANCE_TYPE_FIELD.getPreferredName(), geoDistance.name().toLowerCase(Locale.ROOT)).     builder.field(ORDER_FIELD.getPreferredName(), order).     if (sortMode != null) {         builder.field(SORTMODE_FIELD.getPreferredName(), sortMode).     }     if (nestedPath != null) {         builder.field(NESTED_PATH_FIELD.getPreferredName(), nestedPath).     }     if (nestedFilter != null) {         builder.field(NESTED_FILTER_FIELD.getPreferredName(), nestedFilter, params).     }     if (nestedSort != null) {         builder.field(NESTED_FIELD.getPreferredName(), nestedSort).     }     builder.field(VALIDATION_METHOD_FIELD.getPreferredName(), validation).     builder.field(IGNORE_UNMAPPED.getPreferredName(), ignoreUnmapped).     builder.endObject().     builder.endObject().     return builder. }
false;public;0;4;;@Override public String getWriteableName() {     return NAME. }
false;public;1;23;;@Override public boolean equals(Object object) {     if (this == object) {         return true.     }     if (object == null || getClass() != object.getClass()) {         return false.     }     GeoDistanceSortBuilder other = (GeoDistanceSortBuilder) object.     return Objects.equals(fieldName, other.fieldName) && Objects.deepEquals(points, other.points) && Objects.equals(geoDistance, other.geoDistance) && Objects.equals(unit, other.unit) && Objects.equals(sortMode, other.sortMode) && Objects.equals(order, other.order) && Objects.equals(nestedFilter, other.nestedFilter) && Objects.equals(nestedPath, other.nestedPath) && Objects.equals(validation, other.validation) && Objects.equals(nestedSort, other.nestedSort) && ignoreUnmapped == other.ignoreUnmapped. }
false;public;0;6;;@Override public int hashCode() {     return Objects.hash(this.fieldName, this.points, this.geoDistance, this.unit, this.sortMode, this.order, this.nestedFilter, this.nestedPath, this.validation, this.nestedSort, this.ignoreUnmapped). }
true;public,static;2;106;/**  * Creates a new {@link GeoDistanceSortBuilder} from the query held by the {@link XContentParser} in  * {@link org.elasticsearch.common.xcontent.XContent} format.  *  * @param parser the input parser. The state on the parser contained in this context will be changed as a  *                side effect of this method call  * @param elementName in some sort syntax variations the field name precedes the xContent object that specifies  *                    further parameters, e.g. in '{ "foo": { "order" : "asc"} }'. When parsing the inner object,  *                    the field name can be passed in via this argument  */ ;/**  * Creates a new {@link GeoDistanceSortBuilder} from the query held by the {@link XContentParser} in  * {@link org.elasticsearch.common.xcontent.XContent} format.  *  * @param parser the input parser. The state on the parser contained in this context will be changed as a  *                side effect of this method call  * @param elementName in some sort syntax variations the field name precedes the xContent object that specifies  *                    further parameters, e.g. in '{ "foo": { "order" : "asc"} }'. When parsing the inner object,  *                    the field name can be passed in via this argument  */ public static GeoDistanceSortBuilder fromXContent(XContentParser parser, String elementName) throws IOException {     String fieldName = null.     List<GeoPoint> geoPoints = new ArrayList<>().     DistanceUnit unit = DistanceUnit.DEFAULT.     GeoDistance geoDistance = GeoDistance.ARC.     SortOrder order = SortOrder.ASC.     SortMode sortMode = null.     QueryBuilder nestedFilter = null.     String nestedPath = null.     NestedSortBuilder nestedSort = null.     GeoValidationMethod validation = null.     boolean ignoreUnmapped = false.     XContentParser.Token token.     String currentName = parser.currentName().     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentName = parser.currentName().         } else if (token == XContentParser.Token.START_ARRAY) {             parseGeoPoints(parser, geoPoints).             fieldName = currentName.         } else if (token == XContentParser.Token.START_OBJECT) {             if (NESTED_FILTER_FIELD.match(currentName, parser.getDeprecationHandler())) {                 deprecationLogger.deprecated("[nested_filter] has been deprecated in favour of the [nested] parameter").                 nestedFilter = parseInnerQueryBuilder(parser).             } else if (NESTED_FIELD.match(currentName, parser.getDeprecationHandler())) {                 nestedSort = NestedSortBuilder.fromXContent(parser).             } else {                 // the json in the format of -> field : { lat : 30, lon : 12 }                 if (fieldName != null && fieldName.equals(currentName) == false) {                     throw new ParsingException(parser.getTokenLocation(), "Trying to reset fieldName to [{}], already set to [{}].", currentName, fieldName).                 }                 fieldName = currentName.                 GeoPoint point = new GeoPoint().                 GeoUtils.parseGeoPoint(parser, point).                 geoPoints.add(point).             }         } else if (token.isValue()) {             if (ORDER_FIELD.match(currentName, parser.getDeprecationHandler())) {                 order = SortOrder.fromString(parser.text()).             } else if (UNIT_FIELD.match(currentName, parser.getDeprecationHandler())) {                 unit = DistanceUnit.fromString(parser.text()).             } else if (DISTANCE_TYPE_FIELD.match(currentName, parser.getDeprecationHandler())) {                 geoDistance = GeoDistance.fromString(parser.text()).             } else if (VALIDATION_METHOD_FIELD.match(currentName, parser.getDeprecationHandler())) {                 validation = GeoValidationMethod.fromString(parser.text()).             } else if (SORTMODE_FIELD.match(currentName, parser.getDeprecationHandler())) {                 sortMode = SortMode.fromString(parser.text()).             } else if (NESTED_PATH_FIELD.match(currentName, parser.getDeprecationHandler())) {                 deprecationLogger.deprecated("[nested_path] has been deprecated in favour of the [nested] parameter").                 nestedPath = parser.text().             } else if (IGNORE_UNMAPPED.match(currentName, parser.getDeprecationHandler())) {                 ignoreUnmapped = parser.booleanValue().             } else if (token == Token.VALUE_STRING) {                 if (fieldName != null && fieldName.equals(currentName) == false) {                     throw new ParsingException(parser.getTokenLocation(), "Trying to reset fieldName to [{}], already set to [{}].", currentName, fieldName).                 }                 GeoPoint point = new GeoPoint().                 point.resetFromString(parser.text()).                 geoPoints.add(point).                 fieldName = currentName.             } else if (fieldName.equals(currentName)) {                 throw new ParsingException(parser.getTokenLocation(), "Only geohashes of type string supported for field [{}]", currentName).             } else {                 throw new ParsingException(parser.getTokenLocation(), "[{}] does not support [{}]", NAME, currentName).             }         }     }     GeoDistanceSortBuilder result = new GeoDistanceSortBuilder(fieldName, geoPoints.toArray(new GeoPoint[geoPoints.size()])).     result.geoDistance(geoDistance).     result.unit(unit).     result.order(order).     if (sortMode != null) {         result.sortMode(sortMode).     }     if (nestedFilter != null) {         result.setNestedFilter(nestedFilter).     }     result.setNestedPath(nestedPath).     if (nestedSort != null) {         result.setNestedSort(nestedSort).     }     if (validation != null) {         result.validation(validation).     }     result.ignoreUnmapped(ignoreUnmapped).     return result. }
false;public;0;4;;@Override public SortField.Type reducedType() {     return SortField.Type.DOUBLE. }
false;protected;2;18;;@Override protected NumericDocValues getNumericDocValues(LeafReaderContext context, String field) throws IOException {     final MultiGeoPointValues geoPointValues = geoIndexFieldData.load(context).getGeoPointValues().     final SortedNumericDoubleValues distanceValues = GeoUtils.distanceValues(geoDistance, unit, geoPointValues, localPoints).     final NumericDoubleValues selectedValues.     if (nested == null) {         selectedValues = FieldData.replaceMissing(finalSortMode.select(distanceValues), Double.POSITIVE_INFINITY).     } else {         final BitSet rootDocs = nested.rootDocs(context).         final DocIdSetIterator innerDocs = nested.innerDocs(context).         final int maxChildren = nested.getNestedSort() != null ? nested.getNestedSort().getMaxChildren() : Integer.MAX_VALUE.         selectedValues = finalSortMode.select(distanceValues, Double.POSITIVE_INFINITY, rootDocs, innerDocs, context.reader().maxDoc(), maxChildren).     }     return selectedValues.getRawDoubleValues(). }
false;public;4;23;;@Override public FieldComparator<?> newComparator(String fieldname, int numHits, int sortPos, boolean reversed) {     return new FieldComparator.DoubleComparator(numHits, null, null) {          @Override         protected NumericDocValues getNumericDocValues(LeafReaderContext context, String field) throws IOException {             final MultiGeoPointValues geoPointValues = geoIndexFieldData.load(context).getGeoPointValues().             final SortedNumericDoubleValues distanceValues = GeoUtils.distanceValues(geoDistance, unit, geoPointValues, localPoints).             final NumericDoubleValues selectedValues.             if (nested == null) {                 selectedValues = FieldData.replaceMissing(finalSortMode.select(distanceValues), Double.POSITIVE_INFINITY).             } else {                 final BitSet rootDocs = nested.rootDocs(context).                 final DocIdSetIterator innerDocs = nested.innerDocs(context).                 final int maxChildren = nested.getNestedSort() != null ? nested.getNestedSort().getMaxChildren() : Integer.MAX_VALUE.                 selectedValues = finalSortMode.select(distanceValues, Double.POSITIVE_INFINITY, rootDocs, innerDocs, context.reader().maxDoc(), maxChildren).             }             return selectedValues.getRawDoubleValues().         }     }. }
false;public;1;110;;@Override public SortFieldAndFormat build(QueryShardContext context) throws IOException {     // validation was not available prior to 2.x, so to support bwc percolation queries we only ignore_malformed     // on 2.x created indexes     GeoPoint[] localPoints = points.toArray(new GeoPoint[points.size()]).     if (GeoValidationMethod.isIgnoreMalformed(validation) == false) {         for (GeoPoint point : localPoints) {             if (GeoUtils.isValidLatitude(point.lat()) == false) {                 throw new ElasticsearchParseException("illegal latitude value [{}] for [GeoDistanceSort] for field [{}].", point.lat(), fieldName).             }             if (GeoUtils.isValidLongitude(point.lon()) == false) {                 throw new ElasticsearchParseException("illegal longitude value [{}] for [GeoDistanceSort] for field [{}].", point.lon(), fieldName).             }         }     }     if (GeoValidationMethod.isCoerce(validation)) {         for (GeoPoint point : localPoints) {             GeoUtils.normalizePoint(point, true, true).         }     }     boolean reverse = (order == SortOrder.DESC).     final MultiValueMode finalSortMode.     if (sortMode == null) {         finalSortMode = reverse ? MultiValueMode.MAX : MultiValueMode.MIN.     } else {         finalSortMode = MultiValueMode.fromString(sortMode.toString()).     }     MappedFieldType fieldType = context.fieldMapper(fieldName).     if (fieldType == null) {         if (ignoreUnmapped) {             fieldType = context.getMapperService().unmappedFieldType("geo_point").         } else {             throw new IllegalArgumentException("failed to find mapper for [" + fieldName + "] for geo distance based sort").         }     }     final IndexGeoPointFieldData geoIndexFieldData = context.getForField(fieldType).     final Nested nested.     if (nestedSort != null) {         if (context.indexVersionCreated().before(Version.V_6_5_0) && nestedSort.getMaxChildren() != Integer.MAX_VALUE) {             throw new QueryShardException(context, "max_children is only supported on v6.5.0 or higher").         }         if (nestedSort.getNestedSort() != null && nestedSort.getMaxChildren() != Integer.MAX_VALUE) {             throw new QueryShardException(context, "max_children is only supported on last level of nested sort").         }         // new nested sorts takes priority         nested = resolveNested(context, nestedSort).     } else {         nested = resolveNested(context, nestedPath, nestedFilter).     }     if (// only works with 5.x geo_point     geoIndexFieldData.getClass() == LatLonPointDVIndexFieldData.class && nested == null && // LatLonDocValuesField internally picks the closest point     finalSortMode == MultiValueMode.MIN && unit == DistanceUnit.METERS && reverse == false && localPoints.length == 1) {         return new SortFieldAndFormat(LatLonDocValuesField.newDistanceSort(fieldName, localPoints[0].lat(), localPoints[0].lon()), DocValueFormat.RAW).     }     IndexFieldData.XFieldComparatorSource geoDistanceComparatorSource = new IndexFieldData.XFieldComparatorSource(null, finalSortMode, nested) {          @Override         public SortField.Type reducedType() {             return SortField.Type.DOUBLE.         }          @Override         public FieldComparator<?> newComparator(String fieldname, int numHits, int sortPos, boolean reversed) {             return new FieldComparator.DoubleComparator(numHits, null, null) {                  @Override                 protected NumericDocValues getNumericDocValues(LeafReaderContext context, String field) throws IOException {                     final MultiGeoPointValues geoPointValues = geoIndexFieldData.load(context).getGeoPointValues().                     final SortedNumericDoubleValues distanceValues = GeoUtils.distanceValues(geoDistance, unit, geoPointValues, localPoints).                     final NumericDoubleValues selectedValues.                     if (nested == null) {                         selectedValues = FieldData.replaceMissing(finalSortMode.select(distanceValues), Double.POSITIVE_INFINITY).                     } else {                         final BitSet rootDocs = nested.rootDocs(context).                         final DocIdSetIterator innerDocs = nested.innerDocs(context).                         final int maxChildren = nested.getNestedSort() != null ? nested.getNestedSort().getMaxChildren() : Integer.MAX_VALUE.                         selectedValues = finalSortMode.select(distanceValues, Double.POSITIVE_INFINITY, rootDocs, innerDocs, context.reader().maxDoc(), maxChildren).                     }                     return selectedValues.getRawDoubleValues().                 }             }.         }     }.     return new SortFieldAndFormat(new SortField(fieldName, geoDistanceComparatorSource, reverse), DocValueFormat.RAW). }
false;static;2;25;;static void parseGeoPoints(XContentParser parser, List<GeoPoint> geoPoints) throws IOException {     while (!parser.nextToken().equals(XContentParser.Token.END_ARRAY)) {         if (parser.currentToken() == XContentParser.Token.VALUE_NUMBER) {             // we might get here if the geo point is " number, number] " and the parser already moved over the             // opening bracket in this case we cannot use GeoUtils.parseGeoPoint(..) because this expects an opening             // bracket             double lon = parser.doubleValue().             parser.nextToken().             if (!parser.currentToken().equals(XContentParser.Token.VALUE_NUMBER)) {                 throw new ElasticsearchParseException("geo point parsing: expected second number but got [{}] instead", parser.currentToken()).             }             double lat = parser.doubleValue().             GeoPoint point = new GeoPoint().             point.reset(lat, lon).             geoPoints.add(point).         } else {             GeoPoint point = new GeoPoint().             GeoUtils.parseGeoPoint(parser, point).             geoPoints.add(point).         }     } }
false;public;1;19;;@Override public GeoDistanceSortBuilder rewrite(QueryRewriteContext ctx) throws IOException {     if (nestedFilter == null && nestedSort == null) {         return this.     }     if (nestedFilter != null) {         QueryBuilder rewrite = nestedFilter.rewrite(ctx).         if (nestedFilter == rewrite) {             return this.         }         return new GeoDistanceSortBuilder(this).setNestedFilter(rewrite).     } else {         NestedSortBuilder rewrite = nestedSort.rewrite(ctx).         if (nestedSort == rewrite) {             return this.         }         return new GeoDistanceSortBuilder(this).setNestedSort(rewrite).     } }
