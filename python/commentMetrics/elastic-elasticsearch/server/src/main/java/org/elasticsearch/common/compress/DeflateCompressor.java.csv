commented;modifiers;parameterAmount;loc;comment;code
false;public;1;12;;@Override public boolean isCompressed(BytesReference bytes) {     if (bytes.length() < HEADER.length) {         return false.     }     for (int i = 0. i < HEADER.length. ++i) {         if (bytes.get(i) != HEADER[i]) {             return false.         }     }     return true. }
false;public;0;10;;public void close() throws IOException {     try {         super.close().     } finally {         if (closed.compareAndSet(false, true)) {             // important to release native memory             inflater.end().         }     } }
false;public;1;34;;@Override public StreamInput streamInput(StreamInput in) throws IOException {     final byte[] headerBytes = new byte[HEADER.length].     int len = 0.     while (len < headerBytes.length) {         final int read = in.read(headerBytes, len, headerBytes.length - len).         if (read == -1) {             break.         }         len += read.     }     if (len != HEADER.length || Arrays.equals(headerBytes, HEADER) == false) {         throw new IllegalArgumentException("Input stream is not compressed with DEFLATE!").     }     final boolean nowrap = true.     final Inflater inflater = new Inflater(nowrap).     InputStream decompressedIn = new InflaterInputStream(in, inflater, BUFFER_SIZE).     decompressedIn = new BufferedInputStream(decompressedIn, BUFFER_SIZE).     return new InputStreamStreamInput(decompressedIn) {          final AtomicBoolean closed = new AtomicBoolean(false).          public void close() throws IOException {             try {                 super.close().             } finally {                 if (closed.compareAndSet(false, true)) {                     // important to release native memory                     inflater.end().                 }             }         }     }. }
false;public;0;10;;public void close() throws IOException {     try {         super.close().     } finally {         if (closed.compareAndSet(false, true)) {             // important to release native memory             deflater.end().         }     } }
false;public;1;23;;@Override public StreamOutput streamOutput(StreamOutput out) throws IOException {     out.writeBytes(HEADER).     final boolean nowrap = true.     final Deflater deflater = new Deflater(LEVEL, nowrap).     final boolean syncFlush = true.     DeflaterOutputStream deflaterOutputStream = new DeflaterOutputStream(out, deflater, BUFFER_SIZE, syncFlush).     OutputStream compressedOut = new BufferedOutputStream(deflaterOutputStream, BUFFER_SIZE).     return new OutputStreamStreamOutput(compressedOut) {          final AtomicBoolean closed = new AtomicBoolean(false).          public void close() throws IOException {             try {                 super.close().             } finally {                 if (closed.compareAndSet(false, true)) {                     // important to release native memory                     deflater.end().                 }             }         }     }. }
