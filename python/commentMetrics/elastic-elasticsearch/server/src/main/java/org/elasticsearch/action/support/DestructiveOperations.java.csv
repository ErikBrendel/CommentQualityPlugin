commented;modifiers;parameterAmount;loc;comment;code
false;private;1;3;;private void setDestructiveRequiresName(boolean destructiveRequiresName) {     this.destructiveRequiresName = destructiveRequiresName. }
true;public;1;19;/**  * Fail if there is wildcard usage in indices and the named is required for destructive operations.  */ ;/**  * Fail if there is wildcard usage in indices and the named is required for destructive operations.  */ public void failDestructive(String[] aliasesOrIndices) {     if (!destructiveRequiresName) {         return.     }     if (aliasesOrIndices == null || aliasesOrIndices.length == 0) {         throw new IllegalArgumentException("Wildcard expressions or all indices are not allowed").     } else if (aliasesOrIndices.length == 1) {         if (hasWildcardUsage(aliasesOrIndices[0])) {             throw new IllegalArgumentException("Wildcard expressions or all indices are not allowed").         }     } else {         for (String aliasesOrIndex : aliasesOrIndices) {             if (hasWildcardUsage(aliasesOrIndex)) {                 throw new IllegalArgumentException("Wildcard expressions or all indices are not allowed").             }         }     } }
false;private,static;1;3;;private static boolean hasWildcardUsage(String aliasOrIndex) {     return "_all".equals(aliasOrIndex) || aliasOrIndex.indexOf('*') != -1. }
