# id;timestamp;commentText;codeText;commentWords;codeWords
MetaDataIndexStateService -> static ClusterState addIndexClosedBlocks(final Index[] indices, final Map<Index, ClusterBlock> blockedIndices,                                              final ClusterState currentState);1547030937;Step 1 - Start closing indices by adding a write block__This step builds the list of indices to close (the ones explicitly requested that are not in CLOSE state) and adds a unique cluster_block (or reuses an existing one) to every index to close in the cluster state. After the cluster state is published, the shards_should start to reject writing operations and we can proceed with step 2.;static ClusterState addIndexClosedBlocks(final Index[] indices, final Map<Index, ClusterBlock> blockedIndices,_                                             final ClusterState currentState) {_        final MetaData.Builder metadata = MetaData.builder(currentState.metaData())___        final Set<IndexMetaData> indicesToClose = new HashSet<>()__        for (Index index : indices) {_            final IndexMetaData indexMetaData = metadata.getSafe(index)__            if (indexMetaData.getState() != IndexMetaData.State.CLOSE) {_                indicesToClose.add(indexMetaData)__            } else {_                logger.debug("index {} is already closed, ignoring", index)__                assert currentState.blocks().hasIndexBlock(index.getName(), INDEX_CLOSED_BLOCK)__            }_        }__        if (indicesToClose.isEmpty()) {_            return currentState__        }__        _        RestoreService.checkIndexClosing(currentState, indicesToClose)__        _        SnapshotsService.checkIndexClosing(currentState, indicesToClose)___        _        _        final boolean useDirectClose = currentState.nodes().getMinNodeVersion().before(Version.V_7_0_0)___        final ClusterBlocks.Builder blocks = ClusterBlocks.builder().blocks(currentState.blocks())__        final RoutingTable.Builder routingTable = RoutingTable.builder(currentState.routingTable())___        for (IndexMetaData indexToClose : indicesToClose) {_            final Index index = indexToClose.getIndex()___            ClusterBlock indexBlock = null__            final Set<ClusterBlock> clusterBlocks = currentState.blocks().indices().get(index.getName())__            if (clusterBlocks != null) {_                for (ClusterBlock clusterBlock : clusterBlocks) {_                    if (clusterBlock.id() == INDEX_CLOSED_BLOCK_ID) {_                        _                        indexBlock = clusterBlock__                        break__                    }_                }_            }_            if (useDirectClose) {_                logger.debug("closing index {} directly", index)__                metadata.put(IndexMetaData.builder(indexToClose).state(IndexMetaData.State.CLOSE))_ _                blocks.removeIndexBlockWithId(index.getName(), INDEX_CLOSED_BLOCK_ID)__                routingTable.remove(index.getName())__                indexBlock = INDEX_CLOSED_BLOCK__            } else {_                if (indexBlock == null) {_                    _                    indexBlock = createIndexClosingBlock()__                }_                assert Strings.hasLength(indexBlock.uuid()) : "Closing block should have a UUID"__            }_            blocks.addIndexBlock(index.getName(), indexBlock)__            blockedIndices.put(index, indexBlock)__        }__        logger.info(() -> new ParameterizedMessage("closing indices {}",_            blockedIndices.keySet().stream().map(Object::toString).collect(Collectors.joining(","))))__        return ClusterState.builder(currentState).blocks(blocks).metaData(metadata).routingTable(routingTable.build()).build()__    };step,1,start,closing,indices,by,adding,a,write,block,this,step,builds,the,list,of,indices,to,close,the,ones,explicitly,requested,that,are,not,in,close,state,and,adds,a,unique,cluster,block,or,reuses,an,existing,one,to,every,index,to,close,in,the,cluster,state,after,the,cluster,state,is,published,the,shards,should,start,to,reject,writing,operations,and,we,can,proceed,with,step,2;static,cluster,state,add,index,closed,blocks,final,index,indices,final,map,index,cluster,block,blocked,indices,final,cluster,state,current,state,final,meta,data,builder,metadata,meta,data,builder,current,state,meta,data,final,set,index,meta,data,indices,to,close,new,hash,set,for,index,index,indices,final,index,meta,data,index,meta,data,metadata,get,safe,index,if,index,meta,data,get,state,index,meta,data,state,close,indices,to,close,add,index,meta,data,else,logger,debug,index,is,already,closed,ignoring,index,assert,current,state,blocks,has,index,block,index,get,name,if,indices,to,close,is,empty,return,current,state,restore,service,check,index,closing,current,state,indices,to,close,snapshots,service,check,index,closing,current,state,indices,to,close,final,boolean,use,direct,close,current,state,nodes,get,min,node,version,before,version,final,cluster,blocks,builder,blocks,cluster,blocks,builder,blocks,current,state,blocks,final,routing,table,builder,routing,table,routing,table,builder,current,state,routing,table,for,index,meta,data,index,to,close,indices,to,close,final,index,index,index,to,close,get,index,cluster,block,index,block,null,final,set,cluster,block,cluster,blocks,current,state,blocks,indices,get,index,get,name,if,cluster,blocks,null,for,cluster,block,cluster,block,cluster,blocks,if,cluster,block,id,index,block,cluster,block,break,if,use,direct,close,logger,debug,closing,index,directly,index,metadata,put,index,meta,data,builder,index,to,close,state,index,meta,data,state,close,blocks,remove,index,block,with,id,index,get,name,routing,table,remove,index,get,name,index,block,else,if,index,block,null,index,block,create,index,closing,block,assert,strings,has,length,index,block,uuid,closing,block,should,have,a,uuid,blocks,add,index,block,index,get,name,index,block,blocked,indices,put,index,index,block,logger,info,new,parameterized,message,closing,indices,blocked,indices,key,set,stream,map,object,to,string,collect,collectors,joining,return,cluster,state,builder,current,state,blocks,blocks,meta,data,metadata,routing,table,routing,table,build,build
MetaDataIndexStateService -> static ClusterState addIndexClosedBlocks(final Index[] indices, final Map<Index, ClusterBlock> blockedIndices,                                              final ClusterState currentState);1547467995;Step 1 - Start closing indices by adding a write block__This step builds the list of indices to close (the ones explicitly requested that are not in CLOSE state) and adds a unique cluster_block (or reuses an existing one) to every index to close in the cluster state. After the cluster state is published, the shards_should start to reject writing operations and we can proceed with step 2.;static ClusterState addIndexClosedBlocks(final Index[] indices, final Map<Index, ClusterBlock> blockedIndices,_                                             final ClusterState currentState) {_        final MetaData.Builder metadata = MetaData.builder(currentState.metaData())___        final Set<IndexMetaData> indicesToClose = new HashSet<>()__        for (Index index : indices) {_            final IndexMetaData indexMetaData = metadata.getSafe(index)__            if (indexMetaData.getState() != IndexMetaData.State.CLOSE) {_                indicesToClose.add(indexMetaData)__            } else {_                logger.debug("index {} is already closed, ignoring", index)__                assert currentState.blocks().hasIndexBlock(index.getName(), INDEX_CLOSED_BLOCK)__            }_        }__        if (indicesToClose.isEmpty()) {_            return currentState__        }__        _        RestoreService.checkIndexClosing(currentState, indicesToClose)__        _        SnapshotsService.checkIndexClosing(currentState, indicesToClose)___        _        _        final boolean useDirectClose = currentState.nodes().getMinNodeVersion().before(Version.V_6_7_0)___        final ClusterBlocks.Builder blocks = ClusterBlocks.builder().blocks(currentState.blocks())__        final RoutingTable.Builder routingTable = RoutingTable.builder(currentState.routingTable())___        for (IndexMetaData indexToClose : indicesToClose) {_            final Index index = indexToClose.getIndex()___            ClusterBlock indexBlock = null__            final Set<ClusterBlock> clusterBlocks = currentState.blocks().indices().get(index.getName())__            if (clusterBlocks != null) {_                for (ClusterBlock clusterBlock : clusterBlocks) {_                    if (clusterBlock.id() == INDEX_CLOSED_BLOCK_ID) {_                        _                        indexBlock = clusterBlock__                        break__                    }_                }_            }_            if (useDirectClose) {_                logger.debug("closing index {} directly", index)__                metadata.put(IndexMetaData.builder(indexToClose).state(IndexMetaData.State.CLOSE))_ _                blocks.removeIndexBlockWithId(index.getName(), INDEX_CLOSED_BLOCK_ID)__                routingTable.remove(index.getName())__                indexBlock = INDEX_CLOSED_BLOCK__            } else {_                if (indexBlock == null) {_                    _                    indexBlock = createIndexClosingBlock()__                }_                assert Strings.hasLength(indexBlock.uuid()) : "Closing block should have a UUID"__            }_            blocks.addIndexBlock(index.getName(), indexBlock)__            blockedIndices.put(index, indexBlock)__        }__        logger.info(() -> new ParameterizedMessage("closing indices {}",_            blockedIndices.keySet().stream().map(Object::toString).collect(Collectors.joining(","))))__        return ClusterState.builder(currentState).blocks(blocks).metaData(metadata).routingTable(routingTable.build()).build()__    };step,1,start,closing,indices,by,adding,a,write,block,this,step,builds,the,list,of,indices,to,close,the,ones,explicitly,requested,that,are,not,in,close,state,and,adds,a,unique,cluster,block,or,reuses,an,existing,one,to,every,index,to,close,in,the,cluster,state,after,the,cluster,state,is,published,the,shards,should,start,to,reject,writing,operations,and,we,can,proceed,with,step,2;static,cluster,state,add,index,closed,blocks,final,index,indices,final,map,index,cluster,block,blocked,indices,final,cluster,state,current,state,final,meta,data,builder,metadata,meta,data,builder,current,state,meta,data,final,set,index,meta,data,indices,to,close,new,hash,set,for,index,index,indices,final,index,meta,data,index,meta,data,metadata,get,safe,index,if,index,meta,data,get,state,index,meta,data,state,close,indices,to,close,add,index,meta,data,else,logger,debug,index,is,already,closed,ignoring,index,assert,current,state,blocks,has,index,block,index,get,name,if,indices,to,close,is,empty,return,current,state,restore,service,check,index,closing,current,state,indices,to,close,snapshots,service,check,index,closing,current,state,indices,to,close,final,boolean,use,direct,close,current,state,nodes,get,min,node,version,before,version,final,cluster,blocks,builder,blocks,cluster,blocks,builder,blocks,current,state,blocks,final,routing,table,builder,routing,table,routing,table,builder,current,state,routing,table,for,index,meta,data,index,to,close,indices,to,close,final,index,index,index,to,close,get,index,cluster,block,index,block,null,final,set,cluster,block,cluster,blocks,current,state,blocks,indices,get,index,get,name,if,cluster,blocks,null,for,cluster,block,cluster,block,cluster,blocks,if,cluster,block,id,index,block,cluster,block,break,if,use,direct,close,logger,debug,closing,index,directly,index,metadata,put,index,meta,data,builder,index,to,close,state,index,meta,data,state,close,blocks,remove,index,block,with,id,index,get,name,routing,table,remove,index,get,name,index,block,else,if,index,block,null,index,block,create,index,closing,block,assert,strings,has,length,index,block,uuid,closing,block,should,have,a,uuid,blocks,add,index,block,index,get,name,index,block,blocked,indices,put,index,index,block,logger,info,new,parameterized,message,closing,indices,blocked,indices,key,set,stream,map,object,to,string,collect,collectors,joining,return,cluster,state,builder,current,state,blocks,blocks,meta,data,metadata,routing,table,routing,table,build,build
MetaDataIndexStateService -> public static ClusterBlock createIndexClosingBlock();1547030937;@return Generates a {@link ClusterBlock} that blocks read and write operations on soon-to-be-closed indices. The_cluster block is generated with the id value equals to {@link #INDEX_CLOSED_BLOCK_ID} and a unique UUID.;public static ClusterBlock createIndexClosingBlock() {_        return new ClusterBlock(INDEX_CLOSED_BLOCK_ID, UUIDs.randomBase64UUID(), "index preparing to close. Reopen the index to allow " +_            "writes again or retry closing the index to fully close the index.", false, false, false, RestStatus.FORBIDDEN,_            EnumSet.of(ClusterBlockLevel.WRITE))__    };return,generates,a,link,cluster,block,that,blocks,read,and,write,operations,on,soon,to,be,closed,indices,the,cluster,block,is,generated,with,the,id,value,equals,to,link,and,a,unique,uuid;public,static,cluster,block,create,index,closing,block,return,new,cluster,block,uuids,random,base64uuid,index,preparing,to,close,reopen,the,index,to,allow,writes,again,or,retry,closing,the,index,to,fully,close,the,index,false,false,false,rest,status,forbidden,enum,set,of,cluster,block,level,write
MetaDataIndexStateService -> public static ClusterBlock createIndexClosingBlock();1547467995;@return Generates a {@link ClusterBlock} that blocks read and write operations on soon-to-be-closed indices. The_cluster block is generated with the id value equals to {@link #INDEX_CLOSED_BLOCK_ID} and a unique UUID.;public static ClusterBlock createIndexClosingBlock() {_        return new ClusterBlock(INDEX_CLOSED_BLOCK_ID, UUIDs.randomBase64UUID(), "index preparing to close. Reopen the index to allow " +_            "writes again or retry closing the index to fully close the index.", false, false, false, RestStatus.FORBIDDEN,_            EnumSet.of(ClusterBlockLevel.WRITE))__    };return,generates,a,link,cluster,block,that,blocks,read,and,write,operations,on,soon,to,be,closed,indices,the,cluster,block,is,generated,with,the,id,value,equals,to,link,and,a,unique,uuid;public,static,cluster,block,create,index,closing,block,return,new,cluster,block,uuids,random,base64uuid,index,preparing,to,close,reopen,the,index,to,allow,writes,again,or,retry,closing,the,index,to,fully,close,the,index,false,false,false,rest,status,forbidden,enum,set,of,cluster,block,level,write
MetaDataIndexStateService -> static void validateShardLimit(ClusterState currentState, Index[] indices, DeprecationLogger deprecationLogger);1540486836;Validates whether a list of indices can be opened without going over the cluster shard limit.  Only counts indices which are_currently closed and will be opened, ignores indices which are already open.__@param currentState The current cluster state._@param indices The indices which are to be opened._@param deprecationLogger The logger to use to emit a deprecation warning, if appropriate._@throws ValidationException If this operation would take the cluster over the limit and enforcement is enabled.;static void validateShardLimit(ClusterState currentState, Index[] indices, DeprecationLogger deprecationLogger) {_        int shardsToOpen = Arrays.stream(indices)_            .filter(index -> currentState.metaData().index(index).getState().equals(IndexMetaData.State.CLOSE))_            .mapToInt(index -> getTotalShardCount(currentState, index))_            .sum()___        Optional<String> error = IndicesService.checkShardLimit(shardsToOpen, currentState, deprecationLogger)__        if (error.isPresent()) {_            ValidationException ex = new ValidationException()__            ex.addValidationError(error.get())__            throw ex__        }__    };validates,whether,a,list,of,indices,can,be,opened,without,going,over,the,cluster,shard,limit,only,counts,indices,which,are,currently,closed,and,will,be,opened,ignores,indices,which,are,already,open,param,current,state,the,current,cluster,state,param,indices,the,indices,which,are,to,be,opened,param,deprecation,logger,the,logger,to,use,to,emit,a,deprecation,warning,if,appropriate,throws,validation,exception,if,this,operation,would,take,the,cluster,over,the,limit,and,enforcement,is,enabled;static,void,validate,shard,limit,cluster,state,current,state,index,indices,deprecation,logger,deprecation,logger,int,shards,to,open,arrays,stream,indices,filter,index,current,state,meta,data,index,index,get,state,equals,index,meta,data,state,close,map,to,int,index,get,total,shard,count,current,state,index,sum,optional,string,error,indices,service,check,shard,limit,shards,to,open,current,state,deprecation,logger,if,error,is,present,validation,exception,ex,new,validation,exception,ex,add,validation,error,error,get,throw,ex
MetaDataIndexStateService -> static void validateShardLimit(ClusterState currentState, Index[] indices, DeprecationLogger deprecationLogger);1540847035;Validates whether a list of indices can be opened without going over the cluster shard limit.  Only counts indices which are_currently closed and will be opened, ignores indices which are already open.__@param currentState The current cluster state._@param indices The indices which are to be opened._@param deprecationLogger The logger to use to emit a deprecation warning, if appropriate._@throws ValidationException If this operation would take the cluster over the limit and enforcement is enabled.;static void validateShardLimit(ClusterState currentState, Index[] indices, DeprecationLogger deprecationLogger) {_        int shardsToOpen = Arrays.stream(indices)_            .filter(index -> currentState.metaData().index(index).getState().equals(IndexMetaData.State.CLOSE))_            .mapToInt(index -> getTotalShardCount(currentState, index))_            .sum()___        Optional<String> error = IndicesService.checkShardLimit(shardsToOpen, currentState, deprecationLogger)__        if (error.isPresent()) {_            ValidationException ex = new ValidationException()__            ex.addValidationError(error.get())__            throw ex__        }__    };validates,whether,a,list,of,indices,can,be,opened,without,going,over,the,cluster,shard,limit,only,counts,indices,which,are,currently,closed,and,will,be,opened,ignores,indices,which,are,already,open,param,current,state,the,current,cluster,state,param,indices,the,indices,which,are,to,be,opened,param,deprecation,logger,the,logger,to,use,to,emit,a,deprecation,warning,if,appropriate,throws,validation,exception,if,this,operation,would,take,the,cluster,over,the,limit,and,enforcement,is,enabled;static,void,validate,shard,limit,cluster,state,current,state,index,indices,deprecation,logger,deprecation,logger,int,shards,to,open,arrays,stream,indices,filter,index,current,state,meta,data,index,index,get,state,equals,index,meta,data,state,close,map,to,int,index,get,total,shard,count,current,state,index,sum,optional,string,error,indices,service,check,shard,limit,shards,to,open,current,state,deprecation,logger,if,error,is,present,validation,exception,ex,new,validation,exception,ex,add,validation,error,error,get,throw,ex
MetaDataIndexStateService -> static void validateShardLimit(ClusterState currentState, Index[] indices, DeprecationLogger deprecationLogger);1541092382;Validates whether a list of indices can be opened without going over the cluster shard limit.  Only counts indices which are_currently closed and will be opened, ignores indices which are already open.__@param currentState The current cluster state._@param indices The indices which are to be opened._@param deprecationLogger The logger to use to emit a deprecation warning, if appropriate._@throws ValidationException If this operation would take the cluster over the limit and enforcement is enabled.;static void validateShardLimit(ClusterState currentState, Index[] indices, DeprecationLogger deprecationLogger) {_        int shardsToOpen = Arrays.stream(indices)_            .filter(index -> currentState.metaData().index(index).getState().equals(IndexMetaData.State.CLOSE))_            .mapToInt(index -> getTotalShardCount(currentState, index))_            .sum()___        Optional<String> error = IndicesService.checkShardLimit(shardsToOpen, currentState, deprecationLogger)__        if (error.isPresent()) {_            ValidationException ex = new ValidationException()__            ex.addValidationError(error.get())__            throw ex__        }__    };validates,whether,a,list,of,indices,can,be,opened,without,going,over,the,cluster,shard,limit,only,counts,indices,which,are,currently,closed,and,will,be,opened,ignores,indices,which,are,already,open,param,current,state,the,current,cluster,state,param,indices,the,indices,which,are,to,be,opened,param,deprecation,logger,the,logger,to,use,to,emit,a,deprecation,warning,if,appropriate,throws,validation,exception,if,this,operation,would,take,the,cluster,over,the,limit,and,enforcement,is,enabled;static,void,validate,shard,limit,cluster,state,current,state,index,indices,deprecation,logger,deprecation,logger,int,shards,to,open,arrays,stream,indices,filter,index,current,state,meta,data,index,index,get,state,equals,index,meta,data,state,close,map,to,int,index,get,total,shard,count,current,state,index,sum,optional,string,error,indices,service,check,shard,limit,shards,to,open,current,state,deprecation,logger,if,error,is,present,validation,exception,ex,new,validation,exception,ex,add,validation,error,error,get,throw,ex
MetaDataIndexStateService -> static void validateShardLimit(ClusterState currentState, Index[] indices, DeprecationLogger deprecationLogger);1542402632;Validates whether a list of indices can be opened without going over the cluster shard limit.  Only counts indices which are_currently closed and will be opened, ignores indices which are already open.__@param currentState The current cluster state._@param indices The indices which are to be opened._@param deprecationLogger The logger to use to emit a deprecation warning, if appropriate._@throws ValidationException If this operation would take the cluster over the limit and enforcement is enabled.;static void validateShardLimit(ClusterState currentState, Index[] indices, DeprecationLogger deprecationLogger) {_        int shardsToOpen = Arrays.stream(indices)_            .filter(index -> currentState.metaData().index(index).getState().equals(IndexMetaData.State.CLOSE))_            .mapToInt(index -> getTotalShardCount(currentState, index))_            .sum()___        Optional<String> error = IndicesService.checkShardLimit(shardsToOpen, currentState, deprecationLogger)__        if (error.isPresent()) {_            ValidationException ex = new ValidationException()__            ex.addValidationError(error.get())__            throw ex__        }__    };validates,whether,a,list,of,indices,can,be,opened,without,going,over,the,cluster,shard,limit,only,counts,indices,which,are,currently,closed,and,will,be,opened,ignores,indices,which,are,already,open,param,current,state,the,current,cluster,state,param,indices,the,indices,which,are,to,be,opened,param,deprecation,logger,the,logger,to,use,to,emit,a,deprecation,warning,if,appropriate,throws,validation,exception,if,this,operation,would,take,the,cluster,over,the,limit,and,enforcement,is,enabled;static,void,validate,shard,limit,cluster,state,current,state,index,indices,deprecation,logger,deprecation,logger,int,shards,to,open,arrays,stream,indices,filter,index,current,state,meta,data,index,index,get,state,equals,index,meta,data,state,close,map,to,int,index,get,total,shard,count,current,state,index,sum,optional,string,error,indices,service,check,shard,limit,shards,to,open,current,state,deprecation,logger,if,error,is,present,validation,exception,ex,new,validation,exception,ex,add,validation,error,error,get,throw,ex
MetaDataIndexStateService -> static void validateShardLimit(ClusterState currentState, Index[] indices, DeprecationLogger deprecationLogger);1542697404;Validates whether a list of indices can be opened without going over the cluster shard limit.  Only counts indices which are_currently closed and will be opened, ignores indices which are already open.__@param currentState The current cluster state._@param indices The indices which are to be opened._@param deprecationLogger The logger to use to emit a deprecation warning, if appropriate._@throws ValidationException If this operation would take the cluster over the limit and enforcement is enabled.;static void validateShardLimit(ClusterState currentState, Index[] indices, DeprecationLogger deprecationLogger) {_        int shardsToOpen = Arrays.stream(indices)_            .filter(index -> currentState.metaData().index(index).getState().equals(IndexMetaData.State.CLOSE))_            .mapToInt(index -> getTotalShardCount(currentState, index))_            .sum()___        Optional<String> error = IndicesService.checkShardLimit(shardsToOpen, currentState, deprecationLogger)__        if (error.isPresent()) {_            ValidationException ex = new ValidationException()__            ex.addValidationError(error.get())__            throw ex__        }__    };validates,whether,a,list,of,indices,can,be,opened,without,going,over,the,cluster,shard,limit,only,counts,indices,which,are,currently,closed,and,will,be,opened,ignores,indices,which,are,already,open,param,current,state,the,current,cluster,state,param,indices,the,indices,which,are,to,be,opened,param,deprecation,logger,the,logger,to,use,to,emit,a,deprecation,warning,if,appropriate,throws,validation,exception,if,this,operation,would,take,the,cluster,over,the,limit,and,enforcement,is,enabled;static,void,validate,shard,limit,cluster,state,current,state,index,indices,deprecation,logger,deprecation,logger,int,shards,to,open,arrays,stream,indices,filter,index,current,state,meta,data,index,index,get,state,equals,index,meta,data,state,close,map,to,int,index,get,total,shard,count,current,state,index,sum,optional,string,error,indices,service,check,shard,limit,shards,to,open,current,state,deprecation,logger,if,error,is,present,validation,exception,ex,new,validation,exception,ex,add,validation,error,error,get,throw,ex
MetaDataIndexStateService -> static void validateShardLimit(ClusterState currentState, Index[] indices);1543277112;Validates whether a list of indices can be opened without going over the cluster shard limit.  Only counts indices which are_currently closed and will be opened, ignores indices which are already open.__@param currentState The current cluster state._@param indices The indices which are to be opened._@throws ValidationException If this operation would take the cluster over the limit and enforcement is enabled.;static void validateShardLimit(ClusterState currentState, Index[] indices) {_        int shardsToOpen = Arrays.stream(indices)_            .filter(index -> currentState.metaData().index(index).getState().equals(IndexMetaData.State.CLOSE))_            .mapToInt(index -> getTotalShardCount(currentState, index))_            .sum()___        Optional<String> error = IndicesService.checkShardLimit(shardsToOpen, currentState)__        if (error.isPresent()) {_            ValidationException ex = new ValidationException()__            ex.addValidationError(error.get())__            throw ex__        }__    };validates,whether,a,list,of,indices,can,be,opened,without,going,over,the,cluster,shard,limit,only,counts,indices,which,are,currently,closed,and,will,be,opened,ignores,indices,which,are,already,open,param,current,state,the,current,cluster,state,param,indices,the,indices,which,are,to,be,opened,throws,validation,exception,if,this,operation,would,take,the,cluster,over,the,limit,and,enforcement,is,enabled;static,void,validate,shard,limit,cluster,state,current,state,index,indices,int,shards,to,open,arrays,stream,indices,filter,index,current,state,meta,data,index,index,get,state,equals,index,meta,data,state,close,map,to,int,index,get,total,shard,count,current,state,index,sum,optional,string,error,indices,service,check,shard,limit,shards,to,open,current,state,if,error,is,present,validation,exception,ex,new,validation,exception,ex,add,validation,error,error,get,throw,ex
MetaDataIndexStateService -> static void validateShardLimit(ClusterState currentState, Index[] indices);1544702062;Validates whether a list of indices can be opened without going over the cluster shard limit.  Only counts indices which are_currently closed and will be opened, ignores indices which are already open.__@param currentState The current cluster state._@param indices The indices which are to be opened._@throws ValidationException If this operation would take the cluster over the limit and enforcement is enabled.;static void validateShardLimit(ClusterState currentState, Index[] indices) {_        int shardsToOpen = Arrays.stream(indices)_            .filter(index -> currentState.metaData().index(index).getState().equals(IndexMetaData.State.CLOSE))_            .mapToInt(index -> getTotalShardCount(currentState, index))_            .sum()___        Optional<String> error = IndicesService.checkShardLimit(shardsToOpen, currentState)__        if (error.isPresent()) {_            ValidationException ex = new ValidationException()__            ex.addValidationError(error.get())__            throw ex__        }__    };validates,whether,a,list,of,indices,can,be,opened,without,going,over,the,cluster,shard,limit,only,counts,indices,which,are,currently,closed,and,will,be,opened,ignores,indices,which,are,already,open,param,current,state,the,current,cluster,state,param,indices,the,indices,which,are,to,be,opened,throws,validation,exception,if,this,operation,would,take,the,cluster,over,the,limit,and,enforcement,is,enabled;static,void,validate,shard,limit,cluster,state,current,state,index,indices,int,shards,to,open,arrays,stream,indices,filter,index,current,state,meta,data,index,index,get,state,equals,index,meta,data,state,close,map,to,int,index,get,total,shard,count,current,state,index,sum,optional,string,error,indices,service,check,shard,limit,shards,to,open,current,state,if,error,is,present,validation,exception,ex,new,validation,exception,ex,add,validation,error,error,get,throw,ex
MetaDataIndexStateService -> static void validateShardLimit(ClusterState currentState, Index[] indices);1547030937;Validates whether a list of indices can be opened without going over the cluster shard limit.  Only counts indices which are_currently closed and will be opened, ignores indices which are already open.__@param currentState The current cluster state._@param indices The indices which are to be opened._@throws ValidationException If this operation would take the cluster over the limit and enforcement is enabled.;static void validateShardLimit(ClusterState currentState, Index[] indices) {_        int shardsToOpen = Arrays.stream(indices)_            .filter(index -> currentState.metaData().index(index).getState().equals(IndexMetaData.State.CLOSE))_            .mapToInt(index -> getTotalShardCount(currentState, index))_            .sum()___        Optional<String> error = IndicesService.checkShardLimit(shardsToOpen, currentState)__        if (error.isPresent()) {_            ValidationException ex = new ValidationException()__            ex.addValidationError(error.get())__            throw ex__        }_    };validates,whether,a,list,of,indices,can,be,opened,without,going,over,the,cluster,shard,limit,only,counts,indices,which,are,currently,closed,and,will,be,opened,ignores,indices,which,are,already,open,param,current,state,the,current,cluster,state,param,indices,the,indices,which,are,to,be,opened,throws,validation,exception,if,this,operation,would,take,the,cluster,over,the,limit,and,enforcement,is,enabled;static,void,validate,shard,limit,cluster,state,current,state,index,indices,int,shards,to,open,arrays,stream,indices,filter,index,current,state,meta,data,index,index,get,state,equals,index,meta,data,state,close,map,to,int,index,get,total,shard,count,current,state,index,sum,optional,string,error,indices,service,check,shard,limit,shards,to,open,current,state,if,error,is,present,validation,exception,ex,new,validation,exception,ex,add,validation,error,error,get,throw,ex
MetaDataIndexStateService -> static void validateShardLimit(ClusterState currentState, Index[] indices);1547467995;Validates whether a list of indices can be opened without going over the cluster shard limit.  Only counts indices which are_currently closed and will be opened, ignores indices which are already open.__@param currentState The current cluster state._@param indices The indices which are to be opened._@throws ValidationException If this operation would take the cluster over the limit and enforcement is enabled.;static void validateShardLimit(ClusterState currentState, Index[] indices) {_        int shardsToOpen = Arrays.stream(indices)_            .filter(index -> currentState.metaData().index(index).getState().equals(IndexMetaData.State.CLOSE))_            .mapToInt(index -> getTotalShardCount(currentState, index))_            .sum()___        Optional<String> error = IndicesService.checkShardLimit(shardsToOpen, currentState)__        if (error.isPresent()) {_            ValidationException ex = new ValidationException()__            ex.addValidationError(error.get())__            throw ex__        }_    };validates,whether,a,list,of,indices,can,be,opened,without,going,over,the,cluster,shard,limit,only,counts,indices,which,are,currently,closed,and,will,be,opened,ignores,indices,which,are,already,open,param,current,state,the,current,cluster,state,param,indices,the,indices,which,are,to,be,opened,throws,validation,exception,if,this,operation,would,take,the,cluster,over,the,limit,and,enforcement,is,enabled;static,void,validate,shard,limit,cluster,state,current,state,index,indices,int,shards,to,open,arrays,stream,indices,filter,index,current,state,meta,data,index,index,get,state,equals,index,meta,data,state,close,map,to,int,index,get,total,shard,count,current,state,index,sum,optional,string,error,indices,service,check,shard,limit,shards,to,open,current,state,if,error,is,present,validation,exception,ex,new,validation,exception,ex,add,validation,error,error,get,throw,ex
MetaDataIndexStateService -> static ClusterState closeRoutingTable(final ClusterState currentState,                                           final Map<Index, ClusterBlock> blockedIndices,                                           final Map<Index, AcknowledgedResponse> results);1547030937;Step 3 - Move index states from OPEN to CLOSE in cluster state for indices that are ready for closing.;static ClusterState closeRoutingTable(final ClusterState currentState,_                                          final Map<Index, ClusterBlock> blockedIndices,_                                          final Map<Index, AcknowledgedResponse> results) {_        final MetaData.Builder metadata = MetaData.builder(currentState.metaData())__        final ClusterBlocks.Builder blocks = ClusterBlocks.builder().blocks(currentState.blocks())__        final RoutingTable.Builder routingTable = RoutingTable.builder(currentState.routingTable())___        final Set<String> closedIndices = new HashSet<>()__        for (Map.Entry<Index, AcknowledgedResponse> result : results.entrySet()) {_            final Index index = result.getKey()__            final boolean acknowledged = result.getValue().isAcknowledged()__            try {_                if (acknowledged == false) {_                    logger.debug("verification of shards before closing {} failed", index)__                    continue__                }_                final IndexMetaData indexMetaData = metadata.getSafe(index)__                if (indexMetaData.getState() == IndexMetaData.State.CLOSE) {_                    logger.debug("verification of shards before closing {} succeeded but index is already closed", index)__                    assert currentState.blocks().hasIndexBlock(index.getName(), INDEX_CLOSED_BLOCK)__                    continue__                }_                final ClusterBlock closingBlock = blockedIndices.get(index)__                if (currentState.blocks().hasIndexBlock(index.getName(), closingBlock) == false) {_                    logger.debug("verification of shards before closing {} succeeded but block has been removed in the meantime", index)__                    continue__                }__                logger.debug("closing index {} succeeded", index)__                blocks.removeIndexBlockWithId(index.getName(), INDEX_CLOSED_BLOCK_ID).addIndexBlock(index.getName(), INDEX_CLOSED_BLOCK)__                metadata.put(IndexMetaData.builder(indexMetaData).state(IndexMetaData.State.CLOSE))__                routingTable.remove(index.getName())__                closedIndices.add(index.getName())__            } catch (final IndexNotFoundException e) {_                logger.debug("index {} has been deleted since it was blocked before closing, ignoring", index)__            }_        }_        logger.info("completed closing of indices {}", closedIndices)__        return ClusterState.builder(currentState).blocks(blocks).metaData(metadata).routingTable(routingTable.build()).build()__    };step,3,move,index,states,from,open,to,close,in,cluster,state,for,indices,that,are,ready,for,closing;static,cluster,state,close,routing,table,final,cluster,state,current,state,final,map,index,cluster,block,blocked,indices,final,map,index,acknowledged,response,results,final,meta,data,builder,metadata,meta,data,builder,current,state,meta,data,final,cluster,blocks,builder,blocks,cluster,blocks,builder,blocks,current,state,blocks,final,routing,table,builder,routing,table,routing,table,builder,current,state,routing,table,final,set,string,closed,indices,new,hash,set,for,map,entry,index,acknowledged,response,result,results,entry,set,final,index,index,result,get,key,final,boolean,acknowledged,result,get,value,is,acknowledged,try,if,acknowledged,false,logger,debug,verification,of,shards,before,closing,failed,index,continue,final,index,meta,data,index,meta,data,metadata,get,safe,index,if,index,meta,data,get,state,index,meta,data,state,close,logger,debug,verification,of,shards,before,closing,succeeded,but,index,is,already,closed,index,assert,current,state,blocks,has,index,block,index,get,name,continue,final,cluster,block,closing,block,blocked,indices,get,index,if,current,state,blocks,has,index,block,index,get,name,closing,block,false,logger,debug,verification,of,shards,before,closing,succeeded,but,block,has,been,removed,in,the,meantime,index,continue,logger,debug,closing,index,succeeded,index,blocks,remove,index,block,with,id,index,get,name,add,index,block,index,get,name,metadata,put,index,meta,data,builder,index,meta,data,state,index,meta,data,state,close,routing,table,remove,index,get,name,closed,indices,add,index,get,name,catch,final,index,not,found,exception,e,logger,debug,index,has,been,deleted,since,it,was,blocked,before,closing,ignoring,index,logger,info,completed,closing,of,indices,closed,indices,return,cluster,state,builder,current,state,blocks,blocks,meta,data,metadata,routing,table,routing,table,build,build
MetaDataIndexStateService -> static ClusterState closeRoutingTable(final ClusterState currentState,                                           final Map<Index, ClusterBlock> blockedIndices,                                           final Map<Index, AcknowledgedResponse> results);1547467995;Step 3 - Move index states from OPEN to CLOSE in cluster state for indices that are ready for closing.;static ClusterState closeRoutingTable(final ClusterState currentState,_                                          final Map<Index, ClusterBlock> blockedIndices,_                                          final Map<Index, AcknowledgedResponse> results) {_        final MetaData.Builder metadata = MetaData.builder(currentState.metaData())__        final ClusterBlocks.Builder blocks = ClusterBlocks.builder().blocks(currentState.blocks())__        final RoutingTable.Builder routingTable = RoutingTable.builder(currentState.routingTable())___        final Set<String> closedIndices = new HashSet<>()__        for (Map.Entry<Index, AcknowledgedResponse> result : results.entrySet()) {_            final Index index = result.getKey()__            final boolean acknowledged = result.getValue().isAcknowledged()__            try {_                if (acknowledged == false) {_                    logger.debug("verification of shards before closing {} failed", index)__                    continue__                }_                final IndexMetaData indexMetaData = metadata.getSafe(index)__                if (indexMetaData.getState() == IndexMetaData.State.CLOSE) {_                    logger.debug("verification of shards before closing {} succeeded but index is already closed", index)__                    assert currentState.blocks().hasIndexBlock(index.getName(), INDEX_CLOSED_BLOCK)__                    continue__                }_                final ClusterBlock closingBlock = blockedIndices.get(index)__                if (currentState.blocks().hasIndexBlock(index.getName(), closingBlock) == false) {_                    logger.debug("verification of shards before closing {} succeeded but block has been removed in the meantime", index)__                    continue__                }__                logger.debug("closing index {} succeeded", index)__                blocks.removeIndexBlockWithId(index.getName(), INDEX_CLOSED_BLOCK_ID).addIndexBlock(index.getName(), INDEX_CLOSED_BLOCK)__                metadata.put(IndexMetaData.builder(indexMetaData).state(IndexMetaData.State.CLOSE))__                routingTable.remove(index.getName())__                closedIndices.add(index.getName())__            } catch (final IndexNotFoundException e) {_                logger.debug("index {} has been deleted since it was blocked before closing, ignoring", index)__            }_        }_        logger.info("completed closing of indices {}", closedIndices)__        return ClusterState.builder(currentState).blocks(blocks).metaData(metadata).routingTable(routingTable.build()).build()__    };step,3,move,index,states,from,open,to,close,in,cluster,state,for,indices,that,are,ready,for,closing;static,cluster,state,close,routing,table,final,cluster,state,current,state,final,map,index,cluster,block,blocked,indices,final,map,index,acknowledged,response,results,final,meta,data,builder,metadata,meta,data,builder,current,state,meta,data,final,cluster,blocks,builder,blocks,cluster,blocks,builder,blocks,current,state,blocks,final,routing,table,builder,routing,table,routing,table,builder,current,state,routing,table,final,set,string,closed,indices,new,hash,set,for,map,entry,index,acknowledged,response,result,results,entry,set,final,index,index,result,get,key,final,boolean,acknowledged,result,get,value,is,acknowledged,try,if,acknowledged,false,logger,debug,verification,of,shards,before,closing,failed,index,continue,final,index,meta,data,index,meta,data,metadata,get,safe,index,if,index,meta,data,get,state,index,meta,data,state,close,logger,debug,verification,of,shards,before,closing,succeeded,but,index,is,already,closed,index,assert,current,state,blocks,has,index,block,index,get,name,continue,final,cluster,block,closing,block,blocked,indices,get,index,if,current,state,blocks,has,index,block,index,get,name,closing,block,false,logger,debug,verification,of,shards,before,closing,succeeded,but,block,has,been,removed,in,the,meantime,index,continue,logger,debug,closing,index,succeeded,index,blocks,remove,index,block,with,id,index,get,name,add,index,block,index,get,name,metadata,put,index,meta,data,builder,index,meta,data,state,index,meta,data,state,close,routing,table,remove,index,get,name,closed,indices,add,index,get,name,catch,final,index,not,found,exception,e,logger,debug,index,has,been,deleted,since,it,was,blocked,before,closing,ignoring,index,logger,info,completed,closing,of,indices,closed,indices,return,cluster,state,builder,current,state,blocks,blocks,meta,data,metadata,routing,table,routing,table,build,build
MetaDataIndexStateService -> public void closeIndices(final CloseIndexClusterStateUpdateRequest request, final ActionListener<AcknowledgedResponse> listener);1547030937;Closes one or more indices.__Closing indices is a 3 steps process: it first adds a write block to every indices to close, then waits for the operations on shards_to be terminated and finally closes the indices by moving their state to CLOSE.;public void closeIndices(final CloseIndexClusterStateUpdateRequest request, final ActionListener<AcknowledgedResponse> listener) {_        final Index[] concreteIndices = request.indices()__        if (concreteIndices == null || concreteIndices.length == 0) {_            throw new IllegalArgumentException("Index name is required")__        }__        clusterService.submitStateUpdateTask("add-block-index-to-close " + Arrays.toString(concreteIndices),_            new ClusterStateUpdateTask(Priority.URGENT) {__                private final Map<Index, ClusterBlock> blockedIndices = new HashMap<>()___                @Override_                public ClusterState execute(final ClusterState currentState) {_                    return addIndexClosedBlocks(concreteIndices, blockedIndices, currentState)__                }__                @Override_                public void clusterStateProcessed(final String source, final ClusterState oldState, final ClusterState newState) {_                    if (oldState == newState) {_                        assert blockedIndices.isEmpty() : "List of blocked indices is not empty but cluster state wasn't changed"__                        listener.onResponse(new AcknowledgedResponse(true))__                    } else {_                        assert blockedIndices.isEmpty() == false : "List of blocked indices is empty but cluster state was changed"__                        threadPool.executor(ThreadPool.Names.MANAGEMENT)_                            .execute(new WaitForClosedBlocksApplied(blockedIndices, request,_                                ActionListener.wrap(results ->_                                    clusterService.submitStateUpdateTask("close-indices", new ClusterStateUpdateTask(Priority.URGENT) {__                                        boolean acknowledged = true___                                        @Override_                                        public ClusterState execute(final ClusterState currentState) throws Exception {_                                            final ClusterState updatedState = closeRoutingTable(currentState, blockedIndices, results)__                                            for (Map.Entry<Index, AcknowledgedResponse> result : results.entrySet()) {_                                                IndexMetaData updatedMetaData = updatedState.metaData().index(result.getKey())__                                                if (updatedMetaData != null && updatedMetaData.getState() != IndexMetaData.State.CLOSE) {_                                                    acknowledged = false__                                                    break__                                                }_                                            }_                                            return allocationService.reroute(updatedState, "indices closed")__                                        }__                                        @Override_                                        public void onFailure(final String source, final Exception e) {_                                            listener.onFailure(e)__                                        }__                                        @Override_                                        public void clusterStateProcessed(final String source,_                                                                          final ClusterState oldState, final ClusterState newState) {_                                            listener.onResponse(new AcknowledgedResponse(acknowledged))__                                        }_                                    }),_                                    listener::onFailure)_                                )_                            )__                    }_                }__                @Override_                public void onFailure(final String source, final Exception e) {_                    listener.onFailure(e)__                }__                @Override_                public TimeValue timeout() {_                    return request.masterNodeTimeout()__                }_            }_        )__    };closes,one,or,more,indices,closing,indices,is,a,3,steps,process,it,first,adds,a,write,block,to,every,indices,to,close,then,waits,for,the,operations,on,shards,to,be,terminated,and,finally,closes,the,indices,by,moving,their,state,to,close;public,void,close,indices,final,close,index,cluster,state,update,request,request,final,action,listener,acknowledged,response,listener,final,index,concrete,indices,request,indices,if,concrete,indices,null,concrete,indices,length,0,throw,new,illegal,argument,exception,index,name,is,required,cluster,service,submit,state,update,task,add,block,index,to,close,arrays,to,string,concrete,indices,new,cluster,state,update,task,priority,urgent,private,final,map,index,cluster,block,blocked,indices,new,hash,map,override,public,cluster,state,execute,final,cluster,state,current,state,return,add,index,closed,blocks,concrete,indices,blocked,indices,current,state,override,public,void,cluster,state,processed,final,string,source,final,cluster,state,old,state,final,cluster,state,new,state,if,old,state,new,state,assert,blocked,indices,is,empty,list,of,blocked,indices,is,not,empty,but,cluster,state,wasn,t,changed,listener,on,response,new,acknowledged,response,true,else,assert,blocked,indices,is,empty,false,list,of,blocked,indices,is,empty,but,cluster,state,was,changed,thread,pool,executor,thread,pool,names,management,execute,new,wait,for,closed,blocks,applied,blocked,indices,request,action,listener,wrap,results,cluster,service,submit,state,update,task,close,indices,new,cluster,state,update,task,priority,urgent,boolean,acknowledged,true,override,public,cluster,state,execute,final,cluster,state,current,state,throws,exception,final,cluster,state,updated,state,close,routing,table,current,state,blocked,indices,results,for,map,entry,index,acknowledged,response,result,results,entry,set,index,meta,data,updated,meta,data,updated,state,meta,data,index,result,get,key,if,updated,meta,data,null,updated,meta,data,get,state,index,meta,data,state,close,acknowledged,false,break,return,allocation,service,reroute,updated,state,indices,closed,override,public,void,on,failure,final,string,source,final,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,final,string,source,final,cluster,state,old,state,final,cluster,state,new,state,listener,on,response,new,acknowledged,response,acknowledged,listener,on,failure,override,public,void,on,failure,final,string,source,final,exception,e,listener,on,failure,e,override,public,time,value,timeout,return,request,master,node,timeout
MetaDataIndexStateService -> public void closeIndices(final CloseIndexClusterStateUpdateRequest request, final ActionListener<AcknowledgedResponse> listener);1547467995;Closes one or more indices.__Closing indices is a 3 steps process: it first adds a write block to every indices to close, then waits for the operations on shards_to be terminated and finally closes the indices by moving their state to CLOSE.;public void closeIndices(final CloseIndexClusterStateUpdateRequest request, final ActionListener<AcknowledgedResponse> listener) {_        final Index[] concreteIndices = request.indices()__        if (concreteIndices == null || concreteIndices.length == 0) {_            throw new IllegalArgumentException("Index name is required")__        }__        clusterService.submitStateUpdateTask("add-block-index-to-close " + Arrays.toString(concreteIndices),_            new ClusterStateUpdateTask(Priority.URGENT) {__                private final Map<Index, ClusterBlock> blockedIndices = new HashMap<>()___                @Override_                public ClusterState execute(final ClusterState currentState) {_                    return addIndexClosedBlocks(concreteIndices, blockedIndices, currentState)__                }__                @Override_                public void clusterStateProcessed(final String source, final ClusterState oldState, final ClusterState newState) {_                    if (oldState == newState) {_                        assert blockedIndices.isEmpty() : "List of blocked indices is not empty but cluster state wasn't changed"__                        listener.onResponse(new AcknowledgedResponse(true))__                    } else {_                        assert blockedIndices.isEmpty() == false : "List of blocked indices is empty but cluster state was changed"__                        threadPool.executor(ThreadPool.Names.MANAGEMENT)_                            .execute(new WaitForClosedBlocksApplied(blockedIndices, request,_                                ActionListener.wrap(results ->_                                    clusterService.submitStateUpdateTask("close-indices", new ClusterStateUpdateTask(Priority.URGENT) {__                                        boolean acknowledged = true___                                        @Override_                                        public ClusterState execute(final ClusterState currentState) throws Exception {_                                            final ClusterState updatedState = closeRoutingTable(currentState, blockedIndices, results)__                                            for (Map.Entry<Index, AcknowledgedResponse> result : results.entrySet()) {_                                                IndexMetaData updatedMetaData = updatedState.metaData().index(result.getKey())__                                                if (updatedMetaData != null && updatedMetaData.getState() != IndexMetaData.State.CLOSE) {_                                                    acknowledged = false__                                                    break__                                                }_                                            }_                                            return allocationService.reroute(updatedState, "indices closed")__                                        }__                                        @Override_                                        public void onFailure(final String source, final Exception e) {_                                            listener.onFailure(e)__                                        }__                                        @Override_                                        public void clusterStateProcessed(final String source,_                                                                          final ClusterState oldState, final ClusterState newState) {_                                            listener.onResponse(new AcknowledgedResponse(acknowledged))__                                        }_                                    }),_                                    listener::onFailure)_                                )_                            )__                    }_                }__                @Override_                public void onFailure(final String source, final Exception e) {_                    listener.onFailure(e)__                }__                @Override_                public TimeValue timeout() {_                    return request.masterNodeTimeout()__                }_            }_        )__    };closes,one,or,more,indices,closing,indices,is,a,3,steps,process,it,first,adds,a,write,block,to,every,indices,to,close,then,waits,for,the,operations,on,shards,to,be,terminated,and,finally,closes,the,indices,by,moving,their,state,to,close;public,void,close,indices,final,close,index,cluster,state,update,request,request,final,action,listener,acknowledged,response,listener,final,index,concrete,indices,request,indices,if,concrete,indices,null,concrete,indices,length,0,throw,new,illegal,argument,exception,index,name,is,required,cluster,service,submit,state,update,task,add,block,index,to,close,arrays,to,string,concrete,indices,new,cluster,state,update,task,priority,urgent,private,final,map,index,cluster,block,blocked,indices,new,hash,map,override,public,cluster,state,execute,final,cluster,state,current,state,return,add,index,closed,blocks,concrete,indices,blocked,indices,current,state,override,public,void,cluster,state,processed,final,string,source,final,cluster,state,old,state,final,cluster,state,new,state,if,old,state,new,state,assert,blocked,indices,is,empty,list,of,blocked,indices,is,not,empty,but,cluster,state,wasn,t,changed,listener,on,response,new,acknowledged,response,true,else,assert,blocked,indices,is,empty,false,list,of,blocked,indices,is,empty,but,cluster,state,was,changed,thread,pool,executor,thread,pool,names,management,execute,new,wait,for,closed,blocks,applied,blocked,indices,request,action,listener,wrap,results,cluster,service,submit,state,update,task,close,indices,new,cluster,state,update,task,priority,urgent,boolean,acknowledged,true,override,public,cluster,state,execute,final,cluster,state,current,state,throws,exception,final,cluster,state,updated,state,close,routing,table,current,state,blocked,indices,results,for,map,entry,index,acknowledged,response,result,results,entry,set,index,meta,data,updated,meta,data,updated,state,meta,data,index,result,get,key,if,updated,meta,data,null,updated,meta,data,get,state,index,meta,data,state,close,acknowledged,false,break,return,allocation,service,reroute,updated,state,indices,closed,override,public,void,on,failure,final,string,source,final,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,final,string,source,final,cluster,state,old,state,final,cluster,state,new,state,listener,on,response,new,acknowledged,response,acknowledged,listener,on,failure,override,public,void,on,failure,final,string,source,final,exception,e,listener,on,failure,e,override,public,time,value,timeout,return,request,master,node,timeout
