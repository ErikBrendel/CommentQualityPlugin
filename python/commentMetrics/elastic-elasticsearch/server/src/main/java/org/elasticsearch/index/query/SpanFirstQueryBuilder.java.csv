commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;5;;@Override protected void doWriteTo(StreamOutput out) throws IOException {     out.writeNamedWriteable(matchBuilder).     out.writeInt(end). }
true;public;0;3;/**  * @return the inner {@link SpanQueryBuilder} defined in this query  */ ;/**  * @return the inner {@link SpanQueryBuilder} defined in this query  */ public SpanQueryBuilder innerQuery() {     return this.matchBuilder. }
true;public;0;3;/**  * @return maximum end position of the matching inner span query  */ ;/**  * @return maximum end position of the matching inner span query  */ public int end() {     return this.end. }
false;protected;2;9;;@Override protected void doXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject(NAME).     builder.field(MATCH_FIELD.getPreferredName()).     matchBuilder.toXContent(builder, params).     builder.field(END_FIELD.getPreferredName(), end).     printBoostAndQueryName(builder).     builder.endObject(). }
false;public,static;1;45;;public static SpanFirstQueryBuilder fromXContent(XContentParser parser) throws IOException {     float boost = AbstractQueryBuilder.DEFAULT_BOOST.     SpanQueryBuilder match = null.     Integer end = null.     String queryName = null.     String currentFieldName = null.     XContentParser.Token token.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (token == XContentParser.Token.START_OBJECT) {             if (MATCH_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 QueryBuilder query = parseInnerQueryBuilder(parser).                 if (query instanceof SpanQueryBuilder == false) {                     throw new ParsingException(parser.getTokenLocation(), "span_first [match] must be of type span query").                 }                 match = (SpanQueryBuilder) query.                 checkNoBoost(NAME, currentFieldName, parser, match).             } else {                 throw new ParsingException(parser.getTokenLocation(), "[span_first] query does not support [" + currentFieldName + "]").             }         } else {             if (AbstractQueryBuilder.BOOST_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 boost = parser.floatValue().             } else if (END_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 end = parser.intValue().             } else if (AbstractQueryBuilder.NAME_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 queryName = parser.text().             } else {                 throw new ParsingException(parser.getTokenLocation(), "[span_first] query does not support [" + currentFieldName + "]").             }         }     }     if (match == null) {         throw new ParsingException(parser.getTokenLocation(), "span_first must have [match] span query clause").     }     if (end == null) {         throw new ParsingException(parser.getTokenLocation(), "span_first must have [end] set for it").     }     SpanFirstQueryBuilder queryBuilder = new SpanFirstQueryBuilder(match, end).     queryBuilder.boost(boost).queryName(queryName).     return queryBuilder. }
false;protected;1;6;;@Override protected Query doToQuery(QueryShardContext context) throws IOException {     Query innerSpanQuery = matchBuilder.toQuery(context).     assert innerSpanQuery instanceof SpanQuery.     return new SpanFirstQuery((SpanQuery) innerSpanQuery, end). }
false;protected;0;4;;@Override protected int doHashCode() {     return Objects.hash(matchBuilder, end). }
false;protected;1;5;;@Override protected boolean doEquals(SpanFirstQueryBuilder other) {     return Objects.equals(matchBuilder, other.matchBuilder) && Objects.equals(end, other.end). }
false;public;0;4;;@Override public String getWriteableName() {     return NAME. }
