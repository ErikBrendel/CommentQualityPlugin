commented;modifiers;parameterAmount;loc;comment;code
false;public;3;5;;@Override public MetadataFieldMapper.Builder<?, ?> parse(String name, Map<String, Object> node, ParserContext parserContext) throws MapperParsingException {     throw new MapperParsingException(NAME + " is not configurable"). }
false;public;2;5;;@Override public MetadataFieldMapper getDefault(MappedFieldType fieldType, ParserContext context) {     final Settings indexSettings = context.mapperService().getIndexSettings().getSettings().     return new VersionFieldMapper(indexSettings). }
false;public;0;4;;@Override public MappedFieldType clone() {     return new VersionFieldType(this). }
false;public;0;4;;@Override public String typeName() {     return CONTENT_TYPE. }
false;public;1;4;;@Override public Query existsQuery(QueryShardContext context) {     return new DocValuesFieldExistsQuery(name()). }
false;public;2;4;;@Override public Query termQuery(Object value, QueryShardContext context) {     throw new QueryShardException(context, "The _version field is not searchable"). }
false;public;1;4;;@Override public void preParse(ParseContext context) throws IOException {     super.parse(context). }
false;protected;2;7;;@Override protected void parseCreateField(ParseContext context, List<IndexableField> fields) throws IOException {     // see InternalEngine.updateVersion to see where the real version value is set     final Field version = new NumericDocValuesField(NAME, -1L).     context.version(version).     fields.add(version). }
false;public;1;4;;@Override public void parse(ParseContext context) throws IOException { // _version added in preparse }
false;public;1;10;;@Override public void postParse(ParseContext context) throws IOException {     // In the case of nested docs, let's fill nested docs with version=1 so that Lucene doesn't write a Bitset for documents     // that don't have the field. This is consistent with the default value for efficiency.     Field version = context.version().     assert version != null.     for (Document doc : context.nonRootDocuments()) {         doc.add(version).     } }
false;protected;0;4;;@Override protected String contentType() {     return CONTENT_TYPE. }
false;public;2;4;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     return builder. }
false;protected;1;4;;@Override protected void doMerge(Mapper mergeWith) { // nothing to do }
