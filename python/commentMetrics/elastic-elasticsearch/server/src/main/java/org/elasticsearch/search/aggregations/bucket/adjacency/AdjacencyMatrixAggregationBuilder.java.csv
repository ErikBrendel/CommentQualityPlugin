commented;modifiers;parameterAmount;loc;comment;code
false;public,static;2;5;;public static AggregationBuilder parse(String aggregationName, XContentParser parser) throws IOException {     AdjacencyMatrixAggregationBuilder result = PARSER.parse(parser, new AdjacencyMatrixAggregationBuilder(aggregationName), null).     result.checkConsistency().     return result. }
false;protected;0;5;;protected void checkConsistency() {     if ((filters == null) || (filters.size() == 0)) {         throw new IllegalStateException("[" + name + "] is missing : " + FILTERS_FIELD.getPreferredName() + " parameter").     } }
false;protected;1;10;;protected void setFiltersAsMap(Map<String, QueryBuilder> filters) {     // Convert uniquely named objects into internal KeyedFilters     this.filters = new ArrayList<>(filters.size()).     for (Entry<String, QueryBuilder> kv : filters.entrySet()) {         this.filters.add(new KeyedFilter(kv.getKey(), kv.getValue())).     }     // internally we want to have a fixed order of filters, regardless of     // the order of the filters in the request     Collections.sort(this.filters, Comparator.comparing(KeyedFilter::key)). }
false;protected;1;6;;protected void setFiltersAsList(List<KeyedFilter> filters) {     this.filters = new ArrayList<>(filters).     // internally we want to have a fixed order of filters, regardless of     // the order of the filters in the request     Collections.sort(this.filters, Comparator.comparing(KeyedFilter::key)). }
false;protected;2;4;;@Override protected AggregationBuilder shallowCopy(Builder factoriesBuilder, Map<String, Object> metaData) {     return new AdjacencyMatrixAggregationBuilder(this, factoriesBuilder, metaData). }
false;protected;1;8;;@Override protected void doWriteTo(StreamOutput out) throws IOException {     out.writeVInt(filters.size()).     out.writeString(separator).     for (KeyedFilter keyedFilter : filters) {         keyedFilter.writeTo(out).     } }
true;public;1;7;/**  * Set the separator used to join pairs of bucket keys  */ ;/**  * Set the separator used to join pairs of bucket keys  */ public AdjacencyMatrixAggregationBuilder separator(String separator) {     if (separator == null) {         throw new IllegalArgumentException("[separator] must not be null: [" + name + "]").     }     this.separator = separator.     return this. }
true;public;0;3;/**  * Get the separator used to join pairs of bucket keys  */ ;/**  * Get the separator used to join pairs of bucket keys  */ public String separator() {     return separator. }
true;public;0;7;/**  * Get the filters. This will be an unmodifiable map  */ ;/**  * Get the filters. This will be an unmodifiable map  */ public Map<String, QueryBuilder> filters() {     Map<String, QueryBuilder> result = new HashMap<>(this.filters.size()).     for (KeyedFilter keyedFilter : this.filters) {         result.put(keyedFilter.key(), keyedFilter.filter()).     }     return result. }
false;protected;3;20;;@Override protected AggregatorFactory<?> doBuild(SearchContext context, AggregatorFactory<?> parent, Builder subFactoriesBuilder) throws IOException {     int maxFilters = context.indexShard().indexSettings().getMaxAdjacencyMatrixFilters().     if (filters.size() > maxFilters) {         throw new IllegalArgumentException("Number of filters is too large, must be less than or equal to: [" + maxFilters + "] but was [" + filters.size() + "]." + "This limit can be set by changing the [" + IndexSettings.MAX_ADJACENCY_MATRIX_FILTERS_SETTING.getKey() + "] index level setting.").     }     List<KeyedFilter> rewrittenFilters = new ArrayList<>(filters.size()).     for (KeyedFilter kf : filters) {         rewrittenFilters.add(new KeyedFilter(kf.key(), Rewriteable.rewrite(kf.filter(), context.getQueryShardContext(), true))).     }     return new AdjacencyMatrixAggregatorFactory(name, rewrittenFilters, separator, context, parent, subFactoriesBuilder, metaData). }
false;protected;2;12;;@Override protected XContentBuilder internalXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     builder.field(SEPARATOR_FIELD.getPreferredName(), separator).     builder.startObject(AdjacencyMatrixAggregator.FILTERS_FIELD.getPreferredName()).     for (KeyedFilter keyedFilter : filters) {         builder.field(keyedFilter.key(), keyedFilter.filter()).     }     builder.endObject().     builder.endObject().     return builder. }
false;protected;0;4;;@Override protected int doHashCode() {     return Objects.hash(filters, separator). }
false;protected;1;5;;@Override protected boolean doEquals(Object obj) {     AdjacencyMatrixAggregationBuilder other = (AdjacencyMatrixAggregationBuilder) obj.     return Objects.equals(filters, other.filters) && Objects.equals(separator, other.separator). }
false;public;0;4;;@Override public String getType() {     return NAME. }
