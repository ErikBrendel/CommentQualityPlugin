commented;modifiers;parameterAmount;loc;comment;code
false;private;0;11;;private InputStream nextStream() throws IOException {     assert initialized == false || currentStream != null.     initialized = true.     IOUtils.close(currentStream).     if (slice < numSlices) {         currentStream = openSlice(slice++).     } else {         currentStream = null.     }     return currentStream. }
true;protected,abstract;1;1;/**  * Called for each logical slice given a zero based slice ordinal.  */ ;/**  * Called for each logical slice given a zero based slice ordinal.  */ protected abstract InputStream openSlice(long slice) throws IOException.
false;private;0;6;;private InputStream currentStream() throws IOException {     if (currentStream == null) {         return initialized ? null : nextStream().     }     return currentStream. }
false;public,final;0;13;;@Override public final int read() throws IOException {     InputStream stream = currentStream().     if (stream == null) {         return -1.     }     final int read = stream.read().     if (read == -1) {         nextStream().         return read().     }     return read. }
false;public,final;3;13;;@Override public final int read(byte[] buffer, int offset, int length) throws IOException {     final InputStream stream = currentStream().     if (stream == null) {         return -1.     }     final int read = stream.read(buffer, offset, length).     if (read <= 0) {         nextStream().         return read(buffer, offset, length).     }     return read. }
false;public,final;0;6;;@Override public final void close() throws IOException {     IOUtils.close(currentStream).     initialized = true.     currentStream = null. }
false;public,final;0;5;;@Override public final int available() throws IOException {     InputStream stream = currentStream().     return stream == null ? 0 : stream.available(). }
