commented;modifiers;parameterAmount;loc;comment;code
true;protected;1;4;/**  * Always accept the term.  */ ;/**  * Always accept the term.  */ @Override protected AcceptStatus accept(BytesRef term) throws IOException {     return AcceptStatus.YES. }
true;public;0;5;/**  * Flush the {@code flushBuffer} to the breaker, incrementing the total  * bytes and resetting the buffer.  */ ;/**  * Flush the {@code flushBuffer} to the breaker, incrementing the total  * bytes and resetting the buffer.  */ public void flush() {     breaker.addEstimateBytesAndMaybeBreak(this.flushBuffer, this.fieldName).     this.totalBytes += this.flushBuffer.     this.flushBuffer = 0. }
true;public;0;14;/**  * Proxy to the original next() call, but estimates the overhead of  * loading the next term.  */ ;/**  * Proxy to the original next() call, but estimates the overhead of  * loading the next term.  */ @Override public BytesRef next() throws IOException {     BytesRef term = termsEnum.next().     if (term == null && this.flushBuffer != 0) {         // We have reached the end of the termsEnum, flush the buffer         flush().     } else {         this.flushBuffer += estimator.bytesPerValue(term).         if (this.flushBuffer >= FLUSH_BUFFER_SIZE) {             flush().         }     }     return term. }
true;public;0;3;/**  * @return the total number of bytes that have been aggregated  */ ;/**  * @return the total number of bytes that have been aggregated  */ public long getTotalBytes() {     return this.totalBytes. }
