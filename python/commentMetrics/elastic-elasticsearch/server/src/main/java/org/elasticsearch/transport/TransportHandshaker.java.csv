commented;modifiers;parameterAmount;loc;comment;code
false;;5;28;;void sendHandshake(long requestId, DiscoveryNode node, TcpChannel channel, TimeValue timeout, ActionListener<Version> listener) {     numHandshakes.inc().     final HandshakeResponseHandler handler = new HandshakeResponseHandler(requestId, version, listener).     pendingHandshakes.put(requestId, handler).     channel.addCloseListener(ActionListener.wrap(() -> handler.handleLocalException(new TransportException("handshake failed because connection reset")))).     boolean success = false.     try {         // for the request we use the minCompatVersion since we don't know what's the version of the node we talk to         // we also have no payload on the request but the response will contain the actual version of the node we talk         // to as the payload.         final Version minCompatVersion = version.minimumCompatibilityVersion().         handshakeRequestSender.sendRequest(node, channel, requestId, minCompatVersion).         threadPool.schedule(() -> handler.handleLocalException(new ConnectTransportException(node, "handshake_timeout[" + timeout + "]")), timeout, ThreadPool.Names.GENERIC).         success = true.     } catch (Exception e) {         handler.handleLocalException(new ConnectTransportException(node, "failure to send " + HANDSHAKE_ACTION_NAME, e)).     } finally {         if (success == false) {             TransportResponseHandler<?> removed = pendingHandshakes.remove(requestId).             assert removed == null : "Handshake should not be pending if exception was thrown".         }     } }
false;;5;11;;void handleHandshake(Version version, Set<String> features, TcpChannel channel, long requestId, StreamInput stream) throws IOException {     // Must read the handshake request to exhaust the stream     HandshakeRequest handshakeRequest = new HandshakeRequest(stream).     final int nextByte = stream.read().     if (nextByte != -1) {         throw new IllegalStateException("Handshake request not fully read for requestId [" + requestId + "], action [" + TransportHandshaker.HANDSHAKE_ACTION_NAME + "], available [" + stream.available() + "]. resetting").     }     HandshakeResponse response = new HandshakeResponse(this.version).     handshakeResponseSender.sendResponse(version, features, channel, response, requestId). }
false;;1;3;;TransportResponseHandler<HandshakeResponse> removeHandlerForHandshake(long requestId) {     return pendingHandshakes.remove(requestId). }
false;;0;3;;int getNumPendingHandshakes() {     return pendingHandshakes.size(). }
false;;0;3;;long getNumHandshakes() {     return numHandshakes.count(). }
false;public;1;4;;@Override public HandshakeResponse read(StreamInput in) throws IOException {     return new HandshakeResponse(in). }
false;public;1;12;;@Override public void handleResponse(HandshakeResponse response) {     if (isDone.compareAndSet(false, true)) {         Version version = response.responseVersion.         if (currentVersion.isCompatible(version) == false) {             listener.onFailure(new IllegalStateException("Received message from unsupported version: [" + version + "] minimal compatible version is: [" + currentVersion.minimumCompatibilityVersion() + "]")).         } else {             listener.onResponse(version).         }     } }
false;public;1;6;;@Override public void handleException(TransportException e) {     if (isDone.compareAndSet(false, true)) {         listener.onFailure(new IllegalStateException("handshake failed", e)).     } }
false;;1;5;;void handleLocalException(TransportException e) {     if (removeHandlerForHandshake(requestId) != null && isDone.compareAndSet(false, true)) {         listener.onFailure(e).     } }
false;public;0;4;;@Override public String executor() {     return ThreadPool.Names.SAME. }
false;public;1;4;;@Override public void readFrom(StreamInput in) {     throw new UnsupportedOperationException("usage of Streamable is to be replaced by Writeable"). }
false;public;1;10;;@Override public void writeTo(StreamOutput streamOutput) throws IOException {     super.writeTo(streamOutput).     assert version != null.     try (BytesStreamOutput messageStreamOutput = new BytesStreamOutput(4)) {         Version.writeVersion(version, messageStreamOutput).         BytesReference reference = messageStreamOutput.bytes().         streamOutput.writeBytesReference(reference).     } }
false;public;1;4;;@Override public void readFrom(StreamInput in) {     throw new UnsupportedOperationException("usage of Streamable is to be replaced by Writeable"). }
false;public;1;6;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     assert responseVersion != null.     Version.writeVersion(responseVersion, out). }
false;;0;3;;Version getResponseVersion() {     return responseVersion. }
false;;4;1;;void sendRequest(DiscoveryNode node, TcpChannel channel, long requestId, Version version) throws IOException.
false;;5;2;;void sendResponse(Version version, Set<String> features, TcpChannel channel, TransportResponse response, long requestId) throws IOException.
