commented;modifiers;parameterAmount;loc;comment;code
false;public;3;7;;@Override public void beforeIndexShardClosed(ShardId shardId, @Nullable IndexShard indexShard, Settings indexSettings) {     if (indexShard != null) {         ongoingRecoveries.cancel(indexShard, "shard is closed").     } }
false;private;2;22;;private void recover(StartRecoveryRequest request, ActionListener<RecoveryResponse> listener) throws IOException {     final IndexService indexService = indicesService.indexServiceSafe(request.shardId().getIndex()).     final IndexShard shard = indexService.getShard(request.shardId().id()).     final ShardRouting routingEntry = shard.routingEntry().     if (routingEntry.primary() == false || routingEntry.active() == false) {         throw new DelayRecoveryException("source shard [" + routingEntry + "] is not an active primary").     }     if (request.isPrimaryRelocation() && (routingEntry.relocating() == false || routingEntry.relocatingNodeId().equals(request.targetNode().getId()) == false)) {         logger.debug("delaying recovery of {} as source shard is not marked yet as relocating to {}", request.shardId(), request.targetNode()).         throw new DelayRecoveryException("source shard is not marked yet as relocating to [" + request.targetNode() + "]").     }     RecoverySourceHandler handler = ongoingRecoveries.addNewRecovery(request, shard).     logger.trace("[{}][{}] starting recovery to {}", request.shardId().getIndex().getName(), request.shardId().id(), request.targetNode()).     handler.recoverToTarget(ActionListener.runAfter(listener, () -> ongoingRecoveries.remove(shard, handler))). }
false;public;3;4;;@Override public void messageReceived(final StartRecoveryRequest request, final TransportChannel channel, Task task) throws Exception {     recover(request, new ChannelActionListener<>(channel, Actions.START_RECOVERY, request)). }
false;synchronized;2;6;;synchronized RecoverySourceHandler addNewRecovery(StartRecoveryRequest request, IndexShard shard) {     final ShardRecoveryContext shardContext = ongoingRecoveries.computeIfAbsent(shard, s -> new ShardRecoveryContext()).     RecoverySourceHandler handler = shardContext.addNewRecovery(request, shard).     shard.recoveryStats().incCurrentAsSource().     return handler. }
false;synchronized;2;12;;synchronized void remove(IndexShard shard, RecoverySourceHandler handler) {     final ShardRecoveryContext shardRecoveryContext = ongoingRecoveries.get(shard).     assert shardRecoveryContext != null : "Shard was not registered [" + shard + "]".     boolean remove = shardRecoveryContext.recoveryHandlers.remove(handler).     assert remove : "Handler was not registered [" + handler + "]".     if (remove) {         shard.recoveryStats().decCurrentAsSource().     }     if (shardRecoveryContext.recoveryHandlers.isEmpty()) {         ongoingRecoveries.remove(shard).     } }
false;synchronized;2;16;;synchronized void cancel(IndexShard shard, String reason) {     final ShardRecoveryContext shardRecoveryContext = ongoingRecoveries.get(shard).     if (shardRecoveryContext != null) {         final List<Exception> failures = new ArrayList<>().         for (RecoverySourceHandler handlers : shardRecoveryContext.recoveryHandlers) {             try {                 handlers.cancel(reason).             } catch (Exception ex) {                 failures.add(ex).             } finally {                 shard.recoveryStats().decCurrentAsSource().             }         }         ExceptionsHelper.maybeThrowRuntimeAndSuppress(failures).     } }
true;synchronized;2;11;/**  * Adds recovery source handler.  */ ;/**  * Adds recovery source handler.  */ synchronized RecoverySourceHandler addNewRecovery(StartRecoveryRequest request, IndexShard shard) {     for (RecoverySourceHandler existingHandler : recoveryHandlers) {         if (existingHandler.getRequest().targetAllocationId().equals(request.targetAllocationId())) {             throw new DelayRecoveryException("recovery with same target already registered, waiting for " + "previous recovery attempt to be cancelled or completed").         }     }     RecoverySourceHandler handler = createRecoverySourceHandler(request, shard).     recoveryHandlers.add(handler).     return handler. }
false;private;2;9;;private RecoverySourceHandler createRecoverySourceHandler(StartRecoveryRequest request, IndexShard shard) {     RecoverySourceHandler handler.     final RemoteRecoveryTargetHandler recoveryTarget = new RemoteRecoveryTargetHandler(request.recoveryId(), request.shardId(), transportService, request.targetNode(), recoverySettings, throttleTime -> shard.recoveryStats().addThrottleTime(throttleTime)).     handler = new RecoverySourceHandler(shard, recoveryTarget, request, Math.toIntExact(recoverySettings.getChunkSize().getBytes()), recoverySettings.getMaxConcurrentFileChunks()).     return handler. }
