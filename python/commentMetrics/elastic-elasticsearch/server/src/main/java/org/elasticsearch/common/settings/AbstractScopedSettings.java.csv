# id;timestamp;commentText;codeText;commentWords;codeWords
AbstractScopedSettings -> private boolean isValidDelete(String key, boolean onlyDynamic);1524684173;Returns <code>true</code> if the given key is a valid delete key;private boolean isValidDelete(String key, boolean onlyDynamic) {_        return isFinalSetting(key) == false && _            (onlyDynamic && isDynamicSetting(key)  _                || get(key) == null && key.startsWith(ARCHIVED_SETTINGS_PREFIX) _                || (onlyDynamic == false && get(key) != null))_ _    };returns,code,true,code,if,the,given,key,is,a,valid,delete,key;private,boolean,is,valid,delete,string,key,boolean,only,dynamic,return,is,final,setting,key,false,only,dynamic,is,dynamic,setting,key,get,key,null,key,starts,with,only,dynamic,false,get,key,null
AbstractScopedSettings -> private boolean isValidDelete(String key, boolean onlyDynamic);1528904315;Returns <code>true</code> if the given key is a valid delete key;private boolean isValidDelete(String key, boolean onlyDynamic) {_        return isFinalSetting(key) == false && _            (onlyDynamic && isDynamicSetting(key)  _                || get(key) == null && key.startsWith(ARCHIVED_SETTINGS_PREFIX) _                || (onlyDynamic == false && get(key) != null))_ _    };returns,code,true,code,if,the,given,key,is,a,valid,delete,key;private,boolean,is,valid,delete,string,key,boolean,only,dynamic,return,is,final,setting,key,false,only,dynamic,is,dynamic,setting,key,get,key,null,key,starts,with,only,dynamic,false,get,key,null
AbstractScopedSettings -> private boolean isValidDelete(String key, boolean onlyDynamic);1531179852;Returns <code>true</code> if the given key is a valid delete key;private boolean isValidDelete(String key, boolean onlyDynamic) {_        return isFinalSetting(key) == false && _            (onlyDynamic && isDynamicSetting(key)  _                || get(key) == null && key.startsWith(ARCHIVED_SETTINGS_PREFIX) _                || (onlyDynamic == false && get(key) != null))_ _    };returns,code,true,code,if,the,given,key,is,a,valid,delete,key;private,boolean,is,valid,delete,string,key,boolean,only,dynamic,return,is,final,setting,key,false,only,dynamic,is,dynamic,setting,key,get,key,null,key,starts,with,only,dynamic,false,get,key,null
AbstractScopedSettings -> private boolean isValidDelete(String key, boolean onlyDynamic);1535046779;Returns <code>true</code> if the given key is a valid delete key;private boolean isValidDelete(String key, boolean onlyDynamic) {_        return isFinalSetting(key) == false && _            (onlyDynamic && isDynamicSetting(key)  _                || get(key) == null && key.startsWith(ARCHIVED_SETTINGS_PREFIX) _                || (onlyDynamic == false && get(key) != null))_ _    };returns,code,true,code,if,the,given,key,is,a,valid,delete,key;private,boolean,is,valid,delete,string,key,boolean,only,dynamic,return,is,final,setting,key,false,only,dynamic,is,dynamic,setting,key,get,key,null,key,starts,with,only,dynamic,false,get,key,null
AbstractScopedSettings -> private boolean isValidDelete(String key, boolean onlyDynamic);1536137328;Returns <code>true</code> if the given key is a valid delete key;private boolean isValidDelete(String key, boolean onlyDynamic) {_        return isFinalSetting(key) == false && _            (onlyDynamic && isDynamicSetting(key)  _                || get(key) == null && key.startsWith(ARCHIVED_SETTINGS_PREFIX) _                || (onlyDynamic == false && get(key) != null))_ _    };returns,code,true,code,if,the,given,key,is,a,valid,delete,key;private,boolean,is,valid,delete,string,key,boolean,only,dynamic,return,is,final,setting,key,false,only,dynamic,is,dynamic,setting,key,get,key,null,key,starts,with,only,dynamic,false,get,key,null
AbstractScopedSettings -> private boolean isValidDelete(String key, boolean onlyDynamic);1536314350;Returns <code>true</code> if the given key is a valid delete key;private boolean isValidDelete(String key, boolean onlyDynamic) {_        return isFinalSetting(key) == false && _            (onlyDynamic && isDynamicSetting(key)  _                || get(key) == null && key.startsWith(ARCHIVED_SETTINGS_PREFIX) _                || (onlyDynamic == false && get(key) != null))_ _    };returns,code,true,code,if,the,given,key,is,a,valid,delete,key;private,boolean,is,valid,delete,string,key,boolean,only,dynamic,return,is,final,setting,key,false,only,dynamic,is,dynamic,setting,key,get,key,null,key,starts,with,only,dynamic,false,get,key,null
AbstractScopedSettings -> private boolean isValidDelete(String key, boolean onlyDynamic);1536611444;Returns <code>true</code> if the given key is a valid delete key;private boolean isValidDelete(String key, boolean onlyDynamic) {_        return isFinalSetting(key) == false && _            (onlyDynamic && isDynamicSetting(key)  _                || get(key) == null && key.startsWith(ARCHIVED_SETTINGS_PREFIX) _                || (onlyDynamic == false && get(key) != null))_ _    };returns,code,true,code,if,the,given,key,is,a,valid,delete,key;private,boolean,is,valid,delete,string,key,boolean,only,dynamic,return,is,final,setting,key,false,only,dynamic,is,dynamic,setting,key,get,key,null,key,starts,with,only,dynamic,false,get,key,null
AbstractScopedSettings -> private boolean isValidDelete(String key, boolean onlyDynamic);1536828374;Returns <code>true</code> if the given key is a valid delete key;private boolean isValidDelete(String key, boolean onlyDynamic) {_        return isFinalSetting(key) == false && _            (onlyDynamic && isDynamicSetting(key)  _                || get(key) == null && key.startsWith(ARCHIVED_SETTINGS_PREFIX) _                || (onlyDynamic == false && get(key) != null))_ _    };returns,code,true,code,if,the,given,key,is,a,valid,delete,key;private,boolean,is,valid,delete,string,key,boolean,only,dynamic,return,is,final,setting,key,false,only,dynamic,is,dynamic,setting,key,get,key,null,key,starts,with,only,dynamic,false,get,key,null
AbstractScopedSettings -> private boolean isValidDelete(String key, boolean onlyDynamic);1539951844;Returns <code>true</code> if the given key is a valid delete key;private boolean isValidDelete(String key, boolean onlyDynamic) {_        return isFinalSetting(key) == false && _            (onlyDynamic && isDynamicSetting(key)  _                || get(key) == null && key.startsWith(ARCHIVED_SETTINGS_PREFIX) _                || (onlyDynamic == false && get(key) != null))_ _    };returns,code,true,code,if,the,given,key,is,a,valid,delete,key;private,boolean,is,valid,delete,string,key,boolean,only,dynamic,return,is,final,setting,key,false,only,dynamic,is,dynamic,setting,key,get,key,null,key,starts,with,only,dynamic,false,get,key,null
AbstractScopedSettings -> private boolean isValidDelete(String key, boolean onlyDynamic);1541008027;Returns <code>true</code> if the given key is a valid delete key;private boolean isValidDelete(String key, boolean onlyDynamic) {_        return isFinalSetting(key) == false && _            (onlyDynamic && isDynamicSetting(key)  _                || get(key) == null && key.startsWith(ARCHIVED_SETTINGS_PREFIX) _                || (onlyDynamic == false && get(key) != null))_ _    };returns,code,true,code,if,the,given,key,is,a,valid,delete,key;private,boolean,is,valid,delete,string,key,boolean,only,dynamic,return,is,final,setting,key,false,only,dynamic,is,dynamic,setting,key,get,key,null,key,starts,with,only,dynamic,false,get,key,null
AbstractScopedSettings -> private boolean isValidDelete(String key, boolean onlyDynamic);1541092382;Returns <code>true</code> if the given key is a valid delete key;private boolean isValidDelete(String key, boolean onlyDynamic) {_        return isFinalSetting(key) == false && _            (onlyDynamic && isDynamicSetting(key)  _                || get(key) == null && key.startsWith(ARCHIVED_SETTINGS_PREFIX) _                || (onlyDynamic == false && get(key) != null))_ _    };returns,code,true,code,if,the,given,key,is,a,valid,delete,key;private,boolean,is,valid,delete,string,key,boolean,only,dynamic,return,is,final,setting,key,false,only,dynamic,is,dynamic,setting,key,get,key,null,key,starts,with,only,dynamic,false,get,key,null
AbstractScopedSettings -> private boolean isValidDelete(String key, boolean onlyDynamic);1542402632;Returns <code>true</code> if the given key is a valid delete key;private boolean isValidDelete(String key, boolean onlyDynamic) {_        return isFinalSetting(key) == false && _            (onlyDynamic && isDynamicSetting(key)  _                || get(key) == null && key.startsWith(ARCHIVED_SETTINGS_PREFIX) _                || (onlyDynamic == false && get(key) != null))_ _    };returns,code,true,code,if,the,given,key,is,a,valid,delete,key;private,boolean,is,valid,delete,string,key,boolean,only,dynamic,return,is,final,setting,key,false,only,dynamic,is,dynamic,setting,key,get,key,null,key,starts,with,only,dynamic,false,get,key,null
AbstractScopedSettings -> private boolean isValidDelete(String key, boolean onlyDynamic);1544081506;Returns <code>true</code> if the given key is a valid delete key;private boolean isValidDelete(String key, boolean onlyDynamic) {_        return isFinalSetting(key) == false && _            (onlyDynamic && isDynamicSetting(key)  _                || get(key) == null && key.startsWith(ARCHIVED_SETTINGS_PREFIX) _                || (onlyDynamic == false && get(key) != null))_ _    };returns,code,true,code,if,the,given,key,is,a,valid,delete,key;private,boolean,is,valid,delete,string,key,boolean,only,dynamic,return,is,final,setting,key,false,only,dynamic,is,dynamic,setting,key,get,key,null,key,starts,with,only,dynamic,false,get,key,null
AbstractScopedSettings -> private boolean isValidDelete(String key, boolean onlyDynamic);1544691774;Returns <code>true</code> if the given key is a valid delete key;private boolean isValidDelete(String key, boolean onlyDynamic) {_        return isFinalSetting(key) == false && _            (onlyDynamic && isDynamicSetting(key)  _                || get(key) == null && key.startsWith(ARCHIVED_SETTINGS_PREFIX) _                || (onlyDynamic == false && get(key) != null))_ _    };returns,code,true,code,if,the,given,key,is,a,valid,delete,key;private,boolean,is,valid,delete,string,key,boolean,only,dynamic,return,is,final,setting,key,false,only,dynamic,is,dynamic,setting,key,get,key,null,key,starts,with,only,dynamic,false,get,key,null
AbstractScopedSettings -> private boolean isValidDelete(String key, boolean onlyDynamic);1546877578;Returns <code>true</code> if the given key is a valid delete key;private boolean isValidDelete(String key, boolean onlyDynamic) {_        return isFinalSetting(key) == false && _            (onlyDynamic && isDynamicSetting(key)  _                || get(key) == null && key.startsWith(ARCHIVED_SETTINGS_PREFIX) _                || (onlyDynamic == false && get(key) != null))_ _    };returns,code,true,code,if,the,given,key,is,a,valid,delete,key;private,boolean,is,valid,delete,string,key,boolean,only,dynamic,return,is,final,setting,key,false,only,dynamic,is,dynamic,setting,key,get,key,null,key,starts,with,only,dynamic,false,get,key,null
AbstractScopedSettings -> private boolean isValidDelete(String key, boolean onlyDynamic);1548270339;Returns <code>true</code> if the given key is a valid delete key;private boolean isValidDelete(String key, boolean onlyDynamic) {_        return isFinalSetting(key) == false && _            (onlyDynamic && isDynamicSetting(key)  _                || get(key) == null && key.startsWith(ARCHIVED_SETTINGS_PREFIX) _                || (onlyDynamic == false && get(key) != null))_ _    };returns,code,true,code,if,the,given,key,is,a,valid,delete,key;private,boolean,is,valid,delete,string,key,boolean,only,dynamic,return,is,final,setting,key,false,only,dynamic,is,dynamic,setting,key,get,key,null,key,starts,with,only,dynamic,false,get,key,null
AbstractScopedSettings -> SettingUpdater -> default Runnable updater(Settings current, Settings previous);1524684173;Returns a callable runnable that calls {@link #apply(Object, Settings, Settings)} if the settings_actually changed. This allows to defer the update to a later point in time while keeping type safety._If the value didn't change the returned runnable is a noop.;default Runnable updater(Settings current, Settings previous) {_            if (hasChanged(current, previous)) {_                T value = getValue(current, previous)__                return () -> { apply(value, current, previous)_}__            }_            return () -> {}__        };returns,a,callable,runnable,that,calls,link,apply,object,settings,settings,if,the,settings,actually,changed,this,allows,to,defer,the,update,to,a,later,point,in,time,while,keeping,type,safety,if,the,value,didn,t,change,the,returned,runnable,is,a,noop;default,runnable,updater,settings,current,settings,previous,if,has,changed,current,previous,t,value,get,value,current,previous,return,apply,value,current,previous,return
AbstractScopedSettings -> SettingUpdater -> default Runnable updater(Settings current, Settings previous);1528904315;Returns a callable runnable that calls {@link #apply(Object, Settings, Settings)} if the settings_actually changed. This allows to defer the update to a later point in time while keeping type safety._If the value didn't change the returned runnable is a noop.;default Runnable updater(Settings current, Settings previous) {_            if (hasChanged(current, previous)) {_                T value = getValue(current, previous)__                return () -> { apply(value, current, previous)_}__            }_            return () -> {}__        };returns,a,callable,runnable,that,calls,link,apply,object,settings,settings,if,the,settings,actually,changed,this,allows,to,defer,the,update,to,a,later,point,in,time,while,keeping,type,safety,if,the,value,didn,t,change,the,returned,runnable,is,a,noop;default,runnable,updater,settings,current,settings,previous,if,has,changed,current,previous,t,value,get,value,current,previous,return,apply,value,current,previous,return
AbstractScopedSettings -> SettingUpdater -> default Runnable updater(Settings current, Settings previous);1531179852;Returns a callable runnable that calls {@link #apply(Object, Settings, Settings)} if the settings_actually changed. This allows to defer the update to a later point in time while keeping type safety._If the value didn't change the returned runnable is a noop.;default Runnable updater(Settings current, Settings previous) {_            if (hasChanged(current, previous)) {_                T value = getValue(current, previous)__                return () -> { apply(value, current, previous)_}__            }_            return () -> {}__        };returns,a,callable,runnable,that,calls,link,apply,object,settings,settings,if,the,settings,actually,changed,this,allows,to,defer,the,update,to,a,later,point,in,time,while,keeping,type,safety,if,the,value,didn,t,change,the,returned,runnable,is,a,noop;default,runnable,updater,settings,current,settings,previous,if,has,changed,current,previous,t,value,get,value,current,previous,return,apply,value,current,previous,return
AbstractScopedSettings -> SettingUpdater -> default Runnable updater(Settings current, Settings previous);1535046779;Returns a callable runnable that calls {@link #apply(Object, Settings, Settings)} if the settings_actually changed. This allows to defer the update to a later point in time while keeping type safety._If the value didn't change the returned runnable is a noop.;default Runnable updater(Settings current, Settings previous) {_            if (hasChanged(current, previous)) {_                T value = getValue(current, previous)__                return () -> { apply(value, current, previous)_}__            }_            return () -> {}__        };returns,a,callable,runnable,that,calls,link,apply,object,settings,settings,if,the,settings,actually,changed,this,allows,to,defer,the,update,to,a,later,point,in,time,while,keeping,type,safety,if,the,value,didn,t,change,the,returned,runnable,is,a,noop;default,runnable,updater,settings,current,settings,previous,if,has,changed,current,previous,t,value,get,value,current,previous,return,apply,value,current,previous,return
AbstractScopedSettings -> SettingUpdater -> default Runnable updater(Settings current, Settings previous);1536137328;Returns a callable runnable that calls {@link #apply(Object, Settings, Settings)} if the settings_actually changed. This allows to defer the update to a later point in time while keeping type safety._If the value didn't change the returned runnable is a noop.;default Runnable updater(Settings current, Settings previous) {_            if (hasChanged(current, previous)) {_                T value = getValue(current, previous)__                return () -> { apply(value, current, previous)_}__            }_            return () -> {}__        };returns,a,callable,runnable,that,calls,link,apply,object,settings,settings,if,the,settings,actually,changed,this,allows,to,defer,the,update,to,a,later,point,in,time,while,keeping,type,safety,if,the,value,didn,t,change,the,returned,runnable,is,a,noop;default,runnable,updater,settings,current,settings,previous,if,has,changed,current,previous,t,value,get,value,current,previous,return,apply,value,current,previous,return
AbstractScopedSettings -> SettingUpdater -> default Runnable updater(Settings current, Settings previous);1536314350;Returns a callable runnable that calls {@link #apply(Object, Settings, Settings)} if the settings_actually changed. This allows to defer the update to a later point in time while keeping type safety._If the value didn't change the returned runnable is a noop.;default Runnable updater(Settings current, Settings previous) {_            if (hasChanged(current, previous)) {_                T value = getValue(current, previous)__                return () -> { apply(value, current, previous)_}__            }_            return () -> {}__        };returns,a,callable,runnable,that,calls,link,apply,object,settings,settings,if,the,settings,actually,changed,this,allows,to,defer,the,update,to,a,later,point,in,time,while,keeping,type,safety,if,the,value,didn,t,change,the,returned,runnable,is,a,noop;default,runnable,updater,settings,current,settings,previous,if,has,changed,current,previous,t,value,get,value,current,previous,return,apply,value,current,previous,return
AbstractScopedSettings -> SettingUpdater -> default Runnable updater(Settings current, Settings previous);1536611444;Returns a callable runnable that calls {@link #apply(Object, Settings, Settings)} if the settings_actually changed. This allows to defer the update to a later point in time while keeping type safety._If the value didn't change the returned runnable is a noop.;default Runnable updater(Settings current, Settings previous) {_            if (hasChanged(current, previous)) {_                T value = getValue(current, previous)__                return () -> { apply(value, current, previous)_}__            }_            return () -> {}__        };returns,a,callable,runnable,that,calls,link,apply,object,settings,settings,if,the,settings,actually,changed,this,allows,to,defer,the,update,to,a,later,point,in,time,while,keeping,type,safety,if,the,value,didn,t,change,the,returned,runnable,is,a,noop;default,runnable,updater,settings,current,settings,previous,if,has,changed,current,previous,t,value,get,value,current,previous,return,apply,value,current,previous,return
AbstractScopedSettings -> SettingUpdater -> default Runnable updater(Settings current, Settings previous);1536828374;Returns a callable runnable that calls {@link #apply(Object, Settings, Settings)} if the settings_actually changed. This allows to defer the update to a later point in time while keeping type safety._If the value didn't change the returned runnable is a noop.;default Runnable updater(Settings current, Settings previous) {_            if (hasChanged(current, previous)) {_                T value = getValue(current, previous)__                return () -> { apply(value, current, previous)_}__            }_            return () -> {}__        };returns,a,callable,runnable,that,calls,link,apply,object,settings,settings,if,the,settings,actually,changed,this,allows,to,defer,the,update,to,a,later,point,in,time,while,keeping,type,safety,if,the,value,didn,t,change,the,returned,runnable,is,a,noop;default,runnable,updater,settings,current,settings,previous,if,has,changed,current,previous,t,value,get,value,current,previous,return,apply,value,current,previous,return
AbstractScopedSettings -> SettingUpdater -> default Runnable updater(Settings current, Settings previous);1539951844;Returns a callable runnable that calls {@link #apply(Object, Settings, Settings)} if the settings_actually changed. This allows to defer the update to a later point in time while keeping type safety._If the value didn't change the returned runnable is a noop.;default Runnable updater(Settings current, Settings previous) {_            if (hasChanged(current, previous)) {_                T value = getValue(current, previous)__                return () -> { apply(value, current, previous)_}__            }_            return () -> {}__        };returns,a,callable,runnable,that,calls,link,apply,object,settings,settings,if,the,settings,actually,changed,this,allows,to,defer,the,update,to,a,later,point,in,time,while,keeping,type,safety,if,the,value,didn,t,change,the,returned,runnable,is,a,noop;default,runnable,updater,settings,current,settings,previous,if,has,changed,current,previous,t,value,get,value,current,previous,return,apply,value,current,previous,return
AbstractScopedSettings -> SettingUpdater -> default Runnable updater(Settings current, Settings previous);1541008027;Returns a callable runnable that calls {@link #apply(Object, Settings, Settings)} if the settings_actually changed. This allows to defer the update to a later point in time while keeping type safety._If the value didn't change the returned runnable is a noop.;default Runnable updater(Settings current, Settings previous) {_            if (hasChanged(current, previous)) {_                T value = getValue(current, previous)__                return () -> { apply(value, current, previous)_}__            }_            return () -> {}__        };returns,a,callable,runnable,that,calls,link,apply,object,settings,settings,if,the,settings,actually,changed,this,allows,to,defer,the,update,to,a,later,point,in,time,while,keeping,type,safety,if,the,value,didn,t,change,the,returned,runnable,is,a,noop;default,runnable,updater,settings,current,settings,previous,if,has,changed,current,previous,t,value,get,value,current,previous,return,apply,value,current,previous,return
AbstractScopedSettings -> SettingUpdater -> default Runnable updater(Settings current, Settings previous);1541092382;Returns a callable runnable that calls {@link #apply(Object, Settings, Settings)} if the settings_actually changed. This allows to defer the update to a later point in time while keeping type safety._If the value didn't change the returned runnable is a noop.;default Runnable updater(Settings current, Settings previous) {_            if (hasChanged(current, previous)) {_                T value = getValue(current, previous)__                return () -> { apply(value, current, previous)_}__            }_            return () -> {}__        };returns,a,callable,runnable,that,calls,link,apply,object,settings,settings,if,the,settings,actually,changed,this,allows,to,defer,the,update,to,a,later,point,in,time,while,keeping,type,safety,if,the,value,didn,t,change,the,returned,runnable,is,a,noop;default,runnable,updater,settings,current,settings,previous,if,has,changed,current,previous,t,value,get,value,current,previous,return,apply,value,current,previous,return
AbstractScopedSettings -> SettingUpdater -> default Runnable updater(Settings current, Settings previous);1542402632;Returns a callable runnable that calls {@link #apply(Object, Settings, Settings)} if the settings_actually changed. This allows to defer the update to a later point in time while keeping type safety._If the value didn't change the returned runnable is a noop.;default Runnable updater(Settings current, Settings previous) {_            if (hasChanged(current, previous)) {_                T value = getValue(current, previous)__                return () -> { apply(value, current, previous)_}__            }_            return () -> {}__        };returns,a,callable,runnable,that,calls,link,apply,object,settings,settings,if,the,settings,actually,changed,this,allows,to,defer,the,update,to,a,later,point,in,time,while,keeping,type,safety,if,the,value,didn,t,change,the,returned,runnable,is,a,noop;default,runnable,updater,settings,current,settings,previous,if,has,changed,current,previous,t,value,get,value,current,previous,return,apply,value,current,previous,return
AbstractScopedSettings -> SettingUpdater -> default Runnable updater(Settings current, Settings previous);1544081506;Returns a callable runnable that calls {@link #apply(Object, Settings, Settings)} if the settings_actually changed. This allows to defer the update to a later point in time while keeping type safety._If the value didn't change the returned runnable is a noop.;default Runnable updater(Settings current, Settings previous) {_            if (hasChanged(current, previous)) {_                T value = getValue(current, previous)__                return () -> { apply(value, current, previous)_}__            }_            return () -> {}__        };returns,a,callable,runnable,that,calls,link,apply,object,settings,settings,if,the,settings,actually,changed,this,allows,to,defer,the,update,to,a,later,point,in,time,while,keeping,type,safety,if,the,value,didn,t,change,the,returned,runnable,is,a,noop;default,runnable,updater,settings,current,settings,previous,if,has,changed,current,previous,t,value,get,value,current,previous,return,apply,value,current,previous,return
AbstractScopedSettings -> SettingUpdater -> default Runnable updater(Settings current, Settings previous);1544691774;Returns a callable runnable that calls {@link #apply(Object, Settings, Settings)} if the settings_actually changed. This allows to defer the update to a later point in time while keeping type safety._If the value didn't change the returned runnable is a noop.;default Runnable updater(Settings current, Settings previous) {_            if (hasChanged(current, previous)) {_                T value = getValue(current, previous)__                return () -> { apply(value, current, previous)_}__            }_            return () -> {}__        };returns,a,callable,runnable,that,calls,link,apply,object,settings,settings,if,the,settings,actually,changed,this,allows,to,defer,the,update,to,a,later,point,in,time,while,keeping,type,safety,if,the,value,didn,t,change,the,returned,runnable,is,a,noop;default,runnable,updater,settings,current,settings,previous,if,has,changed,current,previous,t,value,get,value,current,previous,return,apply,value,current,previous,return
AbstractScopedSettings -> SettingUpdater -> default Runnable updater(Settings current, Settings previous);1546877578;Returns a callable runnable that calls {@link #apply(Object, Settings, Settings)} if the settings_actually changed. This allows to defer the update to a later point in time while keeping type safety._If the value didn't change the returned runnable is a noop.;default Runnable updater(Settings current, Settings previous) {_            if (hasChanged(current, previous)) {_                T value = getValue(current, previous)__                return () -> { apply(value, current, previous)_}__            }_            return () -> {}__        };returns,a,callable,runnable,that,calls,link,apply,object,settings,settings,if,the,settings,actually,changed,this,allows,to,defer,the,update,to,a,later,point,in,time,while,keeping,type,safety,if,the,value,didn,t,change,the,returned,runnable,is,a,noop;default,runnable,updater,settings,current,settings,previous,if,has,changed,current,previous,t,value,get,value,current,previous,return,apply,value,current,previous,return
AbstractScopedSettings -> SettingUpdater -> default Runnable updater(Settings current, Settings previous);1548270339;Returns a callable runnable that calls {@link #apply(Object, Settings, Settings)} if the settings_actually changed. This allows to defer the update to a later point in time while keeping type safety._If the value didn't change the returned runnable is a noop.;default Runnable updater(Settings current, Settings previous) {_            if (hasChanged(current, previous)) {_                T value = getValue(current, previous)__                return () -> { apply(value, current, previous)_}__            }_            return () -> {}__        };returns,a,callable,runnable,that,calls,link,apply,object,settings,settings,if,the,settings,actually,changed,this,allows,to,defer,the,update,to,a,later,point,in,time,while,keeping,type,safety,if,the,value,didn,t,change,the,returned,runnable,is,a,noop;default,runnable,updater,settings,current,settings,previous,if,has,changed,current,previous,t,value,get,value,current,previous,return,apply,value,current,previous,return
AbstractScopedSettings -> public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer);1524684173;Adds a settings consumer._<p>_Note: Only settings registered in {@link org.elasticsearch.cluster.ClusterModule} can be changed dynamically._</p>;public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer) {_       addSettingsUpdateConsumer(setting, consumer, (s) -> {})__    };adds,a,settings,consumer,p,note,only,settings,registered,in,link,org,elasticsearch,cluster,cluster,module,can,be,changed,dynamically,p;public,synchronized,t,void,add,settings,update,consumer,setting,t,setting,consumer,t,consumer,add,settings,update,consumer,setting,consumer,s
AbstractScopedSettings -> public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer);1528904315;Adds a settings consumer._<p>_Note: Only settings registered in {@link org.elasticsearch.cluster.ClusterModule} can be changed dynamically._</p>;public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer) {_       addSettingsUpdateConsumer(setting, consumer, (s) -> {})__    };adds,a,settings,consumer,p,note,only,settings,registered,in,link,org,elasticsearch,cluster,cluster,module,can,be,changed,dynamically,p;public,synchronized,t,void,add,settings,update,consumer,setting,t,setting,consumer,t,consumer,add,settings,update,consumer,setting,consumer,s
AbstractScopedSettings -> public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer);1531179852;Adds a settings consumer._<p>_Note: Only settings registered in {@link org.elasticsearch.cluster.ClusterModule} can be changed dynamically._</p>;public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer) {_       addSettingsUpdateConsumer(setting, consumer, (s) -> {})__    };adds,a,settings,consumer,p,note,only,settings,registered,in,link,org,elasticsearch,cluster,cluster,module,can,be,changed,dynamically,p;public,synchronized,t,void,add,settings,update,consumer,setting,t,setting,consumer,t,consumer,add,settings,update,consumer,setting,consumer,s
AbstractScopedSettings -> public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer);1535046779;Adds a settings consumer._<p>_Note: Only settings registered in {@link org.elasticsearch.cluster.ClusterModule} can be changed dynamically._</p>;public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer) {_       addSettingsUpdateConsumer(setting, consumer, (s) -> {})__    };adds,a,settings,consumer,p,note,only,settings,registered,in,link,org,elasticsearch,cluster,cluster,module,can,be,changed,dynamically,p;public,synchronized,t,void,add,settings,update,consumer,setting,t,setting,consumer,t,consumer,add,settings,update,consumer,setting,consumer,s
AbstractScopedSettings -> public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer);1536137328;Adds a settings consumer._<p>_Note: Only settings registered in {@link org.elasticsearch.cluster.ClusterModule} can be changed dynamically._</p>;public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer) {_       addSettingsUpdateConsumer(setting, consumer, (s) -> {})__    };adds,a,settings,consumer,p,note,only,settings,registered,in,link,org,elasticsearch,cluster,cluster,module,can,be,changed,dynamically,p;public,synchronized,t,void,add,settings,update,consumer,setting,t,setting,consumer,t,consumer,add,settings,update,consumer,setting,consumer,s
AbstractScopedSettings -> public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer);1536314350;Adds a settings consumer._<p>_Note: Only settings registered in {@link org.elasticsearch.cluster.ClusterModule} can be changed dynamically._</p>;public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer) {_       addSettingsUpdateConsumer(setting, consumer, (s) -> {})__    };adds,a,settings,consumer,p,note,only,settings,registered,in,link,org,elasticsearch,cluster,cluster,module,can,be,changed,dynamically,p;public,synchronized,t,void,add,settings,update,consumer,setting,t,setting,consumer,t,consumer,add,settings,update,consumer,setting,consumer,s
AbstractScopedSettings -> public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer);1536611444;Adds a settings consumer._<p>_Note: Only settings registered in {@link org.elasticsearch.cluster.ClusterModule} can be changed dynamically._</p>;public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer) {_       addSettingsUpdateConsumer(setting, consumer, (s) -> {})__    };adds,a,settings,consumer,p,note,only,settings,registered,in,link,org,elasticsearch,cluster,cluster,module,can,be,changed,dynamically,p;public,synchronized,t,void,add,settings,update,consumer,setting,t,setting,consumer,t,consumer,add,settings,update,consumer,setting,consumer,s
AbstractScopedSettings -> public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer);1536828374;Adds a settings consumer._<p>_Note: Only settings registered in {@link org.elasticsearch.cluster.ClusterModule} can be changed dynamically._</p>;public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer) {_       addSettingsUpdateConsumer(setting, consumer, (s) -> {})__    };adds,a,settings,consumer,p,note,only,settings,registered,in,link,org,elasticsearch,cluster,cluster,module,can,be,changed,dynamically,p;public,synchronized,t,void,add,settings,update,consumer,setting,t,setting,consumer,t,consumer,add,settings,update,consumer,setting,consumer,s
AbstractScopedSettings -> public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer);1539951844;Adds a settings consumer._<p>_Note: Only settings registered in {@link org.elasticsearch.cluster.ClusterModule} can be changed dynamically._</p>;public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer) {_       addSettingsUpdateConsumer(setting, consumer, (s) -> {})__    };adds,a,settings,consumer,p,note,only,settings,registered,in,link,org,elasticsearch,cluster,cluster,module,can,be,changed,dynamically,p;public,synchronized,t,void,add,settings,update,consumer,setting,t,setting,consumer,t,consumer,add,settings,update,consumer,setting,consumer,s
AbstractScopedSettings -> public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer);1541008027;Adds a settings consumer._<p>_Note: Only settings registered in {@link org.elasticsearch.cluster.ClusterModule} can be changed dynamically._</p>;public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer) {_       addSettingsUpdateConsumer(setting, consumer, (s) -> {})__    };adds,a,settings,consumer,p,note,only,settings,registered,in,link,org,elasticsearch,cluster,cluster,module,can,be,changed,dynamically,p;public,synchronized,t,void,add,settings,update,consumer,setting,t,setting,consumer,t,consumer,add,settings,update,consumer,setting,consumer,s
AbstractScopedSettings -> public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer);1541092382;Adds a settings consumer._<p>_Note: Only settings registered in {@link org.elasticsearch.cluster.ClusterModule} can be changed dynamically._</p>;public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer) {_       addSettingsUpdateConsumer(setting, consumer, (s) -> {})__    };adds,a,settings,consumer,p,note,only,settings,registered,in,link,org,elasticsearch,cluster,cluster,module,can,be,changed,dynamically,p;public,synchronized,t,void,add,settings,update,consumer,setting,t,setting,consumer,t,consumer,add,settings,update,consumer,setting,consumer,s
AbstractScopedSettings -> public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer);1542402632;Adds a settings consumer._<p>_Note: Only settings registered in {@link org.elasticsearch.cluster.ClusterModule} can be changed dynamically._</p>;public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer) {_       addSettingsUpdateConsumer(setting, consumer, (s) -> {})__    };adds,a,settings,consumer,p,note,only,settings,registered,in,link,org,elasticsearch,cluster,cluster,module,can,be,changed,dynamically,p;public,synchronized,t,void,add,settings,update,consumer,setting,t,setting,consumer,t,consumer,add,settings,update,consumer,setting,consumer,s
AbstractScopedSettings -> public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer);1544081506;Adds a settings consumer._<p>_Note: Only settings registered in {@link org.elasticsearch.cluster.ClusterModule} can be changed dynamically._</p>;public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer) {_       addSettingsUpdateConsumer(setting, consumer, (s) -> {})__    };adds,a,settings,consumer,p,note,only,settings,registered,in,link,org,elasticsearch,cluster,cluster,module,can,be,changed,dynamically,p;public,synchronized,t,void,add,settings,update,consumer,setting,t,setting,consumer,t,consumer,add,settings,update,consumer,setting,consumer,s
AbstractScopedSettings -> public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer);1544691774;Adds a settings consumer._<p>_Note: Only settings registered in {@link org.elasticsearch.cluster.ClusterModule} can be changed dynamically._</p>;public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer) {_       addSettingsUpdateConsumer(setting, consumer, (s) -> {})__    };adds,a,settings,consumer,p,note,only,settings,registered,in,link,org,elasticsearch,cluster,cluster,module,can,be,changed,dynamically,p;public,synchronized,t,void,add,settings,update,consumer,setting,t,setting,consumer,t,consumer,add,settings,update,consumer,setting,consumer,s
AbstractScopedSettings -> public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer);1546877578;Adds a settings consumer._<p>_Note: Only settings registered in {@link org.elasticsearch.cluster.ClusterModule} can be changed dynamically._</p>;public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer) {_       addSettingsUpdateConsumer(setting, consumer, (s) -> {})__    };adds,a,settings,consumer,p,note,only,settings,registered,in,link,org,elasticsearch,cluster,cluster,module,can,be,changed,dynamically,p;public,synchronized,t,void,add,settings,update,consumer,setting,t,setting,consumer,t,consumer,add,settings,update,consumer,setting,consumer,s
AbstractScopedSettings -> public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer);1548270339;Adds a settings consumer._<p>_Note: Only settings registered in {@link org.elasticsearch.cluster.ClusterModule} can be changed dynamically._</p>;public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer) {_       addSettingsUpdateConsumer(setting, consumer, (s) -> {})__    };adds,a,settings,consumer,p,note,only,settings,registered,in,link,org,elasticsearch,cluster,cluster,module,can,be,changed,dynamically,p;public,synchronized,t,void,add,settings,update,consumer,setting,t,setting,consumer,t,consumer,add,settings,update,consumer,setting,consumer,s
AbstractScopedSettings -> SettingUpdater -> void apply(T value, Settings current, Settings previous)_;1524684173;Applies the given value to the updater. This methods will actually run the update.;void apply(T value, Settings current, Settings previous)_;applies,the,given,value,to,the,updater,this,methods,will,actually,run,the,update;void,apply,t,value,settings,current,settings,previous
AbstractScopedSettings -> SettingUpdater -> void apply(T value, Settings current, Settings previous)_;1528904315;Applies the given value to the updater. This methods will actually run the update.;void apply(T value, Settings current, Settings previous)_;applies,the,given,value,to,the,updater,this,methods,will,actually,run,the,update;void,apply,t,value,settings,current,settings,previous
AbstractScopedSettings -> SettingUpdater -> void apply(T value, Settings current, Settings previous)_;1531179852;Applies the given value to the updater. This methods will actually run the update.;void apply(T value, Settings current, Settings previous)_;applies,the,given,value,to,the,updater,this,methods,will,actually,run,the,update;void,apply,t,value,settings,current,settings,previous
AbstractScopedSettings -> SettingUpdater -> void apply(T value, Settings current, Settings previous)_;1535046779;Applies the given value to the updater. This methods will actually run the update.;void apply(T value, Settings current, Settings previous)_;applies,the,given,value,to,the,updater,this,methods,will,actually,run,the,update;void,apply,t,value,settings,current,settings,previous
AbstractScopedSettings -> SettingUpdater -> void apply(T value, Settings current, Settings previous)_;1536137328;Applies the given value to the updater. This methods will actually run the update.;void apply(T value, Settings current, Settings previous)_;applies,the,given,value,to,the,updater,this,methods,will,actually,run,the,update;void,apply,t,value,settings,current,settings,previous
AbstractScopedSettings -> SettingUpdater -> void apply(T value, Settings current, Settings previous)_;1536314350;Applies the given value to the updater. This methods will actually run the update.;void apply(T value, Settings current, Settings previous)_;applies,the,given,value,to,the,updater,this,methods,will,actually,run,the,update;void,apply,t,value,settings,current,settings,previous
AbstractScopedSettings -> SettingUpdater -> void apply(T value, Settings current, Settings previous)_;1536611444;Applies the given value to the updater. This methods will actually run the update.;void apply(T value, Settings current, Settings previous)_;applies,the,given,value,to,the,updater,this,methods,will,actually,run,the,update;void,apply,t,value,settings,current,settings,previous
AbstractScopedSettings -> SettingUpdater -> void apply(T value, Settings current, Settings previous)_;1536828374;Applies the given value to the updater. This methods will actually run the update.;void apply(T value, Settings current, Settings previous)_;applies,the,given,value,to,the,updater,this,methods,will,actually,run,the,update;void,apply,t,value,settings,current,settings,previous
AbstractScopedSettings -> SettingUpdater -> void apply(T value, Settings current, Settings previous)_;1539951844;Applies the given value to the updater. This methods will actually run the update.;void apply(T value, Settings current, Settings previous)_;applies,the,given,value,to,the,updater,this,methods,will,actually,run,the,update;void,apply,t,value,settings,current,settings,previous
AbstractScopedSettings -> SettingUpdater -> void apply(T value, Settings current, Settings previous)_;1541008027;Applies the given value to the updater. This methods will actually run the update.;void apply(T value, Settings current, Settings previous)_;applies,the,given,value,to,the,updater,this,methods,will,actually,run,the,update;void,apply,t,value,settings,current,settings,previous
AbstractScopedSettings -> SettingUpdater -> void apply(T value, Settings current, Settings previous)_;1541092382;Applies the given value to the updater. This methods will actually run the update.;void apply(T value, Settings current, Settings previous)_;applies,the,given,value,to,the,updater,this,methods,will,actually,run,the,update;void,apply,t,value,settings,current,settings,previous
AbstractScopedSettings -> SettingUpdater -> void apply(T value, Settings current, Settings previous)_;1542402632;Applies the given value to the updater. This methods will actually run the update.;void apply(T value, Settings current, Settings previous)_;applies,the,given,value,to,the,updater,this,methods,will,actually,run,the,update;void,apply,t,value,settings,current,settings,previous
AbstractScopedSettings -> SettingUpdater -> void apply(T value, Settings current, Settings previous)_;1544081506;Applies the given value to the updater. This methods will actually run the update.;void apply(T value, Settings current, Settings previous)_;applies,the,given,value,to,the,updater,this,methods,will,actually,run,the,update;void,apply,t,value,settings,current,settings,previous
AbstractScopedSettings -> SettingUpdater -> void apply(T value, Settings current, Settings previous)_;1544691774;Applies the given value to the updater. This methods will actually run the update.;void apply(T value, Settings current, Settings previous)_;applies,the,given,value,to,the,updater,this,methods,will,actually,run,the,update;void,apply,t,value,settings,current,settings,previous
AbstractScopedSettings -> SettingUpdater -> void apply(T value, Settings current, Settings previous)_;1546877578;Applies the given value to the updater. This methods will actually run the update.;void apply(T value, Settings current, Settings previous)_;applies,the,given,value,to,the,updater,this,methods,will,actually,run,the,update;void,apply,t,value,settings,current,settings,previous
AbstractScopedSettings -> SettingUpdater -> void apply(T value, Settings current, Settings previous)_;1548270339;Applies the given value to the updater. This methods will actually run the update.;void apply(T value, Settings current, Settings previous)_;applies,the,given,value,to,the,updater,this,methods,will,actually,run,the,update;void,apply,t,value,settings,current,settings,previous
AbstractScopedSettings -> public synchronized <A,B> void addAffixUpdateConsumer(Setting.AffixSetting<A> settingA, Setting.AffixSetting<B> settingB,                                                           BiConsumer<String, Tuple<A, B>> consumer,                                                           BiConsumer<String, Tuple<A, B>> validator);1535046779;Adds a affix settings consumer that accepts the values for two settings. The consumer is only notified if one or both settings change_and if the provided validator succeeded._<p>_Note: Only settings registered in {@link SettingsModule} can be changed dynamically._</p>_This method registers a compound updater that is useful if two settings are depending on each other._The consumer is always provided with both values even if only one of the two changes.;public synchronized <A,B> void addAffixUpdateConsumer(Setting.AffixSetting<A> settingA, Setting.AffixSetting<B> settingB,_                                                          BiConsumer<String, Tuple<A, B>> consumer,_                                                          BiConsumer<String, Tuple<A, B>> validator) {_        _        _        ensureSettingIsRegistered(settingA)__        ensureSettingIsRegistered(settingB)__        SettingUpdater<Map<SettingUpdater<A>, A>> affixUpdaterA = settingA.newAffixUpdater((a,b)-> {}, logger, (a,b)-> {})__        SettingUpdater<Map<SettingUpdater<B>, B>> affixUpdaterB = settingB.newAffixUpdater((a,b)-> {}, logger, (a,b)-> {})___        addSettingsUpdater(new SettingUpdater<Map<String, Tuple<A, B>>>() {__            @Override_            public boolean hasChanged(Settings current, Settings previous) {_                return affixUpdaterA.hasChanged(current, previous) || affixUpdaterB.hasChanged(current, previous)__            }__            @Override_            public Map<String, Tuple<A, B>> getValue(Settings current, Settings previous) {_                Map<String, Tuple<A, B>> map = new HashMap<>()__                BiConsumer<String, A> aConsumer = (key, value) -> {_                    assert map.containsKey(key) == false : "duplicate key: " + key__                    map.put(key, new Tuple<>(value, settingB.getConcreteSettingForNamespace(key).get(current)))__                }__                BiConsumer<String, B> bConsumer = (key, value) -> {_                    Tuple<A, B> abTuple = map.get(key)__                    if (abTuple != null) {_                        map.put(key, new Tuple<>(abTuple.v1(), value))__                    } else {_                        assert settingA.getConcreteSettingForNamespace(key).get(current).equals(settingA.getConcreteSettingForNamespace_                            (key).get(previous)) : "expected: " + settingA.getConcreteSettingForNamespace(key).get(current)_                            + " but was " + settingA.getConcreteSettingForNamespace(key).get(previous)__                        map.put(key, new Tuple<>(settingA.getConcreteSettingForNamespace(key).get(current), value))__                    }_                }__                SettingUpdater<Map<SettingUpdater<A>, A>> affixUpdaterA = settingA.newAffixUpdater(aConsumer, logger, (a,b) ->{})__                SettingUpdater<Map<SettingUpdater<B>, B>> affixUpdaterB = settingB.newAffixUpdater(bConsumer, logger, (a,b) ->{})__                affixUpdaterA.apply(current, previous)__                affixUpdaterB.apply(current, previous)__                for (Map.Entry<String, Tuple<A, B>> entry : map.entrySet()) {_                    validator.accept(entry.getKey(), entry.getValue())__                }_                return Collections.unmodifiableMap(map)__            }__            @Override_            public void apply(Map<String, Tuple<A, B>> values, Settings current, Settings previous) {_                for (Map.Entry<String, Tuple<A, B>> entry : values.entrySet()) {_                    consumer.accept(entry.getKey(), entry.getValue())__                }_            }_        })__    };adds,a,affix,settings,consumer,that,accepts,the,values,for,two,settings,the,consumer,is,only,notified,if,one,or,both,settings,change,and,if,the,provided,validator,succeeded,p,note,only,settings,registered,in,link,settings,module,can,be,changed,dynamically,p,this,method,registers,a,compound,updater,that,is,useful,if,two,settings,are,depending,on,each,other,the,consumer,is,always,provided,with,both,values,even,if,only,one,of,the,two,changes;public,synchronized,a,b,void,add,affix,update,consumer,setting,affix,setting,a,setting,a,setting,affix,setting,b,setting,b,bi,consumer,string,tuple,a,b,consumer,bi,consumer,string,tuple,a,b,validator,ensure,setting,is,registered,setting,a,ensure,setting,is,registered,setting,b,setting,updater,map,setting,updater,a,a,affix,updater,a,setting,a,new,affix,updater,a,b,logger,a,b,setting,updater,map,setting,updater,b,b,affix,updater,b,setting,b,new,affix,updater,a,b,logger,a,b,add,settings,updater,new,setting,updater,map,string,tuple,a,b,override,public,boolean,has,changed,settings,current,settings,previous,return,affix,updater,a,has,changed,current,previous,affix,updater,b,has,changed,current,previous,override,public,map,string,tuple,a,b,get,value,settings,current,settings,previous,map,string,tuple,a,b,map,new,hash,map,bi,consumer,string,a,a,consumer,key,value,assert,map,contains,key,key,false,duplicate,key,key,map,put,key,new,tuple,value,setting,b,get,concrete,setting,for,namespace,key,get,current,bi,consumer,string,b,b,consumer,key,value,tuple,a,b,ab,tuple,map,get,key,if,ab,tuple,null,map,put,key,new,tuple,ab,tuple,v1,value,else,assert,setting,a,get,concrete,setting,for,namespace,key,get,current,equals,setting,a,get,concrete,setting,for,namespace,key,get,previous,expected,setting,a,get,concrete,setting,for,namespace,key,get,current,but,was,setting,a,get,concrete,setting,for,namespace,key,get,previous,map,put,key,new,tuple,setting,a,get,concrete,setting,for,namespace,key,get,current,value,setting,updater,map,setting,updater,a,a,affix,updater,a,setting,a,new,affix,updater,a,consumer,logger,a,b,setting,updater,map,setting,updater,b,b,affix,updater,b,setting,b,new,affix,updater,b,consumer,logger,a,b,affix,updater,a,apply,current,previous,affix,updater,b,apply,current,previous,for,map,entry,string,tuple,a,b,entry,map,entry,set,validator,accept,entry,get,key,entry,get,value,return,collections,unmodifiable,map,map,override,public,void,apply,map,string,tuple,a,b,values,settings,current,settings,previous,for,map,entry,string,tuple,a,b,entry,values,entry,set,consumer,accept,entry,get,key,entry,get,value
AbstractScopedSettings -> public synchronized <A,B> void addAffixUpdateConsumer(Setting.AffixSetting<A> settingA, Setting.AffixSetting<B> settingB,                                                           BiConsumer<String, Tuple<A, B>> consumer,                                                           BiConsumer<String, Tuple<A, B>> validator);1536137328;Adds a affix settings consumer that accepts the values for two settings. The consumer is only notified if one or both settings change_and if the provided validator succeeded._<p>_Note: Only settings registered in {@link SettingsModule} can be changed dynamically._</p>_This method registers a compound updater that is useful if two settings are depending on each other._The consumer is always provided with both values even if only one of the two changes.;public synchronized <A,B> void addAffixUpdateConsumer(Setting.AffixSetting<A> settingA, Setting.AffixSetting<B> settingB,_                                                          BiConsumer<String, Tuple<A, B>> consumer,_                                                          BiConsumer<String, Tuple<A, B>> validator) {_        _        _        ensureSettingIsRegistered(settingA)__        ensureSettingIsRegistered(settingB)__        SettingUpdater<Map<SettingUpdater<A>, A>> affixUpdaterA = settingA.newAffixUpdater((a,b)-> {}, logger, (a,b)-> {})__        SettingUpdater<Map<SettingUpdater<B>, B>> affixUpdaterB = settingB.newAffixUpdater((a,b)-> {}, logger, (a,b)-> {})___        addSettingsUpdater(new SettingUpdater<Map<String, Tuple<A, B>>>() {__            @Override_            public boolean hasChanged(Settings current, Settings previous) {_                return affixUpdaterA.hasChanged(current, previous) || affixUpdaterB.hasChanged(current, previous)__            }__            @Override_            public Map<String, Tuple<A, B>> getValue(Settings current, Settings previous) {_                Map<String, Tuple<A, B>> map = new HashMap<>()__                BiConsumer<String, A> aConsumer = (key, value) -> {_                    assert map.containsKey(key) == false : "duplicate key: " + key__                    map.put(key, new Tuple<>(value, settingB.getConcreteSettingForNamespace(key).get(current)))__                }__                BiConsumer<String, B> bConsumer = (key, value) -> {_                    Tuple<A, B> abTuple = map.get(key)__                    if (abTuple != null) {_                        map.put(key, new Tuple<>(abTuple.v1(), value))__                    } else {_                        assert settingA.getConcreteSettingForNamespace(key).get(current).equals(settingA.getConcreteSettingForNamespace_                            (key).get(previous)) : "expected: " + settingA.getConcreteSettingForNamespace(key).get(current)_                            + " but was " + settingA.getConcreteSettingForNamespace(key).get(previous)__                        map.put(key, new Tuple<>(settingA.getConcreteSettingForNamespace(key).get(current), value))__                    }_                }__                SettingUpdater<Map<SettingUpdater<A>, A>> affixUpdaterA = settingA.newAffixUpdater(aConsumer, logger, (a,b) ->{})__                SettingUpdater<Map<SettingUpdater<B>, B>> affixUpdaterB = settingB.newAffixUpdater(bConsumer, logger, (a,b) ->{})__                affixUpdaterA.apply(current, previous)__                affixUpdaterB.apply(current, previous)__                for (Map.Entry<String, Tuple<A, B>> entry : map.entrySet()) {_                    validator.accept(entry.getKey(), entry.getValue())__                }_                return Collections.unmodifiableMap(map)__            }__            @Override_            public void apply(Map<String, Tuple<A, B>> values, Settings current, Settings previous) {_                for (Map.Entry<String, Tuple<A, B>> entry : values.entrySet()) {_                    consumer.accept(entry.getKey(), entry.getValue())__                }_            }_        })__    };adds,a,affix,settings,consumer,that,accepts,the,values,for,two,settings,the,consumer,is,only,notified,if,one,or,both,settings,change,and,if,the,provided,validator,succeeded,p,note,only,settings,registered,in,link,settings,module,can,be,changed,dynamically,p,this,method,registers,a,compound,updater,that,is,useful,if,two,settings,are,depending,on,each,other,the,consumer,is,always,provided,with,both,values,even,if,only,one,of,the,two,changes;public,synchronized,a,b,void,add,affix,update,consumer,setting,affix,setting,a,setting,a,setting,affix,setting,b,setting,b,bi,consumer,string,tuple,a,b,consumer,bi,consumer,string,tuple,a,b,validator,ensure,setting,is,registered,setting,a,ensure,setting,is,registered,setting,b,setting,updater,map,setting,updater,a,a,affix,updater,a,setting,a,new,affix,updater,a,b,logger,a,b,setting,updater,map,setting,updater,b,b,affix,updater,b,setting,b,new,affix,updater,a,b,logger,a,b,add,settings,updater,new,setting,updater,map,string,tuple,a,b,override,public,boolean,has,changed,settings,current,settings,previous,return,affix,updater,a,has,changed,current,previous,affix,updater,b,has,changed,current,previous,override,public,map,string,tuple,a,b,get,value,settings,current,settings,previous,map,string,tuple,a,b,map,new,hash,map,bi,consumer,string,a,a,consumer,key,value,assert,map,contains,key,key,false,duplicate,key,key,map,put,key,new,tuple,value,setting,b,get,concrete,setting,for,namespace,key,get,current,bi,consumer,string,b,b,consumer,key,value,tuple,a,b,ab,tuple,map,get,key,if,ab,tuple,null,map,put,key,new,tuple,ab,tuple,v1,value,else,assert,setting,a,get,concrete,setting,for,namespace,key,get,current,equals,setting,a,get,concrete,setting,for,namespace,key,get,previous,expected,setting,a,get,concrete,setting,for,namespace,key,get,current,but,was,setting,a,get,concrete,setting,for,namespace,key,get,previous,map,put,key,new,tuple,setting,a,get,concrete,setting,for,namespace,key,get,current,value,setting,updater,map,setting,updater,a,a,affix,updater,a,setting,a,new,affix,updater,a,consumer,logger,a,b,setting,updater,map,setting,updater,b,b,affix,updater,b,setting,b,new,affix,updater,b,consumer,logger,a,b,affix,updater,a,apply,current,previous,affix,updater,b,apply,current,previous,for,map,entry,string,tuple,a,b,entry,map,entry,set,validator,accept,entry,get,key,entry,get,value,return,collections,unmodifiable,map,map,override,public,void,apply,map,string,tuple,a,b,values,settings,current,settings,previous,for,map,entry,string,tuple,a,b,entry,values,entry,set,consumer,accept,entry,get,key,entry,get,value
AbstractScopedSettings -> public synchronized <A,B> void addAffixUpdateConsumer(Setting.AffixSetting<A> settingA, Setting.AffixSetting<B> settingB,                                                           BiConsumer<String, Tuple<A, B>> consumer,                                                           BiConsumer<String, Tuple<A, B>> validator);1536314350;Adds a affix settings consumer that accepts the values for two settings. The consumer is only notified if one or both settings change_and if the provided validator succeeded._<p>_Note: Only settings registered in {@link SettingsModule} can be changed dynamically._</p>_This method registers a compound updater that is useful if two settings are depending on each other._The consumer is always provided with both values even if only one of the two changes.;public synchronized <A,B> void addAffixUpdateConsumer(Setting.AffixSetting<A> settingA, Setting.AffixSetting<B> settingB,_                                                          BiConsumer<String, Tuple<A, B>> consumer,_                                                          BiConsumer<String, Tuple<A, B>> validator) {_        _        _        ensureSettingIsRegistered(settingA)__        ensureSettingIsRegistered(settingB)__        SettingUpdater<Map<SettingUpdater<A>, A>> affixUpdaterA = settingA.newAffixUpdater((a,b)-> {}, logger, (a,b)-> {})__        SettingUpdater<Map<SettingUpdater<B>, B>> affixUpdaterB = settingB.newAffixUpdater((a,b)-> {}, logger, (a,b)-> {})___        addSettingsUpdater(new SettingUpdater<Map<String, Tuple<A, B>>>() {__            @Override_            public boolean hasChanged(Settings current, Settings previous) {_                return affixUpdaterA.hasChanged(current, previous) || affixUpdaterB.hasChanged(current, previous)__            }__            @Override_            public Map<String, Tuple<A, B>> getValue(Settings current, Settings previous) {_                Map<String, Tuple<A, B>> map = new HashMap<>()__                BiConsumer<String, A> aConsumer = (key, value) -> {_                    assert map.containsKey(key) == false : "duplicate key: " + key__                    map.put(key, new Tuple<>(value, settingB.getConcreteSettingForNamespace(key).get(current)))__                }__                BiConsumer<String, B> bConsumer = (key, value) -> {_                    Tuple<A, B> abTuple = map.get(key)__                    if (abTuple != null) {_                        map.put(key, new Tuple<>(abTuple.v1(), value))__                    } else {_                        assert settingA.getConcreteSettingForNamespace(key).get(current).equals(settingA.getConcreteSettingForNamespace_                            (key).get(previous)) : "expected: " + settingA.getConcreteSettingForNamespace(key).get(current)_                            + " but was " + settingA.getConcreteSettingForNamespace(key).get(previous)__                        map.put(key, new Tuple<>(settingA.getConcreteSettingForNamespace(key).get(current), value))__                    }_                }__                SettingUpdater<Map<SettingUpdater<A>, A>> affixUpdaterA = settingA.newAffixUpdater(aConsumer, logger, (a,b) ->{})__                SettingUpdater<Map<SettingUpdater<B>, B>> affixUpdaterB = settingB.newAffixUpdater(bConsumer, logger, (a,b) ->{})__                affixUpdaterA.apply(current, previous)__                affixUpdaterB.apply(current, previous)__                for (Map.Entry<String, Tuple<A, B>> entry : map.entrySet()) {_                    validator.accept(entry.getKey(), entry.getValue())__                }_                return Collections.unmodifiableMap(map)__            }__            @Override_            public void apply(Map<String, Tuple<A, B>> values, Settings current, Settings previous) {_                for (Map.Entry<String, Tuple<A, B>> entry : values.entrySet()) {_                    consumer.accept(entry.getKey(), entry.getValue())__                }_            }_        })__    };adds,a,affix,settings,consumer,that,accepts,the,values,for,two,settings,the,consumer,is,only,notified,if,one,or,both,settings,change,and,if,the,provided,validator,succeeded,p,note,only,settings,registered,in,link,settings,module,can,be,changed,dynamically,p,this,method,registers,a,compound,updater,that,is,useful,if,two,settings,are,depending,on,each,other,the,consumer,is,always,provided,with,both,values,even,if,only,one,of,the,two,changes;public,synchronized,a,b,void,add,affix,update,consumer,setting,affix,setting,a,setting,a,setting,affix,setting,b,setting,b,bi,consumer,string,tuple,a,b,consumer,bi,consumer,string,tuple,a,b,validator,ensure,setting,is,registered,setting,a,ensure,setting,is,registered,setting,b,setting,updater,map,setting,updater,a,a,affix,updater,a,setting,a,new,affix,updater,a,b,logger,a,b,setting,updater,map,setting,updater,b,b,affix,updater,b,setting,b,new,affix,updater,a,b,logger,a,b,add,settings,updater,new,setting,updater,map,string,tuple,a,b,override,public,boolean,has,changed,settings,current,settings,previous,return,affix,updater,a,has,changed,current,previous,affix,updater,b,has,changed,current,previous,override,public,map,string,tuple,a,b,get,value,settings,current,settings,previous,map,string,tuple,a,b,map,new,hash,map,bi,consumer,string,a,a,consumer,key,value,assert,map,contains,key,key,false,duplicate,key,key,map,put,key,new,tuple,value,setting,b,get,concrete,setting,for,namespace,key,get,current,bi,consumer,string,b,b,consumer,key,value,tuple,a,b,ab,tuple,map,get,key,if,ab,tuple,null,map,put,key,new,tuple,ab,tuple,v1,value,else,assert,setting,a,get,concrete,setting,for,namespace,key,get,current,equals,setting,a,get,concrete,setting,for,namespace,key,get,previous,expected,setting,a,get,concrete,setting,for,namespace,key,get,current,but,was,setting,a,get,concrete,setting,for,namespace,key,get,previous,map,put,key,new,tuple,setting,a,get,concrete,setting,for,namespace,key,get,current,value,setting,updater,map,setting,updater,a,a,affix,updater,a,setting,a,new,affix,updater,a,consumer,logger,a,b,setting,updater,map,setting,updater,b,b,affix,updater,b,setting,b,new,affix,updater,b,consumer,logger,a,b,affix,updater,a,apply,current,previous,affix,updater,b,apply,current,previous,for,map,entry,string,tuple,a,b,entry,map,entry,set,validator,accept,entry,get,key,entry,get,value,return,collections,unmodifiable,map,map,override,public,void,apply,map,string,tuple,a,b,values,settings,current,settings,previous,for,map,entry,string,tuple,a,b,entry,values,entry,set,consumer,accept,entry,get,key,entry,get,value
AbstractScopedSettings -> public synchronized <A,B> void addAffixUpdateConsumer(Setting.AffixSetting<A> settingA, Setting.AffixSetting<B> settingB,                                                           BiConsumer<String, Tuple<A, B>> consumer,                                                           BiConsumer<String, Tuple<A, B>> validator);1536611444;Adds a affix settings consumer that accepts the values for two settings. The consumer is only notified if one or both settings change_and if the provided validator succeeded._<p>_Note: Only settings registered in {@link SettingsModule} can be changed dynamically._</p>_This method registers a compound updater that is useful if two settings are depending on each other._The consumer is always provided with both values even if only one of the two changes.;public synchronized <A,B> void addAffixUpdateConsumer(Setting.AffixSetting<A> settingA, Setting.AffixSetting<B> settingB,_                                                          BiConsumer<String, Tuple<A, B>> consumer,_                                                          BiConsumer<String, Tuple<A, B>> validator) {_        _        _        ensureSettingIsRegistered(settingA)__        ensureSettingIsRegistered(settingB)__        SettingUpdater<Map<SettingUpdater<A>, A>> affixUpdaterA = settingA.newAffixUpdater((a,b)-> {}, logger, (a,b)-> {})__        SettingUpdater<Map<SettingUpdater<B>, B>> affixUpdaterB = settingB.newAffixUpdater((a,b)-> {}, logger, (a,b)-> {})___        addSettingsUpdater(new SettingUpdater<Map<String, Tuple<A, B>>>() {__            @Override_            public boolean hasChanged(Settings current, Settings previous) {_                return affixUpdaterA.hasChanged(current, previous) || affixUpdaterB.hasChanged(current, previous)__            }__            @Override_            public Map<String, Tuple<A, B>> getValue(Settings current, Settings previous) {_                Map<String, Tuple<A, B>> map = new HashMap<>()__                BiConsumer<String, A> aConsumer = (key, value) -> {_                    assert map.containsKey(key) == false : "duplicate key: " + key__                    map.put(key, new Tuple<>(value, settingB.getConcreteSettingForNamespace(key).get(current)))__                }__                BiConsumer<String, B> bConsumer = (key, value) -> {_                    Tuple<A, B> abTuple = map.get(key)__                    if (abTuple != null) {_                        map.put(key, new Tuple<>(abTuple.v1(), value))__                    } else {_                        assert settingA.getConcreteSettingForNamespace(key).get(current).equals(settingA.getConcreteSettingForNamespace_                            (key).get(previous)) : "expected: " + settingA.getConcreteSettingForNamespace(key).get(current)_                            + " but was " + settingA.getConcreteSettingForNamespace(key).get(previous)__                        map.put(key, new Tuple<>(settingA.getConcreteSettingForNamespace(key).get(current), value))__                    }_                }__                SettingUpdater<Map<SettingUpdater<A>, A>> affixUpdaterA = settingA.newAffixUpdater(aConsumer, logger, (a,b) ->{})__                SettingUpdater<Map<SettingUpdater<B>, B>> affixUpdaterB = settingB.newAffixUpdater(bConsumer, logger, (a,b) ->{})__                affixUpdaterA.apply(current, previous)__                affixUpdaterB.apply(current, previous)__                for (Map.Entry<String, Tuple<A, B>> entry : map.entrySet()) {_                    validator.accept(entry.getKey(), entry.getValue())__                }_                return Collections.unmodifiableMap(map)__            }__            @Override_            public void apply(Map<String, Tuple<A, B>> values, Settings current, Settings previous) {_                for (Map.Entry<String, Tuple<A, B>> entry : values.entrySet()) {_                    consumer.accept(entry.getKey(), entry.getValue())__                }_            }_        })__    };adds,a,affix,settings,consumer,that,accepts,the,values,for,two,settings,the,consumer,is,only,notified,if,one,or,both,settings,change,and,if,the,provided,validator,succeeded,p,note,only,settings,registered,in,link,settings,module,can,be,changed,dynamically,p,this,method,registers,a,compound,updater,that,is,useful,if,two,settings,are,depending,on,each,other,the,consumer,is,always,provided,with,both,values,even,if,only,one,of,the,two,changes;public,synchronized,a,b,void,add,affix,update,consumer,setting,affix,setting,a,setting,a,setting,affix,setting,b,setting,b,bi,consumer,string,tuple,a,b,consumer,bi,consumer,string,tuple,a,b,validator,ensure,setting,is,registered,setting,a,ensure,setting,is,registered,setting,b,setting,updater,map,setting,updater,a,a,affix,updater,a,setting,a,new,affix,updater,a,b,logger,a,b,setting,updater,map,setting,updater,b,b,affix,updater,b,setting,b,new,affix,updater,a,b,logger,a,b,add,settings,updater,new,setting,updater,map,string,tuple,a,b,override,public,boolean,has,changed,settings,current,settings,previous,return,affix,updater,a,has,changed,current,previous,affix,updater,b,has,changed,current,previous,override,public,map,string,tuple,a,b,get,value,settings,current,settings,previous,map,string,tuple,a,b,map,new,hash,map,bi,consumer,string,a,a,consumer,key,value,assert,map,contains,key,key,false,duplicate,key,key,map,put,key,new,tuple,value,setting,b,get,concrete,setting,for,namespace,key,get,current,bi,consumer,string,b,b,consumer,key,value,tuple,a,b,ab,tuple,map,get,key,if,ab,tuple,null,map,put,key,new,tuple,ab,tuple,v1,value,else,assert,setting,a,get,concrete,setting,for,namespace,key,get,current,equals,setting,a,get,concrete,setting,for,namespace,key,get,previous,expected,setting,a,get,concrete,setting,for,namespace,key,get,current,but,was,setting,a,get,concrete,setting,for,namespace,key,get,previous,map,put,key,new,tuple,setting,a,get,concrete,setting,for,namespace,key,get,current,value,setting,updater,map,setting,updater,a,a,affix,updater,a,setting,a,new,affix,updater,a,consumer,logger,a,b,setting,updater,map,setting,updater,b,b,affix,updater,b,setting,b,new,affix,updater,b,consumer,logger,a,b,affix,updater,a,apply,current,previous,affix,updater,b,apply,current,previous,for,map,entry,string,tuple,a,b,entry,map,entry,set,validator,accept,entry,get,key,entry,get,value,return,collections,unmodifiable,map,map,override,public,void,apply,map,string,tuple,a,b,values,settings,current,settings,previous,for,map,entry,string,tuple,a,b,entry,values,entry,set,consumer,accept,entry,get,key,entry,get,value
AbstractScopedSettings -> public synchronized <A,B> void addAffixUpdateConsumer(Setting.AffixSetting<A> settingA, Setting.AffixSetting<B> settingB,                                                           BiConsumer<String, Tuple<A, B>> consumer,                                                           BiConsumer<String, Tuple<A, B>> validator);1536828374;Adds a affix settings consumer that accepts the values for two settings. The consumer is only notified if one or both settings change_and if the provided validator succeeded._<p>_Note: Only settings registered in {@link SettingsModule} can be changed dynamically._</p>_This method registers a compound updater that is useful if two settings are depending on each other._The consumer is always provided with both values even if only one of the two changes.;public synchronized <A,B> void addAffixUpdateConsumer(Setting.AffixSetting<A> settingA, Setting.AffixSetting<B> settingB,_                                                          BiConsumer<String, Tuple<A, B>> consumer,_                                                          BiConsumer<String, Tuple<A, B>> validator) {_        _        _        ensureSettingIsRegistered(settingA)__        ensureSettingIsRegistered(settingB)__        SettingUpdater<Map<SettingUpdater<A>, A>> affixUpdaterA = settingA.newAffixUpdater((a,b)-> {}, logger, (a,b)-> {})__        SettingUpdater<Map<SettingUpdater<B>, B>> affixUpdaterB = settingB.newAffixUpdater((a,b)-> {}, logger, (a,b)-> {})___        addSettingsUpdater(new SettingUpdater<Map<String, Tuple<A, B>>>() {__            @Override_            public boolean hasChanged(Settings current, Settings previous) {_                return affixUpdaterA.hasChanged(current, previous) || affixUpdaterB.hasChanged(current, previous)__            }__            @Override_            public Map<String, Tuple<A, B>> getValue(Settings current, Settings previous) {_                Map<String, Tuple<A, B>> map = new HashMap<>()__                BiConsumer<String, A> aConsumer = (key, value) -> {_                    assert map.containsKey(key) == false : "duplicate key: " + key__                    map.put(key, new Tuple<>(value, settingB.getConcreteSettingForNamespace(key).get(current)))__                }__                BiConsumer<String, B> bConsumer = (key, value) -> {_                    Tuple<A, B> abTuple = map.get(key)__                    if (abTuple != null) {_                        map.put(key, new Tuple<>(abTuple.v1(), value))__                    } else {_                        assert settingA.getConcreteSettingForNamespace(key).get(current).equals(settingA.getConcreteSettingForNamespace_                            (key).get(previous)) : "expected: " + settingA.getConcreteSettingForNamespace(key).get(current)_                            + " but was " + settingA.getConcreteSettingForNamespace(key).get(previous)__                        map.put(key, new Tuple<>(settingA.getConcreteSettingForNamespace(key).get(current), value))__                    }_                }__                SettingUpdater<Map<SettingUpdater<A>, A>> affixUpdaterA = settingA.newAffixUpdater(aConsumer, logger, (a,b) ->{})__                SettingUpdater<Map<SettingUpdater<B>, B>> affixUpdaterB = settingB.newAffixUpdater(bConsumer, logger, (a,b) ->{})__                affixUpdaterA.apply(current, previous)__                affixUpdaterB.apply(current, previous)__                for (Map.Entry<String, Tuple<A, B>> entry : map.entrySet()) {_                    validator.accept(entry.getKey(), entry.getValue())__                }_                return Collections.unmodifiableMap(map)__            }__            @Override_            public void apply(Map<String, Tuple<A, B>> values, Settings current, Settings previous) {_                for (Map.Entry<String, Tuple<A, B>> entry : values.entrySet()) {_                    consumer.accept(entry.getKey(), entry.getValue())__                }_            }_        })__    };adds,a,affix,settings,consumer,that,accepts,the,values,for,two,settings,the,consumer,is,only,notified,if,one,or,both,settings,change,and,if,the,provided,validator,succeeded,p,note,only,settings,registered,in,link,settings,module,can,be,changed,dynamically,p,this,method,registers,a,compound,updater,that,is,useful,if,two,settings,are,depending,on,each,other,the,consumer,is,always,provided,with,both,values,even,if,only,one,of,the,two,changes;public,synchronized,a,b,void,add,affix,update,consumer,setting,affix,setting,a,setting,a,setting,affix,setting,b,setting,b,bi,consumer,string,tuple,a,b,consumer,bi,consumer,string,tuple,a,b,validator,ensure,setting,is,registered,setting,a,ensure,setting,is,registered,setting,b,setting,updater,map,setting,updater,a,a,affix,updater,a,setting,a,new,affix,updater,a,b,logger,a,b,setting,updater,map,setting,updater,b,b,affix,updater,b,setting,b,new,affix,updater,a,b,logger,a,b,add,settings,updater,new,setting,updater,map,string,tuple,a,b,override,public,boolean,has,changed,settings,current,settings,previous,return,affix,updater,a,has,changed,current,previous,affix,updater,b,has,changed,current,previous,override,public,map,string,tuple,a,b,get,value,settings,current,settings,previous,map,string,tuple,a,b,map,new,hash,map,bi,consumer,string,a,a,consumer,key,value,assert,map,contains,key,key,false,duplicate,key,key,map,put,key,new,tuple,value,setting,b,get,concrete,setting,for,namespace,key,get,current,bi,consumer,string,b,b,consumer,key,value,tuple,a,b,ab,tuple,map,get,key,if,ab,tuple,null,map,put,key,new,tuple,ab,tuple,v1,value,else,assert,setting,a,get,concrete,setting,for,namespace,key,get,current,equals,setting,a,get,concrete,setting,for,namespace,key,get,previous,expected,setting,a,get,concrete,setting,for,namespace,key,get,current,but,was,setting,a,get,concrete,setting,for,namespace,key,get,previous,map,put,key,new,tuple,setting,a,get,concrete,setting,for,namespace,key,get,current,value,setting,updater,map,setting,updater,a,a,affix,updater,a,setting,a,new,affix,updater,a,consumer,logger,a,b,setting,updater,map,setting,updater,b,b,affix,updater,b,setting,b,new,affix,updater,b,consumer,logger,a,b,affix,updater,a,apply,current,previous,affix,updater,b,apply,current,previous,for,map,entry,string,tuple,a,b,entry,map,entry,set,validator,accept,entry,get,key,entry,get,value,return,collections,unmodifiable,map,map,override,public,void,apply,map,string,tuple,a,b,values,settings,current,settings,previous,for,map,entry,string,tuple,a,b,entry,values,entry,set,consumer,accept,entry,get,key,entry,get,value
AbstractScopedSettings -> public synchronized <A,B> void addAffixUpdateConsumer(Setting.AffixSetting<A> settingA, Setting.AffixSetting<B> settingB,                                                           BiConsumer<String, Tuple<A, B>> consumer,                                                           BiConsumer<String, Tuple<A, B>> validator);1539951844;Adds a affix settings consumer that accepts the values for two settings. The consumer is only notified if one or both settings change_and if the provided validator succeeded._<p>_Note: Only settings registered in {@link SettingsModule} can be changed dynamically._</p>_This method registers a compound updater that is useful if two settings are depending on each other._The consumer is always provided with both values even if only one of the two changes.;public synchronized <A,B> void addAffixUpdateConsumer(Setting.AffixSetting<A> settingA, Setting.AffixSetting<B> settingB,_                                                          BiConsumer<String, Tuple<A, B>> consumer,_                                                          BiConsumer<String, Tuple<A, B>> validator) {_        _        _        ensureSettingIsRegistered(settingA)__        ensureSettingIsRegistered(settingB)__        SettingUpdater<Map<SettingUpdater<A>, A>> affixUpdaterA = settingA.newAffixUpdater((a,b)-> {}, logger, (a,b)-> {})__        SettingUpdater<Map<SettingUpdater<B>, B>> affixUpdaterB = settingB.newAffixUpdater((a,b)-> {}, logger, (a,b)-> {})___        addSettingsUpdater(new SettingUpdater<Map<String, Tuple<A, B>>>() {__            @Override_            public boolean hasChanged(Settings current, Settings previous) {_                return affixUpdaterA.hasChanged(current, previous) || affixUpdaterB.hasChanged(current, previous)__            }__            @Override_            public Map<String, Tuple<A, B>> getValue(Settings current, Settings previous) {_                Map<String, Tuple<A, B>> map = new HashMap<>()__                BiConsumer<String, A> aConsumer = (key, value) -> {_                    assert map.containsKey(key) == false : "duplicate key: " + key__                    map.put(key, new Tuple<>(value, settingB.getConcreteSettingForNamespace(key).get(current)))__                }__                BiConsumer<String, B> bConsumer = (key, value) -> {_                    Tuple<A, B> abTuple = map.get(key)__                    if (abTuple != null) {_                        map.put(key, new Tuple<>(abTuple.v1(), value))__                    } else {_                        assert settingA.getConcreteSettingForNamespace(key).get(current).equals(settingA.getConcreteSettingForNamespace_                            (key).get(previous)) : "expected: " + settingA.getConcreteSettingForNamespace(key).get(current)_                            + " but was " + settingA.getConcreteSettingForNamespace(key).get(previous)__                        map.put(key, new Tuple<>(settingA.getConcreteSettingForNamespace(key).get(current), value))__                    }_                }__                SettingUpdater<Map<SettingUpdater<A>, A>> affixUpdaterA = settingA.newAffixUpdater(aConsumer, logger, (a,b) ->{})__                SettingUpdater<Map<SettingUpdater<B>, B>> affixUpdaterB = settingB.newAffixUpdater(bConsumer, logger, (a,b) ->{})__                affixUpdaterA.apply(current, previous)__                affixUpdaterB.apply(current, previous)__                for (Map.Entry<String, Tuple<A, B>> entry : map.entrySet()) {_                    validator.accept(entry.getKey(), entry.getValue())__                }_                return Collections.unmodifiableMap(map)__            }__            @Override_            public void apply(Map<String, Tuple<A, B>> values, Settings current, Settings previous) {_                for (Map.Entry<String, Tuple<A, B>> entry : values.entrySet()) {_                    consumer.accept(entry.getKey(), entry.getValue())__                }_            }_        })__    };adds,a,affix,settings,consumer,that,accepts,the,values,for,two,settings,the,consumer,is,only,notified,if,one,or,both,settings,change,and,if,the,provided,validator,succeeded,p,note,only,settings,registered,in,link,settings,module,can,be,changed,dynamically,p,this,method,registers,a,compound,updater,that,is,useful,if,two,settings,are,depending,on,each,other,the,consumer,is,always,provided,with,both,values,even,if,only,one,of,the,two,changes;public,synchronized,a,b,void,add,affix,update,consumer,setting,affix,setting,a,setting,a,setting,affix,setting,b,setting,b,bi,consumer,string,tuple,a,b,consumer,bi,consumer,string,tuple,a,b,validator,ensure,setting,is,registered,setting,a,ensure,setting,is,registered,setting,b,setting,updater,map,setting,updater,a,a,affix,updater,a,setting,a,new,affix,updater,a,b,logger,a,b,setting,updater,map,setting,updater,b,b,affix,updater,b,setting,b,new,affix,updater,a,b,logger,a,b,add,settings,updater,new,setting,updater,map,string,tuple,a,b,override,public,boolean,has,changed,settings,current,settings,previous,return,affix,updater,a,has,changed,current,previous,affix,updater,b,has,changed,current,previous,override,public,map,string,tuple,a,b,get,value,settings,current,settings,previous,map,string,tuple,a,b,map,new,hash,map,bi,consumer,string,a,a,consumer,key,value,assert,map,contains,key,key,false,duplicate,key,key,map,put,key,new,tuple,value,setting,b,get,concrete,setting,for,namespace,key,get,current,bi,consumer,string,b,b,consumer,key,value,tuple,a,b,ab,tuple,map,get,key,if,ab,tuple,null,map,put,key,new,tuple,ab,tuple,v1,value,else,assert,setting,a,get,concrete,setting,for,namespace,key,get,current,equals,setting,a,get,concrete,setting,for,namespace,key,get,previous,expected,setting,a,get,concrete,setting,for,namespace,key,get,current,but,was,setting,a,get,concrete,setting,for,namespace,key,get,previous,map,put,key,new,tuple,setting,a,get,concrete,setting,for,namespace,key,get,current,value,setting,updater,map,setting,updater,a,a,affix,updater,a,setting,a,new,affix,updater,a,consumer,logger,a,b,setting,updater,map,setting,updater,b,b,affix,updater,b,setting,b,new,affix,updater,b,consumer,logger,a,b,affix,updater,a,apply,current,previous,affix,updater,b,apply,current,previous,for,map,entry,string,tuple,a,b,entry,map,entry,set,validator,accept,entry,get,key,entry,get,value,return,collections,unmodifiable,map,map,override,public,void,apply,map,string,tuple,a,b,values,settings,current,settings,previous,for,map,entry,string,tuple,a,b,entry,values,entry,set,consumer,accept,entry,get,key,entry,get,value
AbstractScopedSettings -> public synchronized <A,B> void addAffixUpdateConsumer(Setting.AffixSetting<A> settingA, Setting.AffixSetting<B> settingB,                                                           BiConsumer<String, Tuple<A, B>> consumer,                                                           BiConsumer<String, Tuple<A, B>> validator);1541008027;Adds a affix settings consumer that accepts the values for two settings. The consumer is only notified if one or both settings change_and if the provided validator succeeded._<p>_Note: Only settings registered in {@link SettingsModule} can be changed dynamically._</p>_This method registers a compound updater that is useful if two settings are depending on each other._The consumer is always provided with both values even if only one of the two changes.;public synchronized <A,B> void addAffixUpdateConsumer(Setting.AffixSetting<A> settingA, Setting.AffixSetting<B> settingB,_                                                          BiConsumer<String, Tuple<A, B>> consumer,_                                                          BiConsumer<String, Tuple<A, B>> validator) {_        _        _        ensureSettingIsRegistered(settingA)__        ensureSettingIsRegistered(settingB)__        SettingUpdater<Map<SettingUpdater<A>, A>> affixUpdaterA = settingA.newAffixUpdater((a,b)-> {}, logger, (a,b)-> {})__        SettingUpdater<Map<SettingUpdater<B>, B>> affixUpdaterB = settingB.newAffixUpdater((a,b)-> {}, logger, (a,b)-> {})___        addSettingsUpdater(new SettingUpdater<Map<String, Tuple<A, B>>>() {__            @Override_            public boolean hasChanged(Settings current, Settings previous) {_                return affixUpdaterA.hasChanged(current, previous) || affixUpdaterB.hasChanged(current, previous)__            }__            @Override_            public Map<String, Tuple<A, B>> getValue(Settings current, Settings previous) {_                Map<String, Tuple<A, B>> map = new HashMap<>()__                BiConsumer<String, A> aConsumer = (key, value) -> {_                    assert map.containsKey(key) == false : "duplicate key: " + key__                    map.put(key, new Tuple<>(value, settingB.getConcreteSettingForNamespace(key).get(current)))__                }__                BiConsumer<String, B> bConsumer = (key, value) -> {_                    Tuple<A, B> abTuple = map.get(key)__                    if (abTuple != null) {_                        map.put(key, new Tuple<>(abTuple.v1(), value))__                    } else {_                        assert settingA.getConcreteSettingForNamespace(key).get(current).equals(settingA.getConcreteSettingForNamespace_                            (key).get(previous)) : "expected: " + settingA.getConcreteSettingForNamespace(key).get(current)_                            + " but was " + settingA.getConcreteSettingForNamespace(key).get(previous)__                        map.put(key, new Tuple<>(settingA.getConcreteSettingForNamespace(key).get(current), value))__                    }_                }__                SettingUpdater<Map<SettingUpdater<A>, A>> affixUpdaterA = settingA.newAffixUpdater(aConsumer, logger, (a,b) ->{})__                SettingUpdater<Map<SettingUpdater<B>, B>> affixUpdaterB = settingB.newAffixUpdater(bConsumer, logger, (a,b) ->{})__                affixUpdaterA.apply(current, previous)__                affixUpdaterB.apply(current, previous)__                for (Map.Entry<String, Tuple<A, B>> entry : map.entrySet()) {_                    validator.accept(entry.getKey(), entry.getValue())__                }_                return Collections.unmodifiableMap(map)__            }__            @Override_            public void apply(Map<String, Tuple<A, B>> values, Settings current, Settings previous) {_                for (Map.Entry<String, Tuple<A, B>> entry : values.entrySet()) {_                    consumer.accept(entry.getKey(), entry.getValue())__                }_            }_        })__    };adds,a,affix,settings,consumer,that,accepts,the,values,for,two,settings,the,consumer,is,only,notified,if,one,or,both,settings,change,and,if,the,provided,validator,succeeded,p,note,only,settings,registered,in,link,settings,module,can,be,changed,dynamically,p,this,method,registers,a,compound,updater,that,is,useful,if,two,settings,are,depending,on,each,other,the,consumer,is,always,provided,with,both,values,even,if,only,one,of,the,two,changes;public,synchronized,a,b,void,add,affix,update,consumer,setting,affix,setting,a,setting,a,setting,affix,setting,b,setting,b,bi,consumer,string,tuple,a,b,consumer,bi,consumer,string,tuple,a,b,validator,ensure,setting,is,registered,setting,a,ensure,setting,is,registered,setting,b,setting,updater,map,setting,updater,a,a,affix,updater,a,setting,a,new,affix,updater,a,b,logger,a,b,setting,updater,map,setting,updater,b,b,affix,updater,b,setting,b,new,affix,updater,a,b,logger,a,b,add,settings,updater,new,setting,updater,map,string,tuple,a,b,override,public,boolean,has,changed,settings,current,settings,previous,return,affix,updater,a,has,changed,current,previous,affix,updater,b,has,changed,current,previous,override,public,map,string,tuple,a,b,get,value,settings,current,settings,previous,map,string,tuple,a,b,map,new,hash,map,bi,consumer,string,a,a,consumer,key,value,assert,map,contains,key,key,false,duplicate,key,key,map,put,key,new,tuple,value,setting,b,get,concrete,setting,for,namespace,key,get,current,bi,consumer,string,b,b,consumer,key,value,tuple,a,b,ab,tuple,map,get,key,if,ab,tuple,null,map,put,key,new,tuple,ab,tuple,v1,value,else,assert,setting,a,get,concrete,setting,for,namespace,key,get,current,equals,setting,a,get,concrete,setting,for,namespace,key,get,previous,expected,setting,a,get,concrete,setting,for,namespace,key,get,current,but,was,setting,a,get,concrete,setting,for,namespace,key,get,previous,map,put,key,new,tuple,setting,a,get,concrete,setting,for,namespace,key,get,current,value,setting,updater,map,setting,updater,a,a,affix,updater,a,setting,a,new,affix,updater,a,consumer,logger,a,b,setting,updater,map,setting,updater,b,b,affix,updater,b,setting,b,new,affix,updater,b,consumer,logger,a,b,affix,updater,a,apply,current,previous,affix,updater,b,apply,current,previous,for,map,entry,string,tuple,a,b,entry,map,entry,set,validator,accept,entry,get,key,entry,get,value,return,collections,unmodifiable,map,map,override,public,void,apply,map,string,tuple,a,b,values,settings,current,settings,previous,for,map,entry,string,tuple,a,b,entry,values,entry,set,consumer,accept,entry,get,key,entry,get,value
AbstractScopedSettings -> public synchronized <A,B> void addAffixUpdateConsumer(Setting.AffixSetting<A> settingA, Setting.AffixSetting<B> settingB,                                                           BiConsumer<String, Tuple<A, B>> consumer,                                                           BiConsumer<String, Tuple<A, B>> validator);1541092382;Adds a affix settings consumer that accepts the values for two settings. The consumer is only notified if one or both settings change_and if the provided validator succeeded._<p>_Note: Only settings registered in {@link SettingsModule} can be changed dynamically._</p>_This method registers a compound updater that is useful if two settings are depending on each other._The consumer is always provided with both values even if only one of the two changes.;public synchronized <A,B> void addAffixUpdateConsumer(Setting.AffixSetting<A> settingA, Setting.AffixSetting<B> settingB,_                                                          BiConsumer<String, Tuple<A, B>> consumer,_                                                          BiConsumer<String, Tuple<A, B>> validator) {_        _        _        ensureSettingIsRegistered(settingA)__        ensureSettingIsRegistered(settingB)__        SettingUpdater<Map<SettingUpdater<A>, A>> affixUpdaterA = settingA.newAffixUpdater((a,b)-> {}, logger, (a,b)-> {})__        SettingUpdater<Map<SettingUpdater<B>, B>> affixUpdaterB = settingB.newAffixUpdater((a,b)-> {}, logger, (a,b)-> {})___        addSettingsUpdater(new SettingUpdater<Map<String, Tuple<A, B>>>() {__            @Override_            public boolean hasChanged(Settings current, Settings previous) {_                return affixUpdaterA.hasChanged(current, previous) || affixUpdaterB.hasChanged(current, previous)__            }__            @Override_            public Map<String, Tuple<A, B>> getValue(Settings current, Settings previous) {_                Map<String, Tuple<A, B>> map = new HashMap<>()__                BiConsumer<String, A> aConsumer = (key, value) -> {_                    assert map.containsKey(key) == false : "duplicate key: " + key__                    map.put(key, new Tuple<>(value, settingB.getConcreteSettingForNamespace(key).get(current)))__                }__                BiConsumer<String, B> bConsumer = (key, value) -> {_                    Tuple<A, B> abTuple = map.get(key)__                    if (abTuple != null) {_                        map.put(key, new Tuple<>(abTuple.v1(), value))__                    } else {_                        assert settingA.getConcreteSettingForNamespace(key).get(current).equals(settingA.getConcreteSettingForNamespace_                            (key).get(previous)) : "expected: " + settingA.getConcreteSettingForNamespace(key).get(current)_                            + " but was " + settingA.getConcreteSettingForNamespace(key).get(previous)__                        map.put(key, new Tuple<>(settingA.getConcreteSettingForNamespace(key).get(current), value))__                    }_                }__                SettingUpdater<Map<SettingUpdater<A>, A>> affixUpdaterA = settingA.newAffixUpdater(aConsumer, logger, (a,b) ->{})__                SettingUpdater<Map<SettingUpdater<B>, B>> affixUpdaterB = settingB.newAffixUpdater(bConsumer, logger, (a,b) ->{})__                affixUpdaterA.apply(current, previous)__                affixUpdaterB.apply(current, previous)__                for (Map.Entry<String, Tuple<A, B>> entry : map.entrySet()) {_                    validator.accept(entry.getKey(), entry.getValue())__                }_                return Collections.unmodifiableMap(map)__            }__            @Override_            public void apply(Map<String, Tuple<A, B>> values, Settings current, Settings previous) {_                for (Map.Entry<String, Tuple<A, B>> entry : values.entrySet()) {_                    consumer.accept(entry.getKey(), entry.getValue())__                }_            }_        })__    };adds,a,affix,settings,consumer,that,accepts,the,values,for,two,settings,the,consumer,is,only,notified,if,one,or,both,settings,change,and,if,the,provided,validator,succeeded,p,note,only,settings,registered,in,link,settings,module,can,be,changed,dynamically,p,this,method,registers,a,compound,updater,that,is,useful,if,two,settings,are,depending,on,each,other,the,consumer,is,always,provided,with,both,values,even,if,only,one,of,the,two,changes;public,synchronized,a,b,void,add,affix,update,consumer,setting,affix,setting,a,setting,a,setting,affix,setting,b,setting,b,bi,consumer,string,tuple,a,b,consumer,bi,consumer,string,tuple,a,b,validator,ensure,setting,is,registered,setting,a,ensure,setting,is,registered,setting,b,setting,updater,map,setting,updater,a,a,affix,updater,a,setting,a,new,affix,updater,a,b,logger,a,b,setting,updater,map,setting,updater,b,b,affix,updater,b,setting,b,new,affix,updater,a,b,logger,a,b,add,settings,updater,new,setting,updater,map,string,tuple,a,b,override,public,boolean,has,changed,settings,current,settings,previous,return,affix,updater,a,has,changed,current,previous,affix,updater,b,has,changed,current,previous,override,public,map,string,tuple,a,b,get,value,settings,current,settings,previous,map,string,tuple,a,b,map,new,hash,map,bi,consumer,string,a,a,consumer,key,value,assert,map,contains,key,key,false,duplicate,key,key,map,put,key,new,tuple,value,setting,b,get,concrete,setting,for,namespace,key,get,current,bi,consumer,string,b,b,consumer,key,value,tuple,a,b,ab,tuple,map,get,key,if,ab,tuple,null,map,put,key,new,tuple,ab,tuple,v1,value,else,assert,setting,a,get,concrete,setting,for,namespace,key,get,current,equals,setting,a,get,concrete,setting,for,namespace,key,get,previous,expected,setting,a,get,concrete,setting,for,namespace,key,get,current,but,was,setting,a,get,concrete,setting,for,namespace,key,get,previous,map,put,key,new,tuple,setting,a,get,concrete,setting,for,namespace,key,get,current,value,setting,updater,map,setting,updater,a,a,affix,updater,a,setting,a,new,affix,updater,a,consumer,logger,a,b,setting,updater,map,setting,updater,b,b,affix,updater,b,setting,b,new,affix,updater,b,consumer,logger,a,b,affix,updater,a,apply,current,previous,affix,updater,b,apply,current,previous,for,map,entry,string,tuple,a,b,entry,map,entry,set,validator,accept,entry,get,key,entry,get,value,return,collections,unmodifiable,map,map,override,public,void,apply,map,string,tuple,a,b,values,settings,current,settings,previous,for,map,entry,string,tuple,a,b,entry,values,entry,set,consumer,accept,entry,get,key,entry,get,value
AbstractScopedSettings -> public synchronized <A,B> void addAffixUpdateConsumer(Setting.AffixSetting<A> settingA, Setting.AffixSetting<B> settingB,                                                           BiConsumer<String, Tuple<A, B>> consumer,                                                           BiConsumer<String, Tuple<A, B>> validator);1542402632;Adds a affix settings consumer that accepts the values for two settings. The consumer is only notified if one or both settings change_and if the provided validator succeeded._<p>_Note: Only settings registered in {@link SettingsModule} can be changed dynamically._</p>_This method registers a compound updater that is useful if two settings are depending on each other._The consumer is always provided with both values even if only one of the two changes.;public synchronized <A,B> void addAffixUpdateConsumer(Setting.AffixSetting<A> settingA, Setting.AffixSetting<B> settingB,_                                                          BiConsumer<String, Tuple<A, B>> consumer,_                                                          BiConsumer<String, Tuple<A, B>> validator) {_        _        _        ensureSettingIsRegistered(settingA)__        ensureSettingIsRegistered(settingB)__        SettingUpdater<Map<SettingUpdater<A>, A>> affixUpdaterA = settingA.newAffixUpdater((a,b)-> {}, logger, (a,b)-> {})__        SettingUpdater<Map<SettingUpdater<B>, B>> affixUpdaterB = settingB.newAffixUpdater((a,b)-> {}, logger, (a,b)-> {})___        addSettingsUpdater(new SettingUpdater<Map<String, Tuple<A, B>>>() {__            @Override_            public boolean hasChanged(Settings current, Settings previous) {_                return affixUpdaterA.hasChanged(current, previous) || affixUpdaterB.hasChanged(current, previous)__            }__            @Override_            public Map<String, Tuple<A, B>> getValue(Settings current, Settings previous) {_                Map<String, Tuple<A, B>> map = new HashMap<>()__                BiConsumer<String, A> aConsumer = (key, value) -> {_                    assert map.containsKey(key) == false : "duplicate key: " + key__                    map.put(key, new Tuple<>(value, settingB.getConcreteSettingForNamespace(key).get(current)))__                }__                BiConsumer<String, B> bConsumer = (key, value) -> {_                    Tuple<A, B> abTuple = map.get(key)__                    if (abTuple != null) {_                        map.put(key, new Tuple<>(abTuple.v1(), value))__                    } else {_                        assert settingA.getConcreteSettingForNamespace(key).get(current).equals(settingA.getConcreteSettingForNamespace_                            (key).get(previous)) : "expected: " + settingA.getConcreteSettingForNamespace(key).get(current)_                            + " but was " + settingA.getConcreteSettingForNamespace(key).get(previous)__                        map.put(key, new Tuple<>(settingA.getConcreteSettingForNamespace(key).get(current), value))__                    }_                }__                SettingUpdater<Map<SettingUpdater<A>, A>> affixUpdaterA = settingA.newAffixUpdater(aConsumer, logger, (a,b) ->{})__                SettingUpdater<Map<SettingUpdater<B>, B>> affixUpdaterB = settingB.newAffixUpdater(bConsumer, logger, (a,b) ->{})__                affixUpdaterA.apply(current, previous)__                affixUpdaterB.apply(current, previous)__                for (Map.Entry<String, Tuple<A, B>> entry : map.entrySet()) {_                    validator.accept(entry.getKey(), entry.getValue())__                }_                return Collections.unmodifiableMap(map)__            }__            @Override_            public void apply(Map<String, Tuple<A, B>> values, Settings current, Settings previous) {_                for (Map.Entry<String, Tuple<A, B>> entry : values.entrySet()) {_                    consumer.accept(entry.getKey(), entry.getValue())__                }_            }_        })__    };adds,a,affix,settings,consumer,that,accepts,the,values,for,two,settings,the,consumer,is,only,notified,if,one,or,both,settings,change,and,if,the,provided,validator,succeeded,p,note,only,settings,registered,in,link,settings,module,can,be,changed,dynamically,p,this,method,registers,a,compound,updater,that,is,useful,if,two,settings,are,depending,on,each,other,the,consumer,is,always,provided,with,both,values,even,if,only,one,of,the,two,changes;public,synchronized,a,b,void,add,affix,update,consumer,setting,affix,setting,a,setting,a,setting,affix,setting,b,setting,b,bi,consumer,string,tuple,a,b,consumer,bi,consumer,string,tuple,a,b,validator,ensure,setting,is,registered,setting,a,ensure,setting,is,registered,setting,b,setting,updater,map,setting,updater,a,a,affix,updater,a,setting,a,new,affix,updater,a,b,logger,a,b,setting,updater,map,setting,updater,b,b,affix,updater,b,setting,b,new,affix,updater,a,b,logger,a,b,add,settings,updater,new,setting,updater,map,string,tuple,a,b,override,public,boolean,has,changed,settings,current,settings,previous,return,affix,updater,a,has,changed,current,previous,affix,updater,b,has,changed,current,previous,override,public,map,string,tuple,a,b,get,value,settings,current,settings,previous,map,string,tuple,a,b,map,new,hash,map,bi,consumer,string,a,a,consumer,key,value,assert,map,contains,key,key,false,duplicate,key,key,map,put,key,new,tuple,value,setting,b,get,concrete,setting,for,namespace,key,get,current,bi,consumer,string,b,b,consumer,key,value,tuple,a,b,ab,tuple,map,get,key,if,ab,tuple,null,map,put,key,new,tuple,ab,tuple,v1,value,else,assert,setting,a,get,concrete,setting,for,namespace,key,get,current,equals,setting,a,get,concrete,setting,for,namespace,key,get,previous,expected,setting,a,get,concrete,setting,for,namespace,key,get,current,but,was,setting,a,get,concrete,setting,for,namespace,key,get,previous,map,put,key,new,tuple,setting,a,get,concrete,setting,for,namespace,key,get,current,value,setting,updater,map,setting,updater,a,a,affix,updater,a,setting,a,new,affix,updater,a,consumer,logger,a,b,setting,updater,map,setting,updater,b,b,affix,updater,b,setting,b,new,affix,updater,b,consumer,logger,a,b,affix,updater,a,apply,current,previous,affix,updater,b,apply,current,previous,for,map,entry,string,tuple,a,b,entry,map,entry,set,validator,accept,entry,get,key,entry,get,value,return,collections,unmodifiable,map,map,override,public,void,apply,map,string,tuple,a,b,values,settings,current,settings,previous,for,map,entry,string,tuple,a,b,entry,values,entry,set,consumer,accept,entry,get,key,entry,get,value
AbstractScopedSettings -> public synchronized <A,B> void addAffixUpdateConsumer(Setting.AffixSetting<A> settingA, Setting.AffixSetting<B> settingB,                                                           BiConsumer<String, Tuple<A, B>> consumer,                                                           BiConsumer<String, Tuple<A, B>> validator);1544081506;Adds a affix settings consumer that accepts the values for two settings. The consumer is only notified if one or both settings change_and if the provided validator succeeded._<p>_Note: Only settings registered in {@link SettingsModule} can be changed dynamically._</p>_This method registers a compound updater that is useful if two settings are depending on each other._The consumer is always provided with both values even if only one of the two changes.;public synchronized <A,B> void addAffixUpdateConsumer(Setting.AffixSetting<A> settingA, Setting.AffixSetting<B> settingB,_                                                          BiConsumer<String, Tuple<A, B>> consumer,_                                                          BiConsumer<String, Tuple<A, B>> validator) {_        _        _        ensureSettingIsRegistered(settingA)__        ensureSettingIsRegistered(settingB)__        SettingUpdater<Map<SettingUpdater<A>, A>> affixUpdaterA = settingA.newAffixUpdater((a,b)-> {}, logger, (a,b)-> {})__        SettingUpdater<Map<SettingUpdater<B>, B>> affixUpdaterB = settingB.newAffixUpdater((a,b)-> {}, logger, (a,b)-> {})___        addSettingsUpdater(new SettingUpdater<Map<String, Tuple<A, B>>>() {__            @Override_            public boolean hasChanged(Settings current, Settings previous) {_                return affixUpdaterA.hasChanged(current, previous) || affixUpdaterB.hasChanged(current, previous)__            }__            @Override_            public Map<String, Tuple<A, B>> getValue(Settings current, Settings previous) {_                Map<String, Tuple<A, B>> map = new HashMap<>()__                BiConsumer<String, A> aConsumer = (key, value) -> {_                    assert map.containsKey(key) == false : "duplicate key: " + key__                    map.put(key, new Tuple<>(value, settingB.getConcreteSettingForNamespace(key).get(current)))__                }__                BiConsumer<String, B> bConsumer = (key, value) -> {_                    Tuple<A, B> abTuple = map.get(key)__                    if (abTuple != null) {_                        map.put(key, new Tuple<>(abTuple.v1(), value))__                    } else {_                        assert settingA.getConcreteSettingForNamespace(key).get(current).equals(settingA.getConcreteSettingForNamespace_                            (key).get(previous)) : "expected: " + settingA.getConcreteSettingForNamespace(key).get(current)_                            + " but was " + settingA.getConcreteSettingForNamespace(key).get(previous)__                        map.put(key, new Tuple<>(settingA.getConcreteSettingForNamespace(key).get(current), value))__                    }_                }__                SettingUpdater<Map<SettingUpdater<A>, A>> affixUpdaterA = settingA.newAffixUpdater(aConsumer, logger, (a,b) ->{})__                SettingUpdater<Map<SettingUpdater<B>, B>> affixUpdaterB = settingB.newAffixUpdater(bConsumer, logger, (a,b) ->{})__                affixUpdaterA.apply(current, previous)__                affixUpdaterB.apply(current, previous)__                for (Map.Entry<String, Tuple<A, B>> entry : map.entrySet()) {_                    validator.accept(entry.getKey(), entry.getValue())__                }_                return Collections.unmodifiableMap(map)__            }__            @Override_            public void apply(Map<String, Tuple<A, B>> values, Settings current, Settings previous) {_                for (Map.Entry<String, Tuple<A, B>> entry : values.entrySet()) {_                    consumer.accept(entry.getKey(), entry.getValue())__                }_            }_        })__    };adds,a,affix,settings,consumer,that,accepts,the,values,for,two,settings,the,consumer,is,only,notified,if,one,or,both,settings,change,and,if,the,provided,validator,succeeded,p,note,only,settings,registered,in,link,settings,module,can,be,changed,dynamically,p,this,method,registers,a,compound,updater,that,is,useful,if,two,settings,are,depending,on,each,other,the,consumer,is,always,provided,with,both,values,even,if,only,one,of,the,two,changes;public,synchronized,a,b,void,add,affix,update,consumer,setting,affix,setting,a,setting,a,setting,affix,setting,b,setting,b,bi,consumer,string,tuple,a,b,consumer,bi,consumer,string,tuple,a,b,validator,ensure,setting,is,registered,setting,a,ensure,setting,is,registered,setting,b,setting,updater,map,setting,updater,a,a,affix,updater,a,setting,a,new,affix,updater,a,b,logger,a,b,setting,updater,map,setting,updater,b,b,affix,updater,b,setting,b,new,affix,updater,a,b,logger,a,b,add,settings,updater,new,setting,updater,map,string,tuple,a,b,override,public,boolean,has,changed,settings,current,settings,previous,return,affix,updater,a,has,changed,current,previous,affix,updater,b,has,changed,current,previous,override,public,map,string,tuple,a,b,get,value,settings,current,settings,previous,map,string,tuple,a,b,map,new,hash,map,bi,consumer,string,a,a,consumer,key,value,assert,map,contains,key,key,false,duplicate,key,key,map,put,key,new,tuple,value,setting,b,get,concrete,setting,for,namespace,key,get,current,bi,consumer,string,b,b,consumer,key,value,tuple,a,b,ab,tuple,map,get,key,if,ab,tuple,null,map,put,key,new,tuple,ab,tuple,v1,value,else,assert,setting,a,get,concrete,setting,for,namespace,key,get,current,equals,setting,a,get,concrete,setting,for,namespace,key,get,previous,expected,setting,a,get,concrete,setting,for,namespace,key,get,current,but,was,setting,a,get,concrete,setting,for,namespace,key,get,previous,map,put,key,new,tuple,setting,a,get,concrete,setting,for,namespace,key,get,current,value,setting,updater,map,setting,updater,a,a,affix,updater,a,setting,a,new,affix,updater,a,consumer,logger,a,b,setting,updater,map,setting,updater,b,b,affix,updater,b,setting,b,new,affix,updater,b,consumer,logger,a,b,affix,updater,a,apply,current,previous,affix,updater,b,apply,current,previous,for,map,entry,string,tuple,a,b,entry,map,entry,set,validator,accept,entry,get,key,entry,get,value,return,collections,unmodifiable,map,map,override,public,void,apply,map,string,tuple,a,b,values,settings,current,settings,previous,for,map,entry,string,tuple,a,b,entry,values,entry,set,consumer,accept,entry,get,key,entry,get,value
AbstractScopedSettings -> public synchronized <A,B> void addAffixUpdateConsumer(Setting.AffixSetting<A> settingA, Setting.AffixSetting<B> settingB,                                                           BiConsumer<String, Tuple<A, B>> consumer,                                                           BiConsumer<String, Tuple<A, B>> validator);1544691774;Adds a affix settings consumer that accepts the values for two settings. The consumer is only notified if one or both settings change_and if the provided validator succeeded._<p>_Note: Only settings registered in {@link SettingsModule} can be changed dynamically._</p>_This method registers a compound updater that is useful if two settings are depending on each other._The consumer is always provided with both values even if only one of the two changes.;public synchronized <A,B> void addAffixUpdateConsumer(Setting.AffixSetting<A> settingA, Setting.AffixSetting<B> settingB,_                                                          BiConsumer<String, Tuple<A, B>> consumer,_                                                          BiConsumer<String, Tuple<A, B>> validator) {_        _        _        ensureSettingIsRegistered(settingA)__        ensureSettingIsRegistered(settingB)__        SettingUpdater<Map<SettingUpdater<A>, A>> affixUpdaterA = settingA.newAffixUpdater((a,b)-> {}, logger, (a,b)-> {})__        SettingUpdater<Map<SettingUpdater<B>, B>> affixUpdaterB = settingB.newAffixUpdater((a,b)-> {}, logger, (a,b)-> {})___        addSettingsUpdater(new SettingUpdater<Map<String, Tuple<A, B>>>() {__            @Override_            public boolean hasChanged(Settings current, Settings previous) {_                return affixUpdaterA.hasChanged(current, previous) || affixUpdaterB.hasChanged(current, previous)__            }__            @Override_            public Map<String, Tuple<A, B>> getValue(Settings current, Settings previous) {_                Map<String, Tuple<A, B>> map = new HashMap<>()__                BiConsumer<String, A> aConsumer = (key, value) -> {_                    assert map.containsKey(key) == false : "duplicate key: " + key__                    map.put(key, new Tuple<>(value, settingB.getConcreteSettingForNamespace(key).get(current)))__                }__                BiConsumer<String, B> bConsumer = (key, value) -> {_                    Tuple<A, B> abTuple = map.get(key)__                    if (abTuple != null) {_                        map.put(key, new Tuple<>(abTuple.v1(), value))__                    } else {_                        assert settingA.getConcreteSettingForNamespace(key).get(current).equals(settingA.getConcreteSettingForNamespace_                            (key).get(previous)) : "expected: " + settingA.getConcreteSettingForNamespace(key).get(current)_                            + " but was " + settingA.getConcreteSettingForNamespace(key).get(previous)__                        map.put(key, new Tuple<>(settingA.getConcreteSettingForNamespace(key).get(current), value))__                    }_                }__                SettingUpdater<Map<SettingUpdater<A>, A>> affixUpdaterA = settingA.newAffixUpdater(aConsumer, logger, (a,b) ->{})__                SettingUpdater<Map<SettingUpdater<B>, B>> affixUpdaterB = settingB.newAffixUpdater(bConsumer, logger, (a,b) ->{})__                affixUpdaterA.apply(current, previous)__                affixUpdaterB.apply(current, previous)__                for (Map.Entry<String, Tuple<A, B>> entry : map.entrySet()) {_                    validator.accept(entry.getKey(), entry.getValue())__                }_                return Collections.unmodifiableMap(map)__            }__            @Override_            public void apply(Map<String, Tuple<A, B>> values, Settings current, Settings previous) {_                for (Map.Entry<String, Tuple<A, B>> entry : values.entrySet()) {_                    consumer.accept(entry.getKey(), entry.getValue())__                }_            }_        })__    };adds,a,affix,settings,consumer,that,accepts,the,values,for,two,settings,the,consumer,is,only,notified,if,one,or,both,settings,change,and,if,the,provided,validator,succeeded,p,note,only,settings,registered,in,link,settings,module,can,be,changed,dynamically,p,this,method,registers,a,compound,updater,that,is,useful,if,two,settings,are,depending,on,each,other,the,consumer,is,always,provided,with,both,values,even,if,only,one,of,the,two,changes;public,synchronized,a,b,void,add,affix,update,consumer,setting,affix,setting,a,setting,a,setting,affix,setting,b,setting,b,bi,consumer,string,tuple,a,b,consumer,bi,consumer,string,tuple,a,b,validator,ensure,setting,is,registered,setting,a,ensure,setting,is,registered,setting,b,setting,updater,map,setting,updater,a,a,affix,updater,a,setting,a,new,affix,updater,a,b,logger,a,b,setting,updater,map,setting,updater,b,b,affix,updater,b,setting,b,new,affix,updater,a,b,logger,a,b,add,settings,updater,new,setting,updater,map,string,tuple,a,b,override,public,boolean,has,changed,settings,current,settings,previous,return,affix,updater,a,has,changed,current,previous,affix,updater,b,has,changed,current,previous,override,public,map,string,tuple,a,b,get,value,settings,current,settings,previous,map,string,tuple,a,b,map,new,hash,map,bi,consumer,string,a,a,consumer,key,value,assert,map,contains,key,key,false,duplicate,key,key,map,put,key,new,tuple,value,setting,b,get,concrete,setting,for,namespace,key,get,current,bi,consumer,string,b,b,consumer,key,value,tuple,a,b,ab,tuple,map,get,key,if,ab,tuple,null,map,put,key,new,tuple,ab,tuple,v1,value,else,assert,setting,a,get,concrete,setting,for,namespace,key,get,current,equals,setting,a,get,concrete,setting,for,namespace,key,get,previous,expected,setting,a,get,concrete,setting,for,namespace,key,get,current,but,was,setting,a,get,concrete,setting,for,namespace,key,get,previous,map,put,key,new,tuple,setting,a,get,concrete,setting,for,namespace,key,get,current,value,setting,updater,map,setting,updater,a,a,affix,updater,a,setting,a,new,affix,updater,a,consumer,logger,a,b,setting,updater,map,setting,updater,b,b,affix,updater,b,setting,b,new,affix,updater,b,consumer,logger,a,b,affix,updater,a,apply,current,previous,affix,updater,b,apply,current,previous,for,map,entry,string,tuple,a,b,entry,map,entry,set,validator,accept,entry,get,key,entry,get,value,return,collections,unmodifiable,map,map,override,public,void,apply,map,string,tuple,a,b,values,settings,current,settings,previous,for,map,entry,string,tuple,a,b,entry,values,entry,set,consumer,accept,entry,get,key,entry,get,value
AbstractScopedSettings -> public synchronized <A,B> void addAffixUpdateConsumer(Setting.AffixSetting<A> settingA, Setting.AffixSetting<B> settingB,                                                           BiConsumer<String, Tuple<A, B>> consumer,                                                           BiConsumer<String, Tuple<A, B>> validator);1546877578;Adds a affix settings consumer that accepts the values for two settings. The consumer is only notified if one or both settings change_and if the provided validator succeeded._<p>_Note: Only settings registered in {@link SettingsModule} can be changed dynamically._</p>_This method registers a compound updater that is useful if two settings are depending on each other._The consumer is always provided with both values even if only one of the two changes.;public synchronized <A,B> void addAffixUpdateConsumer(Setting.AffixSetting<A> settingA, Setting.AffixSetting<B> settingB,_                                                          BiConsumer<String, Tuple<A, B>> consumer,_                                                          BiConsumer<String, Tuple<A, B>> validator) {_        _        _        ensureSettingIsRegistered(settingA)__        ensureSettingIsRegistered(settingB)__        SettingUpdater<Map<SettingUpdater<A>, A>> affixUpdaterA = settingA.newAffixUpdater((a,b)-> {}, logger, (a,b)-> {})__        SettingUpdater<Map<SettingUpdater<B>, B>> affixUpdaterB = settingB.newAffixUpdater((a,b)-> {}, logger, (a,b)-> {})___        addSettingsUpdater(new SettingUpdater<Map<String, Tuple<A, B>>>() {__            @Override_            public boolean hasChanged(Settings current, Settings previous) {_                return affixUpdaterA.hasChanged(current, previous) || affixUpdaterB.hasChanged(current, previous)__            }__            @Override_            public Map<String, Tuple<A, B>> getValue(Settings current, Settings previous) {_                Map<String, Tuple<A, B>> map = new HashMap<>()__                BiConsumer<String, A> aConsumer = (key, value) -> {_                    assert map.containsKey(key) == false : "duplicate key: " + key__                    map.put(key, new Tuple<>(value, settingB.getConcreteSettingForNamespace(key).get(current)))__                }__                BiConsumer<String, B> bConsumer = (key, value) -> {_                    Tuple<A, B> abTuple = map.get(key)__                    if (abTuple != null) {_                        map.put(key, new Tuple<>(abTuple.v1(), value))__                    } else {_                        assert settingA.getConcreteSettingForNamespace(key).get(current).equals(settingA.getConcreteSettingForNamespace_                            (key).get(previous)) : "expected: " + settingA.getConcreteSettingForNamespace(key).get(current)_                            + " but was " + settingA.getConcreteSettingForNamespace(key).get(previous)__                        map.put(key, new Tuple<>(settingA.getConcreteSettingForNamespace(key).get(current), value))__                    }_                }__                SettingUpdater<Map<SettingUpdater<A>, A>> affixUpdaterA = settingA.newAffixUpdater(aConsumer, logger, (a,b) ->{})__                SettingUpdater<Map<SettingUpdater<B>, B>> affixUpdaterB = settingB.newAffixUpdater(bConsumer, logger, (a,b) ->{})__                affixUpdaterA.apply(current, previous)__                affixUpdaterB.apply(current, previous)__                for (Map.Entry<String, Tuple<A, B>> entry : map.entrySet()) {_                    validator.accept(entry.getKey(), entry.getValue())__                }_                return Collections.unmodifiableMap(map)__            }__            @Override_            public void apply(Map<String, Tuple<A, B>> values, Settings current, Settings previous) {_                for (Map.Entry<String, Tuple<A, B>> entry : values.entrySet()) {_                    consumer.accept(entry.getKey(), entry.getValue())__                }_            }_        })__    };adds,a,affix,settings,consumer,that,accepts,the,values,for,two,settings,the,consumer,is,only,notified,if,one,or,both,settings,change,and,if,the,provided,validator,succeeded,p,note,only,settings,registered,in,link,settings,module,can,be,changed,dynamically,p,this,method,registers,a,compound,updater,that,is,useful,if,two,settings,are,depending,on,each,other,the,consumer,is,always,provided,with,both,values,even,if,only,one,of,the,two,changes;public,synchronized,a,b,void,add,affix,update,consumer,setting,affix,setting,a,setting,a,setting,affix,setting,b,setting,b,bi,consumer,string,tuple,a,b,consumer,bi,consumer,string,tuple,a,b,validator,ensure,setting,is,registered,setting,a,ensure,setting,is,registered,setting,b,setting,updater,map,setting,updater,a,a,affix,updater,a,setting,a,new,affix,updater,a,b,logger,a,b,setting,updater,map,setting,updater,b,b,affix,updater,b,setting,b,new,affix,updater,a,b,logger,a,b,add,settings,updater,new,setting,updater,map,string,tuple,a,b,override,public,boolean,has,changed,settings,current,settings,previous,return,affix,updater,a,has,changed,current,previous,affix,updater,b,has,changed,current,previous,override,public,map,string,tuple,a,b,get,value,settings,current,settings,previous,map,string,tuple,a,b,map,new,hash,map,bi,consumer,string,a,a,consumer,key,value,assert,map,contains,key,key,false,duplicate,key,key,map,put,key,new,tuple,value,setting,b,get,concrete,setting,for,namespace,key,get,current,bi,consumer,string,b,b,consumer,key,value,tuple,a,b,ab,tuple,map,get,key,if,ab,tuple,null,map,put,key,new,tuple,ab,tuple,v1,value,else,assert,setting,a,get,concrete,setting,for,namespace,key,get,current,equals,setting,a,get,concrete,setting,for,namespace,key,get,previous,expected,setting,a,get,concrete,setting,for,namespace,key,get,current,but,was,setting,a,get,concrete,setting,for,namespace,key,get,previous,map,put,key,new,tuple,setting,a,get,concrete,setting,for,namespace,key,get,current,value,setting,updater,map,setting,updater,a,a,affix,updater,a,setting,a,new,affix,updater,a,consumer,logger,a,b,setting,updater,map,setting,updater,b,b,affix,updater,b,setting,b,new,affix,updater,b,consumer,logger,a,b,affix,updater,a,apply,current,previous,affix,updater,b,apply,current,previous,for,map,entry,string,tuple,a,b,entry,map,entry,set,validator,accept,entry,get,key,entry,get,value,return,collections,unmodifiable,map,map,override,public,void,apply,map,string,tuple,a,b,values,settings,current,settings,previous,for,map,entry,string,tuple,a,b,entry,values,entry,set,consumer,accept,entry,get,key,entry,get,value
AbstractScopedSettings -> public synchronized <A,B> void addAffixUpdateConsumer(Setting.AffixSetting<A> settingA, Setting.AffixSetting<B> settingB,                                                           BiConsumer<String, Tuple<A, B>> consumer,                                                           BiConsumer<String, Tuple<A, B>> validator);1548270339;Adds a affix settings consumer that accepts the values for two settings. The consumer is only notified if one or both settings change_and if the provided validator succeeded._<p>_Note: Only settings registered in {@link SettingsModule} can be changed dynamically._</p>_This method registers a compound updater that is useful if two settings are depending on each other._The consumer is always provided with both values even if only one of the two changes.;public synchronized <A,B> void addAffixUpdateConsumer(Setting.AffixSetting<A> settingA, Setting.AffixSetting<B> settingB,_                                                          BiConsumer<String, Tuple<A, B>> consumer,_                                                          BiConsumer<String, Tuple<A, B>> validator) {_        _        _        ensureSettingIsRegistered(settingA)__        ensureSettingIsRegistered(settingB)__        SettingUpdater<Map<SettingUpdater<A>, A>> affixUpdaterA = settingA.newAffixUpdater((a,b)-> {}, logger, (a,b)-> {})__        SettingUpdater<Map<SettingUpdater<B>, B>> affixUpdaterB = settingB.newAffixUpdater((a,b)-> {}, logger, (a,b)-> {})___        addSettingsUpdater(new SettingUpdater<Map<String, Tuple<A, B>>>() {__            @Override_            public boolean hasChanged(Settings current, Settings previous) {_                return affixUpdaterA.hasChanged(current, previous) || affixUpdaterB.hasChanged(current, previous)__            }__            @Override_            public Map<String, Tuple<A, B>> getValue(Settings current, Settings previous) {_                Map<String, Tuple<A, B>> map = new HashMap<>()__                BiConsumer<String, A> aConsumer = (key, value) -> {_                    assert map.containsKey(key) == false : "duplicate key: " + key__                    map.put(key, new Tuple<>(value, settingB.getConcreteSettingForNamespace(key).get(current)))__                }__                BiConsumer<String, B> bConsumer = (key, value) -> {_                    Tuple<A, B> abTuple = map.get(key)__                    if (abTuple != null) {_                        map.put(key, new Tuple<>(abTuple.v1(), value))__                    } else {_                        assert settingA.getConcreteSettingForNamespace(key).get(current).equals(settingA.getConcreteSettingForNamespace_                            (key).get(previous)) : "expected: " + settingA.getConcreteSettingForNamespace(key).get(current)_                            + " but was " + settingA.getConcreteSettingForNamespace(key).get(previous)__                        map.put(key, new Tuple<>(settingA.getConcreteSettingForNamespace(key).get(current), value))__                    }_                }__                SettingUpdater<Map<SettingUpdater<A>, A>> affixUpdaterA = settingA.newAffixUpdater(aConsumer, logger, (a,b) ->{})__                SettingUpdater<Map<SettingUpdater<B>, B>> affixUpdaterB = settingB.newAffixUpdater(bConsumer, logger, (a,b) ->{})__                affixUpdaterA.apply(current, previous)__                affixUpdaterB.apply(current, previous)__                for (Map.Entry<String, Tuple<A, B>> entry : map.entrySet()) {_                    validator.accept(entry.getKey(), entry.getValue())__                }_                return Collections.unmodifiableMap(map)__            }__            @Override_            public void apply(Map<String, Tuple<A, B>> values, Settings current, Settings previous) {_                for (Map.Entry<String, Tuple<A, B>> entry : values.entrySet()) {_                    consumer.accept(entry.getKey(), entry.getValue())__                }_            }_        })__    };adds,a,affix,settings,consumer,that,accepts,the,values,for,two,settings,the,consumer,is,only,notified,if,one,or,both,settings,change,and,if,the,provided,validator,succeeded,p,note,only,settings,registered,in,link,settings,module,can,be,changed,dynamically,p,this,method,registers,a,compound,updater,that,is,useful,if,two,settings,are,depending,on,each,other,the,consumer,is,always,provided,with,both,values,even,if,only,one,of,the,two,changes;public,synchronized,a,b,void,add,affix,update,consumer,setting,affix,setting,a,setting,a,setting,affix,setting,b,setting,b,bi,consumer,string,tuple,a,b,consumer,bi,consumer,string,tuple,a,b,validator,ensure,setting,is,registered,setting,a,ensure,setting,is,registered,setting,b,setting,updater,map,setting,updater,a,a,affix,updater,a,setting,a,new,affix,updater,a,b,logger,a,b,setting,updater,map,setting,updater,b,b,affix,updater,b,setting,b,new,affix,updater,a,b,logger,a,b,add,settings,updater,new,setting,updater,map,string,tuple,a,b,override,public,boolean,has,changed,settings,current,settings,previous,return,affix,updater,a,has,changed,current,previous,affix,updater,b,has,changed,current,previous,override,public,map,string,tuple,a,b,get,value,settings,current,settings,previous,map,string,tuple,a,b,map,new,hash,map,bi,consumer,string,a,a,consumer,key,value,assert,map,contains,key,key,false,duplicate,key,key,map,put,key,new,tuple,value,setting,b,get,concrete,setting,for,namespace,key,get,current,bi,consumer,string,b,b,consumer,key,value,tuple,a,b,ab,tuple,map,get,key,if,ab,tuple,null,map,put,key,new,tuple,ab,tuple,v1,value,else,assert,setting,a,get,concrete,setting,for,namespace,key,get,current,equals,setting,a,get,concrete,setting,for,namespace,key,get,previous,expected,setting,a,get,concrete,setting,for,namespace,key,get,current,but,was,setting,a,get,concrete,setting,for,namespace,key,get,previous,map,put,key,new,tuple,setting,a,get,concrete,setting,for,namespace,key,get,current,value,setting,updater,map,setting,updater,a,a,affix,updater,a,setting,a,new,affix,updater,a,consumer,logger,a,b,setting,updater,map,setting,updater,b,b,affix,updater,b,setting,b,new,affix,updater,b,consumer,logger,a,b,affix,updater,a,apply,current,previous,affix,updater,b,apply,current,previous,for,map,entry,string,tuple,a,b,entry,map,entry,set,validator,accept,entry,get,key,entry,get,value,return,collections,unmodifiable,map,map,override,public,void,apply,map,string,tuple,a,b,values,settings,current,settings,previous,for,map,entry,string,tuple,a,b,entry,values,entry,set,consumer,accept,entry,get,key,entry,get,value
AbstractScopedSettings -> void validate(final String key, final Settings settings, final boolean validateDependencies, final boolean validateInternalIndex);1528904315;Validates that the settings is valid.__@param key the key of the setting to validate_@param settings the settings_@param validateDependencies true if dependent settings should be validated_@param validateInternalIndex true if internal index settings should be validated_@throws IllegalArgumentException if the setting is invalid;void validate(final String key, final Settings settings, final boolean validateDependencies, final boolean validateInternalIndex) {_        Setting setting = getRaw(key)__        if (setting == null) {_            LevensteinDistance ld = new LevensteinDistance()__            List<Tuple<Float, String>> scoredKeys = new ArrayList<>()__            for (String k : this.keySettings.keySet()) {_                float distance = ld.getDistance(key, k)__                if (distance > 0.7f) {_                    scoredKeys.add(new Tuple<>(distance, k))__                }_            }_            CollectionUtil.timSort(scoredKeys, (a,b) -> b.v1().compareTo(a.v1()))__            String msgPrefix = "unknown setting"__            SecureSettings secureSettings = settings.getSecureSettings()__            if (secureSettings != null && settings.getSecureSettings().getSettingNames().contains(key)) {_                msgPrefix = "unknown secure setting"__            }_            String msg = msgPrefix + " [" + key + "]"__            List<String> keys = scoredKeys.stream().map((a) -> a.v2()).collect(Collectors.toList())__            if (keys.isEmpty() == false) {_                msg += " did you mean " + (keys.size() == 1 ? "[" + keys.get(0) + "]": "any of " + keys.toString()) + "?"__            } else {_                msg += " please check that any required plugins are installed, or check the breaking changes documentation for removed " +_                    "settings"__            }_            throw new IllegalArgumentException(msg)__        } else  {_            Set<String> settingsDependencies = setting.getSettingsDependencies(key)__            if (setting.hasComplexMatcher()) {_                setting = setting.getConcreteSetting(key)__            }_            if (validateDependencies && settingsDependencies.isEmpty() == false) {_                Set<String> settingKeys = settings.keySet()__                for (String requiredSetting : settingsDependencies) {_                    if (settingKeys.contains(requiredSetting) == false) {_                        throw new IllegalArgumentException("Missing required setting ["_                            + requiredSetting + "] for setting [" + setting.getKey() + "]")__                    }_                }_            }_            _            if (validateInternalIndex && setting.getProperties().contains(Setting.Property.InternalIndex)) {_                throw new IllegalArgumentException(_                        "can not update internal setting [" + setting.getKey() + "]_ this setting is managed via a dedicated API")__            }_        }_        setting.get(settings)__    };validates,that,the,settings,is,valid,param,key,the,key,of,the,setting,to,validate,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,validate,internal,index,true,if,internal,index,settings,should,be,validated,throws,illegal,argument,exception,if,the,setting,is,invalid;void,validate,final,string,key,final,settings,settings,final,boolean,validate,dependencies,final,boolean,validate,internal,index,setting,setting,get,raw,key,if,setting,null,levenstein,distance,ld,new,levenstein,distance,list,tuple,float,string,scored,keys,new,array,list,for,string,k,this,key,settings,key,set,float,distance,ld,get,distance,key,k,if,distance,0,7f,scored,keys,add,new,tuple,distance,k,collection,util,tim,sort,scored,keys,a,b,b,v1,compare,to,a,v1,string,msg,prefix,unknown,setting,secure,settings,secure,settings,settings,get,secure,settings,if,secure,settings,null,settings,get,secure,settings,get,setting,names,contains,key,msg,prefix,unknown,secure,setting,string,msg,msg,prefix,key,list,string,keys,scored,keys,stream,map,a,a,v2,collect,collectors,to,list,if,keys,is,empty,false,msg,did,you,mean,keys,size,1,keys,get,0,any,of,keys,to,string,else,msg,please,check,that,any,required,plugins,are,installed,or,check,the,breaking,changes,documentation,for,removed,settings,throw,new,illegal,argument,exception,msg,else,set,string,settings,dependencies,setting,get,settings,dependencies,key,if,setting,has,complex,matcher,setting,setting,get,concrete,setting,key,if,validate,dependencies,settings,dependencies,is,empty,false,set,string,setting,keys,settings,key,set,for,string,required,setting,settings,dependencies,if,setting,keys,contains,required,setting,false,throw,new,illegal,argument,exception,missing,required,setting,required,setting,for,setting,setting,get,key,if,validate,internal,index,setting,get,properties,contains,setting,property,internal,index,throw,new,illegal,argument,exception,can,not,update,internal,setting,setting,get,key,this,setting,is,managed,via,a,dedicated,api,setting,get,settings
AbstractScopedSettings -> void validate(final String key, final Settings settings, final boolean validateDependencies, final boolean validateInternalIndex);1531179852;Validates that the settings is valid.__@param key the key of the setting to validate_@param settings the settings_@param validateDependencies true if dependent settings should be validated_@param validateInternalIndex true if internal index settings should be validated_@throws IllegalArgumentException if the setting is invalid;void validate(final String key, final Settings settings, final boolean validateDependencies, final boolean validateInternalIndex) {_        Setting<?> setting = getRaw(key)__        if (setting == null) {_            LevensteinDistance ld = new LevensteinDistance()__            List<Tuple<Float, String>> scoredKeys = new ArrayList<>()__            for (String k : this.keySettings.keySet()) {_                float distance = ld.getDistance(key, k)__                if (distance > 0.7f) {_                    scoredKeys.add(new Tuple<>(distance, k))__                }_            }_            CollectionUtil.timSort(scoredKeys, (a,b) -> b.v1().compareTo(a.v1()))__            String msgPrefix = "unknown setting"__            SecureSettings secureSettings = settings.getSecureSettings()__            if (secureSettings != null && settings.getSecureSettings().getSettingNames().contains(key)) {_                msgPrefix = "unknown secure setting"__            }_            String msg = msgPrefix + " [" + key + "]"__            List<String> keys = scoredKeys.stream().map((a) -> a.v2()).collect(Collectors.toList())__            if (keys.isEmpty() == false) {_                msg += " did you mean " + (keys.size() == 1 ? "[" + keys.get(0) + "]": "any of " + keys.toString()) + "?"__            } else {_                msg += " please check that any required plugins are installed, or check the breaking changes documentation for removed " +_                    "settings"__            }_            throw new IllegalArgumentException(msg)__        } else  {_            Set<String> settingsDependencies = setting.getSettingsDependencies(key)__            if (setting.hasComplexMatcher()) {_                setting = setting.getConcreteSetting(key)__            }_            if (validateDependencies && settingsDependencies.isEmpty() == false) {_                Set<String> settingKeys = settings.keySet()__                for (String requiredSetting : settingsDependencies) {_                    if (settingKeys.contains(requiredSetting) == false) {_                        throw new IllegalArgumentException("Missing required setting ["_                            + requiredSetting + "] for setting [" + setting.getKey() + "]")__                    }_                }_            }_            _            if (validateInternalIndex && setting.getProperties().contains(Setting.Property.InternalIndex)) {_                throw new IllegalArgumentException(_                        "can not update internal setting [" + setting.getKey() + "]_ this setting is managed via a dedicated API")__            }_        }_        setting.get(settings)__    };validates,that,the,settings,is,valid,param,key,the,key,of,the,setting,to,validate,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,validate,internal,index,true,if,internal,index,settings,should,be,validated,throws,illegal,argument,exception,if,the,setting,is,invalid;void,validate,final,string,key,final,settings,settings,final,boolean,validate,dependencies,final,boolean,validate,internal,index,setting,setting,get,raw,key,if,setting,null,levenstein,distance,ld,new,levenstein,distance,list,tuple,float,string,scored,keys,new,array,list,for,string,k,this,key,settings,key,set,float,distance,ld,get,distance,key,k,if,distance,0,7f,scored,keys,add,new,tuple,distance,k,collection,util,tim,sort,scored,keys,a,b,b,v1,compare,to,a,v1,string,msg,prefix,unknown,setting,secure,settings,secure,settings,settings,get,secure,settings,if,secure,settings,null,settings,get,secure,settings,get,setting,names,contains,key,msg,prefix,unknown,secure,setting,string,msg,msg,prefix,key,list,string,keys,scored,keys,stream,map,a,a,v2,collect,collectors,to,list,if,keys,is,empty,false,msg,did,you,mean,keys,size,1,keys,get,0,any,of,keys,to,string,else,msg,please,check,that,any,required,plugins,are,installed,or,check,the,breaking,changes,documentation,for,removed,settings,throw,new,illegal,argument,exception,msg,else,set,string,settings,dependencies,setting,get,settings,dependencies,key,if,setting,has,complex,matcher,setting,setting,get,concrete,setting,key,if,validate,dependencies,settings,dependencies,is,empty,false,set,string,setting,keys,settings,key,set,for,string,required,setting,settings,dependencies,if,setting,keys,contains,required,setting,false,throw,new,illegal,argument,exception,missing,required,setting,required,setting,for,setting,setting,get,key,if,validate,internal,index,setting,get,properties,contains,setting,property,internal,index,throw,new,illegal,argument,exception,can,not,update,internal,setting,setting,get,key,this,setting,is,managed,via,a,dedicated,api,setting,get,settings
AbstractScopedSettings -> void validate(final String key, final Settings settings, final boolean validateDependencies, final boolean validateInternalIndex);1535046779;Validates that the settings is valid.__@param key the key of the setting to validate_@param settings the settings_@param validateDependencies true if dependent settings should be validated_@param validateInternalIndex true if internal index settings should be validated_@throws IllegalArgumentException if the setting is invalid;void validate(final String key, final Settings settings, final boolean validateDependencies, final boolean validateInternalIndex) {_        Setting<?> setting = getRaw(key)__        if (setting == null) {_            LevensteinDistance ld = new LevensteinDistance()__            List<Tuple<Float, String>> scoredKeys = new ArrayList<>()__            for (String k : this.keySettings.keySet()) {_                float distance = ld.getDistance(key, k)__                if (distance > 0.7f) {_                    scoredKeys.add(new Tuple<>(distance, k))__                }_            }_            CollectionUtil.timSort(scoredKeys, (a,b) -> b.v1().compareTo(a.v1()))__            String msgPrefix = "unknown setting"__            SecureSettings secureSettings = settings.getSecureSettings()__            if (secureSettings != null && settings.getSecureSettings().getSettingNames().contains(key)) {_                msgPrefix = "unknown secure setting"__            }_            String msg = msgPrefix + " [" + key + "]"__            List<String> keys = scoredKeys.stream().map((a) -> a.v2()).collect(Collectors.toList())__            if (keys.isEmpty() == false) {_                msg += " did you mean " + (keys.size() == 1 ? "[" + keys.get(0) + "]": "any of " + keys.toString()) + "?"__            } else {_                msg += " please check that any required plugins are installed, or check the breaking changes documentation for removed " +_                    "settings"__            }_            throw new IllegalArgumentException(msg)__        } else  {_            Set<String> settingsDependencies = setting.getSettingsDependencies(key)__            if (setting.hasComplexMatcher()) {_                setting = setting.getConcreteSetting(key)__            }_            if (validateDependencies && settingsDependencies.isEmpty() == false) {_                Set<String> settingKeys = settings.keySet()__                for (String requiredSetting : settingsDependencies) {_                    if (settingKeys.contains(requiredSetting) == false) {_                        throw new IllegalArgumentException("Missing required setting ["_                            + requiredSetting + "] for setting [" + setting.getKey() + "]")__                    }_                }_            }_            _            if (validateInternalIndex && setting.getProperties().contains(Setting.Property.InternalIndex)) {_                throw new IllegalArgumentException(_                        "can not update internal setting [" + setting.getKey() + "]_ this setting is managed via a dedicated API")__            }_        }_        setting.get(settings)__    };validates,that,the,settings,is,valid,param,key,the,key,of,the,setting,to,validate,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,validate,internal,index,true,if,internal,index,settings,should,be,validated,throws,illegal,argument,exception,if,the,setting,is,invalid;void,validate,final,string,key,final,settings,settings,final,boolean,validate,dependencies,final,boolean,validate,internal,index,setting,setting,get,raw,key,if,setting,null,levenstein,distance,ld,new,levenstein,distance,list,tuple,float,string,scored,keys,new,array,list,for,string,k,this,key,settings,key,set,float,distance,ld,get,distance,key,k,if,distance,0,7f,scored,keys,add,new,tuple,distance,k,collection,util,tim,sort,scored,keys,a,b,b,v1,compare,to,a,v1,string,msg,prefix,unknown,setting,secure,settings,secure,settings,settings,get,secure,settings,if,secure,settings,null,settings,get,secure,settings,get,setting,names,contains,key,msg,prefix,unknown,secure,setting,string,msg,msg,prefix,key,list,string,keys,scored,keys,stream,map,a,a,v2,collect,collectors,to,list,if,keys,is,empty,false,msg,did,you,mean,keys,size,1,keys,get,0,any,of,keys,to,string,else,msg,please,check,that,any,required,plugins,are,installed,or,check,the,breaking,changes,documentation,for,removed,settings,throw,new,illegal,argument,exception,msg,else,set,string,settings,dependencies,setting,get,settings,dependencies,key,if,setting,has,complex,matcher,setting,setting,get,concrete,setting,key,if,validate,dependencies,settings,dependencies,is,empty,false,set,string,setting,keys,settings,key,set,for,string,required,setting,settings,dependencies,if,setting,keys,contains,required,setting,false,throw,new,illegal,argument,exception,missing,required,setting,required,setting,for,setting,setting,get,key,if,validate,internal,index,setting,get,properties,contains,setting,property,internal,index,throw,new,illegal,argument,exception,can,not,update,internal,setting,setting,get,key,this,setting,is,managed,via,a,dedicated,api,setting,get,settings
AbstractScopedSettings -> public final void validate(             final Settings settings,             final boolean validateDependencies,             final boolean ignorePrivateSettings,             final boolean ignoreArchivedSettings,             final boolean validateInternalIndex);1528904315;Validates that all settings are registered and valid.__@param settings               the settings_@param validateDependencies   true if dependent settings should be validated_@param ignorePrivateSettings  true if private settings should be ignored during validation_@param ignoreArchivedSettings true if archived settings should be ignored during validation_@param validateInternalIndex  true if index internal settings should be validated_@see Setting#getSettingsDependencies(String);public final void validate(_            final Settings settings,_            final boolean validateDependencies,_            final boolean ignorePrivateSettings,_            final boolean ignoreArchivedSettings,_            final boolean validateInternalIndex) {_        final List<RuntimeException> exceptions = new ArrayList<>()__        for (final String key : settings.keySet()) { _            if (isPrivateSetting(key) && ignorePrivateSettings) {_                continue__            }_            if (key.startsWith(ARCHIVED_SETTINGS_PREFIX) && ignoreArchivedSettings) {_                continue__            }_            try {_                validate(key, settings, validateDependencies, validateInternalIndex)__            } catch (final RuntimeException ex) {_                exceptions.add(ex)__            }_        }_        ExceptionsHelper.rethrowAndSuppress(exceptions)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,ignore,private,settings,true,if,private,settings,should,be,ignored,during,validation,param,ignore,archived,settings,true,if,archived,settings,should,be,ignored,during,validation,param,validate,internal,index,true,if,index,internal,settings,should,be,validated,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,final,boolean,ignore,private,settings,final,boolean,ignore,archived,settings,final,boolean,validate,internal,index,final,list,runtime,exception,exceptions,new,array,list,for,final,string,key,settings,key,set,if,is,private,setting,key,ignore,private,settings,continue,if,key,starts,with,ignore,archived,settings,continue,try,validate,key,settings,validate,dependencies,validate,internal,index,catch,final,runtime,exception,ex,exceptions,add,ex,exceptions,helper,rethrow,and,suppress,exceptions
AbstractScopedSettings -> public final void validate(             final Settings settings,             final boolean validateDependencies,             final boolean ignorePrivateSettings,             final boolean ignoreArchivedSettings,             final boolean validateInternalIndex);1531179852;Validates that all settings are registered and valid.__@param settings               the settings_@param validateDependencies   true if dependent settings should be validated_@param ignorePrivateSettings  true if private settings should be ignored during validation_@param ignoreArchivedSettings true if archived settings should be ignored during validation_@param validateInternalIndex  true if index internal settings should be validated_@see Setting#getSettingsDependencies(String);public final void validate(_            final Settings settings,_            final boolean validateDependencies,_            final boolean ignorePrivateSettings,_            final boolean ignoreArchivedSettings,_            final boolean validateInternalIndex) {_        final List<RuntimeException> exceptions = new ArrayList<>()__        for (final String key : settings.keySet()) { _            if (isPrivateSetting(key) && ignorePrivateSettings) {_                continue__            }_            if (key.startsWith(ARCHIVED_SETTINGS_PREFIX) && ignoreArchivedSettings) {_                continue__            }_            try {_                validate(key, settings, validateDependencies, validateInternalIndex)__            } catch (final RuntimeException ex) {_                exceptions.add(ex)__            }_        }_        ExceptionsHelper.rethrowAndSuppress(exceptions)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,ignore,private,settings,true,if,private,settings,should,be,ignored,during,validation,param,ignore,archived,settings,true,if,archived,settings,should,be,ignored,during,validation,param,validate,internal,index,true,if,index,internal,settings,should,be,validated,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,final,boolean,ignore,private,settings,final,boolean,ignore,archived,settings,final,boolean,validate,internal,index,final,list,runtime,exception,exceptions,new,array,list,for,final,string,key,settings,key,set,if,is,private,setting,key,ignore,private,settings,continue,if,key,starts,with,ignore,archived,settings,continue,try,validate,key,settings,validate,dependencies,validate,internal,index,catch,final,runtime,exception,ex,exceptions,add,ex,exceptions,helper,rethrow,and,suppress,exceptions
AbstractScopedSettings -> public final void validate(             final Settings settings,             final boolean validateDependencies,             final boolean ignorePrivateSettings,             final boolean ignoreArchivedSettings,             final boolean validateInternalIndex);1535046779;Validates that all settings are registered and valid.__@param settings               the settings_@param validateDependencies   true if dependent settings should be validated_@param ignorePrivateSettings  true if private settings should be ignored during validation_@param ignoreArchivedSettings true if archived settings should be ignored during validation_@param validateInternalIndex  true if index internal settings should be validated_@see Setting#getSettingsDependencies(String);public final void validate(_            final Settings settings,_            final boolean validateDependencies,_            final boolean ignorePrivateSettings,_            final boolean ignoreArchivedSettings,_            final boolean validateInternalIndex) {_        final List<RuntimeException> exceptions = new ArrayList<>()__        for (final String key : settings.keySet()) { _            if (isPrivateSetting(key) && ignorePrivateSettings) {_                continue__            }_            if (key.startsWith(ARCHIVED_SETTINGS_PREFIX) && ignoreArchivedSettings) {_                continue__            }_            try {_                validate(key, settings, validateDependencies, validateInternalIndex)__            } catch (final RuntimeException ex) {_                exceptions.add(ex)__            }_        }_        ExceptionsHelper.rethrowAndSuppress(exceptions)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,ignore,private,settings,true,if,private,settings,should,be,ignored,during,validation,param,ignore,archived,settings,true,if,archived,settings,should,be,ignored,during,validation,param,validate,internal,index,true,if,index,internal,settings,should,be,validated,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,final,boolean,ignore,private,settings,final,boolean,ignore,archived,settings,final,boolean,validate,internal,index,final,list,runtime,exception,exceptions,new,array,list,for,final,string,key,settings,key,set,if,is,private,setting,key,ignore,private,settings,continue,if,key,starts,with,ignore,archived,settings,continue,try,validate,key,settings,validate,dependencies,validate,internal,index,catch,final,runtime,exception,ex,exceptions,add,ex,exceptions,helper,rethrow,and,suppress,exceptions
AbstractScopedSettings -> SettingUpdater -> boolean hasChanged(Settings current, Settings previous)_;1524684173;Returns true if this updaters setting has changed with the current update_@param current the current settings_@param previous the previous setting_@return true if this updaters setting has changed with the current update;boolean hasChanged(Settings current, Settings previous)_;returns,true,if,this,updaters,setting,has,changed,with,the,current,update,param,current,the,current,settings,param,previous,the,previous,setting,return,true,if,this,updaters,setting,has,changed,with,the,current,update;boolean,has,changed,settings,current,settings,previous
AbstractScopedSettings -> SettingUpdater -> boolean hasChanged(Settings current, Settings previous)_;1528904315;Returns true if this updaters setting has changed with the current update_@param current the current settings_@param previous the previous setting_@return true if this updaters setting has changed with the current update;boolean hasChanged(Settings current, Settings previous)_;returns,true,if,this,updaters,setting,has,changed,with,the,current,update,param,current,the,current,settings,param,previous,the,previous,setting,return,true,if,this,updaters,setting,has,changed,with,the,current,update;boolean,has,changed,settings,current,settings,previous
AbstractScopedSettings -> SettingUpdater -> boolean hasChanged(Settings current, Settings previous)_;1531179852;Returns true if this updaters setting has changed with the current update_@param current the current settings_@param previous the previous setting_@return true if this updaters setting has changed with the current update;boolean hasChanged(Settings current, Settings previous)_;returns,true,if,this,updaters,setting,has,changed,with,the,current,update,param,current,the,current,settings,param,previous,the,previous,setting,return,true,if,this,updaters,setting,has,changed,with,the,current,update;boolean,has,changed,settings,current,settings,previous
AbstractScopedSettings -> SettingUpdater -> boolean hasChanged(Settings current, Settings previous)_;1535046779;Returns true if this updaters setting has changed with the current update_@param current the current settings_@param previous the previous setting_@return true if this updaters setting has changed with the current update;boolean hasChanged(Settings current, Settings previous)_;returns,true,if,this,updaters,setting,has,changed,with,the,current,update,param,current,the,current,settings,param,previous,the,previous,setting,return,true,if,this,updaters,setting,has,changed,with,the,current,update;boolean,has,changed,settings,current,settings,previous
AbstractScopedSettings -> SettingUpdater -> boolean hasChanged(Settings current, Settings previous)_;1536137328;Returns true if this updaters setting has changed with the current update_@param current the current settings_@param previous the previous setting_@return true if this updaters setting has changed with the current update;boolean hasChanged(Settings current, Settings previous)_;returns,true,if,this,updaters,setting,has,changed,with,the,current,update,param,current,the,current,settings,param,previous,the,previous,setting,return,true,if,this,updaters,setting,has,changed,with,the,current,update;boolean,has,changed,settings,current,settings,previous
AbstractScopedSettings -> SettingUpdater -> boolean hasChanged(Settings current, Settings previous)_;1536314350;Returns true if this updaters setting has changed with the current update_@param current the current settings_@param previous the previous setting_@return true if this updaters setting has changed with the current update;boolean hasChanged(Settings current, Settings previous)_;returns,true,if,this,updaters,setting,has,changed,with,the,current,update,param,current,the,current,settings,param,previous,the,previous,setting,return,true,if,this,updaters,setting,has,changed,with,the,current,update;boolean,has,changed,settings,current,settings,previous
AbstractScopedSettings -> SettingUpdater -> boolean hasChanged(Settings current, Settings previous)_;1536611444;Returns true if this updaters setting has changed with the current update_@param current the current settings_@param previous the previous setting_@return true if this updaters setting has changed with the current update;boolean hasChanged(Settings current, Settings previous)_;returns,true,if,this,updaters,setting,has,changed,with,the,current,update,param,current,the,current,settings,param,previous,the,previous,setting,return,true,if,this,updaters,setting,has,changed,with,the,current,update;boolean,has,changed,settings,current,settings,previous
AbstractScopedSettings -> SettingUpdater -> boolean hasChanged(Settings current, Settings previous)_;1536828374;Returns true if this updaters setting has changed with the current update_@param current the current settings_@param previous the previous setting_@return true if this updaters setting has changed with the current update;boolean hasChanged(Settings current, Settings previous)_;returns,true,if,this,updaters,setting,has,changed,with,the,current,update,param,current,the,current,settings,param,previous,the,previous,setting,return,true,if,this,updaters,setting,has,changed,with,the,current,update;boolean,has,changed,settings,current,settings,previous
AbstractScopedSettings -> SettingUpdater -> boolean hasChanged(Settings current, Settings previous)_;1539951844;Returns true if this updaters setting has changed with the current update_@param current the current settings_@param previous the previous setting_@return true if this updaters setting has changed with the current update;boolean hasChanged(Settings current, Settings previous)_;returns,true,if,this,updaters,setting,has,changed,with,the,current,update,param,current,the,current,settings,param,previous,the,previous,setting,return,true,if,this,updaters,setting,has,changed,with,the,current,update;boolean,has,changed,settings,current,settings,previous
AbstractScopedSettings -> SettingUpdater -> boolean hasChanged(Settings current, Settings previous)_;1541008027;Returns true if this updaters setting has changed with the current update_@param current the current settings_@param previous the previous setting_@return true if this updaters setting has changed with the current update;boolean hasChanged(Settings current, Settings previous)_;returns,true,if,this,updaters,setting,has,changed,with,the,current,update,param,current,the,current,settings,param,previous,the,previous,setting,return,true,if,this,updaters,setting,has,changed,with,the,current,update;boolean,has,changed,settings,current,settings,previous
AbstractScopedSettings -> SettingUpdater -> boolean hasChanged(Settings current, Settings previous)_;1541092382;Returns true if this updaters setting has changed with the current update_@param current the current settings_@param previous the previous setting_@return true if this updaters setting has changed with the current update;boolean hasChanged(Settings current, Settings previous)_;returns,true,if,this,updaters,setting,has,changed,with,the,current,update,param,current,the,current,settings,param,previous,the,previous,setting,return,true,if,this,updaters,setting,has,changed,with,the,current,update;boolean,has,changed,settings,current,settings,previous
AbstractScopedSettings -> SettingUpdater -> boolean hasChanged(Settings current, Settings previous)_;1542402632;Returns true if this updaters setting has changed with the current update_@param current the current settings_@param previous the previous setting_@return true if this updaters setting has changed with the current update;boolean hasChanged(Settings current, Settings previous)_;returns,true,if,this,updaters,setting,has,changed,with,the,current,update,param,current,the,current,settings,param,previous,the,previous,setting,return,true,if,this,updaters,setting,has,changed,with,the,current,update;boolean,has,changed,settings,current,settings,previous
AbstractScopedSettings -> SettingUpdater -> boolean hasChanged(Settings current, Settings previous)_;1544081506;Returns true if this updaters setting has changed with the current update_@param current the current settings_@param previous the previous setting_@return true if this updaters setting has changed with the current update;boolean hasChanged(Settings current, Settings previous)_;returns,true,if,this,updaters,setting,has,changed,with,the,current,update,param,current,the,current,settings,param,previous,the,previous,setting,return,true,if,this,updaters,setting,has,changed,with,the,current,update;boolean,has,changed,settings,current,settings,previous
AbstractScopedSettings -> SettingUpdater -> boolean hasChanged(Settings current, Settings previous)_;1544691774;Returns true if this updaters setting has changed with the current update_@param current the current settings_@param previous the previous setting_@return true if this updaters setting has changed with the current update;boolean hasChanged(Settings current, Settings previous)_;returns,true,if,this,updaters,setting,has,changed,with,the,current,update,param,current,the,current,settings,param,previous,the,previous,setting,return,true,if,this,updaters,setting,has,changed,with,the,current,update;boolean,has,changed,settings,current,settings,previous
AbstractScopedSettings -> SettingUpdater -> boolean hasChanged(Settings current, Settings previous)_;1546877578;Returns true if this updaters setting has changed with the current update_@param current the current settings_@param previous the previous setting_@return true if this updaters setting has changed with the current update;boolean hasChanged(Settings current, Settings previous)_;returns,true,if,this,updaters,setting,has,changed,with,the,current,update,param,current,the,current,settings,param,previous,the,previous,setting,return,true,if,this,updaters,setting,has,changed,with,the,current,update;boolean,has,changed,settings,current,settings,previous
AbstractScopedSettings -> SettingUpdater -> boolean hasChanged(Settings current, Settings previous)_;1548270339;Returns true if this updaters setting has changed with the current update_@param current the current settings_@param previous the previous setting_@return true if this updaters setting has changed with the current update;boolean hasChanged(Settings current, Settings previous)_;returns,true,if,this,updaters,setting,has,changed,with,the,current,update,param,current,the,current,settings,param,previous,the,previous,setting,return,true,if,this,updaters,setting,has,changed,with,the,current,update;boolean,has,changed,settings,current,settings,previous
AbstractScopedSettings -> void validate(             final String key, final Settings settings, final boolean validateDependencies, final boolean validateInternalOrPrivateIndex);1536137328;Validates that the settings is valid.__@param key                            the key of the setting to validate_@param settings                       the settings_@param validateDependencies           true if dependent settings should be validated_@param validateInternalOrPrivateIndex true if internal index settings should be validated_@throws IllegalArgumentException if the setting is invalid;void validate(_            final String key, final Settings settings, final boolean validateDependencies, final boolean validateInternalOrPrivateIndex) {_        Setting setting = getRaw(key)__        if (setting == null) {_            LevensteinDistance ld = new LevensteinDistance()__            List<Tuple<Float, String>> scoredKeys = new ArrayList<>()__            for (String k : this.keySettings.keySet()) {_                float distance = ld.getDistance(key, k)__                if (distance > 0.7f) {_                    scoredKeys.add(new Tuple<>(distance, k))__                }_            }_            CollectionUtil.timSort(scoredKeys, (a,b) -> b.v1().compareTo(a.v1()))__            String msgPrefix = "unknown setting"__            SecureSettings secureSettings = settings.getSecureSettings()__            if (secureSettings != null && settings.getSecureSettings().getSettingNames().contains(key)) {_                msgPrefix = "unknown secure setting"__            }_            String msg = msgPrefix + " [" + key + "]"__            List<String> keys = scoredKeys.stream().map((a) -> a.v2()).collect(Collectors.toList())__            if (keys.isEmpty() == false) {_                msg += " did you mean " + (keys.size() == 1 ? "[" + keys.get(0) + "]": "any of " + keys.toString()) + "?"__            } else {_                msg += " please check that any required plugins are installed, or check the breaking changes documentation for removed " +_                    "settings"__            }_            throw new IllegalArgumentException(msg)__        } else  {_            Set<String> settingsDependencies = setting.getSettingsDependencies(key)__            if (setting.hasComplexMatcher()) {_                setting = setting.getConcreteSetting(key)__            }_            if (validateDependencies && settingsDependencies.isEmpty() == false) {_                Set<String> settingKeys = settings.keySet()__                for (String requiredSetting : settingsDependencies) {_                    if (settingKeys.contains(requiredSetting) == false) {_                        throw new IllegalArgumentException("Missing required setting ["_                            + requiredSetting + "] for setting [" + setting.getKey() + "]")__                    }_                }_            }_            _            if (validateInternalOrPrivateIndex) {_                if (setting.isInternalIndex()) {_                    throw new IllegalArgumentException(_                            "can not update internal setting [" + setting.getKey() + "]_ this setting is managed via a dedicated API")__                } else if (setting.isPrivateIndex()) {_                    throw new IllegalArgumentException(_                            "can not update private setting [" + setting.getKey() + "]_ this setting is managed by Elasticsearch")__                }_            }_        }_        setting.get(settings)__    };validates,that,the,settings,is,valid,param,key,the,key,of,the,setting,to,validate,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,validate,internal,or,private,index,true,if,internal,index,settings,should,be,validated,throws,illegal,argument,exception,if,the,setting,is,invalid;void,validate,final,string,key,final,settings,settings,final,boolean,validate,dependencies,final,boolean,validate,internal,or,private,index,setting,setting,get,raw,key,if,setting,null,levenstein,distance,ld,new,levenstein,distance,list,tuple,float,string,scored,keys,new,array,list,for,string,k,this,key,settings,key,set,float,distance,ld,get,distance,key,k,if,distance,0,7f,scored,keys,add,new,tuple,distance,k,collection,util,tim,sort,scored,keys,a,b,b,v1,compare,to,a,v1,string,msg,prefix,unknown,setting,secure,settings,secure,settings,settings,get,secure,settings,if,secure,settings,null,settings,get,secure,settings,get,setting,names,contains,key,msg,prefix,unknown,secure,setting,string,msg,msg,prefix,key,list,string,keys,scored,keys,stream,map,a,a,v2,collect,collectors,to,list,if,keys,is,empty,false,msg,did,you,mean,keys,size,1,keys,get,0,any,of,keys,to,string,else,msg,please,check,that,any,required,plugins,are,installed,or,check,the,breaking,changes,documentation,for,removed,settings,throw,new,illegal,argument,exception,msg,else,set,string,settings,dependencies,setting,get,settings,dependencies,key,if,setting,has,complex,matcher,setting,setting,get,concrete,setting,key,if,validate,dependencies,settings,dependencies,is,empty,false,set,string,setting,keys,settings,key,set,for,string,required,setting,settings,dependencies,if,setting,keys,contains,required,setting,false,throw,new,illegal,argument,exception,missing,required,setting,required,setting,for,setting,setting,get,key,if,validate,internal,or,private,index,if,setting,is,internal,index,throw,new,illegal,argument,exception,can,not,update,internal,setting,setting,get,key,this,setting,is,managed,via,a,dedicated,api,else,if,setting,is,private,index,throw,new,illegal,argument,exception,can,not,update,private,setting,setting,get,key,this,setting,is,managed,by,elasticsearch,setting,get,settings
AbstractScopedSettings -> void validate(             final String key, final Settings settings, final boolean validateDependencies, final boolean validateInternalOrPrivateIndex);1536314350;Validates that the settings is valid.__@param key                            the key of the setting to validate_@param settings                       the settings_@param validateDependencies           true if dependent settings should be validated_@param validateInternalOrPrivateIndex true if internal index settings should be validated_@throws IllegalArgumentException if the setting is invalid;void validate(_            final String key, final Settings settings, final boolean validateDependencies, final boolean validateInternalOrPrivateIndex) {_        Setting setting = getRaw(key)__        if (setting == null) {_            LevenshteinDistance ld = new LevenshteinDistance()__            List<Tuple<Float, String>> scoredKeys = new ArrayList<>()__            for (String k : this.keySettings.keySet()) {_                float distance = ld.getDistance(key, k)__                if (distance > 0.7f) {_                    scoredKeys.add(new Tuple<>(distance, k))__                }_            }_            CollectionUtil.timSort(scoredKeys, (a,b) -> b.v1().compareTo(a.v1()))__            String msgPrefix = "unknown setting"__            SecureSettings secureSettings = settings.getSecureSettings()__            if (secureSettings != null && settings.getSecureSettings().getSettingNames().contains(key)) {_                msgPrefix = "unknown secure setting"__            }_            String msg = msgPrefix + " [" + key + "]"__            List<String> keys = scoredKeys.stream().map((a) -> a.v2()).collect(Collectors.toList())__            if (keys.isEmpty() == false) {_                msg += " did you mean " + (keys.size() == 1 ? "[" + keys.get(0) + "]": "any of " + keys.toString()) + "?"__            } else {_                msg += " please check that any required plugins are installed, or check the breaking changes documentation for removed " +_                    "settings"__            }_            throw new IllegalArgumentException(msg)__        } else  {_            Set<String> settingsDependencies = setting.getSettingsDependencies(key)__            if (setting.hasComplexMatcher()) {_                setting = setting.getConcreteSetting(key)__            }_            if (validateDependencies && settingsDependencies.isEmpty() == false) {_                Set<String> settingKeys = settings.keySet()__                for (String requiredSetting : settingsDependencies) {_                    if (settingKeys.contains(requiredSetting) == false) {_                        throw new IllegalArgumentException("Missing required setting ["_                            + requiredSetting + "] for setting [" + setting.getKey() + "]")__                    }_                }_            }_            _            if (validateInternalOrPrivateIndex) {_                if (setting.isInternalIndex()) {_                    throw new IllegalArgumentException(_                            "can not update internal setting [" + setting.getKey() + "]_ this setting is managed via a dedicated API")__                } else if (setting.isPrivateIndex()) {_                    throw new IllegalArgumentException(_                            "can not update private setting [" + setting.getKey() + "]_ this setting is managed by Elasticsearch")__                }_            }_        }_        setting.get(settings)__    };validates,that,the,settings,is,valid,param,key,the,key,of,the,setting,to,validate,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,validate,internal,or,private,index,true,if,internal,index,settings,should,be,validated,throws,illegal,argument,exception,if,the,setting,is,invalid;void,validate,final,string,key,final,settings,settings,final,boolean,validate,dependencies,final,boolean,validate,internal,or,private,index,setting,setting,get,raw,key,if,setting,null,levenshtein,distance,ld,new,levenshtein,distance,list,tuple,float,string,scored,keys,new,array,list,for,string,k,this,key,settings,key,set,float,distance,ld,get,distance,key,k,if,distance,0,7f,scored,keys,add,new,tuple,distance,k,collection,util,tim,sort,scored,keys,a,b,b,v1,compare,to,a,v1,string,msg,prefix,unknown,setting,secure,settings,secure,settings,settings,get,secure,settings,if,secure,settings,null,settings,get,secure,settings,get,setting,names,contains,key,msg,prefix,unknown,secure,setting,string,msg,msg,prefix,key,list,string,keys,scored,keys,stream,map,a,a,v2,collect,collectors,to,list,if,keys,is,empty,false,msg,did,you,mean,keys,size,1,keys,get,0,any,of,keys,to,string,else,msg,please,check,that,any,required,plugins,are,installed,or,check,the,breaking,changes,documentation,for,removed,settings,throw,new,illegal,argument,exception,msg,else,set,string,settings,dependencies,setting,get,settings,dependencies,key,if,setting,has,complex,matcher,setting,setting,get,concrete,setting,key,if,validate,dependencies,settings,dependencies,is,empty,false,set,string,setting,keys,settings,key,set,for,string,required,setting,settings,dependencies,if,setting,keys,contains,required,setting,false,throw,new,illegal,argument,exception,missing,required,setting,required,setting,for,setting,setting,get,key,if,validate,internal,or,private,index,if,setting,is,internal,index,throw,new,illegal,argument,exception,can,not,update,internal,setting,setting,get,key,this,setting,is,managed,via,a,dedicated,api,else,if,setting,is,private,index,throw,new,illegal,argument,exception,can,not,update,private,setting,setting,get,key,this,setting,is,managed,by,elasticsearch,setting,get,settings
AbstractScopedSettings -> void validate(             final String key, final Settings settings, final boolean validateDependencies, final boolean validateInternalOrPrivateIndex);1536611444;Validates that the settings is valid.__@param key                            the key of the setting to validate_@param settings                       the settings_@param validateDependencies           true if dependent settings should be validated_@param validateInternalOrPrivateIndex true if internal index settings should be validated_@throws IllegalArgumentException if the setting is invalid;void validate(_            final String key, final Settings settings, final boolean validateDependencies, final boolean validateInternalOrPrivateIndex) {_        Setting setting = getRaw(key)__        if (setting == null) {_            LevenshteinDistance ld = new LevenshteinDistance()__            List<Tuple<Float, String>> scoredKeys = new ArrayList<>()__            for (String k : this.keySettings.keySet()) {_                float distance = ld.getDistance(key, k)__                if (distance > 0.7f) {_                    scoredKeys.add(new Tuple<>(distance, k))__                }_            }_            CollectionUtil.timSort(scoredKeys, (a,b) -> b.v1().compareTo(a.v1()))__            String msgPrefix = "unknown setting"__            SecureSettings secureSettings = settings.getSecureSettings()__            if (secureSettings != null && settings.getSecureSettings().getSettingNames().contains(key)) {_                msgPrefix = "unknown secure setting"__            }_            String msg = msgPrefix + " [" + key + "]"__            List<String> keys = scoredKeys.stream().map((a) -> a.v2()).collect(Collectors.toList())__            if (keys.isEmpty() == false) {_                msg += " did you mean " + (keys.size() == 1 ? "[" + keys.get(0) + "]": "any of " + keys.toString()) + "?"__            } else {_                msg += " please check that any required plugins are installed, or check the breaking changes documentation for removed " +_                    "settings"__            }_            throw new IllegalArgumentException(msg)__        } else  {_            Set<Setting<?>> settingsDependencies = setting.getSettingsDependencies(key)__            if (setting.hasComplexMatcher()) {_                setting = setting.getConcreteSetting(key)__            }_            if (validateDependencies && settingsDependencies.isEmpty() == false) {_                for (final Setting<?> settingDependency : settingsDependencies) {_                    if (settingDependency.existsOrFallbackExists(settings) == false) {_                        final String message = String.format(_                                Locale.ROOT,_                                "missing required setting [%s] for setting [%s]",_                                settingDependency.getKey(),_                                setting.getKey())__                        throw new IllegalArgumentException(message)__                    }_                }_            }_            _            if (validateInternalOrPrivateIndex) {_                if (setting.isInternalIndex()) {_                    throw new IllegalArgumentException(_                            "can not update internal setting [" + setting.getKey() + "]_ this setting is managed via a dedicated API")__                } else if (setting.isPrivateIndex()) {_                    throw new IllegalArgumentException(_                            "can not update private setting [" + setting.getKey() + "]_ this setting is managed by Elasticsearch")__                }_            }_        }_        setting.get(settings)__    };validates,that,the,settings,is,valid,param,key,the,key,of,the,setting,to,validate,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,validate,internal,or,private,index,true,if,internal,index,settings,should,be,validated,throws,illegal,argument,exception,if,the,setting,is,invalid;void,validate,final,string,key,final,settings,settings,final,boolean,validate,dependencies,final,boolean,validate,internal,or,private,index,setting,setting,get,raw,key,if,setting,null,levenshtein,distance,ld,new,levenshtein,distance,list,tuple,float,string,scored,keys,new,array,list,for,string,k,this,key,settings,key,set,float,distance,ld,get,distance,key,k,if,distance,0,7f,scored,keys,add,new,tuple,distance,k,collection,util,tim,sort,scored,keys,a,b,b,v1,compare,to,a,v1,string,msg,prefix,unknown,setting,secure,settings,secure,settings,settings,get,secure,settings,if,secure,settings,null,settings,get,secure,settings,get,setting,names,contains,key,msg,prefix,unknown,secure,setting,string,msg,msg,prefix,key,list,string,keys,scored,keys,stream,map,a,a,v2,collect,collectors,to,list,if,keys,is,empty,false,msg,did,you,mean,keys,size,1,keys,get,0,any,of,keys,to,string,else,msg,please,check,that,any,required,plugins,are,installed,or,check,the,breaking,changes,documentation,for,removed,settings,throw,new,illegal,argument,exception,msg,else,set,setting,settings,dependencies,setting,get,settings,dependencies,key,if,setting,has,complex,matcher,setting,setting,get,concrete,setting,key,if,validate,dependencies,settings,dependencies,is,empty,false,for,final,setting,setting,dependency,settings,dependencies,if,setting,dependency,exists,or,fallback,exists,settings,false,final,string,message,string,format,locale,root,missing,required,setting,s,for,setting,s,setting,dependency,get,key,setting,get,key,throw,new,illegal,argument,exception,message,if,validate,internal,or,private,index,if,setting,is,internal,index,throw,new,illegal,argument,exception,can,not,update,internal,setting,setting,get,key,this,setting,is,managed,via,a,dedicated,api,else,if,setting,is,private,index,throw,new,illegal,argument,exception,can,not,update,private,setting,setting,get,key,this,setting,is,managed,by,elasticsearch,setting,get,settings
AbstractScopedSettings -> void validate(             final String key, final Settings settings, final boolean validateDependencies, final boolean validateInternalOrPrivateIndex);1536828374;Validates that the settings is valid.__@param key                            the key of the setting to validate_@param settings                       the settings_@param validateDependencies           true if dependent settings should be validated_@param validateInternalOrPrivateIndex true if internal index settings should be validated_@throws IllegalArgumentException if the setting is invalid;void validate(_            final String key, final Settings settings, final boolean validateDependencies, final boolean validateInternalOrPrivateIndex) {_        Setting setting = getRaw(key)__        if (setting == null) {_            LevenshteinDistance ld = new LevenshteinDistance()__            List<Tuple<Float, String>> scoredKeys = new ArrayList<>()__            for (String k : this.keySettings.keySet()) {_                float distance = ld.getDistance(key, k)__                if (distance > 0.7f) {_                    scoredKeys.add(new Tuple<>(distance, k))__                }_            }_            CollectionUtil.timSort(scoredKeys, (a,b) -> b.v1().compareTo(a.v1()))__            String msgPrefix = "unknown setting"__            SecureSettings secureSettings = settings.getSecureSettings()__            if (secureSettings != null && settings.getSecureSettings().getSettingNames().contains(key)) {_                msgPrefix = "unknown secure setting"__            }_            String msg = msgPrefix + " [" + key + "]"__            List<String> keys = scoredKeys.stream().map((a) -> a.v2()).collect(Collectors.toList())__            if (keys.isEmpty() == false) {_                msg += " did you mean " + (keys.size() == 1 ? "[" + keys.get(0) + "]": "any of " + keys.toString()) + "?"__            } else {_                msg += " please check that any required plugins are installed, or check the breaking changes documentation for removed " +_                    "settings"__            }_            throw new IllegalArgumentException(msg)__        } else  {_            Set<Setting<?>> settingsDependencies = setting.getSettingsDependencies(key)__            if (setting.hasComplexMatcher()) {_                setting = setting.getConcreteSetting(key)__            }_            if (validateDependencies && settingsDependencies.isEmpty() == false) {_                for (final Setting<?> settingDependency : settingsDependencies) {_                    if (settingDependency.existsOrFallbackExists(settings) == false) {_                        final String message = String.format(_                                Locale.ROOT,_                                "missing required setting [%s] for setting [%s]",_                                settingDependency.getKey(),_                                setting.getKey())__                        throw new IllegalArgumentException(message)__                    }_                }_            }_            _            if (validateInternalOrPrivateIndex) {_                if (setting.isInternalIndex()) {_                    throw new IllegalArgumentException(_                            "can not update internal setting [" + setting.getKey() + "]_ this setting is managed via a dedicated API")__                } else if (setting.isPrivateIndex()) {_                    throw new IllegalArgumentException(_                            "can not update private setting [" + setting.getKey() + "]_ this setting is managed by Elasticsearch")__                }_            }_        }_        setting.get(settings)__    };validates,that,the,settings,is,valid,param,key,the,key,of,the,setting,to,validate,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,validate,internal,or,private,index,true,if,internal,index,settings,should,be,validated,throws,illegal,argument,exception,if,the,setting,is,invalid;void,validate,final,string,key,final,settings,settings,final,boolean,validate,dependencies,final,boolean,validate,internal,or,private,index,setting,setting,get,raw,key,if,setting,null,levenshtein,distance,ld,new,levenshtein,distance,list,tuple,float,string,scored,keys,new,array,list,for,string,k,this,key,settings,key,set,float,distance,ld,get,distance,key,k,if,distance,0,7f,scored,keys,add,new,tuple,distance,k,collection,util,tim,sort,scored,keys,a,b,b,v1,compare,to,a,v1,string,msg,prefix,unknown,setting,secure,settings,secure,settings,settings,get,secure,settings,if,secure,settings,null,settings,get,secure,settings,get,setting,names,contains,key,msg,prefix,unknown,secure,setting,string,msg,msg,prefix,key,list,string,keys,scored,keys,stream,map,a,a,v2,collect,collectors,to,list,if,keys,is,empty,false,msg,did,you,mean,keys,size,1,keys,get,0,any,of,keys,to,string,else,msg,please,check,that,any,required,plugins,are,installed,or,check,the,breaking,changes,documentation,for,removed,settings,throw,new,illegal,argument,exception,msg,else,set,setting,settings,dependencies,setting,get,settings,dependencies,key,if,setting,has,complex,matcher,setting,setting,get,concrete,setting,key,if,validate,dependencies,settings,dependencies,is,empty,false,for,final,setting,setting,dependency,settings,dependencies,if,setting,dependency,exists,or,fallback,exists,settings,false,final,string,message,string,format,locale,root,missing,required,setting,s,for,setting,s,setting,dependency,get,key,setting,get,key,throw,new,illegal,argument,exception,message,if,validate,internal,or,private,index,if,setting,is,internal,index,throw,new,illegal,argument,exception,can,not,update,internal,setting,setting,get,key,this,setting,is,managed,via,a,dedicated,api,else,if,setting,is,private,index,throw,new,illegal,argument,exception,can,not,update,private,setting,setting,get,key,this,setting,is,managed,by,elasticsearch,setting,get,settings
AbstractScopedSettings -> void validate(             final String key, final Settings settings, final boolean validateDependencies, final boolean validateInternalOrPrivateIndex);1539951844;Validates that the settings is valid.__@param key                            the key of the setting to validate_@param settings                       the settings_@param validateDependencies           true if dependent settings should be validated_@param validateInternalOrPrivateIndex true if internal index settings should be validated_@throws IllegalArgumentException if the setting is invalid;void validate(_            final String key, final Settings settings, final boolean validateDependencies, final boolean validateInternalOrPrivateIndex) {_        Setting setting = getRaw(key)__        if (setting == null) {_            LevenshteinDistance ld = new LevenshteinDistance()__            List<Tuple<Float, String>> scoredKeys = new ArrayList<>()__            for (String k : this.keySettings.keySet()) {_                float distance = ld.getDistance(key, k)__                if (distance > 0.7f) {_                    scoredKeys.add(new Tuple<>(distance, k))__                }_            }_            CollectionUtil.timSort(scoredKeys, (a,b) -> b.v1().compareTo(a.v1()))__            String msgPrefix = "unknown setting"__            SecureSettings secureSettings = settings.getSecureSettings()__            if (secureSettings != null && settings.getSecureSettings().getSettingNames().contains(key)) {_                msgPrefix = "unknown secure setting"__            }_            String msg = msgPrefix + " [" + key + "]"__            List<String> keys = scoredKeys.stream().map((a) -> a.v2()).collect(Collectors.toList())__            if (keys.isEmpty() == false) {_                msg += " did you mean " + (keys.size() == 1 ? "[" + keys.get(0) + "]": "any of " + keys.toString()) + "?"__            } else {_                msg += " please check that any required plugins are installed, or check the breaking changes documentation for removed " +_                    "settings"__            }_            throw new IllegalArgumentException(msg)__        } else  {_            Set<Setting<?>> settingsDependencies = setting.getSettingsDependencies(key)__            if (setting.hasComplexMatcher()) {_                setting = setting.getConcreteSetting(key)__            }_            if (validateDependencies && settingsDependencies.isEmpty() == false) {_                for (final Setting<?> settingDependency : settingsDependencies) {_                    if (settingDependency.existsOrFallbackExists(settings) == false) {_                        final String message = String.format(_                                Locale.ROOT,_                                "missing required setting [%s] for setting [%s]",_                                settingDependency.getKey(),_                                setting.getKey())__                        throw new IllegalArgumentException(message)__                    }_                }_            }_            _            if (validateInternalOrPrivateIndex) {_                if (setting.isInternalIndex()) {_                    throw new IllegalArgumentException(_                            "can not update internal setting [" + setting.getKey() + "]_ this setting is managed via a dedicated API")__                } else if (setting.isPrivateIndex()) {_                    throw new IllegalArgumentException(_                            "can not update private setting [" + setting.getKey() + "]_ this setting is managed by Elasticsearch")__                }_            }_        }_        setting.get(settings)__    };validates,that,the,settings,is,valid,param,key,the,key,of,the,setting,to,validate,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,validate,internal,or,private,index,true,if,internal,index,settings,should,be,validated,throws,illegal,argument,exception,if,the,setting,is,invalid;void,validate,final,string,key,final,settings,settings,final,boolean,validate,dependencies,final,boolean,validate,internal,or,private,index,setting,setting,get,raw,key,if,setting,null,levenshtein,distance,ld,new,levenshtein,distance,list,tuple,float,string,scored,keys,new,array,list,for,string,k,this,key,settings,key,set,float,distance,ld,get,distance,key,k,if,distance,0,7f,scored,keys,add,new,tuple,distance,k,collection,util,tim,sort,scored,keys,a,b,b,v1,compare,to,a,v1,string,msg,prefix,unknown,setting,secure,settings,secure,settings,settings,get,secure,settings,if,secure,settings,null,settings,get,secure,settings,get,setting,names,contains,key,msg,prefix,unknown,secure,setting,string,msg,msg,prefix,key,list,string,keys,scored,keys,stream,map,a,a,v2,collect,collectors,to,list,if,keys,is,empty,false,msg,did,you,mean,keys,size,1,keys,get,0,any,of,keys,to,string,else,msg,please,check,that,any,required,plugins,are,installed,or,check,the,breaking,changes,documentation,for,removed,settings,throw,new,illegal,argument,exception,msg,else,set,setting,settings,dependencies,setting,get,settings,dependencies,key,if,setting,has,complex,matcher,setting,setting,get,concrete,setting,key,if,validate,dependencies,settings,dependencies,is,empty,false,for,final,setting,setting,dependency,settings,dependencies,if,setting,dependency,exists,or,fallback,exists,settings,false,final,string,message,string,format,locale,root,missing,required,setting,s,for,setting,s,setting,dependency,get,key,setting,get,key,throw,new,illegal,argument,exception,message,if,validate,internal,or,private,index,if,setting,is,internal,index,throw,new,illegal,argument,exception,can,not,update,internal,setting,setting,get,key,this,setting,is,managed,via,a,dedicated,api,else,if,setting,is,private,index,throw,new,illegal,argument,exception,can,not,update,private,setting,setting,get,key,this,setting,is,managed,by,elasticsearch,setting,get,settings
AbstractScopedSettings -> void validate(             final String key, final Settings settings, final boolean validateDependencies, final boolean validateInternalOrPrivateIndex);1541008027;Validates that the settings is valid.__@param key                            the key of the setting to validate_@param settings                       the settings_@param validateDependencies           true if dependent settings should be validated_@param validateInternalOrPrivateIndex true if internal index settings should be validated_@throws IllegalArgumentException if the setting is invalid;void validate(_            final String key, final Settings settings, final boolean validateDependencies, final boolean validateInternalOrPrivateIndex) {_        Setting setting = getRaw(key)__        if (setting == null) {_            LevenshteinDistance ld = new LevenshteinDistance()__            List<Tuple<Float, String>> scoredKeys = new ArrayList<>()__            for (String k : this.keySettings.keySet()) {_                float distance = ld.getDistance(key, k)__                if (distance > 0.7f) {_                    scoredKeys.add(new Tuple<>(distance, k))__                }_            }_            CollectionUtil.timSort(scoredKeys, (a,b) -> b.v1().compareTo(a.v1()))__            String msgPrefix = "unknown setting"__            SecureSettings secureSettings = settings.getSecureSettings()__            if (secureSettings != null && settings.getSecureSettings().getSettingNames().contains(key)) {_                msgPrefix = "unknown secure setting"__            }_            String msg = msgPrefix + " [" + key + "]"__            List<String> keys = scoredKeys.stream().map((a) -> a.v2()).collect(Collectors.toList())__            if (keys.isEmpty() == false) {_                msg += " did you mean " + (keys.size() == 1 ? "[" + keys.get(0) + "]": "any of " + keys.toString()) + "?"__            } else {_                msg += " please check that any required plugins are installed, or check the breaking changes documentation for removed " +_                    "settings"__            }_            throw new IllegalArgumentException(msg)__        } else  {_            Set<Setting<?>> settingsDependencies = setting.getSettingsDependencies(key)__            if (setting.hasComplexMatcher()) {_                setting = setting.getConcreteSetting(key)__            }_            if (validateDependencies && settingsDependencies.isEmpty() == false) {_                for (final Setting<?> settingDependency : settingsDependencies) {_                    if (settingDependency.existsOrFallbackExists(settings) == false) {_                        final String message = String.format(_                                Locale.ROOT,_                                "missing required setting [%s] for setting [%s]",_                                settingDependency.getKey(),_                                setting.getKey())__                        throw new IllegalArgumentException(message)__                    }_                }_            }_            _            if (validateInternalOrPrivateIndex) {_                if (setting.isInternalIndex()) {_                    throw new IllegalArgumentException(_                            "can not update internal setting [" + setting.getKey() + "]_ this setting is managed via a dedicated API")__                } else if (setting.isPrivateIndex()) {_                    throw new IllegalArgumentException(_                            "can not update private setting [" + setting.getKey() + "]_ this setting is managed by Elasticsearch")__                }_            }_        }_        setting.get(settings)__    };validates,that,the,settings,is,valid,param,key,the,key,of,the,setting,to,validate,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,validate,internal,or,private,index,true,if,internal,index,settings,should,be,validated,throws,illegal,argument,exception,if,the,setting,is,invalid;void,validate,final,string,key,final,settings,settings,final,boolean,validate,dependencies,final,boolean,validate,internal,or,private,index,setting,setting,get,raw,key,if,setting,null,levenshtein,distance,ld,new,levenshtein,distance,list,tuple,float,string,scored,keys,new,array,list,for,string,k,this,key,settings,key,set,float,distance,ld,get,distance,key,k,if,distance,0,7f,scored,keys,add,new,tuple,distance,k,collection,util,tim,sort,scored,keys,a,b,b,v1,compare,to,a,v1,string,msg,prefix,unknown,setting,secure,settings,secure,settings,settings,get,secure,settings,if,secure,settings,null,settings,get,secure,settings,get,setting,names,contains,key,msg,prefix,unknown,secure,setting,string,msg,msg,prefix,key,list,string,keys,scored,keys,stream,map,a,a,v2,collect,collectors,to,list,if,keys,is,empty,false,msg,did,you,mean,keys,size,1,keys,get,0,any,of,keys,to,string,else,msg,please,check,that,any,required,plugins,are,installed,or,check,the,breaking,changes,documentation,for,removed,settings,throw,new,illegal,argument,exception,msg,else,set,setting,settings,dependencies,setting,get,settings,dependencies,key,if,setting,has,complex,matcher,setting,setting,get,concrete,setting,key,if,validate,dependencies,settings,dependencies,is,empty,false,for,final,setting,setting,dependency,settings,dependencies,if,setting,dependency,exists,or,fallback,exists,settings,false,final,string,message,string,format,locale,root,missing,required,setting,s,for,setting,s,setting,dependency,get,key,setting,get,key,throw,new,illegal,argument,exception,message,if,validate,internal,or,private,index,if,setting,is,internal,index,throw,new,illegal,argument,exception,can,not,update,internal,setting,setting,get,key,this,setting,is,managed,via,a,dedicated,api,else,if,setting,is,private,index,throw,new,illegal,argument,exception,can,not,update,private,setting,setting,get,key,this,setting,is,managed,by,elasticsearch,setting,get,settings
AbstractScopedSettings -> void validate(             final String key, final Settings settings, final boolean validateDependencies, final boolean validateInternalOrPrivateIndex);1541092382;Validates that the settings is valid.__@param key                            the key of the setting to validate_@param settings                       the settings_@param validateDependencies           true if dependent settings should be validated_@param validateInternalOrPrivateIndex true if internal index settings should be validated_@throws IllegalArgumentException if the setting is invalid;void validate(_            final String key, final Settings settings, final boolean validateDependencies, final boolean validateInternalOrPrivateIndex) {_        Setting setting = getRaw(key)__        if (setting == null) {_            LevenshteinDistance ld = new LevenshteinDistance()__            List<Tuple<Float, String>> scoredKeys = new ArrayList<>()__            for (String k : this.keySettings.keySet()) {_                float distance = ld.getDistance(key, k)__                if (distance > 0.7f) {_                    scoredKeys.add(new Tuple<>(distance, k))__                }_            }_            CollectionUtil.timSort(scoredKeys, (a,b) -> b.v1().compareTo(a.v1()))__            String msgPrefix = "unknown setting"__            SecureSettings secureSettings = settings.getSecureSettings()__            if (secureSettings != null && settings.getSecureSettings().getSettingNames().contains(key)) {_                msgPrefix = "unknown secure setting"__            }_            String msg = msgPrefix + " [" + key + "]"__            List<String> keys = scoredKeys.stream().map((a) -> a.v2()).collect(Collectors.toList())__            if (keys.isEmpty() == false) {_                msg += " did you mean " + (keys.size() == 1 ? "[" + keys.get(0) + "]": "any of " + keys.toString()) + "?"__            } else {_                msg += " please check that any required plugins are installed, or check the breaking changes documentation for removed " +_                    "settings"__            }_            throw new IllegalArgumentException(msg)__        } else  {_            Set<Setting<?>> settingsDependencies = setting.getSettingsDependencies(key)__            if (setting.hasComplexMatcher()) {_                setting = setting.getConcreteSetting(key)__            }_            if (validateDependencies && settingsDependencies.isEmpty() == false) {_                for (final Setting<?> settingDependency : settingsDependencies) {_                    if (settingDependency.existsOrFallbackExists(settings) == false) {_                        final String message = String.format(_                                Locale.ROOT,_                                "missing required setting [%s] for setting [%s]",_                                settingDependency.getKey(),_                                setting.getKey())__                        throw new IllegalArgumentException(message)__                    }_                }_            }_            _            if (validateInternalOrPrivateIndex) {_                if (setting.isInternalIndex()) {_                    throw new IllegalArgumentException(_                            "can not update internal setting [" + setting.getKey() + "]_ this setting is managed via a dedicated API")__                } else if (setting.isPrivateIndex()) {_                    throw new IllegalArgumentException(_                            "can not update private setting [" + setting.getKey() + "]_ this setting is managed by Elasticsearch")__                }_            }_        }_        setting.get(settings)__    };validates,that,the,settings,is,valid,param,key,the,key,of,the,setting,to,validate,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,validate,internal,or,private,index,true,if,internal,index,settings,should,be,validated,throws,illegal,argument,exception,if,the,setting,is,invalid;void,validate,final,string,key,final,settings,settings,final,boolean,validate,dependencies,final,boolean,validate,internal,or,private,index,setting,setting,get,raw,key,if,setting,null,levenshtein,distance,ld,new,levenshtein,distance,list,tuple,float,string,scored,keys,new,array,list,for,string,k,this,key,settings,key,set,float,distance,ld,get,distance,key,k,if,distance,0,7f,scored,keys,add,new,tuple,distance,k,collection,util,tim,sort,scored,keys,a,b,b,v1,compare,to,a,v1,string,msg,prefix,unknown,setting,secure,settings,secure,settings,settings,get,secure,settings,if,secure,settings,null,settings,get,secure,settings,get,setting,names,contains,key,msg,prefix,unknown,secure,setting,string,msg,msg,prefix,key,list,string,keys,scored,keys,stream,map,a,a,v2,collect,collectors,to,list,if,keys,is,empty,false,msg,did,you,mean,keys,size,1,keys,get,0,any,of,keys,to,string,else,msg,please,check,that,any,required,plugins,are,installed,or,check,the,breaking,changes,documentation,for,removed,settings,throw,new,illegal,argument,exception,msg,else,set,setting,settings,dependencies,setting,get,settings,dependencies,key,if,setting,has,complex,matcher,setting,setting,get,concrete,setting,key,if,validate,dependencies,settings,dependencies,is,empty,false,for,final,setting,setting,dependency,settings,dependencies,if,setting,dependency,exists,or,fallback,exists,settings,false,final,string,message,string,format,locale,root,missing,required,setting,s,for,setting,s,setting,dependency,get,key,setting,get,key,throw,new,illegal,argument,exception,message,if,validate,internal,or,private,index,if,setting,is,internal,index,throw,new,illegal,argument,exception,can,not,update,internal,setting,setting,get,key,this,setting,is,managed,via,a,dedicated,api,else,if,setting,is,private,index,throw,new,illegal,argument,exception,can,not,update,private,setting,setting,get,key,this,setting,is,managed,by,elasticsearch,setting,get,settings
AbstractScopedSettings -> void validate(             final String key, final Settings settings, final boolean validateDependencies, final boolean validateInternalOrPrivateIndex);1542402632;Validates that the settings is valid.__@param key                            the key of the setting to validate_@param settings                       the settings_@param validateDependencies           true if dependent settings should be validated_@param validateInternalOrPrivateIndex true if internal index settings should be validated_@throws IllegalArgumentException if the setting is invalid;void validate(_            final String key, final Settings settings, final boolean validateDependencies, final boolean validateInternalOrPrivateIndex) {_        Setting setting = getRaw(key)__        if (setting == null) {_            LevenshteinDistance ld = new LevenshteinDistance()__            List<Tuple<Float, String>> scoredKeys = new ArrayList<>()__            for (String k : this.keySettings.keySet()) {_                float distance = ld.getDistance(key, k)__                if (distance > 0.7f) {_                    scoredKeys.add(new Tuple<>(distance, k))__                }_            }_            CollectionUtil.timSort(scoredKeys, (a,b) -> b.v1().compareTo(a.v1()))__            String msgPrefix = "unknown setting"__            SecureSettings secureSettings = settings.getSecureSettings()__            if (secureSettings != null && settings.getSecureSettings().getSettingNames().contains(key)) {_                msgPrefix = "unknown secure setting"__            }_            String msg = msgPrefix + " [" + key + "]"__            List<String> keys = scoredKeys.stream().map((a) -> a.v2()).collect(Collectors.toList())__            if (keys.isEmpty() == false) {_                msg += " did you mean " + (keys.size() == 1 ? "[" + keys.get(0) + "]": "any of " + keys.toString()) + "?"__            } else {_                msg += " please check that any required plugins are installed, or check the breaking changes documentation for removed " +_                    "settings"__            }_            throw new IllegalArgumentException(msg)__        } else  {_            Set<Setting<?>> settingsDependencies = setting.getSettingsDependencies(key)__            if (setting.hasComplexMatcher()) {_                setting = setting.getConcreteSetting(key)__            }_            if (validateDependencies && settingsDependencies.isEmpty() == false) {_                for (final Setting<?> settingDependency : settingsDependencies) {_                    if (settingDependency.existsOrFallbackExists(settings) == false) {_                        final String message = String.format(_                                Locale.ROOT,_                                "missing required setting [%s] for setting [%s]",_                                settingDependency.getKey(),_                                setting.getKey())__                        throw new IllegalArgumentException(message)__                    }_                }_            }_            _            if (validateInternalOrPrivateIndex) {_                if (setting.isInternalIndex()) {_                    throw new IllegalArgumentException(_                            "can not update internal setting [" + setting.getKey() + "]_ this setting is managed via a dedicated API")__                } else if (setting.isPrivateIndex()) {_                    throw new IllegalArgumentException(_                            "can not update private setting [" + setting.getKey() + "]_ this setting is managed by Elasticsearch")__                }_            }_        }_        setting.get(settings)__    };validates,that,the,settings,is,valid,param,key,the,key,of,the,setting,to,validate,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,validate,internal,or,private,index,true,if,internal,index,settings,should,be,validated,throws,illegal,argument,exception,if,the,setting,is,invalid;void,validate,final,string,key,final,settings,settings,final,boolean,validate,dependencies,final,boolean,validate,internal,or,private,index,setting,setting,get,raw,key,if,setting,null,levenshtein,distance,ld,new,levenshtein,distance,list,tuple,float,string,scored,keys,new,array,list,for,string,k,this,key,settings,key,set,float,distance,ld,get,distance,key,k,if,distance,0,7f,scored,keys,add,new,tuple,distance,k,collection,util,tim,sort,scored,keys,a,b,b,v1,compare,to,a,v1,string,msg,prefix,unknown,setting,secure,settings,secure,settings,settings,get,secure,settings,if,secure,settings,null,settings,get,secure,settings,get,setting,names,contains,key,msg,prefix,unknown,secure,setting,string,msg,msg,prefix,key,list,string,keys,scored,keys,stream,map,a,a,v2,collect,collectors,to,list,if,keys,is,empty,false,msg,did,you,mean,keys,size,1,keys,get,0,any,of,keys,to,string,else,msg,please,check,that,any,required,plugins,are,installed,or,check,the,breaking,changes,documentation,for,removed,settings,throw,new,illegal,argument,exception,msg,else,set,setting,settings,dependencies,setting,get,settings,dependencies,key,if,setting,has,complex,matcher,setting,setting,get,concrete,setting,key,if,validate,dependencies,settings,dependencies,is,empty,false,for,final,setting,setting,dependency,settings,dependencies,if,setting,dependency,exists,or,fallback,exists,settings,false,final,string,message,string,format,locale,root,missing,required,setting,s,for,setting,s,setting,dependency,get,key,setting,get,key,throw,new,illegal,argument,exception,message,if,validate,internal,or,private,index,if,setting,is,internal,index,throw,new,illegal,argument,exception,can,not,update,internal,setting,setting,get,key,this,setting,is,managed,via,a,dedicated,api,else,if,setting,is,private,index,throw,new,illegal,argument,exception,can,not,update,private,setting,setting,get,key,this,setting,is,managed,by,elasticsearch,setting,get,settings
AbstractScopedSettings -> void validate(             final String key, final Settings settings, final boolean validateDependencies, final boolean validateInternalOrPrivateIndex);1544081506;Validates that the settings is valid.__@param key                            the key of the setting to validate_@param settings                       the settings_@param validateDependencies           true if dependent settings should be validated_@param validateInternalOrPrivateIndex true if internal index settings should be validated_@throws IllegalArgumentException if the setting is invalid;void validate(_            final String key, final Settings settings, final boolean validateDependencies, final boolean validateInternalOrPrivateIndex) {_        Setting setting = getRaw(key)__        if (setting == null) {_            LevenshteinDistance ld = new LevenshteinDistance()__            List<Tuple<Float, String>> scoredKeys = new ArrayList<>()__            for (String k : this.keySettings.keySet()) {_                float distance = ld.getDistance(key, k)__                if (distance > 0.7f) {_                    scoredKeys.add(new Tuple<>(distance, k))__                }_            }_            CollectionUtil.timSort(scoredKeys, (a,b) -> b.v1().compareTo(a.v1()))__            String msgPrefix = "unknown setting"__            SecureSettings secureSettings = settings.getSecureSettings()__            if (secureSettings != null && settings.getSecureSettings().getSettingNames().contains(key)) {_                msgPrefix = "unknown secure setting"__            }_            String msg = msgPrefix + " [" + key + "]"__            List<String> keys = scoredKeys.stream().map((a) -> a.v2()).collect(Collectors.toList())__            if (keys.isEmpty() == false) {_                msg += " did you mean " + (keys.size() == 1 ? "[" + keys.get(0) + "]": "any of " + keys.toString()) + "?"__            } else {_                msg += " please check that any required plugins are installed, or check the breaking changes documentation for removed " +_                    "settings"__            }_            throw new IllegalArgumentException(msg)__        } else  {_            Set<Setting<?>> settingsDependencies = setting.getSettingsDependencies(key)__            if (setting.hasComplexMatcher()) {_                setting = setting.getConcreteSetting(key)__            }_            if (validateDependencies && settingsDependencies.isEmpty() == false) {_                for (final Setting<?> settingDependency : settingsDependencies) {_                    if (settingDependency.existsOrFallbackExists(settings) == false) {_                        final String message = String.format(_                                Locale.ROOT,_                                "missing required setting [%s] for setting [%s]",_                                settingDependency.getKey(),_                                setting.getKey())__                        throw new IllegalArgumentException(message)__                    }_                }_            }_            _            if (validateInternalOrPrivateIndex) {_                if (setting.isInternalIndex()) {_                    throw new IllegalArgumentException(_                            "can not update internal setting [" + setting.getKey() + "]_ this setting is managed via a dedicated API")__                } else if (setting.isPrivateIndex()) {_                    throw new IllegalArgumentException(_                            "can not update private setting [" + setting.getKey() + "]_ this setting is managed by Elasticsearch")__                }_            }_        }_        setting.get(settings)__    };validates,that,the,settings,is,valid,param,key,the,key,of,the,setting,to,validate,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,validate,internal,or,private,index,true,if,internal,index,settings,should,be,validated,throws,illegal,argument,exception,if,the,setting,is,invalid;void,validate,final,string,key,final,settings,settings,final,boolean,validate,dependencies,final,boolean,validate,internal,or,private,index,setting,setting,get,raw,key,if,setting,null,levenshtein,distance,ld,new,levenshtein,distance,list,tuple,float,string,scored,keys,new,array,list,for,string,k,this,key,settings,key,set,float,distance,ld,get,distance,key,k,if,distance,0,7f,scored,keys,add,new,tuple,distance,k,collection,util,tim,sort,scored,keys,a,b,b,v1,compare,to,a,v1,string,msg,prefix,unknown,setting,secure,settings,secure,settings,settings,get,secure,settings,if,secure,settings,null,settings,get,secure,settings,get,setting,names,contains,key,msg,prefix,unknown,secure,setting,string,msg,msg,prefix,key,list,string,keys,scored,keys,stream,map,a,a,v2,collect,collectors,to,list,if,keys,is,empty,false,msg,did,you,mean,keys,size,1,keys,get,0,any,of,keys,to,string,else,msg,please,check,that,any,required,plugins,are,installed,or,check,the,breaking,changes,documentation,for,removed,settings,throw,new,illegal,argument,exception,msg,else,set,setting,settings,dependencies,setting,get,settings,dependencies,key,if,setting,has,complex,matcher,setting,setting,get,concrete,setting,key,if,validate,dependencies,settings,dependencies,is,empty,false,for,final,setting,setting,dependency,settings,dependencies,if,setting,dependency,exists,or,fallback,exists,settings,false,final,string,message,string,format,locale,root,missing,required,setting,s,for,setting,s,setting,dependency,get,key,setting,get,key,throw,new,illegal,argument,exception,message,if,validate,internal,or,private,index,if,setting,is,internal,index,throw,new,illegal,argument,exception,can,not,update,internal,setting,setting,get,key,this,setting,is,managed,via,a,dedicated,api,else,if,setting,is,private,index,throw,new,illegal,argument,exception,can,not,update,private,setting,setting,get,key,this,setting,is,managed,by,elasticsearch,setting,get,settings
AbstractScopedSettings -> void validate(             final String key, final Settings settings, final boolean validateDependencies, final boolean validateInternalOrPrivateIndex);1544691774;Validates that the settings is valid.__@param key                            the key of the setting to validate_@param settings                       the settings_@param validateDependencies           true if dependent settings should be validated_@param validateInternalOrPrivateIndex true if internal index settings should be validated_@throws IllegalArgumentException if the setting is invalid;void validate(_            final String key, final Settings settings, final boolean validateDependencies, final boolean validateInternalOrPrivateIndex) {_        Setting setting = getRaw(key)__        if (setting == null) {_            LevenshteinDistance ld = new LevenshteinDistance()__            List<Tuple<Float, String>> scoredKeys = new ArrayList<>()__            for (String k : this.keySettings.keySet()) {_                float distance = ld.getDistance(key, k)__                if (distance > 0.7f) {_                    scoredKeys.add(new Tuple<>(distance, k))__                }_            }_            CollectionUtil.timSort(scoredKeys, (a,b) -> b.v1().compareTo(a.v1()))__            String msgPrefix = "unknown setting"__            SecureSettings secureSettings = settings.getSecureSettings()__            if (secureSettings != null && settings.getSecureSettings().getSettingNames().contains(key)) {_                msgPrefix = "unknown secure setting"__            }_            String msg = msgPrefix + " [" + key + "]"__            List<String> keys = scoredKeys.stream().map((a) -> a.v2()).collect(Collectors.toList())__            if (keys.isEmpty() == false) {_                msg += " did you mean " + (keys.size() == 1 ? "[" + keys.get(0) + "]": "any of " + keys.toString()) + "?"__            } else {_                msg += " please check that any required plugins are installed, or check the breaking changes documentation for removed " +_                    "settings"__            }_            throw new IllegalArgumentException(msg)__        } else  {_            Set<Setting<?>> settingsDependencies = setting.getSettingsDependencies(key)__            if (setting.hasComplexMatcher()) {_                setting = setting.getConcreteSetting(key)__            }_            if (validateDependencies && settingsDependencies.isEmpty() == false) {_                for (final Setting<?> settingDependency : settingsDependencies) {_                    if (settingDependency.existsOrFallbackExists(settings) == false) {_                        final String message = String.format(_                                Locale.ROOT,_                                "missing required setting [%s] for setting [%s]",_                                settingDependency.getKey(),_                                setting.getKey())__                        throw new IllegalArgumentException(message)__                    }_                }_            }_            _            if (validateInternalOrPrivateIndex) {_                if (setting.isInternalIndex()) {_                    throw new IllegalArgumentException(_                            "can not update internal setting [" + setting.getKey() + "]_ this setting is managed via a dedicated API")__                } else if (setting.isPrivateIndex()) {_                    throw new IllegalArgumentException(_                            "can not update private setting [" + setting.getKey() + "]_ this setting is managed by Elasticsearch")__                }_            }_        }_        setting.get(settings)__    };validates,that,the,settings,is,valid,param,key,the,key,of,the,setting,to,validate,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,validate,internal,or,private,index,true,if,internal,index,settings,should,be,validated,throws,illegal,argument,exception,if,the,setting,is,invalid;void,validate,final,string,key,final,settings,settings,final,boolean,validate,dependencies,final,boolean,validate,internal,or,private,index,setting,setting,get,raw,key,if,setting,null,levenshtein,distance,ld,new,levenshtein,distance,list,tuple,float,string,scored,keys,new,array,list,for,string,k,this,key,settings,key,set,float,distance,ld,get,distance,key,k,if,distance,0,7f,scored,keys,add,new,tuple,distance,k,collection,util,tim,sort,scored,keys,a,b,b,v1,compare,to,a,v1,string,msg,prefix,unknown,setting,secure,settings,secure,settings,settings,get,secure,settings,if,secure,settings,null,settings,get,secure,settings,get,setting,names,contains,key,msg,prefix,unknown,secure,setting,string,msg,msg,prefix,key,list,string,keys,scored,keys,stream,map,a,a,v2,collect,collectors,to,list,if,keys,is,empty,false,msg,did,you,mean,keys,size,1,keys,get,0,any,of,keys,to,string,else,msg,please,check,that,any,required,plugins,are,installed,or,check,the,breaking,changes,documentation,for,removed,settings,throw,new,illegal,argument,exception,msg,else,set,setting,settings,dependencies,setting,get,settings,dependencies,key,if,setting,has,complex,matcher,setting,setting,get,concrete,setting,key,if,validate,dependencies,settings,dependencies,is,empty,false,for,final,setting,setting,dependency,settings,dependencies,if,setting,dependency,exists,or,fallback,exists,settings,false,final,string,message,string,format,locale,root,missing,required,setting,s,for,setting,s,setting,dependency,get,key,setting,get,key,throw,new,illegal,argument,exception,message,if,validate,internal,or,private,index,if,setting,is,internal,index,throw,new,illegal,argument,exception,can,not,update,internal,setting,setting,get,key,this,setting,is,managed,via,a,dedicated,api,else,if,setting,is,private,index,throw,new,illegal,argument,exception,can,not,update,private,setting,setting,get,key,this,setting,is,managed,by,elasticsearch,setting,get,settings
AbstractScopedSettings -> void validate(             final String key, final Settings settings, final boolean validateDependencies, final boolean validateInternalOrPrivateIndex);1546877578;Validates that the settings is valid.__@param key                            the key of the setting to validate_@param settings                       the settings_@param validateDependencies           true if dependent settings should be validated_@param validateInternalOrPrivateIndex true if internal index settings should be validated_@throws IllegalArgumentException if the setting is invalid;void validate(_            final String key, final Settings settings, final boolean validateDependencies, final boolean validateInternalOrPrivateIndex) {_        Setting setting = getRaw(key)__        if (setting == null) {_            LevenshteinDistance ld = new LevenshteinDistance()__            List<Tuple<Float, String>> scoredKeys = new ArrayList<>()__            for (String k : this.keySettings.keySet()) {_                float distance = ld.getDistance(key, k)__                if (distance > 0.7f) {_                    scoredKeys.add(new Tuple<>(distance, k))__                }_            }_            CollectionUtil.timSort(scoredKeys, (a,b) -> b.v1().compareTo(a.v1()))__            String msgPrefix = "unknown setting"__            SecureSettings secureSettings = settings.getSecureSettings()__            if (secureSettings != null && settings.getSecureSettings().getSettingNames().contains(key)) {_                msgPrefix = "unknown secure setting"__            }_            String msg = msgPrefix + " [" + key + "]"__            List<String> keys = scoredKeys.stream().map((a) -> a.v2()).collect(Collectors.toList())__            if (keys.isEmpty() == false) {_                msg += " did you mean " + (keys.size() == 1 ? "[" + keys.get(0) + "]": "any of " + keys.toString()) + "?"__            } else {_                msg += " please check that any required plugins are installed, or check the breaking changes documentation for removed " +_                    "settings"__            }_            throw new IllegalArgumentException(msg)__        } else  {_            Set<Setting<?>> settingsDependencies = setting.getSettingsDependencies(key)__            if (setting.hasComplexMatcher()) {_                setting = setting.getConcreteSetting(key)__            }_            if (validateDependencies && settingsDependencies.isEmpty() == false) {_                for (final Setting<?> settingDependency : settingsDependencies) {_                    if (settingDependency.existsOrFallbackExists(settings) == false) {_                        final String message = String.format(_                                Locale.ROOT,_                                "missing required setting [%s] for setting [%s]",_                                settingDependency.getKey(),_                                setting.getKey())__                        throw new IllegalArgumentException(message)__                    }_                }_            }_            _            if (validateInternalOrPrivateIndex) {_                if (setting.isInternalIndex()) {_                    throw new IllegalArgumentException(_                            "can not update internal setting [" + setting.getKey() + "]_ this setting is managed via a dedicated API")__                } else if (setting.isPrivateIndex()) {_                    throw new IllegalArgumentException(_                            "can not update private setting [" + setting.getKey() + "]_ this setting is managed by Elasticsearch")__                }_            }_        }_        setting.get(settings)__    };validates,that,the,settings,is,valid,param,key,the,key,of,the,setting,to,validate,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,validate,internal,or,private,index,true,if,internal,index,settings,should,be,validated,throws,illegal,argument,exception,if,the,setting,is,invalid;void,validate,final,string,key,final,settings,settings,final,boolean,validate,dependencies,final,boolean,validate,internal,or,private,index,setting,setting,get,raw,key,if,setting,null,levenshtein,distance,ld,new,levenshtein,distance,list,tuple,float,string,scored,keys,new,array,list,for,string,k,this,key,settings,key,set,float,distance,ld,get,distance,key,k,if,distance,0,7f,scored,keys,add,new,tuple,distance,k,collection,util,tim,sort,scored,keys,a,b,b,v1,compare,to,a,v1,string,msg,prefix,unknown,setting,secure,settings,secure,settings,settings,get,secure,settings,if,secure,settings,null,settings,get,secure,settings,get,setting,names,contains,key,msg,prefix,unknown,secure,setting,string,msg,msg,prefix,key,list,string,keys,scored,keys,stream,map,a,a,v2,collect,collectors,to,list,if,keys,is,empty,false,msg,did,you,mean,keys,size,1,keys,get,0,any,of,keys,to,string,else,msg,please,check,that,any,required,plugins,are,installed,or,check,the,breaking,changes,documentation,for,removed,settings,throw,new,illegal,argument,exception,msg,else,set,setting,settings,dependencies,setting,get,settings,dependencies,key,if,setting,has,complex,matcher,setting,setting,get,concrete,setting,key,if,validate,dependencies,settings,dependencies,is,empty,false,for,final,setting,setting,dependency,settings,dependencies,if,setting,dependency,exists,or,fallback,exists,settings,false,final,string,message,string,format,locale,root,missing,required,setting,s,for,setting,s,setting,dependency,get,key,setting,get,key,throw,new,illegal,argument,exception,message,if,validate,internal,or,private,index,if,setting,is,internal,index,throw,new,illegal,argument,exception,can,not,update,internal,setting,setting,get,key,this,setting,is,managed,via,a,dedicated,api,else,if,setting,is,private,index,throw,new,illegal,argument,exception,can,not,update,private,setting,setting,get,key,this,setting,is,managed,by,elasticsearch,setting,get,settings
AbstractScopedSettings -> void validate(             final String key, final Settings settings, final boolean validateDependencies, final boolean validateInternalOrPrivateIndex);1548270339;Validates that the settings is valid.__@param key                            the key of the setting to validate_@param settings                       the settings_@param validateDependencies           true if dependent settings should be validated_@param validateInternalOrPrivateIndex true if internal index settings should be validated_@throws IllegalArgumentException if the setting is invalid;void validate(_            final String key, final Settings settings, final boolean validateDependencies, final boolean validateInternalOrPrivateIndex) {_        Setting setting = getRaw(key)__        if (setting == null) {_            LevenshteinDistance ld = new LevenshteinDistance()__            List<Tuple<Float, String>> scoredKeys = new ArrayList<>()__            for (String k : this.keySettings.keySet()) {_                float distance = ld.getDistance(key, k)__                if (distance > 0.7f) {_                    scoredKeys.add(new Tuple<>(distance, k))__                }_            }_            CollectionUtil.timSort(scoredKeys, (a,b) -> b.v1().compareTo(a.v1()))__            String msgPrefix = "unknown setting"__            SecureSettings secureSettings = settings.getSecureSettings()__            if (secureSettings != null && settings.getSecureSettings().getSettingNames().contains(key)) {_                msgPrefix = "unknown secure setting"__            }_            String msg = msgPrefix + " [" + key + "]"__            List<String> keys = scoredKeys.stream().map((a) -> a.v2()).collect(Collectors.toList())__            if (keys.isEmpty() == false) {_                msg += " did you mean " + (keys.size() == 1 ? "[" + keys.get(0) + "]": "any of " + keys.toString()) + "?"__            } else {_                msg += " please check that any required plugins are installed, or check the breaking changes documentation for removed " +_                    "settings"__            }_            throw new IllegalArgumentException(msg)__        } else  {_            Set<Setting<?>> settingsDependencies = setting.getSettingsDependencies(key)__            if (setting.hasComplexMatcher()) {_                setting = setting.getConcreteSetting(key)__            }_            if (validateDependencies && settingsDependencies.isEmpty() == false) {_                for (final Setting<?> settingDependency : settingsDependencies) {_                    if (settingDependency.existsOrFallbackExists(settings) == false) {_                        final String message = String.format(_                                Locale.ROOT,_                                "missing required setting [%s] for setting [%s]",_                                settingDependency.getKey(),_                                setting.getKey())__                        throw new IllegalArgumentException(message)__                    }_                }_            }_            _            if (validateInternalOrPrivateIndex) {_                if (setting.isInternalIndex()) {_                    throw new IllegalArgumentException(_                            "can not update internal setting [" + setting.getKey() + "]_ this setting is managed via a dedicated API")__                } else if (setting.isPrivateIndex()) {_                    throw new IllegalArgumentException(_                            "can not update private setting [" + setting.getKey() + "]_ this setting is managed by Elasticsearch")__                }_            }_        }_        setting.get(settings)__    };validates,that,the,settings,is,valid,param,key,the,key,of,the,setting,to,validate,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,validate,internal,or,private,index,true,if,internal,index,settings,should,be,validated,throws,illegal,argument,exception,if,the,setting,is,invalid;void,validate,final,string,key,final,settings,settings,final,boolean,validate,dependencies,final,boolean,validate,internal,or,private,index,setting,setting,get,raw,key,if,setting,null,levenshtein,distance,ld,new,levenshtein,distance,list,tuple,float,string,scored,keys,new,array,list,for,string,k,this,key,settings,key,set,float,distance,ld,get,distance,key,k,if,distance,0,7f,scored,keys,add,new,tuple,distance,k,collection,util,tim,sort,scored,keys,a,b,b,v1,compare,to,a,v1,string,msg,prefix,unknown,setting,secure,settings,secure,settings,settings,get,secure,settings,if,secure,settings,null,settings,get,secure,settings,get,setting,names,contains,key,msg,prefix,unknown,secure,setting,string,msg,msg,prefix,key,list,string,keys,scored,keys,stream,map,a,a,v2,collect,collectors,to,list,if,keys,is,empty,false,msg,did,you,mean,keys,size,1,keys,get,0,any,of,keys,to,string,else,msg,please,check,that,any,required,plugins,are,installed,or,check,the,breaking,changes,documentation,for,removed,settings,throw,new,illegal,argument,exception,msg,else,set,setting,settings,dependencies,setting,get,settings,dependencies,key,if,setting,has,complex,matcher,setting,setting,get,concrete,setting,key,if,validate,dependencies,settings,dependencies,is,empty,false,for,final,setting,setting,dependency,settings,dependencies,if,setting,dependency,exists,or,fallback,exists,settings,false,final,string,message,string,format,locale,root,missing,required,setting,s,for,setting,s,setting,dependency,get,key,setting,get,key,throw,new,illegal,argument,exception,message,if,validate,internal,or,private,index,if,setting,is,internal,index,throw,new,illegal,argument,exception,can,not,update,internal,setting,setting,get,key,this,setting,is,managed,via,a,dedicated,api,else,if,setting,is,private,index,throw,new,illegal,argument,exception,can,not,update,private,setting,setting,get,key,this,setting,is,managed,by,elasticsearch,setting,get,settings
AbstractScopedSettings -> public synchronized <T> void addAffixMapUpdateConsumer(Setting.AffixSetting<T> setting, Consumer<Map<String, T>> consumer,                                                            BiConsumer<String, T> validator);1539951844;Adds a settings consumer for affix settings. Affix settings have a namespace associated to it that needs to be available to the_consumer in order to be processed correctly. This consumer will get a namespace to value map instead of each individual namespace_and value as in {@link #addAffixUpdateConsumer(Setting.AffixSetting, BiConsumer, BiConsumer)};public synchronized <T> void addAffixMapUpdateConsumer(Setting.AffixSetting<T> setting, Consumer<Map<String, T>> consumer,_                                                           BiConsumer<String, T> validator) {_        final Setting<?> registeredSetting = this.complexMatchers.get(setting.getKey())__        if (setting != registeredSetting) {_            throw new IllegalArgumentException("Setting is not registered for key [" + setting.getKey() + "]")__        }_        addSettingsUpdater(setting.newAffixMapUpdater(consumer, logger, validator))__    };adds,a,settings,consumer,for,affix,settings,affix,settings,have,a,namespace,associated,to,it,that,needs,to,be,available,to,the,consumer,in,order,to,be,processed,correctly,this,consumer,will,get,a,namespace,to,value,map,instead,of,each,individual,namespace,and,value,as,in,link,add,affix,update,consumer,setting,affix,setting,bi,consumer,bi,consumer;public,synchronized,t,void,add,affix,map,update,consumer,setting,affix,setting,t,setting,consumer,map,string,t,consumer,bi,consumer,string,t,validator,final,setting,registered,setting,this,complex,matchers,get,setting,get,key,if,setting,registered,setting,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,setting,get,key,add,settings,updater,setting,new,affix,map,updater,consumer,logger,validator
AbstractScopedSettings -> public synchronized <T> void addAffixMapUpdateConsumer(Setting.AffixSetting<T> setting, Consumer<Map<String, T>> consumer,                                                            BiConsumer<String, T> validator);1541008027;Adds a settings consumer for affix settings. Affix settings have a namespace associated to it that needs to be available to the_consumer in order to be processed correctly. This consumer will get a namespace to value map instead of each individual namespace_and value as in {@link #addAffixUpdateConsumer(Setting.AffixSetting, BiConsumer, BiConsumer)};public synchronized <T> void addAffixMapUpdateConsumer(Setting.AffixSetting<T> setting, Consumer<Map<String, T>> consumer,_                                                           BiConsumer<String, T> validator) {_        final Setting<?> registeredSetting = this.complexMatchers.get(setting.getKey())__        if (setting != registeredSetting) {_            throw new IllegalArgumentException("Setting is not registered for key [" + setting.getKey() + "]")__        }_        addSettingsUpdater(setting.newAffixMapUpdater(consumer, logger, validator))__    };adds,a,settings,consumer,for,affix,settings,affix,settings,have,a,namespace,associated,to,it,that,needs,to,be,available,to,the,consumer,in,order,to,be,processed,correctly,this,consumer,will,get,a,namespace,to,value,map,instead,of,each,individual,namespace,and,value,as,in,link,add,affix,update,consumer,setting,affix,setting,bi,consumer,bi,consumer;public,synchronized,t,void,add,affix,map,update,consumer,setting,affix,setting,t,setting,consumer,map,string,t,consumer,bi,consumer,string,t,validator,final,setting,registered,setting,this,complex,matchers,get,setting,get,key,if,setting,registered,setting,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,setting,get,key,add,settings,updater,setting,new,affix,map,updater,consumer,logger,validator
AbstractScopedSettings -> public synchronized <T> void addAffixMapUpdateConsumer(Setting.AffixSetting<T> setting, Consumer<Map<String, T>> consumer,                                                            BiConsumer<String, T> validator);1541092382;Adds a settings consumer for affix settings. Affix settings have a namespace associated to it that needs to be available to the_consumer in order to be processed correctly. This consumer will get a namespace to value map instead of each individual namespace_and value as in {@link #addAffixUpdateConsumer(Setting.AffixSetting, BiConsumer, BiConsumer)};public synchronized <T> void addAffixMapUpdateConsumer(Setting.AffixSetting<T> setting, Consumer<Map<String, T>> consumer,_                                                           BiConsumer<String, T> validator) {_        final Setting<?> registeredSetting = this.complexMatchers.get(setting.getKey())__        if (setting != registeredSetting) {_            throw new IllegalArgumentException("Setting is not registered for key [" + setting.getKey() + "]")__        }_        addSettingsUpdater(setting.newAffixMapUpdater(consumer, logger, validator))__    };adds,a,settings,consumer,for,affix,settings,affix,settings,have,a,namespace,associated,to,it,that,needs,to,be,available,to,the,consumer,in,order,to,be,processed,correctly,this,consumer,will,get,a,namespace,to,value,map,instead,of,each,individual,namespace,and,value,as,in,link,add,affix,update,consumer,setting,affix,setting,bi,consumer,bi,consumer;public,synchronized,t,void,add,affix,map,update,consumer,setting,affix,setting,t,setting,consumer,map,string,t,consumer,bi,consumer,string,t,validator,final,setting,registered,setting,this,complex,matchers,get,setting,get,key,if,setting,registered,setting,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,setting,get,key,add,settings,updater,setting,new,affix,map,updater,consumer,logger,validator
AbstractScopedSettings -> public synchronized <T> void addAffixMapUpdateConsumer(Setting.AffixSetting<T> setting, Consumer<Map<String, T>> consumer,                                                            BiConsumer<String, T> validator);1542402632;Adds a settings consumer for affix settings. Affix settings have a namespace associated to it that needs to be available to the_consumer in order to be processed correctly. This consumer will get a namespace to value map instead of each individual namespace_and value as in {@link #addAffixUpdateConsumer(Setting.AffixSetting, BiConsumer, BiConsumer)};public synchronized <T> void addAffixMapUpdateConsumer(Setting.AffixSetting<T> setting, Consumer<Map<String, T>> consumer,_                                                           BiConsumer<String, T> validator) {_        final Setting<?> registeredSetting = this.complexMatchers.get(setting.getKey())__        if (setting != registeredSetting) {_            throw new IllegalArgumentException("Setting is not registered for key [" + setting.getKey() + "]")__        }_        addSettingsUpdater(setting.newAffixMapUpdater(consumer, logger, validator))__    };adds,a,settings,consumer,for,affix,settings,affix,settings,have,a,namespace,associated,to,it,that,needs,to,be,available,to,the,consumer,in,order,to,be,processed,correctly,this,consumer,will,get,a,namespace,to,value,map,instead,of,each,individual,namespace,and,value,as,in,link,add,affix,update,consumer,setting,affix,setting,bi,consumer,bi,consumer;public,synchronized,t,void,add,affix,map,update,consumer,setting,affix,setting,t,setting,consumer,map,string,t,consumer,bi,consumer,string,t,validator,final,setting,registered,setting,this,complex,matchers,get,setting,get,key,if,setting,registered,setting,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,setting,get,key,add,settings,updater,setting,new,affix,map,updater,consumer,logger,validator
AbstractScopedSettings -> public synchronized <T> void addAffixMapUpdateConsumer(Setting.AffixSetting<T> setting, Consumer<Map<String, T>> consumer,                                                            BiConsumer<String, T> validator);1544081506;Adds a settings consumer for affix settings. Affix settings have a namespace associated to it that needs to be available to the_consumer in order to be processed correctly. This consumer will get a namespace to value map instead of each individual namespace_and value as in {@link #addAffixUpdateConsumer(Setting.AffixSetting, BiConsumer, BiConsumer)};public synchronized <T> void addAffixMapUpdateConsumer(Setting.AffixSetting<T> setting, Consumer<Map<String, T>> consumer,_                                                           BiConsumer<String, T> validator) {_        final Setting<?> registeredSetting = this.complexMatchers.get(setting.getKey())__        if (setting != registeredSetting) {_            throw new IllegalArgumentException("Setting is not registered for key [" + setting.getKey() + "]")__        }_        addSettingsUpdater(setting.newAffixMapUpdater(consumer, logger, validator))__    };adds,a,settings,consumer,for,affix,settings,affix,settings,have,a,namespace,associated,to,it,that,needs,to,be,available,to,the,consumer,in,order,to,be,processed,correctly,this,consumer,will,get,a,namespace,to,value,map,instead,of,each,individual,namespace,and,value,as,in,link,add,affix,update,consumer,setting,affix,setting,bi,consumer,bi,consumer;public,synchronized,t,void,add,affix,map,update,consumer,setting,affix,setting,t,setting,consumer,map,string,t,consumer,bi,consumer,string,t,validator,final,setting,registered,setting,this,complex,matchers,get,setting,get,key,if,setting,registered,setting,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,setting,get,key,add,settings,updater,setting,new,affix,map,updater,consumer,logger,validator
AbstractScopedSettings -> public synchronized <T> void addAffixMapUpdateConsumer(Setting.AffixSetting<T> setting, Consumer<Map<String, T>> consumer,                                                            BiConsumer<String, T> validator);1544691774;Adds a settings consumer for affix settings. Affix settings have a namespace associated to it that needs to be available to the_consumer in order to be processed correctly. This consumer will get a namespace to value map instead of each individual namespace_and value as in {@link #addAffixUpdateConsumer(Setting.AffixSetting, BiConsumer, BiConsumer)};public synchronized <T> void addAffixMapUpdateConsumer(Setting.AffixSetting<T> setting, Consumer<Map<String, T>> consumer,_                                                           BiConsumer<String, T> validator) {_        final Setting<?> registeredSetting = this.complexMatchers.get(setting.getKey())__        if (setting != registeredSetting) {_            throw new IllegalArgumentException("Setting is not registered for key [" + setting.getKey() + "]")__        }_        addSettingsUpdater(setting.newAffixMapUpdater(consumer, logger, validator))__    };adds,a,settings,consumer,for,affix,settings,affix,settings,have,a,namespace,associated,to,it,that,needs,to,be,available,to,the,consumer,in,order,to,be,processed,correctly,this,consumer,will,get,a,namespace,to,value,map,instead,of,each,individual,namespace,and,value,as,in,link,add,affix,update,consumer,setting,affix,setting,bi,consumer,bi,consumer;public,synchronized,t,void,add,affix,map,update,consumer,setting,affix,setting,t,setting,consumer,map,string,t,consumer,bi,consumer,string,t,validator,final,setting,registered,setting,this,complex,matchers,get,setting,get,key,if,setting,registered,setting,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,setting,get,key,add,settings,updater,setting,new,affix,map,updater,consumer,logger,validator
AbstractScopedSettings -> public synchronized <T> void addAffixMapUpdateConsumer(Setting.AffixSetting<T> setting, Consumer<Map<String, T>> consumer,                                                            BiConsumer<String, T> validator);1546877578;Adds a settings consumer for affix settings. Affix settings have a namespace associated to it that needs to be available to the_consumer in order to be processed correctly. This consumer will get a namespace to value map instead of each individual namespace_and value as in {@link #addAffixUpdateConsumer(Setting.AffixSetting, BiConsumer, BiConsumer)};public synchronized <T> void addAffixMapUpdateConsumer(Setting.AffixSetting<T> setting, Consumer<Map<String, T>> consumer,_                                                           BiConsumer<String, T> validator) {_        final Setting<?> registeredSetting = this.complexMatchers.get(setting.getKey())__        if (setting != registeredSetting) {_            throw new IllegalArgumentException("Setting is not registered for key [" + setting.getKey() + "]")__        }_        addSettingsUpdater(setting.newAffixMapUpdater(consumer, logger, validator))__    };adds,a,settings,consumer,for,affix,settings,affix,settings,have,a,namespace,associated,to,it,that,needs,to,be,available,to,the,consumer,in,order,to,be,processed,correctly,this,consumer,will,get,a,namespace,to,value,map,instead,of,each,individual,namespace,and,value,as,in,link,add,affix,update,consumer,setting,affix,setting,bi,consumer,bi,consumer;public,synchronized,t,void,add,affix,map,update,consumer,setting,affix,setting,t,setting,consumer,map,string,t,consumer,bi,consumer,string,t,validator,final,setting,registered,setting,this,complex,matchers,get,setting,get,key,if,setting,registered,setting,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,setting,get,key,add,settings,updater,setting,new,affix,map,updater,consumer,logger,validator
AbstractScopedSettings -> public synchronized <T> void addAffixMapUpdateConsumer(Setting.AffixSetting<T> setting, Consumer<Map<String, T>> consumer,                                                            BiConsumer<String, T> validator);1548270339;Adds a settings consumer for affix settings. Affix settings have a namespace associated to it that needs to be available to the_consumer in order to be processed correctly. This consumer will get a namespace to value map instead of each individual namespace_and value as in {@link #addAffixUpdateConsumer(Setting.AffixSetting, BiConsumer, BiConsumer)};public synchronized <T> void addAffixMapUpdateConsumer(Setting.AffixSetting<T> setting, Consumer<Map<String, T>> consumer,_                                                           BiConsumer<String, T> validator) {_        final Setting<?> registeredSetting = this.complexMatchers.get(setting.getKey())__        if (setting != registeredSetting) {_            throw new IllegalArgumentException("Setting is not registered for key [" + setting.getKey() + "]")__        }_        addSettingsUpdater(setting.newAffixMapUpdater(consumer, logger, validator))__    };adds,a,settings,consumer,for,affix,settings,affix,settings,have,a,namespace,associated,to,it,that,needs,to,be,available,to,the,consumer,in,order,to,be,processed,correctly,this,consumer,will,get,a,namespace,to,value,map,instead,of,each,individual,namespace,and,value,as,in,link,add,affix,update,consumer,setting,affix,setting,bi,consumer,bi,consumer;public,synchronized,t,void,add,affix,map,update,consumer,setting,affix,setting,t,setting,consumer,map,string,t,consumer,bi,consumer,string,t,validator,final,setting,registered,setting,this,complex,matchers,get,setting,get,key,if,setting,registered,setting,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,setting,get,key,add,settings,updater,setting,new,affix,map,updater,consumer,logger,validator
AbstractScopedSettings -> public final void validate(final Settings settings, final boolean validateDependencies, final boolean validateInternalOrPrivateIndex);1536137328;Validates that all settings are registered and valid.__@param settings                       the settings to validate_@param validateDependencies           true if dependent settings should be validated_@param validateInternalOrPrivateIndex true if internal index settings should be validated_@see Setting#getSettingsDependencies(String);public final void validate(final Settings settings, final boolean validateDependencies, final boolean validateInternalOrPrivateIndex) {_        validate(settings, validateDependencies, false, false, validateInternalOrPrivateIndex)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,to,validate,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,validate,internal,or,private,index,true,if,internal,index,settings,should,be,validated,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,final,boolean,validate,internal,or,private,index,validate,settings,validate,dependencies,false,false,validate,internal,or,private,index
AbstractScopedSettings -> public final void validate(final Settings settings, final boolean validateDependencies, final boolean validateInternalOrPrivateIndex);1536314350;Validates that all settings are registered and valid.__@param settings                       the settings to validate_@param validateDependencies           true if dependent settings should be validated_@param validateInternalOrPrivateIndex true if internal index settings should be validated_@see Setting#getSettingsDependencies(String);public final void validate(final Settings settings, final boolean validateDependencies, final boolean validateInternalOrPrivateIndex) {_        validate(settings, validateDependencies, false, false, validateInternalOrPrivateIndex)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,to,validate,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,validate,internal,or,private,index,true,if,internal,index,settings,should,be,validated,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,final,boolean,validate,internal,or,private,index,validate,settings,validate,dependencies,false,false,validate,internal,or,private,index
AbstractScopedSettings -> public final void validate(final Settings settings, final boolean validateDependencies, final boolean validateInternalOrPrivateIndex);1536611444;Validates that all settings are registered and valid.__@param settings                       the settings to validate_@param validateDependencies           true if dependent settings should be validated_@param validateInternalOrPrivateIndex true if internal index settings should be validated_@see Setting#getSettingsDependencies(String);public final void validate(final Settings settings, final boolean validateDependencies, final boolean validateInternalOrPrivateIndex) {_        validate(settings, validateDependencies, false, false, validateInternalOrPrivateIndex)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,to,validate,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,validate,internal,or,private,index,true,if,internal,index,settings,should,be,validated,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,final,boolean,validate,internal,or,private,index,validate,settings,validate,dependencies,false,false,validate,internal,or,private,index
AbstractScopedSettings -> public final void validate(final Settings settings, final boolean validateDependencies, final boolean validateInternalOrPrivateIndex);1536828374;Validates that all settings are registered and valid.__@param settings                       the settings to validate_@param validateDependencies           true if dependent settings should be validated_@param validateInternalOrPrivateIndex true if internal index settings should be validated_@see Setting#getSettingsDependencies(String);public final void validate(final Settings settings, final boolean validateDependencies, final boolean validateInternalOrPrivateIndex) {_        validate(settings, validateDependencies, false, false, validateInternalOrPrivateIndex)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,to,validate,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,validate,internal,or,private,index,true,if,internal,index,settings,should,be,validated,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,final,boolean,validate,internal,or,private,index,validate,settings,validate,dependencies,false,false,validate,internal,or,private,index
AbstractScopedSettings -> public final void validate(final Settings settings, final boolean validateDependencies, final boolean validateInternalOrPrivateIndex);1539951844;Validates that all settings are registered and valid.__@param settings                       the settings to validate_@param validateDependencies           true if dependent settings should be validated_@param validateInternalOrPrivateIndex true if internal index settings should be validated_@see Setting#getSettingsDependencies(String);public final void validate(final Settings settings, final boolean validateDependencies, final boolean validateInternalOrPrivateIndex) {_        validate(settings, validateDependencies, false, false, validateInternalOrPrivateIndex)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,to,validate,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,validate,internal,or,private,index,true,if,internal,index,settings,should,be,validated,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,final,boolean,validate,internal,or,private,index,validate,settings,validate,dependencies,false,false,validate,internal,or,private,index
AbstractScopedSettings -> public final void validate(final Settings settings, final boolean validateDependencies, final boolean validateInternalOrPrivateIndex);1541008027;Validates that all settings are registered and valid.__@param settings                       the settings to validate_@param validateDependencies           true if dependent settings should be validated_@param validateInternalOrPrivateIndex true if internal index settings should be validated_@see Setting#getSettingsDependencies(String);public final void validate(final Settings settings, final boolean validateDependencies, final boolean validateInternalOrPrivateIndex) {_        validate(settings, validateDependencies, false, false, validateInternalOrPrivateIndex)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,to,validate,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,validate,internal,or,private,index,true,if,internal,index,settings,should,be,validated,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,final,boolean,validate,internal,or,private,index,validate,settings,validate,dependencies,false,false,validate,internal,or,private,index
AbstractScopedSettings -> public final void validate(final Settings settings, final boolean validateDependencies, final boolean validateInternalOrPrivateIndex);1541092382;Validates that all settings are registered and valid.__@param settings                       the settings to validate_@param validateDependencies           true if dependent settings should be validated_@param validateInternalOrPrivateIndex true if internal index settings should be validated_@see Setting#getSettingsDependencies(String);public final void validate(final Settings settings, final boolean validateDependencies, final boolean validateInternalOrPrivateIndex) {_        validate(settings, validateDependencies, false, false, validateInternalOrPrivateIndex)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,to,validate,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,validate,internal,or,private,index,true,if,internal,index,settings,should,be,validated,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,final,boolean,validate,internal,or,private,index,validate,settings,validate,dependencies,false,false,validate,internal,or,private,index
AbstractScopedSettings -> public final void validate(final Settings settings, final boolean validateDependencies, final boolean validateInternalOrPrivateIndex);1542402632;Validates that all settings are registered and valid.__@param settings                       the settings to validate_@param validateDependencies           true if dependent settings should be validated_@param validateInternalOrPrivateIndex true if internal index settings should be validated_@see Setting#getSettingsDependencies(String);public final void validate(final Settings settings, final boolean validateDependencies, final boolean validateInternalOrPrivateIndex) {_        validate(settings, validateDependencies, false, false, validateInternalOrPrivateIndex)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,to,validate,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,validate,internal,or,private,index,true,if,internal,index,settings,should,be,validated,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,final,boolean,validate,internal,or,private,index,validate,settings,validate,dependencies,false,false,validate,internal,or,private,index
AbstractScopedSettings -> public final void validate(final Settings settings, final boolean validateDependencies, final boolean validateInternalOrPrivateIndex);1544081506;Validates that all settings are registered and valid.__@param settings                       the settings to validate_@param validateDependencies           true if dependent settings should be validated_@param validateInternalOrPrivateIndex true if internal index settings should be validated_@see Setting#getSettingsDependencies(String);public final void validate(final Settings settings, final boolean validateDependencies, final boolean validateInternalOrPrivateIndex) {_        validate(settings, validateDependencies, false, false, validateInternalOrPrivateIndex)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,to,validate,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,validate,internal,or,private,index,true,if,internal,index,settings,should,be,validated,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,final,boolean,validate,internal,or,private,index,validate,settings,validate,dependencies,false,false,validate,internal,or,private,index
AbstractScopedSettings -> public final void validate(final Settings settings, final boolean validateDependencies, final boolean validateInternalOrPrivateIndex);1544691774;Validates that all settings are registered and valid.__@param settings                       the settings to validate_@param validateDependencies           true if dependent settings should be validated_@param validateInternalOrPrivateIndex true if internal index settings should be validated_@see Setting#getSettingsDependencies(String);public final void validate(final Settings settings, final boolean validateDependencies, final boolean validateInternalOrPrivateIndex) {_        validate(settings, validateDependencies, false, false, validateInternalOrPrivateIndex)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,to,validate,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,validate,internal,or,private,index,true,if,internal,index,settings,should,be,validated,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,final,boolean,validate,internal,or,private,index,validate,settings,validate,dependencies,false,false,validate,internal,or,private,index
AbstractScopedSettings -> public final void validate(final Settings settings, final boolean validateDependencies, final boolean validateInternalOrPrivateIndex);1546877578;Validates that all settings are registered and valid.__@param settings                       the settings to validate_@param validateDependencies           true if dependent settings should be validated_@param validateInternalOrPrivateIndex true if internal index settings should be validated_@see Setting#getSettingsDependencies(String);public final void validate(final Settings settings, final boolean validateDependencies, final boolean validateInternalOrPrivateIndex) {_        validate(settings, validateDependencies, false, false, validateInternalOrPrivateIndex)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,to,validate,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,validate,internal,or,private,index,true,if,internal,index,settings,should,be,validated,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,final,boolean,validate,internal,or,private,index,validate,settings,validate,dependencies,false,false,validate,internal,or,private,index
AbstractScopedSettings -> public final void validate(final Settings settings, final boolean validateDependencies, final boolean validateInternalOrPrivateIndex);1548270339;Validates that all settings are registered and valid.__@param settings                       the settings to validate_@param validateDependencies           true if dependent settings should be validated_@param validateInternalOrPrivateIndex true if internal index settings should be validated_@see Setting#getSettingsDependencies(String);public final void validate(final Settings settings, final boolean validateDependencies, final boolean validateInternalOrPrivateIndex) {_        validate(settings, validateDependencies, false, false, validateInternalOrPrivateIndex)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,to,validate,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,validate,internal,or,private,index,true,if,internal,index,settings,should,be,validated,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,final,boolean,validate,internal,or,private,index,validate,settings,validate,dependencies,false,false,validate,internal,or,private,index
AbstractScopedSettings -> public synchronized <T> void addAffixUpdateConsumer(Setting.AffixSetting<T> setting,  BiConsumer<String, T> consumer,                                                         BiConsumer<String, T> validator);1524684173;Adds a settings consumer for affix settings. Affix settings have a namespace associated to it that needs to be available to the_consumer in order to be processed correctly.;public synchronized <T> void addAffixUpdateConsumer(Setting.AffixSetting<T> setting,  BiConsumer<String, T> consumer,_                                                        BiConsumer<String, T> validator) {_        final Setting<?> registeredSetting = this.complexMatchers.get(setting.getKey())__        if (setting != registeredSetting) {_            throw new IllegalArgumentException("Setting is not registered for key [" + setting.getKey() + "]")__        }_        addSettingsUpdater(setting.newAffixUpdater(consumer, logger, validator))__    };adds,a,settings,consumer,for,affix,settings,affix,settings,have,a,namespace,associated,to,it,that,needs,to,be,available,to,the,consumer,in,order,to,be,processed,correctly;public,synchronized,t,void,add,affix,update,consumer,setting,affix,setting,t,setting,bi,consumer,string,t,consumer,bi,consumer,string,t,validator,final,setting,registered,setting,this,complex,matchers,get,setting,get,key,if,setting,registered,setting,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,setting,get,key,add,settings,updater,setting,new,affix,updater,consumer,logger,validator
AbstractScopedSettings -> public synchronized <T> void addAffixUpdateConsumer(Setting.AffixSetting<T> setting,  BiConsumer<String, T> consumer,                                                         BiConsumer<String, T> validator);1528904315;Adds a settings consumer for affix settings. Affix settings have a namespace associated to it that needs to be available to the_consumer in order to be processed correctly.;public synchronized <T> void addAffixUpdateConsumer(Setting.AffixSetting<T> setting,  BiConsumer<String, T> consumer,_                                                        BiConsumer<String, T> validator) {_        final Setting<?> registeredSetting = this.complexMatchers.get(setting.getKey())__        if (setting != registeredSetting) {_            throw new IllegalArgumentException("Setting is not registered for key [" + setting.getKey() + "]")__        }_        addSettingsUpdater(setting.newAffixUpdater(consumer, logger, validator))__    };adds,a,settings,consumer,for,affix,settings,affix,settings,have,a,namespace,associated,to,it,that,needs,to,be,available,to,the,consumer,in,order,to,be,processed,correctly;public,synchronized,t,void,add,affix,update,consumer,setting,affix,setting,t,setting,bi,consumer,string,t,consumer,bi,consumer,string,t,validator,final,setting,registered,setting,this,complex,matchers,get,setting,get,key,if,setting,registered,setting,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,setting,get,key,add,settings,updater,setting,new,affix,updater,consumer,logger,validator
AbstractScopedSettings -> public synchronized <T> void addAffixUpdateConsumer(Setting.AffixSetting<T> setting,  BiConsumer<String, T> consumer,                                                         BiConsumer<String, T> validator);1531179852;Adds a settings consumer for affix settings. Affix settings have a namespace associated to it that needs to be available to the_consumer in order to be processed correctly.;public synchronized <T> void addAffixUpdateConsumer(Setting.AffixSetting<T> setting,  BiConsumer<String, T> consumer,_                                                        BiConsumer<String, T> validator) {_        final Setting<?> registeredSetting = this.complexMatchers.get(setting.getKey())__        if (setting != registeredSetting) {_            throw new IllegalArgumentException("Setting is not registered for key [" + setting.getKey() + "]")__        }_        addSettingsUpdater(setting.newAffixUpdater(consumer, logger, validator))__    };adds,a,settings,consumer,for,affix,settings,affix,settings,have,a,namespace,associated,to,it,that,needs,to,be,available,to,the,consumer,in,order,to,be,processed,correctly;public,synchronized,t,void,add,affix,update,consumer,setting,affix,setting,t,setting,bi,consumer,string,t,consumer,bi,consumer,string,t,validator,final,setting,registered,setting,this,complex,matchers,get,setting,get,key,if,setting,registered,setting,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,setting,get,key,add,settings,updater,setting,new,affix,updater,consumer,logger,validator
AbstractScopedSettings -> public synchronized <T> void addAffixUpdateConsumer(Setting.AffixSetting<T> setting,  BiConsumer<String, T> consumer,                                                         BiConsumer<String, T> validator);1535046779;Adds a settings consumer for affix settings. Affix settings have a namespace associated to it that needs to be available to the_consumer in order to be processed correctly.;public synchronized <T> void addAffixUpdateConsumer(Setting.AffixSetting<T> setting,  BiConsumer<String, T> consumer,_                                                        BiConsumer<String, T> validator) {_        ensureSettingIsRegistered(setting)__        addSettingsUpdater(setting.newAffixUpdater(consumer, logger, validator))__    };adds,a,settings,consumer,for,affix,settings,affix,settings,have,a,namespace,associated,to,it,that,needs,to,be,available,to,the,consumer,in,order,to,be,processed,correctly;public,synchronized,t,void,add,affix,update,consumer,setting,affix,setting,t,setting,bi,consumer,string,t,consumer,bi,consumer,string,t,validator,ensure,setting,is,registered,setting,add,settings,updater,setting,new,affix,updater,consumer,logger,validator
AbstractScopedSettings -> public synchronized <T> void addAffixUpdateConsumer(Setting.AffixSetting<T> setting,  BiConsumer<String, T> consumer,                                                         BiConsumer<String, T> validator);1536137328;Adds a settings consumer for affix settings. Affix settings have a namespace associated to it that needs to be available to the_consumer in order to be processed correctly.;public synchronized <T> void addAffixUpdateConsumer(Setting.AffixSetting<T> setting,  BiConsumer<String, T> consumer,_                                                        BiConsumer<String, T> validator) {_        ensureSettingIsRegistered(setting)__        addSettingsUpdater(setting.newAffixUpdater(consumer, logger, validator))__    };adds,a,settings,consumer,for,affix,settings,affix,settings,have,a,namespace,associated,to,it,that,needs,to,be,available,to,the,consumer,in,order,to,be,processed,correctly;public,synchronized,t,void,add,affix,update,consumer,setting,affix,setting,t,setting,bi,consumer,string,t,consumer,bi,consumer,string,t,validator,ensure,setting,is,registered,setting,add,settings,updater,setting,new,affix,updater,consumer,logger,validator
AbstractScopedSettings -> public synchronized <T> void addAffixUpdateConsumer(Setting.AffixSetting<T> setting,  BiConsumer<String, T> consumer,                                                         BiConsumer<String, T> validator);1536314350;Adds a settings consumer for affix settings. Affix settings have a namespace associated to it that needs to be available to the_consumer in order to be processed correctly.;public synchronized <T> void addAffixUpdateConsumer(Setting.AffixSetting<T> setting,  BiConsumer<String, T> consumer,_                                                        BiConsumer<String, T> validator) {_        ensureSettingIsRegistered(setting)__        addSettingsUpdater(setting.newAffixUpdater(consumer, logger, validator))__    };adds,a,settings,consumer,for,affix,settings,affix,settings,have,a,namespace,associated,to,it,that,needs,to,be,available,to,the,consumer,in,order,to,be,processed,correctly;public,synchronized,t,void,add,affix,update,consumer,setting,affix,setting,t,setting,bi,consumer,string,t,consumer,bi,consumer,string,t,validator,ensure,setting,is,registered,setting,add,settings,updater,setting,new,affix,updater,consumer,logger,validator
AbstractScopedSettings -> public synchronized <T> void addAffixUpdateConsumer(Setting.AffixSetting<T> setting,  BiConsumer<String, T> consumer,                                                         BiConsumer<String, T> validator);1536611444;Adds a settings consumer for affix settings. Affix settings have a namespace associated to it that needs to be available to the_consumer in order to be processed correctly.;public synchronized <T> void addAffixUpdateConsumer(Setting.AffixSetting<T> setting,  BiConsumer<String, T> consumer,_                                                        BiConsumer<String, T> validator) {_        ensureSettingIsRegistered(setting)__        addSettingsUpdater(setting.newAffixUpdater(consumer, logger, validator))__    };adds,a,settings,consumer,for,affix,settings,affix,settings,have,a,namespace,associated,to,it,that,needs,to,be,available,to,the,consumer,in,order,to,be,processed,correctly;public,synchronized,t,void,add,affix,update,consumer,setting,affix,setting,t,setting,bi,consumer,string,t,consumer,bi,consumer,string,t,validator,ensure,setting,is,registered,setting,add,settings,updater,setting,new,affix,updater,consumer,logger,validator
AbstractScopedSettings -> public synchronized <T> void addAffixUpdateConsumer(Setting.AffixSetting<T> setting,  BiConsumer<String, T> consumer,                                                         BiConsumer<String, T> validator);1536828374;Adds a settings consumer for affix settings. Affix settings have a namespace associated to it that needs to be available to the_consumer in order to be processed correctly.;public synchronized <T> void addAffixUpdateConsumer(Setting.AffixSetting<T> setting,  BiConsumer<String, T> consumer,_                                                        BiConsumer<String, T> validator) {_        ensureSettingIsRegistered(setting)__        addSettingsUpdater(setting.newAffixUpdater(consumer, logger, validator))__    };adds,a,settings,consumer,for,affix,settings,affix,settings,have,a,namespace,associated,to,it,that,needs,to,be,available,to,the,consumer,in,order,to,be,processed,correctly;public,synchronized,t,void,add,affix,update,consumer,setting,affix,setting,t,setting,bi,consumer,string,t,consumer,bi,consumer,string,t,validator,ensure,setting,is,registered,setting,add,settings,updater,setting,new,affix,updater,consumer,logger,validator
AbstractScopedSettings -> public synchronized <T> void addAffixUpdateConsumer(Setting.AffixSetting<T> setting,  BiConsumer<String, T> consumer,                                                         BiConsumer<String, T> validator);1539951844;Adds a settings consumer for affix settings. Affix settings have a namespace associated to it that needs to be available to the_consumer in order to be processed correctly.;public synchronized <T> void addAffixUpdateConsumer(Setting.AffixSetting<T> setting,  BiConsumer<String, T> consumer,_                                                        BiConsumer<String, T> validator) {_        ensureSettingIsRegistered(setting)__        addSettingsUpdater(setting.newAffixUpdater(consumer, logger, validator))__    };adds,a,settings,consumer,for,affix,settings,affix,settings,have,a,namespace,associated,to,it,that,needs,to,be,available,to,the,consumer,in,order,to,be,processed,correctly;public,synchronized,t,void,add,affix,update,consumer,setting,affix,setting,t,setting,bi,consumer,string,t,consumer,bi,consumer,string,t,validator,ensure,setting,is,registered,setting,add,settings,updater,setting,new,affix,updater,consumer,logger,validator
AbstractScopedSettings -> public synchronized <T> void addAffixUpdateConsumer(Setting.AffixSetting<T> setting,  BiConsumer<String, T> consumer,                                                         BiConsumer<String, T> validator);1541008027;Adds a settings consumer for affix settings. Affix settings have a namespace associated to it that needs to be available to the_consumer in order to be processed correctly.;public synchronized <T> void addAffixUpdateConsumer(Setting.AffixSetting<T> setting,  BiConsumer<String, T> consumer,_                                                        BiConsumer<String, T> validator) {_        ensureSettingIsRegistered(setting)__        addSettingsUpdater(setting.newAffixUpdater(consumer, logger, validator))__    };adds,a,settings,consumer,for,affix,settings,affix,settings,have,a,namespace,associated,to,it,that,needs,to,be,available,to,the,consumer,in,order,to,be,processed,correctly;public,synchronized,t,void,add,affix,update,consumer,setting,affix,setting,t,setting,bi,consumer,string,t,consumer,bi,consumer,string,t,validator,ensure,setting,is,registered,setting,add,settings,updater,setting,new,affix,updater,consumer,logger,validator
AbstractScopedSettings -> public synchronized <T> void addAffixUpdateConsumer(Setting.AffixSetting<T> setting,  BiConsumer<String, T> consumer,                                                         BiConsumer<String, T> validator);1541092382;Adds a settings consumer for affix settings. Affix settings have a namespace associated to it that needs to be available to the_consumer in order to be processed correctly.;public synchronized <T> void addAffixUpdateConsumer(Setting.AffixSetting<T> setting,  BiConsumer<String, T> consumer,_                                                        BiConsumer<String, T> validator) {_        ensureSettingIsRegistered(setting)__        addSettingsUpdater(setting.newAffixUpdater(consumer, logger, validator))__    };adds,a,settings,consumer,for,affix,settings,affix,settings,have,a,namespace,associated,to,it,that,needs,to,be,available,to,the,consumer,in,order,to,be,processed,correctly;public,synchronized,t,void,add,affix,update,consumer,setting,affix,setting,t,setting,bi,consumer,string,t,consumer,bi,consumer,string,t,validator,ensure,setting,is,registered,setting,add,settings,updater,setting,new,affix,updater,consumer,logger,validator
AbstractScopedSettings -> public synchronized <T> void addAffixUpdateConsumer(Setting.AffixSetting<T> setting,  BiConsumer<String, T> consumer,                                                         BiConsumer<String, T> validator);1542402632;Adds a settings consumer for affix settings. Affix settings have a namespace associated to it that needs to be available to the_consumer in order to be processed correctly.;public synchronized <T> void addAffixUpdateConsumer(Setting.AffixSetting<T> setting,  BiConsumer<String, T> consumer,_                                                        BiConsumer<String, T> validator) {_        ensureSettingIsRegistered(setting)__        addSettingsUpdater(setting.newAffixUpdater(consumer, logger, validator))__    };adds,a,settings,consumer,for,affix,settings,affix,settings,have,a,namespace,associated,to,it,that,needs,to,be,available,to,the,consumer,in,order,to,be,processed,correctly;public,synchronized,t,void,add,affix,update,consumer,setting,affix,setting,t,setting,bi,consumer,string,t,consumer,bi,consumer,string,t,validator,ensure,setting,is,registered,setting,add,settings,updater,setting,new,affix,updater,consumer,logger,validator
AbstractScopedSettings -> public synchronized <T> void addAffixUpdateConsumer(Setting.AffixSetting<T> setting,  BiConsumer<String, T> consumer,                                                         BiConsumer<String, T> validator);1544081506;Adds a settings consumer for affix settings. Affix settings have a namespace associated to it that needs to be available to the_consumer in order to be processed correctly.;public synchronized <T> void addAffixUpdateConsumer(Setting.AffixSetting<T> setting,  BiConsumer<String, T> consumer,_                                                        BiConsumer<String, T> validator) {_        ensureSettingIsRegistered(setting)__        addSettingsUpdater(setting.newAffixUpdater(consumer, logger, validator))__    };adds,a,settings,consumer,for,affix,settings,affix,settings,have,a,namespace,associated,to,it,that,needs,to,be,available,to,the,consumer,in,order,to,be,processed,correctly;public,synchronized,t,void,add,affix,update,consumer,setting,affix,setting,t,setting,bi,consumer,string,t,consumer,bi,consumer,string,t,validator,ensure,setting,is,registered,setting,add,settings,updater,setting,new,affix,updater,consumer,logger,validator
AbstractScopedSettings -> public synchronized <T> void addAffixUpdateConsumer(Setting.AffixSetting<T> setting,  BiConsumer<String, T> consumer,                                                         BiConsumer<String, T> validator);1544691774;Adds a settings consumer for affix settings. Affix settings have a namespace associated to it that needs to be available to the_consumer in order to be processed correctly.;public synchronized <T> void addAffixUpdateConsumer(Setting.AffixSetting<T> setting,  BiConsumer<String, T> consumer,_                                                        BiConsumer<String, T> validator) {_        ensureSettingIsRegistered(setting)__        addSettingsUpdater(setting.newAffixUpdater(consumer, logger, validator))__    };adds,a,settings,consumer,for,affix,settings,affix,settings,have,a,namespace,associated,to,it,that,needs,to,be,available,to,the,consumer,in,order,to,be,processed,correctly;public,synchronized,t,void,add,affix,update,consumer,setting,affix,setting,t,setting,bi,consumer,string,t,consumer,bi,consumer,string,t,validator,ensure,setting,is,registered,setting,add,settings,updater,setting,new,affix,updater,consumer,logger,validator
AbstractScopedSettings -> public synchronized <T> void addAffixUpdateConsumer(Setting.AffixSetting<T> setting,  BiConsumer<String, T> consumer,                                                         BiConsumer<String, T> validator);1546877578;Adds a settings consumer for affix settings. Affix settings have a namespace associated to it that needs to be available to the_consumer in order to be processed correctly.;public synchronized <T> void addAffixUpdateConsumer(Setting.AffixSetting<T> setting,  BiConsumer<String, T> consumer,_                                                        BiConsumer<String, T> validator) {_        ensureSettingIsRegistered(setting)__        addSettingsUpdater(setting.newAffixUpdater(consumer, logger, validator))__    };adds,a,settings,consumer,for,affix,settings,affix,settings,have,a,namespace,associated,to,it,that,needs,to,be,available,to,the,consumer,in,order,to,be,processed,correctly;public,synchronized,t,void,add,affix,update,consumer,setting,affix,setting,t,setting,bi,consumer,string,t,consumer,bi,consumer,string,t,validator,ensure,setting,is,registered,setting,add,settings,updater,setting,new,affix,updater,consumer,logger,validator
AbstractScopedSettings -> public synchronized <T> void addAffixUpdateConsumer(Setting.AffixSetting<T> setting,  BiConsumer<String, T> consumer,                                                         BiConsumer<String, T> validator);1548270339;Adds a settings consumer for affix settings. Affix settings have a namespace associated to it that needs to be available to the_consumer in order to be processed correctly.;public synchronized <T> void addAffixUpdateConsumer(Setting.AffixSetting<T> setting,  BiConsumer<String, T> consumer,_                                                        BiConsumer<String, T> validator) {_        ensureSettingIsRegistered(setting)__        addSettingsUpdater(setting.newAffixUpdater(consumer, logger, validator))__    };adds,a,settings,consumer,for,affix,settings,affix,settings,have,a,namespace,associated,to,it,that,needs,to,be,available,to,the,consumer,in,order,to,be,processed,correctly;public,synchronized,t,void,add,affix,update,consumer,setting,affix,setting,t,setting,bi,consumer,string,t,consumer,bi,consumer,string,t,validator,ensure,setting,is,registered,setting,add,settings,updater,setting,new,affix,updater,consumer,logger,validator
AbstractScopedSettings -> public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b,                                                               BiConsumer<A, B> consumer, BiConsumer<A, B> validator);1524684173;Adds a settings consumer that accepts the values for two settings. The consumer is only notified if one or both settings change_and if the provided validator succeeded._<p>_Note: Only settings registered in {@link SettingsModule} can be changed dynamically._</p>_This method registers a compound updater that is useful if two settings are depending on each other._The consumer is always provided with both values even if only one of the two changes.;public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b,_                                                              BiConsumer<A, B> consumer, BiConsumer<A, B> validator) {_        if (a != get(a.getKey())) {_            throw new IllegalArgumentException("Setting is not registered for key [" + a.getKey() + "]")__        }_        if (b != get(b.getKey())) {_            throw new IllegalArgumentException("Setting is not registered for key [" + b.getKey() + "]")__        }_        addSettingsUpdater(Setting.compoundUpdater(consumer, validator, a, b, logger))__    };adds,a,settings,consumer,that,accepts,the,values,for,two,settings,the,consumer,is,only,notified,if,one,or,both,settings,change,and,if,the,provided,validator,succeeded,p,note,only,settings,registered,in,link,settings,module,can,be,changed,dynamically,p,this,method,registers,a,compound,updater,that,is,useful,if,two,settings,are,depending,on,each,other,the,consumer,is,always,provided,with,both,values,even,if,only,one,of,the,two,changes;public,synchronized,a,b,void,add,settings,update,consumer,setting,a,a,setting,b,b,bi,consumer,a,b,consumer,bi,consumer,a,b,validator,if,a,get,a,get,key,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,a,get,key,if,b,get,b,get,key,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,b,get,key,add,settings,updater,setting,compound,updater,consumer,validator,a,b,logger
AbstractScopedSettings -> public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b,                                                               BiConsumer<A, B> consumer, BiConsumer<A, B> validator);1528904315;Adds a settings consumer that accepts the values for two settings. The consumer is only notified if one or both settings change_and if the provided validator succeeded._<p>_Note: Only settings registered in {@link SettingsModule} can be changed dynamically._</p>_This method registers a compound updater that is useful if two settings are depending on each other._The consumer is always provided with both values even if only one of the two changes.;public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b,_                                                              BiConsumer<A, B> consumer, BiConsumer<A, B> validator) {_        if (a != get(a.getKey())) {_            throw new IllegalArgumentException("Setting is not registered for key [" + a.getKey() + "]")__        }_        if (b != get(b.getKey())) {_            throw new IllegalArgumentException("Setting is not registered for key [" + b.getKey() + "]")__        }_        addSettingsUpdater(Setting.compoundUpdater(consumer, validator, a, b, logger))__    };adds,a,settings,consumer,that,accepts,the,values,for,two,settings,the,consumer,is,only,notified,if,one,or,both,settings,change,and,if,the,provided,validator,succeeded,p,note,only,settings,registered,in,link,settings,module,can,be,changed,dynamically,p,this,method,registers,a,compound,updater,that,is,useful,if,two,settings,are,depending,on,each,other,the,consumer,is,always,provided,with,both,values,even,if,only,one,of,the,two,changes;public,synchronized,a,b,void,add,settings,update,consumer,setting,a,a,setting,b,b,bi,consumer,a,b,consumer,bi,consumer,a,b,validator,if,a,get,a,get,key,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,a,get,key,if,b,get,b,get,key,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,b,get,key,add,settings,updater,setting,compound,updater,consumer,validator,a,b,logger
AbstractScopedSettings -> public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b,                                                               BiConsumer<A, B> consumer, BiConsumer<A, B> validator);1531179852;Adds a settings consumer that accepts the values for two settings. The consumer is only notified if one or both settings change_and if the provided validator succeeded._<p>_Note: Only settings registered in {@link SettingsModule} can be changed dynamically._</p>_This method registers a compound updater that is useful if two settings are depending on each other._The consumer is always provided with both values even if only one of the two changes.;public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b,_                                                              BiConsumer<A, B> consumer, BiConsumer<A, B> validator) {_        if (a != get(a.getKey())) {_            throw new IllegalArgumentException("Setting is not registered for key [" + a.getKey() + "]")__        }_        if (b != get(b.getKey())) {_            throw new IllegalArgumentException("Setting is not registered for key [" + b.getKey() + "]")__        }_        addSettingsUpdater(Setting.compoundUpdater(consumer, validator, a, b, logger))__    };adds,a,settings,consumer,that,accepts,the,values,for,two,settings,the,consumer,is,only,notified,if,one,or,both,settings,change,and,if,the,provided,validator,succeeded,p,note,only,settings,registered,in,link,settings,module,can,be,changed,dynamically,p,this,method,registers,a,compound,updater,that,is,useful,if,two,settings,are,depending,on,each,other,the,consumer,is,always,provided,with,both,values,even,if,only,one,of,the,two,changes;public,synchronized,a,b,void,add,settings,update,consumer,setting,a,a,setting,b,b,bi,consumer,a,b,consumer,bi,consumer,a,b,validator,if,a,get,a,get,key,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,a,get,key,if,b,get,b,get,key,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,b,get,key,add,settings,updater,setting,compound,updater,consumer,validator,a,b,logger
AbstractScopedSettings -> public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b,                                                               BiConsumer<A, B> consumer, BiConsumer<A, B> validator);1535046779;Adds a settings consumer that accepts the values for two settings. The consumer is only notified if one or both settings change_and if the provided validator succeeded._<p>_Note: Only settings registered in {@link SettingsModule} can be changed dynamically._</p>_This method registers a compound updater that is useful if two settings are depending on each other._The consumer is always provided with both values even if only one of the two changes.;public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b,_                                                              BiConsumer<A, B> consumer, BiConsumer<A, B> validator) {_        if (a != get(a.getKey())) {_            throw new IllegalArgumentException("Setting is not registered for key [" + a.getKey() + "]")__        }_        if (b != get(b.getKey())) {_            throw new IllegalArgumentException("Setting is not registered for key [" + b.getKey() + "]")__        }_        addSettingsUpdater(Setting.compoundUpdater(consumer, validator, a, b, logger))__    };adds,a,settings,consumer,that,accepts,the,values,for,two,settings,the,consumer,is,only,notified,if,one,or,both,settings,change,and,if,the,provided,validator,succeeded,p,note,only,settings,registered,in,link,settings,module,can,be,changed,dynamically,p,this,method,registers,a,compound,updater,that,is,useful,if,two,settings,are,depending,on,each,other,the,consumer,is,always,provided,with,both,values,even,if,only,one,of,the,two,changes;public,synchronized,a,b,void,add,settings,update,consumer,setting,a,a,setting,b,b,bi,consumer,a,b,consumer,bi,consumer,a,b,validator,if,a,get,a,get,key,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,a,get,key,if,b,get,b,get,key,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,b,get,key,add,settings,updater,setting,compound,updater,consumer,validator,a,b,logger
AbstractScopedSettings -> public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b,                                                               BiConsumer<A, B> consumer, BiConsumer<A, B> validator);1536137328;Adds a settings consumer that accepts the values for two settings. The consumer is only notified if one or both settings change_and if the provided validator succeeded._<p>_Note: Only settings registered in {@link SettingsModule} can be changed dynamically._</p>_This method registers a compound updater that is useful if two settings are depending on each other._The consumer is always provided with both values even if only one of the two changes.;public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b,_                                                              BiConsumer<A, B> consumer, BiConsumer<A, B> validator) {_        if (a != get(a.getKey())) {_            throw new IllegalArgumentException("Setting is not registered for key [" + a.getKey() + "]")__        }_        if (b != get(b.getKey())) {_            throw new IllegalArgumentException("Setting is not registered for key [" + b.getKey() + "]")__        }_        addSettingsUpdater(Setting.compoundUpdater(consumer, validator, a, b, logger))__    };adds,a,settings,consumer,that,accepts,the,values,for,two,settings,the,consumer,is,only,notified,if,one,or,both,settings,change,and,if,the,provided,validator,succeeded,p,note,only,settings,registered,in,link,settings,module,can,be,changed,dynamically,p,this,method,registers,a,compound,updater,that,is,useful,if,two,settings,are,depending,on,each,other,the,consumer,is,always,provided,with,both,values,even,if,only,one,of,the,two,changes;public,synchronized,a,b,void,add,settings,update,consumer,setting,a,a,setting,b,b,bi,consumer,a,b,consumer,bi,consumer,a,b,validator,if,a,get,a,get,key,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,a,get,key,if,b,get,b,get,key,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,b,get,key,add,settings,updater,setting,compound,updater,consumer,validator,a,b,logger
AbstractScopedSettings -> public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b,                                                               BiConsumer<A, B> consumer, BiConsumer<A, B> validator);1536314350;Adds a settings consumer that accepts the values for two settings. The consumer is only notified if one or both settings change_and if the provided validator succeeded._<p>_Note: Only settings registered in {@link SettingsModule} can be changed dynamically._</p>_This method registers a compound updater that is useful if two settings are depending on each other._The consumer is always provided with both values even if only one of the two changes.;public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b,_                                                              BiConsumer<A, B> consumer, BiConsumer<A, B> validator) {_        if (a != get(a.getKey())) {_            throw new IllegalArgumentException("Setting is not registered for key [" + a.getKey() + "]")__        }_        if (b != get(b.getKey())) {_            throw new IllegalArgumentException("Setting is not registered for key [" + b.getKey() + "]")__        }_        addSettingsUpdater(Setting.compoundUpdater(consumer, validator, a, b, logger))__    };adds,a,settings,consumer,that,accepts,the,values,for,two,settings,the,consumer,is,only,notified,if,one,or,both,settings,change,and,if,the,provided,validator,succeeded,p,note,only,settings,registered,in,link,settings,module,can,be,changed,dynamically,p,this,method,registers,a,compound,updater,that,is,useful,if,two,settings,are,depending,on,each,other,the,consumer,is,always,provided,with,both,values,even,if,only,one,of,the,two,changes;public,synchronized,a,b,void,add,settings,update,consumer,setting,a,a,setting,b,b,bi,consumer,a,b,consumer,bi,consumer,a,b,validator,if,a,get,a,get,key,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,a,get,key,if,b,get,b,get,key,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,b,get,key,add,settings,updater,setting,compound,updater,consumer,validator,a,b,logger
AbstractScopedSettings -> public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b,                                                               BiConsumer<A, B> consumer, BiConsumer<A, B> validator);1536611444;Adds a settings consumer that accepts the values for two settings. The consumer is only notified if one or both settings change_and if the provided validator succeeded._<p>_Note: Only settings registered in {@link SettingsModule} can be changed dynamically._</p>_This method registers a compound updater that is useful if two settings are depending on each other._The consumer is always provided with both values even if only one of the two changes.;public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b,_                                                              BiConsumer<A, B> consumer, BiConsumer<A, B> validator) {_        if (a != get(a.getKey())) {_            throw new IllegalArgumentException("Setting is not registered for key [" + a.getKey() + "]")__        }_        if (b != get(b.getKey())) {_            throw new IllegalArgumentException("Setting is not registered for key [" + b.getKey() + "]")__        }_        addSettingsUpdater(Setting.compoundUpdater(consumer, validator, a, b, logger))__    };adds,a,settings,consumer,that,accepts,the,values,for,two,settings,the,consumer,is,only,notified,if,one,or,both,settings,change,and,if,the,provided,validator,succeeded,p,note,only,settings,registered,in,link,settings,module,can,be,changed,dynamically,p,this,method,registers,a,compound,updater,that,is,useful,if,two,settings,are,depending,on,each,other,the,consumer,is,always,provided,with,both,values,even,if,only,one,of,the,two,changes;public,synchronized,a,b,void,add,settings,update,consumer,setting,a,a,setting,b,b,bi,consumer,a,b,consumer,bi,consumer,a,b,validator,if,a,get,a,get,key,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,a,get,key,if,b,get,b,get,key,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,b,get,key,add,settings,updater,setting,compound,updater,consumer,validator,a,b,logger
AbstractScopedSettings -> public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b,                                                               BiConsumer<A, B> consumer, BiConsumer<A, B> validator);1536828374;Adds a settings consumer that accepts the values for two settings. The consumer is only notified if one or both settings change_and if the provided validator succeeded._<p>_Note: Only settings registered in {@link SettingsModule} can be changed dynamically._</p>_This method registers a compound updater that is useful if two settings are depending on each other._The consumer is always provided with both values even if only one of the two changes.;public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b,_                                                              BiConsumer<A, B> consumer, BiConsumer<A, B> validator) {_        if (a != get(a.getKey())) {_            throw new IllegalArgumentException("Setting is not registered for key [" + a.getKey() + "]")__        }_        if (b != get(b.getKey())) {_            throw new IllegalArgumentException("Setting is not registered for key [" + b.getKey() + "]")__        }_        addSettingsUpdater(Setting.compoundUpdater(consumer, validator, a, b, logger))__    };adds,a,settings,consumer,that,accepts,the,values,for,two,settings,the,consumer,is,only,notified,if,one,or,both,settings,change,and,if,the,provided,validator,succeeded,p,note,only,settings,registered,in,link,settings,module,can,be,changed,dynamically,p,this,method,registers,a,compound,updater,that,is,useful,if,two,settings,are,depending,on,each,other,the,consumer,is,always,provided,with,both,values,even,if,only,one,of,the,two,changes;public,synchronized,a,b,void,add,settings,update,consumer,setting,a,a,setting,b,b,bi,consumer,a,b,consumer,bi,consumer,a,b,validator,if,a,get,a,get,key,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,a,get,key,if,b,get,b,get,key,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,b,get,key,add,settings,updater,setting,compound,updater,consumer,validator,a,b,logger
AbstractScopedSettings -> public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b,                                                               BiConsumer<A, B> consumer, BiConsumer<A, B> validator);1539951844;Adds a settings consumer that accepts the values for two settings. The consumer is only notified if one or both settings change_and if the provided validator succeeded._<p>_Note: Only settings registered in {@link SettingsModule} can be changed dynamically._</p>_This method registers a compound updater that is useful if two settings are depending on each other._The consumer is always provided with both values even if only one of the two changes.;public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b,_                                                              BiConsumer<A, B> consumer, BiConsumer<A, B> validator) {_        if (a != get(a.getKey())) {_            throw new IllegalArgumentException("Setting is not registered for key [" + a.getKey() + "]")__        }_        if (b != get(b.getKey())) {_            throw new IllegalArgumentException("Setting is not registered for key [" + b.getKey() + "]")__        }_        addSettingsUpdater(Setting.compoundUpdater(consumer, validator, a, b, logger))__    };adds,a,settings,consumer,that,accepts,the,values,for,two,settings,the,consumer,is,only,notified,if,one,or,both,settings,change,and,if,the,provided,validator,succeeded,p,note,only,settings,registered,in,link,settings,module,can,be,changed,dynamically,p,this,method,registers,a,compound,updater,that,is,useful,if,two,settings,are,depending,on,each,other,the,consumer,is,always,provided,with,both,values,even,if,only,one,of,the,two,changes;public,synchronized,a,b,void,add,settings,update,consumer,setting,a,a,setting,b,b,bi,consumer,a,b,consumer,bi,consumer,a,b,validator,if,a,get,a,get,key,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,a,get,key,if,b,get,b,get,key,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,b,get,key,add,settings,updater,setting,compound,updater,consumer,validator,a,b,logger
AbstractScopedSettings -> public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b,                                                               BiConsumer<A, B> consumer, BiConsumer<A, B> validator);1541008027;Adds a settings consumer that accepts the values for two settings. The consumer is only notified if one or both settings change_and if the provided validator succeeded._<p>_Note: Only settings registered in {@link SettingsModule} can be changed dynamically._</p>_This method registers a compound updater that is useful if two settings are depending on each other._The consumer is always provided with both values even if only one of the two changes.;public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b,_                                                              BiConsumer<A, B> consumer, BiConsumer<A, B> validator) {_        if (a != get(a.getKey())) {_            throw new IllegalArgumentException("Setting is not registered for key [" + a.getKey() + "]")__        }_        if (b != get(b.getKey())) {_            throw new IllegalArgumentException("Setting is not registered for key [" + b.getKey() + "]")__        }_        addSettingsUpdater(Setting.compoundUpdater(consumer, validator, a, b, logger))__    };adds,a,settings,consumer,that,accepts,the,values,for,two,settings,the,consumer,is,only,notified,if,one,or,both,settings,change,and,if,the,provided,validator,succeeded,p,note,only,settings,registered,in,link,settings,module,can,be,changed,dynamically,p,this,method,registers,a,compound,updater,that,is,useful,if,two,settings,are,depending,on,each,other,the,consumer,is,always,provided,with,both,values,even,if,only,one,of,the,two,changes;public,synchronized,a,b,void,add,settings,update,consumer,setting,a,a,setting,b,b,bi,consumer,a,b,consumer,bi,consumer,a,b,validator,if,a,get,a,get,key,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,a,get,key,if,b,get,b,get,key,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,b,get,key,add,settings,updater,setting,compound,updater,consumer,validator,a,b,logger
AbstractScopedSettings -> public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b,                                                               BiConsumer<A, B> consumer, BiConsumer<A, B> validator);1541092382;Adds a settings consumer that accepts the values for two settings. The consumer is only notified if one or both settings change_and if the provided validator succeeded._<p>_Note: Only settings registered in {@link SettingsModule} can be changed dynamically._</p>_This method registers a compound updater that is useful if two settings are depending on each other._The consumer is always provided with both values even if only one of the two changes.;public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b,_                                                              BiConsumer<A, B> consumer, BiConsumer<A, B> validator) {_        if (a != get(a.getKey())) {_            throw new IllegalArgumentException("Setting is not registered for key [" + a.getKey() + "]")__        }_        if (b != get(b.getKey())) {_            throw new IllegalArgumentException("Setting is not registered for key [" + b.getKey() + "]")__        }_        addSettingsUpdater(Setting.compoundUpdater(consumer, validator, a, b, logger))__    };adds,a,settings,consumer,that,accepts,the,values,for,two,settings,the,consumer,is,only,notified,if,one,or,both,settings,change,and,if,the,provided,validator,succeeded,p,note,only,settings,registered,in,link,settings,module,can,be,changed,dynamically,p,this,method,registers,a,compound,updater,that,is,useful,if,two,settings,are,depending,on,each,other,the,consumer,is,always,provided,with,both,values,even,if,only,one,of,the,two,changes;public,synchronized,a,b,void,add,settings,update,consumer,setting,a,a,setting,b,b,bi,consumer,a,b,consumer,bi,consumer,a,b,validator,if,a,get,a,get,key,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,a,get,key,if,b,get,b,get,key,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,b,get,key,add,settings,updater,setting,compound,updater,consumer,validator,a,b,logger
AbstractScopedSettings -> public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b,                                                               BiConsumer<A, B> consumer, BiConsumer<A, B> validator);1542402632;Adds a settings consumer that accepts the values for two settings. The consumer is only notified if one or both settings change_and if the provided validator succeeded._<p>_Note: Only settings registered in {@link SettingsModule} can be changed dynamically._</p>_This method registers a compound updater that is useful if two settings are depending on each other._The consumer is always provided with both values even if only one of the two changes.;public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b,_                                                              BiConsumer<A, B> consumer, BiConsumer<A, B> validator) {_        if (a != get(a.getKey())) {_            throw new IllegalArgumentException("Setting is not registered for key [" + a.getKey() + "]")__        }_        if (b != get(b.getKey())) {_            throw new IllegalArgumentException("Setting is not registered for key [" + b.getKey() + "]")__        }_        addSettingsUpdater(Setting.compoundUpdater(consumer, validator, a, b, logger))__    };adds,a,settings,consumer,that,accepts,the,values,for,two,settings,the,consumer,is,only,notified,if,one,or,both,settings,change,and,if,the,provided,validator,succeeded,p,note,only,settings,registered,in,link,settings,module,can,be,changed,dynamically,p,this,method,registers,a,compound,updater,that,is,useful,if,two,settings,are,depending,on,each,other,the,consumer,is,always,provided,with,both,values,even,if,only,one,of,the,two,changes;public,synchronized,a,b,void,add,settings,update,consumer,setting,a,a,setting,b,b,bi,consumer,a,b,consumer,bi,consumer,a,b,validator,if,a,get,a,get,key,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,a,get,key,if,b,get,b,get,key,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,b,get,key,add,settings,updater,setting,compound,updater,consumer,validator,a,b,logger
AbstractScopedSettings -> public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b,                                                               BiConsumer<A, B> consumer, BiConsumer<A, B> validator);1544081506;Adds a settings consumer that accepts the values for two settings. The consumer is only notified if one or both settings change_and if the provided validator succeeded._<p>_Note: Only settings registered in {@link SettingsModule} can be changed dynamically._</p>_This method registers a compound updater that is useful if two settings are depending on each other._The consumer is always provided with both values even if only one of the two changes.;public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b,_                                                              BiConsumer<A, B> consumer, BiConsumer<A, B> validator) {_        if (a != get(a.getKey())) {_            throw new IllegalArgumentException("Setting is not registered for key [" + a.getKey() + "]")__        }_        if (b != get(b.getKey())) {_            throw new IllegalArgumentException("Setting is not registered for key [" + b.getKey() + "]")__        }_        addSettingsUpdater(Setting.compoundUpdater(consumer, validator, a, b, logger))__    };adds,a,settings,consumer,that,accepts,the,values,for,two,settings,the,consumer,is,only,notified,if,one,or,both,settings,change,and,if,the,provided,validator,succeeded,p,note,only,settings,registered,in,link,settings,module,can,be,changed,dynamically,p,this,method,registers,a,compound,updater,that,is,useful,if,two,settings,are,depending,on,each,other,the,consumer,is,always,provided,with,both,values,even,if,only,one,of,the,two,changes;public,synchronized,a,b,void,add,settings,update,consumer,setting,a,a,setting,b,b,bi,consumer,a,b,consumer,bi,consumer,a,b,validator,if,a,get,a,get,key,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,a,get,key,if,b,get,b,get,key,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,b,get,key,add,settings,updater,setting,compound,updater,consumer,validator,a,b,logger
AbstractScopedSettings -> public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b,                                                               BiConsumer<A, B> consumer, BiConsumer<A, B> validator);1544691774;Adds a settings consumer that accepts the values for two settings. The consumer is only notified if one or both settings change_and if the provided validator succeeded._<p>_Note: Only settings registered in {@link SettingsModule} can be changed dynamically._</p>_This method registers a compound updater that is useful if two settings are depending on each other._The consumer is always provided with both values even if only one of the two changes.;public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b,_                                                              BiConsumer<A, B> consumer, BiConsumer<A, B> validator) {_        if (a != get(a.getKey())) {_            throw new IllegalArgumentException("Setting is not registered for key [" + a.getKey() + "]")__        }_        if (b != get(b.getKey())) {_            throw new IllegalArgumentException("Setting is not registered for key [" + b.getKey() + "]")__        }_        addSettingsUpdater(Setting.compoundUpdater(consumer, validator, a, b, logger))__    };adds,a,settings,consumer,that,accepts,the,values,for,two,settings,the,consumer,is,only,notified,if,one,or,both,settings,change,and,if,the,provided,validator,succeeded,p,note,only,settings,registered,in,link,settings,module,can,be,changed,dynamically,p,this,method,registers,a,compound,updater,that,is,useful,if,two,settings,are,depending,on,each,other,the,consumer,is,always,provided,with,both,values,even,if,only,one,of,the,two,changes;public,synchronized,a,b,void,add,settings,update,consumer,setting,a,a,setting,b,b,bi,consumer,a,b,consumer,bi,consumer,a,b,validator,if,a,get,a,get,key,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,a,get,key,if,b,get,b,get,key,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,b,get,key,add,settings,updater,setting,compound,updater,consumer,validator,a,b,logger
AbstractScopedSettings -> public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b,                                                               BiConsumer<A, B> consumer, BiConsumer<A, B> validator);1546877578;Adds a settings consumer that accepts the values for two settings. The consumer is only notified if one or both settings change_and if the provided validator succeeded._<p>_Note: Only settings registered in {@link SettingsModule} can be changed dynamically._</p>_This method registers a compound updater that is useful if two settings are depending on each other._The consumer is always provided with both values even if only one of the two changes.;public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b,_                                                              BiConsumer<A, B> consumer, BiConsumer<A, B> validator) {_        if (a != get(a.getKey())) {_            throw new IllegalArgumentException("Setting is not registered for key [" + a.getKey() + "]")__        }_        if (b != get(b.getKey())) {_            throw new IllegalArgumentException("Setting is not registered for key [" + b.getKey() + "]")__        }_        addSettingsUpdater(Setting.compoundUpdater(consumer, validator, a, b, logger))__    };adds,a,settings,consumer,that,accepts,the,values,for,two,settings,the,consumer,is,only,notified,if,one,or,both,settings,change,and,if,the,provided,validator,succeeded,p,note,only,settings,registered,in,link,settings,module,can,be,changed,dynamically,p,this,method,registers,a,compound,updater,that,is,useful,if,two,settings,are,depending,on,each,other,the,consumer,is,always,provided,with,both,values,even,if,only,one,of,the,two,changes;public,synchronized,a,b,void,add,settings,update,consumer,setting,a,a,setting,b,b,bi,consumer,a,b,consumer,bi,consumer,a,b,validator,if,a,get,a,get,key,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,a,get,key,if,b,get,b,get,key,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,b,get,key,add,settings,updater,setting,compound,updater,consumer,validator,a,b,logger
AbstractScopedSettings -> public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b,                                                               BiConsumer<A, B> consumer, BiConsumer<A, B> validator);1548270339;Adds a settings consumer that accepts the values for two settings. The consumer is only notified if one or both settings change_and if the provided validator succeeded._<p>_Note: Only settings registered in {@link SettingsModule} can be changed dynamically._</p>_This method registers a compound updater that is useful if two settings are depending on each other._The consumer is always provided with both values even if only one of the two changes.;public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b,_                                                              BiConsumer<A, B> consumer, BiConsumer<A, B> validator) {_        if (a != get(a.getKey())) {_            throw new IllegalArgumentException("Setting is not registered for key [" + a.getKey() + "]")__        }_        if (b != get(b.getKey())) {_            throw new IllegalArgumentException("Setting is not registered for key [" + b.getKey() + "]")__        }_        addSettingsUpdater(Setting.compoundUpdater(consumer, validator, a, b, logger))__    };adds,a,settings,consumer,that,accepts,the,values,for,two,settings,the,consumer,is,only,notified,if,one,or,both,settings,change,and,if,the,provided,validator,succeeded,p,note,only,settings,registered,in,link,settings,module,can,be,changed,dynamically,p,this,method,registers,a,compound,updater,that,is,useful,if,two,settings,are,depending,on,each,other,the,consumer,is,always,provided,with,both,values,even,if,only,one,of,the,two,changes;public,synchronized,a,b,void,add,settings,update,consumer,setting,a,a,setting,b,b,bi,consumer,a,b,consumer,bi,consumer,a,b,validator,if,a,get,a,get,key,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,a,get,key,if,b,get,b,get,key,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,b,get,key,add,settings,updater,setting,compound,updater,consumer,validator,a,b,logger
AbstractScopedSettings -> public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer, Consumer<T> validator);1524684173;Adds a settings consumer with a predicate that is only evaluated at update time._<p>_Note: Only settings registered in {@link SettingsModule} can be changed dynamically._</p>_@param validator an additional validator that is only applied to updates of this setting._This is useful to add additional validation to settings at runtime compared to at startup time.;public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer, Consumer<T> validator) {_        if (setting != get(setting.getKey())) {_            throw new IllegalArgumentException("Setting is not registered for key [" + setting.getKey() + "]")__        }_        addSettingsUpdater(setting.newUpdater(consumer, logger, validator))__    };adds,a,settings,consumer,with,a,predicate,that,is,only,evaluated,at,update,time,p,note,only,settings,registered,in,link,settings,module,can,be,changed,dynamically,p,param,validator,an,additional,validator,that,is,only,applied,to,updates,of,this,setting,this,is,useful,to,add,additional,validation,to,settings,at,runtime,compared,to,at,startup,time;public,synchronized,t,void,add,settings,update,consumer,setting,t,setting,consumer,t,consumer,consumer,t,validator,if,setting,get,setting,get,key,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,setting,get,key,add,settings,updater,setting,new,updater,consumer,logger,validator
AbstractScopedSettings -> public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer, Consumer<T> validator);1528904315;Adds a settings consumer with a predicate that is only evaluated at update time._<p>_Note: Only settings registered in {@link SettingsModule} can be changed dynamically._</p>_@param validator an additional validator that is only applied to updates of this setting._This is useful to add additional validation to settings at runtime compared to at startup time.;public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer, Consumer<T> validator) {_        if (setting != get(setting.getKey())) {_            throw new IllegalArgumentException("Setting is not registered for key [" + setting.getKey() + "]")__        }_        addSettingsUpdater(setting.newUpdater(consumer, logger, validator))__    };adds,a,settings,consumer,with,a,predicate,that,is,only,evaluated,at,update,time,p,note,only,settings,registered,in,link,settings,module,can,be,changed,dynamically,p,param,validator,an,additional,validator,that,is,only,applied,to,updates,of,this,setting,this,is,useful,to,add,additional,validation,to,settings,at,runtime,compared,to,at,startup,time;public,synchronized,t,void,add,settings,update,consumer,setting,t,setting,consumer,t,consumer,consumer,t,validator,if,setting,get,setting,get,key,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,setting,get,key,add,settings,updater,setting,new,updater,consumer,logger,validator
AbstractScopedSettings -> public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer, Consumer<T> validator);1531179852;Adds a settings consumer with a predicate that is only evaluated at update time._<p>_Note: Only settings registered in {@link SettingsModule} can be changed dynamically._</p>_@param validator an additional validator that is only applied to updates of this setting._This is useful to add additional validation to settings at runtime compared to at startup time.;public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer, Consumer<T> validator) {_        if (setting != get(setting.getKey())) {_            throw new IllegalArgumentException("Setting is not registered for key [" + setting.getKey() + "]")__        }_        addSettingsUpdater(setting.newUpdater(consumer, logger, validator))__    };adds,a,settings,consumer,with,a,predicate,that,is,only,evaluated,at,update,time,p,note,only,settings,registered,in,link,settings,module,can,be,changed,dynamically,p,param,validator,an,additional,validator,that,is,only,applied,to,updates,of,this,setting,this,is,useful,to,add,additional,validation,to,settings,at,runtime,compared,to,at,startup,time;public,synchronized,t,void,add,settings,update,consumer,setting,t,setting,consumer,t,consumer,consumer,t,validator,if,setting,get,setting,get,key,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,setting,get,key,add,settings,updater,setting,new,updater,consumer,logger,validator
AbstractScopedSettings -> public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer, Consumer<T> validator);1535046779;Adds a settings consumer with a predicate that is only evaluated at update time._<p>_Note: Only settings registered in {@link SettingsModule} can be changed dynamically._</p>_@param validator an additional validator that is only applied to updates of this setting._This is useful to add additional validation to settings at runtime compared to at startup time.;public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer, Consumer<T> validator) {_        if (setting != get(setting.getKey())) {_            throw new IllegalArgumentException("Setting is not registered for key [" + setting.getKey() + "]")__        }_        addSettingsUpdater(setting.newUpdater(consumer, logger, validator))__    };adds,a,settings,consumer,with,a,predicate,that,is,only,evaluated,at,update,time,p,note,only,settings,registered,in,link,settings,module,can,be,changed,dynamically,p,param,validator,an,additional,validator,that,is,only,applied,to,updates,of,this,setting,this,is,useful,to,add,additional,validation,to,settings,at,runtime,compared,to,at,startup,time;public,synchronized,t,void,add,settings,update,consumer,setting,t,setting,consumer,t,consumer,consumer,t,validator,if,setting,get,setting,get,key,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,setting,get,key,add,settings,updater,setting,new,updater,consumer,logger,validator
AbstractScopedSettings -> public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer, Consumer<T> validator);1536137328;Adds a settings consumer with a predicate that is only evaluated at update time._<p>_Note: Only settings registered in {@link SettingsModule} can be changed dynamically._</p>_@param validator an additional validator that is only applied to updates of this setting._This is useful to add additional validation to settings at runtime compared to at startup time.;public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer, Consumer<T> validator) {_        if (setting != get(setting.getKey())) {_            throw new IllegalArgumentException("Setting is not registered for key [" + setting.getKey() + "]")__        }_        addSettingsUpdater(setting.newUpdater(consumer, logger, validator))__    };adds,a,settings,consumer,with,a,predicate,that,is,only,evaluated,at,update,time,p,note,only,settings,registered,in,link,settings,module,can,be,changed,dynamically,p,param,validator,an,additional,validator,that,is,only,applied,to,updates,of,this,setting,this,is,useful,to,add,additional,validation,to,settings,at,runtime,compared,to,at,startup,time;public,synchronized,t,void,add,settings,update,consumer,setting,t,setting,consumer,t,consumer,consumer,t,validator,if,setting,get,setting,get,key,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,setting,get,key,add,settings,updater,setting,new,updater,consumer,logger,validator
AbstractScopedSettings -> public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer, Consumer<T> validator);1536314350;Adds a settings consumer with a predicate that is only evaluated at update time._<p>_Note: Only settings registered in {@link SettingsModule} can be changed dynamically._</p>_@param validator an additional validator that is only applied to updates of this setting._This is useful to add additional validation to settings at runtime compared to at startup time.;public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer, Consumer<T> validator) {_        if (setting != get(setting.getKey())) {_            throw new IllegalArgumentException("Setting is not registered for key [" + setting.getKey() + "]")__        }_        addSettingsUpdater(setting.newUpdater(consumer, logger, validator))__    };adds,a,settings,consumer,with,a,predicate,that,is,only,evaluated,at,update,time,p,note,only,settings,registered,in,link,settings,module,can,be,changed,dynamically,p,param,validator,an,additional,validator,that,is,only,applied,to,updates,of,this,setting,this,is,useful,to,add,additional,validation,to,settings,at,runtime,compared,to,at,startup,time;public,synchronized,t,void,add,settings,update,consumer,setting,t,setting,consumer,t,consumer,consumer,t,validator,if,setting,get,setting,get,key,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,setting,get,key,add,settings,updater,setting,new,updater,consumer,logger,validator
AbstractScopedSettings -> public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer, Consumer<T> validator);1536611444;Adds a settings consumer with a predicate that is only evaluated at update time._<p>_Note: Only settings registered in {@link SettingsModule} can be changed dynamically._</p>_@param validator an additional validator that is only applied to updates of this setting._This is useful to add additional validation to settings at runtime compared to at startup time.;public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer, Consumer<T> validator) {_        if (setting != get(setting.getKey())) {_            throw new IllegalArgumentException("Setting is not registered for key [" + setting.getKey() + "]")__        }_        addSettingsUpdater(setting.newUpdater(consumer, logger, validator))__    };adds,a,settings,consumer,with,a,predicate,that,is,only,evaluated,at,update,time,p,note,only,settings,registered,in,link,settings,module,can,be,changed,dynamically,p,param,validator,an,additional,validator,that,is,only,applied,to,updates,of,this,setting,this,is,useful,to,add,additional,validation,to,settings,at,runtime,compared,to,at,startup,time;public,synchronized,t,void,add,settings,update,consumer,setting,t,setting,consumer,t,consumer,consumer,t,validator,if,setting,get,setting,get,key,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,setting,get,key,add,settings,updater,setting,new,updater,consumer,logger,validator
AbstractScopedSettings -> public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer, Consumer<T> validator);1536828374;Adds a settings consumer with a predicate that is only evaluated at update time._<p>_Note: Only settings registered in {@link SettingsModule} can be changed dynamically._</p>_@param validator an additional validator that is only applied to updates of this setting._This is useful to add additional validation to settings at runtime compared to at startup time.;public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer, Consumer<T> validator) {_        if (setting != get(setting.getKey())) {_            throw new IllegalArgumentException("Setting is not registered for key [" + setting.getKey() + "]")__        }_        addSettingsUpdater(setting.newUpdater(consumer, logger, validator))__    };adds,a,settings,consumer,with,a,predicate,that,is,only,evaluated,at,update,time,p,note,only,settings,registered,in,link,settings,module,can,be,changed,dynamically,p,param,validator,an,additional,validator,that,is,only,applied,to,updates,of,this,setting,this,is,useful,to,add,additional,validation,to,settings,at,runtime,compared,to,at,startup,time;public,synchronized,t,void,add,settings,update,consumer,setting,t,setting,consumer,t,consumer,consumer,t,validator,if,setting,get,setting,get,key,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,setting,get,key,add,settings,updater,setting,new,updater,consumer,logger,validator
AbstractScopedSettings -> public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer, Consumer<T> validator);1539951844;Adds a settings consumer with a predicate that is only evaluated at update time._<p>_Note: Only settings registered in {@link SettingsModule} can be changed dynamically._</p>_@param validator an additional validator that is only applied to updates of this setting._This is useful to add additional validation to settings at runtime compared to at startup time.;public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer, Consumer<T> validator) {_        if (setting != get(setting.getKey())) {_            throw new IllegalArgumentException("Setting is not registered for key [" + setting.getKey() + "]")__        }_        addSettingsUpdater(setting.newUpdater(consumer, logger, validator))__    };adds,a,settings,consumer,with,a,predicate,that,is,only,evaluated,at,update,time,p,note,only,settings,registered,in,link,settings,module,can,be,changed,dynamically,p,param,validator,an,additional,validator,that,is,only,applied,to,updates,of,this,setting,this,is,useful,to,add,additional,validation,to,settings,at,runtime,compared,to,at,startup,time;public,synchronized,t,void,add,settings,update,consumer,setting,t,setting,consumer,t,consumer,consumer,t,validator,if,setting,get,setting,get,key,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,setting,get,key,add,settings,updater,setting,new,updater,consumer,logger,validator
AbstractScopedSettings -> public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer, Consumer<T> validator);1541008027;Adds a settings consumer with a predicate that is only evaluated at update time._<p>_Note: Only settings registered in {@link SettingsModule} can be changed dynamically._</p>_@param validator an additional validator that is only applied to updates of this setting._This is useful to add additional validation to settings at runtime compared to at startup time.;public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer, Consumer<T> validator) {_        if (setting != get(setting.getKey())) {_            throw new IllegalArgumentException("Setting is not registered for key [" + setting.getKey() + "]")__        }_        addSettingsUpdater(setting.newUpdater(consumer, logger, validator))__    };adds,a,settings,consumer,with,a,predicate,that,is,only,evaluated,at,update,time,p,note,only,settings,registered,in,link,settings,module,can,be,changed,dynamically,p,param,validator,an,additional,validator,that,is,only,applied,to,updates,of,this,setting,this,is,useful,to,add,additional,validation,to,settings,at,runtime,compared,to,at,startup,time;public,synchronized,t,void,add,settings,update,consumer,setting,t,setting,consumer,t,consumer,consumer,t,validator,if,setting,get,setting,get,key,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,setting,get,key,add,settings,updater,setting,new,updater,consumer,logger,validator
AbstractScopedSettings -> public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer, Consumer<T> validator);1541092382;Adds a settings consumer with a predicate that is only evaluated at update time._<p>_Note: Only settings registered in {@link SettingsModule} can be changed dynamically._</p>_@param validator an additional validator that is only applied to updates of this setting._This is useful to add additional validation to settings at runtime compared to at startup time.;public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer, Consumer<T> validator) {_        if (setting != get(setting.getKey())) {_            throw new IllegalArgumentException("Setting is not registered for key [" + setting.getKey() + "]")__        }_        addSettingsUpdater(setting.newUpdater(consumer, logger, validator))__    };adds,a,settings,consumer,with,a,predicate,that,is,only,evaluated,at,update,time,p,note,only,settings,registered,in,link,settings,module,can,be,changed,dynamically,p,param,validator,an,additional,validator,that,is,only,applied,to,updates,of,this,setting,this,is,useful,to,add,additional,validation,to,settings,at,runtime,compared,to,at,startup,time;public,synchronized,t,void,add,settings,update,consumer,setting,t,setting,consumer,t,consumer,consumer,t,validator,if,setting,get,setting,get,key,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,setting,get,key,add,settings,updater,setting,new,updater,consumer,logger,validator
AbstractScopedSettings -> public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer, Consumer<T> validator);1542402632;Adds a settings consumer with a predicate that is only evaluated at update time._<p>_Note: Only settings registered in {@link SettingsModule} can be changed dynamically._</p>_@param validator an additional validator that is only applied to updates of this setting._This is useful to add additional validation to settings at runtime compared to at startup time.;public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer, Consumer<T> validator) {_        if (setting != get(setting.getKey())) {_            throw new IllegalArgumentException("Setting is not registered for key [" + setting.getKey() + "]")__        }_        addSettingsUpdater(setting.newUpdater(consumer, logger, validator))__    };adds,a,settings,consumer,with,a,predicate,that,is,only,evaluated,at,update,time,p,note,only,settings,registered,in,link,settings,module,can,be,changed,dynamically,p,param,validator,an,additional,validator,that,is,only,applied,to,updates,of,this,setting,this,is,useful,to,add,additional,validation,to,settings,at,runtime,compared,to,at,startup,time;public,synchronized,t,void,add,settings,update,consumer,setting,t,setting,consumer,t,consumer,consumer,t,validator,if,setting,get,setting,get,key,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,setting,get,key,add,settings,updater,setting,new,updater,consumer,logger,validator
AbstractScopedSettings -> public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer, Consumer<T> validator);1544081506;Adds a settings consumer with a predicate that is only evaluated at update time._<p>_Note: Only settings registered in {@link SettingsModule} can be changed dynamically._</p>_@param validator an additional validator that is only applied to updates of this setting._This is useful to add additional validation to settings at runtime compared to at startup time.;public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer, Consumer<T> validator) {_        if (setting != get(setting.getKey())) {_            throw new IllegalArgumentException("Setting is not registered for key [" + setting.getKey() + "]")__        }_        addSettingsUpdater(setting.newUpdater(consumer, logger, validator))__    };adds,a,settings,consumer,with,a,predicate,that,is,only,evaluated,at,update,time,p,note,only,settings,registered,in,link,settings,module,can,be,changed,dynamically,p,param,validator,an,additional,validator,that,is,only,applied,to,updates,of,this,setting,this,is,useful,to,add,additional,validation,to,settings,at,runtime,compared,to,at,startup,time;public,synchronized,t,void,add,settings,update,consumer,setting,t,setting,consumer,t,consumer,consumer,t,validator,if,setting,get,setting,get,key,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,setting,get,key,add,settings,updater,setting,new,updater,consumer,logger,validator
AbstractScopedSettings -> public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer, Consumer<T> validator);1544691774;Adds a settings consumer with a predicate that is only evaluated at update time._<p>_Note: Only settings registered in {@link SettingsModule} can be changed dynamically._</p>_@param validator an additional validator that is only applied to updates of this setting._This is useful to add additional validation to settings at runtime compared to at startup time.;public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer, Consumer<T> validator) {_        if (setting != get(setting.getKey())) {_            throw new IllegalArgumentException("Setting is not registered for key [" + setting.getKey() + "]")__        }_        addSettingsUpdater(setting.newUpdater(consumer, logger, validator))__    };adds,a,settings,consumer,with,a,predicate,that,is,only,evaluated,at,update,time,p,note,only,settings,registered,in,link,settings,module,can,be,changed,dynamically,p,param,validator,an,additional,validator,that,is,only,applied,to,updates,of,this,setting,this,is,useful,to,add,additional,validation,to,settings,at,runtime,compared,to,at,startup,time;public,synchronized,t,void,add,settings,update,consumer,setting,t,setting,consumer,t,consumer,consumer,t,validator,if,setting,get,setting,get,key,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,setting,get,key,add,settings,updater,setting,new,updater,consumer,logger,validator
AbstractScopedSettings -> public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer, Consumer<T> validator);1546877578;Adds a settings consumer with a predicate that is only evaluated at update time._<p>_Note: Only settings registered in {@link SettingsModule} can be changed dynamically._</p>_@param validator an additional validator that is only applied to updates of this setting._This is useful to add additional validation to settings at runtime compared to at startup time.;public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer, Consumer<T> validator) {_        if (setting != get(setting.getKey())) {_            throw new IllegalArgumentException("Setting is not registered for key [" + setting.getKey() + "]")__        }_        addSettingsUpdater(setting.newUpdater(consumer, logger, validator))__    };adds,a,settings,consumer,with,a,predicate,that,is,only,evaluated,at,update,time,p,note,only,settings,registered,in,link,settings,module,can,be,changed,dynamically,p,param,validator,an,additional,validator,that,is,only,applied,to,updates,of,this,setting,this,is,useful,to,add,additional,validation,to,settings,at,runtime,compared,to,at,startup,time;public,synchronized,t,void,add,settings,update,consumer,setting,t,setting,consumer,t,consumer,consumer,t,validator,if,setting,get,setting,get,key,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,setting,get,key,add,settings,updater,setting,new,updater,consumer,logger,validator
AbstractScopedSettings -> public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer, Consumer<T> validator);1548270339;Adds a settings consumer with a predicate that is only evaluated at update time._<p>_Note: Only settings registered in {@link SettingsModule} can be changed dynamically._</p>_@param validator an additional validator that is only applied to updates of this setting._This is useful to add additional validation to settings at runtime compared to at startup time.;public synchronized <T> void addSettingsUpdateConsumer(Setting<T> setting, Consumer<T> consumer, Consumer<T> validator) {_        if (setting != get(setting.getKey())) {_            throw new IllegalArgumentException("Setting is not registered for key [" + setting.getKey() + "]")__        }_        addSettingsUpdater(setting.newUpdater(consumer, logger, validator))__    };adds,a,settings,consumer,with,a,predicate,that,is,only,evaluated,at,update,time,p,note,only,settings,registered,in,link,settings,module,can,be,changed,dynamically,p,param,validator,an,additional,validator,that,is,only,applied,to,updates,of,this,setting,this,is,useful,to,add,additional,validation,to,settings,at,runtime,compared,to,at,startup,time;public,synchronized,t,void,add,settings,update,consumer,setting,t,setting,consumer,t,consumer,consumer,t,validator,if,setting,get,setting,get,key,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,setting,get,key,add,settings,updater,setting,new,updater,consumer,logger,validator
AbstractScopedSettings -> public synchronized Settings validateUpdate(Settings settings);1524684173;Validates the given settings by running it through all update listeners without applying it. This_method will not change any settings but will fail if any of the settings can't be applied.;public synchronized Settings validateUpdate(Settings settings) {_        final Settings current = Settings.builder().put(this.settings).put(settings).build()__        final Settings previous = Settings.builder().put(this.settings).put(this.lastSettingsApplied).build()__        List<RuntimeException> exceptions = new ArrayList<>()__        for (SettingUpdater<?> settingUpdater : settingUpdaters) {_            try {_                _                _                settingUpdater.getValue(current, previous)__            } catch (RuntimeException ex) {_                exceptions.add(ex)__                logger.debug(() -> new ParameterizedMessage("failed to prepareCommit settings for [{}]", settingUpdater), ex)__            }_        }_        _        ExceptionsHelper.rethrowAndSuppress(exceptions)__        return current__    };validates,the,given,settings,by,running,it,through,all,update,listeners,without,applying,it,this,method,will,not,change,any,settings,but,will,fail,if,any,of,the,settings,can,t,be,applied;public,synchronized,settings,validate,update,settings,settings,final,settings,current,settings,builder,put,this,settings,put,settings,build,final,settings,previous,settings,builder,put,this,settings,put,this,last,settings,applied,build,list,runtime,exception,exceptions,new,array,list,for,setting,updater,setting,updater,setting,updaters,try,setting,updater,get,value,current,previous,catch,runtime,exception,ex,exceptions,add,ex,logger,debug,new,parameterized,message,failed,to,prepare,commit,settings,for,setting,updater,ex,exceptions,helper,rethrow,and,suppress,exceptions,return,current
AbstractScopedSettings -> public synchronized Settings validateUpdate(Settings settings);1528904315;Validates the given settings by running it through all update listeners without applying it. This_method will not change any settings but will fail if any of the settings can't be applied.;public synchronized Settings validateUpdate(Settings settings) {_        final Settings current = Settings.builder().put(this.settings).put(settings).build()__        final Settings previous = Settings.builder().put(this.settings).put(this.lastSettingsApplied).build()__        List<RuntimeException> exceptions = new ArrayList<>()__        for (SettingUpdater<?> settingUpdater : settingUpdaters) {_            try {_                _                _                settingUpdater.getValue(current, previous)__            } catch (RuntimeException ex) {_                exceptions.add(ex)__                logger.debug(() -> new ParameterizedMessage("failed to prepareCommit settings for [{}]", settingUpdater), ex)__            }_        }_        _        ExceptionsHelper.rethrowAndSuppress(exceptions)__        return current__    };validates,the,given,settings,by,running,it,through,all,update,listeners,without,applying,it,this,method,will,not,change,any,settings,but,will,fail,if,any,of,the,settings,can,t,be,applied;public,synchronized,settings,validate,update,settings,settings,final,settings,current,settings,builder,put,this,settings,put,settings,build,final,settings,previous,settings,builder,put,this,settings,put,this,last,settings,applied,build,list,runtime,exception,exceptions,new,array,list,for,setting,updater,setting,updater,setting,updaters,try,setting,updater,get,value,current,previous,catch,runtime,exception,ex,exceptions,add,ex,logger,debug,new,parameterized,message,failed,to,prepare,commit,settings,for,setting,updater,ex,exceptions,helper,rethrow,and,suppress,exceptions,return,current
AbstractScopedSettings -> public synchronized Settings validateUpdate(Settings settings);1531179852;Validates the given settings by running it through all update listeners without applying it. This_method will not change any settings but will fail if any of the settings can't be applied.;public synchronized Settings validateUpdate(Settings settings) {_        final Settings current = Settings.builder().put(this.settings).put(settings).build()__        final Settings previous = Settings.builder().put(this.settings).put(this.lastSettingsApplied).build()__        List<RuntimeException> exceptions = new ArrayList<>()__        for (SettingUpdater<?> settingUpdater : settingUpdaters) {_            try {_                _                _                settingUpdater.getValue(current, previous)__            } catch (RuntimeException ex) {_                exceptions.add(ex)__                logger.debug(() -> new ParameterizedMessage("failed to prepareCommit settings for [{}]", settingUpdater), ex)__            }_        }_        _        ExceptionsHelper.rethrowAndSuppress(exceptions)__        return current__    };validates,the,given,settings,by,running,it,through,all,update,listeners,without,applying,it,this,method,will,not,change,any,settings,but,will,fail,if,any,of,the,settings,can,t,be,applied;public,synchronized,settings,validate,update,settings,settings,final,settings,current,settings,builder,put,this,settings,put,settings,build,final,settings,previous,settings,builder,put,this,settings,put,this,last,settings,applied,build,list,runtime,exception,exceptions,new,array,list,for,setting,updater,setting,updater,setting,updaters,try,setting,updater,get,value,current,previous,catch,runtime,exception,ex,exceptions,add,ex,logger,debug,new,parameterized,message,failed,to,prepare,commit,settings,for,setting,updater,ex,exceptions,helper,rethrow,and,suppress,exceptions,return,current
AbstractScopedSettings -> public synchronized Settings validateUpdate(Settings settings);1535046779;Validates the given settings by running it through all update listeners without applying it. This_method will not change any settings but will fail if any of the settings can't be applied.;public synchronized Settings validateUpdate(Settings settings) {_        final Settings current = Settings.builder().put(this.settings).put(settings).build()__        final Settings previous = Settings.builder().put(this.settings).put(this.lastSettingsApplied).build()__        List<RuntimeException> exceptions = new ArrayList<>()__        for (SettingUpdater<?> settingUpdater : settingUpdaters) {_            try {_                _                _                settingUpdater.getValue(current, previous)__            } catch (RuntimeException ex) {_                exceptions.add(ex)__                logger.debug(() -> new ParameterizedMessage("failed to prepareCommit settings for [{}]", settingUpdater), ex)__            }_        }_        _        ExceptionsHelper.rethrowAndSuppress(exceptions)__        return current__    };validates,the,given,settings,by,running,it,through,all,update,listeners,without,applying,it,this,method,will,not,change,any,settings,but,will,fail,if,any,of,the,settings,can,t,be,applied;public,synchronized,settings,validate,update,settings,settings,final,settings,current,settings,builder,put,this,settings,put,settings,build,final,settings,previous,settings,builder,put,this,settings,put,this,last,settings,applied,build,list,runtime,exception,exceptions,new,array,list,for,setting,updater,setting,updater,setting,updaters,try,setting,updater,get,value,current,previous,catch,runtime,exception,ex,exceptions,add,ex,logger,debug,new,parameterized,message,failed,to,prepare,commit,settings,for,setting,updater,ex,exceptions,helper,rethrow,and,suppress,exceptions,return,current
AbstractScopedSettings -> public synchronized Settings validateUpdate(Settings settings);1536137328;Validates the given settings by running it through all update listeners without applying it. This_method will not change any settings but will fail if any of the settings can't be applied.;public synchronized Settings validateUpdate(Settings settings) {_        final Settings current = Settings.builder().put(this.settings).put(settings).build()__        final Settings previous = Settings.builder().put(this.settings).put(this.lastSettingsApplied).build()__        List<RuntimeException> exceptions = new ArrayList<>()__        for (SettingUpdater<?> settingUpdater : settingUpdaters) {_            try {_                _                _                settingUpdater.getValue(current, previous)__            } catch (RuntimeException ex) {_                exceptions.add(ex)__                logger.debug(() -> new ParameterizedMessage("failed to prepareCommit settings for [{}]", settingUpdater), ex)__            }_        }_        _        ExceptionsHelper.rethrowAndSuppress(exceptions)__        return current__    };validates,the,given,settings,by,running,it,through,all,update,listeners,without,applying,it,this,method,will,not,change,any,settings,but,will,fail,if,any,of,the,settings,can,t,be,applied;public,synchronized,settings,validate,update,settings,settings,final,settings,current,settings,builder,put,this,settings,put,settings,build,final,settings,previous,settings,builder,put,this,settings,put,this,last,settings,applied,build,list,runtime,exception,exceptions,new,array,list,for,setting,updater,setting,updater,setting,updaters,try,setting,updater,get,value,current,previous,catch,runtime,exception,ex,exceptions,add,ex,logger,debug,new,parameterized,message,failed,to,prepare,commit,settings,for,setting,updater,ex,exceptions,helper,rethrow,and,suppress,exceptions,return,current
AbstractScopedSettings -> public synchronized Settings validateUpdate(Settings settings);1536314350;Validates the given settings by running it through all update listeners without applying it. This_method will not change any settings but will fail if any of the settings can't be applied.;public synchronized Settings validateUpdate(Settings settings) {_        final Settings current = Settings.builder().put(this.settings).put(settings).build()__        final Settings previous = Settings.builder().put(this.settings).put(this.lastSettingsApplied).build()__        List<RuntimeException> exceptions = new ArrayList<>()__        for (SettingUpdater<?> settingUpdater : settingUpdaters) {_            try {_                _                _                settingUpdater.getValue(current, previous)__            } catch (RuntimeException ex) {_                exceptions.add(ex)__                logger.debug(() -> new ParameterizedMessage("failed to prepareCommit settings for [{}]", settingUpdater), ex)__            }_        }_        _        ExceptionsHelper.rethrowAndSuppress(exceptions)__        return current__    };validates,the,given,settings,by,running,it,through,all,update,listeners,without,applying,it,this,method,will,not,change,any,settings,but,will,fail,if,any,of,the,settings,can,t,be,applied;public,synchronized,settings,validate,update,settings,settings,final,settings,current,settings,builder,put,this,settings,put,settings,build,final,settings,previous,settings,builder,put,this,settings,put,this,last,settings,applied,build,list,runtime,exception,exceptions,new,array,list,for,setting,updater,setting,updater,setting,updaters,try,setting,updater,get,value,current,previous,catch,runtime,exception,ex,exceptions,add,ex,logger,debug,new,parameterized,message,failed,to,prepare,commit,settings,for,setting,updater,ex,exceptions,helper,rethrow,and,suppress,exceptions,return,current
AbstractScopedSettings -> public synchronized Settings validateUpdate(Settings settings);1536611444;Validates the given settings by running it through all update listeners without applying it. This_method will not change any settings but will fail if any of the settings can't be applied.;public synchronized Settings validateUpdate(Settings settings) {_        final Settings current = Settings.builder().put(this.settings).put(settings).build()__        final Settings previous = Settings.builder().put(this.settings).put(this.lastSettingsApplied).build()__        List<RuntimeException> exceptions = new ArrayList<>()__        for (SettingUpdater<?> settingUpdater : settingUpdaters) {_            try {_                _                _                settingUpdater.getValue(current, previous)__            } catch (RuntimeException ex) {_                exceptions.add(ex)__                logger.debug(() -> new ParameterizedMessage("failed to prepareCommit settings for [{}]", settingUpdater), ex)__            }_        }_        _        ExceptionsHelper.rethrowAndSuppress(exceptions)__        return current__    };validates,the,given,settings,by,running,it,through,all,update,listeners,without,applying,it,this,method,will,not,change,any,settings,but,will,fail,if,any,of,the,settings,can,t,be,applied;public,synchronized,settings,validate,update,settings,settings,final,settings,current,settings,builder,put,this,settings,put,settings,build,final,settings,previous,settings,builder,put,this,settings,put,this,last,settings,applied,build,list,runtime,exception,exceptions,new,array,list,for,setting,updater,setting,updater,setting,updaters,try,setting,updater,get,value,current,previous,catch,runtime,exception,ex,exceptions,add,ex,logger,debug,new,parameterized,message,failed,to,prepare,commit,settings,for,setting,updater,ex,exceptions,helper,rethrow,and,suppress,exceptions,return,current
AbstractScopedSettings -> public synchronized Settings validateUpdate(Settings settings);1536828374;Validates the given settings by running it through all update listeners without applying it. This_method will not change any settings but will fail if any of the settings can't be applied.;public synchronized Settings validateUpdate(Settings settings) {_        final Settings current = Settings.builder().put(this.settings).put(settings).build()__        final Settings previous = Settings.builder().put(this.settings).put(this.lastSettingsApplied).build()__        List<RuntimeException> exceptions = new ArrayList<>()__        for (SettingUpdater<?> settingUpdater : settingUpdaters) {_            try {_                _                _                settingUpdater.getValue(current, previous)__            } catch (RuntimeException ex) {_                exceptions.add(ex)__                logger.debug(() -> new ParameterizedMessage("failed to prepareCommit settings for [{}]", settingUpdater), ex)__            }_        }_        _        ExceptionsHelper.rethrowAndSuppress(exceptions)__        return current__    };validates,the,given,settings,by,running,it,through,all,update,listeners,without,applying,it,this,method,will,not,change,any,settings,but,will,fail,if,any,of,the,settings,can,t,be,applied;public,synchronized,settings,validate,update,settings,settings,final,settings,current,settings,builder,put,this,settings,put,settings,build,final,settings,previous,settings,builder,put,this,settings,put,this,last,settings,applied,build,list,runtime,exception,exceptions,new,array,list,for,setting,updater,setting,updater,setting,updaters,try,setting,updater,get,value,current,previous,catch,runtime,exception,ex,exceptions,add,ex,logger,debug,new,parameterized,message,failed,to,prepare,commit,settings,for,setting,updater,ex,exceptions,helper,rethrow,and,suppress,exceptions,return,current
AbstractScopedSettings -> public synchronized Settings validateUpdate(Settings settings);1539951844;Validates the given settings by running it through all update listeners without applying it. This_method will not change any settings but will fail if any of the settings can't be applied.;public synchronized Settings validateUpdate(Settings settings) {_        final Settings current = Settings.builder().put(this.settings).put(settings).build()__        final Settings previous = Settings.builder().put(this.settings).put(this.lastSettingsApplied).build()__        List<RuntimeException> exceptions = new ArrayList<>()__        for (SettingUpdater<?> settingUpdater : settingUpdaters) {_            try {_                _                _                settingUpdater.getValue(current, previous)__            } catch (RuntimeException ex) {_                exceptions.add(ex)__                logger.debug(() -> new ParameterizedMessage("failed to prepareCommit settings for [{}]", settingUpdater), ex)__            }_        }_        _        ExceptionsHelper.rethrowAndSuppress(exceptions)__        return current__    };validates,the,given,settings,by,running,it,through,all,update,listeners,without,applying,it,this,method,will,not,change,any,settings,but,will,fail,if,any,of,the,settings,can,t,be,applied;public,synchronized,settings,validate,update,settings,settings,final,settings,current,settings,builder,put,this,settings,put,settings,build,final,settings,previous,settings,builder,put,this,settings,put,this,last,settings,applied,build,list,runtime,exception,exceptions,new,array,list,for,setting,updater,setting,updater,setting,updaters,try,setting,updater,get,value,current,previous,catch,runtime,exception,ex,exceptions,add,ex,logger,debug,new,parameterized,message,failed,to,prepare,commit,settings,for,setting,updater,ex,exceptions,helper,rethrow,and,suppress,exceptions,return,current
AbstractScopedSettings -> public synchronized Settings validateUpdate(Settings settings);1541008027;Validates the given settings by running it through all update listeners without applying it. This_method will not change any settings but will fail if any of the settings can't be applied.;public synchronized Settings validateUpdate(Settings settings) {_        final Settings current = Settings.builder().put(this.settings).put(settings).build()__        final Settings previous = Settings.builder().put(this.settings).put(this.lastSettingsApplied).build()__        List<RuntimeException> exceptions = new ArrayList<>()__        for (SettingUpdater<?> settingUpdater : settingUpdaters) {_            try {_                _                _                settingUpdater.getValue(current, previous)__            } catch (RuntimeException ex) {_                exceptions.add(ex)__                logger.debug(() -> new ParameterizedMessage("failed to prepareCommit settings for [{}]", settingUpdater), ex)__            }_        }_        _        ExceptionsHelper.rethrowAndSuppress(exceptions)__        return current__    };validates,the,given,settings,by,running,it,through,all,update,listeners,without,applying,it,this,method,will,not,change,any,settings,but,will,fail,if,any,of,the,settings,can,t,be,applied;public,synchronized,settings,validate,update,settings,settings,final,settings,current,settings,builder,put,this,settings,put,settings,build,final,settings,previous,settings,builder,put,this,settings,put,this,last,settings,applied,build,list,runtime,exception,exceptions,new,array,list,for,setting,updater,setting,updater,setting,updaters,try,setting,updater,get,value,current,previous,catch,runtime,exception,ex,exceptions,add,ex,logger,debug,new,parameterized,message,failed,to,prepare,commit,settings,for,setting,updater,ex,exceptions,helper,rethrow,and,suppress,exceptions,return,current
AbstractScopedSettings -> public synchronized Settings validateUpdate(Settings settings);1541092382;Validates the given settings by running it through all update listeners without applying it. This_method will not change any settings but will fail if any of the settings can't be applied.;public synchronized Settings validateUpdate(Settings settings) {_        final Settings current = Settings.builder().put(this.settings).put(settings).build()__        final Settings previous = Settings.builder().put(this.settings).put(this.lastSettingsApplied).build()__        List<RuntimeException> exceptions = new ArrayList<>()__        for (SettingUpdater<?> settingUpdater : settingUpdaters) {_            try {_                _                _                settingUpdater.getValue(current, previous)__            } catch (RuntimeException ex) {_                exceptions.add(ex)__                logger.debug(() -> new ParameterizedMessage("failed to prepareCommit settings for [{}]", settingUpdater), ex)__            }_        }_        _        ExceptionsHelper.rethrowAndSuppress(exceptions)__        return current__    };validates,the,given,settings,by,running,it,through,all,update,listeners,without,applying,it,this,method,will,not,change,any,settings,but,will,fail,if,any,of,the,settings,can,t,be,applied;public,synchronized,settings,validate,update,settings,settings,final,settings,current,settings,builder,put,this,settings,put,settings,build,final,settings,previous,settings,builder,put,this,settings,put,this,last,settings,applied,build,list,runtime,exception,exceptions,new,array,list,for,setting,updater,setting,updater,setting,updaters,try,setting,updater,get,value,current,previous,catch,runtime,exception,ex,exceptions,add,ex,logger,debug,new,parameterized,message,failed,to,prepare,commit,settings,for,setting,updater,ex,exceptions,helper,rethrow,and,suppress,exceptions,return,current
AbstractScopedSettings -> public synchronized Settings validateUpdate(Settings settings);1542402632;Validates the given settings by running it through all update listeners without applying it. This_method will not change any settings but will fail if any of the settings can't be applied.;public synchronized Settings validateUpdate(Settings settings) {_        final Settings current = Settings.builder().put(this.settings).put(settings).build()__        final Settings previous = Settings.builder().put(this.settings).put(this.lastSettingsApplied).build()__        List<RuntimeException> exceptions = new ArrayList<>()__        for (SettingUpdater<?> settingUpdater : settingUpdaters) {_            try {_                _                _                settingUpdater.getValue(current, previous)__            } catch (RuntimeException ex) {_                exceptions.add(ex)__                logger.debug(() -> new ParameterizedMessage("failed to prepareCommit settings for [{}]", settingUpdater), ex)__            }_        }_        _        ExceptionsHelper.rethrowAndSuppress(exceptions)__        return current__    };validates,the,given,settings,by,running,it,through,all,update,listeners,without,applying,it,this,method,will,not,change,any,settings,but,will,fail,if,any,of,the,settings,can,t,be,applied;public,synchronized,settings,validate,update,settings,settings,final,settings,current,settings,builder,put,this,settings,put,settings,build,final,settings,previous,settings,builder,put,this,settings,put,this,last,settings,applied,build,list,runtime,exception,exceptions,new,array,list,for,setting,updater,setting,updater,setting,updaters,try,setting,updater,get,value,current,previous,catch,runtime,exception,ex,exceptions,add,ex,logger,debug,new,parameterized,message,failed,to,prepare,commit,settings,for,setting,updater,ex,exceptions,helper,rethrow,and,suppress,exceptions,return,current
AbstractScopedSettings -> public synchronized Settings validateUpdate(Settings settings);1544081506;Validates the given settings by running it through all update listeners without applying it. This_method will not change any settings but will fail if any of the settings can't be applied.;public synchronized Settings validateUpdate(Settings settings) {_        final Settings current = Settings.builder().put(this.settings).put(settings).build()__        final Settings previous = Settings.builder().put(this.settings).put(this.lastSettingsApplied).build()__        List<RuntimeException> exceptions = new ArrayList<>()__        for (SettingUpdater<?> settingUpdater : settingUpdaters) {_            try {_                _                _                settingUpdater.getValue(current, previous)__            } catch (RuntimeException ex) {_                exceptions.add(ex)__                logger.debug(() -> new ParameterizedMessage("failed to prepareCommit settings for [{}]", settingUpdater), ex)__            }_        }_        _        ExceptionsHelper.rethrowAndSuppress(exceptions)__        return current__    };validates,the,given,settings,by,running,it,through,all,update,listeners,without,applying,it,this,method,will,not,change,any,settings,but,will,fail,if,any,of,the,settings,can,t,be,applied;public,synchronized,settings,validate,update,settings,settings,final,settings,current,settings,builder,put,this,settings,put,settings,build,final,settings,previous,settings,builder,put,this,settings,put,this,last,settings,applied,build,list,runtime,exception,exceptions,new,array,list,for,setting,updater,setting,updater,setting,updaters,try,setting,updater,get,value,current,previous,catch,runtime,exception,ex,exceptions,add,ex,logger,debug,new,parameterized,message,failed,to,prepare,commit,settings,for,setting,updater,ex,exceptions,helper,rethrow,and,suppress,exceptions,return,current
AbstractScopedSettings -> public synchronized Settings validateUpdate(Settings settings);1544691774;Validates the given settings by running it through all update listeners without applying it. This_method will not change any settings but will fail if any of the settings can't be applied.;public synchronized Settings validateUpdate(Settings settings) {_        final Settings current = Settings.builder().put(this.settings).put(settings).build()__        final Settings previous = Settings.builder().put(this.settings).put(this.lastSettingsApplied).build()__        List<RuntimeException> exceptions = new ArrayList<>()__        for (SettingUpdater<?> settingUpdater : settingUpdaters) {_            try {_                _                _                settingUpdater.getValue(current, previous)__            } catch (RuntimeException ex) {_                exceptions.add(ex)__                logger.debug(() -> new ParameterizedMessage("failed to prepareCommit settings for [{}]", settingUpdater), ex)__            }_        }_        _        ExceptionsHelper.rethrowAndSuppress(exceptions)__        return current__    };validates,the,given,settings,by,running,it,through,all,update,listeners,without,applying,it,this,method,will,not,change,any,settings,but,will,fail,if,any,of,the,settings,can,t,be,applied;public,synchronized,settings,validate,update,settings,settings,final,settings,current,settings,builder,put,this,settings,put,settings,build,final,settings,previous,settings,builder,put,this,settings,put,this,last,settings,applied,build,list,runtime,exception,exceptions,new,array,list,for,setting,updater,setting,updater,setting,updaters,try,setting,updater,get,value,current,previous,catch,runtime,exception,ex,exceptions,add,ex,logger,debug,new,parameterized,message,failed,to,prepare,commit,settings,for,setting,updater,ex,exceptions,helper,rethrow,and,suppress,exceptions,return,current
AbstractScopedSettings -> public synchronized Settings validateUpdate(Settings settings);1546877578;Validates the given settings by running it through all update listeners without applying it. This_method will not change any settings but will fail if any of the settings can't be applied.;public synchronized Settings validateUpdate(Settings settings) {_        final Settings current = Settings.builder().put(this.settings).put(settings).build()__        final Settings previous = Settings.builder().put(this.settings).put(this.lastSettingsApplied).build()__        List<RuntimeException> exceptions = new ArrayList<>()__        for (SettingUpdater<?> settingUpdater : settingUpdaters) {_            try {_                _                _                settingUpdater.getValue(current, previous)__            } catch (RuntimeException ex) {_                exceptions.add(ex)__                logger.debug(() -> new ParameterizedMessage("failed to prepareCommit settings for [{}]", settingUpdater), ex)__            }_        }_        _        ExceptionsHelper.rethrowAndSuppress(exceptions)__        return current__    };validates,the,given,settings,by,running,it,through,all,update,listeners,without,applying,it,this,method,will,not,change,any,settings,but,will,fail,if,any,of,the,settings,can,t,be,applied;public,synchronized,settings,validate,update,settings,settings,final,settings,current,settings,builder,put,this,settings,put,settings,build,final,settings,previous,settings,builder,put,this,settings,put,this,last,settings,applied,build,list,runtime,exception,exceptions,new,array,list,for,setting,updater,setting,updater,setting,updaters,try,setting,updater,get,value,current,previous,catch,runtime,exception,ex,exceptions,add,ex,logger,debug,new,parameterized,message,failed,to,prepare,commit,settings,for,setting,updater,ex,exceptions,helper,rethrow,and,suppress,exceptions,return,current
AbstractScopedSettings -> public synchronized Settings validateUpdate(Settings settings);1548270339;Validates the given settings by running it through all update listeners without applying it. This_method will not change any settings but will fail if any of the settings can't be applied.;public synchronized Settings validateUpdate(Settings settings) {_        final Settings current = Settings.builder().put(this.settings).put(settings).build()__        final Settings previous = Settings.builder().put(this.settings).put(this.lastSettingsApplied).build()__        List<RuntimeException> exceptions = new ArrayList<>()__        for (SettingUpdater<?> settingUpdater : settingUpdaters) {_            try {_                _                _                settingUpdater.getValue(current, previous)__            } catch (RuntimeException ex) {_                exceptions.add(ex)__                logger.debug(() -> new ParameterizedMessage("failed to prepareCommit settings for [{}]", settingUpdater), ex)__            }_        }_        _        ExceptionsHelper.rethrowAndSuppress(exceptions)__        return current__    };validates,the,given,settings,by,running,it,through,all,update,listeners,without,applying,it,this,method,will,not,change,any,settings,but,will,fail,if,any,of,the,settings,can,t,be,applied;public,synchronized,settings,validate,update,settings,settings,final,settings,current,settings,builder,put,this,settings,put,settings,build,final,settings,previous,settings,builder,put,this,settings,put,this,last,settings,applied,build,list,runtime,exception,exceptions,new,array,list,for,setting,updater,setting,updater,setting,updaters,try,setting,updater,get,value,current,previous,catch,runtime,exception,ex,exceptions,add,ex,logger,debug,new,parameterized,message,failed,to,prepare,commit,settings,for,setting,updater,ex,exceptions,helper,rethrow,and,suppress,exceptions,return,current
AbstractScopedSettings -> public boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type);1524684173;Updates a target settings builder with new, updated or deleted settings from a given settings builder.__@param toApply the new settings to apply_@param target the target settings builder that the updates are applied to. All keys that have explicit null value in toApply will be_removed from this builder_@param updates a settings builder that holds all updates applied to target_@param type a free text string to allow better exceptions messages_@return <code>true</code> if the target has changed otherwise <code>false</code>;public boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type) {_        return updateSettings(toApply, target, updates, type, false)__    };updates,a,target,settings,builder,with,new,updated,or,deleted,settings,from,a,given,settings,builder,param,to,apply,the,new,settings,to,apply,param,target,the,target,settings,builder,that,the,updates,are,applied,to,all,keys,that,have,explicit,null,value,in,to,apply,will,be,removed,from,this,builder,param,updates,a,settings,builder,that,holds,all,updates,applied,to,target,param,type,a,free,text,string,to,allow,better,exceptions,messages,return,code,true,code,if,the,target,has,changed,otherwise,code,false,code;public,boolean,update,settings,settings,to,apply,settings,builder,target,settings,builder,updates,string,type,return,update,settings,to,apply,target,updates,type,false
AbstractScopedSettings -> public boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type);1528904315;Updates a target settings builder with new, updated or deleted settings from a given settings builder.__@param toApply the new settings to apply_@param target the target settings builder that the updates are applied to. All keys that have explicit null value in toApply will be_removed from this builder_@param updates a settings builder that holds all updates applied to target_@param type a free text string to allow better exceptions messages_@return <code>true</code> if the target has changed otherwise <code>false</code>;public boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type) {_        return updateSettings(toApply, target, updates, type, false)__    };updates,a,target,settings,builder,with,new,updated,or,deleted,settings,from,a,given,settings,builder,param,to,apply,the,new,settings,to,apply,param,target,the,target,settings,builder,that,the,updates,are,applied,to,all,keys,that,have,explicit,null,value,in,to,apply,will,be,removed,from,this,builder,param,updates,a,settings,builder,that,holds,all,updates,applied,to,target,param,type,a,free,text,string,to,allow,better,exceptions,messages,return,code,true,code,if,the,target,has,changed,otherwise,code,false,code;public,boolean,update,settings,settings,to,apply,settings,builder,target,settings,builder,updates,string,type,return,update,settings,to,apply,target,updates,type,false
AbstractScopedSettings -> public boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type);1531179852;Updates a target settings builder with new, updated or deleted settings from a given settings builder.__@param toApply the new settings to apply_@param target the target settings builder that the updates are applied to. All keys that have explicit null value in toApply will be_removed from this builder_@param updates a settings builder that holds all updates applied to target_@param type a free text string to allow better exceptions messages_@return <code>true</code> if the target has changed otherwise <code>false</code>;public boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type) {_        return updateSettings(toApply, target, updates, type, false)__    };updates,a,target,settings,builder,with,new,updated,or,deleted,settings,from,a,given,settings,builder,param,to,apply,the,new,settings,to,apply,param,target,the,target,settings,builder,that,the,updates,are,applied,to,all,keys,that,have,explicit,null,value,in,to,apply,will,be,removed,from,this,builder,param,updates,a,settings,builder,that,holds,all,updates,applied,to,target,param,type,a,free,text,string,to,allow,better,exceptions,messages,return,code,true,code,if,the,target,has,changed,otherwise,code,false,code;public,boolean,update,settings,settings,to,apply,settings,builder,target,settings,builder,updates,string,type,return,update,settings,to,apply,target,updates,type,false
AbstractScopedSettings -> public boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type);1535046779;Updates a target settings builder with new, updated or deleted settings from a given settings builder.__@param toApply the new settings to apply_@param target the target settings builder that the updates are applied to. All keys that have explicit null value in toApply will be_removed from this builder_@param updates a settings builder that holds all updates applied to target_@param type a free text string to allow better exceptions messages_@return <code>true</code> if the target has changed otherwise <code>false</code>;public boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type) {_        return updateSettings(toApply, target, updates, type, false)__    };updates,a,target,settings,builder,with,new,updated,or,deleted,settings,from,a,given,settings,builder,param,to,apply,the,new,settings,to,apply,param,target,the,target,settings,builder,that,the,updates,are,applied,to,all,keys,that,have,explicit,null,value,in,to,apply,will,be,removed,from,this,builder,param,updates,a,settings,builder,that,holds,all,updates,applied,to,target,param,type,a,free,text,string,to,allow,better,exceptions,messages,return,code,true,code,if,the,target,has,changed,otherwise,code,false,code;public,boolean,update,settings,settings,to,apply,settings,builder,target,settings,builder,updates,string,type,return,update,settings,to,apply,target,updates,type,false
AbstractScopedSettings -> public boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type);1536137328;Updates a target settings builder with new, updated or deleted settings from a given settings builder.__@param toApply the new settings to apply_@param target the target settings builder that the updates are applied to. All keys that have explicit null value in toApply will be_removed from this builder_@param updates a settings builder that holds all updates applied to target_@param type a free text string to allow better exceptions messages_@return <code>true</code> if the target has changed otherwise <code>false</code>;public boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type) {_        return updateSettings(toApply, target, updates, type, false)__    };updates,a,target,settings,builder,with,new,updated,or,deleted,settings,from,a,given,settings,builder,param,to,apply,the,new,settings,to,apply,param,target,the,target,settings,builder,that,the,updates,are,applied,to,all,keys,that,have,explicit,null,value,in,to,apply,will,be,removed,from,this,builder,param,updates,a,settings,builder,that,holds,all,updates,applied,to,target,param,type,a,free,text,string,to,allow,better,exceptions,messages,return,code,true,code,if,the,target,has,changed,otherwise,code,false,code;public,boolean,update,settings,settings,to,apply,settings,builder,target,settings,builder,updates,string,type,return,update,settings,to,apply,target,updates,type,false
AbstractScopedSettings -> public boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type);1536314350;Updates a target settings builder with new, updated or deleted settings from a given settings builder.__@param toApply the new settings to apply_@param target the target settings builder that the updates are applied to. All keys that have explicit null value in toApply will be_removed from this builder_@param updates a settings builder that holds all updates applied to target_@param type a free text string to allow better exceptions messages_@return <code>true</code> if the target has changed otherwise <code>false</code>;public boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type) {_        return updateSettings(toApply, target, updates, type, false)__    };updates,a,target,settings,builder,with,new,updated,or,deleted,settings,from,a,given,settings,builder,param,to,apply,the,new,settings,to,apply,param,target,the,target,settings,builder,that,the,updates,are,applied,to,all,keys,that,have,explicit,null,value,in,to,apply,will,be,removed,from,this,builder,param,updates,a,settings,builder,that,holds,all,updates,applied,to,target,param,type,a,free,text,string,to,allow,better,exceptions,messages,return,code,true,code,if,the,target,has,changed,otherwise,code,false,code;public,boolean,update,settings,settings,to,apply,settings,builder,target,settings,builder,updates,string,type,return,update,settings,to,apply,target,updates,type,false
AbstractScopedSettings -> public boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type);1536611444;Updates a target settings builder with new, updated or deleted settings from a given settings builder.__@param toApply the new settings to apply_@param target the target settings builder that the updates are applied to. All keys that have explicit null value in toApply will be_removed from this builder_@param updates a settings builder that holds all updates applied to target_@param type a free text string to allow better exceptions messages_@return <code>true</code> if the target has changed otherwise <code>false</code>;public boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type) {_        return updateSettings(toApply, target, updates, type, false)__    };updates,a,target,settings,builder,with,new,updated,or,deleted,settings,from,a,given,settings,builder,param,to,apply,the,new,settings,to,apply,param,target,the,target,settings,builder,that,the,updates,are,applied,to,all,keys,that,have,explicit,null,value,in,to,apply,will,be,removed,from,this,builder,param,updates,a,settings,builder,that,holds,all,updates,applied,to,target,param,type,a,free,text,string,to,allow,better,exceptions,messages,return,code,true,code,if,the,target,has,changed,otherwise,code,false,code;public,boolean,update,settings,settings,to,apply,settings,builder,target,settings,builder,updates,string,type,return,update,settings,to,apply,target,updates,type,false
AbstractScopedSettings -> public boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type);1536828374;Updates a target settings builder with new, updated or deleted settings from a given settings builder.__@param toApply the new settings to apply_@param target the target settings builder that the updates are applied to. All keys that have explicit null value in toApply will be_removed from this builder_@param updates a settings builder that holds all updates applied to target_@param type a free text string to allow better exceptions messages_@return <code>true</code> if the target has changed otherwise <code>false</code>;public boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type) {_        return updateSettings(toApply, target, updates, type, false)__    };updates,a,target,settings,builder,with,new,updated,or,deleted,settings,from,a,given,settings,builder,param,to,apply,the,new,settings,to,apply,param,target,the,target,settings,builder,that,the,updates,are,applied,to,all,keys,that,have,explicit,null,value,in,to,apply,will,be,removed,from,this,builder,param,updates,a,settings,builder,that,holds,all,updates,applied,to,target,param,type,a,free,text,string,to,allow,better,exceptions,messages,return,code,true,code,if,the,target,has,changed,otherwise,code,false,code;public,boolean,update,settings,settings,to,apply,settings,builder,target,settings,builder,updates,string,type,return,update,settings,to,apply,target,updates,type,false
AbstractScopedSettings -> public boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type);1539951844;Updates a target settings builder with new, updated or deleted settings from a given settings builder.__@param toApply the new settings to apply_@param target the target settings builder that the updates are applied to. All keys that have explicit null value in toApply will be_removed from this builder_@param updates a settings builder that holds all updates applied to target_@param type a free text string to allow better exceptions messages_@return <code>true</code> if the target has changed otherwise <code>false</code>;public boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type) {_        return updateSettings(toApply, target, updates, type, false)__    };updates,a,target,settings,builder,with,new,updated,or,deleted,settings,from,a,given,settings,builder,param,to,apply,the,new,settings,to,apply,param,target,the,target,settings,builder,that,the,updates,are,applied,to,all,keys,that,have,explicit,null,value,in,to,apply,will,be,removed,from,this,builder,param,updates,a,settings,builder,that,holds,all,updates,applied,to,target,param,type,a,free,text,string,to,allow,better,exceptions,messages,return,code,true,code,if,the,target,has,changed,otherwise,code,false,code;public,boolean,update,settings,settings,to,apply,settings,builder,target,settings,builder,updates,string,type,return,update,settings,to,apply,target,updates,type,false
AbstractScopedSettings -> public boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type);1541008027;Updates a target settings builder with new, updated or deleted settings from a given settings builder.__@param toApply the new settings to apply_@param target the target settings builder that the updates are applied to. All keys that have explicit null value in toApply will be_removed from this builder_@param updates a settings builder that holds all updates applied to target_@param type a free text string to allow better exceptions messages_@return <code>true</code> if the target has changed otherwise <code>false</code>;public boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type) {_        return updateSettings(toApply, target, updates, type, false)__    };updates,a,target,settings,builder,with,new,updated,or,deleted,settings,from,a,given,settings,builder,param,to,apply,the,new,settings,to,apply,param,target,the,target,settings,builder,that,the,updates,are,applied,to,all,keys,that,have,explicit,null,value,in,to,apply,will,be,removed,from,this,builder,param,updates,a,settings,builder,that,holds,all,updates,applied,to,target,param,type,a,free,text,string,to,allow,better,exceptions,messages,return,code,true,code,if,the,target,has,changed,otherwise,code,false,code;public,boolean,update,settings,settings,to,apply,settings,builder,target,settings,builder,updates,string,type,return,update,settings,to,apply,target,updates,type,false
AbstractScopedSettings -> public boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type);1541092382;Updates a target settings builder with new, updated or deleted settings from a given settings builder.__@param toApply the new settings to apply_@param target the target settings builder that the updates are applied to. All keys that have explicit null value in toApply will be_removed from this builder_@param updates a settings builder that holds all updates applied to target_@param type a free text string to allow better exceptions messages_@return <code>true</code> if the target has changed otherwise <code>false</code>;public boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type) {_        return updateSettings(toApply, target, updates, type, false)__    };updates,a,target,settings,builder,with,new,updated,or,deleted,settings,from,a,given,settings,builder,param,to,apply,the,new,settings,to,apply,param,target,the,target,settings,builder,that,the,updates,are,applied,to,all,keys,that,have,explicit,null,value,in,to,apply,will,be,removed,from,this,builder,param,updates,a,settings,builder,that,holds,all,updates,applied,to,target,param,type,a,free,text,string,to,allow,better,exceptions,messages,return,code,true,code,if,the,target,has,changed,otherwise,code,false,code;public,boolean,update,settings,settings,to,apply,settings,builder,target,settings,builder,updates,string,type,return,update,settings,to,apply,target,updates,type,false
AbstractScopedSettings -> public boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type);1542402632;Updates a target settings builder with new, updated or deleted settings from a given settings builder.__@param toApply the new settings to apply_@param target the target settings builder that the updates are applied to. All keys that have explicit null value in toApply will be_removed from this builder_@param updates a settings builder that holds all updates applied to target_@param type a free text string to allow better exceptions messages_@return <code>true</code> if the target has changed otherwise <code>false</code>;public boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type) {_        return updateSettings(toApply, target, updates, type, false)__    };updates,a,target,settings,builder,with,new,updated,or,deleted,settings,from,a,given,settings,builder,param,to,apply,the,new,settings,to,apply,param,target,the,target,settings,builder,that,the,updates,are,applied,to,all,keys,that,have,explicit,null,value,in,to,apply,will,be,removed,from,this,builder,param,updates,a,settings,builder,that,holds,all,updates,applied,to,target,param,type,a,free,text,string,to,allow,better,exceptions,messages,return,code,true,code,if,the,target,has,changed,otherwise,code,false,code;public,boolean,update,settings,settings,to,apply,settings,builder,target,settings,builder,updates,string,type,return,update,settings,to,apply,target,updates,type,false
AbstractScopedSettings -> public boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type);1544081506;Updates a target settings builder with new, updated or deleted settings from a given settings builder.__@param toApply the new settings to apply_@param target the target settings builder that the updates are applied to. All keys that have explicit null value in toApply will be_removed from this builder_@param updates a settings builder that holds all updates applied to target_@param type a free text string to allow better exceptions messages_@return <code>true</code> if the target has changed otherwise <code>false</code>;public boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type) {_        return updateSettings(toApply, target, updates, type, false)__    };updates,a,target,settings,builder,with,new,updated,or,deleted,settings,from,a,given,settings,builder,param,to,apply,the,new,settings,to,apply,param,target,the,target,settings,builder,that,the,updates,are,applied,to,all,keys,that,have,explicit,null,value,in,to,apply,will,be,removed,from,this,builder,param,updates,a,settings,builder,that,holds,all,updates,applied,to,target,param,type,a,free,text,string,to,allow,better,exceptions,messages,return,code,true,code,if,the,target,has,changed,otherwise,code,false,code;public,boolean,update,settings,settings,to,apply,settings,builder,target,settings,builder,updates,string,type,return,update,settings,to,apply,target,updates,type,false
AbstractScopedSettings -> public boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type);1544691774;Updates a target settings builder with new, updated or deleted settings from a given settings builder.__@param toApply the new settings to apply_@param target the target settings builder that the updates are applied to. All keys that have explicit null value in toApply will be_removed from this builder_@param updates a settings builder that holds all updates applied to target_@param type a free text string to allow better exceptions messages_@return <code>true</code> if the target has changed otherwise <code>false</code>;public boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type) {_        return updateSettings(toApply, target, updates, type, false)__    };updates,a,target,settings,builder,with,new,updated,or,deleted,settings,from,a,given,settings,builder,param,to,apply,the,new,settings,to,apply,param,target,the,target,settings,builder,that,the,updates,are,applied,to,all,keys,that,have,explicit,null,value,in,to,apply,will,be,removed,from,this,builder,param,updates,a,settings,builder,that,holds,all,updates,applied,to,target,param,type,a,free,text,string,to,allow,better,exceptions,messages,return,code,true,code,if,the,target,has,changed,otherwise,code,false,code;public,boolean,update,settings,settings,to,apply,settings,builder,target,settings,builder,updates,string,type,return,update,settings,to,apply,target,updates,type,false
AbstractScopedSettings -> public boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type);1546877578;Updates a target settings builder with new, updated or deleted settings from a given settings builder.__@param toApply the new settings to apply_@param target the target settings builder that the updates are applied to. All keys that have explicit null value in toApply will be_removed from this builder_@param updates a settings builder that holds all updates applied to target_@param type a free text string to allow better exceptions messages_@return <code>true</code> if the target has changed otherwise <code>false</code>;public boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type) {_        return updateSettings(toApply, target, updates, type, false)__    };updates,a,target,settings,builder,with,new,updated,or,deleted,settings,from,a,given,settings,builder,param,to,apply,the,new,settings,to,apply,param,target,the,target,settings,builder,that,the,updates,are,applied,to,all,keys,that,have,explicit,null,value,in,to,apply,will,be,removed,from,this,builder,param,updates,a,settings,builder,that,holds,all,updates,applied,to,target,param,type,a,free,text,string,to,allow,better,exceptions,messages,return,code,true,code,if,the,target,has,changed,otherwise,code,false,code;public,boolean,update,settings,settings,to,apply,settings,builder,target,settings,builder,updates,string,type,return,update,settings,to,apply,target,updates,type,false
AbstractScopedSettings -> public boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type);1548270339;Updates a target settings builder with new, updated or deleted settings from a given settings builder.__@param toApply the new settings to apply_@param target the target settings builder that the updates are applied to. All keys that have explicit null value in toApply will be_removed from this builder_@param updates a settings builder that holds all updates applied to target_@param type a free text string to allow better exceptions messages_@return <code>true</code> if the target has changed otherwise <code>false</code>;public boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type) {_        return updateSettings(toApply, target, updates, type, false)__    };updates,a,target,settings,builder,with,new,updated,or,deleted,settings,from,a,given,settings,builder,param,to,apply,the,new,settings,to,apply,param,target,the,target,settings,builder,that,the,updates,are,applied,to,all,keys,that,have,explicit,null,value,in,to,apply,will,be,removed,from,this,builder,param,updates,a,settings,builder,that,holds,all,updates,applied,to,target,param,type,a,free,text,string,to,allow,better,exceptions,messages,return,code,true,code,if,the,target,has,changed,otherwise,code,false,code;public,boolean,update,settings,settings,to,apply,settings,builder,target,settings,builder,updates,string,type,return,update,settings,to,apply,target,updates,type,false
AbstractScopedSettings -> private boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type, boolean onlyDynamic);1524684173;Updates a target settings builder with new, updated or deleted settings from a given settings builder.__@param toApply the new settings to apply_@param target the target settings builder that the updates are applied to. All keys that have explicit null value in toApply will be_removed from this builder_@param updates a settings builder that holds all updates applied to target_@param type a free text string to allow better exceptions messages_@param onlyDynamic if <code>false</code> all settings are updated otherwise only dynamic settings are updated. if set to_<code>true</code> and a non-dynamic setting is updated an exception is thrown._@return <code>true</code> if the target has changed otherwise <code>false</code>;private boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type, boolean onlyDynamic) {_        boolean changed = false__        final Set<String> toRemove = new HashSet<>()__        Settings.Builder settingsBuilder = Settings.builder()__        final Predicate<String> canUpdate = (key) -> (_            isFinalSetting(key) == false && _                ((onlyDynamic == false && get(key) != null) || isDynamicSetting(key)))__        for (String key : toApply.keySet()) {_            boolean isDelete = toApply.hasValue(key) == false__            if (isDelete && (isValidDelete(key, onlyDynamic) || key.endsWith("*"))) {_                _                _                toRemove.add(key)__                _            } else if (get(key) == null) {_                throw new IllegalArgumentException(type + " setting [" + key + "], not recognized")__            } else if (isDelete == false && canUpdate.test(key)) {_                validate(key, toApply, false)_ _                settingsBuilder.copy(key, toApply)__                updates.copy(key, toApply)__                changed = true__            } else {_                if (isFinalSetting(key)) {_                    throw new IllegalArgumentException("final " + type + " setting [" + key + "], not updateable")__                } else {_                    throw new IllegalArgumentException(type + " setting [" + key + "], not dynamically updateable")__                }_            }_        }_        changed |= applyDeletes(toRemove, target, k -> isValidDelete(k, onlyDynamic))__        target.put(settingsBuilder.build())__        return changed__    };updates,a,target,settings,builder,with,new,updated,or,deleted,settings,from,a,given,settings,builder,param,to,apply,the,new,settings,to,apply,param,target,the,target,settings,builder,that,the,updates,are,applied,to,all,keys,that,have,explicit,null,value,in,to,apply,will,be,removed,from,this,builder,param,updates,a,settings,builder,that,holds,all,updates,applied,to,target,param,type,a,free,text,string,to,allow,better,exceptions,messages,param,only,dynamic,if,code,false,code,all,settings,are,updated,otherwise,only,dynamic,settings,are,updated,if,set,to,code,true,code,and,a,non,dynamic,setting,is,updated,an,exception,is,thrown,return,code,true,code,if,the,target,has,changed,otherwise,code,false,code;private,boolean,update,settings,settings,to,apply,settings,builder,target,settings,builder,updates,string,type,boolean,only,dynamic,boolean,changed,false,final,set,string,to,remove,new,hash,set,settings,builder,settings,builder,settings,builder,final,predicate,string,can,update,key,is,final,setting,key,false,only,dynamic,false,get,key,null,is,dynamic,setting,key,for,string,key,to,apply,key,set,boolean,is,delete,to,apply,has,value,key,false,if,is,delete,is,valid,delete,key,only,dynamic,key,ends,with,to,remove,add,key,else,if,get,key,null,throw,new,illegal,argument,exception,type,setting,key,not,recognized,else,if,is,delete,false,can,update,test,key,validate,key,to,apply,false,settings,builder,copy,key,to,apply,updates,copy,key,to,apply,changed,true,else,if,is,final,setting,key,throw,new,illegal,argument,exception,final,type,setting,key,not,updateable,else,throw,new,illegal,argument,exception,type,setting,key,not,dynamically,updateable,changed,apply,deletes,to,remove,target,k,is,valid,delete,k,only,dynamic,target,put,settings,builder,build,return,changed
AbstractScopedSettings -> private boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type, boolean onlyDynamic);1528904315;Updates a target settings builder with new, updated or deleted settings from a given settings builder.__@param toApply the new settings to apply_@param target the target settings builder that the updates are applied to. All keys that have explicit null value in toApply will be_removed from this builder_@param updates a settings builder that holds all updates applied to target_@param type a free text string to allow better exceptions messages_@param onlyDynamic if <code>false</code> all settings are updated otherwise only dynamic settings are updated. if set to_<code>true</code> and a non-dynamic setting is updated an exception is thrown._@return <code>true</code> if the target has changed otherwise <code>false</code>;private boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type, boolean onlyDynamic) {_        boolean changed = false__        final Set<String> toRemove = new HashSet<>()__        Settings.Builder settingsBuilder = Settings.builder()__        final Predicate<String> canUpdate = (key) -> (_            isFinalSetting(key) == false && _                ((onlyDynamic == false && get(key) != null) || isDynamicSetting(key)))__        for (String key : toApply.keySet()) {_            boolean isDelete = toApply.hasValue(key) == false__            if (isDelete && (isValidDelete(key, onlyDynamic) || key.endsWith("*"))) {_                _                _                toRemove.add(key)__                _            } else if (get(key) == null) {_                throw new IllegalArgumentException(type + " setting [" + key + "], not recognized")__            } else if (isDelete == false && canUpdate.test(key)) {_                validate(key, toApply, false)_ _                settingsBuilder.copy(key, toApply)__                updates.copy(key, toApply)__                changed = true__            } else {_                if (isFinalSetting(key)) {_                    throw new IllegalArgumentException("final " + type + " setting [" + key + "], not updateable")__                } else {_                    throw new IllegalArgumentException(type + " setting [" + key + "], not dynamically updateable")__                }_            }_        }_        changed |= applyDeletes(toRemove, target, k -> isValidDelete(k, onlyDynamic))__        target.put(settingsBuilder.build())__        return changed__    };updates,a,target,settings,builder,with,new,updated,or,deleted,settings,from,a,given,settings,builder,param,to,apply,the,new,settings,to,apply,param,target,the,target,settings,builder,that,the,updates,are,applied,to,all,keys,that,have,explicit,null,value,in,to,apply,will,be,removed,from,this,builder,param,updates,a,settings,builder,that,holds,all,updates,applied,to,target,param,type,a,free,text,string,to,allow,better,exceptions,messages,param,only,dynamic,if,code,false,code,all,settings,are,updated,otherwise,only,dynamic,settings,are,updated,if,set,to,code,true,code,and,a,non,dynamic,setting,is,updated,an,exception,is,thrown,return,code,true,code,if,the,target,has,changed,otherwise,code,false,code;private,boolean,update,settings,settings,to,apply,settings,builder,target,settings,builder,updates,string,type,boolean,only,dynamic,boolean,changed,false,final,set,string,to,remove,new,hash,set,settings,builder,settings,builder,settings,builder,final,predicate,string,can,update,key,is,final,setting,key,false,only,dynamic,false,get,key,null,is,dynamic,setting,key,for,string,key,to,apply,key,set,boolean,is,delete,to,apply,has,value,key,false,if,is,delete,is,valid,delete,key,only,dynamic,key,ends,with,to,remove,add,key,else,if,get,key,null,throw,new,illegal,argument,exception,type,setting,key,not,recognized,else,if,is,delete,false,can,update,test,key,validate,key,to,apply,false,settings,builder,copy,key,to,apply,updates,copy,key,to,apply,changed,true,else,if,is,final,setting,key,throw,new,illegal,argument,exception,final,type,setting,key,not,updateable,else,throw,new,illegal,argument,exception,type,setting,key,not,dynamically,updateable,changed,apply,deletes,to,remove,target,k,is,valid,delete,k,only,dynamic,target,put,settings,builder,build,return,changed
AbstractScopedSettings -> private boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type, boolean onlyDynamic);1531179852;Updates a target settings builder with new, updated or deleted settings from a given settings builder.__@param toApply the new settings to apply_@param target the target settings builder that the updates are applied to. All keys that have explicit null value in toApply will be_removed from this builder_@param updates a settings builder that holds all updates applied to target_@param type a free text string to allow better exceptions messages_@param onlyDynamic if <code>false</code> all settings are updated otherwise only dynamic settings are updated. if set to_<code>true</code> and a non-dynamic setting is updated an exception is thrown._@return <code>true</code> if the target has changed otherwise <code>false</code>;private boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type, boolean onlyDynamic) {_        boolean changed = false__        final Set<String> toRemove = new HashSet<>()__        Settings.Builder settingsBuilder = Settings.builder()__        final Predicate<String> canUpdate = (key) -> (_            isFinalSetting(key) == false && _                ((onlyDynamic == false && get(key) != null) || isDynamicSetting(key)))__        for (String key : toApply.keySet()) {_            boolean isDelete = toApply.hasValue(key) == false__            if (isDelete && (isValidDelete(key, onlyDynamic) || key.endsWith("*"))) {_                _                _                toRemove.add(key)__                _            } else if (get(key) == null) {_                throw new IllegalArgumentException(type + " setting [" + key + "], not recognized")__            } else if (isDelete == false && canUpdate.test(key)) {_                validate(key, toApply, false)_ _                settingsBuilder.copy(key, toApply)__                updates.copy(key, toApply)__                changed = true__            } else {_                if (isFinalSetting(key)) {_                    throw new IllegalArgumentException("final " + type + " setting [" + key + "], not updateable")__                } else {_                    throw new IllegalArgumentException(type + " setting [" + key + "], not dynamically updateable")__                }_            }_        }_        changed |= applyDeletes(toRemove, target, k -> isValidDelete(k, onlyDynamic))__        target.put(settingsBuilder.build())__        return changed__    };updates,a,target,settings,builder,with,new,updated,or,deleted,settings,from,a,given,settings,builder,param,to,apply,the,new,settings,to,apply,param,target,the,target,settings,builder,that,the,updates,are,applied,to,all,keys,that,have,explicit,null,value,in,to,apply,will,be,removed,from,this,builder,param,updates,a,settings,builder,that,holds,all,updates,applied,to,target,param,type,a,free,text,string,to,allow,better,exceptions,messages,param,only,dynamic,if,code,false,code,all,settings,are,updated,otherwise,only,dynamic,settings,are,updated,if,set,to,code,true,code,and,a,non,dynamic,setting,is,updated,an,exception,is,thrown,return,code,true,code,if,the,target,has,changed,otherwise,code,false,code;private,boolean,update,settings,settings,to,apply,settings,builder,target,settings,builder,updates,string,type,boolean,only,dynamic,boolean,changed,false,final,set,string,to,remove,new,hash,set,settings,builder,settings,builder,settings,builder,final,predicate,string,can,update,key,is,final,setting,key,false,only,dynamic,false,get,key,null,is,dynamic,setting,key,for,string,key,to,apply,key,set,boolean,is,delete,to,apply,has,value,key,false,if,is,delete,is,valid,delete,key,only,dynamic,key,ends,with,to,remove,add,key,else,if,get,key,null,throw,new,illegal,argument,exception,type,setting,key,not,recognized,else,if,is,delete,false,can,update,test,key,validate,key,to,apply,false,settings,builder,copy,key,to,apply,updates,copy,key,to,apply,changed,true,else,if,is,final,setting,key,throw,new,illegal,argument,exception,final,type,setting,key,not,updateable,else,throw,new,illegal,argument,exception,type,setting,key,not,dynamically,updateable,changed,apply,deletes,to,remove,target,k,is,valid,delete,k,only,dynamic,target,put,settings,builder,build,return,changed
AbstractScopedSettings -> private boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type, boolean onlyDynamic);1535046779;Updates a target settings builder with new, updated or deleted settings from a given settings builder.__@param toApply the new settings to apply_@param target the target settings builder that the updates are applied to. All keys that have explicit null value in toApply will be_removed from this builder_@param updates a settings builder that holds all updates applied to target_@param type a free text string to allow better exceptions messages_@param onlyDynamic if <code>false</code> all settings are updated otherwise only dynamic settings are updated. if set to_<code>true</code> and a non-dynamic setting is updated an exception is thrown._@return <code>true</code> if the target has changed otherwise <code>false</code>;private boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type, boolean onlyDynamic) {_        boolean changed = false__        final Set<String> toRemove = new HashSet<>()__        Settings.Builder settingsBuilder = Settings.builder()__        final Predicate<String> canUpdate = (key) -> (_            isFinalSetting(key) == false && _                ((onlyDynamic == false && get(key) != null) || isDynamicSetting(key)))__        for (String key : toApply.keySet()) {_            boolean isDelete = toApply.hasValue(key) == false__            if (isDelete && (isValidDelete(key, onlyDynamic) || key.endsWith("*"))) {_                _                _                toRemove.add(key)__                _            } else if (get(key) == null) {_                throw new IllegalArgumentException(type + " setting [" + key + "], not recognized")__            } else if (isDelete == false && canUpdate.test(key)) {_                validate(key, toApply, false)_ _                settingsBuilder.copy(key, toApply)__                updates.copy(key, toApply)__                changed = true__            } else {_                if (isFinalSetting(key)) {_                    throw new IllegalArgumentException("final " + type + " setting [" + key + "], not updateable")__                } else {_                    throw new IllegalArgumentException(type + " setting [" + key + "], not dynamically updateable")__                }_            }_        }_        changed |= applyDeletes(toRemove, target, k -> isValidDelete(k, onlyDynamic))__        target.put(settingsBuilder.build())__        return changed__    };updates,a,target,settings,builder,with,new,updated,or,deleted,settings,from,a,given,settings,builder,param,to,apply,the,new,settings,to,apply,param,target,the,target,settings,builder,that,the,updates,are,applied,to,all,keys,that,have,explicit,null,value,in,to,apply,will,be,removed,from,this,builder,param,updates,a,settings,builder,that,holds,all,updates,applied,to,target,param,type,a,free,text,string,to,allow,better,exceptions,messages,param,only,dynamic,if,code,false,code,all,settings,are,updated,otherwise,only,dynamic,settings,are,updated,if,set,to,code,true,code,and,a,non,dynamic,setting,is,updated,an,exception,is,thrown,return,code,true,code,if,the,target,has,changed,otherwise,code,false,code;private,boolean,update,settings,settings,to,apply,settings,builder,target,settings,builder,updates,string,type,boolean,only,dynamic,boolean,changed,false,final,set,string,to,remove,new,hash,set,settings,builder,settings,builder,settings,builder,final,predicate,string,can,update,key,is,final,setting,key,false,only,dynamic,false,get,key,null,is,dynamic,setting,key,for,string,key,to,apply,key,set,boolean,is,delete,to,apply,has,value,key,false,if,is,delete,is,valid,delete,key,only,dynamic,key,ends,with,to,remove,add,key,else,if,get,key,null,throw,new,illegal,argument,exception,type,setting,key,not,recognized,else,if,is,delete,false,can,update,test,key,validate,key,to,apply,false,settings,builder,copy,key,to,apply,updates,copy,key,to,apply,changed,true,else,if,is,final,setting,key,throw,new,illegal,argument,exception,final,type,setting,key,not,updateable,else,throw,new,illegal,argument,exception,type,setting,key,not,dynamically,updateable,changed,apply,deletes,to,remove,target,k,is,valid,delete,k,only,dynamic,target,put,settings,builder,build,return,changed
AbstractScopedSettings -> private boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type, boolean onlyDynamic);1536137328;Updates a target settings builder with new, updated or deleted settings from a given settings builder.__@param toApply the new settings to apply_@param target the target settings builder that the updates are applied to. All keys that have explicit null value in toApply will be_removed from this builder_@param updates a settings builder that holds all updates applied to target_@param type a free text string to allow better exceptions messages_@param onlyDynamic if <code>false</code> all settings are updated otherwise only dynamic settings are updated. if set to_<code>true</code> and a non-dynamic setting is updated an exception is thrown._@return <code>true</code> if the target has changed otherwise <code>false</code>;private boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type, boolean onlyDynamic) {_        boolean changed = false__        final Set<String> toRemove = new HashSet<>()__        Settings.Builder settingsBuilder = Settings.builder()__        final Predicate<String> canUpdate = (key) -> (_            isFinalSetting(key) == false && _                ((onlyDynamic == false && get(key) != null) || isDynamicSetting(key)))__        for (String key : toApply.keySet()) {_            boolean isDelete = toApply.hasValue(key) == false__            if (isDelete && (isValidDelete(key, onlyDynamic) || key.endsWith("*"))) {_                _                _                toRemove.add(key)__                _            } else if (get(key) == null) {_                throw new IllegalArgumentException(type + " setting [" + key + "], not recognized")__            } else if (isDelete == false && canUpdate.test(key)) {_                validate(key, toApply, false)_ _                settingsBuilder.copy(key, toApply)__                updates.copy(key, toApply)__                changed = true__            } else {_                if (isFinalSetting(key)) {_                    throw new IllegalArgumentException("final " + type + " setting [" + key + "], not updateable")__                } else {_                    throw new IllegalArgumentException(type + " setting [" + key + "], not dynamically updateable")__                }_            }_        }_        changed |= applyDeletes(toRemove, target, k -> isValidDelete(k, onlyDynamic))__        target.put(settingsBuilder.build())__        return changed__    };updates,a,target,settings,builder,with,new,updated,or,deleted,settings,from,a,given,settings,builder,param,to,apply,the,new,settings,to,apply,param,target,the,target,settings,builder,that,the,updates,are,applied,to,all,keys,that,have,explicit,null,value,in,to,apply,will,be,removed,from,this,builder,param,updates,a,settings,builder,that,holds,all,updates,applied,to,target,param,type,a,free,text,string,to,allow,better,exceptions,messages,param,only,dynamic,if,code,false,code,all,settings,are,updated,otherwise,only,dynamic,settings,are,updated,if,set,to,code,true,code,and,a,non,dynamic,setting,is,updated,an,exception,is,thrown,return,code,true,code,if,the,target,has,changed,otherwise,code,false,code;private,boolean,update,settings,settings,to,apply,settings,builder,target,settings,builder,updates,string,type,boolean,only,dynamic,boolean,changed,false,final,set,string,to,remove,new,hash,set,settings,builder,settings,builder,settings,builder,final,predicate,string,can,update,key,is,final,setting,key,false,only,dynamic,false,get,key,null,is,dynamic,setting,key,for,string,key,to,apply,key,set,boolean,is,delete,to,apply,has,value,key,false,if,is,delete,is,valid,delete,key,only,dynamic,key,ends,with,to,remove,add,key,else,if,get,key,null,throw,new,illegal,argument,exception,type,setting,key,not,recognized,else,if,is,delete,false,can,update,test,key,validate,key,to,apply,false,settings,builder,copy,key,to,apply,updates,copy,key,to,apply,changed,true,else,if,is,final,setting,key,throw,new,illegal,argument,exception,final,type,setting,key,not,updateable,else,throw,new,illegal,argument,exception,type,setting,key,not,dynamically,updateable,changed,apply,deletes,to,remove,target,k,is,valid,delete,k,only,dynamic,target,put,settings,builder,build,return,changed
AbstractScopedSettings -> private boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type, boolean onlyDynamic);1536314350;Updates a target settings builder with new, updated or deleted settings from a given settings builder.__@param toApply the new settings to apply_@param target the target settings builder that the updates are applied to. All keys that have explicit null value in toApply will be_removed from this builder_@param updates a settings builder that holds all updates applied to target_@param type a free text string to allow better exceptions messages_@param onlyDynamic if <code>false</code> all settings are updated otherwise only dynamic settings are updated. if set to_<code>true</code> and a non-dynamic setting is updated an exception is thrown._@return <code>true</code> if the target has changed otherwise <code>false</code>;private boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type, boolean onlyDynamic) {_        boolean changed = false__        final Set<String> toRemove = new HashSet<>()__        Settings.Builder settingsBuilder = Settings.builder()__        final Predicate<String> canUpdate = (key) -> (_            isFinalSetting(key) == false && _                ((onlyDynamic == false && get(key) != null) || isDynamicSetting(key)))__        for (String key : toApply.keySet()) {_            boolean isDelete = toApply.hasValue(key) == false__            if (isDelete && (isValidDelete(key, onlyDynamic) || key.endsWith("*"))) {_                _                _                toRemove.add(key)__                _            } else if (get(key) == null) {_                throw new IllegalArgumentException(type + " setting [" + key + "], not recognized")__            } else if (isDelete == false && canUpdate.test(key)) {_                validate(key, toApply, false)_ _                settingsBuilder.copy(key, toApply)__                updates.copy(key, toApply)__                changed = true__            } else {_                if (isFinalSetting(key)) {_                    throw new IllegalArgumentException("final " + type + " setting [" + key + "], not updateable")__                } else {_                    throw new IllegalArgumentException(type + " setting [" + key + "], not dynamically updateable")__                }_            }_        }_        changed |= applyDeletes(toRemove, target, k -> isValidDelete(k, onlyDynamic))__        target.put(settingsBuilder.build())__        return changed__    };updates,a,target,settings,builder,with,new,updated,or,deleted,settings,from,a,given,settings,builder,param,to,apply,the,new,settings,to,apply,param,target,the,target,settings,builder,that,the,updates,are,applied,to,all,keys,that,have,explicit,null,value,in,to,apply,will,be,removed,from,this,builder,param,updates,a,settings,builder,that,holds,all,updates,applied,to,target,param,type,a,free,text,string,to,allow,better,exceptions,messages,param,only,dynamic,if,code,false,code,all,settings,are,updated,otherwise,only,dynamic,settings,are,updated,if,set,to,code,true,code,and,a,non,dynamic,setting,is,updated,an,exception,is,thrown,return,code,true,code,if,the,target,has,changed,otherwise,code,false,code;private,boolean,update,settings,settings,to,apply,settings,builder,target,settings,builder,updates,string,type,boolean,only,dynamic,boolean,changed,false,final,set,string,to,remove,new,hash,set,settings,builder,settings,builder,settings,builder,final,predicate,string,can,update,key,is,final,setting,key,false,only,dynamic,false,get,key,null,is,dynamic,setting,key,for,string,key,to,apply,key,set,boolean,is,delete,to,apply,has,value,key,false,if,is,delete,is,valid,delete,key,only,dynamic,key,ends,with,to,remove,add,key,else,if,get,key,null,throw,new,illegal,argument,exception,type,setting,key,not,recognized,else,if,is,delete,false,can,update,test,key,validate,key,to,apply,false,settings,builder,copy,key,to,apply,updates,copy,key,to,apply,changed,true,else,if,is,final,setting,key,throw,new,illegal,argument,exception,final,type,setting,key,not,updateable,else,throw,new,illegal,argument,exception,type,setting,key,not,dynamically,updateable,changed,apply,deletes,to,remove,target,k,is,valid,delete,k,only,dynamic,target,put,settings,builder,build,return,changed
AbstractScopedSettings -> private boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type, boolean onlyDynamic);1536611444;Updates a target settings builder with new, updated or deleted settings from a given settings builder.__@param toApply the new settings to apply_@param target the target settings builder that the updates are applied to. All keys that have explicit null value in toApply will be_removed from this builder_@param updates a settings builder that holds all updates applied to target_@param type a free text string to allow better exceptions messages_@param onlyDynamic if <code>false</code> all settings are updated otherwise only dynamic settings are updated. if set to_<code>true</code> and a non-dynamic setting is updated an exception is thrown._@return <code>true</code> if the target has changed otherwise <code>false</code>;private boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type, boolean onlyDynamic) {_        boolean changed = false__        final Set<String> toRemove = new HashSet<>()__        Settings.Builder settingsBuilder = Settings.builder()__        final Predicate<String> canUpdate = (key) -> (_            isFinalSetting(key) == false && _                ((onlyDynamic == false && get(key) != null) || isDynamicSetting(key)))__        for (String key : toApply.keySet()) {_            boolean isDelete = toApply.hasValue(key) == false__            if (isDelete && (isValidDelete(key, onlyDynamic) || key.endsWith("*"))) {_                _                _                toRemove.add(key)__                _            } else if (get(key) == null) {_                throw new IllegalArgumentException(type + " setting [" + key + "], not recognized")__            } else if (isDelete == false && canUpdate.test(key)) {_                validate(key, toApply, false)_ _                settingsBuilder.copy(key, toApply)__                updates.copy(key, toApply)__                changed = true__            } else {_                if (isFinalSetting(key)) {_                    throw new IllegalArgumentException("final " + type + " setting [" + key + "], not updateable")__                } else {_                    throw new IllegalArgumentException(type + " setting [" + key + "], not dynamically updateable")__                }_            }_        }_        changed |= applyDeletes(toRemove, target, k -> isValidDelete(k, onlyDynamic))__        target.put(settingsBuilder.build())__        return changed__    };updates,a,target,settings,builder,with,new,updated,or,deleted,settings,from,a,given,settings,builder,param,to,apply,the,new,settings,to,apply,param,target,the,target,settings,builder,that,the,updates,are,applied,to,all,keys,that,have,explicit,null,value,in,to,apply,will,be,removed,from,this,builder,param,updates,a,settings,builder,that,holds,all,updates,applied,to,target,param,type,a,free,text,string,to,allow,better,exceptions,messages,param,only,dynamic,if,code,false,code,all,settings,are,updated,otherwise,only,dynamic,settings,are,updated,if,set,to,code,true,code,and,a,non,dynamic,setting,is,updated,an,exception,is,thrown,return,code,true,code,if,the,target,has,changed,otherwise,code,false,code;private,boolean,update,settings,settings,to,apply,settings,builder,target,settings,builder,updates,string,type,boolean,only,dynamic,boolean,changed,false,final,set,string,to,remove,new,hash,set,settings,builder,settings,builder,settings,builder,final,predicate,string,can,update,key,is,final,setting,key,false,only,dynamic,false,get,key,null,is,dynamic,setting,key,for,string,key,to,apply,key,set,boolean,is,delete,to,apply,has,value,key,false,if,is,delete,is,valid,delete,key,only,dynamic,key,ends,with,to,remove,add,key,else,if,get,key,null,throw,new,illegal,argument,exception,type,setting,key,not,recognized,else,if,is,delete,false,can,update,test,key,validate,key,to,apply,false,settings,builder,copy,key,to,apply,updates,copy,key,to,apply,changed,true,else,if,is,final,setting,key,throw,new,illegal,argument,exception,final,type,setting,key,not,updateable,else,throw,new,illegal,argument,exception,type,setting,key,not,dynamically,updateable,changed,apply,deletes,to,remove,target,k,is,valid,delete,k,only,dynamic,target,put,settings,builder,build,return,changed
AbstractScopedSettings -> private boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type, boolean onlyDynamic);1536828374;Updates a target settings builder with new, updated or deleted settings from a given settings builder.__@param toApply the new settings to apply_@param target the target settings builder that the updates are applied to. All keys that have explicit null value in toApply will be_removed from this builder_@param updates a settings builder that holds all updates applied to target_@param type a free text string to allow better exceptions messages_@param onlyDynamic if <code>false</code> all settings are updated otherwise only dynamic settings are updated. if set to_<code>true</code> and a non-dynamic setting is updated an exception is thrown._@return <code>true</code> if the target has changed otherwise <code>false</code>;private boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type, boolean onlyDynamic) {_        boolean changed = false__        final Set<String> toRemove = new HashSet<>()__        Settings.Builder settingsBuilder = Settings.builder()__        final Predicate<String> canUpdate = (key) -> (_            isFinalSetting(key) == false && _                ((onlyDynamic == false && get(key) != null) || isDynamicSetting(key)))__        for (String key : toApply.keySet()) {_            boolean isDelete = toApply.hasValue(key) == false__            if (isDelete && (isValidDelete(key, onlyDynamic) || key.endsWith("*"))) {_                _                _                toRemove.add(key)__                _            } else if (get(key) == null) {_                throw new IllegalArgumentException(type + " setting [" + key + "], not recognized")__            } else if (isDelete == false && canUpdate.test(key)) {_                validate(key, toApply, false)_ _                settingsBuilder.copy(key, toApply)__                updates.copy(key, toApply)__                changed = true__            } else {_                if (isFinalSetting(key)) {_                    throw new IllegalArgumentException("final " + type + " setting [" + key + "], not updateable")__                } else {_                    throw new IllegalArgumentException(type + " setting [" + key + "], not dynamically updateable")__                }_            }_        }_        changed |= applyDeletes(toRemove, target, k -> isValidDelete(k, onlyDynamic))__        target.put(settingsBuilder.build())__        return changed__    };updates,a,target,settings,builder,with,new,updated,or,deleted,settings,from,a,given,settings,builder,param,to,apply,the,new,settings,to,apply,param,target,the,target,settings,builder,that,the,updates,are,applied,to,all,keys,that,have,explicit,null,value,in,to,apply,will,be,removed,from,this,builder,param,updates,a,settings,builder,that,holds,all,updates,applied,to,target,param,type,a,free,text,string,to,allow,better,exceptions,messages,param,only,dynamic,if,code,false,code,all,settings,are,updated,otherwise,only,dynamic,settings,are,updated,if,set,to,code,true,code,and,a,non,dynamic,setting,is,updated,an,exception,is,thrown,return,code,true,code,if,the,target,has,changed,otherwise,code,false,code;private,boolean,update,settings,settings,to,apply,settings,builder,target,settings,builder,updates,string,type,boolean,only,dynamic,boolean,changed,false,final,set,string,to,remove,new,hash,set,settings,builder,settings,builder,settings,builder,final,predicate,string,can,update,key,is,final,setting,key,false,only,dynamic,false,get,key,null,is,dynamic,setting,key,for,string,key,to,apply,key,set,boolean,is,delete,to,apply,has,value,key,false,if,is,delete,is,valid,delete,key,only,dynamic,key,ends,with,to,remove,add,key,else,if,get,key,null,throw,new,illegal,argument,exception,type,setting,key,not,recognized,else,if,is,delete,false,can,update,test,key,validate,key,to,apply,false,settings,builder,copy,key,to,apply,updates,copy,key,to,apply,changed,true,else,if,is,final,setting,key,throw,new,illegal,argument,exception,final,type,setting,key,not,updateable,else,throw,new,illegal,argument,exception,type,setting,key,not,dynamically,updateable,changed,apply,deletes,to,remove,target,k,is,valid,delete,k,only,dynamic,target,put,settings,builder,build,return,changed
AbstractScopedSettings -> private boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type, boolean onlyDynamic);1539951844;Updates a target settings builder with new, updated or deleted settings from a given settings builder.__@param toApply the new settings to apply_@param target the target settings builder that the updates are applied to. All keys that have explicit null value in toApply will be_removed from this builder_@param updates a settings builder that holds all updates applied to target_@param type a free text string to allow better exceptions messages_@param onlyDynamic if <code>false</code> all settings are updated otherwise only dynamic settings are updated. if set to_<code>true</code> and a non-dynamic setting is updated an exception is thrown._@return <code>true</code> if the target has changed otherwise <code>false</code>;private boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type, boolean onlyDynamic) {_        boolean changed = false__        final Set<String> toRemove = new HashSet<>()__        Settings.Builder settingsBuilder = Settings.builder()__        final Predicate<String> canUpdate = (key) -> (_            isFinalSetting(key) == false && _                ((onlyDynamic == false && get(key) != null) || isDynamicSetting(key)))__        for (String key : toApply.keySet()) {_            boolean isDelete = toApply.hasValue(key) == false__            if (isDelete && (isValidDelete(key, onlyDynamic) || key.endsWith("*"))) {_                _                _                toRemove.add(key)__                _            } else if (get(key) == null) {_                throw new IllegalArgumentException(type + " setting [" + key + "], not recognized")__            } else if (isDelete == false && canUpdate.test(key)) {_                validate(key, toApply, false)_ _                settingsBuilder.copy(key, toApply)__                updates.copy(key, toApply)__                changed = true__            } else {_                if (isFinalSetting(key)) {_                    throw new IllegalArgumentException("final " + type + " setting [" + key + "], not updateable")__                } else {_                    throw new IllegalArgumentException(type + " setting [" + key + "], not dynamically updateable")__                }_            }_        }_        changed |= applyDeletes(toRemove, target, k -> isValidDelete(k, onlyDynamic))__        target.put(settingsBuilder.build())__        return changed__    };updates,a,target,settings,builder,with,new,updated,or,deleted,settings,from,a,given,settings,builder,param,to,apply,the,new,settings,to,apply,param,target,the,target,settings,builder,that,the,updates,are,applied,to,all,keys,that,have,explicit,null,value,in,to,apply,will,be,removed,from,this,builder,param,updates,a,settings,builder,that,holds,all,updates,applied,to,target,param,type,a,free,text,string,to,allow,better,exceptions,messages,param,only,dynamic,if,code,false,code,all,settings,are,updated,otherwise,only,dynamic,settings,are,updated,if,set,to,code,true,code,and,a,non,dynamic,setting,is,updated,an,exception,is,thrown,return,code,true,code,if,the,target,has,changed,otherwise,code,false,code;private,boolean,update,settings,settings,to,apply,settings,builder,target,settings,builder,updates,string,type,boolean,only,dynamic,boolean,changed,false,final,set,string,to,remove,new,hash,set,settings,builder,settings,builder,settings,builder,final,predicate,string,can,update,key,is,final,setting,key,false,only,dynamic,false,get,key,null,is,dynamic,setting,key,for,string,key,to,apply,key,set,boolean,is,delete,to,apply,has,value,key,false,if,is,delete,is,valid,delete,key,only,dynamic,key,ends,with,to,remove,add,key,else,if,get,key,null,throw,new,illegal,argument,exception,type,setting,key,not,recognized,else,if,is,delete,false,can,update,test,key,validate,key,to,apply,false,settings,builder,copy,key,to,apply,updates,copy,key,to,apply,changed,true,else,if,is,final,setting,key,throw,new,illegal,argument,exception,final,type,setting,key,not,updateable,else,throw,new,illegal,argument,exception,type,setting,key,not,dynamically,updateable,changed,apply,deletes,to,remove,target,k,is,valid,delete,k,only,dynamic,target,put,settings,builder,build,return,changed
AbstractScopedSettings -> private boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type, boolean onlyDynamic);1541008027;Updates a target settings builder with new, updated or deleted settings from a given settings builder.__@param toApply the new settings to apply_@param target the target settings builder that the updates are applied to. All keys that have explicit null value in toApply will be_removed from this builder_@param updates a settings builder that holds all updates applied to target_@param type a free text string to allow better exceptions messages_@param onlyDynamic if <code>false</code> all settings are updated otherwise only dynamic settings are updated. if set to_<code>true</code> and a non-dynamic setting is updated an exception is thrown._@return <code>true</code> if the target has changed otherwise <code>false</code>;private boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type, boolean onlyDynamic) {_        boolean changed = false__        final Set<String> toRemove = new HashSet<>()__        Settings.Builder settingsBuilder = Settings.builder()__        final Predicate<String> canUpdate = (key) -> (_            isFinalSetting(key) == false && _                ((onlyDynamic == false && get(key) != null) || isDynamicSetting(key)))__        for (String key : toApply.keySet()) {_            boolean isDelete = toApply.hasValue(key) == false__            if (isDelete && (isValidDelete(key, onlyDynamic) || key.endsWith("*"))) {_                _                _                toRemove.add(key)__                _            } else if (get(key) == null) {_                throw new IllegalArgumentException(type + " setting [" + key + "], not recognized")__            } else if (isDelete == false && canUpdate.test(key)) {_                validate(key, toApply, false)_ _                settingsBuilder.copy(key, toApply)__                updates.copy(key, toApply)__                changed = true__            } else {_                if (isFinalSetting(key)) {_                    throw new IllegalArgumentException("final " + type + " setting [" + key + "], not updateable")__                } else {_                    throw new IllegalArgumentException(type + " setting [" + key + "], not dynamically updateable")__                }_            }_        }_        changed |= applyDeletes(toRemove, target, k -> isValidDelete(k, onlyDynamic))__        target.put(settingsBuilder.build())__        return changed__    };updates,a,target,settings,builder,with,new,updated,or,deleted,settings,from,a,given,settings,builder,param,to,apply,the,new,settings,to,apply,param,target,the,target,settings,builder,that,the,updates,are,applied,to,all,keys,that,have,explicit,null,value,in,to,apply,will,be,removed,from,this,builder,param,updates,a,settings,builder,that,holds,all,updates,applied,to,target,param,type,a,free,text,string,to,allow,better,exceptions,messages,param,only,dynamic,if,code,false,code,all,settings,are,updated,otherwise,only,dynamic,settings,are,updated,if,set,to,code,true,code,and,a,non,dynamic,setting,is,updated,an,exception,is,thrown,return,code,true,code,if,the,target,has,changed,otherwise,code,false,code;private,boolean,update,settings,settings,to,apply,settings,builder,target,settings,builder,updates,string,type,boolean,only,dynamic,boolean,changed,false,final,set,string,to,remove,new,hash,set,settings,builder,settings,builder,settings,builder,final,predicate,string,can,update,key,is,final,setting,key,false,only,dynamic,false,get,key,null,is,dynamic,setting,key,for,string,key,to,apply,key,set,boolean,is,delete,to,apply,has,value,key,false,if,is,delete,is,valid,delete,key,only,dynamic,key,ends,with,to,remove,add,key,else,if,get,key,null,throw,new,illegal,argument,exception,type,setting,key,not,recognized,else,if,is,delete,false,can,update,test,key,validate,key,to,apply,false,settings,builder,copy,key,to,apply,updates,copy,key,to,apply,changed,true,else,if,is,final,setting,key,throw,new,illegal,argument,exception,final,type,setting,key,not,updateable,else,throw,new,illegal,argument,exception,type,setting,key,not,dynamically,updateable,changed,apply,deletes,to,remove,target,k,is,valid,delete,k,only,dynamic,target,put,settings,builder,build,return,changed
AbstractScopedSettings -> private boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type, boolean onlyDynamic);1541092382;Updates a target settings builder with new, updated or deleted settings from a given settings builder.__@param toApply the new settings to apply_@param target the target settings builder that the updates are applied to. All keys that have explicit null value in toApply will be_removed from this builder_@param updates a settings builder that holds all updates applied to target_@param type a free text string to allow better exceptions messages_@param onlyDynamic if <code>false</code> all settings are updated otherwise only dynamic settings are updated. if set to_<code>true</code> and a non-dynamic setting is updated an exception is thrown._@return <code>true</code> if the target has changed otherwise <code>false</code>;private boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type, boolean onlyDynamic) {_        boolean changed = false__        final Set<String> toRemove = new HashSet<>()__        Settings.Builder settingsBuilder = Settings.builder()__        final Predicate<String> canUpdate = (key) -> (_            isFinalSetting(key) == false && _                ((onlyDynamic == false && get(key) != null) || isDynamicSetting(key)))__        for (String key : toApply.keySet()) {_            boolean isDelete = toApply.hasValue(key) == false__            if (isDelete && (isValidDelete(key, onlyDynamic) || key.endsWith("*"))) {_                _                _                toRemove.add(key)__                _            } else if (get(key) == null) {_                throw new IllegalArgumentException(type + " setting [" + key + "], not recognized")__            } else if (isDelete == false && canUpdate.test(key)) {_                validate(key, toApply, false)_ _                settingsBuilder.copy(key, toApply)__                updates.copy(key, toApply)__                changed = true__            } else {_                if (isFinalSetting(key)) {_                    throw new IllegalArgumentException("final " + type + " setting [" + key + "], not updateable")__                } else {_                    throw new IllegalArgumentException(type + " setting [" + key + "], not dynamically updateable")__                }_            }_        }_        changed |= applyDeletes(toRemove, target, k -> isValidDelete(k, onlyDynamic))__        target.put(settingsBuilder.build())__        return changed__    };updates,a,target,settings,builder,with,new,updated,or,deleted,settings,from,a,given,settings,builder,param,to,apply,the,new,settings,to,apply,param,target,the,target,settings,builder,that,the,updates,are,applied,to,all,keys,that,have,explicit,null,value,in,to,apply,will,be,removed,from,this,builder,param,updates,a,settings,builder,that,holds,all,updates,applied,to,target,param,type,a,free,text,string,to,allow,better,exceptions,messages,param,only,dynamic,if,code,false,code,all,settings,are,updated,otherwise,only,dynamic,settings,are,updated,if,set,to,code,true,code,and,a,non,dynamic,setting,is,updated,an,exception,is,thrown,return,code,true,code,if,the,target,has,changed,otherwise,code,false,code;private,boolean,update,settings,settings,to,apply,settings,builder,target,settings,builder,updates,string,type,boolean,only,dynamic,boolean,changed,false,final,set,string,to,remove,new,hash,set,settings,builder,settings,builder,settings,builder,final,predicate,string,can,update,key,is,final,setting,key,false,only,dynamic,false,get,key,null,is,dynamic,setting,key,for,string,key,to,apply,key,set,boolean,is,delete,to,apply,has,value,key,false,if,is,delete,is,valid,delete,key,only,dynamic,key,ends,with,to,remove,add,key,else,if,get,key,null,throw,new,illegal,argument,exception,type,setting,key,not,recognized,else,if,is,delete,false,can,update,test,key,validate,key,to,apply,false,settings,builder,copy,key,to,apply,updates,copy,key,to,apply,changed,true,else,if,is,final,setting,key,throw,new,illegal,argument,exception,final,type,setting,key,not,updateable,else,throw,new,illegal,argument,exception,type,setting,key,not,dynamically,updateable,changed,apply,deletes,to,remove,target,k,is,valid,delete,k,only,dynamic,target,put,settings,builder,build,return,changed
AbstractScopedSettings -> private boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type, boolean onlyDynamic);1542402632;Updates a target settings builder with new, updated or deleted settings from a given settings builder.__@param toApply the new settings to apply_@param target the target settings builder that the updates are applied to. All keys that have explicit null value in toApply will be_removed from this builder_@param updates a settings builder that holds all updates applied to target_@param type a free text string to allow better exceptions messages_@param onlyDynamic if <code>false</code> all settings are updated otherwise only dynamic settings are updated. if set to_<code>true</code> and a non-dynamic setting is updated an exception is thrown._@return <code>true</code> if the target has changed otherwise <code>false</code>;private boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type, boolean onlyDynamic) {_        boolean changed = false__        final Set<String> toRemove = new HashSet<>()__        Settings.Builder settingsBuilder = Settings.builder()__        final Predicate<String> canUpdate = (key) -> (_            isFinalSetting(key) == false && _                ((onlyDynamic == false && get(key) != null) || isDynamicSetting(key)))__        for (String key : toApply.keySet()) {_            boolean isDelete = toApply.hasValue(key) == false__            if (isDelete && (isValidDelete(key, onlyDynamic) || key.endsWith("*"))) {_                _                _                toRemove.add(key)__                _            } else if (get(key) == null) {_                throw new IllegalArgumentException(type + " setting [" + key + "], not recognized")__            } else if (isDelete == false && canUpdate.test(key)) {_                validate(key, toApply, false)_ _                settingsBuilder.copy(key, toApply)__                updates.copy(key, toApply)__                changed = true__            } else {_                if (isFinalSetting(key)) {_                    throw new IllegalArgumentException("final " + type + " setting [" + key + "], not updateable")__                } else {_                    throw new IllegalArgumentException(type + " setting [" + key + "], not dynamically updateable")__                }_            }_        }_        changed |= applyDeletes(toRemove, target, k -> isValidDelete(k, onlyDynamic))__        target.put(settingsBuilder.build())__        return changed__    };updates,a,target,settings,builder,with,new,updated,or,deleted,settings,from,a,given,settings,builder,param,to,apply,the,new,settings,to,apply,param,target,the,target,settings,builder,that,the,updates,are,applied,to,all,keys,that,have,explicit,null,value,in,to,apply,will,be,removed,from,this,builder,param,updates,a,settings,builder,that,holds,all,updates,applied,to,target,param,type,a,free,text,string,to,allow,better,exceptions,messages,param,only,dynamic,if,code,false,code,all,settings,are,updated,otherwise,only,dynamic,settings,are,updated,if,set,to,code,true,code,and,a,non,dynamic,setting,is,updated,an,exception,is,thrown,return,code,true,code,if,the,target,has,changed,otherwise,code,false,code;private,boolean,update,settings,settings,to,apply,settings,builder,target,settings,builder,updates,string,type,boolean,only,dynamic,boolean,changed,false,final,set,string,to,remove,new,hash,set,settings,builder,settings,builder,settings,builder,final,predicate,string,can,update,key,is,final,setting,key,false,only,dynamic,false,get,key,null,is,dynamic,setting,key,for,string,key,to,apply,key,set,boolean,is,delete,to,apply,has,value,key,false,if,is,delete,is,valid,delete,key,only,dynamic,key,ends,with,to,remove,add,key,else,if,get,key,null,throw,new,illegal,argument,exception,type,setting,key,not,recognized,else,if,is,delete,false,can,update,test,key,validate,key,to,apply,false,settings,builder,copy,key,to,apply,updates,copy,key,to,apply,changed,true,else,if,is,final,setting,key,throw,new,illegal,argument,exception,final,type,setting,key,not,updateable,else,throw,new,illegal,argument,exception,type,setting,key,not,dynamically,updateable,changed,apply,deletes,to,remove,target,k,is,valid,delete,k,only,dynamic,target,put,settings,builder,build,return,changed
AbstractScopedSettings -> private boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type, boolean onlyDynamic);1544081506;Updates a target settings builder with new, updated or deleted settings from a given settings builder.__@param toApply the new settings to apply_@param target the target settings builder that the updates are applied to. All keys that have explicit null value in toApply will be_removed from this builder_@param updates a settings builder that holds all updates applied to target_@param type a free text string to allow better exceptions messages_@param onlyDynamic if <code>false</code> all settings are updated otherwise only dynamic settings are updated. if set to_<code>true</code> and a non-dynamic setting is updated an exception is thrown._@return <code>true</code> if the target has changed otherwise <code>false</code>;private boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type, boolean onlyDynamic) {_        boolean changed = false__        final Set<String> toRemove = new HashSet<>()__        Settings.Builder settingsBuilder = Settings.builder()__        final Predicate<String> canUpdate = (key) -> (_            isFinalSetting(key) == false && _                ((onlyDynamic == false && get(key) != null) || isDynamicSetting(key)))__        for (String key : toApply.keySet()) {_            boolean isDelete = toApply.hasValue(key) == false__            if (isDelete && (isValidDelete(key, onlyDynamic) || key.endsWith("*"))) {_                _                _                toRemove.add(key)__                _            } else if (get(key) == null) {_                throw new IllegalArgumentException(type + " setting [" + key + "], not recognized")__            } else if (isDelete == false && canUpdate.test(key)) {_                validate(key, toApply, false)_ _                settingsBuilder.copy(key, toApply)__                updates.copy(key, toApply)__                changed = true__            } else {_                if (isFinalSetting(key)) {_                    throw new IllegalArgumentException("final " + type + " setting [" + key + "], not updateable")__                } else {_                    throw new IllegalArgumentException(type + " setting [" + key + "], not dynamically updateable")__                }_            }_        }_        changed |= applyDeletes(toRemove, target, k -> isValidDelete(k, onlyDynamic))__        target.put(settingsBuilder.build())__        return changed__    };updates,a,target,settings,builder,with,new,updated,or,deleted,settings,from,a,given,settings,builder,param,to,apply,the,new,settings,to,apply,param,target,the,target,settings,builder,that,the,updates,are,applied,to,all,keys,that,have,explicit,null,value,in,to,apply,will,be,removed,from,this,builder,param,updates,a,settings,builder,that,holds,all,updates,applied,to,target,param,type,a,free,text,string,to,allow,better,exceptions,messages,param,only,dynamic,if,code,false,code,all,settings,are,updated,otherwise,only,dynamic,settings,are,updated,if,set,to,code,true,code,and,a,non,dynamic,setting,is,updated,an,exception,is,thrown,return,code,true,code,if,the,target,has,changed,otherwise,code,false,code;private,boolean,update,settings,settings,to,apply,settings,builder,target,settings,builder,updates,string,type,boolean,only,dynamic,boolean,changed,false,final,set,string,to,remove,new,hash,set,settings,builder,settings,builder,settings,builder,final,predicate,string,can,update,key,is,final,setting,key,false,only,dynamic,false,get,key,null,is,dynamic,setting,key,for,string,key,to,apply,key,set,boolean,is,delete,to,apply,has,value,key,false,if,is,delete,is,valid,delete,key,only,dynamic,key,ends,with,to,remove,add,key,else,if,get,key,null,throw,new,illegal,argument,exception,type,setting,key,not,recognized,else,if,is,delete,false,can,update,test,key,validate,key,to,apply,false,settings,builder,copy,key,to,apply,updates,copy,key,to,apply,changed,true,else,if,is,final,setting,key,throw,new,illegal,argument,exception,final,type,setting,key,not,updateable,else,throw,new,illegal,argument,exception,type,setting,key,not,dynamically,updateable,changed,apply,deletes,to,remove,target,k,is,valid,delete,k,only,dynamic,target,put,settings,builder,build,return,changed
AbstractScopedSettings -> private boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type, boolean onlyDynamic);1544691774;Updates a target settings builder with new, updated or deleted settings from a given settings builder.__@param toApply the new settings to apply_@param target the target settings builder that the updates are applied to. All keys that have explicit null value in toApply will be_removed from this builder_@param updates a settings builder that holds all updates applied to target_@param type a free text string to allow better exceptions messages_@param onlyDynamic if <code>false</code> all settings are updated otherwise only dynamic settings are updated. if set to_<code>true</code> and a non-dynamic setting is updated an exception is thrown._@return <code>true</code> if the target has changed otherwise <code>false</code>;private boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type, boolean onlyDynamic) {_        boolean changed = false__        final Set<String> toRemove = new HashSet<>()__        Settings.Builder settingsBuilder = Settings.builder()__        final Predicate<String> canUpdate = (key) -> (_            isFinalSetting(key) == false && _                ((onlyDynamic == false && get(key) != null) || isDynamicSetting(key)))__        for (String key : toApply.keySet()) {_            boolean isDelete = toApply.hasValue(key) == false__            if (isDelete && (isValidDelete(key, onlyDynamic) || key.endsWith("*"))) {_                _                _                toRemove.add(key)__                _            } else if (get(key) == null) {_                throw new IllegalArgumentException(type + " setting [" + key + "], not recognized")__            } else if (isDelete == false && canUpdate.test(key)) {_                validate(key, toApply, false)_ _                settingsBuilder.copy(key, toApply)__                updates.copy(key, toApply)__                changed |= toApply.get(key).equals(target.get(key)) == false__            } else {_                if (isFinalSetting(key)) {_                    throw new IllegalArgumentException("final " + type + " setting [" + key + "], not updateable")__                } else {_                    throw new IllegalArgumentException(type + " setting [" + key + "], not dynamically updateable")__                }_            }_        }_        changed |= applyDeletes(toRemove, target, k -> isValidDelete(k, onlyDynamic))__        target.put(settingsBuilder.build())__        return changed__    };updates,a,target,settings,builder,with,new,updated,or,deleted,settings,from,a,given,settings,builder,param,to,apply,the,new,settings,to,apply,param,target,the,target,settings,builder,that,the,updates,are,applied,to,all,keys,that,have,explicit,null,value,in,to,apply,will,be,removed,from,this,builder,param,updates,a,settings,builder,that,holds,all,updates,applied,to,target,param,type,a,free,text,string,to,allow,better,exceptions,messages,param,only,dynamic,if,code,false,code,all,settings,are,updated,otherwise,only,dynamic,settings,are,updated,if,set,to,code,true,code,and,a,non,dynamic,setting,is,updated,an,exception,is,thrown,return,code,true,code,if,the,target,has,changed,otherwise,code,false,code;private,boolean,update,settings,settings,to,apply,settings,builder,target,settings,builder,updates,string,type,boolean,only,dynamic,boolean,changed,false,final,set,string,to,remove,new,hash,set,settings,builder,settings,builder,settings,builder,final,predicate,string,can,update,key,is,final,setting,key,false,only,dynamic,false,get,key,null,is,dynamic,setting,key,for,string,key,to,apply,key,set,boolean,is,delete,to,apply,has,value,key,false,if,is,delete,is,valid,delete,key,only,dynamic,key,ends,with,to,remove,add,key,else,if,get,key,null,throw,new,illegal,argument,exception,type,setting,key,not,recognized,else,if,is,delete,false,can,update,test,key,validate,key,to,apply,false,settings,builder,copy,key,to,apply,updates,copy,key,to,apply,changed,to,apply,get,key,equals,target,get,key,false,else,if,is,final,setting,key,throw,new,illegal,argument,exception,final,type,setting,key,not,updateable,else,throw,new,illegal,argument,exception,type,setting,key,not,dynamically,updateable,changed,apply,deletes,to,remove,target,k,is,valid,delete,k,only,dynamic,target,put,settings,builder,build,return,changed
AbstractScopedSettings -> private boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type, boolean onlyDynamic);1546877578;Updates a target settings builder with new, updated or deleted settings from a given settings builder.__@param toApply the new settings to apply_@param target the target settings builder that the updates are applied to. All keys that have explicit null value in toApply will be_removed from this builder_@param updates a settings builder that holds all updates applied to target_@param type a free text string to allow better exceptions messages_@param onlyDynamic if <code>false</code> all settings are updated otherwise only dynamic settings are updated. if set to_<code>true</code> and a non-dynamic setting is updated an exception is thrown._@return <code>true</code> if the target has changed otherwise <code>false</code>;private boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type, boolean onlyDynamic) {_        boolean changed = false__        final Set<String> toRemove = new HashSet<>()__        Settings.Builder settingsBuilder = Settings.builder()__        final Predicate<String> canUpdate = (key) -> (_            isFinalSetting(key) == false && _                ((onlyDynamic == false && get(key) != null) || isDynamicSetting(key)))__        for (String key : toApply.keySet()) {_            boolean isDelete = toApply.hasValue(key) == false__            if (isDelete && (isValidDelete(key, onlyDynamic) || key.endsWith("*"))) {_                _                _                toRemove.add(key)__                _            } else if (get(key) == null) {_                throw new IllegalArgumentException(type + " setting [" + key + "], not recognized")__            } else if (isDelete == false && canUpdate.test(key)) {_                get(key).validateWithoutDependencies(toApply)_ _                settingsBuilder.copy(key, toApply)__                updates.copy(key, toApply)__                changed |= toApply.get(key).equals(target.get(key)) == false__            } else {_                if (isFinalSetting(key)) {_                    throw new IllegalArgumentException("final " + type + " setting [" + key + "], not updateable")__                } else {_                    throw new IllegalArgumentException(type + " setting [" + key + "], not dynamically updateable")__                }_            }_        }_        changed |= applyDeletes(toRemove, target, k -> isValidDelete(k, onlyDynamic))__        target.put(settingsBuilder.build())__        return changed__    };updates,a,target,settings,builder,with,new,updated,or,deleted,settings,from,a,given,settings,builder,param,to,apply,the,new,settings,to,apply,param,target,the,target,settings,builder,that,the,updates,are,applied,to,all,keys,that,have,explicit,null,value,in,to,apply,will,be,removed,from,this,builder,param,updates,a,settings,builder,that,holds,all,updates,applied,to,target,param,type,a,free,text,string,to,allow,better,exceptions,messages,param,only,dynamic,if,code,false,code,all,settings,are,updated,otherwise,only,dynamic,settings,are,updated,if,set,to,code,true,code,and,a,non,dynamic,setting,is,updated,an,exception,is,thrown,return,code,true,code,if,the,target,has,changed,otherwise,code,false,code;private,boolean,update,settings,settings,to,apply,settings,builder,target,settings,builder,updates,string,type,boolean,only,dynamic,boolean,changed,false,final,set,string,to,remove,new,hash,set,settings,builder,settings,builder,settings,builder,final,predicate,string,can,update,key,is,final,setting,key,false,only,dynamic,false,get,key,null,is,dynamic,setting,key,for,string,key,to,apply,key,set,boolean,is,delete,to,apply,has,value,key,false,if,is,delete,is,valid,delete,key,only,dynamic,key,ends,with,to,remove,add,key,else,if,get,key,null,throw,new,illegal,argument,exception,type,setting,key,not,recognized,else,if,is,delete,false,can,update,test,key,get,key,validate,without,dependencies,to,apply,settings,builder,copy,key,to,apply,updates,copy,key,to,apply,changed,to,apply,get,key,equals,target,get,key,false,else,if,is,final,setting,key,throw,new,illegal,argument,exception,final,type,setting,key,not,updateable,else,throw,new,illegal,argument,exception,type,setting,key,not,dynamically,updateable,changed,apply,deletes,to,remove,target,k,is,valid,delete,k,only,dynamic,target,put,settings,builder,build,return,changed
AbstractScopedSettings -> private boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type, boolean onlyDynamic);1548270339;Updates a target settings builder with new, updated or deleted settings from a given settings builder.__@param toApply the new settings to apply_@param target the target settings builder that the updates are applied to. All keys that have explicit null value in toApply will be_removed from this builder_@param updates a settings builder that holds all updates applied to target_@param type a free text string to allow better exceptions messages_@param onlyDynamic if <code>false</code> all settings are updated otherwise only dynamic settings are updated. if set to_<code>true</code> and a non-dynamic setting is updated an exception is thrown._@return <code>true</code> if the target has changed otherwise <code>false</code>;private boolean updateSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type, boolean onlyDynamic) {_        boolean changed = false__        final Set<String> toRemove = new HashSet<>()__        Settings.Builder settingsBuilder = Settings.builder()__        final Predicate<String> canUpdate = (key) -> (_            isFinalSetting(key) == false && _                ((onlyDynamic == false && get(key) != null) || isDynamicSetting(key)))__        for (String key : toApply.keySet()) {_            boolean isDelete = toApply.hasValue(key) == false__            if (isDelete && (isValidDelete(key, onlyDynamic) || key.endsWith("*"))) {_                _                _                toRemove.add(key)__                _            } else if (get(key) == null) {_                throw new IllegalArgumentException(type + " setting [" + key + "], not recognized")__            } else if (isDelete == false && canUpdate.test(key)) {_                get(key).validateWithoutDependencies(toApply)_ _                settingsBuilder.copy(key, toApply)__                updates.copy(key, toApply)__                changed |= toApply.get(key).equals(target.get(key)) == false__            } else {_                if (isFinalSetting(key)) {_                    throw new IllegalArgumentException("final " + type + " setting [" + key + "], not updateable")__                } else {_                    throw new IllegalArgumentException(type + " setting [" + key + "], not dynamically updateable")__                }_            }_        }_        changed |= applyDeletes(toRemove, target, k -> isValidDelete(k, onlyDynamic))__        target.put(settingsBuilder.build())__        return changed__    };updates,a,target,settings,builder,with,new,updated,or,deleted,settings,from,a,given,settings,builder,param,to,apply,the,new,settings,to,apply,param,target,the,target,settings,builder,that,the,updates,are,applied,to,all,keys,that,have,explicit,null,value,in,to,apply,will,be,removed,from,this,builder,param,updates,a,settings,builder,that,holds,all,updates,applied,to,target,param,type,a,free,text,string,to,allow,better,exceptions,messages,param,only,dynamic,if,code,false,code,all,settings,are,updated,otherwise,only,dynamic,settings,are,updated,if,set,to,code,true,code,and,a,non,dynamic,setting,is,updated,an,exception,is,thrown,return,code,true,code,if,the,target,has,changed,otherwise,code,false,code;private,boolean,update,settings,settings,to,apply,settings,builder,target,settings,builder,updates,string,type,boolean,only,dynamic,boolean,changed,false,final,set,string,to,remove,new,hash,set,settings,builder,settings,builder,settings,builder,final,predicate,string,can,update,key,is,final,setting,key,false,only,dynamic,false,get,key,null,is,dynamic,setting,key,for,string,key,to,apply,key,set,boolean,is,delete,to,apply,has,value,key,false,if,is,delete,is,valid,delete,key,only,dynamic,key,ends,with,to,remove,add,key,else,if,get,key,null,throw,new,illegal,argument,exception,type,setting,key,not,recognized,else,if,is,delete,false,can,update,test,key,get,key,validate,without,dependencies,to,apply,settings,builder,copy,key,to,apply,updates,copy,key,to,apply,changed,to,apply,get,key,equals,target,get,key,false,else,if,is,final,setting,key,throw,new,illegal,argument,exception,final,type,setting,key,not,updateable,else,throw,new,illegal,argument,exception,type,setting,key,not,dynamically,updateable,changed,apply,deletes,to,remove,target,k,is,valid,delete,k,only,dynamic,target,put,settings,builder,build,return,changed
AbstractScopedSettings -> public synchronized void addSettingsUpdateConsumer(Consumer<Settings> consumer, List<? extends Setting<?>> settings);1524684173;Adds a settings consumer that is only executed if any setting in the supplied list of settings is changed. In that case all the_settings are specified in the argument are returned.__Also automatically adds empty consumers for all settings in order to activate logging;public synchronized void addSettingsUpdateConsumer(Consumer<Settings> consumer, List<? extends Setting<?>> settings) {_        addSettingsUpdater(Setting.groupedSettingsUpdater(consumer, logger, settings))__    };adds,a,settings,consumer,that,is,only,executed,if,any,setting,in,the,supplied,list,of,settings,is,changed,in,that,case,all,the,settings,are,specified,in,the,argument,are,returned,also,automatically,adds,empty,consumers,for,all,settings,in,order,to,activate,logging;public,synchronized,void,add,settings,update,consumer,consumer,settings,consumer,list,extends,setting,settings,add,settings,updater,setting,grouped,settings,updater,consumer,logger,settings
AbstractScopedSettings -> public synchronized void addSettingsUpdateConsumer(Consumer<Settings> consumer, List<? extends Setting<?>> settings);1528904315;Adds a settings consumer that is only executed if any setting in the supplied list of settings is changed. In that case all the_settings are specified in the argument are returned.__Also automatically adds empty consumers for all settings in order to activate logging;public synchronized void addSettingsUpdateConsumer(Consumer<Settings> consumer, List<? extends Setting<?>> settings) {_        addSettingsUpdater(Setting.groupedSettingsUpdater(consumer, logger, settings))__    };adds,a,settings,consumer,that,is,only,executed,if,any,setting,in,the,supplied,list,of,settings,is,changed,in,that,case,all,the,settings,are,specified,in,the,argument,are,returned,also,automatically,adds,empty,consumers,for,all,settings,in,order,to,activate,logging;public,synchronized,void,add,settings,update,consumer,consumer,settings,consumer,list,extends,setting,settings,add,settings,updater,setting,grouped,settings,updater,consumer,logger,settings
AbstractScopedSettings -> public synchronized void addSettingsUpdateConsumer(Consumer<Settings> consumer, List<? extends Setting<?>> settings);1531179852;Adds a settings consumer that is only executed if any setting in the supplied list of settings is changed. In that case all the_settings are specified in the argument are returned.__Also automatically adds empty consumers for all settings in order to activate logging;public synchronized void addSettingsUpdateConsumer(Consumer<Settings> consumer, List<? extends Setting<?>> settings) {_        addSettingsUpdater(Setting.groupedSettingsUpdater(consumer, logger, settings))__    };adds,a,settings,consumer,that,is,only,executed,if,any,setting,in,the,supplied,list,of,settings,is,changed,in,that,case,all,the,settings,are,specified,in,the,argument,are,returned,also,automatically,adds,empty,consumers,for,all,settings,in,order,to,activate,logging;public,synchronized,void,add,settings,update,consumer,consumer,settings,consumer,list,extends,setting,settings,add,settings,updater,setting,grouped,settings,updater,consumer,logger,settings
AbstractScopedSettings -> public synchronized void addSettingsUpdateConsumer(Consumer<Settings> consumer, List<? extends Setting<?>> settings);1535046779;Adds a settings consumer that is only executed if any setting in the supplied list of settings is changed. In that case all the_settings are specified in the argument are returned.__Also automatically adds empty consumers for all settings in order to activate logging;public synchronized void addSettingsUpdateConsumer(Consumer<Settings> consumer, List<? extends Setting<?>> settings) {_        addSettingsUpdater(Setting.groupedSettingsUpdater(consumer, settings))__    };adds,a,settings,consumer,that,is,only,executed,if,any,setting,in,the,supplied,list,of,settings,is,changed,in,that,case,all,the,settings,are,specified,in,the,argument,are,returned,also,automatically,adds,empty,consumers,for,all,settings,in,order,to,activate,logging;public,synchronized,void,add,settings,update,consumer,consumer,settings,consumer,list,extends,setting,settings,add,settings,updater,setting,grouped,settings,updater,consumer,settings
AbstractScopedSettings -> public synchronized void addSettingsUpdateConsumer(Consumer<Settings> consumer, List<? extends Setting<?>> settings);1536137328;Adds a settings consumer that is only executed if any setting in the supplied list of settings is changed. In that case all the_settings are specified in the argument are returned.__Also automatically adds empty consumers for all settings in order to activate logging;public synchronized void addSettingsUpdateConsumer(Consumer<Settings> consumer, List<? extends Setting<?>> settings) {_        addSettingsUpdater(Setting.groupedSettingsUpdater(consumer, settings))__    };adds,a,settings,consumer,that,is,only,executed,if,any,setting,in,the,supplied,list,of,settings,is,changed,in,that,case,all,the,settings,are,specified,in,the,argument,are,returned,also,automatically,adds,empty,consumers,for,all,settings,in,order,to,activate,logging;public,synchronized,void,add,settings,update,consumer,consumer,settings,consumer,list,extends,setting,settings,add,settings,updater,setting,grouped,settings,updater,consumer,settings
AbstractScopedSettings -> public synchronized void addSettingsUpdateConsumer(Consumer<Settings> consumer, List<? extends Setting<?>> settings);1536314350;Adds a settings consumer that is only executed if any setting in the supplied list of settings is changed. In that case all the_settings are specified in the argument are returned.__Also automatically adds empty consumers for all settings in order to activate logging;public synchronized void addSettingsUpdateConsumer(Consumer<Settings> consumer, List<? extends Setting<?>> settings) {_        addSettingsUpdater(Setting.groupedSettingsUpdater(consumer, settings))__    };adds,a,settings,consumer,that,is,only,executed,if,any,setting,in,the,supplied,list,of,settings,is,changed,in,that,case,all,the,settings,are,specified,in,the,argument,are,returned,also,automatically,adds,empty,consumers,for,all,settings,in,order,to,activate,logging;public,synchronized,void,add,settings,update,consumer,consumer,settings,consumer,list,extends,setting,settings,add,settings,updater,setting,grouped,settings,updater,consumer,settings
AbstractScopedSettings -> public synchronized void addSettingsUpdateConsumer(Consumer<Settings> consumer, List<? extends Setting<?>> settings);1536611444;Adds a settings consumer that is only executed if any setting in the supplied list of settings is changed. In that case all the_settings are specified in the argument are returned.__Also automatically adds empty consumers for all settings in order to activate logging;public synchronized void addSettingsUpdateConsumer(Consumer<Settings> consumer, List<? extends Setting<?>> settings) {_        addSettingsUpdater(Setting.groupedSettingsUpdater(consumer, settings))__    };adds,a,settings,consumer,that,is,only,executed,if,any,setting,in,the,supplied,list,of,settings,is,changed,in,that,case,all,the,settings,are,specified,in,the,argument,are,returned,also,automatically,adds,empty,consumers,for,all,settings,in,order,to,activate,logging;public,synchronized,void,add,settings,update,consumer,consumer,settings,consumer,list,extends,setting,settings,add,settings,updater,setting,grouped,settings,updater,consumer,settings
AbstractScopedSettings -> public synchronized void addSettingsUpdateConsumer(Consumer<Settings> consumer, List<? extends Setting<?>> settings);1536828374;Adds a settings consumer that is only executed if any setting in the supplied list of settings is changed. In that case all the_settings are specified in the argument are returned.__Also automatically adds empty consumers for all settings in order to activate logging;public synchronized void addSettingsUpdateConsumer(Consumer<Settings> consumer, List<? extends Setting<?>> settings) {_        addSettingsUpdater(Setting.groupedSettingsUpdater(consumer, settings))__    };adds,a,settings,consumer,that,is,only,executed,if,any,setting,in,the,supplied,list,of,settings,is,changed,in,that,case,all,the,settings,are,specified,in,the,argument,are,returned,also,automatically,adds,empty,consumers,for,all,settings,in,order,to,activate,logging;public,synchronized,void,add,settings,update,consumer,consumer,settings,consumer,list,extends,setting,settings,add,settings,updater,setting,grouped,settings,updater,consumer,settings
AbstractScopedSettings -> public synchronized void addSettingsUpdateConsumer(Consumer<Settings> consumer, List<? extends Setting<?>> settings);1539951844;Adds a settings consumer that is only executed if any setting in the supplied list of settings is changed. In that case all the_settings are specified in the argument are returned.__Also automatically adds empty consumers for all settings in order to activate logging;public synchronized void addSettingsUpdateConsumer(Consumer<Settings> consumer, List<? extends Setting<?>> settings) {_        addSettingsUpdater(Setting.groupedSettingsUpdater(consumer, settings))__    };adds,a,settings,consumer,that,is,only,executed,if,any,setting,in,the,supplied,list,of,settings,is,changed,in,that,case,all,the,settings,are,specified,in,the,argument,are,returned,also,automatically,adds,empty,consumers,for,all,settings,in,order,to,activate,logging;public,synchronized,void,add,settings,update,consumer,consumer,settings,consumer,list,extends,setting,settings,add,settings,updater,setting,grouped,settings,updater,consumer,settings
AbstractScopedSettings -> public synchronized void addSettingsUpdateConsumer(Consumer<Settings> consumer, List<? extends Setting<?>> settings);1541008027;Adds a settings consumer that is only executed if any setting in the supplied list of settings is changed. In that case all the_settings are specified in the argument are returned.__Also automatically adds empty consumers for all settings in order to activate logging;public synchronized void addSettingsUpdateConsumer(Consumer<Settings> consumer, List<? extends Setting<?>> settings) {_        addSettingsUpdater(Setting.groupedSettingsUpdater(consumer, settings))__    };adds,a,settings,consumer,that,is,only,executed,if,any,setting,in,the,supplied,list,of,settings,is,changed,in,that,case,all,the,settings,are,specified,in,the,argument,are,returned,also,automatically,adds,empty,consumers,for,all,settings,in,order,to,activate,logging;public,synchronized,void,add,settings,update,consumer,consumer,settings,consumer,list,extends,setting,settings,add,settings,updater,setting,grouped,settings,updater,consumer,settings
AbstractScopedSettings -> public synchronized void addSettingsUpdateConsumer(Consumer<Settings> consumer, List<? extends Setting<?>> settings);1541092382;Adds a settings consumer that is only executed if any setting in the supplied list of settings is changed. In that case all the_settings are specified in the argument are returned.__Also automatically adds empty consumers for all settings in order to activate logging;public synchronized void addSettingsUpdateConsumer(Consumer<Settings> consumer, List<? extends Setting<?>> settings) {_        addSettingsUpdater(Setting.groupedSettingsUpdater(consumer, settings))__    };adds,a,settings,consumer,that,is,only,executed,if,any,setting,in,the,supplied,list,of,settings,is,changed,in,that,case,all,the,settings,are,specified,in,the,argument,are,returned,also,automatically,adds,empty,consumers,for,all,settings,in,order,to,activate,logging;public,synchronized,void,add,settings,update,consumer,consumer,settings,consumer,list,extends,setting,settings,add,settings,updater,setting,grouped,settings,updater,consumer,settings
AbstractScopedSettings -> public synchronized void addSettingsUpdateConsumer(Consumer<Settings> consumer, List<? extends Setting<?>> settings);1542402632;Adds a settings consumer that is only executed if any setting in the supplied list of settings is changed. In that case all the_settings are specified in the argument are returned.__Also automatically adds empty consumers for all settings in order to activate logging;public synchronized void addSettingsUpdateConsumer(Consumer<Settings> consumer, List<? extends Setting<?>> settings) {_        addSettingsUpdater(Setting.groupedSettingsUpdater(consumer, settings))__    };adds,a,settings,consumer,that,is,only,executed,if,any,setting,in,the,supplied,list,of,settings,is,changed,in,that,case,all,the,settings,are,specified,in,the,argument,are,returned,also,automatically,adds,empty,consumers,for,all,settings,in,order,to,activate,logging;public,synchronized,void,add,settings,update,consumer,consumer,settings,consumer,list,extends,setting,settings,add,settings,updater,setting,grouped,settings,updater,consumer,settings
AbstractScopedSettings -> public synchronized void addSettingsUpdateConsumer(Consumer<Settings> consumer, List<? extends Setting<?>> settings);1544081506;Adds a settings consumer that is only executed if any setting in the supplied list of settings is changed. In that case all the_settings are specified in the argument are returned.__Also automatically adds empty consumers for all settings in order to activate logging;public synchronized void addSettingsUpdateConsumer(Consumer<Settings> consumer, List<? extends Setting<?>> settings) {_        addSettingsUpdater(Setting.groupedSettingsUpdater(consumer, settings))__    };adds,a,settings,consumer,that,is,only,executed,if,any,setting,in,the,supplied,list,of,settings,is,changed,in,that,case,all,the,settings,are,specified,in,the,argument,are,returned,also,automatically,adds,empty,consumers,for,all,settings,in,order,to,activate,logging;public,synchronized,void,add,settings,update,consumer,consumer,settings,consumer,list,extends,setting,settings,add,settings,updater,setting,grouped,settings,updater,consumer,settings
AbstractScopedSettings -> public synchronized void addSettingsUpdateConsumer(Consumer<Settings> consumer, List<? extends Setting<?>> settings);1544691774;Adds a settings consumer that is only executed if any setting in the supplied list of settings is changed. In that case all the_settings are specified in the argument are returned.__Also automatically adds empty consumers for all settings in order to activate logging;public synchronized void addSettingsUpdateConsumer(Consumer<Settings> consumer, List<? extends Setting<?>> settings) {_        addSettingsUpdater(Setting.groupedSettingsUpdater(consumer, settings))__    };adds,a,settings,consumer,that,is,only,executed,if,any,setting,in,the,supplied,list,of,settings,is,changed,in,that,case,all,the,settings,are,specified,in,the,argument,are,returned,also,automatically,adds,empty,consumers,for,all,settings,in,order,to,activate,logging;public,synchronized,void,add,settings,update,consumer,consumer,settings,consumer,list,extends,setting,settings,add,settings,updater,setting,grouped,settings,updater,consumer,settings
AbstractScopedSettings -> public synchronized void addSettingsUpdateConsumer(Consumer<Settings> consumer, List<? extends Setting<?>> settings);1546877578;Adds a settings consumer that is only executed if any setting in the supplied list of settings is changed. In that case all the_settings are specified in the argument are returned.__Also automatically adds empty consumers for all settings in order to activate logging;public synchronized void addSettingsUpdateConsumer(Consumer<Settings> consumer, List<? extends Setting<?>> settings) {_        addSettingsUpdater(Setting.groupedSettingsUpdater(consumer, settings))__    };adds,a,settings,consumer,that,is,only,executed,if,any,setting,in,the,supplied,list,of,settings,is,changed,in,that,case,all,the,settings,are,specified,in,the,argument,are,returned,also,automatically,adds,empty,consumers,for,all,settings,in,order,to,activate,logging;public,synchronized,void,add,settings,update,consumer,consumer,settings,consumer,list,extends,setting,settings,add,settings,updater,setting,grouped,settings,updater,consumer,settings
AbstractScopedSettings -> public synchronized void addSettingsUpdateConsumer(Consumer<Settings> consumer, List<? extends Setting<?>> settings);1548270339;Adds a settings consumer that is only executed if any setting in the supplied list of settings is changed. In that case all the_settings are specified in the argument are returned.__Also automatically adds empty consumers for all settings in order to activate logging;public synchronized void addSettingsUpdateConsumer(Consumer<Settings> consumer, List<? extends Setting<?>> settings) {_        addSettingsUpdater(Setting.groupedSettingsUpdater(consumer, settings))__    };adds,a,settings,consumer,that,is,only,executed,if,any,setting,in,the,supplied,list,of,settings,is,changed,in,that,case,all,the,settings,are,specified,in,the,argument,are,returned,also,automatically,adds,empty,consumers,for,all,settings,in,order,to,activate,logging;public,synchronized,void,add,settings,update,consumer,consumer,settings,consumer,list,extends,setting,settings,add,settings,updater,setting,grouped,settings,updater,consumer,settings
AbstractScopedSettings -> public synchronized <T> void addAffixMapUpdateConsumer(Setting.AffixSetting<T> setting,  Consumer<Map<String, T>> consumer,                                                         BiConsumer<String, T> validator, boolean omitDefaults);1524684173;Adds a settings consumer for affix settings. Affix settings have a namespace associated to it that needs to be available to the_consumer in order to be processed correctly. This consumer will get a namespace to value map instead of each individual namespace_and value as in {@link #addAffixUpdateConsumer(Setting.AffixSetting, BiConsumer, BiConsumer)};public synchronized <T> void addAffixMapUpdateConsumer(Setting.AffixSetting<T> setting,  Consumer<Map<String, T>> consumer,_                                                        BiConsumer<String, T> validator, boolean omitDefaults) {_        final Setting<?> registeredSetting = this.complexMatchers.get(setting.getKey())__        if (setting != registeredSetting) {_            throw new IllegalArgumentException("Setting is not registered for key [" + setting.getKey() + "]")__        }_        addSettingsUpdater(setting.newAffixMapUpdater(consumer, logger, validator, omitDefaults))__    };adds,a,settings,consumer,for,affix,settings,affix,settings,have,a,namespace,associated,to,it,that,needs,to,be,available,to,the,consumer,in,order,to,be,processed,correctly,this,consumer,will,get,a,namespace,to,value,map,instead,of,each,individual,namespace,and,value,as,in,link,add,affix,update,consumer,setting,affix,setting,bi,consumer,bi,consumer;public,synchronized,t,void,add,affix,map,update,consumer,setting,affix,setting,t,setting,consumer,map,string,t,consumer,bi,consumer,string,t,validator,boolean,omit,defaults,final,setting,registered,setting,this,complex,matchers,get,setting,get,key,if,setting,registered,setting,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,setting,get,key,add,settings,updater,setting,new,affix,map,updater,consumer,logger,validator,omit,defaults
AbstractScopedSettings -> public synchronized <T> void addAffixMapUpdateConsumer(Setting.AffixSetting<T> setting,  Consumer<Map<String, T>> consumer,                                                         BiConsumer<String, T> validator, boolean omitDefaults);1528904315;Adds a settings consumer for affix settings. Affix settings have a namespace associated to it that needs to be available to the_consumer in order to be processed correctly. This consumer will get a namespace to value map instead of each individual namespace_and value as in {@link #addAffixUpdateConsumer(Setting.AffixSetting, BiConsumer, BiConsumer)};public synchronized <T> void addAffixMapUpdateConsumer(Setting.AffixSetting<T> setting,  Consumer<Map<String, T>> consumer,_                                                        BiConsumer<String, T> validator, boolean omitDefaults) {_        final Setting<?> registeredSetting = this.complexMatchers.get(setting.getKey())__        if (setting != registeredSetting) {_            throw new IllegalArgumentException("Setting is not registered for key [" + setting.getKey() + "]")__        }_        addSettingsUpdater(setting.newAffixMapUpdater(consumer, logger, validator, omitDefaults))__    };adds,a,settings,consumer,for,affix,settings,affix,settings,have,a,namespace,associated,to,it,that,needs,to,be,available,to,the,consumer,in,order,to,be,processed,correctly,this,consumer,will,get,a,namespace,to,value,map,instead,of,each,individual,namespace,and,value,as,in,link,add,affix,update,consumer,setting,affix,setting,bi,consumer,bi,consumer;public,synchronized,t,void,add,affix,map,update,consumer,setting,affix,setting,t,setting,consumer,map,string,t,consumer,bi,consumer,string,t,validator,boolean,omit,defaults,final,setting,registered,setting,this,complex,matchers,get,setting,get,key,if,setting,registered,setting,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,setting,get,key,add,settings,updater,setting,new,affix,map,updater,consumer,logger,validator,omit,defaults
AbstractScopedSettings -> public synchronized <T> void addAffixMapUpdateConsumer(Setting.AffixSetting<T> setting,  Consumer<Map<String, T>> consumer,                                                         BiConsumer<String, T> validator, boolean omitDefaults);1531179852;Adds a settings consumer for affix settings. Affix settings have a namespace associated to it that needs to be available to the_consumer in order to be processed correctly. This consumer will get a namespace to value map instead of each individual namespace_and value as in {@link #addAffixUpdateConsumer(Setting.AffixSetting, BiConsumer, BiConsumer)};public synchronized <T> void addAffixMapUpdateConsumer(Setting.AffixSetting<T> setting,  Consumer<Map<String, T>> consumer,_                                                        BiConsumer<String, T> validator, boolean omitDefaults) {_        final Setting<?> registeredSetting = this.complexMatchers.get(setting.getKey())__        if (setting != registeredSetting) {_            throw new IllegalArgumentException("Setting is not registered for key [" + setting.getKey() + "]")__        }_        addSettingsUpdater(setting.newAffixMapUpdater(consumer, logger, validator, omitDefaults))__    };adds,a,settings,consumer,for,affix,settings,affix,settings,have,a,namespace,associated,to,it,that,needs,to,be,available,to,the,consumer,in,order,to,be,processed,correctly,this,consumer,will,get,a,namespace,to,value,map,instead,of,each,individual,namespace,and,value,as,in,link,add,affix,update,consumer,setting,affix,setting,bi,consumer,bi,consumer;public,synchronized,t,void,add,affix,map,update,consumer,setting,affix,setting,t,setting,consumer,map,string,t,consumer,bi,consumer,string,t,validator,boolean,omit,defaults,final,setting,registered,setting,this,complex,matchers,get,setting,get,key,if,setting,registered,setting,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,setting,get,key,add,settings,updater,setting,new,affix,map,updater,consumer,logger,validator,omit,defaults
AbstractScopedSettings -> public synchronized <T> void addAffixMapUpdateConsumer(Setting.AffixSetting<T> setting,  Consumer<Map<String, T>> consumer,                                                         BiConsumer<String, T> validator, boolean omitDefaults);1535046779;Adds a settings consumer for affix settings. Affix settings have a namespace associated to it that needs to be available to the_consumer in order to be processed correctly. This consumer will get a namespace to value map instead of each individual namespace_and value as in {@link #addAffixUpdateConsumer(Setting.AffixSetting, BiConsumer, BiConsumer)};public synchronized <T> void addAffixMapUpdateConsumer(Setting.AffixSetting<T> setting,  Consumer<Map<String, T>> consumer,_                                                        BiConsumer<String, T> validator, boolean omitDefaults) {_        final Setting<?> registeredSetting = this.complexMatchers.get(setting.getKey())__        if (setting != registeredSetting) {_            throw new IllegalArgumentException("Setting is not registered for key [" + setting.getKey() + "]")__        }_        addSettingsUpdater(setting.newAffixMapUpdater(consumer, logger, validator, omitDefaults))__    };adds,a,settings,consumer,for,affix,settings,affix,settings,have,a,namespace,associated,to,it,that,needs,to,be,available,to,the,consumer,in,order,to,be,processed,correctly,this,consumer,will,get,a,namespace,to,value,map,instead,of,each,individual,namespace,and,value,as,in,link,add,affix,update,consumer,setting,affix,setting,bi,consumer,bi,consumer;public,synchronized,t,void,add,affix,map,update,consumer,setting,affix,setting,t,setting,consumer,map,string,t,consumer,bi,consumer,string,t,validator,boolean,omit,defaults,final,setting,registered,setting,this,complex,matchers,get,setting,get,key,if,setting,registered,setting,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,setting,get,key,add,settings,updater,setting,new,affix,map,updater,consumer,logger,validator,omit,defaults
AbstractScopedSettings -> public synchronized <T> void addAffixMapUpdateConsumer(Setting.AffixSetting<T> setting,  Consumer<Map<String, T>> consumer,                                                         BiConsumer<String, T> validator, boolean omitDefaults);1536137328;Adds a settings consumer for affix settings. Affix settings have a namespace associated to it that needs to be available to the_consumer in order to be processed correctly. This consumer will get a namespace to value map instead of each individual namespace_and value as in {@link #addAffixUpdateConsumer(Setting.AffixSetting, BiConsumer, BiConsumer)};public synchronized <T> void addAffixMapUpdateConsumer(Setting.AffixSetting<T> setting,  Consumer<Map<String, T>> consumer,_                                                        BiConsumer<String, T> validator, boolean omitDefaults) {_        final Setting<?> registeredSetting = this.complexMatchers.get(setting.getKey())__        if (setting != registeredSetting) {_            throw new IllegalArgumentException("Setting is not registered for key [" + setting.getKey() + "]")__        }_        addSettingsUpdater(setting.newAffixMapUpdater(consumer, logger, validator, omitDefaults))__    };adds,a,settings,consumer,for,affix,settings,affix,settings,have,a,namespace,associated,to,it,that,needs,to,be,available,to,the,consumer,in,order,to,be,processed,correctly,this,consumer,will,get,a,namespace,to,value,map,instead,of,each,individual,namespace,and,value,as,in,link,add,affix,update,consumer,setting,affix,setting,bi,consumer,bi,consumer;public,synchronized,t,void,add,affix,map,update,consumer,setting,affix,setting,t,setting,consumer,map,string,t,consumer,bi,consumer,string,t,validator,boolean,omit,defaults,final,setting,registered,setting,this,complex,matchers,get,setting,get,key,if,setting,registered,setting,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,setting,get,key,add,settings,updater,setting,new,affix,map,updater,consumer,logger,validator,omit,defaults
AbstractScopedSettings -> public synchronized <T> void addAffixMapUpdateConsumer(Setting.AffixSetting<T> setting,  Consumer<Map<String, T>> consumer,                                                         BiConsumer<String, T> validator, boolean omitDefaults);1536314350;Adds a settings consumer for affix settings. Affix settings have a namespace associated to it that needs to be available to the_consumer in order to be processed correctly. This consumer will get a namespace to value map instead of each individual namespace_and value as in {@link #addAffixUpdateConsumer(Setting.AffixSetting, BiConsumer, BiConsumer)};public synchronized <T> void addAffixMapUpdateConsumer(Setting.AffixSetting<T> setting,  Consumer<Map<String, T>> consumer,_                                                        BiConsumer<String, T> validator, boolean omitDefaults) {_        final Setting<?> registeredSetting = this.complexMatchers.get(setting.getKey())__        if (setting != registeredSetting) {_            throw new IllegalArgumentException("Setting is not registered for key [" + setting.getKey() + "]")__        }_        addSettingsUpdater(setting.newAffixMapUpdater(consumer, logger, validator, omitDefaults))__    };adds,a,settings,consumer,for,affix,settings,affix,settings,have,a,namespace,associated,to,it,that,needs,to,be,available,to,the,consumer,in,order,to,be,processed,correctly,this,consumer,will,get,a,namespace,to,value,map,instead,of,each,individual,namespace,and,value,as,in,link,add,affix,update,consumer,setting,affix,setting,bi,consumer,bi,consumer;public,synchronized,t,void,add,affix,map,update,consumer,setting,affix,setting,t,setting,consumer,map,string,t,consumer,bi,consumer,string,t,validator,boolean,omit,defaults,final,setting,registered,setting,this,complex,matchers,get,setting,get,key,if,setting,registered,setting,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,setting,get,key,add,settings,updater,setting,new,affix,map,updater,consumer,logger,validator,omit,defaults
AbstractScopedSettings -> public synchronized <T> void addAffixMapUpdateConsumer(Setting.AffixSetting<T> setting,  Consumer<Map<String, T>> consumer,                                                         BiConsumer<String, T> validator, boolean omitDefaults);1536611444;Adds a settings consumer for affix settings. Affix settings have a namespace associated to it that needs to be available to the_consumer in order to be processed correctly. This consumer will get a namespace to value map instead of each individual namespace_and value as in {@link #addAffixUpdateConsumer(Setting.AffixSetting, BiConsumer, BiConsumer)};public synchronized <T> void addAffixMapUpdateConsumer(Setting.AffixSetting<T> setting,  Consumer<Map<String, T>> consumer,_                                                        BiConsumer<String, T> validator, boolean omitDefaults) {_        final Setting<?> registeredSetting = this.complexMatchers.get(setting.getKey())__        if (setting != registeredSetting) {_            throw new IllegalArgumentException("Setting is not registered for key [" + setting.getKey() + "]")__        }_        addSettingsUpdater(setting.newAffixMapUpdater(consumer, logger, validator, omitDefaults))__    };adds,a,settings,consumer,for,affix,settings,affix,settings,have,a,namespace,associated,to,it,that,needs,to,be,available,to,the,consumer,in,order,to,be,processed,correctly,this,consumer,will,get,a,namespace,to,value,map,instead,of,each,individual,namespace,and,value,as,in,link,add,affix,update,consumer,setting,affix,setting,bi,consumer,bi,consumer;public,synchronized,t,void,add,affix,map,update,consumer,setting,affix,setting,t,setting,consumer,map,string,t,consumer,bi,consumer,string,t,validator,boolean,omit,defaults,final,setting,registered,setting,this,complex,matchers,get,setting,get,key,if,setting,registered,setting,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,setting,get,key,add,settings,updater,setting,new,affix,map,updater,consumer,logger,validator,omit,defaults
AbstractScopedSettings -> public synchronized <T> void addAffixMapUpdateConsumer(Setting.AffixSetting<T> setting,  Consumer<Map<String, T>> consumer,                                                         BiConsumer<String, T> validator, boolean omitDefaults);1536828374;Adds a settings consumer for affix settings. Affix settings have a namespace associated to it that needs to be available to the_consumer in order to be processed correctly. This consumer will get a namespace to value map instead of each individual namespace_and value as in {@link #addAffixUpdateConsumer(Setting.AffixSetting, BiConsumer, BiConsumer)};public synchronized <T> void addAffixMapUpdateConsumer(Setting.AffixSetting<T> setting,  Consumer<Map<String, T>> consumer,_                                                        BiConsumer<String, T> validator, boolean omitDefaults) {_        final Setting<?> registeredSetting = this.complexMatchers.get(setting.getKey())__        if (setting != registeredSetting) {_            throw new IllegalArgumentException("Setting is not registered for key [" + setting.getKey() + "]")__        }_        addSettingsUpdater(setting.newAffixMapUpdater(consumer, logger, validator, omitDefaults))__    };adds,a,settings,consumer,for,affix,settings,affix,settings,have,a,namespace,associated,to,it,that,needs,to,be,available,to,the,consumer,in,order,to,be,processed,correctly,this,consumer,will,get,a,namespace,to,value,map,instead,of,each,individual,namespace,and,value,as,in,link,add,affix,update,consumer,setting,affix,setting,bi,consumer,bi,consumer;public,synchronized,t,void,add,affix,map,update,consumer,setting,affix,setting,t,setting,consumer,map,string,t,consumer,bi,consumer,string,t,validator,boolean,omit,defaults,final,setting,registered,setting,this,complex,matchers,get,setting,get,key,if,setting,registered,setting,throw,new,illegal,argument,exception,setting,is,not,registered,for,key,setting,get,key,add,settings,updater,setting,new,affix,map,updater,consumer,logger,validator,omit,defaults
AbstractScopedSettings -> public boolean updateDynamicSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type);1524684173;Updates a target settings builder with new, updated or deleted settings from a given settings builder._<p>_Note: This method will only allow updates to dynamic settings. if a non-dynamic setting is updated an_{@link IllegalArgumentException} is thrown instead._</p>__@param toApply the new settings to apply_@param target the target settings builder that the updates are applied to. All keys that have explicit null value in toApply will be_removed from this builder_@param updates a settings builder that holds all updates applied to target_@param type a free text string to allow better exceptions messages_@return <code>true</code> if the target has changed otherwise <code>false</code>;public boolean updateDynamicSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type) {_        return updateSettings(toApply, target, updates, type, true)__    };updates,a,target,settings,builder,with,new,updated,or,deleted,settings,from,a,given,settings,builder,p,note,this,method,will,only,allow,updates,to,dynamic,settings,if,a,non,dynamic,setting,is,updated,an,link,illegal,argument,exception,is,thrown,instead,p,param,to,apply,the,new,settings,to,apply,param,target,the,target,settings,builder,that,the,updates,are,applied,to,all,keys,that,have,explicit,null,value,in,to,apply,will,be,removed,from,this,builder,param,updates,a,settings,builder,that,holds,all,updates,applied,to,target,param,type,a,free,text,string,to,allow,better,exceptions,messages,return,code,true,code,if,the,target,has,changed,otherwise,code,false,code;public,boolean,update,dynamic,settings,settings,to,apply,settings,builder,target,settings,builder,updates,string,type,return,update,settings,to,apply,target,updates,type,true
AbstractScopedSettings -> public boolean updateDynamicSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type);1528904315;Updates a target settings builder with new, updated or deleted settings from a given settings builder._<p>_Note: This method will only allow updates to dynamic settings. if a non-dynamic setting is updated an_{@link IllegalArgumentException} is thrown instead._</p>__@param toApply the new settings to apply_@param target the target settings builder that the updates are applied to. All keys that have explicit null value in toApply will be_removed from this builder_@param updates a settings builder that holds all updates applied to target_@param type a free text string to allow better exceptions messages_@return <code>true</code> if the target has changed otherwise <code>false</code>;public boolean updateDynamicSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type) {_        return updateSettings(toApply, target, updates, type, true)__    };updates,a,target,settings,builder,with,new,updated,or,deleted,settings,from,a,given,settings,builder,p,note,this,method,will,only,allow,updates,to,dynamic,settings,if,a,non,dynamic,setting,is,updated,an,link,illegal,argument,exception,is,thrown,instead,p,param,to,apply,the,new,settings,to,apply,param,target,the,target,settings,builder,that,the,updates,are,applied,to,all,keys,that,have,explicit,null,value,in,to,apply,will,be,removed,from,this,builder,param,updates,a,settings,builder,that,holds,all,updates,applied,to,target,param,type,a,free,text,string,to,allow,better,exceptions,messages,return,code,true,code,if,the,target,has,changed,otherwise,code,false,code;public,boolean,update,dynamic,settings,settings,to,apply,settings,builder,target,settings,builder,updates,string,type,return,update,settings,to,apply,target,updates,type,true
AbstractScopedSettings -> public boolean updateDynamicSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type);1531179852;Updates a target settings builder with new, updated or deleted settings from a given settings builder._<p>_Note: This method will only allow updates to dynamic settings. if a non-dynamic setting is updated an_{@link IllegalArgumentException} is thrown instead._</p>__@param toApply the new settings to apply_@param target the target settings builder that the updates are applied to. All keys that have explicit null value in toApply will be_removed from this builder_@param updates a settings builder that holds all updates applied to target_@param type a free text string to allow better exceptions messages_@return <code>true</code> if the target has changed otherwise <code>false</code>;public boolean updateDynamicSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type) {_        return updateSettings(toApply, target, updates, type, true)__    };updates,a,target,settings,builder,with,new,updated,or,deleted,settings,from,a,given,settings,builder,p,note,this,method,will,only,allow,updates,to,dynamic,settings,if,a,non,dynamic,setting,is,updated,an,link,illegal,argument,exception,is,thrown,instead,p,param,to,apply,the,new,settings,to,apply,param,target,the,target,settings,builder,that,the,updates,are,applied,to,all,keys,that,have,explicit,null,value,in,to,apply,will,be,removed,from,this,builder,param,updates,a,settings,builder,that,holds,all,updates,applied,to,target,param,type,a,free,text,string,to,allow,better,exceptions,messages,return,code,true,code,if,the,target,has,changed,otherwise,code,false,code;public,boolean,update,dynamic,settings,settings,to,apply,settings,builder,target,settings,builder,updates,string,type,return,update,settings,to,apply,target,updates,type,true
AbstractScopedSettings -> public boolean updateDynamicSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type);1535046779;Updates a target settings builder with new, updated or deleted settings from a given settings builder._<p>_Note: This method will only allow updates to dynamic settings. if a non-dynamic setting is updated an_{@link IllegalArgumentException} is thrown instead._</p>__@param toApply the new settings to apply_@param target the target settings builder that the updates are applied to. All keys that have explicit null value in toApply will be_removed from this builder_@param updates a settings builder that holds all updates applied to target_@param type a free text string to allow better exceptions messages_@return <code>true</code> if the target has changed otherwise <code>false</code>;public boolean updateDynamicSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type) {_        return updateSettings(toApply, target, updates, type, true)__    };updates,a,target,settings,builder,with,new,updated,or,deleted,settings,from,a,given,settings,builder,p,note,this,method,will,only,allow,updates,to,dynamic,settings,if,a,non,dynamic,setting,is,updated,an,link,illegal,argument,exception,is,thrown,instead,p,param,to,apply,the,new,settings,to,apply,param,target,the,target,settings,builder,that,the,updates,are,applied,to,all,keys,that,have,explicit,null,value,in,to,apply,will,be,removed,from,this,builder,param,updates,a,settings,builder,that,holds,all,updates,applied,to,target,param,type,a,free,text,string,to,allow,better,exceptions,messages,return,code,true,code,if,the,target,has,changed,otherwise,code,false,code;public,boolean,update,dynamic,settings,settings,to,apply,settings,builder,target,settings,builder,updates,string,type,return,update,settings,to,apply,target,updates,type,true
AbstractScopedSettings -> public boolean updateDynamicSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type);1536137328;Updates a target settings builder with new, updated or deleted settings from a given settings builder._<p>_Note: This method will only allow updates to dynamic settings. if a non-dynamic setting is updated an_{@link IllegalArgumentException} is thrown instead._</p>__@param toApply the new settings to apply_@param target the target settings builder that the updates are applied to. All keys that have explicit null value in toApply will be_removed from this builder_@param updates a settings builder that holds all updates applied to target_@param type a free text string to allow better exceptions messages_@return <code>true</code> if the target has changed otherwise <code>false</code>;public boolean updateDynamicSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type) {_        return updateSettings(toApply, target, updates, type, true)__    };updates,a,target,settings,builder,with,new,updated,or,deleted,settings,from,a,given,settings,builder,p,note,this,method,will,only,allow,updates,to,dynamic,settings,if,a,non,dynamic,setting,is,updated,an,link,illegal,argument,exception,is,thrown,instead,p,param,to,apply,the,new,settings,to,apply,param,target,the,target,settings,builder,that,the,updates,are,applied,to,all,keys,that,have,explicit,null,value,in,to,apply,will,be,removed,from,this,builder,param,updates,a,settings,builder,that,holds,all,updates,applied,to,target,param,type,a,free,text,string,to,allow,better,exceptions,messages,return,code,true,code,if,the,target,has,changed,otherwise,code,false,code;public,boolean,update,dynamic,settings,settings,to,apply,settings,builder,target,settings,builder,updates,string,type,return,update,settings,to,apply,target,updates,type,true
AbstractScopedSettings -> public boolean updateDynamicSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type);1536314350;Updates a target settings builder with new, updated or deleted settings from a given settings builder._<p>_Note: This method will only allow updates to dynamic settings. if a non-dynamic setting is updated an_{@link IllegalArgumentException} is thrown instead._</p>__@param toApply the new settings to apply_@param target the target settings builder that the updates are applied to. All keys that have explicit null value in toApply will be_removed from this builder_@param updates a settings builder that holds all updates applied to target_@param type a free text string to allow better exceptions messages_@return <code>true</code> if the target has changed otherwise <code>false</code>;public boolean updateDynamicSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type) {_        return updateSettings(toApply, target, updates, type, true)__    };updates,a,target,settings,builder,with,new,updated,or,deleted,settings,from,a,given,settings,builder,p,note,this,method,will,only,allow,updates,to,dynamic,settings,if,a,non,dynamic,setting,is,updated,an,link,illegal,argument,exception,is,thrown,instead,p,param,to,apply,the,new,settings,to,apply,param,target,the,target,settings,builder,that,the,updates,are,applied,to,all,keys,that,have,explicit,null,value,in,to,apply,will,be,removed,from,this,builder,param,updates,a,settings,builder,that,holds,all,updates,applied,to,target,param,type,a,free,text,string,to,allow,better,exceptions,messages,return,code,true,code,if,the,target,has,changed,otherwise,code,false,code;public,boolean,update,dynamic,settings,settings,to,apply,settings,builder,target,settings,builder,updates,string,type,return,update,settings,to,apply,target,updates,type,true
AbstractScopedSettings -> public boolean updateDynamicSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type);1536611444;Updates a target settings builder with new, updated or deleted settings from a given settings builder._<p>_Note: This method will only allow updates to dynamic settings. if a non-dynamic setting is updated an_{@link IllegalArgumentException} is thrown instead._</p>__@param toApply the new settings to apply_@param target the target settings builder that the updates are applied to. All keys that have explicit null value in toApply will be_removed from this builder_@param updates a settings builder that holds all updates applied to target_@param type a free text string to allow better exceptions messages_@return <code>true</code> if the target has changed otherwise <code>false</code>;public boolean updateDynamicSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type) {_        return updateSettings(toApply, target, updates, type, true)__    };updates,a,target,settings,builder,with,new,updated,or,deleted,settings,from,a,given,settings,builder,p,note,this,method,will,only,allow,updates,to,dynamic,settings,if,a,non,dynamic,setting,is,updated,an,link,illegal,argument,exception,is,thrown,instead,p,param,to,apply,the,new,settings,to,apply,param,target,the,target,settings,builder,that,the,updates,are,applied,to,all,keys,that,have,explicit,null,value,in,to,apply,will,be,removed,from,this,builder,param,updates,a,settings,builder,that,holds,all,updates,applied,to,target,param,type,a,free,text,string,to,allow,better,exceptions,messages,return,code,true,code,if,the,target,has,changed,otherwise,code,false,code;public,boolean,update,dynamic,settings,settings,to,apply,settings,builder,target,settings,builder,updates,string,type,return,update,settings,to,apply,target,updates,type,true
AbstractScopedSettings -> public boolean updateDynamicSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type);1536828374;Updates a target settings builder with new, updated or deleted settings from a given settings builder._<p>_Note: This method will only allow updates to dynamic settings. if a non-dynamic setting is updated an_{@link IllegalArgumentException} is thrown instead._</p>__@param toApply the new settings to apply_@param target the target settings builder that the updates are applied to. All keys that have explicit null value in toApply will be_removed from this builder_@param updates a settings builder that holds all updates applied to target_@param type a free text string to allow better exceptions messages_@return <code>true</code> if the target has changed otherwise <code>false</code>;public boolean updateDynamicSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type) {_        return updateSettings(toApply, target, updates, type, true)__    };updates,a,target,settings,builder,with,new,updated,or,deleted,settings,from,a,given,settings,builder,p,note,this,method,will,only,allow,updates,to,dynamic,settings,if,a,non,dynamic,setting,is,updated,an,link,illegal,argument,exception,is,thrown,instead,p,param,to,apply,the,new,settings,to,apply,param,target,the,target,settings,builder,that,the,updates,are,applied,to,all,keys,that,have,explicit,null,value,in,to,apply,will,be,removed,from,this,builder,param,updates,a,settings,builder,that,holds,all,updates,applied,to,target,param,type,a,free,text,string,to,allow,better,exceptions,messages,return,code,true,code,if,the,target,has,changed,otherwise,code,false,code;public,boolean,update,dynamic,settings,settings,to,apply,settings,builder,target,settings,builder,updates,string,type,return,update,settings,to,apply,target,updates,type,true
AbstractScopedSettings -> public boolean updateDynamicSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type);1539951844;Updates a target settings builder with new, updated or deleted settings from a given settings builder._<p>_Note: This method will only allow updates to dynamic settings. if a non-dynamic setting is updated an_{@link IllegalArgumentException} is thrown instead._</p>__@param toApply the new settings to apply_@param target the target settings builder that the updates are applied to. All keys that have explicit null value in toApply will be_removed from this builder_@param updates a settings builder that holds all updates applied to target_@param type a free text string to allow better exceptions messages_@return <code>true</code> if the target has changed otherwise <code>false</code>;public boolean updateDynamicSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type) {_        return updateSettings(toApply, target, updates, type, true)__    };updates,a,target,settings,builder,with,new,updated,or,deleted,settings,from,a,given,settings,builder,p,note,this,method,will,only,allow,updates,to,dynamic,settings,if,a,non,dynamic,setting,is,updated,an,link,illegal,argument,exception,is,thrown,instead,p,param,to,apply,the,new,settings,to,apply,param,target,the,target,settings,builder,that,the,updates,are,applied,to,all,keys,that,have,explicit,null,value,in,to,apply,will,be,removed,from,this,builder,param,updates,a,settings,builder,that,holds,all,updates,applied,to,target,param,type,a,free,text,string,to,allow,better,exceptions,messages,return,code,true,code,if,the,target,has,changed,otherwise,code,false,code;public,boolean,update,dynamic,settings,settings,to,apply,settings,builder,target,settings,builder,updates,string,type,return,update,settings,to,apply,target,updates,type,true
AbstractScopedSettings -> public boolean updateDynamicSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type);1541008027;Updates a target settings builder with new, updated or deleted settings from a given settings builder._<p>_Note: This method will only allow updates to dynamic settings. if a non-dynamic setting is updated an_{@link IllegalArgumentException} is thrown instead._</p>__@param toApply the new settings to apply_@param target the target settings builder that the updates are applied to. All keys that have explicit null value in toApply will be_removed from this builder_@param updates a settings builder that holds all updates applied to target_@param type a free text string to allow better exceptions messages_@return <code>true</code> if the target has changed otherwise <code>false</code>;public boolean updateDynamicSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type) {_        return updateSettings(toApply, target, updates, type, true)__    };updates,a,target,settings,builder,with,new,updated,or,deleted,settings,from,a,given,settings,builder,p,note,this,method,will,only,allow,updates,to,dynamic,settings,if,a,non,dynamic,setting,is,updated,an,link,illegal,argument,exception,is,thrown,instead,p,param,to,apply,the,new,settings,to,apply,param,target,the,target,settings,builder,that,the,updates,are,applied,to,all,keys,that,have,explicit,null,value,in,to,apply,will,be,removed,from,this,builder,param,updates,a,settings,builder,that,holds,all,updates,applied,to,target,param,type,a,free,text,string,to,allow,better,exceptions,messages,return,code,true,code,if,the,target,has,changed,otherwise,code,false,code;public,boolean,update,dynamic,settings,settings,to,apply,settings,builder,target,settings,builder,updates,string,type,return,update,settings,to,apply,target,updates,type,true
AbstractScopedSettings -> public boolean updateDynamicSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type);1541092382;Updates a target settings builder with new, updated or deleted settings from a given settings builder._<p>_Note: This method will only allow updates to dynamic settings. if a non-dynamic setting is updated an_{@link IllegalArgumentException} is thrown instead._</p>__@param toApply the new settings to apply_@param target the target settings builder that the updates are applied to. All keys that have explicit null value in toApply will be_removed from this builder_@param updates a settings builder that holds all updates applied to target_@param type a free text string to allow better exceptions messages_@return <code>true</code> if the target has changed otherwise <code>false</code>;public boolean updateDynamicSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type) {_        return updateSettings(toApply, target, updates, type, true)__    };updates,a,target,settings,builder,with,new,updated,or,deleted,settings,from,a,given,settings,builder,p,note,this,method,will,only,allow,updates,to,dynamic,settings,if,a,non,dynamic,setting,is,updated,an,link,illegal,argument,exception,is,thrown,instead,p,param,to,apply,the,new,settings,to,apply,param,target,the,target,settings,builder,that,the,updates,are,applied,to,all,keys,that,have,explicit,null,value,in,to,apply,will,be,removed,from,this,builder,param,updates,a,settings,builder,that,holds,all,updates,applied,to,target,param,type,a,free,text,string,to,allow,better,exceptions,messages,return,code,true,code,if,the,target,has,changed,otherwise,code,false,code;public,boolean,update,dynamic,settings,settings,to,apply,settings,builder,target,settings,builder,updates,string,type,return,update,settings,to,apply,target,updates,type,true
AbstractScopedSettings -> public boolean updateDynamicSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type);1542402632;Updates a target settings builder with new, updated or deleted settings from a given settings builder._<p>_Note: This method will only allow updates to dynamic settings. if a non-dynamic setting is updated an_{@link IllegalArgumentException} is thrown instead._</p>__@param toApply the new settings to apply_@param target the target settings builder that the updates are applied to. All keys that have explicit null value in toApply will be_removed from this builder_@param updates a settings builder that holds all updates applied to target_@param type a free text string to allow better exceptions messages_@return <code>true</code> if the target has changed otherwise <code>false</code>;public boolean updateDynamicSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type) {_        return updateSettings(toApply, target, updates, type, true)__    };updates,a,target,settings,builder,with,new,updated,or,deleted,settings,from,a,given,settings,builder,p,note,this,method,will,only,allow,updates,to,dynamic,settings,if,a,non,dynamic,setting,is,updated,an,link,illegal,argument,exception,is,thrown,instead,p,param,to,apply,the,new,settings,to,apply,param,target,the,target,settings,builder,that,the,updates,are,applied,to,all,keys,that,have,explicit,null,value,in,to,apply,will,be,removed,from,this,builder,param,updates,a,settings,builder,that,holds,all,updates,applied,to,target,param,type,a,free,text,string,to,allow,better,exceptions,messages,return,code,true,code,if,the,target,has,changed,otherwise,code,false,code;public,boolean,update,dynamic,settings,settings,to,apply,settings,builder,target,settings,builder,updates,string,type,return,update,settings,to,apply,target,updates,type,true
AbstractScopedSettings -> public boolean updateDynamicSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type);1544081506;Updates a target settings builder with new, updated or deleted settings from a given settings builder._<p>_Note: This method will only allow updates to dynamic settings. if a non-dynamic setting is updated an_{@link IllegalArgumentException} is thrown instead._</p>__@param toApply the new settings to apply_@param target the target settings builder that the updates are applied to. All keys that have explicit null value in toApply will be_removed from this builder_@param updates a settings builder that holds all updates applied to target_@param type a free text string to allow better exceptions messages_@return <code>true</code> if the target has changed otherwise <code>false</code>;public boolean updateDynamicSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type) {_        return updateSettings(toApply, target, updates, type, true)__    };updates,a,target,settings,builder,with,new,updated,or,deleted,settings,from,a,given,settings,builder,p,note,this,method,will,only,allow,updates,to,dynamic,settings,if,a,non,dynamic,setting,is,updated,an,link,illegal,argument,exception,is,thrown,instead,p,param,to,apply,the,new,settings,to,apply,param,target,the,target,settings,builder,that,the,updates,are,applied,to,all,keys,that,have,explicit,null,value,in,to,apply,will,be,removed,from,this,builder,param,updates,a,settings,builder,that,holds,all,updates,applied,to,target,param,type,a,free,text,string,to,allow,better,exceptions,messages,return,code,true,code,if,the,target,has,changed,otherwise,code,false,code;public,boolean,update,dynamic,settings,settings,to,apply,settings,builder,target,settings,builder,updates,string,type,return,update,settings,to,apply,target,updates,type,true
AbstractScopedSettings -> public boolean updateDynamicSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type);1544691774;Updates a target settings builder with new, updated or deleted settings from a given settings builder._<p>_Note: This method will only allow updates to dynamic settings. if a non-dynamic setting is updated an_{@link IllegalArgumentException} is thrown instead._</p>__@param toApply the new settings to apply_@param target the target settings builder that the updates are applied to. All keys that have explicit null value in toApply will be_removed from this builder_@param updates a settings builder that holds all updates applied to target_@param type a free text string to allow better exceptions messages_@return <code>true</code> if the target has changed otherwise <code>false</code>;public boolean updateDynamicSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type) {_        return updateSettings(toApply, target, updates, type, true)__    };updates,a,target,settings,builder,with,new,updated,or,deleted,settings,from,a,given,settings,builder,p,note,this,method,will,only,allow,updates,to,dynamic,settings,if,a,non,dynamic,setting,is,updated,an,link,illegal,argument,exception,is,thrown,instead,p,param,to,apply,the,new,settings,to,apply,param,target,the,target,settings,builder,that,the,updates,are,applied,to,all,keys,that,have,explicit,null,value,in,to,apply,will,be,removed,from,this,builder,param,updates,a,settings,builder,that,holds,all,updates,applied,to,target,param,type,a,free,text,string,to,allow,better,exceptions,messages,return,code,true,code,if,the,target,has,changed,otherwise,code,false,code;public,boolean,update,dynamic,settings,settings,to,apply,settings,builder,target,settings,builder,updates,string,type,return,update,settings,to,apply,target,updates,type,true
AbstractScopedSettings -> public boolean updateDynamicSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type);1546877578;Updates a target settings builder with new, updated or deleted settings from a given settings builder._<p>_Note: This method will only allow updates to dynamic settings. if a non-dynamic setting is updated an_{@link IllegalArgumentException} is thrown instead._</p>__@param toApply the new settings to apply_@param target the target settings builder that the updates are applied to. All keys that have explicit null value in toApply will be_removed from this builder_@param updates a settings builder that holds all updates applied to target_@param type a free text string to allow better exceptions messages_@return <code>true</code> if the target has changed otherwise <code>false</code>;public boolean updateDynamicSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type) {_        return updateSettings(toApply, target, updates, type, true)__    };updates,a,target,settings,builder,with,new,updated,or,deleted,settings,from,a,given,settings,builder,p,note,this,method,will,only,allow,updates,to,dynamic,settings,if,a,non,dynamic,setting,is,updated,an,link,illegal,argument,exception,is,thrown,instead,p,param,to,apply,the,new,settings,to,apply,param,target,the,target,settings,builder,that,the,updates,are,applied,to,all,keys,that,have,explicit,null,value,in,to,apply,will,be,removed,from,this,builder,param,updates,a,settings,builder,that,holds,all,updates,applied,to,target,param,type,a,free,text,string,to,allow,better,exceptions,messages,return,code,true,code,if,the,target,has,changed,otherwise,code,false,code;public,boolean,update,dynamic,settings,settings,to,apply,settings,builder,target,settings,builder,updates,string,type,return,update,settings,to,apply,target,updates,type,true
AbstractScopedSettings -> public boolean updateDynamicSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type);1548270339;Updates a target settings builder with new, updated or deleted settings from a given settings builder._<p>_Note: This method will only allow updates to dynamic settings. if a non-dynamic setting is updated an_{@link IllegalArgumentException} is thrown instead._</p>__@param toApply the new settings to apply_@param target the target settings builder that the updates are applied to. All keys that have explicit null value in toApply will be_removed from this builder_@param updates a settings builder that holds all updates applied to target_@param type a free text string to allow better exceptions messages_@return <code>true</code> if the target has changed otherwise <code>false</code>;public boolean updateDynamicSettings(Settings toApply, Settings.Builder target, Settings.Builder updates, String type) {_        return updateSettings(toApply, target, updates, type, true)__    };updates,a,target,settings,builder,with,new,updated,or,deleted,settings,from,a,given,settings,builder,p,note,this,method,will,only,allow,updates,to,dynamic,settings,if,a,non,dynamic,setting,is,updated,an,link,illegal,argument,exception,is,thrown,instead,p,param,to,apply,the,new,settings,to,apply,param,target,the,target,settings,builder,that,the,updates,are,applied,to,all,keys,that,have,explicit,null,value,in,to,apply,will,be,removed,from,this,builder,param,updates,a,settings,builder,that,holds,all,updates,applied,to,target,param,type,a,free,text,string,to,allow,better,exceptions,messages,return,code,true,code,if,the,target,has,changed,otherwise,code,false,code;public,boolean,update,dynamic,settings,settings,to,apply,settings,builder,target,settings,builder,updates,string,type,return,update,settings,to,apply,target,updates,type,true
AbstractScopedSettings -> void validate(final String key, final Settings settings, final boolean validateDependencies);1528904315;Validates that the settings is valid.__@param key the key of the setting to validate_@param settings the settings_@param validateDependencies true if dependent settings should be validated_@throws IllegalArgumentException if the setting is invalid;void validate(final String key, final Settings settings, final boolean validateDependencies) {_        validate(key, settings, validateDependencies, false)__    };validates,that,the,settings,is,valid,param,key,the,key,of,the,setting,to,validate,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,throws,illegal,argument,exception,if,the,setting,is,invalid;void,validate,final,string,key,final,settings,settings,final,boolean,validate,dependencies,validate,key,settings,validate,dependencies,false
AbstractScopedSettings -> void validate(final String key, final Settings settings, final boolean validateDependencies);1531179852;Validates that the settings is valid.__@param key the key of the setting to validate_@param settings the settings_@param validateDependencies true if dependent settings should be validated_@throws IllegalArgumentException if the setting is invalid;void validate(final String key, final Settings settings, final boolean validateDependencies) {_        validate(key, settings, validateDependencies, false)__    };validates,that,the,settings,is,valid,param,key,the,key,of,the,setting,to,validate,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,throws,illegal,argument,exception,if,the,setting,is,invalid;void,validate,final,string,key,final,settings,settings,final,boolean,validate,dependencies,validate,key,settings,validate,dependencies,false
AbstractScopedSettings -> void validate(final String key, final Settings settings, final boolean validateDependencies);1535046779;Validates that the settings is valid.__@param key the key of the setting to validate_@param settings the settings_@param validateDependencies true if dependent settings should be validated_@throws IllegalArgumentException if the setting is invalid;void validate(final String key, final Settings settings, final boolean validateDependencies) {_        validate(key, settings, validateDependencies, false)__    };validates,that,the,settings,is,valid,param,key,the,key,of,the,setting,to,validate,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,throws,illegal,argument,exception,if,the,setting,is,invalid;void,validate,final,string,key,final,settings,settings,final,boolean,validate,dependencies,validate,key,settings,validate,dependencies,false
AbstractScopedSettings -> void validate(final String key, final Settings settings, final boolean validateDependencies);1536137328;Validates that the settings is valid.__@param key the key of the setting to validate_@param settings the settings_@param validateDependencies true if dependent settings should be validated_@throws IllegalArgumentException if the setting is invalid;void validate(final String key, final Settings settings, final boolean validateDependencies) {_        validate(key, settings, validateDependencies, false)__    };validates,that,the,settings,is,valid,param,key,the,key,of,the,setting,to,validate,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,throws,illegal,argument,exception,if,the,setting,is,invalid;void,validate,final,string,key,final,settings,settings,final,boolean,validate,dependencies,validate,key,settings,validate,dependencies,false
AbstractScopedSettings -> void validate(final String key, final Settings settings, final boolean validateDependencies);1536314350;Validates that the settings is valid.__@param key the key of the setting to validate_@param settings the settings_@param validateDependencies true if dependent settings should be validated_@throws IllegalArgumentException if the setting is invalid;void validate(final String key, final Settings settings, final boolean validateDependencies) {_        validate(key, settings, validateDependencies, false)__    };validates,that,the,settings,is,valid,param,key,the,key,of,the,setting,to,validate,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,throws,illegal,argument,exception,if,the,setting,is,invalid;void,validate,final,string,key,final,settings,settings,final,boolean,validate,dependencies,validate,key,settings,validate,dependencies,false
AbstractScopedSettings -> void validate(final String key, final Settings settings, final boolean validateDependencies);1536611444;Validates that the settings is valid.__@param key the key of the setting to validate_@param settings the settings_@param validateDependencies true if dependent settings should be validated_@throws IllegalArgumentException if the setting is invalid;void validate(final String key, final Settings settings, final boolean validateDependencies) {_        validate(key, settings, validateDependencies, false)__    };validates,that,the,settings,is,valid,param,key,the,key,of,the,setting,to,validate,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,throws,illegal,argument,exception,if,the,setting,is,invalid;void,validate,final,string,key,final,settings,settings,final,boolean,validate,dependencies,validate,key,settings,validate,dependencies,false
AbstractScopedSettings -> void validate(final String key, final Settings settings, final boolean validateDependencies);1536828374;Validates that the settings is valid.__@param key the key of the setting to validate_@param settings the settings_@param validateDependencies true if dependent settings should be validated_@throws IllegalArgumentException if the setting is invalid;void validate(final String key, final Settings settings, final boolean validateDependencies) {_        validate(key, settings, validateDependencies, false)__    };validates,that,the,settings,is,valid,param,key,the,key,of,the,setting,to,validate,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,throws,illegal,argument,exception,if,the,setting,is,invalid;void,validate,final,string,key,final,settings,settings,final,boolean,validate,dependencies,validate,key,settings,validate,dependencies,false
AbstractScopedSettings -> void validate(final String key, final Settings settings, final boolean validateDependencies);1539951844;Validates that the settings is valid.__@param key the key of the setting to validate_@param settings the settings_@param validateDependencies true if dependent settings should be validated_@throws IllegalArgumentException if the setting is invalid;void validate(final String key, final Settings settings, final boolean validateDependencies) {_        validate(key, settings, validateDependencies, false)__    };validates,that,the,settings,is,valid,param,key,the,key,of,the,setting,to,validate,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,throws,illegal,argument,exception,if,the,setting,is,invalid;void,validate,final,string,key,final,settings,settings,final,boolean,validate,dependencies,validate,key,settings,validate,dependencies,false
AbstractScopedSettings -> void validate(final String key, final Settings settings, final boolean validateDependencies);1541008027;Validates that the settings is valid.__@param key the key of the setting to validate_@param settings the settings_@param validateDependencies true if dependent settings should be validated_@throws IllegalArgumentException if the setting is invalid;void validate(final String key, final Settings settings, final boolean validateDependencies) {_        validate(key, settings, validateDependencies, false)__    };validates,that,the,settings,is,valid,param,key,the,key,of,the,setting,to,validate,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,throws,illegal,argument,exception,if,the,setting,is,invalid;void,validate,final,string,key,final,settings,settings,final,boolean,validate,dependencies,validate,key,settings,validate,dependencies,false
AbstractScopedSettings -> void validate(final String key, final Settings settings, final boolean validateDependencies);1541092382;Validates that the settings is valid.__@param key the key of the setting to validate_@param settings the settings_@param validateDependencies true if dependent settings should be validated_@throws IllegalArgumentException if the setting is invalid;void validate(final String key, final Settings settings, final boolean validateDependencies) {_        validate(key, settings, validateDependencies, false)__    };validates,that,the,settings,is,valid,param,key,the,key,of,the,setting,to,validate,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,throws,illegal,argument,exception,if,the,setting,is,invalid;void,validate,final,string,key,final,settings,settings,final,boolean,validate,dependencies,validate,key,settings,validate,dependencies,false
AbstractScopedSettings -> void validate(final String key, final Settings settings, final boolean validateDependencies);1542402632;Validates that the settings is valid.__@param key the key of the setting to validate_@param settings the settings_@param validateDependencies true if dependent settings should be validated_@throws IllegalArgumentException if the setting is invalid;void validate(final String key, final Settings settings, final boolean validateDependencies) {_        validate(key, settings, validateDependencies, false)__    };validates,that,the,settings,is,valid,param,key,the,key,of,the,setting,to,validate,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,throws,illegal,argument,exception,if,the,setting,is,invalid;void,validate,final,string,key,final,settings,settings,final,boolean,validate,dependencies,validate,key,settings,validate,dependencies,false
AbstractScopedSettings -> void validate(final String key, final Settings settings, final boolean validateDependencies);1544081506;Validates that the settings is valid.__@param key the key of the setting to validate_@param settings the settings_@param validateDependencies true if dependent settings should be validated_@throws IllegalArgumentException if the setting is invalid;void validate(final String key, final Settings settings, final boolean validateDependencies) {_        validate(key, settings, validateDependencies, false)__    };validates,that,the,settings,is,valid,param,key,the,key,of,the,setting,to,validate,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,throws,illegal,argument,exception,if,the,setting,is,invalid;void,validate,final,string,key,final,settings,settings,final,boolean,validate,dependencies,validate,key,settings,validate,dependencies,false
AbstractScopedSettings -> void validate(final String key, final Settings settings, final boolean validateDependencies);1544691774;Validates that the settings is valid.__@param key the key of the setting to validate_@param settings the settings_@param validateDependencies true if dependent settings should be validated_@throws IllegalArgumentException if the setting is invalid;void validate(final String key, final Settings settings, final boolean validateDependencies) {_        validate(key, settings, validateDependencies, false)__    };validates,that,the,settings,is,valid,param,key,the,key,of,the,setting,to,validate,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,throws,illegal,argument,exception,if,the,setting,is,invalid;void,validate,final,string,key,final,settings,settings,final,boolean,validate,dependencies,validate,key,settings,validate,dependencies,false
AbstractScopedSettings -> void validate(final String key, final Settings settings, final boolean validateDependencies);1546877578;Validates that the settings is valid.__@param key the key of the setting to validate_@param settings the settings_@param validateDependencies true if dependent settings should be validated_@throws IllegalArgumentException if the setting is invalid;void validate(final String key, final Settings settings, final boolean validateDependencies) {_        validate(key, settings, validateDependencies, false)__    };validates,that,the,settings,is,valid,param,key,the,key,of,the,setting,to,validate,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,throws,illegal,argument,exception,if,the,setting,is,invalid;void,validate,final,string,key,final,settings,settings,final,boolean,validate,dependencies,validate,key,settings,validate,dependencies,false
AbstractScopedSettings -> void validate(final String key, final Settings settings, final boolean validateDependencies);1548270339;Validates that the settings is valid.__@param key the key of the setting to validate_@param settings the settings_@param validateDependencies true if dependent settings should be validated_@throws IllegalArgumentException if the setting is invalid;void validate(final String key, final Settings settings, final boolean validateDependencies) {_        validate(key, settings, validateDependencies, false)__    };validates,that,the,settings,is,valid,param,key,the,key,of,the,setting,to,validate,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,throws,illegal,argument,exception,if,the,setting,is,invalid;void,validate,final,string,key,final,settings,settings,final,boolean,validate,dependencies,validate,key,settings,validate,dependencies,false
AbstractScopedSettings -> public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b, BiConsumer<A, B> consumer);1524684173;Adds a settings consumer that accepts the values for two settings._See {@link #addSettingsUpdateConsumer(Setting, Setting, BiConsumer, BiConsumer)} for details.;public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b, BiConsumer<A, B> consumer) {_        addSettingsUpdateConsumer(a, b, consumer, (i, j) -> {} )__    };adds,a,settings,consumer,that,accepts,the,values,for,two,settings,see,link,add,settings,update,consumer,setting,setting,bi,consumer,bi,consumer,for,details;public,synchronized,a,b,void,add,settings,update,consumer,setting,a,a,setting,b,b,bi,consumer,a,b,consumer,add,settings,update,consumer,a,b,consumer,i,j
AbstractScopedSettings -> public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b, BiConsumer<A, B> consumer);1528904315;Adds a settings consumer that accepts the values for two settings._See {@link #addSettingsUpdateConsumer(Setting, Setting, BiConsumer, BiConsumer)} for details.;public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b, BiConsumer<A, B> consumer) {_        addSettingsUpdateConsumer(a, b, consumer, (i, j) -> {} )__    };adds,a,settings,consumer,that,accepts,the,values,for,two,settings,see,link,add,settings,update,consumer,setting,setting,bi,consumer,bi,consumer,for,details;public,synchronized,a,b,void,add,settings,update,consumer,setting,a,a,setting,b,b,bi,consumer,a,b,consumer,add,settings,update,consumer,a,b,consumer,i,j
AbstractScopedSettings -> public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b, BiConsumer<A, B> consumer);1531179852;Adds a settings consumer that accepts the values for two settings._See {@link #addSettingsUpdateConsumer(Setting, Setting, BiConsumer, BiConsumer)} for details.;public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b, BiConsumer<A, B> consumer) {_        addSettingsUpdateConsumer(a, b, consumer, (i, j) -> {} )__    };adds,a,settings,consumer,that,accepts,the,values,for,two,settings,see,link,add,settings,update,consumer,setting,setting,bi,consumer,bi,consumer,for,details;public,synchronized,a,b,void,add,settings,update,consumer,setting,a,a,setting,b,b,bi,consumer,a,b,consumer,add,settings,update,consumer,a,b,consumer,i,j
AbstractScopedSettings -> public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b, BiConsumer<A, B> consumer);1535046779;Adds a settings consumer that accepts the values for two settings._See {@link #addSettingsUpdateConsumer(Setting, Setting, BiConsumer, BiConsumer)} for details.;public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b, BiConsumer<A, B> consumer) {_        addSettingsUpdateConsumer(a, b, consumer, (i, j) -> {} )__    };adds,a,settings,consumer,that,accepts,the,values,for,two,settings,see,link,add,settings,update,consumer,setting,setting,bi,consumer,bi,consumer,for,details;public,synchronized,a,b,void,add,settings,update,consumer,setting,a,a,setting,b,b,bi,consumer,a,b,consumer,add,settings,update,consumer,a,b,consumer,i,j
AbstractScopedSettings -> public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b, BiConsumer<A, B> consumer);1536137328;Adds a settings consumer that accepts the values for two settings._See {@link #addSettingsUpdateConsumer(Setting, Setting, BiConsumer, BiConsumer)} for details.;public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b, BiConsumer<A, B> consumer) {_        addSettingsUpdateConsumer(a, b, consumer, (i, j) -> {} )__    };adds,a,settings,consumer,that,accepts,the,values,for,two,settings,see,link,add,settings,update,consumer,setting,setting,bi,consumer,bi,consumer,for,details;public,synchronized,a,b,void,add,settings,update,consumer,setting,a,a,setting,b,b,bi,consumer,a,b,consumer,add,settings,update,consumer,a,b,consumer,i,j
AbstractScopedSettings -> public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b, BiConsumer<A, B> consumer);1536314350;Adds a settings consumer that accepts the values for two settings._See {@link #addSettingsUpdateConsumer(Setting, Setting, BiConsumer, BiConsumer)} for details.;public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b, BiConsumer<A, B> consumer) {_        addSettingsUpdateConsumer(a, b, consumer, (i, j) -> {} )__    };adds,a,settings,consumer,that,accepts,the,values,for,two,settings,see,link,add,settings,update,consumer,setting,setting,bi,consumer,bi,consumer,for,details;public,synchronized,a,b,void,add,settings,update,consumer,setting,a,a,setting,b,b,bi,consumer,a,b,consumer,add,settings,update,consumer,a,b,consumer,i,j
AbstractScopedSettings -> public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b, BiConsumer<A, B> consumer);1536611444;Adds a settings consumer that accepts the values for two settings._See {@link #addSettingsUpdateConsumer(Setting, Setting, BiConsumer, BiConsumer)} for details.;public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b, BiConsumer<A, B> consumer) {_        addSettingsUpdateConsumer(a, b, consumer, (i, j) -> {} )__    };adds,a,settings,consumer,that,accepts,the,values,for,two,settings,see,link,add,settings,update,consumer,setting,setting,bi,consumer,bi,consumer,for,details;public,synchronized,a,b,void,add,settings,update,consumer,setting,a,a,setting,b,b,bi,consumer,a,b,consumer,add,settings,update,consumer,a,b,consumer,i,j
AbstractScopedSettings -> public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b, BiConsumer<A, B> consumer);1536828374;Adds a settings consumer that accepts the values for two settings._See {@link #addSettingsUpdateConsumer(Setting, Setting, BiConsumer, BiConsumer)} for details.;public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b, BiConsumer<A, B> consumer) {_        addSettingsUpdateConsumer(a, b, consumer, (i, j) -> {} )__    };adds,a,settings,consumer,that,accepts,the,values,for,two,settings,see,link,add,settings,update,consumer,setting,setting,bi,consumer,bi,consumer,for,details;public,synchronized,a,b,void,add,settings,update,consumer,setting,a,a,setting,b,b,bi,consumer,a,b,consumer,add,settings,update,consumer,a,b,consumer,i,j
AbstractScopedSettings -> public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b, BiConsumer<A, B> consumer);1539951844;Adds a settings consumer that accepts the values for two settings._See {@link #addSettingsUpdateConsumer(Setting, Setting, BiConsumer, BiConsumer)} for details.;public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b, BiConsumer<A, B> consumer) {_        addSettingsUpdateConsumer(a, b, consumer, (i, j) -> {} )__    };adds,a,settings,consumer,that,accepts,the,values,for,two,settings,see,link,add,settings,update,consumer,setting,setting,bi,consumer,bi,consumer,for,details;public,synchronized,a,b,void,add,settings,update,consumer,setting,a,a,setting,b,b,bi,consumer,a,b,consumer,add,settings,update,consumer,a,b,consumer,i,j
AbstractScopedSettings -> public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b, BiConsumer<A, B> consumer);1541008027;Adds a settings consumer that accepts the values for two settings._See {@link #addSettingsUpdateConsumer(Setting, Setting, BiConsumer, BiConsumer)} for details.;public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b, BiConsumer<A, B> consumer) {_        addSettingsUpdateConsumer(a, b, consumer, (i, j) -> {} )__    };adds,a,settings,consumer,that,accepts,the,values,for,two,settings,see,link,add,settings,update,consumer,setting,setting,bi,consumer,bi,consumer,for,details;public,synchronized,a,b,void,add,settings,update,consumer,setting,a,a,setting,b,b,bi,consumer,a,b,consumer,add,settings,update,consumer,a,b,consumer,i,j
AbstractScopedSettings -> public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b, BiConsumer<A, B> consumer);1541092382;Adds a settings consumer that accepts the values for two settings._See {@link #addSettingsUpdateConsumer(Setting, Setting, BiConsumer, BiConsumer)} for details.;public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b, BiConsumer<A, B> consumer) {_        addSettingsUpdateConsumer(a, b, consumer, (i, j) -> {} )__    };adds,a,settings,consumer,that,accepts,the,values,for,two,settings,see,link,add,settings,update,consumer,setting,setting,bi,consumer,bi,consumer,for,details;public,synchronized,a,b,void,add,settings,update,consumer,setting,a,a,setting,b,b,bi,consumer,a,b,consumer,add,settings,update,consumer,a,b,consumer,i,j
AbstractScopedSettings -> public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b, BiConsumer<A, B> consumer);1542402632;Adds a settings consumer that accepts the values for two settings._See {@link #addSettingsUpdateConsumer(Setting, Setting, BiConsumer, BiConsumer)} for details.;public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b, BiConsumer<A, B> consumer) {_        addSettingsUpdateConsumer(a, b, consumer, (i, j) -> {} )__    };adds,a,settings,consumer,that,accepts,the,values,for,two,settings,see,link,add,settings,update,consumer,setting,setting,bi,consumer,bi,consumer,for,details;public,synchronized,a,b,void,add,settings,update,consumer,setting,a,a,setting,b,b,bi,consumer,a,b,consumer,add,settings,update,consumer,a,b,consumer,i,j
AbstractScopedSettings -> public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b, BiConsumer<A, B> consumer);1544081506;Adds a settings consumer that accepts the values for two settings._See {@link #addSettingsUpdateConsumer(Setting, Setting, BiConsumer, BiConsumer)} for details.;public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b, BiConsumer<A, B> consumer) {_        addSettingsUpdateConsumer(a, b, consumer, (i, j) -> {} )__    };adds,a,settings,consumer,that,accepts,the,values,for,two,settings,see,link,add,settings,update,consumer,setting,setting,bi,consumer,bi,consumer,for,details;public,synchronized,a,b,void,add,settings,update,consumer,setting,a,a,setting,b,b,bi,consumer,a,b,consumer,add,settings,update,consumer,a,b,consumer,i,j
AbstractScopedSettings -> public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b, BiConsumer<A, B> consumer);1544691774;Adds a settings consumer that accepts the values for two settings._See {@link #addSettingsUpdateConsumer(Setting, Setting, BiConsumer, BiConsumer)} for details.;public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b, BiConsumer<A, B> consumer) {_        addSettingsUpdateConsumer(a, b, consumer, (i, j) -> {} )__    };adds,a,settings,consumer,that,accepts,the,values,for,two,settings,see,link,add,settings,update,consumer,setting,setting,bi,consumer,bi,consumer,for,details;public,synchronized,a,b,void,add,settings,update,consumer,setting,a,a,setting,b,b,bi,consumer,a,b,consumer,add,settings,update,consumer,a,b,consumer,i,j
AbstractScopedSettings -> public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b, BiConsumer<A, B> consumer);1546877578;Adds a settings consumer that accepts the values for two settings._See {@link #addSettingsUpdateConsumer(Setting, Setting, BiConsumer, BiConsumer)} for details.;public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b, BiConsumer<A, B> consumer) {_        addSettingsUpdateConsumer(a, b, consumer, (i, j) -> {} )__    };adds,a,settings,consumer,that,accepts,the,values,for,two,settings,see,link,add,settings,update,consumer,setting,setting,bi,consumer,bi,consumer,for,details;public,synchronized,a,b,void,add,settings,update,consumer,setting,a,a,setting,b,b,bi,consumer,a,b,consumer,add,settings,update,consumer,a,b,consumer,i,j
AbstractScopedSettings -> public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b, BiConsumer<A, B> consumer);1548270339;Adds a settings consumer that accepts the values for two settings._See {@link #addSettingsUpdateConsumer(Setting, Setting, BiConsumer, BiConsumer)} for details.;public synchronized <A, B> void addSettingsUpdateConsumer(Setting<A> a, Setting<B> b, BiConsumer<A, B> consumer) {_        addSettingsUpdateConsumer(a, b, consumer, (i, j) -> {} )__    };adds,a,settings,consumer,that,accepts,the,values,for,two,settings,see,link,add,settings,update,consumer,setting,setting,bi,consumer,bi,consumer,for,details;public,synchronized,a,b,void,add,settings,update,consumer,setting,a,a,setting,b,b,bi,consumer,a,b,consumer,add,settings,update,consumer,a,b,consumer,i,j
AbstractScopedSettings -> public final void validate(final Settings settings, final boolean validateDependencies);1524684173;Validates that all settings are registered and valid.__@param settings             the settings to validate_@param validateDependencies true if dependent settings should be validated_@see Setting#getSettingsDependencies(String);public final void validate(final Settings settings, final boolean validateDependencies) {_        validate(settings, validateDependencies, false, false)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,to,validate,param,validate,dependencies,true,if,dependent,settings,should,be,validated,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,validate,settings,validate,dependencies,false,false
AbstractScopedSettings -> public final void validate(final Settings settings, final boolean validateDependencies);1528904315;Validates that all settings are registered and valid.__@param settings             the settings to validate_@param validateDependencies true if dependent settings should be validated_@see Setting#getSettingsDependencies(String);public final void validate(final Settings settings, final boolean validateDependencies) {_        validate(settings, validateDependencies, false, false)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,to,validate,param,validate,dependencies,true,if,dependent,settings,should,be,validated,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,validate,settings,validate,dependencies,false,false
AbstractScopedSettings -> public final void validate(final Settings settings, final boolean validateDependencies);1531179852;Validates that all settings are registered and valid.__@param settings             the settings to validate_@param validateDependencies true if dependent settings should be validated_@see Setting#getSettingsDependencies(String);public final void validate(final Settings settings, final boolean validateDependencies) {_        validate(settings, validateDependencies, false, false)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,to,validate,param,validate,dependencies,true,if,dependent,settings,should,be,validated,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,validate,settings,validate,dependencies,false,false
AbstractScopedSettings -> public final void validate(final Settings settings, final boolean validateDependencies);1535046779;Validates that all settings are registered and valid.__@param settings             the settings to validate_@param validateDependencies true if dependent settings should be validated_@see Setting#getSettingsDependencies(String);public final void validate(final Settings settings, final boolean validateDependencies) {_        validate(settings, validateDependencies, false, false)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,to,validate,param,validate,dependencies,true,if,dependent,settings,should,be,validated,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,validate,settings,validate,dependencies,false,false
AbstractScopedSettings -> public final void validate(final Settings settings, final boolean validateDependencies);1536137328;Validates that all settings are registered and valid.__@param settings             the settings to validate_@param validateDependencies true if dependent settings should be validated_@see Setting#getSettingsDependencies(String);public final void validate(final Settings settings, final boolean validateDependencies) {_        validate(settings, validateDependencies, false, false)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,to,validate,param,validate,dependencies,true,if,dependent,settings,should,be,validated,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,validate,settings,validate,dependencies,false,false
AbstractScopedSettings -> public final void validate(final Settings settings, final boolean validateDependencies);1536314350;Validates that all settings are registered and valid.__@param settings             the settings to validate_@param validateDependencies true if dependent settings should be validated_@see Setting#getSettingsDependencies(String);public final void validate(final Settings settings, final boolean validateDependencies) {_        validate(settings, validateDependencies, false, false)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,to,validate,param,validate,dependencies,true,if,dependent,settings,should,be,validated,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,validate,settings,validate,dependencies,false,false
AbstractScopedSettings -> public final void validate(final Settings settings, final boolean validateDependencies);1536611444;Validates that all settings are registered and valid.__@param settings             the settings to validate_@param validateDependencies true if dependent settings should be validated_@see Setting#getSettingsDependencies(String);public final void validate(final Settings settings, final boolean validateDependencies) {_        validate(settings, validateDependencies, false, false)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,to,validate,param,validate,dependencies,true,if,dependent,settings,should,be,validated,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,validate,settings,validate,dependencies,false,false
AbstractScopedSettings -> public final void validate(final Settings settings, final boolean validateDependencies);1536828374;Validates that all settings are registered and valid.__@param settings             the settings to validate_@param validateDependencies true if dependent settings should be validated_@see Setting#getSettingsDependencies(String);public final void validate(final Settings settings, final boolean validateDependencies) {_        validate(settings, validateDependencies, false, false)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,to,validate,param,validate,dependencies,true,if,dependent,settings,should,be,validated,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,validate,settings,validate,dependencies,false,false
AbstractScopedSettings -> public final void validate(final Settings settings, final boolean validateDependencies);1539951844;Validates that all settings are registered and valid.__@param settings             the settings to validate_@param validateDependencies true if dependent settings should be validated_@see Setting#getSettingsDependencies(String);public final void validate(final Settings settings, final boolean validateDependencies) {_        validate(settings, validateDependencies, false, false)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,to,validate,param,validate,dependencies,true,if,dependent,settings,should,be,validated,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,validate,settings,validate,dependencies,false,false
AbstractScopedSettings -> public final void validate(final Settings settings, final boolean validateDependencies);1541008027;Validates that all settings are registered and valid.__@param settings             the settings to validate_@param validateDependencies true if dependent settings should be validated_@see Setting#getSettingsDependencies(String);public final void validate(final Settings settings, final boolean validateDependencies) {_        validate(settings, validateDependencies, false, false)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,to,validate,param,validate,dependencies,true,if,dependent,settings,should,be,validated,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,validate,settings,validate,dependencies,false,false
AbstractScopedSettings -> public final void validate(final Settings settings, final boolean validateDependencies);1541092382;Validates that all settings are registered and valid.__@param settings             the settings to validate_@param validateDependencies true if dependent settings should be validated_@see Setting#getSettingsDependencies(String);public final void validate(final Settings settings, final boolean validateDependencies) {_        validate(settings, validateDependencies, false, false)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,to,validate,param,validate,dependencies,true,if,dependent,settings,should,be,validated,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,validate,settings,validate,dependencies,false,false
AbstractScopedSettings -> public final void validate(final Settings settings, final boolean validateDependencies);1542402632;Validates that all settings are registered and valid.__@param settings             the settings to validate_@param validateDependencies true if dependent settings should be validated_@see Setting#getSettingsDependencies(String);public final void validate(final Settings settings, final boolean validateDependencies) {_        validate(settings, validateDependencies, false, false)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,to,validate,param,validate,dependencies,true,if,dependent,settings,should,be,validated,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,validate,settings,validate,dependencies,false,false
AbstractScopedSettings -> public final void validate(final Settings settings, final boolean validateDependencies);1544081506;Validates that all settings are registered and valid.__@param settings             the settings to validate_@param validateDependencies true if dependent settings should be validated_@see Setting#getSettingsDependencies(String);public final void validate(final Settings settings, final boolean validateDependencies) {_        validate(settings, validateDependencies, false, false)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,to,validate,param,validate,dependencies,true,if,dependent,settings,should,be,validated,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,validate,settings,validate,dependencies,false,false
AbstractScopedSettings -> public final void validate(final Settings settings, final boolean validateDependencies);1544691774;Validates that all settings are registered and valid.__@param settings             the settings to validate_@param validateDependencies true if dependent settings should be validated_@see Setting#getSettingsDependencies(String);public final void validate(final Settings settings, final boolean validateDependencies) {_        validate(settings, validateDependencies, false, false)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,to,validate,param,validate,dependencies,true,if,dependent,settings,should,be,validated,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,validate,settings,validate,dependencies,false,false
AbstractScopedSettings -> public final void validate(final Settings settings, final boolean validateDependencies);1546877578;Validates that all settings are registered and valid.__@param settings             the settings to validate_@param validateDependencies true if dependent settings should be validated_@see Setting#getSettingsDependencies(String);public final void validate(final Settings settings, final boolean validateDependencies) {_        validate(settings, validateDependencies, false, false)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,to,validate,param,validate,dependencies,true,if,dependent,settings,should,be,validated,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,validate,settings,validate,dependencies,false,false
AbstractScopedSettings -> public final void validate(final Settings settings, final boolean validateDependencies);1548270339;Validates that all settings are registered and valid.__@param settings             the settings to validate_@param validateDependencies true if dependent settings should be validated_@see Setting#getSettingsDependencies(String);public final void validate(final Settings settings, final boolean validateDependencies) {_        validate(settings, validateDependencies, false, false)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,to,validate,param,validate,dependencies,true,if,dependent,settings,should,be,validated,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,validate,settings,validate,dependencies,false,false
AbstractScopedSettings -> public final Setting<?> get(String key);1524684173;Returns the {@link Setting} for the given key or <code>null</code> if the setting can not be found.;public final Setting<?> get(String key) {_        Setting<?> raw = getRaw(key)__        if (raw == null) {_            return null__        } if (raw.hasComplexMatcher()) {_            return raw.getConcreteSetting(key)__        } else {_            return raw__        }_    };returns,the,link,setting,for,the,given,key,or,code,null,code,if,the,setting,can,not,be,found;public,final,setting,get,string,key,setting,raw,get,raw,key,if,raw,null,return,null,if,raw,has,complex,matcher,return,raw,get,concrete,setting,key,else,return,raw
AbstractScopedSettings -> public final Setting<?> get(String key);1528904315;Returns the {@link Setting} for the given key or <code>null</code> if the setting can not be found.;public final Setting<?> get(String key) {_        Setting<?> raw = getRaw(key)__        if (raw == null) {_            return null__        } if (raw.hasComplexMatcher()) {_            return raw.getConcreteSetting(key)__        } else {_            return raw__        }_    };returns,the,link,setting,for,the,given,key,or,code,null,code,if,the,setting,can,not,be,found;public,final,setting,get,string,key,setting,raw,get,raw,key,if,raw,null,return,null,if,raw,has,complex,matcher,return,raw,get,concrete,setting,key,else,return,raw
AbstractScopedSettings -> public final Setting<?> get(String key);1531179852;Returns the {@link Setting} for the given key or <code>null</code> if the setting can not be found.;public final Setting<?> get(String key) {_        Setting<?> raw = getRaw(key)__        if (raw == null) {_            return null__        } if (raw.hasComplexMatcher()) {_            return raw.getConcreteSetting(key)__        } else {_            return raw__        }_    };returns,the,link,setting,for,the,given,key,or,code,null,code,if,the,setting,can,not,be,found;public,final,setting,get,string,key,setting,raw,get,raw,key,if,raw,null,return,null,if,raw,has,complex,matcher,return,raw,get,concrete,setting,key,else,return,raw
AbstractScopedSettings -> public final Setting<?> get(String key);1535046779;Returns the {@link Setting} for the given key or <code>null</code> if the setting can not be found.;public final Setting<?> get(String key) {_        Setting<?> raw = getRaw(key)__        if (raw == null) {_            return null__        } if (raw.hasComplexMatcher()) {_            return raw.getConcreteSetting(key)__        } else {_            return raw__        }_    };returns,the,link,setting,for,the,given,key,or,code,null,code,if,the,setting,can,not,be,found;public,final,setting,get,string,key,setting,raw,get,raw,key,if,raw,null,return,null,if,raw,has,complex,matcher,return,raw,get,concrete,setting,key,else,return,raw
AbstractScopedSettings -> public final Setting<?> get(String key);1536137328;Returns the {@link Setting} for the given key or <code>null</code> if the setting can not be found.;public final Setting<?> get(String key) {_        Setting<?> raw = getRaw(key)__        if (raw == null) {_            return null__        } if (raw.hasComplexMatcher()) {_            return raw.getConcreteSetting(key)__        } else {_            return raw__        }_    };returns,the,link,setting,for,the,given,key,or,code,null,code,if,the,setting,can,not,be,found;public,final,setting,get,string,key,setting,raw,get,raw,key,if,raw,null,return,null,if,raw,has,complex,matcher,return,raw,get,concrete,setting,key,else,return,raw
AbstractScopedSettings -> public final Setting<?> get(String key);1536314350;Returns the {@link Setting} for the given key or <code>null</code> if the setting can not be found.;public final Setting<?> get(String key) {_        Setting<?> raw = getRaw(key)__        if (raw == null) {_            return null__        } if (raw.hasComplexMatcher()) {_            return raw.getConcreteSetting(key)__        } else {_            return raw__        }_    };returns,the,link,setting,for,the,given,key,or,code,null,code,if,the,setting,can,not,be,found;public,final,setting,get,string,key,setting,raw,get,raw,key,if,raw,null,return,null,if,raw,has,complex,matcher,return,raw,get,concrete,setting,key,else,return,raw
AbstractScopedSettings -> public final Setting<?> get(String key);1536611444;Returns the {@link Setting} for the given key or <code>null</code> if the setting can not be found.;public final Setting<?> get(String key) {_        Setting<?> raw = getRaw(key)__        if (raw == null) {_            return null__        } if (raw.hasComplexMatcher()) {_            return raw.getConcreteSetting(key)__        } else {_            return raw__        }_    };returns,the,link,setting,for,the,given,key,or,code,null,code,if,the,setting,can,not,be,found;public,final,setting,get,string,key,setting,raw,get,raw,key,if,raw,null,return,null,if,raw,has,complex,matcher,return,raw,get,concrete,setting,key,else,return,raw
AbstractScopedSettings -> public final Setting<?> get(String key);1536828374;Returns the {@link Setting} for the given key or <code>null</code> if the setting can not be found.;public final Setting<?> get(String key) {_        Setting<?> raw = getRaw(key)__        if (raw == null) {_            return null__        } if (raw.hasComplexMatcher()) {_            return raw.getConcreteSetting(key)__        } else {_            return raw__        }_    };returns,the,link,setting,for,the,given,key,or,code,null,code,if,the,setting,can,not,be,found;public,final,setting,get,string,key,setting,raw,get,raw,key,if,raw,null,return,null,if,raw,has,complex,matcher,return,raw,get,concrete,setting,key,else,return,raw
AbstractScopedSettings -> public final Setting<?> get(String key);1539951844;Returns the {@link Setting} for the given key or <code>null</code> if the setting can not be found.;public final Setting<?> get(String key) {_        Setting<?> raw = getRaw(key)__        if (raw == null) {_            return null__        } if (raw.hasComplexMatcher()) {_            return raw.getConcreteSetting(key)__        } else {_            return raw__        }_    };returns,the,link,setting,for,the,given,key,or,code,null,code,if,the,setting,can,not,be,found;public,final,setting,get,string,key,setting,raw,get,raw,key,if,raw,null,return,null,if,raw,has,complex,matcher,return,raw,get,concrete,setting,key,else,return,raw
AbstractScopedSettings -> public final Setting<?> get(String key);1541008027;Returns the {@link Setting} for the given key or <code>null</code> if the setting can not be found.;public final Setting<?> get(String key) {_        Setting<?> raw = getRaw(key)__        if (raw == null) {_            return null__        } if (raw.hasComplexMatcher()) {_            return raw.getConcreteSetting(key)__        } else {_            return raw__        }_    };returns,the,link,setting,for,the,given,key,or,code,null,code,if,the,setting,can,not,be,found;public,final,setting,get,string,key,setting,raw,get,raw,key,if,raw,null,return,null,if,raw,has,complex,matcher,return,raw,get,concrete,setting,key,else,return,raw
AbstractScopedSettings -> public final Setting<?> get(String key);1541092382;Returns the {@link Setting} for the given key or <code>null</code> if the setting can not be found.;public final Setting<?> get(String key) {_        Setting<?> raw = getRaw(key)__        if (raw == null) {_            return null__        } if (raw.hasComplexMatcher()) {_            return raw.getConcreteSetting(key)__        } else {_            return raw__        }_    };returns,the,link,setting,for,the,given,key,or,code,null,code,if,the,setting,can,not,be,found;public,final,setting,get,string,key,setting,raw,get,raw,key,if,raw,null,return,null,if,raw,has,complex,matcher,return,raw,get,concrete,setting,key,else,return,raw
AbstractScopedSettings -> public final Setting<?> get(String key);1542402632;Returns the {@link Setting} for the given key or <code>null</code> if the setting can not be found.;public final Setting<?> get(String key) {_        Setting<?> raw = getRaw(key)__        if (raw == null) {_            return null__        } if (raw.hasComplexMatcher()) {_            return raw.getConcreteSetting(key)__        } else {_            return raw__        }_    };returns,the,link,setting,for,the,given,key,or,code,null,code,if,the,setting,can,not,be,found;public,final,setting,get,string,key,setting,raw,get,raw,key,if,raw,null,return,null,if,raw,has,complex,matcher,return,raw,get,concrete,setting,key,else,return,raw
AbstractScopedSettings -> public final Setting<?> get(String key);1544081506;Returns the {@link Setting} for the given key or <code>null</code> if the setting can not be found.;public final Setting<?> get(String key) {_        Setting<?> raw = getRaw(key)__        if (raw == null) {_            return null__        } if (raw.hasComplexMatcher()) {_            return raw.getConcreteSetting(key)__        } else {_            return raw__        }_    };returns,the,link,setting,for,the,given,key,or,code,null,code,if,the,setting,can,not,be,found;public,final,setting,get,string,key,setting,raw,get,raw,key,if,raw,null,return,null,if,raw,has,complex,matcher,return,raw,get,concrete,setting,key,else,return,raw
AbstractScopedSettings -> public final Setting<?> get(String key);1544691774;Returns the {@link Setting} for the given key or <code>null</code> if the setting can not be found.;public final Setting<?> get(String key) {_        Setting<?> raw = getRaw(key)__        if (raw == null) {_            return null__        } if (raw.hasComplexMatcher()) {_            return raw.getConcreteSetting(key)__        } else {_            return raw__        }_    };returns,the,link,setting,for,the,given,key,or,code,null,code,if,the,setting,can,not,be,found;public,final,setting,get,string,key,setting,raw,get,raw,key,if,raw,null,return,null,if,raw,has,complex,matcher,return,raw,get,concrete,setting,key,else,return,raw
AbstractScopedSettings -> public final Setting<?> get(String key);1546877578;Returns the {@link Setting} for the given key or <code>null</code> if the setting can not be found.;public final Setting<?> get(String key) {_        Setting<?> raw = getRaw(key)__        if (raw == null) {_            return null__        } if (raw.hasComplexMatcher()) {_            return raw.getConcreteSetting(key)__        } else {_            return raw__        }_    };returns,the,link,setting,for,the,given,key,or,code,null,code,if,the,setting,can,not,be,found;public,final,setting,get,string,key,setting,raw,get,raw,key,if,raw,null,return,null,if,raw,has,complex,matcher,return,raw,get,concrete,setting,key,else,return,raw
AbstractScopedSettings -> public final Setting<?> get(String key);1548270339;Returns the {@link Setting} for the given key or <code>null</code> if the setting can not be found.;public final Setting<?> get(String key) {_        Setting<?> raw = getRaw(key)__        if (raw == null) {_            return null__        } if (raw.hasComplexMatcher()) {_            return raw.getConcreteSetting(key)__        } else {_            return raw__        }_    };returns,the,link,setting,for,the,given,key,or,code,null,code,if,the,setting,can,not,be,found;public,final,setting,get,string,key,setting,raw,get,raw,key,if,raw,null,return,null,if,raw,has,complex,matcher,return,raw,get,concrete,setting,key,else,return,raw
AbstractScopedSettings -> public final void validate(             final Settings settings,             final boolean validateDependencies,             final boolean ignorePrivateSettings,             final boolean ignoreArchivedSettings,             final boolean validateInternalOrPrivateIndex);1536137328;Validates that all settings are registered and valid.__@param settings                       the settings_@param validateDependencies           true if dependent settings should be validated_@param ignorePrivateSettings          true if private settings should be ignored during validation_@param ignoreArchivedSettings         true if archived settings should be ignored during validation_@param validateInternalOrPrivateIndex true if index internal settings should be validated_@see Setting#getSettingsDependencies(String);public final void validate(_            final Settings settings,_            final boolean validateDependencies,_            final boolean ignorePrivateSettings,_            final boolean ignoreArchivedSettings,_            final boolean validateInternalOrPrivateIndex) {_        final List<RuntimeException> exceptions = new ArrayList<>()__        for (final String key : settings.keySet()) { _            final Setting<?> setting = getRaw(key)__            if (((isPrivateSetting(key) || (setting != null && setting.isPrivateIndex())) && ignorePrivateSettings)) {_                continue__            }_            if (key.startsWith(ARCHIVED_SETTINGS_PREFIX) && ignoreArchivedSettings) {_                continue__            }_            try {_                validate(key, settings, validateDependencies, validateInternalOrPrivateIndex)__            } catch (final RuntimeException ex) {_                exceptions.add(ex)__            }_        }_        ExceptionsHelper.rethrowAndSuppress(exceptions)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,ignore,private,settings,true,if,private,settings,should,be,ignored,during,validation,param,ignore,archived,settings,true,if,archived,settings,should,be,ignored,during,validation,param,validate,internal,or,private,index,true,if,index,internal,settings,should,be,validated,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,final,boolean,ignore,private,settings,final,boolean,ignore,archived,settings,final,boolean,validate,internal,or,private,index,final,list,runtime,exception,exceptions,new,array,list,for,final,string,key,settings,key,set,final,setting,setting,get,raw,key,if,is,private,setting,key,setting,null,setting,is,private,index,ignore,private,settings,continue,if,key,starts,with,ignore,archived,settings,continue,try,validate,key,settings,validate,dependencies,validate,internal,or,private,index,catch,final,runtime,exception,ex,exceptions,add,ex,exceptions,helper,rethrow,and,suppress,exceptions
AbstractScopedSettings -> public final void validate(             final Settings settings,             final boolean validateDependencies,             final boolean ignorePrivateSettings,             final boolean ignoreArchivedSettings,             final boolean validateInternalOrPrivateIndex);1536314350;Validates that all settings are registered and valid.__@param settings                       the settings_@param validateDependencies           true if dependent settings should be validated_@param ignorePrivateSettings          true if private settings should be ignored during validation_@param ignoreArchivedSettings         true if archived settings should be ignored during validation_@param validateInternalOrPrivateIndex true if index internal settings should be validated_@see Setting#getSettingsDependencies(String);public final void validate(_            final Settings settings,_            final boolean validateDependencies,_            final boolean ignorePrivateSettings,_            final boolean ignoreArchivedSettings,_            final boolean validateInternalOrPrivateIndex) {_        final List<RuntimeException> exceptions = new ArrayList<>()__        for (final String key : settings.keySet()) { _            final Setting<?> setting = getRaw(key)__            if (((isPrivateSetting(key) || (setting != null && setting.isPrivateIndex())) && ignorePrivateSettings)) {_                continue__            }_            if (key.startsWith(ARCHIVED_SETTINGS_PREFIX) && ignoreArchivedSettings) {_                continue__            }_            try {_                validate(key, settings, validateDependencies, validateInternalOrPrivateIndex)__            } catch (final RuntimeException ex) {_                exceptions.add(ex)__            }_        }_        ExceptionsHelper.rethrowAndSuppress(exceptions)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,ignore,private,settings,true,if,private,settings,should,be,ignored,during,validation,param,ignore,archived,settings,true,if,archived,settings,should,be,ignored,during,validation,param,validate,internal,or,private,index,true,if,index,internal,settings,should,be,validated,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,final,boolean,ignore,private,settings,final,boolean,ignore,archived,settings,final,boolean,validate,internal,or,private,index,final,list,runtime,exception,exceptions,new,array,list,for,final,string,key,settings,key,set,final,setting,setting,get,raw,key,if,is,private,setting,key,setting,null,setting,is,private,index,ignore,private,settings,continue,if,key,starts,with,ignore,archived,settings,continue,try,validate,key,settings,validate,dependencies,validate,internal,or,private,index,catch,final,runtime,exception,ex,exceptions,add,ex,exceptions,helper,rethrow,and,suppress,exceptions
AbstractScopedSettings -> public final void validate(             final Settings settings,             final boolean validateDependencies,             final boolean ignorePrivateSettings,             final boolean ignoreArchivedSettings,             final boolean validateInternalOrPrivateIndex);1536611444;Validates that all settings are registered and valid.__@param settings                       the settings_@param validateDependencies           true if dependent settings should be validated_@param ignorePrivateSettings          true if private settings should be ignored during validation_@param ignoreArchivedSettings         true if archived settings should be ignored during validation_@param validateInternalOrPrivateIndex true if index internal settings should be validated_@see Setting#getSettingsDependencies(String);public final void validate(_            final Settings settings,_            final boolean validateDependencies,_            final boolean ignorePrivateSettings,_            final boolean ignoreArchivedSettings,_            final boolean validateInternalOrPrivateIndex) {_        final List<RuntimeException> exceptions = new ArrayList<>()__        for (final String key : settings.keySet()) { _            final Setting<?> setting = getRaw(key)__            if (((isPrivateSetting(key) || (setting != null && setting.isPrivateIndex())) && ignorePrivateSettings)) {_                continue__            }_            if (key.startsWith(ARCHIVED_SETTINGS_PREFIX) && ignoreArchivedSettings) {_                continue__            }_            try {_                validate(key, settings, validateDependencies, validateInternalOrPrivateIndex)__            } catch (final RuntimeException ex) {_                exceptions.add(ex)__            }_        }_        ExceptionsHelper.rethrowAndSuppress(exceptions)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,ignore,private,settings,true,if,private,settings,should,be,ignored,during,validation,param,ignore,archived,settings,true,if,archived,settings,should,be,ignored,during,validation,param,validate,internal,or,private,index,true,if,index,internal,settings,should,be,validated,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,final,boolean,ignore,private,settings,final,boolean,ignore,archived,settings,final,boolean,validate,internal,or,private,index,final,list,runtime,exception,exceptions,new,array,list,for,final,string,key,settings,key,set,final,setting,setting,get,raw,key,if,is,private,setting,key,setting,null,setting,is,private,index,ignore,private,settings,continue,if,key,starts,with,ignore,archived,settings,continue,try,validate,key,settings,validate,dependencies,validate,internal,or,private,index,catch,final,runtime,exception,ex,exceptions,add,ex,exceptions,helper,rethrow,and,suppress,exceptions
AbstractScopedSettings -> public final void validate(             final Settings settings,             final boolean validateDependencies,             final boolean ignorePrivateSettings,             final boolean ignoreArchivedSettings,             final boolean validateInternalOrPrivateIndex);1536828374;Validates that all settings are registered and valid.__@param settings                       the settings_@param validateDependencies           true if dependent settings should be validated_@param ignorePrivateSettings          true if private settings should be ignored during validation_@param ignoreArchivedSettings         true if archived settings should be ignored during validation_@param validateInternalOrPrivateIndex true if index internal settings should be validated_@see Setting#getSettingsDependencies(String);public final void validate(_            final Settings settings,_            final boolean validateDependencies,_            final boolean ignorePrivateSettings,_            final boolean ignoreArchivedSettings,_            final boolean validateInternalOrPrivateIndex) {_        final List<RuntimeException> exceptions = new ArrayList<>()__        for (final String key : settings.keySet()) { _            final Setting<?> setting = getRaw(key)__            if (((isPrivateSetting(key) || (setting != null && setting.isPrivateIndex())) && ignorePrivateSettings)) {_                continue__            }_            if (key.startsWith(ARCHIVED_SETTINGS_PREFIX) && ignoreArchivedSettings) {_                continue__            }_            try {_                validate(key, settings, validateDependencies, validateInternalOrPrivateIndex)__            } catch (final RuntimeException ex) {_                exceptions.add(ex)__            }_        }_        ExceptionsHelper.rethrowAndSuppress(exceptions)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,ignore,private,settings,true,if,private,settings,should,be,ignored,during,validation,param,ignore,archived,settings,true,if,archived,settings,should,be,ignored,during,validation,param,validate,internal,or,private,index,true,if,index,internal,settings,should,be,validated,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,final,boolean,ignore,private,settings,final,boolean,ignore,archived,settings,final,boolean,validate,internal,or,private,index,final,list,runtime,exception,exceptions,new,array,list,for,final,string,key,settings,key,set,final,setting,setting,get,raw,key,if,is,private,setting,key,setting,null,setting,is,private,index,ignore,private,settings,continue,if,key,starts,with,ignore,archived,settings,continue,try,validate,key,settings,validate,dependencies,validate,internal,or,private,index,catch,final,runtime,exception,ex,exceptions,add,ex,exceptions,helper,rethrow,and,suppress,exceptions
AbstractScopedSettings -> public final void validate(             final Settings settings,             final boolean validateDependencies,             final boolean ignorePrivateSettings,             final boolean ignoreArchivedSettings,             final boolean validateInternalOrPrivateIndex);1539951844;Validates that all settings are registered and valid.__@param settings                       the settings_@param validateDependencies           true if dependent settings should be validated_@param ignorePrivateSettings          true if private settings should be ignored during validation_@param ignoreArchivedSettings         true if archived settings should be ignored during validation_@param validateInternalOrPrivateIndex true if index internal settings should be validated_@see Setting#getSettingsDependencies(String);public final void validate(_            final Settings settings,_            final boolean validateDependencies,_            final boolean ignorePrivateSettings,_            final boolean ignoreArchivedSettings,_            final boolean validateInternalOrPrivateIndex) {_        final List<RuntimeException> exceptions = new ArrayList<>()__        for (final String key : settings.keySet()) { _            final Setting<?> setting = getRaw(key)__            if (((isPrivateSetting(key) || (setting != null && setting.isPrivateIndex())) && ignorePrivateSettings)) {_                continue__            }_            if (key.startsWith(ARCHIVED_SETTINGS_PREFIX) && ignoreArchivedSettings) {_                continue__            }_            try {_                validate(key, settings, validateDependencies, validateInternalOrPrivateIndex)__            } catch (final RuntimeException ex) {_                exceptions.add(ex)__            }_        }_        ExceptionsHelper.rethrowAndSuppress(exceptions)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,ignore,private,settings,true,if,private,settings,should,be,ignored,during,validation,param,ignore,archived,settings,true,if,archived,settings,should,be,ignored,during,validation,param,validate,internal,or,private,index,true,if,index,internal,settings,should,be,validated,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,final,boolean,ignore,private,settings,final,boolean,ignore,archived,settings,final,boolean,validate,internal,or,private,index,final,list,runtime,exception,exceptions,new,array,list,for,final,string,key,settings,key,set,final,setting,setting,get,raw,key,if,is,private,setting,key,setting,null,setting,is,private,index,ignore,private,settings,continue,if,key,starts,with,ignore,archived,settings,continue,try,validate,key,settings,validate,dependencies,validate,internal,or,private,index,catch,final,runtime,exception,ex,exceptions,add,ex,exceptions,helper,rethrow,and,suppress,exceptions
AbstractScopedSettings -> public final void validate(             final Settings settings,             final boolean validateDependencies,             final boolean ignorePrivateSettings,             final boolean ignoreArchivedSettings,             final boolean validateInternalOrPrivateIndex);1541008027;Validates that all settings are registered and valid.__@param settings                       the settings_@param validateDependencies           true if dependent settings should be validated_@param ignorePrivateSettings          true if private settings should be ignored during validation_@param ignoreArchivedSettings         true if archived settings should be ignored during validation_@param validateInternalOrPrivateIndex true if index internal settings should be validated_@see Setting#getSettingsDependencies(String);public final void validate(_            final Settings settings,_            final boolean validateDependencies,_            final boolean ignorePrivateSettings,_            final boolean ignoreArchivedSettings,_            final boolean validateInternalOrPrivateIndex) {_        final List<RuntimeException> exceptions = new ArrayList<>()__        for (final String key : settings.keySet()) { _            final Setting<?> setting = getRaw(key)__            if (((isPrivateSetting(key) || (setting != null && setting.isPrivateIndex())) && ignorePrivateSettings)) {_                continue__            }_            if (key.startsWith(ARCHIVED_SETTINGS_PREFIX) && ignoreArchivedSettings) {_                continue__            }_            try {_                validate(key, settings, validateDependencies, validateInternalOrPrivateIndex)__            } catch (final RuntimeException ex) {_                exceptions.add(ex)__            }_        }_        ExceptionsHelper.rethrowAndSuppress(exceptions)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,ignore,private,settings,true,if,private,settings,should,be,ignored,during,validation,param,ignore,archived,settings,true,if,archived,settings,should,be,ignored,during,validation,param,validate,internal,or,private,index,true,if,index,internal,settings,should,be,validated,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,final,boolean,ignore,private,settings,final,boolean,ignore,archived,settings,final,boolean,validate,internal,or,private,index,final,list,runtime,exception,exceptions,new,array,list,for,final,string,key,settings,key,set,final,setting,setting,get,raw,key,if,is,private,setting,key,setting,null,setting,is,private,index,ignore,private,settings,continue,if,key,starts,with,ignore,archived,settings,continue,try,validate,key,settings,validate,dependencies,validate,internal,or,private,index,catch,final,runtime,exception,ex,exceptions,add,ex,exceptions,helper,rethrow,and,suppress,exceptions
AbstractScopedSettings -> public final void validate(             final Settings settings,             final boolean validateDependencies,             final boolean ignorePrivateSettings,             final boolean ignoreArchivedSettings,             final boolean validateInternalOrPrivateIndex);1541092382;Validates that all settings are registered and valid.__@param settings                       the settings_@param validateDependencies           true if dependent settings should be validated_@param ignorePrivateSettings          true if private settings should be ignored during validation_@param ignoreArchivedSettings         true if archived settings should be ignored during validation_@param validateInternalOrPrivateIndex true if index internal settings should be validated_@see Setting#getSettingsDependencies(String);public final void validate(_            final Settings settings,_            final boolean validateDependencies,_            final boolean ignorePrivateSettings,_            final boolean ignoreArchivedSettings,_            final boolean validateInternalOrPrivateIndex) {_        final List<RuntimeException> exceptions = new ArrayList<>()__        for (final String key : settings.keySet()) { _            final Setting<?> setting = getRaw(key)__            if (((isPrivateSetting(key) || (setting != null && setting.isPrivateIndex())) && ignorePrivateSettings)) {_                continue__            }_            if (key.startsWith(ARCHIVED_SETTINGS_PREFIX) && ignoreArchivedSettings) {_                continue__            }_            try {_                validate(key, settings, validateDependencies, validateInternalOrPrivateIndex)__            } catch (final RuntimeException ex) {_                exceptions.add(ex)__            }_        }_        ExceptionsHelper.rethrowAndSuppress(exceptions)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,ignore,private,settings,true,if,private,settings,should,be,ignored,during,validation,param,ignore,archived,settings,true,if,archived,settings,should,be,ignored,during,validation,param,validate,internal,or,private,index,true,if,index,internal,settings,should,be,validated,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,final,boolean,ignore,private,settings,final,boolean,ignore,archived,settings,final,boolean,validate,internal,or,private,index,final,list,runtime,exception,exceptions,new,array,list,for,final,string,key,settings,key,set,final,setting,setting,get,raw,key,if,is,private,setting,key,setting,null,setting,is,private,index,ignore,private,settings,continue,if,key,starts,with,ignore,archived,settings,continue,try,validate,key,settings,validate,dependencies,validate,internal,or,private,index,catch,final,runtime,exception,ex,exceptions,add,ex,exceptions,helper,rethrow,and,suppress,exceptions
AbstractScopedSettings -> public final void validate(             final Settings settings,             final boolean validateDependencies,             final boolean ignorePrivateSettings,             final boolean ignoreArchivedSettings,             final boolean validateInternalOrPrivateIndex);1542402632;Validates that all settings are registered and valid.__@param settings                       the settings_@param validateDependencies           true if dependent settings should be validated_@param ignorePrivateSettings          true if private settings should be ignored during validation_@param ignoreArchivedSettings         true if archived settings should be ignored during validation_@param validateInternalOrPrivateIndex true if index internal settings should be validated_@see Setting#getSettingsDependencies(String);public final void validate(_            final Settings settings,_            final boolean validateDependencies,_            final boolean ignorePrivateSettings,_            final boolean ignoreArchivedSettings,_            final boolean validateInternalOrPrivateIndex) {_        final List<RuntimeException> exceptions = new ArrayList<>()__        for (final String key : settings.keySet()) { _            final Setting<?> setting = getRaw(key)__            if (((isPrivateSetting(key) || (setting != null && setting.isPrivateIndex())) && ignorePrivateSettings)) {_                continue__            }_            if (key.startsWith(ARCHIVED_SETTINGS_PREFIX) && ignoreArchivedSettings) {_                continue__            }_            try {_                validate(key, settings, validateDependencies, validateInternalOrPrivateIndex)__            } catch (final RuntimeException ex) {_                exceptions.add(ex)__            }_        }_        ExceptionsHelper.rethrowAndSuppress(exceptions)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,ignore,private,settings,true,if,private,settings,should,be,ignored,during,validation,param,ignore,archived,settings,true,if,archived,settings,should,be,ignored,during,validation,param,validate,internal,or,private,index,true,if,index,internal,settings,should,be,validated,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,final,boolean,ignore,private,settings,final,boolean,ignore,archived,settings,final,boolean,validate,internal,or,private,index,final,list,runtime,exception,exceptions,new,array,list,for,final,string,key,settings,key,set,final,setting,setting,get,raw,key,if,is,private,setting,key,setting,null,setting,is,private,index,ignore,private,settings,continue,if,key,starts,with,ignore,archived,settings,continue,try,validate,key,settings,validate,dependencies,validate,internal,or,private,index,catch,final,runtime,exception,ex,exceptions,add,ex,exceptions,helper,rethrow,and,suppress,exceptions
AbstractScopedSettings -> public final void validate(             final Settings settings,             final boolean validateDependencies,             final boolean ignorePrivateSettings,             final boolean ignoreArchivedSettings,             final boolean validateInternalOrPrivateIndex);1544081506;Validates that all settings are registered and valid.__@param settings                       the settings_@param validateDependencies           true if dependent settings should be validated_@param ignorePrivateSettings          true if private settings should be ignored during validation_@param ignoreArchivedSettings         true if archived settings should be ignored during validation_@param validateInternalOrPrivateIndex true if index internal settings should be validated_@see Setting#getSettingsDependencies(String);public final void validate(_            final Settings settings,_            final boolean validateDependencies,_            final boolean ignorePrivateSettings,_            final boolean ignoreArchivedSettings,_            final boolean validateInternalOrPrivateIndex) {_        final List<RuntimeException> exceptions = new ArrayList<>()__        for (final String key : settings.keySet()) { _            final Setting<?> setting = getRaw(key)__            if (((isPrivateSetting(key) || (setting != null && setting.isPrivateIndex())) && ignorePrivateSettings)) {_                continue__            }_            if (key.startsWith(ARCHIVED_SETTINGS_PREFIX) && ignoreArchivedSettings) {_                continue__            }_            try {_                validate(key, settings, validateDependencies, validateInternalOrPrivateIndex)__            } catch (final RuntimeException ex) {_                exceptions.add(ex)__            }_        }_        ExceptionsHelper.rethrowAndSuppress(exceptions)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,ignore,private,settings,true,if,private,settings,should,be,ignored,during,validation,param,ignore,archived,settings,true,if,archived,settings,should,be,ignored,during,validation,param,validate,internal,or,private,index,true,if,index,internal,settings,should,be,validated,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,final,boolean,ignore,private,settings,final,boolean,ignore,archived,settings,final,boolean,validate,internal,or,private,index,final,list,runtime,exception,exceptions,new,array,list,for,final,string,key,settings,key,set,final,setting,setting,get,raw,key,if,is,private,setting,key,setting,null,setting,is,private,index,ignore,private,settings,continue,if,key,starts,with,ignore,archived,settings,continue,try,validate,key,settings,validate,dependencies,validate,internal,or,private,index,catch,final,runtime,exception,ex,exceptions,add,ex,exceptions,helper,rethrow,and,suppress,exceptions
AbstractScopedSettings -> public final void validate(             final Settings settings,             final boolean validateDependencies,             final boolean ignorePrivateSettings,             final boolean ignoreArchivedSettings,             final boolean validateInternalOrPrivateIndex);1544691774;Validates that all settings are registered and valid.__@param settings                       the settings_@param validateDependencies           true if dependent settings should be validated_@param ignorePrivateSettings          true if private settings should be ignored during validation_@param ignoreArchivedSettings         true if archived settings should be ignored during validation_@param validateInternalOrPrivateIndex true if index internal settings should be validated_@see Setting#getSettingsDependencies(String);public final void validate(_            final Settings settings,_            final boolean validateDependencies,_            final boolean ignorePrivateSettings,_            final boolean ignoreArchivedSettings,_            final boolean validateInternalOrPrivateIndex) {_        final List<RuntimeException> exceptions = new ArrayList<>()__        for (final String key : settings.keySet()) { _            final Setting<?> setting = getRaw(key)__            if (((isPrivateSetting(key) || (setting != null && setting.isPrivateIndex())) && ignorePrivateSettings)) {_                continue__            }_            if (key.startsWith(ARCHIVED_SETTINGS_PREFIX) && ignoreArchivedSettings) {_                continue__            }_            try {_                validate(key, settings, validateDependencies, validateInternalOrPrivateIndex)__            } catch (final RuntimeException ex) {_                exceptions.add(ex)__            }_        }_        ExceptionsHelper.rethrowAndSuppress(exceptions)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,ignore,private,settings,true,if,private,settings,should,be,ignored,during,validation,param,ignore,archived,settings,true,if,archived,settings,should,be,ignored,during,validation,param,validate,internal,or,private,index,true,if,index,internal,settings,should,be,validated,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,final,boolean,ignore,private,settings,final,boolean,ignore,archived,settings,final,boolean,validate,internal,or,private,index,final,list,runtime,exception,exceptions,new,array,list,for,final,string,key,settings,key,set,final,setting,setting,get,raw,key,if,is,private,setting,key,setting,null,setting,is,private,index,ignore,private,settings,continue,if,key,starts,with,ignore,archived,settings,continue,try,validate,key,settings,validate,dependencies,validate,internal,or,private,index,catch,final,runtime,exception,ex,exceptions,add,ex,exceptions,helper,rethrow,and,suppress,exceptions
AbstractScopedSettings -> public final void validate(             final Settings settings,             final boolean validateDependencies,             final boolean ignorePrivateSettings,             final boolean ignoreArchivedSettings,             final boolean validateInternalOrPrivateIndex);1546877578;Validates that all settings are registered and valid.__@param settings                       the settings_@param validateDependencies           true if dependent settings should be validated_@param ignorePrivateSettings          true if private settings should be ignored during validation_@param ignoreArchivedSettings         true if archived settings should be ignored during validation_@param validateInternalOrPrivateIndex true if index internal settings should be validated_@see Setting#getSettingsDependencies(String);public final void validate(_            final Settings settings,_            final boolean validateDependencies,_            final boolean ignorePrivateSettings,_            final boolean ignoreArchivedSettings,_            final boolean validateInternalOrPrivateIndex) {_        final List<RuntimeException> exceptions = new ArrayList<>()__        for (final String key : settings.keySet()) { _            final Setting<?> setting = getRaw(key)__            if (((isPrivateSetting(key) || (setting != null && setting.isPrivateIndex())) && ignorePrivateSettings)) {_                continue__            }_            if (key.startsWith(ARCHIVED_SETTINGS_PREFIX) && ignoreArchivedSettings) {_                continue__            }_            try {_                validate(key, settings, validateDependencies, validateInternalOrPrivateIndex)__            } catch (final RuntimeException ex) {_                exceptions.add(ex)__            }_        }_        ExceptionsHelper.rethrowAndSuppress(exceptions)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,ignore,private,settings,true,if,private,settings,should,be,ignored,during,validation,param,ignore,archived,settings,true,if,archived,settings,should,be,ignored,during,validation,param,validate,internal,or,private,index,true,if,index,internal,settings,should,be,validated,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,final,boolean,ignore,private,settings,final,boolean,ignore,archived,settings,final,boolean,validate,internal,or,private,index,final,list,runtime,exception,exceptions,new,array,list,for,final,string,key,settings,key,set,final,setting,setting,get,raw,key,if,is,private,setting,key,setting,null,setting,is,private,index,ignore,private,settings,continue,if,key,starts,with,ignore,archived,settings,continue,try,validate,key,settings,validate,dependencies,validate,internal,or,private,index,catch,final,runtime,exception,ex,exceptions,add,ex,exceptions,helper,rethrow,and,suppress,exceptions
AbstractScopedSettings -> public final void validate(             final Settings settings,             final boolean validateDependencies,             final boolean ignorePrivateSettings,             final boolean ignoreArchivedSettings,             final boolean validateInternalOrPrivateIndex);1548270339;Validates that all settings are registered and valid.__@param settings                       the settings_@param validateDependencies           true if dependent settings should be validated_@param ignorePrivateSettings          true if private settings should be ignored during validation_@param ignoreArchivedSettings         true if archived settings should be ignored during validation_@param validateInternalOrPrivateIndex true if index internal settings should be validated_@see Setting#getSettingsDependencies(String);public final void validate(_            final Settings settings,_            final boolean validateDependencies,_            final boolean ignorePrivateSettings,_            final boolean ignoreArchivedSettings,_            final boolean validateInternalOrPrivateIndex) {_        final List<RuntimeException> exceptions = new ArrayList<>()__        for (final String key : settings.keySet()) { _            final Setting<?> setting = getRaw(key)__            if (((isPrivateSetting(key) || (setting != null && setting.isPrivateIndex())) && ignorePrivateSettings)) {_                continue__            }_            if (key.startsWith(ARCHIVED_SETTINGS_PREFIX) && ignoreArchivedSettings) {_                continue__            }_            try {_                validate(key, settings, validateDependencies, validateInternalOrPrivateIndex)__            } catch (final RuntimeException ex) {_                exceptions.add(ex)__            }_        }_        ExceptionsHelper.rethrowAndSuppress(exceptions)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,ignore,private,settings,true,if,private,settings,should,be,ignored,during,validation,param,ignore,archived,settings,true,if,archived,settings,should,be,ignored,during,validation,param,validate,internal,or,private,index,true,if,index,internal,settings,should,be,validated,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,final,boolean,ignore,private,settings,final,boolean,ignore,archived,settings,final,boolean,validate,internal,or,private,index,final,list,runtime,exception,exceptions,new,array,list,for,final,string,key,settings,key,set,final,setting,setting,get,raw,key,if,is,private,setting,key,setting,null,setting,is,private,index,ignore,private,settings,continue,if,key,starts,with,ignore,archived,settings,continue,try,validate,key,settings,validate,dependencies,validate,internal,or,private,index,catch,final,runtime,exception,ex,exceptions,add,ex,exceptions,helper,rethrow,and,suppress,exceptions
AbstractScopedSettings -> public boolean isFinalSetting(String key);1524684173;Returns <code>true</code> if the setting for the given key is final. Otherwise <code>false</code>.;public boolean isFinalSetting(String key) {_        final Setting<?> setting = get(key)__        return setting != null && setting.isFinal()__    };returns,code,true,code,if,the,setting,for,the,given,key,is,final,otherwise,code,false,code;public,boolean,is,final,setting,string,key,final,setting,setting,get,key,return,setting,null,setting,is,final
AbstractScopedSettings -> public boolean isFinalSetting(String key);1528904315;Returns <code>true</code> if the setting for the given key is final. Otherwise <code>false</code>.;public boolean isFinalSetting(String key) {_        final Setting<?> setting = get(key)__        return setting != null && setting.isFinal()__    };returns,code,true,code,if,the,setting,for,the,given,key,is,final,otherwise,code,false,code;public,boolean,is,final,setting,string,key,final,setting,setting,get,key,return,setting,null,setting,is,final
AbstractScopedSettings -> public boolean isFinalSetting(String key);1531179852;Returns <code>true</code> if the setting for the given key is final. Otherwise <code>false</code>.;public boolean isFinalSetting(String key) {_        final Setting<?> setting = get(key)__        return setting != null && setting.isFinal()__    };returns,code,true,code,if,the,setting,for,the,given,key,is,final,otherwise,code,false,code;public,boolean,is,final,setting,string,key,final,setting,setting,get,key,return,setting,null,setting,is,final
AbstractScopedSettings -> public boolean isFinalSetting(String key);1535046779;Returns <code>true</code> if the setting for the given key is final. Otherwise <code>false</code>.;public boolean isFinalSetting(String key) {_        final Setting<?> setting = get(key)__        return setting != null && setting.isFinal()__    };returns,code,true,code,if,the,setting,for,the,given,key,is,final,otherwise,code,false,code;public,boolean,is,final,setting,string,key,final,setting,setting,get,key,return,setting,null,setting,is,final
AbstractScopedSettings -> public boolean isFinalSetting(String key);1536137328;Returns <code>true</code> if the setting for the given key is final. Otherwise <code>false</code>.;public boolean isFinalSetting(String key) {_        final Setting<?> setting = get(key)__        return setting != null && setting.isFinal()__    };returns,code,true,code,if,the,setting,for,the,given,key,is,final,otherwise,code,false,code;public,boolean,is,final,setting,string,key,final,setting,setting,get,key,return,setting,null,setting,is,final
AbstractScopedSettings -> public boolean isFinalSetting(String key);1536314350;Returns <code>true</code> if the setting for the given key is final. Otherwise <code>false</code>.;public boolean isFinalSetting(String key) {_        final Setting<?> setting = get(key)__        return setting != null && setting.isFinal()__    };returns,code,true,code,if,the,setting,for,the,given,key,is,final,otherwise,code,false,code;public,boolean,is,final,setting,string,key,final,setting,setting,get,key,return,setting,null,setting,is,final
AbstractScopedSettings -> public boolean isFinalSetting(String key);1536611444;Returns <code>true</code> if the setting for the given key is final. Otherwise <code>false</code>.;public boolean isFinalSetting(String key) {_        final Setting<?> setting = get(key)__        return setting != null && setting.isFinal()__    };returns,code,true,code,if,the,setting,for,the,given,key,is,final,otherwise,code,false,code;public,boolean,is,final,setting,string,key,final,setting,setting,get,key,return,setting,null,setting,is,final
AbstractScopedSettings -> public boolean isFinalSetting(String key);1536828374;Returns <code>true</code> if the setting for the given key is final. Otherwise <code>false</code>.;public boolean isFinalSetting(String key) {_        final Setting<?> setting = get(key)__        return setting != null && setting.isFinal()__    };returns,code,true,code,if,the,setting,for,the,given,key,is,final,otherwise,code,false,code;public,boolean,is,final,setting,string,key,final,setting,setting,get,key,return,setting,null,setting,is,final
AbstractScopedSettings -> public boolean isFinalSetting(String key);1539951844;Returns <code>true</code> if the setting for the given key is final. Otherwise <code>false</code>.;public boolean isFinalSetting(String key) {_        final Setting<?> setting = get(key)__        return setting != null && setting.isFinal()__    };returns,code,true,code,if,the,setting,for,the,given,key,is,final,otherwise,code,false,code;public,boolean,is,final,setting,string,key,final,setting,setting,get,key,return,setting,null,setting,is,final
AbstractScopedSettings -> public boolean isFinalSetting(String key);1541008027;Returns <code>true</code> if the setting for the given key is final. Otherwise <code>false</code>.;public boolean isFinalSetting(String key) {_        final Setting<?> setting = get(key)__        return setting != null && setting.isFinal()__    };returns,code,true,code,if,the,setting,for,the,given,key,is,final,otherwise,code,false,code;public,boolean,is,final,setting,string,key,final,setting,setting,get,key,return,setting,null,setting,is,final
AbstractScopedSettings -> public boolean isFinalSetting(String key);1541092382;Returns <code>true</code> if the setting for the given key is final. Otherwise <code>false</code>.;public boolean isFinalSetting(String key) {_        final Setting<?> setting = get(key)__        return setting != null && setting.isFinal()__    };returns,code,true,code,if,the,setting,for,the,given,key,is,final,otherwise,code,false,code;public,boolean,is,final,setting,string,key,final,setting,setting,get,key,return,setting,null,setting,is,final
AbstractScopedSettings -> public boolean isFinalSetting(String key);1542402632;Returns <code>true</code> if the setting for the given key is final. Otherwise <code>false</code>.;public boolean isFinalSetting(String key) {_        final Setting<?> setting = get(key)__        return setting != null && setting.isFinal()__    };returns,code,true,code,if,the,setting,for,the,given,key,is,final,otherwise,code,false,code;public,boolean,is,final,setting,string,key,final,setting,setting,get,key,return,setting,null,setting,is,final
AbstractScopedSettings -> public boolean isFinalSetting(String key);1544081506;Returns <code>true</code> if the setting for the given key is final. Otherwise <code>false</code>.;public boolean isFinalSetting(String key) {_        final Setting<?> setting = get(key)__        return setting != null && setting.isFinal()__    };returns,code,true,code,if,the,setting,for,the,given,key,is,final,otherwise,code,false,code;public,boolean,is,final,setting,string,key,final,setting,setting,get,key,return,setting,null,setting,is,final
AbstractScopedSettings -> public boolean isFinalSetting(String key);1544691774;Returns <code>true</code> if the setting for the given key is final. Otherwise <code>false</code>.;public boolean isFinalSetting(String key) {_        final Setting<?> setting = get(key)__        return setting != null && setting.isFinal()__    };returns,code,true,code,if,the,setting,for,the,given,key,is,final,otherwise,code,false,code;public,boolean,is,final,setting,string,key,final,setting,setting,get,key,return,setting,null,setting,is,final
AbstractScopedSettings -> public boolean isFinalSetting(String key);1546877578;Returns <code>true</code> if the setting for the given key is final. Otherwise <code>false</code>.;public boolean isFinalSetting(String key) {_        final Setting<?> setting = get(key)__        return setting != null && setting.isFinal()__    };returns,code,true,code,if,the,setting,for,the,given,key,is,final,otherwise,code,false,code;public,boolean,is,final,setting,string,key,final,setting,setting,get,key,return,setting,null,setting,is,final
AbstractScopedSettings -> public boolean isFinalSetting(String key);1548270339;Returns <code>true</code> if the setting for the given key is final. Otherwise <code>false</code>.;public boolean isFinalSetting(String key) {_        final Setting<?> setting = get(key)__        return setting != null && setting.isFinal()__    };returns,code,true,code,if,the,setting,for,the,given,key,is,final,otherwise,code,false,code;public,boolean,is,final,setting,string,key,final,setting,setting,get,key,return,setting,null,setting,is,final
AbstractScopedSettings -> public static boolean isValidKey(String key);1524684173;Returns <code>true</code> iff the given key is a valid settings key otherwise <code>false</code>;public static boolean isValidKey(String key) {_        return KEY_PATTERN.matcher(key).matches()__    };returns,code,true,code,iff,the,given,key,is,a,valid,settings,key,otherwise,code,false,code;public,static,boolean,is,valid,key,string,key,return,matcher,key,matches
AbstractScopedSettings -> public static boolean isValidKey(String key);1528904315;Returns <code>true</code> iff the given key is a valid settings key otherwise <code>false</code>;public static boolean isValidKey(String key) {_        return KEY_PATTERN.matcher(key).matches()__    };returns,code,true,code,iff,the,given,key,is,a,valid,settings,key,otherwise,code,false,code;public,static,boolean,is,valid,key,string,key,return,matcher,key,matches
AbstractScopedSettings -> public static boolean isValidKey(String key);1531179852;Returns <code>true</code> iff the given key is a valid settings key otherwise <code>false</code>;public static boolean isValidKey(String key) {_        return KEY_PATTERN.matcher(key).matches()__    };returns,code,true,code,iff,the,given,key,is,a,valid,settings,key,otherwise,code,false,code;public,static,boolean,is,valid,key,string,key,return,matcher,key,matches
AbstractScopedSettings -> public static boolean isValidKey(String key);1535046779;Returns <code>true</code> iff the given key is a valid settings key otherwise <code>false</code>;public static boolean isValidKey(String key) {_        return KEY_PATTERN.matcher(key).matches()__    };returns,code,true,code,iff,the,given,key,is,a,valid,settings,key,otherwise,code,false,code;public,static,boolean,is,valid,key,string,key,return,matcher,key,matches
AbstractScopedSettings -> public static boolean isValidKey(String key);1536137328;Returns <code>true</code> iff the given key is a valid settings key otherwise <code>false</code>;public static boolean isValidKey(String key) {_        return KEY_PATTERN.matcher(key).matches()__    };returns,code,true,code,iff,the,given,key,is,a,valid,settings,key,otherwise,code,false,code;public,static,boolean,is,valid,key,string,key,return,matcher,key,matches
AbstractScopedSettings -> public static boolean isValidKey(String key);1536314350;Returns <code>true</code> iff the given key is a valid settings key otherwise <code>false</code>;public static boolean isValidKey(String key) {_        return KEY_PATTERN.matcher(key).matches()__    };returns,code,true,code,iff,the,given,key,is,a,valid,settings,key,otherwise,code,false,code;public,static,boolean,is,valid,key,string,key,return,matcher,key,matches
AbstractScopedSettings -> public static boolean isValidKey(String key);1536611444;Returns <code>true</code> iff the given key is a valid settings key otherwise <code>false</code>;public static boolean isValidKey(String key) {_        return KEY_PATTERN.matcher(key).matches()__    };returns,code,true,code,iff,the,given,key,is,a,valid,settings,key,otherwise,code,false,code;public,static,boolean,is,valid,key,string,key,return,matcher,key,matches
AbstractScopedSettings -> public static boolean isValidKey(String key);1536828374;Returns <code>true</code> iff the given key is a valid settings key otherwise <code>false</code>;public static boolean isValidKey(String key) {_        return KEY_PATTERN.matcher(key).matches()__    };returns,code,true,code,iff,the,given,key,is,a,valid,settings,key,otherwise,code,false,code;public,static,boolean,is,valid,key,string,key,return,matcher,key,matches
AbstractScopedSettings -> public static boolean isValidKey(String key);1539951844;Returns <code>true</code> iff the given key is a valid settings key otherwise <code>false</code>;public static boolean isValidKey(String key) {_        return KEY_PATTERN.matcher(key).matches()__    };returns,code,true,code,iff,the,given,key,is,a,valid,settings,key,otherwise,code,false,code;public,static,boolean,is,valid,key,string,key,return,matcher,key,matches
AbstractScopedSettings -> public static boolean isValidKey(String key);1541008027;Returns <code>true</code> iff the given key is a valid settings key otherwise <code>false</code>;public static boolean isValidKey(String key) {_        return KEY_PATTERN.matcher(key).matches()__    };returns,code,true,code,iff,the,given,key,is,a,valid,settings,key,otherwise,code,false,code;public,static,boolean,is,valid,key,string,key,return,matcher,key,matches
AbstractScopedSettings -> public static boolean isValidKey(String key);1541092382;Returns <code>true</code> iff the given key is a valid settings key otherwise <code>false</code>;public static boolean isValidKey(String key) {_        return KEY_PATTERN.matcher(key).matches()__    };returns,code,true,code,iff,the,given,key,is,a,valid,settings,key,otherwise,code,false,code;public,static,boolean,is,valid,key,string,key,return,matcher,key,matches
AbstractScopedSettings -> public static boolean isValidKey(String key);1542402632;Returns <code>true</code> iff the given key is a valid settings key otherwise <code>false</code>;public static boolean isValidKey(String key) {_        return KEY_PATTERN.matcher(key).matches()__    };returns,code,true,code,iff,the,given,key,is,a,valid,settings,key,otherwise,code,false,code;public,static,boolean,is,valid,key,string,key,return,matcher,key,matches
AbstractScopedSettings -> public static boolean isValidKey(String key);1544081506;Returns <code>true</code> iff the given key is a valid settings key otherwise <code>false</code>;public static boolean isValidKey(String key) {_        return KEY_PATTERN.matcher(key).matches()__    };returns,code,true,code,iff,the,given,key,is,a,valid,settings,key,otherwise,code,false,code;public,static,boolean,is,valid,key,string,key,return,matcher,key,matches
AbstractScopedSettings -> public static boolean isValidKey(String key);1544691774;Returns <code>true</code> iff the given key is a valid settings key otherwise <code>false</code>;public static boolean isValidKey(String key) {_        return KEY_PATTERN.matcher(key).matches()__    };returns,code,true,code,iff,the,given,key,is,a,valid,settings,key,otherwise,code,false,code;public,static,boolean,is,valid,key,string,key,return,matcher,key,matches
AbstractScopedSettings -> public static boolean isValidKey(String key);1546877578;Returns <code>true</code> iff the given key is a valid settings key otherwise <code>false</code>;public static boolean isValidKey(String key) {_        return KEY_PATTERN.matcher(key).matches()__    };returns,code,true,code,iff,the,given,key,is,a,valid,settings,key,otherwise,code,false,code;public,static,boolean,is,valid,key,string,key,return,matcher,key,matches
AbstractScopedSettings -> public static boolean isValidKey(String key);1548270339;Returns <code>true</code> iff the given key is a valid settings key otherwise <code>false</code>;public static boolean isValidKey(String key) {_        return KEY_PATTERN.matcher(key).matches()__    };returns,code,true,code,iff,the,given,key,is,a,valid,settings,key,otherwise,code,false,code;public,static,boolean,is,valid,key,string,key,return,matcher,key,matches
AbstractScopedSettings -> public Settings upgradeSettings(final Settings settings);1536611444;Upgrade all settings eligible for upgrade in the specified settings instance.__@param settings the settings instance that might contain settings to be upgraded_@return a new settings instance if any settings required upgrade, otherwise the same settings instance as specified;public Settings upgradeSettings(final Settings settings) {_        final Settings.Builder builder = Settings.builder()__        boolean changed = false_ _        for (final String key : settings.keySet()) {_            final Setting<?> setting = getRaw(key)__            final Function<Map.Entry<String, String>, Map.Entry<String, String>> upgrader = settingUpgraders.get(setting)__            if (upgrader == null) {_                _                builder.copy(key, settings)__            } else {_                _                changed = true__                final Map.Entry<String, String> upgrade = upgrader.apply(new Entry(key, settings))__                builder.put(upgrade.getKey(), upgrade.getValue())__            }_        }_        _        return changed ? builder.build() : settings__    };upgrade,all,settings,eligible,for,upgrade,in,the,specified,settings,instance,param,settings,the,settings,instance,that,might,contain,settings,to,be,upgraded,return,a,new,settings,instance,if,any,settings,required,upgrade,otherwise,the,same,settings,instance,as,specified;public,settings,upgrade,settings,final,settings,settings,final,settings,builder,builder,settings,builder,boolean,changed,false,for,final,string,key,settings,key,set,final,setting,setting,get,raw,key,final,function,map,entry,string,string,map,entry,string,string,upgrader,setting,upgraders,get,setting,if,upgrader,null,builder,copy,key,settings,else,changed,true,final,map,entry,string,string,upgrade,upgrader,apply,new,entry,key,settings,builder,put,upgrade,get,key,upgrade,get,value,return,changed,builder,build,settings
AbstractScopedSettings -> public Settings upgradeSettings(final Settings settings);1536828374;Upgrade all settings eligible for upgrade in the specified settings instance.__@param settings the settings instance that might contain settings to be upgraded_@return a new settings instance if any settings required upgrade, otherwise the same settings instance as specified;public Settings upgradeSettings(final Settings settings) {_        final Settings.Builder builder = Settings.builder()__        boolean changed = false_ _        for (final String key : settings.keySet()) {_            final Setting<?> setting = getRaw(key)__            final SettingUpgrader<?> upgrader = settingUpgraders.get(setting)__            if (upgrader == null) {_                _                builder.copy(key, settings)__            } else {_                _                changed = true__                _                if (setting.getConcreteSetting(key).isListSetting()) {_                    final List<String> value = settings.getAsList(key)__                    final String upgradedKey = upgrader.getKey(key)__                    final List<String> upgradedValue = upgrader.getListValue(value)__                    builder.putList(upgradedKey, upgradedValue)__                } else {_                    final String value = settings.get(key)__                    final String upgradedKey = upgrader.getKey(key)__                    final String upgradedValue = upgrader.getValue(value)__                    builder.put(upgradedKey, upgradedValue)__                }_            }_        }_        _        return changed ? builder.build() : settings__    };upgrade,all,settings,eligible,for,upgrade,in,the,specified,settings,instance,param,settings,the,settings,instance,that,might,contain,settings,to,be,upgraded,return,a,new,settings,instance,if,any,settings,required,upgrade,otherwise,the,same,settings,instance,as,specified;public,settings,upgrade,settings,final,settings,settings,final,settings,builder,builder,settings,builder,boolean,changed,false,for,final,string,key,settings,key,set,final,setting,setting,get,raw,key,final,setting,upgrader,upgrader,setting,upgraders,get,setting,if,upgrader,null,builder,copy,key,settings,else,changed,true,if,setting,get,concrete,setting,key,is,list,setting,final,list,string,value,settings,get,as,list,key,final,string,upgraded,key,upgrader,get,key,key,final,list,string,upgraded,value,upgrader,get,list,value,value,builder,put,list,upgraded,key,upgraded,value,else,final,string,value,settings,get,key,final,string,upgraded,key,upgrader,get,key,key,final,string,upgraded,value,upgrader,get,value,value,builder,put,upgraded,key,upgraded,value,return,changed,builder,build,settings
AbstractScopedSettings -> public Settings upgradeSettings(final Settings settings);1539951844;Upgrade all settings eligible for upgrade in the specified settings instance.__@param settings the settings instance that might contain settings to be upgraded_@return a new settings instance if any settings required upgrade, otherwise the same settings instance as specified;public Settings upgradeSettings(final Settings settings) {_        final Settings.Builder builder = Settings.builder()__        boolean changed = false_ _        for (final String key : settings.keySet()) {_            final Setting<?> setting = getRaw(key)__            final SettingUpgrader<?> upgrader = settingUpgraders.get(setting)__            if (upgrader == null) {_                _                builder.copy(key, settings)__            } else {_                _                changed = true__                _                if (setting.getConcreteSetting(key).isListSetting()) {_                    final List<String> value = settings.getAsList(key)__                    final String upgradedKey = upgrader.getKey(key)__                    final List<String> upgradedValue = upgrader.getListValue(value)__                    builder.putList(upgradedKey, upgradedValue)__                } else {_                    final String value = settings.get(key)__                    final String upgradedKey = upgrader.getKey(key)__                    final String upgradedValue = upgrader.getValue(value)__                    builder.put(upgradedKey, upgradedValue)__                }_            }_        }_        _        return changed ? builder.build() : settings__    };upgrade,all,settings,eligible,for,upgrade,in,the,specified,settings,instance,param,settings,the,settings,instance,that,might,contain,settings,to,be,upgraded,return,a,new,settings,instance,if,any,settings,required,upgrade,otherwise,the,same,settings,instance,as,specified;public,settings,upgrade,settings,final,settings,settings,final,settings,builder,builder,settings,builder,boolean,changed,false,for,final,string,key,settings,key,set,final,setting,setting,get,raw,key,final,setting,upgrader,upgrader,setting,upgraders,get,setting,if,upgrader,null,builder,copy,key,settings,else,changed,true,if,setting,get,concrete,setting,key,is,list,setting,final,list,string,value,settings,get,as,list,key,final,string,upgraded,key,upgrader,get,key,key,final,list,string,upgraded,value,upgrader,get,list,value,value,builder,put,list,upgraded,key,upgraded,value,else,final,string,value,settings,get,key,final,string,upgraded,key,upgrader,get,key,key,final,string,upgraded,value,upgrader,get,value,value,builder,put,upgraded,key,upgraded,value,return,changed,builder,build,settings
AbstractScopedSettings -> public Settings upgradeSettings(final Settings settings);1541008027;Upgrade all settings eligible for upgrade in the specified settings instance.__@param settings the settings instance that might contain settings to be upgraded_@return a new settings instance if any settings required upgrade, otherwise the same settings instance as specified;public Settings upgradeSettings(final Settings settings) {_        final Settings.Builder builder = Settings.builder()__        boolean changed = false_ _        for (final String key : settings.keySet()) {_            final Setting<?> setting = getRaw(key)__            final SettingUpgrader<?> upgrader = settingUpgraders.get(setting)__            if (upgrader == null) {_                _                builder.copy(key, settings)__            } else {_                _                changed = true__                _                if (setting.getConcreteSetting(key).isListSetting()) {_                    final List<String> value = settings.getAsList(key)__                    final String upgradedKey = upgrader.getKey(key)__                    final List<String> upgradedValue = upgrader.getListValue(value)__                    builder.putList(upgradedKey, upgradedValue)__                } else {_                    final String value = settings.get(key)__                    final String upgradedKey = upgrader.getKey(key)__                    final String upgradedValue = upgrader.getValue(value)__                    builder.put(upgradedKey, upgradedValue)__                }_            }_        }_        _        return changed ? builder.build() : settings__    };upgrade,all,settings,eligible,for,upgrade,in,the,specified,settings,instance,param,settings,the,settings,instance,that,might,contain,settings,to,be,upgraded,return,a,new,settings,instance,if,any,settings,required,upgrade,otherwise,the,same,settings,instance,as,specified;public,settings,upgrade,settings,final,settings,settings,final,settings,builder,builder,settings,builder,boolean,changed,false,for,final,string,key,settings,key,set,final,setting,setting,get,raw,key,final,setting,upgrader,upgrader,setting,upgraders,get,setting,if,upgrader,null,builder,copy,key,settings,else,changed,true,if,setting,get,concrete,setting,key,is,list,setting,final,list,string,value,settings,get,as,list,key,final,string,upgraded,key,upgrader,get,key,key,final,list,string,upgraded,value,upgrader,get,list,value,value,builder,put,list,upgraded,key,upgraded,value,else,final,string,value,settings,get,key,final,string,upgraded,key,upgrader,get,key,key,final,string,upgraded,value,upgrader,get,value,value,builder,put,upgraded,key,upgraded,value,return,changed,builder,build,settings
AbstractScopedSettings -> public Settings upgradeSettings(final Settings settings);1541092382;Upgrade all settings eligible for upgrade in the specified settings instance.__@param settings the settings instance that might contain settings to be upgraded_@return a new settings instance if any settings required upgrade, otherwise the same settings instance as specified;public Settings upgradeSettings(final Settings settings) {_        final Settings.Builder builder = Settings.builder()__        boolean changed = false_ _        for (final String key : settings.keySet()) {_            final Setting<?> setting = getRaw(key)__            final SettingUpgrader<?> upgrader = settingUpgraders.get(setting)__            if (upgrader == null) {_                _                builder.copy(key, settings)__            } else {_                _                changed = true__                _                if (setting.getConcreteSetting(key).isListSetting()) {_                    final List<String> value = settings.getAsList(key)__                    final String upgradedKey = upgrader.getKey(key)__                    final List<String> upgradedValue = upgrader.getListValue(value)__                    builder.putList(upgradedKey, upgradedValue)__                } else {_                    final String value = settings.get(key)__                    final String upgradedKey = upgrader.getKey(key)__                    final String upgradedValue = upgrader.getValue(value)__                    builder.put(upgradedKey, upgradedValue)__                }_            }_        }_        _        return changed ? builder.build() : settings__    };upgrade,all,settings,eligible,for,upgrade,in,the,specified,settings,instance,param,settings,the,settings,instance,that,might,contain,settings,to,be,upgraded,return,a,new,settings,instance,if,any,settings,required,upgrade,otherwise,the,same,settings,instance,as,specified;public,settings,upgrade,settings,final,settings,settings,final,settings,builder,builder,settings,builder,boolean,changed,false,for,final,string,key,settings,key,set,final,setting,setting,get,raw,key,final,setting,upgrader,upgrader,setting,upgraders,get,setting,if,upgrader,null,builder,copy,key,settings,else,changed,true,if,setting,get,concrete,setting,key,is,list,setting,final,list,string,value,settings,get,as,list,key,final,string,upgraded,key,upgrader,get,key,key,final,list,string,upgraded,value,upgrader,get,list,value,value,builder,put,list,upgraded,key,upgraded,value,else,final,string,value,settings,get,key,final,string,upgraded,key,upgrader,get,key,key,final,string,upgraded,value,upgrader,get,value,value,builder,put,upgraded,key,upgraded,value,return,changed,builder,build,settings
AbstractScopedSettings -> public Settings upgradeSettings(final Settings settings);1542402632;Upgrade all settings eligible for upgrade in the specified settings instance.__@param settings the settings instance that might contain settings to be upgraded_@return a new settings instance if any settings required upgrade, otherwise the same settings instance as specified;public Settings upgradeSettings(final Settings settings) {_        final Settings.Builder builder = Settings.builder()__        boolean changed = false_ _        for (final String key : settings.keySet()) {_            final Setting<?> setting = getRaw(key)__            final SettingUpgrader<?> upgrader = settingUpgraders.get(setting)__            if (upgrader == null) {_                _                builder.copy(key, settings)__            } else {_                _                changed = true__                _                if (setting.getConcreteSetting(key).isListSetting()) {_                    final List<String> value = settings.getAsList(key)__                    final String upgradedKey = upgrader.getKey(key)__                    final List<String> upgradedValue = upgrader.getListValue(value)__                    builder.putList(upgradedKey, upgradedValue)__                } else {_                    final String value = settings.get(key)__                    final String upgradedKey = upgrader.getKey(key)__                    final String upgradedValue = upgrader.getValue(value)__                    builder.put(upgradedKey, upgradedValue)__                }_            }_        }_        _        return changed ? builder.build() : settings__    };upgrade,all,settings,eligible,for,upgrade,in,the,specified,settings,instance,param,settings,the,settings,instance,that,might,contain,settings,to,be,upgraded,return,a,new,settings,instance,if,any,settings,required,upgrade,otherwise,the,same,settings,instance,as,specified;public,settings,upgrade,settings,final,settings,settings,final,settings,builder,builder,settings,builder,boolean,changed,false,for,final,string,key,settings,key,set,final,setting,setting,get,raw,key,final,setting,upgrader,upgrader,setting,upgraders,get,setting,if,upgrader,null,builder,copy,key,settings,else,changed,true,if,setting,get,concrete,setting,key,is,list,setting,final,list,string,value,settings,get,as,list,key,final,string,upgraded,key,upgrader,get,key,key,final,list,string,upgraded,value,upgrader,get,list,value,value,builder,put,list,upgraded,key,upgraded,value,else,final,string,value,settings,get,key,final,string,upgraded,key,upgrader,get,key,key,final,string,upgraded,value,upgrader,get,value,value,builder,put,upgraded,key,upgraded,value,return,changed,builder,build,settings
AbstractScopedSettings -> public Settings upgradeSettings(final Settings settings);1544081506;Upgrade all settings eligible for upgrade in the specified settings instance.__@param settings the settings instance that might contain settings to be upgraded_@return a new settings instance if any settings required upgrade, otherwise the same settings instance as specified;public Settings upgradeSettings(final Settings settings) {_        final Settings.Builder builder = Settings.builder()__        boolean changed = false_ _        for (final String key : settings.keySet()) {_            final Setting<?> setting = getRaw(key)__            final SettingUpgrader<?> upgrader = settingUpgraders.get(setting)__            if (upgrader == null) {_                _                builder.copy(key, settings)__            } else {_                _                changed = true__                _                if (setting.getConcreteSetting(key).isListSetting()) {_                    final List<String> value = settings.getAsList(key)__                    final String upgradedKey = upgrader.getKey(key)__                    final List<String> upgradedValue = upgrader.getListValue(value)__                    builder.putList(upgradedKey, upgradedValue)__                } else {_                    final String value = settings.get(key)__                    final String upgradedKey = upgrader.getKey(key)__                    final String upgradedValue = upgrader.getValue(value)__                    builder.put(upgradedKey, upgradedValue)__                }_            }_        }_        _        return changed ? builder.build() : settings__    };upgrade,all,settings,eligible,for,upgrade,in,the,specified,settings,instance,param,settings,the,settings,instance,that,might,contain,settings,to,be,upgraded,return,a,new,settings,instance,if,any,settings,required,upgrade,otherwise,the,same,settings,instance,as,specified;public,settings,upgrade,settings,final,settings,settings,final,settings,builder,builder,settings,builder,boolean,changed,false,for,final,string,key,settings,key,set,final,setting,setting,get,raw,key,final,setting,upgrader,upgrader,setting,upgraders,get,setting,if,upgrader,null,builder,copy,key,settings,else,changed,true,if,setting,get,concrete,setting,key,is,list,setting,final,list,string,value,settings,get,as,list,key,final,string,upgraded,key,upgrader,get,key,key,final,list,string,upgraded,value,upgrader,get,list,value,value,builder,put,list,upgraded,key,upgraded,value,else,final,string,value,settings,get,key,final,string,upgraded,key,upgrader,get,key,key,final,string,upgraded,value,upgrader,get,value,value,builder,put,upgraded,key,upgraded,value,return,changed,builder,build,settings
AbstractScopedSettings -> public Settings upgradeSettings(final Settings settings);1544691774;Upgrade all settings eligible for upgrade in the specified settings instance.__@param settings the settings instance that might contain settings to be upgraded_@return a new settings instance if any settings required upgrade, otherwise the same settings instance as specified;public Settings upgradeSettings(final Settings settings) {_        final Settings.Builder builder = Settings.builder()__        boolean changed = false_ _        for (final String key : settings.keySet()) {_            final Setting<?> setting = getRaw(key)__            final SettingUpgrader<?> upgrader = settingUpgraders.get(setting)__            if (upgrader == null) {_                _                builder.copy(key, settings)__            } else {_                _                changed = true__                _                if (setting.getConcreteSetting(key).isListSetting()) {_                    final List<String> value = settings.getAsList(key)__                    final String upgradedKey = upgrader.getKey(key)__                    final List<String> upgradedValue = upgrader.getListValue(value)__                    builder.putList(upgradedKey, upgradedValue)__                } else {_                    final String value = settings.get(key)__                    final String upgradedKey = upgrader.getKey(key)__                    final String upgradedValue = upgrader.getValue(value)__                    builder.put(upgradedKey, upgradedValue)__                }_            }_        }_        _        return changed ? builder.build() : settings__    };upgrade,all,settings,eligible,for,upgrade,in,the,specified,settings,instance,param,settings,the,settings,instance,that,might,contain,settings,to,be,upgraded,return,a,new,settings,instance,if,any,settings,required,upgrade,otherwise,the,same,settings,instance,as,specified;public,settings,upgrade,settings,final,settings,settings,final,settings,builder,builder,settings,builder,boolean,changed,false,for,final,string,key,settings,key,set,final,setting,setting,get,raw,key,final,setting,upgrader,upgrader,setting,upgraders,get,setting,if,upgrader,null,builder,copy,key,settings,else,changed,true,if,setting,get,concrete,setting,key,is,list,setting,final,list,string,value,settings,get,as,list,key,final,string,upgraded,key,upgrader,get,key,key,final,list,string,upgraded,value,upgrader,get,list,value,value,builder,put,list,upgraded,key,upgraded,value,else,final,string,value,settings,get,key,final,string,upgraded,key,upgrader,get,key,key,final,string,upgraded,value,upgrader,get,value,value,builder,put,upgraded,key,upgraded,value,return,changed,builder,build,settings
AbstractScopedSettings -> public Settings upgradeSettings(final Settings settings);1546877578;Upgrade all settings eligible for upgrade in the specified settings instance.__@param settings the settings instance that might contain settings to be upgraded_@return a new settings instance if any settings required upgrade, otherwise the same settings instance as specified;public Settings upgradeSettings(final Settings settings) {_        final Settings.Builder builder = Settings.builder()__        boolean changed = false_ _        for (final String key : settings.keySet()) {_            final Setting<?> setting = getRaw(key)__            final SettingUpgrader<?> upgrader = settingUpgraders.get(setting)__            if (upgrader == null) {_                _                builder.copy(key, settings)__            } else {_                _                changed = true__                _                if (setting.getConcreteSetting(key).isListSetting()) {_                    final List<String> value = settings.getAsList(key)__                    final String upgradedKey = upgrader.getKey(key)__                    final List<String> upgradedValue = upgrader.getListValue(value)__                    builder.putList(upgradedKey, upgradedValue)__                } else {_                    final String value = settings.get(key)__                    final String upgradedKey = upgrader.getKey(key)__                    final String upgradedValue = upgrader.getValue(value)__                    builder.put(upgradedKey, upgradedValue)__                }_            }_        }_        _        return changed ? builder.build() : settings__    };upgrade,all,settings,eligible,for,upgrade,in,the,specified,settings,instance,param,settings,the,settings,instance,that,might,contain,settings,to,be,upgraded,return,a,new,settings,instance,if,any,settings,required,upgrade,otherwise,the,same,settings,instance,as,specified;public,settings,upgrade,settings,final,settings,settings,final,settings,builder,builder,settings,builder,boolean,changed,false,for,final,string,key,settings,key,set,final,setting,setting,get,raw,key,final,setting,upgrader,upgrader,setting,upgraders,get,setting,if,upgrader,null,builder,copy,key,settings,else,changed,true,if,setting,get,concrete,setting,key,is,list,setting,final,list,string,value,settings,get,as,list,key,final,string,upgraded,key,upgrader,get,key,key,final,list,string,upgraded,value,upgrader,get,list,value,value,builder,put,list,upgraded,key,upgraded,value,else,final,string,value,settings,get,key,final,string,upgraded,key,upgrader,get,key,key,final,string,upgraded,value,upgrader,get,value,value,builder,put,upgraded,key,upgraded,value,return,changed,builder,build,settings
AbstractScopedSettings -> public Settings upgradeSettings(final Settings settings);1548270339;Upgrade all settings eligible for upgrade in the specified settings instance.__@param settings the settings instance that might contain settings to be upgraded_@return a new settings instance if any settings required upgrade, otherwise the same settings instance as specified;public Settings upgradeSettings(final Settings settings) {_        final Settings.Builder builder = Settings.builder()__        boolean changed = false_ _        for (final String key : settings.keySet()) {_            final Setting<?> setting = getRaw(key)__            final SettingUpgrader<?> upgrader = settingUpgraders.get(setting)__            if (upgrader == null) {_                _                builder.copy(key, settings)__            } else {_                _                changed = true__                _                if (setting.getConcreteSetting(key).isListSetting()) {_                    final List<String> value = settings.getAsList(key)__                    final String upgradedKey = upgrader.getKey(key)__                    final List<String> upgradedValue = upgrader.getListValue(value)__                    builder.putList(upgradedKey, upgradedValue)__                } else {_                    final String value = settings.get(key)__                    final String upgradedKey = upgrader.getKey(key)__                    final String upgradedValue = upgrader.getValue(value)__                    builder.put(upgradedKey, upgradedValue)__                }_            }_        }_        _        return changed ? builder.build() : settings__    };upgrade,all,settings,eligible,for,upgrade,in,the,specified,settings,instance,param,settings,the,settings,instance,that,might,contain,settings,to,be,upgraded,return,a,new,settings,instance,if,any,settings,required,upgrade,otherwise,the,same,settings,instance,as,specified;public,settings,upgrade,settings,final,settings,settings,final,settings,builder,builder,settings,builder,boolean,changed,false,for,final,string,key,settings,key,set,final,setting,setting,get,raw,key,final,setting,upgrader,upgrader,setting,upgraders,get,setting,if,upgrader,null,builder,copy,key,settings,else,changed,true,if,setting,get,concrete,setting,key,is,list,setting,final,list,string,value,settings,get,as,list,key,final,string,upgraded,key,upgrader,get,key,key,final,list,string,upgraded,value,upgrader,get,list,value,value,builder,put,list,upgraded,key,upgraded,value,else,final,string,value,settings,get,key,final,string,upgraded,key,upgrader,get,key,key,final,string,upgraded,value,upgrader,get,value,value,builder,put,upgraded,key,upgraded,value,return,changed,builder,build,settings
AbstractScopedSettings -> public boolean isPrivateSetting(String key);1524684173;Returns <code>true</code> iff the setting is a private setting ie. it should be treated as valid even though it has no internal_representation. Otherwise <code>false</code>;public boolean isPrivateSetting(String key) {_        return false__    };returns,code,true,code,iff,the,setting,is,a,private,setting,ie,it,should,be,treated,as,valid,even,though,it,has,no,internal,representation,otherwise,code,false,code;public,boolean,is,private,setting,string,key,return,false
AbstractScopedSettings -> public boolean isPrivateSetting(String key);1528904315;Returns <code>true</code> iff the setting is a private setting ie. it should be treated as valid even though it has no internal_representation. Otherwise <code>false</code>;public boolean isPrivateSetting(String key) {_        return false__    };returns,code,true,code,iff,the,setting,is,a,private,setting,ie,it,should,be,treated,as,valid,even,though,it,has,no,internal,representation,otherwise,code,false,code;public,boolean,is,private,setting,string,key,return,false
AbstractScopedSettings -> public boolean isPrivateSetting(String key);1531179852;Returns <code>true</code> iff the setting is a private setting ie. it should be treated as valid even though it has no internal_representation. Otherwise <code>false</code>;public boolean isPrivateSetting(String key) {_        return false__    };returns,code,true,code,iff,the,setting,is,a,private,setting,ie,it,should,be,treated,as,valid,even,though,it,has,no,internal,representation,otherwise,code,false,code;public,boolean,is,private,setting,string,key,return,false
AbstractScopedSettings -> public boolean isPrivateSetting(String key);1535046779;Returns <code>true</code> iff the setting is a private setting ie. it should be treated as valid even though it has no internal_representation. Otherwise <code>false</code>;public boolean isPrivateSetting(String key) {_        return false__    };returns,code,true,code,iff,the,setting,is,a,private,setting,ie,it,should,be,treated,as,valid,even,though,it,has,no,internal,representation,otherwise,code,false,code;public,boolean,is,private,setting,string,key,return,false
AbstractScopedSettings -> public boolean isPrivateSetting(String key);1536137328;Returns <code>true</code> iff the setting is a private setting ie. it should be treated as valid even though it has no internal_representation. Otherwise <code>false</code>;public boolean isPrivateSetting(String key) {_        return false__    };returns,code,true,code,iff,the,setting,is,a,private,setting,ie,it,should,be,treated,as,valid,even,though,it,has,no,internal,representation,otherwise,code,false,code;public,boolean,is,private,setting,string,key,return,false
AbstractScopedSettings -> public boolean isPrivateSetting(String key);1536314350;Returns <code>true</code> iff the setting is a private setting ie. it should be treated as valid even though it has no internal_representation. Otherwise <code>false</code>;public boolean isPrivateSetting(String key) {_        return false__    };returns,code,true,code,iff,the,setting,is,a,private,setting,ie,it,should,be,treated,as,valid,even,though,it,has,no,internal,representation,otherwise,code,false,code;public,boolean,is,private,setting,string,key,return,false
AbstractScopedSettings -> public boolean isPrivateSetting(String key);1536611444;Returns <code>true</code> iff the setting is a private setting ie. it should be treated as valid even though it has no internal_representation. Otherwise <code>false</code>;public boolean isPrivateSetting(String key) {_        return false__    };returns,code,true,code,iff,the,setting,is,a,private,setting,ie,it,should,be,treated,as,valid,even,though,it,has,no,internal,representation,otherwise,code,false,code;public,boolean,is,private,setting,string,key,return,false
AbstractScopedSettings -> public boolean isPrivateSetting(String key);1536828374;Returns <code>true</code> iff the setting is a private setting ie. it should be treated as valid even though it has no internal_representation. Otherwise <code>false</code>;public boolean isPrivateSetting(String key) {_        return false__    };returns,code,true,code,iff,the,setting,is,a,private,setting,ie,it,should,be,treated,as,valid,even,though,it,has,no,internal,representation,otherwise,code,false,code;public,boolean,is,private,setting,string,key,return,false
AbstractScopedSettings -> public boolean isPrivateSetting(String key);1539951844;Returns <code>true</code> iff the setting is a private setting ie. it should be treated as valid even though it has no internal_representation. Otherwise <code>false</code>;public boolean isPrivateSetting(String key) {_        return false__    };returns,code,true,code,iff,the,setting,is,a,private,setting,ie,it,should,be,treated,as,valid,even,though,it,has,no,internal,representation,otherwise,code,false,code;public,boolean,is,private,setting,string,key,return,false
AbstractScopedSettings -> public boolean isPrivateSetting(String key);1541008027;Returns <code>true</code> iff the setting is a private setting ie. it should be treated as valid even though it has no internal_representation. Otherwise <code>false</code>;public boolean isPrivateSetting(String key) {_        return false__    };returns,code,true,code,iff,the,setting,is,a,private,setting,ie,it,should,be,treated,as,valid,even,though,it,has,no,internal,representation,otherwise,code,false,code;public,boolean,is,private,setting,string,key,return,false
AbstractScopedSettings -> public boolean isPrivateSetting(String key);1541092382;Returns <code>true</code> iff the setting is a private setting ie. it should be treated as valid even though it has no internal_representation. Otherwise <code>false</code>;public boolean isPrivateSetting(String key) {_        return false__    };returns,code,true,code,iff,the,setting,is,a,private,setting,ie,it,should,be,treated,as,valid,even,though,it,has,no,internal,representation,otherwise,code,false,code;public,boolean,is,private,setting,string,key,return,false
AbstractScopedSettings -> public boolean isPrivateSetting(String key);1542402632;Returns <code>true</code> iff the setting is a private setting ie. it should be treated as valid even though it has no internal_representation. Otherwise <code>false</code>;public boolean isPrivateSetting(String key) {_        return false__    };returns,code,true,code,iff,the,setting,is,a,private,setting,ie,it,should,be,treated,as,valid,even,though,it,has,no,internal,representation,otherwise,code,false,code;public,boolean,is,private,setting,string,key,return,false
AbstractScopedSettings -> public boolean isPrivateSetting(String key);1544081506;Returns <code>true</code> iff the setting is a private setting ie. it should be treated as valid even though it has no internal_representation. Otherwise <code>false</code>;public boolean isPrivateSetting(String key) {_        return false__    };returns,code,true,code,iff,the,setting,is,a,private,setting,ie,it,should,be,treated,as,valid,even,though,it,has,no,internal,representation,otherwise,code,false,code;public,boolean,is,private,setting,string,key,return,false
AbstractScopedSettings -> public boolean isPrivateSetting(String key);1544691774;Returns <code>true</code> iff the setting is a private setting ie. it should be treated as valid even though it has no internal_representation. Otherwise <code>false</code>;public boolean isPrivateSetting(String key) {_        return false__    };returns,code,true,code,iff,the,setting,is,a,private,setting,ie,it,should,be,treated,as,valid,even,though,it,has,no,internal,representation,otherwise,code,false,code;public,boolean,is,private,setting,string,key,return,false
AbstractScopedSettings -> public boolean isPrivateSetting(String key);1546877578;Returns <code>true</code> iff the setting is a private setting ie. it should be treated as valid even though it has no internal_representation. Otherwise <code>false</code>;public boolean isPrivateSetting(String key) {_        return false__    };returns,code,true,code,iff,the,setting,is,a,private,setting,ie,it,should,be,treated,as,valid,even,though,it,has,no,internal,representation,otherwise,code,false,code;public,boolean,is,private,setting,string,key,return,false
AbstractScopedSettings -> public boolean isPrivateSetting(String key);1548270339;Returns <code>true</code> iff the setting is a private setting ie. it should be treated as valid even though it has no internal_representation. Otherwise <code>false</code>;public boolean isPrivateSetting(String key) {_        return false__    };returns,code,true,code,iff,the,setting,is,a,private,setting,ie,it,should,be,treated,as,valid,even,though,it,has,no,internal,representation,otherwise,code,false,code;public,boolean,is,private,setting,string,key,return,false
AbstractScopedSettings -> SettingUpdater -> default boolean apply(Settings current, Settings previous);1524684173;Updates this updaters value if it has changed._@return <code>true</code> iff the value has been updated.;default boolean apply(Settings current, Settings previous) {_            if (hasChanged(current, previous)) {_                T value = getValue(current, previous)__                apply(value, current, previous)__                return true__            }_            return false__        };updates,this,updaters,value,if,it,has,changed,return,code,true,code,iff,the,value,has,been,updated;default,boolean,apply,settings,current,settings,previous,if,has,changed,current,previous,t,value,get,value,current,previous,apply,value,current,previous,return,true,return,false
AbstractScopedSettings -> SettingUpdater -> default boolean apply(Settings current, Settings previous);1528904315;Updates this updaters value if it has changed._@return <code>true</code> iff the value has been updated.;default boolean apply(Settings current, Settings previous) {_            if (hasChanged(current, previous)) {_                T value = getValue(current, previous)__                apply(value, current, previous)__                return true__            }_            return false__        };updates,this,updaters,value,if,it,has,changed,return,code,true,code,iff,the,value,has,been,updated;default,boolean,apply,settings,current,settings,previous,if,has,changed,current,previous,t,value,get,value,current,previous,apply,value,current,previous,return,true,return,false
AbstractScopedSettings -> SettingUpdater -> default boolean apply(Settings current, Settings previous);1531179852;Updates this updaters value if it has changed._@return <code>true</code> iff the value has been updated.;default boolean apply(Settings current, Settings previous) {_            if (hasChanged(current, previous)) {_                T value = getValue(current, previous)__                apply(value, current, previous)__                return true__            }_            return false__        };updates,this,updaters,value,if,it,has,changed,return,code,true,code,iff,the,value,has,been,updated;default,boolean,apply,settings,current,settings,previous,if,has,changed,current,previous,t,value,get,value,current,previous,apply,value,current,previous,return,true,return,false
AbstractScopedSettings -> SettingUpdater -> default boolean apply(Settings current, Settings previous);1535046779;Updates this updaters value if it has changed._@return <code>true</code> iff the value has been updated.;default boolean apply(Settings current, Settings previous) {_            if (hasChanged(current, previous)) {_                T value = getValue(current, previous)__                apply(value, current, previous)__                return true__            }_            return false__        };updates,this,updaters,value,if,it,has,changed,return,code,true,code,iff,the,value,has,been,updated;default,boolean,apply,settings,current,settings,previous,if,has,changed,current,previous,t,value,get,value,current,previous,apply,value,current,previous,return,true,return,false
AbstractScopedSettings -> SettingUpdater -> default boolean apply(Settings current, Settings previous);1536137328;Updates this updaters value if it has changed._@return <code>true</code> iff the value has been updated.;default boolean apply(Settings current, Settings previous) {_            if (hasChanged(current, previous)) {_                T value = getValue(current, previous)__                apply(value, current, previous)__                return true__            }_            return false__        };updates,this,updaters,value,if,it,has,changed,return,code,true,code,iff,the,value,has,been,updated;default,boolean,apply,settings,current,settings,previous,if,has,changed,current,previous,t,value,get,value,current,previous,apply,value,current,previous,return,true,return,false
AbstractScopedSettings -> SettingUpdater -> default boolean apply(Settings current, Settings previous);1536314350;Updates this updaters value if it has changed._@return <code>true</code> iff the value has been updated.;default boolean apply(Settings current, Settings previous) {_            if (hasChanged(current, previous)) {_                T value = getValue(current, previous)__                apply(value, current, previous)__                return true__            }_            return false__        };updates,this,updaters,value,if,it,has,changed,return,code,true,code,iff,the,value,has,been,updated;default,boolean,apply,settings,current,settings,previous,if,has,changed,current,previous,t,value,get,value,current,previous,apply,value,current,previous,return,true,return,false
AbstractScopedSettings -> SettingUpdater -> default boolean apply(Settings current, Settings previous);1536611444;Updates this updaters value if it has changed._@return <code>true</code> iff the value has been updated.;default boolean apply(Settings current, Settings previous) {_            if (hasChanged(current, previous)) {_                T value = getValue(current, previous)__                apply(value, current, previous)__                return true__            }_            return false__        };updates,this,updaters,value,if,it,has,changed,return,code,true,code,iff,the,value,has,been,updated;default,boolean,apply,settings,current,settings,previous,if,has,changed,current,previous,t,value,get,value,current,previous,apply,value,current,previous,return,true,return,false
AbstractScopedSettings -> SettingUpdater -> default boolean apply(Settings current, Settings previous);1536828374;Updates this updaters value if it has changed._@return <code>true</code> iff the value has been updated.;default boolean apply(Settings current, Settings previous) {_            if (hasChanged(current, previous)) {_                T value = getValue(current, previous)__                apply(value, current, previous)__                return true__            }_            return false__        };updates,this,updaters,value,if,it,has,changed,return,code,true,code,iff,the,value,has,been,updated;default,boolean,apply,settings,current,settings,previous,if,has,changed,current,previous,t,value,get,value,current,previous,apply,value,current,previous,return,true,return,false
AbstractScopedSettings -> SettingUpdater -> default boolean apply(Settings current, Settings previous);1539951844;Updates this updaters value if it has changed._@return <code>true</code> iff the value has been updated.;default boolean apply(Settings current, Settings previous) {_            if (hasChanged(current, previous)) {_                T value = getValue(current, previous)__                apply(value, current, previous)__                return true__            }_            return false__        };updates,this,updaters,value,if,it,has,changed,return,code,true,code,iff,the,value,has,been,updated;default,boolean,apply,settings,current,settings,previous,if,has,changed,current,previous,t,value,get,value,current,previous,apply,value,current,previous,return,true,return,false
AbstractScopedSettings -> SettingUpdater -> default boolean apply(Settings current, Settings previous);1541008027;Updates this updaters value if it has changed._@return <code>true</code> iff the value has been updated.;default boolean apply(Settings current, Settings previous) {_            if (hasChanged(current, previous)) {_                T value = getValue(current, previous)__                apply(value, current, previous)__                return true__            }_            return false__        };updates,this,updaters,value,if,it,has,changed,return,code,true,code,iff,the,value,has,been,updated;default,boolean,apply,settings,current,settings,previous,if,has,changed,current,previous,t,value,get,value,current,previous,apply,value,current,previous,return,true,return,false
AbstractScopedSettings -> SettingUpdater -> default boolean apply(Settings current, Settings previous);1541092382;Updates this updaters value if it has changed._@return <code>true</code> iff the value has been updated.;default boolean apply(Settings current, Settings previous) {_            if (hasChanged(current, previous)) {_                T value = getValue(current, previous)__                apply(value, current, previous)__                return true__            }_            return false__        };updates,this,updaters,value,if,it,has,changed,return,code,true,code,iff,the,value,has,been,updated;default,boolean,apply,settings,current,settings,previous,if,has,changed,current,previous,t,value,get,value,current,previous,apply,value,current,previous,return,true,return,false
AbstractScopedSettings -> SettingUpdater -> default boolean apply(Settings current, Settings previous);1542402632;Updates this updaters value if it has changed._@return <code>true</code> iff the value has been updated.;default boolean apply(Settings current, Settings previous) {_            if (hasChanged(current, previous)) {_                T value = getValue(current, previous)__                apply(value, current, previous)__                return true__            }_            return false__        };updates,this,updaters,value,if,it,has,changed,return,code,true,code,iff,the,value,has,been,updated;default,boolean,apply,settings,current,settings,previous,if,has,changed,current,previous,t,value,get,value,current,previous,apply,value,current,previous,return,true,return,false
AbstractScopedSettings -> SettingUpdater -> default boolean apply(Settings current, Settings previous);1544081506;Updates this updaters value if it has changed._@return <code>true</code> iff the value has been updated.;default boolean apply(Settings current, Settings previous) {_            if (hasChanged(current, previous)) {_                T value = getValue(current, previous)__                apply(value, current, previous)__                return true__            }_            return false__        };updates,this,updaters,value,if,it,has,changed,return,code,true,code,iff,the,value,has,been,updated;default,boolean,apply,settings,current,settings,previous,if,has,changed,current,previous,t,value,get,value,current,previous,apply,value,current,previous,return,true,return,false
AbstractScopedSettings -> SettingUpdater -> default boolean apply(Settings current, Settings previous);1544691774;Updates this updaters value if it has changed._@return <code>true</code> iff the value has been updated.;default boolean apply(Settings current, Settings previous) {_            if (hasChanged(current, previous)) {_                T value = getValue(current, previous)__                apply(value, current, previous)__                return true__            }_            return false__        };updates,this,updaters,value,if,it,has,changed,return,code,true,code,iff,the,value,has,been,updated;default,boolean,apply,settings,current,settings,previous,if,has,changed,current,previous,t,value,get,value,current,previous,apply,value,current,previous,return,true,return,false
AbstractScopedSettings -> SettingUpdater -> default boolean apply(Settings current, Settings previous);1546877578;Updates this updaters value if it has changed._@return <code>true</code> iff the value has been updated.;default boolean apply(Settings current, Settings previous) {_            if (hasChanged(current, previous)) {_                T value = getValue(current, previous)__                apply(value, current, previous)__                return true__            }_            return false__        };updates,this,updaters,value,if,it,has,changed,return,code,true,code,iff,the,value,has,been,updated;default,boolean,apply,settings,current,settings,previous,if,has,changed,current,previous,t,value,get,value,current,previous,apply,value,current,previous,return,true,return,false
AbstractScopedSettings -> SettingUpdater -> default boolean apply(Settings current, Settings previous);1548270339;Updates this updaters value if it has changed._@return <code>true</code> iff the value has been updated.;default boolean apply(Settings current, Settings previous) {_            if (hasChanged(current, previous)) {_                T value = getValue(current, previous)__                apply(value, current, previous)__                return true__            }_            return false__        };updates,this,updaters,value,if,it,has,changed,return,code,true,code,iff,the,value,has,been,updated;default,boolean,apply,settings,current,settings,previous,if,has,changed,current,previous,t,value,get,value,current,previous,apply,value,current,previous,return,true,return,false
AbstractScopedSettings -> public Settings archiveUnknownOrInvalidSettings(         final Settings settings,         final Consumer<Map.Entry<String, String>> unknownConsumer,         final BiConsumer<Map.Entry<String, String>, IllegalArgumentException> invalidConsumer);1524684173;Archives invalid or unknown settings. Any setting that is not recognized or fails validation_will be archived. This means the setting is prefixed with {@value ARCHIVED_SETTINGS_PREFIX}_and remains in the settings object. This can be used to detect invalid settings via APIs.__@param settings        the {@link Settings} instance to scan for unknown or invalid settings_@param unknownConsumer callback on unknown settings (consumer receives unknown key and its_associated value)_@param invalidConsumer callback on invalid settings (consumer receives invalid key, its_associated value and an exception)_@return a {@link Settings} instance with the unknown or invalid settings archived;public Settings archiveUnknownOrInvalidSettings(_        final Settings settings,_        final Consumer<Map.Entry<String, String>> unknownConsumer,_        final BiConsumer<Map.Entry<String, String>, IllegalArgumentException> invalidConsumer) {_        Settings.Builder builder = Settings.builder()__        boolean changed = false__        for (String key : settings.keySet()) {_            try {_                Setting<?> setting = get(key)__                if (setting != null) {_                    setting.get(settings)__                    builder.copy(key, settings)__                } else {_                    if (key.startsWith(ARCHIVED_SETTINGS_PREFIX) || isPrivateSetting(key)) {_                        builder.copy(key, settings)__                    } else {_                        changed = true__                        unknownConsumer.accept(new Entry(key, settings))__                        _                        builder.copy(ARCHIVED_SETTINGS_PREFIX + key, key, settings)__                    }_                }_            } catch (IllegalArgumentException ex) {_                changed = true__                invalidConsumer.accept(new Entry(key, settings), ex)__                _                builder.copy(ARCHIVED_SETTINGS_PREFIX + key, key, settings)__            }_        }_        if (changed) {_            return builder.build()__        } else {_            return settings__        }_    };archives,invalid,or,unknown,settings,any,setting,that,is,not,recognized,or,fails,validation,will,be,archived,this,means,the,setting,is,prefixed,with,value,and,remains,in,the,settings,object,this,can,be,used,to,detect,invalid,settings,via,apis,param,settings,the,link,settings,instance,to,scan,for,unknown,or,invalid,settings,param,unknown,consumer,callback,on,unknown,settings,consumer,receives,unknown,key,and,its,associated,value,param,invalid,consumer,callback,on,invalid,settings,consumer,receives,invalid,key,its,associated,value,and,an,exception,return,a,link,settings,instance,with,the,unknown,or,invalid,settings,archived;public,settings,archive,unknown,or,invalid,settings,final,settings,settings,final,consumer,map,entry,string,string,unknown,consumer,final,bi,consumer,map,entry,string,string,illegal,argument,exception,invalid,consumer,settings,builder,builder,settings,builder,boolean,changed,false,for,string,key,settings,key,set,try,setting,setting,get,key,if,setting,null,setting,get,settings,builder,copy,key,settings,else,if,key,starts,with,is,private,setting,key,builder,copy,key,settings,else,changed,true,unknown,consumer,accept,new,entry,key,settings,builder,copy,key,key,settings,catch,illegal,argument,exception,ex,changed,true,invalid,consumer,accept,new,entry,key,settings,ex,builder,copy,key,key,settings,if,changed,return,builder,build,else,return,settings
AbstractScopedSettings -> public Settings archiveUnknownOrInvalidSettings(         final Settings settings,         final Consumer<Map.Entry<String, String>> unknownConsumer,         final BiConsumer<Map.Entry<String, String>, IllegalArgumentException> invalidConsumer);1528904315;Archives invalid or unknown settings. Any setting that is not recognized or fails validation_will be archived. This means the setting is prefixed with {@value ARCHIVED_SETTINGS_PREFIX}_and remains in the settings object. This can be used to detect invalid settings via APIs.__@param settings        the {@link Settings} instance to scan for unknown or invalid settings_@param unknownConsumer callback on unknown settings (consumer receives unknown key and its_associated value)_@param invalidConsumer callback on invalid settings (consumer receives invalid key, its_associated value and an exception)_@return a {@link Settings} instance with the unknown or invalid settings archived;public Settings archiveUnknownOrInvalidSettings(_        final Settings settings,_        final Consumer<Map.Entry<String, String>> unknownConsumer,_        final BiConsumer<Map.Entry<String, String>, IllegalArgumentException> invalidConsumer) {_        Settings.Builder builder = Settings.builder()__        boolean changed = false__        for (String key : settings.keySet()) {_            try {_                Setting<?> setting = get(key)__                if (setting != null) {_                    setting.get(settings)__                    builder.copy(key, settings)__                } else {_                    if (key.startsWith(ARCHIVED_SETTINGS_PREFIX) || isPrivateSetting(key)) {_                        builder.copy(key, settings)__                    } else {_                        changed = true__                        unknownConsumer.accept(new Entry(key, settings))__                        _                        builder.copy(ARCHIVED_SETTINGS_PREFIX + key, key, settings)__                    }_                }_            } catch (IllegalArgumentException ex) {_                changed = true__                invalidConsumer.accept(new Entry(key, settings), ex)__                _                builder.copy(ARCHIVED_SETTINGS_PREFIX + key, key, settings)__            }_        }_        if (changed) {_            return builder.build()__        } else {_            return settings__        }_    };archives,invalid,or,unknown,settings,any,setting,that,is,not,recognized,or,fails,validation,will,be,archived,this,means,the,setting,is,prefixed,with,value,and,remains,in,the,settings,object,this,can,be,used,to,detect,invalid,settings,via,apis,param,settings,the,link,settings,instance,to,scan,for,unknown,or,invalid,settings,param,unknown,consumer,callback,on,unknown,settings,consumer,receives,unknown,key,and,its,associated,value,param,invalid,consumer,callback,on,invalid,settings,consumer,receives,invalid,key,its,associated,value,and,an,exception,return,a,link,settings,instance,with,the,unknown,or,invalid,settings,archived;public,settings,archive,unknown,or,invalid,settings,final,settings,settings,final,consumer,map,entry,string,string,unknown,consumer,final,bi,consumer,map,entry,string,string,illegal,argument,exception,invalid,consumer,settings,builder,builder,settings,builder,boolean,changed,false,for,string,key,settings,key,set,try,setting,setting,get,key,if,setting,null,setting,get,settings,builder,copy,key,settings,else,if,key,starts,with,is,private,setting,key,builder,copy,key,settings,else,changed,true,unknown,consumer,accept,new,entry,key,settings,builder,copy,key,key,settings,catch,illegal,argument,exception,ex,changed,true,invalid,consumer,accept,new,entry,key,settings,ex,builder,copy,key,key,settings,if,changed,return,builder,build,else,return,settings
AbstractScopedSettings -> public Settings archiveUnknownOrInvalidSettings(         final Settings settings,         final Consumer<Map.Entry<String, String>> unknownConsumer,         final BiConsumer<Map.Entry<String, String>, IllegalArgumentException> invalidConsumer);1531179852;Archives invalid or unknown settings. Any setting that is not recognized or fails validation_will be archived. This means the setting is prefixed with {@value ARCHIVED_SETTINGS_PREFIX}_and remains in the settings object. This can be used to detect invalid settings via APIs.__@param settings        the {@link Settings} instance to scan for unknown or invalid settings_@param unknownConsumer callback on unknown settings (consumer receives unknown key and its_associated value)_@param invalidConsumer callback on invalid settings (consumer receives invalid key, its_associated value and an exception)_@return a {@link Settings} instance with the unknown or invalid settings archived;public Settings archiveUnknownOrInvalidSettings(_        final Settings settings,_        final Consumer<Map.Entry<String, String>> unknownConsumer,_        final BiConsumer<Map.Entry<String, String>, IllegalArgumentException> invalidConsumer) {_        Settings.Builder builder = Settings.builder()__        boolean changed = false__        for (String key : settings.keySet()) {_            try {_                Setting<?> setting = get(key)__                if (setting != null) {_                    setting.get(settings)__                    builder.copy(key, settings)__                } else {_                    if (key.startsWith(ARCHIVED_SETTINGS_PREFIX) || isPrivateSetting(key)) {_                        builder.copy(key, settings)__                    } else {_                        changed = true__                        unknownConsumer.accept(new Entry(key, settings))__                        _                        builder.copy(ARCHIVED_SETTINGS_PREFIX + key, key, settings)__                    }_                }_            } catch (IllegalArgumentException ex) {_                changed = true__                invalidConsumer.accept(new Entry(key, settings), ex)__                _                builder.copy(ARCHIVED_SETTINGS_PREFIX + key, key, settings)__            }_        }_        if (changed) {_            return builder.build()__        } else {_            return settings__        }_    };archives,invalid,or,unknown,settings,any,setting,that,is,not,recognized,or,fails,validation,will,be,archived,this,means,the,setting,is,prefixed,with,value,and,remains,in,the,settings,object,this,can,be,used,to,detect,invalid,settings,via,apis,param,settings,the,link,settings,instance,to,scan,for,unknown,or,invalid,settings,param,unknown,consumer,callback,on,unknown,settings,consumer,receives,unknown,key,and,its,associated,value,param,invalid,consumer,callback,on,invalid,settings,consumer,receives,invalid,key,its,associated,value,and,an,exception,return,a,link,settings,instance,with,the,unknown,or,invalid,settings,archived;public,settings,archive,unknown,or,invalid,settings,final,settings,settings,final,consumer,map,entry,string,string,unknown,consumer,final,bi,consumer,map,entry,string,string,illegal,argument,exception,invalid,consumer,settings,builder,builder,settings,builder,boolean,changed,false,for,string,key,settings,key,set,try,setting,setting,get,key,if,setting,null,setting,get,settings,builder,copy,key,settings,else,if,key,starts,with,is,private,setting,key,builder,copy,key,settings,else,changed,true,unknown,consumer,accept,new,entry,key,settings,builder,copy,key,key,settings,catch,illegal,argument,exception,ex,changed,true,invalid,consumer,accept,new,entry,key,settings,ex,builder,copy,key,key,settings,if,changed,return,builder,build,else,return,settings
AbstractScopedSettings -> public Settings archiveUnknownOrInvalidSettings(         final Settings settings,         final Consumer<Map.Entry<String, String>> unknownConsumer,         final BiConsumer<Map.Entry<String, String>, IllegalArgumentException> invalidConsumer);1535046779;Archives invalid or unknown settings. Any setting that is not recognized or fails validation_will be archived. This means the setting is prefixed with {@value ARCHIVED_SETTINGS_PREFIX}_and remains in the settings object. This can be used to detect invalid settings via APIs.__@param settings        the {@link Settings} instance to scan for unknown or invalid settings_@param unknownConsumer callback on unknown settings (consumer receives unknown key and its_associated value)_@param invalidConsumer callback on invalid settings (consumer receives invalid key, its_associated value and an exception)_@return a {@link Settings} instance with the unknown or invalid settings archived;public Settings archiveUnknownOrInvalidSettings(_        final Settings settings,_        final Consumer<Map.Entry<String, String>> unknownConsumer,_        final BiConsumer<Map.Entry<String, String>, IllegalArgumentException> invalidConsumer) {_        Settings.Builder builder = Settings.builder()__        boolean changed = false__        for (String key : settings.keySet()) {_            try {_                Setting<?> setting = get(key)__                if (setting != null) {_                    setting.get(settings)__                    builder.copy(key, settings)__                } else {_                    if (key.startsWith(ARCHIVED_SETTINGS_PREFIX) || isPrivateSetting(key)) {_                        builder.copy(key, settings)__                    } else {_                        changed = true__                        unknownConsumer.accept(new Entry(key, settings))__                        _                        builder.copy(ARCHIVED_SETTINGS_PREFIX + key, key, settings)__                    }_                }_            } catch (IllegalArgumentException ex) {_                changed = true__                invalidConsumer.accept(new Entry(key, settings), ex)__                _                builder.copy(ARCHIVED_SETTINGS_PREFIX + key, key, settings)__            }_        }_        if (changed) {_            return builder.build()__        } else {_            return settings__        }_    };archives,invalid,or,unknown,settings,any,setting,that,is,not,recognized,or,fails,validation,will,be,archived,this,means,the,setting,is,prefixed,with,value,and,remains,in,the,settings,object,this,can,be,used,to,detect,invalid,settings,via,apis,param,settings,the,link,settings,instance,to,scan,for,unknown,or,invalid,settings,param,unknown,consumer,callback,on,unknown,settings,consumer,receives,unknown,key,and,its,associated,value,param,invalid,consumer,callback,on,invalid,settings,consumer,receives,invalid,key,its,associated,value,and,an,exception,return,a,link,settings,instance,with,the,unknown,or,invalid,settings,archived;public,settings,archive,unknown,or,invalid,settings,final,settings,settings,final,consumer,map,entry,string,string,unknown,consumer,final,bi,consumer,map,entry,string,string,illegal,argument,exception,invalid,consumer,settings,builder,builder,settings,builder,boolean,changed,false,for,string,key,settings,key,set,try,setting,setting,get,key,if,setting,null,setting,get,settings,builder,copy,key,settings,else,if,key,starts,with,is,private,setting,key,builder,copy,key,settings,else,changed,true,unknown,consumer,accept,new,entry,key,settings,builder,copy,key,key,settings,catch,illegal,argument,exception,ex,changed,true,invalid,consumer,accept,new,entry,key,settings,ex,builder,copy,key,key,settings,if,changed,return,builder,build,else,return,settings
AbstractScopedSettings -> public Settings archiveUnknownOrInvalidSettings(         final Settings settings,         final Consumer<Map.Entry<String, String>> unknownConsumer,         final BiConsumer<Map.Entry<String, String>, IllegalArgumentException> invalidConsumer);1536137328;Archives invalid or unknown settings. Any setting that is not recognized or fails validation_will be archived. This means the setting is prefixed with {@value ARCHIVED_SETTINGS_PREFIX}_and remains in the settings object. This can be used to detect invalid settings via APIs.__@param settings        the {@link Settings} instance to scan for unknown or invalid settings_@param unknownConsumer callback on unknown settings (consumer receives unknown key and its_associated value)_@param invalidConsumer callback on invalid settings (consumer receives invalid key, its_associated value and an exception)_@return a {@link Settings} instance with the unknown or invalid settings archived;public Settings archiveUnknownOrInvalidSettings(_        final Settings settings,_        final Consumer<Map.Entry<String, String>> unknownConsumer,_        final BiConsumer<Map.Entry<String, String>, IllegalArgumentException> invalidConsumer) {_        Settings.Builder builder = Settings.builder()__        boolean changed = false__        for (String key : settings.keySet()) {_            try {_                Setting<?> setting = get(key)__                if (setting != null) {_                    setting.get(settings)__                    builder.copy(key, settings)__                } else {_                    if (key.startsWith(ARCHIVED_SETTINGS_PREFIX) || isPrivateSetting(key)) {_                        builder.copy(key, settings)__                    } else {_                        changed = true__                        unknownConsumer.accept(new Entry(key, settings))__                        _                        builder.copy(ARCHIVED_SETTINGS_PREFIX + key, key, settings)__                    }_                }_            } catch (IllegalArgumentException ex) {_                changed = true__                invalidConsumer.accept(new Entry(key, settings), ex)__                _                builder.copy(ARCHIVED_SETTINGS_PREFIX + key, key, settings)__            }_        }_        if (changed) {_            return builder.build()__        } else {_            return settings__        }_    };archives,invalid,or,unknown,settings,any,setting,that,is,not,recognized,or,fails,validation,will,be,archived,this,means,the,setting,is,prefixed,with,value,and,remains,in,the,settings,object,this,can,be,used,to,detect,invalid,settings,via,apis,param,settings,the,link,settings,instance,to,scan,for,unknown,or,invalid,settings,param,unknown,consumer,callback,on,unknown,settings,consumer,receives,unknown,key,and,its,associated,value,param,invalid,consumer,callback,on,invalid,settings,consumer,receives,invalid,key,its,associated,value,and,an,exception,return,a,link,settings,instance,with,the,unknown,or,invalid,settings,archived;public,settings,archive,unknown,or,invalid,settings,final,settings,settings,final,consumer,map,entry,string,string,unknown,consumer,final,bi,consumer,map,entry,string,string,illegal,argument,exception,invalid,consumer,settings,builder,builder,settings,builder,boolean,changed,false,for,string,key,settings,key,set,try,setting,setting,get,key,if,setting,null,setting,get,settings,builder,copy,key,settings,else,if,key,starts,with,is,private,setting,key,builder,copy,key,settings,else,changed,true,unknown,consumer,accept,new,entry,key,settings,builder,copy,key,key,settings,catch,illegal,argument,exception,ex,changed,true,invalid,consumer,accept,new,entry,key,settings,ex,builder,copy,key,key,settings,if,changed,return,builder,build,else,return,settings
AbstractScopedSettings -> public Settings archiveUnknownOrInvalidSettings(         final Settings settings,         final Consumer<Map.Entry<String, String>> unknownConsumer,         final BiConsumer<Map.Entry<String, String>, IllegalArgumentException> invalidConsumer);1536314350;Archives invalid or unknown settings. Any setting that is not recognized or fails validation_will be archived. This means the setting is prefixed with {@value ARCHIVED_SETTINGS_PREFIX}_and remains in the settings object. This can be used to detect invalid settings via APIs.__@param settings        the {@link Settings} instance to scan for unknown or invalid settings_@param unknownConsumer callback on unknown settings (consumer receives unknown key and its_associated value)_@param invalidConsumer callback on invalid settings (consumer receives invalid key, its_associated value and an exception)_@return a {@link Settings} instance with the unknown or invalid settings archived;public Settings archiveUnknownOrInvalidSettings(_        final Settings settings,_        final Consumer<Map.Entry<String, String>> unknownConsumer,_        final BiConsumer<Map.Entry<String, String>, IllegalArgumentException> invalidConsumer) {_        Settings.Builder builder = Settings.builder()__        boolean changed = false__        for (String key : settings.keySet()) {_            try {_                Setting<?> setting = get(key)__                if (setting != null) {_                    setting.get(settings)__                    builder.copy(key, settings)__                } else {_                    if (key.startsWith(ARCHIVED_SETTINGS_PREFIX) || isPrivateSetting(key)) {_                        builder.copy(key, settings)__                    } else {_                        changed = true__                        unknownConsumer.accept(new Entry(key, settings))__                        _                        builder.copy(ARCHIVED_SETTINGS_PREFIX + key, key, settings)__                    }_                }_            } catch (IllegalArgumentException ex) {_                changed = true__                invalidConsumer.accept(new Entry(key, settings), ex)__                _                builder.copy(ARCHIVED_SETTINGS_PREFIX + key, key, settings)__            }_        }_        if (changed) {_            return builder.build()__        } else {_            return settings__        }_    };archives,invalid,or,unknown,settings,any,setting,that,is,not,recognized,or,fails,validation,will,be,archived,this,means,the,setting,is,prefixed,with,value,and,remains,in,the,settings,object,this,can,be,used,to,detect,invalid,settings,via,apis,param,settings,the,link,settings,instance,to,scan,for,unknown,or,invalid,settings,param,unknown,consumer,callback,on,unknown,settings,consumer,receives,unknown,key,and,its,associated,value,param,invalid,consumer,callback,on,invalid,settings,consumer,receives,invalid,key,its,associated,value,and,an,exception,return,a,link,settings,instance,with,the,unknown,or,invalid,settings,archived;public,settings,archive,unknown,or,invalid,settings,final,settings,settings,final,consumer,map,entry,string,string,unknown,consumer,final,bi,consumer,map,entry,string,string,illegal,argument,exception,invalid,consumer,settings,builder,builder,settings,builder,boolean,changed,false,for,string,key,settings,key,set,try,setting,setting,get,key,if,setting,null,setting,get,settings,builder,copy,key,settings,else,if,key,starts,with,is,private,setting,key,builder,copy,key,settings,else,changed,true,unknown,consumer,accept,new,entry,key,settings,builder,copy,key,key,settings,catch,illegal,argument,exception,ex,changed,true,invalid,consumer,accept,new,entry,key,settings,ex,builder,copy,key,key,settings,if,changed,return,builder,build,else,return,settings
AbstractScopedSettings -> public Settings archiveUnknownOrInvalidSettings(         final Settings settings,         final Consumer<Map.Entry<String, String>> unknownConsumer,         final BiConsumer<Map.Entry<String, String>, IllegalArgumentException> invalidConsumer);1536611444;Archives invalid or unknown settings. Any setting that is not recognized or fails validation_will be archived. This means the setting is prefixed with {@value ARCHIVED_SETTINGS_PREFIX}_and remains in the settings object. This can be used to detect invalid settings via APIs.__@param settings        the {@link Settings} instance to scan for unknown or invalid settings_@param unknownConsumer callback on unknown settings (consumer receives unknown key and its_associated value)_@param invalidConsumer callback on invalid settings (consumer receives invalid key, its_associated value and an exception)_@return a {@link Settings} instance with the unknown or invalid settings archived;public Settings archiveUnknownOrInvalidSettings(_        final Settings settings,_        final Consumer<Map.Entry<String, String>> unknownConsumer,_        final BiConsumer<Map.Entry<String, String>, IllegalArgumentException> invalidConsumer) {_        Settings.Builder builder = Settings.builder()__        boolean changed = false__        for (String key : settings.keySet()) {_            try {_                Setting<?> setting = get(key)__                if (setting != null) {_                    setting.get(settings)__                    builder.copy(key, settings)__                } else {_                    if (key.startsWith(ARCHIVED_SETTINGS_PREFIX) || isPrivateSetting(key)) {_                        builder.copy(key, settings)__                    } else {_                        changed = true__                        unknownConsumer.accept(new Entry(key, settings))__                        _                        builder.copy(ARCHIVED_SETTINGS_PREFIX + key, key, settings)__                    }_                }_            } catch (IllegalArgumentException ex) {_                changed = true__                invalidConsumer.accept(new Entry(key, settings), ex)__                _                builder.copy(ARCHIVED_SETTINGS_PREFIX + key, key, settings)__            }_        }_        if (changed) {_            return builder.build()__        } else {_            return settings__        }_    };archives,invalid,or,unknown,settings,any,setting,that,is,not,recognized,or,fails,validation,will,be,archived,this,means,the,setting,is,prefixed,with,value,and,remains,in,the,settings,object,this,can,be,used,to,detect,invalid,settings,via,apis,param,settings,the,link,settings,instance,to,scan,for,unknown,or,invalid,settings,param,unknown,consumer,callback,on,unknown,settings,consumer,receives,unknown,key,and,its,associated,value,param,invalid,consumer,callback,on,invalid,settings,consumer,receives,invalid,key,its,associated,value,and,an,exception,return,a,link,settings,instance,with,the,unknown,or,invalid,settings,archived;public,settings,archive,unknown,or,invalid,settings,final,settings,settings,final,consumer,map,entry,string,string,unknown,consumer,final,bi,consumer,map,entry,string,string,illegal,argument,exception,invalid,consumer,settings,builder,builder,settings,builder,boolean,changed,false,for,string,key,settings,key,set,try,setting,setting,get,key,if,setting,null,setting,get,settings,builder,copy,key,settings,else,if,key,starts,with,is,private,setting,key,builder,copy,key,settings,else,changed,true,unknown,consumer,accept,new,entry,key,settings,builder,copy,key,key,settings,catch,illegal,argument,exception,ex,changed,true,invalid,consumer,accept,new,entry,key,settings,ex,builder,copy,key,key,settings,if,changed,return,builder,build,else,return,settings
AbstractScopedSettings -> public Settings archiveUnknownOrInvalidSettings(         final Settings settings,         final Consumer<Map.Entry<String, String>> unknownConsumer,         final BiConsumer<Map.Entry<String, String>, IllegalArgumentException> invalidConsumer);1536828374;Archives invalid or unknown settings. Any setting that is not recognized or fails validation_will be archived. This means the setting is prefixed with {@value ARCHIVED_SETTINGS_PREFIX}_and remains in the settings object. This can be used to detect invalid settings via APIs.__@param settings        the {@link Settings} instance to scan for unknown or invalid settings_@param unknownConsumer callback on unknown settings (consumer receives unknown key and its_associated value)_@param invalidConsumer callback on invalid settings (consumer receives invalid key, its_associated value and an exception)_@return a {@link Settings} instance with the unknown or invalid settings archived;public Settings archiveUnknownOrInvalidSettings(_        final Settings settings,_        final Consumer<Map.Entry<String, String>> unknownConsumer,_        final BiConsumer<Map.Entry<String, String>, IllegalArgumentException> invalidConsumer) {_        Settings.Builder builder = Settings.builder()__        boolean changed = false__        for (String key : settings.keySet()) {_            try {_                Setting<?> setting = get(key)__                if (setting != null) {_                    setting.get(settings)__                    builder.copy(key, settings)__                } else {_                    if (key.startsWith(ARCHIVED_SETTINGS_PREFIX) || isPrivateSetting(key)) {_                        builder.copy(key, settings)__                    } else {_                        changed = true__                        unknownConsumer.accept(new Entry(key, settings))__                        _                        builder.copy(ARCHIVED_SETTINGS_PREFIX + key, key, settings)__                    }_                }_            } catch (IllegalArgumentException ex) {_                changed = true__                invalidConsumer.accept(new Entry(key, settings), ex)__                _                builder.copy(ARCHIVED_SETTINGS_PREFIX + key, key, settings)__            }_        }_        if (changed) {_            return builder.build()__        } else {_            return settings__        }_    };archives,invalid,or,unknown,settings,any,setting,that,is,not,recognized,or,fails,validation,will,be,archived,this,means,the,setting,is,prefixed,with,value,and,remains,in,the,settings,object,this,can,be,used,to,detect,invalid,settings,via,apis,param,settings,the,link,settings,instance,to,scan,for,unknown,or,invalid,settings,param,unknown,consumer,callback,on,unknown,settings,consumer,receives,unknown,key,and,its,associated,value,param,invalid,consumer,callback,on,invalid,settings,consumer,receives,invalid,key,its,associated,value,and,an,exception,return,a,link,settings,instance,with,the,unknown,or,invalid,settings,archived;public,settings,archive,unknown,or,invalid,settings,final,settings,settings,final,consumer,map,entry,string,string,unknown,consumer,final,bi,consumer,map,entry,string,string,illegal,argument,exception,invalid,consumer,settings,builder,builder,settings,builder,boolean,changed,false,for,string,key,settings,key,set,try,setting,setting,get,key,if,setting,null,setting,get,settings,builder,copy,key,settings,else,if,key,starts,with,is,private,setting,key,builder,copy,key,settings,else,changed,true,unknown,consumer,accept,new,entry,key,settings,builder,copy,key,key,settings,catch,illegal,argument,exception,ex,changed,true,invalid,consumer,accept,new,entry,key,settings,ex,builder,copy,key,key,settings,if,changed,return,builder,build,else,return,settings
AbstractScopedSettings -> public Settings archiveUnknownOrInvalidSettings(         final Settings settings,         final Consumer<Map.Entry<String, String>> unknownConsumer,         final BiConsumer<Map.Entry<String, String>, IllegalArgumentException> invalidConsumer);1539951844;Archives invalid or unknown settings. Any setting that is not recognized or fails validation_will be archived. This means the setting is prefixed with {@value ARCHIVED_SETTINGS_PREFIX}_and remains in the settings object. This can be used to detect invalid settings via APIs.__@param settings        the {@link Settings} instance to scan for unknown or invalid settings_@param unknownConsumer callback on unknown settings (consumer receives unknown key and its_associated value)_@param invalidConsumer callback on invalid settings (consumer receives invalid key, its_associated value and an exception)_@return a {@link Settings} instance with the unknown or invalid settings archived;public Settings archiveUnknownOrInvalidSettings(_        final Settings settings,_        final Consumer<Map.Entry<String, String>> unknownConsumer,_        final BiConsumer<Map.Entry<String, String>, IllegalArgumentException> invalidConsumer) {_        Settings.Builder builder = Settings.builder()__        boolean changed = false__        for (String key : settings.keySet()) {_            try {_                Setting<?> setting = get(key)__                if (setting != null) {_                    setting.get(settings)__                    builder.copy(key, settings)__                } else {_                    if (key.startsWith(ARCHIVED_SETTINGS_PREFIX) || isPrivateSetting(key)) {_                        builder.copy(key, settings)__                    } else {_                        changed = true__                        unknownConsumer.accept(new Entry(key, settings))__                        _                        builder.copy(ARCHIVED_SETTINGS_PREFIX + key, key, settings)__                    }_                }_            } catch (IllegalArgumentException ex) {_                changed = true__                invalidConsumer.accept(new Entry(key, settings), ex)__                _                builder.copy(ARCHIVED_SETTINGS_PREFIX + key, key, settings)__            }_        }_        if (changed) {_            return builder.build()__        } else {_            return settings__        }_    };archives,invalid,or,unknown,settings,any,setting,that,is,not,recognized,or,fails,validation,will,be,archived,this,means,the,setting,is,prefixed,with,value,and,remains,in,the,settings,object,this,can,be,used,to,detect,invalid,settings,via,apis,param,settings,the,link,settings,instance,to,scan,for,unknown,or,invalid,settings,param,unknown,consumer,callback,on,unknown,settings,consumer,receives,unknown,key,and,its,associated,value,param,invalid,consumer,callback,on,invalid,settings,consumer,receives,invalid,key,its,associated,value,and,an,exception,return,a,link,settings,instance,with,the,unknown,or,invalid,settings,archived;public,settings,archive,unknown,or,invalid,settings,final,settings,settings,final,consumer,map,entry,string,string,unknown,consumer,final,bi,consumer,map,entry,string,string,illegal,argument,exception,invalid,consumer,settings,builder,builder,settings,builder,boolean,changed,false,for,string,key,settings,key,set,try,setting,setting,get,key,if,setting,null,setting,get,settings,builder,copy,key,settings,else,if,key,starts,with,is,private,setting,key,builder,copy,key,settings,else,changed,true,unknown,consumer,accept,new,entry,key,settings,builder,copy,key,key,settings,catch,illegal,argument,exception,ex,changed,true,invalid,consumer,accept,new,entry,key,settings,ex,builder,copy,key,key,settings,if,changed,return,builder,build,else,return,settings
AbstractScopedSettings -> public Settings archiveUnknownOrInvalidSettings(         final Settings settings,         final Consumer<Map.Entry<String, String>> unknownConsumer,         final BiConsumer<Map.Entry<String, String>, IllegalArgumentException> invalidConsumer);1541008027;Archives invalid or unknown settings. Any setting that is not recognized or fails validation_will be archived. This means the setting is prefixed with {@value ARCHIVED_SETTINGS_PREFIX}_and remains in the settings object. This can be used to detect invalid settings via APIs.__@param settings        the {@link Settings} instance to scan for unknown or invalid settings_@param unknownConsumer callback on unknown settings (consumer receives unknown key and its_associated value)_@param invalidConsumer callback on invalid settings (consumer receives invalid key, its_associated value and an exception)_@return a {@link Settings} instance with the unknown or invalid settings archived;public Settings archiveUnknownOrInvalidSettings(_        final Settings settings,_        final Consumer<Map.Entry<String, String>> unknownConsumer,_        final BiConsumer<Map.Entry<String, String>, IllegalArgumentException> invalidConsumer) {_        Settings.Builder builder = Settings.builder()__        boolean changed = false__        for (String key : settings.keySet()) {_            try {_                Setting<?> setting = get(key)__                if (setting != null) {_                    setting.get(settings)__                    builder.copy(key, settings)__                } else {_                    if (key.startsWith(ARCHIVED_SETTINGS_PREFIX) || isPrivateSetting(key)) {_                        builder.copy(key, settings)__                    } else {_                        changed = true__                        unknownConsumer.accept(new Entry(key, settings))__                        _                        builder.copy(ARCHIVED_SETTINGS_PREFIX + key, key, settings)__                    }_                }_            } catch (IllegalArgumentException ex) {_                changed = true__                invalidConsumer.accept(new Entry(key, settings), ex)__                _                builder.copy(ARCHIVED_SETTINGS_PREFIX + key, key, settings)__            }_        }_        if (changed) {_            return builder.build()__        } else {_            return settings__        }_    };archives,invalid,or,unknown,settings,any,setting,that,is,not,recognized,or,fails,validation,will,be,archived,this,means,the,setting,is,prefixed,with,value,and,remains,in,the,settings,object,this,can,be,used,to,detect,invalid,settings,via,apis,param,settings,the,link,settings,instance,to,scan,for,unknown,or,invalid,settings,param,unknown,consumer,callback,on,unknown,settings,consumer,receives,unknown,key,and,its,associated,value,param,invalid,consumer,callback,on,invalid,settings,consumer,receives,invalid,key,its,associated,value,and,an,exception,return,a,link,settings,instance,with,the,unknown,or,invalid,settings,archived;public,settings,archive,unknown,or,invalid,settings,final,settings,settings,final,consumer,map,entry,string,string,unknown,consumer,final,bi,consumer,map,entry,string,string,illegal,argument,exception,invalid,consumer,settings,builder,builder,settings,builder,boolean,changed,false,for,string,key,settings,key,set,try,setting,setting,get,key,if,setting,null,setting,get,settings,builder,copy,key,settings,else,if,key,starts,with,is,private,setting,key,builder,copy,key,settings,else,changed,true,unknown,consumer,accept,new,entry,key,settings,builder,copy,key,key,settings,catch,illegal,argument,exception,ex,changed,true,invalid,consumer,accept,new,entry,key,settings,ex,builder,copy,key,key,settings,if,changed,return,builder,build,else,return,settings
AbstractScopedSettings -> public Settings archiveUnknownOrInvalidSettings(         final Settings settings,         final Consumer<Map.Entry<String, String>> unknownConsumer,         final BiConsumer<Map.Entry<String, String>, IllegalArgumentException> invalidConsumer);1541092382;Archives invalid or unknown settings. Any setting that is not recognized or fails validation_will be archived. This means the setting is prefixed with {@value ARCHIVED_SETTINGS_PREFIX}_and remains in the settings object. This can be used to detect invalid settings via APIs.__@param settings        the {@link Settings} instance to scan for unknown or invalid settings_@param unknownConsumer callback on unknown settings (consumer receives unknown key and its_associated value)_@param invalidConsumer callback on invalid settings (consumer receives invalid key, its_associated value and an exception)_@return a {@link Settings} instance with the unknown or invalid settings archived;public Settings archiveUnknownOrInvalidSettings(_        final Settings settings,_        final Consumer<Map.Entry<String, String>> unknownConsumer,_        final BiConsumer<Map.Entry<String, String>, IllegalArgumentException> invalidConsumer) {_        Settings.Builder builder = Settings.builder()__        boolean changed = false__        for (String key : settings.keySet()) {_            try {_                Setting<?> setting = get(key)__                if (setting != null) {_                    setting.get(settings)__                    builder.copy(key, settings)__                } else {_                    if (key.startsWith(ARCHIVED_SETTINGS_PREFIX) || isPrivateSetting(key)) {_                        builder.copy(key, settings)__                    } else {_                        changed = true__                        unknownConsumer.accept(new Entry(key, settings))__                        _                        builder.copy(ARCHIVED_SETTINGS_PREFIX + key, key, settings)__                    }_                }_            } catch (IllegalArgumentException ex) {_                changed = true__                invalidConsumer.accept(new Entry(key, settings), ex)__                _                builder.copy(ARCHIVED_SETTINGS_PREFIX + key, key, settings)__            }_        }_        if (changed) {_            return builder.build()__        } else {_            return settings__        }_    };archives,invalid,or,unknown,settings,any,setting,that,is,not,recognized,or,fails,validation,will,be,archived,this,means,the,setting,is,prefixed,with,value,and,remains,in,the,settings,object,this,can,be,used,to,detect,invalid,settings,via,apis,param,settings,the,link,settings,instance,to,scan,for,unknown,or,invalid,settings,param,unknown,consumer,callback,on,unknown,settings,consumer,receives,unknown,key,and,its,associated,value,param,invalid,consumer,callback,on,invalid,settings,consumer,receives,invalid,key,its,associated,value,and,an,exception,return,a,link,settings,instance,with,the,unknown,or,invalid,settings,archived;public,settings,archive,unknown,or,invalid,settings,final,settings,settings,final,consumer,map,entry,string,string,unknown,consumer,final,bi,consumer,map,entry,string,string,illegal,argument,exception,invalid,consumer,settings,builder,builder,settings,builder,boolean,changed,false,for,string,key,settings,key,set,try,setting,setting,get,key,if,setting,null,setting,get,settings,builder,copy,key,settings,else,if,key,starts,with,is,private,setting,key,builder,copy,key,settings,else,changed,true,unknown,consumer,accept,new,entry,key,settings,builder,copy,key,key,settings,catch,illegal,argument,exception,ex,changed,true,invalid,consumer,accept,new,entry,key,settings,ex,builder,copy,key,key,settings,if,changed,return,builder,build,else,return,settings
AbstractScopedSettings -> public Settings archiveUnknownOrInvalidSettings(         final Settings settings,         final Consumer<Map.Entry<String, String>> unknownConsumer,         final BiConsumer<Map.Entry<String, String>, IllegalArgumentException> invalidConsumer);1542402632;Archives invalid or unknown settings. Any setting that is not recognized or fails validation_will be archived. This means the setting is prefixed with {@value ARCHIVED_SETTINGS_PREFIX}_and remains in the settings object. This can be used to detect invalid settings via APIs.__@param settings        the {@link Settings} instance to scan for unknown or invalid settings_@param unknownConsumer callback on unknown settings (consumer receives unknown key and its_associated value)_@param invalidConsumer callback on invalid settings (consumer receives invalid key, its_associated value and an exception)_@return a {@link Settings} instance with the unknown or invalid settings archived;public Settings archiveUnknownOrInvalidSettings(_        final Settings settings,_        final Consumer<Map.Entry<String, String>> unknownConsumer,_        final BiConsumer<Map.Entry<String, String>, IllegalArgumentException> invalidConsumer) {_        Settings.Builder builder = Settings.builder()__        boolean changed = false__        for (String key : settings.keySet()) {_            try {_                Setting<?> setting = get(key)__                if (setting != null) {_                    setting.get(settings)__                    builder.copy(key, settings)__                } else {_                    if (key.startsWith(ARCHIVED_SETTINGS_PREFIX) || isPrivateSetting(key)) {_                        builder.copy(key, settings)__                    } else {_                        changed = true__                        unknownConsumer.accept(new Entry(key, settings))__                        _                        builder.copy(ARCHIVED_SETTINGS_PREFIX + key, key, settings)__                    }_                }_            } catch (IllegalArgumentException ex) {_                changed = true__                invalidConsumer.accept(new Entry(key, settings), ex)__                _                builder.copy(ARCHIVED_SETTINGS_PREFIX + key, key, settings)__            }_        }_        if (changed) {_            return builder.build()__        } else {_            return settings__        }_    };archives,invalid,or,unknown,settings,any,setting,that,is,not,recognized,or,fails,validation,will,be,archived,this,means,the,setting,is,prefixed,with,value,and,remains,in,the,settings,object,this,can,be,used,to,detect,invalid,settings,via,apis,param,settings,the,link,settings,instance,to,scan,for,unknown,or,invalid,settings,param,unknown,consumer,callback,on,unknown,settings,consumer,receives,unknown,key,and,its,associated,value,param,invalid,consumer,callback,on,invalid,settings,consumer,receives,invalid,key,its,associated,value,and,an,exception,return,a,link,settings,instance,with,the,unknown,or,invalid,settings,archived;public,settings,archive,unknown,or,invalid,settings,final,settings,settings,final,consumer,map,entry,string,string,unknown,consumer,final,bi,consumer,map,entry,string,string,illegal,argument,exception,invalid,consumer,settings,builder,builder,settings,builder,boolean,changed,false,for,string,key,settings,key,set,try,setting,setting,get,key,if,setting,null,setting,get,settings,builder,copy,key,settings,else,if,key,starts,with,is,private,setting,key,builder,copy,key,settings,else,changed,true,unknown,consumer,accept,new,entry,key,settings,builder,copy,key,key,settings,catch,illegal,argument,exception,ex,changed,true,invalid,consumer,accept,new,entry,key,settings,ex,builder,copy,key,key,settings,if,changed,return,builder,build,else,return,settings
AbstractScopedSettings -> public Settings archiveUnknownOrInvalidSettings(         final Settings settings,         final Consumer<Map.Entry<String, String>> unknownConsumer,         final BiConsumer<Map.Entry<String, String>, IllegalArgumentException> invalidConsumer);1544081506;Archives invalid or unknown settings. Any setting that is not recognized or fails validation_will be archived. This means the setting is prefixed with {@value ARCHIVED_SETTINGS_PREFIX}_and remains in the settings object. This can be used to detect invalid settings via APIs.__@param settings        the {@link Settings} instance to scan for unknown or invalid settings_@param unknownConsumer callback on unknown settings (consumer receives unknown key and its_associated value)_@param invalidConsumer callback on invalid settings (consumer receives invalid key, its_associated value and an exception)_@return a {@link Settings} instance with the unknown or invalid settings archived;public Settings archiveUnknownOrInvalidSettings(_        final Settings settings,_        final Consumer<Map.Entry<String, String>> unknownConsumer,_        final BiConsumer<Map.Entry<String, String>, IllegalArgumentException> invalidConsumer) {_        Settings.Builder builder = Settings.builder()__        boolean changed = false__        for (String key : settings.keySet()) {_            try {_                Setting<?> setting = get(key)__                if (setting != null) {_                    setting.get(settings)__                    builder.copy(key, settings)__                } else {_                    if (key.startsWith(ARCHIVED_SETTINGS_PREFIX) || isPrivateSetting(key)) {_                        builder.copy(key, settings)__                    } else {_                        changed = true__                        unknownConsumer.accept(new Entry(key, settings))__                        _                        builder.copy(ARCHIVED_SETTINGS_PREFIX + key, key, settings)__                    }_                }_            } catch (IllegalArgumentException ex) {_                changed = true__                invalidConsumer.accept(new Entry(key, settings), ex)__                _                builder.copy(ARCHIVED_SETTINGS_PREFIX + key, key, settings)__            }_        }_        if (changed) {_            return builder.build()__        } else {_            return settings__        }_    };archives,invalid,or,unknown,settings,any,setting,that,is,not,recognized,or,fails,validation,will,be,archived,this,means,the,setting,is,prefixed,with,value,and,remains,in,the,settings,object,this,can,be,used,to,detect,invalid,settings,via,apis,param,settings,the,link,settings,instance,to,scan,for,unknown,or,invalid,settings,param,unknown,consumer,callback,on,unknown,settings,consumer,receives,unknown,key,and,its,associated,value,param,invalid,consumer,callback,on,invalid,settings,consumer,receives,invalid,key,its,associated,value,and,an,exception,return,a,link,settings,instance,with,the,unknown,or,invalid,settings,archived;public,settings,archive,unknown,or,invalid,settings,final,settings,settings,final,consumer,map,entry,string,string,unknown,consumer,final,bi,consumer,map,entry,string,string,illegal,argument,exception,invalid,consumer,settings,builder,builder,settings,builder,boolean,changed,false,for,string,key,settings,key,set,try,setting,setting,get,key,if,setting,null,setting,get,settings,builder,copy,key,settings,else,if,key,starts,with,is,private,setting,key,builder,copy,key,settings,else,changed,true,unknown,consumer,accept,new,entry,key,settings,builder,copy,key,key,settings,catch,illegal,argument,exception,ex,changed,true,invalid,consumer,accept,new,entry,key,settings,ex,builder,copy,key,key,settings,if,changed,return,builder,build,else,return,settings
AbstractScopedSettings -> public Settings archiveUnknownOrInvalidSettings(         final Settings settings,         final Consumer<Map.Entry<String, String>> unknownConsumer,         final BiConsumer<Map.Entry<String, String>, IllegalArgumentException> invalidConsumer);1544691774;Archives invalid or unknown settings. Any setting that is not recognized or fails validation_will be archived. This means the setting is prefixed with {@value ARCHIVED_SETTINGS_PREFIX}_and remains in the settings object. This can be used to detect invalid settings via APIs.__@param settings        the {@link Settings} instance to scan for unknown or invalid settings_@param unknownConsumer callback on unknown settings (consumer receives unknown key and its_associated value)_@param invalidConsumer callback on invalid settings (consumer receives invalid key, its_associated value and an exception)_@return a {@link Settings} instance with the unknown or invalid settings archived;public Settings archiveUnknownOrInvalidSettings(_        final Settings settings,_        final Consumer<Map.Entry<String, String>> unknownConsumer,_        final BiConsumer<Map.Entry<String, String>, IllegalArgumentException> invalidConsumer) {_        Settings.Builder builder = Settings.builder()__        boolean changed = false__        for (String key : settings.keySet()) {_            try {_                Setting<?> setting = get(key)__                if (setting != null) {_                    setting.get(settings)__                    builder.copy(key, settings)__                } else {_                    if (key.startsWith(ARCHIVED_SETTINGS_PREFIX) || isPrivateSetting(key)) {_                        builder.copy(key, settings)__                    } else {_                        changed = true__                        unknownConsumer.accept(new Entry(key, settings))__                        _                        builder.copy(ARCHIVED_SETTINGS_PREFIX + key, key, settings)__                    }_                }_            } catch (IllegalArgumentException ex) {_                changed = true__                invalidConsumer.accept(new Entry(key, settings), ex)__                _                builder.copy(ARCHIVED_SETTINGS_PREFIX + key, key, settings)__            }_        }_        if (changed) {_            return builder.build()__        } else {_            return settings__        }_    };archives,invalid,or,unknown,settings,any,setting,that,is,not,recognized,or,fails,validation,will,be,archived,this,means,the,setting,is,prefixed,with,value,and,remains,in,the,settings,object,this,can,be,used,to,detect,invalid,settings,via,apis,param,settings,the,link,settings,instance,to,scan,for,unknown,or,invalid,settings,param,unknown,consumer,callback,on,unknown,settings,consumer,receives,unknown,key,and,its,associated,value,param,invalid,consumer,callback,on,invalid,settings,consumer,receives,invalid,key,its,associated,value,and,an,exception,return,a,link,settings,instance,with,the,unknown,or,invalid,settings,archived;public,settings,archive,unknown,or,invalid,settings,final,settings,settings,final,consumer,map,entry,string,string,unknown,consumer,final,bi,consumer,map,entry,string,string,illegal,argument,exception,invalid,consumer,settings,builder,builder,settings,builder,boolean,changed,false,for,string,key,settings,key,set,try,setting,setting,get,key,if,setting,null,setting,get,settings,builder,copy,key,settings,else,if,key,starts,with,is,private,setting,key,builder,copy,key,settings,else,changed,true,unknown,consumer,accept,new,entry,key,settings,builder,copy,key,key,settings,catch,illegal,argument,exception,ex,changed,true,invalid,consumer,accept,new,entry,key,settings,ex,builder,copy,key,key,settings,if,changed,return,builder,build,else,return,settings
AbstractScopedSettings -> public Settings archiveUnknownOrInvalidSettings(         final Settings settings,         final Consumer<Map.Entry<String, String>> unknownConsumer,         final BiConsumer<Map.Entry<String, String>, IllegalArgumentException> invalidConsumer);1546877578;Archives invalid or unknown settings. Any setting that is not recognized or fails validation_will be archived. This means the setting is prefixed with {@value ARCHIVED_SETTINGS_PREFIX}_and remains in the settings object. This can be used to detect invalid settings via APIs.__@param settings        the {@link Settings} instance to scan for unknown or invalid settings_@param unknownConsumer callback on unknown settings (consumer receives unknown key and its_associated value)_@param invalidConsumer callback on invalid settings (consumer receives invalid key, its_associated value and an exception)_@return a {@link Settings} instance with the unknown or invalid settings archived;public Settings archiveUnknownOrInvalidSettings(_        final Settings settings,_        final Consumer<Map.Entry<String, String>> unknownConsumer,_        final BiConsumer<Map.Entry<String, String>, IllegalArgumentException> invalidConsumer) {_        Settings.Builder builder = Settings.builder()__        boolean changed = false__        for (String key : settings.keySet()) {_            try {_                Setting<?> setting = get(key)__                if (setting != null) {_                    setting.get(settings)__                    builder.copy(key, settings)__                } else {_                    if (key.startsWith(ARCHIVED_SETTINGS_PREFIX) || isPrivateSetting(key)) {_                        builder.copy(key, settings)__                    } else {_                        changed = true__                        unknownConsumer.accept(new Entry(key, settings))__                        _                        builder.copy(ARCHIVED_SETTINGS_PREFIX + key, key, settings)__                    }_                }_            } catch (IllegalArgumentException ex) {_                changed = true__                invalidConsumer.accept(new Entry(key, settings), ex)__                _                builder.copy(ARCHIVED_SETTINGS_PREFIX + key, key, settings)__            }_        }_        if (changed) {_            return builder.build()__        } else {_            return settings__        }_    };archives,invalid,or,unknown,settings,any,setting,that,is,not,recognized,or,fails,validation,will,be,archived,this,means,the,setting,is,prefixed,with,value,and,remains,in,the,settings,object,this,can,be,used,to,detect,invalid,settings,via,apis,param,settings,the,link,settings,instance,to,scan,for,unknown,or,invalid,settings,param,unknown,consumer,callback,on,unknown,settings,consumer,receives,unknown,key,and,its,associated,value,param,invalid,consumer,callback,on,invalid,settings,consumer,receives,invalid,key,its,associated,value,and,an,exception,return,a,link,settings,instance,with,the,unknown,or,invalid,settings,archived;public,settings,archive,unknown,or,invalid,settings,final,settings,settings,final,consumer,map,entry,string,string,unknown,consumer,final,bi,consumer,map,entry,string,string,illegal,argument,exception,invalid,consumer,settings,builder,builder,settings,builder,boolean,changed,false,for,string,key,settings,key,set,try,setting,setting,get,key,if,setting,null,setting,get,settings,builder,copy,key,settings,else,if,key,starts,with,is,private,setting,key,builder,copy,key,settings,else,changed,true,unknown,consumer,accept,new,entry,key,settings,builder,copy,key,key,settings,catch,illegal,argument,exception,ex,changed,true,invalid,consumer,accept,new,entry,key,settings,ex,builder,copy,key,key,settings,if,changed,return,builder,build,else,return,settings
AbstractScopedSettings -> public Settings archiveUnknownOrInvalidSettings(         final Settings settings,         final Consumer<Map.Entry<String, String>> unknownConsumer,         final BiConsumer<Map.Entry<String, String>, IllegalArgumentException> invalidConsumer);1548270339;Archives invalid or unknown settings. Any setting that is not recognized or fails validation_will be archived. This means the setting is prefixed with {@value ARCHIVED_SETTINGS_PREFIX}_and remains in the settings object. This can be used to detect invalid settings via APIs.__@param settings        the {@link Settings} instance to scan for unknown or invalid settings_@param unknownConsumer callback on unknown settings (consumer receives unknown key and its_associated value)_@param invalidConsumer callback on invalid settings (consumer receives invalid key, its_associated value and an exception)_@return a {@link Settings} instance with the unknown or invalid settings archived;public Settings archiveUnknownOrInvalidSettings(_        final Settings settings,_        final Consumer<Map.Entry<String, String>> unknownConsumer,_        final BiConsumer<Map.Entry<String, String>, IllegalArgumentException> invalidConsumer) {_        Settings.Builder builder = Settings.builder()__        boolean changed = false__        for (String key : settings.keySet()) {_            try {_                Setting<?> setting = get(key)__                if (setting != null) {_                    setting.get(settings)__                    builder.copy(key, settings)__                } else {_                    if (key.startsWith(ARCHIVED_SETTINGS_PREFIX) || isPrivateSetting(key)) {_                        builder.copy(key, settings)__                    } else {_                        changed = true__                        unknownConsumer.accept(new Entry(key, settings))__                        _                        builder.copy(ARCHIVED_SETTINGS_PREFIX + key, key, settings)__                    }_                }_            } catch (IllegalArgumentException ex) {_                changed = true__                invalidConsumer.accept(new Entry(key, settings), ex)__                _                builder.copy(ARCHIVED_SETTINGS_PREFIX + key, key, settings)__            }_        }_        if (changed) {_            return builder.build()__        } else {_            return settings__        }_    };archives,invalid,or,unknown,settings,any,setting,that,is,not,recognized,or,fails,validation,will,be,archived,this,means,the,setting,is,prefixed,with,value,and,remains,in,the,settings,object,this,can,be,used,to,detect,invalid,settings,via,apis,param,settings,the,link,settings,instance,to,scan,for,unknown,or,invalid,settings,param,unknown,consumer,callback,on,unknown,settings,consumer,receives,unknown,key,and,its,associated,value,param,invalid,consumer,callback,on,invalid,settings,consumer,receives,invalid,key,its,associated,value,and,an,exception,return,a,link,settings,instance,with,the,unknown,or,invalid,settings,archived;public,settings,archive,unknown,or,invalid,settings,final,settings,settings,final,consumer,map,entry,string,string,unknown,consumer,final,bi,consumer,map,entry,string,string,illegal,argument,exception,invalid,consumer,settings,builder,builder,settings,builder,boolean,changed,false,for,string,key,settings,key,set,try,setting,setting,get,key,if,setting,null,setting,get,settings,builder,copy,key,settings,else,if,key,starts,with,is,private,setting,key,builder,copy,key,settings,else,changed,true,unknown,consumer,accept,new,entry,key,settings,builder,copy,key,key,settings,catch,illegal,argument,exception,ex,changed,true,invalid,consumer,accept,new,entry,key,settings,ex,builder,copy,key,key,settings,if,changed,return,builder,build,else,return,settings
AbstractScopedSettings -> public final void validate(final Settings settings, final boolean validateDependencies, final boolean validateInternalIndex);1528904315;Validates that all settings are registered and valid.__@param settings              the settings to validate_@param validateDependencies  true if dependent settings should be validated_@param validateInternalIndex true if internal index settings should be validated_@see Setting#getSettingsDependencies(String);public final void validate(final Settings settings, final boolean validateDependencies, final boolean validateInternalIndex) {_        validate(settings, validateDependencies, false, false, validateInternalIndex)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,to,validate,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,validate,internal,index,true,if,internal,index,settings,should,be,validated,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,final,boolean,validate,internal,index,validate,settings,validate,dependencies,false,false,validate,internal,index
AbstractScopedSettings -> public final void validate(final Settings settings, final boolean validateDependencies, final boolean validateInternalIndex);1531179852;Validates that all settings are registered and valid.__@param settings              the settings to validate_@param validateDependencies  true if dependent settings should be validated_@param validateInternalIndex true if internal index settings should be validated_@see Setting#getSettingsDependencies(String);public final void validate(final Settings settings, final boolean validateDependencies, final boolean validateInternalIndex) {_        validate(settings, validateDependencies, false, false, validateInternalIndex)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,to,validate,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,validate,internal,index,true,if,internal,index,settings,should,be,validated,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,final,boolean,validate,internal,index,validate,settings,validate,dependencies,false,false,validate,internal,index
AbstractScopedSettings -> public final void validate(final Settings settings, final boolean validateDependencies, final boolean validateInternalIndex);1535046779;Validates that all settings are registered and valid.__@param settings              the settings to validate_@param validateDependencies  true if dependent settings should be validated_@param validateInternalIndex true if internal index settings should be validated_@see Setting#getSettingsDependencies(String);public final void validate(final Settings settings, final boolean validateDependencies, final boolean validateInternalIndex) {_        validate(settings, validateDependencies, false, false, validateInternalIndex)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,to,validate,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,validate,internal,index,true,if,internal,index,settings,should,be,validated,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,final,boolean,validate,internal,index,validate,settings,validate,dependencies,false,false,validate,internal,index
AbstractScopedSettings -> SettingUpdater -> T getValue(Settings current, Settings previous)_;1524684173;Returns the instance value for the current settings. This method is stateless and idempotent._This method will throw an exception if the source of this value is invalid.;T getValue(Settings current, Settings previous)_;returns,the,instance,value,for,the,current,settings,this,method,is,stateless,and,idempotent,this,method,will,throw,an,exception,if,the,source,of,this,value,is,invalid;t,get,value,settings,current,settings,previous
AbstractScopedSettings -> SettingUpdater -> T getValue(Settings current, Settings previous)_;1528904315;Returns the instance value for the current settings. This method is stateless and idempotent._This method will throw an exception if the source of this value is invalid.;T getValue(Settings current, Settings previous)_;returns,the,instance,value,for,the,current,settings,this,method,is,stateless,and,idempotent,this,method,will,throw,an,exception,if,the,source,of,this,value,is,invalid;t,get,value,settings,current,settings,previous
AbstractScopedSettings -> SettingUpdater -> T getValue(Settings current, Settings previous)_;1531179852;Returns the instance value for the current settings. This method is stateless and idempotent._This method will throw an exception if the source of this value is invalid.;T getValue(Settings current, Settings previous)_;returns,the,instance,value,for,the,current,settings,this,method,is,stateless,and,idempotent,this,method,will,throw,an,exception,if,the,source,of,this,value,is,invalid;t,get,value,settings,current,settings,previous
AbstractScopedSettings -> SettingUpdater -> T getValue(Settings current, Settings previous)_;1535046779;Returns the instance value for the current settings. This method is stateless and idempotent._This method will throw an exception if the source of this value is invalid.;T getValue(Settings current, Settings previous)_;returns,the,instance,value,for,the,current,settings,this,method,is,stateless,and,idempotent,this,method,will,throw,an,exception,if,the,source,of,this,value,is,invalid;t,get,value,settings,current,settings,previous
AbstractScopedSettings -> SettingUpdater -> T getValue(Settings current, Settings previous)_;1536137328;Returns the instance value for the current settings. This method is stateless and idempotent._This method will throw an exception if the source of this value is invalid.;T getValue(Settings current, Settings previous)_;returns,the,instance,value,for,the,current,settings,this,method,is,stateless,and,idempotent,this,method,will,throw,an,exception,if,the,source,of,this,value,is,invalid;t,get,value,settings,current,settings,previous
AbstractScopedSettings -> SettingUpdater -> T getValue(Settings current, Settings previous)_;1536314350;Returns the instance value for the current settings. This method is stateless and idempotent._This method will throw an exception if the source of this value is invalid.;T getValue(Settings current, Settings previous)_;returns,the,instance,value,for,the,current,settings,this,method,is,stateless,and,idempotent,this,method,will,throw,an,exception,if,the,source,of,this,value,is,invalid;t,get,value,settings,current,settings,previous
AbstractScopedSettings -> SettingUpdater -> T getValue(Settings current, Settings previous)_;1536611444;Returns the instance value for the current settings. This method is stateless and idempotent._This method will throw an exception if the source of this value is invalid.;T getValue(Settings current, Settings previous)_;returns,the,instance,value,for,the,current,settings,this,method,is,stateless,and,idempotent,this,method,will,throw,an,exception,if,the,source,of,this,value,is,invalid;t,get,value,settings,current,settings,previous
AbstractScopedSettings -> SettingUpdater -> T getValue(Settings current, Settings previous)_;1536828374;Returns the instance value for the current settings. This method is stateless and idempotent._This method will throw an exception if the source of this value is invalid.;T getValue(Settings current, Settings previous)_;returns,the,instance,value,for,the,current,settings,this,method,is,stateless,and,idempotent,this,method,will,throw,an,exception,if,the,source,of,this,value,is,invalid;t,get,value,settings,current,settings,previous
AbstractScopedSettings -> SettingUpdater -> T getValue(Settings current, Settings previous)_;1539951844;Returns the instance value for the current settings. This method is stateless and idempotent._This method will throw an exception if the source of this value is invalid.;T getValue(Settings current, Settings previous)_;returns,the,instance,value,for,the,current,settings,this,method,is,stateless,and,idempotent,this,method,will,throw,an,exception,if,the,source,of,this,value,is,invalid;t,get,value,settings,current,settings,previous
AbstractScopedSettings -> SettingUpdater -> T getValue(Settings current, Settings previous)_;1541008027;Returns the instance value for the current settings. This method is stateless and idempotent._This method will throw an exception if the source of this value is invalid.;T getValue(Settings current, Settings previous)_;returns,the,instance,value,for,the,current,settings,this,method,is,stateless,and,idempotent,this,method,will,throw,an,exception,if,the,source,of,this,value,is,invalid;t,get,value,settings,current,settings,previous
AbstractScopedSettings -> SettingUpdater -> T getValue(Settings current, Settings previous)_;1541092382;Returns the instance value for the current settings. This method is stateless and idempotent._This method will throw an exception if the source of this value is invalid.;T getValue(Settings current, Settings previous)_;returns,the,instance,value,for,the,current,settings,this,method,is,stateless,and,idempotent,this,method,will,throw,an,exception,if,the,source,of,this,value,is,invalid;t,get,value,settings,current,settings,previous
AbstractScopedSettings -> SettingUpdater -> T getValue(Settings current, Settings previous)_;1542402632;Returns the instance value for the current settings. This method is stateless and idempotent._This method will throw an exception if the source of this value is invalid.;T getValue(Settings current, Settings previous)_;returns,the,instance,value,for,the,current,settings,this,method,is,stateless,and,idempotent,this,method,will,throw,an,exception,if,the,source,of,this,value,is,invalid;t,get,value,settings,current,settings,previous
AbstractScopedSettings -> SettingUpdater -> T getValue(Settings current, Settings previous)_;1544081506;Returns the instance value for the current settings. This method is stateless and idempotent._This method will throw an exception if the source of this value is invalid.;T getValue(Settings current, Settings previous)_;returns,the,instance,value,for,the,current,settings,this,method,is,stateless,and,idempotent,this,method,will,throw,an,exception,if,the,source,of,this,value,is,invalid;t,get,value,settings,current,settings,previous
AbstractScopedSettings -> SettingUpdater -> T getValue(Settings current, Settings previous)_;1544691774;Returns the instance value for the current settings. This method is stateless and idempotent._This method will throw an exception if the source of this value is invalid.;T getValue(Settings current, Settings previous)_;returns,the,instance,value,for,the,current,settings,this,method,is,stateless,and,idempotent,this,method,will,throw,an,exception,if,the,source,of,this,value,is,invalid;t,get,value,settings,current,settings,previous
AbstractScopedSettings -> SettingUpdater -> T getValue(Settings current, Settings previous)_;1546877578;Returns the instance value for the current settings. This method is stateless and idempotent._This method will throw an exception if the source of this value is invalid.;T getValue(Settings current, Settings previous)_;returns,the,instance,value,for,the,current,settings,this,method,is,stateless,and,idempotent,this,method,will,throw,an,exception,if,the,source,of,this,value,is,invalid;t,get,value,settings,current,settings,previous
AbstractScopedSettings -> SettingUpdater -> T getValue(Settings current, Settings previous)_;1548270339;Returns the instance value for the current settings. This method is stateless and idempotent._This method will throw an exception if the source of this value is invalid.;T getValue(Settings current, Settings previous)_;returns,the,instance,value,for,the,current,settings,this,method,is,stateless,and,idempotent,this,method,will,throw,an,exception,if,the,source,of,this,value,is,invalid;t,get,value,settings,current,settings,previous
AbstractScopedSettings -> public boolean isDynamicSetting(String key);1524684173;Returns <code>true</code> if the setting for the given key is dynamically updateable. Otherwise <code>false</code>.;public boolean isDynamicSetting(String key) {_        final Setting<?> setting = get(key)__        return setting != null && setting.isDynamic()__    };returns,code,true,code,if,the,setting,for,the,given,key,is,dynamically,updateable,otherwise,code,false,code;public,boolean,is,dynamic,setting,string,key,final,setting,setting,get,key,return,setting,null,setting,is,dynamic
AbstractScopedSettings -> public boolean isDynamicSetting(String key);1528904315;Returns <code>true</code> if the setting for the given key is dynamically updateable. Otherwise <code>false</code>.;public boolean isDynamicSetting(String key) {_        final Setting<?> setting = get(key)__        return setting != null && setting.isDynamic()__    };returns,code,true,code,if,the,setting,for,the,given,key,is,dynamically,updateable,otherwise,code,false,code;public,boolean,is,dynamic,setting,string,key,final,setting,setting,get,key,return,setting,null,setting,is,dynamic
AbstractScopedSettings -> public boolean isDynamicSetting(String key);1531179852;Returns <code>true</code> if the setting for the given key is dynamically updateable. Otherwise <code>false</code>.;public boolean isDynamicSetting(String key) {_        final Setting<?> setting = get(key)__        return setting != null && setting.isDynamic()__    };returns,code,true,code,if,the,setting,for,the,given,key,is,dynamically,updateable,otherwise,code,false,code;public,boolean,is,dynamic,setting,string,key,final,setting,setting,get,key,return,setting,null,setting,is,dynamic
AbstractScopedSettings -> public boolean isDynamicSetting(String key);1535046779;Returns <code>true</code> if the setting for the given key is dynamically updateable. Otherwise <code>false</code>.;public boolean isDynamicSetting(String key) {_        final Setting<?> setting = get(key)__        return setting != null && setting.isDynamic()__    };returns,code,true,code,if,the,setting,for,the,given,key,is,dynamically,updateable,otherwise,code,false,code;public,boolean,is,dynamic,setting,string,key,final,setting,setting,get,key,return,setting,null,setting,is,dynamic
AbstractScopedSettings -> public boolean isDynamicSetting(String key);1536137328;Returns <code>true</code> if the setting for the given key is dynamically updateable. Otherwise <code>false</code>.;public boolean isDynamicSetting(String key) {_        final Setting<?> setting = get(key)__        return setting != null && setting.isDynamic()__    };returns,code,true,code,if,the,setting,for,the,given,key,is,dynamically,updateable,otherwise,code,false,code;public,boolean,is,dynamic,setting,string,key,final,setting,setting,get,key,return,setting,null,setting,is,dynamic
AbstractScopedSettings -> public boolean isDynamicSetting(String key);1536314350;Returns <code>true</code> if the setting for the given key is dynamically updateable. Otherwise <code>false</code>.;public boolean isDynamicSetting(String key) {_        final Setting<?> setting = get(key)__        return setting != null && setting.isDynamic()__    };returns,code,true,code,if,the,setting,for,the,given,key,is,dynamically,updateable,otherwise,code,false,code;public,boolean,is,dynamic,setting,string,key,final,setting,setting,get,key,return,setting,null,setting,is,dynamic
AbstractScopedSettings -> public boolean isDynamicSetting(String key);1536611444;Returns <code>true</code> if the setting for the given key is dynamically updateable. Otherwise <code>false</code>.;public boolean isDynamicSetting(String key) {_        final Setting<?> setting = get(key)__        return setting != null && setting.isDynamic()__    };returns,code,true,code,if,the,setting,for,the,given,key,is,dynamically,updateable,otherwise,code,false,code;public,boolean,is,dynamic,setting,string,key,final,setting,setting,get,key,return,setting,null,setting,is,dynamic
AbstractScopedSettings -> public boolean isDynamicSetting(String key);1536828374;Returns <code>true</code> if the setting for the given key is dynamically updateable. Otherwise <code>false</code>.;public boolean isDynamicSetting(String key) {_        final Setting<?> setting = get(key)__        return setting != null && setting.isDynamic()__    };returns,code,true,code,if,the,setting,for,the,given,key,is,dynamically,updateable,otherwise,code,false,code;public,boolean,is,dynamic,setting,string,key,final,setting,setting,get,key,return,setting,null,setting,is,dynamic
AbstractScopedSettings -> public boolean isDynamicSetting(String key);1539951844;Returns <code>true</code> if the setting for the given key is dynamically updateable. Otherwise <code>false</code>.;public boolean isDynamicSetting(String key) {_        final Setting<?> setting = get(key)__        return setting != null && setting.isDynamic()__    };returns,code,true,code,if,the,setting,for,the,given,key,is,dynamically,updateable,otherwise,code,false,code;public,boolean,is,dynamic,setting,string,key,final,setting,setting,get,key,return,setting,null,setting,is,dynamic
AbstractScopedSettings -> public boolean isDynamicSetting(String key);1541008027;Returns <code>true</code> if the setting for the given key is dynamically updateable. Otherwise <code>false</code>.;public boolean isDynamicSetting(String key) {_        final Setting<?> setting = get(key)__        return setting != null && setting.isDynamic()__    };returns,code,true,code,if,the,setting,for,the,given,key,is,dynamically,updateable,otherwise,code,false,code;public,boolean,is,dynamic,setting,string,key,final,setting,setting,get,key,return,setting,null,setting,is,dynamic
AbstractScopedSettings -> public boolean isDynamicSetting(String key);1541092382;Returns <code>true</code> if the setting for the given key is dynamically updateable. Otherwise <code>false</code>.;public boolean isDynamicSetting(String key) {_        final Setting<?> setting = get(key)__        return setting != null && setting.isDynamic()__    };returns,code,true,code,if,the,setting,for,the,given,key,is,dynamically,updateable,otherwise,code,false,code;public,boolean,is,dynamic,setting,string,key,final,setting,setting,get,key,return,setting,null,setting,is,dynamic
AbstractScopedSettings -> public boolean isDynamicSetting(String key);1542402632;Returns <code>true</code> if the setting for the given key is dynamically updateable. Otherwise <code>false</code>.;public boolean isDynamicSetting(String key) {_        final Setting<?> setting = get(key)__        return setting != null && setting.isDynamic()__    };returns,code,true,code,if,the,setting,for,the,given,key,is,dynamically,updateable,otherwise,code,false,code;public,boolean,is,dynamic,setting,string,key,final,setting,setting,get,key,return,setting,null,setting,is,dynamic
AbstractScopedSettings -> public boolean isDynamicSetting(String key);1544081506;Returns <code>true</code> if the setting for the given key is dynamically updateable. Otherwise <code>false</code>.;public boolean isDynamicSetting(String key) {_        final Setting<?> setting = get(key)__        return setting != null && setting.isDynamic()__    };returns,code,true,code,if,the,setting,for,the,given,key,is,dynamically,updateable,otherwise,code,false,code;public,boolean,is,dynamic,setting,string,key,final,setting,setting,get,key,return,setting,null,setting,is,dynamic
AbstractScopedSettings -> public boolean isDynamicSetting(String key);1544691774;Returns <code>true</code> if the setting for the given key is dynamically updateable. Otherwise <code>false</code>.;public boolean isDynamicSetting(String key) {_        final Setting<?> setting = get(key)__        return setting != null && setting.isDynamic()__    };returns,code,true,code,if,the,setting,for,the,given,key,is,dynamically,updateable,otherwise,code,false,code;public,boolean,is,dynamic,setting,string,key,final,setting,setting,get,key,return,setting,null,setting,is,dynamic
AbstractScopedSettings -> public boolean isDynamicSetting(String key);1546877578;Returns <code>true</code> if the setting for the given key is dynamically updateable. Otherwise <code>false</code>.;public boolean isDynamicSetting(String key) {_        final Setting<?> setting = get(key)__        return setting != null && setting.isDynamic()__    };returns,code,true,code,if,the,setting,for,the,given,key,is,dynamically,updateable,otherwise,code,false,code;public,boolean,is,dynamic,setting,string,key,final,setting,setting,get,key,return,setting,null,setting,is,dynamic
AbstractScopedSettings -> public boolean isDynamicSetting(String key);1548270339;Returns <code>true</code> if the setting for the given key is dynamically updateable. Otherwise <code>false</code>.;public boolean isDynamicSetting(String key) {_        final Setting<?> setting = get(key)__        return setting != null && setting.isDynamic()__    };returns,code,true,code,if,the,setting,for,the,given,key,is,dynamically,updateable,otherwise,code,false,code;public,boolean,is,dynamic,setting,string,key,final,setting,setting,get,key,return,setting,null,setting,is,dynamic
AbstractScopedSettings -> public final void validate(             final Settings settings,             final boolean validateDependencies,             final boolean ignorePrivateSettings,             final boolean ignoreArchivedSettings);1524684173;Validates that all settings are registered and valid.__@param settings               the settings_@param validateDependencies   true if dependent settings should be validated_@param ignorePrivateSettings  true if private settings should be ignored during validation_@param ignoreArchivedSettings true if archived settings should be ignored during validation_@see Setting#getSettingsDependencies(String);public final void validate(_            final Settings settings,_            final boolean validateDependencies,_            final boolean ignorePrivateSettings,_            final boolean ignoreArchivedSettings) {_        final List<RuntimeException> exceptions = new ArrayList<>()__        for (final String key : settings.keySet()) { _            if (isPrivateSetting(key) && ignorePrivateSettings) {_                continue__            }_            if (key.startsWith(ARCHIVED_SETTINGS_PREFIX) && ignoreArchivedSettings) {_                continue__            }_            try {_                validate(key, settings, validateDependencies)__            } catch (final RuntimeException ex) {_                exceptions.add(ex)__            }_        }_        ExceptionsHelper.rethrowAndSuppress(exceptions)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,ignore,private,settings,true,if,private,settings,should,be,ignored,during,validation,param,ignore,archived,settings,true,if,archived,settings,should,be,ignored,during,validation,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,final,boolean,ignore,private,settings,final,boolean,ignore,archived,settings,final,list,runtime,exception,exceptions,new,array,list,for,final,string,key,settings,key,set,if,is,private,setting,key,ignore,private,settings,continue,if,key,starts,with,ignore,archived,settings,continue,try,validate,key,settings,validate,dependencies,catch,final,runtime,exception,ex,exceptions,add,ex,exceptions,helper,rethrow,and,suppress,exceptions
AbstractScopedSettings -> public final void validate(             final Settings settings,             final boolean validateDependencies,             final boolean ignorePrivateSettings,             final boolean ignoreArchivedSettings);1528904315;Validates that all settings are registered and valid.__@param settings               the settings_@param validateDependencies   true if dependent settings should be validated_@param ignorePrivateSettings  true if private settings should be ignored during validation_@param ignoreArchivedSettings true if archived settings should be ignored during validation_@see Setting#getSettingsDependencies(String);public final void validate(_            final Settings settings,_            final boolean validateDependencies,_            final boolean ignorePrivateSettings,_            final boolean ignoreArchivedSettings) {_        validate(settings, validateDependencies, ignorePrivateSettings, ignoreArchivedSettings, false)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,ignore,private,settings,true,if,private,settings,should,be,ignored,during,validation,param,ignore,archived,settings,true,if,archived,settings,should,be,ignored,during,validation,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,final,boolean,ignore,private,settings,final,boolean,ignore,archived,settings,validate,settings,validate,dependencies,ignore,private,settings,ignore,archived,settings,false
AbstractScopedSettings -> public final void validate(             final Settings settings,             final boolean validateDependencies,             final boolean ignorePrivateSettings,             final boolean ignoreArchivedSettings);1531179852;Validates that all settings are registered and valid.__@param settings               the settings_@param validateDependencies   true if dependent settings should be validated_@param ignorePrivateSettings  true if private settings should be ignored during validation_@param ignoreArchivedSettings true if archived settings should be ignored during validation_@see Setting#getSettingsDependencies(String);public final void validate(_            final Settings settings,_            final boolean validateDependencies,_            final boolean ignorePrivateSettings,_            final boolean ignoreArchivedSettings) {_        validate(settings, validateDependencies, ignorePrivateSettings, ignoreArchivedSettings, false)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,ignore,private,settings,true,if,private,settings,should,be,ignored,during,validation,param,ignore,archived,settings,true,if,archived,settings,should,be,ignored,during,validation,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,final,boolean,ignore,private,settings,final,boolean,ignore,archived,settings,validate,settings,validate,dependencies,ignore,private,settings,ignore,archived,settings,false
AbstractScopedSettings -> public final void validate(             final Settings settings,             final boolean validateDependencies,             final boolean ignorePrivateSettings,             final boolean ignoreArchivedSettings);1535046779;Validates that all settings are registered and valid.__@param settings               the settings_@param validateDependencies   true if dependent settings should be validated_@param ignorePrivateSettings  true if private settings should be ignored during validation_@param ignoreArchivedSettings true if archived settings should be ignored during validation_@see Setting#getSettingsDependencies(String);public final void validate(_            final Settings settings,_            final boolean validateDependencies,_            final boolean ignorePrivateSettings,_            final boolean ignoreArchivedSettings) {_        validate(settings, validateDependencies, ignorePrivateSettings, ignoreArchivedSettings, false)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,ignore,private,settings,true,if,private,settings,should,be,ignored,during,validation,param,ignore,archived,settings,true,if,archived,settings,should,be,ignored,during,validation,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,final,boolean,ignore,private,settings,final,boolean,ignore,archived,settings,validate,settings,validate,dependencies,ignore,private,settings,ignore,archived,settings,false
AbstractScopedSettings -> public final void validate(             final Settings settings,             final boolean validateDependencies,             final boolean ignorePrivateSettings,             final boolean ignoreArchivedSettings);1536137328;Validates that all settings are registered and valid.__@param settings               the settings_@param validateDependencies   true if dependent settings should be validated_@param ignorePrivateSettings  true if private settings should be ignored during validation_@param ignoreArchivedSettings true if archived settings should be ignored during validation_@see Setting#getSettingsDependencies(String);public final void validate(_            final Settings settings,_            final boolean validateDependencies,_            final boolean ignorePrivateSettings,_            final boolean ignoreArchivedSettings) {_        validate(settings, validateDependencies, ignorePrivateSettings, ignoreArchivedSettings, false)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,ignore,private,settings,true,if,private,settings,should,be,ignored,during,validation,param,ignore,archived,settings,true,if,archived,settings,should,be,ignored,during,validation,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,final,boolean,ignore,private,settings,final,boolean,ignore,archived,settings,validate,settings,validate,dependencies,ignore,private,settings,ignore,archived,settings,false
AbstractScopedSettings -> public final void validate(             final Settings settings,             final boolean validateDependencies,             final boolean ignorePrivateSettings,             final boolean ignoreArchivedSettings);1536314350;Validates that all settings are registered and valid.__@param settings               the settings_@param validateDependencies   true if dependent settings should be validated_@param ignorePrivateSettings  true if private settings should be ignored during validation_@param ignoreArchivedSettings true if archived settings should be ignored during validation_@see Setting#getSettingsDependencies(String);public final void validate(_            final Settings settings,_            final boolean validateDependencies,_            final boolean ignorePrivateSettings,_            final boolean ignoreArchivedSettings) {_        validate(settings, validateDependencies, ignorePrivateSettings, ignoreArchivedSettings, false)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,ignore,private,settings,true,if,private,settings,should,be,ignored,during,validation,param,ignore,archived,settings,true,if,archived,settings,should,be,ignored,during,validation,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,final,boolean,ignore,private,settings,final,boolean,ignore,archived,settings,validate,settings,validate,dependencies,ignore,private,settings,ignore,archived,settings,false
AbstractScopedSettings -> public final void validate(             final Settings settings,             final boolean validateDependencies,             final boolean ignorePrivateSettings,             final boolean ignoreArchivedSettings);1536611444;Validates that all settings are registered and valid.__@param settings               the settings_@param validateDependencies   true if dependent settings should be validated_@param ignorePrivateSettings  true if private settings should be ignored during validation_@param ignoreArchivedSettings true if archived settings should be ignored during validation_@see Setting#getSettingsDependencies(String);public final void validate(_            final Settings settings,_            final boolean validateDependencies,_            final boolean ignorePrivateSettings,_            final boolean ignoreArchivedSettings) {_        validate(settings, validateDependencies, ignorePrivateSettings, ignoreArchivedSettings, false)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,ignore,private,settings,true,if,private,settings,should,be,ignored,during,validation,param,ignore,archived,settings,true,if,archived,settings,should,be,ignored,during,validation,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,final,boolean,ignore,private,settings,final,boolean,ignore,archived,settings,validate,settings,validate,dependencies,ignore,private,settings,ignore,archived,settings,false
AbstractScopedSettings -> public final void validate(             final Settings settings,             final boolean validateDependencies,             final boolean ignorePrivateSettings,             final boolean ignoreArchivedSettings);1536828374;Validates that all settings are registered and valid.__@param settings               the settings_@param validateDependencies   true if dependent settings should be validated_@param ignorePrivateSettings  true if private settings should be ignored during validation_@param ignoreArchivedSettings true if archived settings should be ignored during validation_@see Setting#getSettingsDependencies(String);public final void validate(_            final Settings settings,_            final boolean validateDependencies,_            final boolean ignorePrivateSettings,_            final boolean ignoreArchivedSettings) {_        validate(settings, validateDependencies, ignorePrivateSettings, ignoreArchivedSettings, false)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,ignore,private,settings,true,if,private,settings,should,be,ignored,during,validation,param,ignore,archived,settings,true,if,archived,settings,should,be,ignored,during,validation,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,final,boolean,ignore,private,settings,final,boolean,ignore,archived,settings,validate,settings,validate,dependencies,ignore,private,settings,ignore,archived,settings,false
AbstractScopedSettings -> public final void validate(             final Settings settings,             final boolean validateDependencies,             final boolean ignorePrivateSettings,             final boolean ignoreArchivedSettings);1539951844;Validates that all settings are registered and valid.__@param settings               the settings_@param validateDependencies   true if dependent settings should be validated_@param ignorePrivateSettings  true if private settings should be ignored during validation_@param ignoreArchivedSettings true if archived settings should be ignored during validation_@see Setting#getSettingsDependencies(String);public final void validate(_            final Settings settings,_            final boolean validateDependencies,_            final boolean ignorePrivateSettings,_            final boolean ignoreArchivedSettings) {_        validate(settings, validateDependencies, ignorePrivateSettings, ignoreArchivedSettings, false)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,ignore,private,settings,true,if,private,settings,should,be,ignored,during,validation,param,ignore,archived,settings,true,if,archived,settings,should,be,ignored,during,validation,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,final,boolean,ignore,private,settings,final,boolean,ignore,archived,settings,validate,settings,validate,dependencies,ignore,private,settings,ignore,archived,settings,false
AbstractScopedSettings -> public final void validate(             final Settings settings,             final boolean validateDependencies,             final boolean ignorePrivateSettings,             final boolean ignoreArchivedSettings);1541008027;Validates that all settings are registered and valid.__@param settings               the settings_@param validateDependencies   true if dependent settings should be validated_@param ignorePrivateSettings  true if private settings should be ignored during validation_@param ignoreArchivedSettings true if archived settings should be ignored during validation_@see Setting#getSettingsDependencies(String);public final void validate(_            final Settings settings,_            final boolean validateDependencies,_            final boolean ignorePrivateSettings,_            final boolean ignoreArchivedSettings) {_        validate(settings, validateDependencies, ignorePrivateSettings, ignoreArchivedSettings, false)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,ignore,private,settings,true,if,private,settings,should,be,ignored,during,validation,param,ignore,archived,settings,true,if,archived,settings,should,be,ignored,during,validation,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,final,boolean,ignore,private,settings,final,boolean,ignore,archived,settings,validate,settings,validate,dependencies,ignore,private,settings,ignore,archived,settings,false
AbstractScopedSettings -> public final void validate(             final Settings settings,             final boolean validateDependencies,             final boolean ignorePrivateSettings,             final boolean ignoreArchivedSettings);1541092382;Validates that all settings are registered and valid.__@param settings               the settings_@param validateDependencies   true if dependent settings should be validated_@param ignorePrivateSettings  true if private settings should be ignored during validation_@param ignoreArchivedSettings true if archived settings should be ignored during validation_@see Setting#getSettingsDependencies(String);public final void validate(_            final Settings settings,_            final boolean validateDependencies,_            final boolean ignorePrivateSettings,_            final boolean ignoreArchivedSettings) {_        validate(settings, validateDependencies, ignorePrivateSettings, ignoreArchivedSettings, false)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,ignore,private,settings,true,if,private,settings,should,be,ignored,during,validation,param,ignore,archived,settings,true,if,archived,settings,should,be,ignored,during,validation,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,final,boolean,ignore,private,settings,final,boolean,ignore,archived,settings,validate,settings,validate,dependencies,ignore,private,settings,ignore,archived,settings,false
AbstractScopedSettings -> public final void validate(             final Settings settings,             final boolean validateDependencies,             final boolean ignorePrivateSettings,             final boolean ignoreArchivedSettings);1542402632;Validates that all settings are registered and valid.__@param settings               the settings_@param validateDependencies   true if dependent settings should be validated_@param ignorePrivateSettings  true if private settings should be ignored during validation_@param ignoreArchivedSettings true if archived settings should be ignored during validation_@see Setting#getSettingsDependencies(String);public final void validate(_            final Settings settings,_            final boolean validateDependencies,_            final boolean ignorePrivateSettings,_            final boolean ignoreArchivedSettings) {_        validate(settings, validateDependencies, ignorePrivateSettings, ignoreArchivedSettings, false)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,ignore,private,settings,true,if,private,settings,should,be,ignored,during,validation,param,ignore,archived,settings,true,if,archived,settings,should,be,ignored,during,validation,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,final,boolean,ignore,private,settings,final,boolean,ignore,archived,settings,validate,settings,validate,dependencies,ignore,private,settings,ignore,archived,settings,false
AbstractScopedSettings -> public final void validate(             final Settings settings,             final boolean validateDependencies,             final boolean ignorePrivateSettings,             final boolean ignoreArchivedSettings);1544081506;Validates that all settings are registered and valid.__@param settings               the settings_@param validateDependencies   true if dependent settings should be validated_@param ignorePrivateSettings  true if private settings should be ignored during validation_@param ignoreArchivedSettings true if archived settings should be ignored during validation_@see Setting#getSettingsDependencies(String);public final void validate(_            final Settings settings,_            final boolean validateDependencies,_            final boolean ignorePrivateSettings,_            final boolean ignoreArchivedSettings) {_        validate(settings, validateDependencies, ignorePrivateSettings, ignoreArchivedSettings, false)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,ignore,private,settings,true,if,private,settings,should,be,ignored,during,validation,param,ignore,archived,settings,true,if,archived,settings,should,be,ignored,during,validation,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,final,boolean,ignore,private,settings,final,boolean,ignore,archived,settings,validate,settings,validate,dependencies,ignore,private,settings,ignore,archived,settings,false
AbstractScopedSettings -> public final void validate(             final Settings settings,             final boolean validateDependencies,             final boolean ignorePrivateSettings,             final boolean ignoreArchivedSettings);1544691774;Validates that all settings are registered and valid.__@param settings               the settings_@param validateDependencies   true if dependent settings should be validated_@param ignorePrivateSettings  true if private settings should be ignored during validation_@param ignoreArchivedSettings true if archived settings should be ignored during validation_@see Setting#getSettingsDependencies(String);public final void validate(_            final Settings settings,_            final boolean validateDependencies,_            final boolean ignorePrivateSettings,_            final boolean ignoreArchivedSettings) {_        validate(settings, validateDependencies, ignorePrivateSettings, ignoreArchivedSettings, false)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,ignore,private,settings,true,if,private,settings,should,be,ignored,during,validation,param,ignore,archived,settings,true,if,archived,settings,should,be,ignored,during,validation,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,final,boolean,ignore,private,settings,final,boolean,ignore,archived,settings,validate,settings,validate,dependencies,ignore,private,settings,ignore,archived,settings,false
AbstractScopedSettings -> public final void validate(             final Settings settings,             final boolean validateDependencies,             final boolean ignorePrivateSettings,             final boolean ignoreArchivedSettings);1546877578;Validates that all settings are registered and valid.__@param settings               the settings_@param validateDependencies   true if dependent settings should be validated_@param ignorePrivateSettings  true if private settings should be ignored during validation_@param ignoreArchivedSettings true if archived settings should be ignored during validation_@see Setting#getSettingsDependencies(String);public final void validate(_            final Settings settings,_            final boolean validateDependencies,_            final boolean ignorePrivateSettings,_            final boolean ignoreArchivedSettings) {_        validate(settings, validateDependencies, ignorePrivateSettings, ignoreArchivedSettings, false)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,ignore,private,settings,true,if,private,settings,should,be,ignored,during,validation,param,ignore,archived,settings,true,if,archived,settings,should,be,ignored,during,validation,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,final,boolean,ignore,private,settings,final,boolean,ignore,archived,settings,validate,settings,validate,dependencies,ignore,private,settings,ignore,archived,settings,false
AbstractScopedSettings -> public final void validate(             final Settings settings,             final boolean validateDependencies,             final boolean ignorePrivateSettings,             final boolean ignoreArchivedSettings);1548270339;Validates that all settings are registered and valid.__@param settings               the settings_@param validateDependencies   true if dependent settings should be validated_@param ignorePrivateSettings  true if private settings should be ignored during validation_@param ignoreArchivedSettings true if archived settings should be ignored during validation_@see Setting#getSettingsDependencies(String);public final void validate(_            final Settings settings,_            final boolean validateDependencies,_            final boolean ignorePrivateSettings,_            final boolean ignoreArchivedSettings) {_        validate(settings, validateDependencies, ignorePrivateSettings, ignoreArchivedSettings, false)__    };validates,that,all,settings,are,registered,and,valid,param,settings,the,settings,param,validate,dependencies,true,if,dependent,settings,should,be,validated,param,ignore,private,settings,true,if,private,settings,should,be,ignored,during,validation,param,ignore,archived,settings,true,if,archived,settings,should,be,ignored,during,validation,see,setting,get,settings,dependencies,string;public,final,void,validate,final,settings,settings,final,boolean,validate,dependencies,final,boolean,ignore,private,settings,final,boolean,ignore,archived,settings,validate,settings,validate,dependencies,ignore,private,settings,ignore,archived,settings,false
AbstractScopedSettings -> public <T> T get(Setting<T> setting);1524684173;Returns the value for the given setting.;public <T> T get(Setting<T> setting) {_        if (setting.getProperties().contains(scope) == false) {_            throw new IllegalArgumentException("settings scope doesn't match the setting scope [" + this.scope + "] not in [" +_                setting.getProperties() + "]")__        }_        if (get(setting.getKey()) == null) {_            throw new IllegalArgumentException("setting " + setting.getKey() + " has not been registered")__        }_        return setting.get(this.lastSettingsApplied, settings)__    };returns,the,value,for,the,given,setting;public,t,t,get,setting,t,setting,if,setting,get,properties,contains,scope,false,throw,new,illegal,argument,exception,settings,scope,doesn,t,match,the,setting,scope,this,scope,not,in,setting,get,properties,if,get,setting,get,key,null,throw,new,illegal,argument,exception,setting,setting,get,key,has,not,been,registered,return,setting,get,this,last,settings,applied,settings
AbstractScopedSettings -> public <T> T get(Setting<T> setting);1528904315;Returns the value for the given setting.;public <T> T get(Setting<T> setting) {_        if (setting.getProperties().contains(scope) == false) {_            throw new IllegalArgumentException("settings scope doesn't match the setting scope [" + this.scope + "] not in [" +_                setting.getProperties() + "]")__        }_        if (get(setting.getKey()) == null) {_            throw new IllegalArgumentException("setting " + setting.getKey() + " has not been registered")__        }_        return setting.get(this.lastSettingsApplied, settings)__    };returns,the,value,for,the,given,setting;public,t,t,get,setting,t,setting,if,setting,get,properties,contains,scope,false,throw,new,illegal,argument,exception,settings,scope,doesn,t,match,the,setting,scope,this,scope,not,in,setting,get,properties,if,get,setting,get,key,null,throw,new,illegal,argument,exception,setting,setting,get,key,has,not,been,registered,return,setting,get,this,last,settings,applied,settings
AbstractScopedSettings -> public <T> T get(Setting<T> setting);1531179852;Returns the value for the given setting.;public <T> T get(Setting<T> setting) {_        if (setting.getProperties().contains(scope) == false) {_            throw new IllegalArgumentException("settings scope doesn't match the setting scope [" + this.scope + "] not in [" +_                setting.getProperties() + "]")__        }_        if (get(setting.getKey()) == null) {_            throw new IllegalArgumentException("setting " + setting.getKey() + " has not been registered")__        }_        return setting.get(this.lastSettingsApplied, settings)__    };returns,the,value,for,the,given,setting;public,t,t,get,setting,t,setting,if,setting,get,properties,contains,scope,false,throw,new,illegal,argument,exception,settings,scope,doesn,t,match,the,setting,scope,this,scope,not,in,setting,get,properties,if,get,setting,get,key,null,throw,new,illegal,argument,exception,setting,setting,get,key,has,not,been,registered,return,setting,get,this,last,settings,applied,settings
AbstractScopedSettings -> public <T> T get(Setting<T> setting);1535046779;Returns the value for the given setting.;public <T> T get(Setting<T> setting) {_        if (setting.getProperties().contains(scope) == false) {_            throw new IllegalArgumentException("settings scope doesn't match the setting scope [" + this.scope + "] not in [" +_                setting.getProperties() + "]")__        }_        if (get(setting.getKey()) == null) {_            throw new IllegalArgumentException("setting " + setting.getKey() + " has not been registered")__        }_        return setting.get(this.lastSettingsApplied, settings)__    };returns,the,value,for,the,given,setting;public,t,t,get,setting,t,setting,if,setting,get,properties,contains,scope,false,throw,new,illegal,argument,exception,settings,scope,doesn,t,match,the,setting,scope,this,scope,not,in,setting,get,properties,if,get,setting,get,key,null,throw,new,illegal,argument,exception,setting,setting,get,key,has,not,been,registered,return,setting,get,this,last,settings,applied,settings
AbstractScopedSettings -> public <T> T get(Setting<T> setting);1536137328;Returns the value for the given setting.;public <T> T get(Setting<T> setting) {_        if (setting.getProperties().contains(scope) == false) {_            throw new IllegalArgumentException("settings scope doesn't match the setting scope [" + this.scope + "] not in [" +_                setting.getProperties() + "]")__        }_        if (get(setting.getKey()) == null) {_            throw new IllegalArgumentException("setting " + setting.getKey() + " has not been registered")__        }_        return setting.get(this.lastSettingsApplied, settings)__    };returns,the,value,for,the,given,setting;public,t,t,get,setting,t,setting,if,setting,get,properties,contains,scope,false,throw,new,illegal,argument,exception,settings,scope,doesn,t,match,the,setting,scope,this,scope,not,in,setting,get,properties,if,get,setting,get,key,null,throw,new,illegal,argument,exception,setting,setting,get,key,has,not,been,registered,return,setting,get,this,last,settings,applied,settings
AbstractScopedSettings -> public <T> T get(Setting<T> setting);1536314350;Returns the value for the given setting.;public <T> T get(Setting<T> setting) {_        if (setting.getProperties().contains(scope) == false) {_            throw new IllegalArgumentException("settings scope doesn't match the setting scope [" + this.scope + "] not in [" +_                setting.getProperties() + "]")__        }_        if (get(setting.getKey()) == null) {_            throw new IllegalArgumentException("setting " + setting.getKey() + " has not been registered")__        }_        return setting.get(this.lastSettingsApplied, settings)__    };returns,the,value,for,the,given,setting;public,t,t,get,setting,t,setting,if,setting,get,properties,contains,scope,false,throw,new,illegal,argument,exception,settings,scope,doesn,t,match,the,setting,scope,this,scope,not,in,setting,get,properties,if,get,setting,get,key,null,throw,new,illegal,argument,exception,setting,setting,get,key,has,not,been,registered,return,setting,get,this,last,settings,applied,settings
AbstractScopedSettings -> public <T> T get(Setting<T> setting);1536611444;Returns the value for the given setting.;public <T> T get(Setting<T> setting) {_        if (setting.getProperties().contains(scope) == false) {_            throw new IllegalArgumentException("settings scope doesn't match the setting scope [" + this.scope + "] not in [" +_                setting.getProperties() + "]")__        }_        if (get(setting.getKey()) == null) {_            throw new IllegalArgumentException("setting " + setting.getKey() + " has not been registered")__        }_        return setting.get(this.lastSettingsApplied, settings)__    };returns,the,value,for,the,given,setting;public,t,t,get,setting,t,setting,if,setting,get,properties,contains,scope,false,throw,new,illegal,argument,exception,settings,scope,doesn,t,match,the,setting,scope,this,scope,not,in,setting,get,properties,if,get,setting,get,key,null,throw,new,illegal,argument,exception,setting,setting,get,key,has,not,been,registered,return,setting,get,this,last,settings,applied,settings
AbstractScopedSettings -> public <T> T get(Setting<T> setting);1536828374;Returns the value for the given setting.;public <T> T get(Setting<T> setting) {_        if (setting.getProperties().contains(scope) == false) {_            throw new IllegalArgumentException("settings scope doesn't match the setting scope [" + this.scope + "] not in [" +_                setting.getProperties() + "]")__        }_        if (get(setting.getKey()) == null) {_            throw new IllegalArgumentException("setting " + setting.getKey() + " has not been registered")__        }_        return setting.get(this.lastSettingsApplied, settings)__    };returns,the,value,for,the,given,setting;public,t,t,get,setting,t,setting,if,setting,get,properties,contains,scope,false,throw,new,illegal,argument,exception,settings,scope,doesn,t,match,the,setting,scope,this,scope,not,in,setting,get,properties,if,get,setting,get,key,null,throw,new,illegal,argument,exception,setting,setting,get,key,has,not,been,registered,return,setting,get,this,last,settings,applied,settings
AbstractScopedSettings -> public <T> T get(Setting<T> setting);1539951844;Returns the value for the given setting.;public <T> T get(Setting<T> setting) {_        if (setting.getProperties().contains(scope) == false) {_            throw new IllegalArgumentException("settings scope doesn't match the setting scope [" + this.scope + "] not in [" +_                setting.getProperties() + "]")__        }_        if (get(setting.getKey()) == null) {_            throw new IllegalArgumentException("setting " + setting.getKey() + " has not been registered")__        }_        return setting.get(this.lastSettingsApplied, settings)__    };returns,the,value,for,the,given,setting;public,t,t,get,setting,t,setting,if,setting,get,properties,contains,scope,false,throw,new,illegal,argument,exception,settings,scope,doesn,t,match,the,setting,scope,this,scope,not,in,setting,get,properties,if,get,setting,get,key,null,throw,new,illegal,argument,exception,setting,setting,get,key,has,not,been,registered,return,setting,get,this,last,settings,applied,settings
AbstractScopedSettings -> public <T> T get(Setting<T> setting);1541008027;Returns the value for the given setting.;public <T> T get(Setting<T> setting) {_        if (setting.getProperties().contains(scope) == false) {_            throw new IllegalArgumentException("settings scope doesn't match the setting scope [" + this.scope + "] not in [" +_                setting.getProperties() + "]")__        }_        if (get(setting.getKey()) == null) {_            throw new IllegalArgumentException("setting " + setting.getKey() + " has not been registered")__        }_        return setting.get(this.lastSettingsApplied, settings)__    };returns,the,value,for,the,given,setting;public,t,t,get,setting,t,setting,if,setting,get,properties,contains,scope,false,throw,new,illegal,argument,exception,settings,scope,doesn,t,match,the,setting,scope,this,scope,not,in,setting,get,properties,if,get,setting,get,key,null,throw,new,illegal,argument,exception,setting,setting,get,key,has,not,been,registered,return,setting,get,this,last,settings,applied,settings
AbstractScopedSettings -> public <T> T get(Setting<T> setting);1541092382;Returns the value for the given setting.;public <T> T get(Setting<T> setting) {_        if (setting.getProperties().contains(scope) == false) {_            throw new IllegalArgumentException("settings scope doesn't match the setting scope [" + this.scope + "] not in [" +_                setting.getProperties() + "]")__        }_        if (get(setting.getKey()) == null) {_            throw new IllegalArgumentException("setting " + setting.getKey() + " has not been registered")__        }_        return setting.get(this.lastSettingsApplied, settings)__    };returns,the,value,for,the,given,setting;public,t,t,get,setting,t,setting,if,setting,get,properties,contains,scope,false,throw,new,illegal,argument,exception,settings,scope,doesn,t,match,the,setting,scope,this,scope,not,in,setting,get,properties,if,get,setting,get,key,null,throw,new,illegal,argument,exception,setting,setting,get,key,has,not,been,registered,return,setting,get,this,last,settings,applied,settings
AbstractScopedSettings -> public <T> T get(Setting<T> setting);1542402632;Returns the value for the given setting.;public <T> T get(Setting<T> setting) {_        if (setting.getProperties().contains(scope) == false) {_            throw new IllegalArgumentException("settings scope doesn't match the setting scope [" + this.scope + "] not in [" +_                setting.getProperties() + "]")__        }_        if (get(setting.getKey()) == null) {_            throw new IllegalArgumentException("setting " + setting.getKey() + " has not been registered")__        }_        return setting.get(this.lastSettingsApplied, settings)__    };returns,the,value,for,the,given,setting;public,t,t,get,setting,t,setting,if,setting,get,properties,contains,scope,false,throw,new,illegal,argument,exception,settings,scope,doesn,t,match,the,setting,scope,this,scope,not,in,setting,get,properties,if,get,setting,get,key,null,throw,new,illegal,argument,exception,setting,setting,get,key,has,not,been,registered,return,setting,get,this,last,settings,applied,settings
AbstractScopedSettings -> public <T> T get(Setting<T> setting);1544081506;Returns the value for the given setting.;public <T> T get(Setting<T> setting) {_        if (setting.getProperties().contains(scope) == false) {_            throw new IllegalArgumentException("settings scope doesn't match the setting scope [" + this.scope + "] not in [" +_                setting.getProperties() + "]")__        }_        if (get(setting.getKey()) == null) {_            throw new IllegalArgumentException("setting " + setting.getKey() + " has not been registered")__        }_        return setting.get(this.lastSettingsApplied, settings)__    };returns,the,value,for,the,given,setting;public,t,t,get,setting,t,setting,if,setting,get,properties,contains,scope,false,throw,new,illegal,argument,exception,settings,scope,doesn,t,match,the,setting,scope,this,scope,not,in,setting,get,properties,if,get,setting,get,key,null,throw,new,illegal,argument,exception,setting,setting,get,key,has,not,been,registered,return,setting,get,this,last,settings,applied,settings
AbstractScopedSettings -> public <T> T get(Setting<T> setting);1544691774;Returns the value for the given setting.;public <T> T get(Setting<T> setting) {_        if (setting.getProperties().contains(scope) == false) {_            throw new IllegalArgumentException("settings scope doesn't match the setting scope [" + this.scope + "] not in [" +_                setting.getProperties() + "]")__        }_        if (get(setting.getKey()) == null) {_            throw new IllegalArgumentException("setting " + setting.getKey() + " has not been registered")__        }_        return setting.get(this.lastSettingsApplied, settings)__    };returns,the,value,for,the,given,setting;public,t,t,get,setting,t,setting,if,setting,get,properties,contains,scope,false,throw,new,illegal,argument,exception,settings,scope,doesn,t,match,the,setting,scope,this,scope,not,in,setting,get,properties,if,get,setting,get,key,null,throw,new,illegal,argument,exception,setting,setting,get,key,has,not,been,registered,return,setting,get,this,last,settings,applied,settings
AbstractScopedSettings -> public <T> T get(Setting<T> setting);1546877578;Returns the value for the given setting.;public <T> T get(Setting<T> setting) {_        if (setting.getProperties().contains(scope) == false) {_            throw new IllegalArgumentException("settings scope doesn't match the setting scope [" + this.scope + "] not in [" +_                setting.getProperties() + "]")__        }_        if (get(setting.getKey()) == null) {_            throw new IllegalArgumentException("setting " + setting.getKey() + " has not been registered")__        }_        return setting.get(this.lastSettingsApplied, settings)__    };returns,the,value,for,the,given,setting;public,t,t,get,setting,t,setting,if,setting,get,properties,contains,scope,false,throw,new,illegal,argument,exception,settings,scope,doesn,t,match,the,setting,scope,this,scope,not,in,setting,get,properties,if,get,setting,get,key,null,throw,new,illegal,argument,exception,setting,setting,get,key,has,not,been,registered,return,setting,get,this,last,settings,applied,settings
AbstractScopedSettings -> public <T> T get(Setting<T> setting);1548270339;Returns the value for the given setting.;public <T> T get(Setting<T> setting) {_        if (setting.getProperties().contains(scope) == false) {_            throw new IllegalArgumentException("settings scope doesn't match the setting scope [" + this.scope + "] not in [" +_                setting.getProperties() + "]")__        }_        if (get(setting.getKey()) == null) {_            throw new IllegalArgumentException("setting " + setting.getKey() + " has not been registered")__        }_        return setting.get(this.lastSettingsApplied, settings)__    };returns,the,value,for,the,given,setting;public,t,t,get,setting,t,setting,if,setting,get,properties,contains,scope,false,throw,new,illegal,argument,exception,settings,scope,doesn,t,match,the,setting,scope,this,scope,not,in,setting,get,properties,if,get,setting,get,key,null,throw,new,illegal,argument,exception,setting,setting,get,key,has,not,been,registered,return,setting,get,this,last,settings,applied,settings
AbstractScopedSettings -> public synchronized Settings applySettings(Settings newSettings);1524684173;Applies the given settings to all the settings consumers or to none of them. The settings_will be merged with the node settings before they are applied while given settings override existing node_settings._@param newSettings the settings to apply_@return the unmerged applied settings;public synchronized Settings applySettings(Settings newSettings) {_        if (lastSettingsApplied != null && newSettings.equals(lastSettingsApplied)) {_            _            return newSettings__        }_        final Settings current = Settings.builder().put(this.settings).put(newSettings).build()__        final Settings previous = Settings.builder().put(this.settings).put(this.lastSettingsApplied).build()__        try {_            List<Runnable> applyRunnables = new ArrayList<>()__            for (SettingUpdater<?> settingUpdater : settingUpdaters) {_                try {_                    applyRunnables.add(settingUpdater.updater(current, previous))__                } catch (Exception ex) {_                    logger.warn(() -> new ParameterizedMessage("failed to prepareCommit settings for [{}]", settingUpdater), ex)__                    throw ex__                }_            }_            for (Runnable settingUpdater : applyRunnables) {_                settingUpdater.run()__            }_        } catch (Exception ex) {_            logger.warn("failed to apply settings", ex)__            throw ex__        } finally {_        }_        return lastSettingsApplied = newSettings__    };applies,the,given,settings,to,all,the,settings,consumers,or,to,none,of,them,the,settings,will,be,merged,with,the,node,settings,before,they,are,applied,while,given,settings,override,existing,node,settings,param,new,settings,the,settings,to,apply,return,the,unmerged,applied,settings;public,synchronized,settings,apply,settings,settings,new,settings,if,last,settings,applied,null,new,settings,equals,last,settings,applied,return,new,settings,final,settings,current,settings,builder,put,this,settings,put,new,settings,build,final,settings,previous,settings,builder,put,this,settings,put,this,last,settings,applied,build,try,list,runnable,apply,runnables,new,array,list,for,setting,updater,setting,updater,setting,updaters,try,apply,runnables,add,setting,updater,updater,current,previous,catch,exception,ex,logger,warn,new,parameterized,message,failed,to,prepare,commit,settings,for,setting,updater,ex,throw,ex,for,runnable,setting,updater,apply,runnables,setting,updater,run,catch,exception,ex,logger,warn,failed,to,apply,settings,ex,throw,ex,finally,return,last,settings,applied,new,settings
AbstractScopedSettings -> public synchronized Settings applySettings(Settings newSettings);1528904315;Applies the given settings to all the settings consumers or to none of them. The settings_will be merged with the node settings before they are applied while given settings override existing node_settings._@param newSettings the settings to apply_@return the unmerged applied settings;public synchronized Settings applySettings(Settings newSettings) {_        if (lastSettingsApplied != null && newSettings.equals(lastSettingsApplied)) {_            _            return newSettings__        }_        final Settings current = Settings.builder().put(this.settings).put(newSettings).build()__        final Settings previous = Settings.builder().put(this.settings).put(this.lastSettingsApplied).build()__        try {_            List<Runnable> applyRunnables = new ArrayList<>()__            for (SettingUpdater<?> settingUpdater : settingUpdaters) {_                try {_                    applyRunnables.add(settingUpdater.updater(current, previous))__                } catch (Exception ex) {_                    logger.warn(() -> new ParameterizedMessage("failed to prepareCommit settings for [{}]", settingUpdater), ex)__                    throw ex__                }_            }_            for (Runnable settingUpdater : applyRunnables) {_                settingUpdater.run()__            }_        } catch (Exception ex) {_            logger.warn("failed to apply settings", ex)__            throw ex__        } finally {_        }_        return lastSettingsApplied = newSettings__    };applies,the,given,settings,to,all,the,settings,consumers,or,to,none,of,them,the,settings,will,be,merged,with,the,node,settings,before,they,are,applied,while,given,settings,override,existing,node,settings,param,new,settings,the,settings,to,apply,return,the,unmerged,applied,settings;public,synchronized,settings,apply,settings,settings,new,settings,if,last,settings,applied,null,new,settings,equals,last,settings,applied,return,new,settings,final,settings,current,settings,builder,put,this,settings,put,new,settings,build,final,settings,previous,settings,builder,put,this,settings,put,this,last,settings,applied,build,try,list,runnable,apply,runnables,new,array,list,for,setting,updater,setting,updater,setting,updaters,try,apply,runnables,add,setting,updater,updater,current,previous,catch,exception,ex,logger,warn,new,parameterized,message,failed,to,prepare,commit,settings,for,setting,updater,ex,throw,ex,for,runnable,setting,updater,apply,runnables,setting,updater,run,catch,exception,ex,logger,warn,failed,to,apply,settings,ex,throw,ex,finally,return,last,settings,applied,new,settings
AbstractScopedSettings -> public synchronized Settings applySettings(Settings newSettings);1531179852;Applies the given settings to all the settings consumers or to none of them. The settings_will be merged with the node settings before they are applied while given settings override existing node_settings._@param newSettings the settings to apply_@return the unmerged applied settings;public synchronized Settings applySettings(Settings newSettings) {_        if (lastSettingsApplied != null && newSettings.equals(lastSettingsApplied)) {_            _            return newSettings__        }_        final Settings current = Settings.builder().put(this.settings).put(newSettings).build()__        final Settings previous = Settings.builder().put(this.settings).put(this.lastSettingsApplied).build()__        try {_            List<Runnable> applyRunnables = new ArrayList<>()__            for (SettingUpdater<?> settingUpdater : settingUpdaters) {_                try {_                    applyRunnables.add(settingUpdater.updater(current, previous))__                } catch (Exception ex) {_                    logger.warn(() -> new ParameterizedMessage("failed to prepareCommit settings for [{}]", settingUpdater), ex)__                    throw ex__                }_            }_            for (Runnable settingUpdater : applyRunnables) {_                settingUpdater.run()__            }_        } catch (Exception ex) {_            logger.warn("failed to apply settings", ex)__            throw ex__        } finally {_        }_        return lastSettingsApplied = newSettings__    };applies,the,given,settings,to,all,the,settings,consumers,or,to,none,of,them,the,settings,will,be,merged,with,the,node,settings,before,they,are,applied,while,given,settings,override,existing,node,settings,param,new,settings,the,settings,to,apply,return,the,unmerged,applied,settings;public,synchronized,settings,apply,settings,settings,new,settings,if,last,settings,applied,null,new,settings,equals,last,settings,applied,return,new,settings,final,settings,current,settings,builder,put,this,settings,put,new,settings,build,final,settings,previous,settings,builder,put,this,settings,put,this,last,settings,applied,build,try,list,runnable,apply,runnables,new,array,list,for,setting,updater,setting,updater,setting,updaters,try,apply,runnables,add,setting,updater,updater,current,previous,catch,exception,ex,logger,warn,new,parameterized,message,failed,to,prepare,commit,settings,for,setting,updater,ex,throw,ex,for,runnable,setting,updater,apply,runnables,setting,updater,run,catch,exception,ex,logger,warn,failed,to,apply,settings,ex,throw,ex,finally,return,last,settings,applied,new,settings
AbstractScopedSettings -> public synchronized Settings applySettings(Settings newSettings);1535046779;Applies the given settings to all the settings consumers or to none of them. The settings_will be merged with the node settings before they are applied while given settings override existing node_settings._@param newSettings the settings to apply_@return the unmerged applied settings;public synchronized Settings applySettings(Settings newSettings) {_        if (lastSettingsApplied != null && newSettings.equals(lastSettingsApplied)) {_            _            return newSettings__        }_        final Settings current = Settings.builder().put(this.settings).put(newSettings).build()__        final Settings previous = Settings.builder().put(this.settings).put(this.lastSettingsApplied).build()__        try {_            List<Runnable> applyRunnables = new ArrayList<>()__            for (SettingUpdater<?> settingUpdater : settingUpdaters) {_                try {_                    applyRunnables.add(settingUpdater.updater(current, previous))__                } catch (Exception ex) {_                    logger.warn(() -> new ParameterizedMessage("failed to prepareCommit settings for [{}]", settingUpdater), ex)__                    throw ex__                }_            }_            for (Runnable settingUpdater : applyRunnables) {_                settingUpdater.run()__            }_        } catch (Exception ex) {_            logger.warn("failed to apply settings", ex)__            throw ex__        } finally {_        }_        return lastSettingsApplied = newSettings__    };applies,the,given,settings,to,all,the,settings,consumers,or,to,none,of,them,the,settings,will,be,merged,with,the,node,settings,before,they,are,applied,while,given,settings,override,existing,node,settings,param,new,settings,the,settings,to,apply,return,the,unmerged,applied,settings;public,synchronized,settings,apply,settings,settings,new,settings,if,last,settings,applied,null,new,settings,equals,last,settings,applied,return,new,settings,final,settings,current,settings,builder,put,this,settings,put,new,settings,build,final,settings,previous,settings,builder,put,this,settings,put,this,last,settings,applied,build,try,list,runnable,apply,runnables,new,array,list,for,setting,updater,setting,updater,setting,updaters,try,apply,runnables,add,setting,updater,updater,current,previous,catch,exception,ex,logger,warn,new,parameterized,message,failed,to,prepare,commit,settings,for,setting,updater,ex,throw,ex,for,runnable,setting,updater,apply,runnables,setting,updater,run,catch,exception,ex,logger,warn,failed,to,apply,settings,ex,throw,ex,finally,return,last,settings,applied,new,settings
AbstractScopedSettings -> public synchronized Settings applySettings(Settings newSettings);1536137328;Applies the given settings to all the settings consumers or to none of them. The settings_will be merged with the node settings before they are applied while given settings override existing node_settings._@param newSettings the settings to apply_@return the unmerged applied settings;public synchronized Settings applySettings(Settings newSettings) {_        if (lastSettingsApplied != null && newSettings.equals(lastSettingsApplied)) {_            _            return newSettings__        }_        final Settings current = Settings.builder().put(this.settings).put(newSettings).build()__        final Settings previous = Settings.builder().put(this.settings).put(this.lastSettingsApplied).build()__        try {_            List<Runnable> applyRunnables = new ArrayList<>()__            for (SettingUpdater<?> settingUpdater : settingUpdaters) {_                try {_                    applyRunnables.add(settingUpdater.updater(current, previous))__                } catch (Exception ex) {_                    logger.warn(() -> new ParameterizedMessage("failed to prepareCommit settings for [{}]", settingUpdater), ex)__                    throw ex__                }_            }_            for (Runnable settingUpdater : applyRunnables) {_                settingUpdater.run()__            }_        } catch (Exception ex) {_            logger.warn("failed to apply settings", ex)__            throw ex__        } finally {_        }_        return lastSettingsApplied = newSettings__    };applies,the,given,settings,to,all,the,settings,consumers,or,to,none,of,them,the,settings,will,be,merged,with,the,node,settings,before,they,are,applied,while,given,settings,override,existing,node,settings,param,new,settings,the,settings,to,apply,return,the,unmerged,applied,settings;public,synchronized,settings,apply,settings,settings,new,settings,if,last,settings,applied,null,new,settings,equals,last,settings,applied,return,new,settings,final,settings,current,settings,builder,put,this,settings,put,new,settings,build,final,settings,previous,settings,builder,put,this,settings,put,this,last,settings,applied,build,try,list,runnable,apply,runnables,new,array,list,for,setting,updater,setting,updater,setting,updaters,try,apply,runnables,add,setting,updater,updater,current,previous,catch,exception,ex,logger,warn,new,parameterized,message,failed,to,prepare,commit,settings,for,setting,updater,ex,throw,ex,for,runnable,setting,updater,apply,runnables,setting,updater,run,catch,exception,ex,logger,warn,failed,to,apply,settings,ex,throw,ex,finally,return,last,settings,applied,new,settings
AbstractScopedSettings -> public synchronized Settings applySettings(Settings newSettings);1536314350;Applies the given settings to all the settings consumers or to none of them. The settings_will be merged with the node settings before they are applied while given settings override existing node_settings._@param newSettings the settings to apply_@return the unmerged applied settings;public synchronized Settings applySettings(Settings newSettings) {_        if (lastSettingsApplied != null && newSettings.equals(lastSettingsApplied)) {_            _            return newSettings__        }_        final Settings current = Settings.builder().put(this.settings).put(newSettings).build()__        final Settings previous = Settings.builder().put(this.settings).put(this.lastSettingsApplied).build()__        try {_            List<Runnable> applyRunnables = new ArrayList<>()__            for (SettingUpdater<?> settingUpdater : settingUpdaters) {_                try {_                    applyRunnables.add(settingUpdater.updater(current, previous))__                } catch (Exception ex) {_                    logger.warn(() -> new ParameterizedMessage("failed to prepareCommit settings for [{}]", settingUpdater), ex)__                    throw ex__                }_            }_            for (Runnable settingUpdater : applyRunnables) {_                settingUpdater.run()__            }_        } catch (Exception ex) {_            logger.warn("failed to apply settings", ex)__            throw ex__        } finally {_        }_        return lastSettingsApplied = newSettings__    };applies,the,given,settings,to,all,the,settings,consumers,or,to,none,of,them,the,settings,will,be,merged,with,the,node,settings,before,they,are,applied,while,given,settings,override,existing,node,settings,param,new,settings,the,settings,to,apply,return,the,unmerged,applied,settings;public,synchronized,settings,apply,settings,settings,new,settings,if,last,settings,applied,null,new,settings,equals,last,settings,applied,return,new,settings,final,settings,current,settings,builder,put,this,settings,put,new,settings,build,final,settings,previous,settings,builder,put,this,settings,put,this,last,settings,applied,build,try,list,runnable,apply,runnables,new,array,list,for,setting,updater,setting,updater,setting,updaters,try,apply,runnables,add,setting,updater,updater,current,previous,catch,exception,ex,logger,warn,new,parameterized,message,failed,to,prepare,commit,settings,for,setting,updater,ex,throw,ex,for,runnable,setting,updater,apply,runnables,setting,updater,run,catch,exception,ex,logger,warn,failed,to,apply,settings,ex,throw,ex,finally,return,last,settings,applied,new,settings
AbstractScopedSettings -> public synchronized Settings applySettings(Settings newSettings);1536611444;Applies the given settings to all the settings consumers or to none of them. The settings_will be merged with the node settings before they are applied while given settings override existing node_settings._@param newSettings the settings to apply_@return the unmerged applied settings;public synchronized Settings applySettings(Settings newSettings) {_        if (lastSettingsApplied != null && newSettings.equals(lastSettingsApplied)) {_            _            return newSettings__        }_        final Settings current = Settings.builder().put(this.settings).put(newSettings).build()__        final Settings previous = Settings.builder().put(this.settings).put(this.lastSettingsApplied).build()__        try {_            List<Runnable> applyRunnables = new ArrayList<>()__            for (SettingUpdater<?> settingUpdater : settingUpdaters) {_                try {_                    applyRunnables.add(settingUpdater.updater(current, previous))__                } catch (Exception ex) {_                    logger.warn(() -> new ParameterizedMessage("failed to prepareCommit settings for [{}]", settingUpdater), ex)__                    throw ex__                }_            }_            for (Runnable settingUpdater : applyRunnables) {_                settingUpdater.run()__            }_        } catch (Exception ex) {_            logger.warn("failed to apply settings", ex)__            throw ex__        } finally {_        }_        return lastSettingsApplied = newSettings__    };applies,the,given,settings,to,all,the,settings,consumers,or,to,none,of,them,the,settings,will,be,merged,with,the,node,settings,before,they,are,applied,while,given,settings,override,existing,node,settings,param,new,settings,the,settings,to,apply,return,the,unmerged,applied,settings;public,synchronized,settings,apply,settings,settings,new,settings,if,last,settings,applied,null,new,settings,equals,last,settings,applied,return,new,settings,final,settings,current,settings,builder,put,this,settings,put,new,settings,build,final,settings,previous,settings,builder,put,this,settings,put,this,last,settings,applied,build,try,list,runnable,apply,runnables,new,array,list,for,setting,updater,setting,updater,setting,updaters,try,apply,runnables,add,setting,updater,updater,current,previous,catch,exception,ex,logger,warn,new,parameterized,message,failed,to,prepare,commit,settings,for,setting,updater,ex,throw,ex,for,runnable,setting,updater,apply,runnables,setting,updater,run,catch,exception,ex,logger,warn,failed,to,apply,settings,ex,throw,ex,finally,return,last,settings,applied,new,settings
AbstractScopedSettings -> public synchronized Settings applySettings(Settings newSettings);1536828374;Applies the given settings to all the settings consumers or to none of them. The settings_will be merged with the node settings before they are applied while given settings override existing node_settings._@param newSettings the settings to apply_@return the unmerged applied settings;public synchronized Settings applySettings(Settings newSettings) {_        if (lastSettingsApplied != null && newSettings.equals(lastSettingsApplied)) {_            _            return newSettings__        }_        final Settings current = Settings.builder().put(this.settings).put(newSettings).build()__        final Settings previous = Settings.builder().put(this.settings).put(this.lastSettingsApplied).build()__        try {_            List<Runnable> applyRunnables = new ArrayList<>()__            for (SettingUpdater<?> settingUpdater : settingUpdaters) {_                try {_                    applyRunnables.add(settingUpdater.updater(current, previous))__                } catch (Exception ex) {_                    logger.warn(() -> new ParameterizedMessage("failed to prepareCommit settings for [{}]", settingUpdater), ex)__                    throw ex__                }_            }_            for (Runnable settingUpdater : applyRunnables) {_                settingUpdater.run()__            }_        } catch (Exception ex) {_            logger.warn("failed to apply settings", ex)__            throw ex__        } finally {_        }_        return lastSettingsApplied = newSettings__    };applies,the,given,settings,to,all,the,settings,consumers,or,to,none,of,them,the,settings,will,be,merged,with,the,node,settings,before,they,are,applied,while,given,settings,override,existing,node,settings,param,new,settings,the,settings,to,apply,return,the,unmerged,applied,settings;public,synchronized,settings,apply,settings,settings,new,settings,if,last,settings,applied,null,new,settings,equals,last,settings,applied,return,new,settings,final,settings,current,settings,builder,put,this,settings,put,new,settings,build,final,settings,previous,settings,builder,put,this,settings,put,this,last,settings,applied,build,try,list,runnable,apply,runnables,new,array,list,for,setting,updater,setting,updater,setting,updaters,try,apply,runnables,add,setting,updater,updater,current,previous,catch,exception,ex,logger,warn,new,parameterized,message,failed,to,prepare,commit,settings,for,setting,updater,ex,throw,ex,for,runnable,setting,updater,apply,runnables,setting,updater,run,catch,exception,ex,logger,warn,failed,to,apply,settings,ex,throw,ex,finally,return,last,settings,applied,new,settings
AbstractScopedSettings -> public synchronized Settings applySettings(Settings newSettings);1539951844;Applies the given settings to all the settings consumers or to none of them. The settings_will be merged with the node settings before they are applied while given settings override existing node_settings._@param newSettings the settings to apply_@return the unmerged applied settings;public synchronized Settings applySettings(Settings newSettings) {_        if (lastSettingsApplied != null && newSettings.equals(lastSettingsApplied)) {_            _            return newSettings__        }_        final Settings current = Settings.builder().put(this.settings).put(newSettings).build()__        final Settings previous = Settings.builder().put(this.settings).put(this.lastSettingsApplied).build()__        try {_            List<Runnable> applyRunnables = new ArrayList<>()__            for (SettingUpdater<?> settingUpdater : settingUpdaters) {_                try {_                    applyRunnables.add(settingUpdater.updater(current, previous))__                } catch (Exception ex) {_                    logger.warn(() -> new ParameterizedMessage("failed to prepareCommit settings for [{}]", settingUpdater), ex)__                    throw ex__                }_            }_            for (Runnable settingUpdater : applyRunnables) {_                settingUpdater.run()__            }_        } catch (Exception ex) {_            logger.warn("failed to apply settings", ex)__            throw ex__        } finally {_        }_        return lastSettingsApplied = newSettings__    };applies,the,given,settings,to,all,the,settings,consumers,or,to,none,of,them,the,settings,will,be,merged,with,the,node,settings,before,they,are,applied,while,given,settings,override,existing,node,settings,param,new,settings,the,settings,to,apply,return,the,unmerged,applied,settings;public,synchronized,settings,apply,settings,settings,new,settings,if,last,settings,applied,null,new,settings,equals,last,settings,applied,return,new,settings,final,settings,current,settings,builder,put,this,settings,put,new,settings,build,final,settings,previous,settings,builder,put,this,settings,put,this,last,settings,applied,build,try,list,runnable,apply,runnables,new,array,list,for,setting,updater,setting,updater,setting,updaters,try,apply,runnables,add,setting,updater,updater,current,previous,catch,exception,ex,logger,warn,new,parameterized,message,failed,to,prepare,commit,settings,for,setting,updater,ex,throw,ex,for,runnable,setting,updater,apply,runnables,setting,updater,run,catch,exception,ex,logger,warn,failed,to,apply,settings,ex,throw,ex,finally,return,last,settings,applied,new,settings
AbstractScopedSettings -> public synchronized Settings applySettings(Settings newSettings);1541008027;Applies the given settings to all the settings consumers or to none of them. The settings_will be merged with the node settings before they are applied while given settings override existing node_settings._@param newSettings the settings to apply_@return the unmerged applied settings;public synchronized Settings applySettings(Settings newSettings) {_        if (lastSettingsApplied != null && newSettings.equals(lastSettingsApplied)) {_            _            return newSettings__        }_        final Settings current = Settings.builder().put(this.settings).put(newSettings).build()__        final Settings previous = Settings.builder().put(this.settings).put(this.lastSettingsApplied).build()__        try {_            List<Runnable> applyRunnables = new ArrayList<>()__            for (SettingUpdater<?> settingUpdater : settingUpdaters) {_                try {_                    applyRunnables.add(settingUpdater.updater(current, previous))__                } catch (Exception ex) {_                    logger.warn(() -> new ParameterizedMessage("failed to prepareCommit settings for [{}]", settingUpdater), ex)__                    throw ex__                }_            }_            for (Runnable settingUpdater : applyRunnables) {_                settingUpdater.run()__            }_        } catch (Exception ex) {_            logger.warn("failed to apply settings", ex)__            throw ex__        } finally {_        }_        return lastSettingsApplied = newSettings__    };applies,the,given,settings,to,all,the,settings,consumers,or,to,none,of,them,the,settings,will,be,merged,with,the,node,settings,before,they,are,applied,while,given,settings,override,existing,node,settings,param,new,settings,the,settings,to,apply,return,the,unmerged,applied,settings;public,synchronized,settings,apply,settings,settings,new,settings,if,last,settings,applied,null,new,settings,equals,last,settings,applied,return,new,settings,final,settings,current,settings,builder,put,this,settings,put,new,settings,build,final,settings,previous,settings,builder,put,this,settings,put,this,last,settings,applied,build,try,list,runnable,apply,runnables,new,array,list,for,setting,updater,setting,updater,setting,updaters,try,apply,runnables,add,setting,updater,updater,current,previous,catch,exception,ex,logger,warn,new,parameterized,message,failed,to,prepare,commit,settings,for,setting,updater,ex,throw,ex,for,runnable,setting,updater,apply,runnables,setting,updater,run,catch,exception,ex,logger,warn,failed,to,apply,settings,ex,throw,ex,finally,return,last,settings,applied,new,settings
AbstractScopedSettings -> public synchronized Settings applySettings(Settings newSettings);1541092382;Applies the given settings to all the settings consumers or to none of them. The settings_will be merged with the node settings before they are applied while given settings override existing node_settings._@param newSettings the settings to apply_@return the unmerged applied settings;public synchronized Settings applySettings(Settings newSettings) {_        if (lastSettingsApplied != null && newSettings.equals(lastSettingsApplied)) {_            _            return newSettings__        }_        final Settings current = Settings.builder().put(this.settings).put(newSettings).build()__        final Settings previous = Settings.builder().put(this.settings).put(this.lastSettingsApplied).build()__        try {_            List<Runnable> applyRunnables = new ArrayList<>()__            for (SettingUpdater<?> settingUpdater : settingUpdaters) {_                try {_                    applyRunnables.add(settingUpdater.updater(current, previous))__                } catch (Exception ex) {_                    logger.warn(() -> new ParameterizedMessage("failed to prepareCommit settings for [{}]", settingUpdater), ex)__                    throw ex__                }_            }_            for (Runnable settingUpdater : applyRunnables) {_                settingUpdater.run()__            }_        } catch (Exception ex) {_            logger.warn("failed to apply settings", ex)__            throw ex__        } finally {_        }_        return lastSettingsApplied = newSettings__    };applies,the,given,settings,to,all,the,settings,consumers,or,to,none,of,them,the,settings,will,be,merged,with,the,node,settings,before,they,are,applied,while,given,settings,override,existing,node,settings,param,new,settings,the,settings,to,apply,return,the,unmerged,applied,settings;public,synchronized,settings,apply,settings,settings,new,settings,if,last,settings,applied,null,new,settings,equals,last,settings,applied,return,new,settings,final,settings,current,settings,builder,put,this,settings,put,new,settings,build,final,settings,previous,settings,builder,put,this,settings,put,this,last,settings,applied,build,try,list,runnable,apply,runnables,new,array,list,for,setting,updater,setting,updater,setting,updaters,try,apply,runnables,add,setting,updater,updater,current,previous,catch,exception,ex,logger,warn,new,parameterized,message,failed,to,prepare,commit,settings,for,setting,updater,ex,throw,ex,for,runnable,setting,updater,apply,runnables,setting,updater,run,catch,exception,ex,logger,warn,failed,to,apply,settings,ex,throw,ex,finally,return,last,settings,applied,new,settings
AbstractScopedSettings -> public synchronized Settings applySettings(Settings newSettings);1542402632;Applies the given settings to all the settings consumers or to none of them. The settings_will be merged with the node settings before they are applied while given settings override existing node_settings._@param newSettings the settings to apply_@return the unmerged applied settings;public synchronized Settings applySettings(Settings newSettings) {_        if (lastSettingsApplied != null && newSettings.equals(lastSettingsApplied)) {_            _            return newSettings__        }_        final Settings current = Settings.builder().put(this.settings).put(newSettings).build()__        final Settings previous = Settings.builder().put(this.settings).put(this.lastSettingsApplied).build()__        try {_            List<Runnable> applyRunnables = new ArrayList<>()__            for (SettingUpdater<?> settingUpdater : settingUpdaters) {_                try {_                    applyRunnables.add(settingUpdater.updater(current, previous))__                } catch (Exception ex) {_                    logger.warn(() -> new ParameterizedMessage("failed to prepareCommit settings for [{}]", settingUpdater), ex)__                    throw ex__                }_            }_            for (Runnable settingUpdater : applyRunnables) {_                settingUpdater.run()__            }_        } catch (Exception ex) {_            logger.warn("failed to apply settings", ex)__            throw ex__        } finally {_        }_        return lastSettingsApplied = newSettings__    };applies,the,given,settings,to,all,the,settings,consumers,or,to,none,of,them,the,settings,will,be,merged,with,the,node,settings,before,they,are,applied,while,given,settings,override,existing,node,settings,param,new,settings,the,settings,to,apply,return,the,unmerged,applied,settings;public,synchronized,settings,apply,settings,settings,new,settings,if,last,settings,applied,null,new,settings,equals,last,settings,applied,return,new,settings,final,settings,current,settings,builder,put,this,settings,put,new,settings,build,final,settings,previous,settings,builder,put,this,settings,put,this,last,settings,applied,build,try,list,runnable,apply,runnables,new,array,list,for,setting,updater,setting,updater,setting,updaters,try,apply,runnables,add,setting,updater,updater,current,previous,catch,exception,ex,logger,warn,new,parameterized,message,failed,to,prepare,commit,settings,for,setting,updater,ex,throw,ex,for,runnable,setting,updater,apply,runnables,setting,updater,run,catch,exception,ex,logger,warn,failed,to,apply,settings,ex,throw,ex,finally,return,last,settings,applied,new,settings
AbstractScopedSettings -> public synchronized Settings applySettings(Settings newSettings);1544081506;Applies the given settings to all the settings consumers or to none of them. The settings_will be merged with the node settings before they are applied while given settings override existing node_settings._@param newSettings the settings to apply_@return the unmerged applied settings;public synchronized Settings applySettings(Settings newSettings) {_        if (lastSettingsApplied != null && newSettings.equals(lastSettingsApplied)) {_            _            return newSettings__        }_        final Settings current = Settings.builder().put(this.settings).put(newSettings).build()__        final Settings previous = Settings.builder().put(this.settings).put(this.lastSettingsApplied).build()__        try {_            List<Runnable> applyRunnables = new ArrayList<>()__            for (SettingUpdater<?> settingUpdater : settingUpdaters) {_                try {_                    applyRunnables.add(settingUpdater.updater(current, previous))__                } catch (Exception ex) {_                    logger.warn(() -> new ParameterizedMessage("failed to prepareCommit settings for [{}]", settingUpdater), ex)__                    throw ex__                }_            }_            for (Runnable settingUpdater : applyRunnables) {_                settingUpdater.run()__            }_        } catch (Exception ex) {_            logger.warn("failed to apply settings", ex)__            throw ex__        } finally {_        }_        return lastSettingsApplied = newSettings__    };applies,the,given,settings,to,all,the,settings,consumers,or,to,none,of,them,the,settings,will,be,merged,with,the,node,settings,before,they,are,applied,while,given,settings,override,existing,node,settings,param,new,settings,the,settings,to,apply,return,the,unmerged,applied,settings;public,synchronized,settings,apply,settings,settings,new,settings,if,last,settings,applied,null,new,settings,equals,last,settings,applied,return,new,settings,final,settings,current,settings,builder,put,this,settings,put,new,settings,build,final,settings,previous,settings,builder,put,this,settings,put,this,last,settings,applied,build,try,list,runnable,apply,runnables,new,array,list,for,setting,updater,setting,updater,setting,updaters,try,apply,runnables,add,setting,updater,updater,current,previous,catch,exception,ex,logger,warn,new,parameterized,message,failed,to,prepare,commit,settings,for,setting,updater,ex,throw,ex,for,runnable,setting,updater,apply,runnables,setting,updater,run,catch,exception,ex,logger,warn,failed,to,apply,settings,ex,throw,ex,finally,return,last,settings,applied,new,settings
AbstractScopedSettings -> public synchronized Settings applySettings(Settings newSettings);1544691774;Applies the given settings to all the settings consumers or to none of them. The settings_will be merged with the node settings before they are applied while given settings override existing node_settings._@param newSettings the settings to apply_@return the unmerged applied settings;public synchronized Settings applySettings(Settings newSettings) {_        if (lastSettingsApplied != null && newSettings.equals(lastSettingsApplied)) {_            _            return newSettings__        }_        final Settings current = Settings.builder().put(this.settings).put(newSettings).build()__        final Settings previous = Settings.builder().put(this.settings).put(this.lastSettingsApplied).build()__        try {_            List<Runnable> applyRunnables = new ArrayList<>()__            for (SettingUpdater<?> settingUpdater : settingUpdaters) {_                try {_                    applyRunnables.add(settingUpdater.updater(current, previous))__                } catch (Exception ex) {_                    logger.warn(() -> new ParameterizedMessage("failed to prepareCommit settings for [{}]", settingUpdater), ex)__                    throw ex__                }_            }_            for (Runnable settingUpdater : applyRunnables) {_                settingUpdater.run()__            }_        } catch (Exception ex) {_            logger.warn("failed to apply settings", ex)__            throw ex__        } finally {_        }_        return lastSettingsApplied = newSettings__    };applies,the,given,settings,to,all,the,settings,consumers,or,to,none,of,them,the,settings,will,be,merged,with,the,node,settings,before,they,are,applied,while,given,settings,override,existing,node,settings,param,new,settings,the,settings,to,apply,return,the,unmerged,applied,settings;public,synchronized,settings,apply,settings,settings,new,settings,if,last,settings,applied,null,new,settings,equals,last,settings,applied,return,new,settings,final,settings,current,settings,builder,put,this,settings,put,new,settings,build,final,settings,previous,settings,builder,put,this,settings,put,this,last,settings,applied,build,try,list,runnable,apply,runnables,new,array,list,for,setting,updater,setting,updater,setting,updaters,try,apply,runnables,add,setting,updater,updater,current,previous,catch,exception,ex,logger,warn,new,parameterized,message,failed,to,prepare,commit,settings,for,setting,updater,ex,throw,ex,for,runnable,setting,updater,apply,runnables,setting,updater,run,catch,exception,ex,logger,warn,failed,to,apply,settings,ex,throw,ex,finally,return,last,settings,applied,new,settings
AbstractScopedSettings -> public synchronized Settings applySettings(Settings newSettings);1546877578;Applies the given settings to all the settings consumers or to none of them. The settings_will be merged with the node settings before they are applied while given settings override existing node_settings._@param newSettings the settings to apply_@return the unmerged applied settings;public synchronized Settings applySettings(Settings newSettings) {_        if (lastSettingsApplied != null && newSettings.equals(lastSettingsApplied)) {_            _            return newSettings__        }_        final Settings current = Settings.builder().put(this.settings).put(newSettings).build()__        final Settings previous = Settings.builder().put(this.settings).put(this.lastSettingsApplied).build()__        try {_            List<Runnable> applyRunnables = new ArrayList<>()__            for (SettingUpdater<?> settingUpdater : settingUpdaters) {_                try {_                    applyRunnables.add(settingUpdater.updater(current, previous))__                } catch (Exception ex) {_                    logger.warn(() -> new ParameterizedMessage("failed to prepareCommit settings for [{}]", settingUpdater), ex)__                    throw ex__                }_            }_            for (Runnable settingUpdater : applyRunnables) {_                settingUpdater.run()__            }_        } catch (Exception ex) {_            logger.warn("failed to apply settings", ex)__            throw ex__        } finally {_        }_        return lastSettingsApplied = newSettings__    };applies,the,given,settings,to,all,the,settings,consumers,or,to,none,of,them,the,settings,will,be,merged,with,the,node,settings,before,they,are,applied,while,given,settings,override,existing,node,settings,param,new,settings,the,settings,to,apply,return,the,unmerged,applied,settings;public,synchronized,settings,apply,settings,settings,new,settings,if,last,settings,applied,null,new,settings,equals,last,settings,applied,return,new,settings,final,settings,current,settings,builder,put,this,settings,put,new,settings,build,final,settings,previous,settings,builder,put,this,settings,put,this,last,settings,applied,build,try,list,runnable,apply,runnables,new,array,list,for,setting,updater,setting,updater,setting,updaters,try,apply,runnables,add,setting,updater,updater,current,previous,catch,exception,ex,logger,warn,new,parameterized,message,failed,to,prepare,commit,settings,for,setting,updater,ex,throw,ex,for,runnable,setting,updater,apply,runnables,setting,updater,run,catch,exception,ex,logger,warn,failed,to,apply,settings,ex,throw,ex,finally,return,last,settings,applied,new,settings
AbstractScopedSettings -> public synchronized Settings applySettings(Settings newSettings);1548270339;Applies the given settings to all the settings consumers or to none of them. The settings_will be merged with the node settings before they are applied while given settings override existing node_settings._@param newSettings the settings to apply_@return the unmerged applied settings;public synchronized Settings applySettings(Settings newSettings) {_        if (lastSettingsApplied != null && newSettings.equals(lastSettingsApplied)) {_            _            return newSettings__        }_        final Settings current = Settings.builder().put(this.settings).put(newSettings).build()__        final Settings previous = Settings.builder().put(this.settings).put(this.lastSettingsApplied).build()__        try {_            List<Runnable> applyRunnables = new ArrayList<>()__            for (SettingUpdater<?> settingUpdater : settingUpdaters) {_                try {_                    applyRunnables.add(settingUpdater.updater(current, previous))__                } catch (Exception ex) {_                    logger.warn(() -> new ParameterizedMessage("failed to prepareCommit settings for [{}]", settingUpdater), ex)__                    throw ex__                }_            }_            for (Runnable settingUpdater : applyRunnables) {_                settingUpdater.run()__            }_        } catch (Exception ex) {_            logger.warn("failed to apply settings", ex)__            throw ex__        } finally {_        }_        return lastSettingsApplied = newSettings__    };applies,the,given,settings,to,all,the,settings,consumers,or,to,none,of,them,the,settings,will,be,merged,with,the,node,settings,before,they,are,applied,while,given,settings,override,existing,node,settings,param,new,settings,the,settings,to,apply,return,the,unmerged,applied,settings;public,synchronized,settings,apply,settings,settings,new,settings,if,last,settings,applied,null,new,settings,equals,last,settings,applied,return,new,settings,final,settings,current,settings,builder,put,this,settings,put,new,settings,build,final,settings,previous,settings,builder,put,this,settings,put,this,last,settings,applied,build,try,list,runnable,apply,runnables,new,array,list,for,setting,updater,setting,updater,setting,updaters,try,apply,runnables,add,setting,updater,updater,current,previous,catch,exception,ex,logger,warn,new,parameterized,message,failed,to,prepare,commit,settings,for,setting,updater,ex,throw,ex,for,runnable,setting,updater,apply,runnables,setting,updater,run,catch,exception,ex,logger,warn,failed,to,apply,settings,ex,throw,ex,finally,return,last,settings,applied,new,settings
AbstractScopedSettings -> public Settings diff(Settings source, Settings defaultSettings);1524684173;Returns a settings object that contains all settings that are not_already set in the given source. The diff contains either the default value for each_setting or the settings value in the given default settings.;public Settings diff(Settings source, Settings defaultSettings) {_        Settings.Builder builder = Settings.builder()__        for (Setting<?> setting : keySettings.values()) {_            setting.diff(builder, source, defaultSettings)__        }_        for (Setting<?> setting : complexMatchers.values()) {_            setting.diff(builder, source, defaultSettings)__        }_        return builder.build()__    };returns,a,settings,object,that,contains,all,settings,that,are,not,already,set,in,the,given,source,the,diff,contains,either,the,default,value,for,each,setting,or,the,settings,value,in,the,given,default,settings;public,settings,diff,settings,source,settings,default,settings,settings,builder,builder,settings,builder,for,setting,setting,key,settings,values,setting,diff,builder,source,default,settings,for,setting,setting,complex,matchers,values,setting,diff,builder,source,default,settings,return,builder,build
AbstractScopedSettings -> public Settings diff(Settings source, Settings defaultSettings);1528904315;Returns a settings object that contains all settings that are not_already set in the given source. The diff contains either the default value for each_setting or the settings value in the given default settings.;public Settings diff(Settings source, Settings defaultSettings) {_        Settings.Builder builder = Settings.builder()__        for (Setting<?> setting : keySettings.values()) {_            setting.diff(builder, source, defaultSettings)__        }_        for (Setting<?> setting : complexMatchers.values()) {_            setting.diff(builder, source, defaultSettings)__        }_        return builder.build()__    };returns,a,settings,object,that,contains,all,settings,that,are,not,already,set,in,the,given,source,the,diff,contains,either,the,default,value,for,each,setting,or,the,settings,value,in,the,given,default,settings;public,settings,diff,settings,source,settings,default,settings,settings,builder,builder,settings,builder,for,setting,setting,key,settings,values,setting,diff,builder,source,default,settings,for,setting,setting,complex,matchers,values,setting,diff,builder,source,default,settings,return,builder,build
AbstractScopedSettings -> public Settings diff(Settings source, Settings defaultSettings);1531179852;Returns a settings object that contains all settings that are not_already set in the given source. The diff contains either the default value for each_setting or the settings value in the given default settings.;public Settings diff(Settings source, Settings defaultSettings) {_        Settings.Builder builder = Settings.builder()__        for (Setting<?> setting : keySettings.values()) {_            setting.diff(builder, source, defaultSettings)__        }_        for (Setting<?> setting : complexMatchers.values()) {_            setting.diff(builder, source, defaultSettings)__        }_        return builder.build()__    };returns,a,settings,object,that,contains,all,settings,that,are,not,already,set,in,the,given,source,the,diff,contains,either,the,default,value,for,each,setting,or,the,settings,value,in,the,given,default,settings;public,settings,diff,settings,source,settings,default,settings,settings,builder,builder,settings,builder,for,setting,setting,key,settings,values,setting,diff,builder,source,default,settings,for,setting,setting,complex,matchers,values,setting,diff,builder,source,default,settings,return,builder,build
AbstractScopedSettings -> public Settings diff(Settings source, Settings defaultSettings);1535046779;Returns a settings object that contains all settings that are not_already set in the given source. The diff contains either the default value for each_setting or the settings value in the given default settings.;public Settings diff(Settings source, Settings defaultSettings) {_        Settings.Builder builder = Settings.builder()__        for (Setting<?> setting : keySettings.values()) {_            setting.diff(builder, source, defaultSettings)__        }_        for (Setting<?> setting : complexMatchers.values()) {_            setting.diff(builder, source, defaultSettings)__        }_        return builder.build()__    };returns,a,settings,object,that,contains,all,settings,that,are,not,already,set,in,the,given,source,the,diff,contains,either,the,default,value,for,each,setting,or,the,settings,value,in,the,given,default,settings;public,settings,diff,settings,source,settings,default,settings,settings,builder,builder,settings,builder,for,setting,setting,key,settings,values,setting,diff,builder,source,default,settings,for,setting,setting,complex,matchers,values,setting,diff,builder,source,default,settings,return,builder,build
AbstractScopedSettings -> public Settings diff(Settings source, Settings defaultSettings);1536137328;Returns a settings object that contains all settings that are not_already set in the given source. The diff contains either the default value for each_setting or the settings value in the given default settings.;public Settings diff(Settings source, Settings defaultSettings) {_        Settings.Builder builder = Settings.builder()__        for (Setting<?> setting : keySettings.values()) {_            setting.diff(builder, source, defaultSettings)__        }_        for (Setting<?> setting : complexMatchers.values()) {_            setting.diff(builder, source, defaultSettings)__        }_        return builder.build()__    };returns,a,settings,object,that,contains,all,settings,that,are,not,already,set,in,the,given,source,the,diff,contains,either,the,default,value,for,each,setting,or,the,settings,value,in,the,given,default,settings;public,settings,diff,settings,source,settings,default,settings,settings,builder,builder,settings,builder,for,setting,setting,key,settings,values,setting,diff,builder,source,default,settings,for,setting,setting,complex,matchers,values,setting,diff,builder,source,default,settings,return,builder,build
AbstractScopedSettings -> public Settings diff(Settings source, Settings defaultSettings);1536314350;Returns a settings object that contains all settings that are not_already set in the given source. The diff contains either the default value for each_setting or the settings value in the given default settings.;public Settings diff(Settings source, Settings defaultSettings) {_        Settings.Builder builder = Settings.builder()__        for (Setting<?> setting : keySettings.values()) {_            setting.diff(builder, source, defaultSettings)__        }_        for (Setting<?> setting : complexMatchers.values()) {_            setting.diff(builder, source, defaultSettings)__        }_        return builder.build()__    };returns,a,settings,object,that,contains,all,settings,that,are,not,already,set,in,the,given,source,the,diff,contains,either,the,default,value,for,each,setting,or,the,settings,value,in,the,given,default,settings;public,settings,diff,settings,source,settings,default,settings,settings,builder,builder,settings,builder,for,setting,setting,key,settings,values,setting,diff,builder,source,default,settings,for,setting,setting,complex,matchers,values,setting,diff,builder,source,default,settings,return,builder,build
AbstractScopedSettings -> public Settings diff(Settings source, Settings defaultSettings);1536611444;Returns a settings object that contains all settings that are not_already set in the given source. The diff contains either the default value for each_setting or the settings value in the given default settings.;public Settings diff(Settings source, Settings defaultSettings) {_        Settings.Builder builder = Settings.builder()__        for (Setting<?> setting : keySettings.values()) {_            setting.diff(builder, source, defaultSettings)__        }_        for (Setting<?> setting : complexMatchers.values()) {_            setting.diff(builder, source, defaultSettings)__        }_        return builder.build()__    };returns,a,settings,object,that,contains,all,settings,that,are,not,already,set,in,the,given,source,the,diff,contains,either,the,default,value,for,each,setting,or,the,settings,value,in,the,given,default,settings;public,settings,diff,settings,source,settings,default,settings,settings,builder,builder,settings,builder,for,setting,setting,key,settings,values,setting,diff,builder,source,default,settings,for,setting,setting,complex,matchers,values,setting,diff,builder,source,default,settings,return,builder,build
AbstractScopedSettings -> public Settings diff(Settings source, Settings defaultSettings);1536828374;Returns a settings object that contains all settings that are not_already set in the given source. The diff contains either the default value for each_setting or the settings value in the given default settings.;public Settings diff(Settings source, Settings defaultSettings) {_        Settings.Builder builder = Settings.builder()__        for (Setting<?> setting : keySettings.values()) {_            setting.diff(builder, source, defaultSettings)__        }_        for (Setting<?> setting : complexMatchers.values()) {_            setting.diff(builder, source, defaultSettings)__        }_        return builder.build()__    };returns,a,settings,object,that,contains,all,settings,that,are,not,already,set,in,the,given,source,the,diff,contains,either,the,default,value,for,each,setting,or,the,settings,value,in,the,given,default,settings;public,settings,diff,settings,source,settings,default,settings,settings,builder,builder,settings,builder,for,setting,setting,key,settings,values,setting,diff,builder,source,default,settings,for,setting,setting,complex,matchers,values,setting,diff,builder,source,default,settings,return,builder,build
AbstractScopedSettings -> public Settings diff(Settings source, Settings defaultSettings);1539951844;Returns a settings object that contains all settings that are not_already set in the given source. The diff contains either the default value for each_setting or the settings value in the given default settings.;public Settings diff(Settings source, Settings defaultSettings) {_        Settings.Builder builder = Settings.builder()__        for (Setting<?> setting : keySettings.values()) {_            setting.diff(builder, source, defaultSettings)__        }_        for (Setting<?> setting : complexMatchers.values()) {_            setting.diff(builder, source, defaultSettings)__        }_        return builder.build()__    };returns,a,settings,object,that,contains,all,settings,that,are,not,already,set,in,the,given,source,the,diff,contains,either,the,default,value,for,each,setting,or,the,settings,value,in,the,given,default,settings;public,settings,diff,settings,source,settings,default,settings,settings,builder,builder,settings,builder,for,setting,setting,key,settings,values,setting,diff,builder,source,default,settings,for,setting,setting,complex,matchers,values,setting,diff,builder,source,default,settings,return,builder,build
AbstractScopedSettings -> public Settings diff(Settings source, Settings defaultSettings);1541008027;Returns a settings object that contains all settings that are not_already set in the given source. The diff contains either the default value for each_setting or the settings value in the given default settings.;public Settings diff(Settings source, Settings defaultSettings) {_        Settings.Builder builder = Settings.builder()__        for (Setting<?> setting : keySettings.values()) {_            setting.diff(builder, source, defaultSettings)__        }_        for (Setting<?> setting : complexMatchers.values()) {_            setting.diff(builder, source, defaultSettings)__        }_        return builder.build()__    };returns,a,settings,object,that,contains,all,settings,that,are,not,already,set,in,the,given,source,the,diff,contains,either,the,default,value,for,each,setting,or,the,settings,value,in,the,given,default,settings;public,settings,diff,settings,source,settings,default,settings,settings,builder,builder,settings,builder,for,setting,setting,key,settings,values,setting,diff,builder,source,default,settings,for,setting,setting,complex,matchers,values,setting,diff,builder,source,default,settings,return,builder,build
AbstractScopedSettings -> public Settings diff(Settings source, Settings defaultSettings);1541092382;Returns a settings object that contains all settings that are not_already set in the given source. The diff contains either the default value for each_setting or the settings value in the given default settings.;public Settings diff(Settings source, Settings defaultSettings) {_        Settings.Builder builder = Settings.builder()__        for (Setting<?> setting : keySettings.values()) {_            setting.diff(builder, source, defaultSettings)__        }_        for (Setting<?> setting : complexMatchers.values()) {_            setting.diff(builder, source, defaultSettings)__        }_        return builder.build()__    };returns,a,settings,object,that,contains,all,settings,that,are,not,already,set,in,the,given,source,the,diff,contains,either,the,default,value,for,each,setting,or,the,settings,value,in,the,given,default,settings;public,settings,diff,settings,source,settings,default,settings,settings,builder,builder,settings,builder,for,setting,setting,key,settings,values,setting,diff,builder,source,default,settings,for,setting,setting,complex,matchers,values,setting,diff,builder,source,default,settings,return,builder,build
AbstractScopedSettings -> public Settings diff(Settings source, Settings defaultSettings);1542402632;Returns a settings object that contains all settings that are not_already set in the given source. The diff contains either the default value for each_setting or the settings value in the given default settings.;public Settings diff(Settings source, Settings defaultSettings) {_        Settings.Builder builder = Settings.builder()__        for (Setting<?> setting : keySettings.values()) {_            setting.diff(builder, source, defaultSettings)__        }_        for (Setting<?> setting : complexMatchers.values()) {_            setting.diff(builder, source, defaultSettings)__        }_        return builder.build()__    };returns,a,settings,object,that,contains,all,settings,that,are,not,already,set,in,the,given,source,the,diff,contains,either,the,default,value,for,each,setting,or,the,settings,value,in,the,given,default,settings;public,settings,diff,settings,source,settings,default,settings,settings,builder,builder,settings,builder,for,setting,setting,key,settings,values,setting,diff,builder,source,default,settings,for,setting,setting,complex,matchers,values,setting,diff,builder,source,default,settings,return,builder,build
AbstractScopedSettings -> public Settings diff(Settings source, Settings defaultSettings);1544081506;Returns a settings object that contains all settings that are not_already set in the given source. The diff contains either the default value for each_setting or the settings value in the given default settings.;public Settings diff(Settings source, Settings defaultSettings) {_        Settings.Builder builder = Settings.builder()__        for (Setting<?> setting : keySettings.values()) {_            setting.diff(builder, source, defaultSettings)__        }_        for (Setting<?> setting : complexMatchers.values()) {_            setting.diff(builder, source, defaultSettings)__        }_        return builder.build()__    };returns,a,settings,object,that,contains,all,settings,that,are,not,already,set,in,the,given,source,the,diff,contains,either,the,default,value,for,each,setting,or,the,settings,value,in,the,given,default,settings;public,settings,diff,settings,source,settings,default,settings,settings,builder,builder,settings,builder,for,setting,setting,key,settings,values,setting,diff,builder,source,default,settings,for,setting,setting,complex,matchers,values,setting,diff,builder,source,default,settings,return,builder,build
AbstractScopedSettings -> public Settings diff(Settings source, Settings defaultSettings);1544691774;Returns a settings object that contains all settings that are not_already set in the given source. The diff contains either the default value for each_setting or the settings value in the given default settings.;public Settings diff(Settings source, Settings defaultSettings) {_        Settings.Builder builder = Settings.builder()__        for (Setting<?> setting : keySettings.values()) {_            setting.diff(builder, source, defaultSettings)__        }_        for (Setting<?> setting : complexMatchers.values()) {_            setting.diff(builder, source, defaultSettings)__        }_        return builder.build()__    };returns,a,settings,object,that,contains,all,settings,that,are,not,already,set,in,the,given,source,the,diff,contains,either,the,default,value,for,each,setting,or,the,settings,value,in,the,given,default,settings;public,settings,diff,settings,source,settings,default,settings,settings,builder,builder,settings,builder,for,setting,setting,key,settings,values,setting,diff,builder,source,default,settings,for,setting,setting,complex,matchers,values,setting,diff,builder,source,default,settings,return,builder,build
AbstractScopedSettings -> public Settings diff(Settings source, Settings defaultSettings);1546877578;Returns a settings object that contains all settings that are not_already set in the given source. The diff contains either the default value for each_setting or the settings value in the given default settings.;public Settings diff(Settings source, Settings defaultSettings) {_        Settings.Builder builder = Settings.builder()__        for (Setting<?> setting : keySettings.values()) {_            setting.diff(builder, source, defaultSettings)__        }_        for (Setting<?> setting : complexMatchers.values()) {_            setting.diff(builder, source, defaultSettings)__        }_        return builder.build()__    };returns,a,settings,object,that,contains,all,settings,that,are,not,already,set,in,the,given,source,the,diff,contains,either,the,default,value,for,each,setting,or,the,settings,value,in,the,given,default,settings;public,settings,diff,settings,source,settings,default,settings,settings,builder,builder,settings,builder,for,setting,setting,key,settings,values,setting,diff,builder,source,default,settings,for,setting,setting,complex,matchers,values,setting,diff,builder,source,default,settings,return,builder,build
AbstractScopedSettings -> public Settings diff(Settings source, Settings defaultSettings);1548270339;Returns a settings object that contains all settings that are not_already set in the given source. The diff contains either the default value for each_setting or the settings value in the given default settings.;public Settings diff(Settings source, Settings defaultSettings) {_        Settings.Builder builder = Settings.builder()__        for (Setting<?> setting : keySettings.values()) {_            setting.diff(builder, source, defaultSettings)__        }_        for (Setting<?> setting : complexMatchers.values()) {_            setting.diff(builder, source, defaultSettings)__        }_        return builder.build()__    };returns,a,settings,object,that,contains,all,settings,that,are,not,already,set,in,the,given,source,the,diff,contains,either,the,default,value,for,each,setting,or,the,settings,value,in,the,given,default,settings;public,settings,diff,settings,source,settings,default,settings,settings,builder,builder,settings,builder,for,setting,setting,key,settings,values,setting,diff,builder,source,default,settings,for,setting,setting,complex,matchers,values,setting,diff,builder,source,default,settings,return,builder,build
