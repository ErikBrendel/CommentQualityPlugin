commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * The index name of the action.  */ ;/**  * The index name of the action.  */ public String getIndex() {     return this.index. }
true;public;0;3;/**  * The type of the action.  */ ;/**  * The type of the action.  */ public String getType() {     return type. }
true;public;0;3;/**  * The id of the action.  */ ;/**  * The id of the action.  */ public String getId() {     return id. }
true;public;0;3;/**  * The failure message.  */ ;/**  * The failure message.  */ public String getMessage() {     return exception != null ? exception.getMessage() : null. }
false;public,static;1;5;;public static Failure readFailure(StreamInput in) throws IOException {     Failure failure = new Failure().     failure.readFrom(in).     return failure. }
false;public;1;7;;@Override public void readFrom(StreamInput in) throws IOException {     index = in.readString().     type = in.readOptionalString().     id = in.readString().     exception = in.readException(). }
false;public;1;7;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeString(index).     out.writeOptionalString(type).     out.writeString(id).     out.writeException(exception). }
false;public;2;10;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     builder.field(INDEX.getPreferredName(), index).     builder.field(TYPE.getPreferredName(), type).     builder.field(ID.getPreferredName(), id).     ElasticsearchException.generateFailureXContent(builder, params, exception, true).     builder.endObject().     return builder. }
false;public;0;3;;public Exception getFailure() {     return exception. }
false;public;0;3;;public MultiGetItemResponse[] getResponses() {     return this.responses. }
false;public;0;4;;@Override public Iterator<MultiGetItemResponse> iterator() {     return Arrays.stream(responses).iterator(). }
false;public;2;17;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     builder.startArray(DOCS.getPreferredName()).     for (MultiGetItemResponse response : responses) {         if (response.isFailed()) {             Failure failure = response.getFailure().             failure.toXContent(builder, params).         } else {             GetResponse getResponse = response.getResponse().             getResponse.toXContent(builder, params).         }     }     builder.endArray().     builder.endObject().     return builder. }
false;public,static;1;25;;public static MultiGetResponse fromXContent(XContentParser parser) throws IOException {     String currentFieldName = null.     List<MultiGetItemResponse> items = new ArrayList<>().     for (Token token = parser.nextToken(). token != Token.END_OBJECT. token = parser.nextToken()) {         switch(token) {             case FIELD_NAME:                 currentFieldName = parser.currentName().                 break.             case START_ARRAY:                 if (DOCS.getPreferredName().equals(currentFieldName)) {                     for (token = parser.nextToken(). token != Token.END_ARRAY. token = parser.nextToken()) {                         if (token == Token.START_OBJECT) {                             items.add(parseItem(parser)).                         }                     }                 }                 break.             default:                 // this is parsing logic on the client side.                 break.         }     }     return new MultiGetResponse(items.toArray(new MultiGetItemResponse[0])). }
false;private,static;1;49;;private static MultiGetItemResponse parseItem(XContentParser parser) throws IOException {     String currentFieldName = null.     String index = null.     String type = null.     String id = null.     ElasticsearchException exception = null.     GetResult getResult = null.     for (Token token = parser.nextToken(). token != Token.END_OBJECT. token = parser.nextToken()) {         switch(token) {             case FIELD_NAME:                 currentFieldName = parser.currentName().                 if (INDEX.match(currentFieldName, parser.getDeprecationHandler()) == false && TYPE.match(currentFieldName, parser.getDeprecationHandler()) == false && ID.match(currentFieldName, parser.getDeprecationHandler()) == false && ERROR.match(currentFieldName, parser.getDeprecationHandler()) == false) {                     getResult = GetResult.fromXContentEmbedded(parser, index, type, id).                 }                 break.             case VALUE_STRING:                 if (INDEX.match(currentFieldName, parser.getDeprecationHandler())) {                     index = parser.text().                 } else if (TYPE.match(currentFieldName, parser.getDeprecationHandler())) {                     type = parser.text().                 } else if (ID.match(currentFieldName, parser.getDeprecationHandler())) {                     id = parser.text().                 }                 break.             case START_OBJECT:                 if (ERROR.match(currentFieldName, parser.getDeprecationHandler())) {                     exception = ElasticsearchException.fromXContent(parser).                 }                 break.             default:                 // this is parsing logic on the client side.                 break.         }         if (getResult != null) {             break.         }     }     if (exception != null) {         return new MultiGetItemResponse(null, new Failure(index, type, id, exception)).     } else {         GetResponse getResponse = new GetResponse(getResult).         return new MultiGetItemResponse(getResponse, null).     } }
false;public;1;8;;@Override public void readFrom(StreamInput in) throws IOException {     super.readFrom(in).     responses = new MultiGetItemResponse[in.readVInt()].     for (int i = 0. i < responses.length. i++) {         responses[i] = MultiGetItemResponse.readItemResponse(in).     } }
false;public;1;8;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeVInt(responses.length).     for (MultiGetItemResponse response : responses) {         response.writeTo(out).     } }
