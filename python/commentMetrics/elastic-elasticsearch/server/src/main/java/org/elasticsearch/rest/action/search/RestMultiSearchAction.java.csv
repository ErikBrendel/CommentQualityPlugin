commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String getName() {     return "msearch_action". }
false;public;2;13;;@Override public RestChannelConsumer prepareRequest(final RestRequest request, final NodeClient client) throws IOException {     MultiSearchRequest multiSearchRequest = parseRequest(request, allowExplicitIndex).     // Emit a single deprecation message if any search request contains types.     for (SearchRequest searchRequest : multiSearchRequest.requests()) {         if (searchRequest.types().length > 0) {             deprecationLogger.deprecatedAndMaybeLog("msearch_with_types", TYPES_DEPRECATION_MESSAGE).             break.         }     }     return channel -> client.multiSearch(multiSearchRequest, new RestToXContentListener<>(channel)). }
true;public,static;2;35;/**  * Parses a {@link RestRequest} body and returns a {@link MultiSearchRequest}  */ ;/**  * Parses a {@link RestRequest} body and returns a {@link MultiSearchRequest}  */ public static MultiSearchRequest parseRequest(RestRequest restRequest, boolean allowExplicitIndex) throws IOException {     MultiSearchRequest multiRequest = new MultiSearchRequest().     IndicesOptions indicesOptions = IndicesOptions.fromRequest(restRequest, multiRequest.indicesOptions()).     multiRequest.indicesOptions(indicesOptions).     if (restRequest.hasParam("max_concurrent_searches")) {         multiRequest.maxConcurrentSearchRequests(restRequest.paramAsInt("max_concurrent_searches", 0)).     }     int preFilterShardSize = restRequest.paramAsInt("pre_filter_shard_size", SearchRequest.DEFAULT_PRE_FILTER_SHARD_SIZE).     final Integer maxConcurrentShardRequests.     if (restRequest.hasParam("max_concurrent_shard_requests")) {         // only set if we have the parameter since we auto adjust the max concurrency on the coordinator         // based on the number of nodes in the cluster         maxConcurrentShardRequests = restRequest.paramAsInt("max_concurrent_shard_requests", Integer.MIN_VALUE).     } else {         maxConcurrentShardRequests = null.     }     parseMultiLineRequest(restRequest, multiRequest.indicesOptions(), allowExplicitIndex, (searchRequest, parser) -> {         searchRequest.source(SearchSourceBuilder.fromXContent(parser, false)).         RestSearchAction.checkRestTotalHits(restRequest, searchRequest).         multiRequest.add(searchRequest).     }).     List<SearchRequest> requests = multiRequest.requests().     preFilterShardSize = Math.max(1, preFilterShardSize / (requests.size() + 1)).     for (SearchRequest request : requests) {         // preserve if it's set on the request         request.setPreFilterShardSize(Math.min(preFilterShardSize, request.getPreFilterShardSize())).         if (maxConcurrentShardRequests != null) {             request.setMaxConcurrentShardRequests(maxConcurrentShardRequests).         }     }     return multiRequest. }
true;public,static;4;15;/**  * Parses a multi-line {@link RestRequest} body, instantiating a {@link SearchRequest} for each line and applying the given consumer.  */ ;/**  * Parses a multi-line {@link RestRequest} body, instantiating a {@link SearchRequest} for each line and applying the given consumer.  */ public static void parseMultiLineRequest(RestRequest request, IndicesOptions indicesOptions, boolean allowExplicitIndex, CheckedBiConsumer<SearchRequest, XContentParser, IOException> consumer) throws IOException {     String[] indices = Strings.splitStringByCommaToArray(request.param("index")).     String[] types = Strings.splitStringByCommaToArray(request.param("type")).     String searchType = request.param("search_type").     boolean ccsMinimizeRoundtrips = request.paramAsBoolean("ccs_minimize_roundtrips", true).     String routing = request.param("routing").     final Tuple<XContentType, BytesReference> sourceTuple = request.contentOrSourceParam().     final XContent xContent = sourceTuple.v1().xContent().     final BytesReference data = sourceTuple.v2().     MultiSearchRequest.readMultiLineFormat(data, xContent, consumer, indices, indicesOptions, types, routing, searchType, ccsMinimizeRoundtrips, request.getXContentRegistry(), allowExplicitIndex). }
false;public;0;4;;@Override public boolean supportsContentStream() {     return true. }
false;protected;0;4;;@Override protected Set<String> responseParams() {     return RESPONSE_PARAMS. }
