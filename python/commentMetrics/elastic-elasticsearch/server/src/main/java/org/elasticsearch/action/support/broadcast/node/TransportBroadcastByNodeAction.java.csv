commented;modifiers;parameterAmount;loc;comment;code
false;private;5;34;;private Response newResponse(Request request, AtomicReferenceArray responses, List<NoShardAvailableActionException> unavailableShardExceptions, Map<String, List<ShardRouting>> nodes, ClusterState clusterState) {     int totalShards = 0.     int successfulShards = 0.     List<ShardOperationResult> broadcastByNodeResponses = new ArrayList<>().     List<DefaultShardOperationFailedException> exceptions = new ArrayList<>().     for (int i = 0. i < responses.length(). i++) {         if (responses.get(i) instanceof FailedNodeException) {             FailedNodeException exception = (FailedNodeException) responses.get(i).             totalShards += nodes.get(exception.nodeId()).size().             for (ShardRouting shard : nodes.get(exception.nodeId())) {                 exceptions.add(new DefaultShardOperationFailedException(shard.getIndexName(), shard.getId(), exception)).             }         } else {             NodeResponse response = (NodeResponse) responses.get(i).             broadcastByNodeResponses.addAll(response.results).             totalShards += response.getTotalShards().             successfulShards += response.getSuccessfulShards().             for (BroadcastShardOperationFailedException throwable : response.getExceptions()) {                 if (!TransportActions.isShardNotAvailableException(throwable)) {                     exceptions.add(new DefaultShardOperationFailedException(throwable.getShardId().getIndexName(), throwable.getShardId().getId(), throwable)).                 }             }         }     }     totalShards += unavailableShardExceptions.size().     int failedShards = exceptions.size().     return newResponse(request, totalShards, successfulShards, failedShards, broadcastByNodeResponses, exceptions, clusterState). }
true;protected,abstract;1;1;/**  * Deserialize a shard-level result from an input stream  *  * @param in input stream  * @return a deserialized shard-level result  */ ;/**  * Deserialize a shard-level result from an input stream  *  * @param in input stream  * @return a deserialized shard-level result  */ protected abstract ShardOperationResult readShardResult(StreamInput in) throws IOException.
true;protected,abstract;7;3;/**  * Creates a new response to the underlying request.  *  * @param request          the underlying request  * @param totalShards      the total number of shards considered for execution of the operation  * @param successfulShards the total number of shards for which execution of the operation was successful  * @param failedShards     the total number of shards for which execution of the operation failed  * @param results          the per-node aggregated shard-level results  * @param shardFailures    the exceptions corresponding to shard operation failures  * @param clusterState     the cluster state  * @return the response  */ ;/**  * Creates a new response to the underlying request.  *  * @param request          the underlying request  * @param totalShards      the total number of shards considered for execution of the operation  * @param successfulShards the total number of shards for which execution of the operation was successful  * @param failedShards     the total number of shards for which execution of the operation failed  * @param results          the per-node aggregated shard-level results  * @param shardFailures    the exceptions corresponding to shard operation failures  * @param clusterState     the cluster state  * @return the response  */ protected abstract Response newResponse(Request request, int totalShards, int successfulShards, int failedShards, List<ShardOperationResult> results, List<DefaultShardOperationFailedException> shardFailures, ClusterState clusterState).
true;protected,abstract;1;1;/**  * Deserialize a request from an input stream  *  * @param in input stream  * @return a de-serialized request  */ ;/**  * Deserialize a request from an input stream  *  * @param in input stream  * @return a de-serialized request  */ protected abstract Request readRequestFrom(StreamInput in) throws IOException.
true;protected,abstract;2;1;/**  * Executes the shard-level operation. This method is called once per shard serially on the receiving node.  *  * @param request      the node-level request  * @param shardRouting the shard on which to execute the operation  * @return the result of the shard-level operation for the shard  */ ;/**  * Executes the shard-level operation. This method is called once per shard serially on the receiving node.  *  * @param request      the node-level request  * @param shardRouting the shard on which to execute the operation  * @return the result of the shard-level operation for the shard  */ protected abstract ShardOperationResult shardOperation(Request request, ShardRouting shardRouting) throws IOException.
true;protected,abstract;3;1;/**  * Determines the shards on which this operation will be executed on. The operation is executed once per shard.  *  * @param clusterState    the cluster state  * @param request         the underlying request  * @param concreteIndices the concrete indices on which to execute the operation  * @return the shards on which to execute the operation  */ ;/**  * Determines the shards on which this operation will be executed on. The operation is executed once per shard.  *  * @param clusterState    the cluster state  * @param request         the underlying request  * @param concreteIndices the concrete indices on which to execute the operation  * @return the shards on which to execute the operation  */ protected abstract ShardsIterator shards(ClusterState clusterState, Request request, String[] concreteIndices).
true;protected,abstract;2;1;/**  * Executes a global block check before polling the cluster state.  *  * @param state   the cluster state  * @param request the underlying request  * @return a non-null exception if the operation is blocked  */ ;/**  * Executes a global block check before polling the cluster state.  *  * @param state   the cluster state  * @param request the underlying request  * @return a non-null exception if the operation is blocked  */ protected abstract ClusterBlockException checkGlobalBlock(ClusterState state, Request request).
true;protected,abstract;3;1;/**  * Executes a global request-level check before polling the cluster state.  *  * @param state           the cluster state  * @param request         the underlying request  * @param concreteIndices the concrete indices on which to execute the operation  * @return a non-null exception if the operation if blocked  */ ;/**  * Executes a global request-level check before polling the cluster state.  *  * @param state           the cluster state  * @param request         the underlying request  * @param concreteIndices the concrete indices on which to execute the operation  * @return a non-null exception if the operation if blocked  */ protected abstract ClusterBlockException checkRequestBlock(ClusterState state, Request request, String[] concreteIndices).
false;protected;3;4;;@Override protected void doExecute(Task task, Request request, ActionListener<Response> listener) {     new AsyncAction(task, request, listener).start(). }
false;public;0;16;;public void start() {     if (nodeIds.size() == 0) {         try {             onCompletion().         } catch (Exception e) {             listener.onFailure(e).         }     } else {         int nodeIndex = -1.         for (Map.Entry<String, List<ShardRouting>> entry : nodeIds.entrySet()) {             nodeIndex++.             DiscoveryNode node = nodes.get(entry.getKey()).             sendNodeRequest(node, entry.getValue(), nodeIndex).         }     } }
false;public;1;6;;@Override public NodeResponse read(StreamInput in) throws IOException {     NodeResponse nodeResponse = new NodeResponse().     nodeResponse.readFrom(in).     return nodeResponse. }
false;public;1;4;;@Override public void handleResponse(NodeResponse response) {     onNodeResponse(node, nodeIndex, response). }
false;public;1;4;;@Override public void handleException(TransportException exp) {     onNodeFailure(node, nodeIndex, exp). }
false;public;0;4;;@Override public String executor() {     return ThreadPool.Names.SAME. }
false;private;3;33;;private void sendNodeRequest(final DiscoveryNode node, List<ShardRouting> shards, final int nodeIndex) {     try {         NodeRequest nodeRequest = new NodeRequest(node.getId(), request, shards).         if (task != null) {             nodeRequest.setParentTask(clusterService.localNode().getId(), task.getId()).         }         transportService.sendRequest(node, transportNodeBroadcastAction, nodeRequest, new TransportResponseHandler<NodeResponse>() {              @Override             public NodeResponse read(StreamInput in) throws IOException {                 NodeResponse nodeResponse = new NodeResponse().                 nodeResponse.readFrom(in).                 return nodeResponse.             }              @Override             public void handleResponse(NodeResponse response) {                 onNodeResponse(node, nodeIndex, response).             }              @Override             public void handleException(TransportException exp) {                 onNodeFailure(node, nodeIndex, exp).             }              @Override             public String executor() {                 return ThreadPool.Names.SAME.             }         }).     } catch (Exception e) {         onNodeFailure(node, nodeIndex, e).     } }
false;protected;3;14;;protected void onNodeResponse(DiscoveryNode node, int nodeIndex, NodeResponse response) {     if (logger.isTraceEnabled()) {         logger.trace("received response for [{}] from node [{}]", actionName, node.getId()).     }     // but concurrency is hard, safety is important, and the small performance loss here does not matter     if (responses.compareAndSet(nodeIndex, null, response)) {         if (counter.incrementAndGet() == responses.length()) {             onCompletion().         }     } }
false;protected;3;15;;protected void onNodeFailure(DiscoveryNode node, int nodeIndex, Throwable t) {     String nodeId = node.getId().     if (logger.isDebugEnabled() && !(t instanceof NodeShouldNotConnectException)) {         logger.debug(new ParameterizedMessage("failed to execute [{}] on node [{}]", actionName, nodeId), t).     }     // but concurrency is hard, safety is important, and the small performance loss here does not matter     if (responses.compareAndSet(nodeIndex, null, new FailedNodeException(nodeId, "Failed node [" + nodeId + "]", t))) {         if (counter.incrementAndGet() == responses.length()) {             onCompletion().         }     } }
false;protected;0;16;;protected void onCompletion() {     Response response = null.     try {         response = newResponse(request, responses, unavailableShardExceptions, nodeIds, clusterState).     } catch (Exception e) {         logger.debug("failed to combine responses from nodes", e).         listener.onFailure(e).     }     if (response != null) {         try {             listener.onResponse(response).         } catch (Exception e) {             listener.onFailure(e).         }     } }
false;public;3;27;;@Override public void messageReceived(final NodeRequest request, TransportChannel channel, Task task) throws Exception {     List<ShardRouting> shards = request.getShards().     final int totalShards = shards.size().     if (logger.isTraceEnabled()) {         logger.trace("[{}] executing operation on [{}] shards", actionName, totalShards).     }     final Object[] shardResultOrExceptions = new Object[totalShards].     int shardIndex = -1.     for (final ShardRouting shardRouting : shards) {         shardIndex++.         onShardOperation(request, shardResultOrExceptions, shardIndex, shardRouting).     }     List<BroadcastShardOperationFailedException> accumulatedExceptions = new ArrayList<>().     List<ShardOperationResult> results = new ArrayList<>().     for (int i = 0. i < totalShards. i++) {         if (shardResultOrExceptions[i] instanceof BroadcastShardOperationFailedException) {             accumulatedExceptions.add((BroadcastShardOperationFailedException) shardResultOrExceptions[i]).         } else {             results.add((ShardOperationResult) shardResultOrExceptions[i]).         }     }     channel.sendResponse(new NodeResponse(request.getNodeId(), totalShards, results, accumulatedExceptions)). }
false;private;4;29;;private void onShardOperation(final NodeRequest request, final Object[] shardResults, final int shardIndex, final ShardRouting shardRouting) {     try {         if (logger.isTraceEnabled()) {             logger.trace("[{}]  executing operation for shard [{}]", actionName, shardRouting.shortSummary()).         }         ShardOperationResult result = shardOperation(request.indicesLevelRequest, shardRouting).         shardResults[shardIndex] = result.         if (logger.isTraceEnabled()) {             logger.trace("[{}]  completed operation for shard [{}]", actionName, shardRouting.shortSummary()).         }     } catch (Exception e) {         BroadcastShardOperationFailedException failure = new BroadcastShardOperationFailedException(shardRouting.shardId(), "operation " + actionName + " failed", e).         failure.setShard(shardRouting.shardId()).         shardResults[shardIndex] = failure.         if (TransportActions.isShardNotAvailableException(e)) {             if (logger.isTraceEnabled()) {                 logger.trace(new ParameterizedMessage("[{}] failed to execute operation for shard [{}]", actionName, shardRouting.shortSummary()), e).             }         } else {             if (logger.isDebugEnabled()) {                 logger.debug(new ParameterizedMessage("[{}] failed to execute operation for shard [{}]", actionName, shardRouting.shortSummary()), e).             }         }     } }
false;public;0;3;;public List<ShardRouting> getShards() {     return shards. }
false;public;0;3;;public String getNodeId() {     return nodeId. }
false;public;0;4;;@Override public String[] indices() {     return indicesLevelRequest.indices(). }
false;public;0;4;;@Override public IndicesOptions indicesOptions() {     return indicesLevelRequest.indicesOptions(). }
false;public;1;7;;@Override public void readFrom(StreamInput in) throws IOException {     super.readFrom(in).     indicesLevelRequest = readRequestFrom(in).     shards = in.readList(ShardRouting::new).     nodeId = in.readString(). }
false;public;1;7;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     indicesLevelRequest.writeTo(out).     out.writeList(shards).     out.writeString(nodeId). }
false;public;0;3;;public String getNodeId() {     return nodeId. }
false;public;0;3;;public int getTotalShards() {     return totalShards. }
false;public;0;3;;public int getSuccessfulShards() {     return results.size(). }
false;public;0;3;;public List<BroadcastShardOperationFailedException> getExceptions() {     return exceptions. }
false;public;1;12;;@Override public void readFrom(StreamInput in) throws IOException {     super.readFrom(in).     nodeId = in.readString().     totalShards = in.readVInt().     results = in.readList((stream) -> stream.readBoolean() ? readShardResult(stream) : null).     if (in.readBoolean()) {         exceptions = in.readList(BroadcastShardOperationFailedException::new).     } else {         exceptions = null.     } }
false;public;1;14;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeString(nodeId).     out.writeVInt(totalShards).     out.writeVInt(results.size()).     for (ShardOperationResult result : results) {         out.writeOptionalStreamable(result).     }     out.writeBoolean(exceptions != null).     if (exceptions != null) {         out.writeList(exceptions).     } }
false;public;1;3;;@Override public void readFrom(StreamInput in) throws IOException { }
false;public;1;3;;@Override public void writeTo(StreamOutput out) throws IOException { }
false;public,static;1;3;;public static EmptyResult readEmptyResultFrom(StreamInput in) {     return INSTANCE. }
