commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public BoundTransportAddress boundAddress() {     return this.boundAddress. }
false;public;0;8;;@Override public HttpInfo info() {     BoundTransportAddress boundTransportAddress = boundAddress().     if (boundTransportAddress == null) {         return null.     }     return new HttpInfo(boundTransportAddress, maxContentLength.getBytes()). }
false;public;0;4;;@Override public HttpStats stats() {     return new HttpStats(httpChannels.size(), totalChannelsAccepted.get()). }
false;protected;0;26;;protected void bindServer() {     // Bind and start to accept incoming connections.     InetAddress[] hostAddresses.     try {         hostAddresses = networkService.resolveBindHostAddresses(bindHosts).     } catch (IOException e) {         throw new BindHttpException("Failed to resolve host [" + Arrays.toString(bindHosts) + "]", e).     }     List<TransportAddress> boundAddresses = new ArrayList<>(hostAddresses.length).     for (InetAddress address : hostAddresses) {         boundAddresses.add(bindAddress(address)).     }     final InetAddress publishInetAddress.     try {         publishInetAddress = networkService.resolvePublishHostAddresses(publishHosts).     } catch (Exception e) {         throw new BindTransportException("Failed to resolve publish address", e).     }     final int publishPort = resolvePublishPort(settings, boundAddresses, publishInetAddress).     TransportAddress publishAddress = new TransportAddress(new InetSocketAddress(publishInetAddress, publishPort)).     this.boundAddress = new BoundTransportAddress(boundAddresses.toArray(new TransportAddress[0]), publishAddress).     logger.info("{}", boundAddress). }
false;private;1;25;;private TransportAddress bindAddress(final InetAddress hostAddress) {     final AtomicReference<Exception> lastException = new AtomicReference<>().     final AtomicReference<InetSocketAddress> boundSocket = new AtomicReference<>().     boolean success = port.iterate(portNumber -> {         try {             synchronized (httpServerChannels) {                 HttpServerChannel httpServerChannel = bind(new InetSocketAddress(hostAddress, portNumber)).                 httpServerChannels.add(httpServerChannel).                 boundSocket.set(httpServerChannel.getLocalAddress()).             }         } catch (Exception e) {             lastException.set(e).             return false.         }         return true.     }).     if (!success) {         throw new BindHttpException("Failed to bind to [" + port.getPortRangeString() + "]", lastException.get()).     }     if (logger.isDebugEnabled()) {         logger.debug("Bound http to address {{}}", NetworkAddress.format(boundSocket.get())).     }     return new TransportAddress(boundSocket.get()). }
false;protected,abstract;1;1;;protected abstract HttpServerChannel bind(InetSocketAddress hostAddress) throws Exception.
false;protected;0;23;;@Override protected void doStop() {     synchronized (httpServerChannels) {         if (httpServerChannels.isEmpty() == false) {             try {                 CloseableChannel.closeChannels(new ArrayList<>(httpServerChannels), true).             } catch (Exception e) {                 logger.warn("exception while closing channels", e).             } finally {                 httpServerChannels.clear().             }         }     }     try {         CloseableChannel.closeChannels(new ArrayList<>(httpChannels), true).     } catch (Exception e) {         logger.warn("unexpected exception while closing http channels", e).     }     httpChannels.clear().     stopInternal(). }
false;protected;0;3;;@Override protected void doClose() { }
true;protected,abstract;0;1;/**  * Called to tear down internal resources  */ ;/**  * Called to tear down internal resources  */ protected abstract void stopInternal().
true;static;3;31;// package private for tests ;// package private for tests static int resolvePublishPort(Settings settings, List<TransportAddress> boundAddresses, InetAddress publishInetAddress) {     int publishPort = SETTING_HTTP_PUBLISH_PORT.get(settings).     if (publishPort < 0) {         for (TransportAddress boundAddress : boundAddresses) {             InetAddress boundInetAddress = boundAddress.address().getAddress().             if (boundInetAddress.isAnyLocalAddress() || boundInetAddress.equals(publishInetAddress)) {                 publishPort = boundAddress.getPort().                 break.             }         }     }     // if no matching boundAddress found, check if there is a unique port for all bound addresses     if (publishPort < 0) {         final IntSet ports = new IntHashSet().         for (TransportAddress boundAddress : boundAddresses) {             ports.add(boundAddress.getPort()).         }         if (ports.size() == 1) {             publishPort = ports.iterator().next().value.         }     }     if (publishPort < 0) {         throw new BindHttpException("Failed to auto-resolve http publish port, multiple bound addresses " + boundAddresses + " with distinct ports and none of them matched the publish address (" + publishInetAddress + "). " + "Please specify a unique port by setting " + SETTING_HTTP_PORT.getKey() + " or " + SETTING_HTTP_PUBLISH_PORT.getKey()).     }     return publishPort. }
false;protected;2;24;;protected void onException(HttpChannel channel, Exception e) {     if (lifecycle.started() == false) {         // just close and ignore - we are already stopped and just need to make sure we release all resources         CloseableChannel.closeChannel(channel).         return.     }     if (NetworkExceptionHelper.isCloseConnectionException(e)) {         logger.trace(() -> new ParameterizedMessage("close connection exception caught while handling client http traffic, closing connection {}", channel), e).         CloseableChannel.closeChannel(channel).     } else if (NetworkExceptionHelper.isConnectException(e)) {         logger.trace(() -> new ParameterizedMessage("connect exception caught while handling client http traffic, closing connection {}", channel), e).         CloseableChannel.closeChannel(channel).     } else if (e instanceof CancelledKeyException) {         logger.trace(() -> new ParameterizedMessage("cancelled key exception caught while handling client http traffic, closing connection {}", channel), e).         CloseableChannel.closeChannel(channel).     } else {         logger.warn(() -> new ParameterizedMessage("caught exception while handling client http traffic, closing connection {}", channel), e).         CloseableChannel.closeChannel(channel).     } }
false;protected;2;3;;protected void onServerException(HttpServerChannel channel, Exception e) {     logger.error(new ParameterizedMessage("exception from http server channel caught on transport layer [channel={}]", channel), e). }
false;protected;1;7;;protected void serverAcceptedChannel(HttpChannel httpChannel) {     boolean addedOnThisCall = httpChannels.add(httpChannel).     assert addedOnThisCall : "Channel should only be added to http channel set once".     totalChannelsAccepted.incrementAndGet().     httpChannel.addCloseListener(ActionListener.wrap(() -> httpChannels.remove(httpChannel))).     logger.trace(() -> new ParameterizedMessage("Http channel accepted: {}", httpChannel)). }
true;public;2;3;/**  * This method handles an incoming http request.  *  * @param httpRequest that is incoming  * @param httpChannel that received the http request  */ ;/**  * This method handles an incoming http request.  *  * @param httpRequest that is incoming  * @param httpChannel that received the http request  */ public void incomingRequest(final HttpRequest httpRequest, final HttpChannel httpChannel) {     handleIncomingRequest(httpRequest, httpChannel, null). }
true;public;3;3;/**  * This method handles an incoming http request that has encountered an error.  *  * @param httpRequest that is incoming  * @param httpChannel that received the http request  * @param exception   that was encountered  */ ;/**  * This method handles an incoming http request that has encountered an error.  *  * @param httpRequest that is incoming  * @param httpChannel that received the http request  * @param exception   that was encountered  */ public void incomingRequestError(final HttpRequest httpRequest, final HttpChannel httpChannel, final Exception exception) {     handleIncomingRequest(httpRequest, httpChannel, exception). }
true;;3;10;// Visible for testing ;// Visible for testing void dispatchRequest(final RestRequest restRequest, final RestChannel channel, final Throwable badRequestCause) {     final ThreadContext threadContext = threadPool.getThreadContext().     try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {         if (badRequestCause != null) {             dispatcher.dispatchBadRequest(restRequest, channel, threadContext, badRequestCause).         } else {             dispatcher.dispatchRequest(restRequest, channel, threadContext).         }     } }
false;private;3;47;;private void handleIncomingRequest(final HttpRequest httpRequest, final HttpChannel httpChannel, final Exception exception) {     Exception badRequestCause = exception.     /*          * We want to create a REST request from the incoming request from Netty. However, creating this request could fail if there          * are incorrectly encoded parameters, or the Content-Type header is invalid. If one of these specific failures occurs, we          * attempt to create a REST request again without the input that caused the exception (e.g., we remove the Content-Type header,          * or skip decoding the parameters). Once we have a request in hand, we then dispatch the request as a bad request with the          * underlying exception that caused us to treat the request as bad.          */     final RestRequest restRequest.     {         RestRequest innerRestRequest.         try {             innerRestRequest = RestRequest.request(xContentRegistry, httpRequest, httpChannel).         } catch (final RestRequest.ContentTypeHeaderException e) {             badRequestCause = ExceptionsHelper.useOrSuppress(badRequestCause, e).             innerRestRequest = requestWithoutContentTypeHeader(httpRequest, httpChannel, badRequestCause).         } catch (final RestRequest.BadParameterException e) {             badRequestCause = ExceptionsHelper.useOrSuppress(badRequestCause, e).             innerRestRequest = RestRequest.requestWithoutParameters(xContentRegistry, httpRequest, httpChannel).         }         restRequest = innerRestRequest.     }     /*          * We now want to create a channel used to send the response on. However, creating this channel can fail if there are invalid          * parameter values for any of the filter_path, human, or pretty parameters. We detect these specific failures via an          * IllegalArgumentException from the channel constructor and then attempt to create a new channel that bypasses parsing of these          * parameter values.          */     final RestChannel channel.     {         RestChannel innerChannel.         ThreadContext threadContext = threadPool.getThreadContext().         try {             innerChannel = new DefaultRestChannel(httpChannel, httpRequest, restRequest, bigArrays, handlingSettings, threadContext).         } catch (final IllegalArgumentException e) {             badRequestCause = ExceptionsHelper.useOrSuppress(badRequestCause, e).             final RestRequest innerRequest = RestRequest.requestWithoutParameters(xContentRegistry, httpRequest, httpChannel).             innerChannel = new DefaultRestChannel(httpChannel, httpRequest, innerRequest, bigArrays, handlingSettings, threadContext).         }         channel = innerChannel.     }     dispatchRequest(restRequest, channel, badRequestCause). }
false;private;3;9;;private RestRequest requestWithoutContentTypeHeader(HttpRequest httpRequest, HttpChannel httpChannel, Exception badRequestCause) {     HttpRequest httpRequestWithoutContentType = httpRequest.removeHeader("Content-Type").     try {         return RestRequest.request(xContentRegistry, httpRequestWithoutContentType, httpChannel).     } catch (final RestRequest.BadParameterException e) {         badRequestCause.addSuppressed(e).         return RestRequest.requestWithoutParameters(xContentRegistry, httpRequestWithoutContentType, httpChannel).     } }
