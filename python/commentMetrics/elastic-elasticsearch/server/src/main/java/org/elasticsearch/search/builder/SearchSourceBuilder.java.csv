commented;modifiers;parameterAmount;loc;comment;code
false;public,static;1;3;;public static SearchSourceBuilder fromXContent(XContentParser parser) throws IOException {     return fromXContent(parser, true). }
false;public,static;2;5;;public static SearchSourceBuilder fromXContent(XContentParser parser, boolean checkTrailingTokens) throws IOException {     SearchSourceBuilder builder = new SearchSourceBuilder().     builder.parseXContent(parser, checkTrailingTokens).     return builder. }
true;public,static;0;3;/**  * A static factory method to construct a new search source.  */ ;/**  * A static factory method to construct a new search source.  */ public static SearchSourceBuilder searchSource() {     return new SearchSourceBuilder(). }
true;public,static;0;3;/**  * A static factory method to construct new search highlights.  */ ;/**  * A static factory method to construct new search highlights.  */ public static HighlightBuilder highlight() {     return new HighlightBuilder(). }
false;public;1;65;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeOptionalWriteable(aggregations).     out.writeOptionalBoolean(explain).     out.writeOptionalWriteable(fetchSourceContext).     if (out.getVersion().before(Version.V_6_4_0)) {         out.writeGenericValue(docValueFields == null ? null : docValueFields.stream().map(ff -> ff.field).collect(Collectors.toList())).     } else {         out.writeBoolean(docValueFields != null).         if (docValueFields != null) {             out.writeList(docValueFields).         }     }     out.writeOptionalWriteable(storedFieldsContext).     out.writeVInt(from).     out.writeOptionalWriteable(highlightBuilder).     out.writeList(indexBoosts).     out.writeOptionalFloat(minScore).     out.writeOptionalNamedWriteable(postQueryBuilder).     out.writeOptionalNamedWriteable(queryBuilder).     boolean hasRescoreBuilders = rescoreBuilders != null.     out.writeBoolean(hasRescoreBuilders).     if (hasRescoreBuilders) {         out.writeNamedWriteableList(rescoreBuilders).     }     boolean hasScriptFields = scriptFields != null.     out.writeBoolean(hasScriptFields).     if (hasScriptFields) {         out.writeList(scriptFields).     }     out.writeVInt(size).     boolean hasSorts = sorts != null.     out.writeBoolean(hasSorts).     if (hasSorts) {         out.writeVInt(sorts.size()).         for (SortBuilder<?> sort : sorts) {             out.writeNamedWriteable(sort).         }     }     boolean hasStats = stats != null.     out.writeBoolean(hasStats).     if (hasStats) {         out.writeStringCollection(stats).     }     out.writeOptionalWriteable(suggestBuilder).     out.writeVInt(terminateAfter).     out.writeOptionalTimeValue(timeout).     out.writeBoolean(trackScores).     out.writeOptionalBoolean(version).     if (out.getVersion().onOrAfter(Version.V_6_7_0)) {         out.writeOptionalBoolean(seqNoAndPrimaryTerm).     }     out.writeNamedWriteableList(extBuilders).     out.writeBoolean(profile).     out.writeOptionalWriteable(searchAfterBuilder).     out.writeOptionalWriteable(sliceBuilder).     out.writeOptionalWriteable(collapse).     if (out.getVersion().onOrAfter(Version.V_7_0_0)) {         out.writeOptionalInt(trackTotalHitsUpTo).     } else {         out.writeBoolean(trackTotalHitsUpTo == null ? true : trackTotalHitsUpTo > SearchContext.TRACK_TOTAL_HITS_DISABLED).     } }
true;public;1;4;/**  * Sets the search query for this request.  *  * @see org.elasticsearch.index.query.QueryBuilders  */ ;/**  * Sets the search query for this request.  *  * @see org.elasticsearch.index.query.QueryBuilders  */ public SearchSourceBuilder query(QueryBuilder query) {     this.queryBuilder = query.     return this. }
true;public;0;3;/**  * Gets the query for this request  */ ;/**  * Gets the query for this request  */ public QueryBuilder query() {     return queryBuilder. }
true;public;1;4;/**  * Sets a filter that will be executed after the query has been executed and  * only has affect on the search hits (not aggregations). This filter is  * always executed as last filtering mechanism.  */ ;/**  * Sets a filter that will be executed after the query has been executed and  * only has affect on the search hits (not aggregations). This filter is  * always executed as last filtering mechanism.  */ public SearchSourceBuilder postFilter(QueryBuilder postFilter) {     this.postQueryBuilder = postFilter.     return this. }
true;public;0;3;/**  * Gets the post filter for this request  */ ;/**  * Gets the post filter for this request  */ public QueryBuilder postFilter() {     return postQueryBuilder. }
true;public;1;7;/**  * From index to start the search from. Defaults to {@code 0}.  */ ;/**  * From index to start the search from. Defaults to {@code 0}.  */ public SearchSourceBuilder from(int from) {     if (from < 0) {         throw new IllegalArgumentException("[from] parameter cannot be negative").     }     this.from = from.     return this. }
true;public;0;3;/**  * Gets the from index to start the search from.  */ ;/**  * Gets the from index to start the search from.  */ public int from() {     return from. }
true;public;1;7;/**  * The number of search hits to return. Defaults to {@code 10}.  */ ;/**  * The number of search hits to return. Defaults to {@code 10}.  */ public SearchSourceBuilder size(int size) {     if (size < 0) {         throw new IllegalArgumentException("[size] parameter cannot be negative, found [" + size + "]").     }     this.size = size.     return this. }
true;public;0;3;/**  * Gets the number of search hits to return.  */ ;/**  * Gets the number of search hits to return.  */ public int size() {     return size. }
true;public;1;4;/**  * Sets the minimum score below which docs will be filtered out.  */ ;/**  * Sets the minimum score below which docs will be filtered out.  */ public SearchSourceBuilder minScore(float minScore) {     this.minScore = minScore.     return this. }
true;public;0;3;/**  * Gets the minimum score below which docs will be filtered out.  */ ;/**  * Gets the minimum score below which docs will be filtered out.  */ public Float minScore() {     return minScore. }
true;public;1;4;/**  * Should each {@link org.elasticsearch.search.SearchHit} be returned with  * an explanation of the hit (ranking).  */ ;/**  * Should each {@link org.elasticsearch.search.SearchHit} be returned with  * an explanation of the hit (ranking).  */ public SearchSourceBuilder explain(Boolean explain) {     this.explain = explain.     return this. }
true;public;0;3;/**  * Indicates whether each search hit will be returned with an explanation of  * the hit (ranking)  */ ;/**  * Indicates whether each search hit will be returned with an explanation of  * the hit (ranking)  */ public Boolean explain() {     return explain. }
true;public;1;4;/**  * Should each {@link org.elasticsearch.search.SearchHit} be returned with a  * version associated with it.  */ ;/**  * Should each {@link org.elasticsearch.search.SearchHit} be returned with a  * version associated with it.  */ public SearchSourceBuilder version(Boolean version) {     this.version = version.     return this. }
true;public;0;3;/**  * Indicates whether the document's version will be included in the search  * hits.  */ ;/**  * Indicates whether the document's version will be included in the search  * hits.  */ public Boolean version() {     return version. }
true;public;1;4;/**  * Should each {@link org.elasticsearch.search.SearchHit} be returned with the  * sequence number and primary term of the last modification of the document.  */ ;/**  * Should each {@link org.elasticsearch.search.SearchHit} be returned with the  * sequence number and primary term of the last modification of the document.  */ public SearchSourceBuilder seqNoAndPrimaryTerm(Boolean seqNoAndPrimaryTerm) {     this.seqNoAndPrimaryTerm = seqNoAndPrimaryTerm.     return this. }
true;public;0;3;/**  * Indicates whether {@link org.elasticsearch.search.SearchHit}s should be returned with the  * sequence number and primary term of the last modification of the document.  */ ;/**  * Indicates whether {@link org.elasticsearch.search.SearchHit}s should be returned with the  * sequence number and primary term of the last modification of the document.  */ public Boolean seqNoAndPrimaryTerm() {     return seqNoAndPrimaryTerm. }
true;public;1;4;/**  * An optional timeout to control how long search is allowed to take.  */ ;/**  * An optional timeout to control how long search is allowed to take.  */ public SearchSourceBuilder timeout(TimeValue timeout) {     this.timeout = timeout.     return this. }
true;public;0;3;/**  * Gets the timeout to control how long search is allowed to take.  */ ;/**  * Gets the timeout to control how long search is allowed to take.  */ public TimeValue timeout() {     return timeout. }
true;public;1;7;/**  * An optional terminate_after to terminate the search after collecting  * <code>terminateAfter</code> documents  */ ;/**  * An optional terminate_after to terminate the search after collecting  * <code>terminateAfter</code> documents  */ public SearchSourceBuilder terminateAfter(int terminateAfter) {     if (terminateAfter < 0) {         throw new IllegalArgumentException("terminateAfter must be > 0").     }     this.terminateAfter = terminateAfter.     return this. }
true;public;0;3;/**  * Gets the number of documents to terminate after collecting.  */ ;/**  * Gets the number of documents to terminate after collecting.  */ public int terminateAfter() {     return terminateAfter. }
true;public;2;6;/**  * Adds a sort against the given field name and the sort ordering.  *  * @param name  *            The name of the field  * @param order  *            The sort ordering  */ ;/**  * Adds a sort against the given field name and the sort ordering.  *  * @param name  *            The name of the field  * @param order  *            The sort ordering  */ public SearchSourceBuilder sort(String name, SortOrder order) {     if (name.equals(ScoreSortBuilder.NAME)) {         return sort(SortBuilders.scoreSort().order(order)).     }     return sort(SortBuilders.fieldSort(name).order(order)). }
true;public;1;6;/**  * Add a sort against the given field name.  *  * @param name  *            The name of the field to sort by  */ ;/**  * Add a sort against the given field name.  *  * @param name  *            The name of the field to sort by  */ public SearchSourceBuilder sort(String name) {     if (name.equals(ScoreSortBuilder.NAME)) {         return sort(SortBuilders.scoreSort()).     }     return sort(SortBuilders.fieldSort(name)). }
true;public;1;7;/**  * Adds a sort builder.  */ ;/**  * Adds a sort builder.  */ public SearchSourceBuilder sort(SortBuilder<?> sort) {     if (sorts == null) {         sorts = new ArrayList<>().     }     sorts.add(sort).     return this. }
true;public;0;3;/**  * Gets the bytes representing the sort builders for this request.  */ ;/**  * Gets the bytes representing the sort builders for this request.  */ public List<SortBuilder<?>> sorts() {     return sorts. }
true;public;1;4;/**  * Applies when sorting, and controls if scores will be tracked as well.  * Defaults to {@code false}.  */ ;/**  * Applies when sorting, and controls if scores will be tracked as well.  * Defaults to {@code false}.  */ public SearchSourceBuilder trackScores(boolean trackScores) {     this.trackScores = trackScores.     return this. }
true;public;0;3;/**  * Indicates whether scores will be tracked for this request.  */ ;/**  * Indicates whether scores will be tracked for this request.  */ public boolean trackScores() {     return trackScores. }
true;public;1;4;/**  * Indicates if the total hit count for the query should be tracked.  */ ;/**  * Indicates if the total hit count for the query should be tracked.  */ public SearchSourceBuilder trackTotalHits(boolean trackTotalHits) {     this.trackTotalHitsUpTo = trackTotalHits ? TRACK_TOTAL_HITS_ACCURATE : TRACK_TOTAL_HITS_DISABLED.     return this. }
true;public;0;4;/**  * Returns the total hit count that should be tracked or null if the value is unset.  * Defaults to null.  */ ;/**  * Returns the total hit count that should be tracked or null if the value is unset.  * Defaults to null.  */ @Nullable public Integer trackTotalHitsUpTo() {     return trackTotalHitsUpTo. }
false;public;1;8;;public SearchSourceBuilder trackTotalHitsUpTo(int trackTotalHitsUpTo) {     if (trackTotalHitsUpTo < TRACK_TOTAL_HITS_DISABLED) {         throw new IllegalArgumentException("[track_total_hits] parameter must be positive or equals to -1, " + "got " + trackTotalHitsUpTo).     }     this.trackTotalHitsUpTo = trackTotalHitsUpTo.     return this. }
true;public;0;6;/**  * The sort values that indicates which docs this request should "search after".  * The sort values of the search_after must be equal to the number of sort fields in the query and they should be  * of the same type (or parsable as such).  * Defaults to {@code null}.  */ ;/**  * The sort values that indicates which docs this request should "search after".  * The sort values of the search_after must be equal to the number of sort fields in the query and they should be  * of the same type (or parsable as such).  * Defaults to {@code null}.  */ public Object[] searchAfter() {     if (searchAfterBuilder == null) {         return null.     }     return searchAfterBuilder.getSortValues(). }
true;public;1;4;/**  * Set the sort values that indicates which docs this request should "search after".  */ ;/**  * Set the sort values that indicates which docs this request should "search after".  */ public SearchSourceBuilder searchAfter(Object[] values) {     this.searchAfterBuilder = new SearchAfterBuilder().setSortValues(values).     return this. }
true;public;1;4;/**  * Sets a filter that will restrict the search hits, the top hits and the aggregations to a slice of the results  * of the main query.  */ ;/**  * Sets a filter that will restrict the search hits, the top hits and the aggregations to a slice of the results  * of the main query.  */ public SearchSourceBuilder slice(SliceBuilder builder) {     this.sliceBuilder = builder.     return this. }
true;public;0;3;/**  * Gets the slice used to filter the search hits, the top hits and the aggregations.  */ ;/**  * Gets the slice used to filter the search hits, the top hits and the aggregations.  */ public SliceBuilder slice() {     return sliceBuilder. }
false;public;0;3;;public CollapseBuilder collapse() {     return collapse. }
false;public;1;4;;public SearchSourceBuilder collapse(CollapseBuilder collapse) {     this.collapse = collapse.     return this. }
true;public;1;7;/**  * Add an aggregation to perform as part of the search.  */ ;/**  * Add an aggregation to perform as part of the search.  */ public SearchSourceBuilder aggregation(AggregationBuilder aggregation) {     if (aggregations == null) {         aggregations = AggregatorFactories.builder().     }     aggregations.addAggregator(aggregation).     return this. }
true;public;1;7;/**  * Add an aggregation to perform as part of the search.  */ ;/**  * Add an aggregation to perform as part of the search.  */ public SearchSourceBuilder aggregation(PipelineAggregationBuilder aggregation) {     if (aggregations == null) {         aggregations = AggregatorFactories.builder().     }     aggregations.addPipelineAggregator(aggregation).     return this. }
true;public;0;3;/**  * Gets the bytes representing the aggregation builders for this request.  */ ;/**  * Gets the bytes representing the aggregation builders for this request.  */ public AggregatorFactories.Builder aggregations() {     return aggregations. }
true;public;1;4;/**  * Adds highlight to perform as part of the search.  */ ;/**  * Adds highlight to perform as part of the search.  */ public SearchSourceBuilder highlighter(HighlightBuilder highlightBuilder) {     this.highlightBuilder = highlightBuilder.     return this. }
true;public;0;3;/**  * Gets the highlighter builder for this request.  */ ;/**  * Gets the highlighter builder for this request.  */ public HighlightBuilder highlighter() {     return highlightBuilder. }
false;public;1;4;;public SearchSourceBuilder suggest(SuggestBuilder suggestBuilder) {     this.suggestBuilder = suggestBuilder.     return this. }
true;public;0;3;/**  * Gets the suggester builder for this request.  */ ;/**  * Gets the suggester builder for this request.  */ public SuggestBuilder suggest() {     return suggestBuilder. }
false;public;1;7;;public SearchSourceBuilder addRescorer(RescorerBuilder<?> rescoreBuilder) {     if (rescoreBuilders == null) {         rescoreBuilders = new ArrayList<>().     }     rescoreBuilders.add(rescoreBuilder).     return this. }
false;public;0;4;;public SearchSourceBuilder clearRescorers() {     rescoreBuilders = null.     return this. }
true;public;1;4;/**  * Should the query be profiled. Defaults to {@code false}  */ ;/**  * Should the query be profiled. Defaults to {@code false}  */ public SearchSourceBuilder profile(boolean profile) {     this.profile = profile.     return this. }
true;public;0;3;/**  * Return whether to profile query execution, or {@code null} if  * unspecified.  */ ;/**  * Return whether to profile query execution, or {@code null} if  * unspecified.  */ public boolean profile() {     return profile. }
true;public;0;3;/**  * Gets the bytes representing the rescore builders for this request.  */ ;/**  * Gets the bytes representing the rescore builders for this request.  */ public List<RescorerBuilder> rescores() {     return rescoreBuilders. }
true;public;1;6;/**  * Indicates whether the response should contain the stored _source for  * every hit  */ ;/**  * Indicates whether the response should contain the stored _source for  * every hit  */ public SearchSourceBuilder fetchSource(boolean fetch) {     FetchSourceContext fetchSourceContext = this.fetchSourceContext != null ? this.fetchSourceContext : FetchSourceContext.FETCH_SOURCE.     this.fetchSourceContext = new FetchSourceContext(fetch, fetchSourceContext.includes(), fetchSourceContext.excludes()).     return this. }
true;public;2;4;/**  * Indicate that _source should be returned with every hit, with an  * "include" and/or "exclude" set which can include simple wildcard  * elements.  *  * @param include  *            An optional include (optionally wildcarded) pattern to filter  *            the returned _source  * @param exclude  *            An optional exclude (optionally wildcarded) pattern to filter  *            the returned _source  */ ;/**  * Indicate that _source should be returned with every hit, with an  * "include" and/or "exclude" set which can include simple wildcard  * elements.  *  * @param include  *            An optional include (optionally wildcarded) pattern to filter  *            the returned _source  * @param exclude  *            An optional exclude (optionally wildcarded) pattern to filter  *            the returned _source  */ public SearchSourceBuilder fetchSource(@Nullable String include, @Nullable String exclude) {     return fetchSource(include == null ? Strings.EMPTY_ARRAY : new String[] { include }, exclude == null ? Strings.EMPTY_ARRAY : new String[] { exclude }). }
true;public;2;6;/**  * Indicate that _source should be returned with every hit, with an  * "include" and/or "exclude" set which can include simple wildcard  * elements.  *  * @param includes  *            An optional list of include (optionally wildcarded) pattern to  *            filter the returned _source  * @param excludes  *            An optional list of exclude (optionally wildcarded) pattern to  *            filter the returned _source  */ ;/**  * Indicate that _source should be returned with every hit, with an  * "include" and/or "exclude" set which can include simple wildcard  * elements.  *  * @param includes  *            An optional list of include (optionally wildcarded) pattern to  *            filter the returned _source  * @param excludes  *            An optional list of exclude (optionally wildcarded) pattern to  *            filter the returned _source  */ public SearchSourceBuilder fetchSource(@Nullable String[] includes, @Nullable String[] excludes) {     FetchSourceContext fetchSourceContext = this.fetchSourceContext != null ? this.fetchSourceContext : FetchSourceContext.FETCH_SOURCE.     this.fetchSourceContext = new FetchSourceContext(fetchSourceContext.fetchSource(), includes, excludes).     return this. }
true;public;1;4;/**  * Indicate how the _source should be fetched.  */ ;/**  * Indicate how the _source should be fetched.  */ public SearchSourceBuilder fetchSource(@Nullable FetchSourceContext fetchSourceContext) {     this.fetchSourceContext = fetchSourceContext.     return this. }
true;public;0;3;/**  * Gets the {@link FetchSourceContext} which defines how the _source should  * be fetched.  */ ;/**  * Gets the {@link FetchSourceContext} which defines how the _source should  * be fetched.  */ public FetchSourceContext fetchSource() {     return fetchSourceContext. }
true;public;1;3;/**  * Adds a stored field to load and return as part of the  * search request. If none are specified, the source of the document will be  * return.  */ ;/**  * Adds a stored field to load and return as part of the  * search request. If none are specified, the source of the document will be  * return.  */ public SearchSourceBuilder storedField(String name) {     return storedFields(Collections.singletonList(name)). }
true;public;1;8;/**  * Sets the stored fields to load and return as part of the search request. If none  * are specified, the source of the document will be returned.  */ ;/**  * Sets the stored fields to load and return as part of the search request. If none  * are specified, the source of the document will be returned.  */ public SearchSourceBuilder storedFields(List<String> fields) {     if (storedFieldsContext == null) {         storedFieldsContext = StoredFieldsContext.fromList(fields).     } else {         storedFieldsContext.addFieldNames(fields).     }     return this. }
true;public;1;4;/**  * Indicates how the stored fields should be fetched.  */ ;/**  * Indicates how the stored fields should be fetched.  */ public SearchSourceBuilder storedFields(StoredFieldsContext context) {     storedFieldsContext = context.     return this. }
true;public;0;3;/**  * Gets the stored fields context.  */ ;/**  * Gets the stored fields context.  */ public StoredFieldsContext storedFields() {     return storedFieldsContext. }
true;public;0;3;/**  * Gets the docvalue fields.  */ ;/**  * Gets the docvalue fields.  */ public List<FieldAndFormat> docValueFields() {     return docValueFields. }
true;public;2;7;/**  * Adds a field to load from the doc values and return as part of the  * search request.  */ ;/**  * Adds a field to load from the doc values and return as part of the  * search request.  */ public SearchSourceBuilder docValueField(String name, @Nullable String format) {     if (docValueFields == null) {         docValueFields = new ArrayList<>().     }     docValueFields.add(new FieldAndFormat(name, format)).     return this. }
true;public;1;3;/**  * Adds a field to load from the doc values and return as part of the  * search request.  */ ;/**  * Adds a field to load from the doc values and return as part of the  * search request.  */ public SearchSourceBuilder docValueField(String name) {     return docValueField(name, null). }
true;public;2;4;/**  * Adds a script field under the given name with the provided script.  *  * @param name  *            The name of the field  * @param script  *            The script  */ ;/**  * Adds a script field under the given name with the provided script.  *  * @param name  *            The name of the field  * @param script  *            The script  */ public SearchSourceBuilder scriptField(String name, Script script) {     scriptField(name, script, false).     return this. }
true;public;3;7;/**  * Adds a script field under the given name with the provided script.  *  * @param name  *            The name of the field  * @param script  *            The script  */ ;/**  * Adds a script field under the given name with the provided script.  *  * @param name  *            The name of the field  * @param script  *            The script  */ public SearchSourceBuilder scriptField(String name, Script script, boolean ignoreFailure) {     if (scriptFields == null) {         scriptFields = new ArrayList<>().     }     scriptFields.add(new ScriptField(name, script, ignoreFailure)).     return this. }
true;public;0;3;/**  * Gets the script fields.  */ ;/**  * Gets the script fields.  */ public List<ScriptField> scriptFields() {     return scriptFields. }
true;public;2;5;/**  * Sets the boost a specific index or alias will receive when the query is executed  * against it.  *  * @param index  *            The index or alias to apply the boost against  * @param indexBoost  *            The boost to apply to the index  */ ;/**  * Sets the boost a specific index or alias will receive when the query is executed  * against it.  *  * @param index  *            The index or alias to apply the boost against  * @param indexBoost  *            The boost to apply to the index  */ public SearchSourceBuilder indexBoost(String index, float indexBoost) {     Objects.requireNonNull(index, "index must not be null").     this.indexBoosts.add(new IndexBoost(index, indexBoost)).     return this. }
true;public;0;3;/**  * Gets the boost a specific indices or aliases will receive when the query is  * executed against them.  */ ;/**  * Gets the boost a specific indices or aliases will receive when the query is  * executed against them.  */ public List<IndexBoost> indexBoosts() {     return indexBoosts. }
true;public;1;4;/**  * The stats groups this request will be aggregated under.  */ ;/**  * The stats groups this request will be aggregated under.  */ public SearchSourceBuilder stats(List<String> statsGroups) {     this.stats = statsGroups.     return this. }
true;public;0;3;/**  * The stats groups this request will be aggregated under.  */ ;/**  * The stats groups this request will be aggregated under.  */ public List<String> stats() {     return stats. }
false;public;1;4;;public SearchSourceBuilder ext(List<SearchExtBuilder> searchExtBuilders) {     this.extBuilders = Objects.requireNonNull(searchExtBuilders, "searchExtBuilders must not be null").     return this. }
false;public;0;3;;public List<SearchExtBuilder> ext() {     return extBuilders. }
true;public;0;4;/**  * @return true if the source only has suggest  */ ;/**  * @return true if the source only has suggest  */ public boolean isSuggestOnly() {     return suggestBuilder != null && queryBuilder == null && aggregations == null. }
true;public;1;32;/**  * Rewrites this search source builder into its primitive form. e.g. by  * rewriting the QueryBuilder. If the builder did not change the identity  * reference must be returned otherwise the builder will be rewritten  * infinitely.  */ ;/**  * Rewrites this search source builder into its primitive form. e.g. by  * rewriting the QueryBuilder. If the builder did not change the identity  * reference must be returned otherwise the builder will be rewritten  * infinitely.  */ @Override public SearchSourceBuilder rewrite(QueryRewriteContext context) throws IOException {     assert (this.equals(shallowCopy(queryBuilder, postQueryBuilder, aggregations, sliceBuilder, sorts, rescoreBuilders, highlightBuilder))).     QueryBuilder queryBuilder = null.     if (this.queryBuilder != null) {         queryBuilder = this.queryBuilder.rewrite(context).     }     QueryBuilder postQueryBuilder = null.     if (this.postQueryBuilder != null) {         postQueryBuilder = this.postQueryBuilder.rewrite(context).     }     AggregatorFactories.Builder aggregations = null.     if (this.aggregations != null) {         aggregations = this.aggregations.rewrite(context).     }     List<SortBuilder<?>> sorts = Rewriteable.rewrite(this.sorts, context).     List<RescorerBuilder> rescoreBuilders = Rewriteable.rewrite(this.rescoreBuilders, context).     HighlightBuilder highlightBuilder = this.highlightBuilder.     if (highlightBuilder != null) {         highlightBuilder = this.highlightBuilder.rewrite(context).     }     boolean rewritten = queryBuilder != this.queryBuilder || postQueryBuilder != this.postQueryBuilder || aggregations != this.aggregations || rescoreBuilders != this.rescoreBuilders || sorts != this.sorts || this.highlightBuilder != highlightBuilder.     if (rewritten) {         return shallowCopy(queryBuilder, postQueryBuilder, aggregations, this.sliceBuilder, sorts, rescoreBuilders, highlightBuilder).     }     return this. }
true;public;1;3;/**  * Create a shallow copy of this builder with a new slice configuration.  */ ;/**  * Create a shallow copy of this builder with a new slice configuration.  */ public SearchSourceBuilder copyWithNewSlice(SliceBuilder slice) {     return shallowCopy(queryBuilder, postQueryBuilder, aggregations, slice, sorts, rescoreBuilders, highlightBuilder). }
true;private;7;34;/**  * Create a shallow copy of this source replaced {@link #queryBuilder}, {@link #postQueryBuilder}, and {@link #sliceBuilder}. Used by  * {@link #rewrite(QueryRewriteContext)} and {@link #copyWithNewSlice(SliceBuilder)}.  */ ;/**  * Create a shallow copy of this source replaced {@link #queryBuilder}, {@link #postQueryBuilder}, and {@link #sliceBuilder}. Used by  * {@link #rewrite(QueryRewriteContext)} and {@link #copyWithNewSlice(SliceBuilder)}.  */ private SearchSourceBuilder shallowCopy(QueryBuilder queryBuilder, QueryBuilder postQueryBuilder, AggregatorFactories.Builder aggregations, SliceBuilder slice, List<SortBuilder<?>> sorts, List<RescorerBuilder> rescoreBuilders, HighlightBuilder highlightBuilder) {     SearchSourceBuilder rewrittenBuilder = new SearchSourceBuilder().     rewrittenBuilder.aggregations = aggregations.     rewrittenBuilder.explain = explain.     rewrittenBuilder.extBuilders = extBuilders.     rewrittenBuilder.fetchSourceContext = fetchSourceContext.     rewrittenBuilder.docValueFields = docValueFields.     rewrittenBuilder.storedFieldsContext = storedFieldsContext.     rewrittenBuilder.from = from.     rewrittenBuilder.highlightBuilder = highlightBuilder.     rewrittenBuilder.indexBoosts = indexBoosts.     rewrittenBuilder.minScore = minScore.     rewrittenBuilder.postQueryBuilder = postQueryBuilder.     rewrittenBuilder.profile = profile.     rewrittenBuilder.queryBuilder = queryBuilder.     rewrittenBuilder.rescoreBuilders = rescoreBuilders.     rewrittenBuilder.scriptFields = scriptFields.     rewrittenBuilder.searchAfterBuilder = searchAfterBuilder.     rewrittenBuilder.sliceBuilder = slice.     rewrittenBuilder.size = size.     rewrittenBuilder.sorts = sorts.     rewrittenBuilder.stats = stats.     rewrittenBuilder.suggestBuilder = suggestBuilder.     rewrittenBuilder.terminateAfter = terminateAfter.     rewrittenBuilder.timeout = timeout.     rewrittenBuilder.trackScores = trackScores.     rewrittenBuilder.trackTotalHitsUpTo = trackTotalHitsUpTo.     rewrittenBuilder.version = version.     rewrittenBuilder.seqNoAndPrimaryTerm = seqNoAndPrimaryTerm.     rewrittenBuilder.collapse = collapse.     return rewrittenBuilder. }
false;public;1;3;;public void parseXContent(XContentParser parser) throws IOException {     parseXContent(parser, true). }
true;public;2;159;/**  * Parse some xContent into this SearchSourceBuilder, overwriting any values specified in the xContent. Use this if you need to set up  * different defaults than a regular SearchSourceBuilder would have and use {@link #fromXContent(XContentParser, boolean)} if you have  * normal defaults.  *  * @param parser The xContent parser.  * @param checkTrailingTokens If true throws a parsing exception when extra tokens are found after the main object.  */ ;/**  * Parse some xContent into this SearchSourceBuilder, overwriting any values specified in the xContent. Use this if you need to set up  * different defaults than a regular SearchSourceBuilder would have and use {@link #fromXContent(XContentParser, boolean)} if you have  * normal defaults.  *  * @param parser The xContent parser.  * @param checkTrailingTokens If true throws a parsing exception when extra tokens are found after the main object.  */ public void parseXContent(XContentParser parser, boolean checkTrailingTokens) throws IOException {     XContentParser.Token token = parser.currentToken().     String currentFieldName = null.     if (token != XContentParser.Token.START_OBJECT && (token = parser.nextToken()) != XContentParser.Token.START_OBJECT) {         throw new ParsingException(parser.getTokenLocation(), "Expected [" + XContentParser.Token.START_OBJECT + "] but found [" + token + "]", parser.getTokenLocation()).     }     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (token.isValue()) {             if (FROM_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 from = parser.intValue().             } else if (SIZE_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 size = parser.intValue().             } else if (TIMEOUT_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 timeout = TimeValue.parseTimeValue(parser.text(), null, TIMEOUT_FIELD.getPreferredName()).             } else if (TERMINATE_AFTER_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 terminateAfter = parser.intValue().             } else if (MIN_SCORE_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 minScore = parser.floatValue().             } else if (VERSION_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 version = parser.booleanValue().             } else if (SEQ_NO_PRIMARY_TERM_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 seqNoAndPrimaryTerm = parser.booleanValue().             } else if (EXPLAIN_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 explain = parser.booleanValue().             } else if (TRACK_SCORES_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 trackScores = parser.booleanValue().             } else if (TRACK_TOTAL_HITS_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 if (token == XContentParser.Token.VALUE_BOOLEAN || (token == XContentParser.Token.VALUE_STRING && Booleans.isBoolean(parser.text()))) {                     trackTotalHitsUpTo = parser.booleanValue() ? TRACK_TOTAL_HITS_ACCURATE : TRACK_TOTAL_HITS_DISABLED.                 } else {                     trackTotalHitsUpTo = parser.intValue().                 }             } else if (_SOURCE_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 fetchSourceContext = FetchSourceContext.fromXContent(parser).             } else if (STORED_FIELDS_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 storedFieldsContext = StoredFieldsContext.fromXContent(SearchSourceBuilder.STORED_FIELDS_FIELD.getPreferredName(), parser).             } else if (SORT_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 sort(parser.text()).             } else if (PROFILE_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 profile = parser.booleanValue().             } else {                 throw new ParsingException(parser.getTokenLocation(), "Unknown key for a " + token + " in [" + currentFieldName + "].", parser.getTokenLocation()).             }         } else if (token == XContentParser.Token.START_OBJECT) {             if (QUERY_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 queryBuilder = parseInnerQueryBuilder(parser).             } else if (POST_FILTER_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 postQueryBuilder = parseInnerQueryBuilder(parser).             } else if (_SOURCE_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 fetchSourceContext = FetchSourceContext.fromXContent(parser).             } else if (SCRIPT_FIELDS_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 scriptFields = new ArrayList<>().                 while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {                     scriptFields.add(new ScriptField(parser)).                 }             } else if (INDICES_BOOST_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 deprecationLogger.deprecated("Object format in indices_boost is deprecated, please use array format instead").                 while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {                     if (token == XContentParser.Token.FIELD_NAME) {                         currentFieldName = parser.currentName().                     } else if (token.isValue()) {                         indexBoosts.add(new IndexBoost(currentFieldName, parser.floatValue())).                     } else {                         throw new ParsingException(parser.getTokenLocation(), "Unknown key for a " + token + " in [" + currentFieldName + "].", parser.getTokenLocation()).                     }                 }             } else if (AGGREGATIONS_FIELD.match(currentFieldName, parser.getDeprecationHandler()) || AGGS_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 aggregations = AggregatorFactories.parseAggregators(parser).             } else if (HIGHLIGHT_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 highlightBuilder = HighlightBuilder.fromXContent(parser).             } else if (SUGGEST_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 suggestBuilder = SuggestBuilder.fromXContent(parser).             } else if (SORT_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 sorts = new ArrayList<>(SortBuilder.fromXContent(parser)).             } else if (RESCORE_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 rescoreBuilders = new ArrayList<>().                 rescoreBuilders.add(RescorerBuilder.parseFromXContent(parser)).             } else if (EXT_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 extBuilders = new ArrayList<>().                 String extSectionName = null.                 while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {                     if (token == XContentParser.Token.FIELD_NAME) {                         extSectionName = parser.currentName().                     } else {                         SearchExtBuilder searchExtBuilder = parser.namedObject(SearchExtBuilder.class, extSectionName, null).                         if (searchExtBuilder.getWriteableName().equals(extSectionName) == false) {                             throw new IllegalStateException("The parsed [" + searchExtBuilder.getClass().getName() + "] object has a " + "different writeable name compared to the name of the section that it was parsed from: found [" + searchExtBuilder.getWriteableName() + "] expected [" + extSectionName + "]").                         }                         extBuilders.add(searchExtBuilder).                     }                 }             } else if (SLICE.match(currentFieldName, parser.getDeprecationHandler())) {                 sliceBuilder = SliceBuilder.fromXContent(parser).             } else if (COLLAPSE.match(currentFieldName, parser.getDeprecationHandler())) {                 collapse = CollapseBuilder.fromXContent(parser).             } else {                 throw new ParsingException(parser.getTokenLocation(), "Unknown key for a " + token + " in [" + currentFieldName + "].", parser.getTokenLocation()).             }         } else if (token == XContentParser.Token.START_ARRAY) {             if (STORED_FIELDS_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 storedFieldsContext = StoredFieldsContext.fromXContent(STORED_FIELDS_FIELD.getPreferredName(), parser).             } else if (DOCVALUE_FIELDS_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 docValueFields = new ArrayList<>().                 while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {                     docValueFields.add(FieldAndFormat.fromXContent(parser)).                 }             } else if (INDICES_BOOST_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {                     indexBoosts.add(new IndexBoost(parser)).                 }             } else if (SORT_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 sorts = new ArrayList<>(SortBuilder.fromXContent(parser)).             } else if (RESCORE_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 rescoreBuilders = new ArrayList<>().                 while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {                     rescoreBuilders.add(RescorerBuilder.parseFromXContent(parser)).                 }             } else if (STATS_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 stats = new ArrayList<>().                 while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {                     if (token == XContentParser.Token.VALUE_STRING) {                         stats.add(parser.text()).                     } else {                         throw new ParsingException(parser.getTokenLocation(), "Expected [" + XContentParser.Token.VALUE_STRING + "] in [" + currentFieldName + "] but found [" + token + "]", parser.getTokenLocation()).                     }                 }             } else if (_SOURCE_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 fetchSourceContext = FetchSourceContext.fromXContent(parser).             } else if (SEARCH_AFTER.match(currentFieldName, parser.getDeprecationHandler())) {                 searchAfterBuilder = SearchAfterBuilder.fromXContent(parser).             } else {                 throw new ParsingException(parser.getTokenLocation(), "Unknown key for a " + token + " in [" + currentFieldName + "].", parser.getTokenLocation()).             }         } else {             throw new ParsingException(parser.getTokenLocation(), "Unknown key for a " + token + " in [" + currentFieldName + "].", parser.getTokenLocation()).         }     }     if (checkTrailingTokens) {         token = parser.nextToken().         if (token != null) {             throw new ParsingException(parser.getTokenLocation(), "Unexpected token [" + token + "] found after the main object.").         }     } }
false;public;2;144;;public XContentBuilder innerToXContent(XContentBuilder builder, Params params) throws IOException {     if (from != -1) {         builder.field(FROM_FIELD.getPreferredName(), from).     }     if (size != -1) {         builder.field(SIZE_FIELD.getPreferredName(), size).     }     if (timeout != null && !timeout.equals(TimeValue.MINUS_ONE)) {         builder.field(TIMEOUT_FIELD.getPreferredName(), timeout.getStringRep()).     }     if (terminateAfter != SearchContext.DEFAULT_TERMINATE_AFTER) {         builder.field(TERMINATE_AFTER_FIELD.getPreferredName(), terminateAfter).     }     if (queryBuilder != null) {         builder.field(QUERY_FIELD.getPreferredName(), queryBuilder).     }     if (postQueryBuilder != null) {         builder.field(POST_FILTER_FIELD.getPreferredName(), postQueryBuilder).     }     if (minScore != null) {         builder.field(MIN_SCORE_FIELD.getPreferredName(), minScore).     }     if (version != null) {         builder.field(VERSION_FIELD.getPreferredName(), version).     }     if (seqNoAndPrimaryTerm != null) {         builder.field(SEQ_NO_PRIMARY_TERM_FIELD.getPreferredName(), seqNoAndPrimaryTerm).     }     if (explain != null) {         builder.field(EXPLAIN_FIELD.getPreferredName(), explain).     }     if (profile) {         builder.field("profile", true).     }     if (fetchSourceContext != null) {         builder.field(_SOURCE_FIELD.getPreferredName(), fetchSourceContext).     }     if (storedFieldsContext != null) {         storedFieldsContext.toXContent(STORED_FIELDS_FIELD.getPreferredName(), builder).     }     if (docValueFields != null) {         builder.startArray(DOCVALUE_FIELDS_FIELD.getPreferredName()).         for (FieldAndFormat docValueField : docValueFields) {             builder.startObject().field("field", docValueField.field).             if (docValueField.format != null) {                 builder.field("format", docValueField.format).             }             builder.endObject().         }         builder.endArray().     }     if (scriptFields != null) {         builder.startObject(SCRIPT_FIELDS_FIELD.getPreferredName()).         for (ScriptField scriptField : scriptFields) {             scriptField.toXContent(builder, params).         }         builder.endObject().     }     if (sorts != null) {         builder.startArray(SORT_FIELD.getPreferredName()).         for (SortBuilder<?> sort : sorts) {             sort.toXContent(builder, params).         }         builder.endArray().     }     if (trackScores) {         builder.field(TRACK_SCORES_FIELD.getPreferredName(), true).     }     if (trackTotalHitsUpTo != null) {         builder.field(TRACK_TOTAL_HITS_FIELD.getPreferredName(), trackTotalHitsUpTo).     }     if (searchAfterBuilder != null) {         builder.array(SEARCH_AFTER.getPreferredName(), searchAfterBuilder.getSortValues()).     }     if (sliceBuilder != null) {         builder.field(SLICE.getPreferredName(), sliceBuilder).     }     if (!indexBoosts.isEmpty()) {         builder.startArray(INDICES_BOOST_FIELD.getPreferredName()).         for (IndexBoost ib : indexBoosts) {             builder.startObject().             builder.field(ib.index, ib.boost).             builder.endObject().         }         builder.endArray().     }     if (aggregations != null) {         builder.field(AGGREGATIONS_FIELD.getPreferredName(), aggregations).     }     if (highlightBuilder != null) {         builder.field(HIGHLIGHT_FIELD.getPreferredName(), highlightBuilder).     }     if (suggestBuilder != null) {         builder.field(SUGGEST_FIELD.getPreferredName(), suggestBuilder).     }     if (rescoreBuilders != null) {         builder.startArray(RESCORE_FIELD.getPreferredName()).         for (RescorerBuilder<?> rescoreBuilder : rescoreBuilders) {             rescoreBuilder.toXContent(builder, params).         }         builder.endArray().     }     if (stats != null) {         builder.field(STATS_FIELD.getPreferredName(), stats).     }     if (extBuilders != null && extBuilders.isEmpty() == false) {         builder.startObject(EXT_FIELD.getPreferredName()).         for (SearchExtBuilder extBuilder : extBuilders) {             extBuilder.toXContent(builder, params).         }         builder.endObject().     }     if (collapse != null) {         builder.field(COLLAPSE.getPreferredName(), collapse).     }     return builder. }
false;public;2;7;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     innerToXContent(builder, params).     builder.endObject().     return builder. }
false;public;0;3;;public String getIndex() {     return index. }
false;public;0;3;;public float getBoost() {     return boost. }
false;public;1;5;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeString(index).     out.writeFloat(boost). }
false;public;2;7;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     builder.field(index, boost).     builder.endObject().     return builder. }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(index, boost). }
false;public;1;12;;@Override public boolean equals(Object obj) {     if (obj == null) {         return false.     }     if (getClass() != obj.getClass()) {         return false.     }     IndexBoost other = (IndexBoost) obj.     return Objects.equals(index, other.index) && Objects.equals(boost, other.boost). }
false;public;1;6;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeString(fieldName).     script.writeTo(out).     out.writeBoolean(ignoreFailure). }
false;public;0;3;;public String fieldName() {     return fieldName. }
false;public;0;3;;public Script script() {     return script. }
false;public;0;3;;public boolean ignoreFailure() {     return ignoreFailure. }
false;public;2;8;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject(fieldName).     builder.field(SCRIPT_FIELD.getPreferredName(), script).     builder.field(IGNORE_FAILURE_FIELD.getPreferredName(), ignoreFailure).     builder.endObject().     return builder. }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(fieldName, script, ignoreFailure). }
false;public;1;13;;@Override public boolean equals(Object obj) {     if (obj == null) {         return false.     }     if (getClass() != obj.getClass()) {         return false.     }     ScriptField other = (ScriptField) obj.     return Objects.equals(fieldName, other.fieldName) && Objects.equals(script, other.script) && Objects.equals(ignoreFailure, other.ignoreFailure). }
false;public;0;7;;@Override public int hashCode() {     return Objects.hash(aggregations, explain, fetchSourceContext, docValueFields, storedFieldsContext, from, highlightBuilder, indexBoosts, minScore, postQueryBuilder, queryBuilder, rescoreBuilders, scriptFields, size, sorts, searchAfterBuilder, sliceBuilder, stats, suggestBuilder, terminateAfter, timeout, trackScores, version, seqNoAndPrimaryTerm, profile, extBuilders, collapse, trackTotalHitsUpTo). }
false;public;1;38;;@Override public boolean equals(Object obj) {     if (obj == null) {         return false.     }     if (obj.getClass() != getClass()) {         return false.     }     SearchSourceBuilder other = (SearchSourceBuilder) obj.     return Objects.equals(aggregations, other.aggregations) && Objects.equals(explain, other.explain) && Objects.equals(fetchSourceContext, other.fetchSourceContext) && Objects.equals(docValueFields, other.docValueFields) && Objects.equals(storedFieldsContext, other.storedFieldsContext) && Objects.equals(from, other.from) && Objects.equals(highlightBuilder, other.highlightBuilder) && Objects.equals(indexBoosts, other.indexBoosts) && Objects.equals(minScore, other.minScore) && Objects.equals(postQueryBuilder, other.postQueryBuilder) && Objects.equals(queryBuilder, other.queryBuilder) && Objects.equals(rescoreBuilders, other.rescoreBuilders) && Objects.equals(scriptFields, other.scriptFields) && Objects.equals(size, other.size) && Objects.equals(sorts, other.sorts) && Objects.equals(searchAfterBuilder, other.searchAfterBuilder) && Objects.equals(sliceBuilder, other.sliceBuilder) && Objects.equals(stats, other.stats) && Objects.equals(suggestBuilder, other.suggestBuilder) && Objects.equals(terminateAfter, other.terminateAfter) && Objects.equals(timeout, other.timeout) && Objects.equals(trackScores, other.trackScores) && Objects.equals(version, other.version) && Objects.equals(seqNoAndPrimaryTerm, other.seqNoAndPrimaryTerm) && Objects.equals(profile, other.profile) && Objects.equals(extBuilders, other.extBuilders) && Objects.equals(collapse, other.collapse) && Objects.equals(trackTotalHitsUpTo, other.trackTotalHitsUpTo). }
false;public;0;4;;@Override public String toString() {     return toString(EMPTY_PARAMS). }
false;public;1;7;;public String toString(Params params) {     try {         return XContentHelper.toXContent(this, XContentType.JSON, params, true).utf8ToString().     } catch (IOException e) {         throw new ElasticsearchException(e).     } }
