commented;modifiers;parameterAmount;loc;comment;code
false;public;1;7;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     Slot slot = (Slot) o.     return CompositeValuesCollectorQueue.this.equals(value, slot.value). }
false;public;0;4;;@Override public int hashCode() {     return CompositeValuesCollectorQueue.this.hashCode(value). }
false;protected;2;4;;@Override protected boolean lessThan(Integer a, Integer b) {     return compare(a, b) > 0. }
true;;0;3;/**  * Whether the queue is full or not.  */ ;/**  * Whether the queue is full or not.  */ boolean isFull() {     return size() >= maxSize. }
true;;0;3;/**  * Compares the current candidate with the values in the queue and returns  * the slot if the candidate is already in the queue or null if the candidate is not present.  */ ;/**  * Compares the current candidate with the values in the queue and returns  * the slot if the candidate is already in the queue or null if the candidate is not present.  */ Integer compareCurrent() {     return map.get(new Slot(CANDIDATE_SLOT)). }
true;;0;3;/**  * Returns the lowest value (exclusive) of the leading source.  */ ;/**  * Returns the lowest value (exclusive) of the leading source.  */ Comparable getLowerValueLeadSource() {     return afterKeyIsSet ? arrays[0].getAfter() : null. }
true;;0;3;/**  * Returns the upper value (inclusive) of the leading source.  */ ;/**  * Returns the upper value (inclusive) of the leading source.  */ Comparable getUpperValueLeadSource() throws IOException {     return size() >= maxSize ? arrays[0].toComparable(top()) : null. }
true;;1;3;/**  * Returns the document count in <code>slot</code>.  */ ;/**  * Returns the document count in <code>slot</code>.  */ int getDocCount(int slot) {     return docCounts.get(slot). }
true;private;1;7;/**  * Copies the current value in <code>slot</code>.  */ ;/**  * Copies the current value in <code>slot</code>.  */ private void copyCurrent(int slot) {     for (int i = 0. i < arrays.length. i++) {         arrays[i].copyCurrent(slot).     }     docCounts = bigArrays.grow(docCounts, slot + 1).     docCounts.set(slot, 1). }
true;;2;15;/**  * Compares the values in <code>slot1</code> with the values in <code>slot2</code>.  */ ;/**  * Compares the values in <code>slot1</code> with the values in <code>slot2</code>.  */ int compare(int slot1, int slot2) {     assert slot2 != CANDIDATE_SLOT.     for (int i = 0. i < arrays.length. i++) {         final int cmp.         if (slot1 == CANDIDATE_SLOT) {             cmp = arrays[i].compareCurrent(slot2).         } else {             cmp = arrays[i].compare(slot1, slot2).         }         if (cmp != 0) {             return cmp.         }     }     return 0. }
true;;2;15;/**  * Returns true if the values in <code>slot1</code> are equals to the value in <code>slot2</code>.  */ ;/**  * Returns true if the values in <code>slot1</code> are equals to the value in <code>slot2</code>.  */ boolean equals(int slot1, int slot2) {     assert slot2 != CANDIDATE_SLOT.     for (int i = 0. i < arrays.length. i++) {         final int cmp.         if (slot1 == CANDIDATE_SLOT) {             cmp = arrays[i].compareCurrent(slot2).         } else {             cmp = arrays[i].compare(slot1, slot2).         }         if (cmp != 0) {             return false.         }     }     return true. }
true;;1;7;/**  * Returns a hash code value for the values in <code>slot</code>.  */ ;/**  * Returns a hash code value for the values in <code>slot</code>.  */ int hashCode(int slot) {     int result = 1.     for (int i = 0. i < arrays.length. i++) {         result = 31 * result + (slot == CANDIDATE_SLOT ? arrays[i].hashCodeCurrent() : arrays[i].hashCode(slot)).     }     return result. }
true;private;0;9;/**  * Compares the after values with the values in <code>slot</code>.  */ ;/**  * Compares the after values with the values in <code>slot</code>.  */ private int compareCurrentWithAfter() {     for (int i = 0. i < arrays.length. i++) {         int cmp = arrays[i].compareCurrentWithAfter().         if (cmp != 0) {             return cmp.         }     }     return 0. }
true;;1;8;/**  * Builds the {@link CompositeKey} for <code>slot</code>.  */ ;/**  * Builds the {@link CompositeKey} for <code>slot</code>.  */ CompositeKey toCompositeKey(int slot) throws IOException {     assert slot < maxSize.     Comparable[] values = new Comparable[arrays.length].     for (int i = 0. i < values.length. i++) {         values[i] = arrays[i].toComparable(slot).     }     return new CompositeKey(values). }
true;;2;3;/**  * Creates the collector that will visit the composite buckets of the matching documents.  * The provided collector <code>in</code> is called on each composite bucket.  */ ;/**  * Creates the collector that will visit the composite buckets of the matching documents.  * The provided collector <code>in</code> is called on each composite bucket.  */ LeafBucketCollector getLeafCollector(LeafReaderContext context, LeafBucketCollector in) throws IOException {     return getLeafCollector(null, context, in). }
true;;3;14;/**  * Creates the collector that will visit the composite buckets of the matching documents.  * If <code>forceLeadSourceValue</code> is not null, the leading source will use this value  * for each document.  * The provided collector <code>in</code> is called on each composite bucket.  */ ;/**  * Creates the collector that will visit the composite buckets of the matching documents.  * If <code>forceLeadSourceValue</code> is not null, the leading source will use this value  * for each document.  * The provided collector <code>in</code> is called on each composite bucket.  */ LeafBucketCollector getLeafCollector(Comparable forceLeadSourceValue, LeafReaderContext context, LeafBucketCollector in) throws IOException {     int last = arrays.length - 1.     LeafBucketCollector collector = in.     while (last > 0) {         collector = arrays[last--].getLeafCollector(context, collector).     }     if (forceLeadSourceValue != null) {         collector = arrays[last].getLeafCollector(forceLeadSourceValue, context, collector).     } else {         collector = arrays[last].getLeafCollector(context, collector).     }     return collector. }
true;;0;36;/**  * Check if the current candidate should be added in the queue.  * @return The target slot of the candidate or -1 is the candidate is not competitive.  */ ;/**  * Check if the current candidate should be added in the queue.  * @return The target slot of the candidate or -1 is the candidate is not competitive.  */ int addIfCompetitive() {     // checks if the candidate key is competitive     Integer topSlot = compareCurrent().     if (topSlot != null) {         // this key is already in the top N, skip it         docCounts.increment(topSlot, 1).         return topSlot.     }     if (afterKeyIsSet && compareCurrentWithAfter() <= 0) {         // this key is greater than the top value collected in the previous round, skip it         return -1.     }     if (size() >= maxSize && // the tree map is full, check if the candidate key should be kept     compare(CANDIDATE_SLOT, top()) > 0) {         // the candidate key is not competitive, skip it         return -1.     }     // the candidate key is competitive     final int newSlot.     if (size() >= maxSize) {         // the queue is full, we replace the last key with this candidate         int slot = pop().         map.remove(new Slot(slot)).         // and we recycle the deleted slot         newSlot = slot.     } else {         newSlot = size().     }     // move the candidate key to its new slot     copyCurrent(newSlot).     map.put(new Slot(newSlot), newSlot).     add(newSlot).     return newSlot. }
false;public;0;4;;@Override public void close() {     Releasables.close(docCounts). }
