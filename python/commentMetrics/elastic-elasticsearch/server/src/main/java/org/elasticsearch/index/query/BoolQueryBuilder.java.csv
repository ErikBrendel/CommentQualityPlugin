commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;12;;@Override protected void doWriteTo(StreamOutput out) throws IOException {     writeQueries(out, mustClauses).     writeQueries(out, mustNotClauses).     writeQueries(out, shouldClauses).     writeQueries(out, filterClauses).     out.writeBoolean(adjustPureNegative).     if (out.getVersion().before(Version.V_6_0_0_alpha1)) {         // disable_coord         out.writeBoolean(true).     }     out.writeOptionalString(minimumShouldMatch). }
true;public;1;7;/**  * Adds a query that <b>must</b> appear in the matching documents and will  * contribute to scoring. No {@code null} value allowed.  */ ;/**  * Adds a query that <b>must</b> appear in the matching documents and will  * contribute to scoring. No {@code null} value allowed.  */ public BoolQueryBuilder must(QueryBuilder queryBuilder) {     if (queryBuilder == null) {         throw new IllegalArgumentException("inner bool query clause cannot be null").     }     mustClauses.add(queryBuilder).     return this. }
true;public;0;3;/**  * Gets the queries that <b>must</b> appear in the matching documents.  */ ;/**  * Gets the queries that <b>must</b> appear in the matching documents.  */ public List<QueryBuilder> must() {     return this.mustClauses. }
true;public;1;7;/**  * Adds a query that <b>must</b> appear in the matching documents but will  * not contribute to scoring. No {@code null} value allowed.  */ ;/**  * Adds a query that <b>must</b> appear in the matching documents but will  * not contribute to scoring. No {@code null} value allowed.  */ public BoolQueryBuilder filter(QueryBuilder queryBuilder) {     if (queryBuilder == null) {         throw new IllegalArgumentException("inner bool query clause cannot be null").     }     filterClauses.add(queryBuilder).     return this. }
true;public;0;3;/**  * Gets the queries that <b>must</b> appear in the matching documents but don't contribute to scoring  */ ;/**  * Gets the queries that <b>must</b> appear in the matching documents but don't contribute to scoring  */ public List<QueryBuilder> filter() {     return this.filterClauses. }
true;public;1;7;/**  * Adds a query that <b>must not</b> appear in the matching documents.  * No {@code null} value allowed.  */ ;/**  * Adds a query that <b>must not</b> appear in the matching documents.  * No {@code null} value allowed.  */ public BoolQueryBuilder mustNot(QueryBuilder queryBuilder) {     if (queryBuilder == null) {         throw new IllegalArgumentException("inner bool query clause cannot be null").     }     mustNotClauses.add(queryBuilder).     return this. }
true;public;0;3;/**  * Gets the queries that <b>must not</b> appear in the matching documents.  */ ;/**  * Gets the queries that <b>must not</b> appear in the matching documents.  */ public List<QueryBuilder> mustNot() {     return this.mustNotClauses. }
true;public;1;7;/**  * Adds a clause that <i>should</i> be matched by the returned documents. For a boolean query with no  * {@code MUST} clauses one or more <code>SHOULD</code> clauses must match a document  * for the BooleanQuery to match. No {@code null} value allowed.  *  * @see #minimumShouldMatch(int)  */ ;/**  * Adds a clause that <i>should</i> be matched by the returned documents. For a boolean query with no  * {@code MUST} clauses one or more <code>SHOULD</code> clauses must match a document  * for the BooleanQuery to match. No {@code null} value allowed.  *  * @see #minimumShouldMatch(int)  */ public BoolQueryBuilder should(QueryBuilder queryBuilder) {     if (queryBuilder == null) {         throw new IllegalArgumentException("inner bool query clause cannot be null").     }     shouldClauses.add(queryBuilder).     return this. }
true;public;0;3;/**  * Gets the list of clauses that <b>should</b> be matched by the returned documents.  *  * @see #should(QueryBuilder)  *  @see #minimumShouldMatch(int)  */ ;/**  * Gets the list of clauses that <b>should</b> be matched by the returned documents.  *  * @see #should(QueryBuilder)  *  @see #minimumShouldMatch(int)  */ public List<QueryBuilder> should() {     return this.shouldClauses. }
true;public;0;3;/**  * @return the string representation of the minimumShouldMatch settings for this query  */ ;/**  * @return the string representation of the minimumShouldMatch settings for this query  */ public String minimumShouldMatch() {     return this.minimumShouldMatch. }
true;public;1;4;/**  * Sets the minimum should match parameter using the special syntax (for example, supporting percentage).  * @see BoolQueryBuilder#minimumShouldMatch(int)  */ ;/**  * Sets the minimum should match parameter using the special syntax (for example, supporting percentage).  * @see BoolQueryBuilder#minimumShouldMatch(int)  */ public BoolQueryBuilder minimumShouldMatch(String minimumShouldMatch) {     this.minimumShouldMatch = minimumShouldMatch.     return this. }
true;public;1;4;/**  * Specifies a minimum number of the optional (should) boolean clauses which must be satisfied.  * <p>  * By default no optional clauses are necessary for a match  * (unless there are no required clauses).  If this method is used,  * then the specified number of clauses is required.  * <p>  * Use of this method is totally independent of specifying that  * any specific clauses are required (or prohibited).  This number will  * only be compared against the number of matching optional clauses.  *  * @param minimumShouldMatch the number of optional clauses that must match  */ ;/**  * Specifies a minimum number of the optional (should) boolean clauses which must be satisfied.  * <p>  * By default no optional clauses are necessary for a match  * (unless there are no required clauses).  If this method is used,  * then the specified number of clauses is required.  * <p>  * Use of this method is totally independent of specifying that  * any specific clauses are required (or prohibited).  This number will  * only be compared against the number of matching optional clauses.  *  * @param minimumShouldMatch the number of optional clauses that must match  */ public BoolQueryBuilder minimumShouldMatch(int minimumShouldMatch) {     this.minimumShouldMatch = Integer.toString(minimumShouldMatch).     return this. }
true;public;0;3;/**  * Returns <code>true</code> iff this query builder has at least one should, must, must not or filter clause.  * Otherwise <code>false</code>.  */ ;/**  * Returns <code>true</code> iff this query builder has at least one should, must, must not or filter clause.  * Otherwise <code>false</code>.  */ public boolean hasClauses() {     return !(mustClauses.isEmpty() && shouldClauses.isEmpty() && mustNotClauses.isEmpty() && filterClauses.isEmpty()). }
true;public;1;4;/**  * If a boolean query contains only negative ("must not") clauses should the  * BooleanQuery be enhanced with a {@link MatchAllDocsQuery} in order to act  * as a pure exclude. The default is <code>true</code>.  */ ;/**  * If a boolean query contains only negative ("must not") clauses should the  * BooleanQuery be enhanced with a {@link MatchAllDocsQuery} in order to act  * as a pure exclude. The default is <code>true</code>.  */ public BoolQueryBuilder adjustPureNegative(boolean adjustPureNegative) {     this.adjustPureNegative = adjustPureNegative.     return this. }
true;public;0;3;/**  * @return the setting for the adjust_pure_negative setting in this query  */ ;/**  * @return the setting for the adjust_pure_negative setting in this query  */ public boolean adjustPureNegative() {     return this.adjustPureNegative. }
false;protected;2;14;;@Override protected void doXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject(NAME).     doXArrayContent(MUST, mustClauses, builder, params).     doXArrayContent(FILTER, filterClauses, builder, params).     doXArrayContent(MUST_NOT, mustNotClauses, builder, params).     doXArrayContent(SHOULD, shouldClauses, builder, params).     builder.field(ADJUST_PURE_NEGATIVE.getPreferredName(), adjustPureNegative).     if (minimumShouldMatch != null) {         builder.field(MINIMUM_SHOULD_MATCH.getPreferredName(), minimumShouldMatch).     }     printBoostAndQueryName(builder).     builder.endObject(). }
false;private,static;4;11;;private static void doXArrayContent(String field, List<QueryBuilder> clauses, XContentBuilder builder, Params params) throws IOException {     if (clauses.isEmpty()) {         return.     }     builder.startArray(field).     for (QueryBuilder clause : clauses) {         clause.toXContent(builder, params).     }     builder.endArray(). }
false;public,static;1;89;;public static BoolQueryBuilder fromXContent(XContentParser parser) throws IOException, ParsingException {     boolean adjustPureNegative = BoolQueryBuilder.ADJUST_PURE_NEGATIVE_DEFAULT.     float boost = DEFAULT_BOOST.     String minimumShouldMatch = null.     final List<QueryBuilder> mustClauses = new ArrayList<>().     final List<QueryBuilder> mustNotClauses = new ArrayList<>().     final List<QueryBuilder> shouldClauses = new ArrayList<>().     final List<QueryBuilder> filterClauses = new ArrayList<>().     String queryName = null.     String currentFieldName = null.     XContentParser.Token token.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (token == XContentParser.Token.START_OBJECT) {             switch(currentFieldName) {                 case MUST:                     mustClauses.add(parseInnerQueryBuilder(parser)).                     break.                 case SHOULD:                     shouldClauses.add(parseInnerQueryBuilder(parser)).                     break.                 case FILTER:                     filterClauses.add(parseInnerQueryBuilder(parser)).                     break.                 case MUST_NOT:                 case MUSTNOT:                     mustNotClauses.add(parseInnerQueryBuilder(parser)).                     break.                 default:                     throw new ParsingException(parser.getTokenLocation(), "[bool] query does not support [" + currentFieldName + "]").             }         } else if (token == XContentParser.Token.START_ARRAY) {             while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {                 switch(currentFieldName) {                     case MUST:                         mustClauses.add(parseInnerQueryBuilder(parser)).                         break.                     case SHOULD:                         shouldClauses.add(parseInnerQueryBuilder(parser)).                         break.                     case FILTER:                         filterClauses.add(parseInnerQueryBuilder(parser)).                         break.                     case MUST_NOT:                     case MUSTNOT:                         mustNotClauses.add(parseInnerQueryBuilder(parser)).                         break.                     default:                         throw new ParsingException(parser.getTokenLocation(), "bool query does not support [" + currentFieldName + "]").                 }             }         } else if (token.isValue()) {             if (DISABLE_COORD_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {             // ignore             } else if (MINIMUM_SHOULD_MATCH.match(currentFieldName, parser.getDeprecationHandler())) {                 minimumShouldMatch = parser.textOrNull().             } else if (BOOST_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 boost = parser.floatValue().             } else if (ADJUST_PURE_NEGATIVE.match(currentFieldName, parser.getDeprecationHandler())) {                 adjustPureNegative = parser.booleanValue().             } else if (NAME_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 queryName = parser.text().             } else {                 throw new ParsingException(parser.getTokenLocation(), "[bool] query does not support [" + currentFieldName + "]").             }         }     }     BoolQueryBuilder boolQuery = new BoolQueryBuilder().     for (QueryBuilder queryBuilder : mustClauses) {         boolQuery.must(queryBuilder).     }     for (QueryBuilder queryBuilder : mustNotClauses) {         boolQuery.mustNot(queryBuilder).     }     for (QueryBuilder queryBuilder : shouldClauses) {         boolQuery.should(queryBuilder).     }     for (QueryBuilder queryBuilder : filterClauses) {         boolQuery.filter(queryBuilder).     }     boolQuery.boost(boost).     boolQuery.adjustPureNegative(adjustPureNegative).     boolQuery.minimumShouldMatch(minimumShouldMatch).     boolQuery.queryName(queryName).     return boolQuery. }
false;public;0;4;;@Override public String getWriteableName() {     return NAME. }
false;protected;1;15;;@Override protected Query doToQuery(QueryShardContext context) throws IOException {     BooleanQuery.Builder booleanQueryBuilder = new BooleanQuery.Builder().     addBooleanClauses(context, booleanQueryBuilder, mustClauses, BooleanClause.Occur.MUST).     addBooleanClauses(context, booleanQueryBuilder, mustNotClauses, BooleanClause.Occur.MUST_NOT).     addBooleanClauses(context, booleanQueryBuilder, shouldClauses, BooleanClause.Occur.SHOULD).     addBooleanClauses(context, booleanQueryBuilder, filterClauses, BooleanClause.Occur.FILTER).     BooleanQuery booleanQuery = booleanQueryBuilder.build().     if (booleanQuery.clauses().isEmpty()) {         return new MatchAllDocsQuery().     }     Query query = Queries.applyMinimumShouldMatch(booleanQuery, minimumShouldMatch).     return adjustPureNegative ? fixNegativeQueryIfNeeded(query) : query. }
false;private,static;4;7;;private static void addBooleanClauses(QueryShardContext context, BooleanQuery.Builder booleanQueryBuilder, List<QueryBuilder> clauses, Occur occurs) throws IOException {     for (QueryBuilder query : clauses) {         Query luceneQuery = query.toQuery(context).         booleanQueryBuilder.add(new BooleanClause(luceneQuery, occurs)).     } }
false;protected;0;5;;@Override protected int doHashCode() {     return Objects.hash(adjustPureNegative, minimumShouldMatch, mustClauses, shouldClauses, mustNotClauses, filterClauses). }
false;protected;1;9;;@Override protected boolean doEquals(BoolQueryBuilder other) {     return Objects.equals(adjustPureNegative, other.adjustPureNegative) && Objects.equals(minimumShouldMatch, other.minimumShouldMatch) && Objects.equals(mustClauses, other.mustClauses) && Objects.equals(shouldClauses, other.shouldClauses) && Objects.equals(mustNotClauses, other.mustNotClauses) && Objects.equals(filterClauses, other.filterClauses). }
false;protected;1;27;;@Override protected QueryBuilder doRewrite(QueryRewriteContext queryRewriteContext) throws IOException {     BoolQueryBuilder newBuilder = new BoolQueryBuilder().     boolean changed = false.     final int clauses = mustClauses.size() + mustNotClauses.size() + filterClauses.size() + shouldClauses.size().     if (clauses == 0) {         return new MatchAllQueryBuilder().boost(boost()).queryName(queryName()).     }     changed |= rewriteClauses(queryRewriteContext, mustClauses, newBuilder::must).     changed |= rewriteClauses(queryRewriteContext, mustNotClauses, newBuilder::mustNot).     changed |= rewriteClauses(queryRewriteContext, filterClauses, newBuilder::filter).     changed |= rewriteClauses(queryRewriteContext, shouldClauses, newBuilder::should).     // lets do some early termination and prevent any kind of rewriting if we have a mandatory query that is a MatchNoneQueryBuilder     Optional<QueryBuilder> any = Stream.concat(newBuilder.mustClauses.stream(), newBuilder.filterClauses.stream()).filter(b -> b instanceof MatchNoneQueryBuilder).findAny().     if (any.isPresent()) {         return any.get().     }     if (changed) {         newBuilder.adjustPureNegative = adjustPureNegative.         newBuilder.minimumShouldMatch = minimumShouldMatch.         newBuilder.boost(boost()).         newBuilder.queryName(queryName()).         return newBuilder.     }     return this. }
false;protected;1;10;;@Override protected void extractInnerHitBuilders(Map<String, InnerHitContextBuilder> innerHits) {     List<QueryBuilder> clauses = new ArrayList<>(filter()).     clauses.addAll(must()).     clauses.addAll(should()).     // no need to include must_not (since there will be no hits for it)     for (QueryBuilder clause : clauses) {         InnerHitContextBuilder.extractInnerHits(clause, innerHits).     } }
false;private,static;3;12;;private static boolean rewriteClauses(QueryRewriteContext queryRewriteContext, List<QueryBuilder> builders, Consumer<QueryBuilder> consumer) throws IOException {     boolean changed = false.     for (QueryBuilder builder : builders) {         QueryBuilder result = builder.rewrite(queryRewriteContext).         if (result != builder) {             changed = true.         }         consumer.accept(result).     }     return changed. }
