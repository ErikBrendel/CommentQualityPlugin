commented;modifiers;parameterAmount;loc;comment;code
true;public;1;18;/**  * Acquires a lock for the given key. The key is compared by it's equals method not by object identity. The lock can be acquired  * by the same thread multiple times. The lock is released by closing the returned {@link Releasable}.  */ ;/**  * Acquires a lock for the given key. The key is compared by it's equals method not by object identity. The lock can be acquired  * by the same thread multiple times. The lock is released by closing the returned {@link Releasable}.  */ public Releasable acquire(T key) {     while (true) {         KeyLock perNodeLock = map.get(key).         if (perNodeLock == null) {             ReleasableLock newLock = tryCreateNewLock(key).             if (newLock != null) {                 return newLock.             }         } else {             assert perNodeLock != null.             int i = perNodeLock.count.get().             if (i > 0 && perNodeLock.count.compareAndSet(i, i + 1)) {                 perNodeLock.lock().                 return new ReleasableLock(key, perNodeLock).             }         }     } }
true;public;1;19;/**  * Tries to acquire the lock for the given key and returns it. If the lock can't be acquired null is returned.  */ ;/**  * Tries to acquire the lock for the given key and returns it. If the lock can't be acquired null is returned.  */ public Releasable tryAcquire(T key) {     final KeyLock perNodeLock = map.get(key).     if (perNodeLock == null) {         return tryCreateNewLock(key).     }     if (perNodeLock.tryLock()) {         // ok we got it - make sure we increment it accordingly otherwise release it again         int i.         while ((i = perNodeLock.count.get()) > 0) {             // the lock we should retry and see if we can still get it or if the count is 0. If that is the case and we give up.             if (perNodeLock.count.compareAndSet(i, i + 1)) {                 return new ReleasableLock(key, perNodeLock).             }         }         // make sure we unlock and don't leave the lock in a locked state         perNodeLock.unlock().     }     return null. }
false;private;1;9;;private ReleasableLock tryCreateNewLock(T key) {     KeyLock newLock = new KeyLock(fair).     newLock.lock().     KeyLock keyLock = map.putIfAbsent(key, newLock).     if (keyLock == null) {         return new ReleasableLock(key, newLock).     }     return null. }
true;public;1;7;/**  * Returns <code>true</code> iff the caller thread holds the lock for the given key  */ ;/**  * Returns <code>true</code> iff the caller thread holds the lock for the given key  */ public boolean isHeldByCurrentThread(T key) {     KeyLock lock = map.get(key).     if (lock == null) {         return false.     }     return lock.isHeldByCurrentThread(). }
false;private;2;9;;private void release(T key, KeyLock lock) {     assert lock == map.get(key).     final int decrementAndGet = lock.count.decrementAndGet().     lock.unlock().     if (decrementAndGet == 0) {         map.remove(key, lock).     }     assert decrementAndGet >= 0 : decrementAndGet + " must be >= 0 but wasn't". }
false;public;0;6;;@Override public void close() {     if (closed.compareAndSet(false, true)) {         release(key, lock).     } }
true;public;0;3;/**  * Returns <code>true</code> if this lock has at least one locked key.  */ ;/**  * Returns <code>true</code> if this lock has at least one locked key.  */ public boolean hasLockedKeys() {     return map.isEmpty() == false. }
