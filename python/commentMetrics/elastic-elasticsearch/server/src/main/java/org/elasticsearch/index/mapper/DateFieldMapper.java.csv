commented;modifiers;parameterAmount;loc;comment;code
false;public;1;3;;public long convert(Instant instant) {     return instant.toEpochMilli(). }
false;public;1;3;;public Instant toInstant(long value) {     return Instant.ofEpochMilli(value). }
false;public;1;3;;public long convert(Instant instant) {     return toLong(instant). }
false;public;1;3;;public Instant toInstant(long value) {     return DateUtils.toInstant(value). }
false;public;0;3;;public String type() {     return type. }
false;;0;3;;NumericType numericType() {     return numericType. }
false;public,abstract;1;1;;public abstract long convert(Instant instant).
false;public,abstract;1;1;;public abstract Instant toInstant(long value).
false;public,static;1;8;;public static Resolution ofOrdinal(int ord) {     for (Resolution resolution : values()) {         if (ord == resolution.ordinal()) {             return resolution.         }     }     throw new IllegalArgumentException("unknown resolution ordinal [" + ord + "]"). }
false;public;0;4;;@Override public DateFieldType fieldType() {     return (DateFieldType) fieldType. }
false;public;1;4;;public Builder ignoreMalformed(boolean ignoreMalformed) {     this.ignoreMalformed = ignoreMalformed.     return builder. }
false;protected;1;9;;protected Explicit<Boolean> ignoreMalformed(BuilderContext context) {     if (ignoreMalformed != null) {         return new Explicit<>(ignoreMalformed, true).     }     if (context.indexSettings() != null) {         return new Explicit<>(IGNORE_MALFORMED_SETTING.get(context.indexSettings()), false).     }     return Defaults.IGNORE_MALFORMED. }
false;public;1;4;;public Builder locale(Locale locale) {     this.locale = locale.     return this. }
false;public;0;3;;public Locale locale() {     return locale. }
false;public;0;3;;public String format() {     return format.value(). }
false;public;1;4;;public Builder format(String format) {     this.format = new Explicit<>(format, true).     return this. }
false;;1;4;;Builder withResolution(Resolution resolution) {     this.resolution = resolution.     return this. }
false;public;0;3;;public boolean isFormatterSet() {     return format.explicit(). }
false;protected;1;13;;@Override protected void setupFieldType(BuilderContext context) {     super.setupFieldType(context).     String pattern = this.format.value().     DateFormatter dateTimeFormatter = fieldType().dateTimeFormatter.     boolean hasPatternChanged = Strings.hasLength(pattern) && Objects.equals(pattern, dateTimeFormatter.pattern()) == false.     if (hasPatternChanged || Objects.equals(builder.locale, dateTimeFormatter.locale()) == false) {         fieldType().setDateTimeFormatter(DateFormatter.forPattern(pattern).withLocale(locale)).     }     fieldType().setResolution(resolution). }
false;public;1;6;;@Override public DateFieldMapper build(BuilderContext context) {     setupFieldType(context).     return new DateFieldMapper(name, fieldType, defaultFieldType, ignoreMalformed(context), context.indexSettings(), multiFieldsBuilder.build(this, context), copyTo). }
false;public;3;30;;@Override public Mapper.Builder<?, ?> parse(String name, Map<String, Object> node, ParserContext parserContext) throws MapperParsingException {     Builder builder = new Builder(name).     builder.withResolution(resolution).     TypeParsers.parseField(builder, name, node, parserContext).     for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(). iterator.hasNext(). ) {         Map.Entry<String, Object> entry = iterator.next().         String propName = entry.getKey().         Object propNode = entry.getValue().         if (propName.equals("null_value")) {             if (propNode == null) {                 throw new MapperParsingException("Property [null_value] cannot be null.").             }             builder.nullValue(propNode.toString()).             iterator.remove().         } else if (propName.equals("ignore_malformed")) {             builder.ignoreMalformed(XContentMapValues.nodeBooleanValue(propNode, name + ".ignore_malformed")).             iterator.remove().         } else if (propName.equals("locale")) {             builder.locale(LocaleUtils.parse(propNode.toString())).             iterator.remove().         } else if (propName.equals("format")) {             builder.format(propNode.toString()).             iterator.remove().         } else if (TypeParsers.parseMultiField(builder, name, parserContext, propName, propNode)) {             iterator.remove().         }     }     return builder. }
false;public;0;4;;@Override public MappedFieldType clone() {     return new DateFieldType(this). }
false;public;1;6;;@Override public boolean equals(Object o) {     if (!super.equals(o))         return false.     DateFieldType that = (DateFieldType) o.     return Objects.equals(dateTimeFormatter, that.dateTimeFormatter) && Objects.equals(resolution, that.resolution). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(super.hashCode(), dateTimeFormatter, resolution). }
false;public;0;4;;@Override public String typeName() {     return resolution.type(). }
false;public;2;14;;@Override public void checkCompatibility(MappedFieldType fieldType, List<String> conflicts) {     super.checkCompatibility(fieldType, conflicts).     DateFieldType other = (DateFieldType) fieldType.     if (Objects.equals(dateTimeFormatter.pattern(), other.dateTimeFormatter.pattern()) == false) {         conflicts.add("mapper [" + name() + "] has different [format] values").     }     if (Objects.equals(dateTimeFormatter.locale(), other.dateTimeFormatter.locale()) == false) {         conflicts.add("mapper [" + name() + "] has different [locale] values").     }     if (Objects.equals(resolution.type(), other.resolution.type()) == false) {         conflicts.add("mapper [" + name() + "] cannot change between milliseconds and nanoseconds").     } }
false;public;0;3;;public DateFormatter dateTimeFormatter() {     return dateTimeFormatter. }
false;;1;5;;void setDateTimeFormatter(DateFormatter formatter) {     checkIfFrozen().     this.dateTimeFormatter = formatter.     this.dateMathParser = dateTimeFormatter.toDateMathParser(). }
false;;1;4;;void setResolution(Resolution resolution) {     checkIfFrozen().     this.resolution = resolution. }
false;protected;0;3;;protected DateMathParser dateMathParser() {     return dateMathParser. }
false;;1;3;;long parse(String value) {     return resolution.convert(DateFormatters.from(dateTimeFormatter().parse(value)).toInstant()). }
false;public;1;8;;@Override public Query existsQuery(QueryShardContext context) {     if (hasDocValues()) {         return new DocValuesFieldExistsQuery(name()).     } else {         return new TermQuery(new Term(FieldNamesFieldMapper.NAME, name())).     } }
false;public;2;8;;@Override public Query termQuery(Object value, @Nullable QueryShardContext context) {     Query query = rangeQuery(value, value, true, true, ShapeRelation.INTERSECTS, null, null, context).     if (boost() != 1f) {         query = new BoostQuery(query, boost()).     }     return query. }
false;public;8;35;;@Override public Query rangeQuery(Object lowerTerm, Object upperTerm, boolean includeLower, boolean includeUpper, ShapeRelation relation, @Nullable ZoneId timeZone, @Nullable DateMathParser forcedDateParser, QueryShardContext context) {     failIfNotIndexed().     if (relation == ShapeRelation.DISJOINT) {         throw new IllegalArgumentException("Field [" + name() + "] of type [" + typeName() + "] does not support DISJOINT ranges").     }     DateMathParser parser = forcedDateParser == null ? dateMathParser : forcedDateParser.     long l, u.     if (lowerTerm == null) {         l = Long.MIN_VALUE.     } else {         l = parseToLong(lowerTerm, !includeLower, timeZone, parser, context).         if (includeLower == false) {             ++l.         }     }     if (upperTerm == null) {         u = Long.MAX_VALUE.     } else {         u = parseToLong(upperTerm, includeUpper, timeZone, parser, context).         if (includeUpper == false) {             --u.         }     }     Query query = LongPoint.newRangeQuery(name(), l, u).     if (hasDocValues()) {         Query dvQuery = SortedNumericDocValuesField.newSlowRangeQuery(name(), l, u).         query = new IndexOrDocValuesQuery(query, dvQuery).     }     return query. }
false;public;5;16;;public long parseToLong(Object value, boolean roundUp, @Nullable ZoneId zone, @Nullable DateMathParser forcedDateParser, QueryRewriteContext context) {     DateMathParser dateParser = dateMathParser().     if (forcedDateParser != null) {         dateParser = forcedDateParser.     }     String strValue.     if (value instanceof BytesRef) {         strValue = ((BytesRef) value).utf8ToString().     } else {         strValue = value.toString().     }     Instant instant = dateParser.parse(strValue, context::nowInMillis, roundUp, zone).     return resolution.convert(instant). }
false;public;8;49;;@Override public Relation isFieldWithinQuery(IndexReader reader, Object from, Object to, boolean includeLower, boolean includeUpper, ZoneId timeZone, DateMathParser dateParser, QueryRewriteContext context) throws IOException {     if (dateParser == null) {         dateParser = this.dateMathParser.     }     long fromInclusive = Long.MIN_VALUE.     if (from != null) {         fromInclusive = parseToLong(from, !includeLower, timeZone, dateParser, context).         if (includeLower == false) {             if (fromInclusive == Long.MAX_VALUE) {                 return Relation.DISJOINT.             }             ++fromInclusive.         }     }     long toInclusive = Long.MAX_VALUE.     if (to != null) {         toInclusive = parseToLong(to, includeUpper, timeZone, dateParser, context).         if (includeUpper == false) {             if (toInclusive == Long.MIN_VALUE) {                 return Relation.DISJOINT.             }             --toInclusive.         }     }     // even if there are no points in the shard     if (PointValues.size(reader, name()) == 0) {         // no points, so nothing matches         return Relation.DISJOINT.     }     long minValue = LongPoint.decodeDimension(PointValues.getMinPackedValue(reader, name()), 0).     long maxValue = LongPoint.decodeDimension(PointValues.getMaxPackedValue(reader, name()), 0).     if (minValue >= fromInclusive && maxValue <= toInclusive) {         return Relation.WITHIN.     } else if (maxValue < fromInclusive || minValue > toInclusive) {         return Relation.DISJOINT.     } else {         return Relation.INTERSECTS.     } }
false;public;1;5;;@Override public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName) {     failIfNoDocValues().     return new DocValuesIndexFieldData.Builder().numericType(resolution.numericType()). }
false;public;1;8;;@Override public Object valueForDisplay(Object value) {     Long val = (Long) value.     if (val == null) {         return null.     }     return dateTimeFormatter().format(resolution.toInstant(val).atZone(ZoneOffset.UTC)). }
false;public;2;13;;@Override public DocValueFormat docValueFormat(@Nullable String format, ZoneId timeZone) {     DateFormatter dateTimeFormatter = this.dateTimeFormatter.     if (format != null) {         dateTimeFormatter = DateFormatter.forPattern(format).withLocale(dateTimeFormatter.locale()).     }     if (timeZone == null) {         timeZone = ZoneOffset.UTC.     }     // milliseconds. The only special case here is docvalue fields, which are handled somewhere else     return new DocValueFormat.DateTime(dateTimeFormatter, timeZone, Resolution.MILLISECONDS). }
false;public;0;4;;@Override public DateFieldType fieldType() {     return (DateFieldType) super.fieldType(). }
false;protected;0;4;;@Override protected String contentType() {     return fieldType.typeName(). }
false;protected;0;4;;@Override protected DateFieldMapper clone() {     return (DateFieldMapper) super.clone(). }
false;protected;2;46;;@Override protected void parseCreateField(ParseContext context, List<IndexableField> fields) throws IOException {     String dateAsString.     if (context.externalValueSet()) {         Object dateAsObject = context.externalValue().         if (dateAsObject == null) {             dateAsString = null.         } else {             dateAsString = dateAsObject.toString().         }     } else {         dateAsString = context.parser().textOrNull().     }     if (dateAsString == null) {         dateAsString = fieldType().nullValueAsString().     }     if (dateAsString == null) {         return.     }     long timestamp.     try {         timestamp = fieldType().parse(dateAsString).     } catch (IllegalArgumentException | ElasticsearchParseException e) {         if (ignoreMalformed.value()) {             context.addIgnoredField(fieldType.name()).             return.         } else {             throw e.         }     }     if (fieldType().indexOptions() != IndexOptions.NONE) {         fields.add(new LongPoint(fieldType().name(), timestamp)).     }     if (fieldType().hasDocValues()) {         fields.add(new SortedNumericDocValuesField(fieldType().name(), timestamp)).     } else if (fieldType().stored() || fieldType().indexOptions() != IndexOptions.NONE) {         createFieldNamesField(context, fields).     }     if (fieldType().stored()) {         fields.add(new StoredField(fieldType().name(), timestamp)).     } }
false;protected;1;8;;@Override protected void doMerge(Mapper mergeWith) {     super.doMerge(mergeWith).     final DateFieldMapper other = (DateFieldMapper) mergeWith.     if (other.ignoreMalformed.explicit()) {         this.ignoreMalformed = other.ignoreMalformed.     } }
false;protected;3;22;;@Override protected void doXContentBody(XContentBuilder builder, boolean includeDefaults, Params params) throws IOException {     super.doXContentBody(builder, includeDefaults, params).     if (includeDefaults || ignoreMalformed.explicit()) {         builder.field("ignore_malformed", ignoreMalformed.value()).     }     if (includeDefaults || fieldType().nullValue() != null) {         builder.field("null_value", fieldType().nullValueAsString()).     }     if (includeDefaults || fieldType().dateTimeFormatter().pattern().equals(DEFAULT_DATE_TIME_FORMATTER.pattern()) == false) {         builder.field("format", fieldType().dateTimeFormatter().pattern()).     }     if (includeDefaults || fieldType().dateTimeFormatter().locale().equals(DEFAULT_DATE_TIME_FORMATTER.locale()) == false) {         builder.field("locale", fieldType().dateTimeFormatter().locale()).     } }
