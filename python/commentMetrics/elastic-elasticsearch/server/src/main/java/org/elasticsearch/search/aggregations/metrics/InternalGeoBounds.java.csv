commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;10;;@Override protected void doWriteTo(StreamOutput out) throws IOException {     out.writeDouble(top).     out.writeDouble(bottom).     out.writeDouble(posLeft).     out.writeDouble(posRight).     out.writeDouble(negLeft).     out.writeDouble(negRight).     out.writeBoolean(wrapLongitude). }
false;public;0;4;;@Override public String getWriteableName() {     return GeoBoundsAggregationBuilder.NAME. }
false;public;2;34;;@Override public InternalAggregation doReduce(List<InternalAggregation> aggregations, ReduceContext reduceContext) {     double top = Double.NEGATIVE_INFINITY.     double bottom = Double.POSITIVE_INFINITY.     double posLeft = Double.POSITIVE_INFINITY.     double posRight = Double.NEGATIVE_INFINITY.     double negLeft = Double.POSITIVE_INFINITY.     double negRight = Double.NEGATIVE_INFINITY.     for (InternalAggregation aggregation : aggregations) {         InternalGeoBounds bounds = (InternalGeoBounds) aggregation.         if (bounds.top > top) {             top = bounds.top.         }         if (bounds.bottom < bottom) {             bottom = bounds.bottom.         }         if (bounds.posLeft < posLeft) {             posLeft = bounds.posLeft.         }         if (bounds.posRight > posRight) {             posRight = bounds.posRight.         }         if (bounds.negLeft < negLeft) {             negLeft = bounds.negLeft.         }         if (bounds.negRight > negRight) {             negRight = bounds.negRight.         }     }     return new InternalGeoBounds(name, top, bottom, posLeft, posRight, negLeft, negRight, wrapLongitude, pipelineAggregators(), getMetaData()). }
false;public;1;46;;@Override public Object getProperty(List<String> path) {     if (path.isEmpty()) {         return this.     } else if (path.size() == 1) {         BoundingBox boundingBox = resolveBoundingBox().         String bBoxSide = path.get(0).         switch(bBoxSide) {             case "top":                 return boundingBox.topLeft.lat().             case "left":                 return boundingBox.topLeft.lon().             case "bottom":                 return boundingBox.bottomRight.lat().             case "right":                 return boundingBox.bottomRight.lon().             default:                 throw new IllegalArgumentException("Found unknown path element [" + bBoxSide + "] in [" + getName() + "]").         }     } else if (path.size() == 2) {         BoundingBox boundingBox = resolveBoundingBox().         GeoPoint cornerPoint = null.         String cornerString = path.get(0).         switch(cornerString) {             case "top_left":                 cornerPoint = boundingBox.topLeft.                 break.             case "bottom_right":                 cornerPoint = boundingBox.bottomRight.                 break.             default:                 throw new IllegalArgumentException("Found unknown path element [" + cornerString + "] in [" + getName() + "]").         }         String latLonString = path.get(1).         switch(latLonString) {             case "lat":                 return cornerPoint.lat().             case "lon":                 return cornerPoint.lon().             default:                 throw new IllegalArgumentException("Found unknown path element [" + latLonString + "] in [" + getName() + "]").         }     } else {         throw new IllegalArgumentException("path not supported for [" + getName() + "]: " + path).     } }
false;public;2;18;;@Override public XContentBuilder doXContentBody(XContentBuilder builder, Params params) throws IOException {     GeoPoint topLeft = topLeft().     GeoPoint bottomRight = bottomRight().     if (topLeft != null) {         builder.startObject(BOUNDS_FIELD.getPreferredName()).         builder.startObject(TOP_LEFT_FIELD.getPreferredName()).         builder.field(LAT_FIELD.getPreferredName(), topLeft.lat()).         builder.field(LON_FIELD.getPreferredName(), topLeft.lon()).         builder.endObject().         builder.startObject(BOTTOM_RIGHT_FIELD.getPreferredName()).         builder.field(LAT_FIELD.getPreferredName(), bottomRight.lat()).         builder.field(LON_FIELD.getPreferredName(), bottomRight.lon()).         builder.endObject().         builder.endObject().     }     return builder. }
false;public;0;3;;public GeoPoint topLeft() {     return topLeft. }
false;public;0;3;;public GeoPoint bottomRight() {     return bottomRight. }
false;private;0;19;;private BoundingBox resolveBoundingBox() {     if (Double.isInfinite(top)) {         return null.     } else if (Double.isInfinite(posLeft)) {         return new BoundingBox(new GeoPoint(top, negLeft), new GeoPoint(bottom, negRight)).     } else if (Double.isInfinite(negLeft)) {         return new BoundingBox(new GeoPoint(top, posLeft), new GeoPoint(bottom, posRight)).     } else if (wrapLongitude) {         double unwrappedWidth = posRight - negLeft.         double wrappedWidth = (180 - posLeft) - (-180 - negRight).         if (unwrappedWidth <= wrappedWidth) {             return new BoundingBox(new GeoPoint(top, negLeft), new GeoPoint(bottom, posRight)).         } else {             return new BoundingBox(new GeoPoint(top, posLeft), new GeoPoint(bottom, negRight)).         }     } else {         return new BoundingBox(new GeoPoint(top, negLeft), new GeoPoint(bottom, posRight)).     } }
false;public;0;9;;@Override public GeoPoint topLeft() {     BoundingBox boundingBox = resolveBoundingBox().     if (boundingBox == null) {         return null.     } else {         return boundingBox.topLeft().     } }
false;public;0;9;;@Override public GeoPoint bottomRight() {     BoundingBox boundingBox = resolveBoundingBox().     if (boundingBox == null) {         return null.     } else {         return boundingBox.bottomRight().     } }
false;protected;1;11;;@Override protected boolean doEquals(Object obj) {     InternalGeoBounds other = (InternalGeoBounds) obj.     return top == other.top && bottom == other.bottom && posLeft == other.posLeft && posRight == other.posRight && negLeft == other.negLeft && negRight == other.negRight && wrapLongitude == other.wrapLongitude. }
false;protected;0;4;;@Override protected int doHashCode() {     return Objects.hash(bottom, posLeft, posRight, negLeft, negRight, wrapLongitude). }
