commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public Map<String, Object> source() {     return source. }
false;public;0;3;;public XContentType sourceContentType() {     return sourceContentType. }
false;private;0;27;;private Map<String, Object> loadSourceIfNeeded() {     if (source != null) {         return source.     }     if (sourceAsBytes != null) {         Tuple<XContentType, Map<String, Object>> tuple = sourceAsMapAndType(sourceAsBytes).         sourceContentType = tuple.v1().         source = tuple.v2().         return source.     }     try {         FieldsVisitor sourceFieldVisitor = new FieldsVisitor(true).         reader.document(docId, sourceFieldVisitor).         BytesReference source = sourceFieldVisitor.source().         if (source == null) {             this.source = emptyMap().             this.sourceContentType = null.         } else {             Tuple<XContentType, Map<String, Object>> tuple = sourceAsMapAndType(source).             this.sourceContentType = tuple.v1().             this.source = tuple.v2().         }     } catch (Exception e) {         throw new ElasticsearchParseException("failed to parse / load source", e).     }     return this.source. }
false;public,static;1;3;;public static Tuple<XContentType, Map<String, Object>> sourceAsMapAndType(BytesReference source) throws ElasticsearchParseException {     return XContentHelper.convertToMap(source, false). }
false;public,static;1;3;;public static Map<String, Object> sourceAsMap(BytesReference source) throws ElasticsearchParseException {     return sourceAsMapAndType(source).v2(). }
false;public;2;10;;public void setSegmentAndDocument(LeafReaderContext context, int docId) {     if (this.reader == context.reader() && this.docId == docId) {         // if we are called with the same document, don't invalidate source         return.     }     this.reader = context.reader().     this.source = null.     this.sourceAsBytes = null.     this.docId = docId. }
false;public;1;3;;public void setSource(BytesReference source) {     this.sourceAsBytes = source. }
false;public;1;3;;public void setSourceContentType(XContentType sourceContentType) {     this.sourceContentType = sourceContentType. }
false;public;1;3;;public void setSource(Map<String, Object> source) {     this.source = source. }
true;public;0;3;/**  * Internal source representation, might be compressed....  */ ;/**  * Internal source representation, might be compressed....  */ public BytesReference internalSourceRef() {     return sourceAsBytes. }
true;public;1;3;/**  * Returns the values associated with the path. Those are "low" level values, and it can  * handle path expression where an array/list is navigated within.  */ ;/**  * Returns the values associated with the path. Those are "low" level values, and it can  * handle path expression where an array/list is navigated within.  */ public List<Object> extractRawValues(String path) {     return XContentMapValues.extractRawValues(path, loadSourceIfNeeded()). }
false;public;1;3;;public Object filter(FetchSourceContext context) {     return context.getFilter().apply(loadSourceIfNeeded()). }
false;public;1;3;;public Object extractValue(String path) {     return XContentMapValues.extractValue(path, loadSourceIfNeeded()). }
false;public;1;4;;@Override public Object get(Object key) {     return loadSourceIfNeeded().get(key). }
false;public;0;4;;@Override public int size() {     return loadSourceIfNeeded().size(). }
false;public;0;4;;@Override public boolean isEmpty() {     return loadSourceIfNeeded().isEmpty(). }
false;public;1;4;;@Override public boolean containsKey(Object key) {     return loadSourceIfNeeded().containsKey(key). }
false;public;1;4;;@Override public boolean containsValue(Object value) {     return loadSourceIfNeeded().containsValue(value). }
false;public;0;4;;@Override public Set keySet() {     return loadSourceIfNeeded().keySet(). }
false;public;0;4;;@Override public Collection values() {     return loadSourceIfNeeded().values(). }
false;public;0;4;;@Override public Set entrySet() {     return loadSourceIfNeeded().entrySet(). }
false;public;2;4;;@Override public Object put(Object key, Object value) {     throw new UnsupportedOperationException(). }
false;public;1;4;;@Override public Object remove(Object key) {     throw new UnsupportedOperationException(). }
false;public;1;4;;@Override public void putAll(Map m) {     throw new UnsupportedOperationException(). }
false;public;0;4;;@Override public void clear() {     throw new UnsupportedOperationException(). }
