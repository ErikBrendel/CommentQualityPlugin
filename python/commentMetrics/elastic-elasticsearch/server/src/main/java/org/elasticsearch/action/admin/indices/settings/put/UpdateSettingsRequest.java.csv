commented;modifiers;parameterAmount;loc;comment;code
false;public;0;8;;@Override public ActionRequestValidationException validate() {     ActionRequestValidationException validationException = null.     if (settings.isEmpty()) {         validationException = addValidationError("no settings to update", validationException).     }     return validationException. }
false;public;0;4;;@Override public String[] indices() {     return indices. }
false;public;0;3;;public Settings settings() {     return settings. }
true;public;1;5;/**  * Sets the indices to apply to settings update to  */ ;/**  * Sets the indices to apply to settings update to  */ @Override public UpdateSettingsRequest indices(String... indices) {     this.indices = indices.     return this. }
false;public;0;4;;@Override public IndicesOptions indicesOptions() {     return indicesOptions. }
false;public;1;4;;public UpdateSettingsRequest indicesOptions(IndicesOptions indicesOptions) {     this.indicesOptions = indicesOptions.     return this. }
true;public;1;4;/**  * Sets the settings to be updated  */ ;/**  * Sets the settings to be updated  */ public UpdateSettingsRequest settings(Settings settings) {     this.settings = settings.     return this. }
true;public;1;4;/**  * Sets the settings to be updated  */ ;/**  * Sets the settings to be updated  */ public UpdateSettingsRequest settings(Settings.Builder settings) {     this.settings = settings.build().     return this. }
true;public;2;4;/**  * Sets the settings to be updated (either json or yaml format)  */ ;/**  * Sets the settings to be updated (either json or yaml format)  */ public UpdateSettingsRequest settings(String source, XContentType xContentType) {     this.settings = Settings.builder().loadFromSource(source, xContentType).build().     return this. }
true;public;0;3;/**  * Returns <code>true</code> iff the settings update should only add but not update settings. If the setting already exists  * it should not be overwritten by this update. The default is <code>false</code>  */ ;/**  * Returns <code>true</code> iff the settings update should only add but not update settings. If the setting already exists  * it should not be overwritten by this update. The default is <code>false</code>  */ public boolean isPreserveExisting() {     return preserveExisting. }
true;public;1;4;/**  * Iff set to <code>true</code> this settings update will only add settings not already set on an index. Existing settings remain  * unchanged.  */ ;/**  * Iff set to <code>true</code> this settings update will only add settings not already set on an index. Existing settings remain  * unchanged.  */ public UpdateSettingsRequest setPreserveExisting(boolean preserveExisting) {     this.preserveExisting = preserveExisting.     return this. }
true;public;1;10;/**  * Sets the settings to be updated (either json or yaml format)  */ ;/**  * Sets the settings to be updated (either json or yaml format)  */ public UpdateSettingsRequest settings(Map<String, ?> source) {     try {         XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON).         builder.map(source).         settings(Strings.toString(builder), builder.contentType()).     } catch (IOException e) {         throw new ElasticsearchGenerationException("Failed to generate [" + source + "]", e).     }     return this. }
false;public;1;8;;@Override public void readFrom(StreamInput in) throws IOException {     super.readFrom(in).     indices = in.readStringArray().     indicesOptions = IndicesOptions.readIndicesOptions(in).     settings = readSettingsFromStream(in).     preserveExisting = in.readBoolean(). }
false;public;1;8;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeStringArrayNullable(indices).     indicesOptions.writeIndicesOptions(out).     writeSettingsToStream(settings, out).     out.writeBoolean(preserveExisting). }
false;public;2;7;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     settings.toXContent(builder, params).     builder.endObject().     return builder. }
false;public;1;14;;public UpdateSettingsRequest fromXContent(XContentParser parser) throws IOException {     Map<String, Object> settings = new HashMap<>().     Map<String, Object> bodySettings = parser.map().     Object innerBodySettings = bodySettings.get("settings").     // clean up in case the body is wrapped with "settings" : { ... }     if (innerBodySettings instanceof Map) {         @SuppressWarnings("unchecked")         Map<String, Object> innerBodySettingsMap = (Map<String, Object>) innerBodySettings.         settings.putAll(innerBodySettingsMap).     } else {         settings.putAll(bodySettings).     }     return this.settings(settings). }
false;public;0;4;;@Override public String toString() {     return "indices : " + Arrays.toString(indices) + "," + Strings.toString(this). }
false;public;1;16;;@Override public boolean equals(Object o) {     if (this == o) {         return true.     }     if (o == null || getClass() != o.getClass()) {         return false.     }     UpdateSettingsRequest that = (UpdateSettingsRequest) o.     return masterNodeTimeout.equals(that.masterNodeTimeout) && timeout.equals(that.timeout) && Objects.equals(settings, that.settings) && Objects.equals(indicesOptions, that.indicesOptions) && Objects.equals(preserveExisting, that.preserveExisting) && Arrays.equals(indices, that.indices). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(masterNodeTimeout, timeout, settings, indicesOptions, preserveExisting, Arrays.hashCode(indices)). }
