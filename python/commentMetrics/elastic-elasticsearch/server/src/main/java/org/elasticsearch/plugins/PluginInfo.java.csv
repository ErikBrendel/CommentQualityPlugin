commented;modifiers;parameterAmount;loc;comment;code
false;public;1;22;;@Override public void writeTo(final StreamOutput out) throws IOException {     out.writeString(name).     out.writeString(description).     out.writeString(version).     if (out.getVersion().onOrAfter(Version.V_6_3_0)) {         Version.writeVersion(elasticsearchVersion, out).         out.writeString(javaVersion).     }     out.writeString(classname).     if (out.getVersion().onOrAfter(Version.V_6_2_0)) {         out.writeStringCollection(extendedPlugins).     }     out.writeBoolean(hasNativeController).     if (out.getVersion().onOrAfter(Version.V_6_0_0_beta2) && out.getVersion().before(Version.V_6_3_0)) {         /*              * Elasticsearch versions in [6.0.0-beta2, 6.3.0) allowed plugins to specify that they require the keystore and this was              * serialized into the plugin info. Therefore, we have to write out a value for this boolean.              */         out.writeBoolean(false).     } }
true;public,static;1;89;/**  * Reads the plugin descriptor file.  *  * @param path           the path to the root directory for the plugin  * @return the plugin info  * @throws IOException if an I/O exception occurred reading the plugin descriptor  */ ;/**  * Reads the plugin descriptor file.  *  * @param path           the path to the root directory for the plugin  * @return the plugin info  * @throws IOException if an I/O exception occurred reading the plugin descriptor  */ public static PluginInfo readFromProperties(final Path path) throws IOException {     final Path descriptor = path.resolve(ES_PLUGIN_PROPERTIES).     final Map<String, String> propsMap.     {         final Properties props = new Properties().         try (InputStream stream = Files.newInputStream(descriptor)) {             props.load(stream).         }         propsMap = props.stringPropertyNames().stream().collect(Collectors.toMap(Function.identity(), props::getProperty)).     }     final String name = propsMap.remove("name").     if (name == null || name.isEmpty()) {         throw new IllegalArgumentException("property [name] is missing in [" + descriptor + "]").     }     final String description = propsMap.remove("description").     if (description == null) {         throw new IllegalArgumentException("property [description] is missing for plugin [" + name + "]").     }     final String version = propsMap.remove("version").     if (version == null) {         throw new IllegalArgumentException("property [version] is missing for plugin [" + name + "]").     }     final String esVersionString = propsMap.remove("elasticsearch.version").     if (esVersionString == null) {         throw new IllegalArgumentException("property [elasticsearch.version] is missing for plugin [" + name + "]").     }     final Version esVersion = Version.fromString(esVersionString).     final String javaVersionString = propsMap.remove("java.version").     if (javaVersionString == null) {         throw new IllegalArgumentException("property [java.version] is missing for plugin [" + name + "]").     }     JarHell.checkVersionFormat(javaVersionString).     final String classname = propsMap.remove("classname").     if (classname == null) {         throw new IllegalArgumentException("property [classname] is missing for plugin [" + name + "]").     }     final String extendedString = propsMap.remove("extended.plugins").     final List<String> extendedPlugins.     if (extendedString == null) {         extendedPlugins = Collections.emptyList().     } else {         extendedPlugins = Arrays.asList(Strings.delimitedListToStringArray(extendedString, ",")).     }     final String hasNativeControllerValue = propsMap.remove("has.native.controller").     final boolean hasNativeController.     if (hasNativeControllerValue == null) {         hasNativeController = false.     } else {         switch(hasNativeControllerValue) {             case "true":                 hasNativeController = true.                 break.             case "false":                 hasNativeController = false.                 break.             default:                 final String message = String.format(Locale.ROOT, "property [%s] must be [%s], [%s], or unspecified but was [%s]", "has_native_controller", "true", "false", hasNativeControllerValue).                 throw new IllegalArgumentException(message).         }     }     if (esVersion.before(Version.V_6_3_0) && esVersion.onOrAfter(Version.V_6_0_0_beta2)) {         propsMap.remove("requires.keystore").     }     if (propsMap.isEmpty() == false) {         throw new IllegalArgumentException("Unknown properties in plugin descriptor: " + propsMap.keySet()).     }     return new PluginInfo(name, description, version, esVersion, javaVersionString, classname, extendedPlugins, hasNativeController). }
true;public;0;3;/**  * The name of the plugin.  *  * @return the plugin name  */ ;/**  * The name of the plugin.  *  * @return the plugin name  */ public String getName() {     return name. }
true;public;0;3;/**  * The description of the plugin.  *  * @return the plugin description  */ ;/**  * The description of the plugin.  *  * @return the plugin description  */ public String getDescription() {     return description. }
true;public;0;3;/**  * The entry point to the plugin.  *  * @return the entry point to the plugin  */ ;/**  * The entry point to the plugin.  *  * @return the entry point to the plugin  */ public String getClassname() {     return classname. }
true;public;0;3;/**  * Other plugins this plugin extends through SPI.  *  * @return the names of the plugins extended  */ ;/**  * Other plugins this plugin extends through SPI.  *  * @return the names of the plugins extended  */ public List<String> getExtendedPlugins() {     return extendedPlugins. }
true;public;0;3;/**  * The version of the plugin  *  * @return the version  */ ;/**  * The version of the plugin  *  * @return the version  */ public String getVersion() {     return version. }
true;public;0;3;/**  * The version of Elasticsearch the plugin was built for.  *  * @return an Elasticsearch version  */ ;/**  * The version of Elasticsearch the plugin was built for.  *  * @return an Elasticsearch version  */ public Version getElasticsearchVersion() {     return elasticsearchVersion. }
true;public;0;3;/**  * The version of Java the plugin was built with.  *  * @return a java version string  */ ;/**  * The version of Java the plugin was built with.  *  * @return a java version string  */ public String getJavaVersion() {     return javaVersion. }
true;public;0;3;/**  * Whether or not the plugin has a native controller.  *  * @return {@code true} if the plugin has a native controller  */ ;/**  * Whether or not the plugin has a native controller.  *  * @return {@code true} if the plugin has a native controller  */ public boolean hasNativeController() {     return hasNativeController. }
false;public;2;17;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     {         builder.field("name", name).         builder.field("version", version).         builder.field("elasticsearch_version", elasticsearchVersion).         builder.field("java_version", javaVersion).         builder.field("description", description).         builder.field("classname", classname).         builder.field("extended_plugins", extendedPlugins).         builder.field("has_native_controller", hasNativeController).     }     builder.endObject().     return builder. }
false;public;1;13;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     PluginInfo that = (PluginInfo) o.     if (!name.equals(that.name))         return false.     // TODO: since the plugins are unique by their directory name, this should only be a name check, version should not matter?     if (version != null ? !version.equals(that.version) : that.version != null)         return false.     return true. }
false;public;0;4;;@Override public int hashCode() {     return name.hashCode(). }
false;public;0;4;;@Override public String toString() {     return toString(""). }
false;public;1;13;;public String toString(String prefix) {     final StringBuilder information = new StringBuilder().append(prefix).append("- Plugin information:\n").append(prefix).append("Name: ").append(name).append("\n").append(prefix).append("Description: ").append(description).append("\n").append(prefix).append("Version: ").append(version).append("\n").append(prefix).append("Elasticsearch Version: ").append(elasticsearchVersion).append("\n").append(prefix).append("Java Version: ").append(javaVersion).append("\n").append(prefix).append("Native Controller: ").append(hasNativeController).append("\n").append(prefix).append("Extended Plugins: ").append(extendedPlugins).append("\n").append(prefix).append(" * Classname: ").append(classname).     return information.toString(). }
