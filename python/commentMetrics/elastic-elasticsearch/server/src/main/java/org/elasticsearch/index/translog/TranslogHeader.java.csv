commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public String getTranslogUUID() {     return translogUUID. }
true;public;0;3;/**  * Returns the primary term stored in this translog header.  * All operations in a translog file are expected to have their primary terms at most this term.  */ ;/**  * Returns the primary term stored in this translog header.  * All operations in a translog file are expected to have their primary terms at most this term.  */ public long getPrimaryTerm() {     return primaryTerm. }
true;public;0;3;/**  * Returns the header size in bytes. This value can be used as the offset of the first translog operation.  * See {@link BaseTranslogReader#getFirstOperationOffset()}  */ ;/**  * Returns the header size in bytes. This value can be used as the offset of the first translog operation.  * See {@link BaseTranslogReader#getFirstOperationOffset()}  */ public int sizeInBytes() {     return headerSizeInBytes. }
false;static;1;3;;static int headerSizeInBytes(String translogUUID) {     return headerSizeInBytes(CURRENT_VERSION, new BytesRef(translogUUID).length). }
false;private,static;2;9;;private static int headerSizeInBytes(int version, int uuidLength) {     int size = CodecUtil.headerLength(TRANSLOG_CODEC).     // uuid     size += Integer.BYTES + uuidLength.     if (version >= VERSION_PRIMARY_TERM) {         // primary term         size += Long.BYTES.         // checksum         size += Integer.BYTES.     }     return size. }
true;static;3;52;/**  * Read a translog header from the given path and file channel  */ ;/**  * Read a translog header from the given path and file channel  */ static TranslogHeader read(final String translogUUID, final Path path, final FileChannel channel) throws IOException {     // This input is intentionally not closed because closing it will close the FileChannel.     final BufferedChecksumStreamInput in = new BufferedChecksumStreamInput(new InputStreamStreamInput(java.nio.channels.Channels.newInputStream(channel), channel.size()), path.toString()).     final int version.     try {         version = CodecUtil.checkHeader(new InputStreamDataInput(in), TRANSLOG_CODEC, VERSION_CHECKSUMS, VERSION_PRIMARY_TERM).     } catch (CorruptIndexException | IndexFormatTooOldException | IndexFormatTooNewException e) {         tryReportOldVersionError(path, channel).         throw new TranslogCorruptedException(path.toString(), "translog header corrupted", e).     }     if (version == VERSION_CHECKSUMS) {         throw new IllegalStateException("pre-2.0 translog found [" + path + "]").     }     // Read the translogUUID     final int uuidLen = in.readInt().     if (uuidLen > channel.size()) {         throw new TranslogCorruptedException(path.toString(), "UUID length can't be larger than the translog").     }     final BytesRef uuid = new BytesRef(uuidLen).     uuid.length = uuidLen.     in.read(uuid.bytes, uuid.offset, uuid.length).     final BytesRef expectedUUID = new BytesRef(translogUUID).     if (uuid.bytesEquals(expectedUUID) == false) {         throw new TranslogCorruptedException(path.toString(), "expected shard UUID " + expectedUUID + " but got: " + uuid + " this translog file belongs to a different translog").     }     // Read the primary term     final long primaryTerm.     if (version == VERSION_PRIMARY_TERM) {         primaryTerm = in.readLong().     } else {         assert version == VERSION_CHECKPOINTS : "Unknown header version [" + version + "]".         primaryTerm = UNASSIGNED_PRIMARY_TERM.     }     // Verify the checksum     if (version >= VERSION_PRIMARY_TERM) {         Translog.verifyChecksum(in).     }     assert primaryTerm >= 0 : "Primary term must be non-negative [" + primaryTerm + "]. translog path [" + path + "]".     final int headerSizeInBytes = headerSizeInBytes(version, uuid.length).     assert channel.position() == headerSizeInBytes : "Header is not fully read. header size [" + headerSizeInBytes + "], position [" + channel.position() + "]".     return new TranslogHeader(translogUUID, primaryTerm, headerSizeInBytes). }
false;private,static;2;18;;private static void tryReportOldVersionError(final Path path, final FileChannel channel) throws IOException {     // Lucene's CodecUtil writes a magic number of 0x3FD76C17 with the header, in binary this looks like:     // binary: 0011 1111 1101 0111 0110 1100 0001 0111     // hex   :    3    f    d    7    6    c    1    7     //      // With version 0 of the translog, the first byte is the Operation.Type, which will always be between 0-4,     // so we know if we grab the first byte, it can be:     // 0x3f => Lucene's magic number, so we can assume it's version 1 or later     // 0x00 => version 0 of the translog     final byte b1 = Channels.readFromFileChannel(channel, 0, 1)[0].     if (b1 == 0x3f) {         // LUCENE_CODEC_HEADER_BYTE         throw new TranslogCorruptedException(path.toString(), "translog looks like version 1 or later, but has corrupted header").     } else if (b1 == 0x00) {         // UNVERSIONED_TRANSLOG_HEADER_BYTE         throw new IllegalStateException("pre-1.4 translog found [" + path + "]").     } }
true;;1;19;/**  * Writes this header with the latest format into the file channel  */ ;/**  * Writes this header with the latest format into the file channel  */ void write(final FileChannel channel) throws IOException {     // This output is intentionally not closed because closing it will close the FileChannel.     @SuppressWarnings({ "IOResourceOpenedButNotSafelyClosed", "resource" })     final BufferedChecksumStreamOutput out = new BufferedChecksumStreamOutput(new OutputStreamStreamOutput(java.nio.channels.Channels.newOutputStream(channel))).     CodecUtil.writeHeader(new OutputStreamDataOutput(out), TRANSLOG_CODEC, CURRENT_VERSION).     // Write uuid     final BytesRef uuid = new BytesRef(translogUUID).     out.writeInt(uuid.length).     out.writeBytes(uuid.bytes, uuid.offset, uuid.length).     // Write primary term     out.writeLong(primaryTerm).     // Checksum header     out.writeInt((int) out.getChecksum()).     out.flush().     channel.force(true).     assert channel.position() == headerSizeInBytes : "Header is not fully written. header size [" + headerSizeInBytes + "], channel position [" + channel.position() + "]". }
