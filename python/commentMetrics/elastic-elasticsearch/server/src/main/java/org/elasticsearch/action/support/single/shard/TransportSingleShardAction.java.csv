commented;modifiers;parameterAmount;loc;comment;code
true;protected;0;3;/**  * Tells whether the action is a main one or a subaction. Used to decide whether we need to register  * the main transport handler. In fact if the action is a subaction, its execute method  * will be called locally to its parent action.  */ ;/**  * Tells whether the action is a main one or a subaction. Used to decide whether we need to register  * the main transport handler. In fact if the action is a subaction, its execute method  * will be called locally to its parent action.  */ protected boolean isSubAction() {     return false. }
false;protected;3;4;;@Override protected void doExecute(Task task, Request request, ActionListener<Response> listener) {     new AsyncSingleAction(request, listener).start(). }
false;protected,abstract;2;1;;protected abstract Response shardOperation(Request request, ShardId shardId) throws IOException.
false;public;1;4;;@Override public void onFailure(Exception e) {     listener.onFailure(e). }
false;protected;0;4;;@Override protected void doRun() throws Exception {     listener.onResponse(shardOperation(request, shardId)). }
false;protected;3;13;;protected void asyncShardOperation(Request request, ShardId shardId, ActionListener<Response> listener) throws IOException {     threadPool.executor(getExecutor(request, shardId)).execute(new AbstractRunnable() {          @Override         public void onFailure(Exception e) {             listener.onFailure(e).         }          @Override         protected void doRun() throws Exception {             listener.onResponse(shardOperation(request, shardId)).         }     }). }
false;protected,abstract;0;1;;protected abstract Response newResponse().
false;protected,abstract;1;1;;protected abstract boolean resolveIndex(Request request).
false;protected;1;3;;protected ClusterBlockException checkGlobalBlock(ClusterState state) {     return state.blocks().globalBlockedException(ClusterBlockLevel.READ). }
false;protected;2;3;;protected ClusterBlockException checkRequestBlock(ClusterState state, InternalRequest request) {     return state.blocks().indexBlockedException(ClusterBlockLevel.READ, request.concreteIndex()). }
false;protected;2;3;;protected void resolveRequest(ClusterState state, InternalRequest request) { }
true;protected,abstract;2;2;/**  * Returns the candidate shards to execute the operation on or <code>null</code> the execute  * the operation locally (the node that received the request)  */ ;/**  * Returns the candidate shards to execute the operation on or <code>null</code> the execute  * the operation locally (the node that received the request)  */ @Nullable protected abstract ShardsIterator shards(ClusterState state, InternalRequest request).
false;public;1;6;;@Override public Response read(StreamInput in) throws IOException {     Response response = newResponse().     response.readFrom(in).     return response. }
false;public;0;4;;@Override public String executor() {     return ThreadPool.Names.SAME. }
false;public;1;4;;@Override public void handleResponse(final Response response) {     listener.onResponse(response). }
false;public;1;4;;@Override public void handleException(TransportException exp) {     listener.onFailure(exp). }
false;public;0;31;;public void start() {     if (shardIt == null) {         // just execute it on the local node         transportService.sendRequest(clusterService.localNode(), transportShardAction, internalRequest.request(), new TransportResponseHandler<Response>() {              @Override             public Response read(StreamInput in) throws IOException {                 Response response = newResponse().                 response.readFrom(in).                 return response.             }              @Override             public String executor() {                 return ThreadPool.Names.SAME.             }              @Override             public void handleResponse(final Response response) {                 listener.onResponse(response).             }              @Override             public void handleException(TransportException exp) {                 listener.onFailure(exp).             }         }).     } else {         perform(null).     } }
false;private;2;7;;private void onFailure(ShardRouting shardRouting, Exception e) {     if (e != null) {         logger.trace(() -> new ParameterizedMessage("{}: failed to execute [{}]", shardRouting, internalRequest.request()), e).     }     perform(e). }
false;public;1;6;;@Override public Response read(StreamInput in) throws IOException {     Response response = newResponse().     response.readFrom(in).     return response. }
false;public;0;4;;@Override public String executor() {     return ThreadPool.Names.SAME. }
false;public;1;4;;@Override public void handleResponse(final Response response) {     listener.onResponse(response). }
false;public;1;4;;@Override public void handleException(TransportException exp) {     onFailure(shardRouting, exp). }
false;private;1;59;;private void perform(@Nullable final Exception currentFailure) {     Exception lastFailure = this.lastFailure.     if (lastFailure == null || TransportActions.isReadOverrideException(currentFailure)) {         lastFailure = currentFailure.         this.lastFailure = currentFailure.     }     final ShardRouting shardRouting = shardIt.nextOrNull().     if (shardRouting == null) {         Exception failure = lastFailure.         if (failure == null || isShardNotAvailableException(failure)) {             failure = new NoShardAvailableActionException(null, LoggerMessageFormat.format("No shard available for [{}]", internalRequest.request()), failure).         } else {             logger.debug(() -> new ParameterizedMessage("{}: failed to execute [{}]", null, internalRequest.request()), failure).         }         listener.onFailure(failure).         return.     }     DiscoveryNode node = nodes.get(shardRouting.currentNodeId()).     if (node == null) {         onFailure(shardRouting, new NoShardAvailableActionException(shardRouting.shardId())).     } else {         internalRequest.request().internalShardId = shardRouting.shardId().         if (logger.isTraceEnabled()) {             logger.trace("sending request [{}] to shard [{}] on node [{}]", internalRequest.request(), internalRequest.request().internalShardId, node).         }         transportService.sendRequest(node, transportShardAction, internalRequest.request(), new TransportResponseHandler<Response>() {              @Override             public Response read(StreamInput in) throws IOException {                 Response response = newResponse().                 response.readFrom(in).                 return response.             }              @Override             public String executor() {                 return ThreadPool.Names.SAME.             }              @Override             public void handleResponse(final Response response) {                 listener.onResponse(response).             }              @Override             public void handleException(TransportException exp) {                 onFailure(shardRouting, exp).             }         }).     } }
false;public;3;5;;@Override public void messageReceived(Request request, final TransportChannel channel, Task task) throws Exception {     // if we have a local operation, execute it on a thread since we don't spawn     execute(request, new ChannelActionListener<>(channel, actionName, request)). }
false;public;3;7;;@Override public void messageReceived(final Request request, final TransportChannel channel, Task task) throws Exception {     if (logger.isTraceEnabled()) {         logger.trace("executing [{}] on shard [{}]", request, request.internalShardId).     }     asyncShardOperation(request, request.internalShardId, new ChannelActionListener<>(channel, transportShardAction, request)). }
false;public;0;3;;public Request request() {     return request. }
false;public;0;3;;public String concreteIndex() {     return concreteIndex. }
false;protected;2;3;;protected String getExecutor(Request request, ShardId shardId) {     return executor. }
