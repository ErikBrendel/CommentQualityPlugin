commented;modifiers;parameterAmount;loc;comment;code
false;static;1;177;;// /////////////////////////////////////// //  // end lenient formatters //  // /////////////////////////////////////// static DateFormatter forPattern(String input) {     if (Strings.hasLength(input)) {         input = input.trim().     }     if (input == null || input.length() == 0) {         throw new IllegalArgumentException("No date pattern provided").     }     if ("iso8601".equals(input)) {         return ISO_8601.     } else if ("basicDate".equals(input) || "basic_date".equals(input)) {         return BASIC_DATE.     } else if ("basicDateTime".equals(input) || "basic_date_time".equals(input)) {         return BASIC_DATE_TIME.     } else if ("basicDateTimeNoMillis".equals(input) || "basic_date_time_no_millis".equals(input)) {         return BASIC_DATE_TIME_NO_MILLIS.     } else if ("basicOrdinalDate".equals(input) || "basic_ordinal_date".equals(input)) {         return BASIC_ORDINAL_DATE.     } else if ("basicOrdinalDateTime".equals(input) || "basic_ordinal_date_time".equals(input)) {         return BASIC_ORDINAL_DATE_TIME.     } else if ("basicOrdinalDateTimeNoMillis".equals(input) || "basic_ordinal_date_time_no_millis".equals(input)) {         return BASIC_ORDINAL_DATE_TIME_NO_MILLIS.     } else if ("basicTime".equals(input) || "basic_time".equals(input)) {         return BASIC_TIME.     } else if ("basicTimeNoMillis".equals(input) || "basic_time_no_millis".equals(input)) {         return BASIC_TIME_NO_MILLIS.     } else if ("basicTTime".equals(input) || "basic_t_time".equals(input)) {         return BASIC_T_TIME.     } else if ("basicTTimeNoMillis".equals(input) || "basic_t_time_no_millis".equals(input)) {         return BASIC_T_TIME_NO_MILLIS.     } else if ("basicWeekDate".equals(input) || "basic_week_date".equals(input)) {         return BASIC_WEEK_DATE.     } else if ("basicWeekDateTime".equals(input) || "basic_week_date_time".equals(input)) {         return BASIC_WEEK_DATE_TIME.     } else if ("basicWeekDateTimeNoMillis".equals(input) || "basic_week_date_time_no_millis".equals(input)) {         return BASIC_WEEK_DATE_TIME_NO_MILLIS.     } else if ("date".equals(input)) {         return DATE.     } else if ("dateHour".equals(input) || "date_hour".equals(input)) {         return DATE_HOUR.     } else if ("dateHourMinute".equals(input) || "date_hour_minute".equals(input)) {         return DATE_HOUR_MINUTE.     } else if ("dateHourMinuteSecond".equals(input) || "date_hour_minute_second".equals(input)) {         return DATE_HOUR_MINUTE_SECOND.     } else if ("dateHourMinuteSecondFraction".equals(input) || "date_hour_minute_second_fraction".equals(input)) {         return DATE_HOUR_MINUTE_SECOND_FRACTION.     } else if ("dateHourMinuteSecondMillis".equals(input) || "date_hour_minute_second_millis".equals(input)) {         return DATE_HOUR_MINUTE_SECOND_MILLIS.     } else if ("dateOptionalTime".equals(input) || "date_optional_time".equals(input)) {         return DATE_OPTIONAL_TIME.     } else if ("dateTime".equals(input) || "date_time".equals(input)) {         return DATE_TIME.     } else if ("dateTimeNoMillis".equals(input) || "date_time_no_millis".equals(input)) {         return DATE_TIME_NO_MILLIS.     } else if ("hour".equals(input)) {         return HOUR.     } else if ("hourMinute".equals(input) || "hour_minute".equals(input)) {         return HOUR_MINUTE.     } else if ("hourMinuteSecond".equals(input) || "hour_minute_second".equals(input)) {         return HOUR_MINUTE_SECOND.     } else if ("hourMinuteSecondFraction".equals(input) || "hour_minute_second_fraction".equals(input)) {         return HOUR_MINUTE_SECOND_FRACTION.     } else if ("hourMinuteSecondMillis".equals(input) || "hour_minute_second_millis".equals(input)) {         return HOUR_MINUTE_SECOND_MILLIS.     } else if ("ordinalDate".equals(input) || "ordinal_date".equals(input)) {         return ORDINAL_DATE.     } else if ("ordinalDateTime".equals(input) || "ordinal_date_time".equals(input)) {         return ORDINAL_DATE_TIME.     } else if ("ordinalDateTimeNoMillis".equals(input) || "ordinal_date_time_no_millis".equals(input)) {         return ORDINAL_DATE_TIME_NO_MILLIS.     } else if ("time".equals(input)) {         return TIME.     } else if ("timeNoMillis".equals(input) || "time_no_millis".equals(input)) {         return TIME_NO_MILLIS.     } else if ("tTime".equals(input) || "t_time".equals(input)) {         return T_TIME.     } else if ("tTimeNoMillis".equals(input) || "t_time_no_millis".equals(input)) {         return T_TIME_NO_MILLIS.     } else if ("weekDate".equals(input) || "week_date".equals(input)) {         return WEEK_DATE.     } else if ("weekDateTime".equals(input) || "week_date_time".equals(input)) {         return WEEK_DATE_TIME.     } else if ("weekDateTimeNoMillis".equals(input) || "week_date_time_no_millis".equals(input)) {         return WEEK_DATE_TIME_NO_MILLIS.     } else if ("weekyear".equals(input) || "week_year".equals(input)) {         return WEEK_YEAR.     } else if ("weekyearWeek".equals(input) || "weekyear_week".equals(input)) {         return WEEKYEAR_WEEK.     } else if ("weekyearWeekDay".equals(input) || "weekyear_week_day".equals(input)) {         return WEEKYEAR_WEEK_DAY.     } else if ("year".equals(input)) {         return YEAR.     } else if ("yearMonth".equals(input) || "year_month".equals(input)) {         return YEAR_MONTH.     } else if ("yearMonthDay".equals(input) || "year_month_day".equals(input)) {         return YEAR_MONTH_DAY.     } else if ("epoch_second".equals(input)) {         return EpochTime.SECONDS_FORMATTER.     } else if ("epoch_millis".equals(input)) {         return EpochTime.MILLIS_FORMATTER.     // strict date formats here, must be at least 4 digits for year and two for months and two for day     } else if ("strictBasicWeekDate".equals(input) || "strict_basic_week_date".equals(input)) {         return STRICT_BASIC_WEEK_DATE.     } else if ("strictBasicWeekDateTime".equals(input) || "strict_basic_week_date_time".equals(input)) {         return STRICT_BASIC_WEEK_DATE_TIME.     } else if ("strictBasicWeekDateTimeNoMillis".equals(input) || "strict_basic_week_date_time_no_millis".equals(input)) {         return STRICT_BASIC_WEEK_DATE_TIME_NO_MILLIS.     } else if ("strictDate".equals(input) || "strict_date".equals(input)) {         return STRICT_DATE.     } else if ("strictDateHour".equals(input) || "strict_date_hour".equals(input)) {         return STRICT_DATE_HOUR.     } else if ("strictDateHourMinute".equals(input) || "strict_date_hour_minute".equals(input)) {         return STRICT_DATE_HOUR_MINUTE.     } else if ("strictDateHourMinuteSecond".equals(input) || "strict_date_hour_minute_second".equals(input)) {         return STRICT_DATE_HOUR_MINUTE_SECOND.     } else if ("strictDateHourMinuteSecondFraction".equals(input) || "strict_date_hour_minute_second_fraction".equals(input)) {         return STRICT_DATE_HOUR_MINUTE_SECOND_FRACTION.     } else if ("strictDateHourMinuteSecondMillis".equals(input) || "strict_date_hour_minute_second_millis".equals(input)) {         return STRICT_DATE_HOUR_MINUTE_SECOND_MILLIS.     } else if ("strictDateOptionalTime".equals(input) || "strict_date_optional_time".equals(input)) {         return STRICT_DATE_OPTIONAL_TIME.     } else if ("strictDateOptionalTimeNanos".equals(input) || "strict_date_optional_time_nanos".equals(input)) {         return STRICT_DATE_OPTIONAL_TIME_NANOS.     } else if ("strictDateTime".equals(input) || "strict_date_time".equals(input)) {         return STRICT_DATE_TIME.     } else if ("strictDateTimeNoMillis".equals(input) || "strict_date_time_no_millis".equals(input)) {         return STRICT_DATE_TIME_NO_MILLIS.     } else if ("strictHour".equals(input) || "strict_hour".equals(input)) {         return STRICT_HOUR.     } else if ("strictHourMinute".equals(input) || "strict_hour_minute".equals(input)) {         return STRICT_HOUR_MINUTE.     } else if ("strictHourMinuteSecond".equals(input) || "strict_hour_minute_second".equals(input)) {         return STRICT_HOUR_MINUTE_SECOND.     } else if ("strictHourMinuteSecondFraction".equals(input) || "strict_hour_minute_second_fraction".equals(input)) {         return STRICT_HOUR_MINUTE_SECOND_FRACTION.     } else if ("strictHourMinuteSecondMillis".equals(input) || "strict_hour_minute_second_millis".equals(input)) {         return STRICT_HOUR_MINUTE_SECOND_MILLIS.     } else if ("strictOrdinalDate".equals(input) || "strict_ordinal_date".equals(input)) {         return STRICT_ORDINAL_DATE.     } else if ("strictOrdinalDateTime".equals(input) || "strict_ordinal_date_time".equals(input)) {         return STRICT_ORDINAL_DATE_TIME.     } else if ("strictOrdinalDateTimeNoMillis".equals(input) || "strict_ordinal_date_time_no_millis".equals(input)) {         return STRICT_ORDINAL_DATE_TIME_NO_MILLIS.     } else if ("strictTime".equals(input) || "strict_time".equals(input)) {         return STRICT_TIME.     } else if ("strictTimeNoMillis".equals(input) || "strict_time_no_millis".equals(input)) {         return STRICT_TIME_NO_MILLIS.     } else if ("strictTTime".equals(input) || "strict_t_time".equals(input)) {         return STRICT_T_TIME.     } else if ("strictTTimeNoMillis".equals(input) || "strict_t_time_no_millis".equals(input)) {         return STRICT_T_TIME_NO_MILLIS.     } else if ("strictWeekDate".equals(input) || "strict_week_date".equals(input)) {         return STRICT_WEEK_DATE.     } else if ("strictWeekDateTime".equals(input) || "strict_week_date_time".equals(input)) {         return STRICT_WEEK_DATE_TIME.     } else if ("strictWeekDateTimeNoMillis".equals(input) || "strict_week_date_time_no_millis".equals(input)) {         return STRICT_WEEK_DATE_TIME_NO_MILLIS.     } else if ("strictWeekyear".equals(input) || "strict_weekyear".equals(input)) {         return STRICT_WEEKYEAR.     } else if ("strictWeekyearWeek".equals(input) || "strict_weekyear_week".equals(input)) {         return STRICT_WEEKYEAR_WEEK.     } else if ("strictWeekyearWeekDay".equals(input) || "strict_weekyear_week_day".equals(input)) {         return STRICT_WEEKYEAR_WEEK_DAY.     } else if ("strictYear".equals(input) || "strict_year".equals(input)) {         return STRICT_YEAR.     } else if ("strictYearMonth".equals(input) || "strict_year_month".equals(input)) {         return STRICT_YEAR_MONTH.     } else if ("strictYearMonthDay".equals(input) || "strict_year_month_day".equals(input)) {         return STRICT_YEAR_MONTH_DAY.     } else {         try {             return new JavaDateFormatter(input, new DateTimeFormatterBuilder().appendPattern(input).toFormatter(Locale.ROOT)).         } catch (IllegalArgumentException e) {             throw new IllegalArgumentException("Invalid format: [" + input + "]: " + e.getMessage(), e).         }     } }
false;static;2;20;;static JavaDateFormatter merge(String pattern, List<DateFormatter> formatters) {     assert formatters.size() > 0.     List<DateTimeFormatter> dateTimeFormatters = new ArrayList<>(formatters.size()).     DateTimeFormatterBuilder roundupBuilder = new DateTimeFormatterBuilder().     DateTimeFormatter printer = null.     for (DateFormatter formatter : formatters) {         assert formatter instanceof JavaDateFormatter.         JavaDateFormatter javaDateFormatter = (JavaDateFormatter) formatter.         if (printer == null) {             printer = javaDateFormatter.getPrinter().         }         dateTimeFormatters.add(javaDateFormatter.getParser()).         roundupBuilder.appendOptional(javaDateFormatter.getRoundupParser()).     }     DateTimeFormatter roundUpParser = roundupBuilder.toFormatter(Locale.ROOT).     return new JavaDateFormatter(pattern, printer, builder -> builder.append(roundUpParser), dateTimeFormatters.toArray(new DateTimeFormatter[0])). }
true;public,static;1;51;/**  * Convert a temporal accessor to a zoned date time object - as performant as possible.  * The .from() methods from the JDK are throwing exceptions when for example ZonedDateTime.from(accessor)  * or Instant.from(accessor). This results in a huge performance penalty and should be prevented  * This method prevents exceptions by querying the accessor for certain capabilities  * and then act on it accordingly  *  * This action assumes that we can reliably fall back to some defaults if not all parts of a  * zoned date time are set  *  * - If a zoned date time is passed, it is returned  * - If no timezone is found, ZoneOffset.UTC is used  * - If we find a time and a date, converting to a ZonedDateTime is straight forward,  *   no defaults will be applied  * - If an accessor only containing of seconds and nanos is found (like epoch_millis/second)  *   an Instant is created out of that, that becomes a ZonedDateTime with a time zone  * - If no time is given, the start of the day is used  * - If no month of the year is found, the first day of the year is used  * - If an iso based weekyear is found, but not week is specified, the first monday  *   of the new year is chosen (reataining BWC to joda time)  * - If an iso based weekyear is found and an iso based weekyear week, the start  *   of the day is used  *  * @param accessor The accessor returned from a parser  *  * @return The converted zoned date time  */ ;/**  * Convert a temporal accessor to a zoned date time object - as performant as possible.  * The .from() methods from the JDK are throwing exceptions when for example ZonedDateTime.from(accessor)  * or Instant.from(accessor). This results in a huge performance penalty and should be prevented  * This method prevents exceptions by querying the accessor for certain capabilities  * and then act on it accordingly  *  * This action assumes that we can reliably fall back to some defaults if not all parts of a  * zoned date time are set  *  * - If a zoned date time is passed, it is returned  * - If no timezone is found, ZoneOffset.UTC is used  * - If we find a time and a date, converting to a ZonedDateTime is straight forward,  *   no defaults will be applied  * - If an accessor only containing of seconds and nanos is found (like epoch_millis/second)  *   an Instant is created out of that, that becomes a ZonedDateTime with a time zone  * - If no time is given, the start of the day is used  * - If no month of the year is found, the first day of the year is used  * - If an iso based weekyear is found, but not week is specified, the first monday  *   of the new year is chosen (reataining BWC to joda time)  * - If an iso based weekyear is found and an iso based weekyear week, the start  *   of the day is used  *  * @param accessor The accessor returned from a parser  *  * @return The converted zoned date time  */ public static ZonedDateTime from(TemporalAccessor accessor) {     if (accessor instanceof ZonedDateTime) {         return (ZonedDateTime) accessor.     }     ZoneId zoneId = accessor.query(TemporalQueries.zone()).     if (zoneId == null) {         zoneId = ZoneOffset.UTC.     }     LocalDate localDate = accessor.query(TemporalQueries.localDate()).     LocalTime localTime = accessor.query(TemporalQueries.localTime()).     boolean isLocalDateSet = localDate != null.     boolean isLocalTimeSet = localTime != null.     // the first two cases are the most common, so this allows us to exit early when parsing dates     if (isLocalDateSet && isLocalTimeSet) {         return of(localDate, localTime, zoneId).     } else if (accessor.isSupported(ChronoField.INSTANT_SECONDS) && accessor.isSupported(NANO_OF_SECOND)) {         return Instant.from(accessor).atZone(zoneId).     } else if (isLocalDateSet) {         return localDate.atStartOfDay(zoneId).     } else if (isLocalTimeSet) {         return of(getLocaldate(accessor), localTime, zoneId).     } else if (accessor.isSupported(ChronoField.YEAR)) {         if (accessor.isSupported(MONTH_OF_YEAR)) {             return getFirstOfMonth(accessor).atStartOfDay(zoneId).         } else {             return Year.of(accessor.get(ChronoField.YEAR)).atDay(1).atStartOfDay(zoneId).         }     } else if (accessor.isSupported(MONTH_OF_YEAR)) {         // missing year, falling back to the epoch and then filling         return getLocaldate(accessor).atStartOfDay(zoneId).     } else if (accessor.isSupported(WeekFields.ISO.weekBasedYear())) {         if (accessor.isSupported(WeekFields.ISO.weekOfWeekBasedYear())) {             return Year.of(accessor.get(WeekFields.ISO.weekBasedYear())).atDay(1).with(WeekFields.ISO.weekOfWeekBasedYear(), accessor.getLong(WeekFields.ISO.weekOfWeekBasedYear())).atStartOfDay(zoneId).         } else {             return Year.of(accessor.get(WeekFields.ISO.weekBasedYear())).atDay(1).with(TemporalAdjusters.firstInMonth(DayOfWeek.MONDAY)).atStartOfDay(zoneId).         }     }     // convert to a zoned date time! If not, we have to extend the above methods     throw new IllegalArgumentException("temporal accessor [" + accessor + "] cannot be converted to zoned date time"). }
false;private,static;1;11;;private static LocalDate getLocaldate(TemporalAccessor accessor) {     if (accessor.isSupported(MONTH_OF_YEAR)) {         if (accessor.isSupported(DAY_OF_MONTH)) {             return LocalDate.of(1970, accessor.get(MONTH_OF_YEAR), accessor.get(DAY_OF_MONTH)).         } else {             return LocalDate.of(1970, accessor.get(MONTH_OF_YEAR), 1).         }     }     return LOCALDATE_EPOCH. }
false;private,static;3;4;;@SuppressForbidden(reason = "ZonedDateTime.of is fine here") private static ZonedDateTime of(LocalDate localDate, LocalTime localTime, ZoneId zoneId) {     return ZonedDateTime.of(localDate, localTime, zoneId). }
false;private,static;1;4;;@SuppressForbidden(reason = "LocalDate.of is fine here") private static LocalDate getFirstOfMonth(TemporalAccessor accessor) {     return LocalDate.of(accessor.get(ChronoField.YEAR), accessor.get(MONTH_OF_YEAR), 1). }
