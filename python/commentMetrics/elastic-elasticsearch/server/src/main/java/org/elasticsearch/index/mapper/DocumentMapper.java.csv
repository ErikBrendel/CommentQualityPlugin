commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;public Builder meta(Map<String, Object> meta) {     this.meta = meta.     return this. }
false;public;1;5;;public Builder put(MetadataFieldMapper.Builder<?, ?> mapper) {     MetadataFieldMapper metadataMapper = mapper.build(builderContext).     metadataMappers.put(metadataMapper.getClass(), metadataMapper).     return this. }
false;public;1;9;;public DocumentMapper build(MapperService mapperService) {     Objects.requireNonNull(rootObjectMapper, "Mapper builder must have the root object mapper set").     Mapping mapping = new Mapping(mapperService.getIndexSettings().getIndexVersionCreated(), rootObjectMapper, metadataMappers.values().toArray(new MetadataFieldMapper[metadataMappers.values().size()]), meta).     return new DocumentMapper(mapperService, mapping). }
false;public;0;3;;public Mapping mapping() {     return mapping. }
false;public;0;3;;public String type() {     return this.type. }
false;public;0;3;;public Text typeText() {     return this.typeText. }
false;public;0;3;;public Map<String, Object> meta() {     return mapping.meta. }
false;public;0;3;;public CompressedXContent mappingSource() {     return this.mappingSource. }
false;public;0;3;;public RootObjectMapper root() {     return mapping.root. }
false;public;1;3;;public <T extends MetadataFieldMapper> T metadataMapper(Class<T> type) {     return mapping.metadataMapper(type). }
false;public;0;3;;public IndexFieldMapper indexMapper() {     return metadataMapper(IndexFieldMapper.class). }
false;public;0;3;;public TypeFieldMapper typeMapper() {     return metadataMapper(TypeFieldMapper.class). }
false;public;0;3;;public SourceFieldMapper sourceMapper() {     return metadataMapper(SourceFieldMapper.class). }
false;public;0;3;;public IdFieldMapper idFieldMapper() {     return metadataMapper(IdFieldMapper.class). }
false;public;0;3;;public RoutingFieldMapper routingFieldMapper() {     return metadataMapper(RoutingFieldMapper.class). }
false;public;0;3;;public IndexFieldMapper IndexFieldMapper() {     return metadataMapper(IndexFieldMapper.class). }
false;public;1;3;;public Query typeFilter(QueryShardContext context) {     return typeMapper().fieldType().termQuery(type, context). }
false;public;0;3;;public boolean hasNestedObjects() {     return hasNestedObjects. }
false;public;0;3;;public DocumentFieldMappers mappers() {     return this.fieldMappers. }
false;public;0;3;;public Map<String, ObjectMapper> objectMappers() {     return this.objectMappers. }
false;public;1;3;;public ParsedDocument parse(SourceToParse source) throws MapperParsingException {     return documentParser.parseDocument(source, mapping.metadataMappers). }
false;public;3;4;;public ParsedDocument createDeleteTombstoneDoc(String index, String type, String id) throws MapperParsingException {     final SourceToParse emptySource = new SourceToParse(index, type, id, new BytesArray("{}"), XContentType.JSON).     return documentParser.parseDocument(emptySource, deleteTombstoneMetadataFieldMappers).toTombstone(). }
false;public;2;9;;public ParsedDocument createNoopTombstoneDoc(String index, String reason) throws MapperParsingException {     // _id won't be used.     final String id = "".     final SourceToParse sourceToParse = new SourceToParse(index, type, id, new BytesArray("{}"), XContentType.JSON).     final ParsedDocument parsedDoc = documentParser.parseDocument(sourceToParse, noopTombstoneMetadataFieldMappers).toTombstone().     // Store the reason of a noop as a raw string in the _source field     final BytesRef byteRef = new BytesRef(reason).     parsedDoc.rootDoc().add(new StoredField(SourceFieldMapper.NAME, byteRef.bytes, byteRef.offset, byteRef.length)).     return parsedDoc. }
true;public;3;31;/**  * Returns the best nested {@link ObjectMapper} instances that is in the scope of the specified nested docId.  */ ;/**  * Returns the best nested {@link ObjectMapper} instances that is in the scope of the specified nested docId.  */ public ObjectMapper findNestedObjectMapper(int nestedDocId, SearchContext sc, LeafReaderContext context) throws IOException {     ObjectMapper nestedObjectMapper = null.     for (ObjectMapper objectMapper : objectMappers().values()) {         if (!objectMapper.nested().isNested()) {             continue.         }         Query filter = objectMapper.nestedTypeFilter().         if (filter == null) {             continue.         }         // We can pass down 'null' as acceptedDocs, because nestedDocId is a doc to be fetched and         // therefor is guaranteed to be a live doc.         final Weight nestedWeight = filter.createWeight(sc.searcher(), ScoreMode.COMPLETE_NO_SCORES, 1f).         Scorer scorer = nestedWeight.scorer(context).         if (scorer == null) {             continue.         }         if (scorer.iterator().advance(nestedDocId) == nestedDocId) {             if (nestedObjectMapper == null) {                 nestedObjectMapper = objectMapper.             } else {                 if (nestedObjectMapper.fullPath().length() < objectMapper.fullPath().length()) {                     nestedObjectMapper = objectMapper.                 }             }         }     }     return nestedObjectMapper. }
false;public;1;4;;public DocumentMapper merge(Mapping mapping) {     Mapping merged = this.mapping.merge(mapping).     return new DocumentMapper(mapperService, merged). }
true;public;1;9;/**  * Recursively update sub field types.  */ ;/**  * Recursively update sub field types.  */ public DocumentMapper updateFieldType(Map<String, MappedFieldType> fullNameToFieldType) {     Mapping updated = this.mapping.updateFieldType(fullNameToFieldType).     if (updated == this.mapping) {         // no change         return this.     }     assert updated == updated.updateFieldType(fullNameToFieldType) : "updateFieldType operation is not idempotent".     return new DocumentMapper(mapperService, updated). }
false;public;2;4;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     return mapping.toXContent(builder, params). }
