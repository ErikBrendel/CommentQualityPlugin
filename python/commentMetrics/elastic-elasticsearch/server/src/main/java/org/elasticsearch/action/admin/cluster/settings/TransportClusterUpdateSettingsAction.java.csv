commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected String executor() {     return ThreadPool.Names.SAME. }
false;protected;2;15;;@Override protected ClusterBlockException checkBlock(ClusterUpdateSettingsRequest request, ClusterState state) {     // allow for dedicated changes to the metadata blocks, so we don't block those to allow to "re-enable" it     if (request.transientSettings().size() + request.persistentSettings().size() == 1) {         // only one setting         if (MetaData.SETTING_READ_ONLY_SETTING.exists(request.persistentSettings()) || MetaData.SETTING_READ_ONLY_SETTING.exists(request.transientSettings()) || MetaData.SETTING_READ_ONLY_ALLOW_DELETE_SETTING.exists(request.transientSettings()) || MetaData.SETTING_READ_ONLY_ALLOW_DELETE_SETTING.exists(request.persistentSettings())) {             // one of the settings above as the only setting in the request means - resetting the block!             return null.         }     }     return state.blocks().globalBlockedException(ClusterBlockLevel.METADATA_WRITE). }
false;protected;0;4;;@Override protected ClusterUpdateSettingsResponse newResponse() {     return new ClusterUpdateSettingsResponse(). }
false;protected;1;4;;@Override protected ClusterUpdateSettingsResponse newResponse(boolean acknowledged) {     return new ClusterUpdateSettingsResponse(acknowledged, updater.getTransientUpdates(), updater.getPersistentUpdate()). }
false;public;1;8;;@Override public void onAllNodesAcked(@Nullable Exception e) {     if (changed) {         reroute(true).     } else {         super.onAllNodesAcked(e).     } }
false;public;0;8;;@Override public void onAckTimeout() {     if (changed) {         reroute(false).     } else {         super.onAckTimeout().     } }
false;public;1;5;;@Override public boolean mustAck(DiscoveryNode discoveryNode) {     // we wait for the reroute ack only if the update settings was acknowledged     return updateSettingsAcked. }
false;protected;1;7;;@Override protected // update settings was acknowledged ClusterUpdateSettingsResponse newResponse(boolean acknowledged) {     return new ClusterUpdateSettingsResponse(updateSettingsAcked && acknowledged, updater.getTransientUpdates(), updater.getPersistentUpdate()). }
false;public;1;6;;@Override public void onNoLongerMaster(String source) {     logger.debug("failed to preform reroute after cluster settings were updated - current node is no longer a master").     listener.onResponse(new ClusterUpdateSettingsResponse(updateSettingsAcked, updater.getTransientUpdates(), updater.getPersistentUpdate())). }
false;public;2;6;;@Override public void onFailure(String source, Exception e) {     // if the reroute fails we only log     logger.debug(() -> new ParameterizedMessage("failed to perform [{}]", source), e).     listener.onFailure(new ElasticsearchException("reroute after update settings failed", e)). }
false;public;1;5;;@Override public ClusterState execute(final ClusterState currentState) {     // now, reroute in case things that require it changed (e.g. number of replicas)     return allocationService.reroute(currentState, "reroute after cluster update settings"). }
false;private;1;53;;private void reroute(final boolean updateSettingsAcked) {     // so we should *not* execute the reroute.     if (!clusterService.state().nodes().isLocalNodeElectedMaster()) {         logger.debug("Skipping reroute after cluster update settings, because node is no longer master").         listener.onResponse(new ClusterUpdateSettingsResponse(updateSettingsAcked, updater.getTransientUpdates(), updater.getPersistentUpdate())).         return.     }     // The reason the reroute needs to be send as separate update task, is that all the *cluster* settings are encapsulate     // in the components (e.g. FilterAllocationDecider), so the changes made by the first call aren't visible     // to the components until the ClusterStateListener instances have been invoked, but are visible after     // the first update task has been completed.     clusterService.submitStateUpdateTask("reroute_after_cluster_update_settings", new AckedClusterStateUpdateTask<ClusterUpdateSettingsResponse>(Priority.URGENT, request, listener) {          @Override         public boolean mustAck(DiscoveryNode discoveryNode) {             // we wait for the reroute ack only if the update settings was acknowledged             return updateSettingsAcked.         }          @Override         protected // update settings was acknowledged         ClusterUpdateSettingsResponse newResponse(boolean acknowledged) {             return new ClusterUpdateSettingsResponse(updateSettingsAcked && acknowledged, updater.getTransientUpdates(), updater.getPersistentUpdate()).         }          @Override         public void onNoLongerMaster(String source) {             logger.debug("failed to preform reroute after cluster settings were updated - current node is no longer a master").             listener.onResponse(new ClusterUpdateSettingsResponse(updateSettingsAcked, updater.getTransientUpdates(), updater.getPersistentUpdate())).         }          @Override         public void onFailure(String source, Exception e) {             // if the reroute fails we only log             logger.debug(() -> new ParameterizedMessage("failed to perform [{}]", source), e).             listener.onFailure(new ElasticsearchException("reroute after update settings failed", e)).         }          @Override         public ClusterState execute(final ClusterState currentState) {             // now, reroute in case things that require it changed (e.g. number of replicas)             return allocationService.reroute(currentState, "reroute after cluster update settings").         }     }). }
false;public;2;5;;@Override public void onFailure(String source, Exception e) {     logger.debug(() -> new ParameterizedMessage("failed to perform [{}]", source), e).     super.onFailure(source, e). }
false;public;1;11;;@Override public ClusterState execute(final ClusterState currentState) {     final ClusterState clusterState = updater.updateSettings(currentState, clusterSettings.upgradeSettings(request.transientSettings()), clusterSettings.upgradeSettings(request.persistentSettings()), logger).     changed = clusterState != currentState.     return clusterState. }
false;protected;3;105;;@Override protected void masterOperation(final ClusterUpdateSettingsRequest request, final ClusterState state, final ActionListener<ClusterUpdateSettingsResponse> listener) {     final SettingsUpdater updater = new SettingsUpdater(clusterSettings).     clusterService.submitStateUpdateTask("cluster_update_settings", new AckedClusterStateUpdateTask<ClusterUpdateSettingsResponse>(Priority.IMMEDIATE, request, listener) {          private volatile boolean changed = false.          @Override         protected ClusterUpdateSettingsResponse newResponse(boolean acknowledged) {             return new ClusterUpdateSettingsResponse(acknowledged, updater.getTransientUpdates(), updater.getPersistentUpdate()).         }          @Override         public void onAllNodesAcked(@Nullable Exception e) {             if (changed) {                 reroute(true).             } else {                 super.onAllNodesAcked(e).             }         }          @Override         public void onAckTimeout() {             if (changed) {                 reroute(false).             } else {                 super.onAckTimeout().             }         }          private void reroute(final boolean updateSettingsAcked) {             // so we should *not* execute the reroute.             if (!clusterService.state().nodes().isLocalNodeElectedMaster()) {                 logger.debug("Skipping reroute after cluster update settings, because node is no longer master").                 listener.onResponse(new ClusterUpdateSettingsResponse(updateSettingsAcked, updater.getTransientUpdates(), updater.getPersistentUpdate())).                 return.             }             // The reason the reroute needs to be send as separate update task, is that all the *cluster* settings are encapsulate             // in the components (e.g. FilterAllocationDecider), so the changes made by the first call aren't visible             // to the components until the ClusterStateListener instances have been invoked, but are visible after             // the first update task has been completed.             clusterService.submitStateUpdateTask("reroute_after_cluster_update_settings", new AckedClusterStateUpdateTask<ClusterUpdateSettingsResponse>(Priority.URGENT, request, listener) {                  @Override                 public boolean mustAck(DiscoveryNode discoveryNode) {                     // we wait for the reroute ack only if the update settings was acknowledged                     return updateSettingsAcked.                 }                  @Override                 protected // update settings was acknowledged                 ClusterUpdateSettingsResponse newResponse(boolean acknowledged) {                     return new ClusterUpdateSettingsResponse(updateSettingsAcked && acknowledged, updater.getTransientUpdates(), updater.getPersistentUpdate()).                 }                  @Override                 public void onNoLongerMaster(String source) {                     logger.debug("failed to preform reroute after cluster settings were updated - current node is no longer a master").                     listener.onResponse(new ClusterUpdateSettingsResponse(updateSettingsAcked, updater.getTransientUpdates(), updater.getPersistentUpdate())).                 }                  @Override                 public void onFailure(String source, Exception e) {                     // if the reroute fails we only log                     logger.debug(() -> new ParameterizedMessage("failed to perform [{}]", source), e).                     listener.onFailure(new ElasticsearchException("reroute after update settings failed", e)).                 }                  @Override                 public ClusterState execute(final ClusterState currentState) {                     // now, reroute in case things that require it changed (e.g. number of replicas)                     return allocationService.reroute(currentState, "reroute after cluster update settings").                 }             }).         }          @Override         public void onFailure(String source, Exception e) {             logger.debug(() -> new ParameterizedMessage("failed to perform [{}]", source), e).             super.onFailure(source, e).         }          @Override         public ClusterState execute(final ClusterState currentState) {             final ClusterState clusterState = updater.updateSettings(currentState, clusterSettings.upgradeSettings(request.transientSettings()), clusterSettings.upgradeSettings(request.persistentSettings()), logger).             changed = clusterState != currentState.             return clusterState.         }     }). }
