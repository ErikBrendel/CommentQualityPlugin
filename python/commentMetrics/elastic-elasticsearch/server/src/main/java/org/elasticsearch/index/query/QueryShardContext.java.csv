commented;modifiers;parameterAmount;loc;comment;code
false;public;1;3;;public void setTypes(String... types) {     this.types = types. }
false;public;0;3;;public String[] getTypes() {     return types. }
false;private;0;6;;private void reset() {     allowUnmappedFields = indexSettings.isDefaultAllowUnmappedFields().     this.lookup = null.     this.namedQueries.clear().     this.nestedScope = new NestedScope(). }
false;public;0;3;;public IndexAnalyzers getIndexAnalyzers() {     return mapperService.getIndexAnalyzers(). }
false;public;0;3;;public Similarity getSearchSimilarity() {     return similarityService != null ? similarityService.similarity(mapperService) : null. }
false;public;0;3;;public List<String> defaultFields() {     return indexSettings.getDefaultFields(). }
false;public;0;3;;public boolean queryStringLenient() {     return indexSettings.isQueryStringLenient(). }
false;public;0;3;;public boolean queryStringAnalyzeWildcard() {     return indexSettings.isQueryStringAnalyzeWildcard(). }
false;public;0;3;;public boolean queryStringAllowLeadingWildcard() {     return indexSettings.isQueryStringAllowLeadingWildcard(). }
false;public;1;3;;public BitSetProducer bitsetFilter(Query filter) {     return bitsetFilterCache.getBitSetProducer(filter). }
false;public;1;3;;public <IFD extends IndexFieldData<?>> IFD getForField(MappedFieldType fieldType) {     return (IFD) indexFieldDataService.apply(fieldType, fullyQualifiedIndex.getName()). }
false;public;2;5;;public void addNamedQuery(String name, Query query) {     if (query != null) {         namedQueries.put(name, query).     } }
false;public;0;4;;public Map<String, Query> copyNamedQueries() {     // This might be a good use case for CopyOnWriteHashMap     return unmodifiableMap(new HashMap<>(namedQueries)). }
true;public;1;3;/**  * Returns all the fields that match a given pattern. If prefixed with a  * type then the fields will be returned with a type prefix.  */ ;/**  * Returns all the fields that match a given pattern. If prefixed with a  * type then the fields will be returned with a type prefix.  */ public Collection<String> simpleMatchToIndexNames(String pattern) {     return mapperService.simpleMatchToFullName(pattern). }
false;public;1;6;;public MappedFieldType fieldMapper(String name) {     if (name.equals(TypeFieldMapper.NAME)) {         deprecationLogger.deprecatedAndMaybeLog("query_with_types", TYPES_DEPRECATION_MESSAGE).     }     return failIfFieldMappingNotFound(name, mapperService.fullName(name)). }
false;public;1;3;;public ObjectMapper getObjectMapper(String name) {     return mapperService.getObjectMapper(name). }
true;public;1;3;/**  * Returns s {@link DocumentMapper} instance for the given type.  * Delegates to {@link MapperService#documentMapper(String)}  */ ;/**  * Returns s {@link DocumentMapper} instance for the given type.  * Delegates to {@link MapperService#documentMapper(String)}  */ public DocumentMapper documentMapper(String type) {     return mapperService.documentMapper(type). }
true;public;1;6;/**  * Gets the search analyzer for the given field, or the default if there is none present for the field  * TODO: remove this by moving defaults into mappers themselves  */ ;/**  * Gets the search analyzer for the given field, or the default if there is none present for the field  * TODO: remove this by moving defaults into mappers themselves  */ public Analyzer getSearchAnalyzer(MappedFieldType fieldType) {     if (fieldType.searchAnalyzer() != null) {         return fieldType.searchAnalyzer().     }     return getMapperService().searchAnalyzer(). }
true;public;1;6;/**  * Gets the search quote analyzer for the given field, or the default if there is none present for the field  * TODO: remove this by moving defaults into mappers themselves  */ ;/**  * Gets the search quote analyzer for the given field, or the default if there is none present for the field  * TODO: remove this by moving defaults into mappers themselves  */ public Analyzer getSearchQuoteAnalyzer(MappedFieldType fieldType) {     if (fieldType.searchQuoteAnalyzer() != null) {         return fieldType.searchQuoteAnalyzer().     }     return getMapperService().searchQuoteAnalyzer(). }
false;public;1;3;;public void setAllowUnmappedFields(boolean allowUnmappedFields) {     this.allowUnmappedFields = allowUnmappedFields. }
false;public;1;3;;public void setMapUnmappedFieldAsString(boolean mapUnmappedFieldAsString) {     this.mapUnmappedFieldAsString = mapUnmappedFieldAsString. }
false;;2;10;;MappedFieldType failIfFieldMappingNotFound(String name, MappedFieldType fieldMapping) {     if (fieldMapping != null || allowUnmappedFields) {         return fieldMapping.     } else if (mapUnmappedFieldAsString) {         TextFieldMapper.Builder builder = new TextFieldMapper.Builder(name).         return builder.build(new Mapper.BuilderContext(indexSettings.getSettings(), new ContentPath(1))).fieldType().     } else {         throw new QueryShardException(this, "No field mapping can be found for the field with name [{}]", name).     } }
true;public;0;8;/**  * Returns the narrowed down explicit types, or, if not set, all types.  */ ;/**  * Returns the narrowed down explicit types, or, if not set, all types.  */ public Collection<String> queryTypes() {     String[] types = getTypes().     if (types == null || types.length == 0 || (types.length == 1 && types[0].equals("_all"))) {         DocumentMapper mapper = getMapperService().documentMapper().         return mapper == null ? Collections.emptyList() : Collections.singleton(mapper.type()).     }     return Arrays.asList(types). }
false;public;0;7;;public SearchLookup lookup() {     if (lookup == null) {         lookup = new SearchLookup(getMapperService(), mappedFieldType -> indexFieldDataService.apply(mappedFieldType, fullyQualifiedIndex.getName()), types).     }     return lookup. }
false;public;0;3;;public NestedScope nestedScope() {     return nestedScope. }
false;public;0;3;;public Version indexVersionCreated() {     return indexSettings.getIndexVersionCreated(). }
false;public;1;9;;public ParsedQuery toQuery(QueryBuilder queryBuilder) {     return toQuery(queryBuilder, q -> {         Query query = q.toQuery(this).         if (query == null) {             query = Queries.newMatchNoDocsQuery("No query left after rewrite.").         }         return query.     }). }
false;private;2;13;;private ParsedQuery toQuery(QueryBuilder queryBuilder, CheckedFunction<QueryBuilder, Query, IOException> filterOrQuery) {     reset().     try {         QueryBuilder rewriteQuery = Rewriteable.rewrite(queryBuilder, this, true).         return new ParsedQuery(filterOrQuery.apply(rewriteQuery), copyNamedQueries()).     } catch (QueryShardException | ParsingException e) {         throw e.     } catch (Exception e) {         throw new QueryShardException(this, "failed to create query: {}", e, queryBuilder).     } finally {         reset().     } }
false;public;0;3;;public Index index() {     return indexSettings.getIndex(). }
true;public,final;0;4;/**  * Return the script service to allow compiling scripts.  */ ;/**  * Return the script service to allow compiling scripts.  */ public final ScriptService getScriptService() {     failIfFrozen().     return scriptService. }
true;public,final;0;3;/**  * if this method is called the query context will throw exception if methods are accessed  * that could yield different results across executions like {@link #getClient()}  */ ;/**  * if this method is called the query context will throw exception if methods are accessed  * that could yield different results across executions like {@link #getClient()}  */ public final void freezeContext() {     this.frozen.set(Boolean.TRUE). }
true;protected,final;0;8;/**  * This method fails if {@link #freezeContext()} is called before on this  * context. This is used to <i>seal</i>.  *  * This methods and all methods that call it should be final to ensure that  * setting the request as not cacheable and the freezing behaviour of this  * class cannot be bypassed. This is important so we can trust when this  * class says a request can be cached.  */ ;/**  * This method fails if {@link #freezeContext()} is called before on this  * context. This is used to <i>seal</i>.  *  * This methods and all methods that call it should be final to ensure that  * setting the request as not cacheable and the freezing behaviour of this  * class cannot be bypassed. This is important so we can trust when this  * class says a request can be cached.  */ protected final void failIfFrozen() {     this.cacheable = false.     if (frozen.get() == Boolean.TRUE) {         throw new IllegalArgumentException("features that prevent cachability are disabled on this context").     } else {         assert frozen.get() == null : frozen.get().     } }
false;public;1;5;;@Override public void registerAsyncAction(BiConsumer<Client, ActionListener<?>> asyncAction) {     failIfFrozen().     super.registerAsyncAction(asyncAction). }
false;public;1;5;;@Override public void executeAsyncActions(ActionListener listener) {     failIfFrozen().     super.executeAsyncActions(listener). }
true;public,final;0;3;/**  * Returns <code>true</code> iff the result of the processed search request is cacheable. Otherwise <code>false</code>  */ ;/**  * Returns <code>true</code> iff the result of the processed search request is cacheable. Otherwise <code>false</code>  */ public final boolean isCacheable() {     return cacheable. }
true;public;0;3;/**  * Returns the shard ID this context was created for.  */ ;/**  * Returns the shard ID this context was created for.  */ public int getShardId() {     return shardId. }
false;public,final;0;5;;@Override public final long nowInMillis() {     failIfFrozen().     return super.nowInMillis(). }
false;public;0;4;;public Client getClient() {     // we somebody uses a terms filter with lookup for instance can't be cached...     failIfFrozen().     return client. }
false;public;1;3;;public QueryBuilder parseInnerQueryBuilder(XContentParser parser) throws IOException {     return AbstractQueryBuilder.parseInnerQueryBuilder(parser). }
false;public,final;0;4;;@Override public final QueryShardContext convertToShardContext() {     return this. }
true;public;0;3;/**  * Returns the index settings for this context. This might return null if the  * context has not index scope.  */ ;/**  * Returns the index settings for this context. This might return null if the  * context has not index scope.  */ public IndexSettings getIndexSettings() {     return indexSettings. }
true;public;0;3;/**  * Return the MapperService.  */ ;/**  * Return the MapperService.  */ public MapperService getMapperService() {     return mapperService. }
true;public;0;3;/**  * Return the current {@link IndexReader}, or {@code null} if no index reader is available,  *  for instance if this rewrite context is used to index queries (percolation).  */ ;/**  * Return the current {@link IndexReader}, or {@code null} if no index reader is available,  *  for instance if this rewrite context is used to index queries (percolation).  */ public IndexReader getIndexReader() {     return reader. }
true;public;0;3;/**  * Returns the fully qualified index including a remote cluster alias if applicable, and the index uuid  */ ;/**  * Returns the fully qualified index including a remote cluster alias if applicable, and the index uuid  */ public Index getFullyQualifiedIndex() {     return fullyQualifiedIndex. }
