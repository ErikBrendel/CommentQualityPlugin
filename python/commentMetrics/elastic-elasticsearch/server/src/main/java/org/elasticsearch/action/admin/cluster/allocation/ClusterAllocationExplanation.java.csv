commented;modifiers;parameterAmount;loc;comment;code
false;public;1;8;;@Override public void writeTo(StreamOutput out) throws IOException {     shardRouting.writeTo(out).     out.writeOptionalWriteable(currentNode).     out.writeOptionalWriteable(relocationTargetNode).     out.writeOptionalWriteable(clusterInfo).     shardAllocationDecision.writeTo(out). }
true;public;0;3;/**  * Returns the shard that the explanation is about.  */ ;/**  * Returns the shard that the explanation is about.  */ public ShardId getShard() {     return shardRouting.shardId(). }
true;public;0;3;/**  * Returns {@code true} if the explained shard is primary, {@code false} otherwise.  */ ;/**  * Returns {@code true} if the explained shard is primary, {@code false} otherwise.  */ public boolean isPrimary() {     return shardRouting.primary(). }
true;public;0;3;/**  * Returns the current {@link ShardRoutingState} of the shard.  */ ;/**  * Returns the current {@link ShardRoutingState} of the shard.  */ public ShardRoutingState getShardState() {     return shardRouting.state(). }
true;public;0;4;/**  * Returns the currently assigned node, or {@code null} if the shard is unassigned.  */ ;/**  * Returns the currently assigned node, or {@code null} if the shard is unassigned.  */ @Nullable public DiscoveryNode getCurrentNode() {     return currentNode. }
true;public;0;4;/**  * Returns the relocating target node, or {@code null} if the shard is not in the {@link ShardRoutingState#RELOCATING} state.  */ ;/**  * Returns the relocating target node, or {@code null} if the shard is not in the {@link ShardRoutingState#RELOCATING} state.  */ @Nullable public DiscoveryNode getRelocationTargetNode() {     return relocationTargetNode. }
true;public;0;4;/**  * Returns the unassigned info for the shard, or {@code null} if the shard is active.  */ ;/**  * Returns the unassigned info for the shard, or {@code null} if the shard is active.  */ @Nullable public UnassignedInfo getUnassignedInfo() {     return shardRouting.unassignedInfo(). }
true;public;0;4;/**  * Returns the cluster disk info for the cluster, or {@code null} if none available.  */ ;/**  * Returns the cluster disk info for the cluster, or {@code null} if none available.  */ @Nullable public ClusterInfo getClusterInfo() {     return this.clusterInfo. }
true;public;0;3;/**  * \  * Returns the shard allocation decision for attempting to assign or move the shard.  */ ;/**  * \  * Returns the shard allocation decision for attempting to assign or move the shard.  */ public ShardAllocationDecision getShardAllocationDecision() {     return shardAllocationDecision. }
false;public;2;44;;public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     {         builder.field("index", shardRouting.getIndexName()).         builder.field("shard", shardRouting.getId()).         builder.field("primary", shardRouting.primary()).         builder.field("current_state", shardRouting.state().toString().toLowerCase(Locale.ROOT)).         if (shardRouting.unassignedInfo() != null) {             unassignedInfoToXContent(shardRouting.unassignedInfo(), builder).         }         if (currentNode != null) {             builder.startObject("current_node").             {                 discoveryNodeToXContent(currentNode, true, builder).                 if (shardAllocationDecision.getMoveDecision().isDecisionTaken() && shardAllocationDecision.getMoveDecision().getCurrentNodeRanking() > 0) {                     builder.field("weight_ranking", shardAllocationDecision.getMoveDecision().getCurrentNodeRanking()).                 }             }             builder.endObject().         }         if (this.clusterInfo != null) {             builder.startObject("cluster_info").             {                 this.clusterInfo.toXContent(builder, params).             }             // end "cluster_info"             builder.endObject().         }         if (shardAllocationDecision.isDecisionTaken()) {             shardAllocationDecision.toXContent(builder, params).         } else {             String explanation.             if (shardRouting.state() == ShardRoutingState.RELOCATING) {                 explanation = "the shard is in the process of relocating from node [" + currentNode.getName() + "] " + "to node [" + relocationTargetNode.getName() + "], wait until relocation has completed".             } else {                 assert shardRouting.state() == ShardRoutingState.INITIALIZING.                 explanation = "the shard is in the process of initializing on node [" + currentNode.getName() + "], " + "wait until initialization has completed".             }             builder.field("explanation", explanation).         }     }     // end wrapping object     builder.endObject().     return builder. }
false;private;2;18;;private XContentBuilder unassignedInfoToXContent(UnassignedInfo unassignedInfo, XContentBuilder builder) throws IOException {     builder.startObject("unassigned_info").     builder.field("reason", unassignedInfo.getReason()).     builder.field("at", UnassignedInfo.DATE_TIME_FORMATTER.format(Instant.ofEpochMilli(unassignedInfo.getUnassignedTimeInMillis()))).     if (unassignedInfo.getNumFailedAllocations() > 0) {         builder.field("failed_allocation_attempts", unassignedInfo.getNumFailedAllocations()).     }     String details = unassignedInfo.getDetails().     if (details != null) {         builder.field("details", details).     }     builder.field("last_allocation_status", AllocationDecision.fromAllocationStatus(unassignedInfo.getLastAllocationStatus())).     builder.endObject().     return builder. }
