commented;modifiers;parameterAmount;loc;comment;code
false;public;1;9;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeOptionalString(phaseName).     out.writeVInt(shardFailures.length).     for (ShardSearchFailure failure : shardFailures) {         failure.writeTo(out).     } }
false;private,static;2;15;;private static Throwable deduplicateCause(Throwable cause, ShardSearchFailure[] shardFailures) {     if (shardFailures == null) {         throw new IllegalArgumentException("shardSearchFailures must not be null").     }     // to prevent duplication in stack traces rendered to the REST layer     if (cause != null) {         for (ShardSearchFailure failure : shardFailures) {             if (failure.getCause() == cause) {                 return null.             }         }     }     return cause. }
false;public;0;16;;@Override public RestStatus status() {     if (shardFailures.length == 0) {         // if no successful shards, it means no active shards, so just return SERVICE_UNAVAILABLE         return RestStatus.SERVICE_UNAVAILABLE.     }     RestStatus status = shardFailures[0].status().     if (shardFailures.length > 1) {         for (int i = 1. i < shardFailures.length. i++) {             if (shardFailures[i].status().getStatus() >= 500) {                 status = shardFailures[i].status().             }         }     }     return status. }
false;public;0;3;;public ShardSearchFailure[] shardFailures() {     return shardFailures. }
false;public;0;11;;@Override public Throwable getCause() {     Throwable cause = super.getCause().     if (cause == null) {         // fall back to guessed root cause         for (ElasticsearchException rootCause : guessRootCauses()) {             return rootCause.         }     }     return cause. }
false;private,static;3;15;;private static String buildMessage(String phaseName, String msg, ShardSearchFailure[] shardFailures) {     StringBuilder sb = new StringBuilder().     sb.append("Failed to execute phase [").append(phaseName).append("], ").append(msg).     if (shardFailures != null && shardFailures.length > 0) {         sb.append(". shardFailures ").         for (ShardSearchFailure shardFailure : shardFailures) {             if (shardFailure.shard() != null) {                 sb.append("{").append(shardFailure.shard()).append(": ").append(shardFailure.reason()).append("}").             } else {                 sb.append("{").append(shardFailure.reason()).append("}").             }         }     }     return sb.toString(). }
false;protected;2;14;;@Override protected void metadataToXContent(XContentBuilder builder, Params params) throws IOException {     builder.field("phase", phaseName).     // notify that it's grouped     builder.field("grouped", true).     builder.field("failed_shards").     builder.startArray().     ShardOperationFailedException[] failures = ExceptionsHelper.groupBy(shardFailures).     for (ShardOperationFailedException failure : failures) {         builder.startObject().         failure.toXContent(builder, params).         builder.endObject().     }     builder.endArray(). }
false;public;2;13;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     Throwable ex = ExceptionsHelper.unwrapCause(this).     if (ex != this) {         generateThrowableXContent(builder, params, this).     } else {         // We don't have a cause when all shards failed, but we do have shards failures so we can "guess" a cause         // (see {@link #getCause()}). Here, we use super.getCause() because we don't want the guessed exception to         // be rendered twice (one in the "cause" field, one in "failed_shards")         innerToXContent(builder, params, this, getExceptionName(), getMessage(), getHeaders(), getMetadata(), super.getCause()).     }     return builder. }
false;public;0;10;;@Override public ElasticsearchException[] guessRootCauses() {     ShardOperationFailedException[] failures = ExceptionsHelper.groupBy(shardFailures).     List<ElasticsearchException> rootCauses = new ArrayList<>(failures.length).     for (ShardOperationFailedException failure : failures) {         ElasticsearchException[] guessRootCauses = ElasticsearchException.guessRootCauses(failure.getCause()).         rootCauses.addAll(Arrays.asList(guessRootCauses)).     }     return rootCauses.toArray(new ElasticsearchException[0]). }
false;public;0;4;;@Override public String toString() {     return buildMessage(phaseName, getMessage(), shardFailures). }
false;public;0;3;;public String getPhaseName() {     return phaseName. }
