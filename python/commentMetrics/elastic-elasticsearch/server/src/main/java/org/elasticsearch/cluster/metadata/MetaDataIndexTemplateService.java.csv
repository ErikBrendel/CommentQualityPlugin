commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public TimeValue timeout() {     return request.masterTimeout. }
false;public;2;4;;@Override public void onFailure(String source, Exception e) {     listener.onFailure(e). }
false;public;1;24;;@Override public ClusterState execute(ClusterState currentState) {     Set<String> templateNames = new HashSet<>().     for (ObjectCursor<String> cursor : currentState.metaData().templates().keys()) {         String templateName = cursor.value.         if (Regex.simpleMatch(request.name, templateName)) {             templateNames.add(templateName).         }     }     if (templateNames.isEmpty()) {         // fail with index missing...         if (Regex.isMatchAllPattern(request.name)) {             return currentState.         }         throw new IndexTemplateMissingException(request.name).     }     MetaData.Builder metaData = MetaData.builder(currentState.metaData()).     for (String templateName : templateNames) {         logger.info("removing template [{}]", templateName).         metaData.removeTemplate(templateName).     }     return ClusterState.builder(currentState).metaData(metaData).build(). }
false;public;3;4;;@Override public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {     listener.onResponse(new RemoveResponse(true)). }
false;public;2;44;;public void removeTemplates(final RemoveRequest request, final RemoveListener listener) {     clusterService.submitStateUpdateTask("remove-index-template [" + request.name + "]", new ClusterStateUpdateTask(Priority.URGENT) {          @Override         public TimeValue timeout() {             return request.masterTimeout.         }          @Override         public void onFailure(String source, Exception e) {             listener.onFailure(e).         }          @Override         public ClusterState execute(ClusterState currentState) {             Set<String> templateNames = new HashSet<>().             for (ObjectCursor<String> cursor : currentState.metaData().templates().keys()) {                 String templateName = cursor.value.                 if (Regex.simpleMatch(request.name, templateName)) {                     templateNames.add(templateName).                 }             }             if (templateNames.isEmpty()) {                 // fail with index missing...                 if (Regex.isMatchAllPattern(request.name)) {                     return currentState.                 }                 throw new IndexTemplateMissingException(request.name).             }             MetaData.Builder metaData = MetaData.builder(currentState.metaData()).             for (String templateName : templateNames) {                 logger.info("removing template [{}]", templateName).                 metaData.removeTemplate(templateName).             }             return ClusterState.builder(currentState).metaData(metaData).build().         }          @Override         public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {             listener.onResponse(new RemoveResponse(true)).         }     }). }
false;public;0;4;;@Override public TimeValue timeout() {     return request.masterTimeout. }
false;public;2;4;;@Override public void onFailure(String source, Exception e) {     listener.onFailure(e). }
false;public;1;20;;@Override public ClusterState execute(ClusterState currentState) throws Exception {     if (request.create && currentState.metaData().templates().containsKey(request.name)) {         throw new IllegalArgumentException("index_template [" + request.name + "] already exists").     }     validateAndAddTemplate(request, templateBuilder, indicesService, xContentRegistry).     for (Alias alias : request.aliases) {         AliasMetaData aliasMetaData = AliasMetaData.builder(alias.name()).filter(alias.filter()).indexRouting(alias.indexRouting()).searchRouting(alias.searchRouting()).build().         templateBuilder.putAlias(aliasMetaData).     }     IndexTemplateMetaData template = templateBuilder.build().     MetaData.Builder builder = MetaData.builder(currentState.metaData()).put(template).     logger.info("adding template [{}] for index patterns {}", request.name, request.indexPatterns).     return ClusterState.builder(currentState).metaData(builder).build(). }
false;public;3;4;;@Override public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {     listener.onResponse(new PutResponse(true)). }
false;public;2;63;;public void putTemplate(final PutRequest request, final PutListener listener) {     Settings.Builder updatedSettingsBuilder = Settings.builder().     updatedSettingsBuilder.put(request.settings).normalizePrefix(IndexMetaData.INDEX_SETTING_PREFIX).     request.settings(updatedSettingsBuilder.build()).     if (request.name == null) {         listener.onFailure(new IllegalArgumentException("index_template must provide a name")).         return.     }     if (request.indexPatterns == null) {         listener.onFailure(new IllegalArgumentException("index_template must provide a template")).         return.     }     try {         validate(request).     } catch (Exception e) {         listener.onFailure(e).         return.     }     final IndexTemplateMetaData.Builder templateBuilder = IndexTemplateMetaData.builder(request.name).     clusterService.submitStateUpdateTask("create-index-template [" + request.name + "], cause [" + request.cause + "]", new ClusterStateUpdateTask(Priority.URGENT) {          @Override         public TimeValue timeout() {             return request.masterTimeout.         }          @Override         public void onFailure(String source, Exception e) {             listener.onFailure(e).         }          @Override         public ClusterState execute(ClusterState currentState) throws Exception {             if (request.create && currentState.metaData().templates().containsKey(request.name)) {                 throw new IllegalArgumentException("index_template [" + request.name + "] already exists").             }             validateAndAddTemplate(request, templateBuilder, indicesService, xContentRegistry).             for (Alias alias : request.aliases) {                 AliasMetaData aliasMetaData = AliasMetaData.builder(alias.name()).filter(alias.filter()).indexRouting(alias.indexRouting()).searchRouting(alias.searchRouting()).build().                 templateBuilder.putAlias(aliasMetaData).             }             IndexTemplateMetaData template = templateBuilder.build().             MetaData.Builder builder = MetaData.builder(currentState.metaData()).put(template).             logger.info("adding template [{}] for index patterns {}", request.name, request.indexPatterns).             return ClusterState.builder(currentState).metaData(builder).build().         }          @Override         public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {             listener.onResponse(new PutResponse(true)).         }     }). }
true;public,static;2;12;/**  * Finds index templates whose index pattern matched with the given index name.  * The result is sorted by {@link IndexTemplateMetaData#order} descending.  */ ;/**  * Finds index templates whose index pattern matched with the given index name.  * The result is sorted by {@link IndexTemplateMetaData#order} descending.  */ public static List<IndexTemplateMetaData> findTemplates(MetaData metaData, String indexName) {     final List<IndexTemplateMetaData> matchedTemplates = new ArrayList<>().     for (ObjectCursor<IndexTemplateMetaData> cursor : metaData.templates().values()) {         final IndexTemplateMetaData template = cursor.value.         final boolean matched = template.patterns().stream().anyMatch(pattern -> Regex.simpleMatch(pattern, indexName)).         if (matched) {             matchedTemplates.add(template).         }     }     CollectionUtil.timSort(matchedTemplates, Comparator.comparingInt(IndexTemplateMetaData::order).reversed()).     return matchedTemplates. }
false;private,static;4;46;;private static void validateAndAddTemplate(final PutRequest request, IndexTemplateMetaData.Builder templateBuilder, IndicesService indicesService, NamedXContentRegistry xContentRegistry) throws Exception {     Index createdIndex = null.     final String temporaryIndexName = UUIDs.randomBase64UUID().     try {         // use the provided values, otherwise just pick valid dummy values         int dummyPartitionSize = IndexMetaData.INDEX_ROUTING_PARTITION_SIZE_SETTING.get(request.settings).         int dummyShards = request.settings.getAsInt(IndexMetaData.SETTING_NUMBER_OF_SHARDS, dummyPartitionSize == 1 ? 1 : dummyPartitionSize + 1).         // create index service for parsing and validating "mappings"         Settings dummySettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT).put(request.settings).put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, dummyShards).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 0).put(IndexMetaData.SETTING_INDEX_UUID, UUIDs.randomBase64UUID()).build().         final IndexMetaData tmpIndexMetadata = IndexMetaData.builder(temporaryIndexName).settings(dummySettings).build().         IndexService dummyIndexService = indicesService.createIndex(tmpIndexMetadata, Collections.emptyList()).         createdIndex = dummyIndexService.index().         templateBuilder.order(request.order).         templateBuilder.version(request.version).         templateBuilder.patterns(request.indexPatterns).         templateBuilder.settings(request.settings).         Map<String, Map<String, Object>> mappingsForValidation = new HashMap<>().         for (Map.Entry<String, String> entry : request.mappings.entrySet()) {             try {                 templateBuilder.putMapping(entry.getKey(), entry.getValue()).             } catch (Exception e) {                 throw new MapperParsingException("Failed to parse mapping [{}]: {}", e, entry.getKey(), e.getMessage()).             }             mappingsForValidation.put(entry.getKey(), MapperService.parseMapping(xContentRegistry, entry.getValue())).         }         dummyIndexService.mapperService().merge(mappingsForValidation, MergeReason.MAPPING_UPDATE).     } finally {         if (createdIndex != null) {             indicesService.removeIndex(createdIndex, NO_LONGER_ASSIGNED, " created for parsing template mapping").         }     } }
false;private;1;60;;private void validate(PutRequest request) {     List<String> validationErrors = new ArrayList<>().     if (request.name.contains(" ")) {         validationErrors.add("name must not contain a space").     }     if (request.name.contains(",")) {         validationErrors.add("name must not contain a ','").     }     if (request.name.contains("#")) {         validationErrors.add("name must not contain a '#'").     }     if (request.name.startsWith("_")) {         validationErrors.add("name must not start with '_'").     }     if (!request.name.toLowerCase(Locale.ROOT).equals(request.name)) {         validationErrors.add("name must be lower cased").     }     for (String indexPattern : request.indexPatterns) {         if (indexPattern.contains(" ")) {             validationErrors.add("template must not contain a space").         }         if (indexPattern.contains(",")) {             validationErrors.add("template must not contain a ','").         }         if (indexPattern.contains("#")) {             validationErrors.add("template must not contain a '#'").         }         if (indexPattern.startsWith("_")) {             validationErrors.add("template must not start with '_'").         }         if (!Strings.validFileNameExcludingAstrix(indexPattern)) {             validationErrors.add("template must not contain the following characters " + Strings.INVALID_FILENAME_CHARS).         }     }     try {         // templates must be consistent with regards to dependencies         indexScopedSettings.validate(request.settings, true).     } catch (IllegalArgumentException iae) {         validationErrors.add(iae.getMessage()).         for (Throwable t : iae.getSuppressed()) {             validationErrors.add(t.getMessage()).         }     }     List<String> indexSettingsValidation = metaDataCreateIndexService.getIndexSettingsValidationErrors(request.settings, true).     validationErrors.addAll(indexSettingsValidation).     if (!validationErrors.isEmpty()) {         ValidationException validationException = new ValidationException().         validationException.addValidationErrors(validationErrors).         throw new InvalidIndexTemplateException(request.name, validationException.getMessage()).     }     for (Alias alias : request.aliases) {         // we validate the alias only partially, as we don't know yet to which index it'll get applied to         aliasValidator.validateAliasStandalone(alias).         if (request.indexPatterns.contains(alias.name())) {             throw new IllegalArgumentException("Alias [" + alias.name() + "] cannot be the same as any pattern in [" + String.join(", ", request.indexPatterns) + "]").         }     } }
false;;1;1;;void onResponse(PutResponse response).
false;;1;1;;void onFailure(Exception e).
false;public;1;4;;public PutRequest order(int order) {     this.order = order.     return this. }
false;public;1;4;;public PutRequest patterns(List<String> indexPatterns) {     this.indexPatterns = indexPatterns.     return this. }
false;public;1;4;;public PutRequest create(boolean create) {     this.create = create.     return this. }
false;public;1;4;;public PutRequest settings(Settings settings) {     this.settings = settings.     return this. }
false;public;1;4;;public PutRequest mappings(Map<String, String> mappings) {     this.mappings.putAll(mappings).     return this. }
false;public;1;4;;public PutRequest aliases(Set<Alias> aliases) {     this.aliases.addAll(aliases).     return this. }
false;public;2;4;;public PutRequest putMapping(String mappingType, String mappingSource) {     mappings.put(mappingType, mappingSource).     return this. }
false;public;1;4;;public PutRequest masterTimeout(TimeValue masterTimeout) {     this.masterTimeout = masterTimeout.     return this. }
false;public;1;4;;public PutRequest version(Integer version) {     this.version = version.     return this. }
false;public;0;3;;public boolean acknowledged() {     return acknowledged. }
false;public;1;4;;public RemoveRequest masterTimeout(TimeValue masterTimeout) {     this.masterTimeout = masterTimeout.     return this. }
false;public;0;3;;public boolean acknowledged() {     return acknowledged. }
false;;1;1;;void onResponse(RemoveResponse response).
false;;1;1;;void onFailure(Exception e).
