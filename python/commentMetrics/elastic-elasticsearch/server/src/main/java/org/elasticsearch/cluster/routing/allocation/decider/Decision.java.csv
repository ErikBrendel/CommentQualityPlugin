commented;modifiers;parameterAmount;loc;comment;code
true;public,static;4;3;/**  * Creates a simple decision  * @param type {@link Type} of the decision  * @param label label for the Decider that produced this decision  * @param explanation explanation of the decision  * @param explanationParams additional parameters for the decision  * @return new {@link Decision} instance  */ ;/**  * Creates a simple decision  * @param type {@link Type} of the decision  * @param label label for the Decider that produced this decision  * @param explanation explanation of the decision  * @param explanationParams additional parameters for the decision  * @return new {@link Decision} instance  */ public static Decision single(Type type, @Nullable String label, @Nullable String explanation, @Nullable Object... explanationParams) {     return new Single(type, label, explanation, explanationParams). }
false;public,static;1;18;;public static Decision readFrom(StreamInput in) throws IOException {     // Determine whether to read a Single or Multi Decision     if (in.readBoolean()) {         Multi result = new Multi().         int decisionCount = in.readVInt().         for (int i = 0. i < decisionCount. i++) {             Decision s = readFrom(in).             result.decisions.add(s).         }         return result.     } else {         Single result = new Single().         result.type = Type.readFrom(in).         result.label = in.readOptionalString().         result.explanationString = in.readOptionalString().         return result.     } }
false;public,static;1;13;;public static Type readFrom(StreamInput in) throws IOException {     int i = in.readVInt().     switch(i) {         case 0:             return NO.         case 1:             return YES.         case 2:             return THROTTLE.         default:             throw new IllegalArgumentException("No Type for integer [" + i + "]").     } }
false;public;1;4;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeVInt(id). }
false;public;1;10;;public boolean higherThan(Type other) {     if (this == NO) {         return false.     } else if (other == NO) {         return true.     } else if (other == THROTTLE && this == YES) {         return true.     }     return false. }
true;public,abstract;0;1;/**  * Get the {@link Type} of this decision  * @return {@link Type} of this decision  */ ;/**  * Get the {@link Type} of this decision  * @return {@link Type} of this decision  */ public abstract Type type().
true;public,abstract;0;2;/**  * Get the description label for this decision.  */ ;/**  * Get the description label for this decision.  */ @Nullable public abstract String label().
true;public,abstract;0;2;/**  * Get the explanation for this decision.  */ ;/**  * Get the explanation for this decision.  */ @Nullable public abstract String getExplanation().
true;public,abstract;0;1;/**  * Return the list of all decisions that make up this decision  */ ;/**  * Return the list of all decisions that make up this decision  */ public abstract List<Decision> getDecisions().
false;public;0;4;;@Override public Type type() {     return this.type. }
false;public;0;5;;@Override @Nullable public String label() {     return this.label. }
false;public;0;4;;@Override public List<Decision> getDecisions() {     return Collections.singletonList(this). }
true;public;0;8;/**  * Returns the explanation string, fully formatted.  Only formats the string once.  */ ;/**  * Returns the explanation string, fully formatted.  Only formats the string once.  */ @Override @Nullable public String getExplanation() {     if (explanationString == null && explanation != null) {         explanationString = String.format(Locale.ROOT, explanation, explanationParams).     }     return this.explanationString. }
false;public;1;15;;@Override public boolean equals(Object object) {     if (this == object) {         return true.     }     if (object == null || getClass() != object.getClass()) {         return false.     }     Decision.Single s = (Decision.Single) object.     return this.type == s.type && Objects.equals(label, s.label) && Objects.equals(getExplanation(), s.getExplanation()). }
false;public;0;8;;@Override public int hashCode() {     int result = type.hashCode().     result = 31 * result + (label == null ? 0 : label.hashCode()).     String explanationStr = getExplanation().     result = 31 * result + (explanationStr == null ? 0 : explanationStr.hashCode()).     return result. }
false;public;0;7;;@Override public String toString() {     if (explanationString != null || explanation != null) {         return type + "(" + getExplanation() + ")".     }     return type + "()". }
false;public;2;10;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     builder.field("decider", label).     builder.field("decision", type).     String explanation = getExplanation().     builder.field("explanation", explanation != null ? explanation : "none").     builder.endObject().     return builder. }
false;public;1;9;;@Override public void writeTo(StreamOutput out) throws IOException {     // flag specifying its a single decision     out.writeBoolean(false).     type.writeTo(out).     out.writeOptionalString(label).     // Flatten explanation on serialization, so that explanationParams     // do not need to be serialized     out.writeOptionalString(getExplanation()). }
true;public;1;4;/**  * Add a decision to this {@link Multi}decision instance  * @param decision {@link Decision} to add  * @return {@link Multi}decision instance with the given decision added  */ ;/**  * Add a decision to this {@link Multi}decision instance  * @param decision {@link Decision} to add  * @return {@link Multi}decision instance with the given decision added  */ public Multi add(Decision decision) {     decisions.add(decision).     return this. }
false;public;0;13;;@Override public Type type() {     Type ret = Type.YES.     for (int i = 0. i < decisions.size(). i++) {         Type type = decisions.get(i).type().         if (type == Type.NO) {             return type.         } else if (type == Type.THROTTLE) {             ret = type.         }     }     return ret. }
false;public;0;6;;@Override @Nullable public String label() {     // Multi decisions have no labels     return null. }
false;public;0;5;;@Override @Nullable public String getExplanation() {     throw new UnsupportedOperationException("multi-level decisions do not have an explanation"). }
false;public;0;4;;@Override public List<Decision> getDecisions() {     return Collections.unmodifiableList(this.decisions). }
false;public;1;14;;@Override public boolean equals(final Object object) {     if (this == object) {         return true.     }     if (object == null || getClass() != object.getClass()) {         return false.     }     final Decision.Multi m = (Decision.Multi) object.     return this.decisions.equals(m.decisions). }
false;public;0;4;;@Override public int hashCode() {     return 31 * decisions.hashCode(). }
false;public;0;8;;@Override public String toString() {     StringBuilder sb = new StringBuilder().     for (Decision decision : decisions) {         sb.append("[").append(decision.toString()).append("]").     }     return sb.toString(). }
false;public;2;7;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     for (Decision d : decisions) {         d.toXContent(builder, params).     }     return builder. }
false;public;1;8;;@Override public void writeTo(StreamOutput out) throws IOException {     // flag indicating it is a multi decision     out.writeBoolean(true).     out.writeVInt(getDecisions().size()).     for (Decision d : getDecisions()) {         d.writeTo(out).     } }
