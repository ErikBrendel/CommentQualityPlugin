commented;modifiers;parameterAmount;loc;comment;code
true;public,final;2;44;/**  * Adds the given item to the queue. The listener is notified once the item is processed  */ ;/**  * Adds the given item to the queue. The listener is notified once the item is processed  */ public final void put(Item item, Consumer<Exception> listener) {     Objects.requireNonNull(item, "item must not be null").     Objects.requireNonNull(listener, "listener must not be null").     // the algorithm here tires to reduce the load on each individual caller.     // we try to have only one caller that processes pending items to disc while others just add to the queue but     // at the same time never overload the node by pushing too many items into the queue.     // we first try make a promise that we are responsible for the processing     final boolean promised = promiseSemaphore.tryAcquire().     final Tuple<Item, Consumer<Exception>> itemTuple = new Tuple<>(item, listener).     if (promised == false) {         // in this case we are not responsible and can just block until there is space         try {             queue.put(new Tuple<>(item, listener)).         } catch (InterruptedException e) {             Thread.currentThread().interrupt().             listener.accept(e).         }     }     // while we are draining that mean we might exit below too early in the while loop if the drainAndSync call is fast.     if (promised || promiseSemaphore.tryAcquire()) {         final List<Tuple<Item, Consumer<Exception>>> candidates = new ArrayList<>().         try {             if (promised) {                 // we are responsible for processing we don't need to add the tuple to the queue we can just add it to the candidates                 candidates.add(itemTuple).             }             // since we made the promise to process we gotta do it here at least once             drainAndProcess(candidates).         } finally {             // now to ensure we are passing it on we release the promise so another thread can take over             promiseSemaphore.release().         }         while (queue.isEmpty() == false && promiseSemaphore.tryAcquire()) {             // yet if the queue is not empty AND nobody else has yet made the promise to take over we continue processing             try {                 drainAndProcess(candidates).             } finally {                 promiseSemaphore.release().             }         }     } }
false;private;1;5;;private void drainAndProcess(List<Tuple<Item, Consumer<Exception>>> candidates) {     queue.drainTo(candidates).     processList(candidates).     candidates.clear(). }
false;private;1;20;;private void processList(List<Tuple<Item, Consumer<Exception>>> candidates) {     Exception exception = null.     if (candidates.isEmpty() == false) {         try {             write(candidates).         } catch (Exception ex) {             // if this fails we are in deep shit - fail the request             logger.debug("failed to write candidates", ex).             // this exception is passed to all listeners - we don't retry. if this doesn't work we are in deep shit             exception = ex.         }     }     for (Tuple<Item, Consumer<Exception>> tuple : candidates) {         Consumer<Exception> consumer = tuple.v2().         try {             consumer.accept(exception).         } catch (Exception ex) {             logger.warn("failed to notify callback", ex).         }     } }
true;protected,abstract;1;1;/**  * Writes or processes the items out or to disk.  */ ;/**  * Writes or processes the items out or to disk.  */ protected abstract void write(List<Tuple<Item, Consumer<Exception>>> candidates) throws IOException.
