commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * The source that caused this cluster event to be raised.  */ ;/**  * The source that caused this cluster event to be raised.  */ public String source() {     return this.source. }
true;public;0;3;/**  * The new cluster state that caused this change event.  */ ;/**  * The new cluster state that caused this change event.  */ public ClusterState state() {     return this.state. }
true;public;0;3;/**  * The previous cluster state for this change event.  */ ;/**  * The previous cluster state for this change event.  */ public ClusterState previousState() {     return this.previousState. }
true;public;0;3;/**  * Returns <code>true</code> iff the routing tables (for all indices) have  * changed between the previous cluster state and the current cluster state.  * Note that this is an object reference equality test, not an equals test.  */ ;/**  * Returns <code>true</code> iff the routing tables (for all indices) have  * changed between the previous cluster state and the current cluster state.  * Note that this is an object reference equality test, not an equals test.  */ public boolean routingTableChanged() {     return state.routingTable() != previousState.routingTable(). }
true;public;1;10;/**  * Returns <code>true</code> iff the routing table has changed for the given index.  * Note that this is an object reference equality test, not an equals test.  */ ;/**  * Returns <code>true</code> iff the routing table has changed for the given index.  * Note that this is an object reference equality test, not an equals test.  */ public boolean indexRoutingTableChanged(String index) {     Objects.requireNonNull(index, "index must not be null").     if (!state.routingTable().hasIndex(index) && !previousState.routingTable().hasIndex(index)) {         return false.     }     if (state.routingTable().hasIndex(index) && previousState.routingTable().hasIndex(index)) {         return state.routingTable().index(index) != previousState.routingTable().index(index).     }     return true. }
true;public;0;16;/**  * Returns the indices created in this event  */ ;/**  * Returns the indices created in this event  */ public List<String> indicesCreated() {     if (!metaDataChanged()) {         return Collections.emptyList().     }     List<String> created = null.     for (ObjectCursor<String> cursor : state.metaData().indices().keys()) {         String index = cursor.value.         if (!previousState.metaData().hasIndex(index)) {             if (created == null) {                 created = new ArrayList<>().             }             created.add(index).         }     }     return created == null ? Collections.<String>emptyList() : created. }
true;public;0;9;/**  * Returns the indices deleted in this event  */ ;/**  * Returns the indices deleted in this event  */ public List<Index> indicesDeleted() {     if (previousState.blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)) {         // working off of a non-initialized previous state, so use the tombstones for index deletions         return indicesDeletedFromTombstones().     } else {         // examine the diffs in index metadata between the previous and new cluster states to get the deleted indices         return indicesDeletedFromClusterState().     } }
true;public;0;3;/**  * Returns <code>true</code> iff the metadata for the cluster has changed between  * the previous cluster state and the new cluster state. Note that this is an object  * reference equality test, not an equals test.  */ ;/**  * Returns <code>true</code> iff the metadata for the cluster has changed between  * the previous cluster state and the new cluster state. Note that this is an object  * reference equality test, not an equals test.  */ public boolean metaDataChanged() {     return state.metaData() != previousState.metaData(). }
true;public;0;21;/**  * Returns a set of custom meta data types when any custom metadata for the cluster has changed  * between the previous cluster state and the new cluster state. custom meta data types are  * returned iff they have been added, updated or removed between the previous and the current state  */ ;/**  * Returns a set of custom meta data types when any custom metadata for the cluster has changed  * between the previous cluster state and the new cluster state. custom meta data types are  * returned iff they have been added, updated or removed between the previous and the current state  */ public Set<String> changedCustomMetaDataSet() {     Set<String> result = new HashSet<>().     ImmutableOpenMap<String, MetaData.Custom> currentCustoms = state.metaData().customs().     ImmutableOpenMap<String, MetaData.Custom> previousCustoms = previousState.metaData().customs().     if (currentCustoms.equals(previousCustoms) == false) {         for (ObjectObjectCursor<String, MetaData.Custom> currentCustomMetaData : currentCustoms) {             // new custom md added or existing custom md changed             if (previousCustoms.containsKey(currentCustomMetaData.key) == false || currentCustomMetaData.value.equals(previousCustoms.get(currentCustomMetaData.key)) == false) {                 result.add(currentCustomMetaData.key).             }         }         // existing custom md deleted         for (ObjectObjectCursor<String, MetaData.Custom> previousCustomMetaData : previousCustoms) {             if (currentCustoms.containsKey(previousCustomMetaData.key) == false) {                 result.add(previousCustomMetaData.key).             }         }     }     return result. }
true;public,static;2;6;/**  * Returns <code>true</code> iff the {@link IndexMetaData} for a given index  * has changed between the previous cluster state and the new cluster state.  * Note that this is an object reference equality test, not an equals test.  */ ;/**  * Returns <code>true</code> iff the {@link IndexMetaData} for a given index  * has changed between the previous cluster state and the new cluster state.  * Note that this is an object reference equality test, not an equals test.  */ public static boolean indexMetaDataChanged(IndexMetaData metaData1, IndexMetaData metaData2) {     assert metaData1 != null && metaData2 != null.     // same instance if its a version match     return metaData1 != metaData2. }
true;public;0;3;/**  * Returns <code>true</code> iff the cluster level blocks have changed between cluster states.  * Note that this is an object reference equality test, not an equals test.  */ ;/**  * Returns <code>true</code> iff the cluster level blocks have changed between cluster states.  * Note that this is an object reference equality test, not an equals test.  */ public boolean blocksChanged() {     return state.blocks() != previousState.blocks(). }
true;public;0;3;/**  * Returns <code>true</code> iff the local node is the mater node of the cluster.  */ ;/**  * Returns <code>true</code> iff the local node is the mater node of the cluster.  */ public boolean localNodeMaster() {     return state.nodes().isLocalNodeElectedMaster(). }
true;public;0;3;/**  * Returns the {@link org.elasticsearch.cluster.node.DiscoveryNodes.Delta} between  * the previous cluster state and the new cluster state.  */ ;/**  * Returns the {@link org.elasticsearch.cluster.node.DiscoveryNodes.Delta} between  * the previous cluster state and the new cluster state.  */ public DiscoveryNodes.Delta nodesDelta() {     return this.nodesDelta. }
true;public;0;3;/**  * Returns <code>true</code> iff nodes have been removed from the cluster since the last cluster state.  */ ;/**  * Returns <code>true</code> iff nodes have been removed from the cluster since the last cluster state.  */ public boolean nodesRemoved() {     return nodesDelta.removed(). }
true;public;0;3;/**  * Returns <code>true</code> iff nodes have been added from the cluster since the last cluster state.  */ ;/**  * Returns <code>true</code> iff nodes have been added from the cluster since the last cluster state.  */ public boolean nodesAdded() {     return nodesDelta.added(). }
true;public;0;3;/**  * Returns <code>true</code> iff nodes have been changed (added or removed) from the cluster since the last cluster state.  */ ;/**  * Returns <code>true</code> iff nodes have been changed (added or removed) from the cluster since the last cluster state.  */ public boolean nodesChanged() {     return nodesRemoved() || nodesAdded(). }
true;public;0;5;/**  * Determines whether or not the current cluster state represents an entirely  * new cluster, either when a node joins a cluster for the first time or when  * the node receives a cluster state update from a brand new cluster (different  * UUID from the previous cluster), which will happen when a master node is  * elected that has never been part of the cluster before.  */ ;/**  * Determines whether or not the current cluster state represents an entirely  * new cluster, either when a node joins a cluster for the first time or when  * the node receives a cluster state update from a brand new cluster (different  * UUID from the previous cluster), which will happen when a master node is  * elected that has never been part of the cluster before.  */ public boolean isNewCluster() {     final String prevClusterUUID = previousState.metaData().clusterUUID().     final String currClusterUUID = state.metaData().clusterUUID().     return prevClusterUUID.equals(currClusterUUID) == false. }
true;private;0;24;// If an index exists in the previous cluster state, but not in the new cluster state, it must have been deleted. ;// Get the deleted indices by comparing the index metadatas in the previous and new cluster states. // If an index exists in the previous cluster state, but not in the new cluster state, it must have been deleted. private List<Index> indicesDeletedFromClusterState() {     // https://github.com/elastic/elasticsearch/issues/11665     if (metaDataChanged() == false || isNewCluster()) {         return Collections.emptyList().     }     List<Index> deleted = null.     for (ObjectCursor<IndexMetaData> cursor : previousState.metaData().indices().values()) {         IndexMetaData index = cursor.value.         IndexMetaData current = state.metaData().index(index.getIndex()).         if (current == null) {             if (deleted == null) {                 deleted = new ArrayList<>().             }             deleted.add(index.getIndex()).         }     }     return deleted == null ? Collections.<Index>emptyList() : deleted. }
false;private;0;10;;private List<Index> indicesDeletedFromTombstones() {     // We look at the full tombstones list to see which indices need to be deleted.  In the case of     // a valid previous cluster state, indicesDeletedFromClusterState() will be used to get the deleted     // list, so a diff doesn't make sense here.  When a node (re)joins the cluster, its possible for it     // to re-process the same deletes or process deletes about indices it never knew about.  This is not     // an issue because there are safeguards in place in the delete store operation in case the index     // folder doesn't exist on the file system.     List<IndexGraveyard.Tombstone> tombstones = state.metaData().indexGraveyard().getTombstones().     return tombstones.stream().map(IndexGraveyard.Tombstone::getIndex).collect(Collectors.toList()). }
