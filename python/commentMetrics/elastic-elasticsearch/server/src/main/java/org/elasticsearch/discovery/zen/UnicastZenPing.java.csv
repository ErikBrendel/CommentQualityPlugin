# id;timestamp;commentText;codeText;commentWords;codeWords
UnicastZenPing -> @Override     public void ping(final Consumer<PingCollection> resultsConsumer, final TimeValue duration);1524684173;Sends three rounds of pings notifying the specified {@link Consumer} when pinging is complete. Pings are sent after resolving_configured unicast hosts to their IP address (subject to DNS caching within the JVM). A batch of pings is sent, then another batch_of pings is sent at half the specified {@link TimeValue}, and then another batch of pings is sent at the specified {@link TimeValue}._The pings that are sent carry a timeout of 1.25 times the specified {@link TimeValue}. When pinging each node, a connection and_handshake is performed, with a connection timeout of the specified {@link TimeValue}.__@param resultsConsumer the callback when pinging is complete_@param duration        the timeout for various components of the pings;@Override_    public void ping(final Consumer<PingCollection> resultsConsumer, final TimeValue duration) {_        ping(resultsConsumer, duration, duration)__    };sends,three,rounds,of,pings,notifying,the,specified,link,consumer,when,pinging,is,complete,pings,are,sent,after,resolving,configured,unicast,hosts,to,their,ip,address,subject,to,dns,caching,within,the,jvm,a,batch,of,pings,is,sent,then,another,batch,of,pings,is,sent,at,half,the,specified,link,time,value,and,then,another,batch,of,pings,is,sent,at,the,specified,link,time,value,the,pings,that,are,sent,carry,a,timeout,of,1,25,times,the,specified,link,time,value,when,pinging,each,node,a,connection,and,handshake,is,performed,with,a,connection,timeout,of,the,specified,link,time,value,param,results,consumer,the,callback,when,pinging,is,complete,param,duration,the,timeout,for,various,components,of,the,pings;override,public,void,ping,final,consumer,ping,collection,results,consumer,final,time,value,duration,ping,results,consumer,duration,duration
UnicastZenPing -> @Override     public void ping(final Consumer<PingCollection> resultsConsumer, final TimeValue duration);1529600205;Sends three rounds of pings notifying the specified {@link Consumer} when pinging is complete. Pings are sent after resolving_configured unicast hosts to their IP address (subject to DNS caching within the JVM). A batch of pings is sent, then another batch_of pings is sent at half the specified {@link TimeValue}, and then another batch of pings is sent at the specified {@link TimeValue}._The pings that are sent carry a timeout of 1.25 times the specified {@link TimeValue}. When pinging each node, a connection and_handshake is performed, with a connection timeout of the specified {@link TimeValue}.__@param resultsConsumer the callback when pinging is complete_@param duration        the timeout for various components of the pings;@Override_    public void ping(final Consumer<PingCollection> resultsConsumer, final TimeValue duration) {_        ping(resultsConsumer, duration, duration)__    };sends,three,rounds,of,pings,notifying,the,specified,link,consumer,when,pinging,is,complete,pings,are,sent,after,resolving,configured,unicast,hosts,to,their,ip,address,subject,to,dns,caching,within,the,jvm,a,batch,of,pings,is,sent,then,another,batch,of,pings,is,sent,at,half,the,specified,link,time,value,and,then,another,batch,of,pings,is,sent,at,the,specified,link,time,value,the,pings,that,are,sent,carry,a,timeout,of,1,25,times,the,specified,link,time,value,when,pinging,each,node,a,connection,and,handshake,is,performed,with,a,connection,timeout,of,the,specified,link,time,value,param,results,consumer,the,callback,when,pinging,is,complete,param,duration,the,timeout,for,various,components,of,the,pings;override,public,void,ping,final,consumer,ping,collection,results,consumer,final,time,value,duration,ping,results,consumer,duration,duration
UnicastZenPing -> @Override     public void ping(final Consumer<PingCollection> resultsConsumer, final TimeValue duration);1529687475;Sends three rounds of pings notifying the specified {@link Consumer} when pinging is complete. Pings are sent after resolving_configured unicast hosts to their IP address (subject to DNS caching within the JVM). A batch of pings is sent, then another batch_of pings is sent at half the specified {@link TimeValue}, and then another batch of pings is sent at the specified {@link TimeValue}._The pings that are sent carry a timeout of 1.25 times the specified {@link TimeValue}. When pinging each node, a connection and_handshake is performed, with a connection timeout of the specified {@link TimeValue}.__@param resultsConsumer the callback when pinging is complete_@param duration        the timeout for various components of the pings;@Override_    public void ping(final Consumer<PingCollection> resultsConsumer, final TimeValue duration) {_        ping(resultsConsumer, duration, duration)__    };sends,three,rounds,of,pings,notifying,the,specified,link,consumer,when,pinging,is,complete,pings,are,sent,after,resolving,configured,unicast,hosts,to,their,ip,address,subject,to,dns,caching,within,the,jvm,a,batch,of,pings,is,sent,then,another,batch,of,pings,is,sent,at,half,the,specified,link,time,value,and,then,another,batch,of,pings,is,sent,at,the,specified,link,time,value,the,pings,that,are,sent,carry,a,timeout,of,1,25,times,the,specified,link,time,value,when,pinging,each,node,a,connection,and,handshake,is,performed,with,a,connection,timeout,of,the,specified,link,time,value,param,results,consumer,the,callback,when,pinging,is,complete,param,duration,the,timeout,for,various,components,of,the,pings;override,public,void,ping,final,consumer,ping,collection,results,consumer,final,time,value,duration,ping,results,consumer,duration,duration
UnicastZenPing -> @Override     public void ping(final Consumer<PingCollection> resultsConsumer, final TimeValue duration);1540847035;Sends three rounds of pings notifying the specified {@link Consumer} when pinging is complete. Pings are sent after resolving_configured unicast hosts to their IP address (subject to DNS caching within the JVM). A batch of pings is sent, then another batch_of pings is sent at half the specified {@link TimeValue}, and then another batch of pings is sent at the specified {@link TimeValue}._The pings that are sent carry a timeout of 1.25 times the specified {@link TimeValue}. When pinging each node, a connection and_handshake is performed, with a connection timeout of the specified {@link TimeValue}.__@param resultsConsumer the callback when pinging is complete_@param duration        the timeout for various components of the pings;@Override_    public void ping(final Consumer<PingCollection> resultsConsumer, final TimeValue duration) {_        ping(resultsConsumer, duration, duration)__    };sends,three,rounds,of,pings,notifying,the,specified,link,consumer,when,pinging,is,complete,pings,are,sent,after,resolving,configured,unicast,hosts,to,their,ip,address,subject,to,dns,caching,within,the,jvm,a,batch,of,pings,is,sent,then,another,batch,of,pings,is,sent,at,half,the,specified,link,time,value,and,then,another,batch,of,pings,is,sent,at,the,specified,link,time,value,the,pings,that,are,sent,carry,a,timeout,of,1,25,times,the,specified,link,time,value,when,pinging,each,node,a,connection,and,handshake,is,performed,with,a,connection,timeout,of,the,specified,link,time,value,param,results,consumer,the,callback,when,pinging,is,complete,param,duration,the,timeout,for,various,components,of,the,pings;override,public,void,ping,final,consumer,ping,collection,results,consumer,final,time,value,duration,ping,results,consumer,duration,duration
UnicastZenPing -> @Override     public void ping(final Consumer<PingCollection> resultsConsumer, final TimeValue duration);1541092382;Sends three rounds of pings notifying the specified {@link Consumer} when pinging is complete. Pings are sent after resolving_configured unicast hosts to their IP address (subject to DNS caching within the JVM). A batch of pings is sent, then another batch_of pings is sent at half the specified {@link TimeValue}, and then another batch of pings is sent at the specified {@link TimeValue}._The pings that are sent carry a timeout of 1.25 times the specified {@link TimeValue}. When pinging each node, a connection and_handshake is performed, with a connection timeout of the specified {@link TimeValue}.__@param resultsConsumer the callback when pinging is complete_@param duration        the timeout for various components of the pings;@Override_    public void ping(final Consumer<PingCollection> resultsConsumer, final TimeValue duration) {_        ping(resultsConsumer, duration, duration)__    };sends,three,rounds,of,pings,notifying,the,specified,link,consumer,when,pinging,is,complete,pings,are,sent,after,resolving,configured,unicast,hosts,to,their,ip,address,subject,to,dns,caching,within,the,jvm,a,batch,of,pings,is,sent,then,another,batch,of,pings,is,sent,at,half,the,specified,link,time,value,and,then,another,batch,of,pings,is,sent,at,the,specified,link,time,value,the,pings,that,are,sent,carry,a,timeout,of,1,25,times,the,specified,link,time,value,when,pinging,each,node,a,connection,and,handshake,is,performed,with,a,connection,timeout,of,the,specified,link,time,value,param,results,consumer,the,callback,when,pinging,is,complete,param,duration,the,timeout,for,various,components,of,the,pings;override,public,void,ping,final,consumer,ping,collection,results,consumer,final,time,value,duration,ping,results,consumer,duration,duration
UnicastZenPing -> @Override     public void ping(final Consumer<PingCollection> resultsConsumer, final TimeValue duration);1542402632;Sends three rounds of pings notifying the specified {@link Consumer} when pinging is complete. Pings are sent after resolving_configured unicast hosts to their IP address (subject to DNS caching within the JVM). A batch of pings is sent, then another batch_of pings is sent at half the specified {@link TimeValue}, and then another batch of pings is sent at the specified {@link TimeValue}._The pings that are sent carry a timeout of 1.25 times the specified {@link TimeValue}. When pinging each node, a connection and_handshake is performed, with a connection timeout of the specified {@link TimeValue}.__@param resultsConsumer the callback when pinging is complete_@param duration        the timeout for various components of the pings;@Override_    public void ping(final Consumer<PingCollection> resultsConsumer, final TimeValue duration) {_        ping(resultsConsumer, duration, duration)__    };sends,three,rounds,of,pings,notifying,the,specified,link,consumer,when,pinging,is,complete,pings,are,sent,after,resolving,configured,unicast,hosts,to,their,ip,address,subject,to,dns,caching,within,the,jvm,a,batch,of,pings,is,sent,then,another,batch,of,pings,is,sent,at,half,the,specified,link,time,value,and,then,another,batch,of,pings,is,sent,at,the,specified,link,time,value,the,pings,that,are,sent,carry,a,timeout,of,1,25,times,the,specified,link,time,value,when,pinging,each,node,a,connection,and,handshake,is,performed,with,a,connection,timeout,of,the,specified,link,time,value,param,results,consumer,the,callback,when,pinging,is,complete,param,duration,the,timeout,for,various,components,of,the,pings;override,public,void,ping,final,consumer,ping,collection,results,consumer,final,time,value,duration,ping,results,consumer,duration,duration
UnicastZenPing -> @Override     public void ping(final Consumer<PingCollection> resultsConsumer, final TimeValue duration);1544081506;Sends three rounds of pings notifying the specified {@link Consumer} when pinging is complete. Pings are sent after resolving_configured unicast hosts to their IP address (subject to DNS caching within the JVM). A batch of pings is sent, then another batch_of pings is sent at half the specified {@link TimeValue}, and then another batch of pings is sent at the specified {@link TimeValue}._The pings that are sent carry a timeout of 1.25 times the specified {@link TimeValue}. When pinging each node, a connection and_handshake is performed, with a connection timeout of the specified {@link TimeValue}.__@param resultsConsumer the callback when pinging is complete_@param duration        the timeout for various components of the pings;@Override_    public void ping(final Consumer<PingCollection> resultsConsumer, final TimeValue duration) {_        ping(resultsConsumer, duration, duration)__    };sends,three,rounds,of,pings,notifying,the,specified,link,consumer,when,pinging,is,complete,pings,are,sent,after,resolving,configured,unicast,hosts,to,their,ip,address,subject,to,dns,caching,within,the,jvm,a,batch,of,pings,is,sent,then,another,batch,of,pings,is,sent,at,half,the,specified,link,time,value,and,then,another,batch,of,pings,is,sent,at,the,specified,link,time,value,the,pings,that,are,sent,carry,a,timeout,of,1,25,times,the,specified,link,time,value,when,pinging,each,node,a,connection,and,handshake,is,performed,with,a,connection,timeout,of,the,specified,link,time,value,param,results,consumer,the,callback,when,pinging,is,complete,param,duration,the,timeout,for,various,components,of,the,pings;override,public,void,ping,final,consumer,ping,collection,results,consumer,final,time,value,duration,ping,results,consumer,duration,duration
UnicastZenPing -> @Override     public void ping(final Consumer<PingCollection> resultsConsumer, final TimeValue duration);1548953505;Sends three rounds of pings notifying the specified {@link Consumer} when pinging is complete. Pings are sent after resolving_configured unicast hosts to their IP address (subject to DNS caching within the JVM). A batch of pings is sent, then another batch_of pings is sent at half the specified {@link TimeValue}, and then another batch of pings is sent at the specified {@link TimeValue}._The pings that are sent carry a timeout of 1.25 times the specified {@link TimeValue}. When pinging each node, a connection and_handshake is performed, with a connection timeout of the specified {@link TimeValue}.__@param resultsConsumer the callback when pinging is complete_@param duration        the timeout for various components of the pings;@Override_    public void ping(final Consumer<PingCollection> resultsConsumer, final TimeValue duration) {_        ping(resultsConsumer, duration, duration)__    };sends,three,rounds,of,pings,notifying,the,specified,link,consumer,when,pinging,is,complete,pings,are,sent,after,resolving,configured,unicast,hosts,to,their,ip,address,subject,to,dns,caching,within,the,jvm,a,batch,of,pings,is,sent,then,another,batch,of,pings,is,sent,at,half,the,specified,link,time,value,and,then,another,batch,of,pings,is,sent,at,the,specified,link,time,value,the,pings,that,are,sent,carry,a,timeout,of,1,25,times,the,specified,link,time,value,when,pinging,each,node,a,connection,and,handshake,is,performed,with,a,connection,timeout,of,the,specified,link,time,value,param,results,consumer,the,callback,when,pinging,is,complete,param,duration,the,timeout,for,various,components,of,the,pings;override,public,void,ping,final,consumer,ping,collection,results,consumer,final,time,value,duration,ping,results,consumer,duration,duration
UnicastZenPing -> @Override     public void ping(final Consumer<PingCollection> resultsConsumer, final TimeValue duration);1549356412;Sends three rounds of pings notifying the specified {@link Consumer} when pinging is complete. Pings are sent after resolving_configured unicast hosts to their IP address (subject to DNS caching within the JVM). A batch of pings is sent, then another batch_of pings is sent at half the specified {@link TimeValue}, and then another batch of pings is sent at the specified {@link TimeValue}._The pings that are sent carry a timeout of 1.25 times the specified {@link TimeValue}. When pinging each node, a connection and_handshake is performed, with a connection timeout of the specified {@link TimeValue}.__@param resultsConsumer the callback when pinging is complete_@param duration        the timeout for various components of the pings;@Override_    public void ping(final Consumer<PingCollection> resultsConsumer, final TimeValue duration) {_        ping(resultsConsumer, duration, duration)__    };sends,three,rounds,of,pings,notifying,the,specified,link,consumer,when,pinging,is,complete,pings,are,sent,after,resolving,configured,unicast,hosts,to,their,ip,address,subject,to,dns,caching,within,the,jvm,a,batch,of,pings,is,sent,then,another,batch,of,pings,is,sent,at,half,the,specified,link,time,value,and,then,another,batch,of,pings,is,sent,at,the,specified,link,time,value,the,pings,that,are,sent,carry,a,timeout,of,1,25,times,the,specified,link,time,value,when,pinging,each,node,a,connection,and,handshake,is,performed,with,a,connection,timeout,of,the,specified,link,time,value,param,results,consumer,the,callback,when,pinging,is,complete,param,duration,the,timeout,for,various,components,of,the,pings;override,public,void,ping,final,consumer,ping,collection,results,consumer,final,time,value,duration,ping,results,consumer,duration,duration
UnicastZenPing -> @Override     public void ping(final Consumer<PingCollection> resultsConsumer, final TimeValue duration);1549452878;Sends three rounds of pings notifying the specified {@link Consumer} when pinging is complete. Pings are sent after resolving_configured unicast hosts to their IP address (subject to DNS caching within the JVM). A batch of pings is sent, then another batch_of pings is sent at half the specified {@link TimeValue}, and then another batch of pings is sent at the specified {@link TimeValue}._The pings that are sent carry a timeout of 1.25 times the specified {@link TimeValue}. When pinging each node, a connection and_handshake is performed, with a connection timeout of the specified {@link TimeValue}.__@param resultsConsumer the callback when pinging is complete_@param duration        the timeout for various components of the pings;@Override_    public void ping(final Consumer<PingCollection> resultsConsumer, final TimeValue duration) {_        ping(resultsConsumer, duration, duration)__    };sends,three,rounds,of,pings,notifying,the,specified,link,consumer,when,pinging,is,complete,pings,are,sent,after,resolving,configured,unicast,hosts,to,their,ip,address,subject,to,dns,caching,within,the,jvm,a,batch,of,pings,is,sent,then,another,batch,of,pings,is,sent,at,half,the,specified,link,time,value,and,then,another,batch,of,pings,is,sent,at,the,specified,link,time,value,the,pings,that,are,sent,carry,a,timeout,of,1,25,times,the,specified,link,time,value,when,pinging,each,node,a,connection,and,handshake,is,performed,with,a,connection,timeout,of,the,specified,link,time,value,param,results,consumer,the,callback,when,pinging,is,complete,param,duration,the,timeout,for,various,components,of,the,pings;override,public,void,ping,final,consumer,ping,collection,results,consumer,final,time,value,duration,ping,results,consumer,duration,duration
UnicastZenPing -> @Override     public void ping(final Consumer<PingCollection> resultsConsumer, final TimeValue duration);1550575247;Sends three rounds of pings notifying the specified {@link Consumer} when pinging is complete. Pings are sent after resolving_configured unicast hosts to their IP address (subject to DNS caching within the JVM). A batch of pings is sent, then another batch_of pings is sent at half the specified {@link TimeValue}, and then another batch of pings is sent at the specified {@link TimeValue}._The pings that are sent carry a timeout of 1.25 times the specified {@link TimeValue}. When pinging each node, a connection and_handshake is performed, with a connection timeout of the specified {@link TimeValue}.__@param resultsConsumer the callback when pinging is complete_@param duration        the timeout for various components of the pings;@Override_    public void ping(final Consumer<PingCollection> resultsConsumer, final TimeValue duration) {_        ping(resultsConsumer, duration, duration)__    };sends,three,rounds,of,pings,notifying,the,specified,link,consumer,when,pinging,is,complete,pings,are,sent,after,resolving,configured,unicast,hosts,to,their,ip,address,subject,to,dns,caching,within,the,jvm,a,batch,of,pings,is,sent,then,another,batch,of,pings,is,sent,at,half,the,specified,link,time,value,and,then,another,batch,of,pings,is,sent,at,the,specified,link,time,value,the,pings,that,are,sent,carry,a,timeout,of,1,25,times,the,specified,link,time,value,when,pinging,each,node,a,connection,and,handshake,is,performed,with,a,connection,timeout,of,the,specified,link,time,value,param,results,consumer,the,callback,when,pinging,is,complete,param,duration,the,timeout,for,various,components,of,the,pings;override,public,void,ping,final,consumer,ping,collection,results,consumer,final,time,value,duration,ping,results,consumer,duration,duration
UnicastZenPing -> protected void ping(final Consumer<PingCollection> resultsConsumer,                         final TimeValue scheduleDuration,                         final TimeValue requestDuration);1524684173;a variant of {@link #ping(Consumer, TimeValue)}, but allows separating the scheduling duration_from the duration used for request level time outs. This is useful for testing;protected void ping(final Consumer<PingCollection> resultsConsumer,_                        final TimeValue scheduleDuration,_                        final TimeValue requestDuration) {_        final List<DiscoveryNode> seedNodes__        try {_            seedNodes = resolveHostsLists(_                unicastZenPingExecutorService,_                logger,_                configuredHosts,_                limitPortCounts,_                transportService,_                UNICAST_NODE_PREFIX,_                resolveTimeout)__        } catch (InterruptedException e) {_            throw new RuntimeException(e)__        }_        seedNodes.addAll(hostsProvider.buildDynamicNodes())__        final DiscoveryNodes nodes = contextProvider.clusterState().nodes()__        _        for (ObjectCursor<DiscoveryNode> masterNode : nodes.getMasterNodes().values()) {_            seedNodes.add(masterNode.value)__        }__        final ConnectionProfile connectionProfile =_            ConnectionProfile.buildSingleChannelProfile(TransportRequestOptions.Type.REG, requestDuration, requestDuration)__        final PingingRound pingingRound = new PingingRound(pingingRoundIdGenerator.incrementAndGet(), seedNodes, resultsConsumer,_            nodes.getLocalNode(), connectionProfile)__        activePingingRounds.put(pingingRound.id(), pingingRound)__        final AbstractRunnable pingSender = new AbstractRunnable() {_            @Override_            public void onFailure(Exception e) {_                if (e instanceof AlreadyClosedException == false) {_                    logger.warn("unexpected error while pinging", e)__                }_            }__            @Override_            protected void doRun() throws Exception {_                sendPings(requestDuration, pingingRound)__            }_        }__        threadPool.generic().execute(pingSender)__        threadPool.schedule(TimeValue.timeValueMillis(scheduleDuration.millis() / 3), ThreadPool.Names.GENERIC, pingSender)__        threadPool.schedule(TimeValue.timeValueMillis(scheduleDuration.millis() / 3 * 2), ThreadPool.Names.GENERIC, pingSender)__        threadPool.schedule(scheduleDuration, ThreadPool.Names.GENERIC, new AbstractRunnable() {_            @Override_            protected void doRun() throws Exception {_                finishPingingRound(pingingRound)__            }__            @Override_            public void onFailure(Exception e) {_                logger.warn("unexpected error while finishing pinging round", e)__            }_        })__    };a,variant,of,link,ping,consumer,time,value,but,allows,separating,the,scheduling,duration,from,the,duration,used,for,request,level,time,outs,this,is,useful,for,testing;protected,void,ping,final,consumer,ping,collection,results,consumer,final,time,value,schedule,duration,final,time,value,request,duration,final,list,discovery,node,seed,nodes,try,seed,nodes,resolve,hosts,lists,unicast,zen,ping,executor,service,logger,configured,hosts,limit,port,counts,transport,service,resolve,timeout,catch,interrupted,exception,e,throw,new,runtime,exception,e,seed,nodes,add,all,hosts,provider,build,dynamic,nodes,final,discovery,nodes,nodes,context,provider,cluster,state,nodes,for,object,cursor,discovery,node,master,node,nodes,get,master,nodes,values,seed,nodes,add,master,node,value,final,connection,profile,connection,profile,connection,profile,build,single,channel,profile,transport,request,options,type,reg,request,duration,request,duration,final,pinging,round,pinging,round,new,pinging,round,pinging,round,id,generator,increment,and,get,seed,nodes,results,consumer,nodes,get,local,node,connection,profile,active,pinging,rounds,put,pinging,round,id,pinging,round,final,abstract,runnable,ping,sender,new,abstract,runnable,override,public,void,on,failure,exception,e,if,e,instanceof,already,closed,exception,false,logger,warn,unexpected,error,while,pinging,e,override,protected,void,do,run,throws,exception,send,pings,request,duration,pinging,round,thread,pool,generic,execute,ping,sender,thread,pool,schedule,time,value,time,value,millis,schedule,duration,millis,3,thread,pool,names,generic,ping,sender,thread,pool,schedule,time,value,time,value,millis,schedule,duration,millis,3,2,thread,pool,names,generic,ping,sender,thread,pool,schedule,schedule,duration,thread,pool,names,generic,new,abstract,runnable,override,protected,void,do,run,throws,exception,finish,pinging,round,pinging,round,override,public,void,on,failure,exception,e,logger,warn,unexpected,error,while,finishing,pinging,round,e
UnicastZenPing -> protected void ping(final Consumer<PingCollection> resultsConsumer,                         final TimeValue scheduleDuration,                         final TimeValue requestDuration);1529600205;a variant of {@link #ping(Consumer, TimeValue)}, but allows separating the scheduling duration_from the duration used for request level time outs. This is useful for testing;protected void ping(final Consumer<PingCollection> resultsConsumer,_                        final TimeValue scheduleDuration,_                        final TimeValue requestDuration) {_        final List<TransportAddress> seedAddresses = new ArrayList<>()__        try {_            seedAddresses.addAll(resolveHostsLists(_                unicastZenPingExecutorService,_                logger,_                configuredHosts,_                limitPortCounts,_                transportService,_                resolveTimeout))__        } catch (InterruptedException e) {_            throw new RuntimeException(e)__        }_        seedAddresses.addAll(hostsProvider.buildDynamicHosts())__        final DiscoveryNodes nodes = contextProvider.clusterState().nodes()__        _        for (ObjectCursor<DiscoveryNode> masterNode : nodes.getMasterNodes().values()) {_            seedAddresses.add(masterNode.value.getAddress())__        }__        final ConnectionProfile connectionProfile =_            ConnectionProfile.buildSingleChannelProfile(TransportRequestOptions.Type.REG, requestDuration, requestDuration)__        final PingingRound pingingRound = new PingingRound(pingingRoundIdGenerator.incrementAndGet(), seedAddresses, resultsConsumer,_            nodes.getLocalNode(), connectionProfile)__        activePingingRounds.put(pingingRound.id(), pingingRound)__        final AbstractRunnable pingSender = new AbstractRunnable() {_            @Override_            public void onFailure(Exception e) {_                if (e instanceof AlreadyClosedException == false) {_                    logger.warn("unexpected error while pinging", e)__                }_            }__            @Override_            protected void doRun() throws Exception {_                sendPings(requestDuration, pingingRound)__            }_        }__        threadPool.generic().execute(pingSender)__        threadPool.schedule(TimeValue.timeValueMillis(scheduleDuration.millis() / 3), ThreadPool.Names.GENERIC, pingSender)__        threadPool.schedule(TimeValue.timeValueMillis(scheduleDuration.millis() / 3 * 2), ThreadPool.Names.GENERIC, pingSender)__        threadPool.schedule(scheduleDuration, ThreadPool.Names.GENERIC, new AbstractRunnable() {_            @Override_            protected void doRun() throws Exception {_                finishPingingRound(pingingRound)__            }__            @Override_            public void onFailure(Exception e) {_                logger.warn("unexpected error while finishing pinging round", e)__            }_        })__    };a,variant,of,link,ping,consumer,time,value,but,allows,separating,the,scheduling,duration,from,the,duration,used,for,request,level,time,outs,this,is,useful,for,testing;protected,void,ping,final,consumer,ping,collection,results,consumer,final,time,value,schedule,duration,final,time,value,request,duration,final,list,transport,address,seed,addresses,new,array,list,try,seed,addresses,add,all,resolve,hosts,lists,unicast,zen,ping,executor,service,logger,configured,hosts,limit,port,counts,transport,service,resolve,timeout,catch,interrupted,exception,e,throw,new,runtime,exception,e,seed,addresses,add,all,hosts,provider,build,dynamic,hosts,final,discovery,nodes,nodes,context,provider,cluster,state,nodes,for,object,cursor,discovery,node,master,node,nodes,get,master,nodes,values,seed,addresses,add,master,node,value,get,address,final,connection,profile,connection,profile,connection,profile,build,single,channel,profile,transport,request,options,type,reg,request,duration,request,duration,final,pinging,round,pinging,round,new,pinging,round,pinging,round,id,generator,increment,and,get,seed,addresses,results,consumer,nodes,get,local,node,connection,profile,active,pinging,rounds,put,pinging,round,id,pinging,round,final,abstract,runnable,ping,sender,new,abstract,runnable,override,public,void,on,failure,exception,e,if,e,instanceof,already,closed,exception,false,logger,warn,unexpected,error,while,pinging,e,override,protected,void,do,run,throws,exception,send,pings,request,duration,pinging,round,thread,pool,generic,execute,ping,sender,thread,pool,schedule,time,value,time,value,millis,schedule,duration,millis,3,thread,pool,names,generic,ping,sender,thread,pool,schedule,time,value,time,value,millis,schedule,duration,millis,3,2,thread,pool,names,generic,ping,sender,thread,pool,schedule,schedule,duration,thread,pool,names,generic,new,abstract,runnable,override,protected,void,do,run,throws,exception,finish,pinging,round,pinging,round,override,public,void,on,failure,exception,e,logger,warn,unexpected,error,while,finishing,pinging,round,e
UnicastZenPing -> protected void ping(final Consumer<PingCollection> resultsConsumer,                         final TimeValue scheduleDuration,                         final TimeValue requestDuration);1529687475;a variant of {@link #ping(Consumer, TimeValue)}, but allows separating the scheduling duration_from the duration used for request level time outs. This is useful for testing;protected void ping(final Consumer<PingCollection> resultsConsumer,_                        final TimeValue scheduleDuration,_                        final TimeValue requestDuration) {_        final List<TransportAddress> seedAddresses = new ArrayList<>()__        seedAddresses.addAll(hostsProvider.buildDynamicHosts(createHostsResolver()))__        final DiscoveryNodes nodes = contextProvider.clusterState().nodes()__        _        for (ObjectCursor<DiscoveryNode> masterNode : nodes.getMasterNodes().values()) {_            seedAddresses.add(masterNode.value.getAddress())__        }__        final ConnectionProfile connectionProfile =_            ConnectionProfile.buildSingleChannelProfile(TransportRequestOptions.Type.REG, requestDuration, requestDuration)__        final PingingRound pingingRound = new PingingRound(pingingRoundIdGenerator.incrementAndGet(), seedAddresses, resultsConsumer,_            nodes.getLocalNode(), connectionProfile)__        activePingingRounds.put(pingingRound.id(), pingingRound)__        final AbstractRunnable pingSender = new AbstractRunnable() {_            @Override_            public void onFailure(Exception e) {_                if (e instanceof AlreadyClosedException == false) {_                    logger.warn("unexpected error while pinging", e)__                }_            }__            @Override_            protected void doRun() throws Exception {_                sendPings(requestDuration, pingingRound)__            }_        }__        threadPool.generic().execute(pingSender)__        threadPool.schedule(TimeValue.timeValueMillis(scheduleDuration.millis() / 3), ThreadPool.Names.GENERIC, pingSender)__        threadPool.schedule(TimeValue.timeValueMillis(scheduleDuration.millis() / 3 * 2), ThreadPool.Names.GENERIC, pingSender)__        threadPool.schedule(scheduleDuration, ThreadPool.Names.GENERIC, new AbstractRunnable() {_            @Override_            protected void doRun() throws Exception {_                finishPingingRound(pingingRound)__            }__            @Override_            public void onFailure(Exception e) {_                logger.warn("unexpected error while finishing pinging round", e)__            }_        })__    };a,variant,of,link,ping,consumer,time,value,but,allows,separating,the,scheduling,duration,from,the,duration,used,for,request,level,time,outs,this,is,useful,for,testing;protected,void,ping,final,consumer,ping,collection,results,consumer,final,time,value,schedule,duration,final,time,value,request,duration,final,list,transport,address,seed,addresses,new,array,list,seed,addresses,add,all,hosts,provider,build,dynamic,hosts,create,hosts,resolver,final,discovery,nodes,nodes,context,provider,cluster,state,nodes,for,object,cursor,discovery,node,master,node,nodes,get,master,nodes,values,seed,addresses,add,master,node,value,get,address,final,connection,profile,connection,profile,connection,profile,build,single,channel,profile,transport,request,options,type,reg,request,duration,request,duration,final,pinging,round,pinging,round,new,pinging,round,pinging,round,id,generator,increment,and,get,seed,addresses,results,consumer,nodes,get,local,node,connection,profile,active,pinging,rounds,put,pinging,round,id,pinging,round,final,abstract,runnable,ping,sender,new,abstract,runnable,override,public,void,on,failure,exception,e,if,e,instanceof,already,closed,exception,false,logger,warn,unexpected,error,while,pinging,e,override,protected,void,do,run,throws,exception,send,pings,request,duration,pinging,round,thread,pool,generic,execute,ping,sender,thread,pool,schedule,time,value,time,value,millis,schedule,duration,millis,3,thread,pool,names,generic,ping,sender,thread,pool,schedule,time,value,time,value,millis,schedule,duration,millis,3,2,thread,pool,names,generic,ping,sender,thread,pool,schedule,schedule,duration,thread,pool,names,generic,new,abstract,runnable,override,protected,void,do,run,throws,exception,finish,pinging,round,pinging,round,override,public,void,on,failure,exception,e,logger,warn,unexpected,error,while,finishing,pinging,round,e
UnicastZenPing -> protected void ping(final Consumer<PingCollection> resultsConsumer,                         final TimeValue scheduleDuration,                         final TimeValue requestDuration);1540847035;a variant of {@link #ping(Consumer, TimeValue)}, but allows separating the scheduling duration_from the duration used for request level time outs. This is useful for testing;protected void ping(final Consumer<PingCollection> resultsConsumer,_                        final TimeValue scheduleDuration,_                        final TimeValue requestDuration) {_        final List<TransportAddress> seedAddresses = new ArrayList<>()__        seedAddresses.addAll(hostsProvider.buildDynamicHosts(createHostsResolver()))__        final DiscoveryNodes nodes = contextProvider.clusterState().nodes()__        _        for (ObjectCursor<DiscoveryNode> masterNode : nodes.getMasterNodes().values()) {_            seedAddresses.add(masterNode.value.getAddress())__        }__        final ConnectionProfile connectionProfile =_            ConnectionProfile.buildSingleChannelProfile(TransportRequestOptions.Type.REG, requestDuration, requestDuration)__        final PingingRound pingingRound = new PingingRound(pingingRoundIdGenerator.incrementAndGet(), seedAddresses, resultsConsumer,_            nodes.getLocalNode(), connectionProfile)__        activePingingRounds.put(pingingRound.id(), pingingRound)__        final AbstractRunnable pingSender = new AbstractRunnable() {_            @Override_            public void onFailure(Exception e) {_                if (e instanceof AlreadyClosedException == false) {_                    logger.warn("unexpected error while pinging", e)__                }_            }__            @Override_            protected void doRun() throws Exception {_                sendPings(requestDuration, pingingRound)__            }_        }__        threadPool.generic().execute(pingSender)__        threadPool.schedule(TimeValue.timeValueMillis(scheduleDuration.millis() / 3), ThreadPool.Names.GENERIC, pingSender)__        threadPool.schedule(TimeValue.timeValueMillis(scheduleDuration.millis() / 3 * 2), ThreadPool.Names.GENERIC, pingSender)__        threadPool.schedule(scheduleDuration, ThreadPool.Names.GENERIC, new AbstractRunnable() {_            @Override_            protected void doRun() throws Exception {_                finishPingingRound(pingingRound)__            }__            @Override_            public void onFailure(Exception e) {_                logger.warn("unexpected error while finishing pinging round", e)__            }_        })__    };a,variant,of,link,ping,consumer,time,value,but,allows,separating,the,scheduling,duration,from,the,duration,used,for,request,level,time,outs,this,is,useful,for,testing;protected,void,ping,final,consumer,ping,collection,results,consumer,final,time,value,schedule,duration,final,time,value,request,duration,final,list,transport,address,seed,addresses,new,array,list,seed,addresses,add,all,hosts,provider,build,dynamic,hosts,create,hosts,resolver,final,discovery,nodes,nodes,context,provider,cluster,state,nodes,for,object,cursor,discovery,node,master,node,nodes,get,master,nodes,values,seed,addresses,add,master,node,value,get,address,final,connection,profile,connection,profile,connection,profile,build,single,channel,profile,transport,request,options,type,reg,request,duration,request,duration,final,pinging,round,pinging,round,new,pinging,round,pinging,round,id,generator,increment,and,get,seed,addresses,results,consumer,nodes,get,local,node,connection,profile,active,pinging,rounds,put,pinging,round,id,pinging,round,final,abstract,runnable,ping,sender,new,abstract,runnable,override,public,void,on,failure,exception,e,if,e,instanceof,already,closed,exception,false,logger,warn,unexpected,error,while,pinging,e,override,protected,void,do,run,throws,exception,send,pings,request,duration,pinging,round,thread,pool,generic,execute,ping,sender,thread,pool,schedule,time,value,time,value,millis,schedule,duration,millis,3,thread,pool,names,generic,ping,sender,thread,pool,schedule,time,value,time,value,millis,schedule,duration,millis,3,2,thread,pool,names,generic,ping,sender,thread,pool,schedule,schedule,duration,thread,pool,names,generic,new,abstract,runnable,override,protected,void,do,run,throws,exception,finish,pinging,round,pinging,round,override,public,void,on,failure,exception,e,logger,warn,unexpected,error,while,finishing,pinging,round,e
UnicastZenPing -> protected void ping(final Consumer<PingCollection> resultsConsumer,                         final TimeValue scheduleDuration,                         final TimeValue requestDuration);1541092382;a variant of {@link #ping(Consumer, TimeValue)}, but allows separating the scheduling duration_from the duration used for request level time outs. This is useful for testing;protected void ping(final Consumer<PingCollection> resultsConsumer,_                        final TimeValue scheduleDuration,_                        final TimeValue requestDuration) {_        final List<TransportAddress> seedAddresses = new ArrayList<>()__        seedAddresses.addAll(hostsProvider.buildDynamicHosts(createHostsResolver()))__        final DiscoveryNodes nodes = contextProvider.clusterState().nodes()__        _        for (ObjectCursor<DiscoveryNode> masterNode : nodes.getMasterNodes().values()) {_            seedAddresses.add(masterNode.value.getAddress())__        }__        final ConnectionProfile connectionProfile =_            ConnectionProfile.buildSingleChannelProfile(TransportRequestOptions.Type.REG, requestDuration, requestDuration)__        final PingingRound pingingRound = new PingingRound(pingingRoundIdGenerator.incrementAndGet(), seedAddresses, resultsConsumer,_            nodes.getLocalNode(), connectionProfile)__        activePingingRounds.put(pingingRound.id(), pingingRound)__        final AbstractRunnable pingSender = new AbstractRunnable() {_            @Override_            public void onFailure(Exception e) {_                if (e instanceof AlreadyClosedException == false) {_                    logger.warn("unexpected error while pinging", e)__                }_            }__            @Override_            protected void doRun() throws Exception {_                sendPings(requestDuration, pingingRound)__            }_        }__        threadPool.generic().execute(pingSender)__        threadPool.schedule(TimeValue.timeValueMillis(scheduleDuration.millis() / 3), ThreadPool.Names.GENERIC, pingSender)__        threadPool.schedule(TimeValue.timeValueMillis(scheduleDuration.millis() / 3 * 2), ThreadPool.Names.GENERIC, pingSender)__        threadPool.schedule(scheduleDuration, ThreadPool.Names.GENERIC, new AbstractRunnable() {_            @Override_            protected void doRun() throws Exception {_                finishPingingRound(pingingRound)__            }__            @Override_            public void onFailure(Exception e) {_                logger.warn("unexpected error while finishing pinging round", e)__            }_        })__    };a,variant,of,link,ping,consumer,time,value,but,allows,separating,the,scheduling,duration,from,the,duration,used,for,request,level,time,outs,this,is,useful,for,testing;protected,void,ping,final,consumer,ping,collection,results,consumer,final,time,value,schedule,duration,final,time,value,request,duration,final,list,transport,address,seed,addresses,new,array,list,seed,addresses,add,all,hosts,provider,build,dynamic,hosts,create,hosts,resolver,final,discovery,nodes,nodes,context,provider,cluster,state,nodes,for,object,cursor,discovery,node,master,node,nodes,get,master,nodes,values,seed,addresses,add,master,node,value,get,address,final,connection,profile,connection,profile,connection,profile,build,single,channel,profile,transport,request,options,type,reg,request,duration,request,duration,final,pinging,round,pinging,round,new,pinging,round,pinging,round,id,generator,increment,and,get,seed,addresses,results,consumer,nodes,get,local,node,connection,profile,active,pinging,rounds,put,pinging,round,id,pinging,round,final,abstract,runnable,ping,sender,new,abstract,runnable,override,public,void,on,failure,exception,e,if,e,instanceof,already,closed,exception,false,logger,warn,unexpected,error,while,pinging,e,override,protected,void,do,run,throws,exception,send,pings,request,duration,pinging,round,thread,pool,generic,execute,ping,sender,thread,pool,schedule,time,value,time,value,millis,schedule,duration,millis,3,thread,pool,names,generic,ping,sender,thread,pool,schedule,time,value,time,value,millis,schedule,duration,millis,3,2,thread,pool,names,generic,ping,sender,thread,pool,schedule,schedule,duration,thread,pool,names,generic,new,abstract,runnable,override,protected,void,do,run,throws,exception,finish,pinging,round,pinging,round,override,public,void,on,failure,exception,e,logger,warn,unexpected,error,while,finishing,pinging,round,e
UnicastZenPing -> protected void ping(final Consumer<PingCollection> resultsConsumer,                         final TimeValue scheduleDuration,                         final TimeValue requestDuration);1542402632;a variant of {@link #ping(Consumer, TimeValue)}, but allows separating the scheduling duration_from the duration used for request level time outs. This is useful for testing;protected void ping(final Consumer<PingCollection> resultsConsumer,_                        final TimeValue scheduleDuration,_                        final TimeValue requestDuration) {_        final List<TransportAddress> seedAddresses = new ArrayList<>()__        seedAddresses.addAll(hostsProvider.buildDynamicHosts(createHostsResolver()))__        final DiscoveryNodes nodes = contextProvider.clusterState().nodes()__        _        for (ObjectCursor<DiscoveryNode> masterNode : nodes.getMasterNodes().values()) {_            seedAddresses.add(masterNode.value.getAddress())__        }__        final ConnectionProfile connectionProfile =_            ConnectionProfile.buildSingleChannelProfile(TransportRequestOptions.Type.REG, requestDuration, requestDuration)__        final PingingRound pingingRound = new PingingRound(pingingRoundIdGenerator.incrementAndGet(), seedAddresses, resultsConsumer,_            nodes.getLocalNode(), connectionProfile)__        activePingingRounds.put(pingingRound.id(), pingingRound)__        final AbstractRunnable pingSender = new AbstractRunnable() {_            @Override_            public void onFailure(Exception e) {_                if (e instanceof AlreadyClosedException == false) {_                    logger.warn("unexpected error while pinging", e)__                }_            }__            @Override_            protected void doRun() throws Exception {_                sendPings(requestDuration, pingingRound)__            }_        }__        threadPool.generic().execute(pingSender)__        threadPool.schedule(TimeValue.timeValueMillis(scheduleDuration.millis() / 3), ThreadPool.Names.GENERIC, pingSender)__        threadPool.schedule(TimeValue.timeValueMillis(scheduleDuration.millis() / 3 * 2), ThreadPool.Names.GENERIC, pingSender)__        threadPool.schedule(scheduleDuration, ThreadPool.Names.GENERIC, new AbstractRunnable() {_            @Override_            protected void doRun() throws Exception {_                finishPingingRound(pingingRound)__            }__            @Override_            public void onFailure(Exception e) {_                logger.warn("unexpected error while finishing pinging round", e)__            }_        })__    };a,variant,of,link,ping,consumer,time,value,but,allows,separating,the,scheduling,duration,from,the,duration,used,for,request,level,time,outs,this,is,useful,for,testing;protected,void,ping,final,consumer,ping,collection,results,consumer,final,time,value,schedule,duration,final,time,value,request,duration,final,list,transport,address,seed,addresses,new,array,list,seed,addresses,add,all,hosts,provider,build,dynamic,hosts,create,hosts,resolver,final,discovery,nodes,nodes,context,provider,cluster,state,nodes,for,object,cursor,discovery,node,master,node,nodes,get,master,nodes,values,seed,addresses,add,master,node,value,get,address,final,connection,profile,connection,profile,connection,profile,build,single,channel,profile,transport,request,options,type,reg,request,duration,request,duration,final,pinging,round,pinging,round,new,pinging,round,pinging,round,id,generator,increment,and,get,seed,addresses,results,consumer,nodes,get,local,node,connection,profile,active,pinging,rounds,put,pinging,round,id,pinging,round,final,abstract,runnable,ping,sender,new,abstract,runnable,override,public,void,on,failure,exception,e,if,e,instanceof,already,closed,exception,false,logger,warn,unexpected,error,while,pinging,e,override,protected,void,do,run,throws,exception,send,pings,request,duration,pinging,round,thread,pool,generic,execute,ping,sender,thread,pool,schedule,time,value,time,value,millis,schedule,duration,millis,3,thread,pool,names,generic,ping,sender,thread,pool,schedule,time,value,time,value,millis,schedule,duration,millis,3,2,thread,pool,names,generic,ping,sender,thread,pool,schedule,schedule,duration,thread,pool,names,generic,new,abstract,runnable,override,protected,void,do,run,throws,exception,finish,pinging,round,pinging,round,override,public,void,on,failure,exception,e,logger,warn,unexpected,error,while,finishing,pinging,round,e
UnicastZenPing -> protected void ping(final Consumer<PingCollection> resultsConsumer,                         final TimeValue scheduleDuration,                         final TimeValue requestDuration);1544081506;a variant of {@link #ping(Consumer, TimeValue)}, but allows separating the scheduling duration_from the duration used for request level time outs. This is useful for testing;protected void ping(final Consumer<PingCollection> resultsConsumer,_                        final TimeValue scheduleDuration,_                        final TimeValue requestDuration) {_        final List<TransportAddress> seedAddresses = new ArrayList<>()__        seedAddresses.addAll(hostsProvider.buildDynamicHosts(createHostsResolver()))__        final DiscoveryNodes nodes = contextProvider.clusterState().nodes()__        _        for (ObjectCursor<DiscoveryNode> masterNode : nodes.getMasterNodes().values()) {_            seedAddresses.add(masterNode.value.getAddress())__        }__        final ConnectionProfile connectionProfile =_            ConnectionProfile.buildSingleChannelProfile(TransportRequestOptions.Type.REG, requestDuration, requestDuration)__        final PingingRound pingingRound = new PingingRound(pingingRoundIdGenerator.incrementAndGet(), seedAddresses, resultsConsumer,_            nodes.getLocalNode(), connectionProfile)__        activePingingRounds.put(pingingRound.id(), pingingRound)__        final AbstractRunnable pingSender = new AbstractRunnable() {_            @Override_            public void onFailure(Exception e) {_                if (e instanceof AlreadyClosedException == false) {_                    logger.warn("unexpected error while pinging", e)__                }_            }__            @Override_            protected void doRun() throws Exception {_                sendPings(requestDuration, pingingRound)__            }_        }__        threadPool.generic().execute(pingSender)__        threadPool.schedule(TimeValue.timeValueMillis(scheduleDuration.millis() / 3), ThreadPool.Names.GENERIC, pingSender)__        threadPool.schedule(TimeValue.timeValueMillis(scheduleDuration.millis() / 3 * 2), ThreadPool.Names.GENERIC, pingSender)__        threadPool.schedule(scheduleDuration, ThreadPool.Names.GENERIC, new AbstractRunnable() {_            @Override_            protected void doRun() throws Exception {_                finishPingingRound(pingingRound)__            }__            @Override_            public void onFailure(Exception e) {_                logger.warn("unexpected error while finishing pinging round", e)__            }_        })__    };a,variant,of,link,ping,consumer,time,value,but,allows,separating,the,scheduling,duration,from,the,duration,used,for,request,level,time,outs,this,is,useful,for,testing;protected,void,ping,final,consumer,ping,collection,results,consumer,final,time,value,schedule,duration,final,time,value,request,duration,final,list,transport,address,seed,addresses,new,array,list,seed,addresses,add,all,hosts,provider,build,dynamic,hosts,create,hosts,resolver,final,discovery,nodes,nodes,context,provider,cluster,state,nodes,for,object,cursor,discovery,node,master,node,nodes,get,master,nodes,values,seed,addresses,add,master,node,value,get,address,final,connection,profile,connection,profile,connection,profile,build,single,channel,profile,transport,request,options,type,reg,request,duration,request,duration,final,pinging,round,pinging,round,new,pinging,round,pinging,round,id,generator,increment,and,get,seed,addresses,results,consumer,nodes,get,local,node,connection,profile,active,pinging,rounds,put,pinging,round,id,pinging,round,final,abstract,runnable,ping,sender,new,abstract,runnable,override,public,void,on,failure,exception,e,if,e,instanceof,already,closed,exception,false,logger,warn,unexpected,error,while,pinging,e,override,protected,void,do,run,throws,exception,send,pings,request,duration,pinging,round,thread,pool,generic,execute,ping,sender,thread,pool,schedule,time,value,time,value,millis,schedule,duration,millis,3,thread,pool,names,generic,ping,sender,thread,pool,schedule,time,value,time,value,millis,schedule,duration,millis,3,2,thread,pool,names,generic,ping,sender,thread,pool,schedule,schedule,duration,thread,pool,names,generic,new,abstract,runnable,override,protected,void,do,run,throws,exception,finish,pinging,round,pinging,round,override,public,void,on,failure,exception,e,logger,warn,unexpected,error,while,finishing,pinging,round,e
UnicastZenPing -> protected void ping(final Consumer<PingCollection> resultsConsumer,                         final TimeValue scheduleDuration,                         final TimeValue requestDuration);1548953505;a variant of {@link #ping(Consumer, TimeValue)}, but allows separating the scheduling duration_from the duration used for request level time outs. This is useful for testing;protected void ping(final Consumer<PingCollection> resultsConsumer,_                        final TimeValue scheduleDuration,_                        final TimeValue requestDuration) {_        final List<TransportAddress> seedAddresses = new ArrayList<>()__        seedAddresses.addAll(hostsProvider.buildDynamicHosts(createHostsResolver()))__        final DiscoveryNodes nodes = contextProvider.clusterState().nodes()__        _        for (ObjectCursor<DiscoveryNode> masterNode : nodes.getMasterNodes().values()) {_            seedAddresses.add(masterNode.value.getAddress())__        }__        final ConnectionProfile connectionProfile =_            ConnectionProfile.buildSingleChannelProfile(TransportRequestOptions.Type.REG, requestDuration, requestDuration)__        final PingingRound pingingRound = new PingingRound(pingingRoundIdGenerator.incrementAndGet(), seedAddresses, resultsConsumer,_            nodes.getLocalNode(), connectionProfile)__        activePingingRounds.put(pingingRound.id(), pingingRound)__        final AbstractRunnable pingSender = new AbstractRunnable() {_            @Override_            public void onFailure(Exception e) {_                if (e instanceof AlreadyClosedException == false) {_                    logger.warn("unexpected error while pinging", e)__                }_            }__            @Override_            protected void doRun() throws Exception {_                sendPings(requestDuration, pingingRound)__            }_        }__        threadPool.generic().execute(pingSender)__        threadPool.schedule(pingSender, TimeValue.timeValueMillis(scheduleDuration.millis() / 3), ThreadPool.Names.GENERIC)__        threadPool.schedule(pingSender, TimeValue.timeValueMillis(scheduleDuration.millis() / 3 * 2), ThreadPool.Names.GENERIC)__        threadPool.schedule(new AbstractRunnable() {_            @Override_            protected void doRun() throws Exception {_                finishPingingRound(pingingRound)__            }__            @Override_            public void onFailure(Exception e) {_                logger.warn("unexpected error while finishing pinging round", e)__            }_        }, scheduleDuration, ThreadPool.Names.GENERIC)__    };a,variant,of,link,ping,consumer,time,value,but,allows,separating,the,scheduling,duration,from,the,duration,used,for,request,level,time,outs,this,is,useful,for,testing;protected,void,ping,final,consumer,ping,collection,results,consumer,final,time,value,schedule,duration,final,time,value,request,duration,final,list,transport,address,seed,addresses,new,array,list,seed,addresses,add,all,hosts,provider,build,dynamic,hosts,create,hosts,resolver,final,discovery,nodes,nodes,context,provider,cluster,state,nodes,for,object,cursor,discovery,node,master,node,nodes,get,master,nodes,values,seed,addresses,add,master,node,value,get,address,final,connection,profile,connection,profile,connection,profile,build,single,channel,profile,transport,request,options,type,reg,request,duration,request,duration,final,pinging,round,pinging,round,new,pinging,round,pinging,round,id,generator,increment,and,get,seed,addresses,results,consumer,nodes,get,local,node,connection,profile,active,pinging,rounds,put,pinging,round,id,pinging,round,final,abstract,runnable,ping,sender,new,abstract,runnable,override,public,void,on,failure,exception,e,if,e,instanceof,already,closed,exception,false,logger,warn,unexpected,error,while,pinging,e,override,protected,void,do,run,throws,exception,send,pings,request,duration,pinging,round,thread,pool,generic,execute,ping,sender,thread,pool,schedule,ping,sender,time,value,time,value,millis,schedule,duration,millis,3,thread,pool,names,generic,thread,pool,schedule,ping,sender,time,value,time,value,millis,schedule,duration,millis,3,2,thread,pool,names,generic,thread,pool,schedule,new,abstract,runnable,override,protected,void,do,run,throws,exception,finish,pinging,round,pinging,round,override,public,void,on,failure,exception,e,logger,warn,unexpected,error,while,finishing,pinging,round,e,schedule,duration,thread,pool,names,generic
UnicastZenPing -> protected void ping(final Consumer<PingCollection> resultsConsumer,                         final TimeValue scheduleDuration,                         final TimeValue requestDuration);1549356412;a variant of {@link #ping(Consumer, TimeValue)}, but allows separating the scheduling duration_from the duration used for request level time outs. This is useful for testing;protected void ping(final Consumer<PingCollection> resultsConsumer,_                        final TimeValue scheduleDuration,_                        final TimeValue requestDuration) {_        final List<TransportAddress> seedAddresses = new ArrayList<>()__        seedAddresses.addAll(hostsProvider.buildDynamicHosts(createHostsResolver()))__        final DiscoveryNodes nodes = contextProvider.clusterState().nodes()__        _        for (ObjectCursor<DiscoveryNode> masterNode : nodes.getMasterNodes().values()) {_            seedAddresses.add(masterNode.value.getAddress())__        }__        final ConnectionProfile connectionProfile =_            ConnectionProfile.buildSingleChannelProfile(TransportRequestOptions.Type.REG, requestDuration, requestDuration)__        final PingingRound pingingRound = new PingingRound(pingingRoundIdGenerator.incrementAndGet(), seedAddresses, resultsConsumer,_            nodes.getLocalNode(), connectionProfile)__        activePingingRounds.put(pingingRound.id(), pingingRound)__        final AbstractRunnable pingSender = new AbstractRunnable() {_            @Override_            public void onFailure(Exception e) {_                if (e instanceof AlreadyClosedException == false) {_                    logger.warn("unexpected error while pinging", e)__                }_            }__            @Override_            protected void doRun() throws Exception {_                sendPings(requestDuration, pingingRound)__            }_        }__        threadPool.generic().execute(pingSender)__        threadPool.schedule(pingSender, TimeValue.timeValueMillis(scheduleDuration.millis() / 3), ThreadPool.Names.GENERIC)__        threadPool.schedule(pingSender, TimeValue.timeValueMillis(scheduleDuration.millis() / 3 * 2), ThreadPool.Names.GENERIC)__        threadPool.schedule(new AbstractRunnable() {_            @Override_            protected void doRun() throws Exception {_                finishPingingRound(pingingRound)__            }__            @Override_            public void onFailure(Exception e) {_                logger.warn("unexpected error while finishing pinging round", e)__            }_        }, scheduleDuration, ThreadPool.Names.GENERIC)__    };a,variant,of,link,ping,consumer,time,value,but,allows,separating,the,scheduling,duration,from,the,duration,used,for,request,level,time,outs,this,is,useful,for,testing;protected,void,ping,final,consumer,ping,collection,results,consumer,final,time,value,schedule,duration,final,time,value,request,duration,final,list,transport,address,seed,addresses,new,array,list,seed,addresses,add,all,hosts,provider,build,dynamic,hosts,create,hosts,resolver,final,discovery,nodes,nodes,context,provider,cluster,state,nodes,for,object,cursor,discovery,node,master,node,nodes,get,master,nodes,values,seed,addresses,add,master,node,value,get,address,final,connection,profile,connection,profile,connection,profile,build,single,channel,profile,transport,request,options,type,reg,request,duration,request,duration,final,pinging,round,pinging,round,new,pinging,round,pinging,round,id,generator,increment,and,get,seed,addresses,results,consumer,nodes,get,local,node,connection,profile,active,pinging,rounds,put,pinging,round,id,pinging,round,final,abstract,runnable,ping,sender,new,abstract,runnable,override,public,void,on,failure,exception,e,if,e,instanceof,already,closed,exception,false,logger,warn,unexpected,error,while,pinging,e,override,protected,void,do,run,throws,exception,send,pings,request,duration,pinging,round,thread,pool,generic,execute,ping,sender,thread,pool,schedule,ping,sender,time,value,time,value,millis,schedule,duration,millis,3,thread,pool,names,generic,thread,pool,schedule,ping,sender,time,value,time,value,millis,schedule,duration,millis,3,2,thread,pool,names,generic,thread,pool,schedule,new,abstract,runnable,override,protected,void,do,run,throws,exception,finish,pinging,round,pinging,round,override,public,void,on,failure,exception,e,logger,warn,unexpected,error,while,finishing,pinging,round,e,schedule,duration,thread,pool,names,generic
UnicastZenPing -> protected void ping(final Consumer<PingCollection> resultsConsumer,                         final TimeValue scheduleDuration,                         final TimeValue requestDuration);1549452878;a variant of {@link #ping(Consumer, TimeValue)}, but allows separating the scheduling duration_from the duration used for request level time outs. This is useful for testing;protected void ping(final Consumer<PingCollection> resultsConsumer,_                        final TimeValue scheduleDuration,_                        final TimeValue requestDuration) {_        final List<TransportAddress> seedAddresses = new ArrayList<>()__        seedAddresses.addAll(hostsProvider.getSeedAddresses(createHostsResolver()))__        final DiscoveryNodes nodes = contextProvider.clusterState().nodes()__        _        for (ObjectCursor<DiscoveryNode> masterNode : nodes.getMasterNodes().values()) {_            seedAddresses.add(masterNode.value.getAddress())__        }__        final ConnectionProfile connectionProfile =_            ConnectionProfile.buildSingleChannelProfile(TransportRequestOptions.Type.REG, requestDuration, requestDuration)__        final PingingRound pingingRound = new PingingRound(pingingRoundIdGenerator.incrementAndGet(), seedAddresses, resultsConsumer,_            nodes.getLocalNode(), connectionProfile)__        activePingingRounds.put(pingingRound.id(), pingingRound)__        final AbstractRunnable pingSender = new AbstractRunnable() {_            @Override_            public void onFailure(Exception e) {_                if (e instanceof AlreadyClosedException == false) {_                    logger.warn("unexpected error while pinging", e)__                }_            }__            @Override_            protected void doRun() throws Exception {_                sendPings(requestDuration, pingingRound)__            }_        }__        threadPool.generic().execute(pingSender)__        threadPool.schedule(pingSender, TimeValue.timeValueMillis(scheduleDuration.millis() / 3), ThreadPool.Names.GENERIC)__        threadPool.schedule(pingSender, TimeValue.timeValueMillis(scheduleDuration.millis() / 3 * 2), ThreadPool.Names.GENERIC)__        threadPool.schedule(new AbstractRunnable() {_            @Override_            protected void doRun() throws Exception {_                finishPingingRound(pingingRound)__            }__            @Override_            public void onFailure(Exception e) {_                logger.warn("unexpected error while finishing pinging round", e)__            }_        }, scheduleDuration, ThreadPool.Names.GENERIC)__    };a,variant,of,link,ping,consumer,time,value,but,allows,separating,the,scheduling,duration,from,the,duration,used,for,request,level,time,outs,this,is,useful,for,testing;protected,void,ping,final,consumer,ping,collection,results,consumer,final,time,value,schedule,duration,final,time,value,request,duration,final,list,transport,address,seed,addresses,new,array,list,seed,addresses,add,all,hosts,provider,get,seed,addresses,create,hosts,resolver,final,discovery,nodes,nodes,context,provider,cluster,state,nodes,for,object,cursor,discovery,node,master,node,nodes,get,master,nodes,values,seed,addresses,add,master,node,value,get,address,final,connection,profile,connection,profile,connection,profile,build,single,channel,profile,transport,request,options,type,reg,request,duration,request,duration,final,pinging,round,pinging,round,new,pinging,round,pinging,round,id,generator,increment,and,get,seed,addresses,results,consumer,nodes,get,local,node,connection,profile,active,pinging,rounds,put,pinging,round,id,pinging,round,final,abstract,runnable,ping,sender,new,abstract,runnable,override,public,void,on,failure,exception,e,if,e,instanceof,already,closed,exception,false,logger,warn,unexpected,error,while,pinging,e,override,protected,void,do,run,throws,exception,send,pings,request,duration,pinging,round,thread,pool,generic,execute,ping,sender,thread,pool,schedule,ping,sender,time,value,time,value,millis,schedule,duration,millis,3,thread,pool,names,generic,thread,pool,schedule,ping,sender,time,value,time,value,millis,schedule,duration,millis,3,2,thread,pool,names,generic,thread,pool,schedule,new,abstract,runnable,override,protected,void,do,run,throws,exception,finish,pinging,round,pinging,round,override,public,void,on,failure,exception,e,logger,warn,unexpected,error,while,finishing,pinging,round,e,schedule,duration,thread,pool,names,generic
UnicastZenPing -> protected void ping(final Consumer<PingCollection> resultsConsumer,                         final TimeValue scheduleDuration,                         final TimeValue requestDuration);1550575247;a variant of {@link #ping(Consumer, TimeValue)}, but allows separating the scheduling duration_from the duration used for request level time outs. This is useful for testing;protected void ping(final Consumer<PingCollection> resultsConsumer,_                        final TimeValue scheduleDuration,_                        final TimeValue requestDuration) {_        final List<TransportAddress> seedAddresses = new ArrayList<>()__        seedAddresses.addAll(hostsProvider.getSeedAddresses(createHostsResolver()))__        final DiscoveryNodes nodes = contextProvider.clusterState().nodes()__        _        for (ObjectCursor<DiscoveryNode> masterNode : nodes.getMasterNodes().values()) {_            seedAddresses.add(masterNode.value.getAddress())__        }__        final ConnectionProfile connectionProfile =_            ConnectionProfile.buildSingleChannelProfile(TransportRequestOptions.Type.REG, requestDuration, requestDuration,_                TimeValue.MINUS_ONE, null)__        final PingingRound pingingRound = new PingingRound(pingingRoundIdGenerator.incrementAndGet(), seedAddresses, resultsConsumer,_            nodes.getLocalNode(), connectionProfile)__        activePingingRounds.put(pingingRound.id(), pingingRound)__        final AbstractRunnable pingSender = new AbstractRunnable() {_            @Override_            public void onFailure(Exception e) {_                if (e instanceof AlreadyClosedException == false) {_                    logger.warn("unexpected error while pinging", e)__                }_            }__            @Override_            protected void doRun() throws Exception {_                sendPings(requestDuration, pingingRound)__            }_        }__        threadPool.generic().execute(pingSender)__        threadPool.schedule(pingSender, TimeValue.timeValueMillis(scheduleDuration.millis() / 3), ThreadPool.Names.GENERIC)__        threadPool.schedule(pingSender, TimeValue.timeValueMillis(scheduleDuration.millis() / 3 * 2), ThreadPool.Names.GENERIC)__        threadPool.schedule(new AbstractRunnable() {_            @Override_            protected void doRun() throws Exception {_                finishPingingRound(pingingRound)__            }__            @Override_            public void onFailure(Exception e) {_                logger.warn("unexpected error while finishing pinging round", e)__            }_        }, scheduleDuration, ThreadPool.Names.GENERIC)__    };a,variant,of,link,ping,consumer,time,value,but,allows,separating,the,scheduling,duration,from,the,duration,used,for,request,level,time,outs,this,is,useful,for,testing;protected,void,ping,final,consumer,ping,collection,results,consumer,final,time,value,schedule,duration,final,time,value,request,duration,final,list,transport,address,seed,addresses,new,array,list,seed,addresses,add,all,hosts,provider,get,seed,addresses,create,hosts,resolver,final,discovery,nodes,nodes,context,provider,cluster,state,nodes,for,object,cursor,discovery,node,master,node,nodes,get,master,nodes,values,seed,addresses,add,master,node,value,get,address,final,connection,profile,connection,profile,connection,profile,build,single,channel,profile,transport,request,options,type,reg,request,duration,request,duration,time,value,null,final,pinging,round,pinging,round,new,pinging,round,pinging,round,id,generator,increment,and,get,seed,addresses,results,consumer,nodes,get,local,node,connection,profile,active,pinging,rounds,put,pinging,round,id,pinging,round,final,abstract,runnable,ping,sender,new,abstract,runnable,override,public,void,on,failure,exception,e,if,e,instanceof,already,closed,exception,false,logger,warn,unexpected,error,while,pinging,e,override,protected,void,do,run,throws,exception,send,pings,request,duration,pinging,round,thread,pool,generic,execute,ping,sender,thread,pool,schedule,ping,sender,time,value,time,value,millis,schedule,duration,millis,3,thread,pool,names,generic,thread,pool,schedule,ping,sender,time,value,time,value,millis,schedule,duration,millis,3,2,thread,pool,names,generic,thread,pool,schedule,new,abstract,runnable,override,protected,void,do,run,throws,exception,finish,pinging,round,pinging,round,override,public,void,on,failure,exception,e,logger,warn,unexpected,error,while,finishing,pinging,round,e,schedule,duration,thread,pool,names,generic
UnicastZenPing -> public static List<TransportAddress> resolveHostsLists(         final ExecutorService executorService,         final Logger logger,         final List<String> hosts,         final int limitPortCounts,         final TransportService transportService,         final TimeValue resolveTimeout);1529687475;Resolves a list of hosts to a list of transport addresses. Each host is resolved into a transport address (or a collection of_addresses if the number of ports is greater than one). Host lookups are done in parallel using specified executor service up_to the specified resolve timeout.__@param executorService  the executor service used to parallelize hostname lookups_@param logger           logger used for logging messages regarding hostname lookups_@param hosts            the hosts to resolve_@param limitPortCounts  the number of ports to resolve (should be 1 for non-local transport)_@param transportService the transport service_@param resolveTimeout   the timeout before returning from hostname lookups_@return a list of resolved transport addresses;public static List<TransportAddress> resolveHostsLists(_        final ExecutorService executorService,_        final Logger logger,_        final List<String> hosts,_        final int limitPortCounts,_        final TransportService transportService,_        final TimeValue resolveTimeout) {_        Objects.requireNonNull(executorService)__        Objects.requireNonNull(logger)__        Objects.requireNonNull(hosts)__        Objects.requireNonNull(transportService)__        Objects.requireNonNull(resolveTimeout)__        if (resolveTimeout.nanos() < 0) {_            throw new IllegalArgumentException("resolve timeout must be non-negative but was [" + resolveTimeout + "]")__        }_        _        final List<Callable<TransportAddress[]>> callables =_            hosts_                .stream()_                .map(hn -> (Callable<TransportAddress[]>) () -> transportService.addressesFromString(hn, limitPortCounts))_                .collect(Collectors.toList())__        final List<Future<TransportAddress[]>> futures__        try {_            futures = executorService.invokeAll(callables, resolveTimeout.nanos(), TimeUnit.NANOSECONDS)__        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()__            return Collections.emptyList()__        }_        final List<TransportAddress> transportAddresses = new ArrayList<>()__        final Set<TransportAddress> localAddresses = new HashSet<>()__        localAddresses.add(transportService.boundAddress().publishAddress())__        localAddresses.addAll(Arrays.asList(transportService.boundAddress().boundAddresses()))__        _        _        final Iterator<String> it = hosts.iterator()__        for (final Future<TransportAddress[]> future : futures) {_            final String hostname = it.next()__            if (!future.isCancelled()) {_                assert future.isDone()__                try {_                    final TransportAddress[] addresses = future.get()__                    logger.trace("resolved host [{}] to {}", hostname, addresses)__                    for (int addressId = 0_ addressId < addresses.length_ addressId++) {_                        final TransportAddress address = addresses[addressId]__                        _                        if (localAddresses.contains(address) == false) {_                            transportAddresses.add(address)__                        }_                    }_                } catch (final ExecutionException e) {_                    assert e.getCause() != null__                    final String message = "failed to resolve host [" + hostname + "]"__                    logger.warn(message, e.getCause())__                } catch (InterruptedException e) {_                    Thread.currentThread().interrupt()__                    _                }_            } else {_                logger.warn("timed out after [{}] resolving host [{}]", resolveTimeout, hostname)__            }_        }_        return Collections.unmodifiableList(transportAddresses)__    };resolves,a,list,of,hosts,to,a,list,of,transport,addresses,each,host,is,resolved,into,a,transport,address,or,a,collection,of,addresses,if,the,number,of,ports,is,greater,than,one,host,lookups,are,done,in,parallel,using,specified,executor,service,up,to,the,specified,resolve,timeout,param,executor,service,the,executor,service,used,to,parallelize,hostname,lookups,param,logger,logger,used,for,logging,messages,regarding,hostname,lookups,param,hosts,the,hosts,to,resolve,param,limit,port,counts,the,number,of,ports,to,resolve,should,be,1,for,non,local,transport,param,transport,service,the,transport,service,param,resolve,timeout,the,timeout,before,returning,from,hostname,lookups,return,a,list,of,resolved,transport,addresses;public,static,list,transport,address,resolve,hosts,lists,final,executor,service,executor,service,final,logger,logger,final,list,string,hosts,final,int,limit,port,counts,final,transport,service,transport,service,final,time,value,resolve,timeout,objects,require,non,null,executor,service,objects,require,non,null,logger,objects,require,non,null,hosts,objects,require,non,null,transport,service,objects,require,non,null,resolve,timeout,if,resolve,timeout,nanos,0,throw,new,illegal,argument,exception,resolve,timeout,must,be,non,negative,but,was,resolve,timeout,final,list,callable,transport,address,callables,hosts,stream,map,hn,callable,transport,address,transport,service,addresses,from,string,hn,limit,port,counts,collect,collectors,to,list,final,list,future,transport,address,futures,try,futures,executor,service,invoke,all,callables,resolve,timeout,nanos,time,unit,nanoseconds,catch,interrupted,exception,e,thread,current,thread,interrupt,return,collections,empty,list,final,list,transport,address,transport,addresses,new,array,list,final,set,transport,address,local,addresses,new,hash,set,local,addresses,add,transport,service,bound,address,publish,address,local,addresses,add,all,arrays,as,list,transport,service,bound,address,bound,addresses,final,iterator,string,it,hosts,iterator,for,final,future,transport,address,future,futures,final,string,hostname,it,next,if,future,is,cancelled,assert,future,is,done,try,final,transport,address,addresses,future,get,logger,trace,resolved,host,to,hostname,addresses,for,int,address,id,0,address,id,addresses,length,address,id,final,transport,address,address,addresses,address,id,if,local,addresses,contains,address,false,transport,addresses,add,address,catch,final,execution,exception,e,assert,e,get,cause,null,final,string,message,failed,to,resolve,host,hostname,logger,warn,message,e,get,cause,catch,interrupted,exception,e,thread,current,thread,interrupt,else,logger,warn,timed,out,after,resolving,host,resolve,timeout,hostname,return,collections,unmodifiable,list,transport,addresses
UnicastZenPing -> public static List<TransportAddress> resolveHostsLists(         final ExecutorService executorService,         final Logger logger,         final List<String> hosts,         final int limitPortCounts,         final TransportService transportService,         final TimeValue resolveTimeout);1540847035;Resolves a list of hosts to a list of transport addresses. Each host is resolved into a transport address (or a collection of_addresses if the number of ports is greater than one). Host lookups are done in parallel using specified executor service up_to the specified resolve timeout.__@param executorService  the executor service used to parallelize hostname lookups_@param logger           logger used for logging messages regarding hostname lookups_@param hosts            the hosts to resolve_@param limitPortCounts  the number of ports to resolve (should be 1 for non-local transport)_@param transportService the transport service_@param resolveTimeout   the timeout before returning from hostname lookups_@return a list of resolved transport addresses;public static List<TransportAddress> resolveHostsLists(_        final ExecutorService executorService,_        final Logger logger,_        final List<String> hosts,_        final int limitPortCounts,_        final TransportService transportService,_        final TimeValue resolveTimeout) {_        Objects.requireNonNull(executorService)__        Objects.requireNonNull(logger)__        Objects.requireNonNull(hosts)__        Objects.requireNonNull(transportService)__        Objects.requireNonNull(resolveTimeout)__        if (resolveTimeout.nanos() < 0) {_            throw new IllegalArgumentException("resolve timeout must be non-negative but was [" + resolveTimeout + "]")__        }_        _        final List<Callable<TransportAddress[]>> callables =_            hosts_                .stream()_                .map(hn -> (Callable<TransportAddress[]>) () -> transportService.addressesFromString(hn, limitPortCounts))_                .collect(Collectors.toList())__        final List<Future<TransportAddress[]>> futures__        try {_            futures = executorService.invokeAll(callables, resolveTimeout.nanos(), TimeUnit.NANOSECONDS)__        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()__            return Collections.emptyList()__        }_        final List<TransportAddress> transportAddresses = new ArrayList<>()__        final Set<TransportAddress> localAddresses = new HashSet<>()__        localAddresses.add(transportService.boundAddress().publishAddress())__        localAddresses.addAll(Arrays.asList(transportService.boundAddress().boundAddresses()))__        _        _        final Iterator<String> it = hosts.iterator()__        for (final Future<TransportAddress[]> future : futures) {_            final String hostname = it.next()__            if (!future.isCancelled()) {_                assert future.isDone()__                try {_                    final TransportAddress[] addresses = future.get()__                    logger.trace("resolved host [{}] to {}", hostname, addresses)__                    for (int addressId = 0_ addressId < addresses.length_ addressId++) {_                        final TransportAddress address = addresses[addressId]__                        _                        if (localAddresses.contains(address) == false) {_                            transportAddresses.add(address)__                        }_                    }_                } catch (final ExecutionException e) {_                    assert e.getCause() != null__                    final String message = "failed to resolve host [" + hostname + "]"__                    logger.warn(message, e.getCause())__                } catch (InterruptedException e) {_                    Thread.currentThread().interrupt()__                    _                }_            } else {_                logger.warn("timed out after [{}] resolving host [{}]", resolveTimeout, hostname)__            }_        }_        return Collections.unmodifiableList(transportAddresses)__    };resolves,a,list,of,hosts,to,a,list,of,transport,addresses,each,host,is,resolved,into,a,transport,address,or,a,collection,of,addresses,if,the,number,of,ports,is,greater,than,one,host,lookups,are,done,in,parallel,using,specified,executor,service,up,to,the,specified,resolve,timeout,param,executor,service,the,executor,service,used,to,parallelize,hostname,lookups,param,logger,logger,used,for,logging,messages,regarding,hostname,lookups,param,hosts,the,hosts,to,resolve,param,limit,port,counts,the,number,of,ports,to,resolve,should,be,1,for,non,local,transport,param,transport,service,the,transport,service,param,resolve,timeout,the,timeout,before,returning,from,hostname,lookups,return,a,list,of,resolved,transport,addresses;public,static,list,transport,address,resolve,hosts,lists,final,executor,service,executor,service,final,logger,logger,final,list,string,hosts,final,int,limit,port,counts,final,transport,service,transport,service,final,time,value,resolve,timeout,objects,require,non,null,executor,service,objects,require,non,null,logger,objects,require,non,null,hosts,objects,require,non,null,transport,service,objects,require,non,null,resolve,timeout,if,resolve,timeout,nanos,0,throw,new,illegal,argument,exception,resolve,timeout,must,be,non,negative,but,was,resolve,timeout,final,list,callable,transport,address,callables,hosts,stream,map,hn,callable,transport,address,transport,service,addresses,from,string,hn,limit,port,counts,collect,collectors,to,list,final,list,future,transport,address,futures,try,futures,executor,service,invoke,all,callables,resolve,timeout,nanos,time,unit,nanoseconds,catch,interrupted,exception,e,thread,current,thread,interrupt,return,collections,empty,list,final,list,transport,address,transport,addresses,new,array,list,final,set,transport,address,local,addresses,new,hash,set,local,addresses,add,transport,service,bound,address,publish,address,local,addresses,add,all,arrays,as,list,transport,service,bound,address,bound,addresses,final,iterator,string,it,hosts,iterator,for,final,future,transport,address,future,futures,final,string,hostname,it,next,if,future,is,cancelled,assert,future,is,done,try,final,transport,address,addresses,future,get,logger,trace,resolved,host,to,hostname,addresses,for,int,address,id,0,address,id,addresses,length,address,id,final,transport,address,address,addresses,address,id,if,local,addresses,contains,address,false,transport,addresses,add,address,catch,final,execution,exception,e,assert,e,get,cause,null,final,string,message,failed,to,resolve,host,hostname,logger,warn,message,e,get,cause,catch,interrupted,exception,e,thread,current,thread,interrupt,else,logger,warn,timed,out,after,resolving,host,resolve,timeout,hostname,return,collections,unmodifiable,list,transport,addresses
UnicastZenPing -> public static List<TransportAddress> resolveHostsLists(         final ExecutorService executorService,         final Logger logger,         final List<String> hosts,         final int limitPortCounts,         final TransportService transportService,         final TimeValue resolveTimeout);1541092382;Resolves a list of hosts to a list of transport addresses. Each host is resolved into a transport address (or a collection of_addresses if the number of ports is greater than one). Host lookups are done in parallel using specified executor service up_to the specified resolve timeout.__@param executorService  the executor service used to parallelize hostname lookups_@param logger           logger used for logging messages regarding hostname lookups_@param hosts            the hosts to resolve_@param limitPortCounts  the number of ports to resolve (should be 1 for non-local transport)_@param transportService the transport service_@param resolveTimeout   the timeout before returning from hostname lookups_@return a list of resolved transport addresses;public static List<TransportAddress> resolveHostsLists(_        final ExecutorService executorService,_        final Logger logger,_        final List<String> hosts,_        final int limitPortCounts,_        final TransportService transportService,_        final TimeValue resolveTimeout) {_        Objects.requireNonNull(executorService)__        Objects.requireNonNull(logger)__        Objects.requireNonNull(hosts)__        Objects.requireNonNull(transportService)__        Objects.requireNonNull(resolveTimeout)__        if (resolveTimeout.nanos() < 0) {_            throw new IllegalArgumentException("resolve timeout must be non-negative but was [" + resolveTimeout + "]")__        }_        _        final List<Callable<TransportAddress[]>> callables =_            hosts_                .stream()_                .map(hn -> (Callable<TransportAddress[]>) () -> transportService.addressesFromString(hn, limitPortCounts))_                .collect(Collectors.toList())__        final List<Future<TransportAddress[]>> futures__        try {_            futures = executorService.invokeAll(callables, resolveTimeout.nanos(), TimeUnit.NANOSECONDS)__        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()__            return Collections.emptyList()__        }_        final List<TransportAddress> transportAddresses = new ArrayList<>()__        final Set<TransportAddress> localAddresses = new HashSet<>()__        localAddresses.add(transportService.boundAddress().publishAddress())__        localAddresses.addAll(Arrays.asList(transportService.boundAddress().boundAddresses()))__        _        _        final Iterator<String> it = hosts.iterator()__        for (final Future<TransportAddress[]> future : futures) {_            final String hostname = it.next()__            if (!future.isCancelled()) {_                assert future.isDone()__                try {_                    final TransportAddress[] addresses = future.get()__                    logger.trace("resolved host [{}] to {}", hostname, addresses)__                    for (int addressId = 0_ addressId < addresses.length_ addressId++) {_                        final TransportAddress address = addresses[addressId]__                        _                        if (localAddresses.contains(address) == false) {_                            transportAddresses.add(address)__                        }_                    }_                } catch (final ExecutionException e) {_                    assert e.getCause() != null__                    final String message = "failed to resolve host [" + hostname + "]"__                    logger.warn(message, e.getCause())__                } catch (InterruptedException e) {_                    Thread.currentThread().interrupt()__                    _                }_            } else {_                logger.warn("timed out after [{}] resolving host [{}]", resolveTimeout, hostname)__            }_        }_        return Collections.unmodifiableList(transportAddresses)__    };resolves,a,list,of,hosts,to,a,list,of,transport,addresses,each,host,is,resolved,into,a,transport,address,or,a,collection,of,addresses,if,the,number,of,ports,is,greater,than,one,host,lookups,are,done,in,parallel,using,specified,executor,service,up,to,the,specified,resolve,timeout,param,executor,service,the,executor,service,used,to,parallelize,hostname,lookups,param,logger,logger,used,for,logging,messages,regarding,hostname,lookups,param,hosts,the,hosts,to,resolve,param,limit,port,counts,the,number,of,ports,to,resolve,should,be,1,for,non,local,transport,param,transport,service,the,transport,service,param,resolve,timeout,the,timeout,before,returning,from,hostname,lookups,return,a,list,of,resolved,transport,addresses;public,static,list,transport,address,resolve,hosts,lists,final,executor,service,executor,service,final,logger,logger,final,list,string,hosts,final,int,limit,port,counts,final,transport,service,transport,service,final,time,value,resolve,timeout,objects,require,non,null,executor,service,objects,require,non,null,logger,objects,require,non,null,hosts,objects,require,non,null,transport,service,objects,require,non,null,resolve,timeout,if,resolve,timeout,nanos,0,throw,new,illegal,argument,exception,resolve,timeout,must,be,non,negative,but,was,resolve,timeout,final,list,callable,transport,address,callables,hosts,stream,map,hn,callable,transport,address,transport,service,addresses,from,string,hn,limit,port,counts,collect,collectors,to,list,final,list,future,transport,address,futures,try,futures,executor,service,invoke,all,callables,resolve,timeout,nanos,time,unit,nanoseconds,catch,interrupted,exception,e,thread,current,thread,interrupt,return,collections,empty,list,final,list,transport,address,transport,addresses,new,array,list,final,set,transport,address,local,addresses,new,hash,set,local,addresses,add,transport,service,bound,address,publish,address,local,addresses,add,all,arrays,as,list,transport,service,bound,address,bound,addresses,final,iterator,string,it,hosts,iterator,for,final,future,transport,address,future,futures,final,string,hostname,it,next,if,future,is,cancelled,assert,future,is,done,try,final,transport,address,addresses,future,get,logger,trace,resolved,host,to,hostname,addresses,for,int,address,id,0,address,id,addresses,length,address,id,final,transport,address,address,addresses,address,id,if,local,addresses,contains,address,false,transport,addresses,add,address,catch,final,execution,exception,e,assert,e,get,cause,null,final,string,message,failed,to,resolve,host,hostname,logger,warn,message,e,get,cause,catch,interrupted,exception,e,thread,current,thread,interrupt,else,logger,warn,timed,out,after,resolving,host,resolve,timeout,hostname,return,collections,unmodifiable,list,transport,addresses
UnicastZenPing -> public static List<TransportAddress> resolveHostsLists(         final ExecutorService executorService,         final Logger logger,         final List<String> hosts,         final int limitPortCounts,         final TransportService transportService,         final TimeValue resolveTimeout);1542402632;Resolves a list of hosts to a list of transport addresses. Each host is resolved into a transport address (or a collection of_addresses if the number of ports is greater than one). Host lookups are done in parallel using specified executor service up_to the specified resolve timeout.__@param executorService  the executor service used to parallelize hostname lookups_@param logger           logger used for logging messages regarding hostname lookups_@param hosts            the hosts to resolve_@param limitPortCounts  the number of ports to resolve (should be 1 for non-local transport)_@param transportService the transport service_@param resolveTimeout   the timeout before returning from hostname lookups_@return a list of resolved transport addresses;public static List<TransportAddress> resolveHostsLists(_        final ExecutorService executorService,_        final Logger logger,_        final List<String> hosts,_        final int limitPortCounts,_        final TransportService transportService,_        final TimeValue resolveTimeout) {_        Objects.requireNonNull(executorService)__        Objects.requireNonNull(logger)__        Objects.requireNonNull(hosts)__        Objects.requireNonNull(transportService)__        Objects.requireNonNull(resolveTimeout)__        if (resolveTimeout.nanos() < 0) {_            throw new IllegalArgumentException("resolve timeout must be non-negative but was [" + resolveTimeout + "]")__        }_        _        final List<Callable<TransportAddress[]>> callables =_            hosts_                .stream()_                .map(hn -> (Callable<TransportAddress[]>) () -> transportService.addressesFromString(hn, limitPortCounts))_                .collect(Collectors.toList())__        final List<Future<TransportAddress[]>> futures__        try {_            futures = executorService.invokeAll(callables, resolveTimeout.nanos(), TimeUnit.NANOSECONDS)__        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()__            return Collections.emptyList()__        }_        final List<TransportAddress> transportAddresses = new ArrayList<>()__        final Set<TransportAddress> localAddresses = new HashSet<>()__        localAddresses.add(transportService.boundAddress().publishAddress())__        localAddresses.addAll(Arrays.asList(transportService.boundAddress().boundAddresses()))__        _        _        final Iterator<String> it = hosts.iterator()__        for (final Future<TransportAddress[]> future : futures) {_            final String hostname = it.next()__            if (!future.isCancelled()) {_                assert future.isDone()__                try {_                    final TransportAddress[] addresses = future.get()__                    logger.trace("resolved host [{}] to {}", hostname, addresses)__                    for (int addressId = 0_ addressId < addresses.length_ addressId++) {_                        final TransportAddress address = addresses[addressId]__                        _                        if (localAddresses.contains(address) == false) {_                            transportAddresses.add(address)__                        }_                    }_                } catch (final ExecutionException e) {_                    assert e.getCause() != null__                    final String message = "failed to resolve host [" + hostname + "]"__                    logger.warn(message, e.getCause())__                } catch (InterruptedException e) {_                    Thread.currentThread().interrupt()__                    _                }_            } else {_                logger.warn("timed out after [{}] resolving host [{}]", resolveTimeout, hostname)__            }_        }_        return Collections.unmodifiableList(transportAddresses)__    };resolves,a,list,of,hosts,to,a,list,of,transport,addresses,each,host,is,resolved,into,a,transport,address,or,a,collection,of,addresses,if,the,number,of,ports,is,greater,than,one,host,lookups,are,done,in,parallel,using,specified,executor,service,up,to,the,specified,resolve,timeout,param,executor,service,the,executor,service,used,to,parallelize,hostname,lookups,param,logger,logger,used,for,logging,messages,regarding,hostname,lookups,param,hosts,the,hosts,to,resolve,param,limit,port,counts,the,number,of,ports,to,resolve,should,be,1,for,non,local,transport,param,transport,service,the,transport,service,param,resolve,timeout,the,timeout,before,returning,from,hostname,lookups,return,a,list,of,resolved,transport,addresses;public,static,list,transport,address,resolve,hosts,lists,final,executor,service,executor,service,final,logger,logger,final,list,string,hosts,final,int,limit,port,counts,final,transport,service,transport,service,final,time,value,resolve,timeout,objects,require,non,null,executor,service,objects,require,non,null,logger,objects,require,non,null,hosts,objects,require,non,null,transport,service,objects,require,non,null,resolve,timeout,if,resolve,timeout,nanos,0,throw,new,illegal,argument,exception,resolve,timeout,must,be,non,negative,but,was,resolve,timeout,final,list,callable,transport,address,callables,hosts,stream,map,hn,callable,transport,address,transport,service,addresses,from,string,hn,limit,port,counts,collect,collectors,to,list,final,list,future,transport,address,futures,try,futures,executor,service,invoke,all,callables,resolve,timeout,nanos,time,unit,nanoseconds,catch,interrupted,exception,e,thread,current,thread,interrupt,return,collections,empty,list,final,list,transport,address,transport,addresses,new,array,list,final,set,transport,address,local,addresses,new,hash,set,local,addresses,add,transport,service,bound,address,publish,address,local,addresses,add,all,arrays,as,list,transport,service,bound,address,bound,addresses,final,iterator,string,it,hosts,iterator,for,final,future,transport,address,future,futures,final,string,hostname,it,next,if,future,is,cancelled,assert,future,is,done,try,final,transport,address,addresses,future,get,logger,trace,resolved,host,to,hostname,addresses,for,int,address,id,0,address,id,addresses,length,address,id,final,transport,address,address,addresses,address,id,if,local,addresses,contains,address,false,transport,addresses,add,address,catch,final,execution,exception,e,assert,e,get,cause,null,final,string,message,failed,to,resolve,host,hostname,logger,warn,message,e,get,cause,catch,interrupted,exception,e,thread,current,thread,interrupt,else,logger,warn,timed,out,after,resolving,host,resolve,timeout,hostname,return,collections,unmodifiable,list,transport,addresses
UnicastZenPing -> public static List<TransportAddress> resolveHostsLists(         final ExecutorService executorService,         final Logger logger,         final List<String> hosts,         final int limitPortCounts,         final TransportService transportService,         final TimeValue resolveTimeout);1544081506;Resolves a list of hosts to a list of transport addresses. Each host is resolved into a transport address (or a collection of_addresses if the number of ports is greater than one). Host lookups are done in parallel using specified executor service up_to the specified resolve timeout.__@param executorService  the executor service used to parallelize hostname lookups_@param logger           logger used for logging messages regarding hostname lookups_@param hosts            the hosts to resolve_@param limitPortCounts  the number of ports to resolve (should be 1 for non-local transport)_@param transportService the transport service_@param resolveTimeout   the timeout before returning from hostname lookups_@return a list of resolved transport addresses;public static List<TransportAddress> resolveHostsLists(_        final ExecutorService executorService,_        final Logger logger,_        final List<String> hosts,_        final int limitPortCounts,_        final TransportService transportService,_        final TimeValue resolveTimeout) {_        Objects.requireNonNull(executorService)__        Objects.requireNonNull(logger)__        Objects.requireNonNull(hosts)__        Objects.requireNonNull(transportService)__        Objects.requireNonNull(resolveTimeout)__        if (resolveTimeout.nanos() < 0) {_            throw new IllegalArgumentException("resolve timeout must be non-negative but was [" + resolveTimeout + "]")__        }_        _        final List<Callable<TransportAddress[]>> callables =_            hosts_                .stream()_                .map(hn -> (Callable<TransportAddress[]>) () -> transportService.addressesFromString(hn, limitPortCounts))_                .collect(Collectors.toList())__        final List<Future<TransportAddress[]>> futures__        try {_            futures = executorService.invokeAll(callables, resolveTimeout.nanos(), TimeUnit.NANOSECONDS)__        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()__            return Collections.emptyList()__        }_        final List<TransportAddress> transportAddresses = new ArrayList<>()__        final Set<TransportAddress> localAddresses = new HashSet<>()__        localAddresses.add(transportService.boundAddress().publishAddress())__        localAddresses.addAll(Arrays.asList(transportService.boundAddress().boundAddresses()))__        _        _        final Iterator<String> it = hosts.iterator()__        for (final Future<TransportAddress[]> future : futures) {_            final String hostname = it.next()__            if (!future.isCancelled()) {_                assert future.isDone()__                try {_                    final TransportAddress[] addresses = future.get()__                    logger.trace("resolved host [{}] to {}", hostname, addresses)__                    for (int addressId = 0_ addressId < addresses.length_ addressId++) {_                        final TransportAddress address = addresses[addressId]__                        _                        if (localAddresses.contains(address) == false) {_                            transportAddresses.add(address)__                        }_                    }_                } catch (final ExecutionException e) {_                    assert e.getCause() != null__                    final String message = "failed to resolve host [" + hostname + "]"__                    logger.warn(message, e.getCause())__                } catch (InterruptedException e) {_                    Thread.currentThread().interrupt()__                    _                }_            } else {_                logger.warn("timed out after [{}] resolving host [{}]", resolveTimeout, hostname)__            }_        }_        return Collections.unmodifiableList(transportAddresses)__    };resolves,a,list,of,hosts,to,a,list,of,transport,addresses,each,host,is,resolved,into,a,transport,address,or,a,collection,of,addresses,if,the,number,of,ports,is,greater,than,one,host,lookups,are,done,in,parallel,using,specified,executor,service,up,to,the,specified,resolve,timeout,param,executor,service,the,executor,service,used,to,parallelize,hostname,lookups,param,logger,logger,used,for,logging,messages,regarding,hostname,lookups,param,hosts,the,hosts,to,resolve,param,limit,port,counts,the,number,of,ports,to,resolve,should,be,1,for,non,local,transport,param,transport,service,the,transport,service,param,resolve,timeout,the,timeout,before,returning,from,hostname,lookups,return,a,list,of,resolved,transport,addresses;public,static,list,transport,address,resolve,hosts,lists,final,executor,service,executor,service,final,logger,logger,final,list,string,hosts,final,int,limit,port,counts,final,transport,service,transport,service,final,time,value,resolve,timeout,objects,require,non,null,executor,service,objects,require,non,null,logger,objects,require,non,null,hosts,objects,require,non,null,transport,service,objects,require,non,null,resolve,timeout,if,resolve,timeout,nanos,0,throw,new,illegal,argument,exception,resolve,timeout,must,be,non,negative,but,was,resolve,timeout,final,list,callable,transport,address,callables,hosts,stream,map,hn,callable,transport,address,transport,service,addresses,from,string,hn,limit,port,counts,collect,collectors,to,list,final,list,future,transport,address,futures,try,futures,executor,service,invoke,all,callables,resolve,timeout,nanos,time,unit,nanoseconds,catch,interrupted,exception,e,thread,current,thread,interrupt,return,collections,empty,list,final,list,transport,address,transport,addresses,new,array,list,final,set,transport,address,local,addresses,new,hash,set,local,addresses,add,transport,service,bound,address,publish,address,local,addresses,add,all,arrays,as,list,transport,service,bound,address,bound,addresses,final,iterator,string,it,hosts,iterator,for,final,future,transport,address,future,futures,final,string,hostname,it,next,if,future,is,cancelled,assert,future,is,done,try,final,transport,address,addresses,future,get,logger,trace,resolved,host,to,hostname,addresses,for,int,address,id,0,address,id,addresses,length,address,id,final,transport,address,address,addresses,address,id,if,local,addresses,contains,address,false,transport,addresses,add,address,catch,final,execution,exception,e,assert,e,get,cause,null,final,string,message,failed,to,resolve,host,hostname,logger,warn,message,e,get,cause,catch,interrupted,exception,e,thread,current,thread,interrupt,else,logger,warn,timed,out,after,resolving,host,resolve,timeout,hostname,return,collections,unmodifiable,list,transport,addresses
UnicastZenPing -> public static List<TransportAddress> resolveHostsLists(         final ExecutorService executorService,         final Logger logger,         final List<String> hosts,         final int limitPortCounts,         final TransportService transportService,         final TimeValue resolveTimeout);1548953505;Resolves a list of hosts to a list of transport addresses. Each host is resolved into a transport address (or a collection of_addresses if the number of ports is greater than one). Host lookups are done in parallel using specified executor service up_to the specified resolve timeout.__@param executorService  the executor service used to parallelize hostname lookups_@param logger           logger used for logging messages regarding hostname lookups_@param hosts            the hosts to resolve_@param limitPortCounts  the number of ports to resolve (should be 1 for non-local transport)_@param transportService the transport service_@param resolveTimeout   the timeout before returning from hostname lookups_@return a list of resolved transport addresses;public static List<TransportAddress> resolveHostsLists(_        final ExecutorService executorService,_        final Logger logger,_        final List<String> hosts,_        final int limitPortCounts,_        final TransportService transportService,_        final TimeValue resolveTimeout) {_        Objects.requireNonNull(executorService)__        Objects.requireNonNull(logger)__        Objects.requireNonNull(hosts)__        Objects.requireNonNull(transportService)__        Objects.requireNonNull(resolveTimeout)__        if (resolveTimeout.nanos() < 0) {_            throw new IllegalArgumentException("resolve timeout must be non-negative but was [" + resolveTimeout + "]")__        }_        _        final List<Callable<TransportAddress[]>> callables =_            hosts_                .stream()_                .map(hn -> (Callable<TransportAddress[]>) () -> transportService.addressesFromString(hn, limitPortCounts))_                .collect(Collectors.toList())__        final List<Future<TransportAddress[]>> futures__        try {_            futures = executorService.invokeAll(callables, resolveTimeout.nanos(), TimeUnit.NANOSECONDS)__        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()__            return Collections.emptyList()__        }_        final List<TransportAddress> transportAddresses = new ArrayList<>()__        final Set<TransportAddress> localAddresses = new HashSet<>()__        localAddresses.add(transportService.boundAddress().publishAddress())__        localAddresses.addAll(Arrays.asList(transportService.boundAddress().boundAddresses()))__        _        _        final Iterator<String> it = hosts.iterator()__        for (final Future<TransportAddress[]> future : futures) {_            final String hostname = it.next()__            if (!future.isCancelled()) {_                assert future.isDone()__                try {_                    final TransportAddress[] addresses = future.get()__                    logger.trace("resolved host [{}] to {}", hostname, addresses)__                    for (int addressId = 0_ addressId < addresses.length_ addressId++) {_                        final TransportAddress address = addresses[addressId]__                        _                        if (localAddresses.contains(address) == false) {_                            transportAddresses.add(address)__                        }_                    }_                } catch (final ExecutionException e) {_                    assert e.getCause() != null__                    final String message = "failed to resolve host [" + hostname + "]"__                    logger.warn(message, e.getCause())__                } catch (InterruptedException e) {_                    Thread.currentThread().interrupt()__                    _                }_            } else {_                logger.warn("timed out after [{}] resolving host [{}]", resolveTimeout, hostname)__            }_        }_        return Collections.unmodifiableList(transportAddresses)__    };resolves,a,list,of,hosts,to,a,list,of,transport,addresses,each,host,is,resolved,into,a,transport,address,or,a,collection,of,addresses,if,the,number,of,ports,is,greater,than,one,host,lookups,are,done,in,parallel,using,specified,executor,service,up,to,the,specified,resolve,timeout,param,executor,service,the,executor,service,used,to,parallelize,hostname,lookups,param,logger,logger,used,for,logging,messages,regarding,hostname,lookups,param,hosts,the,hosts,to,resolve,param,limit,port,counts,the,number,of,ports,to,resolve,should,be,1,for,non,local,transport,param,transport,service,the,transport,service,param,resolve,timeout,the,timeout,before,returning,from,hostname,lookups,return,a,list,of,resolved,transport,addresses;public,static,list,transport,address,resolve,hosts,lists,final,executor,service,executor,service,final,logger,logger,final,list,string,hosts,final,int,limit,port,counts,final,transport,service,transport,service,final,time,value,resolve,timeout,objects,require,non,null,executor,service,objects,require,non,null,logger,objects,require,non,null,hosts,objects,require,non,null,transport,service,objects,require,non,null,resolve,timeout,if,resolve,timeout,nanos,0,throw,new,illegal,argument,exception,resolve,timeout,must,be,non,negative,but,was,resolve,timeout,final,list,callable,transport,address,callables,hosts,stream,map,hn,callable,transport,address,transport,service,addresses,from,string,hn,limit,port,counts,collect,collectors,to,list,final,list,future,transport,address,futures,try,futures,executor,service,invoke,all,callables,resolve,timeout,nanos,time,unit,nanoseconds,catch,interrupted,exception,e,thread,current,thread,interrupt,return,collections,empty,list,final,list,transport,address,transport,addresses,new,array,list,final,set,transport,address,local,addresses,new,hash,set,local,addresses,add,transport,service,bound,address,publish,address,local,addresses,add,all,arrays,as,list,transport,service,bound,address,bound,addresses,final,iterator,string,it,hosts,iterator,for,final,future,transport,address,future,futures,final,string,hostname,it,next,if,future,is,cancelled,assert,future,is,done,try,final,transport,address,addresses,future,get,logger,trace,resolved,host,to,hostname,addresses,for,int,address,id,0,address,id,addresses,length,address,id,final,transport,address,address,addresses,address,id,if,local,addresses,contains,address,false,transport,addresses,add,address,catch,final,execution,exception,e,assert,e,get,cause,null,final,string,message,failed,to,resolve,host,hostname,logger,warn,message,e,get,cause,catch,interrupted,exception,e,thread,current,thread,interrupt,else,logger,warn,timed,out,after,resolving,host,resolve,timeout,hostname,return,collections,unmodifiable,list,transport,addresses
UnicastZenPing -> public static List<TransportAddress> resolveHostsLists(         final ExecutorService executorService,         final Logger logger,         final List<String> hosts,         final int limitPortCounts,         final TransportService transportService,         final TimeValue resolveTimeout);1549356412;Resolves a list of hosts to a list of transport addresses. Each host is resolved into a transport address (or a collection of_addresses if the number of ports is greater than one). Host lookups are done in parallel using specified executor service up_to the specified resolve timeout.__@param executorService  the executor service used to parallelize hostname lookups_@param logger           logger used for logging messages regarding hostname lookups_@param hosts            the hosts to resolve_@param limitPortCounts  the number of ports to resolve (should be 1 for non-local transport)_@param transportService the transport service_@param resolveTimeout   the timeout before returning from hostname lookups_@return a list of resolved transport addresses;public static List<TransportAddress> resolveHostsLists(_        final ExecutorService executorService,_        final Logger logger,_        final List<String> hosts,_        final int limitPortCounts,_        final TransportService transportService,_        final TimeValue resolveTimeout) {_        Objects.requireNonNull(executorService)__        Objects.requireNonNull(logger)__        Objects.requireNonNull(hosts)__        Objects.requireNonNull(transportService)__        Objects.requireNonNull(resolveTimeout)__        if (resolveTimeout.nanos() < 0) {_            throw new IllegalArgumentException("resolve timeout must be non-negative but was [" + resolveTimeout + "]")__        }_        _        final List<Callable<TransportAddress[]>> callables =_            hosts_                .stream()_                .map(hn -> (Callable<TransportAddress[]>) () -> transportService.addressesFromString(hn, limitPortCounts))_                .collect(Collectors.toList())__        final List<Future<TransportAddress[]>> futures__        try {_            futures = executorService.invokeAll(callables, resolveTimeout.nanos(), TimeUnit.NANOSECONDS)__        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()__            return Collections.emptyList()__        }_        final List<TransportAddress> transportAddresses = new ArrayList<>()__        final Set<TransportAddress> localAddresses = new HashSet<>()__        localAddresses.add(transportService.boundAddress().publishAddress())__        localAddresses.addAll(Arrays.asList(transportService.boundAddress().boundAddresses()))__        _        _        final Iterator<String> it = hosts.iterator()__        for (final Future<TransportAddress[]> future : futures) {_            final String hostname = it.next()__            if (!future.isCancelled()) {_                assert future.isDone()__                try {_                    final TransportAddress[] addresses = future.get()__                    logger.trace("resolved host [{}] to {}", hostname, addresses)__                    for (int addressId = 0_ addressId < addresses.length_ addressId++) {_                        final TransportAddress address = addresses[addressId]__                        _                        if (localAddresses.contains(address) == false) {_                            transportAddresses.add(address)__                        }_                    }_                } catch (final ExecutionException e) {_                    assert e.getCause() != null__                    final String message = "failed to resolve host [" + hostname + "]"__                    logger.warn(message, e.getCause())__                } catch (InterruptedException e) {_                    Thread.currentThread().interrupt()__                    _                }_            } else {_                logger.warn("timed out after [{}] resolving host [{}]", resolveTimeout, hostname)__            }_        }_        return Collections.unmodifiableList(transportAddresses)__    };resolves,a,list,of,hosts,to,a,list,of,transport,addresses,each,host,is,resolved,into,a,transport,address,or,a,collection,of,addresses,if,the,number,of,ports,is,greater,than,one,host,lookups,are,done,in,parallel,using,specified,executor,service,up,to,the,specified,resolve,timeout,param,executor,service,the,executor,service,used,to,parallelize,hostname,lookups,param,logger,logger,used,for,logging,messages,regarding,hostname,lookups,param,hosts,the,hosts,to,resolve,param,limit,port,counts,the,number,of,ports,to,resolve,should,be,1,for,non,local,transport,param,transport,service,the,transport,service,param,resolve,timeout,the,timeout,before,returning,from,hostname,lookups,return,a,list,of,resolved,transport,addresses;public,static,list,transport,address,resolve,hosts,lists,final,executor,service,executor,service,final,logger,logger,final,list,string,hosts,final,int,limit,port,counts,final,transport,service,transport,service,final,time,value,resolve,timeout,objects,require,non,null,executor,service,objects,require,non,null,logger,objects,require,non,null,hosts,objects,require,non,null,transport,service,objects,require,non,null,resolve,timeout,if,resolve,timeout,nanos,0,throw,new,illegal,argument,exception,resolve,timeout,must,be,non,negative,but,was,resolve,timeout,final,list,callable,transport,address,callables,hosts,stream,map,hn,callable,transport,address,transport,service,addresses,from,string,hn,limit,port,counts,collect,collectors,to,list,final,list,future,transport,address,futures,try,futures,executor,service,invoke,all,callables,resolve,timeout,nanos,time,unit,nanoseconds,catch,interrupted,exception,e,thread,current,thread,interrupt,return,collections,empty,list,final,list,transport,address,transport,addresses,new,array,list,final,set,transport,address,local,addresses,new,hash,set,local,addresses,add,transport,service,bound,address,publish,address,local,addresses,add,all,arrays,as,list,transport,service,bound,address,bound,addresses,final,iterator,string,it,hosts,iterator,for,final,future,transport,address,future,futures,final,string,hostname,it,next,if,future,is,cancelled,assert,future,is,done,try,final,transport,address,addresses,future,get,logger,trace,resolved,host,to,hostname,addresses,for,int,address,id,0,address,id,addresses,length,address,id,final,transport,address,address,addresses,address,id,if,local,addresses,contains,address,false,transport,addresses,add,address,catch,final,execution,exception,e,assert,e,get,cause,null,final,string,message,failed,to,resolve,host,hostname,logger,warn,message,e,get,cause,catch,interrupted,exception,e,thread,current,thread,interrupt,else,logger,warn,timed,out,after,resolving,host,resolve,timeout,hostname,return,collections,unmodifiable,list,transport,addresses
UnicastZenPing -> public static List<TransportAddress> resolveHostsLists(         final ExecutorService executorService,         final Logger logger,         final List<String> hosts,         final int limitPortCounts,         final TransportService transportService,         final TimeValue resolveTimeout);1549452878;Resolves a list of hosts to a list of transport addresses. Each host is resolved into a transport address (or a collection of_addresses if the number of ports is greater than one). Host lookups are done in parallel using specified executor service up_to the specified resolve timeout.__@param executorService  the executor service used to parallelize hostname lookups_@param logger           logger used for logging messages regarding hostname lookups_@param hosts            the hosts to resolve_@param limitPortCounts  the number of ports to resolve (should be 1 for non-local transport)_@param transportService the transport service_@param resolveTimeout   the timeout before returning from hostname lookups_@return a list of resolved transport addresses;public static List<TransportAddress> resolveHostsLists(_        final ExecutorService executorService,_        final Logger logger,_        final List<String> hosts,_        final int limitPortCounts,_        final TransportService transportService,_        final TimeValue resolveTimeout) {_        Objects.requireNonNull(executorService)__        Objects.requireNonNull(logger)__        Objects.requireNonNull(hosts)__        Objects.requireNonNull(transportService)__        Objects.requireNonNull(resolveTimeout)__        if (resolveTimeout.nanos() < 0) {_            throw new IllegalArgumentException("resolve timeout must be non-negative but was [" + resolveTimeout + "]")__        }_        _        final List<Callable<TransportAddress[]>> callables =_            hosts_                .stream()_                .map(hn -> (Callable<TransportAddress[]>) () -> transportService.addressesFromString(hn, limitPortCounts))_                .collect(Collectors.toList())__        final List<Future<TransportAddress[]>> futures__        try {_            futures = executorService.invokeAll(callables, resolveTimeout.nanos(), TimeUnit.NANOSECONDS)__        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()__            return Collections.emptyList()__        }_        final List<TransportAddress> transportAddresses = new ArrayList<>()__        final Set<TransportAddress> localAddresses = new HashSet<>()__        localAddresses.add(transportService.boundAddress().publishAddress())__        localAddresses.addAll(Arrays.asList(transportService.boundAddress().boundAddresses()))__        _        _        final Iterator<String> it = hosts.iterator()__        for (final Future<TransportAddress[]> future : futures) {_            final String hostname = it.next()__            if (!future.isCancelled()) {_                assert future.isDone()__                try {_                    final TransportAddress[] addresses = future.get()__                    logger.trace("resolved host [{}] to {}", hostname, addresses)__                    for (int addressId = 0_ addressId < addresses.length_ addressId++) {_                        final TransportAddress address = addresses[addressId]__                        _                        if (localAddresses.contains(address) == false) {_                            transportAddresses.add(address)__                        }_                    }_                } catch (final ExecutionException e) {_                    assert e.getCause() != null__                    final String message = "failed to resolve host [" + hostname + "]"__                    logger.warn(message, e.getCause())__                } catch (InterruptedException e) {_                    Thread.currentThread().interrupt()__                    _                }_            } else {_                logger.warn("timed out after [{}] resolving host [{}]", resolveTimeout, hostname)__            }_        }_        return Collections.unmodifiableList(transportAddresses)__    };resolves,a,list,of,hosts,to,a,list,of,transport,addresses,each,host,is,resolved,into,a,transport,address,or,a,collection,of,addresses,if,the,number,of,ports,is,greater,than,one,host,lookups,are,done,in,parallel,using,specified,executor,service,up,to,the,specified,resolve,timeout,param,executor,service,the,executor,service,used,to,parallelize,hostname,lookups,param,logger,logger,used,for,logging,messages,regarding,hostname,lookups,param,hosts,the,hosts,to,resolve,param,limit,port,counts,the,number,of,ports,to,resolve,should,be,1,for,non,local,transport,param,transport,service,the,transport,service,param,resolve,timeout,the,timeout,before,returning,from,hostname,lookups,return,a,list,of,resolved,transport,addresses;public,static,list,transport,address,resolve,hosts,lists,final,executor,service,executor,service,final,logger,logger,final,list,string,hosts,final,int,limit,port,counts,final,transport,service,transport,service,final,time,value,resolve,timeout,objects,require,non,null,executor,service,objects,require,non,null,logger,objects,require,non,null,hosts,objects,require,non,null,transport,service,objects,require,non,null,resolve,timeout,if,resolve,timeout,nanos,0,throw,new,illegal,argument,exception,resolve,timeout,must,be,non,negative,but,was,resolve,timeout,final,list,callable,transport,address,callables,hosts,stream,map,hn,callable,transport,address,transport,service,addresses,from,string,hn,limit,port,counts,collect,collectors,to,list,final,list,future,transport,address,futures,try,futures,executor,service,invoke,all,callables,resolve,timeout,nanos,time,unit,nanoseconds,catch,interrupted,exception,e,thread,current,thread,interrupt,return,collections,empty,list,final,list,transport,address,transport,addresses,new,array,list,final,set,transport,address,local,addresses,new,hash,set,local,addresses,add,transport,service,bound,address,publish,address,local,addresses,add,all,arrays,as,list,transport,service,bound,address,bound,addresses,final,iterator,string,it,hosts,iterator,for,final,future,transport,address,future,futures,final,string,hostname,it,next,if,future,is,cancelled,assert,future,is,done,try,final,transport,address,addresses,future,get,logger,trace,resolved,host,to,hostname,addresses,for,int,address,id,0,address,id,addresses,length,address,id,final,transport,address,address,addresses,address,id,if,local,addresses,contains,address,false,transport,addresses,add,address,catch,final,execution,exception,e,assert,e,get,cause,null,final,string,message,failed,to,resolve,host,hostname,logger,warn,message,e,get,cause,catch,interrupted,exception,e,thread,current,thread,interrupt,else,logger,warn,timed,out,after,resolving,host,resolve,timeout,hostname,return,collections,unmodifiable,list,transport,addresses
UnicastZenPing -> public static List<TransportAddress> resolveHostsLists(         final ExecutorService executorService,         final Logger logger,         final List<String> hosts,         final int limitPortCounts,         final TransportService transportService,         final TimeValue resolveTimeout);1550575247;Resolves a list of hosts to a list of transport addresses. Each host is resolved into a transport address (or a collection of_addresses if the number of ports is greater than one). Host lookups are done in parallel using specified executor service up_to the specified resolve timeout.__@param executorService  the executor service used to parallelize hostname lookups_@param logger           logger used for logging messages regarding hostname lookups_@param hosts            the hosts to resolve_@param limitPortCounts  the number of ports to resolve (should be 1 for non-local transport)_@param transportService the transport service_@param resolveTimeout   the timeout before returning from hostname lookups_@return a list of resolved transport addresses;public static List<TransportAddress> resolveHostsLists(_        final ExecutorService executorService,_        final Logger logger,_        final List<String> hosts,_        final int limitPortCounts,_        final TransportService transportService,_        final TimeValue resolveTimeout) {_        Objects.requireNonNull(executorService)__        Objects.requireNonNull(logger)__        Objects.requireNonNull(hosts)__        Objects.requireNonNull(transportService)__        Objects.requireNonNull(resolveTimeout)__        if (resolveTimeout.nanos() < 0) {_            throw new IllegalArgumentException("resolve timeout must be non-negative but was [" + resolveTimeout + "]")__        }_        _        final List<Callable<TransportAddress[]>> callables =_            hosts_                .stream()_                .map(hn -> (Callable<TransportAddress[]>) () -> transportService.addressesFromString(hn, limitPortCounts))_                .collect(Collectors.toList())__        final List<Future<TransportAddress[]>> futures__        try {_            futures = executorService.invokeAll(callables, resolveTimeout.nanos(), TimeUnit.NANOSECONDS)__        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()__            return Collections.emptyList()__        }_        final List<TransportAddress> transportAddresses = new ArrayList<>()__        final Set<TransportAddress> localAddresses = new HashSet<>()__        localAddresses.add(transportService.boundAddress().publishAddress())__        localAddresses.addAll(Arrays.asList(transportService.boundAddress().boundAddresses()))__        _        _        final Iterator<String> it = hosts.iterator()__        for (final Future<TransportAddress[]> future : futures) {_            final String hostname = it.next()__            if (!future.isCancelled()) {_                assert future.isDone()__                try {_                    final TransportAddress[] addresses = future.get()__                    logger.trace("resolved host [{}] to {}", hostname, addresses)__                    for (int addressId = 0_ addressId < addresses.length_ addressId++) {_                        final TransportAddress address = addresses[addressId]__                        _                        if (localAddresses.contains(address) == false) {_                            transportAddresses.add(address)__                        }_                    }_                } catch (final ExecutionException e) {_                    assert e.getCause() != null__                    final String message = "failed to resolve host [" + hostname + "]"__                    logger.warn(message, e.getCause())__                } catch (InterruptedException e) {_                    Thread.currentThread().interrupt()__                    _                }_            } else {_                logger.warn("timed out after [{}] resolving host [{}]", resolveTimeout, hostname)__            }_        }_        return Collections.unmodifiableList(transportAddresses)__    };resolves,a,list,of,hosts,to,a,list,of,transport,addresses,each,host,is,resolved,into,a,transport,address,or,a,collection,of,addresses,if,the,number,of,ports,is,greater,than,one,host,lookups,are,done,in,parallel,using,specified,executor,service,up,to,the,specified,resolve,timeout,param,executor,service,the,executor,service,used,to,parallelize,hostname,lookups,param,logger,logger,used,for,logging,messages,regarding,hostname,lookups,param,hosts,the,hosts,to,resolve,param,limit,port,counts,the,number,of,ports,to,resolve,should,be,1,for,non,local,transport,param,transport,service,the,transport,service,param,resolve,timeout,the,timeout,before,returning,from,hostname,lookups,return,a,list,of,resolved,transport,addresses;public,static,list,transport,address,resolve,hosts,lists,final,executor,service,executor,service,final,logger,logger,final,list,string,hosts,final,int,limit,port,counts,final,transport,service,transport,service,final,time,value,resolve,timeout,objects,require,non,null,executor,service,objects,require,non,null,logger,objects,require,non,null,hosts,objects,require,non,null,transport,service,objects,require,non,null,resolve,timeout,if,resolve,timeout,nanos,0,throw,new,illegal,argument,exception,resolve,timeout,must,be,non,negative,but,was,resolve,timeout,final,list,callable,transport,address,callables,hosts,stream,map,hn,callable,transport,address,transport,service,addresses,from,string,hn,limit,port,counts,collect,collectors,to,list,final,list,future,transport,address,futures,try,futures,executor,service,invoke,all,callables,resolve,timeout,nanos,time,unit,nanoseconds,catch,interrupted,exception,e,thread,current,thread,interrupt,return,collections,empty,list,final,list,transport,address,transport,addresses,new,array,list,final,set,transport,address,local,addresses,new,hash,set,local,addresses,add,transport,service,bound,address,publish,address,local,addresses,add,all,arrays,as,list,transport,service,bound,address,bound,addresses,final,iterator,string,it,hosts,iterator,for,final,future,transport,address,future,futures,final,string,hostname,it,next,if,future,is,cancelled,assert,future,is,done,try,final,transport,address,addresses,future,get,logger,trace,resolved,host,to,hostname,addresses,for,int,address,id,0,address,id,addresses,length,address,id,final,transport,address,address,addresses,address,id,if,local,addresses,contains,address,false,transport,addresses,add,address,catch,final,execution,exception,e,assert,e,get,cause,null,final,string,message,failed,to,resolve,host,hostname,logger,warn,message,e,get,cause,catch,interrupted,exception,e,thread,current,thread,interrupt,else,logger,warn,timed,out,after,resolving,host,resolve,timeout,hostname,return,collections,unmodifiable,list,transport,addresses
UnicastZenPing -> public void clearTemporalResponses();1524684173;Clears the list of cached ping responses.;public void clearTemporalResponses() {_        temporalResponses.clear()__    };clears,the,list,of,cached,ping,responses;public,void,clear,temporal,responses,temporal,responses,clear
UnicastZenPing -> public void clearTemporalResponses();1529600205;Clears the list of cached ping responses.;public void clearTemporalResponses() {_        temporalResponses.clear()__    };clears,the,list,of,cached,ping,responses;public,void,clear,temporal,responses,temporal,responses,clear
UnicastZenPing -> public void clearTemporalResponses();1529687475;Clears the list of cached ping responses.;public void clearTemporalResponses() {_        temporalResponses.clear()__    };clears,the,list,of,cached,ping,responses;public,void,clear,temporal,responses,temporal,responses,clear
UnicastZenPing -> public void clearTemporalResponses();1540847035;Clears the list of cached ping responses.;public void clearTemporalResponses() {_        temporalResponses.clear()__    };clears,the,list,of,cached,ping,responses;public,void,clear,temporal,responses,temporal,responses,clear
UnicastZenPing -> public void clearTemporalResponses();1541092382;Clears the list of cached ping responses.;public void clearTemporalResponses() {_        temporalResponses.clear()__    };clears,the,list,of,cached,ping,responses;public,void,clear,temporal,responses,temporal,responses,clear
UnicastZenPing -> public void clearTemporalResponses();1542402632;Clears the list of cached ping responses.;public void clearTemporalResponses() {_        temporalResponses.clear()__    };clears,the,list,of,cached,ping,responses;public,void,clear,temporal,responses,temporal,responses,clear
UnicastZenPing -> public void clearTemporalResponses();1544081506;Clears the list of cached ping responses.;public void clearTemporalResponses() {_        temporalResponses.clear()__    };clears,the,list,of,cached,ping,responses;public,void,clear,temporal,responses,temporal,responses,clear
UnicastZenPing -> public void clearTemporalResponses();1548953505;Clears the list of cached ping responses.;public void clearTemporalResponses() {_        temporalResponses.clear()__    };clears,the,list,of,cached,ping,responses;public,void,clear,temporal,responses,temporal,responses,clear
UnicastZenPing -> public void clearTemporalResponses();1549356412;Clears the list of cached ping responses.;public void clearTemporalResponses() {_        temporalResponses.clear()__    };clears,the,list,of,cached,ping,responses;public,void,clear,temporal,responses,temporal,responses,clear
UnicastZenPing -> public void clearTemporalResponses();1549452878;Clears the list of cached ping responses.;public void clearTemporalResponses() {_        temporalResponses.clear()__    };clears,the,list,of,cached,ping,responses;public,void,clear,temporal,responses,temporal,responses,clear
UnicastZenPing -> public void clearTemporalResponses();1550575247;Clears the list of cached ping responses.;public void clearTemporalResponses() {_        temporalResponses.clear()__    };clears,the,list,of,cached,ping,responses;public,void,clear,temporal,responses,temporal,responses,clear
