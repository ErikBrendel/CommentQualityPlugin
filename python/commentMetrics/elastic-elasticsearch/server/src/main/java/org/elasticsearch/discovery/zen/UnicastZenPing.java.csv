commented;modifiers;parameterAmount;loc;comment;code
true;public,static;6;63;/**  * Resolves a list of hosts to a list of transport addresses. Each host is resolved into a transport address (or a collection of  * addresses if the number of ports is greater than one). Host lookups are done in parallel using specified executor service up  * to the specified resolve timeout.  *  * @param executorService  the executor service used to parallelize hostname lookups  * @param logger           logger used for logging messages regarding hostname lookups  * @param hosts            the hosts to resolve  * @param limitPortCounts  the number of ports to resolve (should be 1 for non-local transport)  * @param transportService the transport service  * @param resolveTimeout   the timeout before returning from hostname lookups  * @return a list of resolved transport addresses  */ ;/**  * Resolves a list of hosts to a list of transport addresses. Each host is resolved into a transport address (or a collection of  * addresses if the number of ports is greater than one). Host lookups are done in parallel using specified executor service up  * to the specified resolve timeout.  *  * @param executorService  the executor service used to parallelize hostname lookups  * @param logger           logger used for logging messages regarding hostname lookups  * @param hosts            the hosts to resolve  * @param limitPortCounts  the number of ports to resolve (should be 1 for non-local transport)  * @param transportService the transport service  * @param resolveTimeout   the timeout before returning from hostname lookups  * @return a list of resolved transport addresses  */ public static List<TransportAddress> resolveHostsLists(final ExecutorService executorService, final Logger logger, final List<String> hosts, final int limitPortCounts, final TransportService transportService, final TimeValue resolveTimeout) {     Objects.requireNonNull(executorService).     Objects.requireNonNull(logger).     Objects.requireNonNull(hosts).     Objects.requireNonNull(transportService).     Objects.requireNonNull(resolveTimeout).     if (resolveTimeout.nanos() < 0) {         throw new IllegalArgumentException("resolve timeout must be non-negative but was [" + resolveTimeout + "]").     }     // create tasks to submit to the executor service. we will wait up to resolveTimeout for these tasks to complete     final List<Callable<TransportAddress[]>> callables = hosts.stream().map(hn -> (Callable<TransportAddress[]>) () -> transportService.addressesFromString(hn, limitPortCounts)).collect(Collectors.toList()).     final List<Future<TransportAddress[]>> futures.     try {         futures = executorService.invokeAll(callables, resolveTimeout.nanos(), TimeUnit.NANOSECONDS).     } catch (InterruptedException e) {         Thread.currentThread().interrupt().         return Collections.emptyList().     }     final List<TransportAddress> transportAddresses = new ArrayList<>().     final Set<TransportAddress> localAddresses = new HashSet<>().     localAddresses.add(transportService.boundAddress().publishAddress()).     localAddresses.addAll(Arrays.asList(transportService.boundAddress().boundAddresses())).     // ExecutorService#invokeAll guarantees that the futures are returned in the iteration order of the tasks so we can associate the     // hostname with the corresponding task by iterating together     final Iterator<String> it = hosts.iterator().     for (final Future<TransportAddress[]> future : futures) {         final String hostname = it.next().         if (!future.isCancelled()) {             assert future.isDone().             try {                 final TransportAddress[] addresses = future.get().                 logger.trace("resolved host [{}] to {}", hostname, addresses).                 for (int addressId = 0. addressId < addresses.length. addressId++) {                     final TransportAddress address = addresses[addressId].                     // no point in pinging ourselves                     if (localAddresses.contains(address) == false) {                         transportAddresses.add(address).                     }                 }             } catch (final ExecutionException e) {                 assert e.getCause() != null.                 final String message = "failed to resolve host [" + hostname + "]".                 logger.warn(message, e.getCause()).             } catch (InterruptedException e) {                 Thread.currentThread().interrupt().             // ignore             }         } else {             logger.warn("timed out after [{}] resolving host [{}]", resolveTimeout, hostname).         }     }     return Collections.unmodifiableList(transportAddresses). }
false;private;0;4;;private SeedHostsProvider.HostsResolver createHostsResolver() {     return (hosts, limitPortCounts) -> resolveHostsLists(unicastZenPingExecutorService, logger, hosts, limitPortCounts, transportService, resolveTimeout). }
false;public;0;6;;@Override public void close() {     ThreadPool.terminate(unicastZenPingExecutorService, 10, TimeUnit.SECONDS).     Releasables.close(activePingingRounds.values()).     closed = true. }
false;public;0;3;;@Override public void start() { }
true;public;0;3;/**  * Clears the list of cached ping responses.  */ ;/**  * Clears the list of cached ping responses.  */ public void clearTemporalResponses() {     temporalResponses.clear(). }
true;public;2;4;/**  * Sends three rounds of pings notifying the specified {@link Consumer} when pinging is complete. Pings are sent after resolving  * configured unicast hosts to their IP address (subject to DNS caching within the JVM). A batch of pings is sent, then another batch  * of pings is sent at half the specified {@link TimeValue}, and then another batch of pings is sent at the specified {@link TimeValue}.  * The pings that are sent carry a timeout of 1.25 times the specified {@link TimeValue}. When pinging each node, a connection and  * handshake is performed, with a connection timeout of the specified {@link TimeValue}.  *  * @param resultsConsumer the callback when pinging is complete  * @param duration        the timeout for various components of the pings  */ ;/**  * Sends three rounds of pings notifying the specified {@link Consumer} when pinging is complete. Pings are sent after resolving  * configured unicast hosts to their IP address (subject to DNS caching within the JVM). A batch of pings is sent, then another batch  * of pings is sent at half the specified {@link TimeValue}, and then another batch of pings is sent at the specified {@link TimeValue}.  * The pings that are sent carry a timeout of 1.25 times the specified {@link TimeValue}. When pinging each node, a connection and  * handshake is performed, with a connection timeout of the specified {@link TimeValue}.  *  * @param resultsConsumer the callback when pinging is complete  * @param duration        the timeout for various components of the pings  */ @Override public void ping(final Consumer<PingCollection> resultsConsumer, final TimeValue duration) {     ping(resultsConsumer, duration, duration). }
false;public;1;6;;@Override public void onFailure(Exception e) {     if (e instanceof AlreadyClosedException == false) {         logger.warn("unexpected error while pinging", e).     } }
false;protected;0;4;;@Override protected void doRun() throws Exception {     sendPings(requestDuration, pingingRound). }
false;protected;0;4;;@Override protected void doRun() throws Exception {     finishPingingRound(pingingRound). }
false;public;1;4;;@Override public void onFailure(Exception e) {     logger.warn("unexpected error while finishing pinging round", e). }
true;protected;3;45;/**  * a variant of {@link #ping(Consumer, TimeValue)}, but allows separating the scheduling duration  * from the duration used for request level time outs. This is useful for testing  */ ;/**  * a variant of {@link #ping(Consumer, TimeValue)}, but allows separating the scheduling duration  * from the duration used for request level time outs. This is useful for testing  */ protected void ping(final Consumer<PingCollection> resultsConsumer, final TimeValue scheduleDuration, final TimeValue requestDuration) {     final List<TransportAddress> seedAddresses = new ArrayList<>().     seedAddresses.addAll(hostsProvider.getSeedAddresses(createHostsResolver())).     final DiscoveryNodes nodes = contextProvider.clusterState().nodes().     // add all possible master nodes that were active in the last known cluster configuration     for (ObjectCursor<DiscoveryNode> masterNode : nodes.getMasterNodes().values()) {         seedAddresses.add(masterNode.value.getAddress()).     }     final ConnectionProfile connectionProfile = ConnectionProfile.buildSingleChannelProfile(TransportRequestOptions.Type.REG, requestDuration, requestDuration, TimeValue.MINUS_ONE, null).     final PingingRound pingingRound = new PingingRound(pingingRoundIdGenerator.incrementAndGet(), seedAddresses, resultsConsumer, nodes.getLocalNode(), connectionProfile).     activePingingRounds.put(pingingRound.id(), pingingRound).     final AbstractRunnable pingSender = new AbstractRunnable() {          @Override         public void onFailure(Exception e) {             if (e instanceof AlreadyClosedException == false) {                 logger.warn("unexpected error while pinging", e).             }         }          @Override         protected void doRun() throws Exception {             sendPings(requestDuration, pingingRound).         }     }.     threadPool.generic().execute(pingSender).     threadPool.schedule(pingSender, TimeValue.timeValueMillis(scheduleDuration.millis() / 3), ThreadPool.Names.GENERIC).     threadPool.schedule(pingSender, TimeValue.timeValueMillis(scheduleDuration.millis() / 3 * 2), ThreadPool.Names.GENERIC).     threadPool.schedule(new AbstractRunnable() {          @Override         protected void doRun() throws Exception {             finishPingingRound(pingingRound).         }          @Override         public void onFailure(Exception e) {             logger.warn("unexpected error while finishing pinging round", e).         }     }, scheduleDuration, ThreadPool.Names.GENERIC). }
true;protected;1;3;// for testing ;// for testing protected void finishPingingRound(PingingRound pingingRound) {     pingingRound.close(). }
false;public;0;3;;public int id() {     return this.id. }
false;public;0;3;;public boolean isClosed() {     return this.closed.get(). }
false;public;0;4;;public List<TransportAddress> getSeedAddresses() {     ensureOpen().     return seedAddresses. }
false;public;1;28;;public Connection getOrConnect(DiscoveryNode node) throws IOException {     Connection result.     try (Releasable ignore = connectionLock.acquire(node.getAddress())) {         result = tempConnections.get(node.getAddress()).         if (result == null) {             ensureOpen().             boolean success = false.             logger.trace("[{}] opening connection to [{}]", id(), node).             result = transportService.openConnection(node, connectionProfile).             try {                 transportService.handshake(result, connectionProfile.getHandshakeTimeout().millis()).                 synchronized (this) {                     // acquire lock and check if closed, to prevent leaving an open connection after closing                     ensureOpen().                     Connection existing = tempConnections.put(node.getAddress(), result).                     assert existing == null.                     success = true.                 }             } finally {                 if (success == false) {                     logger.trace("[{}] closing connection to [{}] due to failure", id(), node).                     IOUtils.closeWhileHandlingException(result).                 }             }         }     }     return result. }
false;private;0;5;;private void ensureOpen() {     if (isClosed()) {         throw new AlreadyClosedException("pinging round [" + id + "] is finished").     } }
false;public;1;5;;public void addPingResponseToCollection(PingResponse pingResponse) {     if (localNode.equals(pingResponse.node()) == false) {         pingCollection.addPing(pingResponse).     } }
false;public;0;19;;@Override public void close() {     List<Connection> toClose = null.     synchronized (this) {         if (closed.compareAndSet(false, true)) {             activePingingRounds.remove(id).             toClose = new ArrayList<>(tempConnections.values()).             tempConnections.clear().         }     }     if (toClose != null) {         // we actually closed         try {             pingListener.accept(pingCollection).         } finally {             IOUtils.closeWhileHandlingException(toClose).         }     } }
false;public;0;3;;public ConnectionProfile getConnectionProfile() {     return connectionProfile. }
false;protected;2;31;;protected void sendPings(final TimeValue timeout, final PingingRound pingingRound) {     final ClusterState lastState = contextProvider.clusterState().     final UnicastPingRequest pingRequest = new UnicastPingRequest(pingingRound.id(), timeout, createPingResponse(lastState)).     List<TransportAddress> temporalAddresses = temporalResponses.stream().map(pingResponse -> {         assert clusterName.equals(pingResponse.clusterName()) : "got a ping request from a different cluster. expected " + clusterName + " got " + pingResponse.clusterName().         return pingResponse.node().getAddress().     }).collect(Collectors.toList()).     final Stream<TransportAddress> uniqueAddresses = Stream.concat(pingingRound.getSeedAddresses().stream(), temporalAddresses.stream()).distinct().     // resolve what we can via the latest cluster state     final Set<DiscoveryNode> nodesToPing = uniqueAddresses.map(address -> {         DiscoveryNode foundNode = lastState.nodes().findByAddress(address).         if (foundNode != null && transportService.nodeConnected(foundNode)) {             return foundNode.         } else {             return new DiscoveryNode(address.toString(), address, emptyMap(), emptySet(), Version.CURRENT.minimumCompatibilityVersion()).         }     }).collect(Collectors.toSet()).     nodesToPing.forEach(node -> sendPingRequestToNode(node, timeout, pingingRound, pingRequest)). }
false;protected;0;21;;@Override protected void doRun() throws Exception {     Connection connection = null.     if (transportService.nodeConnected(node)) {         try {             // concurrency can still cause disconnects             connection = transportService.getConnection(node).         } catch (NodeNotConnectedException e) {             logger.trace("[{}] node [{}] just disconnected, will create a temp connection", pingingRound.id(), node).         }     }     if (connection == null) {         connection = pingingRound.getOrConnect(node).     }     logger.trace("[{}] sending to {}", pingingRound.id(), node).     transportService.sendRequest(connection, ACTION_NAME, pingRequest, TransportRequestOptions.builder().withTimeout((long) (timeout.millis() * 1.25)).build(), getPingResponseHandler(pingingRound, node)). }
false;public;1;13;;@Override public void onFailure(Exception e) {     if (e instanceof ConnectTransportException || e instanceof AlreadyClosedException) {         // can't connect to the node - this is more common path!         logger.trace(() -> new ParameterizedMessage("[{}] failed to ping {}", pingingRound.id(), node), e).     } else if (e instanceof RemoteTransportException) {         // something went wrong on the other side         logger.debug(() -> new ParameterizedMessage("[{}] received a remote error as a response to ping {}", pingingRound.id(), node), e).     } else {         logger.warn(() -> new ParameterizedMessage("[{}] failed send ping to {}", pingingRound.id(), node), e).     } }
false;public;1;6;;@Override public void onRejection(Exception e) {     // The RejectedExecutionException can come from the fact unicastZenPingExecutorService is at its max down in sendPings     // But don't bail here, we can retry later on after the send ping has been scheduled.     logger.debug("Ping execution rejected", e). }
false;private;4;47;;private void sendPingRequestToNode(final DiscoveryNode node, TimeValue timeout, final PingingRound pingingRound, final UnicastPingRequest pingRequest) {     submitToExecutor(new AbstractRunnable() {          @Override         protected void doRun() throws Exception {             Connection connection = null.             if (transportService.nodeConnected(node)) {                 try {                     // concurrency can still cause disconnects                     connection = transportService.getConnection(node).                 } catch (NodeNotConnectedException e) {                     logger.trace("[{}] node [{}] just disconnected, will create a temp connection", pingingRound.id(), node).                 }             }             if (connection == null) {                 connection = pingingRound.getOrConnect(node).             }             logger.trace("[{}] sending to {}", pingingRound.id(), node).             transportService.sendRequest(connection, ACTION_NAME, pingRequest, TransportRequestOptions.builder().withTimeout((long) (timeout.millis() * 1.25)).build(), getPingResponseHandler(pingingRound, node)).         }          @Override         public void onFailure(Exception e) {             if (e instanceof ConnectTransportException || e instanceof AlreadyClosedException) {                 // can't connect to the node - this is more common path!                 logger.trace(() -> new ParameterizedMessage("[{}] failed to ping {}", pingingRound.id(), node), e).             } else if (e instanceof RemoteTransportException) {                 // something went wrong on the other side                 logger.debug(() -> new ParameterizedMessage("[{}] received a remote error as a response to ping {}", pingingRound.id(), node), e).             } else {                 logger.warn(() -> new ParameterizedMessage("[{}] failed send ping to {}", pingingRound.id(), node), e).             }         }          @Override         public void onRejection(Exception e) {             // The RejectedExecutionException can come from the fact unicastZenPingExecutorService is at its max down in sendPings             // But don't bail here, we can retry later on after the send ping has been scheduled.             logger.debug("Ping execution rejected", e).         }     }). }
true;protected;1;3;// for testing ;// for testing protected void submitToExecutor(AbstractRunnable abstractRunnable) {     unicastZenPingExecutorService.execute(abstractRunnable). }
false;public;1;4;;@Override public UnicastPingResponse read(StreamInput in) throws IOException {     return new UnicastPingResponse(in). }
false;public;0;4;;@Override public String executor() {     return ThreadPool.Names.SAME. }
false;public;1;11;;@Override public void handleResponse(UnicastPingResponse response) {     logger.trace("[{}] received response from {}: {}", pingingRound.id(), node, Arrays.toString(response.pingResponses)).     if (pingingRound.isClosed()) {         if (logger.isTraceEnabled()) {             logger.trace("[{}] skipping received response from {}. already closed", pingingRound.id(), node).         }     } else {         Stream.of(response.pingResponses).forEach(pingingRound::addPingResponseToCollection).     } }
false;public;1;10;;@Override public void handleException(TransportException exp) {     if (exp instanceof ConnectTransportException || exp.getCause() instanceof ConnectTransportException || exp.getCause() instanceof AlreadyClosedException) {         // ok, not connected...         logger.trace(() -> new ParameterizedMessage("failed to connect to {}", node), exp).     } else if (closed == false) {         logger.warn(() -> new ParameterizedMessage("failed to send ping to [{}]", node), exp).     } }
true;protected;2;38;// for testing ;// for testing protected TransportResponseHandler<UnicastPingResponse> getPingResponseHandler(final PingingRound pingingRound, final DiscoveryNode node) {     return new TransportResponseHandler<UnicastPingResponse>() {          @Override         public UnicastPingResponse read(StreamInput in) throws IOException {             return new UnicastPingResponse(in).         }          @Override         public String executor() {             return ThreadPool.Names.SAME.         }          @Override         public void handleResponse(UnicastPingResponse response) {             logger.trace("[{}] received response from {}: {}", pingingRound.id(), node, Arrays.toString(response.pingResponses)).             if (pingingRound.isClosed()) {                 if (logger.isTraceEnabled()) {                     logger.trace("[{}] skipping received response from {}. already closed", pingingRound.id(), node).                 }             } else {                 Stream.of(response.pingResponses).forEach(pingingRound::addPingResponseToCollection).             }         }          @Override         public void handleException(TransportException exp) {             if (exp instanceof ConnectTransportException || exp.getCause() instanceof ConnectTransportException || exp.getCause() instanceof AlreadyClosedException) {                 // ok, not connected...                 logger.trace(() -> new ParameterizedMessage("failed to connect to {}", node), exp).             } else if (closed == false) {                 logger.warn(() -> new ParameterizedMessage("failed to send ping to [{}]", node), exp).             }         }     }. }
false;private;1;14;;private UnicastPingResponse handlePingRequest(final UnicastPingRequest request) {     assert clusterName.equals(request.pingResponse.clusterName()) : "got a ping request from a different cluster. expected " + clusterName + " got " + request.pingResponse.clusterName().     temporalResponses.add(request.pingResponse).     // add to any ongoing pinging     activePingingRounds.values().forEach(p -> p.addPingResponseToCollection(request.pingResponse)).     threadPool.schedule(() -> temporalResponses.remove(request.pingResponse), TimeValue.timeValueMillis(request.timeout.millis() * 2), ThreadPool.Names.SAME).     List<PingResponse> pingResponses = CollectionUtils.iterableAsArrayList(temporalResponses).     pingResponses.add(createPingResponse(contextProvider.clusterState())).     return new UnicastPingResponse(request.id, pingResponses.toArray(new PingResponse[pingResponses.size()])). }
false;public;3;16;;@Override public void messageReceived(UnicastPingRequest request, TransportChannel channel, Task task) throws Exception {     if (closed) {         throw new AlreadyClosedException("node is shutting down").     }     if (request.pingResponse.clusterName().equals(clusterName)) {         channel.sendResponse(handlePingRequest(request)).     } else {         throw new IllegalStateException(String.format(Locale.ROOT, "mismatched cluster names. request: [%s], local: [%s]", request.pingResponse.clusterName().value(), clusterName.value())).     } }
false;public;1;4;;@Override public void readFrom(StreamInput in) throws IOException {     throw new UnsupportedOperationException("usage of Streamable is to be replaced by Writeable"). }
false;public;1;7;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeInt(id).     out.writeTimeValue(timeout).     pingResponse.writeTo(out). }
false;private;1;4;;private PingResponse createPingResponse(ClusterState clusterState) {     DiscoveryNodes discoNodes = clusterState.nodes().     return new PingResponse(discoNodes.getLocalNode(), discoNodes.getMasterNode(), clusterState). }
false;public;1;4;;@Override public void readFrom(StreamInput in) throws IOException {     throw new UnsupportedOperationException("usage of Streamable is to be replaced by Writeable"). }
false;public;1;9;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeInt(id).     out.writeVInt(pingResponses.length).     for (PingResponse pingResponse : pingResponses) {         pingResponse.writeTo(out).     } }
false;protected;0;3;;protected Version getVersion() {     // for tests     return Version.CURRENT. }
false;public,static;1;11;;public static int getMaxConcurrentResolvers(Settings settings) {     if (LEGACY_DISCOVERY_ZEN_PING_UNICAST_CONCURRENT_CONNECTS_SETTING.exists(settings)) {         if (DISCOVERY_SEED_RESOLVER_MAX_CONCURRENT_RESOLVERS_SETTING.exists(settings)) {             throw new IllegalArgumentException("it is forbidden to set both [" + DISCOVERY_SEED_RESOLVER_MAX_CONCURRENT_RESOLVERS_SETTING.getKey() + "] and [" + LEGACY_DISCOVERY_ZEN_PING_UNICAST_CONCURRENT_CONNECTS_SETTING.getKey() + "]").         }         return LEGACY_DISCOVERY_ZEN_PING_UNICAST_CONCURRENT_CONNECTS_SETTING.get(settings).     }     return DISCOVERY_SEED_RESOLVER_MAX_CONCURRENT_RESOLVERS_SETTING.get(settings). }
false;public,static;1;11;;public static TimeValue getResolveTimeout(Settings settings) {     if (LEGACY_DISCOVERY_ZEN_PING_UNICAST_HOSTS_RESOLVE_TIMEOUT.exists(settings)) {         if (DISCOVERY_SEED_RESOLVER_TIMEOUT_SETTING.exists(settings)) {             throw new IllegalArgumentException("it is forbidden to set both [" + DISCOVERY_SEED_RESOLVER_TIMEOUT_SETTING.getKey() + "] and [" + LEGACY_DISCOVERY_ZEN_PING_UNICAST_HOSTS_RESOLVE_TIMEOUT.getKey() + "]").         }         return LEGACY_DISCOVERY_ZEN_PING_UNICAST_HOSTS_RESOLVE_TIMEOUT.get(settings).     }     return DISCOVERY_SEED_RESOLVER_TIMEOUT_SETTING.get(settings). }
