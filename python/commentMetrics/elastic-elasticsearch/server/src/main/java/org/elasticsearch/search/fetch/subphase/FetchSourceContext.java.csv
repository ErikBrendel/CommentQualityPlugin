commented;modifiers;parameterAmount;loc;comment;code
false;public;1;6;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeBoolean(fetchSource).     out.writeStringArray(includes).     out.writeStringArray(excludes). }
false;public;0;3;;public boolean fetchSource() {     return this.fetchSource. }
false;public;0;3;;public String[] includes() {     return this.includes. }
false;public;0;3;;public String[] excludes() {     return this.excludes. }
false;public,static;1;31;;public static FetchSourceContext parseFromRestRequest(RestRequest request) {     Boolean fetchSource = null.     String[] sourceExcludes = null.     String[] sourceIncludes = null.     String source = request.param("_source").     if (source != null) {         if (Booleans.isTrue(source)) {             fetchSource = true.         } else if (Booleans.isFalse(source)) {             fetchSource = false.         } else {             sourceIncludes = Strings.splitStringByCommaToArray(source).         }     }     String sIncludes = request.param("_source_includes").     if (sIncludes != null) {         sourceIncludes = Strings.splitStringByCommaToArray(sIncludes).     }     String sExcludes = request.param("_source_excludes").     if (sExcludes != null) {         sourceExcludes = Strings.splitStringByCommaToArray(sExcludes).     }     if (fetchSource != null || sourceIncludes != null || sourceExcludes != null) {         return new FetchSourceContext(fetchSource == null ? true : fetchSource, sourceIncludes, sourceExcludes).     }     return null. }
false;public,static;1;67;;public static FetchSourceContext fromXContent(XContentParser parser) throws IOException {     XContentParser.Token token = parser.currentToken().     boolean fetchSource = true.     String[] includes = Strings.EMPTY_ARRAY.     String[] excludes = Strings.EMPTY_ARRAY.     if (token == XContentParser.Token.VALUE_BOOLEAN) {         fetchSource = parser.booleanValue().     } else if (token == XContentParser.Token.VALUE_STRING) {         includes = new String[] { parser.text() }.     } else if (token == XContentParser.Token.START_ARRAY) {         ArrayList<String> list = new ArrayList<>().         while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {             list.add(parser.text()).         }         includes = list.toArray(new String[list.size()]).     } else if (token == XContentParser.Token.START_OBJECT) {         String currentFieldName = null.         while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {             if (token == XContentParser.Token.FIELD_NAME) {                 currentFieldName = parser.currentName().             } else if (token == XContentParser.Token.START_ARRAY) {                 if (INCLUDES_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                     List<String> includesList = new ArrayList<>().                     while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {                         if (token == XContentParser.Token.VALUE_STRING) {                             includesList.add(parser.text()).                         } else {                             throw new ParsingException(parser.getTokenLocation(), "Unknown key for a " + token + " in [" + currentFieldName + "].", parser.getTokenLocation()).                         }                     }                     includes = includesList.toArray(new String[includesList.size()]).                 } else if (EXCLUDES_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                     List<String> excludesList = new ArrayList<>().                     while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {                         if (token == XContentParser.Token.VALUE_STRING) {                             excludesList.add(parser.text()).                         } else {                             throw new ParsingException(parser.getTokenLocation(), "Unknown key for a " + token + " in [" + currentFieldName + "].", parser.getTokenLocation()).                         }                     }                     excludes = excludesList.toArray(new String[excludesList.size()]).                 } else {                     throw new ParsingException(parser.getTokenLocation(), "Unknown key for a " + token + " in [" + currentFieldName + "].", parser.getTokenLocation()).                 }             } else if (token == XContentParser.Token.VALUE_STRING) {                 if (INCLUDES_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                     includes = new String[] { parser.text() }.                 } else if (EXCLUDES_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                     excludes = new String[] { parser.text() }.                 } else {                     throw new ParsingException(parser.getTokenLocation(), "Unknown key for a " + token + " in [" + currentFieldName + "].", parser.getTokenLocation()).                 }             } else {                 throw new ParsingException(parser.getTokenLocation(), "Unknown key for a " + token + " in [" + currentFieldName + "].", parser.getTokenLocation()).             }         }     } else {         throw new ParsingException(parser.getTokenLocation(), "Expected one of [" + XContentParser.Token.VALUE_BOOLEAN + ", " + XContentParser.Token.START_OBJECT + "] but found [" + token + "]", parser.getTokenLocation()).     }     return new FetchSourceContext(fetchSource, includes, excludes). }
false;public;2;12;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     if (fetchSource) {         builder.startObject().         builder.array(INCLUDES_FIELD.getPreferredName(), includes).         builder.array(EXCLUDES_FIELD.getPreferredName(), excludes).         builder.endObject().     } else {         builder.value(false).     }     return builder. }
false;public;1;13;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     FetchSourceContext that = (FetchSourceContext) o.     if (fetchSource != that.fetchSource)         return false.     if (!Arrays.equals(excludes, that.excludes))         return false.     if (!Arrays.equals(includes, that.includes))         return false.     return true. }
false;public;0;7;;@Override public int hashCode() {     int result = (fetchSource ? 1 : 0).     result = 31 * result + (includes != null ? Arrays.hashCode(includes) : 0).     result = 31 * result + (excludes != null ? Arrays.hashCode(excludes) : 0).     return result. }
true;public;0;6;/**  * Returns a filter function that expects the source map as an input and returns  * the filtered map.  */ ;/**  * Returns a filter function that expects the source map as an input and returns  * the filtered map.  */ public Function<Map<String, ?>, Map<String, Object>> getFilter() {     if (filter == null) {         filter = XContentMapValues.filter(includes, excludes).     }     return filter. }
