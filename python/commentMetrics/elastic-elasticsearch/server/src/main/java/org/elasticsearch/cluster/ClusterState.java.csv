# id;timestamp;commentText;codeText;commentWords;codeWords
ClusterState -> public String stateUUID();1524684173;This stateUUID is automatically generated for for each version of cluster state. It is used to make sure that_we are applying diffs to the right previous state.;public String stateUUID() {_        return this.stateUUID__    };this,state,uuid,is,automatically,generated,for,for,each,version,of,cluster,state,it,is,used,to,make,sure,that,we,are,applying,diffs,to,the,right,previous,state;public,string,state,uuid,return,this,state,uuid
ClusterState -> public String stateUUID();1525162917;This stateUUID is automatically generated for for each version of cluster state. It is used to make sure that_we are applying diffs to the right previous state.;public String stateUUID() {_        return this.stateUUID__    };this,state,uuid,is,automatically,generated,for,for,each,version,of,cluster,state,it,is,used,to,make,sure,that,we,are,applying,diffs,to,the,right,previous,state;public,string,state,uuid,return,this,state,uuid
ClusterState -> public String stateUUID();1527878678;This stateUUID is automatically generated for for each version of cluster state. It is used to make sure that_we are applying diffs to the right previous state.;public String stateUUID() {_        return this.stateUUID__    };this,state,uuid,is,automatically,generated,for,for,each,version,of,cluster,state,it,is,used,to,make,sure,that,we,are,applying,diffs,to,the,right,previous,state;public,string,state,uuid,return,this,state,uuid
ClusterState -> public String stateUUID();1528103657;This stateUUID is automatically generated for for each version of cluster state. It is used to make sure that_we are applying diffs to the right previous state.;public String stateUUID() {_        return this.stateUUID__    };this,state,uuid,is,automatically,generated,for,for,each,version,of,cluster,state,it,is,used,to,make,sure,that,we,are,applying,diffs,to,the,right,previous,state;public,string,state,uuid,return,this,state,uuid
ClusterState -> public String stateUUID();1535405719;This stateUUID is automatically generated for for each version of cluster state. It is used to make sure that_we are applying diffs to the right previous state.;public String stateUUID() {_        return this.stateUUID__    };this,state,uuid,is,automatically,generated,for,for,each,version,of,cluster,state,it,is,used,to,make,sure,that,we,are,applying,diffs,to,the,right,previous,state;public,string,state,uuid,return,this,state,uuid
ClusterState -> public String stateUUID();1539723533;This stateUUID is automatically generated for for each version of cluster state. It is used to make sure that_we are applying diffs to the right previous state.;public String stateUUID() {_        return this.stateUUID__    };this,state,uuid,is,automatically,generated,for,for,each,version,of,cluster,state,it,is,used,to,make,sure,that,we,are,applying,diffs,to,the,right,previous,state;public,string,state,uuid,return,this,state,uuid
ClusterState -> public String stateUUID();1544081506;This stateUUID is automatically generated for for each version of cluster state. It is used to make sure that_we are applying diffs to the right previous state.;public String stateUUID() {_        return this.stateUUID__    };this,state,uuid,is,automatically,generated,for,for,each,version,of,cluster,state,it,is,used,to,make,sure,that,we,are,applying,diffs,to,the,right,previous,state;public,string,state,uuid,return,this,state,uuid
ClusterState -> public String stateUUID();1546592956;This stateUUID is automatically generated for for each version of cluster state. It is used to make sure that_we are applying diffs to the right previous state.;public String stateUUID() {_        return this.stateUUID__    };this,state,uuid,is,automatically,generated,for,for,each,version,of,cluster,state,it,is,used,to,make,sure,that,we,are,applying,diffs,to,the,right,previous,state;public,string,state,uuid,return,this,state,uuid
ClusterState -> public String stateUUID();1548320260;This stateUUID is automatically generated for for each version of cluster state. It is used to make sure that_we are applying diffs to the right previous state.;public String stateUUID() {_        return this.stateUUID__    };this,state,uuid,is,automatically,generated,for,for,each,version,of,cluster,state,it,is,used,to,make,sure,that,we,are,applying,diffs,to,the,right,previous,state;public,string,state,uuid,return,this,state,uuid
ClusterState -> public String stateUUID();1548349549;This stateUUID is automatically generated for for each version of cluster state. It is used to make sure that_we are applying diffs to the right previous state.;public String stateUUID() {_        return this.stateUUID__    };this,state,uuid,is,automatically,generated,for,for,each,version,of,cluster,state,it,is,used,to,make,sure,that,we,are,applying,diffs,to,the,right,previous,state;public,string,state,uuid,return,this,state,uuid
ClusterState -> public boolean supersedes(ClusterState other);1524684173;a cluster state supersedes another state if they are from the same master and the version of this state is higher than that of the_other state._<p>_In essence that means that all the changes from the other cluster state are also reflected by the current one;public boolean supersedes(ClusterState other) {_        return this.nodes().getMasterNodeId() != null && this.nodes().getMasterNodeId().equals(other.nodes().getMasterNodeId())_            && this.version() > other.version()___    };a,cluster,state,supersedes,another,state,if,they,are,from,the,same,master,and,the,version,of,this,state,is,higher,than,that,of,the,other,state,p,in,essence,that,means,that,all,the,changes,from,the,other,cluster,state,are,also,reflected,by,the,current,one;public,boolean,supersedes,cluster,state,other,return,this,nodes,get,master,node,id,null,this,nodes,get,master,node,id,equals,other,nodes,get,master,node,id,this,version,other,version
ClusterState -> public boolean supersedes(ClusterState other);1525162917;a cluster state supersedes another state if they are from the same master and the version of this state is higher than that of the_other state._<p>_In essence that means that all the changes from the other cluster state are also reflected by the current one;public boolean supersedes(ClusterState other) {_        return this.nodes().getMasterNodeId() != null && this.nodes().getMasterNodeId().equals(other.nodes().getMasterNodeId())_            && this.version() > other.version()___    };a,cluster,state,supersedes,another,state,if,they,are,from,the,same,master,and,the,version,of,this,state,is,higher,than,that,of,the,other,state,p,in,essence,that,means,that,all,the,changes,from,the,other,cluster,state,are,also,reflected,by,the,current,one;public,boolean,supersedes,cluster,state,other,return,this,nodes,get,master,node,id,null,this,nodes,get,master,node,id,equals,other,nodes,get,master,node,id,this,version,other,version
ClusterState -> public boolean supersedes(ClusterState other);1527878678;a cluster state supersedes another state if they are from the same master and the version of this state is higher than that of the_other state._<p>_In essence that means that all the changes from the other cluster state are also reflected by the current one;public boolean supersedes(ClusterState other) {_        return this.nodes().getMasterNodeId() != null && this.nodes().getMasterNodeId().equals(other.nodes().getMasterNodeId())_            && this.version() > other.version()___    };a,cluster,state,supersedes,another,state,if,they,are,from,the,same,master,and,the,version,of,this,state,is,higher,than,that,of,the,other,state,p,in,essence,that,means,that,all,the,changes,from,the,other,cluster,state,are,also,reflected,by,the,current,one;public,boolean,supersedes,cluster,state,other,return,this,nodes,get,master,node,id,null,this,nodes,get,master,node,id,equals,other,nodes,get,master,node,id,this,version,other,version
ClusterState -> public boolean supersedes(ClusterState other);1528103657;a cluster state supersedes another state if they are from the same master and the version of this state is higher than that of the_other state._<p>_In essence that means that all the changes from the other cluster state are also reflected by the current one;public boolean supersedes(ClusterState other) {_        return this.nodes().getMasterNodeId() != null && this.nodes().getMasterNodeId().equals(other.nodes().getMasterNodeId())_            && this.version() > other.version()___    };a,cluster,state,supersedes,another,state,if,they,are,from,the,same,master,and,the,version,of,this,state,is,higher,than,that,of,the,other,state,p,in,essence,that,means,that,all,the,changes,from,the,other,cluster,state,are,also,reflected,by,the,current,one;public,boolean,supersedes,cluster,state,other,return,this,nodes,get,master,node,id,null,this,nodes,get,master,node,id,equals,other,nodes,get,master,node,id,this,version,other,version
ClusterState -> public boolean supersedes(ClusterState other);1535405719;a cluster state supersedes another state if they are from the same master and the version of this state is higher than that of the_other state._<p>_In essence that means that all the changes from the other cluster state are also reflected by the current one;public boolean supersedes(ClusterState other) {_        return this.nodes().getMasterNodeId() != null && this.nodes().getMasterNodeId().equals(other.nodes().getMasterNodeId())_            && this.version() > other.version()___    };a,cluster,state,supersedes,another,state,if,they,are,from,the,same,master,and,the,version,of,this,state,is,higher,than,that,of,the,other,state,p,in,essence,that,means,that,all,the,changes,from,the,other,cluster,state,are,also,reflected,by,the,current,one;public,boolean,supersedes,cluster,state,other,return,this,nodes,get,master,node,id,null,this,nodes,get,master,node,id,equals,other,nodes,get,master,node,id,this,version,other,version
ClusterState -> public boolean supersedes(ClusterState other);1539723533;a cluster state supersedes another state if they are from the same master and the version of this state is higher than that of the_other state._<p>_In essence that means that all the changes from the other cluster state are also reflected by the current one;public boolean supersedes(ClusterState other) {_        return this.nodes().getMasterNodeId() != null && this.nodes().getMasterNodeId().equals(other.nodes().getMasterNodeId())_            && this.version() > other.version()___    };a,cluster,state,supersedes,another,state,if,they,are,from,the,same,master,and,the,version,of,this,state,is,higher,than,that,of,the,other,state,p,in,essence,that,means,that,all,the,changes,from,the,other,cluster,state,are,also,reflected,by,the,current,one;public,boolean,supersedes,cluster,state,other,return,this,nodes,get,master,node,id,null,this,nodes,get,master,node,id,equals,other,nodes,get,master,node,id,this,version,other,version
ClusterState -> public boolean supersedes(ClusterState other);1544081506;a cluster state supersedes another state if they are from the same master and the version of this state is higher than that of the_other state._<p>_In essence that means that all the changes from the other cluster state are also reflected by the current one;public boolean supersedes(ClusterState other) {_        return this.nodes().getMasterNodeId() != null && this.nodes().getMasterNodeId().equals(other.nodes().getMasterNodeId())_            && this.version() > other.version()___    };a,cluster,state,supersedes,another,state,if,they,are,from,the,same,master,and,the,version,of,this,state,is,higher,than,that,of,the,other,state,p,in,essence,that,means,that,all,the,changes,from,the,other,cluster,state,are,also,reflected,by,the,current,one;public,boolean,supersedes,cluster,state,other,return,this,nodes,get,master,node,id,null,this,nodes,get,master,node,id,equals,other,nodes,get,master,node,id,this,version,other,version
ClusterState -> public boolean supersedes(ClusterState other);1546592956;a cluster state supersedes another state if they are from the same master and the version of this state is higher than that of the_other state._<p>_In essence that means that all the changes from the other cluster state are also reflected by the current one;public boolean supersedes(ClusterState other) {_        return this.nodes().getMasterNodeId() != null && this.nodes().getMasterNodeId().equals(other.nodes().getMasterNodeId())_            && this.version() > other.version()___    };a,cluster,state,supersedes,another,state,if,they,are,from,the,same,master,and,the,version,of,this,state,is,higher,than,that,of,the,other,state,p,in,essence,that,means,that,all,the,changes,from,the,other,cluster,state,are,also,reflected,by,the,current,one;public,boolean,supersedes,cluster,state,other,return,this,nodes,get,master,node,id,null,this,nodes,get,master,node,id,equals,other,nodes,get,master,node,id,this,version,other,version
ClusterState -> public boolean supersedes(ClusterState other);1548320260;a cluster state supersedes another state if they are from the same master and the version of this state is higher than that of the_other state._<p>_In essence that means that all the changes from the other cluster state are also reflected by the current one;public boolean supersedes(ClusterState other) {_        return this.nodes().getMasterNodeId() != null && this.nodes().getMasterNodeId().equals(other.nodes().getMasterNodeId())_            && this.version() > other.version()___    };a,cluster,state,supersedes,another,state,if,they,are,from,the,same,master,and,the,version,of,this,state,is,higher,than,that,of,the,other,state,p,in,essence,that,means,that,all,the,changes,from,the,other,cluster,state,are,also,reflected,by,the,current,one;public,boolean,supersedes,cluster,state,other,return,this,nodes,get,master,node,id,null,this,nodes,get,master,node,id,equals,other,nodes,get,master,node,id,this,version,other,version
ClusterState -> public boolean supersedes(ClusterState other);1548349549;a cluster state supersedes another state if they are from the same master and the version of this state is higher than that of the_other state._<p>_In essence that means that all the changes from the other cluster state are also reflected by the current one;public boolean supersedes(ClusterState other) {_        return this.nodes().getMasterNodeId() != null && this.nodes().getMasterNodeId().equals(other.nodes().getMasterNodeId())_            && this.version() > other.version()___    };a,cluster,state,supersedes,another,state,if,they,are,from,the,same,master,and,the,version,of,this,state,is,higher,than,that,of,the,other,state,p,in,essence,that,means,that,all,the,changes,from,the,other,cluster,state,are,also,reflected,by,the,current,one;public,boolean,supersedes,cluster,state,other,return,this,nodes,get,master,node,id,null,this,nodes,get,master,node,id,equals,other,nodes,get,master,node,id,this,version,other,version
ClusterState -> FeatureAware -> static <T extends VersionedNamedWriteable & FeatureAware> boolean shouldSerialize(final StreamOutput out, final T custom);1528103657;Tests whether or not the custom should be serialized. The criteria are:_<ul>_<li>the output stream must be at least the minimum supported version of the custom</li>_<li>the output stream must have the feature required by the custom (if any) or not be a transport client</li>_</ul>_<p>_That is, we only serialize customs to clients than can understand the custom based on the version of the client and the features_that the client has. For transport clients we can be lenient in requiring a feature in which case we do not send the custom but_for connected nodes we always require that the node has the required feature.__@param out    the output stream_@param custom the custom to serialize_@param <T>    the type of the custom_@return true if the custom should be serialized and false otherwise;static <T extends VersionedNamedWriteable & FeatureAware> boolean shouldSerialize(final StreamOutput out, final T custom) {_            if (out.getVersion().before(custom.getMinimalSupportedVersion())) {_                return false__            }_            if (custom.getRequiredFeature().isPresent()) {_                final String requiredFeature = custom.getRequiredFeature().get()__                _                return out.hasFeature(requiredFeature) || out.hasFeature(TransportClient.TRANSPORT_CLIENT_FEATURE) == false__            }_            return true__        };tests,whether,or,not,the,custom,should,be,serialized,the,criteria,are,ul,li,the,output,stream,must,be,at,least,the,minimum,supported,version,of,the,custom,li,li,the,output,stream,must,have,the,feature,required,by,the,custom,if,any,or,not,be,a,transport,client,li,ul,p,that,is,we,only,serialize,customs,to,clients,than,can,understand,the,custom,based,on,the,version,of,the,client,and,the,features,that,the,client,has,for,transport,clients,we,can,be,lenient,in,requiring,a,feature,in,which,case,we,do,not,send,the,custom,but,for,connected,nodes,we,always,require,that,the,node,has,the,required,feature,param,out,the,output,stream,param,custom,the,custom,to,serialize,param,t,the,type,of,the,custom,return,true,if,the,custom,should,be,serialized,and,false,otherwise;static,t,extends,versioned,named,writeable,feature,aware,boolean,should,serialize,final,stream,output,out,final,t,custom,if,out,get,version,before,custom,get,minimal,supported,version,return,false,if,custom,get,required,feature,is,present,final,string,required,feature,custom,get,required,feature,get,return,out,has,feature,required,feature,out,has,feature,transport,client,false,return,true
ClusterState -> FeatureAware -> static <T extends VersionedNamedWriteable & FeatureAware> boolean shouldSerialize(final StreamOutput out, final T custom);1535405719;Tests whether or not the custom should be serialized. The criteria are:_<ul>_<li>the output stream must be at least the minimum supported version of the custom</li>_<li>the output stream must have the feature required by the custom (if any) or not be a transport client</li>_</ul>_<p>_That is, we only serialize customs to clients than can understand the custom based on the version of the client and the features_that the client has. For transport clients we can be lenient in requiring a feature in which case we do not send the custom but_for connected nodes we always require that the node has the required feature.__@param out    the output stream_@param custom the custom to serialize_@param <T>    the type of the custom_@return true if the custom should be serialized and false otherwise;static <T extends VersionedNamedWriteable & FeatureAware> boolean shouldSerialize(final StreamOutput out, final T custom) {_            if (out.getVersion().before(custom.getMinimalSupportedVersion())) {_                return false__            }_            if (custom.getRequiredFeature().isPresent()) {_                final String requiredFeature = custom.getRequiredFeature().get()__                _                return out.hasFeature(requiredFeature) || out.hasFeature(TransportClient.TRANSPORT_CLIENT_FEATURE) == false__            }_            return true__        };tests,whether,or,not,the,custom,should,be,serialized,the,criteria,are,ul,li,the,output,stream,must,be,at,least,the,minimum,supported,version,of,the,custom,li,li,the,output,stream,must,have,the,feature,required,by,the,custom,if,any,or,not,be,a,transport,client,li,ul,p,that,is,we,only,serialize,customs,to,clients,than,can,understand,the,custom,based,on,the,version,of,the,client,and,the,features,that,the,client,has,for,transport,clients,we,can,be,lenient,in,requiring,a,feature,in,which,case,we,do,not,send,the,custom,but,for,connected,nodes,we,always,require,that,the,node,has,the,required,feature,param,out,the,output,stream,param,custom,the,custom,to,serialize,param,t,the,type,of,the,custom,return,true,if,the,custom,should,be,serialized,and,false,otherwise;static,t,extends,versioned,named,writeable,feature,aware,boolean,should,serialize,final,stream,output,out,final,t,custom,if,out,get,version,before,custom,get,minimal,supported,version,return,false,if,custom,get,required,feature,is,present,final,string,required,feature,custom,get,required,feature,get,return,out,has,feature,required,feature,out,has,feature,transport,client,false,return,true
ClusterState -> FeatureAware -> static <T extends VersionedNamedWriteable & FeatureAware> boolean shouldSerialize(final StreamOutput out, final T custom);1539723533;Tests whether or not the custom should be serialized. The criteria are:_<ul>_<li>the output stream must be at least the minimum supported version of the custom</li>_<li>the output stream must have the feature required by the custom (if any) or not be a transport client</li>_</ul>_<p>_That is, we only serialize customs to clients than can understand the custom based on the version of the client and the features_that the client has. For transport clients we can be lenient in requiring a feature in which case we do not send the custom but_for connected nodes we always require that the node has the required feature.__@param out    the output stream_@param custom the custom to serialize_@param <T>    the type of the custom_@return true if the custom should be serialized and false otherwise;static <T extends VersionedNamedWriteable & FeatureAware> boolean shouldSerialize(final StreamOutput out, final T custom) {_            if (out.getVersion().before(custom.getMinimalSupportedVersion())) {_                return false__            }_            if (custom.getRequiredFeature().isPresent()) {_                final String requiredFeature = custom.getRequiredFeature().get()__                _                return out.hasFeature(requiredFeature) || out.hasFeature(TransportClient.TRANSPORT_CLIENT_FEATURE) == false__            }_            return true__        };tests,whether,or,not,the,custom,should,be,serialized,the,criteria,are,ul,li,the,output,stream,must,be,at,least,the,minimum,supported,version,of,the,custom,li,li,the,output,stream,must,have,the,feature,required,by,the,custom,if,any,or,not,be,a,transport,client,li,ul,p,that,is,we,only,serialize,customs,to,clients,than,can,understand,the,custom,based,on,the,version,of,the,client,and,the,features,that,the,client,has,for,transport,clients,we,can,be,lenient,in,requiring,a,feature,in,which,case,we,do,not,send,the,custom,but,for,connected,nodes,we,always,require,that,the,node,has,the,required,feature,param,out,the,output,stream,param,custom,the,custom,to,serialize,param,t,the,type,of,the,custom,return,true,if,the,custom,should,be,serialized,and,false,otherwise;static,t,extends,versioned,named,writeable,feature,aware,boolean,should,serialize,final,stream,output,out,final,t,custom,if,out,get,version,before,custom,get,minimal,supported,version,return,false,if,custom,get,required,feature,is,present,final,string,required,feature,custom,get,required,feature,get,return,out,has,feature,required,feature,out,has,feature,transport,client,false,return,true
ClusterState -> FeatureAware -> static <T extends VersionedNamedWriteable & FeatureAware> boolean shouldSerialize(final StreamOutput out, final T custom);1544081506;Tests whether or not the custom should be serialized. The criteria are:_<ul>_<li>the output stream must be at least the minimum supported version of the custom</li>_<li>the output stream must have the feature required by the custom (if any) or not be a transport client</li>_</ul>_<p>_That is, we only serialize customs to clients than can understand the custom based on the version of the client and the features_that the client has. For transport clients we can be lenient in requiring a feature in which case we do not send the custom but_for connected nodes we always require that the node has the required feature.__@param out    the output stream_@param custom the custom to serialize_@param <T>    the type of the custom_@return true if the custom should be serialized and false otherwise;static <T extends VersionedNamedWriteable & FeatureAware> boolean shouldSerialize(final StreamOutput out, final T custom) {_            if (out.getVersion().before(custom.getMinimalSupportedVersion())) {_                return false__            }_            if (custom.getRequiredFeature().isPresent()) {_                final String requiredFeature = custom.getRequiredFeature().get()__                _                return out.hasFeature(requiredFeature) || out.hasFeature(TransportClient.TRANSPORT_CLIENT_FEATURE) == false__            }_            return true__        };tests,whether,or,not,the,custom,should,be,serialized,the,criteria,are,ul,li,the,output,stream,must,be,at,least,the,minimum,supported,version,of,the,custom,li,li,the,output,stream,must,have,the,feature,required,by,the,custom,if,any,or,not,be,a,transport,client,li,ul,p,that,is,we,only,serialize,customs,to,clients,than,can,understand,the,custom,based,on,the,version,of,the,client,and,the,features,that,the,client,has,for,transport,clients,we,can,be,lenient,in,requiring,a,feature,in,which,case,we,do,not,send,the,custom,but,for,connected,nodes,we,always,require,that,the,node,has,the,required,feature,param,out,the,output,stream,param,custom,the,custom,to,serialize,param,t,the,type,of,the,custom,return,true,if,the,custom,should,be,serialized,and,false,otherwise;static,t,extends,versioned,named,writeable,feature,aware,boolean,should,serialize,final,stream,output,out,final,t,custom,if,out,get,version,before,custom,get,minimal,supported,version,return,false,if,custom,get,required,feature,is,present,final,string,required,feature,custom,get,required,feature,get,return,out,has,feature,required,feature,out,has,feature,transport,client,false,return,true
ClusterState -> FeatureAware -> static <T extends VersionedNamedWriteable & FeatureAware> boolean shouldSerialize(final StreamOutput out, final T custom);1546592956;Tests whether or not the custom should be serialized. The criteria are:_<ul>_<li>the output stream must be at least the minimum supported version of the custom</li>_<li>the output stream must have the feature required by the custom (if any) or not be a transport client</li>_</ul>_<p>_That is, we only serialize customs to clients than can understand the custom based on the version of the client and the features_that the client has. For transport clients we can be lenient in requiring a feature in which case we do not send the custom but_for connected nodes we always require that the node has the required feature.__@param out    the output stream_@param custom the custom to serialize_@param <T>    the type of the custom_@return true if the custom should be serialized and false otherwise;static <T extends VersionedNamedWriteable & FeatureAware> boolean shouldSerialize(final StreamOutput out, final T custom) {_            if (out.getVersion().before(custom.getMinimalSupportedVersion())) {_                return false__            }_            if (custom.getRequiredFeature().isPresent()) {_                final String requiredFeature = custom.getRequiredFeature().get()__                _                return out.hasFeature(requiredFeature) || out.hasFeature(TransportClient.TRANSPORT_CLIENT_FEATURE) == false__            }_            return true__        };tests,whether,or,not,the,custom,should,be,serialized,the,criteria,are,ul,li,the,output,stream,must,be,at,least,the,minimum,supported,version,of,the,custom,li,li,the,output,stream,must,have,the,feature,required,by,the,custom,if,any,or,not,be,a,transport,client,li,ul,p,that,is,we,only,serialize,customs,to,clients,than,can,understand,the,custom,based,on,the,version,of,the,client,and,the,features,that,the,client,has,for,transport,clients,we,can,be,lenient,in,requiring,a,feature,in,which,case,we,do,not,send,the,custom,but,for,connected,nodes,we,always,require,that,the,node,has,the,required,feature,param,out,the,output,stream,param,custom,the,custom,to,serialize,param,t,the,type,of,the,custom,return,true,if,the,custom,should,be,serialized,and,false,otherwise;static,t,extends,versioned,named,writeable,feature,aware,boolean,should,serialize,final,stream,output,out,final,t,custom,if,out,get,version,before,custom,get,minimal,supported,version,return,false,if,custom,get,required,feature,is,present,final,string,required,feature,custom,get,required,feature,get,return,out,has,feature,required,feature,out,has,feature,transport,client,false,return,true
ClusterState -> FeatureAware -> static <T extends VersionedNamedWriteable & FeatureAware> boolean shouldSerialize(final StreamOutput out, final T custom);1548320260;Tests whether or not the custom should be serialized. The criteria are:_<ul>_<li>the output stream must be at least the minimum supported version of the custom</li>_<li>the output stream must have the feature required by the custom (if any) or not be a transport client</li>_</ul>_<p>_That is, we only serialize customs to clients than can understand the custom based on the version of the client and the features_that the client has. For transport clients we can be lenient in requiring a feature in which case we do not send the custom but_for connected nodes we always require that the node has the required feature.__@param out    the output stream_@param custom the custom to serialize_@param <T>    the type of the custom_@return true if the custom should be serialized and false otherwise;static <T extends VersionedNamedWriteable & FeatureAware> boolean shouldSerialize(final StreamOutput out, final T custom) {_            if (out.getVersion().before(custom.getMinimalSupportedVersion())) {_                return false__            }_            if (custom.getRequiredFeature().isPresent()) {_                final String requiredFeature = custom.getRequiredFeature().get()__                _                return out.hasFeature(requiredFeature) || out.hasFeature(TransportClient.TRANSPORT_CLIENT_FEATURE) == false__            }_            return true__        };tests,whether,or,not,the,custom,should,be,serialized,the,criteria,are,ul,li,the,output,stream,must,be,at,least,the,minimum,supported,version,of,the,custom,li,li,the,output,stream,must,have,the,feature,required,by,the,custom,if,any,or,not,be,a,transport,client,li,ul,p,that,is,we,only,serialize,customs,to,clients,than,can,understand,the,custom,based,on,the,version,of,the,client,and,the,features,that,the,client,has,for,transport,clients,we,can,be,lenient,in,requiring,a,feature,in,which,case,we,do,not,send,the,custom,but,for,connected,nodes,we,always,require,that,the,node,has,the,required,feature,param,out,the,output,stream,param,custom,the,custom,to,serialize,param,t,the,type,of,the,custom,return,true,if,the,custom,should,be,serialized,and,false,otherwise;static,t,extends,versioned,named,writeable,feature,aware,boolean,should,serialize,final,stream,output,out,final,t,custom,if,out,get,version,before,custom,get,minimal,supported,version,return,false,if,custom,get,required,feature,is,present,final,string,required,feature,custom,get,required,feature,get,return,out,has,feature,required,feature,out,has,feature,transport,client,false,return,true
ClusterState -> FeatureAware -> static <T extends VersionedNamedWriteable & FeatureAware> boolean shouldSerialize(final StreamOutput out, final T custom);1548349549;Tests whether or not the custom should be serialized. The criteria are:_<ul>_<li>the output stream must be at least the minimum supported version of the custom</li>_<li>the output stream must have the feature required by the custom (if any) or not be a transport client</li>_</ul>_<p>_That is, we only serialize customs to clients than can understand the custom based on the version of the client and the features_that the client has. For transport clients we can be lenient in requiring a feature in which case we do not send the custom but_for connected nodes we always require that the node has the required feature.__@param out    the output stream_@param custom the custom to serialize_@param <T>    the type of the custom_@return true if the custom should be serialized and false otherwise;static <T extends VersionedNamedWriteable & FeatureAware> boolean shouldSerialize(final StreamOutput out, final T custom) {_            if (out.getVersion().before(custom.getMinimalSupportedVersion())) {_                return false__            }_            if (custom.getRequiredFeature().isPresent()) {_                final String requiredFeature = custom.getRequiredFeature().get()__                _                return out.hasFeature(requiredFeature) || out.hasFeature(TransportClient.TRANSPORT_CLIENT_FEATURE) == false__            }_            return true__        };tests,whether,or,not,the,custom,should,be,serialized,the,criteria,are,ul,li,the,output,stream,must,be,at,least,the,minimum,supported,version,of,the,custom,li,li,the,output,stream,must,have,the,feature,required,by,the,custom,if,any,or,not,be,a,transport,client,li,ul,p,that,is,we,only,serialize,customs,to,clients,than,can,understand,the,custom,based,on,the,version,of,the,client,and,the,features,that,the,client,has,for,transport,clients,we,can,be,lenient,in,requiring,a,feature,in,which,case,we,do,not,send,the,custom,but,for,connected,nodes,we,always,require,that,the,node,has,the,required,feature,param,out,the,output,stream,param,custom,the,custom,to,serialize,param,t,the,type,of,the,custom,return,true,if,the,custom,should,be,serialized,and,false,otherwise;static,t,extends,versioned,named,writeable,feature,aware,boolean,should,serialize,final,stream,output,out,final,t,custom,if,out,get,version,before,custom,get,minimal,supported,version,return,false,if,custom,get,required,feature,is,present,final,string,required,feature,custom,get,required,feature,get,return,out,has,feature,required,feature,out,has,feature,transport,client,false,return,true
ClusterState -> Builder -> public static ClusterState fromBytes(byte[] data, DiscoveryNode localNode, NamedWriteableRegistry registry) throws IOException;1524684173;@param data      input bytes_@param localNode used to set the local node in the cluster state.;public static ClusterState fromBytes(byte[] data, DiscoveryNode localNode, NamedWriteableRegistry registry) throws IOException {_            StreamInput in = new NamedWriteableAwareStreamInput(StreamInput.wrap(data), registry)__            return readFrom(in, localNode)___        };param,data,input,bytes,param,local,node,used,to,set,the,local,node,in,the,cluster,state;public,static,cluster,state,from,bytes,byte,data,discovery,node,local,node,named,writeable,registry,registry,throws,ioexception,stream,input,in,new,named,writeable,aware,stream,input,stream,input,wrap,data,registry,return,read,from,in,local,node
ClusterState -> Builder -> public static ClusterState fromBytes(byte[] data, DiscoveryNode localNode, NamedWriteableRegistry registry) throws IOException;1525162917;@param data      input bytes_@param localNode used to set the local node in the cluster state.;public static ClusterState fromBytes(byte[] data, DiscoveryNode localNode, NamedWriteableRegistry registry) throws IOException {_            StreamInput in = new NamedWriteableAwareStreamInput(StreamInput.wrap(data), registry)__            return readFrom(in, localNode)___        };param,data,input,bytes,param,local,node,used,to,set,the,local,node,in,the,cluster,state;public,static,cluster,state,from,bytes,byte,data,discovery,node,local,node,named,writeable,registry,registry,throws,ioexception,stream,input,in,new,named,writeable,aware,stream,input,stream,input,wrap,data,registry,return,read,from,in,local,node
ClusterState -> Builder -> public static ClusterState fromBytes(byte[] data, DiscoveryNode localNode, NamedWriteableRegistry registry) throws IOException;1527878678;@param data      input bytes_@param localNode used to set the local node in the cluster state.;public static ClusterState fromBytes(byte[] data, DiscoveryNode localNode, NamedWriteableRegistry registry) throws IOException {_            StreamInput in = new NamedWriteableAwareStreamInput(StreamInput.wrap(data), registry)__            return readFrom(in, localNode)___        };param,data,input,bytes,param,local,node,used,to,set,the,local,node,in,the,cluster,state;public,static,cluster,state,from,bytes,byte,data,discovery,node,local,node,named,writeable,registry,registry,throws,ioexception,stream,input,in,new,named,writeable,aware,stream,input,stream,input,wrap,data,registry,return,read,from,in,local,node
ClusterState -> Builder -> public static ClusterState fromBytes(byte[] data, DiscoveryNode localNode, NamedWriteableRegistry registry) throws IOException;1528103657;@param data      input bytes_@param localNode used to set the local node in the cluster state.;public static ClusterState fromBytes(byte[] data, DiscoveryNode localNode, NamedWriteableRegistry registry) throws IOException {_            StreamInput in = new NamedWriteableAwareStreamInput(StreamInput.wrap(data), registry)__            return readFrom(in, localNode)___        };param,data,input,bytes,param,local,node,used,to,set,the,local,node,in,the,cluster,state;public,static,cluster,state,from,bytes,byte,data,discovery,node,local,node,named,writeable,registry,registry,throws,ioexception,stream,input,in,new,named,writeable,aware,stream,input,stream,input,wrap,data,registry,return,read,from,in,local,node
ClusterState -> Builder -> public static ClusterState fromBytes(byte[] data, DiscoveryNode localNode, NamedWriteableRegistry registry) throws IOException;1535405719;@param data      input bytes_@param localNode used to set the local node in the cluster state.;public static ClusterState fromBytes(byte[] data, DiscoveryNode localNode, NamedWriteableRegistry registry) throws IOException {_            StreamInput in = new NamedWriteableAwareStreamInput(StreamInput.wrap(data), registry)__            return readFrom(in, localNode)___        };param,data,input,bytes,param,local,node,used,to,set,the,local,node,in,the,cluster,state;public,static,cluster,state,from,bytes,byte,data,discovery,node,local,node,named,writeable,registry,registry,throws,ioexception,stream,input,in,new,named,writeable,aware,stream,input,stream,input,wrap,data,registry,return,read,from,in,local,node
ClusterState -> Builder -> public static ClusterState fromBytes(byte[] data, DiscoveryNode localNode, NamedWriteableRegistry registry) throws IOException;1539723533;@param data      input bytes_@param localNode used to set the local node in the cluster state.;public static ClusterState fromBytes(byte[] data, DiscoveryNode localNode, NamedWriteableRegistry registry) throws IOException {_            StreamInput in = new NamedWriteableAwareStreamInput(StreamInput.wrap(data), registry)__            return readFrom(in, localNode)___        };param,data,input,bytes,param,local,node,used,to,set,the,local,node,in,the,cluster,state;public,static,cluster,state,from,bytes,byte,data,discovery,node,local,node,named,writeable,registry,registry,throws,ioexception,stream,input,in,new,named,writeable,aware,stream,input,stream,input,wrap,data,registry,return,read,from,in,local,node
ClusterState -> Builder -> public static ClusterState fromBytes(byte[] data, DiscoveryNode localNode, NamedWriteableRegistry registry) throws IOException;1544081506;@param data      input bytes_@param localNode used to set the local node in the cluster state.;public static ClusterState fromBytes(byte[] data, DiscoveryNode localNode, NamedWriteableRegistry registry) throws IOException {_            StreamInput in = new NamedWriteableAwareStreamInput(StreamInput.wrap(data), registry)__            return readFrom(in, localNode)___        };param,data,input,bytes,param,local,node,used,to,set,the,local,node,in,the,cluster,state;public,static,cluster,state,from,bytes,byte,data,discovery,node,local,node,named,writeable,registry,registry,throws,ioexception,stream,input,in,new,named,writeable,aware,stream,input,stream,input,wrap,data,registry,return,read,from,in,local,node
ClusterState -> Builder -> public static ClusterState fromBytes(byte[] data, DiscoveryNode localNode, NamedWriteableRegistry registry) throws IOException;1546592956;@param data      input bytes_@param localNode used to set the local node in the cluster state.;public static ClusterState fromBytes(byte[] data, DiscoveryNode localNode, NamedWriteableRegistry registry) throws IOException {_            StreamInput in = new NamedWriteableAwareStreamInput(StreamInput.wrap(data), registry)__            return readFrom(in, localNode)___        };param,data,input,bytes,param,local,node,used,to,set,the,local,node,in,the,cluster,state;public,static,cluster,state,from,bytes,byte,data,discovery,node,local,node,named,writeable,registry,registry,throws,ioexception,stream,input,in,new,named,writeable,aware,stream,input,stream,input,wrap,data,registry,return,read,from,in,local,node
ClusterState -> Builder -> public static ClusterState fromBytes(byte[] data, DiscoveryNode localNode, NamedWriteableRegistry registry) throws IOException;1548320260;@param data      input bytes_@param localNode used to set the local node in the cluster state.;public static ClusterState fromBytes(byte[] data, DiscoveryNode localNode, NamedWriteableRegistry registry) throws IOException {_            StreamInput in = new NamedWriteableAwareStreamInput(StreamInput.wrap(data), registry)__            return readFrom(in, localNode)___        };param,data,input,bytes,param,local,node,used,to,set,the,local,node,in,the,cluster,state;public,static,cluster,state,from,bytes,byte,data,discovery,node,local,node,named,writeable,registry,registry,throws,ioexception,stream,input,in,new,named,writeable,aware,stream,input,stream,input,wrap,data,registry,return,read,from,in,local,node
ClusterState -> Builder -> public static ClusterState fromBytes(byte[] data, DiscoveryNode localNode, NamedWriteableRegistry registry) throws IOException;1548349549;@param data      input bytes_@param localNode used to set the local node in the cluster state.;public static ClusterState fromBytes(byte[] data, DiscoveryNode localNode, NamedWriteableRegistry registry) throws IOException {_            StreamInput in = new NamedWriteableAwareStreamInput(StreamInput.wrap(data), registry)__            return readFrom(in, localNode)___        };param,data,input,bytes,param,local,node,used,to,set,the,local,node,in,the,cluster,state;public,static,cluster,state,from,bytes,byte,data,discovery,node,local,node,named,writeable,registry,registry,throws,ioexception,stream,input,in,new,named,writeable,aware,stream,input,stream,input,wrap,data,registry,return,read,from,in,local,node
ClusterState -> Custom -> default boolean isPrivate();1524684173;Returns <code>true</code> iff this {@link Custom} is private to the cluster and should never be send to a client._The default is <code>false</code>_;default boolean isPrivate() {_            return false__        };returns,code,true,code,iff,this,link,custom,is,private,to,the,cluster,and,should,never,be,send,to,a,client,the,default,is,code,false,code;default,boolean,is,private,return,false
ClusterState -> Custom -> default boolean isPrivate();1525162917;Returns <code>true</code> iff this {@link Custom} is private to the cluster and should never be send to a client._The default is <code>false</code>_;default boolean isPrivate() {_            return false__        };returns,code,true,code,iff,this,link,custom,is,private,to,the,cluster,and,should,never,be,send,to,a,client,the,default,is,code,false,code;default,boolean,is,private,return,false
ClusterState -> Custom -> default boolean isPrivate();1527878678;Returns <code>true</code> iff this {@link Custom} is private to the cluster and should never be send to a client._The default is <code>false</code>_;default boolean isPrivate() {_            return false__        };returns,code,true,code,iff,this,link,custom,is,private,to,the,cluster,and,should,never,be,send,to,a,client,the,default,is,code,false,code;default,boolean,is,private,return,false
ClusterState -> Custom -> default boolean isPrivate();1528103657;Returns <code>true</code> iff this {@link Custom} is private to the cluster and should never be send to a client._The default is <code>false</code>_;default boolean isPrivate() {_            return false__        };returns,code,true,code,iff,this,link,custom,is,private,to,the,cluster,and,should,never,be,send,to,a,client,the,default,is,code,false,code;default,boolean,is,private,return,false
ClusterState -> Custom -> default boolean isPrivate();1535405719;Returns <code>true</code> iff this {@link Custom} is private to the cluster and should never be send to a client._The default is <code>false</code>_;default boolean isPrivate() {_            return false__        };returns,code,true,code,iff,this,link,custom,is,private,to,the,cluster,and,should,never,be,send,to,a,client,the,default,is,code,false,code;default,boolean,is,private,return,false
ClusterState -> Custom -> default boolean isPrivate();1539723533;Returns <code>true</code> iff this {@link Custom} is private to the cluster and should never be send to a client._The default is <code>false</code>_;default boolean isPrivate() {_            return false__        };returns,code,true,code,iff,this,link,custom,is,private,to,the,cluster,and,should,never,be,send,to,a,client,the,default,is,code,false,code;default,boolean,is,private,return,false
ClusterState -> Custom -> default boolean isPrivate();1544081506;Returns <code>true</code> iff this {@link Custom} is private to the cluster and should never be send to a client._The default is <code>false</code>_;default boolean isPrivate() {_            return false__        };returns,code,true,code,iff,this,link,custom,is,private,to,the,cluster,and,should,never,be,send,to,a,client,the,default,is,code,false,code;default,boolean,is,private,return,false
ClusterState -> Custom -> default boolean isPrivate();1546592956;Returns <code>true</code> iff this {@link Custom} is private to the cluster and should never be send to a client._The default is <code>false</code>_;default boolean isPrivate() {_            return false__        };returns,code,true,code,iff,this,link,custom,is,private,to,the,cluster,and,should,never,be,send,to,a,client,the,default,is,code,false,code;default,boolean,is,private,return,false
ClusterState -> Custom -> default boolean isPrivate();1548320260;Returns <code>true</code> iff this {@link Custom} is private to the cluster and should never be send to a client._The default is <code>false</code>_;default boolean isPrivate() {_            return false__        };returns,code,true,code,iff,this,link,custom,is,private,to,the,cluster,and,should,never,be,send,to,a,client,the,default,is,code,false,code;default,boolean,is,private,return,false
ClusterState -> Custom -> default boolean isPrivate();1548349549;Returns <code>true</code> iff this {@link Custom} is private to the cluster and should never be send to a client._The default is <code>false</code>_;default boolean isPrivate() {_            return false__        };returns,code,true,code,iff,this,link,custom,is,private,to,the,cluster,and,should,never,be,send,to,a,client,the,default,is,code,false,code;default,boolean,is,private,return,false
ClusterState -> FeatureAware -> default Optional<String> getRequiredFeature();1527878678;An optional feature that is required for the client to have.__@return an empty optional if no feature is required otherwise a string representing the required feature;default Optional<String> getRequiredFeature() {_            return Optional.empty()__        };an,optional,feature,that,is,required,for,the,client,to,have,return,an,empty,optional,if,no,feature,is,required,otherwise,a,string,representing,the,required,feature;default,optional,string,get,required,feature,return,optional,empty
ClusterState -> FeatureAware -> default Optional<String> getRequiredFeature();1528103657;An optional feature that is required for the client to have.__@return an empty optional if no feature is required otherwise a string representing the required feature;default Optional<String> getRequiredFeature() {_            return Optional.empty()__        };an,optional,feature,that,is,required,for,the,client,to,have,return,an,empty,optional,if,no,feature,is,required,otherwise,a,string,representing,the,required,feature;default,optional,string,get,required,feature,return,optional,empty
ClusterState -> FeatureAware -> default Optional<String> getRequiredFeature();1535405719;An optional feature that is required for the client to have.__@return an empty optional if no feature is required otherwise a string representing the required feature;default Optional<String> getRequiredFeature() {_            return Optional.empty()__        };an,optional,feature,that,is,required,for,the,client,to,have,return,an,empty,optional,if,no,feature,is,required,otherwise,a,string,representing,the,required,feature;default,optional,string,get,required,feature,return,optional,empty
ClusterState -> FeatureAware -> default Optional<String> getRequiredFeature();1539723533;An optional feature that is required for the client to have.__@return an empty optional if no feature is required otherwise a string representing the required feature;default Optional<String> getRequiredFeature() {_            return Optional.empty()__        };an,optional,feature,that,is,required,for,the,client,to,have,return,an,empty,optional,if,no,feature,is,required,otherwise,a,string,representing,the,required,feature;default,optional,string,get,required,feature,return,optional,empty
ClusterState -> FeatureAware -> default Optional<String> getRequiredFeature();1544081506;An optional feature that is required for the client to have.__@return an empty optional if no feature is required otherwise a string representing the required feature;default Optional<String> getRequiredFeature() {_            return Optional.empty()__        };an,optional,feature,that,is,required,for,the,client,to,have,return,an,empty,optional,if,no,feature,is,required,otherwise,a,string,representing,the,required,feature;default,optional,string,get,required,feature,return,optional,empty
ClusterState -> FeatureAware -> default Optional<String> getRequiredFeature();1546592956;An optional feature that is required for the client to have.__@return an empty optional if no feature is required otherwise a string representing the required feature;default Optional<String> getRequiredFeature() {_            return Optional.empty()__        };an,optional,feature,that,is,required,for,the,client,to,have,return,an,empty,optional,if,no,feature,is,required,otherwise,a,string,representing,the,required,feature;default,optional,string,get,required,feature,return,optional,empty
ClusterState -> FeatureAware -> default Optional<String> getRequiredFeature();1548320260;An optional feature that is required for the client to have.__@return an empty optional if no feature is required otherwise a string representing the required feature;default Optional<String> getRequiredFeature() {_            return Optional.empty()__        };an,optional,feature,that,is,required,for,the,client,to,have,return,an,empty,optional,if,no,feature,is,required,otherwise,a,string,representing,the,required,feature;default,optional,string,get,required,feature,return,optional,empty
ClusterState -> FeatureAware -> default Optional<String> getRequiredFeature();1548349549;An optional feature that is required for the client to have.__@return an empty optional if no feature is required otherwise a string representing the required feature;default Optional<String> getRequiredFeature() {_            return Optional.empty()__        };an,optional,feature,that,is,required,for,the,client,to,have,return,an,empty,optional,if,no,feature,is,required,otherwise,a,string,representing,the,required,feature;default,optional,string,get,required,feature,return,optional,empty
ClusterState -> public RoutingNodes getRoutingNodes();1524684173;Returns a built (on demand) routing nodes view of the routing table.;public RoutingNodes getRoutingNodes() {_        if (routingNodes != null) {_            return routingNodes__        }_        routingNodes = new RoutingNodes(this)__        return routingNodes__    };returns,a,built,on,demand,routing,nodes,view,of,the,routing,table;public,routing,nodes,get,routing,nodes,if,routing,nodes,null,return,routing,nodes,routing,nodes,new,routing,nodes,this,return,routing,nodes
ClusterState -> public RoutingNodes getRoutingNodes();1525162917;Returns a built (on demand) routing nodes view of the routing table.;public RoutingNodes getRoutingNodes() {_        if (routingNodes != null) {_            return routingNodes__        }_        routingNodes = new RoutingNodes(this)__        return routingNodes__    };returns,a,built,on,demand,routing,nodes,view,of,the,routing,table;public,routing,nodes,get,routing,nodes,if,routing,nodes,null,return,routing,nodes,routing,nodes,new,routing,nodes,this,return,routing,nodes
ClusterState -> public RoutingNodes getRoutingNodes();1527878678;Returns a built (on demand) routing nodes view of the routing table.;public RoutingNodes getRoutingNodes() {_        if (routingNodes != null) {_            return routingNodes__        }_        routingNodes = new RoutingNodes(this)__        return routingNodes__    };returns,a,built,on,demand,routing,nodes,view,of,the,routing,table;public,routing,nodes,get,routing,nodes,if,routing,nodes,null,return,routing,nodes,routing,nodes,new,routing,nodes,this,return,routing,nodes
ClusterState -> public RoutingNodes getRoutingNodes();1528103657;Returns a built (on demand) routing nodes view of the routing table.;public RoutingNodes getRoutingNodes() {_        if (routingNodes != null) {_            return routingNodes__        }_        routingNodes = new RoutingNodes(this)__        return routingNodes__    };returns,a,built,on,demand,routing,nodes,view,of,the,routing,table;public,routing,nodes,get,routing,nodes,if,routing,nodes,null,return,routing,nodes,routing,nodes,new,routing,nodes,this,return,routing,nodes
ClusterState -> public RoutingNodes getRoutingNodes();1535405719;Returns a built (on demand) routing nodes view of the routing table.;public RoutingNodes getRoutingNodes() {_        if (routingNodes != null) {_            return routingNodes__        }_        routingNodes = new RoutingNodes(this)__        return routingNodes__    };returns,a,built,on,demand,routing,nodes,view,of,the,routing,table;public,routing,nodes,get,routing,nodes,if,routing,nodes,null,return,routing,nodes,routing,nodes,new,routing,nodes,this,return,routing,nodes
ClusterState -> public RoutingNodes getRoutingNodes();1539723533;Returns a built (on demand) routing nodes view of the routing table.;public RoutingNodes getRoutingNodes() {_        if (routingNodes != null) {_            return routingNodes__        }_        routingNodes = new RoutingNodes(this)__        return routingNodes__    };returns,a,built,on,demand,routing,nodes,view,of,the,routing,table;public,routing,nodes,get,routing,nodes,if,routing,nodes,null,return,routing,nodes,routing,nodes,new,routing,nodes,this,return,routing,nodes
ClusterState -> public RoutingNodes getRoutingNodes();1544081506;Returns a built (on demand) routing nodes view of the routing table.;public RoutingNodes getRoutingNodes() {_        if (routingNodes != null) {_            return routingNodes__        }_        routingNodes = new RoutingNodes(this)__        return routingNodes__    };returns,a,built,on,demand,routing,nodes,view,of,the,routing,table;public,routing,nodes,get,routing,nodes,if,routing,nodes,null,return,routing,nodes,routing,nodes,new,routing,nodes,this,return,routing,nodes
ClusterState -> public RoutingNodes getRoutingNodes();1546592956;Returns a built (on demand) routing nodes view of the routing table.;public RoutingNodes getRoutingNodes() {_        if (routingNodes != null) {_            return routingNodes__        }_        routingNodes = new RoutingNodes(this)__        return routingNodes__    };returns,a,built,on,demand,routing,nodes,view,of,the,routing,table;public,routing,nodes,get,routing,nodes,if,routing,nodes,null,return,routing,nodes,routing,nodes,new,routing,nodes,this,return,routing,nodes
ClusterState -> public RoutingNodes getRoutingNodes();1548320260;Returns a built (on demand) routing nodes view of the routing table.;public RoutingNodes getRoutingNodes() {_        if (routingNodes != null) {_            return routingNodes__        }_        routingNodes = new RoutingNodes(this)__        return routingNodes__    };returns,a,built,on,demand,routing,nodes,view,of,the,routing,table;public,routing,nodes,get,routing,nodes,if,routing,nodes,null,return,routing,nodes,routing,nodes,new,routing,nodes,this,return,routing,nodes
ClusterState -> public RoutingNodes getRoutingNodes();1548349549;Returns a built (on demand) routing nodes view of the routing table.;public RoutingNodes getRoutingNodes() {_        if (routingNodes != null) {_            return routingNodes__        }_        routingNodes = new RoutingNodes(this)__        return routingNodes__    };returns,a,built,on,demand,routing,nodes,view,of,the,routing,table;public,routing,nodes,get,routing,nodes,if,routing,nodes,null,return,routing,nodes,routing,nodes,new,routing,nodes,this,return,routing,nodes
ClusterState -> public int getMinimumMasterNodesOnPublishingMaster();1548320260;The node-level `discovery.zen.minimum_master_nodes` setting on the master node that published this cluster state, for use in rolling_upgrades from 6.x to 7.x. Once all the 6.x master-eligible nodes have left the cluster, the 7.x nodes use this value to determine how_many master-eligible nodes must be discovered before the cluster can be bootstrapped. Note that this method returns the node-level_value of this setting, and ignores any cluster-level override that was set via the API. Callers are expected to combine this value_with any value set in the cluster-level settings. This should be removed once we no longer need support for {@link Version#V_6_7_0}.;public int getMinimumMasterNodesOnPublishingMaster() {_        return minimumMasterNodesOnPublishingMaster__    };the,node,level,discovery,zen,setting,on,the,master,node,that,published,this,cluster,state,for,use,in,rolling,upgrades,from,6,x,to,7,x,once,all,the,6,x,master,eligible,nodes,have,left,the,cluster,the,7,x,nodes,use,this,value,to,determine,how,many,master,eligible,nodes,must,be,discovered,before,the,cluster,can,be,bootstrapped,note,that,this,method,returns,the,node,level,value,of,this,setting,and,ignores,any,cluster,level,override,that,was,set,via,the,api,callers,are,expected,to,combine,this,value,with,any,value,set,in,the,cluster,level,settings,this,should,be,removed,once,we,no,longer,need,support,for,link,version;public,int,get,minimum,master,nodes,on,publishing,master,return,minimum,master,nodes,on,publishing,master
ClusterState -> public int getMinimumMasterNodesOnPublishingMaster();1548349549;The node-level `discovery.zen.minimum_master_nodes` setting on the master node that published this cluster state, for use in rolling_upgrades from 6.x to 7.x. Once all the 6.x master-eligible nodes have left the cluster, the 7.x nodes use this value to determine how_many master-eligible nodes must be discovered before the cluster can be bootstrapped. Note that this method returns the node-level_value of this setting, and ignores any cluster-level override that was set via the API. Callers are expected to combine this value_with any value set in the cluster-level settings. This should be removed once we no longer need support for {@link Version#V_6_7_0}.;public int getMinimumMasterNodesOnPublishingMaster() {_        return minimumMasterNodesOnPublishingMaster__    };the,node,level,discovery,zen,setting,on,the,master,node,that,published,this,cluster,state,for,use,in,rolling,upgrades,from,6,x,to,7,x,once,all,the,6,x,master,eligible,nodes,have,left,the,cluster,the,7,x,nodes,use,this,value,to,determine,how,many,master,eligible,nodes,must,be,discovered,before,the,cluster,can,be,bootstrapped,note,that,this,method,returns,the,node,level,value,of,this,setting,and,ignores,any,cluster,level,override,that,was,set,via,the,api,callers,are,expected,to,combine,this,value,with,any,value,set,in,the,cluster,level,settings,this,should,be,removed,once,we,no,longer,need,support,for,link,version;public,int,get,minimum,master,nodes,on,publishing,master,return,minimum,master,nodes,on,publishing,master
